<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGI::Simple::Standard - a wrapper module for CGI::Simple that provides a function style interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcgi-simple-perl">libcgi-simple-perl_1.281-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CGI::Simple::Standard - a wrapper module for CGI::Simple that provides a function style interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use CGI::Simple::Standard qw( -autoload );
           use CGI::Simple::Standard qw( :core :cookie :header :misc );
           use CGI::Simple::Standard qw( param upload );

           $CGI::Simple::Standard::POST_MAX = 1024;       # max upload via post 1kB
           $CGI::Simple::Standard::DISABLE_UPLOADS = 0;   # enable uploads

           @params = param();        # return all param names as a list
           $value =  param('foo');   # return the first value supplied for 'foo'
           @values = param('foo');   # return all values supplied for foo

           %fields   = Vars();       # returns untied key value pair hash
           $hash_ref = Vars();       # or as a hash ref
           %fields   = Vars("|");    # packs multiple values with "|" rather than "\0";

           @keywords = keywords();   # return all keywords as a list

           param( 'foo', 'some', 'new', 'values' );        # set new 'foo' values
           param( -name=&gt;'foo', -value=&gt;'bar' );
           param( -name=&gt;'foo', -value=&gt;['bar','baz'] );

           append( -name=&gt;'foo', -value=&gt;'bar' );          # append values to 'foo'
           append( -name=&gt;'foo', -value=&gt;['some', 'new', 'values'] );

           Delete('foo');   # delete param 'foo' and all its values
           Delete_all();    # delete everything

           &lt;INPUT TYPE="file" NAME="upload_file" SIZE="42"&gt;

           $files    = upload()                   # number of files uploaded
           @files    = upload();                  # names of all uploaded files
           $filename = param('upload_file')       # filename of 'upload_file' field
           $mime     = upload_info($filename,'mime'); # MIME type of uploaded file
           $size     = upload_info($filename,'size'); # size of uploaded file

           my $fh = $q-&gt;upload($filename);     # open filehandle to read from
           while ( read( $fh, $buffer, 1024 ) ) { ... }

           # short and sweet upload
           $ok = upload( param('upload_file'), '/path/to/write/file.name' );
           print "Uploaded ".param('upload_file')." and wrote it OK!" if $ok;

           $decoded    = url_decode($encoded);
           $encoded    = url_encode($unencoded);
           $escaped    = escapeHTML('&lt;&gt;"&amp;');
           $unescaped  = unescapeHTML('&amp;lt;&amp;gt;&amp;quot;&amp;amp;');

           $qs = query_string();   # get all data in $q as a query string OK for GET

           <a href="../man1/no_cache.1.html">no_cache</a>(1);            # set Pragma: no-cache + expires
           print header();         # print a simple header
           # get a complex header
           $header = header(   -type       =&gt; 'image/gif'
                               -nph        =&gt; 1,
                               -status     =&gt; '402 Payment required',
                               -expires    =&gt;'+24h',
                               -cookie     =&gt; $cookie,
                               -charset    =&gt; 'utf-7',
                               -attachment =&gt; 'foo.gif',
                               -Cost       =&gt; '$2.00');

           @cookies = cookie();        # get names of all available cookies
           $value   = cookie('foo')    # get first value of cookie 'foo'
           @value   = cookie('foo')    # get all values of cookie 'foo'
           # get a cookie formatted for header() method
           $cookie  = cookie(  -name    =&gt; 'Password',
                               -values  =&gt; ['superuser','god','my dog woofie'],
                               -expires =&gt; '+3d',
                               -domain  =&gt; '.nowhere.com',
                               -path    =&gt; '/cgi-bin/database',
                               -secure  =&gt; 1 );
           print header( -cookie=&gt;$cookie );       # set cookie

           print redirect('<a href="http://go.away.now">http://go.away.now</a>');   # print a redirect header

           dienice( cgi_error() ) if cgi_error();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is a wrapper for the completely object oriented CGI::Simple module and provides a simple
       functional style interface. It provides two different methods to import function names into your
       namespace.

   <b>Autoloading</b>
       If you specify the '-autoload' pragma like this:

           use CGI::Simple::Standard qw( -autoload );

       Then it will use AUTOLOAD and a symbol table trick to export only those subs you actually call into your
       namespace. When you specify the '-autoload' pragma this module exports a single AUTOLOAD subroutine into
       you namespace. This will clash with any AUTOLOAD sub that exists in the calling namespace so if you are
       using AUTOLOAD for something else don't use this pragma.

       Anyway, when you call a subroutine that is not defined in your script this AUTOLOAD sub will be called.
       The first time this happens it will initialize a CGI::Simple object and then apply the requested method
       (if it exists) to it. A fatal exception will be thrown if you try to use an undefined method (function).

   <b>Specified</b> <b>Export</b>
       Alternatively you can specify the functions you wish to import. You can do this on a per function basis
       like this:

           use CGI::Simple::Standard qw( param upload query_string Dump );

       or utilize the %EXPORT_TAGS that group functions into related groups.  Here are the groupings:

         %EXPORT_TAGS = (
           ':html'     =&gt; [ qw(:misc) ],
           ':standard' =&gt; [ qw(:core :access) ],
           ':cgi'      =&gt; [ qw(:core :access) ],
           ':all'      =&gt; [ qw(:core :misc :cookie :header :push :debug :cgi-lib
                               :access :internal) ],
           ':core'     =&gt; [ qw(param add_param param_fetch url_param keywords
                               append Delete delete_all Delete_all upload
                               query_string parse_query_string  parse_keywordlist
                               Vars save_parameters restore_parameters) ],
           ':misc'     =&gt; [ qw(url_decode url_encode escapeHTML unescapeHTML put) ],
           ':cookie'   =&gt; [ qw(cookie raw_cookie) ],
           ':header'   =&gt; [ qw(header cache no_cache redirect) ],
           ':push'     =&gt; [ qw(multipart_init multipart_start multipart_end
                               multipart_final) ],
           ':debug'    =&gt; [ qw(Dump as_string cgi_error _cgi_object) ],
           ':cgi-lib'  =&gt; [ qw(ReadParse SplitParam MethGet MethPost MyBaseUrl MyURL
                               MyFullUrl PrintHeader HtmlTop HtmlBot PrintVariables
                               PrintEnv CgiDie CgiError Vars) ],
           ':ssl'      =&gt; [ qw(https) ],
           ':access'   =&gt; [ qw(version nph all_parameters charset crlf globals
                               auth_type content_length content_type document_root
                               gateway_interface path_translated referer remote_addr
                               remote_host remote_ident remote_user request_method
                               script_name server_name server_port server_protocol
                               server_software user_name user_agent virtual_host
                               path_info Accept http https protocol url self_url
                               state) ],
           ':internal' =&gt; [ qw(_initialize_globals _use_cgi_pm_global_settings
                               _store_globals _reset_globals) ]
           );

       The familiar CGI.pm tags are available but do not include the HTML functionality. You specify the import
       of some function groups like this:

       use CGI::Simple::Standard qw( :core :cookie :header );

       Note that the function groups all start with a : char.

   <b>Mix</b> <b>and</b> <b>Match</b>
       You can use the '-autoload' pragma, specifically named function imports and tag group imports together if
       you desire.

</pre><h4><b>$POST_MAX</b> <b>and</b> <b>$DISABLE_UPLOADS</b></h4><pre>
       If you wish to set $POST_MAX or $DISABLE_UPLOADS you must do this *after* the use statement and *before*
       the first function call as shown in the synopsis.

       Unlike CGI.pm uploads are disabled by default and the maximum acceptable data via post is capped at
       102_400kB rather than infinity. This is specifically to avoid denial of service attacks by default. To
       enable uploads and to allow them to be of infinite size you simply:

           $CGI::Simple::Standard::POST_MAX = -1;         # infinite size upload
           $CGI::Simple::Standard::$DISABLE_UPLOADS = 0;  # enable uploads

       Alternatively you can specify the CGI.pm default values as shown above by specifying the '-default'
       pragma in your use statement.

           use CGI::Simple::Standard qw( -default ..... );

</pre><h4><b>EXPORT</b></h4><pre>
       Nothing by default.

       Under the '-autoload' pragma the AUTOLOAD subroutine is exported into the calling namespace. Additional
       subroutines are only imported into this namespace if you physically call them. They are installed in the
       symbol table the first time you use them to save repeated calls to AUTOLOAD.

       If you specifically request a function or group of functions via an EXPORT_TAG then stubs of these
       functions are exported into the calling namespace. These stub functions will be replaced with the real
       functions only if you actually call them saving wasted compilation effort.

</pre><h4><b>FUNCTION</b> <b>DETAILS</b></h4><pre>
       This is a wrapper module for CGI::Simple. Virtually all the methods available in the OO interface are
       available via the functional interface. Several method names are aliased to prevent namespace conflicts:

           $q-&gt;delete('foo')   =&gt;  Delete('foo')
           $q-&gt;delete_all      =&gt;  Delete_all() or delete_all()
           $q-&gt;save(\*FH)      =&gt;  save_parameters(\*FH)
           $q-&gt;accept()        =&gt;  Accept()

       Although you could use the <b>new()</b> function to genrate new OO CGI::Simple objects the <b>restore_parameters()</b>
       function is a better choice as it operates like new but on the correct underlying CGI::Simple object for
       the functional interface.

       <b>restore_parameters()</b> can be used exactly as you might use <b>new()</b> in that you can supply arguments to it
       such as query strings, hashes and file handles to re-initialize your underlying object.

           $q-&gt;new CGI::Simple()                =&gt; restore_parameters()
           $q-&gt;new CGI::Simple({foo=&gt;'bar'})    =&gt; restore_parameters({foo=&gt;'bar'})
           $q-&gt;new CGI::Simple($query_string)   =&gt; restore_parameters($query_string)
           $q-&gt;new CGI::Simple(\*FH)            =&gt; restore_parameters(\*FH)

       For full details of the available functions see the CGI::Simple docs. Just remove the $q-&gt; part and use
       the method name directly.

</pre><h4><b>BUGS</b></h4><pre>
       As this is 0.01 there are almost bound to be some.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dr James Freeman &lt;<a href="mailto:jfreeman@tassie.net.au">jfreeman@tassie.net.au</a>&gt; This release by Andy Armstrong &lt;<a href="mailto:andy@hexten.net">andy@hexten.net</a>&gt;

       This package is free software and is provided "as is" without express or implied warranty. It may be
       used, redistributed and/or modified under the terms of the Perl Artistic License (see
       <a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>)

       Address bug reports and comments to: <a href="mailto:andy@hexten.net">andy@hexten.net</a>

</pre><h4><b>CREDITS</b></h4><pre>
       The interface and key sections of the CGI::Simple code come from CGI.pm by Lincoln Stein.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CGI::Simple which is the back end for this module, <b>CGI.pm</b> <b>by</b> <b>Lincoln</b> <b>Stein</b>

perl v5.38.2                                       2024-02-04                         <u>CGI::Simple::<a href="../man3pm/Standard.3pm.html">Standard</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>