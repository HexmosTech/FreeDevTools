<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGI::Simple - A Simple totally OO CGI interface that is CGI.pm compliant</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcgi-simple-perl">libcgi-simple-perl_1.281-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CGI::Simple - A Simple totally OO CGI interface that is CGI.pm compliant

</pre><h4><b>VERSION</b></h4><pre>
       This document describes CGI::Simple version 1.281.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use CGI::Simple;
           $CGI::Simple::POST_MAX = 1024;       # max upload via post default 100kB
           $CGI::Simple::DISABLE_UPLOADS = 0;   # enable uploads

           $q = CGI::Simple-&gt;new;
           $q = CGI::Simple-&gt;new( { 'foo'=&gt;'1', 'bar'=&gt;[2,3,4] } );
           $q = CGI::Simple-&gt;new( 'foo=1&amp;bar=2&amp;bar=3&amp;bar=4' );
           $q = CGI::Simple-&gt;new( \*FILEHANDLE );

           $q-&gt;save( \*FILEHANDLE );   # save current object to a file as used by new

           @params = $q-&gt;param;        # return all param names as a list
           $value = $q-&gt;param('foo');  # return the first value supplied for 'foo'
           @values = $q-&gt;param('foo'); # return all values supplied for foo

           %fields   = $q-&gt;Vars;      # returns untied key value pair hash
           $hash_ref = $q-&gt;Vars;      # or as a hash ref
           %fields   = $q-&gt;Vars("|"); # packs multiple values with "|" rather than "\0";

           @keywords = $q-&gt;keywords;  # return all keywords as a list

           $q-&gt;param( 'foo', 'some', 'new', 'values' );      # set new 'foo' values
           $q-&gt;param( -name=&gt;'foo', -value=&gt;'bar' );
           $q-&gt;param( -name=&gt;'foo', -value=&gt;['bar','baz'] );

           $q-&gt;param( 'foo', 'some', 'new', 'values' );      # append values to 'foo'
           $q-&gt;append( -name=&gt;'foo', -value=&gt;'bar' );
           $q-&gt;append( -name=&gt;'foo', -value=&gt;['some', 'new', 'values'] );

           $q-&gt;delete('foo'); # delete param 'foo' and all its values
           $q-&gt;delete_all;    # delete everything

           &lt;INPUT TYPE="file" NAME="upload_file" SIZE="42"&gt;

           $files    = $q-&gt;upload()                # number of files uploaded
           @files    = $q-&gt;upload();               # names of all uploaded files
           $filename = $q-&gt;param('upload_file')    # filename of uploaded file
           $mime     = $q-&gt;upload_info($filename,'mime'); # MIME type of uploaded file
           $size     = $q-&gt;upload_info($filename,'size'); # size of uploaded file

           my $fh = $q-&gt;upload($filename);         # get filehandle to read from
           while ( read( $fh, $buffer, 1024 ) ) { ... }

           # short and sweet upload
           $ok = $q-&gt;upload( $q-&gt;param('upload_file'), '/path/to/write/file.name' );
           print "Uploaded ".$q-&gt;param('upload_file')." and wrote it OK!" if $ok;

           $decoded    = $q-&gt;url_decode($encoded);
           $encoded    = $q-&gt;url_encode($unencoded);
           $escaped    = $q-&gt;escapeHTML('&lt;&gt;"&amp;');
           $unescaped  = $q-&gt;unescapeHTML('&amp;lt;&amp;gt;&amp;quot;&amp;amp;');

           $qs = $q-&gt;query_string; # get all data in $q as a query string OK for GET

           $q-&gt;<a href="../man1/no_cache.1.html">no_cache</a>(1);        # set Pragma: no-cache + expires
           print $q-&gt;header();     # print a simple header
           # get a complex header
           $header = $q-&gt;header(   -type       =&gt; 'image/gif'
                                   -nph        =&gt; 1,
                                   -status     =&gt; '402 Payment required',
                                   -expires    =&gt;'+24h',
                                   -cookie     =&gt; $cookie,
                                   -charset    =&gt; 'utf-7',
                                   -attachment =&gt; 'foo.gif',
                                   -Cost       =&gt; '$2.00'
                               );
           # a p3p header (OK for redirect use as well)
           $header = $q-&gt;header( -p3p =&gt; 'policyref="<a href="http://somesite.com/P3P/PolicyReferences.xml">http://somesite.com/P3P/PolicyReferences.xml</a>' );

           @cookies = $q-&gt;cookie();        # get names of all available cookies
           $value   = $q-&gt;cookie('foo')    # get first value of cookie 'foo'
           @value   = $q-&gt;cookie('foo')    # get all values of cookie 'foo'
           # get a cookie formatted for header() method
           $cookie  = $q-&gt;cookie(  -name    =&gt; 'Password',
                                   -values  =&gt; ['superuser','god','my dog woofie'],
                                   -expires =&gt; '+3d',
                                   -domain  =&gt; '.nowhere.com',
                                   -path    =&gt; '/cgi-bin/database',
                                   -secure  =&gt; 1
                                );
           print $q-&gt;header( -cookie=&gt;$cookie );       # set cookie

           print $q-&gt;redirect('<a href="http://go.away.now">http://go.away.now</a>');   # print a redirect header

           dienice( $q-&gt;cgi_error ) if $q-&gt;cgi_error;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       CGI::Simple provides a relatively lightweight drop in replacement for CGI.pm.  It shares an identical OO
       interface to CGI.pm for parameter parsing, file upload, cookie handling and header generation. This
       module is entirely object oriented, however a complete functional interface is available by using the
       CGI::Simple::Standard module.

       Essentially everything in CGI.pm that relates to the CGI (not HTML) side of things is available. There
       are even a few new methods and additions to old ones! If you are interested in what has gone on under the
       hood see the Compatibility with CGI.pm section at the end.

       In practical testing this module loads and runs about twice as fast as CGI.pm depending on the precise
       task.

</pre><h4><b>CALLING</b> <b>CGI::Simple</b> <b>ROUTINES</b> <b>USING</b> <b>THE</b> <b>OBJECT</b> <b>INTERFACE</b></h4><pre>
       Here is a very brief rundown on how you use the interface. Full details follow.

   <b>First</b> <b>you</b> <b>need</b> <b>to</b> <b>initialize</b> <b>an</b> <b>object</b>
       Before you can call a CGI::Simple method you must create a CGI::Simple object.  You do that by using the
       module and then calling the <b>new()</b> constructor:

           use CGI::Simple;
           my $q = CGI::Simple-&gt;new;

       It is traditional to call your object $q for query or perhaps $cgi.

   <b>Next</b> <b>you</b> <b>call</b> <b>methods</b> <b>on</b> <b>that</b> <b>object</b>
       Once you have your object you can call methods on it using the -&gt; arrow syntax For example to get the
       names of all the parameters passed to your script you would just write:

           @names = $q-&gt;param();

       Many methods are sensitive to the context in which you call them. In the example above the <b>param()</b> method
       returns a list of all the parameter names when called without any arguments.

       When you call <b>param('arg')</b> with a single argument it assumes you want to get the value(s) associated with
       that argument (parameter). If you ask for an array it gives you an array of all the values associated
       with it's argument:

           @values = $q-&gt;param('foo');  # get all the values for 'foo'

       whereas if you ask for a scalar like this:

           $value = $q-&gt;param('foo');   # get only the first value for 'foo'

       then it returns only the first value (if more than one value for 'foo' exists).

       In case you ased for a list it will return all the values preserving the order in which the values of the
       given key were passed in the request.

       Most CGI::Simple routines accept several arguments, sometimes as many as 10 optional ones!  To simplify
       this interface, all routines use a named argument calling style that looks like this:

           print $q-&gt;header( -type=&gt;'image/gif', -expires=&gt;'+3d' );

       Each argument name is preceded by a dash.  Neither case nor order matters in the argument list.  -type,
       -Type, and -TYPE are all acceptable.

       Several routines are commonly called with just one argument.  In the case of these routines you can
       provide the single argument without an argument name.  <b>header()</b> happens to be one of these routines.  In
       this case, the single argument is the document type.

          print $q-&gt;header('text/html');

       Sometimes methods expect a scalar, sometimes a reference to an array, and sometimes a reference to a
       hash.  Often, you can pass any type of argument and the routine will do whatever is most appropriate.
       For example, the <b>param()</b> method can be used to set a CGI parameter to a single or a multi-valued value.
       The two cases are shown below:

          $q-&gt;param(-name=&gt;'veggie',-value=&gt;'tomato');
          $q-&gt;param(-name=&gt;'veggie',-value=&gt;['tomato','tomahto','potato','potahto']);

</pre><h4><b>CALLING</b> <b>CGI::Simple</b> <b>ROUTINES</b> <b>USING</b> <b>THE</b> <b>FUNCTION</b> <b>INTERFACE</b></h4><pre>
       For convenience a functional interface is provided by the CGI::Simple::Standard module. This hides the OO
       details from you and allows you to simply call methods. You may either use AUTOLOADING of methods or
       import specific method sets into you namespace. Here are the first few examples again using the function
       interface.

           use CGI::Simple::Standard qw(-autoload);
           @names  = param();
           @values = param('foo');
           $value  = param('foo');
           print header(-type=&gt;'image/gif',-expires=&gt;'+3d');
           print header('text/html');

       Yes that's it. Not a $q-&gt; in sight. You just use the module and select how/which methods to load. You
       then just call the methods you want exactly as before but without the $q-&gt; notation.

       When (if) you read the following docs and are using the functional interface just pretend the $q-&gt; is not
       there.

   <b>Selecting</b> <b>which</b> <b>methods</b> <b>to</b> <b>load</b>
       When you use the functional interface Perl needs to be able to find the functions you call. The simplest
       way of doing this is to use autoloading as shown above. When you use CGI::Simple::Standard with the
       '-autoload' pragma it exports a single AUTOLOAD sub into you namespace. Every time you call a non
       existent function AUTOLOAD is called and will load the required function and install it in your
       namespace. Thus only the AUTOLOAD sub and those functions you specifically call will be imported.

       Alternatively CGI::Simple::Standard provides a range of function sets you can import or you can just
       select exactly what you want. You do this using the familiar

           use CGI::Simple::Standard qw( :func_set  some_func);

       notation. This will import the ':func_set' function set and the specific function 'some_func'.

   <b>To</b> <b>Autoload</b> <b>or</b> <b>not</b> <b>to</b> <b>Autoload,</b> <b>that</b> <b>is</b> <b>the</b> <b>question.</b>
       If you do not have a AUTOLOAD sub in you script it is generally best to use the '-autoload' option. Under
       autoload you can use any method you want but only import and compile those functions you actually use.

       If you do not use autoload you must specify what functions to import. You can only use functions that you
       have imported. For comvenience functions are grouped into related sets. If you choose to import one or
       more ':func_set' you may have potential namespace collisions so check out the docs to see what gets
       imported. Using the ':all' tag is pretty slack but it is there if you want. Full details of the function
       sets are provided in the CGI::Simple::Standard docs

       If you just want say the param and header methods just load these two.

           use CGI::Simple::Standard qw(param header);

   <b>Setting</b> <b>globals</b> <b>using</b> <b>the</b> <b>functional</b> <b>interface</b>
       Where you see global variables being set using the syntax:

           $CGI::Simple::DEBUG = 1;

       You use exactly the same syntax when using CGI::Simple::Standard.

</pre><h4><b>THE</b> <b>CORE</b> <b>METHODS</b></h4><pre>
   <b>new()</b> <b>Creating</b> <b>a</b> <b>new</b> <b>query</b> <b>object</b>
       The first step in using CGI::Simple is to create a new query object using the <b>new()</b> constructor:

            $q = CGI::Simple-&gt;new;

       This will parse the input (from both POST and GET methods) and store it into an object called $q.

       If you provide a file handle to the <b>new()</b> method, it will read parameters from the file (or STDIN, or
       whatever).

       Historically people were doing this way:

            open FH, "test.in" or die $!;
            $q = CGI::Simple-&gt;new(\*FH);

       but this is the recommended way:

            open $fh, '&lt;', "test.in" or die $!;
            $q = CGI::Simple-&gt;new($fh);

       The file should be a series of newline delimited TAG=VALUE pairs.  Conveniently, this type of file is
       created by the <b>save()</b> method (see below). Multiple records can be saved and restored.  IO::File objects
       work fine.

       If you are using the function-oriented interface provided by CGI::Simple::Standard and want to initialize
       from a file handle, the way to do this is with <b>restore_parameters()</b>.  This will (re)initialize the
       default CGI::Simple object from the indicated file handle.

           restore_parameters($fh);

       In fact for all intents and purposes <b>restore_parameters()</b> is identical to <b>new()</b> Note that
       <b>restore_parameters()</b> does not exist in CGI::Simple itself so you can't use it.

       You can also initialize the query object from an associative array reference:

           $q = CGI::Simple-&gt;new( { 'dinosaur' =&gt; 'barney',
                                   'song'     =&gt; 'I love you',
                                   'friends'  =&gt; [qw/Jessica George Nancy/] }
                               );

       or from a properly formatted, URL-escaped query string:

           $q = CGI::Simple-&gt;new( 'dinosaur=barney&amp;color=purple' );

       or from a previously existing CGI::Simple object (this generates an identical clone including all global
       variable settings, etc that are stored in the object):

           $old_query = CGI::Simple-&gt;new;
           $new_query = CGI::Simple-&gt;new($old_query);

       To create an empty query, initialize it from an empty string or hash:

           $empty_query = CGI::Simple-&gt;new("");


              -or-
           $empty_query = CGI::Simple-&gt;new({});

   <b>keywords()</b> <b>Fetching</b> <b>a</b> <b>list</b> <b>of</b> <b>keywords</b> <b>from</b> <b>a</b> <b>query</b>
           @keywords = $q-&gt;keywords;

       If the script was invoked as the result of an &lt;ISINDEX&gt; search, the parsed keywords can be obtained as an
       array using the <b>keywords()</b> method.

   <b>param()</b> <b>Fetching</b> <b>the</b> <b>names</b> <b>of</b> <b>all</b> <b>parameters</b> <b>passed</b> <b>to</b> <b>your</b> <b>script</b>
           @names = $q-&gt;param;

       If the script was invoked with a parameter list (e.g. "name1=value1&amp;name2=value2&amp;name3=value3"), the
       <b>param()</b> method will return the parameter names as a list.  If the script was invoked as an &lt;ISINDEX&gt;
       script and contains a string without ampersands (e.g. "value1+value2+value3") , there will be a single
       parameter named "keywords" containing the "+"-delimited keywords.

       NOTE: The array of parameter names returned will be in the same order as they were submitted by the
       browser.  Usually this order is the same as the order in which the parameters are defined in the form
       (however, this isn't part of the spec, and so isn't guaranteed).

   <b>param()</b> <b>Fetching</b> <b>the</b> <b>value</b> <b>or</b> <b>values</b> <b>of</b> <b>a</b> <b>simple</b> <b>named</b> <b>parameter</b>
           @values = $q-&gt;param('foo');


                 -or-
           $value = $q-&gt;param('foo');

       Pass the <b>param()</b> method a single argument to fetch the value of the named parameter. If the parameter is
       multi-valued (e.g. from multiple selections in a scrolling list), you can ask to receive an array.
       Otherwise the method will return a single value.

       If a value is not given in the query string, as in the queries "name1=&amp;name2=" or "name1&amp;name2", it will
       be returned by default as an empty string. If you set the global variable:

           $CGI::Simple::NO_UNDEF_PARAMS = 1;

       Then value-less parameters will be ignored, and will not exist in the query object. If you try to access
       them via param you will get an undef return value.

   <b>param()</b> <b>Setting</b> <b>the</b> <b>values</b> <b>of</b> <b>a</b> <b>named</b> <b>parameter</b>
           $q-&gt;param('foo','an','array','of','values');

       This sets the value for the named parameter 'foo' to an array of values.  This is one way to change the
       value of a field.

       <b>param()</b> also recognizes a named parameter style of calling described in more detail later:

           $q-&gt;param(-name=&gt;'foo',-values=&gt;['an','array','of','values']);


                         -or-
           $q-&gt;param(-name=&gt;'foo',-value=&gt;'the value');

   <b>param()</b> <b>Retrieving</b> <b>non-application/x-www-form-urlencoded</b> <b>data</b>
       If POSTed or PUTed data is not of type application/x-www-form-urlencoded or multipart/form-data, then the
       data will not be processed, but instead be returned as-is in a parameter named POSTDATA or PUTDATA.  To
       retrieve it, use code like this:

           my $data = $q-&gt;param( 'POSTDATA' );


                         -or-
           my $data = $q-&gt;param( 'PUTDATA' );

       (If you don't know what the preceding means, don't worry about it.  It only affects people trying to use
       CGI::Simple for REST webservices)

   <b>add_param()</b> <b>Setting</b> <b>the</b> <b>values</b> <b>of</b> <b>a</b> <b>named</b> <b>parameter</b>
       You nay also use the new method <b>add_param</b> to add parameters. This is an alias to the <b>_add_param()</b>
       internal method that actually does all the work.  You can call it like this:

           $q-&gt;add_param('foo', 'new');
           $q-&gt;add_param('foo', [1,2,3,4,5]);
           $q-&gt;add_param( 'foo', 'bar', 'overwrite' );

       The first argument is the parameter, the second the value or an array ref of values and the optional
       third argument sets overwrite mode. If the third argument is absent of false the values will be appended.
       If true the values will overwrite any existing ones

   <b>append()</b> <b>Appending</b> <b>values</b> <b>to</b> <b>a</b> <b>named</b> <b>parameter</b>
          $q-&gt;append(-name=&gt;'foo',-values=&gt;['yet','more','values']);

       This adds a value or list of values to the named parameter.  The values are appended to the end of the
       parameter if it already exists.  Otherwise the parameter is created.  Note that this method only
       recognizes the named argument calling syntax.

   <b>import_names()</b> <b>Importing</b> <b>all</b> <b>parameters</b> <b>into</b> <b>a</b> <b>namespace.</b>
       This method was silly, non OO and has been deleted. You can get all the params as a hash using <b>Vars</b> or
       via all the other accessors.

   <b>delete()</b> <b>Deleting</b> <b>a</b> <b>parameter</b> <b>completely</b>
           $q-&gt;delete('foo');

       This completely clears a parameter. If you are using the function call interface, use <b>Delete()</b> instead to
       avoid conflicts with Perl's built-in delete operator.

       If you are using the function call interface, use <b>Delete()</b> instead to avoid conflicts with Perl's built-
       in delete operator.

   <b>delete_all()</b> <b>Deleting</b> <b>all</b> <b>parameters</b>
           $q-&gt;delete_all();

       This clears the CGI::Simple object completely. For CGI.pm compatibility <b>Delete_all()</b> is provided however
       there is no reason to use this in the function call interface other than symmetry.

       For CGI.pm compatibility <b>Delete_all()</b> is provided as an alias for <b>delete_all</b> however there is no reason
       to use this, even in the function call interface.

   <b>param_fetch()</b> <b>Direct</b> <b>access</b> <b>to</b> <b>the</b> <b>parameter</b> <b>list</b>
       This method is provided for CGI.pm compatibility only. It returns an array ref to the values associated
       with a named param. It is deprecated.

   <b>Vars()</b> <b>Fetching</b> <b>the</b> <b>entire</b> <b>parameter</b> <b>list</b> <b>as</b> <b>a</b> <b>hash</b>
           $params = $q-&gt;Vars;  # as a tied hash ref
           print $params-&gt;{'address'};
           @foo = split "\0", $params-&gt;{'foo'};

           %params = $q-&gt;Vars;  # as a plain hash
           print $params{'address'};
           @foo = split "\0", $params{'foo'};

           %params = $q-&gt;Vars(','); # specifying a different separator than "\0"
           @foo = split ',', $params{'foo'};

       Many people want to fetch the entire parameter list as a hash in which the keys are the names of the CGI
       parameters, and the values are the parameters' values.  The <b>Vars()</b> method does this.

       Called in a scalar context, it returns the parameter list as a tied hash reference. Because this hash ref
       is tied changing a key/value changes the underlying CGI::Simple object.

       Called in a list context, it returns the parameter list as an ordinary hash.  Changing this hash will not
       change the underlying CGI::Simple object

       When using <b>Vars()</b>, the thing you must watch out for are multi-valued CGI parameters.  Because a hash
       cannot distinguish between scalar and list context, multi-valued parameters will be returned as a packed
       string, separated by the "\0" (null) character.  You must split this packed string in order to get at the
       individual values.  This is the convention introduced long ago by Steve Brenner in his cgi-lib.pl module
       for Perl version 4.

       You can change the character used to do the multiple value packing by passing it to <b>Vars()</b> as an argument
       as shown.

   <b>url_param()</b> <b>Access</b> <b>the</b> <b>QUERY_STRING</b> <b>regardless</b> <b>of</b> <b>'GET'</b> <b>or</b> <b>'POST'</b>
       The <b>url_param()</b> method makes the QUERY_STRING data available regardless of whether the REQUEST_METHOD was
       'GET' or 'POST'. You can do anything with <b>url_param</b> that you can do with <b>param()</b>, however the data set is
       completely independent.

       Technically what happens if you use this method is that the QUERY_STRING data is parsed into a new
       CGI::Simple object which is stored within the current object. <b>url_param</b> then just calls <b>param()</b> on this
       new object.

   <b>parse_query_string()</b> <b>Add</b> <b>QUERY_STRING</b> <b>data</b> <b>to</b> <b>'POST'</b> <b>requests</b>
       When the REQUEST_METHOD is 'POST' the default behavior is to ignore name/value pairs or keywords in the
       $ENV{'QUERY_STRING'}. You can override this by calling <b>parse_query_string()</b> which will add the
       QUERY_STRING data to the data already in our CGI::Simple object if the REQUEST_METHOD was 'POST'

           $q = CGI::Simple-&gt;new;
           $q-&gt;parse_query_string;  # add $ENV{'QUERY_STRING'} data to our $q object

       If the REQUEST_METHOD was 'GET' then the QUERY_STRING will already be stored in our object so
       <b>parse_query_string</b> will be ignored.

       This is a new method in CGI::Simple that is not available in CGI.pm

   <b>save()</b> <b>Saving</b> <b>the</b> <b>state</b> <b>of</b> <b>an</b> <b>object</b> <b>to</b> <b>file</b>
           $q-&gt;save(\*FILEHANDLE)

       This will write the current state of the form to the provided filehandle.  You can read it back in by
       providing a filehandle to the <b>new()</b> method.

       The format of the saved file is:

           NAME1=VALUE1
           NAME1=VALUE1'
           NAME2=VALUE2
           NAME3=VALUE3
           =

       Both name and value are URL escaped.  Multi-valued CGI parameters are represented as repeated names.  A
       session record is delimited by a single = symbol.  You can write out multiple records and read them back
       in with several calls to <b>new()</b>.

           open my $fh, '&lt;', "test.in" or die $!;
           $q1 = CGI::Simple-&gt;new($fh);  # get the first record
           $q2 = CGI::Simple-&gt;new($fh);  # get the next record

       Note: If you wish to use this method from the function-oriented (non-OO) interface, the exported name for
       this method is <b>save_parameters()</b>.  Also if you want to initialize from a file handle, the way to do this
       is with <b>restore_parameters()</b>.  This will (re)initialize the default CGI::Simple object from the indicated
       file handle.

           restore_parameters($fh);

</pre><h4><b>FILE</b> <b>UPLOADS</b></h4><pre>
       File uploads are easy with CGI::Simple. You use the <b>upload()</b> method.  Assuming you have the following in
       your HTML:

           &lt;FORM
            METHOD="POST"
            ACTION="<a href="http://somewhere.com/cgi-bin/script.cgi">http://somewhere.com/cgi-bin/script.cgi</a>"
            ENCTYPE="multipart/form-data"&gt;
               &lt;INPUT TYPE="file" NAME="upload_file1" SIZE="42"&gt;
               &lt;INPUT TYPE="file" NAME="upload_file2" SIZE="42"&gt;
           &lt;/FORM&gt;

       Note that the ENCTYPE is "multipart/form-data". You must specify this or the browser will default to
       "application/x-www-form-urlencoded" which will result in no files being uploaded although on the surface
       things will appear OK.

       When the user submits this form any supplied files will be spooled onto disk and saved in temporary
       files. These files will be deleted when your script.cgi exits so if you want to keep them you will need
       to proceed as follows.

   <b>upload()</b> <b>The</b> <b>key</b> <b>file</b> <b>upload</b> <b>method</b>
       The <b>upload()</b> method is quite versatile. If you call <b>upload()</b> without any arguments it will return a list
       of uploaded files in list context and the number of uploaded files in scalar context.

           $number_of_files = $q-&gt;upload;
           @list_of_files   = $q-&gt;upload;

       Having established that you have uploaded files available you can get the browser supplied filename using
       <b>param()</b> like this:

           $filename1 = $q-&gt;param('upload_file1');

       You can then get a filehandle to read from by calling <b>upload()</b> and supplying this filename as an
       argument. Warning: do not modify the value you get from <b>param()</b> in any way - you don't need to untaint
       it.

           $fh = $q-&gt;upload( $filename1 );

       Now to save the file you would just do something like:

           $save_path = '/path/to/write/file.name';
           open my $out, '&gt;', $save_path or die "Oops $!\n";
           binmode $out;
           print $out $buffer while read( $fh, $buffer, 4096 );
           close $out;

       By utilizing a new feature of the upload method this process can be simplified to:

           $ok = $q-&gt;upload( $q-&gt;param('upload_file1'), '/path/to/write/file.name' );
           if ($ok) {
               print "Uploaded and wrote file OK!";
           } else {
               print $q-&gt;cgi_error();
           }

       As you can see upload will accept an optional second argument and will write the file to this file path.
       It will return 1 for success and undef if it fails. If it fails you can get the error from <b>cgi_error</b>

       You can also use just the fieldname as an argument to upload ie:

           $fh = $q-&gt;upload( 'upload_field_name' );

           or

           $ok = $q-&gt;upload( 'upload_field_name', '/path/to/write/file.name' );

       BUT there is a catch. If you have multiple upload fields, all called 'upload_field_name' then you will
       only get the last uploaded file from these fields.

   <b>upload_info()</b> <b>Get</b> <b>the</b> <b>details</b> <b>about</b> <b>uploaded</b> <b>files</b>
       The <b>upload_info()</b> method is a new method. Called without arguments it returns the number of uploaded
       files in scalar context and the names of those files in list context.

           $number_of_upload_files   = $q-&gt;upload_info();
           @filenames_of_all_uploads = $q-&gt;upload_info();

       You can get the MIME type of an uploaded file like this:

           $mime = $q-&gt;upload_info( $filename1, 'mime' );

       If you want to know how big a file is before you copy it you can get that information from <b>uploadInfo</b>
       which will return the file size in bytes.

           $file_size = $q-&gt;upload_info( $filename1, 'size' );

       The size attribute is optional as this is the default value returned.

       Note: The old CGI.pm <b>uploadInfo()</b> method has been deleted.

   <b>$POST_MAX</b> <b>and</b> <b>$DISABLE_UPLOADS</b>
       CGI.pm has a default setting that allows infinite size file uploads by default. In contrast file uploads
       are disabled by default in CGI::Simple to discourage Denial of Service attacks. You must enable them
       before you expect file uploads to work.

       When file uploads are disabled the file name and file size details will still be available from <b>param()</b>
       and <b>upload_info</b> respectively but the upload filehandle returned by <b>upload()</b> will be undefined - not
       surprising as the underlying temp file will not exist either.

       You can enable uploads using the '-upload' pragma. You do this by specifying this in you use statement:

           use CGI::Simple qw(-upload);

       Alternatively you can enable uploads via the $DISABLE_UPLOADS global like this:

           use CGI::Simple;
           $CGI::Simple::DISABLE_UPLOADS = 0;
           $q = CGI::Simple-&gt;new;

       If you wish to set $DISABLE_UPLOADS you must do this *after* the use statement and *before* the new
       constructor call as shown above.

       The maximum acceptable data via post is capped at 102_400kB rather than infinity which is the CGI.pm
       default. This should be ample for most tasks but you can set this to whatever you want using the
       $POST_MAX global.

           use CGI::Simple;
           $CGI::Simple::DISABLE_UPLOADS = 0;      # enable uploads
           $CGI::Simple::POST_MAX = 1_048_576;     # allow 1MB uploads
           $q = CGI::Simple-&gt;new;

       If you set to -1 infinite size uploads will be permitted, which is the CGI.pm default.

           $CGI::Simple::POST_MAX = -1;            # infinite size upload

       Alternatively you can specify all the CGI.pm default values which allow file uploads of infinite size in
       one easy step by specifying the '-default' pragma in your use statement.

           use CGI::Simple qw( -default ..... );

   <b>binmode()</b> <b>and</b> <b>Win32</b>
       If you are using CGI::Simple be sure to call <b>binmode()</b> on any handle that you create to write the
       uploaded file to disk. Calling <b>binmode()</b> will do no harm on other systems anyway.

</pre><h4><b>MISCELANEOUS</b> <b>METHODS</b></h4><pre>
   <b>escapeHTML()</b> <b>Escaping</b> <b>HTML</b> <b>special</b> <b>characters</b>
       In HTML the &lt; &gt; " and &amp; chars have special meaning and need to be escaped to &amp;lt; &amp;gt; &amp;quot; and &amp;amp;
       respectively.

           $escaped = $q-&gt;escapeHTML( $string );

           $escaped = $q-&gt;escapeHTML( $string, 'new_lines_too' );

       If the optional second argument is supplied then newlines will be escaped to.

   <b>unescapeHTML()</b> <b>Unescape</b> <b>HTML</b> <b>special</b> <b>characters</b>
       This performs the reverse of <b>escapeHTML()</b>.

           $unescaped = $q-&gt;unescapeHTML( $HTML_escaped_string );

   <b>url_decode()</b> <b>Decode</b> <b>a</b> <b>URL</b> <b>encoded</b> <b>string</b>
       This method will correctly decode a url encoded string.

           $decoded = $q-&gt;url_decode( $encoded );

   <b>url_encode()</b> <b>URL</b> <b>encode</b> <b>a</b> <b>string</b>
       This method will correctly URL encode a string.

           $encoded = $q-&gt;url_encode( $string );

   <b>parse_keywordlist()</b> <b>Parse</b> <b>a</b> <b>supplied</b> <b>keyword</b> <b>list</b>
           @keywords = $q-&gt;parse_keywordlist( $keyword_list );

       This method returns a list of keywords, correctly URL escaped and split out of the supplied string

   <b>put()</b> <b>Send</b> <b>output</b> <b>to</b> <b>browser</b>
       CGI.pm alias for print. $q-&gt;put('Hello World!') will print the usual

   <b>print()</b> <b>Send</b> <b>output</b> <b>to</b> <b>browser</b>
       CGI.pm alias for print. $q-&gt;print('Hello World!') will print the usual

</pre><h4><b>HTTP</b> <b>COOKIES</b></h4><pre>
       CGI.pm has several methods that support cookies.

       A cookie is a name=value pair much like the named parameters in a CGI query string.  CGI scripts create
       one or more cookies and send them to the browser in the HTTP header.  The browser maintains a list of
       cookies that belong to a particular Web server, and returns them to the CGI script during subsequent
       interactions.

       In addition to the required name=value pair, each cookie has several optional attributes:

       1. an expiration time
           This  is  a  time/date  string  (in  a special GMT format) that indicates when a cookie expires.  The
           cookie will be saved and returned to your script until this expiration date is reached  if  the  user
           exits  the  browser  and  restarts it.  If an expiration date isn't specified, the cookie will remain
           active until the user quits the browser.

       2. a domain
           This is a partial or complete domain name for which the cookie is valid.  The browser will return the
           cookie to any host that matches the partial domain name.  For example, if you specify a  domain  name
           of  ".capricorn.com",  then  the  browser will return the cookie to Web servers running on any of the
           machines "www.capricorn.com", "www2.capricorn.com", "feckless.capricorn.com", etc.  Domain names must
           contain at least two periods to prevent attempts to match on top level domains like  ".edu".   If  no
           domain  is  specified, then the browser will only return the cookie to servers on the host the cookie
           originated from.

       3. a path
           If you provide a cookie path attribute, the browser will check it against your  script's  URL  before
           returning  the  cookie.   For  example,  if  you specify the path "/cgi-bin", then the cookie will be
           returned    to    each    of    the    scripts    "/cgi-bin/tally.pl",    "/cgi-bin/order.pl",    and
           "/cgi-bin/customer_service/complain.pl",  but  not  to  the  script "/cgi-private/site_admin.pl".  By
           default, path is set to "/", which causes the cookie to be sent to any CGI script on your site.

       4. a "secure" flag
           If the "secure" attribute is set, the cookie will only be sent to your script if the CGI  request  is
           occurring on a secure channel, such as SSL.

   <b>cookie()</b> <b>A</b> <b>simple</b> <b>access</b> <b>method</b> <b>to</b> <b>cookies</b>
       The interface to HTTP cookies is the <b>cookie()</b> method:

           $cookie = $q-&gt;cookie( -name      =&gt; 'sessionID',
                                 -value     =&gt; 'xyzzy',
                                 -expires   =&gt; '+1h',
                                 -path      =&gt; '/cgi-bin/database',
                                 -domain    =&gt; '.capricorn.org',
                                 -secure    =&gt; 1
                                );
           print $q-&gt;header(-cookie=&gt;$cookie);

       <b>cookie()</b> creates a new cookie.  Its parameters include:

       <b>-name</b>
           The  name  of  the  cookie (required).  This can be any string at all.  Although browsers limit their
           cookie names to non-whitespace alphanumeric characters, CGI.pm removes this restriction  by  escaping
           and unescaping cookies behind the scenes.

       <b>-value</b>
           The  value  of  the cookie.  This can be any scalar value, array reference, or even associative array
           reference.  For example, you can store an entire associative array into a cookie this way:

               $cookie=$q-&gt;cookie( -name   =&gt; 'family information',
                                   -value  =&gt; \%childrens_ages );

       <b>-path</b>
           The optional partial path for which this cookie will be valid, as described above.

       <b>-domain</b>
           The optional partial domain for which this cookie will be valid, as described above.

       <b>-expires</b>
           The optional expiration date for this cookie.  The format is as  described  in  the  section  on  the
           <b>header()</b> method:

               "+1h"  one hour from now

       <b>-secure</b>
           If set to true, this cookie will only be used within a secure SSL session.

       The  cookie  created  by <b>cookie()</b> must be incorporated into the HTTP header within the string returned by
       the <b>header()</b> method:

           print $q-&gt;header(-cookie=&gt;$my_cookie);

       To create multiple cookies, give <b>header()</b> an array reference:

           $cookie1 = $q-&gt;cookie( -name  =&gt; 'riddle_name',
                                  -value =&gt; "The Sphynx's Question"
                                );
           $cookie2 = $q-&gt;cookie( -name  =&gt; 'answers',
                                  -value =&gt; \%answers
                                );
           print $q-&gt;header( -cookie =&gt; [ $cookie1, $cookie2 ] );

       To retrieve a cookie, request it by name by calling <b>cookie()</b> method without the <b>-value</b> parameter:

           use CGI::Simple;
           $q = CGI::Simple-&gt;new;
           $riddle  = $q-&gt;cookie('riddle_name');
           %answers = $q-&gt;cookie('answers');

       Cookies created with a single scalar value, such as the "riddle_name" cookie, will be  returned  in  that
       form.  Cookies with array and hash values can also be retrieved.

       The  cookie  and  CGI::Simple   namespaces  are  separate.  If you have a parameter named 'answers' and a
       cookie named 'answers', the values retrieved by <b>param()</b> and  <b>cookie()</b>  are  independent  of  each  other.
       However, it's simple to turn a CGI parameter into a cookie, and vice-versa:

           # turn a CGI parameter into a cookie
           $c = $q-&gt;cookie( -name=&gt;'answers', -value=&gt;[$q-&gt;param('answers')] );
           # vice-versa
           $q-&gt;param( -name=&gt;'answers', -value=&gt;[$q-&gt;cookie('answers')] );

   <b>raw_cookie()</b>
       Returns  the  HTTP_COOKIE  variable. Cookies have a special format, and this method call just returns the
       raw form (?cookie dough). See <b>cookie()</b> for ways of setting and retrieving cooked cookies.

       Called with no parameters, <b>raw_cookie()</b> returns the packed cookie structure.  You can  separate  it  into
       individual  cookies  by  splitting  on  the  character  sequence "; ".  Called with the name of a cookie,
       retrieves the <b>unescaped</b> form of the cookie.  You can use the regular <b>cookie()</b> method to get the names, or
       use the <b>raw_fetch()</b> method from the CGI::Simmple::Cookie module.

</pre><h4><b>CREATING</b> <b>HTTP</b> <b>HEADERS</b></h4><pre>
       Normally the first thing you will do in any CGI script is print out  an  HTTP  header.   This  tells  the
       browser  what  type  of  document  to expect, and gives other optional information, such as the language,
       expiration date, and whether to cache the document.  The header  can  also  be  manipulated  for  special
       purposes, such as server push and pay per view pages.

   <b>header()</b> <b>Create</b> <b>simple</b> <b>or</b> <b>complex</b> <b>HTTP</b> <b>headers</b>
           print $q-&gt;header;


                -or-
           print $q-&gt;header('image/gif');


                -or-
           print $q-&gt;header('text/html','204 No response');


                -or-
           print $q-&gt;header( -type       =&gt; 'image/gif',
                             -nph        =&gt; 1,
                             -status     =&gt; '402 Payment required',
                             -expires    =&gt; '+3d',
                             -cookie     =&gt; $cookie,
                             -charset    =&gt; 'utf-7',
                             -attachment =&gt; 'foo.gif',
                             -Cost       =&gt; '$2.00'
                           );

       <b>header()</b>  returns  the Content-type: header.  You can provide your own MIME type if you choose, otherwise
       it defaults to text/html.  An optional second parameter specifies the status code  and  a  human-readable
       message.  For example, you can specify 204, "No response" to create a script that tells the browser to do
       nothing at all.

       The  last  example  shows  the  named argument style for passing arguments to the CGI methods using named
       parameters.  Recognized parameters are <b>-type</b>, <b>-status</b>, <b>-cookie</b>, <b>-target</b>,  <b>-expires</b>,  <b>-nph</b>,  <b>-charset</b>  and
       <b>-attachment</b>.  Any other named parameters will be stripped of their initial hyphens and turned into header
       fields, allowing you to specify any HTTP header you desire.

       For example, you can produce non-standard HTTP header fields by providing them as named arguments:

         print $q-&gt;header( -type            =&gt; 'text/html',
                           -nph             =&gt; 1,
                           -cost            =&gt; 'Three smackers',
                           -annoyance_level =&gt; 'high',
                           -complaints_to   =&gt; 'bit bucket'
                         );

       This will produce the following non-standard HTTP header:

           HTTP/1.0 200 OK
           Cost: Three smackers
           Annoyance-level: high
           Complaints-to: bit bucket
           Content-type: text/html

       Note  that underscores are translated automatically into hyphens. This feature allows you to keep up with
       the rapidly changing HTTP "standards".

       The <b>-type</b> is a key element  that  tell  the  browser  how  to  display  your  document.  The  default  is
       'text/html'. Common types are:

           text/html
           text/plain
           image/gif
           image/jpg
           image/png
           application/octet-stream

       The <b>-status</b> code is the HTTP response code. The default is 200 OK. Common status codes are:

           200 OK
           204 No Response
           301 Moved Permanently
           302 Found
           303 See Other
           307 Temporary Redirect
           400 Bad Request
           401 Unauthorized
           403 Forbidden
           404 Not Found
           405 Not Allowed
           408 Request Timed Out
           500 Internal Server Error
           503 Service Unavailable
           504 Gateway Timed Out

       The  <b>-expires</b> parameter lets you indicate to a browser and proxy server how long to cache pages for. When
       you specify an absolute or relative expiration interval with this  parameter,  some  browsers  and  proxy
       servers  will cache the script's output until the indicated expiration date.  The following forms are all
       valid for the -expires field:

           +30s                                30 seconds from now
           +10m                                ten minutes from now
           +1h                                 one hour from now
           -1d                                 yesterday (i.e. "ASAP!")
           now                                 immediately
           +3M                                 in three months
           +10y                                in ten years time
           Thursday, 25-Apr-1999 00:40:33 GMT  at the indicated time &amp; date

       The <b>-cookie</b> parameter generates a header that tells the browser to provide a "magic  cookie"  during  all
       subsequent  transactions  with  your  script.   Netscape  cookies  have  a  special  format that includes
       interesting attributes such as expiration time.  Use the <b>cookie()</b> method to create and  retrieve  session
       cookies.

       The <b>-target</b> is for frames use

       The  <b>-nph</b> parameter, if set to a true value, will issue the correct headers to work with a NPH (no-parse-
       header) script.  This is important to use with certain servers that expect all their scripts to be NPH.

       The <b>-charset</b> parameter can be used to control the character set sent to the browser.   If  not  provided,
       defaults to ISO-8859-1.  As a side effect, this sets the <b>charset()</b> method as well.

       The  <b>-attachment</b>  parameter  can  be used to turn the page into an attachment.  Instead of displaying the
       page, some browsers will prompt the user to save it to disk.  The value of the argument is the  suggested
       name   for   the  saved  file.   In  order  for  this  to  work,  you  may  have  to  set  the  <b>-type</b>  to
       'application/octet-stream'.

   <b>no_cache()</b> <b>Preventing</b> <b>browser</b> <b>caching</b> <b>of</b> <b>scripts</b>
       Most browsers will not cache the output from CGI scripts. Every time the browser reloads  the  page,  the
       script  is invoked anew. However some browsers do cache pages. You can discourage this behavior using the
       <b>no_cache()</b> function.

           $q-&gt;<a href="../man1/no_cache.1.html">no_cache</a>(1); # turn caching off by sending appropriate headers
           $q-&gt;<a href="../man1/no_cache.1.html">no_cache</a>(1); # do not send cache related headers.

           $q-&gt;<a href="../man1/no_cache.1.html">no_cache</a>(1);
           print header (-type=&gt;'image/gif', -nph=&gt;1);

           This will produce a header like the following:

           HTTP/1.0 200 OK
           Server: Apache - accept no substitutes
           Expires: Thu, 15 Nov 2001 03:37:50 GMT
           Date: Thu, 15 Nov 2001 03:37:50 GMT
           Pragma: no-cache
           Content-Type: image/gif

       Both the Pragma: no-cache header field and an Expires header that corresponds to  the  current  time  (ie
       now) will be sent.

   <b>cache()</b> <b>Preventing</b> <b>browser</b> <b>caching</b> <b>of</b> <b>scripts</b>
       The somewhat ill named <b>cache()</b> method is a legacy from CGI.pm. It operates the same as the new <b>no_cache()</b>
       method.  The  difference is/was that when set it results only in the Pragma: no-cache line being printed.
       Expires time data is not sent.

   <b>redirect()</b> <b>Generating</b> <b>a</b> <b>redirection</b> <b>header</b>
           print $q-&gt;redirect('<a href="http://somewhere.else/in/movie/land">http://somewhere.else/in/movie/land</a>');

       Sometimes you don't want to produce a document yourself,  but  simply  redirect  the  browser  elsewhere,
       perhaps choosing a URL based on the time of day or the identity of the user.

       The  <b>redirect()</b> function redirects the browser to a different URL.  If you use redirection like this, you
       should <b>not</b> print out a header as well.

       One hint I can offer is that relative links may not work correctly when you  generate  a  redirection  to
       another  document  on  your  site.  This is due to a well-intentioned optimization that some servers use.
       The solution to this is to use the  full  URL  (including  the  http:  part)  of  the  document  you  are
       redirecting to.

       You can also use named arguments:

           print $q-&gt;redirect( -uri=&gt;'<a href="http://somewhere.else/in/movie/land">http://somewhere.else/in/movie/land</a>',
                               -nph=&gt;1
                             );

       The  <b>-nph</b> parameter, if set to a true value, will issue the correct headers to work with a NPH (no-parse-
       header) script.  This is important to use with certain servers, such as Microsoft ones, which expect  all
       their scripts to be NPH.

</pre><h4><b>PRAGMAS</b></h4><pre>
       There  are a number of pragmas that you can specify in your use CGI::Simple statement. Pragmas, which are
       always preceded by a hyphen, change the way that CGI::Simple functions in various ways. You can generally
       achieve exactly the same results by setting the underlying $GLOBAL_VARIABLES.

       For example the '-upload' pargma will enable file uploads:

           use CGI::Simple qw(-upload);

       In CGI::Simple::Standard Pragmas, function sets , and individual functions can all  be  imported  in  the
       same  <b>use()</b>  line.   For  example,  the following use statement imports the standard set of functions and
       enables debugging mode (pragma -debug):

           use CGI::Simple::Standard qw(:standard -debug);

       The current list of pragmas is as follows:

       -no_undef_params
           If a value is not given in the query string, as in the queries "name1=&amp;name2=" or  "name1&amp;name2",  by
           default it will be returned as an empty string.

           If  you  specify the '-no_undef_params' pragma then CGI::Simple ignores parameters with no values and
           they will not appear in the query object.

       -nph
           This makes CGI.pm produce a header appropriate for an NPH (no parsed header) script.  You may need to
           do other things as well to tell the server that the script is NPH.  See the discussion of NPH scripts
           below.

       -newstyle_urls
           Separate the name=value pairs in CGI parameter query strings with semicolons rather than  ampersands.
           For example:

               ?name=fred;age=24;favorite_color=3

           Semicolon-delimited  query  strings  are  always  accepted, but will not be emitted by <b>self_url()</b> and
           <b>query_string()</b> unless the -newstyle_urls pragma is specified.

       -oldstyle_urls
           Separate the name=value pairs in CGI parameter query strings with ampersands rather than  semicolons.
           This is the default.

               ?name=fred&amp;age=24&amp;favorite_color=3

       -autoload
           This  is  only available for CGI::Simple::Standard and uses AUTOLOAD to load functions on demand. See
           the CGI::Simple::Standard docs for details.

       -no_debug
           This turns off the command-line processing features. This is the default.

       -debug1 and debug2
           This turns on debugging.  At debug level 1 CGI::Simple will read arguments from the command-line.  At
           debug  level  2  CGI.pm  will  produce  the prompt "(offline mode: enter name=value pairs on standard
           input)" and wait for input on STDIN. If no number is specified then a debug level of 2 is used.

           See the section on debugging for more details.

       -default
           This sets the default global values for CGI.pm which will enable  infinite  size  file  uploads,  and
           specify the '-newstyle_urls' and '-debug1' pragmas

       -no_upload
           Disable uploads - the default setting

       - upload
           Enable uploads - the CGI.pm default

       -unique_header
           Only allows headers to be generated once per script invocation

       -carp
           Carp when <b>cgi_error()</b> called, default is to do nothing

       -croak
           Croak when <b>cgi_error()</b> called, default is to do nothing

</pre><h4><b>USING</b> <b>NPH</b> <b>SCRIPTS</b></h4><pre>
       NPH,  or  "no-parsed-header",  scripts  bypass  the server completely by sending the complete HTTP header
       directly to the browser.  This has slight performance benefits, but is of most use for  taking  advantage
       of HTTP extensions that are not directly supported by your server, such as server push and PICS headers.

       Servers  use  a variety of conventions for designating CGI scripts as NPH.  Many Unix servers look at the
       beginning of the script's name for the prefix "nph-".   The  Macintosh  WebSTAR  server  and  Microsoft's
       Internet  Information  Server, in contrast, try to decide whether a program is an NPH script by examining
       the first line of script output.

       CGI.pm supports NPH scripts with a special NPH mode.  When in this mode, CGI.pm will output the necessary
       extra header information when the <b>header()</b> and <b>redirect()</b> methods are called. You can set NPH mode in any
       of the following ways:

       In the <b>use</b> statement
           Simply add the "-nph" pragma to the use:

               use CGI::Simple qw(-nph)

       By calling the <b>nph()</b> method:
           Call <b>nph()</b> with a non-zero parameter at any point after using CGI.pm in your program.

               $q-&gt;<a href="../man1/nph.1.html">nph</a>(1)

       By using <b>-nph</b> parameters
           in the <b>header()</b> and <b>redirect()</b>  statements:

               print $q-&gt;header(-nph=&gt;1);

       The Microsoft Internet Information Server requires NPH mode.  CGI::Simple will automatically detect  when
       the  script  is  running  under  IIS and put itself into this mode.  You do not need to do this manually,
       although it won't hurt anything if you do.  However, note that if you have applied Service Pack  6,  much
       of  the  functionality of NPH scripts, including the ability to redirect while setting a cookie, b&lt;do not
       work    at    all&gt;    on     IIS     without     a     special     patch     from     Microsoft.      See
       <a href="http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP">http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP</a>:  Non-Parsed  Headers  Stripped  From  CGI
       Applications That Have nph- Prefix in Name.

</pre><h4><b>SERVER</b> <b>PUSH</b></h4><pre>
       CGI.pm provides four simple functions for producing multipart documents of the type needed  to  implement
       server  push.  These functions were graciously provided by Ed Jordan &lt;<a href="mailto:ed@fidalgo.net">ed@fidalgo.net</a>&gt; with additions from
       Andrew Benham &lt;<a href="mailto:adsb@bigfoot.com">adsb@bigfoot.com</a>&gt;

       You are also advised to put the script into NPH mode and to set $| to 1 to avoid buffering problems.

       Browser support for server push is variable.

       Here is a simple script that demonstrates server push:

           #!/usr/local/bin/perl
           use CGI::Simple::Standard qw/:push -nph/;
           $| = 1;
           print multipart_init(-boundary=&gt;'----here we go!');
           foreach (0 .. 4) {
               print multipart_start(-type=&gt;'text/plain'),
               "The current time is ",scalar(localtime),"\n";
               if ($_ &lt; 4) {
                   print multipart_end;
               }
               else {
                   print multipart_final;
               }
               sleep 1;
           }

       This script initializes server push by calling <b>multipart_init()</b>.  It then  enters  a  loop  in  which  it
       begins  a  new  multipart section by calling <b>multipart_start()</b>, prints the current local time, and ends a
       multipart section with <b>multipart_end()</b>.  It then  sleeps  a  second,  and  begins  again.  On  the  final
       iteration, it ends the multipart section with <b>multipart_final()</b> rather than with <b>multipart_end()</b>.

   <b>multipart_init()</b> <b>Initialize</b> <b>the</b> <b>multipart</b> <b>system</b>
           multipart_init(-boundary=&gt;$boundary);

       Initialize  the  multipart  system.  The -boundary argument specifies what MIME boundary string to use to
       separate parts of the document.  If not provided, CGI.pm chooses a reasonable boundary for you.

   <b>multipart_start()</b> <b>Start</b> <b>a</b> <b>new</b> <b>part</b> <b>of</b> <b>the</b> <b>multipart</b> <b>document</b>
           multipart_start(-type=&gt;$type)

       Start a new part of the multipart document using the specified MIME type.  If not specified, text/html is
       assumed.

   <b>multipart_end()</b> <b>End</b> <b>a</b> <b>multipart</b> <b>part</b>
           multipart_end()

       End a part.  You must remember to call <b>multipart_end()</b> once for each <b>multipart_start()</b>, except at the end
       of the last  part  of  the  multipart  document  when  <b>multipart_final()</b>  should  be  called  instead  of
       <b>multipart_end()</b>.

   <b>multipart_final()</b>
           multipart_final()

       End all parts.  You should call <b>multipart_final()</b> rather than <b>multipart_end()</b> at the end of the last part
       of the multipart document.

   <b>CGI::Push</b>
       Users interested in server push applications should also have a look at the <b>CGI::Push</b> module.

</pre><h4><b>DEBUGGING</b></h4><pre>
       If  you  are  running the script from the command line or in the perl debugger, you can pass the script a
       list of keywords or parameter=value pairs on the command line or from standard input (you don't  have  to
       worry  about  tricking your script into reading from environment variables).  Before you do this you will
       need to change the debug level from the default level of 0 (no debug) to either 1 if you  want  to  debug
       from  @ARGV  (the  command  line)  of  2 if you want to debug from STDIN. You can do this using the debug
       pragma like this:

           use CGI::Simple qw(-debug2);  # set debug to level 2 =&gt; from STDIN

               or this:

           $CGI::Simple::DEBUG = 1;      # set debug to level 1 =&gt; from @ARGV

       At debug level 1 you can pass keywords and name=value pairs like this:

           your_script.pl keyword1 keyword2 keyword3

               or this:

           your_script.pl keyword1+keyword2+keyword3

               or this:

           your_script.pl name1=value1 name2=value2

               or this:

           your_script.pl name1=value1&amp;name2=value2

       At debug level 2 you can feed newline-delimited name=value pairs to the script  on  standard  input.  You
       will be presented with the following prompt:

           (offline mode: enter name=value pairs on standard input)

       You  end  the  input with your system dependent end of file character.  You should try ^Z ^X ^D and ^C if
       all else fails. The ^ means hold down the [Ctrl] button while you press the other key.

       When debugging, you can use quotes and backslashes to escape characters in  the  familiar  shell  manner,
       letting you place spaces and other funny characters in your parameter=value pairs:

           your_script.pl "name1='I am a long value'" "name2=two\ words"

   <b>Dump()</b> <b>Dumping</b> <b>the</b> <b>current</b> <b>object</b> <b>details</b>
       The <b>Dump()</b> method produces a string consisting of all the query's object attributes formatted nicely as a
       nested  list.   This dump includes the name/value pairs and a number of other details. This is useful for
       debugging purposes:

           print $q-&gt;Dump

       The actual result of this is HTML escaped formatted text wrapped in &lt;pre&gt; tags so if you send it straight
       to the browser it produces something that looks like:

           $VAR1 = bless( {
                '.parameters' =&gt; [
                                   'name',
                                   'color'
                                 ],
                '.globals' =&gt; {
                                'FATAL' =&gt; -1,
                                'DEBUG' =&gt; 0,
                                'NO_NULL' =&gt; 1,
                                'POST_MAX' =&gt; 102400,
                                'USE_CGI_PM_DEFAULTS' =&gt; 0,
                                'HEADERS_ONCE' =&gt; 0,
                                'NPH' =&gt; 0,
                                'DISABLE_UPLOADS' =&gt; 1,
                                'NO_UNDEF_PARAMS' =&gt; 0,
                                'USE_PARAM_SEMICOLONS' =&gt; 0
                              },
                '.fieldnames' =&gt; {
                                   'color' =&gt; '1',
                                   'name' =&gt; '1'
                                 },
                '.mod_perl' =&gt; '',
                'color' =&gt; [
                             'red',
                             'green',
                             'blue'
                           ],
                'name' =&gt; [
                            'JaPh,'
                          ]
               }, 'CGI::Simple' );

       You may recognize this as valid Perl syntax (which it is)  and/or  the  output  from  Data::Dumper  (also
       true).  This  is  the  actual guts of how the information is stored in the query object. All the internal
       params start with a . char

       Alternatively you can dump your object and the current environment using:

           print $q-&gt;Dump(\%ENV);

   <b>PrintEnv()</b> <b>Dumping</b> <b>the</b> <b>environment</b>
       You can get a similar browser friendly dump of the current %ENV hash using:

           print $q-&gt;PrintEnv;

       This will produce something like (in the browser):

           $VAR1 = {
                 'QUERY_STRING' =&gt; 'name=JaPh%2C&amp;color=red&amp;color=green&amp;color=blue',
                 'CONTENT_TYPE' =&gt; 'application/x-www-form-urlencoded',
                 'REGRESSION_TEST' =&gt; 'simple.t.pl',
                 'VIM' =&gt; 'C:\\WINDOWS\\Desktop\\vim',
                 'HTTP_REFERER' =&gt; 'xxx.sex.com',
                 'HTTP_USER_AGENT' =&gt; 'LWP',
                 'HTTP_ACCEPT' =&gt; 'text/html;q=1, image/gif;q=0.42, */*;q=0.001',
                 'REMOTE_HOST' =&gt; 'localhost',
                 'HTTP_HOST' =&gt; 'the.restaurant.at.the.end.of.the.universe',
                 'GATEWAY_INTERFACE' =&gt; 'bleeding edge',
                 'REMOTE_IDENT' =&gt; 'None of your damn business',
                 'SCRIPT_NAME' =&gt; '/cgi-bin/foo.cgi',
                 'SERVER_NAME' =&gt; 'nowhere.com',
                 'HTTP_COOKIE' =&gt; '',
                 'CONTENT_LENGTH' =&gt; '42',
                 'HTTPS_A' =&gt; 'A',
                 'HTTP_FROM' =&gt; '<a href="mailto:spammer@nowhere.com">spammer@nowhere.com</a>',
                 'HTTPS_B' =&gt; 'B',
                 'SERVER_PROTOCOL' =&gt; 'HTTP/1.0',
                 'PATH_TRANSLATED' =&gt; '/usr/local/somewhere/else',
                 'SERVER_SOFTWARE' =&gt; 'Apache - accept no substitutes',
                 'PATH_INFO' =&gt; '/somewhere/else',
                 'REMOTE_USER' =&gt; 'Just another Perl hacker,',
                 'REMOTE_ADDR' =&gt; '127.0.0.1',
                 'HTTPS' =&gt; 'ON',
                 'DOCUMENT_ROOT' =&gt; '/vs/www/foo',
                 'REQUEST_METHOD' =&gt; 'GET',
                 'REDIRECT_QUERY_STRING' =&gt; '',
                 'AUTH_TYPE' =&gt; 'PGP MD5 DES rot13',
                 'COOKIE' =&gt; 'foo=a%20phrase; bar=yes%2C%20a%20phrase&amp;;I%20say;',
                 'SERVER_PORT' =&gt; '8080'
               };

   <b>cgi_error()</b> <b>Retrieving</b> <b>CGI::Simple</b> <b>error</b> <b>messages</b>
       Errors can occur while processing user input, particularly when processing uploaded  files.   When  these
       errors  occur, CGI::Simple will stop processing and return an empty parameter list.  You can test for the
       existence and nature of errors using the <b>cgi_error()</b> function.  The error messages are formatted as  HTTP
       status  codes. You can either incorporate the error text into an HTML page, or use it as the value of the
       HTTP status:

           my $error = $q-&gt;cgi_error;
           if ($error) {
               print $q-&gt;header(-status=&gt;$error);
               print "&lt;H2&gt;$error&lt;/H2&gt;;
             exit;
           }

</pre><h4><b>ACCESSOR</b> <b>METHODS</b></h4><pre>
   <b>version()</b> <b>Get</b> <b>the</b> <b>CGI::Simple</b> <b>version</b> <b>info</b>
           $version = $q-&gt;version();

       The <b>version()</b> method returns the value of $VERSION

   <b>nph()</b> <b>Enable/disable</b> <b>NPH</b> <b>(Non</b> <b>Parsed</b> <b>Header)</b> <b>mode</b>
           $q-&gt;<a href="../man1/nph.1.html">nph</a>(1);  # enable NPH mode
           $q-&gt;<a href="../man0/nph.0.html">nph</a>(0);  # disable NPH mode

       The <b>nph()</b> method enables and disables NPH headers. See the NPH section.

   <b>all_parameters()</b> <b>Get</b> <b>the</b> <b>names/values</b> <b>of</b> <b>all</b> <b>parameters</b>
           @all_parameters = $q-&gt;all_parameters();

       The <b>all_parameters()</b> method is an alias for <b>param()</b>

   <b>charset()</b> <b>Get/set</b> <b>the</b> <b>current</b> <b>character</b> <b>set.</b>
           $charset = $q-&gt;charset(); # get current charset
           $q-&gt;charset('utf-42');    # set the charset

       The <b>charset()</b> method gets the current charset value if no argument is supplied or sets it if an  argument
       is supplied.

   <b>crlf()</b> <b>Get</b> <b>the</b> <b>system</b> <b>specific</b> <b>line</b> <b>ending</b> <b>sequence</b>
           $crlf = $q-&gt;crlf();

       The <b>crlf()</b> method returns the system specific line ending sequence.

   <b>globals()</b> <b>Get/set</b> <b>the</b> <b>value</b> <b>of</b> <b>the</b> <b>remaining</b> <b>global</b> <b>variables</b>
           $globals = $q-&gt;globals('FATAL');     # get the current value of $FATAL
           $globals = $q-&gt;globals('FATAL', 1 ); # set croak mode on cgi_error()

       The  <b>globals()</b> method gets/sets the values of the global variables after the script has been invoked. For
       globals like $POST_MAX and $DISABLE_UPLOADS this makes no difference as they must be set prior to calling
       the new constructor but there might be reason the change the value of others.

   <b>auth_type()</b> <b>Get</b> <b>the</b> <b>current</b> <b>authorization/verification</b> <b>method</b>
           $auth_type = $q-&gt;auth_type();

       The  <b>auth_type()</b>  method  returns   the   value   of   $ENV{'AUTH_TYPE'}   which   should   contain   the
       authorization/verification method in use for this script, if any.

   <b>content_length()</b> <b>Get</b> <b>the</b> <b>content</b> <b>length</b> <b>submitted</b> <b>in</b> <b>a</b> <b>POST</b>
           $content_length = $q-&gt;content_length();

       The <b>content_length()</b> method returns the value of $ENV{'AUTH_TYPE'}

   <b>content_type()</b> <b>Get</b> <b>the</b> <b>content_type</b> <b>of</b> <b>data</b> <b>submitted</b> <b>in</b> <b>a</b> <b>POST</b>
           $content_type = $q-&gt;content_type();

       The   <b>content_type()</b>   method   returns   the  content_type  of  data  submitted  in  a  POST,  generally
       'multipart/form-data' or 'application/x-www-form-urlencoded' as supplied in $ENV{'CONTENT_TYPE'}

   <b>document_root()</b> <b>Get</b> <b>the</b> <b>document</b> <b>root</b>
           $document_root = $q-&gt;document_root();

       The <b>document_root()</b> method returns the value of $ENV{'DOCUMENT_ROOT'}

   <b>gateway_interface()</b> <b>Get</b> <b>the</b> <b>gateway</b> <b>interface</b>
           $gateway_interface = $q-&gt;gateway_interface();

       The <b>gateway_interface()</b> method returns the value of $ENV{'GATEWAY_INTERFACE'}

   <b>path_translated()</b> <b>Get</b> <b>the</b> <b>value</b> <b>of</b> <b>path</b> <b>translated</b>
           $path_translated = $q-&gt;path_translated();

       The <b>path_translated()</b> method returns the value of $ENV{'PATH_TRANSLATED'}

   <b>referer()</b> <b>Spy</b> <b>on</b> <b>your</b> <b>users</b>
           $referer = $q-&gt;referer();

       The <b>referer()</b> method returns the value of $ENV{'REFERER'} This will  return  the  URL  of  the  page  the
       browser was viewing prior to fetching your script.  Not available for all browsers.

   <b>remote_addr()</b> <b>Get</b> <b>the</b> <b>remote</b> <b>address</b>
           $remote_addr = $q-&gt;remote_addr();

       The <b>remote_addr()</b> method returns the value of $ENV{'REMOTE_ADDR'} or 127.0.0.1 (localhost) if this is not
       defined.

   <b>remote_host()</b> <b>Get</b> <b>a</b> <b>value</b> <b>for</b> <b>remote</b> <b>host</b>
           $remote_host = $q-&gt;remote_host();

       The  <b>remote_host()</b>  method  returns  the  value  of  $ENV{'REMOTE_HOST'} if it is defined. If this is not
       defined it returns $ENV{'REMOTE_ADDR'} If this is not defined it returns 'localhost'

   <b>remote_ident()</b> <b>Get</b> <b>the</b> <b>remote</b> <b>identity</b>
           $remote_ident = $q-&gt;remote_ident();

       The <b>remote_ident()</b> method returns the value of $ENV{'REMOTE_IDENT'}

   <b>remote_user()</b> <b>Get</b> <b>the</b> <b>remote</b> <b>user</b>
           $remote_user = $q-&gt;remote_user();

       The <b>remote_user()</b> method returns the authorization/verification name used for user verification, if  this
       script is protected. The value comes from $ENV{'REMOTE_USER'}

   <b>request_method()</b> <b>Get</b> <b>the</b> <b>request</b> <b>method</b>
           $request_method = $q-&gt;request_method();

       The  <b>request_method()</b>  method returns the method used to access your script, usually one of 'POST', 'GET'
       or 'HEAD' as supplied by $ENV{'REQUEST_METHOD'}

   <b>script_name()</b> <b>Get</b> <b>the</b> <b>script</b> <b>name</b>
           $script_name = $q-&gt;script_name();

       The <b>script_name()</b> method returns the value of $ENV{'SCRIPT_NAME'} if it is defined. Otherwise it  returns
       Perl's script name from $0. Failing this it returns a null string ''

   <b>server_name()</b> <b>Get</b> <b>the</b> <b>server</b> <b>name</b>
           $server_name = $q-&gt;server_name();

       The <b>server_name()</b> method returns the value of $ENV{'SERVER_NAME'} if defined or 'localhost' otherwise

   <b>server_port()</b> <b>Get</b> <b>the</b> <b>port</b> <b>the</b> <b>server</b> <b>is</b> <b>listening</b> <b>on</b>
           $server_port = $q-&gt;server_port();

       The <b>server_port()</b> method returns the value $ENV{'SERVER_PORT'} if defined or 80 if not.

   <b>server_protocol()</b> <b>Get</b> <b>the</b> <b>current</b> <b>server</b> <b>protocol</b>
           $server_protocol = $q-&gt;server_protocol();

       The  <b>server_protocol()</b>  method  returns  the  value  of  $ENV{'SERVER_PROTOCOL'} if defined or 'HTTP/1.0'
       otherwise

   <b>server_software()</b> <b>Get</b> <b>the</b> <b>server</b> <b>software</b>
           $server_software = $q-&gt;server_software();

       The <b>server_software()</b> method returns  the  value  $ENV{'SERVER_SOFTWARE'}  or  'cmdline'  If  the  server
       software  is IIS it formats your hard drive, installs Linux, FTPs to www.apache.org, installs Apache, and
       then restores your system from tape. Well maybe not, but it's a nice thought.

   <b>user_name()</b> <b>Get</b> <b>a</b> <b>value</b> <b>for</b> <b>the</b> <b>user</b> <b>name.</b>
           $user_name = $q-&gt;user_name();

       Attempt to obtain the remote user's name, using a variety of different techniques.  This only works  with
       older browsers such as Mosaic.  Newer browsers do not report the user name for privacy reasons!

       Technically   the   <b>user_name()</b>   method   returns   the  value  of  $ENV{'HTTP_FROM'}  or  failing  that
       $ENV{'REMOTE_IDENT'} or as a last choice $ENV{'REMOTE_USER'}

   <b>user_agent()</b> <b>Get</b> <b>the</b> <b>users</b> <b>browser</b> <b>type</b>
           $ua = $q-&gt;user_agent();          # return the user agent
           $ok = $q-&gt;user_agent('mozilla'); # return true if user agent 'mozilla'

       The <b>user_agent()</b> method returns the value of $ENV{'HTTP_USER_AGENT'}  when called without an argument  or
       true  or  false  if  the  $ENV{'HTTP_USER_AGENT'}  matches  the  passed  argument.  The  matching is case
       insensitive and partial.

   <b>virtual_host()</b> <b>Get</b> <b>the</b> <b>virtual</b> <b>host</b>
           $virtual_host = $q-&gt;virtual_host();

       The <b>virtual_host()</b> method returns the value of  $ENV{'HTTP_HOST'} if defined or $ENV{'SERVER_NAME'} as  a
       default. Port numbers are removed.

   <b>path_info()</b> <b>Get</b> <b>any</b> <b>extra</b> <b>path</b> <b>info</b> <b>set</b> <b>to</b> <b>the</b> <b>script</b>
           $path_info = $q-&gt;path_info();

       The  <b>path_info()</b>  method  returns  additional  path  information  from  the  script  URL.  E.G.  fetching
       /cgi-bin/your_script/additional/stuff will result in $q-&gt;<b>path_info()</b> returning "/additional/stuff".

       NOTE: The Microsoft Internet Information Server is broken with respect to  additional  path  information.
       If  you  use the Perl DLL library, the IIS server will attempt to execute the additional path information
       as a Perl script.  If you use the ordinary file  associations  mapping,  the  path  information  will  be
       present  in  the  environment,  but  incorrect.   The  best thing to do is to avoid using additional path
       information in CGI scripts destined for use with IIS.

   <b>Accept()</b> <b>Get</b> <b>the</b> <b>browser</b> <b>MIME</b> <b>types</b>
           $Accept = $q-&gt;Accept();

       The <b>Accept()</b> method returns a list of MIME types that the remote browser accepts. If you give this method
       a single argument corresponding to a MIME type, as in $q-&gt;Accept('text/html'), it will return a  floating
       point  value  corresponding to the browser's preference for this type from 0.0 (don't want) to 1.0.  Glob
       types (e.g. text/*) in the browser's accept list are handled correctly.

   <b>accept()</b> <b>Alias</b> <b>for</b> <b>Accept()</b>
           $accept = $q-&gt;accept();

       The <b>accept()</b> Method is an alias for <b>Accept()</b>

   <b>http()</b> <b>Get</b> <b>a</b> <b>range</b> <b>of</b> <b>HTTP</b> <b>related</b> <b>information</b>
           $http = $q-&gt;http();

       Called with no arguments the <b>http()</b> method returns the list  of  HTTP  or  HTTPS  environment  variables,
       including such things as HTTP_USER_AGENT, HTTP_ACCEPT_LANGUAGE, and HTTP_ACCEPT_CHARSET, corresponding to
       the  like-named  HTTP header fields in the request. Called with the name of an HTTP header field, returns
       its value.  Capitalization and the use of hyphens versus underscores are not significant.

       For example, all three of these examples are equivalent:

          $requested_language = $q-&gt;http('Accept-language');
          $requested_language = $q-&gt;http('Accept_language');
          $requested_language = $q-&gt;http('HTTP_ACCEPT_LANGUAGE');

   <b>https()</b> <b>Get</b> <b>a</b> <b>range</b> <b>of</b> <b>HTTPS</b> <b>related</b> <b>information</b>
           $https = $q-&gt;https();

       The <b>https()</b> method is similar to the <b>http()</b> method except that when called without an argument it returns
       the value of $ENV{'HTTPS'} which will be true if a HTTPS connection is in use and false otherwise.

   <b>protocol()</b> <b>Get</b> <b>the</b> <b>current</b> <b>protocol</b>
           $protocol = $q-&gt;protocol();

       The <b>protocol()</b> method returns 'https' if a HTTPS connection is in  use  or  the  <b>server_protocol()</b>  minus
       version numbers ('http') otherwise.

   <b>url()</b> <b>Return</b> <b>the</b> <b>script's</b> <b>URL</b> <b>in</b> <b>several</b> <b>formats</b>
           $full_url      = $q-&gt;url();
           $full_url      = $q-&gt;url(-full=&gt;1);
           $relative_url  = $q-&gt;url(-relative=&gt;1);
           $absolute_url  = $q-&gt;url(-absolute=&gt;1);
           $url_with_path = $q-&gt;url(-path_info=&gt;1);
           $url_with_path_and_query = $q-&gt;url(-path_info=&gt;1,-query=&gt;1);
           $netloc        = $q-&gt;url(-base =&gt; 1);

       <b>url()</b>  returns  the  script's  URL in a variety of formats.  Called without any arguments, it returns the
       full form of the URL, including host name and port number

           <a href="http://your.host.com/path/to/script.cgi">http://your.host.com/path/to/script.cgi</a>

       You can modify this format with the following named arguments:

       <b>-absolute</b>
           If true, produce an absolute URL, e.g.

               /path/to/script.cgi

       <b>-relative</b>
           Produce a relative URL.  This  is  useful  if  you  want  to  reinvoke  your  script  with  different
           parameters. For example:

               script.cgi

       <b>-full</b>
           Produce  the  full URL, exactly as if called without any arguments.  This overrides the -relative and
           -absolute arguments.

       <b>-path</b> (<b>-path_info</b>)
           Append the additional path information to the URL.  This can be combined  with  <b>-full</b>,  <b>-absolute</b>  or
           <b>-relative</b>.  <b>-path_info</b> is provided as a synonym.

       <b>-query</b> (<b>-query_string</b>)
           Append  the  query  string  to  the  URL.   This  can be combined with <b>-full</b>, <b>-absolute</b> or <b>-relative</b>.
           <b>-query_string</b> is provided as a synonym.

       <b>-base</b>
           Generate just the protocol and net location, as in <a href="http://www.foo.com">http://www.foo.com</a>:8000

   <b>self_url()</b> <b>Get</b> <b>the</b> <b>scripts</b> <b>complete</b> <b>URL</b>
           $self_url = $q-&gt;self_url();

       The <b>self_url()</b> method returns the value of:

          $self-&gt;url( '-path_info'=&gt;1, '-query'=&gt;1, '-full'=&gt;1 );

   <b>state()</b> <b>Alias</b> <b>for</b> <b>self_url()</b>
           $state = $q-&gt;state();

       The <b>state()</b> method is an alias for <b>self_url()</b>

</pre><h4><b>COMPATIBILITY</b> <b>WITH</b> <b>cgi-lib.pl</b> <b>2.18</b></h4><pre>
       To make it easier to port existing programs that use  cgi-lib.pl  all  the  subs  within  cgi-lib.pl  are
       available in CGI::Simple.  Using the functional interface of CGI::Simple::Standard porting is as easy as:

           OLD VERSION
               require "cgi-lib.pl";
               &amp;ReadParse;
               print "The value of the antique is $in{'antique'}.\n";

           NEW VERSION
               use CGI::Simple::Standard qw(:cgi-lib);
               &amp;ReadParse;
               print "The value of the antique is $in{'antique'}.\n";

       CGI:Simple's  <b>ReadParse()</b> routine creates a variable named %in, which can be accessed to obtain the query
       variables.  Like ReadParse, you can also provide your own variable via a glob. Infrequently used features
       of <b>ReadParse()</b>, such as the creation of @in and $in variables, are not supported.

       You can also use the OO interface of CGI::Simple and call <b>ReadParse()</b> and other cgi-lib.pl functions like
       this:

           &amp;CGI::Simple::ReadParse;       # get hash values in %in

           my $q = CGI::Simple-&gt;new;
           $q-&gt;ReadParse();                # same thing

           CGI::Simple::ReadParse(*field); # get hash values in %field function style

           my $q = CGI::Simple-&gt;new;
           $q-&gt;ReadParse(*field);          # same thing

       Once you use <b>ReadParse()</b> under the functional interface , you can retrieve the query object  itself  this
       way if needed:

           $q = $in{'CGI'};

       Either  way  it  allows you to start using the more interesting features of CGI.pm without rewriting your
       old scripts from scratch.

       Unlike CGI.pm all the cgi-lib.pl functions from Version 2.18 are supported:

           ReadParse()
           SplitParam()
           MethGet()
           MethPost()
           MyBaseUrl()
           MyURL()
           MyFullUrl()
           PrintHeader()
           HtmlTop()
           HtmlBot()
           PrintVariables()
           PrintEnv()
           CgiDie()
           CgiError()

</pre><h4><b>COMPATIBILITY</b> <b>WITH</b> <b>CGI.pm</b></h4><pre>
       I has long been suggested that the CGI and HTML parts of CGI.pm should be  split  into  separate  modules
       (even  the  author  suggests  this!),  CGI::Simple  represents  the  realization of this and contains the
       complete CGI side of CGI.pm. Code-wise it weighs in at a little under 30% of the  size  of  CGI.pm  at  a
       little under 1000 lines.

       A  great deal of care has been taken to ensure that the interface remains unchanged although a few tweaks
       have been made. The test suite is extensive and includes all the CGI.pm test scripts as well as a  series
       of  new test scripts. You may like to have a look at /t/concur.t which makes 160 tests of CGI::Simple and
       CGI in parallel and compares the results to ensure they are identical. This is  the  case  as  of  CGI.pm
       2.78.

       You  can't make an omelet without breaking eggs. A large number of methods and global variables have been
       deleted as detailed below. Some pragmas are also gone. In the tarball there is  a  script  <b>/misc/check.pl</b>
       that  will check if a script seems to be using any of these now non existent methods, globals or pragmas.
       You call it like this:

           perl check.pl &lt;files&gt;

       If it finds any likely candidates it will print a line with the line number,  problem  method/global  and
       the complete line. For example here is some output from running the script on CGI.pm:

           ...
           3162: Problem:'$CGI::OS'   local($CRLF) = "\015\012" if $CGI::OS eq 'VMS';
           3165: Problem:'fillBuffer' $self-&gt;fillBuffer($FILLUNIT);
           ....

</pre><h4><b>DIFFERENCES</b> <b>FROM</b> <b>CGI.pm</b></h4><pre>
       CGI::Simple is strict and warnings compliant.

       There are 4 modules in this distribution:

           CGI/Simple.pm           supplies all the core code.
           CGI/Simple/Cookie.pm    supplies the cookie handling functions.
           CGI/Simple/Util.pm      supplies a variety of utility functions
           CGI/Simple/Standard.pm  supplies a functional interface for Simple.pm

       Simple.pm  is  the  core  module  that provide all the essential functionality.  Cookie.pm is a shortened
       rehash of the CGI.pm module of the same name which supplies the required  cookie  functionality.  Util.pm
       has been recoded to use an internal object for data storage and supplies rarely needed non core functions
       and/or  functions  needed  for  the  HTML side of things. Standard.pm is a wrapper module that supplies a
       complete functional interface to the OO back end supplied by CGI::Simple.

       Although a serious attempt has been made to keep the interface identical, some minor changes  and  tweaks
       have been made. They will likely be insignificant to most users but here are the gory details.

   <b>Globals</b> <b>Variables</b>
       The  list  of  global variables has been pruned by 75%. Here is the complete list of the global variables
       used:

           $VERSION = "0.01";
           # set this to 1 to use CGI.pm default global settings
           $USE_CGI_PM_DEFAULTS = 0 unless defined $USE_CGI_PM_DEFAULTS;
           # see if user wants old  CGI.pm defaults
           do{ _use_cgi_pm_global_settings(); return } if $USE_CGI_PM_DEFAULTS;
           # no file uploads by default, set to 0 to enable uploads
           $DISABLE_UPLOADS = 1 unless defined $DISABLE_UPLOADS;
           # use a post max of 100K, set to -1 for no limits
           $POST_MAX = 102_400 unless defined $POST_MAX;
           # do not include undefined params parsed from query string
           $NO_UNDEF_PARAMS = 0 unless defined $NO_UNDEF_PARAMS;
           # separate the name=value pairs with ; rather than &amp;
           $USE_PARAM_SEMICOLONS = 0 unless defined $USE_PARAM_SEMICOLONS;
           # only print headers once
           $HEADERS_ONCE = 0 unless defined $HEADERS_ONCE;
           # Set this to 1 to enable NPH scripts
           $NPH = 0 unless defined $NPH;
           # 0 =&gt; no debug, 1 =&gt; from @ARGV,  2 =&gt; from STDIN
           $DEBUG = 0 unless defined $DEBUG;
           # filter out null bytes in param - value pairs
           $NO_NULL  = 1 unless defined $NO_NULL;
           # set behavior when cgi_err() called -1 =&gt; silent, 0 =&gt; carp, 1 =&gt; croak
           $FATAL = -1 unless defined $FATAL;

       Four of the default values of the old CGI.pm variables have been changed.  Unlike CGI.pm which by default
       allows unlimited POST data and file uploads by default CGI::Simple limits POST data  size  to  100kB  and
       denies  file  uploads  by  default.  $USE_PARAM_SEMICOLONS is set to 0 by default so we use (old style) &amp;
       rather than ; as the pair separator for query strings. Debugging is disabled by default.

       There are three new global variables. If $NO_NULL is true (the default) then CGI::Simple will strip  null
       bytes  out of names, values and keywords. Null bytes can do interesting things to C based code like Perl.
       Uploaded files are not touched. $FATAL controls the behavior when <b>cgi_error()</b>  is  called.   The  default
       value  of -1 makes errors silent. $USE_CGI_PM_DEFAULTS reverts the defaults to the CGI.pm standard values
       ie unlimited file uploads via POST for DNS attacks. You can also get  the  defaults  back  by  using  the
       '-default' pragma in the use:

           use CGI::Simple qw(-default);
           use CGI::Simple::Standard qw(-default);

       The values of the global variables are stored in the CGI::Simple object and can be referenced and changed
       using the <b>globals()</b> method like this:

           my $value = $q-&gt;globals( 'VARNAME' );      # get
           $q-&gt;globals( 'VARNAME', 'some value' );    # set

       As with many CGI.pm methods if you pass the optional value that will be set.

       The  $CGI::Simple::VARNAME = 'N' syntax is only useful prior to calling the <b>new()</b> constructor. After that
       all reference is to the values stored in the CGI::Simple object  so  you  must  change  these  using  the
       <b>globals()</b> method.

       $DISABLE_UPLOADS  and $POST_MAX *must* be set prior to calling the constructor if you want the changes to
       have any effect as they control behavior during initialization. This is the same a CGI.pm  although  some
       people  seem  to  miss this rather important point and set these after calling the constructor which does
       nothing.

       The following globals are no longer relevant and have all been deleted:

           $AUTOLOADED_ROUTINES
           $AUTOLOAD_DEBUG
           $BEEN_THERE
           $CRLF
           $DEFAULT_DTD
           $EBCDIC
           $FH
           $FILLUNIT
           $IIS
           $IN
           $INITIAL_FILLUNIT
           $JSCRIPT
           $MAC
           $MAXTRIES
           $MOD_PERL
           $NOSTICKY
           $OS
           $PERLEX
           $PRIVATE_TEMPFILES
           $Q
           $QUERY_CHARSET
           $QUERY_PARAM
           $SCRATCH
           $SL
           $SPIN_LOOP_MAX
           $TIMEOUT
           $TMPDIRECTORY
           $XHTML
           %EXPORT
           %EXPORT_OK
           %EXPORT_TAGS
           %OVERLOAD
           %QUERY_FIELDNAMES
           %SUBS
           @QUERY_PARAM
           @TEMP

       Notes: CGI::Simple uses IO::File-&gt;new_tmpfile to get tempfile filehandles.  These are private by  default
       so  $PRIVATE_TEMPFILES  is  no  longer  required nor is $TMPDIRECTORY. The value that were stored in $OS,
       $CRLF, $QUERY_CHARSET and $EBCDIC are now stored in the CGI::Simple::Util object where they find most  of
       their  use. The $MOD_PERL and $PERLEX values are now stored in our CGI::Simple object. $IIS was only used
       once in <b>path_info()</b>.  $SL the system specific / \ : path delimiter is not required  as  we  let  IO::File
       handle  our  tempfile requirements. The rest of the globals are HTML related, export related, hand rolled
       autoload related or serve obscure purposes in CGI.pm

   <b>Changes</b> <b>to</b> <b>pragmas</b>
       There are some new pragmas available. See the pragmas section for details.  The following CGI.pm  pragmas
       are not available:

           -any
           -compile
           -nosticky
           -no_xhtml
           -private_tempfiles

   <b>Filehandles</b>
       Unlike  CGI.pm  which  tries  to  accept  all  filehandle  like objects only \*FH and $fh are accepted by
       CGI::Simple as file accessors for <b>new()</b> and <b>save()</b>.  IO::File objects work fine.

   <b>Hash</b> <b>interface</b>
           %hash = $q-&gt;Vars();     # pack values with "\0";
           %hash = $q-&gt;Vars(",");  # comma separate values

       You may optionally pass <b>Vars()</b> a string that will be used to  separate  multiple  values  when  they  are
       packed  into  the  single  hash value. If no value is supplied the default "\0" (null byte) will be used.
       Null bytes are dangerous things for C based code (ie Perl).

   <b>cgi-lib.pl</b>
       All the cgi-lib.pl 2.18 routines are supported. Unlike CGI.pm all the  subroutines  from  cgi-lib.pl  are
       included. They have been GOLFED down to 25 lines but they all work pretty much the same as the originals.

</pre><h4><b>CGI::Simple</b> <b>COMPLETE</b> <b>METHOD</b> <b>LIST</b></h4><pre>
       Here is a complete list of all the CGI::Simple methods.

   <b>Guts</b> <b>(hands</b> <b>off,</b> <b>except</b> <b>of</b> <b>course</b> <b>for</b> <b>new)</b>
           _initialize_globals
           _use_cgi_pm_global_settings
           _store_globals
           import
           _reset_globals
           new
           _initialize
           _read_parse
           _parse_params
           _add_param
           _parse_keywordlist
           _parse_multipart
           _save_tmpfile
           _read_data

   <b>Core</b> <b>Methods</b>
           param
           add_param
           param_fetch
           url_param
           keywords
           Vars
           append
           delete
           Delete
           delete_all
           Delete_all
           upload
           upload_info
           query_string
           parse_query_string
           parse_keywordlist

   <b>Save</b> <b>and</b> <b>Restore</b> <b>from</b> <b>File</b> <b>Methods</b>
           _init_from_file
           save
           save_parameters

   <b>Miscellaneous</b> <b>Methods</b>
           url_decode
           url_encode
           escapeHTML
           unescapeHTML
           put
           print

   <b>Cookie</b> <b>Methods</b>
           cookie
           raw_cookie

   <b>Header</b> <b>Methods</b>
           header
           cache
           no_cache
           redirect

   <b>Server</b> <b>Push</b> <b>Methods</b>
           multipart_init
           multipart_start
           multipart_end
           multipart_final

   <b>Debugging</b> <b>Methods</b>
           read_from_cmdline
           Dump
           as_string
           cgi_error

   <b>cgi-lib.pl</b> <b>Compatibility</b> <b>Routines</b> <b>-</b> <b>all</b> <b>2.18</b> <b>functions</b> <b>available</b>
           _shift_if_ref
           ReadParse
           SplitParam
           MethGet
           MethPost
           MyBaseUrl
           MyURL
           MyFullUrl
           PrintHeader
           HtmlTop
           HtmlBot
           PrintVariables
           PrintEnv
           CgiDie
           CgiError

   <b>Accessor</b> <b>Methods</b>
           version
           nph
           all_parameters
           charset
           crlf                # new, returns OS specific CRLF sequence
           globals             # get/set global variables
           auth_type
           content_length
           content_type
           document_root
           gateway_interface
           path_translated
           referer
           remote_addr
           remote_host
           remote_ident
           remote_user
           request_method
           script_name
           server_name
           server_port
           server_protocol
           server_software
           user_name
           user_agent
           virtual_host
           path_info
           Accept
           accept
           http
           https
           protocol
           url
           self_url
           state

</pre><h4><b>NEW</b> <b>METHODS</b> <b>IN</b> <b>CGI::Simple</b></h4><pre>
       There  are  a few new methods in CGI::Simple as listed below. The highlights are the <b>parse_query_string()</b>
       method to add the QUERY_STRING data to your object if the method was POST. The <b>no_cache()</b> method adds  an
       expires  now  directive and the Pragma: no-cache directive to the header to encourage some browsers to do
       the right thing. <b>PrintEnv()</b> from the cgi-lib.pl routines will dump an HTML friendly list of the %ENV  and
       makes  a  handy  addition  to <b>Dump()</b> for use in debugging. The upload method now accepts a filepath as an
       optional second argument as shown in the synopsis. If this is supplied the uploaded file will be  written
       to there automagically.

   <b>Internal</b> <b>Routines</b>
           _initialize_globals()
           _use_cgi_pm_global_settings()
           _store_globals()
           _initialize()
           _init_from_file()
           _read_parse()
           _parse_params()
           _add_param()
           _parse_keywordlist()
           _parse_multipart()
           _save_tmpfile()
           _read_data()

   <b>New</b> <b>Public</b> <b>Methods</b>
           add_param()             # adds a param/value(s) pair +/- overwrite
           upload_info()           # uploaded files MIME type and size
           url_decode()            # decode s url encoded string
           url_encode()            # url encode a string
           parse_query_string()    # add QUERY_STRING data to $q object if 'POST'
           no_cache()              # add both the Pragma: no-cache
                                   # and Expires/Date =&gt; 'now' to header

   <b>cgi-lib.pl</b> <b>methods</b> <b>added</b> <b>for</b> <b>completeness</b>
           _shift_if_ref()         # internal hack reminiscent of self_or_default :-)
           MyBaseUrl()
           MyURL()
           MyFullUrl()
           PrintVariables()
           PrintEnv()
           CgiDie()
           CgiError()

   <b>New</b> <b>Accessors</b>
           crlf()                  # returns CRLF sequence
           globals()               # global vars now stored in $q object - get/set
           content_length()        # returns $ENV{'CONTENT_LENGTH'}
           document_root()         # returns $ENV{'DOCUMENT_ROOT'}
           gateway_interface()     # returns $ENV{'GATEWAY_INTERFACE'}

</pre><h4><b>METHODS</b> <b>IN</b> <b>CGI.pm</b> <b>NOT</b> <b>IN</b> <b>CGI::Simple</b></h4><pre>
       Here is a complete list of what is not included in CGI::Simple. Basically all the HTML related stuff plus
       large redundant chunks of the guts. The check.pl script in the /misc dir will check to see if a script is
       using any of these.

   <b>Guts</b> <b>-</b> <b>rearranged,</b> <b>recoded,</b> <b>renamed</b> <b>and</b> <b>hacked</b> <b>out</b> <b>of</b> <b>existence</b>
           initialize_globals()
           compile()
           expand_tags()
           self_or_default()
           self_or_CGI()
           init()
           to_filehandle()
           save_request()
           parse_params()
           add_parameter()
           binmode()
           _make_tag_func()
           AUTOLOAD()
           _compile()
           _setup_symbols()
           new_MultipartBuffer()
           read_from_client()
           import_names()     # I dislike this and left it out, so shoot me.

   <b>HTML</b> <b>Related</b>
           autoEscape()
           URL_ENCODED()
           MULTIPART()
           SERVER_PUSH()
           start_html()
           _style()
           _script()
           end_html()
           isindex()
           startform()
           start_form()
           end_multipart_form()
           start_multipart_form()
           endform()
           end_form()
           _textfield()
           textfield()
           filefield()
           password_field()
           textarea()
           button()
           submit()
           reset()
           defaults()
           comment()
           checkbox()
           checkbox_group()
           _tableize()
           radio_group()
           popup_menu()
           scrolling_list()
           hidden()
           image_button()
           nosticky()
           default_dtd()

   <b>Upload</b> <b>Related</b>
       CGI::Simple uses anonymous tempfiles supplied by IO::File to spool uploaded files to.

           private_tempfiles() # automatic in CGI::Simple
           tmpFileName()       # all upload files are anonymous
           uploadInfo()        # relied on FH access, replaced with upload_info()

   <b>Really</b> <b>Private</b> <b>Subs</b> <b>(marked</b> <b>as</b> <b>so)</b>
           previous_or_default()
           register_parameter()
           get_fields()
           _set_values_and_labels()
           _compile_all()
           asString()
           compare()

   <b>Internal</b> <b>Multipart</b> <b>Parsing</b> <b>Routines</b>
           read_multipart()
           readHeader()
           readBody()
           read()
           fillBuffer()
           eof()

</pre><h4><b>EXPORT</b></h4><pre>
       Nothing.

</pre><h4><b>AUTHOR</b> <b>INFORMATION</b></h4><pre>
       Originally  copyright  2001  Dr  James  Freeman  &lt;<a href="mailto:jfreeman@tassie.net.au">jfreeman@tassie.net.au</a>&gt;  This release by Andy Armstrong
       &lt;<a href="mailto:andy@hexten.net">andy@hexten.net</a>&gt;

       This package is free software and is provided "as is" without express or  implied  warranty.  It  may  be
       used,   redistributed   and/or   modified   under   the   terms   of   the  Perl  Artistic  License  (see
       <a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>)

       Address bug reports and comments to: <a href="mailto:andy@hexten.net">andy@hexten.net</a>.  When  sending  bug  reports,  please  provide  the
       version  of  CGI::Simple,  the version of Perl, the name and version of your Web server, and the name and
       version of the operating system you are using.  If the problem is even remotely browser dependent, please
       provide information about the affected browsers as well.

       Address bug reports and comments to: <a href="mailto:andy@hexten.net">andy@hexten.net</a>

</pre><h4><b>CREDITS</b></h4><pre>
       Lincoln D. Stein (<a href="mailto:lstein@cshl.org">lstein@cshl.org</a>) and everyone else who worked on the original CGI.pm  upon  which  this
       module is heavily based

       Brandon Black for some heavy duty testing and bug fixes

       John  D Robinson and Jeroen Latour for helping solve some interesting test failures as well as Perlmonks:
       tommyw, grinder, Jaap, vek, erasei, jlongino and strider_corinth

       Thanks for patches to:

       Ewan Edwards, Joshua N Pritikin, Mike Barry, Michael Nachbaur, Chris Williams,  Mark  Stosberg,  Krasimir
       Berov, Yamada Masahiro

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2007, Andy Armstrong "&lt;<a href="mailto:andy@hexten.net">andy@hexten.net</a>&gt;". All rights reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself. See perlartistic.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>CGI</b>, CGI::Simple::Standard, CGI::Simple::Cookie, CGI::Simple::Util, CGI::Minimal

perl v5.38.2                                       2024-02-04                                   <u>CGI::<a href="../man3pm/Simple.3pm.html">Simple</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>