<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Easy - Easy to Use DBI interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-easy-perl">libdbix-easy-perl_0.21-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Easy - Easy to Use DBI interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use DBIx::Easy;
         my $dbi_interface = new DBIx::Easy qw(Pg template1);

         $dbi_interface -&gt; insert ('transaction',
                          id =&gt; serial ('transaction', 'transactionid'),
                          time =&gt; \$dbi_interface -&gt; now);

         $dbi_interface -&gt; update ('components', "table='ram'", price =&gt; 100);
         $rows_deleted = $dbi_interface -&gt; delete ('components', 'stock = 0');
         $dbi_interface -&gt; makemap ('components', 'id', 'price', 'price &gt; 10');
         $components = $dbi_interface -&gt; rows ('components');
         $components_needed = $dbi_interface -&gt; rows ('components', 'stock = 0');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       DBIx::Easy is an easy to use DBI interface.  Currently the Pg, mSQL, mysql, Sybase, ODBC and XBase
       drivers are supported.

</pre><h4><b>CREATING</b> <b>A</b> <b>NEW</b> <b>DBI</b> <b>INTERFACE</b> <b>OBJECT</b></h4><pre>
         $dbi_interface = new DBIx::Easy qw(Pg template1);
         $dbi_interface = new DBIx::Easy qw(Pg template1 racke);
         $dbi_interface = new DBIx::Easy qw(Pg template1 racke aF3xD4_i);
         $dbi_interface = new DBIx::Easy qw(Pg template1 <a href="mailto:racke@linuxia.de">racke@linuxia.de</a> aF3xD4_i);
         $dbi_interface = new DBIx::Easy qw(Pg template1 <a href="mailto:racke@linuxia.de">racke@linuxia.de</a>:3306 aF3xD4_i);

       The required parameters are the database driver and the database name. Additional parameters are the
       database user and the password to access the database. To specify the database host use the USER@HOST
       notation for the user parameter. If you want to specify the port to connect to use USER@HOST:PORT.

</pre><h4><b>DESTROYING</b> <b>A</b> <b>DBI</b> <b>INTERFACE</b> <b>OBJECT</b></h4><pre>
       It is important that you commit all changes at the end of the interaction with the DBMS. You can either
       explicitly commit

         $dbi_interface -&gt; commit ();

       or do it implicitly:

         undef $dbi_interface;

</pre><h4><b>ERROR</b> <b>HANDLING</b></h4><pre>
         sub fatal {
           my ($statement, $err, $msg) = @_;
           die ("$0: Statement \"$statement\" failed (ERRNO: $err, ERRMSG: $msg)\n");
         }
         $dbi_interface -&gt; install_handler (\&amp;fatal);

       If any of the DBI methods fails, either <u>die</u> will be invoked or an error handler installed with
       <u>install_handler</u> will be called.

</pre><h4><b>CACHING</b> <b>ISSUES</b></h4><pre>
       By default, this module caches table structures. This can be disabled by setting
       <u>$DBIx::Easy::cache_structs</u> to 0.

</pre><h4><b>XBASE</b> <b>DRIVER</b></h4><pre>
       The DBIx::Easy method rows fails to work with the DBD::XBase driver.

</pre><h4><b>METHODS</b></h4><pre>
   <b>DATABASE</b> <b>ACCESS</b>
       process <u>statement</u>
             $sth = $dbi_interface -&gt; process ("SELECT * FROM foo");
             print "Table foo contains ", $sth -&gt; rows, " rows.\n";

           Processes  <u>statement</u>  by  just  combining the <u>prepare</u> and <u>execute</u> steps of the DBI. Returns statement
           handle in case of success.

       insert <u>table</u> <u>column</u> <u>value</u> [<u>column</u> <u>value</u>] ...
             $sth = $dbi_interface -&gt; insert ('bar', drink =&gt; 'Caipirinha');

           Inserts the given <u>column</u>/<u>value</u> pairs into <u>table</u>. Determines from the SQL data type which  values  has
           to been quoted. Just pass a reference to the value to protect values with SQL functions from quoting.

       update <u>table</u> <u>conditions</u> <u>column</u> <u>value</u> [<u>column</u> <u>value</u>] ...
             $dbi_interface -&gt; update ('components', "table='ram'", price =&gt; 100);
             $dbi_interface -&gt; update ('components', "table='ram'", price =&gt; \"price + 20");

           Updates  any  row  of  <u>table</u>  which fulfill the <u>conditions</u> by inserting the given <u>column</u>/<u>value</u> pairs.
           Scalar references can be used to embed  strings  without  further  quoting  into  the  resulting  SQL
           statement. Returns the number of rows modified.

       put <u>table</u> <u>conditions</u> <u>column</u> <u>value</u> [<u>column</u> <u>value</u>] ...
       delete <u>table</u> <u>conditions</u>
             $dbi_interface -&gt; delete ('components', "stock=0");

           Deletes  any  row  of  <u>table</u>  which  fulfill the <u>conditions</u>. Without conditions all rows are deleted.
           Returns the number of rows deleted.

       do_without_transaction <u>statement</u>
             $sth = $dbi_interface -&gt; do_without_transaction ("CREATE DATABASE foo");

             Issues a DBI do statement while forcing autocommit. This is used for
             statements that can't be run in transaction mode (like CREATE DATABASE
             in PostgreSQL).

       rows <u>table</u> [<u>conditions</u>]
             $components = $dbi_interface -&gt; rows ('components');
             $components_needed = $dbi_interface -&gt; rows ('components', 'stock = 0');

           Returns the number of rows within <u>table</u> satisfying <u>conditions</u> if any.

       makemap <u>table</u> <u>keycol</u> <u>valcol</u> [<u>condition</u>]
               $dbi_interface -&gt; makemap ('components', 'idf', 'price');
               $dbi_interface -&gt; makemap ('components', 'idf', 'price', 'price &gt; 10');
               $dbi_interface -&gt; makemap ('components', 'idf', '*');
               $dbi_interface -&gt; makemap ('components', 'idf', '*', 'price &gt; 10');

           Produces a mapping between the values within column <u>keycol</u>  and  column  <u>valcol</u>  from  <u>table</u>.  If  an
           <u>condition</u> is given, only rows matching this <u>condition</u> are used for the mapping.

           In  order  to  get  the hash reference to the record as value of the mapping, use the asterisk as the
           <u>valcol</u> parameter.

       random_row <u>table</u> <u>conditions</u> [<u>map</u>]
           Returns random row of the specified <u>table</u>. If <u>map</u> is set, the result  is  a  hash  reference  of  the
           selected  row,  otherwise  an  array  reference.  If  the  table  doesn't contains rows, undefined is
           returned.

       serial <u>table</u> <u>sequence</u>
           Returns a serial number for <u>table</u> by querying the next value from <u>sequence</u>. Depending on the DBMS one
           of the parameters is ignored.  This is <u>sequence</u> for mSQL resp. <u>table</u> for  PostgreSQL.  mysql  doesn't
           support sequences, but the AUTO_INCREMENT keyword for fields.  In this case this method returns 0 and
           mysql generates a serial number for this field.

       fill <u>sth</u> <u>hashref</u> [<u>flag</u> <u>column</u> ...]
           Fetches  the  next  table  row from the result stored into <u>sth</u> and records the value of each field in
           <u>hashref</u>. If <u>flag</u> is set, only the fields specified by the <u>column</u> arguments are considered,  otherwise
           the fields specified by the <u>column</u> arguments are omitted.

       view <u>table</u> [<u>name</u> <u>value</u> ...]
             foreach my $table (sort $dbi_interface -&gt; tables)
               {
               print $cgi -&gt; h2 ('Contents of ', $cgi -&gt; code ($table));
               print $dbi_interface -&gt; view ($table);
               }

           Produces  plain  text  representation  of the database table <u>table</u>. This method accepts the following
           options as <u>name</u>/<u>value</u> pairs:

           <b>columns</b>: Which columns to display.

           <b>order</b>: Which column to sort the row after.

           <b>limit</b>: Maximum number of rows to display.

           <b>separator</b>: Separator inserted between the columns.

           <b>where</b>: Display only rows matching this condition.

             print $dbi_interface -&gt; view ($table,
                                           order =&gt; $cgi -&gt; param ('order') || '',
                                           where =&gt; "price &gt; 0");

   <b>DATABASE</b> <b>INFORMATION</b>
       is_table <u>NAME</u>
           Returns truth value if there exists a table <u>NAME</u> in this database.

       tables
           Returns list of all tables in this database.

       sequences
           Returns list of all sequences in this database (Postgres only).

       columns <u>TABLE</u>
           Returns list of the column names of <u>TABLE</u>.

       types <u>TABLE</u>
           Returns list of the column types of <u>TABLE</u>.

       sizes <u>TABLE</u>
           Returns list of the column sizes of <u>TABLE</u>.

       typemap <u>TABLE</u>
           Returns mapping between column names and column types for table <u>TABLE</u>.

       sizemap <u>TABLE</u>
           Returns mapping between column names and column sizes for table <u>TABLE</u>.

   <b>TIME</b> <b>VALUES</b>
       now
             $dbi_interface -&gt; insert ('transaction',
                              id =&gt; serial ('transaction', 'transactionid'),
                              time =&gt; \$dbi_interface -&gt; now);

           Returns representation for the current time. Uses special values of the DBMS if possible.

   <b>MONETARY</b> <b>VALUES</b>
       money2num <u>money</u>
           Converts the monetary value <u>money</u> to a numeric one.

   <b>MISCELLANEOUS</b>
       is_auth_error <u>msg</u>
           This method decides if the error message <u>msg</u> is caused by an authentification error or not.

</pre><h4><b>AUTHORS</b></h4><pre>
       Stefan Hornburg (Racke), <a href="mailto:racke@linuxia.de">racke@linuxia.de</a> Dennis Sch\[:o]n, <a href="mailto:ds@1d10t.de">ds@1d10t.de</a>

       Support for Sybase and ODBC provided by David B. Bitton &lt;<a href="mailto:david@codenoevil.com">david@codenoevil.com</a>&gt;.

</pre><h4><b>VERSION</b></h4><pre>
       0.20

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b><a href="../man3/DBI.3.html">DBI</a></b>(3), <b>DBD::<a href="../man3/Pg.3.html">Pg</a></b>(3), <b>DBD::<a href="../man3/mysql.3.html">mysql</a></b>(3), <b>DBD::<a href="../man3/msql.3.html">msql</a></b>(3), <b>DBD::<a href="../man3/Sybase.3.html">Sybase</a></b>(3), <b>DBD::<a href="../man3/ODBC.3.html">ODBC</a></b>(3).

perl v5.40.1                                       2025-08-11                                          <u><a href="../man3pm/Easy.3pm.html">Easy</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>