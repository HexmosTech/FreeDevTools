<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Simple::Examples - Examples of how to use DBIx::Simple</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-simple-perl">libdbix-simple-perl_1.37-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Simple::Examples - Examples of how to use DBIx::Simple

</pre><h4><b>DESCRIPTION</b></h4><pre>
       DBIx::Simple provides a simplified interface to DBI, Perl's powerful database module.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>General</b>
           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
           use strict;
           use DBIx::Simple;

           # Instant database with DBD::SQLite
           my $db = DBIx::Simple-&gt;connect('dbi:SQLite:dbname=file.dat')
               or die DBIx::Simple-&gt;error;

           # Connecting to a MySQL database
           my $db = DBIx::Simple-&gt;connect(
               'DBI:mysql:database=test',     # DBI source specification
               'test', 'test',                # Username and password
               { RaiseError =&gt; 1 }            # Additional options
           );

           # Using an existing database handle
           my $db = DBIx::Simple-&gt;connect($dbh);

           # Abstracted example: $db-&gt;query($query, @variables)-&gt;what_you_want;

           $db-&gt;commit or die $db-&gt;error;

   <b>Simple</b> <b>Queries</b>
           $db-&gt;query('DELETE FROM foo WHERE id = ?', $id) or die $db-&gt;error;

           for (1..100) {
               $db-&gt;query(
                   'INSERT INTO randomvalues VALUES (?, ?)',
                   int <a href="../man10/rand.10.html">rand</a>(10),
                   int <a href="../man10/rand.10.html">rand</a>(10)
               ) or die $db-&gt;error;
           }

           $db-&gt;query(
               'INSERT INTO sometable VALUES (??)',
               $first, $second, $third, $fourth, $fifth, $sixth
           );
           # (??) is expanded to (?, ?, ?, ?, ?, ?) automatically

   <b>Single</b> <b>row</b> <b>queries</b>
           my ($two)          = $db-&gt;query('SELECT 1 + 1')-&gt;list;
           my ($three, $four) = $db-&gt;query('SELECT 3, 2 + 2')-&gt;list;

           my ($name, $email) = $db-&gt;query(
               'SELECT name, email FROM people WHERE email = ? LIMIT 1',
               $mail
           )-&gt;list;

       Or, more efficiently:

           $db-&gt;query('SELECT 1 + 1')-&gt;into(my $two);
           $db-&gt;query('SELECT 3, 2 + 2')-&gt;into(my ($three, $four));

           $db-&gt;query(
               'SELECT name, email FROM people WHERE email = ? LIMIT 1',
               $mail
           )-&gt;into(my ($name, $email));

   <b>Fetching</b> <b>all</b> <b>rows</b> <b>in</b> <b>one</b> <b>go</b>
       <u>One</u> <u>big</u> <u>flattened</u> <u>list</u> <u>(primarily</u> <u>for</u> <u>single</u> <u>column</u> <u>queries)</u>

           my @names = $db-&gt;query('SELECT name FROM people WHERE id &gt; 5')-&gt;flat;

       <u>Rows</u> <u>as</u> <u>array</u> <u>references</u>

           for my $row ($db-&gt;query('SELECT name, email FROM people')-&gt;arrays) {
               print "Name: $row-&gt;[0], Email: $row-&gt;[1]\n";
           }

       <u>Rows</u> <u>as</u> <u>hash</u> <u>references</u>

           for my $row ($db-&gt;query('SELECT name, email FROM people')-&gt;hashes) {
               print "Name: $row-&gt;{name}, Email: $row-&gt;{email}\n";
           }

   <b>Fetching</b> <b>one</b> <b>row</b> <b>at</b> <b>a</b> <b>time</b>
       <u>Rows</u> <u>into</u> <u>separate</u> <u>variables</u>

           {
               my $result = $db-&gt;query('SELECT name, email FROM people');
               $result-&gt;bind(my ($name, $email));
               while ($result-&gt;fetch) {
                   print "Name: $name, Email: $email\n";
               }
           }

       or:

           {
               my $result = $db-&gt;query('SELECT name, email FROM people');
               while ($result-&gt;into(my ($name, $email))) {
                   print "Name: $name, Email: $email\n";
               }
           }

       <u>Rows</u> <u>as</u> <u>lists</u>

           {
               my $result = $db-&gt;query('SELECT name, email FROM people');
               while (my @row = $result-&gt;list) {
                   print "Name: $row[0], Email: $row[1]\n";
               }
           }

       <u>Rows</u> <u>as</u> <u>array</u> <u>references</u>

           {
               my $result = $db-&gt;query('SELECT name, email FROM people');
               while (my $row = $result-&gt;array) {
                   print "Name: $row-&gt;[0], Email: $row-&gt;[1]\n";
               }
           }

       <u>Rows</u> <u>as</u> <u>hash</u> <u>references</u>

           {
               my $result = $db-&gt;query('SELECT name, email FROM people');
               while (my $row = $result-&gt;hash) {
                   print "Name: $row-&gt;{name}, Email: $row-&gt;{email}\n";
               }
           }

   <b>Building</b> <b>maps</b> <b>(also</b> <b>fetching</b> <b>all</b> <b>rows</b> <b>in</b> <b>one</b> <b>go)</b>
       <u>map</u>

       A hash of hashes

           my $customers =
               $db
               -&gt; query('SELECT id, name, location FROM people')
               -&gt; map_hashes('id');

           # $customers = { $id =&gt; { name =&gt; $name, location =&gt; $location }, ... }

       A hash of arrays

           my $customers =
               $db
               -&gt; query('SELECT id, name, location FROM people')
               -&gt; <a href="../man0/map_arrays.0.html">map_arrays</a>(0);

           # $customers = { $id =&gt; [ $name, $location ], ... }

       A hash of values (two-column queries)

           my $names =
               $db
               -&gt; query('SELECT id, name FROM people')
               -&gt; map;

           # $names = { $id =&gt; $name, ... }

       <u>group</u>

       A hash of arrays of hashes

           my $customers =
               $db
               -&gt; query('SELECT id, name, location FROM people')
               -&gt; group_hashes('location');

           # $customers = { $location =&gt; [ { id =&gt; $id, name =&gt; $name }, ... ], ... }

       A hash of arrays of arrays

           my $customers =
               $db
               -&gt; query('SELECT id, name, location FROM people')
               -&gt; <a href="../man2/group_arrays.2.html">group_arrays</a>(2);

           # $customers = { $location =&gt; [ [ $id, $name ], ... ], ... }

       A hash of arrays of values (two-column queries)

           my $names =
               $db
               -&gt; query('SELECT location, name FROM people')
               -&gt; group;

           # $names = { $location =&gt; [ $name, $name, ... ], ... }

</pre><h4><b>EXAMPLES</b> <b>WITH</b> <b>SQL::Interp</b></h4><pre>
       If you have SQL::Interp installed, you can use the semi-abstracting method "iquery". This works just like
       "query", but with parts of the query interleaved with the bind arguments, passed as references.

       You should read SQL::Interp. These examples are not enough to fully understand all the possibilities.

       The following examples are based on the documentation of SQL::Interp.

           my $result = $db-&gt;iquery('INSERT INTO table', \%item);
           my $result = $db-&gt;iquery('UPDATE table SET', \%item, 'WHERE y &lt;&gt; ', \2);
           my $result = $db-&gt;iquery('DELETE FROM table WHERE y = ', \2);

           # These two select syntax produce the same result
           my $result = $db-&gt;iquery('SELECT * FROM table WHERE x = ', \$s, 'AND y IN', \@v);
           my $result = $db-&gt;iquery('SELECT * FROM table WHERE', {x =&gt; $s, y =&gt; \@v});

           for ($result-&gt;hashes) { ... }

       Use a syntax highlighting editor for good visual distinction.

       If you need the helper functions "sql" and "sql_type", you can import them with "use SQL::Interp;"

</pre><h4><b>EXAMPLES</b> <b>WITH</b> <b>SQL::Abstract</b></h4><pre>
       If you have SQL::Abstract installed, you can use the abstracting methods "select", "insert", "update",
       "delete". These work like "query", but instead of a query and bind arguments, use abstracted arguments.

       You should read SQL::Abstract. These examples are not enough to fully understand all the possibilities.

       The SQL::Abstract object is available (writable) through the "abstract" property.

       The following examples are based on the documentation of SQL::Abstract.

   <b>Overview</b>
       If you don't like the defaults, just assign a new object:

           $db-&gt;abstract = SQL::Abstract-&gt;new(
               case    =&gt; 'lower',
               cmp     =&gt; 'like',
               logic   =&gt; 'and',
               convert =&gt; 'upper'
           );

       If you don't assign any object, one will be created automatically using the default options. The
       SQL::Abstract module is loaded on demand.

           my $result = $db-&gt;select($table, \@fields, \%where, \@order);
           my $result = $db-&gt;insert($table, \%fieldvals || \@values);
           my $result = $db-&gt;update($table, \%fieldvals, \%where);
           my $result = $db-&gt;delete($table, \%where);

           for ($result-&gt;hashes) { ... }

   <b>Complete</b> <b>examples</b>
       <u>select</u>

           my @tickets = $db-&gt;select(
               'tickets', '*', {
                   requestor =&gt; 'inna',
                   worker    =&gt; ['nwiger', 'rcwe', 'sfz'],
                   status    =&gt; { '!=', 'completed' }
               }
           )-&gt;hashes;

       <u>insert</u>

       If you already have your data as a hash, inserting becomes much easier:

           $db-&gt;insert('people', \%data);

       Instead of:

           $db-&gt;query(
               q[
                   INSERT
                   INTO people (name, phone, address, ...)
                   VALUES (??)
               ],
               @data{'name', 'phone', 'address', ... }
           );

       <u>update,</u> <u>delete</u>

           $db-&gt;update(
               'tickets', {
                   worker    =&gt; 'juerd',
                   status    =&gt; 'completed'
               },
               { id =&gt; $id }
           )

           $db-&gt;delete('tickets', { id =&gt; $id });

       <u>where</u>

       The "where" method is not wrapped directly, because it doesn't generate a query and thus doesn't really
       have anything to do with the database module.

       But using the "abstract" property, you can still easily access it:

           my $where = $db-&gt;abstract-&gt;where({ foo =&gt; $foo });

</pre><h4><b>EXAMPLES</b> <b>WITH</b> <b>DBIx::XHTML_Table</b></h4><pre>
       If you have DBIx::XHTML_Table installed, you can use the result methods "xto" and "html".

       You should read DBIx::XHTML_Table. These examples are not enough to fully understand what is going on.
       When reading that documentation, note that you don't have to pass hash references to DBIx::Simple's
       methods. It is supported, though.

       DBIx::XHTML_Table is loaded on demand.

   <b>Overview</b>
       To print a simple table, all you have to do is:

           print $db-&gt;query('SELECT * FROM foo')-&gt;html;

       Of course, anything that produces a result object can be used. The same thing using the abstraction
       method "select" would be:

           print $db-&gt;select('foo', '*')-&gt;html;

       A DBIx::XHTML_Table object can be generated with the "xto" (<b>X</b>HTML_<b>T</b>able <b>O</b>bject) method:

           my $table = $db-&gt;query($query)-&gt;xto;

   <b>Passing</b> <b>attributes</b>
       DBIx::Simple sends the attributes you pass to "html" both to the constructor and the output method. This
       allows you to specify both HTML attributes (like "bgcolor") and options for XHTML_Table (like
       "no_ucfirst" and "no_indent") all at once:

           print $result-&gt;html(
               tr         =&gt; { bgcolor =&gt; [ qw/silver white/ ] },
               no_ucfirst =&gt; 1
           );

   <b>Using</b> <b>an</b> <b>XHTML_Table</b> <b>object</b>
       Not everything can be controlled by passing attributes. For full flexibility, the XHTML_Table object can
       be used directly:

           my $table = $db-&gt;query($query)-&gt;xto(
               tr =&gt; { bgcolor =&gt; [ qw/silver white/ ] }
           );

           $table-&gt;set_group('client', 1);
           $table-&gt;calc_totals('credit', '%.2f');

           print $table-&gt;output({ no_ucfirst =&gt; 1 });  # note the {}!

</pre><h4><b>EXAMPLES</b> <b>WITH</b> <b>Text::Table</b></h4><pre>
       "$result-&gt;text("neat")"
               Neither neat nor pretty, but useful for debugging. Uses DBI's "neat_list" method. Doesn't display
               column names.

                   '1', 'Camel', 'mammal'
                   '2', 'Llama', 'mammal'
                   '3', 'Owl', 'bird'
                   '4', 'Juerd', undef

       "$result-&gt;text("table")"
               Displays a simple table using ASCII lines.

                   id | animal |  type
                   ---+--------+-------
                    1 |  Camel | mammal
                    2 |  Llama | mammal
                    3 |  Owl   | bird
                    4 |  Juerd |

       "$result-&gt;text("box")"
               Displays a simple table using ASCII lines, with an outside border.

                   +----+--------+--------+
                   | id | animal |  type  |
                   +----+--------+--------+
                   |  1 |  Camel | mammal |
                   |  2 |  Llama | mammal |
                   |  3 |  Owl   | bird   |
                   |  4 |  Juerd |        |
                   +----+--------+--------+

       For "table" and "box", you need Anno Siegel's Text::Table module installed.

</pre><h4><b>AUTHOR</b></h4><pre>
       Juerd Waalboer &lt;<a href="mailto:juerd@cpan.org">juerd@cpan.org</a>&gt; &lt;<a href="http://juerd.nl/">http://juerd.nl/</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       DBIx::Simple, SQL::Abstract

perl v5.36.0                                       2023-09-01                        <u>DBIx::Simple::<a href="../man3pm/Examples.3pm.html">Examples</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>