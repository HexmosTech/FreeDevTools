<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URI::Fetch - Smart URI fetching/caching</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liburi-fetch-perl">liburi-fetch-perl_0.15-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       URI::Fetch - Smart URI fetching/caching

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use URI::Fetch;

           ## Simple fetch.
           my $res = URI::Fetch-&gt;fetch('<a href="http://example.com/atom.xml">http://example.com/atom.xml</a>')
               or die URI::Fetch-&gt;errstr;
           do_something($res-&gt;content) if $res-&gt;is_success;

           ## Fetch using specified ETag and Last-Modified headers.
           $res = URI::Fetch-&gt;fetch('<a href="http://example.com/atom.xml">http://example.com/atom.xml</a>',
                   ETag =&gt; '123-ABC',
                   LastModified =&gt; time - 3600,
           )
               or die URI::Fetch-&gt;errstr;

           ## Fetch using an on-disk cache that URI::Fetch manages for you.
           my $cache = Cache::File-&gt;new( cache_root =&gt; '/tmp/cache' );
           $res = URI::Fetch-&gt;fetch('<a href="http://example.com/atom.xml">http://example.com/atom.xml</a>',
                   Cache =&gt; $cache
           )
               or die URI::Fetch-&gt;errstr;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>URI::Fetch</u> is a smart client for fetching HTTP pages, notably syndication feeds (RSS, Atom, and others),
       in an intelligent, bandwidth- and time-saving way. That means:

       •   GZIP support

           If  you  have  <u>Compress::Zlib</u>  installed,  <u>URI::Fetch</u> will automatically try to download a compressed
           version of the content, saving bandwidth (and time).

       •   <u>Last-Modified</u> and <u>ETag</u> support

           If you use a local cache (see the <u>Cache</u> parameter to <u>fetch</u>), <u>URI::Fetch</u> will keep track of the  <u>Last-</u>
           <u>Modified</u>  and  <u>ETag</u>  headers  from  the  server,  allowing  you to only download pages that have been
           modified since the last time you checked.

       •   Proper understanding of HTTP error codes

           Certain HTTP error codes are special, particularly when fetching syndication feeds, and  well-written
           clients should pay special attention to them.  <u>URI::Fetch</u> can only do so much for you in this regard,
           but it gives you the tools to be a well-written client.

           The response from <u>fetch</u> gives you the raw HTTP response code, along with special handling of 4 codes:

           •   200 (OK)

               Signals that the content of a page/feed was retrieved successfully.

           •   301 (Moved Permanently)

               Signals that a page/feed has moved permanently, and that your database of feeds should be updated
               to reflect the new URI.

           •   304 (Not Modified)

               Signals that a page/feed has not changed since it was last fetched.

           •   410 (Gone)

               Signals  that  a  page/feed  is  gone and will never be coming back, so you should stop trying to
               fetch it.

   <b>Change</b> <b>from</b> <b>0.09</b>
       If you make a request using a cache and get back a 304 response code (Not Modified), then if the  content
       was  returned from the cache, then "is_success()" will return true, and "$response-&gt;content" will contain
       the cached content.

       I think this is the right behaviour, given the philosophy of "URI::Fetch", but please let me (NEILB) know
       if you disagree.

</pre><h4><b>USAGE</b></h4><pre>
   <b>URI::Fetch-&gt;fetch($uri,</b> <b>%param)</b>
       Fetches a page identified by the URI <u>$uri</u>.

       On success, returns a <u>URI::Fetch::Response</u> object; on failure, returns "undef".

       <u>%param</u> can contain:

       •   LastModified

       •   ETag

           <u>LastModified</u> and <u>ETag</u> can be supplied to force the server to  only  return  the  full  page  if  it's
           changed since the last request. If you're writing your own feed client, this is recommended practice,
           because it limits both your bandwidth use and the server's.

           If  you'd  rather  not have to store the <u>LastModified</u> time and <u>ETag</u> yourself, see the <u>Cache</u> parameter
           below (and the SYNOPSIS above).

       •   Cache

           If you'd like <u>URI::Fetch</u> to cache responses between requests, provide the  <u>Cache</u>  parameter  with  an
           object  supporting  the  Cache  API  (e.g.  <u>Cache::File</u>, <u>Cache::Memory</u>). Specifically, an object that
           supports "$cache-&gt;get($key)" and "$cache-&gt;set($key, $value, $expires)".

           If supplied, <u>URI::Fetch</u> will store the page content, ETag, and last-modified time of the response  in
           the cache, and will pull the content from the cache on subsequent requests if the page returns a Not-
           Modified response.

       •   UserAgent

           Optional.   You  may  provide your own LWP::UserAgent instance.  Look into LWPx::ParanoidUserAgent if
           you're fetching URLs given to you by possibly malicious parties.

       •   NoNetwork

           Optional.    Controls   the   interaction   between   the    cache    and    HTTP    requests    with
           If-Modified-Since/If-None-Match headers.  Possible behaviors are:

           false (default)
               If  a  page  is in the cache, the origin HTTP server is always checked for a fresher copy with an
               If-Modified-Since and/or If-None-Match header.

           1   If set to 1, the origin HTTP is never contacted, regardless of the page being in  cache  or  not.
               If  the page is missing from cache, the fetch method will return undef.  If the page is in cache,
               that page will be returned, no matter how old it is.  Note that setting  this  option  means  the
               URI::Fetch::Response object will never have the http_response member set.

           "N", where N &gt; 1
               The  origin HTTP server is not contacted <b>if</b> the page is in cache <b>and</b> the cached page was inserted
               in the last N seconds.  If the cached copy is older than N seconds, a normal HTTP  request  (full
               or cache check) is done.

       •   ContentAlterHook

           Optional.   A  subref  that gets called with a scalar reference to your content so you can modify the
           content before it's returned and before it's put in cache.

           For instance, you may want to only cache the &lt;head&gt; section of an HTML document, or you may  want  to
           take a feed URL and cache only a pre-parsed version of it.  If you modify the scalarref given to your
           hook  and  change  it  into  a  hashref,  scalarref,  or some blessed object, that same value will be
           returned to you later on not-modified responses.

       •   CacheEntryGrep

           Optional.  A subref that gets called with the <u>URI::Fetch::Response</u> object about to  be  cached  (with
           the  contents already possibly transformed by your "ContentAlterHook").  If your subref returns true,
           the page goes into the cache.  If false, it doesn't.

       •   Freeze

       •   Thaw

           Optional. Subrefs that get called to serialize and deserialize, respectively, the data that  will  be
           cached.  The  cached  data  should  be  assumed  to  be  an arbitrary Perl data structure, containing
           (potentially) references to arrays, hashes, etc.

           Freeze should serialize the structure into a scalar; Thaw should deserialize the scalar into  a  data
           structure.

           By default, <u>Storable</u> will be used for freezing and thawing the cached data structure.

       •   ForceResponse

           Optional.  A  boolean that indicates a <u>URI::Fetch::Response</u> should be returned regardless of the HTTP
           status. By default "undef" is returned when a response is not a "success" (200 codes) or one  of  the
           recognized  HTTP  status  codes listed above. The HTTP status message can then be retreived using the
           "errstr" method on the class.

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;https://github.com/neilbowers/URI-Fetch&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       <u>URI::Fetch</u> is free software; you may redistribute it and/or modify  it  under  the  same  terms  as  Perl
       itself.

</pre><h4><b>AUTHOR</b> <b>&amp;</b> <b>COPYRIGHT</b></h4><pre>
       Except  where  otherwise noted, <u>URI::Fetch</u> is Copyright 2004 Benjamin Trott, ben+<a href="mailto:cpan@stupidfool.org">cpan@stupidfool.org</a>. All
       rights reserved.

       Currently maintained by Neil Bowers.

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Tim Appnel

       •   Mario Domgoergen

       •   Karen Etheridge

       •   Brad Fitzpatrick

       •   Jason Hall

       •   Naoya Ito

       •   Tatsuhiko Miyagawa

perl v5.32.1                                       2021-09-16                                    <u>URI::<a href="../man3pm/Fetch.3pm.html">Fetch</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>