<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cprof - A simple Call Count Profiling Tool using breakpoints for minimal runtime performance impact.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cprof - A simple Call Count Profiling Tool using breakpoints for minimal runtime performance impact.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>cprof</u> module is used to profile a program to find out how many times different functions are called.
       Breakpoints similar to local call  trace,  but  containing  a  counter,  are  used  to  minimise  runtime
       performance impact.

       Since breakpoints are used there is no need for special compilation of any module to be profiled. For now
       these breakpoints can only be set on BEAM code so BIFs cannot be call count traced.

       The size of the call counters is the host machine word size. One bit is used when pausing the counter, so
       the maximum counter value for a 32-bit host is 2147483647.

       The  profiling  result  is  delivered as a term containing a sorted list of entries, one per module. Each
       module entry contains a sorted list of functions. The sorting order in both cases is of  decreasing  call
       count.

       Call  count  tracing is very lightweight compared to other forms of tracing since no trace message has to
       be generated. Some measurements indicates performance degradation in the vicinity of 10 percent.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>analyse()</b> <b>-&gt;</b>
                  {AllCallCount :: integer() &gt;= 0,
                   ModAnalysisList :: mod_analysis_list()}

       <b>analyse(Limit)</b> <b>-&gt;</b>
                  {AllCallCount :: integer() &gt;= 0,
                   ModAnalysisList :: mod_analysis_list()}

       <b>analyse(Mod)</b> <b>-&gt;</b> <b>ModAnalysis</b> <b>::</b> <b>mod_analysis()</b>

       <b>analyse(Mod,</b> <b>Limit)</b> <b>-&gt;</b> <b>ModAnalysis</b> <b>::</b> <b>mod_analysis()</b>

              Types:

                 Mod = module()
                 Limit = integer() &gt;= 0
                 <b>mod_analysis_list()</b> = [mod_analysis()]
                 <b>mod_analysis()</b> =
                     {Mod :: module(),
                      ModCallCount :: integer() &gt;= 0,
                      FuncAnalysisList :: func_analysis_list()}
                 <b>func_analysis_list()</b> =
                     [{mfa(), FuncCallCount :: integer() &gt;= 0}]

              Collects and analyses the call counters presently in the node for either module <u>Mod</u>,  or  for  all
              modules (except <u>cprof</u> itself), and returns:

                <u>FuncAnalysisList</u>:
                  A list of tuples, one for each function in a module, in decreasing <u>FuncCallCount</u> order.

                <u>ModCallCount</u>:
                  The sum of <u>FuncCallCount</u> values for all functions in module <u>Mod</u>.

                <u>AllCallCount</u>:
                  The sum of <u>ModCallCount</u> values for all modules concerned in <u>ModAnalysisList</u>.

                <u>ModAnalysisList</u>:
                  A list of tuples, one for each module except <u>cprof</u>, in decreasing <u>ModCallCount</u> order.

              If  call counters are still running while <u>analyse/0..2</u> is executing, you might get an inconsistent
              result. This happens if the process executing  <u>analyse/0..2</u>  gets  scheduled  out  so  some  other
              process can increment the counters that are being analysed, Calling <u>pause()</u> before analysing takes
              care of the problem.

              If  the  <u>Mod</u>  argument  is  given,  the  result  contains a <u>ModAnalysis</u> tuple for module <u>Mod</u> only,
              otherwise  the  result  contains  one  <u>ModAnalysis</u>   tuple   for   all   modules   returned   from
              <u>code:all_loaded()</u> except <u>cprof</u> itself.

              All  functions  with a <u>FuncCallCount</u> lower than <u>Limit</u> are excluded from <u>FuncAnalysisList</u>. They are
              still included in <u>ModCallCount</u>, though. The default value for <u>Limit</u> is <u>1</u>.

       <b>pause()</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Pause call count tracing for all functions in all modules and stop it for all functions in modules
              to be loaded. This is the same as <u>(pause({'_','_','_'})+stop({on_load}))</u>.

              See also <u>pause/1..3</u> below.

       <b>pause(FuncSpec)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>pause(Mod,</b> <b>Func)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>pause(Mod,</b> <b>Func,</b> <b>Arity)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Mod = module()
                 Func = atom()
                 Arity = arity()

              Pause call counters for matching functions in matching modules. The <u>FS</u> argument  can  be  used  to
              specify the first argument to <u>erlang:trace_pattern/3</u>.

              The  call  counters  for  all matching functions that has got call count breakpoints are paused at
              their current count.

              Return the number of matching functions  that  can  have  call  count  breakpoints,  the  same  as
              <u>start/0..3</u> with the same arguments would have returned.

       <b>restart()</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>restart(FuncSpec)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>restart(Mod,</b> <b>Func)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>restart(Mod,</b> <b>Func,</b> <b>Arity)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Mod = module()
                 Func = atom()
                 Arity = arity()

              Restart  call  counters for the matching functions in matching modules that are call count traced.
              The <u>FS</u> argument can be used to specify the first argument to <u>erlang:trace_pattern/3</u>.

              The call counters for all matching functions that has got call count breakpoints are set  to  zero
              and running.

              Return  the  number  of  matching  functions  that  can  have  call count breakpoints, the same as
              <u>start/0..3</u> with the same arguments would have returned.

       <b>start()</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Start call count tracing for all functions in all modules, and also for all functions  in  modules
              to be loaded. This is the same as <u>(start({'_','_','_'})+start({on_load}))</u>.

              See also <u>start/1..3</u> below.

       <b>start(FuncSpec)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>start(Mod,</b> <b>Func)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>start(Mod,</b> <b>Func,</b> <b>Arity)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Mod = module()
                 Func = atom()
                 Arity = arity()

              Start  call  count tracing for matching functions in matching modules. The <u>FS</u> argument can be used
              to specify the first argument to <u>erlang:trace_pattern/3</u>, for example <u>on_load</u>.

              Set call count breakpoints on the matching functions that has  no  call  count  breakpoints.  Call
              counters are set to zero and running for all matching functions.

              Return the number of matching functions that has got call count breakpoints.

       <b>stop()</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Stop call count tracing for all functions in all modules, and also for all functions in modules to
              be loaded. This is the same as <u>(stop({'_','_','_'})+stop({on_load}))</u>.

              See also <u>stop/1..3</u> below.

       <b>stop(FuncSpec)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>stop(Mod,</b> <b>Func)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>stop(Mod,</b> <b>Func,</b> <b>Arity)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Mod = module()
                 Func = atom()
                 Arity = arity()

              Stop call count tracing for matching functions in matching modules. The <u>FS</u> argument can be used to
              specify the first argument to <u>erlang:trace_pattern/3</u>, for example <u>on_load</u>.

              Remove call count breakpoints from the matching functions that has call count breakpoints.

              Return  the  number  of  matching  functions  that  can  have  call count breakpoints, the same as
              <u>start/0..3</u> with the same arguments would have returned.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3erl/eprof.3erl.html">eprof</a>(3erl), <a href="../man3erl/fprof.3erl.html">fprof</a>(3erl), <a href="../man3erl/erlang.3erl.html">erlang</a>(3erl), User's Guide

Ericsson AB                                        tools 3.5.2                                       <u><a href="../man3erl/cprof.3erl.html">cprof</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>