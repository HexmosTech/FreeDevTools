<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UR - rich declarative transactional objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libur-perl">libur-perl_0.470+ds-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       UR - rich declarative transactional objects

</pre><h4><b>VERSION</b></h4><pre>
       This document describes UR version 0.47

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use UR;

           ## no database

           class Foo { is =&gt; 'Bar', has =&gt; [qw/prop1 prop2 prop3/] };

           $o1 = Foo-&gt;create(prop1 =&gt; 111, prop2 =&gt; 222, prop3 =&gt; 333);

           @o = Foo-&gt;get(prop2 =&gt; 222, prop1 =&gt; [101,111,121], 'prop3 between' =&gt; [200, 400]);
           # returns one object

           $o1-&gt;delete;

           @o = Foo-&gt;get(prop2 =&gt; 222, prop1 =&gt; [101,111,121], 'prop3 between' =&gt; [200, 400]);
           # returns zero objects

           @o = Foo-&gt;get(prop2 =&gt; 222, prop1 =&gt; [101,111,121], 'prop3 between' =&gt; [200, 400]);
           # returns one object again

           ## database

           class Animal {
               has =&gt; [
                   favorite_food =&gt; { is =&gt; 'Text', doc =&gt; "what's yummy?" },
               ],
               data_source =&gt; 'MyDB1',
               table_name =&gt; 'Animal'
           };

           class Cat {
               is =&gt; 'Animal',
               has =&gt; [
                   feet    =&gt; { is =&gt; 'Number', default_value =&gt; 4 },
                   fur     =&gt; { is =&gt; 'Text', valid_values =&gt; [qw/fluffy scruffy/] },
               ],
               data_source =&gt; 'MyDB1',
               table_name =&gt; 'Cat'
           };

           Cat-&gt;create(feet =&gt; 4, fur =&gt; 'fluffy', favorite_food =&gt; 'taters');

           @cats = Cat-&gt;get(favorite_food =&gt; ['taters','sea bass']);

           $c = $cats[0];

           print $c-&gt;feet,"\n";

           $c-&gt;fur('scruffy');

           UR::Context-&gt;commit();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       UR is a class framework and object/relational mapper for Perl.  It starts with the familiar Perl meme of
       the blessed hash reference as the basis for object instances, and extends its capabilities with ORM
       (object-relational mapping) capabilities, object cache, in-memory transactions, more formal class
       definitions, metadata, documentation system, iterators, command line tools, etc.

       UR can handle multiple column primary and foreign keys, SQL joins involving class inheritance and
       relationships, and does its best to avoid querying the database unless the requested data has not been
       loaded before.  It has support for SQLite, Oracle, Mysql and Postgres databases, and the ability to use a
       text file as a table.

       UR uses the same syntax to define non-persistent objects, and supports in-memory transactions for both.

</pre><h4><b>DOCUMENTATION</b></h4><pre>
   <b>Manuals</b>
       ur - command line interface

       UR::Manual::Overview - UR from Ten Thousand Feet

       UR::Manual::Tutorial - Getting started with UR

       UR::Manual::Presentation - Slides for a presentation on UR

       UR::Manual::Cookbook - Recepies for getting stuff working

       UR::Manual::Metadata - UR's metadata system

       UR::Object::Type::Initializer - Defining classes

   <b>Basic</b> <b>Entities</b>
       UR::Object - Pretty much everything is-a UR::Object

       UR::Object::Type - Metadata class for Classes

       UR::Object::Property - Metadata class for Properties

       UR::Namespace - Manage packages and classes

       UR::Context - Software transactions and More!

       UR::DataSource - How and where to get data

</pre><h4><b>QUICK</b> <b>TUTORIAL</b></h4><pre>
       First create a Namespace class for your application, Music.pm:

           package Music;
           use UR;

           class Music {
               is =&gt; 'UR::Namespace'
           };

           1;

       Next, define a data source representing your database, Music/DataSource/DB1.pm

           package Music::DataSource::DB1;
           use Music;

           class Music::DataSource::DB1 {
               is =&gt; ['UR::DataSource::MySQL', 'UR::Singleton'],
               has_constant =&gt; [
                   server  =&gt; { value =&gt; 'database=music' },
                   owner   =&gt; { value =&gt; 'music' },
                   login   =&gt; { value =&gt; 'mysqluser' },
                   auth    =&gt; { value =&gt; 'mysqlpasswd' },
               ]
           };

           or to get something going quickly, SQLite has smart defaults...

           class Music::DataSource::DB1 {
               is =&gt; ['UR::DataSource::SQLite', 'UR::Singleton'],
           };

       Create a class to represent artists, who have many CDs, in Music/Artist.pm

           package Music::Artist;
           use Music;

           class Music::Artist {
               id_by =&gt; 'artist_id',
               has =&gt; [
                   name =&gt; { is =&gt; 'Text' },
                   cds  =&gt; { is =&gt; 'Music::Cd', is_many =&gt; 1, reverse_as =&gt; 'artist' }
               ],
               data_source =&gt; 'Music::DataSource::DB1',
               table_name =&gt; 'ARTIST',
           };

       Create a class to represent CDs, in Music/Cd.pm

           package Music::Cd;
           use Music;

           class Music::Cd {
               id_by =&gt; 'cd_id',
               has =&gt; [
                   artist =&gt; { is =&gt; 'Music::Artist', id_by =&gt; 'artist_id' },
                   title  =&gt; { is =&gt; 'Text' },
                   year   =&gt; { is =&gt; 'Integer' },
                   artist_name =&gt; { via =&gt; 'artist', to =&gt; 'name' },
               ],
               data_source =&gt; 'Music::DataSource::DB1',
               table_name =&gt; 'CD',
           };

       If the database does not exist, you can run this to generate the tables and columns from the classes
       you've written (very experimental):

         $ cd Music
         $ ur update schema

       If the database existed already, you could have done this to get it to write the last 2 classes for you:

         $ cd Music;
         $ ur update classes

       Regardless, if the classes and database tables are present, you can then use these classes in your
       application code:

           # Using the namespace enables auto-loading of modules upon first attempt to call a method
           use Music;

           # This would get back all Artist objects:
           my @all_artists = Music::Artist-&gt;get();

           # After the above, further requests would be cached
           # if that set were large though, you might want to iterate gradually:
           my $artist_iter = Music::Artist-&gt;create_iterator();

           # Get the first object off of the iterator
           my $first_artist = $artist_iter-&gt;next();

           # Get all the CDs published in 2007 for the first artist
           my @cds_2007 = Music::Cd-&gt;get(year =&gt; 2007, artist =&gt; $first_artist);

           # Use non-equality operators:
           my @some_cds = Music::Cd-&gt;get(
               'year between' =&gt; ['2004','2009']
           );

           # This will use a JOIN with the ARTISTS table internally to filter
           # the data in the database.  @some_cds will contain Music::Cd objects.
           # As a side effect, related Artist objects will be loaded into the cache
           @some_cds = Music::Cd-&gt;get(
               year =&gt; '2007',
               'artist_name like' =&gt; 'Bob%'
           );

           # These values would be cached...
           my @artists_for_some_cds = map { $_-&gt;artist } @some_cds;

           # This will use a join to prefetch Artist objects related to the
           # objects that match the filter
           my @other_cds = Music::Cd-&gt;get(
               'title like' =&gt; '%White%',
               -hints =&gt; ['artist']
           );
           my $other_artist_0 = $other_cds[0]-&gt;artist;  # already loaded so no query

           # create() instantiates a new object in the current "context", but does not save
           # it in the database.  It will autogenerate its own cd_id:
           my $new_cd = Music::Cd-&gt;create(
               title =&gt; 'Cool Album',
               year  =&gt; 2009
           );

           # Assign it to an artist; fills in the artist_id field of $new_cd
           $first_artist-&gt;add_cd($new_cd);

           # Save all changes in the current transaction back to the database(s)
           # which are behind the changed objects.
           UR::Context-&gt;current-&gt;commit;

</pre><h4><b>Environment</b> <b>Variables</b></h4><pre>
       UR uses several environment variables to do things like run with database commits disabled, watching SQL
       queries run, examine query plans, and control cache size, etc.

       These make development and debugging fast and easy.

       See UR::Env for details.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       Class::Autouse Cwd Data::Dumper Date::Format DBI File::Basename FindBin FreezeThaw Path::Class
       Scalar::Util Sub::Installer Sub::Name Sys::Hostname Text::Diff Time::HiRes XML::Simple

</pre><h4><b>AUTHORS</b></h4><pre>
       UR was built by the software development team at the McDonnell Genome Institute at the Washington
       University School of Medicine (Richard K. Wilson, PI).

       Incarnations of it run laboratory automation and analysis systems for high-throughput genomics.

        Anthony Brummett   <a href="mailto:brummett@cpan.org">brummett@cpan.org</a>
        Nathan Nutter
        Josh McMichael
        Eric Clark
        Ben Oberkfell
        Eddie Belter
        Feiyu Du
        Adam Dukes
        Brian Derickson
        Craig Pohl
        Gabe Sanderson
        Todd Hepler
        Jason Walker
        James Weible
        Indraniel Das
        Shin Leong
        Ken Swanson
        Scott Abbott
        Alice Diec
        William Schroeder
        Shawn Leonard
        Lynn Carmichael
        Amy Hawkins
        Michael Kiwala
        Kevin Crouse
        Mark Johnson
        Kyung Kim
        Jon Schindler
        Justin Lolofie
        Jerome Peirick
        Ryan Richt
        John Osborne
        Chris Harris
        Philip Kimmey
        Robert Long
        Travis Abbott
        Matthew Callaway
        James Eldred
        Scott Smith        <a href="mailto:sakoht@cpan.org">sakoht@cpan.org</a>
        David Dooling

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2002-2016 Washington University in St. Louis, MO.

       This software is licensed under the same terms as Perl itself.  See the LICENSE file in this
       distribution.

perl v5.38.2                                       2024-06-15                                            <u><a href="../man3pm/UR.3pm.html">UR</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>