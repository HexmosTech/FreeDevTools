<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>"Object::Pad::MetaFunctions" - utility functions for "Object::Pad" classes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libobject-pad-perl">libobject-pad-perl_0.820-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       "Object::Pad::MetaFunctions" - utility functions for "Object::Pad" classes

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use v5.36;
          use Object::Pad::MetaFunctions qw( deconstruct_object );

          sub debug_print_object ( $obj )
          {
             my ( $classname, @repr ) = deconstruct_object( $obj );

             say "An object of type $classname having:";

             foreach my ( $fieldname, $value ) ( @repr ) {
                printf "%30s = %s\n", $fieldname, $value;
             }
          }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module contains a number of miscellaneous utility functions for working with Object::Pad-based
       classes or instances thereof.

       These functions all involve a certain amount of encapsulation-breaking into the object instances being
       operated on. This sort of thing shouldn't be encouraged in most regular code, but there can be occasions
       when it is useful; such as debug printing of values, generic serialisation, or tightly-coupled unit tests
       that wish to operate on the internals of the object instances they test.

       Therefore, use of these functions should be considered "last-resort". Consider carefully the sorts of
       things you are trying to do with them, and whether this kind of reaching into the internals of an object,
       bypassing all of its interface encapsulation, is really the best technique to achieve your goal.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>metaclass</b>
          $metaclass = metaclass( $obj );

       <u>Since</u> <u>version</u> <u>0.67.</u>

       Returns the Object::Pad::MOP::Class metaclass associated with the class that the object is an instance
       of.

   <b>deconstruct_object</b>
          ( $classname, @repr ) = deconstruct_object( $obj );

       <u>Since</u> <u>version</u> <u>0.67.</u>

       Returns a list of perl values containing a representation of all the fields in the object instance. This
       representation form may be useful for tasks such as debug printing or serialisation of the instance. This
       list is prefixed by the name of the class of instance as a plain string.

       The exact form of this representation is still experimental and may change in a later version. Currently,
       it takes the form of an even-sized list of key/value pairs, associating field names with their values.
       Each key gives the name of a component class and the full name of the field within it, separated by a dot
       (".").

          'CLASSNAME.$FIELD1' =&gt; VALUE, 'CLASSNAME.@FIELD2' =&gt; VALUE, ...

       In the case of scalar fields, the value is the actual value of that field. In the case of array or hash
       fields, the value in the repr list is a reference to an anonymous <u>copy</u> <u>of</u> the value stored in the field.

          'CLASSNAME.$SCALARFIELD' =&gt; $VALUE,
          'CLASSNAME.@ARRAYFIELD'  =&gt; [ @VALUE ],
          'CLASSNAME.%HASHFIELD'   =&gt; { %VALUE },

       The pairs are ordered, with the actual object class type first, followed by any roles added by that
       class, then each parent class recursively. Within each component class, the fields are given in declared
       order.

       This reliable ordering may be useful when printing values in human-readable form, or serialising to some
       stable storage.

   <b>ref_field</b>
          $fieldref = ref_field( $fieldname, $obj );

       <u>Since</u> <u>version</u> <u>0.67.</u>

       Returns a reference to the named field storage variable of the given instance object. The <u>$fieldname</u>
       should be specified as the class name and the field name separated by a dot (".") (as per
       "deconstruct_object").

       The class name may also be omitted; at which point the first occurrence of a field of the given name
       found in any component class it matched instead.

       If no matching field is found, an exception is thrown.

       Be careful when using this function as it has the ability to expose instance fields in a way that allows
       them to be modified. For a safer alternative when only read access is required, use "get_field" instead.

   <b>get_field</b>
          $scalar = get_field( $fieldname, $obj );
          @array  = get_field( $fieldname, $obj );
          %hash   = get_field( $fieldname, $obj );

       <u>Since</u> <u>version</u> <u>0.67.</u>

       Returns the value of the named field of the given instance object. Behaves correctly given context;
       namely, that when invoked on array or hash fields in scalar context it will return the number of elements
       or keys, or in list context will return the list of elements or key/value pairs.

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Evans &lt;<a href="mailto:leonerd@leonerd.org.uk">leonerd@leonerd.org.uk</a>&gt;

perl v5.40.1                                       2025-03-03                    <u>Object::Pad::<a href="../man3pm/MetaFunctions.3pm.html">MetaFunctions</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>