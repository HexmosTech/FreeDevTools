<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Tools::AnalysisResult - Base class for analysis result objects and parsers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-perl-perl">libbio-perl-perl_1.7.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Tools::AnalysisResult - Base class for analysis result objects and parsers

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # obtain a AnalysisResult derived object somehow

           print "Method ", $result-&gt;analysis_method(),
                 ", version ", $result-&gt;analysis_method_version(),
                 ", performed on ", $result-&gt;analysis_date(), "\n";

           # annotate a sequence utilizing SeqAnalysisParserI methods
           while($feat = $result-&gt;next_feature()) {
               $seq-&gt;add_SeqFeature($feat);
           }
           $result-&gt;close();

           # query object, e.g. a Bio::SeqI implementing object
           $queryseq = $result-&gt;analysis_query();

           # Subject of the analysis -- may be undefined. Refer to derived module
           # to find out what is returned.
           $subject = $result-&gt;analysis_subject();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The AnalysisResult module is supposed to be the base class for modules encapsulating parsers and
       interpreters for the result of a analysis that was carried out with a query sequence.

       The notion of an analysis represented by this base class is that of a unary or binary operator, taking
       either one query or a query and a subject and producing a result. The query is e.g. a sequence, and a
       subject is either a sequence, too, or a database of sequences.

       This module also implements the Bio::SeqAnalysisParserI interface, and thus can be used wherever such an
       object fits.  See Bio::SeqAnalysisParserI.  Developers will find a ready-to-use <b>parse()</b> method, but need
       to implement <b>next_feature()</b> in an inheriting class. Support for initialization with input file names and
       reading from streams is also ready to use.

       Note that this module does not provide support for <b>running</b> an analysis.  Rather, it is positioned in the
       subsequent parsing step (concerned with turning raw results into BioPerl objects).

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>Lists</b>
       User feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments
       and suggestions preferably to one of the Bioperl mailing lists.  Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list:

       <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather than to the module maintainer directly. Many experienced and reponsive experts will be able look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>Bugs</b>
       Report bugs to the Bioperl bug tracking system to help us keep track the bugs and their resolution.  Bug
       reports can be submitted via the web:

         https://github.com/bioperl/bioperl-live/issues

</pre><h4><b>AUTHOR</b> <b>-</b> <b>Hilmar</b> <b>Lapp</b></h4><pre>
       Email hlapp-at-gmx.net

</pre><h4><b>APPENDIX</b></h4><pre>
       The rest of the documentation details each of the object methods. Internal methods are usually preceded
       with a _

   <b>_initialize_state</b>
        Title   : _initialize_state
        Usage   : n/a; usually called by _initialize()
        Function: This method is for BioPerl B&lt;developers&gt; only, as indicated by the
                  leading underscore in its name.

                  Performs initialization or reset of the state of this object. The
                  difference to _initialize() is that it may be called at any time,
                  and repeatedly within the lifetime of this object. B&lt;Note&gt;, however,
                  that this is potentially dangerous in a multi-threading
                  environment. In general, calling this method twice is discouraged
                  for this reason.

                  This method is supposed to reset the state such that any 'history'
                  is lost. State information that does not change during object
                  lifetime is not considered as history, e.g. parent, name, etc shall
                  not be reset. An inheriting object should only be concerned with
                  state information it introduces itself, and for everything else
                  call SUPER::_initialize_state(@args).

                  An example is parsing an input file: a state reset implies
                  discarding any unread input, and the actual input itself, followed
                  by setting the new input.

                  The argument syntax is the same as for L&lt;new()|new&gt; and L&lt;_initialize()|_initialize&gt;,
                  i.e., named parameters following the -name=&gt;$value convention.
                  The following parameters are dealt with by the implementation
                  provided here:
                     -INPUT, -FH, -FILE
                  (tags are case-insensitive).
        Example :
        Returns :
        Args    :

   <b>analysis_query</b>
        Usage     : $query_obj = $result-&gt;analysis_query();
        Purpose   : Set/Get the name of the query used to generate the result, that
                    is, the entity on which the analysis was performed. Will mostly
                    be a sequence object (Bio::PrimarySeq compatible).
        Argument  :
        Returns   : The object set before. Mostly a Bio::PrimarySeq compatible object.

   <b>analysis_subject</b>
        Usage     : $result-&gt;analyis_subject();
        Purpose   : Set/Get the subject of the analysis against which it was
                    performed. For similarity searches it will probably be a database,
                    and for sequence feature predictions (exons, promoters, etc) it
                    may be a collection of models or homologous sequences that were
                    used, or undefined.
        Returns   : The object that was set before, or undef.
        Argument  :

   <b>analysis_date</b>
        Usage     : $result-&gt;analysis_date();
        Purpose   : Set/Get the date on which the analysis was performed.
        Returns   : String
        Argument  :
        Comments  :

   <b>analysis_method</b>
        Usage     : $result-&gt;analysis_method();
        Purpose   : Set/Get the name of the sequence analysis method that was used
                    to produce this result (BLASTP, FASTA, etc.). May also be the
                    actual name of a program.
        Returns   : String
        Argument  : n/a

   <b>analysis_method_version</b>
        Usage     : $result-&gt;analysis_method_version();
        Purpose   : Set/Get the version string of the analysis program.
                  : (e.g., 1.4.9MP, 2.0a19MP-WashU).
        Returns   : String
        Argument  : n/a

perl v5.32.1                                       2021-08-15                    <u>Bio::Tools::<a href="../man3pm/AnalysisResult.3pm.html">AnalysisResult</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>