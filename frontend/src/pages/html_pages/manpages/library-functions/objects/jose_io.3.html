<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jose_io - IO Chaining.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libjose-dev">libjose-dev_14-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       jose_io - IO Chaining.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Data</b> <b>Structures</b>
       struct <b>jose_io_t</b>
           The interface for chained IO.

   <b>Typedefs</b>
       typedef <b>jose_io_t</b> <b>jose_io_auto_t</b>
           Defines a <b>jose_io_t</b> which calls <b>jose_io_decref()</b> at end of scope.

   <b>Functions</b>
       <b>jose_io_t</b> * <b>jose_io_incref</b> (<b>jose_io_t</b> *io)
           Increases the reference count of an IO object.
       void <b>jose_io_decref</b> (<b>jose_io_t</b> *io)
           Decreases the reference count of an IO object.
       <b>jose_io_t</b> * <b>jose_io_malloc</b> (jose_cfg_t *cfg, void **buf, size_t *len)
           Creates a new IO object which collects data into a dynamic buffer.
       void * <b>jose_io_malloc_steal</b> (void **buf)
           Steals the buffer created by the <b>jose_io_malloc()</b> IO object.
       <b>jose_io_t</b> * <b>jose_io_buffer</b> (jose_cfg_t *cfg, void *buf, size_t *len)
           Creates a new IO object which collects data into a static buffer.
       <b>jose_io_t</b> * <b>jose_io_file</b> (jose_cfg_t *cfg, FILE *file)
           Creates a new IO object which writes data into a FILE.
       <b>jose_io_t</b> * <b>jose_io_multiplex</b> (jose_cfg_t *cfg, <b>jose_io_t</b> **nexts, bool all)
           Creates a new IO object which multiplexes data into multiple IO objects.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       IO Chaining.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>jose_io_t</b> <b>jose_io_auto_t</b>
       Defines a <b>jose_io_t</b> which calls <b>jose_io_decref()</b> at end of scope. For example:

       void foo() {
           uint8_t *buf = NULL;
           size_t len = 0;
           jose_io_auto_t *io = jose_io_malloc(NULL, &amp;buf, &amp;len);
           // jose_io_decref() implicitly called
       }

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>jose_io_t*</b> <b>jose_io_incref</b> <b>(jose_io_t</b> <b>*</b> <b>io)</b>
       Increases the reference count of an IO object. This function always succeeds.

       <b>Parameters:</b>
           <u>io</u> The <b>jose_io_t</b> entity you are using.

       <b>Returns:</b>
           The value of io (for convenience).

   <b>void</b> <b>jose_io_decref</b> <b>(jose_io_t</b> <b>*</b> <b>io)</b>
       Decreases the reference count of an IO object. When the reference count reaches zero, io-&gt;free() is
       called.

       <b>Parameters:</b>
           <u>io</u> The <b>jose_io_t</b> entity you are using.

   <b>jose_io_t*</b> <b>jose_io_malloc</b> <b>(jose_cfg_t</b> <b>*</b> <b>cfg,</b> <b>void</b> <b>**</b> <b>buf,</b> <b>size_t</b> <b>*</b> <b>len)</b>
       Creates a new IO object which collects data into a dynamic buffer. The dynamic buffer is allocated into
       the buf pointer you provided and the length of the buffer is stored in len. The pointer referenced by buf
       must remain valid for the entire duration of the returned IO object.

       The default behavior is for the IO object to zero and free the buffer when it is freed. This means that,
       by default, you own the buffer pointer but the buffer itself is owned by the IO object. You can, however,
       steal the buffer by setting the buffer pointer to NULL.

       <b>See</b> <b>also:</b>
           <b>jose_io_malloc_steal()</b>

       <b>Parameters:</b>
           <u>cfg</u> The configuration context (optional).
           <u>buf</u> A buffer pointer pointer.
           <u>len</u> A pointer to the length of the buffer.

       <b>Returns:</b>
           The new IO object or NULL on error.

   <b>void*</b> <b>jose_io_malloc_steal</b> <b>(void</b> <b>**</b> <b>buf)</b>
       Steals the buffer created by the <b>jose_io_malloc()</b> IO object. This convenience function simply returns the
       value of *buf and then sets *buf to NULL.

       <b>See</b> <b>also:</b>
           <b>jose_io_malloc()</b>

       <b>Parameters:</b>
           <u>buf</u> A pointer to the buffer pointer.

       <b>Returns:</b>
           The value of *buf before it is set to NULL.

   <b>jose_io_t*</b> <b>jose_io_buffer</b> <b>(jose_cfg_t</b> <b>*</b> <b>cfg,</b> <b>void</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>*</b> <b>len)</b>
       Creates a new IO object which collects data into a static buffer. The size of buf MUST be specified in
       the variable pointed to by len. This will be the maximum data written. However, after the function
       returns, the variable pointed to by len will contain the current length of data in the buffer.

       Unlike <b>jose_io_malloc()</b>, you own the buffer and it is not zeroed or freed when the IO object is freed.

       <b>Parameters:</b>
           <u>cfg</u> The configuration context (optional).
           <u>buf</u> A buffer pointer.
           <u>len</u> A pointer to the length of the buffer.

       <b>Returns:</b>
           The new IO object or NULL on error.

   <b>jose_io_t*</b> <b>jose_io_file</b> <b>(jose_cfg_t</b> <b>*</b> <b>cfg,</b> <b>FILE</b> <b>*</b> <b>file)</b>
       Creates a new IO object which writes data into a FILE. This function DOES NOT take ownership of the FILE.
       You are still responsible for calling fclose() at the appropriate time.

       <b>Parameters:</b>
           <u>cfg</u> The configuration context (optional).
           <u>file</u> The output file which MUST be opened for writing or appending.

       <b>Returns:</b>
           The new IO object or NULL on error.

   <b>jose_io_t*</b> <b>jose_io_multiplex</b> <b>(jose_cfg_t</b> <b>*</b> <b>cfg,</b> <b>jose_io_t</b> <b>**</b> <b>nexts,</b> <b>bool</b> <b>all)</b>
       Creates a new IO object which multiplexes data into multiple IO objects. If all is true, the success of
       all nexts is required. Otherwise, all but one of the nexts can fail before the error is propagated
       upward.

       <b>Parameters:</b>
           <u>cfg</u> The configuration context (optional).
           <u>nexts</u> A NULL-terminated array of IO object pointers.
           <u>all</u> Whether or not the success of all nexts is required.

       <b>Returns:</b>
           The new IO object or NULL on error.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for José from the source code.

José                                             Tue May 30 2017                                      <u><a href="../man3/jose_io.3.html">jose_io</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>