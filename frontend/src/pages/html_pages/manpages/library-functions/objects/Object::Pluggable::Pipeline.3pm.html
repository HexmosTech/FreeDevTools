<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object::Pluggable::Pipeline - The plugin pipeline for Object::Pluggable.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libobject-pluggable-perl">libobject-pluggable-perl_1.29-2.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Object::Pluggable::Pipeline - The plugin pipeline for Object::Pluggable.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Object::Pluggable;
         use Object::Pluggable::Pipeline;
         use My::Plugin;

         my $self = Object::Pluggable-&gt;new();

         # the following operations are presented in pairs
         # the first is the general procedure, the second is
         # the specific way using the pipeline directly

         # to install a plugin
         $self-&gt;plugin_add(mine =&gt; My::Plugin-&gt;new);
         $self-&gt;pipeline-&gt;push(mine =&gt; My::Plugin-&gt;new);

         # to remove a plugin
         $self-&gt;plugin_del('mine');        # or the object
         $self-&gt;pipeline-&gt;remove('mine');  # or the object

         # to get a plugin
         my $plug = $self-&gt;plugin_get('mine');
         my $plug = $self-&gt;pipeline-&gt;get('mine');

         # there are other very specific operations that
         # the pipeline offers, demonstrated here:

         # to get the pipeline object itself
         my $pipe = $self-&gt;pipeline;

         # to install a plugin at the front of the pipeline
         $pipe-&gt;unshift(mine =&gt; My::Plugin-&gt;new);

         # to remove the plugin at the end of the pipeline
         my $plug = $pipe-&gt;pop;

         # to remove the plugin at the front of the pipeline
         my $plug = $pipe-&gt;shift;

         # to replace a plugin with another
         $pipe-&gt;replace(mine =&gt; newmine =&gt; My::Plugin-&gt;new);

         # to insert a plugin before another
         $pipe-&gt;insert_before(mine =&gt; newmine =&gt; My::Plugin-&gt;new);

         # to insert a plugin after another
         $pipe-&gt;insert_after(mine =&gt; newmine =&gt; My::Plugin-&gt;new);

         # to get the location in the pipeline of a plugin
         my $index = $pipe-&gt;get_index('mine');

         # to move a plugin closer to the front of the pipeline
         $pipe-&gt;bump_up('mine');

         # to move a plugin closer to the end of the pipeline
         $pipe-&gt;bump_down('mine');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Object::Pluggable::Pipeline defines the Plugin pipeline system for Object::Pluggable instances.

</pre><h4><b>METHODS</b></h4><pre>
   <b>"new"</b>
       Takes one argument, the Object::Pluggable object to attach to.

   <b>"push"</b>
       Takes at least two arguments, an alias for a plugin and the plugin object itself. Any extra arguments
       will be passed to the register method of the plugin object. If a plugin with that alias already exists,
       $@ will be set and "undef" will be returned. Otherwise, it adds the plugin to the end of the pipeline and
       registers it. This will yield a "plugin_add" event. If successful, it returns the size of the pipeline.

        my $new_size = $pipe-&gt;push($name, $plug, @register_args);

   <b>"unshift"</b>
       Takes at least two arguments, an alias for a plugin and the plugin object itself. Any extra arguments
       will be passed to the register method of the plugin object. If a plugin with that alias already exists,
       $@ will be set and "undef" will be returned. Otherwise, it adds the plugin to the beginning of the
       pipeline and registers it. This will yield a "plugin_add" event. If successful, it returns the size of
       the pipeline.

        my $new_size = $pipe-&gt;push($name, $plug, @register_args);

   <b>"shift"</b>
       Takes any number of arguments. The first plugin in the pipeline is removed.  Any arguments will be passed
       to the unregister method of the plugin object.  This will yield a "plugin_del" event. In list context, it
       returns the plugin and its alias; in scalar context, it returns only the plugin. If there were no
       elements, an empty list or "undef" will be returned.

        my ($plug, $name) = $pipe-&gt;shift(@unregister_args);
        my $plug = $pipe-&gt;shift(@unregister_args);

   <b>"pop"</b>
       Takes any number of arguments. The last plugin in the pipeline is removed.  Any arguments will be passed
       to the unregister method of the plugin object.  This will yield an "plugin_del" event. In list context,
       it returns the plugin and its alias; in scalar context, it returns only the plugin. If there were no
       elements, an empty list or "undef" will be returned.

        my ($plug, $name) = $pipe-&gt;pop(@unregister_args);
        my $plug = $pipe-&gt;pop(@unregister_args);

   <b>"replace"</b>
       Takes at least three arguments, the old plugin or its alias, an alias for the new plugin and the new
       plugin object itself. You can optionally pass two array references of arguments which will be delivered
       to the unregister method of the old plugin and the register method of the new plugin, respectively.  If
       you only want to pass the latter, you can put "undef" in place of the former. If the old plugin doesn't
       exist, or if there is already a plugin with the new alias (besides the old plugin), $@ will be set and
       "undef" will be returned. Otherwise, it removes the old plugin (yielding an "plugin_del" event) and
       replaces it with the new plugin. This will yield an "plugin_add" event. If successful, it returns 1.

        my $success = $pipe-&gt;replace($name, $new_name, $new_plug, \@unregister_args, \@register_args);
        my $success = $pipe-&gt;replace($plug, $new_name, $new_plug, \@unregister_args, \@register_args);

   <b>"insert_before"</b>
       Takes at least three arguments, the plugin that is relative to the operation, an alias for the new plugin
       and the new plugin object itself. Any extra arguments will be passed to the register method of the new
       plugin object. If the first plugin doesn't exist, or if there is already a plugin with the new alias, $@
       will be set and "undef" will be returned. Otherwise, the new plugin is placed just prior to the other
       plugin in the pipeline. If successful, it returns 1.

        my $success = $pipe-&gt;insert_before($name, $new_name, $new_plug, @register_args);
        my $success = $pipe-&gt;insert_before($plug, $new_name, $new_plug, @register_args);

   <b>"insert_after"</b>
       Takes at least three arguments, the plugin that is relative to the operation, an alias for the new plugin
       and the new plugin object itself. any extra arguments will be passed to the register method of the new
       plugin object. If the first plugin doesn't exist, or if there is already a plugin with the new alias, $@
       will be set and "undef" will be returned. Otherwise, the new plugin is placed just after to the other
       plugin in the pipeline. If successful, it returns 1.

        my $success = $pipe-&gt;insert_after($name, $new_name, $new_plug, @register_args);
        my $success = $pipe-&gt;insert_after($plug, $new_name, $new_plug, @register_args);

   <b>"bump_up"</b>
       Takes one or two arguments, the plugin or its alias, and the distance to bump the plugin. The distance
       defaults to 1. If the plugin doesn't exist, $@ will be set and <b>-1</b> <b>will</b> <b>be</b> <b>returned,</b> <b>not</b> <b>undef</b>. Otherwise,
       the plugin will be moved the given distance closer to the front of the pipeline. A warning is issued
       alerting you if it would have been moved past the beginning of the pipeline, and the plugin is placed at
       the beginning. If successful, the new index of the plugin in the pipeline is returned.

        my $pos = $pipe-&gt;bump_up($name);
        my $pos = $pipe-&gt;bump_up($plug);
        my $pos = $pipe-&gt;bump_up($name, $delta);
        my $pos = $pipe-&gt;bump_up($plug, $delta);

   <b>"bump_down"</b>
       Takes one or two arguments, the plugin or its alias, and the distance to bump the plugin. The distance
       defaults to 1. If the plugin doesn't exist, $@ will be set and <b>-1</b> <b>will</b> <b>be</b> <b>returned,</b> <b>not</b> <b>"undef"</b>.
       Otherwise, the plugin will be moved the given distance closer to the end of the pipeline.  A warning is
       issued alerting you if it would have been moved past the end of the pipeline, and the plugin is placed at
       the end. If successful, the new index of the plugin in the pipeline is returned.

        my $pos = $pipe-&gt;bump_down($name);
        my $pos = $pipe-&gt;bump_down($plug);
        my $pos = $pipe-&gt;bump_down($name, $delta);
        my $pos = $pipe-&gt;bump_down($plug, $delta);

   <b>"remove"</b>
       Takes at least one argument, a plugin or its alias. Any arguments will be passed to the unregister method
       of the plugin object. If the plugin doesn't exist, $@ will be set and "undef" will be returned.
       Otherwise, the plugin is removed from the pipeline. This will yield an "plugin_del" event. In list
       context, it returns the plugin and its alias; in scalar context, it returns only the plugin.

        my ($plug, $name) = $pipe-&gt;remove($the_name, @unregister_args);
        my ($plug, $name) = $pipe-&gt;remove($the_plug, @unregister_args);
        my $plug = $pipe-&gt;remove($the_name, @unregister_args);
        my $plug = $pipe-&gt;remove($the_plug, @unregister_args);

   <b>"get"</b>
       Takes one argument, a plugin or its alias. If no such plugin exists, $@ will be set and "undef" will be
       returned. In list context, it returns the plugin and its alias; in scalar context, it returns only the
       plugin.

        my ($plug, $name) = $pipe-&gt;get($the_name);
        my ($plug, $name) = $pipe-&gt;get($the_plug);
        my $plug = $pipe-&gt;get($the_name);
        my $plug = $pipe-&gt;get($the_plug);

   <b>"get_index"</b>
       Takes one argument, a plugin or its alias. If no such plugin exists, $@ will be set and <b>-1</b> <b>will</b> <b>be</b>
       <b>returned,</b> <b>not</b> <b>"undef"</b>. Otherwise, the index in the pipeline is returned.

        my $pos = $pipe-&gt;get_index($name);
        my $pos = $pipe-&gt;get_index($plug);

</pre><h4><b>BUGS</b></h4><pre>
       None known so far.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jeff "japhy" Pinyan, <u><a href="mailto:japhy@perlmonk.org">japhy@perlmonk.org</a></u>.

</pre><h4><b>MAINTAINER</b></h4><pre>
       Chris "BinGOs" Williams, <u><a href="mailto:chris@bingosnet.co.uk">chris@bingosnet.co.uk</a></u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Object::Pluggable.

       POE::Component::IRC,

perl v5.32.0                                       2021-01-04                   <u>Object::Pluggable::<a href="../man3pm/Pipeline.3pm.html">Pipeline</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>