<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wx_object - wx_object - Generic wx object behaviour.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wx_object - wx_object - Generic wx object behaviour.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       wx_object - Generic wx object behaviour

       This  is  a  behaviour  module  that  can  be used for "sub classing" wx objects. It works like a regular
       gen_server module and creates a server per object.

       NOTE: Currently no form of inheritance is implemented.

       The user module should export:

       init(Args) should return
       {wxObject, State} | {wxObject, State, Timeout} | ignore | {stop, Reason}

       Asynchronous window event handling:
       handle_event(#wx{}, State) should return
       {noreply, State} | {noreply, State, Timeout} | {stop, Reason, State}

       The user module can export the following callback functions:

       handle_call(Msg, {From, Tag}, State) should return
       {reply, Reply, State} | {reply, Reply, State, Timeout} | {noreply, State} | {noreply, State,  Timeout}  |
       {stop, Reason, Reply, State}

       handle_cast(Msg, State) should return
       {noreply, State} | {noreply, State, Timeout} | {stop, Reason, State}

       If  the  above  are  not  exported but called, the wx_object process will crash. The user module can also
       export:

       Info is message e.g. {'EXIT', P, R}, {nodedown, N}, ...
       handle_info(Info, State) should return , ...
       {noreply, State} | {noreply, State, Timeout} | {stop, Reason, State}

       If a message is sent to the wx_object process when handle_info is  not  exported,  the  message  will  be
       dropped and ignored.

       When  stop  is  returned  in  one  of  the  functions  above  with  Reason  =  normal  | shutdown | Term,
       terminate(State) is called. It lets the user module clean up, it is always called when server  terminates
       or  when  wx_object()  in  the driver is deleted. If the Parent process terminates the Module:terminate/2
       function is called.
       terminate(Reason, State)

       Example:

         -<a href="../manmyDialog/module.myDialog.html">module</a>(myDialog).
         -export([new/2, show/1, destroy/1]).  %% API
         -export([init/1, handle_call/3, handle_event/2,
                  handle_info/2, code_change/3, terminate/2]).
                  new/2, showModal/1, destroy/1]).  %% Callbacks

         %% Client API
         new(Parent, Msg) -&gt;
            wx_object:start(?MODULE, [Parent,Id], []).

         show(Dialog) -&gt;
            wx_object:call(Dialog, show_modal).

         destroy(Dialog) -&gt;
            wx_object:call(Dialog, destroy).

         %% Server Implementation ala gen_server
         init([Parent, Str]) -&gt;
            Dialog = wxDialog:new(Parent, 42, "Testing", []),
            ...
            wxDialog:connect(Dialog, command_button_clicked),
            {Dialog, MyState}.

         handle_call(show, _From, State) -&gt;
            wxDialog:show(State#state.win),
            {reply, ok, State};
         ...
         handle_event(#wx{}, State) -&gt;
            io:format("Users clicked button~n",[]),
            {noreply, State};
         ...

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <b>request_id()</b> <b>=</b> <b>term():</b>

         <b>server_ref()</b> <b>=</b> <b>wx:wx_object()</b> <b>|</b> <b>atom()</b> <b>|</b> <b>pid():</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>start(Name,</b> <b>Mod,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>wxWindow:wxWindow()</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Name = {local, atom()}
                 Mod = atom()
                 Args = term()
                 Flag = trace | log | {logfile, string()} | statistics | debug
                 Options = [{timeout, timeout()} | {debug, [Flag]}]

              Starts a generic wx_object server and invokes Mod:init(Args) in the new process.

       <b>start_link(Mod,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>wxWindow:wxWindow()</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Mod = atom()
                 Args = term()
                 Flag = trace | log | {logfile, string()} | statistics | debug
                 Options = [{timeout, timeout()} | {debug, [Flag]}]

              Starts a generic wx_object server and invokes Mod:init(Args) in the new process.

       <b>start_link(Name,</b> <b>Mod,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>wxWindow:wxWindow()</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Name = {local, atom()}
                 Mod = atom()
                 Args = term()
                 Flag = trace | log | {logfile, string()} | statistics | debug
                 Options = [{timeout, timeout()} | {debug, [Flag]}]

              Starts a generic wx_object server and invokes Mod:init(Args) in the new process.

       <b>stop(Obj)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Obj = wx:wx_object() | atom() | pid()

              Stops a generic wx_object server with reason  'normal'.  Invokes  terminate(Reason,State)  in  the
              server.  The  call  waits  until  the  process  is  terminated.  If the process does not exist, an
              exception is raised.

       <b>stop(Obj,</b> <b>Reason,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Obj = wx:wx_object() | atom() | pid()
                 Reason = term()
                 Timeout = timeout()

              Stops a generic wx_object server with the given Reason.  Invokes  terminate(Reason,State)  in  the
              server.  The  call waits until the process is terminated. If the call times out, or if the process
              does not exist, an exception is raised.

       <b>call(Obj,</b> <b>Request)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Obj = wx:wx_object() | atom() | pid()
                 Request = term()

              Make  a  call  to  a  wx_object  server.  The  call  waits  until  it  gets  a   result.   Invokes
              handle_call(Request, From, State) in the server

       <b>call(Obj,</b> <b>Request,</b> <b>Timeout)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Obj = wx:wx_object() | atom() | pid()
                 Request = term()
                 Timeout = integer()

              Make  a  call  to  a wx_object server with a timeout. Invokes handle_call(Request, From, State) in
              server

       <b>send_request(Obj,</b> <b>Request::term())</b> <b>-&gt;</b> <b>request_id()</b>

              Types:

                 Obj = wx:wx_object() | atom() | pid()

              Make an send_request to a generic server. and return a RequestId which  can/should  be  used  with
              wait_response/[1|2]. Invokes handle_call(Request, From, State) in server.

       <b>wait_response(RequestId::request_id())</b> <b>-&gt;</b> <b>{reply,</b> <b>Reply::term()}</b> <b>|</b> <b>{error,</b> <b>{term(),</b> <b>server_ref()}}</b>

              Wait infinitely for a reply from a generic server.

       <b>wait_response(Key::request_id(),</b>  <b>Timeout::timeout())</b>  <b>-&gt;</b>  <b>{reply,</b>  <b>Reply::term()}</b>  <b>|</b>  <b>timeout</b>  <b>|</b> <b>{error,</b>
       <b>{term(),</b> <b>server_ref()}}</b>

              Wait 'timeout' for a reply from a generic server.

       <b>check_response(Msg::term(),</b> <b>Key::request_id())</b> <b>-&gt;</b> <b>{reply,</b>  <b>Reply::term()}</b>  <b>|</b>  <b>false</b>  <b>|</b>  <b>{error,</b>  <b>{term(),</b>
       <b>server_ref()}}</b>

              Check if a received message was a reply to a RequestId

       <b>cast(Obj,</b> <b>Request)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Obj = wx:wx_object() | atom() | pid()
                 Request = term()

              Make a cast to a wx_object server. Invokes handle_cast(Request, State) in the server

       <b>get_pid(Obj)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Obj = wx:wx_object() | atom() | pid()

              Get the pid of the object handle.

       <b>set_pid(Obj,</b> <b>Pid::pid())</b> <b>-&gt;</b> <b>wx:wx_object()</b>

              Types:

                 Obj = wx:wx_object() | atom() | pid()

              Sets the controlling process of the object handle.

       <b>reply(X1::{pid(),</b> <b>Tag::term()},</b> <b>Reply::term())</b> <b>-&gt;</b> <b>pid()</b>

              Get the pid of the object handle.

</pre><h4><b>AUTHORS</b></h4><pre>
       <u>&lt;&gt;</u>

                                                    wx 2.1.1                                     <u><a href="../man3erl/wx_object.3erl.html">wx_object</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>