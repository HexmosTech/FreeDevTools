<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tool - base class for tool objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ivtools-dev">ivtools-dev_2.0.11d.a1-3build7_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tool - base class for tool objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;Unidraw/Tools/tool.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Tool  is an abstract base class for objects that support direct manipulation of components.  Tools employ
       animation and other visual effects for immediate feedback to reinforce the user's perception that  he  is
       dealing  with  real  objects.  The user <u>grasps</u> and <u>wields</u> a tool to achieve a desired <u>effect</u>.  The effect
       may involve a change to one or more components' internal state, or it may change the way  components  are
       viewed, or there may be no effect at all (if for example the tool is used in an inapropriate context).

       Conceptually,  tools  do  their work within viewers, in which graphical component views are displayed and
       manipulated.  Whenever a viewer receives an input event (such as a mouse click or key press), it in  turn
       asks  the  current  tool (defined by the enclosing editor object) to produce a manipulator object. A tool
       implements its CreateManipulator operation to create and initialize  an  appropriate  manipulator,  which
       encapsulates the tool's manipulation semantics by defining the three phases (grasp, wield, effect) of the
       manipulation.   Moreover,  a  tool  can  delegate  manipulator creation to one or more of the GraphicView
       objects in the viewer to allow component-specific interaction.  A tool's  InterpretManipulator  operation
       accesses and analyzes information in the manipulator that characterizes the manipulation and then creates
       a  command  that carries out the desired effect.  If a tool delegated manipulator creation to a graphical
       view, then it must delegate its interpretation to the same view.

</pre><h4><b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>virtual</b> <b>Manipulator*</b> <b>CreateManipulator(</b>
          <b>Viewer*,</b> <b>Event&amp;,</b> <b>Transformer*</b>
       <b>)</b>

       <b>virtual</b> <b>void</b> <b>InterpretManipulator(Manipulator*)</b>
              Operations that define how the tool reacts when it is used and its ultimate effect.  The tool  can
              defer  manipulator  creation  and  interpretation  to a GraphicView.  This allows the same tool to
              behave differently depending on the component it manipulates.

              CreateManipulator creates a manipulator that is appropriate for the tool.  It receives the  viewer
              in  which  the  manipulation will take place, an event with which to initialize the manipulator if
              necessary, and the coordinate transformation that  maps  canvas  coordinates  into  the  subject's
              coordinate  space.   InterpretManipulator  is  called  following  manipulation  and defines how to
              construct a command that carries out the manipulation's desired effect.

       <b>virtual</b> <b>void</b> <b>SetControlInfo(ControlInfo*)</b>
       <b>virtual</b> <b>ControlInfo*</b> <b>GetControlInfo()</b>
              Tools use a ControlInfo object to store information from which  to  build  a  user  interface  for
              engaging  the tool.  These operations set and get the ControlInfo object.  SetControlInfo does <u>not</u>
              delete the ControlInfo being replaced.

       <b>virtual</b> <b>Component*</b> <b>Copy()</b>
              Return a copy of the tool.  Subclasses should redefine this operation to  return  an  instance  of
              their type.

       <b>virtual</b> <b>void</b> <b>Read(istream&amp;)</b>
       <b>virtual</b> <b>void</b> <b>Write(ostream&amp;)</b>
              Read  and  write  the  tool's  contents to a stream to support catalog operations.  Read and write
              typically call first the corresponding operations defined by their parent  class,  and  then  they
              read  or write their class-specific state.  Note that you must ensure that the objects are read in
              the same order they are written.

       <b>virtual</b> <b>ClassId</b> <b>GetClassId()</b>
       <b>virtual</b> <b>boolean</b> <b>IsA(ClassId)</b>
              GetClassId returns the unique class identifier for the Tool subclass, while  IsA  returns  whether
              the  instance  is  of  a  class  or subclass corresponding to the given identifier.  IsA typically
              checks the given identifier against the instance's own (as defined by  its  GetClassId  operation)
              and,  failing  that,  calls  its  parent  classes'  IsA  operation.   All subclasses must redefine
              GetClassId and IsA to ensure that their identifiers are unique and that instances are written  and
              read properly.

</pre><h4><b>PROTECTED</b> <b>OPERATIONS</b></h4><pre>
       <b>Tool(ControlInfo*</b> <b>=</b> <b>nil)</b>
              The  constructor is protected to prevent instatiation of the abstract base class.  The ControlInfo
              object is optional, but only tools that have no visible manifestion in the interface  should  omit
              it.

       <b>ControlInfo*</b> <b>CopyControlInfo()</b>
              CopyControlInfo  is  a  convenience  function that subclasses may use in their Copy operation.  It
              returns a copy of the tool's ControlInfo object if it non-nil, simply checking for a nil  argument
              before calling the corresponding Copy on the ControlInfo object.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3U/Catalog.3U.html">Catalog</a>(3U),  <a href="../man3U/Command.3U.html">Command</a>(3U),  <a href="../man3U/ControlInfo.3U.html">ControlInfo</a>(3U),  <a href="../man3U/Editor.3U.html">Editor</a>(3U),  <a href="../man3I/Event.3I.html">Event</a>(3I),  <a href="../man3U/GraphicView.3U.html">GraphicView</a>(3U),  <a href="../man3U/Manipulator.3U.html">Manipulator</a>(3U),
       <a href="../man3I/Transformer.3I.html">Transformer</a>(3I), <a href="../man3U/Viewer.3U.html">Viewer</a>(3U), <a href="../man3U/classes.3U.html">classes</a>(3U), istream(3C++), ostream(3C++)

Unidraw                                          24 January 1991                                        <u><a href="../man3U/Tool.3U.html">Tool</a></u>(3U)
</pre>
 </div>
</div></section>
</div>
</body>
</html>