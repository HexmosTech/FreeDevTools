<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Set::Object - set of objects and strings</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libset-object-perl">libset-object-perl_1.42-1build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Set::Object - set of objects and strings

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Set::Object qw(set);

         my $set = set();            # or Set::Object-&gt;new()

         $set-&gt;insert(@thingies);
         $set-&gt;remove(@thingies);

         @items = @$set;             # or $set-&gt;members for the unsorted array

         $union = $set1 + $set2;
         $intersection = $set1 * $set2;
         $difference = $set1 - $set2;
         $symmetric_difference = $set1 % $set2;

         print "set1 is a proper subset of set2"
             if $set1 &lt; $set2;

         print "set1 is a subset of set2"
             if $set1 &lt;= $set2;

         # common idiom - iterate over any pure Perl structure
         use Set::Object qw(reftype);
         my @stack = $root;
         my $seen = Set::Object-&gt;new(@stack);
         while (my $object = pop @stack) {
             if (reftype $object eq "HASH") {
                 # do something with hash members

                 # add the new nodes to the stack
                 push @stack, grep { ref $_ &amp;&amp; $seen-&gt;insert($_) }
                     values %$object;
             }
             elsif (reftype $object eq "ARRAY") {
                 # do something with array members

                 # add the new nodes to the stack
                 push @stack, grep { ref $_ &amp;&amp; $seen-&gt;insert($_) }
                     @$object;

             }
             elsif (reftype $object =~ /SCALAR|REF/) {
                 push @stack, $$object
                     if ref $$object &amp;&amp; $seen-&gt;insert($$object);
             }
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This modules implements a set of objects, that is, an unordered collection of objects without
       duplication.

       The term <u>objects</u> is applied loosely - for the sake of Set::Object, anything that is a reference is
       considered an object.

       Set::Object 1.09 and later includes support for inserting scalars (including the empty string, but
       excluding "undef") as well as objects.  This can be thought of as (and is currently implemented as) a
       degenerate hash that only has keys and no values.  Unlike objects placed into a Set::Object, scalars that
       are inserted will be flattened into strings, so will lose any magic (eg, tie) or other special bits that
       they went in with; only strings come out.

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
   <b>Set::Object-&gt;new(</b> <b>[</b><u><b>list</b></u><b>]</b> <b>)</b>
       Return a new "Set::Object" containing the elements passed in <u>list</u>.

   <b>set(@members)</b>
       Return a new "Set::Object" filled with @members.  You have to explicitly import this method.

       <b>New</b> <b>in</b> <b>Set::Object</b> <b>1.22</b>: this function is now called as a method to return new sets the various methods
       that return a new set, such as "-&gt;intersection", "-&gt;union", etc and their overloaded counterparts.  The
       default method always returns "Set::Object" objects, preserving previous behaviour and not second
       guessing the nature of your derived Set::Object class.

   <b>weak_set()</b>
       Return a new "Set::Object::Weak", filled with @members.  You have to explicitly import this method.

</pre><h4><b>INSTANCE</b> <b>METHODS</b></h4><pre>
   <b>insert(</b> <b>[</b><u><b>list</b></u><b>]</b> <b>)</b>
       Add items to the "Set::Object".

       Adding the same object several times is not an error, but any "Set::Object" will contain at most one
       occurrence of the same object.

       Returns the number of elements that were actually added.  As of Set::Object 1.23, "undef" will not
       insert.

   <b>includes(</b> <b>[</b><u><b>list</b></u><b>]</b> <b>)</b>
   <b>has(</b> <b>[</b><u><b>list</b></u><b>]</b> <b>)</b>
   <b>contains(</b> <b>[</b><u><b>list</b></u><b>]</b> <b>)</b>
       Return "true" if <b>all</b> the objects in <u>list</u> are members of the "Set::Object".  <u>list</u> may be empty, in which
       case "true" is always returned.

       As of Set::Object 1.23, "undef" will never appear to be present in any set (even if the set contains the
       empty string).  Prior to 1.23, there would have been a run-time warning.

   <b>member(</b> <b>[</b><u><b>item</b></u><b>]</b> <b>)</b>
   <b>element(</b> <b>[</b><u><b>item</b></u><b>]</b> <b>)</b>
       Like "includes", but takes a single item to check and returns that item if the value is found, rather
       than just a true value.

   <b>members</b>
   <b>elements</b>
       Return the objects contained in the "Set::Object" in random (hash) order.

       Note that the elements of a "Set::Object" in list context are returned sorted - @$set - so using the
       "members" method is much faster.

   <b>size</b>
       Return the number of elements in the "Set::Object".

   <b>remove(</b> <b>[</b><u><b>list</b></u><b>]</b> <b>)</b>
   <b>delete(</b> <b>[</b><u><b>list</b></u><b>]</b> <b>)</b>
       Remove objects from a "Set::Object".

       Removing the same object more than once, or removing an object absent from the "Set::Object" is not an
       error.

       Returns the number of elements that were actually removed.

       As of Set::Object 1.23, removing "undef" is safe (but having an "undef" in the passed in list does not
       increase the return value, because it could never be in the set)

   <b>weaken</b>
       Makes all the references in the set "weak" - that is, they do not increase the reference count of the
       object they point to, just like Scalar::Util's "weaken" function.

       This was introduced with Set::Object 1.16, and uses a brand new type of magic.  <b>Use</b> <b>with</b> <b>caution</b>.  If you
       get segfaults when you use "weaken", please reduce your problem to a test script before submission.

       <b>New:</b> as of Set::Object 1.19, you may use the "weak_set" function to make weak sets, or
       "Set::Object::Weak-&gt;new", or import the "set" constructor from "Set::Object::Weak" instead.  See
       Set::Object::Weak for more.

       <b>Note</b> <b>to</b> <b>people</b> <b>sub-classing</b> <b>"Set::Object":</b> this method re-blesses the invocant to "Set::Object::Weak".
       Override the method "weak_pkg" in your sub-class to control this behaviour.

   <b>is_weak</b>
       Returns a true value if this set is a weak set.

   <b>strengthen</b>
       Turns a weak set back into a normal one.

       <b>Note</b> <b>to</b> <b>people</b> <b>sub-classing</b> <b>"Set::Object":</b> this method re-blesses the invocant to "Set::Object".
       Override the method "strong_pkg" in your sub-class to control this behaviour.

   <b>invert(</b> <b>[</b><u><b>list</b></u><b>]</b> <b>)</b>
       For each item in <u>list</u>, it either removes it or adds it to the set, so that a change is always made.

       Also available as the overloaded operator "/", in which case it expects another set (or a single scalar
       element), and returns a new set that is the original set with all the second set's items inverted.

   <b>clear</b>
       Empty this "Set::Object".

   <b>as_string</b>
       Return a textual Smalltalk-ish representation of the "Set::Object".  Also available as overloaded
       operator "".

   <b>equal(</b> <u><b>set</b></u> <b>)</b>
       Returns a true value if <u>set</u> contains exactly the same members as the invocant.

       Also available as overloaded operator "==" (or "eq").

   <b>not_equal(</b> <u><b>set</b></u> <b>)</b>
       Returns a false value if <u>set</u> contains exactly the same members as the invocant.

       Also available as overloaded operator "!=" (or "ne").

   <b>intersection(</b> <b>[</b><u><b>list</b></u><b>]</b> <b>)</b>
       Return a new "Set::Object" containing the intersection of the "Set::Object"s passed as arguments.

       Also available as overloaded operator "*".

   <b>union(</b> <b>[</b><u><b>list</b></u><b>]</b> <b>)</b>
       Return a new "Set::Object" containing the union of the "Set::Object"s passed as arguments.

       Also available as overloaded operator "+".

   <b>difference</b> <b>(</b> <u><b>set</b></u> <b>)</b>
       Return a new "Set::Object" containing the members of the first (invocant) set with the passed
       "Set::Object"s' elements removed.

       Also available as overloaded operator "-".

   <b>unique</b> <b>(</b> <u><b>set</b></u> <b>)</b>
   <b>symmetric_difference</b> <b>(</b> <u><b>set</b></u> <b>)</b>
       Return a new "Set::Object" containing the members of all passed sets (including the invocant), with
       common elements removed.  This will be the opposite (complement) of the <u>intersection</u> of the two sets.

       Also available as overloaded operator "%".

   <b>subset(</b> <u><b>set</b></u> <b>)</b>
       Return "true" if this "Set::Object" is a subset of <u>set</u>.

       Also available as operator "&lt;=".

   <b>proper_subset(</b> <u><b>set</b></u> <b>)</b>
       Return "true" if this "Set::Object" is a proper subset of <u>set</u> Also available as operator "&lt;".

   <b>superset(</b> <u><b>set</b></u> <b>)</b>
       Return "true" if this "Set::Object" is a superset of <u>set</u>.  Also available as operator "&gt;=".

   <b>proper_superset(</b> <u><b>set</b></u> <b>)</b>
       Return "true" if this "Set::Object" is a proper superset of <u>set</u> Also available as operator "&gt;".

   <b>is_null(</b> <u><b>set</b></u> <b>)</b>
       Returns a true value if this set does not contain any members, that is, if its size is zero.

</pre><h4><b>Set::Scalar</b> <b>compatibility</b> <b>methods</b></h4><pre>
       By and large, Set::Object is not and probably never will be feature-compatible with Set::Scalar; however
       the following functions are provided anyway.

   <b>compare(</b> <u><b>set</b></u> <b>)</b>
       returns one of:

         "proper intersect"
         "proper subset"
         "proper superset"
         "equal"
         "disjoint"

   <b>is_disjoint(</b> <u><b>set</b></u> <b>)</b>
       Returns a true value if the two sets have no common items.

   <b>as_string_callback(</b> <u><b>set</b></u> <b>)</b>
       Allows you to define a custom stringify function.  This is only a class method.  If you want anything
       fancier than this, you should sub-class Set::Object.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       The following functions are defined by the Set::Object XS code for convenience; they are largely
       identical to the versions in the Scalar::Util module, but there are a couple that provide functions not
       catered to by that module.

       Please use the versions in Scalar::Util in preference to these functions.  In fact, if you use these
       functions in your production code then you may have to rewrite it some day.  They are retained only
       because they are "mostly harmless".

       <b>blessed</b>
           <b>Do</b> <b>not</b> <b>use</b> <b>in</b> <b>production</b> <b>code</b>

           Returns a true value if the passed reference (RV) is blessed.  See also Acme::Holy.

       <b>reftype</b>
           <b>Do</b> <b>not</b> <b>use</b> <b>in</b> <b>production</b> <b>code</b>

           A  bit like the perl built-in "ref" function, but returns the <u>type</u> of reference; ie, if the reference
           is blessed then it returns what "ref" would have if it were not blessed.  Useful for "seeing through"
           blessed references.

       <b>refaddr</b>
           <b>Do</b> <b>not</b> <b>use</b> <b>in</b> <b>production</b> <b>code</b>

           Returns the memory address of a scalar.  <b>Warning</b>: this is <u>not</u> guaranteed to  be  unique  for  scalars
           created in a program; memory might get re-used!

       <b>is_int</b>, <b>is_string</b>, <b>is_double</b>
           <b>Do</b> <b>not</b> <b>use</b> <b>in</b> <b>production</b> <b>code</b>

           A  quick  way  of  checking  the  three  bits  on  scalars  -  IOK  (is_int), NOK (is_double) and POK
           (is_string).  Note that the exact behaviour of when these bits get set is not  defined  by  the  perl
           API.

           This function returns the "p" versions of the macro (SvIOKp, etc); use with caution.

       <b>is_overloaded</b>
           <b>Do</b> <b>not</b> <b>use</b> <b>in</b> <b>production</b> <b>code</b>

           A quick way to check if an object has overload magic on it.

       <b>ish_int</b>
           <b>Deprecated</b> <b>and</b> <b>will</b> <b>be</b> <b>removed</b> <b>in</b> <b>2014</b>

           This function returns true, if the value it is passed looks like it <u>already</u> <u>is</u> a representation of an
           <u>integer</u>.  This is so that you can decide whether the value passed is a hash key or an array index.

       <b>is_key</b>
           <b>Deprecated</b> <b>and</b> <b>will</b> <b>be</b> <b>removed</b> <b>in</b> <b>2014</b>

           This function returns true, if the value it is passed looks more like an <u>index</u> to a collection than a
           <u>value</u> of a collection.  Similar to the looks_like_number internal function, but weird.  Avoid.

       <b>get_magic</b>
           <b>Do</b> <b>not</b> <b>use</b> <b>in</b> <b>production</b> <b>code</b>

           Pass to a scalar, and get the magick wand ("mg_obj") used by the weak set implementation.  The return
           will  be a list of integers which are pointers to the actual "ISET" structure.  Whatever you do don't
           change the array :).  This is used only by the test suite, and if you find it  useful  for  something
           then you should probably conjure up a test suite and send it to me, otherwise it could get pulled.

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
       These class methods are probably only interesting to those sub-classing "Set::Object".

       strong_pkg
           When  a  set that was already weak is strengthened using "-&gt;strengthen", it gets re-blessed into this
           package.

       weak_pkg
           When a set that was NOT already weak is weakened using  "-&gt;weaken",  it  gets  re-blessed  into  this
           package.

       tie_array_pkg
           When the object is accessed as an array, tie the array into this package.

       tie_hash_pkg
           When the object is accessed as a hash, tie the hash into this package.

</pre><h4><b>SERIALIZATION</b></h4><pre>
       It  is  possible to serialize "Set::Object" objects via Storable and duplicate via "dclone"; such support
       was added in release 1.04.  As of "Set::Object" version 1.15, it is possible to freeze scalar items, too.

       However, the support for freezing scalar items introduced a backwards incompatibility.  Earlier  versions
       than 1.15 will "thaw" sets frozen using Set::Object 1.15 and later as a set with one item - an array that
       contains the actual members.

       Additionally,  version  1.15  had  a  bug that meant that it would not detect "freeze" protocol upgrades,
       instead reverting to pre-1.15 behaviour.

       "Set::Object" 1.16 and above are capable of dealing correctly with  all  serialized  forms,  as  well  as
       correctly aborting if a "newer" "freeze" protocol is detected during "thaw".

</pre><h4><b>PERFORMANCE</b></h4><pre>
       The  following  benchmark compares "Set::Object" with using a hash to emulate a set-like collection (this
       is an old benchmark, but still holds true):

          use Set::Object;

          package Obj;
          sub new { bless { } }

          @els = map { Obj-&gt;new() } 1..1000;

          require Benchmark;

          Benchmark::timethese(100, {
             'Control' =&gt; sub { },
             'H insert' =&gt; sub { my %h = (); @h{@els} = @els; },
             'S insert' =&gt; sub { my $s = Set::Object-&gt;new(); $s-&gt;insert(@els) },
             } );

          %gh = ();
          @gh{@els} = @els;

          $gs = Set::Object-&gt;new(@els);
          $el = $els[33];

          Benchmark::timethese(100_000, {
                  'H lookup' =&gt; sub { exists $gh{33} },
                  'S lookup' =&gt; sub { $gs-&gt;includes($el) }
             } );

       On my computer the results are:

          Benchmark: timing 100 iterations of Control, H insert, S insert...
             Control:  0 secs ( 0.01 usr  0.00 sys =  0.01 cpu)
                      (warning: too few iterations for a reliable count)
            H insert: 68 secs (67.81 usr  0.00 sys = 67.81 cpu)
            S insert:  9 secs ( 8.81 usr  0.00 sys =  8.81 cpu)
          Benchmark: timing 100000 iterations of H lookup, S lookup...
            H lookup:  7 secs ( 7.14 usr  0.00 sys =  7.14 cpu)
            S lookup:  6 secs ( 5.94 usr  0.00 sys =  5.94 cpu)

       This benchmark compares the unsorted members method, against the sorted @$ list context.

          perl -MBenchmark -mList::Util -mSet::Object -e'
          $set = Set::Object::set (List::Util::shuffle(1..1000));
          Benchmark::timethese(-3, {
             "Slow \@\$set       " =&gt; sub { $i++ for @$set; },
             "Fast set-&gt;members" =&gt; sub { $i++ for $set-&gt;members(); },
             });'

           Benchmark: running Fast set-&gt;members, Slow @$set        for at least 3 CPU seconds...
           Fast set-&gt;members:  4 wallclock secs ( 3.17 usr +  0.00 sys =  3.17 CPU) @ 9104.42/s (n=28861)
           Slow @$set       :  4 wallclock secs ( 3.23 usr +  0.00 sys =  3.23 CPU) @ 1689.16/s (n=5456)

</pre><h4><b>THREAD</b> <b>SAFETY</b></h4><pre>
       This module is not thread-safe.

</pre><h4><b>AUTHOR</b></h4><pre>
       Original Set::Object module by Jean-Louis Leroy, &lt;<a href="mailto:jll@skynet.be">jll@skynet.be</a>&gt;

       Set::Scalar compatibility, XS debugging, weak references support courtesy of Sam Vilain, &lt;<a href="mailto:samv@cpan.org">samv@cpan.org</a>&gt;.

       New maintainer is Reini Urban &lt;<a href="mailto:rurban@cpan.org">rurban@cpan.org</a>&gt;.  Patches against &lt;https://github.com/rurban/Set-Object/&gt;
       please.  Tickets at RT &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Set-Object&gt;

</pre><h4><b>LICENCE</b></h4><pre>
       Copyright (c) 1998-1999, Jean-Louis Leroy. All Rights Reserved.  This module is free software. It may  be
       used, redistributed and/or modified under the terms of the Perl Artistic License, either the original, or
       at your option, any later version.

       Portions Copyright (c) 2003 - 2005, Sam Vilain.  Same license.

       Portions  Copyright  (c)  2006,  2007, Catalyst IT (NZ) Limited.  This module is free software. It may be
       used, redistributed and/or modified under the terms of the Perl Artistic License

       Portions Copyright (c) 2013, cPanel.  Same license.  Portions Copyright  (c)  2020,  Reini  Urban.   Same
       license.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b><a href="../man1/perltie.1.html">perltie</a></b>(1), Set::Scalar, overload

perl v5.40.0                                       2024-10-20                                   <u>Set::<a href="../man3pm/Object.3pm.html">Object</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>