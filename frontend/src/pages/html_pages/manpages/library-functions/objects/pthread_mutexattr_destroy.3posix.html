<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       pthread_mutexattr_destroy, pthread_mutexattr_init — destroy and initialize the mutex attributes object

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;

       int pthread_mutexattr_destroy(pthread_mutexattr_t *<u>attr</u>);
       int pthread_mutexattr_init(pthread_mutexattr_t *<u>attr</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>pthread_mutexattr_destroy</u>() function shall destroy a mutex attributes object; the object becomes, in
       effect, uninitialized.  An  implementation  may  cause  <u>pthread_mutexattr_destroy</u>()  to  set  the  object
       referenced by <u>attr</u> to an invalid value.

       A  destroyed  <u>attr</u>  attributes object can be reinitialized using <u>pthread_mutexattr_init</u>(); the results of
       otherwise referencing the object after it has been destroyed are undefined.

       The <u>pthread_mutexattr_init</u>() function shall initialize a mutex attributes object <u>attr</u>  with  the  default
       value for all of the attributes defined by the implementation.

       Results  are  undefined  if  <u>pthread_mutexattr_init</u>()  is  called  specifying an already initialized <u>attr</u>
       attributes object.

       After a mutex attributes object has been used to initialize one or more mutexes, any  function  affecting
       the attributes object (including destruction) shall not affect any previously initialized mutexes.

       The behavior is undefined if the value specified by the <u>attr</u> argument to <u>pthread_mutexattr_destroy</u>() does
       not refer to an initialized mutex attributes object.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon  successful  completion, <u>pthread_mutexattr_destroy</u>() and <u>pthread_mutexattr_init</u>() shall return zero;
       otherwise, an error number shall be returned to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>pthread_mutexattr_init</u>() function shall fail if:

       <b>ENOMEM</b> Insufficient memory exists to initialize the mutex attributes object.

       These functions shall not return an error code of <b>[EINTR]</b>.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       None.

</pre><h4><b>RATIONALE</b></h4><pre>
       If an implementation detects that the value specified by the <u>attr</u> argument to <u>pthread_mutexattr_destroy</u>()
       does not refer to an initialized mutex attributes object, it is recommended that the function should fail
       and report an <b>[EINVAL]</b> error.

       See  <u>pthread_attr_destroy</u>()  for  a  general  explanation  of  attributes.   Attributes   objects   allow
       implementations  to experiment with useful extensions and permit extension of this volume of POSIX.1‐2017
       without changing the existing functions. Thus, they provide for future extensibility of  this  volume  of
       POSIX.1‐2017  and  reduce  the temptation to standardize prematurely on semantics that are not yet widely
       implemented or understood.

       Examples of possible additional mutex attributes that have been discussed  are  <u>spin_only</u>,  <u>limited_spin</u>,
       <u>no_spin</u>,  <u>recursive</u>,  and  <u>metered</u>.  (To explain what the latter attributes might mean: recursive mutexes
       would allow for multiple re-locking by the  current  owner;  metered  mutexes  would  transparently  keep
       records  of  queue length, wait time, and so on.) Since there is not yet wide agreement on the usefulness
       of these resulting from shared implementation and usage experience, they are not yet  specified  in  this
       volume  of  POSIX.1‐2017.  Mutex attributes objects, however, make it possible to test out these concepts
       for possible standardization at a later time.

   <b>Mutex</b> <b>Attributes</b> <b>and</b> <b>Performance</b>
       Care has been taken to ensure that the default values of the mutex attributes have been defined such that
       mutexes initialized with the defaults have simple enough semantics so that the locking and unlocking  can
       be done with the equivalent of a test-and-set instruction (plus possibly a few other basic instructions).

       There  is  at least one implementation method that can be used to reduce the cost of testing at lock-time
       if a mutex has non-default attributes. One such method that an implementation can employ (and this can be
       made fully transparent to fully conforming POSIX applications) is to secretly pre-lock any  mutexes  that
       are  initialized  to  non-default  attributes.  Any  later  attempt  to  lock  such  a  mutex  causes the
       implementation to branch to the ``slow path'' as if the mutex were unavailable; then, on the  slow  path,
       the  implementation can do the ``real work'' to lock a non-default mutex. The underlying unlock operation
       is more complicated since the implementation never really wants to release the pre-lock on this  kind  of
       mutex.  This  illustrates that, depending on the hardware, there may be certain optimizations that can be
       used so that whatever mutex attributes are considered ``most frequently  used''  can  be  processed  most
       efficiently.

   <b>Process</b> <b>Shared</b> <b>Memory</b> <b>and</b> <b>Synchronization</b>
       The existence of memory mapping functions in this volume of POSIX.1‐2017 leads to the possibility that an
       application  may  allocate  the  synchronization  objects from this section in memory that is accessed by
       multiple processes (and therefore, by threads of multiple processes).

       In order to permit such usage, while at the same time keeping the usual case (that  is,  usage  within  a
       single process) efficient, a <u>process-shared</u> option has been defined.

       If  an implementation supports the _POSIX_THREAD_PROCESS_SHARED option, then the <u>process-shared</u> attribute
       can be used to indicate that mutexes or condition variables  may  be  accessed  by  threads  of  multiple
       processes.

       The  default  setting of PTHREAD_PROCESS_PRIVATE has been chosen for the <u>process-shared</u> attribute so that
       the most efficient forms of these synchronization objects are created by default.

       Synchronization variables that are initialized with the PTHREAD_PROCESS_PRIVATE <u>process-shared</u>  attribute
       may  only  be operated on by threads in the process that initialized them. Synchronization variables that
       are initialized with the PTHREAD_PROCESS_SHARED <u>process-shared</u> attribute may be operated on by any thread
       in any process that has access to it. In particular, these processes may exist beyond the lifetime of the
       initializing process. For example, the following code implements a simple counting semaphore in a  mapped
       file that may be used by many processes.

           /* sem.h */
           struct semaphore {
               pthread_mutex_t lock;
               pthread_cond_t nonzero;
               unsigned count;
           };
           typedef struct semaphore semaphore_t;

           semaphore_t *semaphore_create(char *semaphore_name);
           semaphore_t *semaphore_open(char *semaphore_name);
           void semaphore_post(semaphore_t *semap);
           void semaphore_wait(semaphore_t *semap);
           void semaphore_close(semaphore_t *semap);

           /* sem.c */
           #include &lt;sys/types.h&gt;
           #include &lt;sys/stat.h&gt;
           #include &lt;sys/mman.h&gt;
           #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
           #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;
           #include "sem.h"

           semaphore_t *
           semaphore_create(char *semaphore_name)
           {
           int fd;
               semaphore_t *semap;
               pthread_mutexattr_t psharedm;
               pthread_condattr_t psharedc;

               fd = open(semaphore_name, O_RDWR | O_CREAT | O_EXCL, 0666);
               if (fd &lt; 0)
                   return (NULL);
               (void) ftruncate(fd, sizeof(semaphore_t));
               (void) pthread_mutexattr_init(&amp;psharedm);
               (void) pthread_mutexattr_setpshared(&amp;psharedm,
                   PTHREAD_PROCESS_SHARED);
               (void) pthread_condattr_init(&amp;psharedc);
               (void) pthread_condattr_setpshared(&amp;psharedc,
                   PTHREAD_PROCESS_SHARED);
               semap = (semaphore_t *) mmap(NULL, sizeof(semaphore_t),
                       PROT_READ | PROT_WRITE, MAP_SHARED,
                       fd, 0);
               close (fd);
               (void) pthread_mutex_init(&amp;semap-&gt;lock, &amp;psharedm);
               (void) pthread_cond_init(&amp;semap-&gt;nonzero, &amp;psharedc);
               semap-&gt;count = 0;
               return (semap);
           }

           semaphore_t *
           semaphore_open(char *semaphore_name)
           {
               int fd;
               semaphore_t *semap;

               fd = open(semaphore_name, O_RDWR, 0666);
               if (fd &lt; 0)
                   return (NULL);
               semap = (semaphore_t *) mmap(NULL, sizeof(semaphore_t),
                       PROT_READ | PROT_WRITE, MAP_SHARED,
                       fd, 0);
               close (fd);
               return (semap);
           }

           void
           semaphore_post(semaphore_t *semap)
           {
               pthread_mutex_lock(&amp;semap-&gt;lock);
               if (semap-&gt;count == 0)
                   pthread_cond_signal(&amp;semapx-&gt;nonzero);
               semap-&gt;count++;
               pthread_mutex_unlock(&amp;semap-&gt;lock);
           }

           void
           semaphore_wait(semaphore_t *semap)
           {
               pthread_mutex_lock(&amp;semap-&gt;lock);
               while (semap-&gt;count == 0)
                   pthread_cond_wait(&amp;semap-&gt;nonzero, &amp;semap-&gt;lock);
               semap-&gt;count--;
               pthread_mutex_unlock(&amp;semap-&gt;lock);
           }

           void
           semaphore_close(semaphore_t *semap)
           {
               munmap((void *) semap, sizeof(semaphore_t));
           }

       The following code is for three separate processes that create, post, and wait on a semaphore in the file
       <b>/tmp/semaphore</b>.   Once  the  file  is  created,  the  post  and wait programs increment and decrement the
       counting semaphore (waiting and waking as required) even though they did not initialize the semaphore.

           /* create.c */
           #include "pthread.h"
           #include "sem.h"

           int
           main()
           {
               semaphore_t *semap;

               semap = semaphore_create("/tmp/semaphore");
               if (semap == NULL)
                   <a href="../man1/exit.1.html">exit</a>(1);
               semaphore_close(semap);
               return (0);
           }

           /* post */
           #include "pthread.h"
           #include "sem.h"

           int
           main()
           {
               semaphore_t *semap;

               semap = semaphore_open("/tmp/semaphore");
               if (semap == NULL)
                   <a href="../man1/exit.1.html">exit</a>(1);
               semaphore_post(semap);
               semaphore_close(semap);
               return (0);
           }

           /* wait */
           #include "pthread.h"
           #include "sem.h"

           int
           main()
           {
               semaphore_t *semap;

               semap = semaphore_open("/tmp/semaphore");
               if (semap == NULL)
                   <a href="../man1/exit.1.html">exit</a>(1);
               semaphore_wait(semap);
               semaphore_close(semap);
               return (0);
           }

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>pthread_cond_destroy</u>(), <u>pthread_create</u>(), <u>pthread_mutex_destroy</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;pthread.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                     <u><a href="../man3POSIX/PTHREAD_MUTEXATTR_DESTROY.3POSIX.html">PTHREAD_MUTEXATTR_DESTROY</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>