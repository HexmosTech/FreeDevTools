<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nx::Object - API reference of the base class in the NX object system</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/nsf">nsf_2.4.0-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       nx::Object - API reference of the base class in the NX object system

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>nx::Object</b>  <b>create</b>  <u>obj</u>  ?<b>-object-mixins</b>  <u>mixinSpec</u>?  ?<b>-class</b>  <u>newClassName</u>? ?<b>-object-filters</b> <u>filterSpec</u>?
       ?<u>initBlock</u>?

       <b>nx::Object</b> <b>new</b> ?<b>-object-mixins</b> <u>mixinSpec</u>? ?<b>-class</b> <u>newClassName</u>? ?<b>-object-filters</b> <u>filterSpec</u>? ?<u>initBlock</u>?

       <u>obj</u> ?<b>public</b> | <b>private</b> | <b>protected</b>? <b>object</b> <b>alias</b> ?<b>-debug</b>? ?<b>-deprecated</b>? <u>methodName</u> ?<b>-returns</b> <u>valueChecker</u>?
       ?<b>-frame</b> <b>object</b> | <b>method</b>? <u>cmdName</u>

       <u>obj</u> <b>cget</b> <u>configurationOption</u>

       <u>obj</u> <b>configure</b> ?<u>configurationOption</u> <u>value</u> ...?

       <u>obj</u> <b>contains</b> ?-withnew <u>trueFalse</u>? ?-object <u>objectName</u>? ?-class <u>className</u>? <u>cmds</u>

       <u>obj</u> <b>copy</b> ?<u>newObjectName</u>?

       <u>obj</u> <b>delete</b> <b>object</b> <u>feature</u> <u>arg</u>

       <u>obj</u> <b>destroy</b>

       <u>obj</u> <b>eval</b> <u>arg</u> ?<u>arg</u> ...?

       <u>obj</u> <b>object</b> <b>filters</b> <u>submethod</u> ?<u>arg</u> ...?

       <u>obj</u> ?<b>public</b> | <b>protected</b> | <b>private</b>? <b>object</b> <b>forward</b> ?<b>-debug</b>? ?<b>-deprecated</b>? <u>methodName</u> ?<b>-prefix</b>  <u>prefixName</u>?
       ?<b>-frame</b> <b>object</b>? ?<b>-returns</b> <u>valueChecker</u>? ?<b>-verbose</b>? ?<u>target</u>? ?<u>arg</u> ...?

       <u>obj</u> <b>info</b> <b>baseclass</b>

       <u>obj</u> <b>info</b> <b>children</b> ?<b>-type</b> <u>className</u>? ?<u>pattern</u>?

       <u>obj</u> <b>info</b> <b>class</b>

       <u>obj</u> <b>info</b> <b>has</b> ?<b>mixin</b> | <b>namespace</b> | <b>type</b>? ?<u>arg</u> ...?

       <u>obj</u> <b>info</b> <b>lookup</b> <u>submethod</u> ?<u>arg</u> ...?

       <u>obj</u> <b>info</b> <b>name</b>

       <u>obj</u> <b>info</b> <b>info</b> ?<b>-asList</b>?

       <u>obj</u> <b>info</b> <b>object</b> <b>filters</b> ?<b>-guards</b>? ?<u>pattern</u>?

       <u>obj</u> <b>info</b> <b>object</b> <b>method</b> <u>option</u> <u>methodName</u>

       <u>obj</u> <b>info</b> <b>object</b> <b>methods</b> ?<b>-callprotection</b> <u>level</u>? ?<b>-type</b> <u>methodType</u>? ?<b>-path</b>? ?<u>namePattern</u>?

       <u>obj</u> <b>info</b> <b>object</b> <b>mixins</b> ?<b>-guards</b>? ?<u>pattern</u>?

       <u>obj</u> <b>info</b> <b>object</b> <b>slots</b> ?<b>-type</b> <u>className</u>? ?<u>pattern</u>?

       <u>obj</u> <b>info</b> <b>object</b> <b>variables</b> ?<u>pattern</u>?

       <u>obj</u> <b>info</b> <b>parent</b>

       <u>obj</u> <b>info</b> <b>precedence</b> ?<b>-intrinsic</b>? ?<u>pattern</u>?

       <u>obj</u> <b>info</b> <b>variable</b> <u>option</u> <u>handle</u>

       <u>obj</u> <b>info</b> <b>vars</b> ?<u>pattern</u>?

       <u>obj</u>  ?<b>public</b>  |  <b>protected</b> | <b>private</b>? <b>object</b> <b>method</b> ?<b>-debug</b>? ?<b>-deprecated</b>? <u>name</u> <u>parameters</u> ?<b>-checkalways</b>?
       ?<b>-returns</b> <u>valueChecker</u>? <u>body</u>

       <u>obj</u> <b>move</b> <u>newObjectName</u>

       <u>obj</u> <b>object</b> <b>mixins</b> <u>submethod</u> ?<u>arg</u> ...?

       <u>obj</u> <b>object</b> <b>property</b> ?<b>-accessor</b> <b>public</b> | <b>protected</b> | <b>private</b>? ?<b>-class</b> <u>className</u>? ?<b>-configurable</b> <u>trueFalse</u>?
       ?<b>-incremental</b>? ?<b>-nocomplain</b>? ?<b>-trace</b> <b>set</b> | <b>get</b> | <b>default</b>? <u>spec</u> ?<u>initBlock</u>?

       <u>obj</u> <b>require</b> <b>namespace</b>

       <u>obj</u> <b>require</b> ?<b>public</b> | <b>protected</b> | <b>private</b>? <b>object</b> <b>method</b> <u>methodName</u>

       <u>obj</u> <b>unknown</b> <u>unknownMethodName</u> ?<u>arg</u> ...?

       <u>obj</u> <b>uplevel</b> ?<u>level</u>? <u>arg1</u> ?<u>arg2</u> ...?

       <u>obj</u> <b>upvar</b> ?<u>level</u>? <u>otherVar1</u> <u>localVar1</u> ?<u>otherVar2</u> <u>localVar2</u> ...?

       <u>obj</u>  <b>object</b>  <b>variable</b>  ?<b>-accessor</b>  <b>public</b>  |  <b>protected</b>  |  <b>private</b>?  ?<b>-incremental</b>?  ?<b>-class</b>  <u>className</u>?
       ?<b>-configurable</b>   <u>trueFalse</u>?  ?<b>-initblock</b>  <u>script</u>?  ?<b>-trace</b>  <b>set</b>  |  <b>get</b>  |  <b>default</b>?  ?<b>-nocomplain</b>?  <u>spec</u>
       ?<u>defaultValue</u>?

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>nx::Object</b> is the base class of the NX object system. All objects defined in NX are (direct or  indirect)
       instances  of  this  base  class.  The methods provided by the <b>nx::Object</b> base class are available to all
       objects and to all classes defined in NX.

               +---------+
               | ::nx::* |
               +---------+--------------------------------------Y
               |                                                |
               |  +---------+     instance of     +----------+  |
               |  |         |&lt;....................|          |  |
               |  |  Class  |                     |  Object  |  |
               |  |         |....................&gt;|          |  |
               |  +----+----+     subclass of     +-----+----+  |
               |       ^                           ^    ^       |
              instance.|...........................|....|......./
                    of |                           |    |
                 +-----+-----+    subclass of      |    | instance
                 |           |.....................|    | of
                 |   /cls/   |    (by default)          |
                 |           |                          |
                 +-----------+                          |
                       ^                                |
              instance |.............(xor)..............|
                    of |         +-----------+          |
                       |.........|           |..........|
                                 |   /obj/   |
                                 |           |
                                 +-----------+

       NX allows for creating and for using objects (e.g. <u>obj</u>)  which  are  instantiated  from  the  base  class
       <b>nx::Object</b>  directly.  Typical use cases are singletons and anonymous, inline objects. In such use cases,
       NX does not require creating an intermediate application class (e.g. <u>cls</u>),  which  specializes  the  base
       class <b>nx::Object</b> by default, beforehand.

       Objects  (e.g. <u>obj</u>) which are creating by instantiating a previously defined application class (e.g. <u>cls</u>)
       are indirect instances of <b>nx::Object</b>.

       Direct instances of <b>nx::Object</b> can be created as follows:

       <b>nx::Object</b> <b>create</b> <u>obj</u> ?<b>-object-mixins</b> <u>mixinSpec</u>? ?<b>-class</b> <u>newClassName</u>? ?<b>-object-filters</b> <u>filterSpec</u>?
       ?<u>initBlock</u>?

              To create a direct instance of <b>nx::Object</b> having an explicit name <u>obj</u>, use <b>create</b>  on  <b>nx::Object</b>.
              Note  that  <b>create</b>  is  defined  by  <b>nx::Class</b> and is available to <b>nx::Object</b> being an instance of
              <b>nx::Class</b>. This way, singleton objects can be created, for example.

       <b>nx::Object</b> <b>new</b> ?<b>-object-mixins</b> <u>mixinSpec</u>? ?<b>-class</b> <u>newClassName</u>? ?<b>-object-filters</b> <u>filterSpec</u>? ?<u>initBlock</u>?
              To create a direct instance of <b>nx::Object</b> having an automatically assigned, implicit object  name,
              use  <b>new</b> on <b>nx::Object</b>. Note that <b>new</b> is defined by <b>nx::Class</b> and is available to <b>nx::Object</b> being
              an instance of <b>nx::Class</b>. Using <b>new</b> allows for creating anonymous, inline objects, for example.

       The configuration options for direct and indirect instances of  <b>nx::Object</b>,  which  can  be  passed  when
       calling <b>create</b> and <b>new</b>, are documented in the subsequent section.

</pre><h4><b>CONFIGURATION</b> <b>OPTIONS</b> <b>FOR</b> <b>INSTANCES</b> <b>OF</b> <b>NX::OBJECT</b></h4><pre>
       Configuration options can be used for configuring objects during their creation by passing the options as
       non-positional  arguments into calls of <b>new</b> and <b>create</b> (see <b>nx::Class</b>). An existing object can be queried
       for its current configuration using <b>cget</b> and it can be re-configured using <b>configure</b>. Legal configuration
       options are:

       <b>-class</b> ?<u>className</u>?
              Retrieves the current class of the object or sets the object's class to <u>className</u>, if provided.

       <b>-object-filters</b> ?<u>filterMethods</u>?
              Retrieves the list of currently active per-object filter methods or  sets  a  list  of  per-object
              filter methods, if <u>filterMethods</u> is provided.

       <b>-object-mixins</b> ?<u>mixinSpecs</u>?
              If  <u>mixinSpecs</u>  is  not  specified,  retrieves  the  list  of  currently  active  per-object mixin
              specifications. If <u>mixinSpecs</u> is specified, sets a list  of  per-object  mixin  specifications  to
              become active. mixin classes are returned or set in terms of a list of mixin specifications.

</pre><h4><b>METHODS</b> <b>FOR</b> <b>INSTANCES</b> <b>OF</b> <b>NX::OBJECT</b></h4><pre>
       <b>alias</b>

              <u>obj</u> ?<b>public</b> | <b>private</b> | <b>protected</b>? <b>object</b> <b>alias</b> ?<b>-debug</b>? ?<b>-deprecated</b>? <u>methodName</u> ?<b>-returns</b>
              <u>valueChecker</u>? ?<b>-frame</b> <b>object</b> | <b>method</b>? <u>cmdName</u>
                     Define  an alias method for the given object. The resulting method registers a pre-existing
                     Tcl command <u>cmdName</u> under the (alias) name <u>methodName</u> with the object. If <u>cmdName</u> refers to
                     another <b>method</b>, the corresponding argument should be  a  valid  method  handle.  If  a  Tcl
                     command  (e.g.,  a  <b>proc</b>),  the  argument  should be a fully qualified Tcl command name. If
                     aliasing a subcommand (e.g., <b>array</b> <b>exists</b>) of  a  Tcl  namespace  ensemble  (e.g.,  <b>array</b>),
                     <u>cmdName</u>  must  hold  the  fully qualified subcommand name (and not the ensemble name of the
                     subcommand).

                     As for a regular <b>object</b> <b>method</b>, <b>-returns</b> allows for setting a value checker on  the  values
                     returned by the aliased command <u>cmdName</u>.

                     When  creating an alias method for a <u>C-implemented</u> Tcl command (i.e., command defined using
                     the Tcl/NX C-API), <b>-frame</b> sets the scope  for  variable  references  used  in  the  aliased
                     command.  If the provided value is <b>object</b>, then variable references will be resolved in the
                     context of the called object, i.e., the object upon which the alias method is  invoked,  as
                     if  they  were  object  variables. There is no need for using the colon-prefix notation for
                     identifying object variables. If the value is <b>method</b>, then  the  aliased  command  will  be
                     executed as a regular method call. The command is aware of its called-object context; i.e.,
                     it  can  resolve  <b>::nx::self</b>.  In  addition, the alias method has access to the method-call
                     context (e.g., <b>nx::next</b>). If <b>-frame</b> is omitted, and by  default,  the  variable  references
                     will resolve in the context of the caller of the alias method.

                     To express deprecation of the alias method <u>methodName</u>, set the <b>-deprecated</b> flag. Deprecated
                     methods  remain  usable from client code, but their usage will be signaled to the developer
                     and/or can be tracked using <b>::nsf::deprecated</b>. To register <u>methodName</u>  with  the  debugger,
                     set  the  <b>-debug</b>  flag.  Entering and exiting a method, which was flagged for debugging, is
                     recorded   by   calling   the   redefinable   callback   procs    <b>::nsf::debug::call</b>    and
                     <b>::nsf::debug::exit</b>,  respectively. By default, these callbacks forward to <b>::nsf::log</b>, which
                     can also be customized at the script level.

       <b>cget</b>

              <u>obj</u> <b>cget</b> <u>configurationOption</u>
                     The method is used to  obtain  the  current  value  of  <u>configurationOption</u>  for  <u>obj</u>.  The
                     configuration   options   available  for  querying  through  <b>cget</b>  are  determined  by  the
                     configurable properties defined by the class hierarchy of <u>obj</u>. The queryable  configuration
                     options   for   <u>obj</u>   can  be  obtained  by  calling  <b>info</b>  <b>lookup</b>  <b>syntax</b>  <b>configure</b>.  The
                     <u>configurationOption</u> can be set and modified using <b>configure</b>.

                     % nx::Object create obj
                     ::obj
                     % ::obj info lookup syntax configure
                     ?-object-mixins /mixinreg .../? ?-class /class/? ?-object-filters /filterreg .../? ?/__initblock/?
                     % ::obj cget -class
                     ::nx::Object

       <b>configure</b>

              <u>obj</u> <b>configure</b> ?<u>configurationOption</u> <u>value</u> ...?
                     This method sets configuration options on an object. The  configuration  options  available
                     for  setting  on  <u>obj</u>  are  determined  by the configurable properties defined by the class
                     hierarchy of <u>obj</u>. The settable configuration options for <u>obj</u> can  be  obtained  by  calling
                     <b>info</b>  <b>lookup</b>  <b>syntax</b>  <b>configure</b>.  Furthermore,  <b>configure</b>  is  also  called  during  object
                     construction. Under object construction, it receives the arguments  passed  into  calls  of
                     <b>create</b> and <b>new</b>. Options set using <b>configure</b> can be retrieved using <b>cget</b>.

                     % nx::Class create Foo {:property x}
                     ::Foo
                     % Foo create f1 -x 101
                     ::f1
                     % f1 cget -x
                     101
                     % f1 configure -x 200
                     % f1 cget -x
                     200

       <b>contains</b>

              <u>obj</u> <b>contains</b> ?-withnew <u>trueFalse</u>? ?-object <u>objectName</u>? ?-class <u>className</u>? <u>cmds</u>
                     This  method  acts as a builder for nested object structures. Object and class construction
                     statements passed to this method as its last argument <u>cmds</u> are evaluated in a way  so  that
                     the  receiver  object  <u>obj</u> becomes the parent of the newly constructed objects and classes.
                     This is realized by setting explicitly the  namespace  for  constructing  relatively  named
                     objects. Fully qualified object names in <u>cmds</u> evade the nesting.

                     <b>-withnew</b>  requests the automatic rescoping of objects created using <b>new</b> so that they become
                     nested into the receiver object <u>obj</u>, rather than being created in the default namespace for
                     autonamed objects (i.e., ::nsf). If turned off, autonamed objects do not become children of
                     <u>obj</u>.

                     The parent object <u>objectName</u> to be used instead of <u>obj</u> can be specified using  <b>-object</b>.  If
                     this  explicitly  set  parent  object  does not exist prior to calling <b>contains</b>, it will be
                     created on the fly as a direct instance of <b>nx::Object</b>. Alternatively, using <b>-class</b>, a class
                     <u>className</u> other than <b>nx::Object</b> for the on-the-fly creation of <u>objectName</u> can be provided.

                     % nx::Class create Window {
                       :contains {
                         #
                         # Become children of Window, implicitly
                         #
                         nx::Class create Header; # Window::Header
                         nx::Object create Panel; # Window::Panel
                       }
                       #
                       # Explicitly declared a child of Window using [self]
                       #
                       nx::Class create [self]::Slider; # Window::Slider
                       #
                       # Fully-qualified objects do not become nested
                       #
                       nx::Class create ::Door; # ::Door
                     }
                     ::Window
                     % ::Window info children
                     ::Window::Panel ::Window::Header ::Window::Slider

       <b>copy</b>

              <u>obj</u> <b>copy</b> ?<u>newObjectName</u>?
                     Creates a full and deep copy of a  source  object  <u>obj</u>.  The  object's  copy  features  all
                     structural and behavioral properties of the source object, including object variables, per-
                     object  methods, nested objects, slot objects, namespaces, filters, mixins, and traces. The
                     copy can be named explicitly, if <u>newObjectName</u> is provided, or it  is  named  automatically
                     (in the spirit of <b>new</b> of <b>nx::Class</b>).

       <b>delete</b>

              <u>obj</u> <b>delete</b> <b>object</b> <u>feature</u> <u>arg</u>
                     This  method  serves as the equivalent to Tcl's <b>rename</b> for removing structural (properties,
                     variables) and behavioral features (methods) of the object:

              <u>obj</u> <b>delete</b> <b>object</b> <b>property</b> <u>propertyName</u>

              <u>obj</u> <b>delete</b> <b>object</b> <b>variable</b> <u>variableName</u>

              <u>obj</u> <b>delete</b> <b>object</b> <b>method</b> <u>methodName</u>
                     Removes  a  property  <u>propertyName</u>,   variable   <u>variableName</u>,   and   method   <u>methodName</u>,
                     respectively, previously defined for the scope of the object.

                     <b>delete</b>  <b>object</b> <b>method</b> can be equally used for removing regular methods (see <b>object</b> <b>method</b>),
                     an alias method (see <b>object</b> <b>alias</b>), and a forwarder method (see <b>object</b> <b>forward</b>).

       <b>destroy</b>

              <u>obj</u> <b>destroy</b>
                     This method allows for explicitly destructing an object <u>obj</u>, potentially prior to <u>obj</u> being
                     destroyed by the object system (e.g. during the shutdown of the object system upon  calling
                     <b>exit</b>):

                     [nx::Object new] destroy

                     By  providing  a  custom implementation of <b>destroy</b>, the destruction procedure of <u>obj</u> can be
                     customized. Typically, once the application-specific destruction  logic  has  completed,  a
                     custom <b>destroy</b> will trigger the actual, physical object destruction via <b>next</b>.

                     % [nx::Object create obj {
                       :public method destroy {} {
                         puts "destroying [self]"
                         next; # physical destruction
                       }
                     }] destroy
                     destroying ::obj

                     A customized object-destruction scheme can be made shared between the instances of a class,
                     by defining the custom <b>destroy</b> for an application class:

                     % nx::Class create Foo {
                         :method destroy {} {
                           puts "destroying [self]"
                           next; # physical destruction
                         }
                     }
                     ::Foo
                     % Foo create f1
                     ::f1
                     % f1 destroy
                     destroying ::f1

                     Physical  destruction is performed by clearing the in-memory object storage of <u>obj</u>. This is
                     achieved by passing <u>obj</u> into a call to <b>dealloc</b> provided  by  <b>nx::Class</b>.  A  near,  scripted
                     equivalent to the C-implemented <b>destroy</b> provided by <b>nx::Object</b> would look as follows:

                     % Object method destroy {} {
                       [:info class] dealloc [self]
                     }

                     Note,  however, that <b>destroy</b> is protected against application-level redefinition. Trying to
                     evaluate the above script snippet yields:

                     refuse to overwrite protected method 'destroy'; derive e.g. a subclass!

                     A custom <b>destroy</b> must be provided as a refinement in a subclass of <b>nx::Object</b> or in a mixin
                     class.

       <b>eval</b>

              <u>obj</u> <b>eval</b> <u>arg</u> ?<u>arg</u> ...?
                     Evaluates a special Tcl script for the scope of <u>obj</u> in the style of Tcl's <b>eval</b>. There  are,
                     however,  notable  differences  to  the  standard  <b>eval</b>:  In  this script, the colon-prefix
                     notation is available to dispatch to methods and to access variables of  <u>obj</u>.  Script-local
                     variables,  which  are  thrown away once the evaluation of the script has completed, can be
                     defined to store intermediate results.

                       % nx::Object create obj {
                         :object property {bar 1}
                         :public object method foo {x} { return $x }
                       }
                       ::obj
                       % ::obj eval {
                         set y [:foo ${:bar}]
                       }
                       1

       <b>filters</b>

              <u>obj</u> <b>object</b> <b>filters</b> <u>submethod</u> ?<u>arg</u> ...?
                     Accesses and modifies the list of methods which are registered as filters with <u>obj</u> using  a
                     specific setter or getter <u>submethod</u>:

                     <u>obj</u> <b>object</b> <b>filters</b> <b>add</b> <u>spec</u> ?<u>index</u>?
                            Inserts  a  single  filter  into  the current list of filters of <u>obj</u>. Using <u>index</u>, a
                            position in the existing list of filters for inserting the new filter can be set. If
                            omitted, <u>index</u> defaults to the list head (0).

                     <u>obj</u> <b>object</b> <b>filters</b> <b>clear</b>
                            Removes all filters from <u>obj</u> and returns the list of removed  filters.  Clearing  is
                            equivalent to passing an empty list for <u>filterSpecList</u> to <b>object</b> <b>filter</b> <b>set</b>.

                     <u>obj</u> <b>object</b> <b>filters</b> <b>delete</b> ?<b>-nocomplain</b>? <u>specPattern</u>
                            Removes  a  single filter from the current list of filters of <u>obj</u> whose spec matches
                            <u>specPattern</u>. <u>specPattern</u> can contain special  matching  chars  (see  <b>string</b>  <b>match</b>).
                            <b>object</b>  <b>filters</b>  <b>delete</b>  will  throw an error if there is no matching filter, unless
                            <b>-nocomplain</b> is set.

                     <u>obj</u> <b>object</b> <b>filters</b> <b>get</b>
                            Returns the list of current filter specifications registered for <u>obj</u>.

                     <u>obj</u> <b>object</b> <b>filters</b> <b>guard</b> <u>methodName</u> ?<u>expr</u>?
                            If <u>expr</u> is specified, registers a guard expression <u>expr</u> with  a  filter  <u>methodName</u>.
                            This  requires  that  the  filter  <u>methodName</u>  has  been previously set using <b>object</b>
                            <b>filters</b> <b>set</b> or added using <b>object</b> <b>filters</b> <b>add</b>. <u>expr</u> must be a valid  Tcl  expression
                            (see  <b>expr</b>).  An  empty  string  for  <u>expr</u> will clear the currently registered guard
                            expression for filter <u>methodName</u>.

                            If <u>expr</u> is omitted, returns the  guard  expression  set  on  the  filter  <u>methodName</u>
                            defined for <u>obj</u>. If none is available, an empty string will be returned.

                     <u>obj</u> <b>object</b> <b>filters</b> <b>methods</b> ?<u>pattern</u>?
                            If  <u>pattern</u>  is  omitted,  returns  all  filter  names  which are defined by <u>obj</u>. By
                            specifying <u>pattern</u>, the returned filters can be limited to those whose  names  match
                            <u>patterns</u> (see <b>string</b> <b>match</b>).

                     <u>obj</u> <b>object</b> <b>filters</b> <b>set</b> <u>filterSpecList</u>
                            <u>filterSpecList</u>  takes  a  list of filter specs, with each spec being itself either a
                            one-element  or  a  two-element  list:  <u>methodName</u>  ?-guard  <u>guardExpr</u>?.  <u>methodName</u>
                            identifies an existing method of <u>obj</u> which becomes registered as a filter. If having
                            three  elements, the third element <u>guardExpr</u> will be stored as a guard expression of
                            the filter. This guard expression must be a valid Tcl expression (see <b>expr</b>). <u>expr</u> is
                            evaluated when <u>obj</u> receives  a  message  to  determine  whether  the  filter  should
                            intercept  the  message.  Guard expressions allow for realizing context-dependent or
                            conditional filter composition.

                     Every <u>methodName</u> in a <u>spec</u> must resolve to an existing method in the scope of  the  object.
                     To  access and to manipulate the list of filters of <u>obj</u>, <b>cget</b>|<b>configure</b> <b>-object-filters</b> can
                     also be used.

       <b>forward</b>

              <u>obj</u> ?<b>public</b> | <b>protected</b> | <b>private</b>? <b>object</b> <b>forward</b> ?<b>-debug</b>? ?<b>-deprecated</b>? <u>methodName</u> ?<b>-prefix</b>
              <u>prefixName</u>? ?<b>-frame</b> <b>object</b>? ?<b>-returns</b> <u>valueChecker</u>? ?<b>-verbose</b>? ?<u>target</u>? ?<u>arg</u> ...?
                     Define a forward method for the given object. The definition of a forward method  registers
                     a  predefined,  but  changeable  list  of  forwarder  arguments  under the (forwarder) name
                     <u>methodName</u>. Upon calling the forward method, the forwarder arguments are evaluated as a Tcl
                     command call. That is, if present, <u>target</u> is interpreted as a Tcl command (e.g., a Tcl <b>proc</b>
                     or an object) and the remainder of the forwarder arguments <u>arg</u>  as  arguments  passed  into
                     this  command.  The  actual method arguments to the invocation of the forward method itself
                     are appended to the list of forwarder arguments.   If  <u>target</u>  is  omitted,  the  value  of
                     <u>methodName</u> is implicitly set and used as <u>target</u>. This way, when providing a fully-qualified
                     Tcl  command name as <u>methodName</u> without <u>target</u>, the unqualified <u>methodName</u> (<b>namespace</b> <b>tail</b>)
                     is used as the forwarder name; while the fully-qualified one serves as the <u>target</u>.

                     As for a regular <b>object</b> <b>method</b>, <b>-returns</b> allows for setting a value checker on  the  values
                     returned  by  the  resulting Tcl command call. When passing <b>object</b> to <b>-frame</b>, the resulting
                     Tcl command is evaluated in the context of the object receiving the  forward  method  call.
                     This  way,  variable  names used in the resulting execution of a command become resolved as
                     object variables.

                     To express deprecation  of  the  forward  method  <u>methodName</u>,  set  the  <b>-deprecated</b>  flag.
                     Deprecated  methods remain usable from client code, but their usage will be signaled to the
                     developer and/or can be tracked using <b>::nsf::deprecated</b>. To register  <u>methodName</u>  with  the
                     debugger,  set  the  <b>-debug</b>  flag.   Entering  and  exiting a method, which was flagged for
                     debugging, is recorded by calling the redefinable  callback  procs  <b>::nsf::debug::call</b>  and
                     <b>::nsf::debug::exit</b>,  respectively. By default, these callbacks forward to <b>::nsf::log</b>, which
                     can also be customized at the script level.

                     The list of forwarder arguments <u>arg</u> can contain as its elements a mix of literal values and
                     placeholders. Placeholders are prefixed with a  percent  symbol  (%)  and  substituted  for
                     concrete  values upon calling the forward method. These placeholders allow for constructing
                     and for manipulating the arguments to be passed into the resulting command call on the fly:

                     •      <b>%method</b> becomes substituted for the name of the forward method, i.e. <u>methodName</u>.

                     •      <b>%self</b> becomes substituted for the name of the  object  receiving  the  call  of  the
                            forward method.

                     •      <b>%1</b>  becomes  substituted for the first method argument passed to the call of forward
                            method. This requires, in turn, that <u>at</u> <u>least</u> one argument is passed along with  the
                            method call.

                            Alternatively,  <b>%1</b>  accepts  an optional argument <u>defaults</u>: {<b>%1</b> <u>defaults</u>}.  <u>defaults</u>
                            must be a valid Tcl list of two elements. For the first element, <b>%1</b>  is  substituted
                            when  there  is  no  first  method  argument which can be consumed by <b>%1</b>. The second
                            element is inserted upon availability of a first method argument with  the  consumed
                            argument  being  appended  right  after the second list element. This placeholder is
                            typically used to define a pair of getter/setter methods.

                     •      {<b>%@</b><u>index</u> <u>value</u>} becomes substituted for the specified <u>value</u> at position <u>index</u> in the
                            forwarder-arguments list, with <u>index</u> being either a  positive  integer,  a  negative
                            integer,  or  the  literal  value  <b>end</b>  (such as in Tcl's <b>lindex</b>). Positive integers
                            specify a list position relative to the list head, negative integers give a position
                            relative to the list tail. Indexes for positioning placeholders in the definition of
                            a forward method are evaluated from left to right and should be  used  in  ascending
                            order.

                            Note  that <u>value</u> can be a literal or any of the placeholders (e.g., <b>%method</b>, <b>%self</b>).
                            Position prefixes are exempted, they are evaluated as <b>%</b><u>cmdName</u>-placeholders in  this
                            context.

                     •      {<b>%argclindex</b>  <u>list</u>}  becomes  substituted for the <u>n</u>th element of the provided <u>list</u> ,
                            with <u>n</u> corresponding to the number of method arguments passed to the forward  method
                            call.

                     •      <b>%%</b> is substituted for a single, literal percent symbol (%).

                     •      <b>%</b><u>cmdName</u>  is  substituted  for  the  value  returned  from executing the Tcl command
                            <u>cmdName</u>. To pass arguments to <u>cmdName</u>, the placeholder should be wrapped into a  Tcl
                            <b>list</b>: {<b>%</b><u>cmdName</u> ?<u>arg</u> ...?}.

                            Consider  using fully-qualified Tcl command names for <u>cmdName</u> to avoid possible name
                            conflicts with the predefined placeholders, e.g., <b>%self</b> vs. %<b>::nx::self</b>.

              To disambiguate the names of subcommands or methods, which potentially become called by a  forward
              method,  a  prefix  <u>prefixName</u> can be set using <b>-prefix</b>. This prefix is prepended automatically to
              the argument following <u>target</u> (i.e., a second argument), if present. If missing,  <b>-prefix</b>  has  no
              effect on the forward method call.

              To  inspect  and  to debug the conversions performed by the above placeholders, setting the switch
              <b>-verbose</b> will have the command list to  be  executed  (i.e.,  after  substitution)  printed  using
              <b>::nsf::log</b> (debugging level: <b>notice</b>) upon calling the forward method.

       <b>info</b>

              <u>obj</u> <b>info</b> <b>baseclass</b>
                     Returns  the  base  class of <u>obj</u>. The base class is the class from which all NX objects are
                     instantiated directly or indirectly (typically <b>nx::Object</b>).

              <u>obj</u> <b>info</b> <b>children</b> ?<b>-type</b> <u>className</u>? ?<u>pattern</u>?
                     Retrieves the list of nested (or aggregated) objects of <u>obj</u>. The  resulting  list  contains
                     the fully qualified names of the nested objects. If <b>-type</b> is set, only nested objects which
                     are  direct  or  indirect  instances  of  class <u>className</u> are returned. Using <u>pattern</u>, only
                     nested objects whose names match <u>pattern</u> are  returned.  The  <u>pattern</u>  string  can  contain
                     special  matching  characters  (see  <b>string</b> <b>match</b>). This method allows for introspecting on
                     <b>contains</b>.

              <u>obj</u> <b>info</b> <b>class</b>
                     Returns the fully qualified  name  of  the  current  <b>nx::Class</b>  of  <u>obj</u>.  In  case  of  re-
                     classification  (see  <b>configure</b>),  the  returned class will be different from the <b>nx::Class</b>
                     from which <u>obj</u> was originally instantiated using <b>create</b> or <b>new</b>.

              <u>obj</u> <b>info</b> <b>has</b> ?<b>mixin</b> | <b>namespace</b> | <b>type</b>? ?<u>arg</u> ...?

                     <u>obj</u> <b>info</b> <b>has</b> <b>mixin</b> <u>className</u>
                            Verifies whether <u>obj</u> has a given <b>nx::Class</b> <u>className</u> registered  as  a  mixin  class
                            (returns: <b>true</b>) or not (returns: <b>false</b>).

                     <u>obj</u> <b>info</b> <b>has</b> <b>namespace</b>
                            Checks  whether  the  object  has  a  companion Tcl namespace (returns: <b>true</b>) or not
                            (returns: <b>false</b>). The namespace could have been created using, for  example,  <b>object</b>
                            <b>require</b> <b>namespace</b>.

                     <u>obj</u> <b>info</b> <b>has</b> <b>type</b> <u>className</u>
                            Tests whether the <b>nx::Class</b> <u>className</u> is a type of the object (returns: <b>true</b>) or not
                            (returns: <b>false</b>). That is, the method checks whether the object is a direct instance
                            of <u>className</u> or an indirect instance of one of the superclasses of <u>className</u>.

              <u>obj</u> <b>info</b> <b>lookup</b> <u>submethod</u> ?<u>arg</u> ...?
                     A  collection  of  submethods to retrieve structural features (e.g.  configuration options,
                     slot objects) and behavioral features (e.g. methods, filters) available for  <u>obj</u>  from  the
                     perspective  of  a client to <u>obj</u>. Features provided by <u>obj</u> itself and by the classes in its
                     current linearization list are considered.

                     <u>obj</u> <b>info</b> <b>lookup</b> <b>filter</b> <u>name</u>
                            Returns the method handle for the filter method <u>name</u>, if  currently  registered.  If
                            there is no filter <u>name</u> registered, an empty string is returned.

                     <u>obj</u> <b>info</b> <b>lookup</b> <b>filters</b> ?<b>-guards</b>? ?<u>namePattern</u>?
                            Returns the method handles of all filters which are active on <u>obj</u>. By turning on the
                            switch  <b>-guards</b>,  the corresponding guard expressions, if any, are also reported for
                            each filter as a three-element list: <u>methodHandle</u>  -guard  <u>guardExpr</u>.  The  returned
                            filters can be limited to those whose names match <u>namePattern</u> (see <b>string</b> <b>match</b>).

                     <u>obj</u> <b>info</b> <b>lookup</b> <b>method</b> <u>name</u>
                            Returns  the  method handle for a method <u>name</u> if a so-named method can be invoked on
                            <u>obj</u>. If there is no method <u>name</u>, an empty string is returned.

                     <u>obj</u> <b>info</b> <b>lookup</b> <b>methods</b> ?<u>namePattern</u>?
                            Returns the names of all methods (including aliases and  forwarders)  which  can  be
                            invoked  on  <u>obj</u>.  The  returned  methods  can be limited to those whose names match
                            <u>namePattern</u> (see <b>string</b> <b>match</b>).

                     <u>obj</u> <b>info</b> <b>lookup</b> <b>mixins</b> ?<b>-guards</b>? ?<u>namePattern</u>?
                            Returns the object names of all mixin classes which are currently active on <u>obj</u>.  By
                            turning on the switch <b>-guards</b>, the corresponding guard expressions, if any, are also
                            reported  as  a three-element list for each mixin class: <u>className</u> -guard <u>guardExpr</u>.
                            The returned mixin classes can be limited to those  whose  names  match  <u>namePattern</u>
                            (see <b>string</b> <b>match</b>).

                     <u>obj</u> <b>info</b> <b>lookup</b> <b>parameters</b> <u>methodName</u> ?<u>namePattern</u>?
                            Returns  the  parameter  specification of the method <u>methodName</u> callable on <u>obj</u> as a
                            list  of  parameter  names  and  type  specifications.   The   resulting   parameter
                            specification  can be limited to those parameters whose names match <u>namePattern</u> (see
                            <b>string</b> <b>match</b>).

                     <u>obj</u> <b>info</b> <b>lookup</b> <b>slots</b> ?<b>-type</b> <u>className</u>? ?<b>-source</b> all | application | system? ?<u>namePattern</u>?
                            Returns the command names of all slot objects responsible for  managing  properties,
                            variables,  and relations of <u>obj</u>. The returned slot objects can be limited according
                            to any or a combination of the  following  criteria:  First,  slot  objects  can  be
                            filtered  based  on  their  command  names  matching <u>namePattern</u> (see <b>string</b> <b>match</b>).
                            Second, <b>-type</b> allows one to select  slot  objects  which  are  instantiated  from  a
                            subclass  <u>className</u>  of <b>nx::Slot</b> (default: <b>nx::Slot</b>) . Third, <b>-source</b> restricts slot
                            objects returned according to their provenance in either the NX  <u>system</u>  classes  or
                            the <u>application</u> classes present in the linearization list of <u>obj</u> (default: <u>all</u>).

                            To  extract  details of each slot object, use the <b>info</b> submethods available for each
                            slot object.

                     <u>obj</u> <b>info</b> <b>lookup</b> <b>syntax</b> <u>methodName</u> ?<u>namePattern</u>?
                            Returns the method parameters  of  the  method  <u>methodName</u>  callable  on  <u>obj</u>  as  a
                            concrete-syntax  description  to  be  used  in  human-understandable messages (e.g.,
                            errors or warnings, documentation strings). The  result  can  be  limited  to  those
                            parameters matching the <u>namePattern</u> (see <b>string</b> <b>match</b>).

                     <u>obj</u> <b>info</b> <b>lookup</b> <b>variables</b>
                            Returns  the  command  names of all slot objects responsible for managing properties
                            and variables of <u>obj</u>, if provided by <u>obj</u> or the classes in the linearization list of
                            <u>obj</u>.

                            This is equivalent to  calling:  <u>obj</u>  <b>info</b>  <b>lookup</b>  <b>slots</b>  -type  ::nx::VariableSlot
                            -source all ?<u>namePattern</u>?.

                            To  extract  details of each slot object, use the <b>info</b> submethods available for each
                            slot object.

              <u>obj</u> <b>info</b> <b>name</b>
                     Returns the unqualified name of an object, i.e., the  object  name  without  any  namespace
                     qualifiers.

              <u>obj</u> <b>info</b> <b>info</b> ?<b>-asList</b>?
                     Returns  the  available submethods of the <b>info</b> method ensemble for <u>obj</u>, either as a pretty-
                     printed string or as a Tcl list (if the switch <b>-asList</b> is set) for further processing.

              <u>obj</u> <b>info</b> <b>object</b> <b>filters</b> ?<b>-guards</b>? ?<u>pattern</u>?
                     If <u>pattern</u> is omitted, returns all filter names which are defined by <u>obj</u>. By turning on the
                     switch <b>-guards</b>, the corresponding guard expressions, if any, are also reported  along  with
                     each  filter  as  a three-element list: <u>filterName</u> -guard <u>guardExpr</u>. By specifying <u>pattern</u>,
                     the returned filters can be limited to those whose names match <u>patterns</u> (see <b>string</b> <b>match</b>).

              <u>obj</u> <b>info</b> <b>object</b> <b>method</b> <u>option</u> <u>methodName</u>
                     This introspection submethod provides access to the details of <u>methodName</u> provided by  <u>obj</u>.
                     If  <u>methodName</u>  is  not  the  name  of  an existing method, an empty string is returned. To
                     disambiguate between a non-existing method and an empty string as valid return value (e.g.,
                     for <b>info</b> <b>object</b> <b>method</b> <b>args|parameters|args|...</b>), use <b>info</b> <b>object</b> <b>method</b> <b>exists</b>.

                     Permitted values for <u>option</u> are:

                     •      <b>args</b> returns a list containing the parameter names of <u>methodName</u>, in  order  of  the
                            method-parameter specification.

                     •      <b>body</b> returns the body script of <u>methodName</u>.

                     •      <b>callprotection</b>  returns  the  call-protection  level  set  for  <u>methodName</u>; possible
                            values: <b>public</b>, <b>protected</b>, <b>private</b>.

                     •      <b>debug</b> returns 1 if <u>methodName</u> is in debug mode, 0 otherwise.

                     •      <b>definition</b> returns a canonical command list which allows for (re-)define <u>methodName</u>.

                     •      <b>definitionhandle</b> returns the method handle for a submethod in a method ensemble from
                            the perspective of <u>obj</u> as method provider. <u>methodName</u> must contain a complete method
                            path.

                     •      <b>deprecated</b> returns 1 if <u>methodName</u> is deprecated, 0 otherwise.

                     •      <b>exists</b> returns 1 if there is a <u>methodName</u> provided by <u>obj</u>, returns 0 otherwise.

                     •      <b>handle</b> returns the method handle for <u>methodName</u>.

                     •      <b>origin</b> returns the aliased command if <u>methodName</u> is an alias  method,  or  an  empty
                            string otherwise.

                     •      <b>parameters</b>  returns the parameter specification of <u>methodName</u> as a list of parameter
                            names and type specifications.

                     •      <b>registrationhandle</b> returns the method handle for a submethod in  a  method  ensemble
                            from the perspective of the method caller. <u>methodName</u> must contain a complete method
                            path.

                     •      <b>returns</b> gives the type specification defined for the return value of <u>methodName</u>.

                     •      <b>submethods</b>  returns  the  names  of all submethods of <u>methodName</u>, if <u>methodName</u> is a
                            method ensemble. Otherwise, an empty string is returned.

                     •      <b>syntax</b> returns the method parameters of <u>methodName</u> as a concrete-syntax  description
                            to be used in human-understandable messages (e.g., errors or warnings, documentation
                            strings).

                     •      <b>type</b>  returns  whether <u>methodName</u> is a <u>scripted</u> method, an <u>alias</u> method, a <u>forwarder</u>
                            method, or a <u>setter</u> method.

              <u>obj</u> <b>info</b> <b>object</b> <b>methods</b> ?<b>-callprotection</b> <u>level</u>? ?<b>-type</b> <u>methodType</u>? ?<b>-path</b>? ?<u>namePattern</u>?
                     Returns the names of all methods defined by <u>obj</u>.  Methods  covered  include  those  defined
                     using  <b>object</b>  <b>alias</b> and <b>object</b> <b>forward</b>. The returned methods can be limited to those whose
                     names match <u>namePattern</u> (see <b>string</b> <b>match</b>).

                     By setting <b>-callprotection</b>, only methods  of  a  certain  call  protection  <u>level</u>  (<b>public</b>,
                     <b>protected</b>,  or <b>private</b>) will be returned. Methods of a specific type can be requested using
                     <b>-type</b>. The recognized values for <u>methodType</u> are:

                     •      <b>scripted</b> denotes methods defined using <b>object</b> <b>method</b>;

                     •      <b>alias</b> denotes alias methods defined using <b>object</b> <b>alias</b>;

                     •      <b>forwarder</b> denotes forwarder methods defined using <b>object</b> <b>forward</b>;

                     •      <b>setter</b> denotes methods defined using <b>::nsf::setter</b>;

                     •      <b>all</b> returns methods of any type, without restrictions (also the default value);

              <u>obj</u> <b>info</b> <b>object</b> <b>mixins</b> ?<b>-guards</b>? ?<u>pattern</u>?
                     If <u>pattern</u> is omitted, returns the object names of  the  mixin  classes  which  extend  <u>obj</u>
                     directly.  By  turning  on the switch <b>-guards</b>, the corresponding guard expressions, if any,
                     are also reported  along  with  each  mixin  as  a  three-element  list:  <u>className</u>  -guard
                     <u>guardExpr</u>.  The  returned  mixin classes can be limited to those whose names match <u>patterns</u>
                     (see <b>string</b> <b>match</b>).

              <u>obj</u> <b>info</b> <b>object</b> <b>slots</b> ?<b>-type</b> <u>className</u>? ?<u>pattern</u>?
                     If <u>pattern</u> is not specified, returns the object names of all slot objects defined  by  <u>obj</u>.
                     The returned slot objects can be limited according to any or a combination of the following
                     criteria: First, slot objects can be filtered based on their command names matching <u>pattern</u>
                     (see  <b>string</b> <b>match</b>). Second, <b>-type</b> allows one to select slot objects which are instantiated
                     from a subclass <u>className</u> of <b>nx::Slot</b> (default: <b>nx::Slot</b>).

              <u>obj</u> <b>info</b> <b>object</b> <b>variables</b> ?<u>pattern</u>?
                     If <u>pattern</u> is omitted, returns the object names of all slot objects provided by  <u>obj</u>  which
                     are  responsible for managing properties and variables of <u>obj</u>. Otherwise, only slot objects
                     whose names match <u>pattern</u> are returned.

                     This is equivalent to calling: <u>obj</u> <b>info</b> <b>object</b> <b>slots</b> <b>-type</b> <b>::nx::VariableSlot</b> <u>pattern</u>.

                     To extract details of each slot object, use the <b>info</b> submethods  available  for  each  slot
                     object.

              <u>obj</u> <b>info</b> <b>parent</b>
                     Returns the fully qualified name of the parent object of <u>obj</u>, if any. If there is no parent
                     object, the name of the Tcl namespace containing <u>obj</u> (e.g. "::") will be reported.

              <u>obj</u> <b>info</b> <b>precedence</b> ?<b>-intrinsic</b>? ?<u>pattern</u>?
                     Lists  the  classes  from  which  <u>obj</u> inherits structural (e.g.  properties) and behavioral
                     features (e.g. methods) and methods, in order of the linearization scheme in NX. By setting
                     the switch <b>-intrinsic</b>, only classes which participate in superclass/subclass  relationships
                     (i.e.,  intrinsic  classes) are returned. If a <u>pattern</u> is provided only classes whose names
                     match <u>pattern</u> are returned. The <u>pattern</u> string can contain special matching characters (see
                     <b>string</b> <b>match</b>).

              <u>obj</u> <b>info</b> <b>variable</b> <u>option</u> <u>handle</u>
                     Retrieves selected details about a variable represented by the given <u>handle</u>. A  <u>handle</u>  can
                     be  obtained  by querying <u>obj</u> using <b>info</b> <b>object</b> <b>variables</b> and <b>info</b> <b>lookup</b> <b>variables</b>.  Valid
                     values for <u>option</u> are:

                     •      <b>name</b> returns the variable name.

                     •      <b>parameter</b> returns a canonical parameter specification eligible  to  (re-)define  the
                            given variable (e.g. using <b>object</b> <b>variable</b>) in a new context.

                     •      <b>definition</b>  returns  a  canonical  representation  of the definition command used to
                            create the variable in its current configuration.

              <u>obj</u> <b>info</b> <b>vars</b> ?<u>pattern</u>?
                     Yields a list of Tcl variable names created and defined for the scope of <u>obj</u>, i.e.,  object
                     variables.  The  list  can  be  limited  to object variables whose names match <u>pattern</u>. The
                     <u>pattern</u> string can contain special matching characters (see <b>string</b> <b>match</b>).

       <b>method</b>

              <u>obj</u> ?<b>public</b> | <b>protected</b> | <b>private</b>? <b>object</b> <b>method</b> ?<b>-debug</b>? ?<b>-deprecated</b>? <u>name</u> <u>parameters</u>
              ?<b>-checkalways</b>? ?<b>-returns</b> <u>valueChecker</u>? <u>body</u>
                     Defines a scripted method <u>methodName</u> for the scope of the object. The method  becomes  part
                     of  the object's signature interface. Besides a <u>methodName</u>, the method definition specifies
                     the method <u>parameters</u> and a method <u>body</u>.

                     <u>parameters</u> accepts a  Tcl  <b>list</b>  containing  an  arbitrary  number  of  non-positional  and
                     positional  parameter  definitions. Each parameter definition comprises a parameter name, a
                     parameter-specific value checker, and parameter options.

                     The <u>body</u> contains the method implementation as a script block. In  this  body  script,  the
                     colon-prefix  notation  is  available  to  denote  an  object  variable and a self call. In
                     addition, the context of the object receiving the method call (i.e., the  message)  can  be
                     accessed  (e.g.,  using  <b>nx::self</b>)  and  the  call  stack  can be introspected (e.g., using
                     <b>nx::current</b>).

                     Optionally, <b>-returns</b> allows for setting a value checker on values returned  by  the  method
                     implementation.  By setting the switch <b>-checkalways</b>, value checking on arguments and return
                     value is guaranteed to be performed, even if value checking is  temporarily  disabled;  see
                     <b>nx::configure</b>).

                     To  express  deprecation  of  the method <u>name</u>, set the <b>-deprecated</b> flag. Deprecated methods
                     remain usable from client code, but their usage will be signaled to  the  developer  and/or
                     can  be tracked using <b>::nsf::deprecated</b>. To register <u>name</u> with the debugger, set the <b>-debug</b>
                     flag. Entering and exiting a method, which  was  flagged  for  debugging,  is  recorded  by
                     calling   the   redefinable   callback  procs  <b>::nsf::debug::call</b>  and  <b>::nsf::debug::exit</b>,
                     respectively. By default,  these  callbacks  forward  to  <b>::nsf::log</b>,  which  can  also  be
                     customized at the script level.

                     A  method  closely resembles a Tcl <b>proc</b>, but it differs in some important aspects: First, a
                     method can define non-positional parameters and value checkers on  arguments.  Second,  the
                     script  implementing the method body can contain object-specific notation and commands (see
                     above). Third, method calls <u>cannot</u> be intercepted using Tcl <b>trace</b>. Note  that  an  existing
                     Tcl <b>proc</b> can be registered as an alias method with the object (see <b>object</b> <b>alias</b>).

       <b>move</b>

              <u>obj</u> <b>move</b> <u>newObjectName</u>
                     Effectively  renames an object. First, the source object <u>obj</u> is cloned into a target object
                     <u>newObjectName</u> using <b>copy</b>. Second, the source object <u>obj</u> is destroyed by  invoking  <b>destroy</b>.
                     <b>move</b>  is  also called internally when <b>rename</b> is performed for a Tcl command representing an
                     object.

       <b>mixins</b>

              <u>obj</u> <b>object</b> <b>mixins</b> <u>submethod</u> ?<u>arg</u> ...?
                     Accesses and modifies the list of mixin classes of <u>obj</u> using a specific  setter  or  getter
                     <u>submethod</u>:

                     <u>obj</u> <b>object</b> <b>mixins</b> <b>add</b> <u>spec</u> ?<u>index</u>?
                            Inserts  a  single  mixin class into the current list of mixin classes of <u>obj</u>. Using
                            <u>index</u>, a position in the existing list of mixin classes for inserting the new  mixin
                            class can be set. If omitted, <u>index</u> defaults to the list head (0).

                     <u>obj</u> <b>object</b> <b>mixins</b> <b>classes</b> ?<u>pattern</u>?
                            If  <u>pattern</u>  is  omitted, returns the object names of the mixin classes which extend
                            <u>obj</u> directly. By specifying <u>pattern</u>, the returned mixin classes can  be  limited  to
                            those whose names match <u>pattern</u> (see <b>string</b> <b>match</b>).

                     <u>obj</u> <b>object</b> <b>mixins</b> <b>clear</b>
                            Removes  all  mixin  classes from <u>obj</u> and returns the list of removed mixin classes.
                            Clearing is equivalent to passing an empty list for <u>mixinSpecList</u> to  <b>object</b>  <b>mixins</b>
                            <b>set</b>.

                     <u>obj</u> <b>object</b> <b>mixins</b> <b>delete</b> ?<b>-nocomplain</b>? <u>specPattern</u>
                            Removes a mixin class from a current list of mixin classes of <u>obj</u> whose spec matches
                            <u>specPattern</u>.  <u>specPattern</u>  can  contain  special  matching chars (see <b>string</b> <b>match</b>).
                            <b>object</b> <b>mixins</b> <b>delete</b> will throw an error if there is no matching mixin class, unless
                            <b>-nocomplain</b> is set.

                     <u>obj</u> <b>object</b> <b>mixins</b> <b>get</b>
                            Returns the list of current mixin specifications.

                     <u>obj</u> <b>object</b> <b>mixins</b> <b>guard</b> <u>className</u> ?<u>expr</u>?
                            If <u>expr</u> is specified, a guard expression <u>expr</u> is registered  with  the  mixin  class
                            <u>className</u>.  This  requires  that  the  corresponding  mixin class <u>className</u> has been
                            previously set using <b>object</b> <b>mixins</b> <b>set</b> or added using <b>object</b> <b>mixins</b> <b>add</b>.  <u>expr</u>  must
                            be  a  valid  Tcl  expression  (see  <b>expr</b>).  An empty string for <u>expr</u> will clear the
                            currently registered guard expression for the mixin class <u>className</u>.

                            If <u>expr</u> is not specified, returns the active guard expression. If none is available,
                            an empty string will be returned.

                     <u>obj</u> <b>object</b> <b>mixins</b> <b>set</b> <u>mixinSpecList</u>
                            <u>mixinSpecList</u> represents a list of mixin class specs, with each  spec  being  itself
                            either  a  one-element  or  a  three-element  list: <u>className</u> ?-guard <u>guardExpr</u>?. If
                            having one element, the element will be considered the <u>className</u> of the mixin class.
                            If having three elements, the third element <u>guardExpr</u> will  be  stored  as  a  guard
                            expression  of  the  mixin class. This guard expression will be evaluated using <b>expr</b>
                            when <u>obj</u> receives a message to determine if the mixin is  to  be  considered  during
                            method  dispatch  or not. Guard expressions allow for realizing context-dependent or
                            conditional mixin composition.

                     At the time of setting the mixin relation, that is, calling <b>object</b> <b>mixins</b>, every  <u>className</u>
                     as  part  of  a spec must be an existing instance of <b>nx::Class</b>. To access and to manipulate
                     the list of mixin classes of <u>obj</u>, <b>cget</b>|<b>configure</b> <b>-object-mixins</b> can also be used.

       <b>__object_configureparameter</b>

              <u>obj</u> <b>__object_configureparameter</b>
                     Computes and returns the configuration options available for <u>obj</u>, to be consumed as method-
                     parameter specification by <b>configure</b>.

       <b>property</b>

              <u>obj</u> <b>object</b> <b>property</b> ?<b>-accessor</b> <b>public</b> | <b>protected</b> | <b>private</b>? ?<b>-class</b> <u>className</u>? ?<b>-configurable</b>
              <u>trueFalse</u>? ?<b>-incremental</b>? ?<b>-nocomplain</b>? ?<b>-trace</b> <b>set</b> | <b>get</b> | <b>default</b>? <u>spec</u> ?<u>initBlock</u>?
                     Defines  a  property  for  the  scope  of  the  object.  The  <u>spec</u>  provides  the  property
                     specification  as  a  <b>list</b>  holding  at  least  one  element  or,  maximum,  two  elements:
                     <u>propertyName</u>?<b>:</b><u>typeSpec</u>? ?<u>defaultValue</u>?. The <u>propertyName</u> is also used as to form the  names
                     of  the  getter/setter  methods,  if requested (see <b>-accessor</b>). It is, optionally, equipped
                     with a <u>typeSpec</u> following a colon delimiter which specifies a value checker for the  values
                     which become assigned to the property. The second, optional element sets a <u>defaultValue</u> for
                     this property.

                     If <b>-accessor</b> is set, a property will provide for different getter and setter methods:

                     <u>obj</u> <u>propertyName</u> <b>exists</b>
                            Returns  1  if the value store of <u>propertyName</u> (e.g., an object variable) exists and
                            has been given a value, returns 0 otherwise.

                     <u>obj</u> <u>propertyName</u> <b>set</b> <u>value</u>
                            Sets the property <u>propertyName</u> to <u>value</u>.

                     <u>obj</u> <u>propertyName</u> <b>get</b>
                            Returns the current value of property <u>propertyName</u>.

                     <u>obj</u> <u>propertyName</u> <b>unset</b>
                            Removes the value store of <u>propertyName</u> (e.g., an object variable), if existing.

                     The option value passed along <b>-accessor</b> sets the level of call protection for the generated
                     getter and setter methods: <b>public</b>, <b>protected</b>, or <b>private</b>. By default, no getter and  setter
                     methods are created.

                     Turning on the switch <b>-incremental</b> provides a refined setter interface to the value managed
                     by the property. First, setting <b>-incremental</b> implies requesting <b>-accessor</b> (set to <b>public</b> by
                     default, if not specified explicitly). Second, the managed value will be considered a valid
                     Tcl  list. A multiplicity of <b>1..*</b> is set by default, if not specified explicitly as part of
                     <u>spec</u>. Third, to manage this list value element-wise (<u>incrementally</u>), two additional  setter
                     methods become available:

                     <u>obj</u> <u>propertyName</u> <b>add</b> <u>element</u> ?<u>index</u>?
                            Adding  <u>element</u>  to  the managed list value, at the list position given by <u>index</u> (by
                            default: 0).

                     <u>obj</u> <u>propertyName</u> <b>delete</b> ?<b>-nocomplain</b>? <u>elementPattern</u>
                            Removing the first occurrence of an  element  from  the  managed  list  value  which
                            matches  <u>elementPattern</u>.  <u>elementPattern</u> can contain matching characters (see <b>string</b>
                            <b>match</b>). An error will be thrown if there is no match, unless <b>-nocomplain</b> is set.

              By setting <b>-configurable</b> to <b>true</b> (the default), the property can be accessed and modified  through
              <b>cget</b> and <b>configure</b>, respectively. If <b>false</b>, no configuration option will become available via <b>cget</b>
              and <b>configure</b>.

              If  neither <b>-accessor</b> nor <b>-configurable</b> are requested, the value managed by the property will have
              to be accessed and modified directly. If the property manages an object variable, its  value  will
              be readable and writable using <b>set</b> and <b>eval</b>.

              The  <b>-trace</b>  option  causes  certain  slot  methods  to  be executed whenever <b>get</b>, <b>set</b>, or <b>default</b>
              operations are invoked on the property:

                     •      <b>set</b>: <u>slot</u> <b>value=set</b> <u>obj</u> <u>propertyName</u> <u>value</u>

                     •      <b>get</b>: <u>slot</u> <b>value=get</b> <u>obj</u> <u>propertyName</u>

                     •      <b>default</b>: <u>slot</u> <b>value=default</b> <u>obj</u> <u>propertyName</u>

              A property becomes implemented by a slot object under any of the following conditions:

                     •      <b>-configurable</b> equals <b>true</b> (by default).

                     •      <b>-accessor</b> is one of <b>public</b>, <b>protected</b>, or <b>private</b>.

                     •      <b>-incremental</b> is turned on.

                     •      <u>initBlock</u> is a non-empty string.

                     Assuming default settings, every property is realized by a slot object.

                     Provided a slot object managing the property is to be created,  a  custom  class  <u>className</u>
                     from  which  this  slot  object  is to be instantiated can be set using <b>-class</b>. The default
                     value is <b>::nx::VariableSlot</b>.

                     The last argument <u>initBlock</u> accepts an  optional  Tcl  script  which  is  passed  into  the
                     initialization  procedure (see <b>configure</b>) of the property's slot object. See also <u>initBlock</u>
                     for <b>create</b> and <b>new</b>.

                     By default, the property will ascertain that  no  (potentially)  pre-existing  and  equally
                     named  object  variable  will  be  overwritten  when  defining  the  property. In case of a
                     conflict, an error exception is thrown:

                     % Object create obj { set :x 1 }
                     ::obj
                     % ::obj object property {x 2}
                     object ::obj has already an instance variable named 'x'

                     If the switch <b>-nocomplain</b> is on, this check is omitted (continuing the above example):

                     % ::obj object property -nocomplain {x 2}
                     % ::obj eval {set :x}
                     2

       <b>require</b>

              <u>obj</u> <b>require</b> <b>namespace</b>
                     Create a Tcl namespace named after the object <u>obj</u>. All object variables become available as
                     namespace variables.

              <u>obj</u> <b>require</b> ?<b>public</b> | <b>protected</b> | <b>private</b>? <b>object</b> <b>method</b> <u>methodName</u>
                     Attempts to register a method definition made available using <b>::nsf::method::provide</b>  under
                     the  name  <u>methodName</u>  with  <u>obj</u>  .  The  registered  method  is  subjected to default call
                     protection (<b>protected</b>), if not set explicitly.

       <b>unknown</b>

              <u>obj</u> <b>unknown</b> <u>unknownMethodName</u> ?<u>arg</u> ...?
                     This method is called implicitly whenever an unknown method is invoked.   <u>unknownMethodName</u>
                     indicates  the unresolvable method name, followed by the remainder of the original argument
                     vector as a number of <u>arg</u> of the calling method invocation.

       <b>uplevel</b>

              <u>obj</u> <b>uplevel</b> ?<u>level</u>? <u>arg1</u> ?<u>arg2</u> ...?
                     Evaluate a script or a command at a different stack-frame level.  The  command  behaves  in
                     essence  like  Tcl's  <b>uplevel</b>, but can be used to achieve identical results when filters or
                     mixins are registered.

                     •      If the <u>level</u> specifier is omitted, <b>uplevel</b> will skip any auxiliary frames  added  to
                            the  stack by active filters and mixins. The resulting stack-frame level corresponds
                            to the callinglevel as indicated by <b>nx::current</b>. In this case method <b>uplevel</b> can  be
                            used  to  evaluate  the  command in the next enclosing procedure call, i.e., a frame
                            corresponding to a proc, method, or apply call, while skipping frames of filters and
                            mixins.

                     •      If the <u>level</u> specifier is provided (relative, or absolute), <b>uplevel</b> will execute the
                            command in the stack-frame level. In such cases, method <b>uplevel</b> behaves  like  Tcl's
                            <b>uplevel</b> command.

                       % nx::Object create ::obj
                       ::obj
                       % ::obj public object method foo {varName} {
                           :uplevel set $varName 1; return
                       }
                       ::obj::foo
                       % namespace eval ::ns1 {
                            ::obj foo BAR
                       }
                       % namespace eval ::ns1 {
                           info exists BAR
                       }
                       1

              Note,  in  the example above, <b>uplevel</b> is guaranteed to resolve to the calling context of <b>foo</b> (ns1)
              despite mixins and filters being (potentially) registered on <b>obj</b>.

       <b>upvar</b>

              <u>obj</u> <b>upvar</b> ?<u>level</u>? <u>otherVar1</u> <u>localVar1</u> ?<u>otherVar2</u> <u>localVar2</u> ...?
                     Links one or more local  variables  to  variables  defined  in  other  scopes  (namespaces,
                     objects, call frames).  The command behaves in essence like Tcl's <b>upvar</b>, but can be used to
                     achieve identical results when filters or mixins are registered.

                     •      If the <u>level</u> specifier is omitted, <b>upvar</b> will skip any auxiliary frames added to the
                            stack  by  active filters and mixins. The resulting stack-frame level corresponds to
                            the callinglevel as indicated by <b>nx::current</b>. Therefore, method <b>upvar</b>  gives  access
                            to the next enclosing procedure call, i.e., a frame corresponding to a proc, method,
                            or apply call, while skipping frames of filters and mixins.

                     •      If the <u>level</u> specifier is provided (relative, or absolute), <b>upvar</b> will link into the
                            requested  stack-frame level. In these cases, method <b>upvar</b> behaves like Tcl's  <b>upvar</b>
                            command.

                       % nx::Object create ::obj
                       ::obj
                       % ::obj public object method foo {varName} {
                           :upvar $varName x; set x 1; return
                       }
                       ::obj::foo
                       % namespace eval ::ns1 {
                            ::obj foo BAR
                       }
                       % namespace eval ::ns1 {
                           info exists BAR
                       }
                       1

              Note, in the example above, <b>upvar</b> is guaranteed to resolve to the calling  context  of  <b>foo</b>  (ns1)
              despite mixins and filters being (potentially) registered on <b>obj</b>.

       <b>variable</b>

              <u>obj</u> <b>object</b> <b>variable</b> ?<b>-accessor</b> <b>public</b> | <b>protected</b> | <b>private</b>? ?<b>-incremental</b>? ?<b>-class</b> <u>className</u>?
              ?<b>-configurable</b> <u>trueFalse</u>? ?<b>-initblock</b> <u>script</u>? ?<b>-trace</b> <b>set</b> | <b>get</b> | <b>default</b>? ?<b>-nocomplain</b>? <u>spec</u>
              ?<u>defaultValue</u>?
                     Defines  a  variable  for  the  scope  of  the  object.  The  <u>spec</u>  provides  the  variable
                     specification:  <u>variableName</u>?<b>:</b><u>typeSpec</u>?.  The  <u>variableName</u>  will  be  used  to  name   the
                     underlying  Tcl variable and the getter/setter methods, if requested (see <b>-accessor</b>).  <u>spec</u>
                     is optionally equipped with a <u>typeSpec</u> following a colon delimiter which specifies a  value
                     checker for the values managed by the variable. Optionally, a <u>defaultValue</u> can be defined.

                     If <b>-accessor</b> is set explicitly, a variable will provide for getter and setter methods:

                     <u>obj</u> <u>variableName</u> <b>exists</b>
                            Returns  1  if the value store of <u>variableName</u> (e.g., an object variable) exists and
                            has been given a value, returns 0 otherwise.

                     <u>obj</u> <u>variableName</u> <b>set</b> <u>varValue</u>
                            Sets <u>variableName</u> to <u>varValue</u>.

                     <u>obj</u> <u>variableName</u> <b>get</b>
                            Returns the current value of <u>variableName</u>.

                     <u>obj</u> <u>variableName</u> <b>unset</b>
                            Removes <u>variableName</u>, if existing, underlying the property.

                     The option value passed along <b>-accessor</b> sets the level of call protection  for  the  getter
                     and setter methods: <b>public</b>, <b>protected</b>, or <b>private</b>. By default, no getter and setter methods
                     are created.

                     Turning on the switch <b>-incremental</b> provides a refined setter interface to the value managed
                     by  the  variable.  First,  setting  <b>-incremental</b>  implies  requesting <b>-accessor</b> (<b>public</b> by
                     default, if not specified explicitly). Second, the managed value will be considered a valid
                     Tcl list. A multiplicity of <b>1..*</b> is set by default, if not specified explicitly as part  of
                     <u>spec</u>  (see  above).  Third,  to  manage  this  list value element-wise (<u>incrementally</u>), two
                     additional setter operations become available:

                     <u>obj</u> <u>variableName</u> <b>add</b> <u>element</u> ?<u>index</u>?
                            Adding <u>element</u> to the managed list value, at the list position given  by  <u>index</u>  (by
                            default: 0).

                     <u>obj</u> <u>variableName</u> <b>delete</b> ?<b>-nocomplain</b>? <u>elementPattern</u>
                            Removing  the  first  occurrence  of  an  element  from the managed list value which
                            matches <u>elementPattern</u>. <u>elementPattern</u> can contain matching characters  (see  <b>string</b>
                            <b>match</b>). An error will be thrown if there is no match, unless <b>-nocomplain</b> is set.

              By  setting  <b>-configurable</b>  to  <b>true</b>,  the  variable  can  be  accessed  and modified via <b>cget</b> and
              <b>configure</b>, respectively. If <b>false</b> (the default), the interface based on <b>cget</b>  and  <b>configure</b>  will
              not  become  available.  In  this  case,  and  provided that <b>-accessor</b> is set, the variable can be
              accessed and modified via the getter/setter methods. Alternatively, the underlying  Tcl  variable,
              which  is  represented  by the variable, can always be accessed and modified directly, e.g., using
              <b>eval</b>. By default, <b>-configurable</b> is <b>false</b>.

              The <b>-trace</b> option causes certain slot methods  to  be  executed  whenever  <b>get</b>,  <b>set</b>,  or  <b>default</b>
              operations are invoked on the variable:

                     •      <b>set</b>: <u>slot</u> <b>value=set</b> <u>obj</u> <u>variableName</u> <u>value</u>

                     •      <b>get</b>: <u>slot</u> <b>value=get</b> <u>obj</u> <u>variableName</u>

                     •      <b>default</b>: <u>slot</u> <b>value=default</b> <u>obj</u> <u>variableName</u>

              A variable becomes implemented by a slot object under any of the following conditions:

                     •      <b>-configurable</b> equals <b>true</b>.

                     •      <b>-accessor</b> is one of <b>public</b>, <b>protected</b>, or <b>private</b>.

                     •      <b>-incremental</b> is turned on.

                     •      <b>-initblock</b> is a non-empty string.

                     Provided  a  slot  object  managing the variable is to be created, a custom class <u>className</u>
                     from which this slot object is to be instantiated can be  set  using  <b>-class</b>.  The  default
                     value is <b>::nx::VariableSlot</b>.

                     Using  <b>-initblock</b>,  an  optional  Tcl  <u>script</u>  can be defined which becomes passed into the
                     initialization procedure (see <b>configure</b>) of the variable's slot object. See also  <u>initBlock</u>
                     for <b>create</b> and <b>new</b>.

                     By  default,  the  variable  will  ascertain  that  a pre-existing and equally named object
                     variable will not be overwritten when defining the variable. In  case  of  a  conflict,  an
                     error exception is thrown:

                     % Object create obj { set :x 1 }
                     ::obj
                     % ::obj object variable x 2
                     object ::obj has already an instance variable named 'x'

                     If the switch <b>-nocomplain</b> is on, this check is omitted (continuing the above example):

                     % ::obj object variable -nocomplain x 2
                     % ::obj eval {set :x}
                     2

</pre><h4><b>OBJECT</b> <b>SELF-REFERENCE</b></h4><pre>
       Objects are naturally recursive, with methods of an object <b>::obj</b> frequently invoking other methods in the
       same  object <b>::obj</b> and accessing <b>::obj</b>'s object variables. To represent these self-references effectively
       in method bodies, and depending on the usage scenario, NX offers  two  alternative  notations  for  self-
       references:  one based on a special-purpose syntax token ("colon prefix"), the other based on the command
       <b>nx::current</b>.

       Both, the colon-prefix notation and <b>nx::current</b>, may be used only in method bodies and scripts passed  to
       <b>eval</b>.  If they appear anywhere else, an error will be reported.  There are three main use cases for self-
       references:

       [1]    As a <u>placeholder</u> for the currently active object, <b>nx::current</b> can be used to retrieve  the  object
              name.

       [2]    Reading  and  writing  <u>object</u>  <u>variables</u>  directly  (i.e.  without getter/setter methods in place)
              require the use of variable names carrying the prefix  <b>:</b>  ("colon-prefix  notation").  Internally,
              colon-prefixed variable names are processed using Tcl's variable resolvers. Alternatively, one can
              provide for getter/setter methods for object variables (see <b>property</b> and <b>variable</b>).

       [3]    <u>Self-referential</u> <u>method</u> <u>calls</u> can be defined via prefixing (<b>:</b>) the method names or, alternatively,
              via  <b>nx::current</b>.  Internally,  colon-prefixed  method  names  are  processed  using Tcl's command
              resolvers. The colon-prefix notation is recommended, also because it has  a  (slight)  performance
              advantage over <b>nx::current</b> which requires two rather than one command evaluation per method call.

       See the following listing for some examples corresponding to use cases 1--3:

                Object create ::obj {
                  # 1) print name of currently active object ('::obj')
                  puts [current];
                  # 2) object variables
                  set :x 1; :object variable y 2;
                  :public object method print {} {
                    # 2.a) method-local variable
                    set z 3;
                    # 2.b) variable substitution using '$' and ':'
                    puts ${:x}-${:y}-$z;
                    # 2.c) reading variables using 'set'
                    puts [set :x]-[set :y]-[set z];
                    # 2.d) writing variables using 'set', 'incr', ...
                    set :x 1; incr :y;
                  }
                  :public object method show {} {
                    # 3.a) self-referential method call using ':'
                    :print;
                    # 3.b) self-referential method call using 'nx::current'
                    [current] print;
                    # 3.c) self-referential method call using 'nx::current object'
                    [current object] print;
                  }
                  :show
                }

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2014-19 Stefan Sobernig &lt;<a href="mailto:stefan.sobernig@wu.ac.at">stefan.sobernig@wu.ac.at</a>&gt;, Gustaf Neumann &lt;<a href="mailto:gustaf.neumann@wu.ac.at">gustaf.neumann@wu.ac.at</a>&gt;; available under the Creative Commons Attribution 3.0 Austria license (CC BY 3.0 AT).

Object                                                2.4.0                                      <u>nx::<a href="../man3nx/Object.3nx.html">Object</a></u>(3nx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>