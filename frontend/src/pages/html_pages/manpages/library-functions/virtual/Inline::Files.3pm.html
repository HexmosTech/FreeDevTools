<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inline::Files - Multiple virtual files at the end of your code</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libinline-files-perl">libinline-files-perl_0.71-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Inline::Files - Multiple virtual files at the end of your code

</pre><h4><b>VERSION</b></h4><pre>
       This document describes version 0.69 of Inline::Files, released June 24, 2015.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Inline::Files;

           my Code $here;

           # etc.
           # etc.
           # etc.

           __FOO__
           This is a virtual file at the end
           of the data

           __BAR__
           This is another
           virtual

           file
           __FOO__
           This is yet another
           such file

</pre><h4><b>WARNING</b></h4><pre>
       It is possible that this module may overwrite the source code in files that use it. To protect yourself
       against this possibility, you are <u>strongly</u> advised to use the "-backup" option described in "Safety
       first".

       This module is still experimental. Regardless of whether you use "-backup" or not, by using this module
       you agree that the authors will b&lt;under no circumstances&gt; be responsible for any loss of data, code,
       time, money, or limbs, or for any other disadvantage incurred as a result of using Inline::Files.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Inline::Files generalizes the notion of the "__DATA__" marker and the associated "&lt;DATA&gt;" filehandle, to
       an arbitrary number of markers and associated filehandles.

       When you add the line:

           use Inline::Files;

       to a source file you can then specify an arbitrary number of distinct virtual files at the end of the
       code. Each such virtual file is marked by a line of the form:

           __SOME_SYMBOL_NAME_IN_UPPER_CASE__

       The following text -- up to the next such marker -- is treated as a file, whose (pseudo-)name is
       available as an element of the package array @SOME_SYMBOL_NAME_IN_UPPER_CASE. The name of the first
       virtual file with this marker is also available as the package scalar $SOME_SYMBOL_NAME_IN_UPPER_CASE.

       The filehandle of the same name is magical -- just like "ARGV" -- in that it automatically opens itself
       when first read. Furthermore -- just like "ARGV" -- the filehandle re-opens itself to the next
       appropriate virtual file (by "shift"-ing the first element of @SOME_SYMBOL_NAME_IN_UPPER_CASE into
       $SOME_SYMBOL_NAME_IN_UPPER_CASE) whenever it reaches EOF.

       So, just as with "ARGV", you can treat all the virtual files associated with a single symbol either as a
       single, multi-part file:

           use Inline::Files;

           while (&lt;FILE&gt;) {
               print "$FILE: $_";
           }

           __FILE__
           File 1
           here

           __FILE__
           File 2
           here

           __OTHER_FILE__
           Other file 1

           __FILE__
           File 3
           here

       or as a series of individual files:

           use Inline::Files;

           foreach $filename (@FILE) {
               open HANDLE, $filename;
               print "&lt;&lt;$filename&gt;&gt;\n";
               while (&lt;HANDLE&gt;) {
                   print;
               }
           }

           __FILE__
           File 1
           here

           __FILE__
           File 2
           here

           __OTHER_FILE__
           Other file 1

           __FILE__
           File 3
           here

       Note that these two examples completely ignore the lines:

           __OTHER_FILE__
           Other file 1

       which would be accessed via the "OTHER_FILE" filehandle.

       Unlike "&lt;ARGV&gt;"/@ARGV/$ARGV, Inline::Files also makes use of the hash associated with an inline file's
       symbol. That is, when you create an inline file with a marker "__WHATEVER__", the hash %WHATEVER will
       contain information about that file. That information is:

       $WHATEVER{file}
           The name of the disk file in which the inlined "__WHATEVER__" files were defined;

       $WHATEVER{line}
           The  line  (starting  from  1)  at  which  the  current  inline "__WHATEVER__" file being accessed by
           "&lt;WHATEVER&gt;" started.

       $WHATEVER{offset}
           The byte offset (starting from 0) at which the current inline "__WHATEVER__" file being  accessed  by
           "&lt;WHATEVER&gt;" started.

       $WHATEVER{writable}
           Whether the the current inline file being accessed by "&lt;WHATEVER&gt;" is opened for output.

       The  hash  and its elements are read-only and the entry values are only meaningful when the corresponding
       filehandle is open.

   <b>Writable</b> <b>virtual</b> <b>files</b>
       If the source file that uses Inline::Files is itself writable, then the virtual  files  it  contains  may
       also be opened for write access. For example, here is a very simple persistence mechanism:

           use Inline::Files;
           use Data::Dumper;

           open CACHE or die $!;   # read access (uses $CACHE to locate file)
           eval join "", &lt;CACHE&gt;;
           close CACHE or die $!;

           print "\$var was '$var'\n";
           while (&lt;&gt;) {
               chomp;
               $var = $_;
               print "\$var now '$var'\n";
           }

           open CACHE, "&gt;$CACHE" or die $!;    # write access
           print CACHE Data::Dumper-&gt;Dump([$var],['var']);
           close CACHE or die $!;

           __CACHE__
           $var = 'Original value';

       <u>Unlike</u> "ARGV", if a virtual file is part of a writable file and is automagically opened, it is opened for
       full read/write access. So the above example, could be even simpler:

           use Inline::Files;
           use Data::Dumper;

           eval join "", &lt;CACHE&gt;;      # Automagically opened

           print "\$var was '$var'\n";
           while (&lt;&gt;) {
               chomp;
               $var = $_;
               print "\$var now '$var'\n";
           }

           seek CACHE, 0, 0;
           print CACHE Data::Dumper-&gt;Dump([$var],['var']);

           __CACHE__
           $var = 'Original value';

       In  either case, the original file is updated only at the end of execution, on an explicit "close" of the
       virtual file's handle, or when "Inline::Files::Virtual::vf_save" is explicitly called.

   <b>Creating</b> <b>new</b> <b>Inline</b> <b>files</b> <b>on</b> <b>the</b> <b>fly.</b>
       You can also open up new Inline output files at run time. Simply use the open function with a  valid  new
       Inline file handle name and <b>no</b> file name. Like this:

           use Inline::Files;

           open IFILE, '&gt;';

           print IFILE "This line will be placed into a new Inline file\n";
           print IFILE "which is marked by '__IFILE__'\n";

   <b>Safety</b> <b>first</b>
       Because  Inline::Files  handles  are  often  read-write, it's possible to accidentally nuke your hard-won
       data. But Inline::Files can save you from yourself.

       If Inline::Files is loaded with the "-backup" option:

           use Inline::Files -backup;

       then the source file that uses it is backed up before the inline files are extracted. The backup file  is
       the name of the source file with the suffix ".bak" appended.

       You  can  also  specify a different name for the backup file, by associating that name with the "-backup"
       flag:

           use Inline::Files -backup =&gt; '/tmp/sauve_qui_peut';

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The Inline::Files::Virtual module

       The Filter::Util::Call module

   <b>BUGS</b> <b>ADDED</b> <b>BY</b>
       Alberto Simoes  (<a href="mailto:ambs@cpan.org">ambs@cpan.org</a>)

</pre><h4><b>UNWITTING</b> <b>PAWN</b> <b>OF</b> <b>AN</b> <b>AUTHOR</b></h4><pre>
       Damian Conway  (<a href="mailto:damian@conway.org">damian@conway.org</a>)

</pre><h4><b>EVIL</b> <b>MASTERMIND</b> <b>BEHIND</b> <b>IT</b> <b>ALL</b></h4><pre>
       Brian Ingerson (<a href="mailto:INGY@cpan.org">INGY@cpan.org</a>)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2001-2009. Damian Conway. All rights reserved.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself.

       See <a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>

perl v5.36.0                                       2022-12-06                                 <u>Inline::<a href="../man3pm/Files.3pm.html">Files</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>