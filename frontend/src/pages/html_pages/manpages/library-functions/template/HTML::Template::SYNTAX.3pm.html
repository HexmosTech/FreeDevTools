<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Template::SYNTAX - syntax of html template language for HTML::Template</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-template-pro-perl">libhtml-template-pro-perl_0.9524-1build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Template::SYNTAX - syntax of html template language for HTML::Template

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This help is only on syntax of html template files.  For perl interface of HTML::Template::Pro you should
       see "SYNOPSIS" in HTML::Template::PerlInterface.

       First you make a template - this is just a normal HTML file with a few extra tags, the simplest being
       &lt;TMPL_VAR&gt;

       For example, test.tmpl:

         &lt;html&gt;
         &lt;head&gt;&lt;title&gt;Test Template&lt;/title&gt;
         &lt;body&gt;
         My Home Directory is &lt;TMPL_VAR NAME=HOME&gt;
         &lt;p&gt;
         My Path is set to &lt;TMPL_VAR NAME=PATH&gt;
         &lt;/body&gt;
         &lt;/html&gt;

       Now define the value for HOME and PATH, for example, in perl it will look like

         $template-&gt;param(HOME =&gt; $ENV{HOME});
         $template-&gt;param(PATH =&gt; $ENV{PATH});

       and process the template. If all is well in the universe this should show something like this in your
       browser:

         My Home Directory is /home/some/directory
         My Path is set to <a href="file:/bin">/bin</a>;<a href="file:/usr/bin">/usr/bin</a>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module attempts to make using HTML templates simple and natural.  It extends standard HTML with a
       few new HTML-esque tags - &lt;TMPL_VAR&gt;, &lt;TMPL_LOOP&gt;, &lt;TMPL_INCLUDE&gt;, &lt;TMPL_IF&gt;, &lt;TMPL_ELSE&gt; and
       &lt;TMPL_UNLESS&gt;.  (HTML::Template::Pro also supports &lt;TMPL_ELSIF&gt; tag.)  The file written with HTML and
       these new tags is called a template.  It is usually saved separate from your script - possibly even
       created by someone else!  Using this module you fill in the values for the variables, loops and branches
       declared in the template.  This allows you to separate design - the HTML - from the data, which you
       generate in the Perl script.

       This module is licensed under the (L)GPL or perl license.  See the LICENSE section below for more
       details.

</pre><h4><b>TUTORIAL</b></h4><pre>
       If you're new to HTML::Template, I suggest you start with the introductory article available on the
       HTML::Template website:

          <a href="http://html-template.sourceforge.net">http://html-template.sourceforge.net</a>

</pre><h4><b>MOTIVATION</b></h4><pre>
       It is true that there are a number of packages out there to do HTML templates.  On the one hand you have
       things like HTML::Embperl which allows you freely mix Perl with HTML.  On the other hand lie home-grown
       variable substitution solutions.  Hopefully the module can find a place between the two.

       One advantage of this module over a full HTML::Embperl-esque solution is that it enforces an important
       divide - design and programming.  By limiting the programmer to just using simple variables and loops in
       the HTML, the template remains accessible to designers and other non-perl people.  The use of HTML-esque
       syntax goes further to make the format understandable to others.  In the future this similarity could be
       used to extend existing HTML editors/analyzers to support HTML::Template.

       An advantage of this module over home-grown tag-replacement schemes is the support for loops.  In my work
       I am often called on to produce tables of data in html.  Producing them using simplistic HTML templates
       results in CGIs containing lots of HTML since the HTML itself cannot represent loops.  The introduction
       of loop statements in the HTML simplifies this situation considerably.  The designer can layout a single
       row and the programmer can fill it in as many times as necessary - all they must agree on is the
       parameter names.

       For all that, I think the best thing about this module is that it does just one thing and it does it
       quickly and carefully.  It doesn't try to replace Perl and HTML, it just augments them to interact a
       little better.  And it's pretty fast.

</pre><h4><b>THE</b> <b>TAGS</b></h4><pre>
   <b>GENERAL</b> <b>TAG</b> <b>SYNTAX</b>
       A generic HTML::Template tag that is supported by HTML::Template::Pro looks like &lt;TMPL_SOMETHING A="B"
       [C="D" ...]&gt;. Tags are case-insensitve: &lt;tmpl_something a="B" [c="D" ...]&gt; is acceptable.  Single quotes
       can be used, &lt;TMPL_SOMETHING A='B' [C='D' ...]&gt; quotes can be omitted, &lt;TMPL_SOMETHING A=B ... &gt; and
       option name could be often guessed as in &lt;TMPL_SOMETHING B&gt;.

       template tags could be decorated as html comments &lt;!-- TMPL_SOMETHING A="B" --&gt;

       Also, as HTML::Template::Pro extension (starting from version 0.90), template tags could also be
       decorated as xml &lt;TMPL_SOMETHING A="B" /&gt;

       See NOTES.

   <b>TMPL_VAR</b>
         &lt;TMPL_VAR NAME="PARAMETER_NAME"&gt;

       The &lt;TMPL_VAR&gt; tag is very simple.  For each &lt;TMPL_VAR&gt; tag in the template you call
       $template-&gt;param(PARAMETER_NAME =&gt; "VALUE").  When the template is output the &lt;TMPL_VAR&gt; is replaced with
       the VALUE text you specified.  If you don't set a parameter it just gets skipped in the output.

       Optionally you can use the "ESCAPE=HTML" option in the tag to indicate that you want the value to be
       HTML-escaped before being returned from output (the old ESCAPE=1 syntax is still supported).  This means
       that the ", &lt;, &gt;, and &amp; characters get translated into &amp;quot;, &amp;lt;, &amp;gt; and &amp;amp; respectively.  This
       is useful when you want to use a TMPL_VAR in a context where those characters would cause trouble.
       Example:

          &lt;input name=param type=text value="&lt;TMPL_VAR NAME="PARAM"&gt;"&gt;

       If you called param() with a value like sam"my you'll get in trouble with HTML's idea of a double-quote.
       On the other hand, if you use ESCAPE=HTML, like this:

          &lt;input name=param type=text value="&lt;TMPL_VAR ESCAPE=HTML NAME="PARAM"&gt;"&gt;

       You'll get what you wanted no matter what value happens to be passed in for param.  You can also write
       ESCAPE="HTML", ESCAPE='HTML' and ESCAPE='1'.

       "ESCAPE=0" and "ESCAPE=NONE" turn off escaping, which is the default behavior.

       There is also the "ESCAPE=URL" option which may be used for VARs that populate a URL.  It will do URL
       escaping, like replacing ' ' with '+' and '/' with '%2F'.

       There is also the "ESCAPE=JS" option which may be used for VARs that need to be placed within a
       Javascript string. All \n, \r, ' and " characters are escaped.

       You can assign a default value to a variable with the DEFAULT attribute.  For example, this will output
       "the devil gave me a taco" if the "who" variable is not set.

         The &lt;TMPL_VAR NAME=WHO DEFAULT=devil&gt; gave me a taco.

   <b>TMPL_LOOP</b>
         &lt;TMPL_LOOP NAME="LOOP_NAME"&gt; ... &lt;/TMPL_LOOP&gt;

       The &lt;TMPL_LOOP&gt; tag is a bit more complicated than &lt;TMPL_VAR&gt;.  The &lt;TMPL_LOOP&gt; tag allows you to delimit
       a section of text and give it a name.  Inside this named loop you place &lt;TMPL_VAR&gt;s.  Now you pass to
       param() a list (an array ref) of parameter assignments (hash refs) for this loop.  The loop iterates over
       the list and produces output from the text block for each pass.  Unset parameters are skipped.  Here's an
       example:

        In the template:

          &lt;TMPL_LOOP NAME=EMPLOYEE_INFO&gt;
             Name: &lt;TMPL_VAR NAME=NAME&gt; &lt;br&gt;
             Job:  &lt;TMPL_VAR NAME=JOB&gt;  &lt;p&gt;
          &lt;/TMPL_LOOP&gt;

        In the script:

          $template-&gt;param(EMPLOYEE_INFO =&gt; [
                                              { name =&gt; 'Sam', job =&gt; 'programmer' },
                                              { name =&gt; 'Steve', job =&gt; 'soda jerk' },
                                            ]
                          );
          print $template-&gt;output();

        The output in a browser:

          Name: Sam
          Job: programmer

          Name: Steve
          Job: soda jerk

       As you can see above the &lt;TMPL_LOOP&gt; takes a list of variable assignments and then iterates over the loop
       body producing output.

       Often you'll want to generate a &lt;TMPL_LOOP&gt;'s contents programmatically.  Here's an example of how this
       can be done (many other ways are possible!):

          # a couple of arrays of data to put in a loop:
          my @words = qw(I Am Cool);
          my @numbers = qw(1 2 3);

          my @loop_data = ();  # initialize an array to hold your loop

          while (@words and @numbers) {
            my %row_data;  # get a fresh hash for the row data

            # fill in this row
            $row_data{WORD} = shift @words;
            $row_data{NUMBER} = shift @numbers;

            # the crucial step - push a reference to this row into the loop!
            push(@loop_data, \%row_data);
          }

          # finally, assign the loop data to the loop param, again with a
          # reference:
          $template-&gt;param(THIS_LOOP =&gt; \@loop_data);

       The above example would work with a template like:

          &lt;TMPL_LOOP NAME="THIS_LOOP"&gt;
             Word: &lt;TMPL_VAR NAME="WORD"&gt;     &lt;br&gt;
             Number: &lt;TMPL_VAR NAME="NUMBER"&gt; &lt;p&gt;
          &lt;/TMPL_LOOP&gt;

       It would produce output like:

          Word: I
          Number: 1

          Word: Am
          Number: 2

          Word: Cool
          Number: 3

       &lt;TMPL_LOOP&gt;s within &lt;TMPL_LOOP&gt;s are fine and work as you would expect.  If the syntax for the param()
       call has you stumped, here's an example of a param call with one nested loop:

         $template-&gt;param(LOOP =&gt; [
                                   { name =&gt; 'Bobby',
                                     nicknames =&gt; [
                                                   { name =&gt; 'the big bad wolf' },
                                                   { name =&gt; 'He-Man' },
                                                  ],
                                   },
                                  ],
                         );

       Basically, each &lt;TMPL_LOOP&gt; gets an array reference.  Inside the array are any number of hash references.
       These hashes contain the name=&gt;value pairs for a single pass over the loop template.

       Inside a &lt;TMPL_LOOP&gt;, the only variables that are usable are the ones from the &lt;TMPL_LOOP&gt;.  The
       variables in the outer blocks are not visible within a template loop.  For the computer-science geeks
       among you, a &lt;TMPL_LOOP&gt; introduces a new scope much like a perl subroutine call.  If you want your
       variables to be global you can use 'global_vars' option to <b>new()</b> described below.

   <b>TMPL_INCLUDE</b>
         &lt;TMPL_INCLUDE NAME="filename.tmpl"&gt;
         &lt;TMPL_INCLUDE EXPR="function_call, variable, expression" DEFAULT='some_file'&gt;

       This tag includes a template directly into the current template at the point where the tag is found.  The
       included template contents are used exactly as if its contents were physically included in the master
       template.

       The file specified can be an absolute path (beginning with a '/' under Unix, for example).  If it isn't
       absolute, the path to the enclosing file is tried first.  After that the path in the environment variable
       HTML_TEMPLATE_ROOT is tried, if it exists.  Next, the "path" option is consulted, first as-is and then
       with HTML_TEMPLATE_ROOT prepended if available.  As a final attempt, the filename is passed to <b>open()</b>
       directly.  See below for more information on HTML_TEMPLATE_ROOT and the "path" option to <b>new()</b>.

       As a protection against infinitly recursive includes, an arbitrary limit of 10 levels deep is imposed.
       You can alter this limit with the "max_includes" option.  See the entry for the "max_includes" option
       below for more details.

       For the &lt;TMPL_INCLUDE EXPR=".."&gt; see "INCLUDE extension to Expr" for more details.

   <b>TMPL_IF</b>
         &lt;TMPL_IF NAME="PARAMETER_NAME"&gt; ... &lt;/TMPL_IF&gt;

       The &lt;TMPL_IF&gt; tag allows you to include or not include a block of the template based on the value of a
       given parameter name.  If the parameter is given a value that is true for Perl - like '1' - then the
       block is included in the output.  If it is not defined, or given a false value - like '0' - then it is
       skipped.  The parameters are specified the same way as with TMPL_VAR.

       Example Template:

          &lt;TMPL_IF NAME="BOOL"&gt;
            Some text that only gets displayed if BOOL is true!
          &lt;/TMPL_IF&gt;

       Now if you call $template-&gt;param(BOOL =&gt; 1) then the above block will be included by output.

       &lt;TMPL_IF&gt; &lt;/TMPL_IF&gt; blocks can include any valid HTML::Template construct - VARs and LOOPs and other
       IF/ELSE blocks.  Note, however, that intersecting a &lt;TMPL_IF&gt; and a &lt;TMPL_LOOP&gt; is invalid.

          Not going to work:
          &lt;TMPL_IF BOOL&gt;
             &lt;TMPL_LOOP SOME_LOOP&gt;
          &lt;/TMPL_IF&gt;
             &lt;/TMPL_LOOP&gt;

       If the name of a TMPL_LOOP is used in a TMPL_IF, the IF block will output if the loop has at least one
       row.  Example:

         &lt;TMPL_IF LOOP_ONE&gt;
           This will output if the loop is not empty.
         &lt;/TMPL_IF&gt;

         &lt;TMPL_LOOP LOOP_ONE&gt;
           ....
         &lt;/TMPL_LOOP&gt;

       WARNING: Much of the benefit of HTML::Template is in decoupling your Perl and HTML.  If you introduce
       numerous cases where you have TMPL_IFs and matching Perl <b>if()</b>s, you will create a maintenance problem in
       keeping the two synchronized.  I suggest you adopt the practice of only using TMPL_IF if you can do so
       without requiring a matching <b>if()</b> in your Perl code.

   <b>TMPL_ELSIF</b>
         &lt;TMPL_IF NAME="PARAMETER_NAME1"&gt; ...
         &lt;TMPL_ELSIF NAME="PARAMETER_NAME2"&gt; ...
         &lt;TMPL_ELSIF NAME="PARAMETER_NAME3"&gt; ...
         &lt;TMPL_ELSE&gt; ... &lt;/TMPL_IF&gt;

       WARNING: TMPL_ELSIF is a HTML::Template::Pro extension! It is not supported in HTML::Template (as of
       2.9).

   <b>TMPL_ELSE</b>
         &lt;TMPL_IF NAME="PARAMETER_NAME"&gt; ... &lt;TMPL_ELSE&gt; ... &lt;/TMPL_IF&gt;

       You can include an alternate block in your TMPL_IF block by using TMPL_ELSE.  NOTE: You still end the
       block with &lt;/TMPL_IF&gt;, not &lt;/TMPL_ELSE&gt;!

          Example:

          &lt;TMPL_IF BOOL&gt;
            Some text that is included only if BOOL is true
          &lt;TMPL_ELSE&gt;
            Some text that is included only if BOOL is false
          &lt;/TMPL_IF&gt;

   <b>TMPL_UNLESS</b>
         &lt;TMPL_UNLESS NAME="PARAMETER_NAME"&gt; ... &lt;/TMPL_UNLESS&gt;

       This tag is the opposite of &lt;TMPL_IF&gt;.  The block is output if the CONTROL_PARAMETER is set false or not
       defined.  You can use &lt;TMPL_ELSE&gt; with &lt;TMPL_UNLESS&gt; just as you can with &lt;TMPL_IF&gt;.

         Example:

         &lt;TMPL_UNLESS BOOL&gt;
           Some text that is output only if BOOL is FALSE.
         &lt;TMPL_ELSE&gt;
           Some text that is output only if BOOL is TRUE.
         &lt;/TMPL_UNLESS&gt;

       If the name of a TMPL_LOOP is used in a TMPL_UNLESS, the UNLESS block output if the loop has zero rows.

         &lt;TMPL_UNLESS LOOP_ONE&gt;
           This will output if the loop is empty.
         &lt;/TMPL_UNLESS&gt;

         &lt;TMPL_LOOP LOOP_ONE&gt;
           ....
         &lt;/TMPL_LOOP&gt;

   <b>NOTES</b>
       HTML::Template's tags are meant to mimic normal HTML tags.  However, they are allowed to "break the
       rules".  Something like:

          &lt;img src="&lt;TMPL_VAR IMAGE_SRC&gt;"&gt;

       is not really valid HTML, but it is a perfectly valid use and will work as planned.

       The "NAME=" in the tag is optional, although for extensibility's sake I recommend using it.  Example -
       "&lt;TMPL_LOOP LOOP_NAME&gt;" is acceptable.

       If you're a fanatic about valid HTML and would like your templates to conform to valid HTML syntax, you
       may optionally type template tags in the form of HTML comments. This may be of use to HTML authors who
       would like to validate their templates' HTML syntax prior to HTML::Template processing, or who use DTD-
       savvy editing tools.

         &lt;!-- TMPL_VAR NAME=PARAM1 --&gt;

       In order to realize a dramatic savings in bandwidth, the standard (non-comment) tags will be used
       throughout this documentation.

</pre><h4><b>EXPR</b> <b>EXTENSION</b></h4><pre>
       This module supports an extension to HTML::Template which allows expressions in the template syntax which
       was implemented in HTML::Template::Expr. See HTML::Template::Expr for details.

       Expression support includes comparisons, math operations, string operations and a mechanism to allow you
       add your own functions at runtime.  The basic syntax is:

          &lt;TMPL_IF EXPR="banana_count &gt; 10"&gt;
            I've got a lot of bananas.
          &lt;/TMPL_IF&gt;

       This will output "I've got a lot of bananas" if you call:

          $template-&gt;param(banana_count =&gt; 100);

       In your script.  &lt;TMPL_VAR&gt;s also work with expressions:

          I'd like to have &lt;TMPL_VAR EXPR="banana_count * 2"&gt; bananas.

       This will output "I'd like to have 200 bananas." with the same <b>param()</b> call as above.

</pre><h4><b>BASIC</b> <b>SYNTAX</b></h4><pre>
   <b>Variables</b>
       Variables are unquoted alphanumeric strings with the same restrictions as variable names in
       HTML::Template.  Their values are set through <b>param()</b>, just like normal HTML::Template variables.  For
       example, these two lines are equivalent:

          &lt;TMPL_VAR EXPR="foo"&gt;

          &lt;TMPL_VAR NAME="foo"&gt;

   <b>Emiliano</b> <b>Bruni</b> <b>extension</b> <b>to</b> <b>Expr</b>
       original HTML::Template allows almost arbitrary chars in parameter names, but original
       HTML::Template::Expr (as to 0.04) allows variables in the 'EXPR' tag to be only
       m![A-Za-z_][A-Za-z0-9_]*!.

       With this extension, arbitrary chars can be used in variable name inside the 'EXPR' tag if bracketed in
       ${}, as, for example, EXPR="${foo.bar} eq 'a'".  Note that old bracketing into {} is considered obsolete,
       as it will clash with JSON assignments like A = { "key" =&gt; "val" }.

       COMPATIBILITY WARNING.  Currently, this extension is not present in HTML::Template::Expr (as of 0.04).

   <b>INCLUDE</b> <b>extension</b> <b>to</b> <b>Expr</b>
       With this extension, you can write something like &lt;TMPL_INCLUDE EXPR="variable"&gt;
        or &lt;TMPL_INCLUDE EXPR="<b>function_call()</b>"&gt;, or even &lt;TMPL_INCLUDE EXPR="function_call(VAR1,VAR2,<b>func2()</b>)
       DEFAULT='some_file'"&gt;

       SECURITY WARNING.  Using of this extension with untrasted values of variables is a potential security
       leak (as in &lt;TMPL_INCLUDE EXPR="USER_INPUT"&gt; with USER_INPUT='<a href="file:/etc/passwd">/etc/passwd</a>').  Omit it unless you know
       what you are doing.

       COMPATIBILITY WARNING.  Currently, this extension is not present in HTML::Template::Expr (as of 0.04).

   <b>Constants</b>
       Numbers are unquoted strings of numbers and may have a single "." to indicate a floating point number.
       For example:

          &lt;TMPL_VAR EXPR="10 + 20.5"&gt;

       String constants must be enclosed in quotes, single or double.  For example:

          &lt;TMPL_VAR EXPR="sprintf('%d', foo)"&gt;

       Note that the original parser of HTML::Template::Expr is currently (0.04) rather simple, so if you need
       backward compatibility all compound expressions must be parenthesized.

       Backward compatible examples:

          &lt;TMPL_VAR EXPR="(10 + foo) / bar"&gt;

          &lt;TMPL_IF EXPR="(foo % 10) &gt; (bar + 1)"&gt;

       Nevertheless, in HTML::Template::Pro, you can safely write things like

          &lt;TMPL_VAR EXPR="1+2*foo/bar^2 "&gt;

       with proper priority of operations.

       Pattern in a regular expression must be enclosed with "/":

          &lt;TMPL_VAR EXPR="foo =~ /bar/"&gt;

</pre><h4><b>COMPARISON</b></h4><pre>
       Here's a list of supported comparison operators:

       •   Numeric Comparisons

           •   &lt;

           •   &gt;

           •   ==

           •   !=

           •   &gt;=

           •   &lt;=

           •   &lt;=&gt;

       •   String Comparisons

           •   gt

           •   lt

           •   eq

           •   ne

           •   ge

           •   le

           •   cmp

</pre><h4><b>MATHEMATICS</b></h4><pre>
       The basic operators are supported:

       •   +

       •   -

       •   *

       •   /

       •   %

       •   ^ (not supported in HTML::Template::Expr)

       There are also some mathy functions.  See the FUNCTIONS section below.

</pre><h4><b>LOGIC</b></h4><pre>
       Boolean logic is available:

       •   &amp;&amp; (synonym: and)

       •   || (synonym: or)

</pre><h4><b>REGULAR</b> <b>EXPRESSION</b> <b>SUPPORT</b></h4><pre>
       regexp  support  is added to HTML::Template::Expr and HTML::Template::Pro by Stanislav Yadykin &lt;tosick at
       altlinux.ru&gt;.  Currently it is not included in official distribution of HTML::Template::Expr.

       Standard regexp syntax:

       •   =~

       •   !~

</pre><h4><b>FUNCTIONS</b></h4><pre>
       The following functions are available to be used in expressions.  See perldoc perlfunc for details.

       •   sprintf

       •   substr (2 and 3 arg versions only)

       •   lc

       •   lcfirst

       •   uc

       •   ucfirst

       •   length

       •   defined

       •   abs

       •   atan2

       •   cos

       •   exp

       •   hex

       •   int

       •   log

       •   oct

       •   rand

       •   sin

       •   sqrt

       •   srand

       All functions must be called using full parenthesis.  For example, this is a syntax error:

          &lt;TMPL_IF expr="defined foo"&gt;

       But this is good:

          &lt;TMPL_IF expr="defined(foo)"&gt;

</pre><h4><b>EXPR:</b> <b>DEFINING</b> <b>NEW</b> <b>FUNCTIONS</b></h4><pre>
       You may also define functions of your own.  See HTML::Template::PerlInterface for details.

</pre><h4><b>AUTHOR</b></h4><pre>
       Sam Tregar, <a href="mailto:sam@tregar.com">sam@tregar.com</a> (Main text)

       I. Vlasenko, &lt;<a href="mailto:viy@altlinux.org">viy@altlinux.org</a>&gt; (Pecularities of HTML::Template::Pro)

</pre><h4><b>LICENSE</b></h4><pre>
         HTML::Template : A module for using HTML Templates with Perl
         Copyright (C) 2000-2008 Sam Tregar (<a href="mailto:sam@tregar.com">sam@tregar.com</a>)

         This module is free software; you can redistribute it and/or modify it
         under the terms of either:

         a) the GNU General Public License as published by the Free Software
         Foundation; either version 2, or (at your option) any later version,

         or

         b) the "Artistic License" which comes with this module.

         This program is distributed in the hope that it will be useful,
         but WITHOUT ANY WARRANTY; without even the implied warranty of
         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
         the GNU General Public License or the Artistic License for more details.

         You should have received a copy of the Artistic License with this
         module, in the file ARTISTIC.  If not, I'll be glad to provide one.

         You should have received a copy of the GNU General Public License
         along with this program; if not, write to the Free Software
         Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
         USA

perl v5.40.0                                       2024-10-20                        <u>HTML::Template::<a href="../man3pm/SYNTAX.3pm.html">SYNTAX</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>