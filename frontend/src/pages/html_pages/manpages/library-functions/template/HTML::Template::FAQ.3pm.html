<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Template::FAQ - Frequently Asked Questions about HTML::Template</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-template-perl">libhtml-template-perl_2.97-2build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Template::FAQ - Frequently Asked Questions about HTML::Template

</pre><h4><b>SYNOPSIS</b></h4><pre>
       In the interest of greater understanding I've started a FAQ section of the perldocs. Please look in here
       before you send me email.

</pre><h4><b>FREQUENTLY</b> <b>ASKED</b> <b>QUESTIONS</b></h4><pre>
   <b>Is</b> <b>there</b> <b>a</b> <b>place</b> <b>to</b> <b>go</b> <b>to</b> <b>discuss</b> <b>HTML::Template</b> <b>and/or</b> <b>get</b> <b>help?</b>
       There's a mailing-list for discussing HTML::Template at <a href="mailto:html-template-users@lists.sourceforge.net">html-template-users@lists.sourceforge.net</a>. Join
       at:

          <a href="http://lists.sourceforge.net/lists/listinfo/html-template-users">http://lists.sourceforge.net/lists/listinfo/html-template-users</a>

       If you just want to get email when new releases are available you can join the announcements mailing-list
       here:

           <a href="http://lists.sourceforge.net/lists/listinfo/html-template-announce">http://lists.sourceforge.net/lists/listinfo/html-template-announce</a>

   <b>Is</b> <b>there</b> <b>a</b> <b>searchable</b> <b>archive</b> <b>for</b> <b>the</b> <b>mailing-list?</b>
       Yes, you can find an archive of the SourceForge list here:

           <a href="http://dir.gmane.org/gmane.comp.lang.perl.modules.html-template">http://dir.gmane.org/gmane.comp.lang.perl.modules.html-template</a>

   <b>I</b> <b>want</b> <b>support</b> <b>for</b> <b>&lt;TMPL_XXX&gt;!</b> <b>How</b> <b>about</b> <b>it?</b>
       Maybe. I definitely encourage people to discuss their ideas for HTML::Template on the mailing list.
       Please be ready to explain to me how the new tag fits in with HTML::Template's mission to provide a fast,
       lightweight system for using HTML templates.

       NOTE: Offering to program said addition and provide it in the form of a patch to the most recent version
       of HTML::Template will definitely have a softening effect on potential opponents!

   <b>I</b> <b>found</b> <b>a</b> <b>bug,</b> <b>can</b> <b>you</b> <b>fix</b> <b>it?</b>
       That depends. Did you send me the VERSION of HTML::Template, a test script and a test template? If so,
       then almost certainly.

       If you're feeling really adventurous, HTML::Template is publicly available on GitHub
       (https://github.com/mpeters/html-template). Please feel free to fork it and send me a pull request with
       any changes you have.

   <b>&lt;TMPL_VAR&gt;s</b> <b>from</b> <b>the</b> <b>main</b> <b>template</b> <b>aren't</b> <b>working</b> <b>inside</b> <b>a</b> <b>&lt;TMPL_LOOP&gt;!</b> <b>Why?</b>
       This is the intended behavior. "&lt;TMPL_LOOP&gt;" introduces a separate scope for "&lt;TMPL_VAR&gt;s" much like a
       subroutine call in Perl introduces a separate scope for "my" variables.

       If you want your "&lt;TMPL_VAR&gt;"s to be global you can set the "global_vars" option when you call new(). See
       above for documentation of the "global_vars" new() option.

   <b>How</b> <b>can</b> <b>I</b> <b>pre-load</b> <b>my</b> <b>templates</b> <b>using</b> <b>cache-mode</b> <b>and</b> <b>mod_perl?</b>
       Add something like this to your startup.pl:

           use HTML::Template;
           use File::Find;

           print STDERR "Pre-loading HTML Templates...\n";
           find(
               sub {
                   return unless /\.tmpl$/;
                   HTML::Template-&gt;new(
                       filename =&gt; "$File::Find::dir/$_",
                       cache    =&gt; 1,
                   );
               },
               '/path/to/templates',
               '/another/path/to/templates/'
           );

       Note that you'll need to modify the "return unless" line to specify the extension you use for your
       template files - I use <u>.tmpl</u>, as you can see. You'll also need to specify the path to your template
       files.

       One potential problem: the <u>/path/to/templates/</u> must be <b>EXACTLY</b> the same path you use when you call
       "HTML::Template-&gt;new()". Otherwise the cache won't know they're the same file and will load a new copy -
       instead getting a speed increase, you'll double your memory usage.  To find out if this is happening set
       "cache_debug =" 1&gt; in your application code and look for "CACHE MISS" messages in the logs.

   <b>What</b> <b>characters</b> <b>are</b> <b>allowed</b> <b>in</b> <b>TMPL_*</b> <b>names?</b>
       Numbers, letters, '.', '/', '+', '-' and '_'.

   <b>How</b> <b>can</b> <b>I</b> <b>execute</b> <b>a</b> <b>program</b> <b>from</b> <b>inside</b> <b>my</b> <b>template?</b>
       Short answer: you can't. Longer answer: you shouldn't since this violates the fundamental concept behind
       HTML::Template - that design and code should be separate.

       But, inevitably some people still want to do it. If that describes you then you should take a look at
       HTML::Template::Expr. Using HTML::Template::Expr it should be easy to write a run_program() function.
       Then you can do awful stuff like:

           &lt;tmpl_var expr="run_program('foo.pl')"&gt;

       Just, please, don't tell me about it. I'm feeling guilty enough just for writing HTML::Template::Expr in
       the first place.

   <b>What's</b> <b>the</b> <b>best</b> <b>way</b> <b>to</b> <b>create</b> <b>a</b> <b>&lt;select&gt;</b> <b>form</b> <b>element</b> <b>using</b> <b>HTML::Template?</b>
       There is much disagreement on this issue. My personal preference is to use CGI.pm's excellent
       popup_menu() and scrolling_list() functions to fill in a single "&lt;tmpl_var select_foo&gt;" variable.

       To some people this smacks of mixing HTML and code in a way that they hoped HTML::Template would help
       them avoid. To them I'd say that HTML is a violation of the principle of separating design from
       programming. There's no clear separation between the programmatic elements of the "&lt;form&gt;" tags and the
       layout of the "&lt;form&gt;" tags.  You'll have to draw the line somewhere - clearly the designer can't be
       entirely in charge of form creation.

       It's a balancing act and you have to weigh the pros and cons on each side. It is certainly possible to
       produce a "&lt;select&gt;" element entirely inside the template. What you end up with is a rat's nest of loops
       and conditionals. Alternately you can give up a certain amount of flexibility in return for vastly
       simplifying your templates. I generally choose the latter.

       Another option is to investigate HTML::FillInForm which some have reported success using to solve this
       problem.

perl v5.40.1                                       2025-02-18                           <u>HTML::Template::<a href="../man3pm/FAQ.3pm.html">FAQ</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>