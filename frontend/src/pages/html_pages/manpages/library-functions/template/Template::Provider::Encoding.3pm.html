<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template::Provider::Encoding - Explicitly declare encodings of your templates</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtemplate-provider-encoding-perl">libtemplate-provider-encoding-perl_0.10-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Template::Provider::Encoding - Explicitly declare encodings of your templates

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Template::Provider::Encoding;
         use Template::Stash::ForceUTF8;
         use Template;

         my $tt = Template-&gt;new(
             LOAD_TEMPLATES =&gt; [ Template::Provider::Encoding-&gt;new ],
             STASH =&gt; Template::Stash::ForceUTF8-&gt;new,
         );

         # Everything should be Unicode
         # (but you can pass UTF-8 bytes as well, thanks to Template::Stash::ForceUTF8)
         my $author = "\x{5bae}\x{5ddd}";

         # this will emit Unicode flagged string to STDOUT. You might
         # probably want to binmode(STDOUT, ":encoding($enccoding)")
         # before process() call
         $tt-&gt;process($template, { author =&gt; $author });

         # in your templates
         [% USE encoding 'utf-8' -%]
         My name is [% author %]. { ... whatever UTF-8 bytes }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Template::Provider::Encoding is a Template Provider subclass to decode template using its declaration.
       You have to declare encoding of the template in the head (1st line) of template using (fake) encoding TT
       plugin. Otherwise the template is handled as utf-8.

         [% USE encoding 'utf-8' %]
         Here comes utf-8 strings with [% variable %].

</pre><h4><b>DIFFERNCE</b> <b>WITH</b> <b>OTHER</b> <b>WAYS</b></h4><pre>
   <b>UNICODE</b> <b>option</b> <b>and</b> <b>BOM</b>
       Recent TT allows "UNICODE" option to Template::Provider and by adding it Provider scans BOM (byte-order
       mark) to detect UTF-8/UTF-16 encoded template files. This module does basically the same thing in a
       different way, but IMHO adding BOM to template files is a little painful especially for non-programmers.

   <b>Template::Provider::Encode</b>
       Template::Provider::Encode provides a very similar way to detect Template file encodings and output the
       template into various encodings.

       This module doesn't touch output encoding of the template and instead it emits valid Unicode flagged
       string. I think the output encoding conversion should be done by other piece of code, especially in the
       framework.

       This module doesn't require you to specify encoding in the code, nor doesn't <u>guess</u> encodings. Instead it
       forces you to put "[% USE encoding 'foo-bar' %]" in the top of template files, which is explicit and, I
       think, is a good convention.

</pre><h4><b>AUTHOR</b></h4><pre>
       Tatsuhiko Miyagawa &lt;<a href="mailto:miyagawa@bulknews.net">miyagawa@bulknews.net</a>&gt;

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Template::Stash::ForceUTF8, Template::Provider::Encode

perl v5.34.0                                       2022-06-17                  <u>Template::Provider::<a href="../man3pm/Encoding.3pm.html">Encoding</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>