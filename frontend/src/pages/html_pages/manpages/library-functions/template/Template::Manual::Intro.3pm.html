<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template::Manual::Intro - Introduction to the Template Toolkit</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtemplate-perl">libtemplate-perl_2.27-1build11_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Template::Manual::Intro - Introduction to the Template Toolkit

</pre><h4><b>Introduction</b></h4><pre>
       The Template Toolkit is a collection of Perl modules which implement a fast, flexible, powerful and
       extensible template processing system.  It is most often used for generating dynamic web content,
       although it can be used equally well for processing any kind of text documents.

       At the simplest level it provides an easy way to process template files, filling in embedded variable
       references with their equivalent values.  Here's an example of a template.

           Dear [% name %],

           It has come to our attention that your account is in
           arrears to the sum of [% debt %].

           Please settle your account before [% deadline %] or we
           will be forced to revoke your Licence to Thrill.

           The Management.

       By default, template directives are embedded within the character sequences "[%" ... "%]" but you can
       change these and various other options to configure how the Template Toolkit looks, feels and works.  You
       can set the "INTERPOLATE" option, for example, if you prefer to embed your variables in Perl style:

           Dear $name,

           It has come to our attention that your account is in
           arrears to the sum of $debt.

           ...etc...

</pre><h4><b>The</b> <b>Template</b> <b>Perl</b> <b>Module</b></h4><pre>
       The Template Perl module is the front end to the Template Toolkit for Perl programmers, providing access
       to the full range of functionality through a single module with a simple interface. It loads the other
       modules as required and instantiates a default set of objects to handle subsequent template processing
       requests. Configuration parameters may be passed to the Template constructor method, <b>new()</b>, which are
       then used to configure the generate object.

           use Template;

           my $tt = Template-&gt;new({
               INCLUDE_PATH =&gt; '/usr/local/templates',
               INTERPOLATE  =&gt; 1,
           }) || die "$Template::ERROR\n";

       The Template object implements a <b>process()</b> method for processing template files or text. The name of the
       input template (or various other sources) is passed as the first argument, followed by a reference to a
       hash array of variable definitions for substitution in the template.

           my $vars = {
               name     =&gt; 'Count Edward van Halen',
               debt     =&gt; '3 riffs and a solo',
               deadline =&gt; 'the next chorus',
           };

           $tt-&gt;process('letters/overdrawn', $vars)
               || die $tt-&gt;error(), "\n";

       The <b>process()</b> method returns a true value (1) on success and prints the template output to "STDOUT", by
       default. On error, the <b>process()</b> method returns a false value ("undef").  The <b>error()</b> method can then be
       called to retrieve details of the error.

</pre><h4><b>Component</b> <b>Based</b> <b>Content</b> <b>Construction</b></h4><pre>
       A number of special directives are provided, such as "INSERT", "INCLUDE" and "PROCESS", which allow
       content to be built up from smaller template components. This permits a modular approach to building a
       web site or other content repository, promoting reusability, cross-site consistency, ease of construction
       and subsequent maintenance. Common elements such as headers, footers, menu bars, tables, and so on, can
       be created as separate template files which can then be processed into other documents as required. All
       defined variables are inherited by these templates along with any additional "local" values specified.

           [% PROCESS header
                title = "The Cat Sat on the Mat"
           %]

           [% PROCESS menu %]

           The location of the missing feline has now been established.
           Thank you for your assistance.

           [% INSERT legal/disclaimer %]

           [% PROCESS footer %]

       You can also define a template as a BLOCK within the same file and PROCESS it just like any other
       template file.  This can be invaluable for building up repetitive elements such as tables, menus, etc.

           [% BLOCK tabrow %]
              &lt;tr&gt;&lt;td&gt;[% name %]&lt;/td&gt;&lt;td&gt;[% email %]&lt;/td&gt;&lt;/tr&gt;
           [% END %]

           &lt;table&gt;
           [% PROCESS tabrow name="tom"   email="<a href="mailto:tom@here.org">tom@here.org</a>"    %]
           [% PROCESS tabrow name="dick"  email="<a href="mailto:disk@there.org">disk@there.org</a>"  %]
           [% PROCESS tabrow name="larry" email="<a href="mailto:larry@where.org">larry@where.org</a>" %]
           &lt;/table&gt;

</pre><h4><b>Data</b> <b>and</b> <b>Code</b> <b>Binding</b></h4><pre>
       One of the key features that sets the Template Toolkit apart from other template processors is the
       ability to bind template variables to any kind of Perl data: scalars, lists, hash arrays, sub-routines
       and objects.

           my $vars = {
               root   =&gt; '<a href="http://here.com/there">http://here.com/there</a>',
               menu   =&gt; [ 'modules', 'authors', 'scripts' ],
               client =&gt; {
                   name =&gt; 'Doctor Joseph von Satriani',
                   id   =&gt; 'JVSAT',
               },
               checkout =&gt; sub { my $total = shift; ...; return $something },
               shopcart =&gt; My::Cool::Shopping::Cart-&gt;new(),
           };

       The Template Toolkit will automatically Do The Right Thing to access the data in an appropriate manner to
       return some value which can then be output. The dot operator '"."' is used to access into lists and
       hashes or to call object methods. The "FOREACH" directive is provided for iterating through lists, and
       various logical tests are available using directives such as "IF", "UNLESS", "ELSIF", "ELSE", "SWITCH",
       "CASE", etc.

           [% FOREACH section = menu %]
              &lt;a href="[% root %]/[% section %]/index.html"&gt;[% section %]&lt;/a&gt;
           [% END %]

           &lt;b&gt;Client&lt;/b&gt;: [% client.name %] (id: [% client.id %])

           [% IF shopcart.nitems %]
              Your shopping cart contains the following items:
              &lt;ul&gt;
              [% FOREACH item = shopcart.contents %]
                &lt;li&gt;[% item.name %] : [% item.qty %] @ [% item.price %]
              [% END %]
              &lt;/ul&gt;

              [% checkout(shopcart.total) %]

           [% ELSE %]
              No items currently in shopping cart.
           [% END %]

</pre><h4><b>Advanced</b> <b>Features:</b> <b>Filters,</b> <b>Macros,</b> <b>Exceptions,</b> <b>Plugins</b></h4><pre>
       The Template Toolkit also provides a number of additional directives for advanced processing and
       programmatical functionality.  It supports output filters (FILTER), allows custom macros to be defined
       (MACRO), has a fully-featured exception handling system (TRY, THROW, CATCH, FINAL) and supports a plugin
       architecture (USE) which allows special plugin modules and even regular Perl modules to be loaded and
       used with the minimum of fuss.  The Template Toolkit is "just" a template processor but you can trivially
       extend it to incorporate the functionality of any Perl module you can get your hands on.  Thus, it is
       also a scalable and extensible template framework, ideally suited for managing the presentation layer for
       application servers, content management systems and other web applications.

</pre><h4><b>Separating</b> <b>Presentation</b> <b>and</b> <b>Application</b> <b>Logic</b></h4><pre>
       Rather than embedding Perl code or some other scripting language directly into template documents, it
       encourages you to keep functional components (i.e. Perl code) separate from presentation components (e.g.
       HTML templates).  The template variables provide the interface between the two layers, allowing data to
       be generated in code and then passed to a template component for displaying (pipeline model) or for sub-
       routine or object references to be bound to variables which can then be called from the template as and
       when required (callback model).

       The directives that the Template Toolkit provide implement their own mini programming language, but
       they're not really designed for serious, general purpose programming.  Perl is a far more appropriate
       language for that.  If you embed application logic (e.g. Perl or other scripting language fragments) in
       HTML templates then you risk losing the clear separation of concerns between functionality and
       presentation.  It becomes harder to maintain the two elements in isolation and more difficult, if not
       impossible, to reuse code or presentation elements by themselves.  It is far better to write your
       application code in separate Perl modules, libraries or scripts and then use templates to control how the
       resulting data is presented as output.  Thus you should think of the Template Toolkit language as a set
       of layout directives for displaying data, not calculating it.

       Having said that, the Template Toolkit doesn't force you into one approach or the other.  It attempts to
       be pragmatic rather than dogmatic in allowing you to do whatever best gets the job done.  Thus, if you
       enable the EVAL_PERL option then you can happily embed real Perl code in your templates within PERL ...
       END directives.

</pre><h4><b>Performance</b></h4><pre>
       The Template Toolkit uses a fast YACC-like parser which compiles templates into Perl code for maximum
       runtime efficiency.  It also has an advanced caching mechanism which manages in-memory and on-disk (i.e.
       persistent) versions of compiled templates.  The modules that comprise the toolkit are highly
       configurable and the architecture around which they're built is designed to be extensible.  The Template
       Toolkit provides a powerful framework around which content creation and delivery systems can be built
       while also providing a simple interface through the Template front-end module for general use.

perl v5.40.0                                       2024-10-20                       <u>Template::Manual::<a href="../man3pm/Intro.3pm.html">Intro</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>