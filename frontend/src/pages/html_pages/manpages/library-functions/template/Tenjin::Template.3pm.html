<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tenjin::Template - A Tenjin template object, either built from a file or from memory.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtenjin-perl">libtenjin-perl_1.000001-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tenjin::Template - A Tenjin template object, either built from a file or from memory.

</pre><h4><b>SYNOPSIS</b></h4><pre>
               # mostly used internally, but you can manipulate
               # templates like so

               my $template = Tenjin::Template-&gt;new('/path/to/templates/template.html');
               my $context = { scalar =&gt; 'scalar', arrayref =&gt; ['one', 2, "3"] };
               $template-&gt;render($context);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is in charge of the task of compiling Tenjin templates.  Templates in Tenjin are compiled
       into standard Perl code (combined with any Perl code used inside the templates themselves). Rendering a
       template means "eval"uating that Perl code and returning its output.

       The Tenjin engine reads a template file or a template string, and creates a Template object from it. Then
       the object compiles itself by traversing the template, parsing Tenjin macros like 'include' and
       'start_capture', replaces Tenjin expressions (i.e. "[== $expr =]" or "[= $expr =]") with the appropriate
       Perl code, etc. This module ties a template object with a context object, but all context manipulation
       (and the actual "eval"uation of the Perl code) is done by Tenjin::Context.

       If you're planning on using this module by itself (i.e. without the Tenjin engine), keep in mind that
       template caching and layout templates are not handled by this module.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new(</b> <b>[$filename,</b> <b>\%opts]</b> <b>)</b>
       Creates a new Tenjin::Template object, possibly from a file on the file system (in which case $filename
       must be provided and be an absolute path to a template file). Optionally, a hash-ref of options can be
       passed to set some customizations. Available options are 'escapefunc', which will be in charge of
       escaping expressions (from "[= $expr =]") instead of the internal method (which uses HTML::Entities); and
       'rawclass', which can be used to prevent variables and objects of a certain class from being escaped, in
       which case the variable must be a hash-ref that has a key named 'str', which will be used instead. So,
       for example, if you have a variable named $var which is a hash-ref, and 'rawclass' is set as 'HASH', then
       writing "[= $var =]" on your templates will replace $var with "$var-&gt;{str}".

   <b>render(</b> <b>[$_context]</b> <b>)</b>
       Renders the template, possibly with a context hash-ref, and returns the rendered output. If errors have
       occurred when rendering the template (which might happen since templates have and are Perl code), then
       this method will croak.

</pre><h4><b>INTERNAL</b> <b>METHODS</b></h4><pre>
   <b>convert_file(</b> <b>$filename</b> <b>)</b>
       Receives an absolute path to a template file, converts that file to Perl code by calling <b>convert()</b> and
       returns that code.

   <b>convert(</b> <b>$input,</b> <b>[$filename]</b> <b>)</b>
       Receives a text of a template (i.e. the template itself) and possibly an absolute path to the template
       file (if the template comes from a file), and converts the template into Perl code, which is later
       "eval"uated for rendering. Conversion is done by parsing the statements in the template (see
       <b>parse_stmt()</b>).

   <b>compile_stmt_pattern(</b> <b>$pl</b> <b>)</b>
       Receives a string which denotes the Perl code delimiter which is used inside templates. Tenjin uses
       '"&lt;?pl ... ?&gt;"' and '"&lt;?PL ... ?&gt;"' (the latter for preprocessing), so $pl will be 'pl'. This method
       returns a tranlsation regular expression which will be used for reading embedded Perl code.

   <b>stmt_pattern</b>
       Returns the default pattern (which uses 'pl') with the previous_method.

   <b>expr_pattern()</b>
       Defines how expressions are written in Tenjin templates ("[== $expr =]" and "[= $expr =]").

   <b>parse_stmt(</b> <b>$bufref,</b> <b>$input</b> <b>)</b>
       Receives a buffer which is used for saving a template's expressions and the template's text, parses all
       expressions in the templates and pushes them to the buffer.

   <b>hook_stmt(</b> <b>$stmt</b> <b>)</b>
   <b>expand_macro(</b> <b>$funcname,</b> <b>$arg</b> <b>)</b>
       This method is in charge of invoking macro functions which might be used inside templates. The following
       macros are available:

       •   include( $filename )

           Includes  another  template,  whose  name  is  $filename,  inside  the current template. The included
           template will be placed inside the template as if they were one unit, so the context variable applies
           to both.

       •   start_capture( $name ) and end_capture()

           Tells Tenjin to capture the output of the rendered template from the point where start_capture()  was
           called to the point where end_capture() was called. You must provide a name for the captured portion,
           which  will  be  made available in the context as "$_context-&gt;{$name}" for immediate usage. Note that
           the captured portion will not be printed unless you do so explicilty with "$_context-&gt;{$name}".

       •   start_placeholder( $var ) and end_placeholder()

           This is a special method which can be used for making your templates  a  bit  cleaner.  Suppose  your
           context  might have a variable whose name is defined in $var. If that variable exists in the context,
           you simply want to print it, but if it's not, you want to print and/or perform other things. In  that
           case  you  can call start_placeholder( $var ) with the name of the context variable you want printed,
           and if it's not, anything you do between start_placeholder() and end_placeholder()  will  be  printed
           instead.

       •   echo( $exr )

           Just prints the provided expression. You might want to use it if you're a little too comfortable with
           PHP.

   <b>get_expr_and_escapeflag(</b> <b>$not_escape,</b> <b>$expr,</b> <b>$delete_newline</b> <b>)</b>
   <b>parse_expr(</b> <b>$bufref,</b> <b>$input</b> <b>)</b>
   <b>start_text_part(</b> <b>$bufref</b> <b>)</b>
   <b>stop_text_part(</b> <b>$bufref</b> <b>)</b>
   <b>add_text(</b> <b>$bufref,</b> <b>$text</b> <b>)</b>
   <b>add_stmt(</b> <b>$bufref,</b> <b>$stmt</b> <b>)</b>
   <b>add_expr(</b> <b>$bufref,</b> <b>$expr,</b> <b>$flag_escape</b> <b>)</b>
   <b>defun(</b> <b>$funcname,</b> <b>@args</b> <b>)</b>
   <b>compile()</b>
   <b>escaped_expr(</b> <b>$expr</b> <b>)</b>
       Receives  a  Perl  expression (from "[= $expr =]") and escapes it. This will happen in one of three ways:
       with the escape function defined  in  "$opts-&gt;{escapefunc}"  (if  defined),  with  a  scalar  string  (if
       "$opts-&gt;{rawclass}" is defined), or with escape_xml() from Tenjin::Util, which uses HTML::Entites.

   <b>_read_file(</b> <b>$filename,</b> <b>[$lock_required]</b> <b>)</b>
       Receives  an  absolute  path  to  a template file, reads its content and returns it. If $lock_required is
       passed (and has a true value), the file will be locked for reading.

   <b>_write_file(</b> <b>$filename,</b> <b>$content,</b> <b>[$lock_required]</b> <b>)</b>
       Receives an absolute path to a template file and  the  templates  contents,  and  creates  the  file  (or
       truncates  it,  if existing) with that contents.  If $lock_required is passed (and has a true value), the
       file will be locked exclusively when writing.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Tenjin.

</pre><h4><b>AUTHOR,</b> <b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       See Tenjin.

perl v5.38.2                                       2024-03-08                              <u>Tenjin::<a href="../man3pm/Template.3pm.html">Template</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>