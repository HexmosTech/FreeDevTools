<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template::Context - Runtime context in which templates are processed</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtemplate-perl">libtemplate-perl_2.27-1build11_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Template::Context - Runtime context in which templates are processed

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Template::Context;

           # constructor
           $context = Template::Context-&gt;new(\%config)
               || die $Template::Context::ERROR;

           # fetch (load and compile) a template
           $template = $context-&gt;template($template_name);

           # fetch (load and instantiate) a plugin object
           $plugin = $context-&gt;plugin($name, \@args);

           # fetch (return or create) a filter subroutine
           $filter = $context-&gt;filter($name, \@args, $alias);

           # process/include a template, errors are thrown via die()
           $output = $context-&gt;process($template, \%vars);
           $output = $context-&gt;include($template, \%vars);

           # raise an exception via die()
           $context-&gt;throw($error_type, $error_message, \$output_buffer);

           # catch an exception, clean it up and fix output buffer
           $exception = $context-&gt;catch($exception, \$output_buffer);

           # save/restore the stash to effect variable localisation
           $new_stash = $context-&gt;localise(\%vars);
           $old_stash = $context-&gt;delocalise();

           # add new BLOCK or FILTER definitions
           $context-&gt;define_block($name, $block);
           $context-&gt;define_filter($name, \&amp;filtersub, $is_dynamic);

           # reset context, clearing any imported BLOCK definitions
           $context-&gt;reset();

           # methods for accessing internal items
           $stash     = $context-&gt;stash();
           $tflag     = $context-&gt;trim();
           $epflag    = $context-&gt;eval_perl();
           $providers = $context-&gt;templates();
           $providers = $context-&gt;plugins();
           $providers = $context-&gt;filters();
           ...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "Template::Context" module defines an object class for representing a runtime context in which
       templates are processed.  It provides an interface to the fundamental operations of the Template Toolkit
       processing engine through which compiled templates (i.e. Perl code constructed from the template source)
       can process templates, load plugins and filters, raise exceptions and so on.

       A default "Template::Context" object is created by the Template module.  Any "Template::Context" options
       may be passed to the Template <b>new()</b> constructor method and will be forwarded to the "Template::Context"
       constructor.

           use Template;

           my $template = Template-&gt;new({
               TRIM      =&gt; 1,
               EVAL_PERL =&gt; 1,
               BLOCKS    =&gt; {
                   header =&gt; 'This is the header',
                   footer =&gt; 'This is the footer',
               },
           });

       Similarly, the "Template::Context" constructor will forward all configuration parameters onto other
       default objects (e.g. Template::Provider, Template::Plugins, Template::Filters, etc.) that it may need to
       instantiate.

           $context = Template::Context-&gt;new({
               INCLUDE_PATH =&gt; '/home/abw/templates', # provider option
               TAG_STYLE    =&gt; 'html',                # parser option
           });

       A "Template::Context" object (or subclass) can be explicitly instantiated and passed to the Template
       <b>new()</b> constructor method as the "CONTEXT" configuration item.

           use Template;
           use Template::Context;

           my $context  = Template::Context-&gt;new({ TRIM =&gt; 1 });
           my $template = Template-&gt;new({ CONTEXT =&gt; $context });

       The Template module uses the Template::Config <b>context()</b> factory method to create a default context object
       when required. The $Template::Config::CONTEXT package variable may be set to specify an alternate context
       module. This will be loaded automatically and its <b>new()</b> constructor method called by the <b>context()</b>
       factory method when a default context object is required.

           use Template;

           $Template::Config::CONTEXT = 'MyOrg::Template::Context';

           my $template = Template-&gt;new({
               EVAL_PERL   =&gt; 1,
               EXTRA_MAGIC =&gt; 'red hot',  # your extra config items
               ...
           });

</pre><h4><b>METHODS</b></h4><pre>
   <b>new(\%params)</b>
       The new() constructor method is called to instantiate a "Template::Context" object. Configuration
       parameters may be specified as a HASH reference or as a list of "name =&gt; value" pairs.

           my $context = Template::Context-&gt;new({
               INCLUDE_PATH =&gt; 'header',
               POST_PROCESS =&gt; 'footer',
           });

           my $context = Template::Context-&gt;new( EVAL_PERL =&gt; 1 );

       The new() method returns a "Template::Context" object or "undef" on error. In the latter case, a relevant
       error message can be retrieved by the <b>error()</b> class method or directly from the $Template::Context::ERROR
       package variable.

           my $context = Template::Context-&gt;new(\%config)
               || die Template::Context-&gt;error();

           my $context = Template::Context-&gt;new(\%config)
               || die $Template::Context::ERROR;

       The following configuration items may be specified.  Please see Template::Manual::Config for further
       details.

       <u>VARIABLES</u>

       The VARIABLES option can be used to specify a hash array of template variables.

           my $context = Template::Context-&gt;new({
               VARIABLES =&gt; {
                   title   =&gt; 'A Demo Page',
                   author  =&gt; 'Joe Random Hacker',
                   version =&gt; 3.14,
               },
           };

       <u>BLOCKS</u>

       The BLOCKS option can be used to pre-define a default set of template blocks.

           my $context = Template::Context-&gt;new({
               BLOCKS =&gt; {
                   header  =&gt; 'The Header.  [% title %]',
                   footer  =&gt; sub { return $some_output_text },
                   another =&gt; Template::Document-&gt;new({ ... }),
               },
           });

       <u>VIEWS</u>

       The VIEWS option can be used to pre-define one or more Template::View objects.

           my $context = Template::Context-&gt;new({
               VIEWS =&gt; [
                   bottom =&gt; { prefix =&gt; 'bottom/' },
                   middle =&gt; { prefix =&gt; 'middle/', base =&gt; 'bottom' },
                   top    =&gt; { prefix =&gt; 'top/',    base =&gt; 'middle' },
               ],
           });

       <u>TRIM</u>

       The TRIM option can be set to have any leading and trailing whitespace automatically removed from the
       output of all template files and "BLOCK"s.

       example:

           [% BLOCK foo %]

           Line 1 of foo

           [% END %]

           before
           [% INCLUDE foo %]
           after

       output:

           before
           Line 1 of foo
           after

       <u>EVAL_PERL</u>

       The EVAL_PERL is used to indicate if "PERL" and/or "RAWPERL" blocks should be evaluated. It is disabled
       by default.

       <u>RECURSION</u>

       The RECURSION can be set to allow templates to recursively process themselves, either directly (e.g.
       template "foo" calls "INCLUDE foo") or indirectly (e.g.  "foo" calls "INCLUDE bar" which calls "INCLUDE
       foo").

       <u>LOAD_TEMPLATES</u>

       The LOAD_TEMPLATES option can be used to provide a reference to a list of Template::Provider objects or
       sub-classes thereof which will take responsibility for loading and compiling templates.

           my $context = Template::Context-&gt;new({
               LOAD_TEMPLATES =&gt; [
                   MyOrg::Template::Provider-&gt;new({ ... }),
                   Template::Provider-&gt;new({ ... }),
               ],
           });

       <u>LOAD_PLUGINS</u>

       The LOAD_PLUGINS options can be used to specify a list of provider objects responsible for loading and
       instantiating template plugin objects.

           my $context = Template::Context-&gt;new({
               LOAD_PLUGINS =&gt; [
                   MyOrg::Template::Plugins-&gt;new({ ... }),
                   Template::Plugins-&gt;new({ ... }),
               ],
           });

       <u>LOAD_FILTERS</u>

       The LOAD_FILTERS option can be used to specify a list of provider objects for returning and/or creating
       filter subroutines.

           my $context = Template::Context-&gt;new({
               LOAD_FILTERS =&gt; [
                   MyTemplate::Filters-&gt;new(),
                   Template::Filters-&gt;new(),
               ],
           });

       <u>STASH</u>

       The STASH option can be used to specify a Template::Stash object or sub-class which will take
       responsibility for managing template variables.

           my $stash = MyOrg::Template::Stash-&gt;new({ ... });
           my $context = Template::Context-&gt;new({
               STASH =&gt; $stash,
           });

       <u>DEBUG</u>

       The DEBUG option can be used to enable various debugging features of the Template::Context module.

           use Template::Constants qw( :debug );

           my $template = Template-&gt;new({
               DEBUG =&gt; DEBUG_CONTEXT | DEBUG_DIRS,
           });

   <b>template($name)</b>
       Returns a compiled template by querying each of the LOAD_TEMPLATES providers (instances of
       Template::Provider, or sub-class) in turn.

           $template = $context-&gt;template('header');

       On error, a Template::Exception object of type '"file"' is thrown via die().  This can be caught by
       enclosing the call to template() in an "eval" block and examining $@.

           eval { $template = $context-&gt;template('header') };
           if ($@) {
               print "failed to fetch template: $@\n";
           }

   <b>plugin($name,</b> <b>\@args)</b>
       Instantiates a plugin object by querying each of the LOAD_PLUGINS providers. The default LOAD_PLUGINS
       provider is a Template::Plugins object which attempts to load plugin modules, according the various
       configuration items such as PLUGIN_BASE, LOAD_PERL, etc., and then instantiate an object via <b>new()</b>. A
       reference to a list of constructor arguments may be passed as the second parameter. These are forwarded
       to the plugin constructor.

       Returns a reference to a plugin (which is generally an object, but doesn't have to be).  Errors are
       thrown as Template::Exception objects with the type set to '"plugin"'.

           $plugin = $context-&gt;plugin('DBI', 'dbi:msql:mydbname');

   <b>filter($name,</b> <b>\@args,</b> <b>$alias)</b>
       Instantiates a filter subroutine by querying the LOAD_FILTERS providers.  The default LOAD_FILTERS
       provider is a Template::Filters object.

       Additional arguments may be passed by list reference along with an optional alias under which the filter
       will be cached for subsequent use. The filter is cached under its own $name if $alias is undefined.
       Subsequent calls to filter($name) will return the cached entry, if defined. Specifying arguments bypasses
       the caching mechanism and always creates a new filter. Errors are thrown as Template::Exception objects
       with the type set to '"filter"'.

           # static filter (no args)
           $filter = $context-&gt;filter('html');

           # dynamic filter (args) aliased to 'padright'
           $filter = $context-&gt;filter('format', '%60s', 'padright');

           # retrieve previous filter via 'padright' alias
           $filter = $context-&gt;filter('padright');

   <b>process($template,</b> <b>\%vars)</b>
       Processes a template named or referenced by the first parameter and returns the output generated.  An
       optional reference to a hash array may be passed as the second parameter, containing variable definitions
       which will be set before the template is processed.  The template is processed in the current context,
       with no localisation of variables performed.   Errors are thrown as Template::Exception objects via
       die().

           $output = $context-&gt;process('header', { title =&gt; 'Hello World' });

   <b>include($template,</b> <b>\%vars)</b>
       Similar to <b>process()</b>, but using localised variables.  Changes made to any variables will only persist
       until the include() method completes.

           $output = $context-&gt;include('header', { title =&gt; 'Hello World' });

   <b>insert($template)</b>
       This method returns the source content of a template file without performing any evaluation.  It is used
       to implement the "INSERT" directive.

   <b>throw($error_type,</b> <b>$error_message,</b> <b>\$output)</b>
       Raises an exception in the form of a Template::Exception object by calling die(). This method may be
       passed a reference to an existing Template::Exception object; a single value containing an error message
       which is used to instantiate a Template::Exception of type '"undef"'; or a pair of values representing
       the exception "type" and "info" from which a Template::Exception object is instantiated. e.g.

           $context-&gt;throw($exception);
           $context-&gt;throw("I'm sorry Dave, I can't do that");
           $context-&gt;throw('denied', "I'm sorry Dave, I can't do that");

       The optional third parameter may be a reference to the current output buffer.  This is then stored in the
       exception object when created, allowing the catcher to examine and use the output up to the point at
       which the exception was raised.

           $output .= 'blah blah blah';
           $output .= 'more rhubarb';
           $context-&gt;throw('yack', 'Too much yacking', \$output);

   <b>catch($exception,</b> <b>\$output)</b>
       Catches an exception thrown, either as a reference to a Template::Exception object or some other value.
       In the latter case, the error string is promoted to a Template::Exception object of '"undef"' type. This
       method also accepts a reference to the current output buffer which is passed to the Template::Exception
       constructor, or is appended to the output buffer stored in an existing Template::Exception object, if
       unique (i.e. not the same reference). By this process, the correct state of the output buffer can be
       reconstructed for simple or nested throws.

   <b>define_block($name,</b> <b>$block)</b>
       Adds a new block definition to the internal BLOCKS cache.  The first argument should contain the name of
       the block and the second a reference to a Template::Document object or template sub-routine, or template
       text which is automatically compiled into a template sub-routine.

       Returns a true value (the sub-routine or Template::Document reference) on success or undef on failure.
       The relevant error message can be retrieved by calling the <b>error()</b> method.

   <b>define_filter($name,</b> <b>\&amp;filter,</b> <b>$is_dynamic)</b>
       Adds a new filter definition by calling the <b>store()</b> method on each of the LOAD_FILTERS providers until
       accepted (in the usual case, this is accepted straight away by the one and only Template::Filters
       provider). The first argument should contain the name of the filter and the second a reference to a
       filter subroutine. The optional third argument can be set to any true value to indicate that the
       subroutine is a dynamic filter factory.

       Returns a true value or throws a '"filter"' exception on error.

   <b>define_vmethod($type,</b> <b>$name,</b> <b>$code)</b>
       This method is a wrapper around the Template::Stash <b>define_vmethod()</b> method.  It can be used to define
       new virtual methods.

           # define a new scalar (item) virtual method
           $context-&gt;define_vmethod(
               item =&gt; ucfirst =&gt; sub {
                   my $text = shift;
                   return ucfirst $text;
               }
           )

   <b>define_view($name,</b> <b>\%params)</b>
       This method allows you to define a named view.

           $context-&gt;define_view(
               my_view =&gt; {
                   prefix =&gt; 'my_templates/'
               }
           );

       The view is then accessible as a template variable.

           [% my_view.print(some_data) %]

   <b>define_views($views)</b>
       This method allows you to define multiple named views.  A reference to a hash array or list reference
       should be passed as an argument.

           $context-&gt;define_view({     # hash reference
               my_view_one =&gt; {
                   prefix =&gt; 'my_templates_one/'
               },
               my_view_two =&gt; {
                   prefix =&gt; 'my_templates_two/'
               }
           });

       If you're defining multiple views of which one or more are based on other views in the same definition
       then you should pass them as a list reference.  This ensures that they get created in the right order
       (Perl does not preserve the order of items defined in a hash reference so you can't guarantee that your
       base class view will be defined before your subclass view).

           $context-&gt;define_view([     # list referenence
               my_view_one =&gt; {
                   prefix =&gt; 'my_templates_one/'
               },
               my_view_two =&gt; {
                   prefix =&gt; 'my_templates_two/' ,
                   base   =&gt; 'my_view_one',
               }
           ]);

       The views are then accessible as template variables.

           [% my_view_one.print(some_data) %]
           [% my_view_two.print(some_data) %]

       See also the VIEWS option.

   <b>stash()</b>
       This method returns the Template::Stash object used internally to manage template variables.

   <b>localise(\%vars)</b>
       Clones the stash to create a context with localised variables.  Returns a reference to the newly cloned
       stash object which is also stored internally.

           $stash = $context-&gt;localise();

   <b>delocalise()</b>
       Restore the stash to its state prior to localisation.

           $stash = $context-&gt;delocalise();

   <b>visit(\%blocks)</b>
       This method is called by Template::Document objects immediately before they process their content.  It is
       called to register any local "BLOCK" definitions with the context object so that they may be subsequently
       delivered on request.

   <b>leave()</b>
       Compliment to the <b>visit()</b> method. Called by Template::Document objects immediately after they process
       their content.

   <b>view()</b>
       This method creates a Template::View object bound to the context.

   <b>reset()</b>
       Clears the local BLOCKS cache of any "BLOCK" definitions.  Any initial set of BLOCKS specified as a
       configuration item to the constructor will be reinstated.

   <b>debugging($flag,</b> <b>@args)</b>
       This method is used to control debugging output.  It is used to implement the DEBUG directive.

       The first argument can be "on" or "off" to enable or disable debugging respectively.  The numerical
       values 0 and 1 can also be used if you prefer.

           $context-&gt;debugging('on');

       Alternately, the first argument can be "format" to define a new debug message format.  The second
       argument should be the format string which can contain any of the $file, $line or $text symbols to
       indicate where the relevant values should be inserted.

           # note single quotes to prevent interpolated of variables
           $context-&gt;debugging( format =&gt; '## $file line $line: $text' );

       The final use of this method is to generate debugging messages themselves.  The first argument should be
       "msg", followed by a reference to a hash array of value to insert into the debugging format string.

           $context-&gt;debugging(
               msg =&gt; {
                   line =&gt; 20,
                   file =&gt; 'example.tt',
                   text =&gt; 'Trampoline! Trampoline!',
               }
           );

   <b>AUTOLOAD</b>
       An "AUTOLOAD" method provides access to context configuration items.

           $stash     = $context-&gt;stash();
           $tflag     = $context-&gt;trim();
           $epflag    = $context-&gt;eval_perl();
           ...

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley &lt;<a href="mailto:abw@wardley.org">abw@wardley.org</a>&gt; &lt;<a href="http://wardley.org/">http://wardley.org/</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 1996-2013 Andy Wardley.  All Rights Reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Template, Template::Document, Template::Exception, Template::Filters, Template::Plugins,
       Template::Provider, Template::Service, Template::Stash

perl v5.40.0                                       2024-10-20                             <u>Template::<a href="../man3pm/Context.3pm.html">Context</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>