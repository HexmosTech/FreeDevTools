<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template::Service - General purpose template processing service</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtemplate-perl">libtemplate-perl_2.27-1build11_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Template::Service - General purpose template processing service

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Template::Service;

           my $service = Template::Service-&gt;new({
               PRE_PROCESS  =&gt; [ 'config', 'header' ],
               POST_PROCESS =&gt; 'footer',
               ERROR        =&gt; {
                   user     =&gt; 'user/index.html',
                   dbi      =&gt; 'error/database',
                   default  =&gt; 'error/default',
               },
           });

           my $output = $service-&gt;process($template_name, \%replace)
               || die $service-&gt;error(), "\n";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "Template::Service" module implements an object class for providing a consistent template processing
       service.

       Standard header (PRE_PROCESS) and footer (POST_PROCESS) templates may be specified which are prepended
       and appended to all templates processed by the service (but not any other templates or blocks "INCLUDE"d
       or "PROCESS"ed from within). An ERROR hash may be specified which redirects the service to an alternate
       template file in the case of uncaught exceptions being thrown. This allows errors to be automatically
       handled by the service and a guaranteed valid response to be generated regardless of any processing
       problems encountered.

       A default "Template::Service" object is created by the Template module.  Any "Template::Service" options
       may be passed to the Template <b>new()</b> constructor method and will be forwarded to the Template::Service
       constructor.

           use Template;

           my $template = Template-&gt;new({
               PRE_PROCESS  =&gt; 'header',
               POST_PROCESS =&gt; 'footer',
           });

       Similarly, the "Template::Service" constructor will forward all configuration parameters onto other
       default objects (e.g. Template::Context) that it may need to instantiate.

       A "Template::Service" object (or subclass) can be explicitly instantiated and passed to the Template
       <b>new()</b> constructor method as the SERVICE item.

           use Template;
           use Template::Service;

           my $service = Template::Service-&gt;new({
               PRE_PROCESS  =&gt; 'header',
               POST_PROCESS =&gt; 'footer',
           });

           my $template = Template-&gt;new({
               SERVICE =&gt; $service,
           });

       The "Template::Service" module can be sub-classed to create custom service handlers.

           use Template;
           use MyOrg::Template::Service;

           my $service = MyOrg::Template::Service-&gt;new({
               PRE_PROCESS  =&gt; 'header',
               POST_PROCESS =&gt; 'footer',
               COOL_OPTION  =&gt; 'enabled in spades',
           });

           my $template = Template-&gt;new({
               SERVICE =&gt; $service,
           });

       The Template module uses the Template::Config <b>service()</b> factory method to create a default service object
       when required. The $Template::Config::SERVICE package variable may be set to specify an alternate service
       module. This will be loaded automatically and its <b>new()</b> constructor method called by the <b>service()</b>
       factory method when a default service object is required. Thus the previous example could be written as:

           use Template;

           $Template::Config::SERVICE = 'MyOrg::Template::Service';

           my $template = Template-&gt;new({
               PRE_PROCESS  =&gt; 'header',
               POST_PROCESS =&gt; 'footer',
               COOL_OPTION  =&gt; 'enabled in spades',
           });

</pre><h4><b>METHODS</b></h4><pre>
   <b>new(\%config)</b>
       The new() constructor method is called to instantiate a "Template::Service" object.  Configuration
       parameters may be specified as a HASH reference or as a list of "name =&gt; value" pairs.

           my $service1 = Template::Service-&gt;new({
               PRE_PROCESS  =&gt; 'header',
               POST_PROCESS =&gt; 'footer',
           });

           my $service2 = Template::Service-&gt;new( ERROR =&gt; 'error.html' );

       The new() method returns a "Template::Service" object or "undef" on error. In the latter case, a relevant
       error message can be retrieved by the <b>error()</b> class method or directly from the $Template::Service::ERROR
       package variable.

           my $service = Template::Service-&gt;new(\%config)
               || die Template::Service-&gt;error();

           my $service = Template::Service-&gt;new(\%config)
               || die $Template::Service::ERROR;

   <b>process($input,</b> <b>\%replace)</b>
       The process() method is called to process a template specified as the first parameter, $input. This may
       be a file name, file handle (e.g. "GLOB" or "IO::Handle") or a reference to a text string containing the
       template text. An additional hash reference may be passed containing template variable definitions.

       The method processes the template, adding any PRE_PROCESS or POST_PROCESS templates defined, and returns
       the output text. An uncaught exception thrown by the template will be handled by a relevant ERROR handler
       if defined. Errors that occur in the PRE_PROCESS or POST_PROCESS templates, or those that occur in the
       main input template and aren't handled, cause the method to return "undef" to indicate failure. The
       appropriate error message can be retrieved via the <b>error()</b> method.

           $service-&gt;process('myfile.html', { title =&gt; 'My Test File' })
               || die $service-&gt;error();

   <b>context()</b>
       Returns a reference to the internal context object which is, by default, an instance of the
       Template::Context class.

</pre><h4><b>CONFIGURATION</b> <b>OPTIONS</b></h4><pre>
       The following list summarises the configuration options that can be provided to the "Template::Service"
       <b>new()</b> constructor. Please consult Template::Manual::Config for further details and examples of each
       configuration option in use.

   <b>PRE_PROCESS,</b> <b>POST_PROCESS</b>
       The PRE_PROCESS and POST_PROCESS options may be set to contain the name(s) of template files which should
       be processed immediately before and/or after each template. These do not get added to templates processed
       into a document via directives such as "INCLUDE" "PROCESS", "WRAPPER", etc.

           my $service = Template::Service-&gt;new({
               PRE_PROCESS  =&gt; 'header',
               POST_PROCESS =&gt; 'footer',
           };

       Multiple templates may be specified as a reference to a list.  Each is processed in the order defined.

           my $service = Template::Service-&gt;new({
               PRE_PROCESS  =&gt; [ 'config', 'header' ],
               POST_PROCESS =&gt; 'footer',
           };

   <b>PROCESS</b>
       The PROCESS option may be set to contain the name(s) of template files which should be processed instead
       of the main template passed to the "Template::Service" <b>process()</b> method. This can be used to apply
       consistent wrappers around all templates, similar to the use of PRE_PROCESS and POST_PROCESS templates.

           my $service = Template::Service-&gt;new({
               PROCESS  =&gt; 'content',
           };

           # processes 'content' instead of 'foo.html'
           $service-&gt;process('foo.html');

       A reference to the original template is available in the "template" variable.  Metadata items can be
       inspected and the template can be processed by specifying it as a variable reference (i.e. prefixed by
       '"$"') to an "INCLUDE", "PROCESS" or "WRAPPER" directive.

       Example "PROCESS" template:

           &lt;html&gt;
             &lt;head&gt;
               &lt;title&gt;[% template.title %]&lt;/title&gt;
             &lt;/head&gt;
             &lt;body&gt;
             [% PROCESS $template %]
             &lt;/body&gt;
           &lt;/html&gt;

   <b>ERROR</b>
       The ERROR (or "ERRORS" if you prefer) configuration item can be used to name a single template or specify
       a hash array mapping exception types to templates which should be used for error handling. If an uncaught
       exception is raised from within a template then the appropriate error template will instead be processed.

       If specified as a single value then that template will be processed for all uncaught exceptions.

           my $service = Template::Service-&gt;new({
               ERROR =&gt; 'error.html'
           });

       If the ERROR or ERRORS item is a hash reference the keys are assumed to be exception types and the
       relevant template for a given exception will be selected. A "default" template may be provided for the
       general case.

           my $service = Template::Service-&gt;new({
               ERRORS =&gt; {
                   user     =&gt; 'user/index.html',
                   dbi      =&gt; 'error/database',
                   default  =&gt; 'error/default',
               },
           });

   <b>AUTO_RESET</b>
       The AUTO_RESET option is set by default and causes the local "BLOCKS" cache for the Template::Context
       object to be reset on each call to the Template <b>process()</b> method.  This ensures that any "BLOCK"s defined
       within a template will only persist until that template is finished processing.

   <b>DEBUG</b>
       The DEBUG option can be used to enable debugging messages from the "Template::Service" module by setting
       it to include the "DEBUG_SERVICE" value.

           use Template::Constants qw( :debug );

           my $template = Template-&gt;new({
               DEBUG =&gt; DEBUG_SERVICE,
           });

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley &lt;<a href="mailto:abw@wardley.org">abw@wardley.org</a>&gt; &lt;<a href="http://wardley.org/">http://wardley.org/</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 1996-2007 Andy Wardley.  All Rights Reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Template, Template::Context

perl v5.40.0                                       2024-10-20                             <u>Template::<a href="../man3pm/Service.3pm.html">Service</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>