<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::DBStag::SQLTemplate - A Template for an SQL query</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-dbstag-perl">libdbix-dbstag-perl_0.12-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
         DBIx::DBStag::SQLTemplate - A Template for an SQL query

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # find template by name
         $template = $dbh-&gt;find_template("mydb-personq");

         # execute this template, filling in the 'name' attribute
         $xml = $dbh-&gt;selectall_xml(-template=&gt;$template,
                                    -bind=&gt;{name =&gt; "fred"});

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A template represents a canned query that can be parameterized.

       Templates are collected in directories (in future it will be possible to store them in files or in the db
       itself).

       To tell DBStag where your templates are, you should set:

         setenv DBSTAG_TEMPLATE_DIRS "$HOME/mytemplates:/data/bioconf/templates"

       Your templates should end with the suffix <b>.stg</b>, otherwise they will not be picked up

       You can name templates any way you like, but the standard way is to use 2 or 3 fields

         SCHEMA-OBJECT

       or

         SCHEMA-OBJECT-QUALIFIERS

       (with underscores used within fields)

       A template file should contain at minimum some SQL; for example:

       Example template 1
             SELECT
                          studio.*,
                          movie.*,
                          star.*
             FROM
                          studio NATURAL JOIN
                          movie NATURAL JOIN
                          movie_to_star NATURAL JOIN
                          star
             WHERE
                          [movie.genre = &amp;genre&amp;] [star.lastname = &amp;lastname&amp;]
             USE NESTING (set(studio(movie(star))))

           That's all! However, there are ways to make your template more useful

       Example template 2
             :SELECT
                          studio.*,
                          movie.*,
                          star.*
             :FROM
                          studio NATURAL JOIN
                          movie NATURAL JOIN
                          movie_to_star NATURAL JOIN
                          star
             :WHERE
                          [movie.genre = &amp;genre&amp;] [star.lastname = &amp;lastname&amp;]
             :USE NESTING (set(studio(movie(star))))

             //
             schema: movie
             desc: query for fetching movies

           By including <b>:</b> at the beginning it makes it easier for parsers to assemble SQL (this is not necessary
           for DBStag however)

           After the // you can add tag: value data.

           You  should  set  <b>schema:</b>  if you want the template to be available to users of a db that conforms to
           that schema

   <b>GETTING</b> <b>A</b> <b>TEMPLATE</b>
       The DBIx::DBStag object gives various methods for fetching templates by name, by database or by schema

   <b>VARIABLES</b>
       WHERE clause variables in the template look like this

         &amp;foo&amp;

       variables are bound at query time

         my $set = $dbh-&gt;selectall_stag(-template=&gt;$t,
                                        -bind=&gt;["bar"]);

       or

         my $set = $dbh-&gt;selectall_stag(-template=&gt;$t,
                                        -bind=&gt;{foo=&gt;"bar"});

       If the former is chosen, variables are bound from the bind list as they are found

   <b>OPTIONAL</b> <b>BLOCKS</b>
         WHERE [ foo = &amp;foo&amp; ]

       If foo is not bound then the part between the square brackets is left out

       Multiple option blocks are <b>AND</b>ed together

       An option block need not contain a variable - if it contains no <b>&amp;variable&amp;</b> name it is automatically <b>AND</b>ed

   <b>BINDING</b> <b>OPERATORS</b>
       The operator can be bound at query time too

         WHERE [ foo =&gt; &amp;foo&amp; ]

       Will become either

         WHERE foo = ?

       or

         WHERE foo LIKE ?

       or

         WHERE foo IN (f0, f1, ..., fn)

       Depending on whether foo contains the % character, or if foo is bound to an ARRAY

</pre><h4><b>METHODS</b></h4><pre>
   <b>name</b>
         Usage   - $name = $template-&gt;name
         Returns - str
         Args    -

       every template has a name that (should) uniquely identify it

   <b>desc</b>
         Usage   - $desc = $template-&gt;desc
         Returns - str
         Args    -

       templates have optional descriptions

   <b>get_varnames</b>
         Usage   - $varnames = $template-&gt;get_varnames
         Returns - listref of strs
         Args    -

       Returns the names of all variable used in this template

</pre><h4><b>WEBSITE</b></h4><pre>
       &lt;<a href="http://stag.sourceforge.net">http://stag.sourceforge.net</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Chris Mungall &lt;<u><a href="mailto:cjm@fruitfly.org">cjm@fruitfly.org</a></u>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2003 Chris Mungall

       This module is free software.  You may distribute this module under the same terms as perl itself

perl v5.36.0                                       2022-10-14                     <u>DBIx::DBStag::<a href="../man3pm/SQLTemplate.3pm.html">SQLTemplate</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>