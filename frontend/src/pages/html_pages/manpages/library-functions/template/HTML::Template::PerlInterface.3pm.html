<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Template::PerlInterface - perl interface of HTML::Template::Pro</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-template-pro-perl">libhtml-template-pro-perl_0.9524-1build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Template::PerlInterface - perl interface of HTML::Template::Pro

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This help is only on perl interface of HTML::Template::Pro.  For syntax of html template files you should
       see "SYNOPSIS" in HTML::Template::SYNTAX.

       First you make a template - this is just a normal HTML file with a few extra tags, the simplest being
       &lt;TMPL_VAR&gt;

       For example, test.tmpl:

         &lt;html&gt;
         &lt;head&gt;&lt;title&gt;Test Template&lt;/title&gt;
         &lt;body&gt;
         My Home Directory is &lt;TMPL_VAR NAME=HOME&gt;
         &lt;p&gt;
         My Path is set to &lt;TMPL_VAR NAME=PATH&gt;
         &lt;/body&gt;
         &lt;/html&gt;

       See HTML::Template::SYNTAX for their syntax.

       Now create a small CGI program:

         #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
         use HTML::Template::Pro;

         # open the html template
         my $template = HTML::Template::Pro-&gt;new(
               filename =&gt; 'test.tmpl',
               case_sensitive=&gt; 1);

         # fill in some parameters
         $template-&gt;param(HOME =&gt; $ENV{HOME});
         $template-&gt;param(PATH =&gt; $ENV{PATH});

         # send the obligatory Content-Type and print the template output
         print "Content-Type: text/html\n\n";

         # print output
         $template-&gt;output(print_to=&gt;\*STDOUT);

         # this would also work.
         # print $template-&gt;output();

         # this would also work. It is faster,
         # but (WARNING!) not compatible with original HTML::Template.
         # $template-&gt;output();

       If all is well in the universe this should show something like this in your browser when visiting the
       CGI:

         My Home Directory is /home/some/directory
         My Path is set to <a href="file:/bin">/bin</a>;<a href="file:/usr/bin">/usr/bin</a>

       For the best performance it is recommended to use case_sensitive=&gt;1 in <b>new()</b> and print_to=&gt;\*STDOUT in
       <b>output()</b>.

       Note that (HTML::Template::Pro version 0.90+) <b>output()</b>, called in void context, also prints to stdout
       using built-in htmltmplpro C library calls, so the last call "$template-&gt;<b>output()</b>;" might be, in fact,
       the fastest way to call <b>output()</b>.

       IMPORTANT NOTE: you can safely write

         my $template = HTML::Template-&gt;new( ... options ...)
               or even
         my $template = HTML::Template::Expr-&gt;new( ... options ...)

       with HTML::Template::Pro, because in absence of original HTML::Template and HTML::Template::Expr
       HTML::Template::Pro intercepts their calls.

       You can also use all three modules and safely mix their calls (benchmarking may be the only reason for
       it).  In case you want to mix calls to HTML::Template::Expr and HTML::Template::Pro, the only proper
       usage of their load is

       use HTML::Template; use HTML::Template::Expr; use HTML::Template::Pro;

       Of course, if you don't plan to mix them (in most cases) it is enough to simply write

       use HTML::Template::Pro;

       Simply use HTML::Template::Pro, it supports all functions of HTML::Template::Expr.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       HTML::Template::Pro is a fast C/perl+XS implementation of HTML::Template and HTML::Template::Expr.  See
       HTML::Template::Pro for details.

       It fully supports template language of HTML::Template as described in HTML::Template::SYNTAX.

       Briefly,

       "This module attempts to make using HTML templates simple and natural.  It extends standard HTML with a
       few new HTML-esque tags - &lt;TMPL_VAR&gt;, &lt;TMPL_LOOP&gt;, &lt;TMPL_INCLUDE&gt;, &lt;TMPL_IF&gt;, &lt;TMPL_ELSE&gt; and
       &lt;TMPL_UNLESS&gt;.  The file written with HTML and these new tags is called a template.  It is usually saved
       separate from your script - possibly even created by someone else!  Using this module you fill in the
       values for the variables, loops and branches declared in the template.  This allows you to separate
       design - the HTML - from the data, which you generate in the Perl script."

       Here is described a perl interface of HTML::Template::Pro and HTML::Template + HTML::Template::Expr.  See
       <b>DISTINCTIONS</b> for brief summary of distinctions between HTML::Template::Pro and HTML::Template.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new()</b>
       Call <b>new()</b> to create a new Template object:

         my $template = HTML::Template-&gt;new( filename =&gt; 'file.tmpl',
                                             option =&gt; 'value'
                                           );

       You must call <b>new()</b> with at least one name =&gt; value pair specifying how to access the template text.  You
       can use "filename =&gt; 'file.tmpl'" to specify a filename to be opened as the template.  Alternately you
       can use:

         my $t = HTML::Template-&gt;new( scalarref =&gt; $ref_to_template_text,
                                      option =&gt; 'value'
                                    );

       and

         my $t = HTML::Template-&gt;new( arrayref =&gt; $ref_to_array_of_lines ,
                                      option =&gt; 'value'
                                    );

       These initialize the template from in-memory resources.  In almost every case you'll want to use the
       filename parameter.  If you're worried about all the disk access from reading a template file just use
       mod_perl and the cache option detailed below.

       You can also read the template from an already opened filehandle, either traditionally as a glob or as a
       FileHandle:

         my $t = HTML::Template-&gt;new( filehandle =&gt; *FH, option =&gt; 'value');

       The four <b>new()</b> calling methods can also be accessed as below, if you prefer.

         my $t = HTML::Template-&gt;new_file('file.tmpl', option =&gt; 'value');

         my $t = HTML::Template-&gt;new_scalar_ref($ref_to_template_text,
                                               option =&gt; 'value');

         my $t = HTML::Template-&gt;new_array_ref($ref_to_array_of_lines,
                                              option =&gt; 'value');

         my $t = HTML::Template-&gt;new_filehandle($fh,
                                              option =&gt; 'value');

       And as a final option, for those that might prefer it, you can call new as:

         my $t = HTML::Template-&gt;new(type =&gt; 'filename',
                                     source =&gt; 'file.tmpl');

       Which works for all three of the source types.

       If the environment variable HTML_TEMPLATE_ROOT is set and your filename doesn't begin with /, then the
       path will be relative to the value of $HTML_TEMPLATE_ROOT.  Example - if the environment variable
       HTML_TEMPLATE_ROOT is set to "/home/sam" and I call HTML::Template-&gt;<b>new()</b> with filename set to
       "sam.tmpl", the HTML::Template will try to open "/home/sam/sam.tmpl" to access the template file.  You
       can also affect the search path for files with the "path" option to <b>new()</b> - see below for more
       information.

       You can modify the Template object's behavior with <b>new()</b>.  The options are available:

       Error Detection Options
           •   die_on_bad_params  -  if  set  to  0  the module will let you call $template-&gt;param(param_name =&gt;
               'value')  even  if  'param_name'  doesn't  exist  in  the  template  body.   Defaults  to  1   in
               HTML::Template.

               HTML::Template::Pro  always  use  die_on_bad_params =&gt; 0.  It currently can't be changed, because
               HTML::Template::Pro can't know whether a parameter is bad until it finishes output.

               Note that it is wrapper-only option: it is not implemented in the htmltmplpro C library.

           •   force_untaint - if set to 1 the module will not  allow  you  to  set  unescaped  parameters  with
               tainted  values.  If  set  to  2 you will have to untaint all parameters, including ones with the
               escape attribute.  This option makes sure  you  untaint  everything  so  you  don't  accidentally
               introduce e.g. cross-site-scripting (CSS) vulnerabilities. Requires taint mode. Defaults to 0.

               In  the  original HTML::Template, if the "force_untaint" option is set an error occurs if you try
               to set a value that is tainted in the <b>param()</b> call. In HTML::Template::Pro, an error occurs  when
               output is called.

               Note that the tainted value will never be printed; but, to completely suppress output, one should
               use  call  to  <b>output()</b>  that  returns string, like print $tmpl-&gt;<b>output()</b>; Then <b>output()</b> will die
               before it returns the string to print.

               Note that it is wrapper-only perl-specific option: it is not implemented  in  the  htmltmplpro  C
               library.

           •   strict - if set to 0 the module will allow things that look like they might be TMPL_* tags to get
               by without dieing.  Example:

                  &lt;TMPL_HUH NAME=ZUH&gt;

               Would  normally  cause an error, but if you call new with strict =&gt; 0, HTML::Template will ignore
               it.  Defaults to 1.

               HTML::Template::Pro always implies strict =&gt; 0.

       Caching Options
           HTML::Template use many caching options  such  as  cache,  shared_cache,  double_cache,  blind_cache,
           file_cache, file_cache_dir, file_cache_dir_mode, double_file_cache to cache preparsed html templates.

           Since HTML::Template::Pro parses and outputs templates at once, it silently ignores those options.

       Filesystem Options
           •   path  -  you  can  set  this variable with a list of paths to search for files specified with the
               "filename" option to <b>new()</b> and for files included with the &lt;TMPL_INCLUDE&gt; tag.  This list is only
               consulted when the filename is relative.  The HTML_TEMPLATE_ROOT environment variable  is  always
               tried  first  if  it  exists.  Also, if HTML_TEMPLATE_ROOT is set then an attempt will be made to
               prepend HTML_TEMPLATE_ROOT onto paths in the path array.  In the case of a  &lt;TMPL_INCLUDE&gt;  file,
               the path to the including file is also tried before path is consulted.

               Example:

                  my $template = HTML::Template-&gt;new( filename =&gt; 'file.tmpl',
                                                      path =&gt; [ '/path/to/templates',
                                                                '/alternate/path'
                                                              ]
                                                     );

               NOTE:  the paths in the path list must be expressed as UNIX paths, separated by the forward-slash
               character ('/').

           •   search_path_on_include - if set to a true value the module will search from the top of the  array
               of paths specified by the path option on every &lt;TMPL_INCLUDE&gt; and use the first matching template
               found.   The  normal behavior is to look only in the current directory for a template to include.
               Defaults to 0.

       Debugging Options
           •   debug - if set to 1 the module will write random debugging information to STDERR.  Defaults to 0.

           •   HTML::Template use many cache debug options such as stack_debug, cache_debug, shared_cache_debug,
               memory_debug.  Since HTML::Template::Pro parses  and  outputs  templates  at  once,  it  silently
               ignores those options.

       Miscellaneous Options
           •   associate  - this option allows you to inherit the parameter values from other objects.  The only
               requirement  for  the  other  object  is  that  it  have  a  param()  method  that   works   like
               HTML::Template's param().  A good candidate would be a CGI.pm query object.  Example:

                 my $query = new CGI;
                 my $template = HTML::Template-&gt;new(filename =&gt; 'template.tmpl',
                                                    associate =&gt; $query);

               Now, "$template-&gt;output()" will act as though

                 $template-&gt;param('FormField', $cgi-&gt;param('FormField'));

               had  been specified for each key/value pair that would be provided by the "$cgi-&gt;param()" method.
               Parameters you set directly take precedence over associated parameters.

               You can specify multiple objects to associate by passing an  anonymous  array  to  the  associate
               option.  They are searched for parameters in the order they appear:

                 my $template = HTML::Template-&gt;new(filename =&gt; 'template.tmpl',
                                                    associate =&gt; [$query, $other_obj]);

               NOTE:  If  the  option case_sensitive =&gt; 0, the parameter names are matched in a case-insensitive
               manner.  If you have two parameters in a CGI object like 'NAME' and 'Name'  one  will  be  chosen
               randomly by associate.  This behavior can be changed by setting option case_sensitive to 1.

           •   case_sensitive  -  setting  this  option to true causes HTML::Template to treat template variable
               names case-sensitively.   The  following  example  would  only  set  one  parameter  without  the
               "case_sensitive" option:

                 my $template = HTML::Template-&gt;new(filename =&gt; 'template.tmpl',
                                                    case_sensitive =&gt; 1);
                 $template-&gt;param(
                   FieldA =&gt; 'foo',
                   fIELDa =&gt; 'bar',
                 );

               This  option  defaults  to  off to keep compatibility with HTML::Template.  Nevertheless, setting
               case_sensitive =&gt; 1 is encouraged, because it significantly improves performance.

               If case_sensitive is set to 0, the perl wrapper is forced to lowercase keys in every hash it will
               find  in  "param"  tree,  which  is  sometimes  an  expensive  operation.  To  avoid  this,   set
               case_sensitive =&gt; 1.

               If  case conversion is necessary, there is an alternative lightweight option tmpl_var_case, which
               is HTML::Template::Pro specific.

               Note that case_sensitive is wrapper-only option: it is  not  implemented  in  the  htmltmplpro  C
               library.

           •   tmpl_var_case  -  this  option  is  similar to case_sensitive, but is implemented directly in the
               htmltmplpro C library.  Instead of converting keys in every hash of "param" tree, it converts the
               name of variable.

               For example, in case of &lt;tmpl_var name="CamelCaseName"&gt; setting tmpl_var_case = ASK_NAME_AS_IS  |
               ASK_NAME_LOWERCASE  | ASK_NAME_UPPERCASE will cause HTML::Template::Pro to look into "param" tree
               for 3 names: CamelCaseName, camelcasename, and CAMELCASENAME.

               By default, the name is asked "as is".

           •   loop_context_vars - when this parameter is set to true (it is false by default) four loop context
               variables are made available inside a loop: __first__, __last__, __inner__, __odd__.  They can be
               used with &lt;TMPL_IF&gt;, &lt;TMPL_UNLESS&gt; and &lt;TMPL_ELSE&gt; to control how a loop is output.

               In addition to the above, a __counter__ var is also made available when  loop  context  variables
               are turned on.

               Example:

                  &lt;TMPL_LOOP NAME="FOO"&gt;
                     &lt;TMPL_IF NAME="__first__"&gt;
                       This only outputs on the first pass.
                     &lt;/TMPL_IF&gt;

                     &lt;TMPL_IF NAME="__odd__"&gt;
                       This outputs every other pass, on the odd passes.
                     &lt;/TMPL_IF&gt;

                     &lt;TMPL_UNLESS NAME="__odd__"&gt;
                       This outputs every other pass, on the even passes.
                     &lt;/TMPL_UNLESS&gt;

                     &lt;TMPL_IF NAME="__inner__"&gt;
                       This outputs on passes that are neither first nor last.
                     &lt;/TMPL_IF&gt;

                     This is pass number &lt;TMPL_VAR NAME="__counter__"&gt;.

                     &lt;TMPL_IF NAME="__last__"&gt;
                       This only outputs on the last pass.
                     &lt;/TMPL_IF&gt;
                  &lt;/TMPL_LOOP&gt;

               One  use  of  this  feature  is  to  provide a "separator" similar in effect to the perl function
               <b>join()</b>.  Example:

                  &lt;TMPL_LOOP FRUIT&gt;
                     &lt;TMPL_IF __last__&gt; and &lt;/TMPL_IF&gt;
                     &lt;TMPL_VAR KIND&gt;&lt;TMPL_UNLESS __last__&gt;, &lt;TMPL_ELSE&gt;.&lt;/TMPL_UNLESS&gt;
                  &lt;/TMPL_LOOP&gt;

               Would output (in a browser) something like:

                 Apples, Oranges, Brains, Toes, and Kiwi.

               Given an appropriate param() call, of course.  NOTE: A loop with only a single pass will get both
               __first__ and __last__ set to true, but not __inner__.

               NOTE: in the original HTML::Template with case_sensitive = 1 and  loop_context_vars  the  special
               loop  variables  are  available  in  lower-case only.  In HTML::Template::Pro they are recognized
               regardless of case.

           •   no_includes - set this option to 1 to disallow the &lt;TMPL_INCLUDE&gt; tag in the template file.  This
               can be used to make opening untrusted templates <b>slightly</b> less dangerous.  Defaults to 0.

           •   max_includes - set this variable to determine the maximum depth that includes can reach.  Set  to
               10  by default.  Including files to a depth greater than this value causes an error message to be
               displayed.  Set to 0 to disable this protection.

           •   global_vars - normally variables declared outside a loop are not available inside a  loop.   This
               option  makes &lt;TMPL_VAR&gt;s like global variables in Perl - they have unlimited scope.  This option
               also affects &lt;TMPL_IF&gt; and &lt;TMPL_UNLESS&gt;.

               Example:

                 This is a normal variable: &lt;TMPL_VAR NORMAL&gt;.&lt;P&gt;

                 &lt;TMPL_LOOP NAME=FROOT_LOOP&gt;
                    Here it is inside the loop: &lt;TMPL_VAR NORMAL&gt;&lt;P&gt;
                 &lt;/TMPL_LOOP&gt;

               Normally this wouldn't work as expected, since &lt;TMPL_VAR NORMAL&gt;'s value outside the loop is  not
               available inside the loop.

               The  global_vars option also allows you to access the values of an enclosing loop within an inner
               loop.  For example, in this loop the inner loop will have access to the value of OUTER_VAR in the
               correct iteration:

                  &lt;TMPL_LOOP OUTER_LOOP&gt;
                     OUTER: &lt;TMPL_VAR OUTER_VAR&gt;
                       &lt;TMPL_LOOP INNER_LOOP&gt;
                          INNER: &lt;TMPL_VAR INNER_VAR&gt;
                          INSIDE OUT: &lt;TMPL_VAR OUTER_VAR&gt;
                       &lt;/TMPL_LOOP&gt;
                  &lt;/TMPL_LOOP&gt;

               <b>NOTE</b>: "global_vars" is not "global_loops" (which does not exist).   That  means  that  loops  you
               declare at one scope are not available inside other loops even when "global_vars" is on.

           •   path_like_variable_scope   -   this   option   switches   on  a  Shigeki  Morimoto  extension  to
               HTML::Template::Pro that allows access to variables that are outside the current loop scope using
               path-like expressions.

               Example: {{{ &lt;TMPL_LOOP NAME=class&gt;
                 &lt;TMPL_LOOP NAME=person&gt;
                   &lt;TMPL_VAR NAME="../teacher_name"&gt;  &lt;!-- access to class.teacher_name --&gt;
                   &lt;TMPL_VAR NAME="name"&gt;
                   &lt;TMPL_VAR NAME="/top_level_value"&gt; &lt;!-- access to top level value --&gt;
                   &lt;TMPL_VAR NAME="age"&gt;
                     &lt;TMPL_LOOP NAME="../../school"&gt;  &lt;!-- enter loop before accessing its vars --&gt;
                       &lt;TMPL_VAR NAME="school_name"&gt;  &lt;!-- access to [..<a href="file:/../">/../</a>]school.school_name --&gt;
                     &lt;/TMPL_LOOP&gt;
                 &lt;/TMPL_LOOP&gt; &lt;/TMPL_LOOP&gt; }}}

           •   filter - this option allows you to specify a filter for your  template  files.   A  filter  is  a
               subroutine that will be called after HTML::Template reads your template file but before it starts
               parsing template tags.

               In  the  most  simple  usage,  you  simply assign a code reference to the filter parameter.  This
               subroutine will receive a single argument - a reference to a string containing the template  file
               text.  Here is an example that accepts templates with tags that look like "!!!ZAP_VAR FOO!!!" and
               transforms them into HTML::Template tags:

                  my $filter = sub {
                    my $text_ref = shift;
                    $$text_ref =~ s/!!!ZAP_(.*?)!!!/&lt;TMPL_$1&gt;/g;
                  };

                  # open zap.tmpl using the above filter
                  my $template = HTML::Template-&gt;new(filename =&gt; 'zap.tmpl',
                                                     filter =&gt; $filter);

               More complicated usages are possible.  You can request that your filter receive the template text
               as  an array of lines rather than as a single scalar.  To do that you need to specify your filter
               using a hash-ref.  In this form you specify the filter  using  the  "sub"  key  and  the  desired
               argument  format  using the "format" key.  The available formats are "scalar" and "array".  Using
               the "array" format will  incur  a  performance  penalty  but  may  be  more  convenient  in  some
               situations.

                  my $template = HTML::Template-&gt;new(filename =&gt; 'zap.tmpl',
                                                     filter =&gt; { sub =&gt; $filter,
                                                                 format =&gt; 'array' });

               You may also have multiple filters.  This allows simple filters to be combined for more elaborate
               functionality.  To do this you specify an array of filters.  The filters are applied in the order
               they are specified.

                  my $template = HTML::Template-&gt;new(filename =&gt; 'zap.tmpl',
                                                     filter =&gt; [
                                                          { sub =&gt; \&amp;decompress,
                                                            format =&gt; 'scalar' },
                                                          { sub =&gt; \&amp;remove_spaces,
                                                            format =&gt; 'array' }
                                                       ]);

               The  specified  filters will be called for any TMPL_INCLUDEed files just as they are for the main
               template file.

           •   default_escape - Set this parameter to "HTML", "URL" or "JS" and HTML::Template  will  apply  the
               specified escaping to all variables unless they declare a different escape in the template.

   <b>param()</b>
       param() can be called in a number of ways

       1) To return a list of parameters in the template :
          ( this features is distinct in HTML::Template::Pro:
          it returns a list of parameters _SET_ after <b>new()</b> )

          my @parameter_names = $self-&gt;param();

       2) To return the value set to a param :

          my $value = $self-&gt;param('PARAM');

       3) To set the value of a parameter :

             # For simple TMPL_VARs:
             $self-&gt;param(PARAM =&gt; 'value');

             # with a subroutine reference that gets called to get the value
             # of the scalar.  The sub will receive the template object as a
             # parameter.
             $self-&gt;param(PARAM =&gt; sub { return 'value' });

             # And TMPL_LOOPs:
             $self-&gt;param(LOOP_PARAM =&gt;
                          [
                           { PARAM =&gt; VALUE_FOR_FIRST_PASS, ... },
                           { PARAM =&gt; VALUE_FOR_SECOND_PASS, ... }
                           ...
                          ]
                         );

       4) To set the value of a a number of parameters :

            # For simple TMPL_VARs:
            $self-&gt;param(PARAM =&gt; 'value',
                         PARAM2 =&gt; 'value'
                        );

             # And with some TMPL_LOOPs:
             $self-&gt;param(PARAM =&gt; 'value',
                          PARAM2 =&gt; 'value',
                          LOOP_PARAM =&gt;
                          [
                           { PARAM =&gt; VALUE_FOR_FIRST_PASS, ... },
                           { PARAM =&gt; VALUE_FOR_SECOND_PASS, ... }
                           ...
                          ],
                          ANOTHER_LOOP_PARAM =&gt;
                          [
                           { PARAM =&gt; VALUE_FOR_FIRST_PASS, ... },
                           { PARAM =&gt; VALUE_FOR_SECOND_PASS, ... }
                           ...
                          ]
                         );

       5) To set the value of a a number of parameters using a hash-ref :

             $self-&gt;param(
                          {
                             PARAM =&gt; 'value',
                             PARAM2 =&gt; 'value',
                             LOOP_PARAM =&gt;
                             [
                               { PARAM =&gt; VALUE_FOR_FIRST_PASS, ... },
                               { PARAM =&gt; VALUE_FOR_SECOND_PASS, ... }
                               ...
                             ],
                             ANOTHER_LOOP_PARAM =&gt;
                             [
                               { PARAM =&gt; VALUE_FOR_FIRST_PASS, ... },
                               { PARAM =&gt; VALUE_FOR_SECOND_PASS, ... }
                               ...
                             ]
                           }
                          );

   <b>clear_params()</b>
       Sets all the parameters to undef.  Useful internally, if nowhere else!

   <b>output()</b>
       <b>output()</b> returns the final result of the template.  In most situations you'll want to print this, like:

          print $template-&gt;output();

       When  output  is  called  each  occurrence of &lt;TMPL_VAR NAME=name&gt; is replaced with the value assigned to
       "name" via param().  If a named parameter is unset it is  simply  replaced  with  ''.   &lt;TMPL_LOOPS&gt;  are
       evaluated once per parameter set, accumulating output on each pass.

       Calling  <b>output()</b>  is  guaranteed  not  to  change  the  state  of  the Template object, in case you were
       wondering.  This property is mostly important for the internal implementation of loops.

       You may optionally supply a filehandle to print to automatically as the template is generated.  This  may
       improve performance and lower memory consumption.  Example:

          $template-&gt;output(print_to =&gt; *STDOUT);

       The return value is undefined when using the "print_to" option.

   <b>query()</b>
       This method is not supported in HTML::Template::Pro.

</pre><h4><b>DISTINCTIONS</b> <b>AND</b> <b>INCOMPATIBILITIES</b></h4><pre>
       The  main  reason  for small incompatibilities between HTML::Template and HTML::Template::Pro is the fact
       that HTML::Template builds parsed tree of  template  before  anything  else.  So  it  has  an  additional
       information which HTML::Template::Pro obtains during output.

       In  cases  when HTML::Template dies, such as no_includes, bad syntax of template, max_includes and so on,
       HTML::Template::Pro issues warning to STDERR and continue.

   <b>new()</b>
       the following options are not supported in HTML::Template::Pro:

        vanguard_compatibility_mode.

       The  options  die_on_bad_params  and  strict  are  ignored.   HTML::Template::Pro   behaves   itself   as
       HTML::Template called with
        die_on_bad_params =&gt; 0, strict =&gt; 0.

       It  currently  can't be changed, because HTML::Template::Pro can't know whether a parameter is bad before
       it start output.  This may change in future releases.

       To  keep  backward  compatibility  with  HTML::Template,  you  should  explicitly  call  its  <b>new()</b>  with
       die_on_bad_params =&gt; 0, strict =&gt; 0.

   <b>query()</b>
       This method is not supported in HTML::Template::Pro.

   <b>param()</b>
       <b>param()</b>  without arguments should return a list of parameters in the template.  In HTML::Template::Pro it
       returns a list of parameters set after <b>new()</b>.

</pre><h4><b>BUGS</b></h4><pre>
       With <u>case_sensitive</u> and <u>loop_context_vars</u> the special loop variables should be  available  in  lower-case
       only.

       <u>associate</u> is case_sensitive inside loops.

       When submitting bug reports, be sure to include full details, including the VERSION of the module, a test
       script and a test template demonstrating the problem!

</pre><h4><b>EXPR:</b> <b>DEFINING</b> <b>NEW</b> <b>FUNCTIONS</b></h4><pre>
       To define a new function, pass a "functions" option to new:

         $t = HTML::Template::Pro-&gt;new(filename =&gt; 'foo.tmpl',
                                        functions =&gt;
                                          { func_name =&gt; \&amp;func_handler });
       or

         $t = HTML::Template::Expr-&gt;new(filename =&gt; 'foo.tmpl',
                                        functions =&gt;
                                          { func_name =&gt; \&amp;func_handler });

       Or, you can use "register_function" class method to register the function globally:

         HTML::Template::Pro-&gt;register_function(func_name =&gt; \&amp;func_handler);
       or
         HTML::Template::Expr-&gt;register_function(func_name =&gt; \&amp;func_handler);

       You  provide  a subroutine reference that will be called during output.  It will receive as arguments the
       parameters specified in the template.  For example, here's a function that checks if a directory exists:

         sub directory_exists {
           my $dir_name = shift;
           return 1 if -d $dir_name;
           return 0;
         }

       If you call HTML::Template::Expr-&gt;<b>new()</b> with a "functions" arg:

         $t = HTML::Template::Expr-&gt;new(filename =&gt; 'foo.tmpl',
                                        functions =&gt; {
                                           directory_exists =&gt; \&amp;directory_exists
                                        });

       Then you can use it in your template:

         &lt;tmpl_if expr="directory_exists('/home/sam')"&gt;

       This can be abused in ways that make my teeth hurt.

   <b>register_function()</b> <b>extended</b> <b>usage</b> <b>(HTML::Template::Pro</b> <b>specific)</b>
       register_function() can be called in a number of ways

       1) To fetch the names of registered functions in the template:

       •   if register_function() was called in a newly created object it returns a

              list of function's that set _after_ or _in_ new():

              my @registered_functions_names = $self-&gt;register_function();

       •   in global context register_function() will return a list of _ALL_
              avalible function's

              my @all_avalible_functions_names =
           HTML::Template::Pro-&gt;register_function();

           2) To fetching the function by name:

              my $function = $self-&gt;register_function('FUNCTION_NAME');

           3) To set a new function:

               # Set function, that can be called in templates, wich are processed
               # by the current object:
               $self-&gt;register_function(foozicate =&gt; sub { ... });

               # Set global function:
               HTML::Template::Pro-&gt;register_function(barify    =&gt; sub { ... });

       for details of "how to defined a function" see in "EXPR: DEFINING NEW FUNCTIONS".

</pre><h4><b>EXPR</b> <b>MOD_PERL</b> <b>TIP</b></h4><pre>
       "register_function" class method can be called in mod_perl's startup.pl  to  define  widely  used  common
       functions to HTML::Template::Expr. Add something like this to your startup.pl:

         use HTML::Template::Pro;

         HTML::Template::Pro-&gt;register_function(foozicate =&gt; sub { ... });
         HTML::Template::Pro-&gt;register_function(barify    =&gt; sub { ... });
         HTML::Template::Pro-&gt;register_function(baznate   =&gt; sub { ... });

</pre><h4><b>EXPR</b> <b>CAVEATS</b></h4><pre>
       HTML::Template::Pro  does  not  forces the HTML::Template global_vars option to be set, whereas currently
       HTML::Template::Expr  does.   Anyway,  this  also  will  hopefully  go  away  in  a  future  version   of
       HTML::Template::Expr, so if you need global_vars in your templates then you should set it explicitly.

</pre><h4><b>CREDITS</b></h4><pre>
       to Sam Tregar, <a href="mailto:sam@tregar.com">sam@tregar.com</a>

       Original credits of HTML::Template:

       This  module  was  the  brain  child  of  my  boss,  Jesse  Erlbaum  ( <a href="mailto:jesse@vm.com">jesse@vm.com</a> ) at Vanguard Media (
       <a href="http://vm.com">http://vm.com</a> ) .  The most original idea in this module - the &lt;TMPL_LOOP&gt; - was entirely his.

       Fixes, Bug Reports, Optimizations and Ideas have been generously provided by:

          Richard Chen
          Mike Blazer
          Adriano Nagelschmidt Rodrigues
          Andrej Mikus
          Ilya Obshadko
          Kevin Puetz
          Steve Reppucci
          Richard Dice
          Tom Hukins
          Eric Zylberstejn
          David Glasser
          Peter Marelas
          James William Carlson
          Frank D. Cringle
          Winfried Koenig
          Matthew Wickline
          Doug Steinwand
          Drew Taylor
          Tobias Brox
          Michael Lloyd
          Simran Gambhir
          Chris Houser &lt;<a href="mailto:chouser@bluweb.com">chouser@bluweb.com</a>&gt;
          Larry Moore
          Todd Larason
          Jody Biggs
          T.J. Mather
          Martin Schroth
          Dave Wolfe
          uchum
          Kawai Takanori
          Peter Guelich
          Chris Nokleberg
          Ralph Corderoy
          William Ward
          Ade Olonoh
          Mark Stosberg
          Lance Thomas
          Roland Giersig
          Jere Julian
          Peter Leonard
          Kenny Smith
          Sean P. Scanlon
          Martin Pfeffer
          David Ferrance
          Gyepi Sam
          Darren Chamberlain
          Paul Baker
          Gabor Szabo
          Craig Manley
          Richard Fein
          The Phalanx Project
          Sven Neuhaus

       Thanks!

       Original credits of HTML::Template::Expr:

       The following people have generously submitted bug reports, patches and ideas:

          Peter Leonard
          Tatsuhiko Miyagawa

       Thanks!

</pre><h4><b>WEBSITE</b></h4><pre>
       You can find information about HTML::Template::Pro at:

          <a href="http://html-tmpl-pro.sourceforge.net">http://html-tmpl-pro.sourceforge.net</a>

       You can find information about HTML::Template and other related modules at:

          <a href="http://html-template.sourceforge.net">http://html-template.sourceforge.net</a>

</pre><h4><b>AUTHOR</b></h4><pre>
       Sam Tregar, <a href="mailto:sam@tregar.com">sam@tregar.com</a> (Main text)

       I. Vlasenko, &lt;<a href="mailto:viy@altlinux.org">viy@altlinux.org</a>&gt; (Pecularities of HTML::Template::Pro)

</pre><h4><b>LICENSE</b></h4><pre>
         HTML::Template : A module for using HTML Templates with Perl
         Copyright (C) 2000-2002 Sam Tregar (<a href="mailto:sam@tregar.com">sam@tregar.com</a>)

         This module is free software; you can redistribute it and/or modify it
         under the terms of either:

         a) the GNU General Public License as published by the Free Software
         Foundation; either version 1, or (at your option) any later version,

         or

         b) the "Artistic License" which comes with this module.

         This program is distributed in the hope that it will be useful,
         but WITHOUT ANY WARRANTY; without even the implied warranty of
         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
         the GNU General Public License or the Artistic License for more details.

         You should have received a copy of the Artistic License with this
         module, in the file ARTISTIC.  If not, I'll be glad to provide one.

         You should have received a copy of the GNU General Public License
         along with this program; if not, write to the Free Software
         Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
         USA

perl v5.40.0                                       2024-10-20                 <u>HTML::Template::<a href="../man3pm/PerlInterface.3pm.html">PerlInterface</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>