<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGI::FormBuilder::Template::Text - FormBuilder interface to Text::Template</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcgi-formbuilder-perl">libcgi-formbuilder-perl_3.10-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CGI::FormBuilder::Template::Text - FormBuilder interface to Text::Template

</pre><h4><b>SYNOPSIS</b></h4><pre>
           my $form = CGI::FormBuilder-&gt;new(
                           fields   =&gt; \@fields,
                           template =&gt; {
                               type =&gt; 'Text',
                               template =&gt; 'form.tmpl',
                               variable =&gt; 'form',
                           }
                      );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This engine adapts <b>FormBuilder</b> to use "Text::Template". Usage is very similar to Template Toolkit:

           my $form = CGI::FormBuilder-&gt;new(
                           fields =&gt; \@fields,
                           template =&gt; {
                               type =&gt; 'Text',           # use Text::Template
                               template =&gt; 'form.tmpl',
                           }
                      );

       The default options passed into "Text::Template-&gt;new()" with this calling form are:

           TYPE   =&gt; 'FILE'
           SOURCE =&gt; 'form.tmpl'
           DELIMITERS =&gt; ['&lt;%','%&gt;']

       As these params are passed for you, your template will look very similar to ones used by Template Toolkit
       and "HTML::Mason" (the Text::Template default delimiters are "{" and "}", but using alternative
       delimiters speeds it up by about 25%, and the "&lt;%" and "%&gt;" delimiters are good, familiar-looking
       alternatives).

       The following methods are provided (usually only used internally):

   <b>engine</b>
       Returns a reference to the "Text::Template" object

   <b>prepare</b>
       Returns a hash of all the fields ready to be rendered.

   <b>render</b>
       Uses the prepared hash and expands the template, returning a string of HTML.

</pre><h4><b>TEMPLATES</b></h4><pre>
           &lt;% $jshead %&gt;  -  JavaScript to stick in &lt;head&gt;
           &lt;% $title  %&gt;  -  The &lt;title&gt; of the HTML form
           &lt;% $start  %&gt;  -  Opening &lt;form&gt; tag and internal fields
           &lt;% $submit %&gt;  -  The submit button(s)
           &lt;% $reset  %&gt;  -  The reset button
           &lt;% $end    %&gt;  -  Closing &lt;/form&gt; tag
           &lt;% $fields %&gt;  -  List of fields
           &lt;% $field  %&gt;  -  Hash of fields (for lookup by name)

       Note that you refer to variables with a preceding "$", just like in Perl.  Like Template Toolkit, you can
       specify a variable to place fields under:

           my $form = CGI::FormBuilder-&gt;new(
               fields =&gt; \@fields,
               template =&gt; {
                    type =&gt; 'Text',
                    template =&gt; 'form.tmpl',
                    variable =&gt; 'form'
               },
           );

       Unlike Template Toolkit, though, these will not be placed in OO-style, dot-separated vars. Instead, a
       hash will be created which you then reference:

           &lt;% $form{jshead} %&gt;
           &lt;% $form{start}  %&gt;
           etc.

       And field data is in a hash-of-hashrefs format:

           For a field named...  The field data is in...
           --------------------  -----------------------
           job                   &lt;% $form{field}{job}   %]
           size                  &lt;% $form{field}{size}  %]
           email                 &lt;% $form{field}{email} %]

       Since "Text::Template" looks so much like Perl, you can access individual elements and create variables
       like so:

           &lt;%
               my $myfield = $form{field}{email};
               $myfield-&gt;{label};      # text label
               $myfield-&gt;{field};      # field input tag
               $myfield-&gt;{value};      # first value
               $myfield-&gt;{values};     # list of all values
               $myfield-&gt;{options};    # list of all options
               $myfield-&gt;{required};   # required flag
               $myfield-&gt;{invalid};    # invalid flag
               $myfield-&gt;{error};      # error string if invalid
           %&gt;

           &lt;%
               for my $field (@{$form{fields}}) {
                   $OUT .= "&lt;tr&gt;\n&lt;td&gt;" . $field-&gt;{label} . "&lt;/td&gt; &lt;td&gt;"
                                        . $field-&gt;{field} . "&lt;/td&gt;\n&lt;tr&gt;";
               }
           %&gt;

       In addition, when using the engine option, you supply an existing Text::Template object or a hash of
       parameters to be passed to "new()".  For example, you can ask for different delimiters yourself:

           my $form = CGI::FormBuilder-&gt;new(
               fields =&gt; \@fields,
               template =&gt; {
                    type =&gt; 'Text',
                    template =&gt; 'form.tmpl',
                    variable =&gt; 'form',
                    engine   =&gt; {
                       DELIMITERS =&gt; [ '[@--', '--@]' ],
                    },
                    data =&gt; {
                         version =&gt; 1.23,
                         author  =&gt; 'Fred Smith',
                    },
               },
           );

       If you pass a hash of parameters, you can override the "TYPE" and "SOURCE" parameters, as well as any
       other "Text::Template" options. For example, you can pass in a string template with "TYPE =&gt; STRING"
       instead of loading it from a file. You must specify <b>both</b> "TYPE" and "SOURCE" if doing so.  The good news
       is this is trivial:

           my $form = CGI::FormBuilder-&gt;new(
               fields =&gt; \@fields,
               template =&gt; {
                    type =&gt; 'Text',
                    variable =&gt; 'form',
                    engine   =&gt; {
                         TYPE =&gt; 'STRING',
                         SOURCE =&gt; $string,
                         DELIMITERS =&gt; [ '[@--', '--@]' ],
                    },
                    data =&gt; {
                         version =&gt; 1.23,
                         author  =&gt; 'Fred Smith',
                    },
               },
           );

       If you get the crazy idea to let users of your application pick the template file (strongly discouraged)
       and you're getting errors, look at the "Text::Template" documentation for the "UNTAINT" feature.

       Also, note that "Text::Template"'s "PREPEND =&gt; 'use strict;'" option is not recommended due to the
       dynamic nature for "FormBuilder".  If you use it, then you'll have to declare each variable that
       "FormBuilder" puts into your template with "use vars qw($jshead' ... etc);"

       If you're really stuck on this, though, a workaround is to say:

           PREPEND =&gt; 'use strict; use vars qw(%form);'

       and then set the option "variable =&gt; 'form'". That way you can have strict Perl without too much hassle,
       except that your code might be exhausting to look at :-).  Things like
       $form{field}{your_field_name}{field} end up being all over the place, instead of the nicer short forms.

       Finally, when you use the "data" template option, the keys you specify will be available to the template
       as regular variables. In the above example, these would be "&lt;% $version %&gt;" and "&lt;% $author %&gt;". And
       complex datatypes are easy:

           data =&gt; {
                   anArray =&gt; [ 1, 2, 3 ],
                   aHash =&gt; { orange =&gt; 'tangy', chocolate =&gt; 'sweet' },
           }

       This becomes the following in your template:

           &lt;%
               @anArray;    # you can use $myArray[1] etc.
               %aHash;      # you can use $myHash{chocolate} etc.
           %&gt;

       For more information, please consult the "Text::Template" documentation.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CGI::FormBuilder, CGI::FormBuilder::Template, Text::Template

</pre><h4><b>REVISION</b></h4><pre>
       $Id: Text.pm 100 2007-03-02 18:13:13Z nwiger $

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (c) Nate Wiger &lt;<a href="http://nateware.com">http://nateware.com</a>&gt;. All Rights Reserved.

       Text::Template support is due to huge contributions by Jonathan Buhacoff.  Thanks man.

       This module is free software; you may copy this under the terms of the GNU General Public License, or the
       Artistic License, copies of which should have accompanied your Perl kit.

perl v5.36.0                                       2022-10-15              <u>CGI::FormBuilder::Template::<a href="../man3pm/Text.3pm.html">Text</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>