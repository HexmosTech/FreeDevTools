<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template::FAQ - Frequently Asked Questions about the Template Toolkit</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtemplate-perl">libtemplate-perl_2.27-1build11_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Template::FAQ - Frequently Asked Questions about the Template Toolkit

</pre><h4><b>Template</b> <b>Toolkit</b> <b>Language</b></h4><pre>
   <b>Why</b> <b>doesn't</b> <b>[%</b> <b>a</b> <b>=</b> <b>b</b> <b>IF</b> <b>c</b> <b>%]</b> <b>work</b> <b>as</b> <b>expected?</b>
       There's a limitation in the TT2 parser which means that the following code doesn't work as you might
       expect:

           [% a = b IF c %]

       The parser interprets it as an attempt to set "a" to the result of "b IF c", like this:

           [% a = (b IF c) %]

       If you want to set "a = b" only if "c" is true, then do this instead:

           [% SET a = b IF c %]

       The explicit "SET" keyword gives the parser the clue it needs to do the right thing.

       NOTE: this will be fixed in TT3

   <b>If</b> <b>I'm</b> <b>using</b> <b>TT</b> <b>to</b> <b>write</b> <b>out</b> <b>a</b> <b>TT</b> <b>template,</b> <b>is</b> <b>there</b> <b>a</b> <b>good</b> <b>way</b> <b>to</b> <b>escape</b> <b>[%</b> <b>and</b> <b>%]?</b>
       You can do something like this:

           [% stag = "[\%"
              etag = "%\]"
           %]

       and then:

           [% stag; 'hello'; etag %]

       Or you can use the "TAGS" directive, like so:

           [% TAGS [- -] %]
           [- INCLUDE foo -]   # is a directive
           [% INCLUDE foo %]   # not a directive

   <b>How</b> <b>do</b> <b>I</b> <b>iterate</b> <b>over</b> <b>a</b> <b>hash?</b>
       This is covered in the Template::Manual::VMethods section of the manual. A list of all the keys that are
       in the hash can be obtained with the "keys" virtual method. You can then iterate over that list and by
       looking up each key in turn get the value.

           [% FOREACH key = product.keys %]
              [% key %] =&gt; [% product.$key %]
           [% END %]

</pre><h4><b>Plugins</b></h4><pre>
   <b>How</b> <b>do</b> <b>I</b> <b>get</b> <b>the</b> <b>Table</b> <b>plugin</b> <b>to</b> <b>order</b> <b>data</b> <b>across</b> <b>rather</b> <b>than</b> <b>down?</b>
       Order the data into rows:

           Steve     Karen     Jeff
           Brooklyn  Nantucket Fairfax
           NY        MA        VA

           [% USE table(data, rows=3) %]

       Then ask for each column

           [% FOREACH column = table.cols %]

       And then print each item in the column going across the output rows

           [% FOREACH item = column %]
               &lt;td&gt;[% item %]&lt;/td&gt;
           [% END %]

   <b>Accessing</b> <b>Cookies</b>
       Jeff Boes &lt;<a href="mailto:jboes@nexcerpt.com">jboes@nexcerpt.com</a>&gt; asks:

           Does anyone have a quick-n-dirty approach to accessing
           cookies from templates?

       Jonas Liljegren answers:

           [% USE CGI %]

           &lt;p&gt;The value is [% CGI.cookie('cookie_name') | html %]

</pre><h4><b>Extending</b> <b>the</b> <b>Template</b> <b>Toolkit</b></h4><pre>
   <b>Can</b> <b>I</b> <b>serve</b> <b>templates</b> <b>from</b> <b>a</b> <b>database?</b>
       Short answer: yes, Chris Nandor has done this for Slash.  You need to subclass Template::Provider.  See
       the mailing list archives for further info.

   <b>Can</b> <b>I</b> <b>fetch</b> <b>templates</b> <b>via</b> <b>http?</b>
       To do the job properly, you should subclass Template::Provider to "Template::Provider::HTTP" and use a
       "PREFIX_MAP" option to bind the "http" template prefix to that particular provider (you may want to go
       digging around in the <u>Changes</u> file around version 2.01 for more info on "PREFIX_MAP" - it may not be
       properly documented anywhere else...yet!). e.g.

           use Template::Provider::HTTP;

           my $file = Template::Provider( INCLUDE_PATH =&gt; [...] );
           my $http = Template::Provider::HTTP-&gt;new(...);
           my $tt2  = Template-&gt;new({
               LOAD_TEMPLATES =&gt; [ $file, $http ],
               PREFIX_MAP =&gt; {
                   file    =&gt; '0',     # file:foo.html
                   http    =&gt; '1',     # http:foo.html
                   default =&gt; '0',     # foo.html =&gt; file:foo.html
               }
           });

       Now a template specified as:

           [% INCLUDE foo %]

       will be served by the 'file' provider (the default).  Otherwise you can explicitly add a prefix:

           [% INCLUDE file:foo.html %]
           [% INCLUDE http:foo.html %]
           [% INCLUDE <a href="http://www.xyz.com/tt2/header.tt2">http://www.xyz.com/tt2/header.tt2</a> %]

       This same principal can be used to create a DBI template provider.  e.g.

           [% INCLUDE dbi:foo.html %]

       Alas, we don't yet have a DBI provider as part of the Template Toolkit. There has been some talk on the
       mailing list about efforts to develop DBI and/or HTTP providers but as yet no-one has stepped forward to
       take up the challenge...

       In the mean time, Craig Barrat's post from the mailing list has some useful pointers on how to achieve
       this using existing modules.  See &lt;<a href="http://tt2.org/pipermail/templates/2001-May/000954.html">http://tt2.org/pipermail/templates/2001-May/000954.html</a>&gt;

</pre><h4><b>Miscellaneous</b></h4><pre>
   <b>How</b> <b>can</b> <b>I</b> <b>find</b> <b>out</b> <b>the</b> <b>name</b> <b>of</b> <b>the</b> <b>main</b> <b>template</b> <b>being</b> <b>processed?</b>
       The "template" variable contains a reference to the Template::Document object for the main template
       you're processing (i.e. the one provided as the first argument to the Template <b>process()</b> method).  The
       "name" method returns its name.

           [% template.name %]     # e.g. index.html

   <b>How</b> <b>can</b> <b>I</b> <b>find</b> <b>out</b> <b>the</b> <b>name</b> <b>of</b> <b>the</b> <b>current</b> <b>template</b> <b>being</b> <b>processed?</b>
       The "template" variable always references the <u>main</u> template being processed.  So even if you call [%
       INCLUDE header %], and that calls [% INCLUDE menu %], the "template" variable will be unchanged.

       index.html:

           [% template.name  %]     # index.html
           [% INCLUDE header %]

       header:

           [% template.name  %]     # index.html
           [% INCLUDE menu   %]

       menu:

           [% template.name  %]     # index.html

       In contrast, the "component" variable always references the <u>current</u> template being processed.

       index.html

           [% component.name %]     # index.html
           [% INCLUDE header %]

       header:

           [% component.name %]     # header
           [% INCLUDE menu   %]

       menu:

           [% component.name  %]     # menu

   <b>How</b> <b>do</b> <b>I</b> <b>print</b> <b>the</b> <b>modification</b> <b>time</b> <b>of</b> <b>the</b> <b>template</b> <b>or</b> <b>component?</b>
       The "template" and "component" variables reference the main template and the current template being
       processed (see previous questions).  The "modtime" method returns the modification time of the
       corresponding template file as a number of seconds since the Unix epoch (00:00:00 GMT 1st January 1970).

       This number doesn't mean much to anyone (except perhaps serious Unix geeks) so you'll probably want to
       use the Date plugin to format it for human consumption.

           [% USE Date %]
           [% template.name %] last modified [% Date.format(template.modtime) %]

   <b>How</b> <b>can</b> <b>I</b> <b>configure</b> <b>variables</b> <b>on</b> <b>a</b> <b>per-request</b> <b>basis?</b>
       One easy way to achieve this is to define a single "PRE_PROCESS" template which loads in other
       configuration files based on variables defined or other conditions.

       For example, my setup usually looks something like this:

           PRE_PROCESS =&gt; 'config/main'

       config/main:

           [%  DEFAULT  style   = 'text'
                        section =  template.section or 'home';

               PROCESS  config/site
                     +  config/urls
                     +  config/macros
                     + "config/style/$style"
                     + "config/section/$section"
                     + ...
           %]

       This allows me to set a single 'style' variable to control which config file gets pre-processed to set my
       various style options (colours, img paths, etc).  For example:

       config/style/basic:

           [%  style = {
                   name = style    # save existing 'style' var as 'style.name'

                   # define various other style variables....
                   col = {
                       back =&gt; '#ffffff'
                       text =&gt; '#000000'
                           # ...etc...
                   }

                   logo = {
                           # ...etc...
                   }

                   # ...etc...
               }
           %]

       Each source template can declare which section it's in via a META directive:

         [% META
              title   = 'General Information'
              section = 'info'
         %]
         ...

       This controls which section configuration file gets loaded to set various other variables for defining
       the section title, menu, etc.

       config/section/info:

           [%  section = {
                   name   = section  # save 'section' var as 'section.name'
                   title  = 'Information'
                   menu   = [ ... ]
                   # ...etc...
               }
           %]

       This illustrates the basic principal but you can extend it to perform pretty much any kind of per-
       document initialisation that you require.

   <b>Why</b> <b>do</b> <b>I</b> <b>get</b> <b>rubbish</b> <b>for</b> <b>my</b> <b>utf-8</b> <b>templates?</b>
       First of all, make sure that your template files define a Byte Order Mark
       &lt;<a href="http://en.wikipedia.org/wiki/Byte_Order_Mark">http://en.wikipedia.org/wiki/Byte_Order_Mark</a>&gt;

       If you for some reason don't want to add BOM to your templates, you can force Template to use a
       particular encoding (e.g. "utf8") for your templates with the "ENCODING" option.

           my $template = Template-&gt;new({
               ENCODING =&gt; 'utf8'
           });

</pre><h4><b>Questions</b> <b>About</b> <b>This</b> <b>FAQ</b></h4><pre>
   <b>Why</b> <b>is</b> <b>this</b> <b>FAQ</b> <b>so</b> <b>short?</b>
       Because we don't have anyone maintaining it.

   <b>Can</b> <b>I</b> <b>help?</b>
       Yes please :-)

perl v5.40.0                                       2024-10-20                                 <u>Template::<a href="../man3pm/FAQ.3pm.html">FAQ</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>