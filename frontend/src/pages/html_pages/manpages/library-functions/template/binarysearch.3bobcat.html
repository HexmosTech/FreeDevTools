<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::binary_search - Extensions to the STL binary_search function template</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::binary_search - Extensions to the STL binary_search function template

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/binarysearch&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>FBB::binary_search</b> function templates extend the STL <u>binary_search</u> function templates by returning an
       iterator  to  the found element, instead of a <b>bool</b> value informing the caller whether or not the searched
       for element is present in a provided iterator range.

       The <b>bool</b> value returned by the STL <u>binary_search</u> function template is often not the kind  of  information
       the  caller  of the function is interested in. Rather, the caller will often want to use <u>binary_search</u> in
       the way <u>find_if</u> is used: returning an iterator to an element or returning the end-iterator if the element
       was not found.

       Whereas <u>find_if</u> does not require the elements in the iterator range to be sorted, and  therefore  uses  a
       linear  search,  <u>binary_search</u>  benefits  from  the  sorted  nature of the elements using a binary search
       algorithm requiring <u>2</u> <u>log</u> <u>N</u> iterations to locate the searched for element rather than  (on  average)  <u>N/2</u>
       iterations.  The  <u>FBB::binary_search</u>  algorithm uses this binary searching process while at the same time
       allowing it to be used like <u>find_if</u>.

       Since the <u>FBB::binary_search</u> function templates use the same  number  and  types  of  parameters  as  the
       <u>stl::binary_search</u>  function  templates  and  because  they  are  implemented  using the <u>stl::lower_bound</u>
       algorithms the <u>FBB</u> namespace must explicitly be specified when calling <u>binary_search</u>.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All constructors, members, operators and manipulators, mentioned in this man-page,  are  defined  in  the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       -

</pre><h4><b>OVERLOADED</b> <b>FUNCTIONS</b></h4><pre>
       In the following description several template type parameters are used. They are:

       o      <b>Iterator</b> represents an iterator type;

       o      <b>Type</b> represents a value of the type to which <u>Iterator</u> points.

       o      <b>Comparator</b>  represents  a  comparator  function  or  class  type object which was used to sort the
              elements to which the <u>Iterator</u> range refer;

       o      <b>Iterator</b> <b>binary_search(Iterator</b> <b>begin,</b> <b>Iterator</b> <b>end,</b> <b>Type</b> <b>const</b> <b>&amp;value)</b>:
              Using a binary search algorithm <u>value</u> is searched for in the range of elements referred to by  the
              provided  iterator  range.  If  the value is found an iterator pointing to this value is returned,
              otherwise <u>end</u> is returned. The elements in the range must have been sorted by the <u>Type’s</u> <u>operator&lt;</u>
              function.

       o      <b>Iterator</b> <b>binary_search(Iterator</b> <b>begin,</b> <b>Iterator</b> <b>end,</b> <b>Type</b> <b>const</b> <b>&amp;value,</b> <b>Comparator</b> <b>comparator)</b>:
              Using a binary search algorithm <u>value</u> is searched for in the range of elements referred to by  the
              provided  iterator  range.  If  the value is found an iterator pointing to this value is returned,
              otherwise  <u>end</u>  is  returned.  The  elements  and  the   provided   value   are   compared   using
              <u>comparator(*iterator,</u>  <u>value)</u>  calls, where <u>*iterator</u> refers to an object in the provided iterator
              range. The elements in the range must have been sorted by  the  <u>Comparator</u>  function  or  function
              object.

              The  <u>comparator</u>  function is called with two arguments. The first argument refers to an element in
              the <u>begin..end</u> range, the second argument refers to <u>value</u>.

              Usually the types of these arguments are identical, but they may differ.  Assuming  that  <u>Iterator</u>
              refers  to elements of a type <u>Data</u>, then comparison operators <u>bool</u> <u>operator&lt;(Data</u> <u>const</u> <u>&amp;lhs,</u> <u>Type</u>
              <u>const</u> <u>&amp;rhs)</u> and <u>bool</u> <u>operator&lt;(Type</u> <u>const</u> <u>&amp;rhs,</u> <u>Data</u> <u>const</u> <u>&amp;lhs)</u> must both be available.

</pre><h4><b>EXAMPLES</b></h4><pre>
       #include &lt;iostream&gt;
       #include &lt;string&gt;

       #include &lt;bobcat/binarysearch&gt;

       using namespace std;

       string words[] =
       {
           "eight",                // alphabetically sorted number-names
           "five",
           "four",
           "nine",
           "one",
           "seven",
           "six",
           "ten",
           "three",
           "two"
       };

       bool compFun(string const &amp;left, string const &amp;right)
       {
           return left &lt; right;
       }

       int main()
       {
           string *ret = FBB::binary_search(words, words + 10, "five");
           if (ret != words + 10)
               cout &lt;&lt; "five is at offset " &lt;&lt; (ret - words) &lt;&lt; endl;

           ret = FBB::binary_search(words, words + 10, "grandpa");
           if (ret == words + 10)
               cout &lt;&lt; "grandpa is not the name of a number\n";

           ret = FBB::binary_search(words, words + 10, "five",
               [&amp;](string const &amp;element, string const &amp;value)
               {
                   return element &lt; value;
               }
           );

           if (ret != words + 10)
               cout &lt;&lt; "five is at offset " &lt;&lt; (ret - words) &lt;&lt; endl;

           ret = FBB::binary_search(words, words + 10, "grandpa", compFun);
                                                          // or use: Comparator()
           if (ret == words + 10)
               cout &lt;&lt; "grandpa is not the name of a number\n";
       }

       and an example showing the use of different types:
       #include &lt;iostream&gt;
       #include &lt;string&gt;

       #include &lt;bobcat/binarysearch&gt;

       using namespace std;

       struct Words
       {
           string str;
           int value;
       };

       bool operator&lt;(Words const &amp;word, string const &amp;str)
       {
           return word.str &lt; str;
       }

       bool operator&lt;(string const &amp;str, Words const &amp;word)
       {
           return str &lt; word.str;
       }

       Words words[] =
       {
           { "eight", 0 },                // alphabetically sorted number-names
           { "five", 0 },
           { "four", 0 },
           { "nine", 0 },
           { "one", 0 },
           { "seven", 0 },
           { "six", 0 },
           { "ten", 0 },
           { "three", 0 },
           { "two", 0 }
       };

       int main()
       {
           auto ret = FBB::binary_search(words, words + 10, "five",
               [&amp;](Words const &amp;element, string const &amp;value)
               {
                   return element &lt; value;
               }
           );

           cout &lt;&lt; (ret != words + 10 ? "found it" : "not present") &lt;&lt; ’\n’;
       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/binarysearch</u> - defines the template functions

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7)

</pre><h4><b>BUGS</b></h4><pre>
       None reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>: debian package containing the static library, headers, manual pages, and  developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                        <u>FBB::<a href="../man3bobcat/binary_search.3bobcat.html">binary_search</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>