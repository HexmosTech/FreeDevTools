<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::MakeMethods::Template - Extensible code templates</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-makemethods-perl">libclass-makemethods-perl_1.01-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::MakeMethods::Template - Extensible code templates

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package MyObject;
         use Class::MakeMethods::Template::Hash (
           'new'       =&gt; 'new',
           'string'    =&gt; 'foo',
           'number'    =&gt; 'bar',
         );

         my $obj = MyObject-&gt;new( foo =&gt; "Foozle", bar =&gt; 23 );
         print $obj-&gt;foo();
         $obj-&gt;<a href="../man42/bar.42.html">bar</a>(42);

</pre><h4><b>MOTIVATION</b></h4><pre>
       If you compare the source code of some of the closure-generating methods provided by other subclasses of
       Class::MakeMethods, such as the "hash" accessors provided by the various Standard::* subclasses, you will
       notice a fair amount of duplication. This module provides a way of assembling common pieces of code to
       facilitate support the maintenance of much larger libraries of generated methods.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module extends the Class::MakeMethods framework by providing an abstract superclass for extensible
       code-templating method generators.

       Common types of methods are generalized into <b>template</b> <b>definitions</b>.  For example, "Template::Generic"'s
       "new" provides a template for methods that create object instances, while "Template::Generic"'s "scalar"
       is a template for methods that allow you to get and set individual scalar values.

       Thse definitions are then re-used and modified by various <b>template</b> <b>subclasses</b>. For example, the
       "Template::Hash" subclass supports blessed-hash objects, while the "Template::Global" subclass supports
       shared data; each of them includes an appropriate version of the "scalar" accessor template for those
       object types.

       Each template defines one or more <b>behaviors</b>, individual methods which can be installed in a calling
       package, and <b>interfaces</b>, which select from those behaviours and indicate the names to install the methods
       under.

       Each individual meta-method defined by a calling package requires a <b>method</b> <b>name</b>, and may optionally
       include other key-value <b>parameters</b>, which can control the operation of some meta-methods.

</pre><h4><b>USAGE</b></h4><pre>
   <b>Class::MakeMethods</b> <b>Calling</b> <b>Conventions</b>
       When you "use" this package, the method declarations you provide as arguments cause subroutines to be
       generated and installed in your module.

       You can also omit the arguments to "use" and instead make methods at runtime by passing the declarations
       to a subsequent call to "make()".

       You may include any number of declarations in each call to "use" or "make()". If methods with the same
       name already exist, earlier calls to "use" or "make()" win over later ones, but within each call, later
       declarations superceed earlier ones.

       You can install methods in a different package by passing "-TargetClass =&gt; <u>package</u>" as your first
       arguments to "use" or "make".

       See Class::MakeMethods for more details.

   <b>Passing</b> <b>Parameters</b>
       The following types of Basic declarations are supported:

       •   <u>generator_type</u> =&gt; "<u>method_name</u>"

       •   <u>generator_type</u> =&gt; "<u>name_1</u> <u>name_2</u>..."

       •   <u>generator_type</u> =&gt; [ "<u>name_1</u>", "<u>name_2</u>", ...]

       See  "TEMPLATE  CLASSES"  in  Class::MakeMethods::Docs::Catalog  for  a  list  of the supported values of
       <u>generator_type</u>.

       For each method name you provide, a subroutine of the indicated type  will  be  generated  and  installed
       under that name in your module.

       Method names should start with a letter, followed by zero or more letters, numbers, or underscores.

   <b>Standard</b> <b>Declaration</b> <b>Syntax</b>
       The  Standard syntax provides several ways to optionally associate a hash of additional parameters with a
       given method name.

       •   <u>generator_type</u> =&gt; [ "<u>name_1</u>" =&gt; { <u>param</u>=&gt;<u>value</u>... }, ... ]

           A hash of parameters to use just for this method name.

           (Note: to prevent confusion with self-contained definition hashes, described below, parameter  hashes
           following a method name must not contain the key 'name'.)

       •   <u>generator_type</u> =&gt; [ [ "<u>name_1</u>", "<u>name_2</u>", ... ] =&gt; { <u>param</u>=&gt;<u>value</u>... } ]

           Each of these method names gets a copy of the same set of parameters.

       •   <u>generator_type</u> =&gt; [ { "name"=&gt;"<u>name_1</u>", <u>param</u>=&gt;<u>value</u>... }, ... ]

           By  including  the  reserved parameter "name", you create a self contained declaration with that name
           and any associated hash values.

       Basic declarations, as described above, are treated as having an empty parameter hash.

   <b>Default</b> <b>Parameters</b>
       A set of default parameters to be used for several  declarations  may  be  specified  using  any  of  the
       following types of arguments to a Template method generator call:

       •   '-<u>param</u>' =&gt; '<u>value</u>'

           Set a default value for the specified parameter.

       •   '--' =&gt; { '<u>param</u>' =&gt; '<u>value</u>', ... }

           Set  default  values  for one or more parameters. Equivalent to a series of '-<u>param</u>' =&gt; '<u>value</u>' pairs
           for each pair in the referenced hash.

       •   '--<u>special_param_value</u>'

           Specifies a value for special parameter; the two supported parameter types are:

           -   '--<u>interface_name</u>'

               Select a predefined interface; equivalent to '-interface'=&gt; '<u>interface_name</u>'.

               For more information about interfaces, see "Selecting Interfaces" below.

           -   '--<u>modifier_name</u>'

               Select a global behavior modifier, such as '--private' or '--protected'.

               For more information about modifiers, see "Selecting Modifiers" below.

       Parameters set in these ways are passed to each declaration that follows it until the end of the  method-
       generator  argument array, or until overridden by another declaration. Parameters specified in a hash for
       a specific method name, as discussed above, will  override  the  defaults  of  the  same  name  for  that
       particular method.

</pre><h4><b>PARAMETER</b> <b>REFERENCE</b></h4><pre>
       Each meta-method is allocated a hash in which to store its parameters and optional information.

       (Note that you can not override parameters on a per-object level.)

   <b>Special</b> <b>Parameters</b>
       The following parameters are pre-defined or have a special meaning:

       •   name

           The primary name of the meta-method. Note that the subroutines installed into the calling package may
           be given different names, depending on the rules specified by the interface.

       •   interface

           The  name  of  a  predefined  interface,  or a reference to a custom interface, to use for this meta-
           method. See "Selecting Interfaces", below.

       •   modifier

           The names of one or more predefined modifier flags. See "Selecting Modifiers", below.

   <b>Informative</b> <b>Parameters</b>
       The following parameters are set automatically when your meta-method is declared:

       •   target_class

           The class that requested the meta-method, into which its subroutines will be installed.

       •   template_name

           The Class::MakeMethods::Template method used for this declaration.

       •   template_class

           The Class::MakeMethods::Template subclass used for this declaration.

   <b>Other</b> <b>Parameters</b>
       Specific subclasses and template types provide support for additional parameters.

       Note that you generally should not arbitrarily assign additional parameters to a meta-method  unless  you
       know that they do not conflict with any parameters already defined or used by that meta-method.

   <b>Parameter</b> <b>Expansion</b>
       If a parameter specification contains '*', it is replaced with the primary method name.

       Example: The following defines counter (*, *_incr, *_reset) meta-methods j and k, which use the hash keys
       j_index and k_index to fetch and store their values.

         use Class::MakeMethods::Template::Hash
           counter =&gt; [ '-hash_key' =&gt; '*_index', qw/ j k / ];

       (See Class::MakeMethods::Template::Hash for information about the "hash_key" parameter.)

       If a parameter specification contains '*{<u>param</u>}', it is replaced with the value of that parameter.

       Example:  The  following  defines  a  Hash  scalar  meta-method  which will store its value in a hash key
       composed of the defining package's name and individual method name, such as "$self-&gt;{<u>MyObject</u>-<u>foo</u>}":

         use Class::MakeMethods::Template::Hash
           'scalar' =&gt; [ '-hash_key' =&gt; '*{target_class}-*{name}', qw/ l / ];

   <b>Selecting</b> <b>Interfaces</b>
       Each template provides one or more predefined interfaces, each of which specifies one or more methods  to
       be installed in your package, and the method names to use. Check the documentation for specific templates
       for a list of which interfaces they define.

       An interface may be specified for a single method by providing an 'interface' parameter:

       •   '<u>interface_name</u>'

           Select a predefined interface.

           Example:  Instead of the normal Hash scalar method named x, the following creates methods with "Java-
           style" names and behaviors, getx and setx.

             use Class::MakeMethods::Template::Hash
               'scalar' =&gt; [ 'x' =&gt; { interface=&gt;'java' } ];

           (See "scalar" in Class::MakeMethods::Template::Generic for a description of the "java" interface.)

       •   '<u>behavior_name</u>'

           A simple interface consisting only of the named behavior.

           For example, the below declaration creates a read-only methods named q. (There are no  set  or  clear
           methods, so any value would have to be placed in the hash by other means.)

             use Class::MakeMethods::Template::Hash (
               'scalar' =&gt; [ 'q' =&gt; { interface=&gt;'get' } ]
             );

       •   {  '<u>subroutine_name_pattern</u>' =&gt; '<u>behavior_name</u>', ... }

           A custom interface consists of a hash-ref that maps subroutine names to the associated behaviors. Any
           "*" characters in <u>subroutine_name_pattern</u> are replaced with the declared method name.

           For example, the below delcaration creates paired get_w and set_w methods:

             use Class::MakeMethods::Template::Hash (
               'scalar' =&gt; [ 'w' =&gt; { interface=&gt; { 'get_*'=&gt;'get', 'set_*'=&gt;'set' } } ]
             );

       Some interfaces provide very different behaviors than the default interface.

       Example:  The  following  defines  a  method  g, which if called with an argument appends to, rather than
       overwriting, the current value:

         use Class::MakeMethods::Template::Hash
           'string' =&gt; [ '--get_concat', 'g' ];

       A named interface may also be specified as a default in the argument list with a leading '--' followed by
       the interface's name.

       Example: Instead of the normal Hash scalar methods (named x and clear_x), the following  creates  methods
       with "Java-style" names and behaviors (getx, setx).

         use Class::MakeMethods::Template::Hash
           'scalar' =&gt; [ '--java', 'x'  ];

       An  interface set in this way affects all meta-methods that follow it until another interface is selected
       or the end of the array is reached; to return to the original names request the 'default' interface.

       Example: The below creates "Java-style" methods for e and f, "normal scalar" methods for g, and  "Eiffel-
       style" methods for h.

         use Class::MakeMethods::Template::Hash
           'scalar' =&gt; [
             '--java'=&gt; 'e', 'f',
             '--default'=&gt; 'g',
             '--eiffel'=&gt; 'h',
           ];

   <b>Selecting</b> <b>Modifiers</b>
       You may select modifiers, which will affect all behaviors.

         use Class::MakeMethods::Template::Hash
             'scalar' =&gt; [ 'a', '--protected' =&gt; 'b', --private' =&gt; 'c' ];

       Method b croaks if it's called from outside of the current package or its subclasses.

       Method c croaks if it's called from outside of the current package.

       See the documentation for each template to learn which modifiers it supports.

   <b>Runtime</b> <b>Parameter</b> <b>Access</b>
       If the meta-method is defined using an interface which includes the attributes method, run-time access to
       meta-method parameters is available.

       Example: The following defines a counter meta-method named y, and then later changes the 'join' parameter
       for that method at runtime.

         use Class::MakeMethods ( get_concat =&gt; 'y' );

         y_attributes(undef, 'join', "\t" )
         print y_attributes(undef, 'join')

</pre><h4><b>EXTENDING</b></h4><pre>
       You can create your own method-generator templates by following the below outline.

   <b>Mechanisms</b>
       Dynamic generation of methods in Perl generally depends on one of two approaches: string evals, which can
       be  as  flexible  as  your  string-manipulation  functions allow, but are run-time resource intensive; or
       closures, which are limited by the number of subroutine constructors you write ahead of  time  but  which
       are faster and smaller than evals.

       Class::MakeMethods::Template uses both of these approaches: To generate different types of subroutines, a
       simple text-substitution mechanism combines bits of Perl to produce the source code for a subroutine, and
       then  evals  those  to produce code refs. Any differences which can be handled with only data changes are
       managed at the closure layer; once the subroutines are built, they are repeatedly bound  as  closures  to
       hashes of parameter data.

   <b>Code</b> <b>Generation</b>
       A  substitution-based  "macro  language"  is  used  to  assemble code strings. This happens only once per
       specific subclass/template/behavior combination used in your program. (If you have disk-caching  enabled,
       the template interpretation is only done once, and then saved; see below.)

       There  are  numerous examples of this within the Generic interface and its subclasses; for examples, look
       at the following methods: Universal:generic, Generic:scalar, Hash:generic, and Hash:scalar.

       See Class::MakeMethods::Utility::TextBuilder for more information.

   <b>Template</b> <b>Definitions</b>
       Template method generators are declared by creating a subroutine that returns a hash-ref  of  information
       about  the  template. When these subroutines are first called, the template information is filled in with
       imported and derived values, blessed as a Class::MakeMethods::Template object, and cached.

       Each "use" of your subclass, or call to its "make",  causes  these  objects  to  assemble  the  requested
       methods and return them to Class::MakeMethods for installation in the calling package.

       Method  generators  defined  this  way will have support for parameters, custom interfaces, and the other
       features discussed above.

       (Your module may also use the "Aliasing"  and  "Rewriting"  functionality  described  in  "EXTENDING"  in
       Class::MakeMethods.)

       Definition  hashes  contain  several  types  of  named resources in a second level of hash-refs under the
       following keys:

       •   interface - Naming styles (see "Defining Interfaces", below)

       •   params - Default parameters for meta-methods declared with this template (see  "Default  Parameters",
           below)

       •   behavior - Method recipes (see "Defining Behaviors", below)

       •   code_expr - Bits of code used by the behaviors

   <b>Minimum</b> <b>Template</b> <b>Definition</b>
       You must at least specify one behavior; all other information is optional.

       Class::MakeMethods  will  automatically  fill  in  the  template  name  and  class as 'template_name' and
       'template_class' entries in the version of your template definition hash that  it  caches  and  uses  for
       future execution.

       For example a simple sub-class that defines a method type upper_case_get_set might look like this:

         package Class::MakeMethods::UpperCase;
         use Class::MakeMethods '-isasubclass';

         sub uc_scalar {
           return {
             'behavior' =&gt; {
               'default' =&gt; sub {
                 my $m_info = $_[0];
                 return sub {
                   my $self = shift;
                   if ( scalar @_ ) {
                     $self-&gt;{ $m_info-&gt;{'name'} } = uc( shift )
                   } else {
                     $self-&gt;{ $m_info-&gt;{'name'} };
                   }
                 }
               },
             }
           }
         }

       And a caller could then use it to generate methods in their package by invoking:

         Class::MakeMethods::UpperCase-&gt;make( 'uc_scalar' =&gt; [ 'foo' ] );

   <b>Default</b> <b>Parameters</b>
       Each template may include a set of default parameters for all declarations as "params =&gt; <u>hash_ref</u>".

       Template-default  parameters  can  be overridden by interface '-params', described below, and and method-
       specific parameters, described above.

   <b>Defining</b> <b>Interfaces</b>
       Template definitions may have one or more interfaces, including the default one, named  'default',  which
       is  automatically  selected  if another interface is not requested. (If no default interface is provided,
       one is constructed, which simply calls for a behavior named default.)

       Most commonly, an interface is specified as a hash which  maps  one  or  more  subroutine  names  to  the
       behavior  to  use  for each. The interface subroutine names generally contain an asterisk character, '*',
       which will be replaced by the name of each meta-method.

       Example: The below defines methods e_get, e_set, and e_clear.

         use Class::MakeMethods::Template::Hash
           'scalar' =&gt; [
             -interface=&gt;{ '*_clear'=&gt;clear, '*_get'=&gt;'get', '*_set'=&gt;'set' }, 'e'
           ];

       If the provided name does not contain an asterisk, it will not be modified for  individual  meta-methods;
       for  examples,  see  the bit_fields method generated by Generic bits, and the DESTROY method generated by
       InsideOut meta-methods.

       In addition to  the  name-to-behavior  correspondences  described  above,  interfaces  may  also  contain
       additional entries with keys beginning with the '-' character which are interpreted as follows:

       •   "-params =&gt; <u>hash_ref</u>"

           Interfaces  may  include a '-params' key and associated reference to a hash of default parameters for
           that interface.

       •   "-base =&gt; <u>interface_name</u>"

           Interfaces can be based on previously existing ones by including a -base  specification  in  the  the
           hash.  The  base  value  should  contain  one  or  more space-separated names of the interfaces to be
           included.

           Example: The below defines methods getG, setG, and clearG.

             use Class::MakeMethods::Template::Hash
               'scalar' =&gt; [
                 -interface =&gt; { -base=&gt;'java', 'clear*'=&gt;'clear' }, qw/ G /
               ];

           If multiple interfaces are included in the -base specification and specify  different  behaviors  for
           the  same  subroutine  name, the later ones will override the earlier. Names which appear in the base
           interface can be overridden by providing a new value, or a name can be removed by mapping it to undef
           or the empty string.

           Example: The following defines a get-set meta-method h, but suppresses the clear_h method:

             use Class::MakeMethods::Template::Hash
               'scalar' =&gt; [
                 -interface =&gt; { -base=&gt;'with_clear', 'clear_*'=&gt;'' }, qw/ h /
               ];

   <b>Defining</b> <b>Behaviors</b>
       Behaviors can be provided as text which is eval'd to form a closure-generating subroutine when it's first
       used; $self is automatically defined and assigned the value of the first argument.

             'behavior' =&gt; {
               'default' =&gt; q{
                   if ( scalar @_ ) { $self-&gt;{ $m_info-&gt;{'name'} } = uc shift }
                   $self-&gt;{ $m_info-&gt;{'name'} };
               },
             }

       A  simple  substitution  syntax  provides  for  macro  interpretation  with  definition   strings.   This
       functionality  is currently undocumented; for additional details see the _interpret_text_builder function
       in Class::MakeMethods, and review the code_expr hashes defined in Class::MakeMethods::Generic.

   <b>Importing</b>
       You can copy values out of other template definitions by specifying an '-import'  key  and  corresponding
       hash  reference.  You can specify an -import for inside any of the template definition sub-hashes.  If no
       -import is specified for a subhash, and there is a top-level -import value, it is used instead.

       Inside an -import hash, provide "<u>TemplateClass</u>:<u>type</u>" names for each source you wish to copy from, and the
       values to import, which can be a string, a reference to an array of strings, or '*' to import  everything
       available. (The order of copying is not defined.)

       Example: The below definition creates a new template which is identical to an existing one.

         package Class::MakeMethods::MyMethods;
         sub scalarama {
           { -import =&gt; { 'Template::Hash:scalar' =&gt; '*' } }
         }

       Values  that  are  already set are not modified, unless they're an array ref, in which case they're added
       to.

       Example:

         package Class::MakeMethods::MyMethods;
         sub foo_method {
           { 'behavior' =&gt; {
             '-init' =&gt; [ sub {  warn "Defining foo_method $_[0]-&gt;{'name'}" } ],
             'default' =&gt; q{ warn "Calling foo_method behavior" }.
           } }
         }
         sub bar_method {
           { 'behavior' =&gt; {
             -import =&gt; { 'MyMethods:foo_method' =&gt; '*' },
             '-init' =&gt; [ sub {  warn "Defining bar_method $_[0]-&gt;{'name'}" } ],
             'default' =&gt; q{ warn "Calling bar_method behavior" }.
           } }
         }

       In this case, the bar_method ends up with an array of two '-init' subroutines, its own and  the  imported
       one, but only its own default behavior.

   <b>Modifying</b> <b>Existing</b> <b>Templates</b>
       You can over-write information contained in template definitions to alter their subsequent behavior.

       Example:  The  following  extends the Hash:scalar template definition by adding a new interface, and then
       uses it to create scalar accessor methods named access_p and access_q that get and  set  values  for  the
       hash keys 'p' and 'q':

         Class::MakeMethods::Template::Hash-&gt;named_method('scalar')-&gt;
                 {'interface'}{'frozzle'} = { 'access_*'=&gt;'get_set' };

         package My::Object;
         Class::MakeMethods::Template::Hash-&gt;make( 'scalar' =&gt; [ --frozzle =&gt; qw( p q ) ] );

         $object-&gt;access_p('Potato');    # $object-&gt;{p} = 'Potato'
         print $object-&gt;access_q();      # print $object-&gt;{q}

       Note  that  this  constitutes  "action  at  a distance" and will affect subsequent use by other packages;
       unless you are "fixing" the current behavior, you are urged to create your own template definition  which
       imports the base behavior of the existing template and overrides the information in question.

       Example:  The  following  safely  declares  a  new  version  of  Hash:scalar  with the desired additional
       interface:

         package My::Methods;

         sub scalar {
           {
             -import =&gt; { 'Template::Hash:scalar' =&gt; '*' } ,
             interface =&gt; { 'frozzle' =&gt; { 'access_*'=&gt;'get_set' } },
           }
         }

         package My::Object;
         My::Methods-&gt;make( 'scalar' =&gt; [ --frozzle =&gt; qw( p q ) ] );

   <b>Disk</b> <b>Caching</b>
       To enable disk caching of generated code, create an empty directory and pass it to the DiskCache package:

         use Class::MakeMethods::Utility::DiskCache qw( /my/code/dir );

       This has a mixed effect on performance, but has the notable advantage of letting you view the subroutines
       that are being generated by your templates.

       See Class::MakeMethods::Utility::DiskCache for more information.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See Class::MakeMethods for general information about this distribution.

       See Class::MakeMethods::Examples for some illustrations of what you can do with this package.

       For    distribution,    installation,    support,    copyright    and    license     information,     see
       Class::MakeMethods::Docs::ReadMe.

perl v5.36.0                                       2022-10-13                         <u>MakeMethods::<a href="../man3pm/Template.3pm.html">Template</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>