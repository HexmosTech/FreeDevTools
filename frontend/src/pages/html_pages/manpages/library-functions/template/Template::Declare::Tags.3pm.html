<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template::Declare::Tags - Build and install XML Tag subroutines for Template::Declare</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtemplate-declare-perl">libtemplate-declare-perl_0.47-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Template::Declare::Tags - Build and install XML Tag subroutines for Template::Declare

</pre><h4><b>SYNOPSIS</b></h4><pre>
           package MyApp::Templates;

           use base 'Template::Declare';
           use Template::Declare::Tags 'HTML';

           template main =&gt; sub {
               link {}
               table {
                   row {
                       cell { "Hello, world!" }
                   }
               }
               img { attr { src =&gt; 'cat.gif' } }
               img { src is 'dog.gif' }
           };

       Produces:

        &lt;link /&gt;
        &lt;table&gt;
         &lt;tr&gt;
          &lt;td&gt;Hello, world!&lt;/td&gt;
         &lt;/tr&gt;
        &lt;/table&gt;
        &lt;img src="cat.gif" /&gt;
        &lt;img src="dog.gif" /&gt;

       Using XUL templates with a namespace:

           package MyApp::Templates;

           use base 'Template::Declare';
           use Template::Declare::Tags
               'XUL', HTML =&gt; { namespace =&gt; 'html' };

           template main =&gt; sub {
               groupbox {
                   caption { attr { label =&gt; 'Colors' } }
                   html::div { html::p { 'howdy!' } }
                   html::br {}
               }
           };

       Produces:

        &lt;groupbox&gt;
         &lt;caption label="Colors" /&gt;
         &lt;html:div&gt;
          &lt;html:p&gt;howdy!&lt;/html:p&gt;
         &lt;/html:div&gt;
         &lt;html:br&gt;&lt;/html:br&gt;
        &lt;/groupbox&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Template::Declare::Tags" is used to generate templates and install subroutines for tag sets into the
       calling namespace.

       You can specify the tag sets to install by providing a list of tag modules in the "use" statement:

           use Template::Declare::Tags qw/ HTML XUL /;

       By default, Template::Declare::Tags uses the tag set provided by Template::Declare::TagSet::HTML. So

           use Template::Declare::Tags;

       is equivalent to

           use Template::Declare::Tags 'HTML';

       Currently Template::Declare bundles the following tag sets: Template::Declare::TagSet::HTML,
       Template::Declare::TagSet::XUL, Template::Declare::TagSet::RDF, and Template::Declare::TagSet::RDF::EM.

       You can specify your own tag set classes, as long as they subclass Template::Declare::TagSet and
       implement the corresponding methods (e.g.  "get_tag_list").

       If you implement a custom tag set module named "Template::Declare::TagSet::Foo", you can load it into a
       template module like so:

           use Template::Declare::Tags 'Foo';

       If your tag set module is not under the Template::Declare::TagSet namespace, use the "from" option to
       load it. Fore example, if you created a tag set named "MyTag::Foo", then you could load it like so:

           use Template::Declare::Tags Foo =&gt; { from =&gt; 'MyTag::Foo' };

       XML namespaces are emulated by Perl packages. For example, to embed HTML tags within XUL using the "html"
       namespace:

           package MyApp::Templates;

           use base 'Template::Declare';
           use Template::Declare::Tags 'XUL', HTML =&gt; { namespace =&gt; 'html' };

           template main =&gt; sub {
               groupbox {
                   caption { attr { label =&gt; 'Colors' } }
                   html::div { html::p { 'howdy!' } }
                   html::br {}
               }
           };

       This will output:

        &lt;groupbox&gt;
         &lt;caption label="Colors" /&gt;
         &lt;html:div&gt;
          &lt;html:p&gt;howdy!&lt;/html:p&gt;
         &lt;/html:div&gt;
         &lt;html:br&gt;&lt;/html:br&gt;
        &lt;/groupbox&gt;

       Behind the scenes, "Template::Declare::Tags" generates a Perl package named "html" and installs the HTML
       tag subroutines into that package. On the other hand, XUL tag subroutines are installed into the current
       package, namely, "MyApp::Templates" in the previous example.

       There may be cases when you want to specify a different Perl package for a particular XML namespace. For
       instance, if the "html" Perl package has already been used for other purposes in your application and you
       don't want to install subs there and mess things up, use the "package" option to install them elsewhere:

           package MyApp::Templates;
           use base 'Template::Declare';
           use Template::Declare::Tags 'XUL', HTML =&gt; {
               namespace =&gt; 'htm',
               package   =&gt; 'MyHtml'
           };

           template main =&gt; sub {
               groupbox {
                   caption { attr { label =&gt; 'Colors' } }
                   MyHtml::div { MyHtml::p { 'howdy!' } }
                   MyHtml::br {}
               }
           };

       This code will generate something like the following:

        &lt;groupbox&gt;
         &lt;caption label="Colors" /&gt;
         &lt;htm:div&gt;
          &lt;htm:p&gt;howdy!&lt;/htm:p&gt;
         &lt;/htm:div&gt;
         &lt;htm:br&gt;&lt;/htm:br&gt;
        &lt;/groupbox&gt;

</pre><h4><b>METHODS</b> <b>AND</b> <b>SUBROUTINES</b></h4><pre>
   <b>Declaring</b> <b>templates</b>
       <u>template</u> <u>TEMPLATENAME</u> <u>=&gt;</u> <u>sub</u> <u>{</u> <u>'Implementation'</u> <u>};</u>

           template select_list =&gt; sub {
               my $self = shift;
               select {
                   option { $_ } for @_;
               }
           };

       Declares a template in the current package. The first argument to the template subroutine will always be
       a "Template::Declare" object. Subsequent arguments will be all those passed to "show()". For example, to
       use the above example to output a select list of colors, you'd call it like so:

           Template::Declare-&gt;show('select_list', qw(red yellow green purple));

       You can use any URL-legal characters in the template name; "Template::Declare" will encode the template
       as a Perl subroutine and stash it where "show()" can find it.

       (Did you know that you can have characters like ":" and "/" in your Perl subroutine names? The easy way
       to get at them is with "can").

       <u>private</u> <u>template</u> <u>TEMPLATENAME</u> <u>=&gt;</u> <u>sub</u> <u>{</u> <u>'Implementation'</u> <u>};</u>

           private template select_list =&gt; sub {
               my $self = shift;
               select {
                   option { $_ } for @_;
               }
           };

       Declares that a template isn't available to be called directly from client code. The resulting template
       can instead only be called from the package in which it's created.

   <b>Showing</b> <b>templates</b>
       <u>show</u> <u>[$template_name</u> <u>or</u> <u>$template_coderef],</u> <u>args</u>

           show( main =&gt; { user =&gt; 'Bob' } );

       Displays templates. The first argument is the name of the template to be displayed. Any additional
       arguments will be passed directly to the template.

       "show" can either be called with a template name or a package/object and a template. (It's both
       functional and OO.)

       If called from within a Template::Declare subclass, then private templates are accessible and visible. If
       called from something that isn't a Template::Declare, only public templates will be visible.

       From the outside world, users can either call "Template::Declare-&gt;show()", "show()" exported from
       Template::Declare::Tags or "Template::Declare::Tags::show()" directly to render a publicly visible
       template.

       Private templates may only be called from within the "Template::Declare" package.

       <u>show_page</u>

           show_page( main =&gt; { user =&gt; 'Bob' } );

       Like "show()", but does not dispatch to private templates. It's used internally by "show()" when when
       that method is called from outside a template class.

   <b>Attributes</b>
       <u>attr</u> <u>HASH</u>

           attr { src =&gt; 'logo.png' };

       Specifies attributes for the element tag in which it appears. For example, to add a class and ID to an
       HTML paragraph:

           p {
              attr {
                  class =&gt; 'greeting text',
                  id    =&gt; 'welcome',
              };
              'This is a welcoming paragraph';
           }

       <u>ATTR</u> <u>is</u> <u>VALUE</u>

       Attributes can also be specified by using "is", as in

           p {
              class is 'greeting text';
              id    is 'welcome';
              'This is a welcoming paragraph';
           }

       A few tricks work for 'is':

           http_equiv is 'foo'; # =&gt; http-equiv="foo"
           xml__lang is 'foo';  # =&gt; xml:lang="foo"

       So double underscore replaced with colon and single underscore with dash.

       <u>with</u>

           with ( id =&gt; 'greeting', class =&gt; 'foo' ),
               p { 'Hello, World wide web' };

       An alternative way to specify attributes for a tag, just for variation. The standard way to do the same
       as this example using "attr" is:

           p { attr { id =&gt; 'greeting', class =&gt; 'foo' }
               'Hello, World wide web' };

   <b>Displaying</b> <b>text</b> <b>and</b> <b>raw</b> <b>data</b>
       <u>outs</u> <u>STUFF</u>

           p { outs 'Grettings &amp; welcome pyoonie hyoomon.' }

       HTML-encodes its arguments and appends them to "Template::Declare"'s output buffer. This is similar to
       simply returning a string from a tag function call, but is occasionally useful when you need to output a
       mix of things, as in:

           p { outs 'hello'; em { 'world' } }

       <u>outs_raw</u> <u>STUFF</u>

          p { outs_raw "That's what &lt;em&gt;I'm&lt;/em&gt; talking about!' }

       Appends its arguments to "Template::Declare"'s output buffer without HTML escaping.

   <b>Installing</b> <b>tags</b> <b>and</b> <b>wrapping</b> <b>stuff</b>
       <u>install_tag</u> <u>TAGNAME,</u> <u>TAGSET</u>

           install_tag video =&gt; 'Template::Declare::TagSet::HTML';

       Sets up TAGNAME as a tag that can be used in user templates. TAGSET is an instance of a subclass for
       Template::Declare::TagSet.

       <u>smart_tag_wrapper</u>

           # create a tag that has access to the arguments set with L&lt;/with&gt;.
           sub sample_smart_tag (&amp;) {
               my $code = shift;

               smart_tag_wrapper {
                   my %args = @_; # set using 'with'
                   outs( 'keys: ' . join( ', ', sort keys %args) . "\n" );
                   $code-&gt;();
               };
           }

           # use it
           with ( foo =&gt; 'bar', baz =&gt; 'bundy' ), sample_smart_tag {
               outs( "Hello, World!\n" );
           };

       The output would be

           keys: baz, foo
           Hello, World!

       The smart tag wrapper allows you to create code that has access to the attribute arguments specified via
       "with". It passes those arguments in to the wrapped code in @_. It also takes care of putting the output
       in the right place and tidying up after itself. This might be useful to change the behavior of a template
       based on attributes passed to "with".

       <u>create_wrapper</u> <u>WRAPPERNAME</u> <u>=&gt;</u> <u>sub</u> <u>{</u> <u>'Implementation'</u> <u>};</u>

           create_wrapper basics =&gt; sub {
               my $code = shift;
               html {
                   head { title { 'Welcome' } };
                   body { $code-&gt;() }
               }
           };

       "create_wrapper" declares a wrapper subroutine that can be called like a tag sub, but can optionally take
       arguments to be passed to the wrapper sub. For example, if you wanted to wrap all of the output of a
       template in the usual HTML headers and footers, you can do something like this:

           package MyApp::Templates;
           use Template::Declare::Tags;
           use base 'Template::Declare';

           BEGIN {
               create_wrapper wrap =&gt; sub {
                   my $code = shift;
                   my %params = @_;
                   html {
                       head { title { outs "Hello, $params{user}!"} };
                       body {
                           $code-&gt;();
                           div { outs 'This is the end, my friend' };
                       };
                   }
               };
           }

           template inner =&gt; sub {
               wrap {
                   h1 { outs "Hello, Jesse, s'up?" };
               } user =&gt; 'Jesse';
           };

       Note how the "wrap" wrapper function is available for calling after it has been declared in a "BEGIN"
       block. Also note how you can pass arguments to the function after the closing brace (you don't need a
       comma there!).

       The output from the "inner" template will look something like this:

        &lt;html&gt;
         &lt;head&gt;
          &lt;title&gt;Hello, Jesse!&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
          &lt;h1&gt;Hello, Jesse, s&amp;#39;up?&lt;/h1&gt;
          &lt;div&gt;This is the end, my friend&lt;/div&gt;
         &lt;/body&gt;
        &lt;/html&gt;

   <b>Helpers</b>
       <u>xml_decl</u> <u>HASH</u>

           xml_decl { 'xml', version =&gt; '1.0' };

       Emits an XML declaration. For example:

           xml_decl { 'xml', version =&gt; '1.0' };
           xml_decl { 'xml-stylesheet',  href =&gt; "chrome://global/skin/", type =&gt; "text/css" };

       Produces:

        &lt;?xml version="1.0"?&gt;
        &lt;?xml-stylesheet href="chrome://global/skin/" type="text/css"?&gt;

       <u>current_template</u>

           my $path = current_template();

       Returns the absolute path of the current template

       <u>current_base_path</u>

           my $path = current_base_path();

       Returns the absolute base path of the current template

       <u>under</u>

       "under" is a helper function providing semantic sugar for the "mix" method of Template::Declare.

       <u>setting</u>

       "setting" is a helper function providing semantic sugar for the "mix" method of Template::Declare.

</pre><h4><b>VARIABLES</b></h4><pre>
       @Template::Declare::Tags::EXPORT
           Holds  the  names  of the static subroutines exported by this class. Tag subroutines generated by tag
           sets, however, are not included here.

       @Template::Declare::Tags::TAG_SUB_LIST
           Contains the names of the tag subroutines generated from a tag set.

           Note that this array won't get cleared automatically  before  another  "use  Template::Decalre::Tags"
           statement.

           @Template::Declare::Tags::TagSubs is aliased to this variable for backward-compatibility.

       $Template::Declare::Tags::TAG_NEST_DEPTH
           Controls  the  indentation  of  the  XML  tags in the final outputs. For example, you can temporarily
           disable a tag's indentation by the following lines of code:

               body {
                   pre {
                     local $Template::Declare::Tags::TAG_NEST_DEPTH = 0;
                     script { attr { src =&gt; 'foo.js' } }
                   }
               }

           It generates

            &lt;body&gt;
             &lt;pre&gt;
            &lt;script src="foo.js"&gt;&lt;/script&gt;
             &lt;/pre&gt;
            &lt;/body&gt;

           Note that now the "script" tag has <u>no</u> indentation and we've got what we want. ;)

       $Template::Declare::Tags::SKIP_XML_ESCAPING
           Disables XML escape postprocessing entirely. Use at your own risk.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Template::Declare::TagSet::HTML, Template::Declare::TagSet::XUL, Template::Declare.

</pre><h4><b>AUTHORS</b></h4><pre>
       Jesse Vincent &lt;<a href="mailto:jesse@bestpractical.com">jesse@bestpractical.com</a>&gt;

       Agent Zhang &lt;<a href="mailto:agentzh@yahoo.cn">agentzh@yahoo.cn</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2006-2009 Best Practical Solutions, LLC.

perl v5.34.0                                       2022-06-17                       <u>Template::Declare::<a href="../man3pm/Tags.3pm.html">Tags</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>