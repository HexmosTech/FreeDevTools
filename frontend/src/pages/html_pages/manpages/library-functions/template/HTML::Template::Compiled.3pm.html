<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Template::Compiled - Template System Compiles HTML::Template files to Perl code</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-template-compiled-perl">libhtml-template-compiled-perl_1.003-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Template::Compiled - Template System Compiles HTML::Template files to Perl code

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use HTML::Template::Compiled;
         # recommended options:
         # case_sensitive =&gt; 1
         # search_path_on_include =&gt; 1
         # use_query =&gt; 0
         # default_escape =&gt; 'HTML' # &lt;-- HIGHLY RECOMMENDED

         # note that the following
         # use HTML::Template::Compiled speed =&gt; 1
         # is deprecated (can be problematic under persistent environments)

         # or for the biggest compatibility with HTML::Template
         # case_sensitive =&gt; 0
         # search_path_on_include =&gt; 0
         # use_query =&gt; 1
         # note that the following
         # use HTML::Template::Compiled compatible =&gt; 1;
         # is deprecated (can be problematic under persistent environments)

         # or use HTML::Template::Compiled::Classic

           my $htc = HTML::Template::Compiled-&gt;new(
               filename            =&gt; 'test.tmpl',
               case_sensitive      =&gt; 1,
               default_escape      =&gt; 'HTML',
           );
           $htc-&gt;param(
               BAND =&gt; $name,
               ALBUMS =&gt; [
                   { TITLE =&gt; $t1, YEAR =&gt; $y1 },
                   { TITLE =&gt; $t2, YEAR =&gt; $y2 },
               ],
           );
           print $htc-&gt;output;

         test.tmpl:
         Band: &lt;TMPL_VAR BAND&gt;
         &lt;TMPL_LOOP ALBUMS&gt;
         Title: &lt;TMPL_VAR TITLE&gt; (&lt;TMPL_VAR YEAR&gt;)
         &lt;/TMPL_LOOP&gt;

         Or use different tag styles:
         Band: &lt;%= BAND %&gt;
         &lt;%loop ALBUMS %&gt;
         Title: &lt;%= TITLE %&gt; (&lt;%= YEAR %&gt;)
         &lt;%/loop %&gt;
         Band: [%= BAND %]
         [%loop ALBUMS %]
         Title: [%= TITLE %] ([%= YEAR %])
         [%/loop %]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       HTML::Template::Compiled is a template system which can be used for HTML::Template templates with almost
       the same API. It offers more flexible template delimiters, additional tags and features, and by compiling
       the template into perl code it can run significantly faster in persistent environments such as FastCGI or
       mod_perl.

       The goal is to offer more features for flexibility but keep the basic syntax as easy as it is.

       Features at a glance:

       Dot notation for objects, hashes and arrays
       Use expressions without any disadvantages like those in HTML::Template::Expr
       Write escaping plugins and plugins for new tags
       Alternate delimiters, e.g. "[%if %]" and "&lt;%if %&gt;"
       Avoid "global_vars" option by using the "SET_VAR" tag to create aliases.
       Tags ELSIF, EACH, WHILE, COMMENT, WRAPPER, SWITCH/CASE, INCLUDE_VAR
       Chomp newlines/whitespace

       For a quick reference, see HTML::Template::Compiled::Reference.

       As the basic features work like in HTML::Template, please get familiar with its documentation before.

       HTML::Template::Compiled  (HTC)  does not implement all features of HTML::Template (see "COMPATIBILITY"),
       and it has got some additional features which are explained below: "ADDITIONAL FEATURES"

       See "BENCHMARKS" for some examples on the performance. Since it depends highly on the options used and on
       the template size there can be no general statement on its performance.

       You might want to use HTML::Template::Compiled::Lazy  for  CGI  environments  as  it  doesn't  parse  the
       template  before calling output. But note that HTC::Lazy isn't much tested, and I don't use it myself, so
       there's a lack of experience.  If you use it and have problems, please report.

       HTC will use a lot of memory because it keeps all template objects in memory.  If you  are  on  mod_perl,
       and  have  a  lot of templates, you should preload them at server startup to be sure that it is in shared
       memory. At the moment HTC is not fully tested for keeping all data in shared memory (e.g. when a copy-on-
       write occurs), but it seems like it's behaving well.  For preloading you can use
         HTML::Template::Compiled-&gt;preload($cache_dir).

       Generating code, writing it on disk and later <b>eval()</b> it can open security holes, for example if you  have
       more users on the same machine that can access the same files (usually an http server running as 'www' or
       'nobody'). See "SECURITY" for details what you can do to safe yourself.

       NOTE:  If  you don't need any of the additional features listed below and if you don't need the speed (in
       many cases it's probably not worth trading speed for memory), then you might  be  better  off  with  just
       using HTML::Template.

       NOTE2:  If  you  have  any questions, bug reports, send them to me and not to Sam Tregar.  This module is
       developed by me at the moment, independently from HTML::Template, although I try to get most of the tests
       from it passing for HTC. See "RESOURCES" for current information.

   <b>FEATURES</b> <b>FROM</b> <b>HTML::TEMPLATE</b>
       TMPL_VAR
       TMPL_LOOP
       TMPL_(IF|UNLESS|ELSE)
       TMPL_INCLUDE
       HTML_TEMPLATE_ROOT
       ESCAPE=(HTML|URL|JS|0)
       DEFAULT=...
       "__first__", "__last__", "__inner__", "__outer__", "__odd__", "__counter__", "__even__"
       &lt;!-- TMPL_VAR NAME=PARAM1 --&gt;
       case insensitive var names
           use option case_sensitive =&gt; 0 to use this feature (slow down)

       filters
       vars that are subrefs - not implemented, only in HTML::Template::Compiled::Classic
       scalarref, arrayref, filehandle
       "global_vars"
       "query"
           Has a bug (doesn't return parameters in included files of included files).  I'm working on that.

   <b>ADDITIONAL</b> <b>FEATURES</b>
       What can HTC do for you additionally to HTML::Template?

       tag TMPL_ELSIF
           No need to have cascading "if-else-if-else"s

       tag TMPL_EACH
           Iterate over a hash. See "TMPL_EACH"

       tag TMPL_WITH
           see "TMPL_WITH"

       tag TMPL_WHILE
           see "TMPL_WHILE"

       tag TMPL_SET_VAR
           see "SET_VAR"

       tag TMPL_USE_VARS
           see "USE_VARS"

       tags TMPL_COMMENT, TMPL_NOPARSE, TMPL_VERBATIM
           see "TMPL_COMMENT", "TMPL_NOPARSE", "TMPL_VERBATIM"

       tag TMPL_WRAPPER
           see "WRAPPER"

       "__index__"
           Additional loop variable ("__counter__ -1")

       "__break__"
           Additional loop variable (see "TMPL_LOOP")

       "__filename__", "__filenameshort__" (since 0.91_001)
           Insert the template filename for debugging:

               &lt;%= __filename__ %&gt;
               &lt;%= __filenameshort__ %&gt;

           will turn out as:
               templates/path/file.html
               path/file.html

           See also option debug_file in "OPTIONS" for adding the filename globally.

       tags TMPL_SWITCH, TMPL_CASE
           see "TMPL_SWITCH"

       "TMPL_PERL"
           Include perl code in your template. See "RUNNING PERL WITH TMPL_PERL"

       CHOMP
           New in version 0.96_001, please report any bugs and send me suggestions.

           You can set global chomp options in the constructor. These work like in Template-Toolkit:

               my $htc = HTML::Template::Compiled-&gt;new(
                   pre_chomp  =&gt; 0, # 0, 1, 2, 3, default 0
                   post_chomp =&gt; 1, # 0, 1, 2, 3, default 0
               );

           Meaning of the values: 0: Don't chomp 1: remove only spaces in the line before or after  the  tag  2:
           remove  all whitespaces before or after the tag, and replace with one space 3: remove all whitespaces
           before or after the tag

           In the template you can change that feature by using PRE_CHOMP and POST_CHOMP attributes:

               &lt;%= foo PRE_CHOMP=3 POST_CHOMP=1 %&gt;

           The experimental tags +..._chomp have been removed.

       Generating perl code
           See "IMPLEMENTATION"

       better variable access
           dot-notation for accessing hash values. See "EXTENDED VARIABLE ACCESS"

       rendering objects
           dot-notation for accessing object methods. See "RENDERING OBJECTS"

       output to filehandle
           See "OPTIONS"

       Dynamic includes
           "INCLUDE_VAR", "INCLUDE_STRING". See "INCLUDE"

       tag TMPL_IF_DEFINED
           Check for definedness instead of truth:
             &lt;TMPL_IF_DEFINED NAME="var"&gt;

       ALIAS
           Set an alias for a loop variable. You can use the alias then with $alias.  The syntax without the "$"
           is also possible but not recommended any more.

           For example, these two loops are functionally equivalent:

            &lt;tmpl_loop foo&gt;
              &lt;tmpl_var _&gt;
            &lt;/tmpl_loop foo&gt;
            &lt;tmpl_loop foo alias=current&gt;
              &lt;tmpl_var $current&gt;
            &lt;/tmpl_loop foo&gt;

           This works with "TMPL_LOOP" and "TMPL_WHILE" at the moment.

           You can also set aliases with the "SET_VAR" tag. See "SET_VAR"

           To use template parameters with a "$" at the beginning (which is not officially supported,  but  some
           are obviously using it), you can set:

               local $HTML::Template::Compiled::Compiler::DISABLE_NEW_ALIAS = 1;

           This is only a temporary workaround and will be removed some day!

           Note that you are also able to access variables with dollar signs like this:

               &lt;tmpl_var _.$foo &gt;

           since  underscore  means  current position in the parameter stash, and aliases are only recognized at
           the beginning of a template var. But note that dollar signs are still not officially supported.

       Chained escaping
           See "ESCAPING"

       tagstyles
           For those who like it (i like it because it is shorter than TMPL_), you can use &lt;% %&gt;  tags  and  the
           &lt;%= tag instead of &lt;%VAR (which will work, too):

            &lt;%IF blah%&gt;  &lt;%= VARIABLE%&gt;  &lt;%/IF%&gt;

           Define your own tagstyles and/or deactivate predefined ones.  See "OPTIONS" tagstyle.

       pre_chomp, post_chomp
           See "CHOMP"

   <b>MISSING</b> <b>AND</b> <b>DIFFERENT</b> <b>FEATURES</b>
       There are some features of H::T that are missing or behaving different.  I'll try to list them here.

       <u>MISSING</u> <u>FEATURES</u>

       die_on_bad_params
           I don't think I'll implement that.

       force_untaint
           Not planned at the moment

       vanguard_compatibility_mode
           Not planned.

       shared_cache, double_cache
           Not planned at the moment

       blind_cache
           Not  sure  if  I  should  implement.  In  HTC  you have the possibility to set the expire time of the
           templates (after that time in memory the template file is rechecked if it has changed), so setting  a
           very  high  value  for  expire_time  would  have  the  same  effect  as  blind_cache.   See "CACHING"
           "expire_time"

       double_file_cache
           If I understand correctly, in HT, this enables memory and file cache at the same time. In  HTC,  this
           is not needed. If you use file_cache and cache, both are used.

       file_cache_dir_mode
           Not planned. The cache dir must exist, and subdirectories are not created at the moment.

       cache_lazy_vars, cache_lazy_loops
           Not  planned  at the moment (This would be for HTML::Template::Compiled::Classic, since it implements
           code refs).

       utf8
           Might be added in the future, HTC already has "open_mode"

       various debug options
           Might be implemented in the future

       associate
           Not planned.

       max_includes
           Not planned

       die_on_missing_include
           Maybe

       <u>DIFFERENT</u> <u>FEATURES</u>

       case_sensitive
           default is 1 (on).

           Deactivate by passing option case_sensitive 0.

           Note (again): this will slow down templating a lot (50%).

           Explanation: This has nothing to do with "TMPL_IF" or "tmpl_if". It's about the variable names.  With
           case_sensitive set to 1, the following tags are different:

               &lt;tmpl_var Foo&gt; prints the value of hash key 'Foo'
               &lt;tmpl_var fOO&gt; prints the value of hash key 'fOO'

           With case_sensitive set to 0, all your parameters passed to "param()" are converted to lowercase, and
           the following tags are the same:

               &lt;tmpl_var Foo&gt; prints the value of hash key 'foo'
               &lt;tmpl_var fOO&gt; prints the value of hash key 'foo'

       subref variables
           As  of  version  0.69, subref variables are not supported any more with HTML::Template::Compiled. Use
           HTML::Template::Compiled::Classic (contained in this distribution) instead. It provides most features
           of HTC.

       search_path_on_include
           Default: 0

           In the HTML::Template documentation it says, if search_path_on_include is set to 1, the paths of  the
           path  option  are  searched,  while  the  default behaviour is to look "only" in the current template
           directory.

           It's not clear if it still searches in the current directory if set to 1. I found out that it is not,
           so you cannot have both.

           In HTML::Template::Compiled, search_path_on_include can have three values:
               0: search current template directory
               1: search paths specified
               2: search paths and current template directory.

       open_mode
           In HTC you should leave out the "&lt;" at the beginning.

           If you want to have your templates read in utf-8, use

               open_mode =&gt; ':encoding(utf-8)',

           as an option.

       use_query
           default is 0 (off). Set it via the option "use_query"

       Arrayrefs
           At the moment this snippet

             &lt;tmpl_if arrayref&gt;true&lt;tmpl_else&gt;false&lt;/tmpl_if arrayref&gt;

           with this code:

               $htc-&gt;param(arrayref =&gt; []);

           will print true in HTC and false in HTML::Template. In HTML::Template an array  is  true  if  it  has
           content,  in  HTC  it's  true if it (the reference) is defined. I'll try to find a way to change that
           behaviour, though that might be for the cost of speed.

           As of HTML::Template::Compiled 0.85 you can use this syntax:

               &lt;tmpl_if arrayref# &gt;true&lt;tmpl_else&gt;false&lt;/tmpl_if &gt;

           In HTML::Template::Compiled::Classic 0.04 it works as in HTML::Template.

       debug_cache
           Additional to 0 or 1 it can take an array ref for debugging only specific cache operations.

       Note: the following is deprecated:

           To be compatible in all of the above options all use:

             use HTML::Template::Compiled compatible =&gt; 1;

           If you don't care about these options you should use

             use HTML::Template::Compiled speed =&gt; 1;

        which is the default but depending on user wishes that might change.

   <b>DEPRECATED</b>
       class methods ExpireTime, EnableSub, CaseSensitive, SearchPathOnInclude, UseQuery
       option formatter_path
       tag USE_VARS, not needed anymore
       option cache_dir (replaced by file_cache_dir)
       options method_call, deref, default_path, dumper
       import tags short, compatible, speed

   <b>ESCAPING</b>
       Like in HTML::Template, you have "ESCAPE=HTML", "ESCAPE=URL" and "ESCAPE_JS".   "ESCAPE=HTML"  will  only
       escape  '"&amp;&lt;&gt;.  If  you want to escape more, use "ESCAPE=HTML_ALL".  Additionally you have "ESCAPE=DUMP",
       which by default will generate a Data::Dumper output.

       You can also chain different escapings, like "ESCAPE=DUMP|HTML".

       Additionally to ESCAPE=JS you have ESCAPE=IJSON which does not escape the single quote.

   <b>INCLUDE</b>
       Additionally to

         &lt;TMPL_INCLUDE NAME="file.htc"&gt;

       you can do an include of a template variable:

         &lt;TMPL_INCLUDE_VAR NAME="file_include_var"&gt;
         $htc-&gt;param(file_include_var =&gt; "file.htc");

       Using "INCLUDE VAR="..."" is deprecated.

       You can also include strings:

           template:
           inc: &lt;%include_string foo %&gt;

           code:
           $htc-&gt;param(
               foo =&gt; 'included=&lt;%= bar%&gt;',
               bar =&gt; 'real',
           );

           output:
           inc: included=real

       Note that included strings are not cached and cannot include files or strings themselves.

   <b>EXTENDED</b> <b>VARIABLE</b> <b>ACCESS</b>
       With HTC, you have more control over how you access your template parameters. An example:

         my %hash = (
           SELF =&gt; '/path/to/script.pl',
           LANGUAGE =&gt; 'de',
           BAND =&gt; 'Bauhaus',
           ALBUMS =&gt; [
           {
             NAME =&gt; 'Mask',
             SONGS =&gt; [ { NAME =&gt; 'Hair of the Dog' }, ... ],
           },
           ],
           INFO =&gt; {
             BIOGRAPHY =&gt; '...',
             LINK =&gt; '...'
           },
           NAME =&gt; "Cool script",
         );

       Now in the TMPL_LOOP "ALBUMS" you would like to access the path to your script, stored in $hash{SELF}. in
       HTML::Template you have to set the option "global_vars", so you can access $hash{SELF}  from  everywhere.
       Unfortunately, now "NAME" is also global, which might not a problem in this simple example, but in a more
       complicated template this is impossible. With HTC, you wouldn't use "global_vars" here, but you can say:

         &lt;TMPL_VAR .SELF&gt;

       to  access  the  root element, and you could even say ".INFO.BIOGRAPHY" or "ALBUMS[0].SONGS[0].NAME" (the
       latter has changed since version 0.79)

   <b>RENDERING</b> <b>OBJECTS</b>
       This is still in development, so I might change the API here.

       Additionally to feeding a simple hash to HTC, you can feed it objects.  To do method calls you  can  also
       use '.' in the template.

         my $htc = HTML::Template::Compiled-&gt;new(
           ...
         );

         $htc-&gt;param(
           VAR =&gt; "blah",
           OBJECT =&gt; bless({...}, "Your::Class"),
         );

         &lt;TMPL_VAR NAME="OBJECT.fullname"&gt;
         &lt;TMPL_WITH OBJECT&gt;
         Name: &lt;TMPL_VAR fullname&gt;
         &lt;/TMPL_WITH&gt;

       "fullname" will call the fullname method of your Your::Class object.

       It's recommended to just use the default . value for methods and dereferencing.

       I  might  stop  supporting  that  you can set the values for method calls by setting an option. Ideally I
       would like to have that behaviour changed only by inheriting.

   <b>RUNNING</b> <b>PERL</b> <b>WITH</b> <b>TMPL_PERL</b>
       Yes, templating systems are for separating code and templates. But as it turned  out  to  be  implemented
       much  easier  than  expressions  i  decided  to implement it. But expressions are also available with the
       option "use_expressions".

       Note: If you have templates that can be edited by untrustworthy persons  then  you  don't  want  them  to
       include perl code.

       So,  how  do  you  use  the  perl-tag?  First, you have to set the option "use_perl" to 1 when creating a
       template object.

       Important note: don't use "print" in the included code. Usually the template  code  is  concatenated  and
       returned to your perl script.  To 'print' something out use

           __OUT__ 2**3;

       This will be turned into something like

           $OUT .= 2**3;
           # or
           print $fh 2**3;

       Important note 2: HTC does not parse Perl. if you use the classic tag-delimiters like this:

           &lt;tmpl_perl if (__CURRENT__-&gt;count &gt; 42) { &gt;

       this will not work as it might seem. Use other delimiters instead:

           &lt;%perl if (__CURRENT__-&gt;count &gt; 42) { %&gt;

       Example:

           &lt;tmpl_loop list&gt;
           &lt;tmpl_perl unless (__INDEX__ % 3) { &gt;
             &lt;/tr&gt;&lt;tr&gt;
           &lt;tmpl_perl } &gt;
           &lt;/tmpl_loop list&gt;

           # takes the current position of the parameter
           # hash, key 'foo' and multiplies it with 3
           &lt;%perl __OUT__ __CURRENT__-&gt;{foo} * 3; %&gt;

       List of special keywords inside a perl-tag:

       __OUT__
           Is turned into "$OUT .=" or "print $fh"

       __HTC__
           Is turned into the variable containing the current template object.

       __CURRENT__
           Turned into the variable containing the current position in the parameter hash.

       __ROOT__
           Turned into the variable containing the parameter hash.

       __INDEX__
           Turned into the current index of a loop (starting with 0).

   <b>INHERITANCE</b>
       It's possible since version 0.69 to inherit from HTML::Template::Compiled.  It's just not documented, and
       internal method names might change in the near future. I'll try to fix the API and document which methods
       you can inherit.

       <u>METHODS</u> <u>TO</u> <u>INHERIT</u>

       method_call
           Default is "sub method_call { '.' }"

       deref
           Default is "sub deref { '.' }"

       formatter_path
           Deprecated, see HTML::Template::Compiled::Formatter please.

       compile_early
           Define  if every included file should be checked and parsed at compile time of the including template
           or later when it is really used.

           Default is "sub compile_early { 1 }"

       parser_class
           Default is "sub parser_class { 'HTML::Template::Compiled::Parser' }"

           You can write your own parser class (which must inherit  from  HTML::Template::Compiled::Parser)  and
           use this.

           HTML::Template::Compiled::Lazy uses this.

   <b>DEBUGGING</b>
       For printing out the contents of all the parameters you can do:

         &lt;TMPL_LOOP ALBUMS&gt;
         Dump: &lt;TMPL_VAR _ ESCAPE=DUMP|HTML&gt;
         &lt;/TMPL_LOOP&gt;

       The  special  name  "_"  gives  you  the  current  parameter and "ESCAPE=DUMP" will by default generate a
       Data::Dumper output of the current variable, in this case it will dump out the contents of every album in
       a loop. To correctly display that in html "|HTML" will escape html entities.

   <b>TMPL_WITH</b>
       If you have a deep leveled hash you might not want to always  write  THE.FULL.PATH.TO.YOUR.VAR.  Jump  to
       your desired level once and then you need only one level. Compare:

         &lt;TMPL_WITH DEEP.PATH.TO.HASH&gt;
         &lt;TMPL_VAR NAME&gt;: &lt;TMPL_VAR AGE&gt;
         &lt;/TMPL_WITH&gt;

         &lt;TMPL_VAR DEEP.PATH.TO.HASH.NAME&gt;: &lt;TMPL_VAR DEEP.PATH.TO.HASH.AGE&gt;

       Inside TMPL_WITH you can't reference parent nodes unless you're using global_vars.

   <b>TMPL_LOOP</b>
       The special name "_" gives you the current parameter. In loops you can use it like this:

        &lt;tmpl_loop foo&gt;
         Current item: &lt;tmpl_var _ &gt;
        &lt;/tmpl_loop&gt;

       Also you can give the current item an alias. See "ALIAS".

       The LOOP tag allows you to define a JOIN attribute:

        &lt;tmpl_loop favourite_colors join=", "&gt;
         &lt;tmpl_var _ &gt;
        &lt;/tmpl_loop&gt;

       This will output something like "blue, pink, yellow".  This is easier than doing:

        &lt;tmpl_loop favourite_colors&gt;
        &lt;tmpl_unless __first__&gt;, &lt;/tmpl_unless&gt;
         &lt;tmpl_var _ &gt;
        &lt;/tmpl_loop&gt;

       The "LOOP", "WHILE" and "EACH" tags allow you to define a BREAK attribute:

        &lt;tmpl_loop bingo break="3"&gt; &lt;tmpl_var _ &gt;&lt;if __break__&gt;\n&lt;/if&gt;&lt;/tmpl_loop&gt;

           $htc-&gt;param(bingo =&gt; [qw(X 0 _ _ X 0 _ _ X)]);

       outputs

           X 0 _
           _ X 0
           _ _ X

       So specifying BREAK=3 sets __break__ to 1 every 3rd loop iteration.

       TMPL_LOOP  expects an array reference, also if it is a method call. If you want to iterate with TMPL_LOOP
       over a list from a method call, set the attribute "context=list":

           &lt;tmpl_loop object.list_method context=list&gt;
               &lt;tmpl_var _ &gt;
           &lt;/tmpl_loop&gt;

   <b>TMPL_WHILE</b>
       Useful for iterating, for example over database resultsets.  The directive

         &lt;tmpl_while resultset.fetchrow&gt;
           &lt;tmpl_var _.0&gt;
         &lt;/tmpl_while&gt;

       will work like:
         while (my $row = $resultset-&gt;fetchrow) {
           print $row-&gt;[0];
         }

       So the special variable name _ is set to the current item returned by the iterator.

       You also can use "ALIAS" here.

   <b>TMPL_EACH</b>
       Iterating over a hash. Internally it is not implemented as an each, so you can also sort the output:

           Sorted alphanumerically by default (since 0.93):
               &lt;tmpl_each letters &gt;
                   &lt;tmpl_var __key__ &gt;:&lt;tmpl_var __value__&gt;
               &lt;/tmpl_each letters &gt;
           Sorted numerically:
               &lt;tmpl_each numbers sort=num &gt;
                   &lt;tmpl_var __key__ &gt;:&lt;tmpl_var __value__&gt;
               &lt;/tmpl_each numbers &gt;
           Not sorted:
               &lt;tmpl_each numbers sort=0 &gt;
                   &lt;tmpl_var __key__ &gt;:&lt;tmpl_var __value__&gt;
               &lt;/tmpl_each numbers &gt;
           Sorted alphanumerically:
               &lt;tmpl_each letters sort=alpha &gt;
                   &lt;tmpl_var __key__ &gt;:&lt;tmpl_var __value__&gt;
               &lt;/tmpl_each letters &gt;

       You have to set the option "loop_context_vars" to true to use the special vars "__key__" and "__value__".

       If you want to iterate over a hash instead of a hashref (some methods might return plain  hashes  instead
       of references and TMPL_EACH expects a ref), then you can set "context=list":

           &lt;tmpl_each object.hash_method context=list&gt;
           &lt;tmpl_var __key__ &gt;
           &lt;/tmpl_each&gt;

       Since  1.000_001  you can also define by which variable you want to sort.  If you have a hash with hashes
       as values:

           $htc-&gt;param(
               letters =&gt; {
                   1 =&gt; { letter =&gt;'b' },
                   2 =&gt; { letter =&gt;'a' },
                   3 =&gt; { letter =&gt;'c' },
               },
           );
           &lt;%each letters sort=alpha sortby="letter" %&gt;
           &lt;%set_var val value=__value__ %&gt;
           &lt;%= __key__ %&gt; = &lt;%= $val.letter %&gt;
           &lt;%/each%&gt;

   <b>SET_VAR</b>
       Since 0.96_002

       Sets a local variable to the value given in "value" or "expr"

           &lt;tmpl_set foo expr=23&gt;
           &lt;tmpl_set name=bar expr=23&gt;
           &lt;tmpl_set boo value=var.boo&gt;
           &lt;tmpl_set oof expr="21*2"&gt;
           &lt;tmpl_var $foo&gt;
           &lt;tmpl_var $bar&gt;
           ...

       "value=.." behaves like a variable name from the parameter stash.  The variable name to  set  must  match
       /[0-9a-z_]+/i

       You  can  refer  to an alias via $alias or simply "alias". Note that the latter syntax is not recommended
       any more since it can conflict with parameters from the stash.

       If you want to use aliases in includes, you need to use the $alias syntax.

   <b>USE_VARS</b>
       deprecated. Was added in 0.96_004 to make it possible to use aliases set with "alias=..." or "SET_VAR" in
       includes. Now you should rather use the &lt;$alias&gt; syntax.

       The following explanation is just there for history and will be removed some time in the future. For  now
       it still works.

       Necessary  if you want vars like SET_VAR and loop aliases from outside in includes.  Before the first use
       in the include, add:

           &lt;tmpl_use_vars foo,bar,boo &gt;

       so that the compiler recognizes them as user defined vars  and  not  parameters  from  the  stash.   This
       statement  is  valid  until  the  end  of  the template so you cannot "overwrite" parameters of the stash
       locally.

   <b>WRAPPER</b>
       Since 0.97_005. Experimental. Please test.

       Needs option "loop_context_vars".

       Works similar to WRAPPER in Template-Toolkit.

       Is similar to TMPL_INCLUDE, just that the included wrapper is wrapped around the content. It can be  used
       to avoid including head and foot separately.

           &lt;tmpl_wrapper wrapper.html &gt;
           content: some var: &lt;tmpl_var foo &gt;
           &lt;/tmpl_wrapper&gt;

       In wrapper.html the special loop context var "__wrapper__" is used for the included content:

           wrapper.html:
           &lt;some&gt;&lt;layout&gt;
           &lt;tmpl_var __wrapped__ &gt;
           &lt;/layout&gt;&lt;/some&gt;

       Important notes:

       If  you  are  using  "out_fh"  to  print  directly to a filehandle instead of returning to a string, this
       feature might not be useful, since it is appending the content inside of the  wrapper  to  a  string  and
       prints  it when it comes to the end of the wrapper tag.  So if you are using "out_fh" to avoid generating
       long strings in memory, you should rather use TMPL_INCLUDE instead.

       Also you need perl 5.8 or higher to use it in combination with out_fh.

   <b>TMPL_COMMENT</b>
       For debugging purposes you can temporarily comment out regions:

         Wanted: &lt;tmpl_var wanted&gt;
           &lt;tmpl_comment outer&gt;
           this won't be printed
             &lt;tmpl_comment inner&gt;
               &lt;tmpl_var unwanted&gt;
             &lt;/tmpl_comment inner&gt;
             &lt;tmpl_var unwanted&gt;
         &lt;/tmpl_comment outer&gt;

         $htc-&gt;param(unwanted =&gt; "no thanks", wanted =&gt; "we want this");

       The output is (whitespaces stripped):

         Wanted: we want this

       HTC will ignore anything between COMMENT  directives.   This  is  useful  for  debugging,  and  also  for
       documentation inside the template which should not be outputted.

   <b>TMPL_NOPARSE</b>
       Anything between

         &lt;tmpl_noparse&gt;...&lt;/tmpl_noparse&gt;

       will  not be recognized as template directives. Same syntax as TMPL_COMMENT.  It will output the content,
       though.

   <b>TMPL_VERBATIM</b>
       Anything between

         &lt;tmpl_verbatim&gt;...&lt;/tmpl_verbatim&gt;

       will not be recognized as template directives. Same syntax  as  "TMPL_NOPARSE",  but  it  will  be  HTML-
       Escaped. This can be useful for debugging.

   <b>TMPL_SWITCH</b>
       The  SWITCH  directive has the same syntax as VAR, IF etc.  The CASE directive takes a simple string or a
       comma separated list of strings.  Yes, without quotes. This will probably change! I just don't  know  yet
       how it should look like. Suggestions?

       With that directive you can do simple string comparisons.

        &lt;tmpl_switch language&gt;(or &lt;tmpl_switch name=language&gt;)
         &lt;tmpl_case de&gt;echt cool
         &lt;tmpl_case en&gt;very cool
         &lt;tmpl_case es&gt;superculo
         &lt;tmpl_case fr,se&gt;don't speak french or swedish
         &lt;tmpl_case default&gt;sorry, no translation for cool in language &lt;%=language%&gt; available
         &lt;tmpl_case&gt;(same as default)
        &lt;/tmpl_switch&gt;

       It's also possible to specify the default with a list of other strings:

        &lt;tmpl_case fr,default&gt;

       Note that the default case should always be the last statement before the closing switch.

   <b>OPTIONS</b>
       As  you can cache the generated perl code in files, some of the options are fixed; that means for example
       if you set the  option  case_sensitive  to  0  and  the  next  time  you  call  the  same  template  with
       case_sensitive 1 then this will be ignored. The options below will be marked as (fixed).

       path
           Path to template files

       search_path_on_include
           Search the list of paths specified with "path" when including a template.  Default is 0

           See "DIFFERENT FEATURES" for the additional possible value 2.

       file_cache
           Set to 1 if you want to use file caching and specify the path with file_cache_dir.

       file_cache_dir
           Path to caching directory (you have to create it before)

       cache_dir
           Replaced by file_cache_dir like in HTML::Template. Will be deprecated in future versions.

       cache
           Is  1  by  default.  If set to 0, no memory caching is done. Only recommendable if you have a dynamic
           template content (with scalarref, arrayre for example).

       expire_time
           Recheck template files on disk after "expire_time" seconds. See "CACHING"

       filename
           Template to parse

       scalarref
           Reference to a scalar with your template content. It's possible to cache scalarrefs, too, if you have
           Digest::MD5 installed. Note that your cache directory  might  get  filled  with  files  from  earlier
           versions. Clean the cache regularly.

           Don't  cache  scalarrefs  if you have dynamic strings. Your memory might get filled up fast!  Use the
           option

             cache =&gt; 0

           to disable memory caching.

       arrayref
           Reference to array containing lines of the template content (newlines have to be included)

       filehandle
           Filehandle which contains the template content. Note that HTC will not cache templates  created  like
           this.

       loop_context_vars (fixed)
           Vars  like  "__first__", "__last__", "__inner__", "__odd__", "__counter__", "__index__", "__outer__",
           "__even__"

           The variable "__index__" works just like "__counter__", only that it starts at 0 instead of 1.

       global_vars (fixed)
           If set to 1, every outer variable can be accessed from anywhere in the enclosing scope.

           Default is 0.

           Note that I don't recommend using global_vars. For referring to parameters up in the  stash  you  can
           use aliases via "alias=..." or "SET_VAR".  See "ALIAS" and "SET_VAR".

           If you still would like to be able to navigate up the parameter stash, you have the following option:

           If  set  to  2,  you  don't  have global vars, but have the possibility to go up the stack one level.
           Example:

            &lt;tmpl_var ...key&gt;

           This will get you up 2 levels (remember: one dot means root in HTC) and access the 'key' element.

           If set to 3 ("3 == 1|2") you have both, global vars and explicitly going up the stack.

           So setting global_vars to 2 can save you from global vars but still allows you to browse through  the
           stack.

       default_escape
             my $htc = HTML::Template::Compiled-&gt;new(
               ...
               default_escape =&gt; 'HTML', # or URL
             );

           Now  everything  will  be  escaped for HTML unless you explicitly specify "ESCAPE=0" (no escaping) or
           "ESCAPE=URL".

       strict (since 0.97_001)
           Default: 1

           If set to 0 unknown tags will be ignored and output verbatim:

               &lt;TMPL_FOOBAR anything ... &lt;TMPL_VAR valid&gt;

       line_info (fixed) (since 1.000_004)
           Default: 0

             my $htc = HTML::Template::Compiled-&gt;new(
                 ...
                 line_info =&gt; 1, # default 0
             );

           If any runtime errors occur, line information will output the template filename and line (instead  of
           "eval" and the generated perl code line)

       warnings (fixed) (since 1.000_004)
           Default: 0

           If set to 1, runtime warnings (like use of uninitialized value) will be output to stderr.

           If set to 'fatal', any runtime warning will cause the script to die.

       no_includes (since 0.92)
           Default  is  0.  If  set to 1, the tags INCLUDE, INCLUDE_VAR and INCLUDE_STRING will cause a template
           syntax error when creating. This can be useful when opening untrusted templates, otherwise  any  file
           in the filesystem could be opened.

       debug_file (fixed) (since 0.91_001)
           Additionally to the context_vars __filename__ and __filenameshort__ you can enable filename debugging
           globally.

           If the option is set to 'start', at the start of every template will be added:
               &lt;!-- start templates/path/filename.html --&gt;

           If set to 'end', at the end will be added:
               &lt;!-- end templates/path/filename.html --&gt;

           If set to 'start,end', both comments will be added.

           If set to 'start,short', 'end,short' or 'start,end,short' the path to the templates will be stripped:
               &lt;!-- start path/filename.html --&gt;
               &lt;!-- end path/filename.html --&gt;

       optimize (fixed) (since 1.001_001)
           Hashref with compiler hints.

           Every  access  to  the  parameter  stash has to check if the current var is an object or a hash. This
           allows you to use the same notation for hash accesses and method calls without caring about the data.
           But this is quite expensive. You can give the compiler hints:

               HTML::Template::Compiled-&gt;new(
                   optimize =&gt; {
                       initial_var  =&gt; 1, # defaults
                       object_check =&gt; 0,
                       root_hash    =&gt; 0,
                   },

           initial_var
               Default: 1

               Might become a default in the code itself and removed as an option. Report if you  have  problems
               and  set  it  to  0.   This is just a minor internal optimization for variable accesses like "[%=
               foo.bar.baz %]"

           object_check
               Default: 0

               If you are in a loop and make several accesses to the same var, it always  checks  if  it  is  an
               object or not:

                   [%loop threads %]
                   [%= id %]
                   [%= title %]
                   [%= ctime %]
                   ...
                   [%/loop threads %]

               If  you  set  this  to true, the check will be done at the beginning of the loop and saved into a
               variable, so that  subsequent  accesses  only  use  the  check  variable.   Same  for  TMPL_WITH,
               TMPL_WHILE.

               If  you only have one access in a loop, this might be unnecessary overhead.  Also, theoretically,
               a variable can change during calls.

               In the most cases this option should be fine. I will set the default to 1 someday probably.

           root_hash
               It is possible to pass an object to <b>param()</b> instead of a hash.  So even every access to the  root
               of  the  parameter  stash  has  to  check if it is an object or a hashref.  In the most cases the
               parameter stash is a hashref. If you are sure that you always have a parameter hash and  activate
               this option, the compiler can avoid this check.

       objects (fixed) (since 0.91_001)
           if set to true, you can use method calls like
               &lt;%= object.method %&gt;

           Default  is  'strict'  (true).   If  set to 'strict', the method will be called if we have an object,
           otherwise it's treated as a hash lookup. If the method doesn't exist, it dies.  If set to 'nostrict',
           the method will be called only if the object 'can' do the method,  otherwise  it  will  return  undef
           (this will need Scalar::Util).  If set to 0, no method calls are allowed.

       deref (fixed)
           Deprecated. Please inherit and overwrite method 'deref'. See "INHERITANCE"

           Define the string you want to use for dereferencing, default is "." at the moment:

            &lt;TMPL_VAR hash.key&gt;

       method_call (fixed)
           Deprecated. Please inherit and overwrite method 'method_call'. See "INHERITANCE"

           Define the string you want to use for method calls, default is . at the moment:

            &lt;TMPL_VAR object.method&gt;

           Don't  use  -&gt;,  though,  like you could in earlier version. Var names can contain: Numbers, letters,
           '.', '/', '+', '-' and '_', just like HTML::Template. Note that  if  your  var  names  contain  dots,
           though,   they   will   be   treated   as   hash   dereferences.   If  you  want  literal  dots,  use
           HTML::Template::Compiled::Classic instead.

       default_path (fixed)
           Deprecated, see HTML::Template::Compiled::Formatter please.

             my $htc = HTML::Template::Compiled-&gt;new(
               ...
               default_path
                    # default is PATH_DEREF
                 =&gt; HTML::Template::Compiled::Utils::PATH_FORMATTER,
             );

           Is needed if you have an unqualified tmpl_var that should be resolved as a call  to  your  formatter,
           for  example. Otherwise you have to call it fully qualified. If your formatter_path is '/', you'd say
           tmpl_var "_/method".  With the option default_path you can make that the default, so you  don't  need
           the "_/": "tmpl_var method". If you don't use formatters, don't care about this option.

       line_numbers
           NOTE: This option does not exist any more; line numbers will always be reported.

           For  debugging:  prints  the  line number of the wrong tag, e.g. if you have a /TMPL_IF that does not
           have an opening tag.

       case_sensitive (fixed)
           default is 1, set it to 0 to use this feature like in HTML::Template. Note that this  can  slow  down
           your program a lot (50%).

       dumper
           This   option  is  deprecated  as  of  version  0.76.  You  must  now  use  a  plugin  instead,  like
           HTML::Template::Compiled::Plugin::DHTML, for example.

             my $t = HTML::Template::Compiled-&gt;new(
               ...
               dumper = sub { my_cool_dumper($_[0]) },
             );
             ---
             &lt;TMPL_VAR var ESCAPE=DUMP&gt;

           This will call "my_cool_dumper()" on "var".

           Alternatively  you   can   use   the   DHTML   plugin   which   is   using   "Data::TreeDumper"   and
           "Data::TreeDumper::Renderer::DHTML".  You'll  get  a   dumper  like output which you can collapse and
           expand, for example. See Data::TreeDumper and Data::TreeDumper::Renderer::DHTML for more information.
           Example:

             my $t = HTML::Template::Compiled-&gt;new(
               ...
               dumper = 'DHTML',
             );

           For an example see "examples/dhtml.html".

       out_fh (fixed)
             my $t = HTML::Template::Compiled-&gt;new(
               ...
               out_fh =&gt; 1,
             );
             ...
             $t-&gt;output($fh); # or output(\*STDOUT) or even output()

           This option is fixed, so if you create a template with "out_fh", every output of this  template  will
           print to a specified (or default "STDOUT") filehandle.

       filter
           Filter template code before parsing.

             my $t = HTML::Template::Compiled-&gt;new(
               ...
               filter =&gt; sub { myfilter( ${$_[0]} ) },
               # or
               filter =&gt; [ {
                   sub =&gt; sub { myfilter( ${$_[0]} ) },
                   format =&gt; 'scalar', # or array
                 },
                 ...
               ],
             );

       tagstyle (fixed)
           Specify  which  styles you want to use. This option takes an arrayref with strings of named tagstyles
           or your own regexes.

           At the moment there are the following named tagstyles builtin:

               # classic (active by default)
               &lt;TMPL_IF foo&gt;&lt;tmpl_var bar&gt;&lt;/TMPL_IF&gt;

               # comment (active by default)
               &lt;!-- TMPL_IF foo --&gt;&lt;!-- TMPL_VAR bar --&gt;&lt;!-- /TMPL_IF --&gt;

               # asp (active by default)
               &lt;%if foo%&gt;&lt;%VAR bar%&gt;&lt;%/if%&gt;

               # php (not active by default)
               &lt;?if foo?&gt;&lt;?var bar?&gt;&lt;?/if foo?&gt;

               # tt (not active by default)
               [%if foo%][%var bar%][%/if foo%]

           You deactivate a style by saying -stylename. You activate by saying +stylename.

           Define your own tagstyle by specifying regexes.  For  example  you  want  to  use  {"{{if  foo}}{{var
           bar}}{{/if foo}}", then your definition should be:

               [
                   qr({{), # start of opening tag
                   qr(}}), # end of opening tag
                   qr({{/), # start of closing tag
                   qr(}}), # end of closing tag
               ]

           NOTE: do not specify capturing parentheses in you regexes. If you need parentheses, use "(?:foo|bar)"
           instead of "(foo|bar)".

           Say  you want to deactivate asp-style, comment-style, activate php- and tt-style and your own "{{}} "
           style, then say:

               my $htc = HTML::Template::Compiled-&gt;new(
                   ...
                   tagstyle =&gt; [
                       qw(-asp -comment +php +tt),
                       [ qr({{), qr(}}), qr({{/), qr(}})],
                   ],
               );

       use_expressions (since 0.91_003)
           Set to 1 if you  want  to  use  expressions.  The  basic  expressions  work  more  or  less  like  in
           HTML::Template::Expr  -  I took the parsing code from it and used it with some minor changes - thanks
           to Sam Tregar.

               &lt;%if expr="some.var &gt; 3" %&gt;It's grater than 3&lt;%/if %&gt;

           But with expressions you can also use more complex navigation through the template stash:

           You can use object methods with parameters. While a normal method call can  only  be  called  without
           parameters, like

               &lt;%= object.name %&gt;

           with expressions you can give it parameters:

               &lt;%= expr="object.create_link('navi')" %&gt;

           Inside  function  and  method calls, hash keys you also can use template vars (array indices and hash
           keys since 0.96_003).

               &lt;%= expr=".path.to.hash{var}" %&gt;
               &lt;%= expr=".path.to.hash{.another.var[123]}{'literal key'}" %&gt;

           It is only minimally tested yet, so use with care and please report any bugs you find.

           A useful example: Output a number of items with their prices formatted.

               my $nf = Number::Format-&gt;new(...);
               my $htc = HTML::Template::Compiled-&gt;new(
                   filename =&gt; 'items.html',
                   use_expressions =&gt; 1,
               );
               $htc-&gt;param(
                   items =&gt; [
                       { size =&gt;  50 * 1024 * 1024 * 1024, price =&gt; 49.95 },
                       { size =&gt; 250 * 1024 * 1024 * 1024, price =&gt; 110.99 },
                   ],
                   nf =&gt; $nf,
               );

           items.html:

               &lt;%loop .items %&gt;
               Size: &lt;%= expr=".nf.format_bytes(size)" %&gt;
               Price: &lt;%= expr=".nf.format_price(price)" %&gt;
               &lt;%/loop %&gt;

           Output:
               Size: 50G
               Price: 49,95 EUR

               Size: 250G
               Price: 110,99 EUR

       formatter
           Deprecated, see HTML::Template::Compiled::Formatter please.

           With formatter you can specify how an object should be rendered. This is useful  if  you  don't  want
           object methods to be called, but only a given subset of methods.

             my $htc = HTML::Template::Compiled-&gt;new(
             ...
             formatter =&gt; {
               'Your::Class' =&gt; {
                 fullname =&gt; sub {
                   $_[0]-&gt;first . ' ' . $_[0]-&gt;last
                 },
                 first =&gt; Your::Class-&gt;can('first'),
                 last =&gt; Your::Class-&gt;can('last'),
                 },
               },
             );
             # $obj is a Your::Class object
             $htc-&gt;param(obj =&gt; $obj);
             # Template:
             # Fullname: &lt;tmpl_var obj/fullname&gt;

       formatter_path (fixed)
           Deprecated, see HTML::Template::Compiled::Formatter please.

       debug
           If set to 1 you will get the generated perl code on standard error

       use_query
           Set it to 1 if you plan to use the <b>query()</b> method. Default is 0.

           Explanation:  If  you want to use <b>query()</b> to collect information on the template HTC has to do extra-
           work while compiling and uses extra-memory, so you can choose to save HTC work by  setting  use_query
           to  0  (default)  or  letting HTC do the extra work by setting it to 1. If you would like 1 to be the
           default, write me. If enough people write me, I'll think about it =)

       use_perl
           Set to 1 if you want to use the perl-tag. See "TMPL_PERL". Default is 0.

       cache_debug
           Default: 0

           You can debug hits and misses for file cache and memory cache:

               # debug all cache
               my $htc = HTML::Template::Compiled-&gt;new(
                   cache_debug =&gt; 1,
                   ...
               );
               # only debug misses
               my $htc = HTML::Template::Compiled-&gt;new(
                   cache_debug =&gt; [qw/ file_miss mem_miss /],
                   ...
               );

           Possible values when passing an array ref: file_miss file_hit mem_miss mem_hit

           Output looks similar to HTML::Template cache_debug and will be output to STDERR via <b>warn()</b>.

   <b>METHODS</b>
       clear_cache ([DIR])
           Class method. It will clear the memory cache either of a specified cache directory:

             HTML::Template::Compiled-&gt;clear_cache($cache_dir);

           or all memory caches:

             HTML::Template::Compiled-&gt;clear_cache();

       clear_filecache
           Class- or object-method. Removes all generated perl files from a given directory.

             # clear a directory
             HTML::Template::Compiled-&gt;clear_filecache('cache_directory');
             # clear this template's cache directory (and not one template file only!)
             $htc-&gt;clear_filecache();

       param
           Works like in HTML::Template.

       query
           Works like in HTML::Template. But it is not activated by default. If you want to use it, specify  the
           use_query option.

       preload
           Class  method. Will preload all template files from a given cachedir into memory. Should be done, for
           example in a mod_perl environment, at server startup, so all templates go into "shared memory"

             HTML::Template::Compiled-&gt;preload($cache_dir);

           If you don't do preloading in mod_perl, memory usage might go up if you have a lot of templates.

           Note: the directory is *not* the template directory. It should be the directory which you give as the
           file_cache_dir option.

       precompile
           Class method. It will precompile a list of template files into the  specified  cache  directory.  See
           "PRECOMPILE".

       clear_params
           Empty all parameters.

       debug_code (since 0.91_003)
           If  you  get an error from the generated template, you might want to debug the executed code. You can
           now call "debug_code" to get the compiled code and  the  line  the  error  occurred.  Note  that  the
           reported  line  might not be the exact line where the error occurred, also look around the line.  The
           template filename reported does currently only report the main template, not the name of an  included
           template. I'll try to fix that.

               local $HTML::Template::Compiled::DEBUG = 1;
               my $htc = HTML::Template::Compiled-&gt;new(
                   filename =&gt; 'some_file_with_runtime_error.html',
               );
               eval {
                   print $htc-&gt;output;
               };
               if ($@) {
                   # reports as text
                   my $msg = $htc-&gt;debug_code;
                   # reports as a html table
                   my $msg_html = $htc-&gt;debug_code('html');
               }

       get_plugin
               my $plugin = $htc-&gt;get_plugin('Name::of::plugin');

           Returns  the  plugin object of that classname. If the plugin is only a string (the classname itself),
           it returns this string, so this method is only useful for plugin objects.

       var2expression
           Useful for plugins. Parses a template var ("name="foo.bar.baz"" and returns the perl  expression  for
           the compiler.

</pre><h4><b>EXPORT</b></h4><pre>
       None.

</pre><h4><b>CACHING</b></h4><pre>
       You create a template almost like in HTML::Template:

         my $t = HTML::Template::Compiled-&gt;new(
           path                =&gt; 'templates',
           loop_context_vars   =&gt; 1,
           filename            =&gt; 'test.html',
           # for testing without cache comment out
           file_cache          =&gt; 1,
           file_cache_dir      =&gt; "cache",
         );

       The  next  time  you  start  your application and create a new template, HTC will read all generated perl
       files, and a call to the constructor like above won't parse the template, but just use the  loaded  code.
       If your template file has changed, though, then it will be parsed again.

       You can set the expire time of a template by passing the option

           expire_time =&gt; $seconds

       Note that

           HTML::Template::Compiled-&gt;ExpireTime($seconds);
           C&lt;$HTML::Template::Compiled::NEW_CHECK&gt;

       are  deprecated  since  they  change  a global variable which is then visible in the whole process, so in
       persistent environments other apps might be affected.

       So an expire time of 600 seconds (default) will check after 10 minutes if the tmpl file was modified. Set
       it to a very high value will then  ignore  any  changes,  until  you  delete  the  generated  code.   For
       development  you  should  set  it  to  0,  for  a pre-production server you can set it to 60 seconds, for
       example. It can make quite a difference.

</pre><h4><b>PLUGINS</b></h4><pre>
       At   the   moment   you   can   use   and   write   plugins   for    the    "ESCAPE"    attribute.    See
       HTML::Template::Compiled::Plugin::XMLEscape  for  an example how to use it; and have a look at the source
       code if you want to know how to write a plugin yourself.

       Using Plugins:

           my $htc = HTML::Template::Compiled-&gt;new(
               ...
               plugin =&gt; ['HTML::Template::Compiled::Foo::Bar'],
               # oor shorter:
               plugin =&gt; ['::Foo::Bar'],
           );

</pre><h4><b>LAZY</b> <b>LOADING</b></h4><pre>
       Let's say you're in a CGI environment and have a lot of includes in your template, but only few  of  them
       are  actually  used. HTML::Template::Compiled will (as HTML::Template does) parse all of your includes at
       once.   Just  like  the  "use"  function  does  in  perl.  To  get  a   behaviour   like   require,   use
       HTML::Template::Compiled::Lazy.

</pre><h4><b>TODO</b></h4><pre>
       associate, methods with simple parameters, expressions, pluggable, ...

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       HTC generates a perl subroutine out of every template. Each included template is a subroutine for itself.
       You  can look at the generated code by activating file caching and looking into the cache directory. When
       you call "output()", the subroutine is called. The subroutine either  creates  a  string  and  adds  each
       template text or the results of the tags to the string, or it prints it directly to a filehandle. Because
       of the implementation you have to know at creation time of the module if you want to get a string back or
       if you want to print to a filehandle.

</pre><h4><b>SECURITY</b></h4><pre>
       HTML::Template::Compiled  uses  basically  the same file caching model as, for example, Template- Toolkit
       does: The compiled Perl code is written to disk and later reread via "do" or  by  reading  the  file  and
       "eval" the content.

       If  you  are  sharing  a  read/write  environment  with  untrusted users (for example on a machine with a
       webserver, like many webhosters offer, and all scripts are running as the same httpd user), realize  that
       there is possibility of modifying the Perl code that is cached and then executed. The best solution is to
       not be in such an environment!

       In  this case it is the safest option to generate your compiled templates on a local machine and just put
       the compiled templates onto the server, with no write access for the http server.  Set the  "expire_time"
       option to a high value so that HTC never attempts to check the template timestamp to force a regenerating
       of the code.

       If  you  are  alone  on  the machine, but you are running under taint mode (see perlsec) then you have to
       explicitly set the $UNTAINT variable to 1. HTC will then untaint the code for you and treat it as  if  it
       were safe (it hopefully is =).

</pre><h4><b>PRECOMPILE</b></h4><pre>
       I  think  there  is  no way to provide an easy function for precompiling, because every template can have
       different options.  If you have all your templates with the same options, then you can use the precompile
       class method.  It works like this:

         HTML::Template::Compiled-&gt;precompile(
           # usual options like path, default_escape, global_vars, file_cache_dir, ...
           filenames =&gt; [ list of template-filenames ],
         );

       This will then pre-compile all templates into file_cache_dir. Now you would just put this directory  onto
       the  server,  and it doesn't need any write-permissions, as it will be never changed (until you update it
       because templates have changed).

</pre><h4><b>BENCHMARKS</b></h4><pre>
       The options "case_sensitive", "loop_context_vars" and "global_vars" can have  the  biggest  influence  on
       speed.

       Setting case_sensitive to 1, loop_context_vars to 0 and global_vars to 0 saves time.

       On  the  other  hand,  compared  to HTML::Template, you have a large speed gain under mod_perl if you use
       case_sensitive = 1, loop_context_vars = 0, With CGI HTC is slower.

       See the "examples/bench.pl" contained in this distribution.

       Here are some examples from the benchmark script. I'm showing only Template::AutoFilter,  Template::HTML,
       HTML::Template  and  HTC.  These four modules allow you to set automatic HTML escaping ('filter') for all
       variables.

        loop_context_vars 1
        global_vars 0
        case_sensitive 1
        default_escape HTML (respectively Template::AutoFilter and Template::HTML)

        ht: HTML::Template 2.10
        htc: HTML::Template::Compiled 0.95
        ttaf: Template::AutoFilter 0.112350 with Template 2.22
        tth: Template::HTML 0.02 with Template 2.22

       First test is with the test.(htc|tt) from the examples directory, about 900 bytes.

       Test without file cache and without memory cache.

                     all_ht:  1 wallclock secs ( 0.40 usr +  0.00 sys =  0.40 CPU) @ 250.00/s (n=100)
                    all_htc:  1 wallclock secs ( 1.74 usr +  0.01 sys =  1.75 CPU) @ 57.14/s (n=100)
        all_ttaf_new_object:  1 wallclock secs ( 1.69 usr +  0.01 sys =  1.70 CPU) @ 58.82/s (n=100)
         all_tth_new_object:  1 wallclock secs ( 1.44 usr +  0.00 sys =  1.44 CPU) @ 69.44/s (n=100)

       With file cache:

                     all_ht:  1 wallclock secs ( 1.03 usr +  0.01 sys =  1.04 CPU) @ 379.81/s (n=395)
                    all_htc:  1 wallclock secs ( 1.07 usr +  0.00 sys =  1.07 CPU) @ 260.75/s (n=279)
        all_ttaf_new_object:  1 wallclock secs ( 1.07 usr +  0.04 sys =  1.11 CPU) @ 251.35/s (n=279)
         all_tth_new_object:  1 wallclock secs ( 1.01 usr +  0.04 sys =  1.05 CPU) @ 227.62/s (n=239)

       With memory cache:

              all_ht:  1 wallclock secs ( 1.04 usr +  0.00 sys =  1.04 CPU) @ 461.54/s (n=480)
             all_htc:  1 wallclock secs ( 1.05 usr +  0.01 sys =  1.06 CPU) @ 3168.87/s (n=3359)
        process_ttaf:  1 wallclock secs ( 1.04 usr +  0.00 sys =  1.04 CPU) @ 679.81/s (n=707)
         process_tth:  1 wallclock secs ( 1.05 usr +  0.00 sys =  1.05 CPU) @ 609.52/s (n=640)

       Now I'm using a template with about 18Kb by multiplying the example template 20 times. You can  see  that
       everything is running slower but some run more slower than others.

       Test without file cache and without memory cache.

                     all_ht:  8 wallclock secs ( 7.57 usr +  0.04 sys =  7.61 CPU) @ 13.14/s (n=100)
                    all_htc: 32 wallclock secs (32.08 usr +  0.06 sys = 32.14 CPU) @  3.11/s (n=100)
        all_ttaf_new_object: 36 wallclock secs (36.21 usr +  0.04 sys = 36.25 CPU) @  2.76/s (n=100)
         all_tth_new_object: 29 wallclock secs (28.92 usr +  0.05 sys = 28.97 CPU) @  3.45/s (n=100)

       With file cache:

                     all_ht:  8 wallclock secs ( 7.22 usr +  0.00 sys =  7.22 CPU) @ 13.85/s (n=100)
                    all_htc:  5 wallclock secs ( 5.32 usr +  0.00 sys =  5.32 CPU) @ 18.80/s (n=100)
        all_ttaf_new_object:  8 wallclock secs ( 7.59 usr +  0.15 sys =  7.74 CPU) @ 12.92/s (n=100)
         all_tth_new_object:  9 wallclock secs ( 8.74 usr +  0.19 sys =  8.93 CPU) @ 11.20/s (n=100)

       With memory cache:

              all_ht:  1 wallclock secs ( 1.04 usr +  0.01 sys =  1.05 CPU) @ 15.24/s (n=16)
             all_htc:  1 wallclock secs ( 1.12 usr +  0.00 sys =  1.12 CPU) @ 272.32/s (n=305)
        process_ttaf:  1 wallclock secs ( 1.07 usr +  0.00 sys =  1.07 CPU) @ 39.25/s (n=42)
         process_tth:  1 wallclock secs ( 1.05 usr +  0.00 sys =  1.05 CPU) @ 34.29/s (n=36)

       So the performance difference highly depends on the size of the template and on the various options.  You
       can  see  that using the 900byte template HTC is slower with file cache than HTML::Template, but with the
       18Kb template it's faster.

</pre><h4><b>EXAMPLES</b></h4><pre>
       See "objects.html" in examples (and "examples/objects.pl") for an example how to feed objects to HTC.

</pre><h4><b>BUGS</b></h4><pre>
       Probably many bugs I don't know yet =)

       Use         the          bugtracking          system          to          report          a          bug:
       <a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=HTML-Template-Compiled

</pre><h4><b>Why</b> <b>another</b> <b>Template</b> <b>System?</b></h4><pre>
       You  might  ask  why  I  implement yet another templating system. There are so many to choose from. Well,
       there are several reasons.

       I like the syntax of HTML::Template *because* it is very restricted.  It's also  easy  to  use  (template
       syntax and API).  However, there are some things I miss I try to implement here.

       I think while HTML::Template is quite good, the implementation can be made more efficient (and still pure
       Perl). That's what I'm trying to achieve.

       I  use  it  in my web applications, so I first write it for myself =) If I can efficiently use it, it was
       worth it.

</pre><h4><b>RESOURCES</b></h4><pre>
       See <a href="http://htcompiled.sf.net/">http://htcompiled.sf.net/</a> for svn access.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       HTML::Template

       HTML::Template::JIT

       Template - Toolkit

       <a href="http://www.tinita.de/projects/perl/">http://www.tinita.de/projects/perl/</a>

</pre><h4><b>AUTHOR</b></h4><pre>
       Tina Mueller

</pre><h4><b>CREDITS</b></h4><pre>
       Sam Tregar big thanks for ideas and letting me use his HTML::Template test suite

       Bjoern Kriews for original idea and contributions

       Special Thanks to Sascha Kiefer - he finds all the bugs!

       Ronnie Neumann, Martin Fabiani, Kai Sengpiel,  Jan  Willamowius,  Justin  Day,  Steffen  Winkler,  Henrik
       Tougaard for ideas, beta-testing and patches

       &lt;<a href="http://www.perlmonks.org/">http://www.perlmonks.org/</a>&gt; and <a href="http://www.perl-community.de/">http://www.perl-community.de/</a>&gt; for everyday learning

       Corion, Limbic~Region, tye, runrig and others from perlmonks.org

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2005-2012 by Tina Mueller

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself, either Perl version 5.8.3 or, at your option, any later version of Perl 5 you may have available.

perl v5.36.0                                       2022-11-19                      <u>HTML::Template::<a href="../man3pm/Compiled.3pm.html">Compiled</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>