<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log::Report::Extract::Template - collect translatable strings from template files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblog-report-lexicon-perl">liblog-report-lexicon-perl_1.12-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Log::Report::Extract::Template - collect translatable strings from template files

</pre><h4><b>INHERITANCE</b></h4><pre>
        Log::Report::Extract::Template
          is a Log::Report::Extract

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # First use of this module: extract msgids from various kinds
        # of text-files, usually web templates.
        # See script "xgettext-perl" for standard wrapper script

        my $extr = Log::Report::Extract::Template-&gt;new
          ( lexicon =&gt; '<a href="file:/usr/share/locale">/usr/share/locale</a>'
          , domain  =&gt; 'my-web-site'
          , pattern =&gt; 'TT2-loc'
          );
        $extr-&gt;process('website/page.html');  # many times
        $extr-&gt;showStats;
        $extr-&gt;write;

        # Second use: connect to Template::Toolkit
        # See DETAILS chapter below

        [% loc("Greetings {name},", name =&gt; client.name) %]
        [% | loc(name =&gt; client.name) %]Greetings {name}[% END %]
        [% 'Greetings {name}' | loc(name =&gt; client.name) %]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module helps maintaining the POT files which list translatable strings from template files (or other
       flat text files) by updating the list of message-ids which are kept in them.

       After initiation, the <b>process()</b> method needs to be called for each file in the domain  and the existing
       PO files will get updated accordingly.

       If no translations exist yet, one "$textdomain.po" file will be created as point to start.  Copy that
       file into "$textdomain/$lang.po"

       Extends "DESCRIPTION" in Log::Report::Extract.

</pre><h4><b>METHODS</b></h4><pre>
       Extends "METHODS" in Log::Report::Extract.

   <b>Constructors</b>
       Extends "Constructors" in Log::Report::Extract.

       Log::Report::Extract::Template-&gt;<b>new</b>(%options)
            -Option --Defined in          --Default
             charset  Log::Report::Extract  'utf-8'
             domain                         &lt;required&gt;
             lexicon  Log::Report::Extract  &lt;required&gt;
             pattern                        &lt;undef&gt;

           charset =&gt; STRING
           domain =&gt; DOMAIN
             There  is  no  syntax  for specifying domains in templates (yet), so you must be explicit about the
             collection we are making now.

           lexicon =&gt; DIRECTORY
           pattern =&gt; PREDEFINED|CODE
             See the DETAILS section below for a detailed explenation.

   <b>Accessors</b>
       Extends "Accessors" in Log::Report::Extract.

       $obj-&gt;<b>addPot</b>($domain, $pot, %options)
           Inherited, see "Accessors" in Log::Report::Extract

       $obj-&gt;<b>charset</b>()
           Inherited, see "Accessors" in Log::Report::Extract

       $obj-&gt;<b>domain</b>()
       $obj-&gt;<b>domains</b>()
           Inherited, see "Accessors" in Log::Report::Extract

       $obj-&gt;<b>index</b>()
           Inherited, see "Accessors" in Log::Report::Extract

       $obj-&gt;<b>pattern</b>()
       $obj-&gt;<b>pots</b>($domain)
           Inherited, see "Accessors" in Log::Report::Extract

   <b>Processors</b>
       Extends "Processors" in Log::Report::Extract.

       $obj-&gt;<b>cleanup</b>(%options)
           Inherited, see "Processors" in Log::Report::Extract

       $obj-&gt;<b>process</b>($filename, %options)
           Update the domains mentioned in the $filename.  All textdomains defined in the file will get  updated
           automatically, but not written before all files where processed.

            -Option --Default
             charset  'utf-8'
             pattern  &lt;from new(pattern)&gt;

           charset =&gt; STRING
             The character encoding used in this template file.

           pattern =&gt; PREDEFINED|CODE
             Read the DETAILS section about this.

       $obj-&gt;<b>showStats</b>( [$domains] )
           Inherited, see "Processors" in Log::Report::Extract

       $obj-&gt;<b>store</b>( $domain, $filename, $linenr, $context, $msg, [$msg_plural] )
           Inherited, see "Processors" in Log::Report::Extract

       $obj-&gt;<b>write</b>( [$domain] )
           Inherited, see "Processors" in Log::Report::Extract

</pre><h4><b>DETAILS</b></h4><pre>
   <b>Scan</b> <b>Patterns</b>
       Various template systems use different conventions for denoting strings to be translated.

       <u>Predefined</u> <u>for</u> <u>Template-Toolkit</u>

       There  is  not  a single convention for translations in "Template-Toolkit" (see Template), so you need to
       specify which version TT you use and which function name you want to use.  In extreme cases, you may even
       build separate translation tables by simply providing using functions.

       For instance

          pattern =&gt; 'TT2-loc'

       will scan for

         [% loc("msgid", key =&gt; value, ...) %]
         [% loc('msgid', key =&gt; value, ...) %]
         [% loc("msgid|plural", count, key =&gt; value, ...) %]

         [% INCLUDE
              title = loc('something')
          %]

         [% | loc(n =&gt; name) %]hi {n}[% END %]
         [% 'hi {n}' | loc(n =&gt; name) %]

       For TT1, the brackets can either be '[%...%]' or '%%...%%'.  The function name is treated case-sensitive.
       Some people prefer 'l()' or 'L()'.

       The code needed

         # during initiation of the webserver, once in your script (before fork)
         my $lexicons   = 'some-directory-for-translation-tables';
         my $translator = Log::Report::Translator::POT-&gt;new(lexicons =&gt; $lexicons);
         my $domain     = textdomain $textdomain;
         $domain-&gt;configure(translator =&gt; $translator);

         # your standard template driver
         sub handler {
            ...
            my $vars      = { ...all kinds of values... };
            $vars-&gt;{loc}  = \&amp;translate;           # &lt;--- this is extra

            my $output    = '';
            my $templater = Template-&gt;new(...);
            $templater-&gt;process($template_fn, $vars, \$output);
            print $output;
         }

         # anywhere in the same file
         sub translate {
           my $textdomain = ...;   # your choice when running xgettext-perl
           my $lang       = ...;   # how do you figure that out?
           my $msg = Log::Report::Message-&gt;fromTemplateToolkit($textdomain, @_);
           $msg-&gt;toString($lang);
         }

       To generate the pod tables, run in the shell something like

         xgettext-perl -p $lexicons --template TT2-loc \
             --domain $textdomain  $templates_dir

       If you want to implement your own extractor --to avoid "xgettext-perl"-- you need to run  something  like
       this:

         my $extr = Log::Report::Extract::Template-&gt;new
           ( lexicon =&gt; $output
           , charset =&gt; 'utf-8'
           , domain  =&gt; $domain
           , pattern =&gt; 'TT2-loc'
           );
         $extr-&gt;process($_) for @filenames;
         $extr-&gt;write;

   <b>Use</b> <b>in</b> <b>combination</b> <b>with</b> <b>contexts</b>
       This  example  extends  the  previous  with  using  context  sensitive  translations,  as  implemented by
       Log::Report::Translator::Context.

       Let's say that the translation of some of the sentences on the  website  depend  on  the  gender  of  the
       addressed person.  An example of the use in a TT2 template:

         [% loc("{name&lt;gender} forgot his key", name =&gt; person.name) %]

       The  extraction  script <u>xgettext-perl</u> will expand this into two records in the PO file, respectively with
       msgctxt attribute 'gender=male' and 'gender=female'.

       When your PO-files are not generated by 'xgettext-perl', you do not need a separate domain  configuration
       file:

         $domain-&gt;configure
           ( context_rules =&gt; +{gender =&gt; ['male','female']}
           , translator    =&gt; $translator
           );

       When  your  PO-files  are  generated by 'xgettext-perl', you need to share the context-rules between that
       msgid extractor and your runtime code. That same file needs to be passed with the 'domain'  parameter  to
       the script.

         # add context_rules either explicit or via 'config' filename
         $domain-&gt;configure
           ( config     =&gt; 'my/own/$domain.conf'
           , translator =&gt; $translator
           );

       Now,  when  you  generate  the  pages, you need to set-up the right context.  In this case, we set-up the
       gender of the person who gets addressed.  (The name  'gender'  is  good  for  examples,  but  quite  non-
       descriptive.  Maybe 'user_gender' is more maintainable)

         $domain-&gt;setContext( +{gender =&gt; 'male'} );  # or ('gender=male')
         $domain-&gt;setContext( "gender=male" );        # same

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This  module  is  part of Log-Report-Lexicon distribution version 1.12, built on April 18, 2025. Website:
       <u><a href="http://perl.overmeer.net/CPAN/">http://perl.overmeer.net/CPAN/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2007-2025 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.1                                       2025-04-24                <u>Log::Report::Extract::<a href="../man3pm/Template.3pm.html">Template</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>