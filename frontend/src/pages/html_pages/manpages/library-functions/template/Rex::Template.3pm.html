<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rex::Template - simple template engine</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/rex">rex_1.16.0-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Rex::Template - simple template engine

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Rex::Template;

        my $template = Rex::Template-&gt;new;

        print $template-&gt;parse($content, \%template_vars);
        print $template-&gt;parse($content, @template_vars);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a simple template engine for configuration files. It is included mostly for backwards
       compatibility, and it is recommended to use Rex::Template::NG instead (for better control of chomping new
       lines, and better diagnostics if things go wrong).

   <b>SYNTAX</b>
       The following syntax is recognized:

       •   anything  between  "&lt;%"  and "%&gt;" markers are considered as a template directive, which is treated as
           Perl code

       •   if the opening marker is followed by an equal sign ("&lt;%=") or a plus sign ("&lt;%+"), then the directive
           is replaced with the value it evaluates to

       •   if the closing marker is prefixed with a minus sign ("-%&gt;"), then any trailing newlines  are  chomped
           for that directive

       The  built-in  template  support is intentionally kept basic and simple. For anything more sophisticated,
       please use your favorite template engine.

   <b>EXAMPLES</b>
       Plain text is unchanged:

        my $result = $template-&gt;parse( 'one two three', {} );

        # $result is 'one two three'

       Variable interpolation:

        my $result = template-&gt;parse( 'Hello, this is &lt;%= $::name %&gt;', { name =&gt; 'foo' } ); # original format
        my $result = template-&gt;parse( 'Hello, this is &lt;%+ $::name %&gt;', { name =&gt; 'foo' } ); # alternative format with + sign
        my $result = template-&gt;parse( 'Hello, this is &lt;%= $name %&gt;',   { name =&gt; 'foo' } ); # local variables
        my $result = template-&gt;parse( 'Hello, this is &lt;%= $name %&gt;',     name =&gt; 'foo'   ); # array of variables, instead of hashref

        # $result is 'Hello, this is foo' for all cases above

       Simple evaluation:

        my $result = $template-&gt;parse( '&lt;%= join("/", @{$elements} ) %&gt;', elements =&gt; [qw(one two three)] );
        # $result is 'one/two/three'

       Embedded code blocks:

        my $content = '&lt;% if ($logged_in) { %&gt;
        Logged in!
        &lt;% } else { %&gt;
        Logged out!
        &lt;% } %&gt;';

        my $result = $template-&gt;parse( $content, logged_in =&gt; 1 );

        # $result is "\nLogged in!\n"

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Not much, mainly due to the internal approach of the module.

       If there was a problem, it prints an "INFO" level <u>"syntax</u> <u>error</u> <u>at</u> <u>..."</u>, followed by a "WARN"  about  <u>"It</u>
       <u>seems</u>  <u>that</u>  <u>there</u> <u>was</u> <u>an</u> <u>error</u> <u>processing</u> <u>the</u> <u>template</u> <u>because</u> <u>the</u> <u>result</u> <u>is</u> <u>empty."</u>, and finally <u>"Error</u>
       <u>processing</u> <u>template</u> <u>at</u> <u>..."</u>.

       The beginning of the reported syntax error might give some clue where the error happened in the template,
       but that's it.

       Use Rex::Template::NG instead for better diagnostics.

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
       If $Rex::Template::BE_LOCAL is set to a true value, then local template variables are  supported  instead
       of  only global ones ($foo vs $::foo). The default value is 1 since Rex-0.41. It can be disabled with the
       no_local_template_vars feature flag.

       If $Rex::Template::DO_CHOMP is set to a true value, then any trailing new line character  resulting  from
       template directives are chomped. Defaults to 0.

       This module does not support any environment variables.

</pre><h4><b>EXPORTED</b> <b>FUNCTIONS</b></h4><pre>
   <b>parse($content,</b> <b>$variables)</b>
       Parse  $content  as  a template, using $variables hash reference to pass name-value pairs of variables to
       make them available for the template function.

       Alternatively, the variables may be passed as an array instead of a hash reference.

   <b>is_defined($variable,</b> <b>$default_value)</b>
       This function will check if $variable is defined.  If  yes,  it  will  return  the  value  of  $variable,
       otherwise it will return $default_value.

       You can use this function inside your templates, for example:

        ServerTokens &lt;%= is_defined( $::server_tokens, 'Prod' ) %&gt;

</pre><h4><b>DEPENDENCIES</b></h4><pre>
</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       It might not be able to chomp new line characters resulting from templates in every case.

       It can't report useful diagnostic messages upon errors.

       Use Rex::Template::NG instead.

perl v5.40.0                                       2025-02-06                                 <u>Rex::<a href="../man3pm/Template.3pm.html">Template</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>