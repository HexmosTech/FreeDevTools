<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>regsub - Perform substitutions based on regular expression pattern matching</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       regsub - Perform substitutions based on regular expression pattern matching

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>regsub</b> ?<u>switches</u>? <u>exp</u> <u>string</u> <u>subSpec</u> ?<u>varName</u>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  command matches the regular expression <u>exp</u> against <u>string</u>, and either copies <u>string</u> to the variable
       whose name is given by <u>varName</u> or returns <u>string</u> if <u>varName</u> is not present.  (Regular expression matching
       is described in the <b>re_syntax</b> reference page.)  If there is a match, then while copying <u>string</u> to <u>varName</u>
       (or to the result of this command if <u>varName</u> is not present) the portion of <u>string</u> that  matched  <u>exp</u>  is
       replaced  with  <u>subSpec</u>.  If <u>subSpec</u> contains a “&amp;” or “\0”, then it is replaced in the substitution with
       the portion of <u>string</u> that matched <u>exp</u>.  If <u>subSpec</u> contains a “\<u>n</u>”, where <u>n</u> is a digit between 1 and  9,
       then  it  is  replaced in the substitution with the portion of <u>string</u> that matched the <u>n</u>'th parenthesized
       subexpression of <u>exp</u>.  Additional backslashes may be used in <u>subSpec</u> to prevent special interpretation of
       “&amp;”, “\0”, “\<u>n</u>” and backslashes.  The use of backslashes in <u>subSpec</u> tends to interact badly with the  Tcl
       parser's  use  of  backslashes,  so  it  is  generally safest to enclose <u>subSpec</u> in braces if it includes
       backslashes.

       If the initial arguments to <b>regsub</b> start with <b>-</b>  then  they  are  treated  as  switches.   The  following
       switches are currently supported:

       <b>-all</b>   All  ranges  in  <u>string</u>  that  match <u>exp</u> are found and substitution is performed for each of these
              ranges.  Without this switch only the first matching range is found and substituted.  If  <b>-all</b>  is
              specified,  then  “&amp;”  and  “\<u>n</u>” sequences are handled for each substitution using the information
              from the corresponding match.

       <b>-command</b>
              Changes the handling of <u>subSpec</u> so that it is not treated as a template for a substitution  string 2
              and  the substrings “&amp;” and “\<u>n</u>” no longer have special meaning. Instead <u>subSpec</u> must be a command 2
              prefix, that is, a non-empty list.  The substring of  <u>string</u>  that  matches  <u>exp</u>,  and  then  each 2
              substring  that  matches  each  capturing sub-RE within <u>exp</u> are appended as additional elements to 2
              that list. (The items appended to the list are much like what <b>regexp</b> <b>-inline</b> would  return).   The 2
              completed  list  is  then  evaluated  as  a  Tcl  command,  and  the result of that command is the 2
              substitution string.  Any error or exception from command evaluation becomes an error or exception 2
              from the <b>regsub</b> command.                                                                           2

              If <b>-all</b> is not also given, the command callback will be invoked at most  once  (exactly  when  the 2
              regular  expression  matches).  If  <b>-all</b>  is  given, the command callback will be invoked for each 2
              matched location, in sequence.  The exact location indices that matched are not made available  to 2
              the script.                                                                                        2

              See <b>EXAMPLES</b> below for illustrative cases.                                                         2

       <b>-expanded</b>
              Enables  use  of the expanded regular expression syntax where whitespace and comments are ignored.
              This is the same as specifying the <b>(?x)</b> embedded option (see the <b>re_syntax</b> manual page).

       <b>-line</b>  Enables newline-sensitive matching.  By default, newline is a completely ordinary  character  with
              no  special  meaning.   With this flag, “[^” bracket expressions and “.”  never match newline, “^”
              matches an empty string after any newline in addition to its normal function, and “$”  matches  an
              empty  string  before  any newline in addition to its normal function.  This flag is equivalent to
              specifying both <b>-linestop</b> and <b>-lineanchor</b>, or the <b>(?n)</b> embedded option (see the  <b>re_syntax</b>  manual
              page).

       <b>-linestop</b>
              Changes  the behavior of “[^” bracket expressions and “.”  so that they stop at newlines.  This is
              the same as specifying the <b>(?p)</b> embedded option (see the <b>re_syntax</b> manual page).

       <b>-lineanchor</b>
              Changes the behavior of “^” and “$” (the “anchors”) so they match the beginning and end of a  line
              respectively.   This  is the same as specifying the <b>(?w)</b> embedded option (see the <b>re_syntax</b> manual
              page).

       <b>-nocase</b>
              Upper-case characters in <u>string</u> will be converted  to  lower-case  before  matching  against  <u>exp</u>;
              however, substitutions specified by <u>subSpec</u> use the original unconverted form of <u>string</u>.

       <b>-start</b> <u>index</u>
              Specifies  a  character  index offset into the string to start matching the regular expression at.
              The <u>index</u> value is interpreted in the same manner as the <u>index</u> argument  to  <b>string</b>  <b>index</b>.   When
              using this switch, “^” will not match the beginning of the line, and \A will still match the start
              of the string at <u>index</u>.  <u>index</u> will be constrained to the bounds of the input string.

       <b>--</b>     Marks  the  end  of  switches.   The argument following this one will be treated as <u>exp</u> even if it
              starts with a <b>-</b>.

       If <u>varName</u> is supplied, the command returns a count of the number of matching ranges that were found  and
       replaced,  otherwise  the  string  after  replacement  is  returned.  See the manual entry for <b>regexp</b> for
       details on the interpretation of regular expressions.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Replace (in the string in variable <u>string</u>) every instance of <b>foo</b> which is a word by itself with <b>bar</b>:

              <b>regsub</b> -all {\mfoo\M} $string bar string

       or (using the “basic regular expression” syntax):

              <b>regsub</b> -all {(?b)\&lt;foo\&gt;} $string bar string

       Insert double-quotes around the first instance of the word <b>interesting</b>, however it is capitalized.

              <b>regsub</b> -nocase {\yinteresting\y} $string {"&amp;"} string

       Convert all non-ASCII and Tcl-significant characters into \u escape sequences by using <b>regsub</b>  and  <b>subst</b>
       in combination:

              # This RE is just a character class for almost everything "bad"
              set RE {[][{};#\\\$ \r\t\u0080-\uffff]}

              # We will substitute with a fragment of Tcl script in brackets
              set substitution {[format \\\\u%04x [scan "\\&amp;" %c]]}

              # Now we apply the substitution to get a subst-string that
              # will perform the computational parts of the conversion. Note
              # that newline is handled specially through <b>string</b> <b>map</b> since
              # backslash-newline is a special sequence.
              set quoted [subst [string map {\n {\\u000a}} \
                      [<b>regsub</b> -all $RE $string $substitution]]]

       The  above  operation  can  be  done  using  <b>regsub</b> <b>-command</b> instead, which is often faster. (A full pre- 2
       computed <b>string</b> <b>map</b> would be faster still, but the cost of computing the  map  for  a  transformation  as 2
       complex as this can be quite large.)                                                                      2

              # This RE is just a character class for everything "bad"                                           2
              set RE {[][{};#\\\$\s\u0080-\uffff]}                                                               2

              # This encodes what the RE described above matches                                                 2
              proc encodeChar {ch} {                                                                             2
                  # newline is handled specially since backslash-newline is a                                    2
                  # special sequence.                                                                            2
                  if {$ch eq "\n"} {                                                                             2
                      return "\\u000a"                                                                           2
                  }                                                                                              2
                  # No point in writing this as a one-liner                                                      2
                  scan $ch %c charNumber                                                                         2
                  format "\\u%04x" $charNumber                                                                   2
              }                                                                                                  2

              set quoted [<b>regsub</b> -all -command $RE $string encodeChar]                                           2

       Decoding a URL-encoded string using <b>regsub</b> <b>-command</b>, a lambda term and the <b>apply</b> command.                 2

              # Match one of the sequences in a URL-encoded string that needs                                    2
              # fixing, converting + to space and %XX to the right character                                     2
              # (e.g., %7e becomes ~)                                                                            2
              set RE {(\+)|%([0-9A-Fa-f]{2})}                                                                    2

              # Note that -command uses a command prefix, not a command name                                     2
              set decoded [<b>regsub</b> -all -command $RE $string {apply {{- p h} {                                    2
                  # + is a special case; handle directly                                                         2
                  if {$p eq "+"} {                                                                               2
                      return " "                                                                                 2
                  }                                                                                              2
                  # convert hex to a char                                                                        2
                  scan $h %x charNumber                                                                          2
                  format %c $charNumber                                                                          2
              }}}]                                                                                               2

       The <b>-command</b> option can also be useful for restricting the range of commands such as <b>string</b> <b>totitle</b>:      2

              set message "the quIck broWn fOX JUmped oVer the laZy dogS..."                                     2
              puts [<b>regsub</b> -all -command {\w+} $message {string totitle}]                                        2
              # → <u>The</u> <u>Quick</u> <u>Brown</u> <u>Fox</u> <u>Jumped</u> <u>Over</u> <u>The</u> <u>Lazy</u> <u>Dogs..</u>                                                2

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/regexp.3tcl.html">regexp</a>(3tcl), <a href="../man3tcl/re_syntax.3tcl.html">re_syntax</a>(3tcl), <a href="../man3tcl/subst.3tcl.html">subst</a>(3tcl), <a href="../man3tcl/string.3tcl.html">string</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       match, pattern, quoting, regular expression, substitution

Tcl                                                    8.3                                          <u><a href="../man3tcl/regsub.3tcl.html">regsub</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>