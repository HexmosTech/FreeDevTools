<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::Aligner - justify strings to various alignment styles</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-aligner-perl">libtext-aligner-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::Aligner - justify strings to various alignment styles

</pre><h4><b>VERSION</b></h4><pre>
       version 0.16

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Text::Aligner qw( align );

         # Print the words "just a test!" right-justified each on a line:

         my @lines = align( 'right', qw( just a test!);
         print "$_\n" for @lines;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Text::Aligner exports a single function, <b>align()</b>, which is used to justify strings to various alignment
       styles.  The alignment specification is the first argument, followed by any number of scalars which are
       subject to alignment.

       The operation depends on context.  In list context, a list of the justified scalars is returned.  In
       scalar context, the justified arguments are joined into a single string with newlines appended.  The
       original arguments remain unchanged.  In void context, in-place justification is attempted.  In this
       case, all arguments must be lvalues.

       <b>Align()</b> also does one level of scalar dereferencing.  That is, whenever one of the arguments is a scalar
       reference, the scalar pointed to is aligned instead.  Other references are simply stringified.  An
       undefined argument is interpreted as an empty string without complaint.

       Alignment respects colorizing escape sequences a la Term::ANSIColor which means it knows that these
       sequences don't take up space on the screen.

</pre><h4><b>NAME</b></h4><pre>
       Text::Aligner - module to align text.

</pre><h4><b>ALIGNMENT</b></h4><pre>
       The first argument of the <b>align()</b> function is an alignment style, a single scalar.

       It can be one of the strings "left", "right", "center", "num", "point", or "auto", or a regular
       expression (qr/.../), or a coderef.

       A default style of "left" is assumed for every other value, including "" and undef.

       "left", "right" and "center" have the obvious meanings.  These can also be given as numbers 0, 1, and 0.5
       respectively. (Other numbers are also possible, but probably not very useful).

       "num", and its synonym "point", specify that the decimal points be aligned (assumed on the right, unless
       present).  Arbitrary (non-numeric) strings are also aligned in this manner, so they end up one column
       left of the (possibly assumed) decimal point, flush right with any integers.  For the occasional string
       like "inf", or "-" for missing values, this may be the right place.  A string-only column ends up right-
       aligned (unless there are points present).

       The "auto" style separates numeric strings (that are composed of "-", ".", and digits in the usual
       manner) and aligns them numerically.  Other strings are left aligned with the number that sticks out
       farthest to the left.  This gives left alignment for string-only columns and numeric alignment for
       columns of numbers.  In mixed columns, strings are reasonably placed to serve as column headings or
       intermediate titles.

       With "num" (and "point") it is possible to specify another character for the decimal point in the form
       "num(,)".  In fact, you can specify any string after a leading "(", and the closing ")" is optional.
       "point(=&gt;)" could be used to align certain pieces of Perl code.  This option is currently not available
       with "auto" alignment (because recognition of numbers is Anglo-centric).

       If a regular expression is specified, the points are aligned where the first match of the regex starts.
       A match is assumed immediately after the string if it doesn't match.

       A regular expression is a powerful way of alignment specification.  It can replace most others easily,
       except center alignment and, of course, the double action of "auto".

</pre><h4><b>POSITIONERS</b></h4><pre>
       For entirely self-defined forms of alignment, a coderef, also known as a positioner, can be given instead
       of an alignment style.  This code will be called once or more times with the string to be aligned as its
       argument.  It must return two numbers, a width and a position, that describe how to align a string with
       other strings.

       The width should normally be the length of the string.  The position defines a point relative to the
       beginning of the string, which is aligned with the positions given for other strings.

       A zero position for all strings results in left alignment, positioning to the end of the string results
       in right alignment, and returning half the length gives center alignment.  "num" alignment is realized by
       marking the position of the decimal point.

       Note that the position you return is a relative measure.  Adding a constant value to all positions
       results in no change in alignment.  It doesn't have to point inside the string (as in right alignment,
       where it points one character past the end of the string).

       The first return value of a positioner should almost always be the length of the given string.  However,
       it may be useful to lie about the string length if the string contains escape sequences that occupy no
       place on screen.

</pre><h4><b>SUBROUTINES</b></h4><pre>
   <b>align($style,</b> <b>$str)</b>
       See above.

   <b>new(...)</b>
       For internal use.

</pre><h4><b>USAGE</b></h4><pre>
         use Text::Aligner qw( align );

         align( $style, $str, ...);

         $style must be given and must be an alignment specification.
         Any number of scalars can follow.  An argument that contains a
         scalar reference is dereferenced before it is used.  In scalar
         and list context, the aligned strings are returned.  In void
         context, the values are aligned in place and must be lvalues.

</pre><h4><b>BUGS</b></h4><pre>
       None known as of release, but...

</pre><h4><b>AUTHOR</b></h4><pre>
           Anno Siegel
           CPAN ID: ANNO

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2002 Anno Siegel. All rights reserved.  This program is free software; you can redistribute
       it and/or modify it under the terms of the ISC license.

       (This program had been licensed under the same terms as Perl itself up to version 1.118 released on 2011,
       and was relicensed by permission of its originator).

       The full text of the license can be found in the LICENSE file included with this module.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1)

       Text::Table .

</pre><h4><b>AUTHOR</b></h4><pre>
       Shlomi Fish &lt;<a href="mailto:shlomif@cpan.org">shlomif@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2002 by Anno Siegel.

       This is free software, licensed under:

         The ISC License

perl v5.36.0                                       2022-11-19                                 <u>Text::<a href="../man3pm/Aligner.3pm.html">Aligner</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>