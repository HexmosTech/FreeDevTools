<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Tools::Run::Alignment::Clustalw - Object for the calculation of a multiple sequence alignment from a</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libbio-tools-run-alignment-clustalw-perl">libbio-tools-run-alignment-clustalw-perl_1.7.4-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Tools::Run::Alignment::Clustalw - Object for the calculation of a multiple sequence alignment from a
       set of unaligned sequences or alignments using the Clustalw program

</pre><h4><b>VERSION</b></h4><pre>
       version 1.7.4

</pre><h4><b>SYNOPSIS</b></h4><pre>
         #  Build a clustalw alignment factory
         @params = ('ktuple' =&gt; 2, 'matrix' =&gt; 'BLOSUM');
         $factory = Bio::Tools::Run::Alignment::Clustalw-&gt;new(@params);

         #  Pass the factory a list of sequences to be aligned.
         $inputfilename = 't/data/cysprot.fa';
         $aln = $factory-&gt;align($inputfilename); # $aln is a SimpleAlign object.
         # or
         $seq_array_ref = \@seq_array;
         # where @seq_array is an array of Bio::Seq objects
         $aln = $factory-&gt;align($seq_array_ref);

         # Or one can pass the factory a pair of (sub)alignments
         #to be aligned against each other, e.g.:
         $aln = $factory-&gt;profile_align($aln1,$aln2);
         # where $aln1 and $aln2 are Bio::SimpleAlign objects.

         # Or one can pass the factory an alignment and one or more unaligned
         # sequences to be added to the alignment. For example:
         $aln = $factory-&gt;profile_align($aln1,$seq); # $seq is a Bio::Seq object.

         # Get a tree of the sequences
         $tree = $factory-&gt;tree(\@seq_array);

         # Get both an alignment and a tree
         ($aln, $tree) = $factory-&gt;run(\@seq_array);

         # Do a footprinting analysis on the supplied sequences, getting back the
         # most conserved sub-alignments
         my @results = $factory-&gt;footprint(\@seq_array);
         foreach my $result (@results) {
           print $result-&gt;consensus_string, "\n";
         }

         # There are various additional options and input formats available.
         # See the DESCRIPTION section that follows for additional details.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Note: this DESCRIPTION only documents the Bioperl interface to Clustalw.  Clustalw, itself, is a large &amp;
       complex program - for more information regarding clustalw, please see the clustalw documentation which
       accompanies the clustalw distribution. Clustalw is available from (among others)
       <a href="ftp://ftp.ebi.ac.uk/pub/software/">ftp://ftp.ebi.ac.uk/pub/software/</a>. Clustalw.pm has only been tested using version 1.8 of clustalw.
       Compatibility with earlier versions of the clustalw program is currently unknown. Before running Clustalw
       successfully it will be necessary: to install clustalw on your system, and to ensure that users have
       execute privileges for the clustalw program.

   <b>Helping</b> <b>the</b> <b>module</b> <b>find</b> <b>your</b> <b>executable</b>
       You will need to enable Clustalw to find the clustalw program. This can be done in (at least) three ways:

        1. Make sure the clustalw executable is in your path so that
           which clustalw
           returns a clustalw executable on your system.

        2. Define an environmental variable CLUSTALDIR which is a
           directory which contains the 'clustalw' application:
           In bash:

           export CLUSTALDIR=/home/username/clustalw1.8

           In csh/tcsh:

           setenv CLUSTALDIR /home/username/clustalw1.8

        3. Include a definition of an environmental variable CLUSTALDIR in
           every script that will use this Clustalw wrapper module, e.g.:

           BEGIN { $ENV{CLUSTALDIR} = '/home/username/clustalw1.8/' }
           use Bio::Tools::Run::Alignment::Clustalw;

       If you are running an application on a webserver make sure the webserver environment has the proper PATH
       set or use the options 2 or 3 to set the variables.

   <b>How</b> <b>it</b> <b>works</b>
       Bio::Tools::Run::Alignment::Clustalw is an object for performing a multiple sequence alignment from a set
       of unaligned sequences and/or sub-alignments by means of the clustalw program.

       Initially, a clustalw "factory object" is created. Optionally, the factory may be passed most of the
       parameters or switches of the clustalw program, e.g.:

         @params = ('ktuple' =&gt; 2, 'matrix' =&gt; 'BLOSUM');
         $factory = Bio::Tools::Run::Alignment::Clustalw-&gt;new(@params);

       Any parameters not explicitly set will remain as the defaults of the clustalw program.  Additional
       parameters and switches (not available in clustalw) may also be set.  Currently, the only such parameter
       is "quiet", which when set to a non-zero value, suppresses clustalw terminal output. Not all clustalw
       parameters are supported at this stage.

       By default, Clustalw output is returned solely in a the form of a Bio::SimpleAlign object which can then
       be printed and/or saved in multiple formats using the AlignIO.pm module. Optionally the raw clustalw
       output file can be saved if the calling script specifies an output file (with the clustalw parameter
       OUTFILE).  Currently only the GCG-MSF output file formats is supported.

       Not all parameters and features have been implemented yet in Perl format.

       Alignment parameters can be changed and/or examined at any time after the factory has been created.  The
       program checks that any parameter/switch being set/read is valid.  However, currently no additional
       checks are included to check that parameters are of the proper type (eg string or numeric) or that their
       values are within the proper range.  As an example, to change the value of the clustalw parameter ktuple
       to 3 and subsequently to check its value one would write:

         $ktuple = 3;
         $factory-&gt;ktuple($ktuple);
         $get_ktuple = $factory-&gt;ktuple();

       Once the factory has been created and the appropriate parameters set, one can call the method <b>align()</b> to
       align a set of unaligned sequences, or call <b>profile_align()</b> to add one or more sequences or a second
       alignment to an initial alignment.

       Input to <b>align()</b> may consist of a set of unaligned sequences in the form of the name of file containing
       the sequences. For example,

         $inputfilename = 't/data/cysprot.fa';
         $aln = $factory-E&lt;gt&gt;align($inputfilename);

       Alternately one can create an array of Bio::Seq objects somehow

         $str = Bio::SeqIO-&gt;new(-file=&gt; 't/data/cysprot.fa', -format =&gt; 'Fasta');
         @seq_array =();
         while ( my $seq = $str-&gt;next_seq() ) {push (@seq_array, $seq) ;}

       and pass the factory a reference to that array

         $seq_array_ref = \@seq_array;
         $aln = $factory-&gt;align($seq_array_ref);

       In either case, <b>align()</b> returns a reference to a SimpleAlign object which can then used (see
       Bio::SimpleAlign).

       Once an initial alignment exists, one can pass the factory additional sequence(s) to be added (ie
       aligned) to the original alignment.  The alignment can be passed as either an alignment file or a
       Bio:SimpleAlign object.  The unaligned sequence(s) can be passed as a filename or as an array of BioPerl
       sequence objects or as a single BioPerl Seq object.  For example (to add a single sequence to an
       alignment),

         $str = Bio::AlignIO-&gt;new(-file=&gt; 't/data/cysprot1a.msf');
         $aln = $str-&gt;next_aln();
         $str1 = Bio::SeqIO-&gt;new(-file=&gt; 't/data/cysprot1b.fa');
         $seq = $str1-&gt;next_seq();
         $aln = $factory-&gt;profile_align($aln,$seq);

       In either case, <b>profile_align()</b> returns a reference to a SimpleAlign object containing a new SimpleAlign
       object of the alignment with the additional sequence(s) added in.

       Finally one can pass the factory a pair of (sub)alignments to be aligned against each other.  The
       alignments can be passed in the form of either a pair of alignment files or a pair of Bio:SimpleAlign
       objects. For example,

         $profile1 = 't/data/cysprot1a.msf';
         $profile2 = 't/data/cysprot1b.msf';
         $aln = $factory-&gt;profile_align($profile1,$profile2);

       or

         $str1 = Bio::AlignIO-&gt;new(-file=&gt; 't/data/cysprot1a.msf');
         $aln1 = $str1-&gt;next_aln();
         $str2 = Bio::AlignIO-&gt;new(-file=&gt; 't/data/cysprot1b.msf');
         $aln2 = $str2-&gt;next_aln();
         $aln = $factory-&gt;profile_align($aln1,$aln2);

       In either case, <b>profile_align()</b> returns a reference to a SimpleAlign object containing an
       (super)alignment of the two input alignments.

       For more examples of syntax and use of Clustalw, the user is encouraged to look at the script Clustalw.t
       in the t/ directory.

       Note: Clustalw is still under development. Various features of the clustalw program have not yet been
       implemented.  If you would like that a specific clustalw feature be added to this perl contact
       <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>.

       These can be specified as parameters when instantiating a new Clustalw object, or through get/set methods
       of the same name (lowercase).

</pre><h4><b>INTERNAL</b> <b>METHODS</b></h4><pre>
   <b>_run</b>
        Title   : _run
        Usage   : Internal function, not to be called directly
        Function: makes actual system call to clustalw program
        Returns : nothing; clustalw output is written to a
                  temporary file
        Args    : Name of a file containing a set of unaligned fasta sequences
                  and hash of parameters to be passed to clustalw

   <b>_setinput()</b>
        Title   : _setinput
        Usage   : Internal function, not to be called directly
        Function: Create input file for clustalw program
        Returns : name of file containing clustalw data input
        Args    : Seq or Align object reference or input file name

   <b>_setparams()</b>
        Title   : _setparams
        Usage   : Internal function, not to be called directly
        Function: Create parameter inputs for clustalw program
        Returns : parameter string to be passed to clustalw
                  during align or profile_align
        Args    : name of calling object

</pre><h4><b>EXAMPLE</b></h4><pre>
       You will need to have installed clustalw and to ensure that Clustalw.pm can find it.  This can be done in
       different ways (bash syntax):

         export PATH=$PATH:/home/peter/clustalw1.8

       or define an environmental variable CLUSTALDIR:

         export CLUSTALDIR=/home/peter/clustalw1.8

       or include a definition of an environmental variable CLUSTALDIR in every script that will use Clustal.pm:

         BEGIN {$ENV{CLUSTALDIR} = '/home/peter/clustalw1.8/'; }

       We are going to demonstrate 3 possible applications of Clustalw.pm:

       1.  Test effect of varying clustalw alignment parameter(s) on resulting alignment

       2.  Test  effect  of  changing  the  order  that  sequences  are  added to the alignment on the resulting
           alignment

       3.  Test effect of incorporating an "anchor point" in the alignment process

       Before we can do any tests, we need to set up the  environment,  create  the  factory  and  read  in  the
       unaligned sequences.

         use Getopt::Long;
         use Bio::Tools::Run::Alignment::Clustalw;
         use Bio::SimpleAlign;
         use Bio::AlignIO;
         use Bio::SeqIO;
         use strict;

         # set some default values
         my $infile = 't/data/cysprot1a.fa';
         my @params = ('quiet' =&gt; 1 );
         my $do_only = '123';   # string listing examples to be executed. Default is to
                                # execute all tests (ie 1,2 and 3)
         my $param = 'ktuple';  # parameter to be varied in example 1
         my $startvalue = 1;    # initial value for parameter $param
         my $stopvalue = 3;     # final value for parameter $param
         my $regex = 'W[AT]F';  # regular expression for 'anchoring' alignment in example 3
         my $extension = 30;    # distance regexp anchor should be extended in each direction
                                # for local alignment in example 3
         my $helpflag = 0;      # Flag to show usage info.

         # get user options
         my @argv = @ARGV;  # copy ARGV before GetOptions() massacres it.

         &amp;GetOptions("h!" =&gt; \$helpflag, "help!" =&gt; \$helpflag,
                     "in=s" =&gt; \$infile,
                     "param=s" =&gt; \$param,
                     "do=s" =&gt;  \$do_only,
                     "start=i" =&gt;  \$startvalue,
                     "stop=i" =&gt;  \$stopvalue,
                     "ext=i" =&gt;  \$extension,
                     "regex=s" =&gt;  \$regex,) ;

         if ($helpflag) { &amp;clustalw_usage(); exit 0;}

         # create factory &amp; set user-specified global clustalw parameters
         foreach my $argv (@argv) {
             unless ($argv =~ /^(.*)=&gt;(.*)$/) { next;}
             push (@params, $1 =&gt; $2);
         }
         my $factory = Bio::Tools::Run::Alignment::Clustalw-&gt;new(@params);

         # put unaligned sequences in a Bio::Seq array
         my $str = Bio::SeqIO-&gt;new(-file=&gt; $infile, '-format' =&gt; 'Fasta');
         my ($paramvalue, $aln, $subaln, @consensus, $seq_num, $string, $strout, $id);
         my @seq_array =();
         while ( my $seq = $str-&gt;next_seq() ) { push (@seq_array, $seq) ;}

         # Do each example that has digit present in variable $do_only
         $_= $do_only;
         /1/ &amp;&amp; &amp;vary_params();
         /2/ &amp;&amp; &amp;vary_align_order();
         /3/ &amp;&amp; &amp;anchored_align();

         ## End of "main"

         #################################################
         #   vary_params(): Example demonstrating varying of clustalw parameter
         #

         sub vary_params {

             print "Beginning parameter-varying example... \n";

             # Now we'll create several alignments, 1 for each value of the selected
             # parameter. We also compute a simple consensus string for each alignment.
             # (In the default case, we vary the "ktuple" parameter,  creating 3
             # alignments using ktuple values from 1 to 3.)

             my $index =0;
             for ($paramvalue = $startvalue; $paramvalue &lt; ($stopvalue + 1); $paramvalue++) {
                 $factory-&gt;$param($paramvalue);  # set parameter value
                 print "Performing alignment with $param = $paramvalue \n";
                 $aln = $factory-&gt;align(\@seq_array);
                 $string = $aln-&gt;consensus_string(); # Get consensus of alignment
                 # convert '?' to 'X' at non-consensus positions
                 $string =~ s/\?/X/g;
                 $consensus[$index] = Bio::Seq-&gt;new(-id=&gt;"$param=$paramvalue",-seq=&gt;$string);
                 $index++;
             }
             # Compare consensus strings for alignments with different $param values by
             # making an alignment of the different consensus strings
             # $factory-&gt;<a href="../man1/ktuple.1.html">ktuple</a>(1);  # set ktuple parameter
             print "Performing alignment of $param consensus sequences \n";
             $aln = $factory-&gt;align(\@consensus);
             $strout = Bio::AlignIO-&gt;newFh('-format' =&gt; 'msf');
             print $strout $aln;

             return 1;
         }

         #################################################
         #   vary_align_order():
         #
         # For our second example, we'll test the effect of changing the order
         # that sequences are added to the alignment

         sub vary_align_order {

             print "\nBeginning alignment-order-changing example... \n";

             @consensus = ();  # clear array
             for ($seq_num = 0; $seq_num &lt; scalar(@seq_array); $seq_num++) {
                 my $obj_out = shift @seq_array;  # remove one Seq object from array and save
                 $id = $obj_out-&gt;display_id;
                 # align remaining sequences
                 print "Performing alignment with sequence $id left out \n";
                 $subaln = $factory-&gt;align(\@seq_array);
                 # add left-out sequence to subalignment
                 $aln = $factory-&gt;profile_align($subaln,$obj_out);
                 $string = $aln-&gt;consensus_string(); # Get consensus of alignment
                 # convert '?' to 'X' for non-consensus positions
                 $string =~ s/\?/X/g;
                 $consensus[$seq_num] = Bio::Seq-&gt;new(-id=&gt;"$id left out",-seq=&gt;$string);
                 push @seq_array, $obj_out;  # return Seq object for next (sub) alignment
             }

             # Compare consensus strings for alignments created in different orders
             # $factory-&gt;<a href="../man1/ktuple.1.html">ktuple</a>(1);  # set ktuple parameter
             print "\nPerforming alignment of consensus sequences for different reorderings \n";
             print "Each consensus is labeled by the sequence which was omitted in the initial alignment\n";
             $aln = $factory-&gt;align(\@consensus);
             $strout = Bio::AlignIO-&gt;newFh('-format' =&gt; 'msf');
             print $strout $aln;

             return 1;
         }

         #################################################
         #   anchored_align()
         #
         # For our last example, we'll test a way to perform a local alignment by
         # "anchoring" the alignment to a regular expression.  This is similar
         # to the approach taken in the recent dbclustal program.
         # In principle, we could write a script to search for a good regular expression
         # to use. Instead, here we'll simply choose one manually after looking at the
         # previous alignments.

         sub anchored_align {

             my @local_array = ();
             my @seqs_not_matched = ();

             print "\n Beginning anchored-alignment example... \n";

             for ($seq_num = 0; $seq_num &lt; scalar(@seq_array); $seq_num++) {
                 my $seqobj = $seq_array[$seq_num];
                 my $seq =  $seqobj-&gt;seq();
                 my $id =  $seqobj-&gt;id();
                 # if $regex is not found in the sequence, save sequence id name and set
                 # array value =0 for later
                 unless ($seq =~/$regex/) {
                     $local_array[$seq_num] = 0;
                     push (@seqs_not_matched, $id) ;
                     next;
                 }
                 # find positions of start and of subsequence to be aligned
                 my $match_start_pos = length($`);
                 my $match_stop_pos = length($`) + length($&amp;);
                 my $start =  ($match_start_pos - $extension) &gt; 1 ?
                     ($match_start_pos - $extension) +1 : 1;
                 my $stop =  ($match_stop_pos + $extension) &lt; length($seq) ?
                     ($match_stop_pos + $extension) : length($seq);
                 my $string = $seqobj-&gt;subseq($start, $stop);

                 $local_array[$seq_num] = Bio::Seq-&gt;new(-id=&gt;$id, -seq=&gt;$string);
             }
             @local_array = grep $_ , @local_array; # remove array entries with no match

             # Perform alignment on the local segments of the sequences which match "anchor"
             $aln = $factory-&gt;align(\@local_array);
             my $consensus  = $aln-&gt;consensus_string(); # Get consensus of local alignment

             if (scalar(@seqs_not_matched) ) {
                 print " Sequences not matching $regex : @seqs_not_matched \n"
             } else {
                 print " All sequences match $regex : @seqs_not_matched \n"
         }
             print "Consensus sequence of local alignment: $consensus \n";

             return 1;
         }

         #----------------
         sub clustalw_usage {
         #----------------

         #-----------------------
         # Prints usage information for general parameters.

             print STDERR &lt;&lt;"QQ_PARAMS_QQ";

          Command-line accessible script variables and commands:
          -------------------------------
          -h                 :  Display this usage info and exit.
          -in &lt;str&gt;          :  File containing input sequences in fasta format (default = $infile) .
          -do &lt;str&gt;          :  String listing examples to be executed. Default is to execute
                                all tests (ie default = '123')
          -param &lt;str&gt;   :  Parameter to be varied in example 1. Any clustalw parameter
                            which takes inteer values can be varied (default = 'ktuple')
          -start &lt;int&gt;   :  Initial value for varying parameter in example 1 (default = 1)
          -stop &lt;int&gt;    :  Final value for varying parameter (default = 3)
          -regex   &lt;str&gt; :  Regular expression for 'anchoring' alignment in example 3
                            (default = $regex)
          -ext &lt;int&gt;     :  Distance regexp anchor should be extended in each direction
                            for local alignment in example 3   (default = 30)

         In addition, any valid Clustalw parameter can be set using the syntax
         "parameter=&gt;value" as in "ktuple=&gt;3"

         So a typical command lines might be:
          &gt; clustalw.pl -param=pairgap -start=2 -stop=3 -do=1 "ktuple=&gt;3"
         or
          &gt; clustalw.pl -ext=10 -regex='W[AST]F' -do=23 -in='t/cysprot1a.fa'

         QQ_PARAMS_QQ

         }

</pre><h4><b>PARAMETER</b> <b>FOR</b> <b>ALIGNMENT</b> <b>COMPUTATION</b></h4><pre>
   <b>KTUPLE</b>
        Title       : KTUPLE
        Description : (optional) set the word size to be used in the alignment
                      This is the size of exactly matching fragment that is used.
                      INCREASE for speed (max= 2 for proteins; 4 for DNA),
                      DECREASE for sensitivity.
                      For longer sequences (e.g. &gt;1000 residues) you may
                      need to increase the default

   <b>TOPDIAGS</b>
        Title       : TOPDIAGS
        Description : (optional) number of best diagonals to use
                      The number of k-tuple matches on each diagonal
                      (in an imaginary dot-matrix plot) is calculated.
                      Only the best ones (with most matches) are used in
                      the alignment.  This parameter specifies how many.
                      Decrease for speed; increase for sensitivity.

   <b>WINDOW</b>
        Title       : WINDOW
        Description : (optional) window size
                      This is the number of diagonals around each of the 'best'
                      diagonals that will be used.  Decrease for speed;
                      increase for sensitivity.

   <b>PAIRGAP</b>
        Title       : PAIRGAP
        Description : (optional) gap penalty for pairwise alignments
                      This is a penalty for each gap in the fast alignments.
                      It has little affect on the speed or sensitivity except
                      for extreme values.

   <b>FIXEDGAP</b>
        Title       : FIXEDGAP
        Description : (optional) fixed length gap penalty

   <b>FLOATGAP</b>
        Title       : FLOATGAP
        Description : (optional) variable length gap penalty

   <b>MATRIX</b>
        Title       : MATRIX
        Default     : PAM100 for DNA - PAM250 for protein alignment
        Description : (optional) substitution matrix used in the multiple
                      alignments. Depends on the version of clustalw as to
                      what default matrix will be used

                      PROTEIN WEIGHT MATRIX leads to a new menu where you are
                      offered a choice of weight matrices. The default for
                      proteins in version 1.8 is the PAM series derived by
                      Gonnet and colleagues. Note, a series is used! The
                      actual matrix that is used depends on how similar the
                      sequences to be aligned at this alignment step
                      are. Different matrices work differently at each
                      evolutionary distance.

                      DNA WEIGHT MATRIX leads to a new menu where a single
                      matrix (not a series) can be selected. The default is
                      the matrix used by BESTFIT for comparison of nucleic
                      acid sequences.

   <b>TYPE</b>
        Title       : TYPE
        Description : (optional) sequence type: protein or DNA. This allows
                       you to explicitly override the programs attempt at
                       guessing the type of the sequence.  It is only useful
                       if you are using sequences with a VERY strange
                       composition.

   <b>OUTPUT</b>
        Title       : OUTPUT
        Description : (optional) clustalw supports GCG or PHYLIP or PIR or
                       Clustal format.  See the Bio::AlignIO modules for
                       which formats are supported by bioperl.

   <b>OUTFILE</b>
        Title       : OUTFILE
        Description : (optional) Name of clustalw output file. If not set
                       module will erase output file.  In any case alignment will
                       be returned in the form of SimpleAlign objects

   <b>TRANSMIT</b>
        Title       : TRANSMIT
        Description : (optional) transitions not weighted.  The default is to
                       weight transitions as more favourable than other
                       mismatches in DNA alignments.  This switch makes all
                       nucleotide mismatches equally weighted.

   <b>program_name</b>
        Title   : program_name
        Usage   : $factory&gt;program_name()
        Function: holds the program name
        Returns:  string
        Args    : None

   <b>program_dir</b>
        Title   : program_dir
        Usage   : $factory-&gt;program_dir(@params)
        Function: returns the program directory, obtained from ENV variable.
        Returns:  string
        Args    :

   <b>version</b>
        Title   : version
        Usage   : exit if $prog-&gt;version() &lt; 1.8
        Function: Determine the version number of the program
        Example :
        Returns : float or undef
        Args    : none

   <b>run</b>
        Title   : run
        Usage   : ($aln, $tree) = $factory-&gt;run($inputfilename);
                  ($aln, $tree) = $factory-&gt;run($seq_array_ref);
        Function: Perform a multiple sequence alignment, generating a tree at the same
                  time. (Like align() and tree() combined.)
        Returns : A SimpleAlign object containing the sequence alignment and a
                  Bio::Tree::Tree object with the tree relating the sequences.
        Args    : Name of a file containing a set of unaligned fasta sequences
                  or else an array of references to Bio::Seq objects.

   <b>align</b>
        Title   : align
        Usage   : $inputfilename = 't/data/cysprot.fa';
                  $aln = $factory-&gt;align($inputfilename);
                  or
                  $seq_array_ref = \@seq_array; # @seq_array is array of Seq objs
                  $aln = $factory-&gt;align($seq_array_ref);
        Function: Perform a multiple sequence alignment
        Returns : Reference to a SimpleAlign object containing the
                  sequence alignment.
        Args    : Name of a file containing a set of unaligned fasta sequences
                  or else an array of references to Bio::Seq objects.

        Throws an exception if argument is not either a string (eg a
        filename) or a reference to an array of Bio::Seq objects.  If
        argument is string, throws exception if file corresponding to string
        name can not be found. If argument is Bio::Seq array, throws
        exception if less than two sequence objects are in array.

   <b>profile_align</b>
        Title   : profile_align
        Usage   : $aln = $factory-&gt;profile_align(@simple_aligns);
                  or
                  $aln = $factory-&gt;profile_align(@subalignment_filenames);
        Function: Perform an alignment of 2 (sub)alignments
        Returns : Reference to a SimpleAlign object containing the (super)alignment.
        Args    : Names of 2 files containing the subalignments
                  or references to 2 Bio::SimpleAlign objects.

       Throws  an  exception  if  arguments  are  not either strings (eg filenames) or references to SimpleAlign
       objects.

   <b>add_sequences</b>
        Title   : add_sequences
        Usage   :
        Function: Align and add sequences into an alignment
        Example :
        Returns : Reference to a SimpleAlign object containing the (super)alignment.
        Args    : Names of 2 files, the first one containing an alignment and the second one containing sequences to be added
                or references to 2 Bio::SimpleAlign objects.

       Throws an exception if arguments are not either strings  (eg  filenames)  or  references  to  SimpleAlign
       objects.

   <b>tree</b>
        Title   : tree
        Usage   : @params = ('bootstrap' =&gt; 1000,
                             'tossgaps'  =&gt; 1,
                             'kimura'    =&gt; 1,
                             'seed'      =&gt; 121,
                             'bootlabels'=&gt; 'nodes',
                             'quiet'     =&gt; 1);
                  $factory = Bio::Tools::Run::Alignment::Clustalw-&gt;new(@params);
                  $tree_obj = $factory-&gt;tree($aln_obj);
                  or
                  $tree_obj = $factory-&gt;tree($treefilename);
        Function: Retrieve a tree corresponding to the input
        Returns : Bio::TreeIO object
        Args    : Bio::SimpleAlign or filename of a tree

   <b>footprint</b>
        Title   : footprint
        Usage   : @alns = $factory-&gt;footprint($treefilename, $window_size, $diff);
                  @alns = $factory-&gt;footprint($seqs_array_ref);
        Function: Aligns all the supplied sequences and slices out of the alignment
                  those regions along a sliding window who's tree length differs
                  significantly from the total average tree length.
        Returns : list of Bio::SimpleAlign objects
        Args    : first argument as per run(), optional second argument to specify
                  the size of the sliding window (default 5 bp) and optional third
                  argument to specify the % difference from the total tree length
                  needed for a window to be considered a footprint (default 33%).

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>lists</b>
       User  feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments
       and suggestions preferably to the Bioperl mailing list.  Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>              - General discussion
         <a href="http://bioperl.org/Support.html">http://bioperl.org/Support.html</a>    - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list: <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather than to the module maintainer directly. Many experienced and reponsive experts will be  able  look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>bugs</b>
       Report  bugs  to  the Bioperl bug tracking system to help us keep track of the bugs and their resolution.
       Bug reports can be submitted via the web:

         https://github.com/bioperl/bio-tools-run-alignment-clustalw/issues

</pre><h4><b>AUTHORS</b></h4><pre>
       Peter Schattner &lt;<a href="mailto:schattner@alum.mit.edu">schattner@alum.mit.edu</a>&gt;

       Jason Stajich &lt;<a href="mailto:jason@bioperl.org">jason@bioperl.org</a>&gt;

       Sendu Bala &lt;<a href="mailto:bix@sendu.me.uk">bix@sendu.me.uk</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This software is copyright (c) by Peter Schattner &lt;<a href="mailto:schattner@alum.mit.edu">schattner@alum.mit.edu</a>&gt;.

       This software is available under the same terms as the perl 5 programming language system itself.

perl v5.30.3                                       2020-10-24             <u>Bio::Tools::Run...nment::<a href="../man3pm/Clustalw.3pm.html">Clustalw</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>