<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libatomic-malloc - Library providing simple almost-lock-free malloc implementation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libatomic-ops-dev">libatomic-ops-dev_7.8.2-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libatomic-malloc - Library providing simple almost-lock-free malloc implementation

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;atomic_ops_malloc.h&gt;</b>

       <b>cc</b> <b>...</b> <b>-latomic_ops_gpl</b>

       Note that the AO_malloc implementation is licensed under the GPL, unlike the lower level routines.

       <b>void</b> <b>*AO_malloc(size_t</b> <b>sz);</b>
       <b>void</b> <b>AO_free(void</b> <b>*p);</b>
       <b>void</b> <b>AO_malloc_enable_mmap(void);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A simple almost-lock-free malloc implementation.

       This  is  intended  as  a safe way to allocate memory from a signal handler, or to allocate memory in the
       context of a library that does not know what thread library it will be used with.  In either case locking
       is impossible.

       Note that the operations are only guaranteed to be 1-lock-free, i.e. a single  blocked  thread  will  not
       prevent  progress, but multiple blocked threads may.  To safely use these operations in a signal handler,
       the handler should be non-reentrant, i.e. it should not be interruptable by another handler  using  these
       operations.   Furthermore  use  outside  of  signal  handlers  in  a  multithreaded application should be
       protected by a lock, so that at most one invocation may be interrupted by  a  signal.   The  header  will
       define  the  macro <u>AO_MALLOC_IS_LOCK_FREE</u> on platforms on which malloc is completely lock-free, and hence
       these restrictions do not apply.

       In the presence of threads, but absence of contention, the time performance of this package should be  as
       good,   or  slightly  better  than,  most  system  malloc  implementations.   Its  space  performance  is
       theoretically optimal (to within a constant factor), but probably quite poor in practice.  In particular,
       no attempt is made to coalesce free small memory blocks.  Something like Doug Lea's malloc is  likely  to
       use significantly less memory for complex applications.

       Perfomance on platforms without an efficient compare-and-swap implementation will be poor.

       This  package  was  not  designed for processor-scalability in the face of high allocation rates.  If all
       threads happen to allocate different-sized objects, you might get lucky.  Otherwise expect contention and
       false-sharing problems.  If this is an issue, something like Maged Michael's algorithm (PLDI 2004)  would
       be  technically  a  far better choice.  If you are concerned only with scalablity, and not signal-safety,
       you might also consider using Hoard instead.  We have seen a factor of 3 to 4 slowdown from the  standard
       glibc  malloc  implementation  with  contention, even when the performance without contention was faster.
       (To make the implementation more scalable, one would need to replicate at least the free list headers, so
       that concurrent access is possible without cache conflicts.)

       Unfortunately there is no portable async-signal-safe way to obtain large chunks of memory  from  the  OS.
       Based  on  reading  of  the source code, mmap-based allocation appears safe under Linux, and probably BSD
       variants.  It is probably unsafe for operating systems built on Mach, such as  Apple's  Darwin.   Without
       use of mmap, the allocator is limited to a fixed size, statically preallocated heap (2MB by default), and
       will  fail  to  allocate  objects  above  a  certain  size  (just  under 64K by default).  Use of mmap to
       circumvent these limitations requires an explicit call.

       The entire interface to the AO_malloc package currently consists of:

       <b>AO_malloc</b>
              Allocate an area of memory

       <b>AO_free</b>
              Free a previously malloced memory area

       AO_malloc_enable_mmap
              Enable mmap for large malloc chunks

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/libatomic-ops.3.html">libatomic-ops</a>(3), <a href="../man3/libatomic-stack.3.html">libatomic-stack</a>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
       This manual page was written by Ian Wienand &lt;<a href="mailto:ianw@gelato.unsw.edu.au">ianw@gelato.unsw.edu.au</a>&gt;, based on comments  in  the  source
       code.  It was written for the Debian project (but may be used by others).

Ian Wienand                                       2 June, 2005                               <u><a href="../man3/LIBATOMIC-MALLOC.3.html">LIBATOMIC-MALLOC</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>