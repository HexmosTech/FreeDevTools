<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVP_PKEY_encapsulate_init, EVP_PKEY_auth_encapsulate_init, EVP_PKEY_encapsulate - Key encapsulation using</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       EVP_PKEY_encapsulate_init, EVP_PKEY_auth_encapsulate_init, EVP_PKEY_encapsulate - Key encapsulation using
       a KEM algorithm with a public key

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/evp.h&gt;

        int EVP_PKEY_encapsulate_init(EVP_PKEY_CTX *ctx, const OSSL_PARAM params[]);
        int EVP_PKEY_auth_encapsulate_init(EVP_PKEY_CTX *ctx, EVP_PKEY *authpriv,
                                          const OSSL_PARAM params[]);
        int EVP_PKEY_encapsulate(EVP_PKEY_CTX *ctx,
                                 unsigned char *wrappedkey, size_t *wrappedkeylen,
                                 unsigned char *genkey, size_t *genkeylen);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>EVP_PKEY_encapsulate_init()</b> function initializes a public key algorithm context <u>ctx</u> for an
       encapsulation operation and then sets the <u>params</u> on the context in the same way as calling
       <b><a href="../man3/EVP_PKEY_CTX_set_params.3.html">EVP_PKEY_CTX_set_params</a></b>(3).  Note that <u>ctx</u> is usually is produced using <b><a href="../man3/EVP_PKEY_CTX_new_from_pkey.3.html">EVP_PKEY_CTX_new_from_pkey</a></b>(3),
       specifying the public key to use.

       The <b>EVP_PKEY_auth_encapsulate_init()</b> function is similar to <b>EVP_PKEY_encapsulate_init()</b> but also passes
       an <u>authpriv</u> authentication private key that is used during encapsulation.

       The <b>EVP_PKEY_encapsulate()</b> function performs a public key encapsulation operation using <u>ctx</u>.  The shared
       secret writen to <u>genkey</u> can be used as an input for key derivation, typically for various symmetric
       algorithms.  Its size is written to <u>genkeylen</u>, which must be initialised to the size of the provided
       buffer.

       The ciphertext written to <u>wrappedkey</u> is an encapsulated form, which is expected to be only usable by the
       holder of the private key corresponding to wthe public key associated with <u>ctx</u>.  This ciphertext is then
       communicated to the private-key holder, who can use <b><a href="../man3/EVP_PKEY_decapsulate.3.html">EVP_PKEY_decapsulate</a></b>(3) to securely recover the same
       shared secret.

       If <u>wrappedkey</u> is NULL then the maximum size of the output buffer is written to the <u>*wrappedkeylen</u>
       parameter unless <u>wrappedkeylen</u> is NULL and the maximum size of the generated key buffer is written to
       <u>*genkeylen</u> unless <u>genkeylen</u> is NULL.

       If <u>wrappedkey</u> is not NULL and the call is successful then the generated shared secret is written to
       <u>genkey</u> and its size is written to <u>*genkeylen</u> (which must be non-NULL).  The encapsulated ciphertext is
       written to <u>wrappedkey</u> and its size is written to <u>*wrappedkeylen</u> (must also be non-NULL), The value
       pointed to by <u>wrappedlen</u> initially hold the size of the <u>unwrapped</u> buffer so that its size can be
       validated by the call, ensuring it is large enough to hold the result written to <u>wrapped</u>.

       Absent detailed prior knowledge of the internals of the specific KEM algorithm, callers SHOULD NOT assume
       that the returned shared secret and ciphertext are necessarily of the maximum possible length.  The
       lengths returned via <u>*wrappedkeylen</u> and <u>*genkeylen</u> SHOULD be used to determine the actual lengths of the
       outputs.

</pre><h4><b>NOTES</b></h4><pre>
       After the call to <b>EVP_PKEY_encapsulate_init()</b>, algorithm-specific parameters for the operation may be set
       or modified using <b><a href="../man3/EVP_PKEY_CTX_set_params.3.html">EVP_PKEY_CTX_set_params</a></b>(3).

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>EVP_PKEY_encapsulate_init()</b>, <b>EVP_PKEY_auth_encapsulate_init()</b> and <b>EVP_PKEY_encapsulate()</b> return 1 for
       success and 0 or a negative value for failure. In particular a return value of -2 indicates the operation
       is not supported by the public key algorithm.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Encapsulate an RSASVE key (for RSA keys).

        #include &lt;openssl/evp.h&gt;

        /*
         * NB: assumes rsa_pub_key is an public key of another party.
         */

        EVP_PKEY_CTX *ctx = NULL;
        size_t secretlen = 0, outlen = 0;
        unsigned char *out = NULL, *secret = NULL;

        ctx = EVP_PKEY_CTX_new_from_pkey(libctx, rsa_pub_key, NULL);
        if (ctx == NULL)
            /* Error */
        if (EVP_PKEY_encapsulate_init(ctx, NULL) &lt;= 0)
            /* Error */

        /* Set the mode - only 'RSASVE' is currently supported */
         if (EVP_PKEY_CTX_set_kem_op(ctx, "RSASVE") &lt;= 0)
            /* Error */
        /* Determine buffer length */
        if (EVP_PKEY_encapsulate(ctx, NULL, &amp;outlen, NULL, &amp;secretlen) &lt;= 0)
            /* Error */

        out = OPENSSL_malloc(outlen);
        secret = OPENSSL_malloc(secretlen);
        if (out == NULL || secret == NULL)
            /* malloc failure */

        /*
         * The generated 'secret' can be used as key material.
         * The encapsulated 'out' can be sent to another party who can
         * decapsulate it using their private key to retrieve the 'secret'.
         */
        if (EVP_PKEY_encapsulate(ctx, out, &amp;outlen, secret, &amp;secretlen) &lt;= 0)
            /* Error */

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/EVP_PKEY_CTX_new_from_pkey.3.html">EVP_PKEY_CTX_new_from_pkey</a></b>(3), <b><a href="../man3/EVP_PKEY_decapsulate.3.html">EVP_PKEY_decapsulate</a></b>(3), <b><a href="../man7/EVP_KEM-RSA.7.html">EVP_KEM-RSA</a></b>(7), <b><a href="../man7/EVP_KEM-X25519.7.html">EVP_KEM-X25519</a></b>(7), <b><a href="../man7/EVP_KEM-EC.7.html">EVP_KEM-EC</a></b>(7),
       <b><a href="../man7/EVP_KEM-ML-KEM-512.7.html">EVP_KEM-ML-KEM-512</a></b>(7), <b><a href="../man7/EVP_KEM-ML-KEM-768.7.html">EVP_KEM-ML-KEM-768</a></b>(7), <b><a href="../man7/EVP_KEM-ML-KEM-1024.7.html">EVP_KEM-ML-KEM-1024</a></b>(7)

</pre><h4><b>HISTORY</b></h4><pre>
       The functions <b>EVP_PKEY_encapsulate_init()</b> and <b>EVP_PKEY_encapsulate()</b> were added in OpenSSL 3.0.  The
       function <b>EVP_PKEY_auth_encapsulate_init()</b> was added in OpenSSL 3.2.

       Support for <b>ML-KEM</b> was added in OpenSSL 3.5.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2020-2025 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                         <u><a href="../man3SSL/EVP_PKEY_ENCAPSULATE.3SSL.html">EVP_PKEY_ENCAPSULATE</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>