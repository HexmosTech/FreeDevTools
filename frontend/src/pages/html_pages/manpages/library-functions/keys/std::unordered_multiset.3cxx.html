<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::unordered_multiset< _Value, _Hash, _Pred, _Alloc > - A standard container composed of equivalent</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::unordered_multiset&lt; _Value, _Hash, _Pred, _Alloc &gt; - A standard container composed of equivalent
       keys (possibly containing multiple of each key value) in which the elements' keys are the elements
       themselves.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;unordered_set&gt;

   <b>Public</b> <b>Types</b>
       <b>using</b> <b>node_type</b> = <b>typename</b> _Hashtable::node_type

           <b>typedef</b> _Hashtable::key_type <b>key_type</b>
               Public typedefs.
           <b>typedef</b> _Hashtable::value_type <b>value_type</b>
               Public typedefs.
           <b>typedef</b> _Hashtable::hasher <b>hasher</b>
               Public typedefs.
           <b>typedef</b> _Hashtable::key_equal <b>key_equal</b>
               Public typedefs.
           <b>typedef</b> _Hashtable::allocator_type <b>allocator_type</b>
               Public typedefs.

           <b>typedef</b> _Hashtable::pointer <b>pointer</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::const_pointer <b>const_pointer</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::reference <b>reference</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::const_reference <b>const_reference</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::iterator <b>iterator</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::const_iterator <b>const_iterator</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::local_iterator <b>local_iterator</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::const_local_iterator <b>const_local_iterator</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::size_type <b>size_type</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::difference_type <b>difference_type</b>
               Iterator-related typedefs.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>unordered_multiset</b> ()=<b>default</b>
           Default constructor.
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>unordered_multiset</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           <b>size_type</b> __n, const <b>allocator_type</b> &amp;__a)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>unordered_multiset</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           <b>size_type</b> __n, const <b>hasher</b> &amp;<b>__hf</b>, const <b>allocator_type</b> &amp;__a)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>unordered_multiset</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           <b>size_type</b> __n=0, const <b>hasher</b> &amp;<b>__hf</b>=<b>hasher</b>(), const <b>key_equal</b> &amp;<b>__eql</b>=<b>key_equal</b>(), const
           <b>allocator_type</b> &amp;__a=<b>allocator_type</b>())
           Builds an unordered_multiset from a range.
       <b>unordered_multiset</b> (const <b>allocator_type</b> &amp;__a)
           Creates an unordered_multiset with no elements.
       <b>unordered_multiset</b> (const <b>unordered_multiset</b> &amp;)=<b>default</b>
           Copy constructor.
       <b>unordered_multiset</b> (const <b>unordered_multiset</b> &amp;<b>__umset</b>, const <b>allocator_type</b> &amp;__a)
       <b>unordered_multiset</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>, <b>size_type</b> __n, const <b>allocator_type</b> &amp;__a)
       <b>unordered_multiset</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>, <b>size_type</b> __n, const <b>hasher</b> &amp;<b>__hf</b>, const
           <b>allocator_type</b> &amp;__a)
       <b>unordered_multiset</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>, <b>size_type</b> __n=0, const <b>hasher</b> &amp;<b>__hf</b>=<b>hasher</b>(),
           const <b>key_equal</b> &amp;<b>__eql</b>=<b>key_equal</b>(), const <b>allocator_type</b> &amp;__a=<b>allocator_type</b>())
           Builds an unordered_multiset from an initializer_list.
       <b>unordered_multiset</b> (<b>size_type</b> __n, const <b>allocator_type</b> &amp;__a)
       <b>unordered_multiset</b> (<b>size_type</b> __n, const <b>hasher</b> &amp;<b>__hf</b>, const <b>allocator_type</b> &amp;__a)
       <b>unordered_multiset</b> (<b>size_type</b> __n, const <b>hasher</b> &amp;<b>__hf</b>=<b>hasher</b>(), const <b>key_equal</b> &amp;<b>__eql</b>=<b>key_equal</b>(), const
           <b>allocator_type</b> &amp;__a=<b>allocator_type</b>())
           Default constructor creates no elements.
       <b>unordered_multiset</b> (<b>unordered_multiset</b> &amp;&amp;)=<b>default</b>
           Move constructor.
       <b>unordered_multiset</b> (<b>unordered_multiset</b> &amp;&amp;<b>__umset</b>, const <b>allocator_type</b> &amp;__a)
           noexcept(noexcept(<b>_Hashtable</b>(<b>std::move</b>(__umset._M_h), __a)))
       <b>size_type</b> <b>bucket</b> (const <b>key_type</b> &amp;<b>__key</b>) const
       <b>size_type</b> <b>bucket_count</b> () const noexcept
           Returns the number of buckets of the unordered_multiset.
       <b>size_type</b> <b>bucket_size</b> (<b>size_type</b> __n) const
       <b>const_iterator</b> <b>cbegin</b> () const noexcept
       <b>const_iterator</b> <b>cend</b> () const noexcept
       <b>void</b> <b>clear</b> () noexcept
       template&lt;typename... _Args&gt; <b>iterator</b> <b>emplace</b> (<b>_Args</b> &amp;&amp;... <b>__args</b>)
           Builds and insert an element into the unordered_multiset.
       template&lt;typename... _Args&gt; <b>iterator</b> <b>emplace_hint</b> (<b>const_iterator</b> <b>__pos</b>, <b>_Args</b> &amp;&amp;... <b>__args</b>)
           Inserts an element into the unordered_multiset.
       bool <b>empty</b> () const noexcept
           Returns true if the unordered_multiset is empty.
       <b>size_type</b> <b>erase</b> (const <b>key_type</b> &amp;__x)
           Erases elements according to the provided key.
       <b>iterator</b> <b>erase</b> (<b>const_iterator</b> __first, <b>const_iterator</b> __last)
           Erases a [__first,__last) range of elements from an unordered_multiset.
       node_type <b>extract</b> (const <b>key_type</b> &amp;<b>__key</b>)
           Extract a node.
       node_type <b>extract</b> (<b>const_iterator</b> <b>__pos</b>)
           Extract a node.
       <b>allocator_type</b> <b>get_allocator</b> () const noexcept
           Returns the allocator object used by the unordered_multiset.
       <b>hasher</b> <b>hash_function</b> () const
           Returns the hash functor object with which the unordered_multiset was constructed.
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>void</b> <b>insert</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last)
           A template function that inserts a range of elements.
       <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__hint</b>, node_type &amp;&amp;<b>__nh</b>)
           Re-insert an extracted node.
       <b>void</b> <b>insert</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>)
           Inserts a list of elements into the unordered_multiset.
       <b>iterator</b> <b>insert</b> (node_type &amp;&amp;<b>__nh</b>)
           Re-insert an extracted node.
       <b>key_equal</b> <b>key_eq</b> () const
           Returns the key comparison object with which the unordered_multiset was constructed.
       float <b>load_factor</b> () const noexcept
           Returns the average number of elements per bucket.
       <b>size_type</b> <b>max_bucket_count</b> () const noexcept
           Returns the maximum number of buckets of the unordered_multiset.
       float <b>max_load_factor</b> () const noexcept
           Returns a positive number that the unordered_multiset tries to keep the load factor less than or
           equal to.
       <b>void</b> <b>max_load_factor</b> (float <b>__z</b>)
           Change the unordered_multiset maximum load factor.
       <b>size_type</b> <b>max_size</b> () const noexcept
           Returns the maximum size of the unordered_multiset.
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_multiset</b>&lt; _Value, <b>_H2</b>, <b>_P2</b>, _Alloc &gt;
           &amp;&amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_multiset</b>&lt; _Value, <b>_H2</b>, <b>_P2</b>, _Alloc &gt;
           &amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_set</b>&lt; _Value, <b>_H2</b>, <b>_P2</b>, _Alloc &gt; &amp;&amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_set</b>&lt; _Value, <b>_H2</b>, <b>_P2</b>, _Alloc &gt; &amp;<b>__source</b>)
       <b>unordered_multiset</b> &amp; <b>operator=</b> (const <b>unordered_multiset</b> &amp;)=<b>default</b>
           Copy assignment operator.
       <b>unordered_multiset</b> &amp; <b>operator=</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>)
           Unordered_multiset list assignment operator.
       <b>unordered_multiset</b> &amp; <b>operator=</b> (<b>unordered_multiset</b> &amp;&amp;)=<b>default</b>
           Move assignment operator.
       <b>void</b> <b>rehash</b> (<b>size_type</b> __n)
           May rehash the unordered_multiset.
       <b>void</b> <b>reserve</b> (<b>size_type</b> __n)
           Prepare the unordered_multiset for a specified number of elements.
       <b>size_type</b> <b>size</b> () const noexcept
           Returns the size of the unordered_multiset.
       <b>void</b> <b>swap</b> (<b>unordered_multiset</b> &amp;__x) noexcept(noexcept(_M_h.swap(__x._M_h)))
           Swaps data with another unordered_multiset.

           <b>iterator</b> <b>begin</b> () noexcept
           <b>const_iterator</b> <b>begin</b> () const noexcept

           <b>iterator</b> <b>end</b> () noexcept
           <b>const_iterator</b> <b>end</b> () const noexcept

           <b>iterator</b> <b>insert</b> (const <b>value_type</b> &amp;__x)
               Inserts an element into the unordered_multiset.
           <b>iterator</b> <b>insert</b> (<b>value_type</b> &amp;&amp;__x)
               Inserts an element into the unordered_multiset.

           <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__hint</b>, const <b>value_type</b> &amp;__x)
               Inserts an element into the unordered_multiset.
           <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__hint</b>, <b>value_type</b> &amp;&amp;__x)
               Inserts an element into the unordered_multiset.

           <b>iterator</b> <b>erase</b> (<b>const_iterator</b> <b>__position</b>)
               Erases an element from an unordered_multiset.
           <b>iterator</b> <b>erase</b> (<b>iterator</b> <b>__position</b>)
               Erases an element from an unordered_multiset.

           <b>iterator</b> <b>find</b> (const <b>key_type</b> &amp;__x)
               Tries to locate an element in an unordered_multiset.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>find</b> (const <b>_Kt</b> &amp;__x) -&gt; <b>decltype</b>(_M_h._M_find_tr(__x))
               Tries to locate an element in an unordered_multiset.
           <b>const_iterator</b> <b>find</b> (const <b>key_type</b> &amp;__x) const
               Tries to locate an element in an unordered_multiset.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>find</b> (const <b>_Kt</b> &amp;__x) const -&gt; <b>decltype</b>(_M_h._M_find_tr(__x))
               Tries to locate an element in an unordered_multiset.

           <b>size_type</b> <b>count</b> (const <b>key_type</b> &amp;__x) const
               Finds the number of elements.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>count</b> (const <b>_Kt</b> &amp;__x) const -&gt; <b>decltype</b>(_M_h._M_count_tr(__x))
               Finds the number of elements.

           bool <b>contains</b> (const <b>key_type</b> &amp;__x) const
               Finds whether an element with the given key exists.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>contains</b> (const <b>_Kt</b> &amp;__x) const -&gt; <b>decltype</b>(_M_h._M_find_tr(__x),
               <b>void</b>(), <b>true</b>)
               Finds whether an element with the given key exists.

           <b>std::pair</b>&lt; <b>iterator</b>, <b>iterator</b> &gt; <b>equal_range</b> (const <b>key_type</b> &amp;__x)
               Finds a subsequence matching given key.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>equal_range</b> (const <b>_Kt</b> &amp;__x) -&gt; <b>decltype</b>(_M_h._M_equal_range_tr(__x))
               Finds a subsequence matching given key.
           <b>std::pair</b>&lt; <b>const_iterator</b>, <b>const_iterator</b> &gt; <b>equal_range</b> (const <b>key_type</b> &amp;__x) const
               Finds a subsequence matching given key.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>equal_range</b> (const <b>_Kt</b> &amp;__x) const -&gt;
               <b>decltype</b>(_M_h._M_equal_range_tr(__x))
               Finds a subsequence matching given key.

           <b>local_iterator</b> <b>begin</b> (<b>size_type</b> __n)
               Returns a read-only (constant) iterator pointing to the first bucket element.
           <b>const_local_iterator</b> <b>begin</b> (<b>size_type</b> __n) const
               Returns a read-only (constant) iterator pointing to the first bucket element.
           <b>const_local_iterator</b> <b>cbegin</b> (<b>size_type</b> __n) const
               Returns a read-only (constant) iterator pointing to the first bucket element.

           <b>local_iterator</b> <b>end</b> (<b>size_type</b> __n)
               Returns a read-only (constant) iterator pointing to one past the last bucket elements.
           <b>const_local_iterator</b> <b>end</b> (<b>size_type</b> __n) const
               Returns a read-only (constant) iterator pointing to one past the last bucket elements.
           <b>const_local_iterator</b> <b>cend</b> (<b>size_type</b> __n) const
               Returns a read-only (constant) iterator pointing to one past the last bucket elements.

   <b>Friends</b>
       template&lt;<b>typename</b> <b>_Value1</b> , <b>typename</b> <b>_Hash1</b> , <b>typename</b> <b>_Pred1</b> , <b>typename</b> _Alloc1 &gt; bool <b>operator==</b> (const
           <b>unordered_multiset</b>&lt; <b>_Value1</b>, <b>_Hash1</b>, <b>_Pred1</b>, _Alloc1 &gt; &amp;, const <b>unordered_multiset</b>&lt; <b>_Value1</b>, <b>_Hash1</b>,
           <b>_Pred1</b>, _Alloc1 &gt; &amp;)
       template&lt;<b>typename</b> , <b>typename</b> , <b>typename</b> &gt; <b>class</b> <b>std::_Hash_merge_helper</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Value,</b> <b>typename</b> <b>_Hash</b> <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b> <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b> <b>_Alloc</b> <b>=</b>
       <b>allocator&lt;_Value&gt;&gt;</b>
       class std::unordered_multiset&lt; _Value, _Hash, _Pred, _Alloc &gt;"A standard container composed of equivalent
       keys (possibly containing multiple of each key value) in which the elements' keys are the elements
       themselves.

       <b>Since</b>
           C++11

       <b>Template</b> <b>Parameters</b>
           <b>_</b><u>Value</u> Type of key objects.
           <b>_</b><u>Hash</u> Hashing function object type, defaults to hash&lt;_Value&gt;.
           <b>_</b><u>Pred</u> Predicate function object type, defaults to equal_to&lt;_Value&gt;.
           <b>_</b><u>Alloc</u> Allocator type, defaults to allocator&lt;_Key&gt;.

       Meets the requirements of a container, and unordered associative container

       Base is _Hashtable, dispatched at compile time via template alias __umset_hashtable.

</pre><h4><b>Member</b> <b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::allocator_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::allocator_type</b>
       Public typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::const_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::const_iterator</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::const_local_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::const_local_iterator</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::const_pointer</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::const_pointer</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::const_reference</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::const_reference</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::difference_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::difference_type</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::hasher</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::hasher</b>
       Public typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::iterator</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::key_equal</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::key_equal</b>
       Public typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::key_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::key_type</b>
       Public typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::local_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::local_iterator</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::pointer</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::pointer</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::reference</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::reference</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::size_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::size_type</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::value_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::value_type</b>
       Public typedefs.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multiset</b>
       <b>()</b> <b>[default]</b>
       Default constructor.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multiset</b>
       <b>(size_type</b> <b>__n,</b> <b>const</b> <b>hasher</b> <b>&amp;</b> <b>__hf</b> <b>=</b> <b>hasher(),</b> <b>const</b> <b>key_equal</b> <b>&amp;</b> <b>__eql</b> <b>=</b> <b>key_equal(),</b> <b>const</b>
       <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline],</b>  <b>[explicit]</b>
       Default constructor creates no elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> Minimal initial number of buckets.
           <b>__</b><u>hf</u> A hash functor.
           <b>__</b><u>eql</u> A key equality functor.
           <b>__</b><u>a</u> An allocator object.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>&gt;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multiset</b> <b>(_InputIterator</b> <b>__first,</b> <b>_InputIterator</b> <b>__last,</b> <b>size_type</b> <b>__n</b> <b>=</b> <b>0,</b>
       <b>const</b> <b>hasher</b> <b>&amp;</b> <b>__hf</b> <b>=</b> <b>hasher(),</b> <b>const</b> <b>key_equal</b> <b>&amp;</b> <b>__eql</b> <b>=</b> <b>key_equal(),</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b>
       <b>allocator_type())</b> <b>[inline]</b>
       Builds an unordered_multiset from a range.

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.
           <b>__</b><u>n</u> Minimal initial number of buckets.
           <b>__</b><u>hf</u> A hash functor.
           <b>__</b><u>eql</u> A key equality functor.
           <b>__</b><u>a</u> An allocator object.

       Create an unordered_multiset consisting of copies of the elements from [__first,__last). This is linear
       in N (where N is distance(__first,__last)).

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multiset</b>
       <b>(const</b> <b>unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;)</b> <b>[default]</b>
       Copy constructor.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multiset</b>
       <b>(unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;)</b> <b>[default]</b>
       Move constructor.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multiset</b>
       <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l,</b> <b>size_type</b> <b>__n</b> <b>=</b> <b>0,</b> <b>const</b> <b>hasher</b> <b>&amp;</b> <b>__hf</b> <b>=</b> <b>hasher(),</b> <b>const</b> <b>key_equal</b> <b>&amp;</b>
       <b>__eql</b> <b>=</b> <b>key_equal(),</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline]</b>
       Builds an unordered_multiset from an initializer_list.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.
           <b>__</b><u>n</u> Minimal initial number of buckets.
           <b>__</b><u>hf</u> A hash functor.
           <b>__</b><u>eql</u> A key equality functor.
           <b>__</b><u>a</u> An allocator object.

       Create an unordered_multiset consisting of copies of the elements in the list. This is linear in N (where
       N is <b>__</b><u>l.size()</u>).

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multiset</b>
       <b>(const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a)</b> <b>[inline],</b>  <b>[explicit]</b>
       Creates an unordered_multiset with no elements.

       <b>Parameters</b>
           <b>__</b><u>a</u> An allocator object.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>const_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::begin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points to the first element in the unordered_multiset.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::begin</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points to the first element in the unordered_multiset.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>local_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::begin</b> <b>(size_type</b> <b>__n)</b> <b>[inline]</b>
       Returns a read-only (constant) iterator pointing to the first bucket element.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read-only local iterator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>const_local_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::begin</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline]</b>
       Returns a read-only (constant) iterator pointing to the first bucket element.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read-only local iterator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::bucket_count</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the number of buckets of the unordered_multiset.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>const_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::cbegin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points to the first element in the unordered_multiset.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>const_local_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::cbegin</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline]</b>
       Returns a read-only (constant) iterator pointing to the first bucket element.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read-only local iterator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>const_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::cend</b>
       <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points one past the last element in the unordered_multiset.

       Referenced by <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert()</b>.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>const_local_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::cend</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline]</b>
       Returns a read-only (constant) iterator pointing to one past the last bucket elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read-only local iterator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>void</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::clear</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Erases all elements in an unordered_multiset.

       Note that this function only erases the elements, and that if the elements themselves are pointers, the
       pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::contains</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b> <b>decltype(_M_h._M_find_tr(__x),</b> <b>void(),</b> <b>true)</b>
             [inline]"

       Finds whether an element with the given key exists.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of elements to be located.

       <b>Returns</b>
           True if there is any element with the specified key.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>bool</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::contains</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Finds whether an element with the given key exists.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of elements to be located.

       <b>Returns</b>
           True if there is any element with the specified key.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::count</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b> <b>decltype(_M_h._M_count_tr(__x))</b>
             [inline]"

       Finds the number of elements.

       <b>Parameters</b>
           <b>__</b><u>x</u> Element to located.

       <b>Returns</b>
           Number of elements with specified key.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::count</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Finds the number of elements.

       <b>Parameters</b>
           <b>__</b><u>x</u> Element to located.

       <b>Returns</b>
           Number of elements with specified key.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>template&lt;typename...</b> <b>_Args&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::emplace</b> <b>(_Args</b> <b>&amp;&amp;...</b> <b>__args)</b> <b>[inline]</b>
       Builds and insert an element into the unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>args</u> Arguments used to generate an element.

       <b>Returns</b>
           An iterator that points to the inserted element.

       Insertion requires amortized constant time.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>template&lt;typename...</b> <b>_Args&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::emplace_hint</b> <b>(const_iterator</b> <b>__pos,</b> <b>_Args</b> <b>&amp;&amp;...</b> <b>__args)</b> <b>[inline]</b>
       Inserts an element into the unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>pos</u> An iterator that serves as a hint as to where the element should be inserted.
           <b>__</b><u>args</u> Arguments used to generate the element to be inserted.

       <b>Returns</b>
           An iterator that points to the inserted element.

       Note that the first parameter is only a hint and can potentially improve the performance of the insertion
       process. A bad hint would cause no gains in efficiency.

       For more on <u>hinting</u>, see:
       https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints

       Insertion requires amortized constant time.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>bool</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::empty</b> <b>()</b> <b>const</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Returns true if the unordered_multiset is empty.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>const_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::end</b>
       <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points one past the last element in the unordered_multiset.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::end</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points one past the last element in the unordered_multiset.

       Referenced by <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::extract()</b>.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>local_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::end</b>
       <b>(size_type</b> <b>__n)</b> <b>[inline]</b>
       Returns a read-only (constant) iterator pointing to one past the last bucket elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read-only local iterator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>const_local_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::end</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline]</b>
       Returns a read-only (constant) iterator pointing to one past the last bucket elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read-only local iterator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>-&gt;</b> <b>decltype(_M_h._M_equal_range_tr(__x))</b>
             [inline]"

       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Pair of iterators that possibly points to the subsequence matching given key.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b> <b>decltype(_M_h._M_equal_range_tr(__x))</b>
             [inline]"

       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Pair of iterators that possibly points to the subsequence matching given key.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>std::pair&lt;</b> <b>iterator,</b> <b>iterator</b> <b>&gt;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Pair of iterators that possibly points to the subsequence matching given key.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>std::pair&lt;</b> <b>const_iterator,</b> <b>const_iterator</b> <b>&gt;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Pair of iterators that possibly points to the subsequence matching given key.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::erase</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Erases elements according to the provided key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of element to be erased.

       <b>Returns</b>
           The number of elements erased.

       This function erases all the elements located by the given key from an unordered_multiset.

       Note that this function only erases the element, and that if the element is itself a pointer, the
       pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::erase</b>
       <b>(const_iterator</b> <b>__first,</b> <b>const_iterator</b> <b>__last)</b> <b>[inline]</b>
       Erases a [__first,__last) range of elements from an unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>first</u> Iterator pointing to the start of the range to be erased.
           <b>__</b><u>last</u> Iterator pointing to the end of the range to be erased.

       <b>Returns</b>
           The iterator <b>__</b><u>last</u>.

       This function erases a sequence of elements from an unordered_multiset.

       Note that this function only erases the element, and that if the element is itself a pointer, the
       pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::erase</b>
       <b>(const_iterator</b> <b>__position)</b> <b>[inline]</b>
       Erases an element from an unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>position</u> An iterator pointing to the element to be erased.

       <b>Returns</b>
           An iterator pointing to the element immediately following <b>__</b><u>position</u> prior to the element being
           erased. If no such element exists, end() is returned.

       This function erases an element, pointed to by the given iterator, from an unordered_multiset.

       Note that this function only erases the element, and that if the element is itself a pointer, the
       pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::erase</b>
       <b>(iterator</b> <b>__position)</b> <b>[inline]</b>
       Erases an element from an unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>position</u> An iterator pointing to the element to be erased.

       <b>Returns</b>
           An iterator pointing to the element immediately following <b>__</b><u>position</u> prior to the element being
           erased. If no such element exists, end() is returned.

       This function erases an element, pointed to by the given iterator, from an unordered_multiset.

       Note that this function only erases the element, and that if the element is itself a pointer, the
       pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>node_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::extract</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__key)</b> <b>[inline]</b>
       Extract a node.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>node_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::extract</b>
       <b>(const_iterator</b> <b>__pos)</b> <b>[inline]</b>
       Extract a node.

       References <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::find</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>-&gt;</b> <b>decltype(_M_h._M_find_tr(__x))</b>
             [inline]"

       Tries to locate an element in an unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>x</u> Element to be located.

       <b>Returns</b>
           Iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-
       the-end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b>
       <b>_Alloc</b> <b>&gt;::find</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b> <b>decltype(_M_h._M_find_tr(__x))</b>
             [inline]"

       Tries to locate an element in an unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>x</u> Element to be located.

       <b>Returns</b>
           Iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-
       the-end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::find</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Tries to locate an element in an unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>x</u> Element to be located.

       <b>Returns</b>
           Iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-
       the-end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>const_iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::find</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Tries to locate an element in an unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>x</u> Element to be located.

       <b>Returns</b>
           Iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-
       the-end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>allocator_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::get_allocator</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the allocator object used by the unordered_multiset.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>hasher</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::hash_function</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Returns the hash functor object with which the unordered_multiset was constructed.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>&gt;</b> <b>void</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(_InputIterator</b> <b>__first,</b> <b>_InputIterator</b> <b>__last)</b> <b>[inline]</b>
       A template function that inserts a range of elements.

       <b>Parameters</b>
           <b>__</b><u>first</u> Iterator pointing to the start of the range to be inserted.
           <b>__</b><u>last</u> Iterator pointing to the end of the range.

       Complexity similar to that of the range constructor.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts an element into the unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>x</u> Element to be inserted.

       <b>Returns</b>
           An iterator that points to the inserted element.

       Insertion requires amortized constant time.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(const_iterator</b> <b>__hint,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts an element into the unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>hint</u> An iterator that serves as a hint as to where the element should be inserted.
           <b>__</b><u>x</u> Element to be inserted.

       <b>Returns</b>
           An iterator that points to the inserted element.

       Note that the first parameter is only a hint and can potentially improve the performance of the insertion
       process. A bad hint would cause no gains in efficiency.

       For more on <u>hinting</u>, see:
       https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints

       Insertion requires amortized constant.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(const_iterator</b> <b>__hint,</b> <b>node_type</b> <b>&amp;&amp;</b> <b>__nh)</b> <b>[inline]</b>
       Re-insert an extracted node.

       References <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(const_iterator</b> <b>__hint,</b> <b>value_type</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts an element into the unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>hint</u> An iterator that serves as a hint as to where the element should be inserted.
           <b>__</b><u>x</u> Element to be inserted.

       <b>Returns</b>
           An iterator that points to the inserted element.

       Note that the first parameter is only a hint and can potentially improve the performance of the insertion
       process. A bad hint would cause no gains in efficiency.

       For more on <u>hinting</u>, see:
       https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints

       Insertion requires amortized constant.

       References <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>void</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l)</b> <b>[inline]</b>
       Inserts a list of elements into the unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>l</u> A std::initializer_list&lt;value_type&gt; of elements to be inserted.

       Complexity similar to that of the range constructor.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(node_type</b> <b>&amp;&amp;</b> <b>__nh)</b> <b>[inline]</b>
       Re-insert an extracted node.

       References <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::cend()</b>, and <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(value_type</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts an element into the unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>x</u> Element to be inserted.

       <b>Returns</b>
           An iterator that points to the inserted element.

       Insertion requires amortized constant time.

       References <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>key_equal</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::key_eq</b> <b>()</b>
       <b>const</b> <b>[inline]</b>
       Returns the key comparison object with which the unordered_multiset was constructed.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>float</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::load_factor</b>
       <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the average number of elements per bucket.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::max_bucket_count</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the maximum number of buckets of the unordered_multiset.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>float</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::max_load_factor</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a positive number that the unordered_multiset tries to keep the load factor less than or equal
       to.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>void</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::max_load_factor</b> <b>(float</b> <b>__z)</b> <b>[inline]</b>
       Change the unordered_multiset maximum load factor.

       <b>Parameters</b>
           <b>__</b><u>z</u> The new maximum load factor.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::max_size</b>
       <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the maximum size of the unordered_multiset.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>unordered_multiset</b> <b>&amp;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::operator=</b> <b>(const</b> <b>unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;)</b> <b>[default]</b>
       Copy assignment operator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>unordered_multiset</b> <b>&amp;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::operator=</b> <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l)</b> <b>[inline]</b>
       Unordered_multiset list assignment operator.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.

       This function fills an unordered_multiset with copies of the elements in the initializer list <b>__</b><u>l</u>.

       Note that the assignment completely changes the unordered_multiset and that the resulting
       unordered_multiset's size is the same as the number of elements assigned.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>unordered_multiset</b> <b>&amp;</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b>
       <b>&gt;::operator=</b> <b>(unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;)</b> <b>[default]</b>
       Move assignment operator.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>void</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::rehash</b>
       <b>(size_type</b> <b>__n)</b> <b>[inline]</b>
       May rehash the unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>n</u> The new number of buckets.

       Rehash will occur only if the new number of buckets respect the unordered_multiset maximum load factor.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>void</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::reserve</b>
       <b>(size_type</b> <b>__n)</b> <b>[inline]</b>
       Prepare the unordered_multiset for a specified number of elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> Number of elements required.

       Same as rehash(ceil(n / max_load_factor())).

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::size</b> <b>()</b>
       <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the size of the unordered_multiset.

   <b>template&lt;typename</b> <b>_Value</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Value&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Value&gt;,</b> <b>typename</b>
       <b>_Alloc</b>  <b>=</b> <b>allocator&lt;_Value&gt;&gt;</b> <b>void</b> <b>std::unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::swap</b>
       <b>(unordered_multiset&lt;</b> <b>_Value,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Swaps data with another unordered_multiset.

       <b>Parameters</b>
           <b>__</b><u>x</u> An unordered_multiset of the same element and allocator types.

       This exchanges the elements between two sets in constant time. Note that the global std::swap() function
       is specialized such that std::swap(s1,s2) will feed to this function.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstd<u>std::unordered_multise...</u> <b>_</b><u>Hash,</u> <b>_</b><u>Pred,</u> <b>_</b><u>Alloc</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>