<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::ECDH - Elliptic Curve Diffie-Hellman PKI, computing shared keys</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::ECDH - Elliptic Curve Diffie-Hellman PKI, computing shared keys

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/ecdh&gt;</b>
       Linking option: <u>-lbobcat</u> <u>-lcrypto</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  class  <b>FBB::ECDH</b>  computes shared keys (shared secrets) applying elliptic keys to the Diffie-Hellman
       (1976) algorithm. The Diffie-Hellman algorithm uses public and private information,  providing  a  public
       key infrastructure (PKI). The public information consists of an elliptic curve specification and a public
       key, which may be shared over insecure media.

       The  Diffie-Hellman  algorithm  is  commonly  used  to compute a shared key which is then used to encrypt
       information sent between two parties.

       One party, which in this man-page is called the <u>initiator</u>, specifies at  construction  time  an  elliptic
       curve,  constructs  a  public  and private key, and writes the public key in hexadecimal big-endian form,
       followed by the name of the used elliptic curve to  file.  The  initiator’s  private  key  is  separately
       written  to  file,  as the private key is required for computating the shared key. Encryption may be used
       when writing the private key to file.

       Next the initiator passes the file containing the initiator’s  public  key  and  the  name  of  the  used
       elliptic curve to the other party, which in this man-page is called the <u>peer</u>.

       The  peer,  having  received the initiator’s (public key) file constructs an <b>FBB::ECDH</b> object. The peer’s
       <u>ECDH</u> constructor computes the peer’s public and private key, writes the peer’s public key  to  file,  and
       constructs the shared key. Once the peer’s <u>ECDH</u> object has been constructed the peer can write the shared
       key  to  file. The peer’s private key may optionally also be written to file, but that’s optional, as the
       peer’s private key is not required for subsequent computations. Encryption may also be used when  writing
       the peer’s private key to file.

       The  file  containing the peer’s public key is then sent to the initator. The initator constructs an <u>ECDH</u>
       object specifying the names of the used elliptic curve, of the file containing  the  initiator’s  private
       key,  and  the  name  of  the  file  containing  the  peer’s  public  key. Once this <u>ECDH</u> object has been
       constructed the peer may write the shared key to file.

       The initiator and peer’s shared keys are identical and can be used for symmetric encryption of  sensitive
       information shared between the initiator and the peer.

       <u>FBB::Exception</u>s are thrown if the <u>ECDH</u> constructors  or members cannot complete their tasks.

       <b>Perfect</b> <b>Forward</b> <b>Secrecy</b> <b>and</b> <b>Ephemeral</b> <b>Diffie</b> <b>Hellman</b>

       The  initiator and peer may decide not to save their private information once they have constructed their
       shared keys, resulting in <u>Perfect</u> <u>Forward</u> <u>Secrecy</u> and <u>Ephemeral</u> <u>Diffie</u> <u>Hellman</u>. Here, this  procedure  is
       applied as follows:

       o      Initiator and peer have agreed upon and securely exchanged a long-lasting common secret, which may
              be used in combination with, e.g., symmetric encryption methods.

       o      Applying the procedure described in the previous section, the private keys are not saved on files,
              and the process constructing the initiator’s <u>ECDH</u> object may not terminate, but must remain active
              until  the  peer’s  public key has been received. Once the initiator’s process has constructed the
              public key that key is encrypted  using  the  common  secret,  and  is  then  sent  to  the  peer.
              Alternatively,  the  initiator’s  private  key  may  temporarily be stored in shared memory or may
              temporarily be stored encrypted on file.

       o      The peer, having received the initiator’s public key, constructs the shared secret,  encrypts  the
              peer’s public key, and sends the encrypted public key to the initiator.

       o      The initiator upon receipt of the peer’s public key, computes the shared key, either by continuing
              the  temporarily  suspended  construction  process  or by retrieving the shared key from memory or
              file, removing the storage (memory or file) thereafter.

       o      Since the private keys and the public keys are not stored or kept on files the shared keys  cannot
              be  reconstructed,  while  a  Man-In-The-Middle  attack  is prevented by only exchanging encrypted
              public information.

       o      The shared key can now be used to encrypt a communication session

       <b>Document</b> <b>encryption</b> <b>using</b> <b>Diffie</b> <b>Hellman</b>

       As with PKI in general, the Diffie Hellman key exchange method itself is normally not used for encrypting
       documents. Instead, it is used to obtain a key that is used for symmetric encryption methods like 3DES or
       CBC. These symmetric encryption  methods  are  available  through,  e.g.,  Bobcats’  <u>ISymCryptStream</u>  and
       <u>OSymCryptStream</u> classes.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All  constructors,  members,  operators  and manipulators, mentioned in this man-page, are defined in the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       -

</pre><h4><b>ENUMERATIONS</b></h4><pre>
       The class <u>ECDH</u> defines two enumerations, each having one defined value. The  enumberations  are  used  to
       select specific overloaded versions of the <u>ECDH</u> constructors or <u>set</u> members:

       o      The  t(enum  TheInitiator) has value <u>Initiator</u> and is used to select overloaded versions meant for
              the initiator;

       o      The t(enum ThePeer) has value <u>Peer</u> and is used to select overloaded versions meant for the peer.

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       o      <b>ECDH()</b>:
              The default constructor is available merely constructing a valid object. It also prepares a map of
              all elliptic curves predefined by <u>openSSL</u>. As  all  other  constructors  use  default  constructor
              delegation the map is also available after calling the other constructors;

       o      <b>ECDH(TheInitiator</b> <b>init,</b> <b>std::string</b> <b>const</b> <b>&amp;curveName,</b> <b>std::string</b> <b>const</b> <b>&amp;initPubFname)</b>:
              This  constructor  initializes  the  <u>ECDH</u>  object  to  be  used by the initiator, constructing the
              initiator’s private and public keys  using  the  elliptic  curve  specified  by  <u>curveName</u>  (e.g.,
              <u>secp384r1</u>,  see  also  <u>operator&lt;&lt;</u>  below).  The  initiator’s public key (in big-endian hexadecimal
              format) and <u>curveName</u> are written to <u>initPubFname</u>;

              This constructor should be called  by  the  initiator  to  start  the  Diffie-Hellman  shared  key
              computation procedure;

       o      <b>ECDH(ThePeer</b> <b>peer,</b> <b>std::string</b> <b>const</b> <b>&amp;initPubFname,</b> <b>std::string</b> <b>const</b> <b>&amp;peerPubFname)</b>:
              This  constructor  is  used  by  the peer, having received the initiator’s public info on the file
              <u>initPubFname</u>.  It constructs the peer’s private and public keys as well as  the  shared  key.  The
              peer’s  public  key  (in  big-endian hexadecimal format) is written to <u>peerPubFname</u>, which file is
              then be sent to the initiator;

       o      <b>ECDH(std::string</b>  <b>const</b>   <b>&amp;curveName,</b>   <b>std::string</b>   <b>const</b>   <b>&amp;peerPubFname,</b>   <b>std::string</b>   <b>const</b>
              <b>&amp;initSecFname,</b> <b>std::string</b> <b>const</b> <b>passphrase</b> <b>=</b> <b>"")</b>:
              Once  the initiator has received the peer’s public key (in the file <u>peerPubFname</u>) this constructor
              constructs the initiator’s version of the shared key. Here, the initiator has previously saved the
              initiator’s private key to <u>initSecFname</u>, optionally using encryption. If encryption was used  then
              the then used passphrase must also be specified when using this constructor.

       The move constructor (and move assignment operator) is available.

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       o      <b>std::string</b> <b>const</b> <b>&amp;curve()</b> <b>const</b>:
              The used elliptic curve is returned;

       o      <b>std::string</b> <b>privKey()</b> <b>const</b>:
              The big-endian hex-formatted private key is returned, prefixed by a line containing <u>hex</u>;

       o      <b>void</b> <b>privKey(std::string</b> <b>const</b> <b>&amp;privKeyFname,</b> <b>std::string</b> <b>passphrase)</b> <b>const</b>:
              The  private private key is encrypted using the <u>AES-256-GCM</u> encryption algorithm, using passphrase
              <u>passphrase</u>. It is then written to <u>privKeyFname</u>, prefixed  by  a  line  containing  <u>encrypted</u>.  The
              string <u>passphrase</u> must consist of at least five characters, and may contain multiple words;

       o      <b>std::string</b> <b>const</b> <b>&amp;pubKey()</b> <b>const</b>:
              The public key is returned as a big-endian hexadecimal string;

       o      <b>void</b> <b>set(TheInitiator</b> <b>init,</b> <b>std::string</b> <b>const</b> <b>&amp;curveName,</b> <b>std::string</b> <b>const</b> <b>&amp;initPubFname)</b>:
              This  member  should  be  called by the initiator, constructing the initiator’s private and public
              keys using the elliptic curve specified by <u>curveName</u>. The initiator’s public  key  (in  big-endian
              hexadecimal  format)  and  <u>curveName</u>  are  written  to <u>initPubFname</u>.  This member is automatically
              called by the constructor having the same parameters, but it  may  also  explicitly  called  after
              using the default constructor;

       o      <b>void</b> <b>set(ThePeer</b> <b>peer,</b> <b>std::string</b> <b>const</b> <b>&amp;initPubFname,</b> <b>std::string</b> <b>const</b> <b>&amp;peerPubFname)</b>:
              This  member should be called by the peer, having received the initiator’s public info on the file
              <u>initPubFname</u>.  It constructs the peer’s private and public keys as well as  the  shared  key.  The
              peer’s  public  key  (in  big-endian hexadecimal format) is written to <u>peerPubFname</u>, which file is
              then be sent to the initiator.  This member is automatically called by the constructor having  the
              same parameters, but it may also explicitly called after using the default constructor;

       o      <b>void</b>   <b>set(std::string</b>  <b>const</b>  <b>&amp;curveName,</b>  <b>std::string</b>  <b>const</b>  <b>&amp;peerPubFname,</b>  <b>std::string</b>  <b>const</b>
              <b>&amp;initSecFname,</b> <b>std::string</b> <b>const</b> <b>passphrase</b> <b>=</b> <b>"")</b>:
              This member should be  called  by  the  initiator,  once  the  peer’s  public  key  (in  the  file
              <u>peerPubFname</u>) has been received. It computes the initiator’s version of the shared key. When using
              this  member  the  initiator  has  previously  saved  the initiator’s private key to <u>initSecFname</u>,
              optionally using encryption. If encryption was used then the then used  passphrase  must  also  be
              specified as this member’s last argument.

       o      <b>std::string</b> <b>const</b> <b>&amp;sharedKey()</b> <b>const</b>:
              This member returns the computed shared key (in big-endian hexadecimal format);

       o      <b>std::string</b> <b>const</b> <b>&amp;sharedKey(std::string</b> <b>const</b> <b>&amp;peerPubFname)</b>:
              Instead  of  using the <u>set(std::string</u> <u>const</u> <u>&amp;curveName,</u> <u>...)</u> member or the <u>ECDH(std::string</u> <u>const</u>
              <u>&amp;curveName,</u> <u>...)</u> constructor, the initiator may also merely call the <u>set(TheInitiator</u>  <u>init,</u>  <u>...)</u>
              member  or  the <u>ECDH(TheInitiator</u> <u>init,</u> <u>...)</u> constructor, suspending the process in which they are
              called until the file containing the peer’s public key has been received. Then, this member can be
              called by the constructed <u>ECDH</u> object to obtain the initiator’s shared key. The advantage of using
              this member is that the initiator does not have to save the initiator’s private key.

</pre><h4><b>OVERLOADED</b> <b>OPERATOR</b></h4><pre>
       o      <b>std::ostream</b> <b>&amp;operator&lt;&lt;(ostream</b> <b>&amp;out,</b> <b>ECDH</b> <b>const</b> <b>&amp;ecdh)</b>:
              The (alphabetically ordered) currently available elliptic curves and their associated  comment  is
              written to <u>out</u>, one elliptic curve on a separate line.

</pre><h4><b>EXAMPLE</b></h4><pre>
       Start the program with one of the following arguments:

       o      curves: show the available elliptic curves on <u>cout</u>;

       o      init: compute the initiator’s public/secret keys writing them to <u>init.pub</u> and <u>init.sec</u>;

       o      peer:  compute  the  peer’s  public/secret keys writing them to <u>peer.pub</u> and <u>peer.sec</u>, compute the
              peer’s shared key (<u>peer.shared</u>);

       o      priv: compute the initiator’s shared key  (<u>init.shared</u>)  after  making  <u>peer.pub</u>  available  in  a
              separate process, using a single initiator process.

       o      shared: compute the initiator’s shared key (<u>init.shared</u>) using a separate initiator process.

       #include "main.ih"

       int main(int argc, char **argv)
       try
       {
           if (argc == 1)
           {
               usage(path{ argv[0] }.filename().string());
               return 0;
           }

           if ("curves"s == argv[1])           // show supported ECDH curves.
               cout &lt;&lt; ECDH{};

           else if ("init"s == argv[1])        // initiator key construction
           {
                                               // write the file containing
                                               // the curve + public key
               ECDH ecdh{ ECDH::Initiator, "secp384r1", "init.pub" };

                                               // save the initiator’s
                                              // private key
               ecdh.privKey("init.sec", "use your passphrase");
                   // not using encryption:
                   // auto initSec = Exception::factory&lt;ofstream&gt;("init.sec");
                   // initSec &lt;&lt; ecdh.privKey() &lt;&lt; ’\n’;
           }

           else if ("priv"s == argv[1])        // initiator key construction
           {
                                               // write the file containing
                                               // the curve + public key
               ECDH ecdh{ ECDH::Initiator, "secp384r1", "init.pub" };

               cout &lt;&lt; "wait for the peer’s public key. "
                       "Press Enter to continue... ";
               cin.ignore(100, ’\n’);
                                                           // written to file
               auto initShared = Exception::factory&lt;ofstream&gt;("init.shared");
               initShared &lt;&lt; ecdh.sharedKey("peer.pub") &lt;&lt; ’\n’;
           }

           else if ("peer"s == argv[1])        // peer’s key construction
           {
                                               // write the peer’s public key
               ECDH ecdh{ ECDH::Peer, "init.pub", "peer.pub" };

                                               // save the peer’s private
                                               // key (although not needed)
               auto out = Exception::factory&lt;ofstream&gt;("peer.sec");
               out &lt;&lt; ecdh.privKey() &lt;&lt; ’\n’;

               out = Exception::factory&lt;ofstream&gt;("peer.shared");
               out &lt;&lt; ecdh.sharedKey() &lt;&lt; ’\n’;
           }

           else if ("shared"s == argv[1])      // the initiator’s shared key
           {                                   // construction
               ECDH ecdh{ "secp384r1", "peer.pub", "init.sec",
                                                   "use your passphrase" };

               auto initShared = Exception::factory&lt;ofstream&gt;("init.shared");
               initShared &lt;&lt; ecdh.sharedKey() &lt;&lt; ’\n’;     // written to file
           }

           else
           {
               usage(path{ argv[0] }.filename().string());
               return 1;
           }
       }
       catch (exception const &amp;exc)
       {
           cerr &lt;&lt; "Error: " &lt;&lt; exc.what() &lt;&lt; ’\n’;
           return 1;
       }
       catch (...)                     // and handle an unexpected exception
       {
           cerr &lt;&lt; "unexpected exception\n";
           return 1;
       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/ecdh</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7), <b><a href="../man3bobcat/bigint.3bobcat.html">bigint</a></b>(3bobcat), <b><a href="../man3bobcat/diffiehellman.3bobcat.html">diffiehellman</a></b>(3bobcat), <b><a href="../man3bobcat/isymcryptstream.3bobcat.html">isymcryptstream</a></b>(3bobcat), <b><a href="../man3bobcat/osymcryptstream.3bobcat.html">osymcryptstream</a></b>(3bobcat)

</pre><h4><b>BUGS</b></h4><pre>
       None Reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>:  debian package containing the static library, headers, manual pages, and developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                                 <u>FBB::<a href="../man3bobcat/ECDH.3bobcat.html">ECDH</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>