<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc > - A standard container composed of equivalent</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::unordered_multimap&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; - A standard container composed of equivalent
       keys (possibly containing multiple of each key value) that associates values of another type with the
       keys.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;unordered_map&gt;

   <b>Public</b> <b>Types</b>
       <b>using</b> <b>node_type</b> = <b>typename</b> _Hashtable::node_type

           <b>typedef</b> _Hashtable::key_type <b>key_type</b>
               Public typedefs.
           <b>typedef</b> _Hashtable::value_type <b>value_type</b>
               Public typedefs.
           <b>typedef</b> _Hashtable::mapped_type <b>mapped_type</b>
               Public typedefs.
           <b>typedef</b> _Hashtable::hasher <b>hasher</b>
               Public typedefs.
           <b>typedef</b> _Hashtable::key_equal <b>key_equal</b>
               Public typedefs.
           <b>typedef</b> _Hashtable::allocator_type <b>allocator_type</b>
               Public typedefs.

           <b>typedef</b> _Hashtable::pointer <b>pointer</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::const_pointer <b>const_pointer</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::reference <b>reference</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::const_reference <b>const_reference</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::iterator <b>iterator</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::const_iterator <b>const_iterator</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::local_iterator <b>local_iterator</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::const_local_iterator <b>const_local_iterator</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::size_type <b>size_type</b>
               Iterator-related typedefs.
           <b>typedef</b> _Hashtable::difference_type <b>difference_type</b>
               Iterator-related typedefs.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>unordered_multimap</b> ()=<b>default</b>
           Default constructor.
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>unordered_multimap</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           <b>size_type</b> __n, const <b>allocator_type</b> &amp;__a)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>unordered_multimap</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           <b>size_type</b> __n, const <b>hasher</b> &amp;<b>__hf</b>, const <b>allocator_type</b> &amp;__a)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>unordered_multimap</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           <b>size_type</b> __n=0, const <b>hasher</b> &amp;<b>__hf</b>=<b>hasher</b>(), const <b>key_equal</b> &amp;<b>__eql</b>=<b>key_equal</b>(), const
           <b>allocator_type</b> &amp;__a=<b>allocator_type</b>())
           Builds an unordered_multimap from a range.
       <b>unordered_multimap</b> (const <b>allocator_type</b> &amp;__a)
           Creates an unordered_multimap with no elements.
       <b>unordered_multimap</b> (const <b>unordered_multimap</b> &amp;)=<b>default</b>
           Copy constructor.
       <b>unordered_multimap</b> (const <b>unordered_multimap</b> &amp;<b>__ummap</b>, const <b>allocator_type</b> &amp;__a)
       <b>unordered_multimap</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>, <b>size_type</b> __n, const <b>allocator_type</b> &amp;__a)
       <b>unordered_multimap</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>, <b>size_type</b> __n, const <b>hasher</b> &amp;<b>__hf</b>, const
           <b>allocator_type</b> &amp;__a)
       <b>unordered_multimap</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>, <b>size_type</b> __n=0, const <b>hasher</b> &amp;<b>__hf</b>=<b>hasher</b>(),
           const <b>key_equal</b> &amp;<b>__eql</b>=<b>key_equal</b>(), const <b>allocator_type</b> &amp;__a=<b>allocator_type</b>())
           Builds an unordered_multimap from an initializer_list.
       <b>unordered_multimap</b> (<b>size_type</b> __n, const <b>allocator_type</b> &amp;__a)
       <b>unordered_multimap</b> (<b>size_type</b> __n, const <b>hasher</b> &amp;<b>__hf</b>, const <b>allocator_type</b> &amp;__a)
       <b>unordered_multimap</b> (<b>size_type</b> __n, const <b>hasher</b> &amp;<b>__hf</b>=<b>hasher</b>(), const <b>key_equal</b> &amp;<b>__eql</b>=<b>key_equal</b>(), const
           <b>allocator_type</b> &amp;__a=<b>allocator_type</b>())
           Default constructor creates no elements.
       <b>unordered_multimap</b> (<b>unordered_multimap</b> &amp;&amp;)=<b>default</b>
           Move constructor.
       <b>unordered_multimap</b> (<b>unordered_multimap</b> &amp;&amp;<b>__ummap</b>, const <b>allocator_type</b> &amp;__a)
           noexcept(noexcept(<b>_Hashtable</b>(<b>std::move</b>(__ummap._M_h), __a)))
       <b>iterator</b> <b>begin</b> () noexcept
       <b>local_iterator</b> <b>begin</b> (<b>size_type</b> __n)
           Returns a read/write iterator pointing to the first bucket element.
       <b>size_type</b> <b>bucket</b> (const <b>key_type</b> &amp;<b>__key</b>) const
       <b>size_type</b> <b>bucket_count</b> () const noexcept
           Returns the number of buckets of the unordered_multimap.
       <b>size_type</b> <b>bucket_size</b> (<b>size_type</b> __n) const
       <b>void</b> <b>clear</b> () noexcept
       template&lt;typename... _Args&gt; <b>iterator</b> <b>emplace</b> (<b>_Args</b> &amp;&amp;... <b>__args</b>)
           Attempts to build and insert a std::pair into the unordered_multimap.
       template&lt;typename... _Args&gt; <b>iterator</b> <b>emplace_hint</b> (<b>const_iterator</b> <b>__pos</b>, <b>_Args</b> &amp;&amp;... <b>__args</b>)
           Attempts to build and insert a std::pair into the unordered_multimap.
       bool <b>empty</b> () const noexcept
           Returns true if the unordered_multimap is empty.
       <b>iterator</b> <b>end</b> () noexcept
       <b>local_iterator</b> <b>end</b> (<b>size_type</b> __n)
           Returns a read/write iterator pointing to one past the last bucket elements.
       <b>size_type</b> <b>erase</b> (const <b>key_type</b> &amp;__x)
           Erases elements according to the provided key.
       <b>iterator</b> <b>erase</b> (<b>const_iterator</b> __first, <b>const_iterator</b> __last)
           Erases a [__first,__last) range of elements from an unordered_multimap.
       node_type <b>extract</b> (const <b>key_type</b> &amp;<b>__key</b>)
           Extract a node.
       node_type <b>extract</b> (<b>const_iterator</b> <b>__pos</b>)
           Extract a node.
       <b>allocator_type</b> <b>get_allocator</b> () const noexcept
           Returns the allocator object used by the unordered_multimap.
       <b>hasher</b> <b>hash_function</b> () const
           Returns the hash functor object with which the unordered_multimap was constructed.
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>void</b> <b>insert</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last)
           A template function that attempts to insert a range of elements.
       <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__hint</b>, node_type &amp;&amp;<b>__nh</b>)
           Re-insert an extracted node.
       <b>void</b> <b>insert</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>)
           Attempts to insert a list of elements into the unordered_multimap.
       <b>iterator</b> <b>insert</b> (node_type &amp;&amp;<b>__nh</b>)
           Re-insert an extracted node.
       <b>key_equal</b> <b>key_eq</b> () const
           Returns the key comparison object with which the unordered_multimap was constructed.
       float <b>load_factor</b> () const noexcept
           Returns the average number of elements per bucket.
       <b>size_type</b> <b>max_bucket_count</b> () const noexcept
           Returns the maximum number of buckets of the unordered_multimap.
       float <b>max_load_factor</b> () const noexcept
           Returns a positive number that the unordered_multimap tries to keep the load factor less than or
           equal to.
       <b>void</b> <b>max_load_factor</b> (float <b>__z</b>)
           Change the unordered_multimap maximum load factor.
       <b>size_type</b> <b>max_size</b> () const noexcept
           Returns the maximum size of the unordered_multimap.
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_map</b>&lt; <b>_Key</b>, _Tp, <b>_H2</b>, <b>_P2</b>, _Alloc &gt;
           &amp;&amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_map</b>&lt; <b>_Key</b>, _Tp, <b>_H2</b>, <b>_P2</b>, _Alloc &gt;
           &amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_multimap</b>&lt; <b>_Key</b>, _Tp, <b>_H2</b>, <b>_P2</b>, _Alloc &gt;
           &amp;&amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_H2</b> , <b>typename</b> <b>_P2</b> &gt; <b>void</b> <b>merge</b> (<b>unordered_multimap</b>&lt; <b>_Key</b>, _Tp, <b>_H2</b>, <b>_P2</b>, _Alloc &gt;
           &amp;<b>__source</b>)
       <b>unordered_multimap</b> &amp; <b>operator=</b> (const <b>unordered_multimap</b> &amp;)=<b>default</b>
           Copy assignment operator.
       <b>unordered_multimap</b> &amp; <b>operator=</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>)
           Unordered_multimap list assignment operator.
       <b>unordered_multimap</b> &amp; <b>operator=</b> (<b>unordered_multimap</b> &amp;&amp;)=<b>default</b>
           Move assignment operator.
       <b>void</b> <b>rehash</b> (<b>size_type</b> __n)
           May rehash the unordered_multimap.
       <b>void</b> <b>reserve</b> (<b>size_type</b> __n)
           Prepare the unordered_multimap for a specified number of elements.
       <b>size_type</b> <b>size</b> () const noexcept
           Returns the size of the unordered_multimap.
       <b>void</b> <b>swap</b> (<b>unordered_multimap</b> &amp;__x) noexcept(noexcept(_M_h.swap(__x._M_h)))
           Swaps data with another unordered_multimap.

           <b>const_iterator</b> <b>begin</b> () const noexcept
           <b>const_iterator</b> <b>cbegin</b> () const noexcept

           <b>const_iterator</b> <b>end</b> () const noexcept
           <b>const_iterator</b> <b>cend</b> () const noexcept

           <b>iterator</b> <b>insert</b> (const <b>value_type</b> &amp;__x)
               Inserts a std::pair into the unordered_multimap.
           <b>iterator</b> <b>insert</b> (<b>value_type</b> &amp;&amp;__x)
               Inserts a std::pair into the unordered_multimap.
           template&lt;<b>typename</b> <b>_Pair</b> &gt; __enable_if_t&lt; <b>is_constructible</b>&lt; <b>value_type</b>, <b>_Pair</b> &amp;&amp; &gt;::value, <b>iterator</b> &gt;
               <b>insert</b> (<b>_Pair</b> &amp;&amp;__x)
               Inserts a std::pair into the unordered_multimap.

           <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__hint</b>, const <b>value_type</b> &amp;__x)
               Inserts a std::pair into the unordered_multimap.
           <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__hint</b>, <b>value_type</b> &amp;&amp;__x)
               Inserts a std::pair into the unordered_multimap.
           template&lt;<b>typename</b> <b>_Pair</b> &gt; __enable_if_t&lt; <b>is_constructible</b>&lt; <b>value_type</b>, <b>_Pair</b> &amp;&amp; &gt;::value, <b>iterator</b> &gt;
               <b>insert</b> (<b>const_iterator</b> <b>__hint</b>, <b>_Pair</b> &amp;&amp;__x)
               Inserts a std::pair into the unordered_multimap.

           <b>iterator</b> <b>erase</b> (<b>const_iterator</b> <b>__position</b>)
               Erases an element from an unordered_multimap.
           <b>iterator</b> <b>erase</b> (<b>iterator</b> <b>__position</b>)
               Erases an element from an unordered_multimap.

           <b>iterator</b> <b>find</b> (const <b>key_type</b> &amp;__x)
               Tries to locate an element in an unordered_multimap.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>find</b> (const <b>_Kt</b> &amp;__x) -&gt; <b>decltype</b>(_M_h._M_find_tr(__x))
               Tries to locate an element in an unordered_multimap.
           <b>const_iterator</b> <b>find</b> (const <b>key_type</b> &amp;__x) const
               Tries to locate an element in an unordered_multimap.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>find</b> (const <b>_Kt</b> &amp;__x) const -&gt; <b>decltype</b>(_M_h._M_find_tr(__x))
               Tries to locate an element in an unordered_multimap.

           <b>size_type</b> <b>count</b> (const <b>key_type</b> &amp;__x) const
               Finds the number of elements.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>count</b> (const <b>_Kt</b> &amp;__x) const -&gt; <b>decltype</b>(_M_h._M_count_tr(__x))
               Finds the number of elements.

           bool <b>contains</b> (const <b>key_type</b> &amp;__x) const
               Finds whether an element with the given key exists.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>contains</b> (const <b>_Kt</b> &amp;__x) const -&gt; <b>decltype</b>(_M_h._M_find_tr(__x),
               <b>void</b>(), <b>true</b>)
               Finds whether an element with the given key exists.

           <b>std::pair</b>&lt; <b>iterator</b>, <b>iterator</b> &gt; <b>equal_range</b> (const <b>key_type</b> &amp;__x)
               Finds a subsequence matching given key.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>equal_range</b> (const <b>_Kt</b> &amp;__x) -&gt; <b>decltype</b>(_M_h._M_equal_range_tr(__x))
               Finds a subsequence matching given key.
           <b>std::pair</b>&lt; <b>const_iterator</b>, <b>const_iterator</b> &gt; <b>equal_range</b> (const <b>key_type</b> &amp;__x) const
               Finds a subsequence matching given key.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>equal_range</b> (const <b>_Kt</b> &amp;__x) const -&gt;
               <b>decltype</b>(_M_h._M_equal_range_tr(__x))
               Finds a subsequence matching given key.

           <b>const_local_iterator</b> <b>begin</b> (<b>size_type</b> __n) const
               Returns a read-only (constant) iterator pointing to the first bucket element.
           <b>const_local_iterator</b> <b>cbegin</b> (<b>size_type</b> __n) const
               Returns a read-only (constant) iterator pointing to the first bucket element.

           <b>const_local_iterator</b> <b>end</b> (<b>size_type</b> __n) const
               Returns a read-only (constant) iterator pointing to one past the last bucket elements.
           <b>const_local_iterator</b> <b>cend</b> (<b>size_type</b> __n) const
               Returns a read-only (constant) iterator pointing to one past the last bucket elements.

   <b>Friends</b>
       template&lt;<b>typename</b> <b>_Key1</b> , <b>typename</b> <b>_Tp1</b> , <b>typename</b> <b>_Hash1</b> , <b>typename</b> <b>_Pred1</b> , <b>typename</b> _Alloc1 &gt; bool
           <b>operator==</b> (const <b>unordered_multimap</b>&lt; <b>_Key1</b>, <b>_Tp1</b>, <b>_Hash1</b>, <b>_Pred1</b>, _Alloc1 &gt; &amp;, const
           <b>unordered_multimap</b>&lt; <b>_Key1</b>, <b>_Tp1</b>, <b>_Hash1</b>, <b>_Pred1</b>, _Alloc1 &gt; &amp;)
       template&lt;<b>typename</b> , <b>typename</b> , <b>typename</b> &gt; <b>class</b> <b>std::_Hash_merge_helper</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Key,</b> <b>typename</b> <b>_Tp,</b> <b>typename</b> <b>_Hash</b> <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b> <b>=</b> <b>equal_to&lt;_Key&gt;,</b> <b>typename</b>
       <b>_Alloc</b> <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b>
       class std::unordered_multimap&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;"A standard container composed of
       equivalent keys (possibly containing multiple of each key value) that associates values of another type
       with the keys.

       <b>Since</b>
           C++11

       <b>Template</b> <b>Parameters</b>
           <b>_</b><u>Key</u> Type of key objects.
           <b>_</b><u>Tp</u> Type of mapped objects.
           <b>_</b><u>Hash</u> Hashing function object type, defaults to hash&lt;_Value&gt;.
           <b>_</b><u>Pred</u> Predicate function object type, defaults to equal_to&lt;_Value&gt;.
           <b>_</b><u>Alloc</u> Allocator type, defaults to std::allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;.

       Meets the requirements of a container, and unordered associative container

       The resulting value type of the container is std::pair&lt;const _Key, _Tp&gt;.

       Base is _Hashtable, dispatched at compile time via template alias __ummap_hashtable.

</pre><h4><b>Member</b> <b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::allocator_type</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::allocator_type</b>
       Public typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::const_iterator</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::const_iterator</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::const_local_iterator</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::const_local_iterator</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::const_pointer</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::const_pointer</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::const_reference</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::const_reference</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::difference_type</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::difference_type</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::hasher</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::hasher</b>
       Public typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::iterator</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::iterator</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::key_equal</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::key_equal</b>
       Public typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::key_type</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::key_type</b>
       Public typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::local_iterator</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::local_iterator</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::mapped_type</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::mapped_type</b>
       Public typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::pointer</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::pointer</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::reference</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::reference</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::size_type</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::size_type</b>
       Iterator-related typedefs.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>typedef</b> <b>_Hashtable::value_type</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::value_type</b>
       Public typedefs.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multimap</b> <b>()</b> <b>[default]</b>
       Default constructor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multimap</b> <b>(size_type</b> <b>__n,</b> <b>const</b> <b>hasher</b> <b>&amp;</b> <b>__hf</b> <b>=</b> <b>hasher(),</b> <b>const</b> <b>key_equal</b> <b>&amp;</b>
       <b>__eql</b> <b>=</b> <b>key_equal(),</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline],</b>  <b>[explicit]</b>
       Default constructor creates no elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> Mnimal initial number of buckets.
           <b>__</b><u>hf</u> A hash functor.
           <b>__</b><u>eql</u> A key equality functor.
           <b>__</b><u>a</u> An allocator object.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>&gt;</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multimap</b> <b>(_InputIterator</b> <b>__first,</b>
       <b>_InputIterator</b> <b>__last,</b> <b>size_type</b> <b>__n</b> <b>=</b> <b>0,</b> <b>const</b> <b>hasher</b> <b>&amp;</b> <b>__hf</b> <b>=</b> <b>hasher(),</b> <b>const</b> <b>key_equal</b> <b>&amp;</b> <b>__eql</b> <b>=</b>
       <b>key_equal(),</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline]</b>
       Builds an unordered_multimap from a range.

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.
           <b>__</b><u>n</u> Minimal initial number of buckets.
           <b>__</b><u>hf</u> A hash functor.
           <b>__</b><u>eql</u> A key equality functor.
           <b>__</b><u>a</u> An allocator object.

       Create an unordered_multimap consisting of copies of the elements from [__first,__last). This is linear
       in N (where N is distance(__first,__last)).

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multimap</b> <b>(const</b> <b>unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;)</b>
       <b>[default]</b>
       Copy constructor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multimap</b> <b>(unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;)</b> <b>[default]</b>
       Move constructor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multimap</b> <b>(const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a)</b> <b>[inline],</b>  <b>[explicit]</b>
       Creates an unordered_multimap with no elements.

       <b>Parameters</b>
           <b>__</b><u>a</u> An allocator object.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::unordered_multimap</b> <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l,</b> <b>size_type</b> <b>__n</b> <b>=</b> <b>0,</b> <b>const</b> <b>hasher</b>
       <b>&amp;</b> <b>__hf</b> <b>=</b> <b>hasher(),</b> <b>const</b> <b>key_equal</b> <b>&amp;</b> <b>__eql</b> <b>=</b> <b>key_equal(),</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b>
       <b>[inline]</b>
       Builds an unordered_multimap from an initializer_list.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.
           <b>__</b><u>n</u> Minimal initial number of buckets.
           <b>__</b><u>hf</u> A hash functor.
           <b>__</b><u>eql</u> A key equality functor.
           <b>__</b><u>a</u> An allocator object.

       Create an unordered_multimap consisting of copies of the elements in the list. This is linear in N (where
       N is <b>__</b><u>l.size()</u>).

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>const_iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::begin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points to the first element in the unordered_multimap.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::begin</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write iterator that points to the first element in the unordered_multimap.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>local_iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::begin</b> <b>(size_type</b> <b>__n)</b> <b>[inline]</b>
       Returns a read/write iterator pointing to the first bucket element.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read/write local iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>const_local_iterator</b> <b>std::unordered_multimap&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::begin</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline]</b>
       Returns a read-only (constant) iterator pointing to the first bucket element.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read-only local iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::bucket_count</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the number of buckets of the unordered_multimap.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>const_iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::cbegin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points to the first element in the unordered_multimap.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>const_local_iterator</b> <b>std::unordered_multimap&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::cbegin</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline]</b>
       Returns a read-only (constant) iterator pointing to the first bucket element.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read-only local iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>const_iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::cend</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points one past the last element in the unordered_multimap.

       Referenced by <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>const_local_iterator</b> <b>std::unordered_multimap&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::cend</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline]</b>
       Returns a read-only (constant) iterator pointing to one past the last bucket elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read-only local iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>void</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::clear</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       Erases all elements in an unordered_multimap. Note that this function only erases the elements, and that
       if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the
       pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::contains</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b>
       <b>decltype(_M_h._M_find_tr(__x),</b> <b>void(),</b> <b>true)</b>
             [inline]"

       Finds whether an element with the given key exists.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of elements to be located.

       <b>Returns</b>
           True if there is any element with the specified key.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>bool</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::contains</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Finds whether an element with the given key exists.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of elements to be located.

       <b>Returns</b>
           True if there is any element with the specified key.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::count</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b>
       <b>decltype(_M_h._M_count_tr(__x))</b>
             [inline]"

       Finds the number of elements.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to count.

       <b>Returns</b>
           Number of elements with specified key.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::count</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Finds the number of elements.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to count.

       <b>Returns</b>
           Number of elements with specified key.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename...</b> <b>_Args&gt;</b> <b>iterator</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::emplace</b> <b>(_Args</b> <b>&amp;&amp;...</b> <b>__args)</b> <b>[inline]</b>
       Attempts to build and insert a std::pair into the unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>args</u> Arguments used to generate a new pair instance (see std::piecewise_contruct for passing
           arguments to each part of the pair constructor).

       <b>Returns</b>
           An iterator that points to the inserted pair.

       This function attempts to build and insert a (key, value) pair into the unordered_multimap.

       Insertion requires amortized constant time.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename...</b> <b>_Args&gt;</b> <b>iterator</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::emplace_hint</b> <b>(const_iterator</b> <b>__pos,</b> <b>_Args</b>
       <b>&amp;&amp;...</b> <b>__args)</b> <b>[inline]</b>
       Attempts to build and insert a std::pair into the unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>pos</u> An iterator that serves as a hint as to where the pair should be inserted.
           <b>__</b><u>args</u> Arguments used to generate a new pair instance (see std::piecewise_contruct for passing
           arguments to each part of the pair constructor).

       <b>Returns</b>
           An iterator that points to the element with key of the std::pair built from <b>__</b><u>args</u>.

       Note that the first parameter is only a hint and can potentially improve the performance of the insertion
       process. A bad hint would cause no gains in efficiency.

       See https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       for more on <u>hinting</u>.

       Insertion requires amortized constant time.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>bool</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::empty</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns true if the unordered_multimap is empty.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>const_iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::end</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points one past the last element in the unordered_multimap.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::end</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write iterator that points one past the last element in the unordered_multimap.

       Referenced by <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::extract()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>local_iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::end</b> <b>(size_type</b> <b>__n)</b> <b>[inline]</b>
       Returns a read/write iterator pointing to one past the last bucket elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read/write local iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>const_local_iterator</b> <b>std::unordered_multimap&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::end</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline]</b>
       Returns a read-only (constant) iterator pointing to one past the last bucket elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> The bucket index.

       <b>Returns</b>
           A read-only local iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>-&gt;</b>
       <b>decltype(_M_h._M_equal_range_tr(__x))</b>
             [inline]"

       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Pair of iterators that possibly points to the subsequence matching given key.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b>
       <b>decltype(_M_h._M_equal_range_tr(__x))</b>
             [inline]"

       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Pair of iterators that possibly points to the subsequence matching given key.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>std::pair&lt;</b> <b>iterator,</b> <b>iterator</b> <b>&gt;</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Pair of iterators that possibly points to the subsequence matching given key.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>std::pair&lt;</b> <b>const_iterator,</b> <b>const_iterator</b> <b>&gt;</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b>
       <b>[inline]</b>
       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Pair of iterators that possibly points to the subsequence matching given key.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::erase</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Erases elements according to the provided key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of elements to be erased.

       <b>Returns</b>
           The number of elements erased.

       This function erases all the elements located by the given key from an unordered_multimap. Note that this
       function only erases the element, and that if the element is itself a pointer, the pointed-to memory is
       not touched in any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::erase</b> <b>(const_iterator</b> <b>__first,</b> <b>const_iterator</b> <b>__last)</b> <b>[inline]</b>
       Erases a [__first,__last) range of elements from an unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>first</u> Iterator pointing to the start of the range to be erased.
           <b>__</b><u>last</u> Iterator pointing to the end of the range to be erased.

       <b>Returns</b>
           The iterator <b>__</b><u>last</u>.

       This function erases a sequence of elements from an unordered_multimap. Note that this function only
       erases the elements, and that if the element is itself a pointer, the pointed-to memory is not touched in
       any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::erase</b> <b>(const_iterator</b> <b>__position)</b> <b>[inline]</b>
       Erases an element from an unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>position</u> An iterator pointing to the element to be erased.

       <b>Returns</b>
           An iterator pointing to the element immediately following <b>__</b><u>position</u> prior to the element being
           erased. If no such element exists, end() is returned.

       This function erases an element, pointed to by the given iterator, from an unordered_multimap. Note that
       this function only erases the element, and that if the element is itself a pointer, the pointed-to memory
       is not touched in any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::erase</b> <b>(iterator</b> <b>__position)</b> <b>[inline]</b>
       Erases an element from an unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>position</u> An iterator pointing to the element to be erased.

       <b>Returns</b>
           An iterator pointing to the element immediately following <b>__</b><u>position</u> prior to the element being
           erased. If no such element exists, end() is returned.

       This function erases an element, pointed to by the given iterator, from an unordered_multimap. Note that
       this function only erases the element, and that if the element is itself a pointer, the pointed-to memory
       is not touched in any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>node_type</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::extract</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__key)</b> <b>[inline]</b>
       Extract a node.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>node_type</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::extract</b> <b>(const_iterator</b> <b>__pos)</b> <b>[inline]</b>
       Extract a node.

       References <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::find</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>-&gt;</b>
       <b>decltype(_M_h._M_find_tr(__x))</b>
             [inline]"

       Tries to locate an element in an unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-
       the-end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::find</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b>
       <b>decltype(_M_h._M_find_tr(__x))</b>
             [inline]"

       Tries to locate an element in an unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-
       the-end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::find</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Tries to locate an element in an unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-
       the-end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>const_iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::find</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Tries to locate an element in an unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key to be located.

       <b>Returns</b>
           Iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-
       the-end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>allocator_type</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::get_allocator</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the allocator object used by the unordered_multimap.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>hasher</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::hash_function</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Returns the hash functor object with which the unordered_multimap was constructed.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>&gt;</b> <b>void</b>
       <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(_InputIterator</b> <b>__first,</b>
       <b>_InputIterator</b> <b>__last)</b> <b>[inline]</b>
       A template function that attempts to insert a range of elements.

       <b>Parameters</b>
           <b>__</b><u>first</u> Iterator pointing to the start of the range to be inserted.
           <b>__</b><u>last</u> Iterator pointing to the end of the range.

       Complexity similar to that of the range constructor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename</b> <b>_Pair</b> <b>&gt;</b> <b>__enable_if_t&lt;</b>
       <b>is_constructible&lt;</b> <b>value_type,</b> <b>_Pair</b> <b>&amp;&amp;</b> <b>&gt;::value,</b> <b>iterator</b> <b>&gt;</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(_Pair</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts a std::pair into the unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           An iterator that points to the inserted pair.

       Insertion requires amortized constant time.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts a std::pair into the unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           An iterator that points to the inserted pair.

       Insertion requires amortized constant time.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>template&lt;typename</b> <b>_Pair</b> <b>&gt;</b> <b>__enable_if_t&lt;</b>
       <b>is_constructible&lt;</b> <b>value_type,</b> <b>_Pair</b> <b>&amp;&amp;</b> <b>&gt;::value,</b> <b>iterator</b> <b>&gt;</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(const_iterator</b> <b>__hint,</b> <b>_Pair</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts a std::pair into the unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>hint</u> An iterator that serves as a hint as to where the pair should be inserted.
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           An iterator that points to the element with key of <b>__</b><u>x</u> (may or may not be the pair passed in).

       Note that the first parameter is only a hint and can potentially improve the performance of the insertion
       process. A bad hint would cause no gains in efficiency.

       See https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       for more on <u>hinting</u>.

       Insertion requires amortized constant time.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(const_iterator</b> <b>__hint,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts a std::pair into the unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>hint</u> An iterator that serves as a hint as to where the pair should be inserted.
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           An iterator that points to the element with key of <b>__</b><u>x</u> (may or may not be the pair passed in).

       Note that the first parameter is only a hint and can potentially improve the performance of the insertion
       process. A bad hint would cause no gains in efficiency.

       See https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       for more on <u>hinting</u>.

       Insertion requires amortized constant time.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(const_iterator</b> <b>__hint,</b> <b>node_type</b> <b>&amp;&amp;</b> <b>__nh)</b> <b>[inline]</b>
       Re-insert an extracted node.

       References <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(const_iterator</b> <b>__hint,</b> <b>value_type</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts a std::pair into the unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>hint</u> An iterator that serves as a hint as to where the pair should be inserted.
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           An iterator that points to the element with key of <b>__</b><u>x</u> (may or may not be the pair passed in).

       Note that the first parameter is only a hint and can potentially improve the performance of the insertion
       process. A bad hint would cause no gains in efficiency.

       See https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       for more on <u>hinting</u>.

       Insertion requires amortized constant time.

       References <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>void</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l)</b> <b>[inline]</b>
       Attempts to insert a list of elements into the unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>l</u> A std::initializer_list&lt;value_type&gt; of elements to be inserted.

       Complexity similar to that of the range constructor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(node_type</b> <b>&amp;&amp;</b> <b>__nh)</b> <b>[inline]</b>
       Re-insert an extracted node.

       References <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::cend()</b>, and <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>iterator</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(value_type</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline]</b>
       Inserts a std::pair into the unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           An iterator that points to the inserted pair.

       Insertion requires amortized constant time.

       References <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>key_equal</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::key_eq</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Returns the key comparison object with which the unordered_multimap was constructed.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>float</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::load_factor</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the average number of elements per bucket.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::max_bucket_count</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the maximum number of buckets of the unordered_multimap.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>float</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::max_load_factor</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a positive number that the unordered_multimap tries to keep the load factor less than or equal
       to.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>void</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::max_load_factor</b> <b>(float</b> <b>__z)</b> <b>[inline]</b>
       Change the unordered_multimap maximum load factor.

       <b>Parameters</b>
           <b>__</b><u>z</u> The new maximum load factor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::max_size</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the maximum size of the unordered_multimap.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>unordered_multimap</b> <b>&amp;</b> <b>std::unordered_multimap&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::operator=</b> <b>(const</b> <b>unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;</b>
       <b>&amp;)</b> <b>[default]</b>
       Copy assignment operator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>unordered_multimap</b> <b>&amp;</b> <b>std::unordered_multimap&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::operator=</b> <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l)</b> <b>[inline]</b>
       Unordered_multimap list assignment operator.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.

       This function fills an unordered_multimap with copies of the elements in the initializer list <b>__</b><u>l</u>.

       Note that the assignment completely changes the unordered_multimap and that the resulting
       unordered_multimap's size is the same as the number of elements assigned.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>unordered_multimap</b> <b>&amp;</b> <b>std::unordered_multimap&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::operator=</b> <b>(unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;)</b>
       <b>[default]</b>
       Move assignment operator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>void</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::rehash</b> <b>(size_type</b> <b>__n)</b> <b>[inline]</b>
       May rehash the unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>n</u> The new number of buckets.

       Rehash will occur only if the new number of buckets respect the unordered_multimap maximum load factor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>void</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::reserve</b> <b>(size_type</b> <b>__n)</b> <b>[inline]</b>
       Prepare the unordered_multimap for a specified number of elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> Number of elements required.

       Same as rehash(ceil(n / max_load_factor())).

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>size_type</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::size</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the size of the unordered_multimap.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>hash&lt;_Key&gt;,</b> <b>typename</b> <b>_Pred</b>  <b>=</b> <b>equal_to&lt;_Key&gt;,</b>
       <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;&gt;&gt;</b> <b>void</b> <b>std::unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b>
       <b>_Pred,</b> <b>_Alloc</b> <b>&gt;::swap</b> <b>(unordered_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Hash,</b> <b>_Pred,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[noexcept]</b>

       Swaps data with another unordered_multimap.

       <b>Parameters</b>
           <b>__</b><u>x</u> An unordered_multimap of the same element and allocator types.

       This exchanges the elements between two unordered_multimap in constant time. Note that the global
       std::swap() function is specialized such that std::swap(m1,m2) will feed to this function.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libst<u>std::unordered_multimap...</u> <b>_</b><u>Hash,</u> <b>_</b><u>Pred,</u> <b>_</b><u>Alloc</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>