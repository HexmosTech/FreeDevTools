<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       pthread_key_create — thread-specific data key creation

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;

       int pthread_key_create(pthread_key_t *<u>key</u>, void (*<u>destructor</u>)(void*));

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>pthread_key_create</u>()  function shall create a thread-specific data key visible to all threads in the
       process. Key values provided by <u>pthread_key_create</u>() are opaque objects used  to  locate  thread-specific
       data.  Although  the  same  key  value  may  be used by different threads, the values bound to the key by
       <u>pthread_setspecific</u>() are maintained on a per-thread basis and  persist  for  the  life  of  the  calling
       thread.

       Upon key creation, the value NULL shall be associated with the new key in all active threads. Upon thread
       creation, the value NULL shall be associated with all defined keys in the new thread.

       An  optional  destructor  function may be associated with each key value.  At thread exit, if a key value
       has a non-NULL destructor pointer, and the thread has a non-NULL value  associated  with  that  key,  the
       value  of  the  key  is  set  to  NULL,  and  then  the function pointed to is called with the previously
       associated value as its sole argument. The order of destructor calls is  unspecified  if  more  than  one
       destructor exists for a thread when it exits.

       If, after all the destructors have been called for all non-NULL values with associated destructors, there
       are  still  some  non-NULL values with associated destructors, then the process is repeated. If, after at
       least {PTHREAD_DESTRUCTOR_ITERATIONS} iterations of destructor calls  for  outstanding  non-NULL  values,
       there  are  still  some  non-NULL  values  with  associated destructors, implementations may stop calling
       destructors, or  they  may  continue  calling  destructors  until  no  non-NULL  values  with  associated
       destructors exist, even though this might result in an infinite loop.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       If  successful,  the  <u>pthread_key_create</u>()  function  shall store the newly created key value at *<u>key</u> and
       shall return zero. Otherwise, an error number shall be returned to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>pthread_key_create</u>() function shall fail if:

       <b>EAGAIN</b> The system lacked the necessary resources to create  another  thread-specific  data  key,  or  the
              system-imposed limit on the total number of keys per process {PTHREAD_KEYS_MAX} has been exceeded.

       <b>ENOMEM</b> Insufficient memory exists to create the key.

       The <u>pthread_key_create</u>() function shall not return an error code of <b>[EINTR]</b>.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  example  demonstrates  a  function that initializes a thread-specific data key when it is
       first called, and associates a thread-specific object with each calling thread, initializing this  object
       when necessary.

           static pthread_key_t key;
           static pthread_once_t key_once = PTHREAD_ONCE_INIT;

           static void
           make_key()
           {
               (void) pthread_key_create(&amp;key, NULL);
           }

           func()
           {
               void *ptr;

               (void) pthread_once(&amp;key_once, make_key);
               if ((ptr = pthread_getspecific(key)) == NULL) {
                   ptr = malloc(OBJECT_SIZE);
                   ...
                   (void) pthread_setspecific(key, ptr);
               }
               ...
           }

       Note  that  the  key  has  to be initialized before <u>pthread_getspecific</u>() or <u>pthread_setspecific</u>() can be
       used. The <u>pthread_key_create</u>() call could either be explicitly made in a module  initialization  routine,
       or it can be done implicitly by the first call to a module as in this example. Any attempt to use the key
       before it is initialized is a programming error, making the code below incorrect.

           static pthread_key_t key;

           func()
           {
               void *ptr;

              /* KEY NOT INITIALIZED!!!  THIS WILL NOT WORK!!! */
               if ((ptr = pthread_getspecific(key)) == NULL &amp;&amp;
                   pthread_setspecific(key, NULL) != 0) {
                   pthread_key_create(&amp;key, NULL);
                   ...
               }
           }

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       None.

</pre><h4><b>RATIONALE</b></h4><pre>
   <b>Destructor</b> <b>Functions</b>
       Normally,  the  value  bound  to a key on behalf of a particular thread is a pointer to storage allocated
       dynamically on behalf of the calling thread. The destructor functions specified with <u>pthread_key_create</u>()
       are intended to be used to free this storage when the thread exits.  Thread cancellation cleanup handlers
       cannot be used for this purpose because thread-specific data may persist outside  the  lexical  scope  in
       which the cancellation cleanup handlers operate.

       If  the  value  associated  with  a  key needs to be updated during the lifetime of the thread, it may be
       necessary to release the storage associated with the old value before the new value  is  bound.  Although
       the  <u>pthread_setspecific</u>()  function could do this automatically, this feature is not needed often enough
       to justify the added complexity. Instead, the programmer is responsible for freeing the stale storage:

           pthread_getspecific(key, &amp;old);
           new = allocate();
           destructor(old);
           pthread_setspecific(key, new);

       <b>Note:</b>     The above example could leak storage if run with asynchronous  cancellation  enabled.  No  such
                 problems  occur  in  the default cancellation state if no cancellation points occur between the
                 get and set.

       There is no notion of a destructor-safe function. If an application does not call <u>pthread_exit</u>()  from  a
       signal  handler,  or  if  it blocks any signal whose handler may call <u>pthread_exit</u>() while calling async-
       unsafe functions, all functions may be safely called from destructors.

   <b>Non-Idempotent</b> <b>Data</b> <b>Key</b> <b>Creation</b>
       There were requests to  make  <u>pthread_key_create</u>()  idempotent  with  respect  to  a  given  <u>key</u>  address
       parameter.  This  would  allow  applications  to call <u>pthread_key_create</u>() multiple times for a given <u>key</u>
       address and be guaranteed that only one key would be created. Doing so would require the key value to  be
       previously  initialized  (possibly at compile time) to a known null value and would require that implicit
       mutual-exclusion be performed based on the address  and  contents  of  the  <u>key</u>  parameter  in  order  to
       guarantee that exactly one key would be created.

       Unfortunately,  the implicit mutual-exclusion would not be limited to only <u>pthread_key_create</u>().  On many
       implementations, implicit mutual-exclusion would also have to be performed by  <u>pthread_getspecific</u>()  and
       <u>pthread_setspecific</u>()  in order to guard against using incompletely stored or not-yet-visible key values.
       This could significantly increase the cost of important operations, particularly <u>pthread_getspecific</u>().

       Thus, this proposal was rejected. The <u>pthread_key_create</u>() function performs no implicit synchronization.
       It is the responsibility of the programmer to ensure that it is called exactly once per key before use of
       the key. Several straightforward mechanisms can already be used to  accomplish  this,  including  calling
       explicit  module  initialization  functions,  using  mutexes,  and  using <u>pthread_once</u>().  This places no
       significant burden on the programmer, introduces no possibly confusing <u>ad</u>  <u>hoc</u>  implicit  synchronization
       mechanism, and potentially allows commonly used thread-specific data operations to be more efficient.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>pthread_getspecific</u>(), <u>pthread_key_delete</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;pthread.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                            <u><a href="../man3POSIX/PTHREAD_KEY_CREATE.3POSIX.html">PTHREAD_KEY_CREATE</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>