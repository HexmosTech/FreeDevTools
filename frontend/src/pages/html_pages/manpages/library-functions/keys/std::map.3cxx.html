<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::map< _Key, _Tp, _Compare, _Alloc > - A standard container made up of (key,value) pairs, which can be</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::map&lt; _Key, _Tp, _Compare, _Alloc &gt; - A standard container made up of (key,value) pairs, which can be
       retrieved based on a key, in logarithmic time.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;map&gt;

   <b>Public</b> <b>Types</b>
       <b>typedef</b> _Alloc <b>allocator_type</b>
       <b>typedef</b> <b>_Rep_type::const_iterator</b> <b>const_iterator</b>
       <b>typedef</b> _Alloc_traits::const_pointer <b>const_pointer</b>
       <b>typedef</b> _Alloc_traits::const_reference <b>const_reference</b>
       <b>typedef</b> <b>_Rep_type::const_reverse_iterator</b> <b>const_reverse_iterator</b>
       <b>typedef</b> _Rep_type::difference_type <b>difference_type</b>
       <b>using</b> <b>insert_return_type</b> = <b>typename</b> <b>_Rep_type::insert_return_type</b>
       <b>typedef</b> <b>_Rep_type::iterator</b> <b>iterator</b>
       <b>typedef</b> _Compare <b>key_compare</b>
       <b>typedef</b> <b>_Key</b> <b>key_type</b>
       <b>typedef</b> _Tp <b>mapped_type</b>
       <b>using</b> <b>node_type</b> = <b>typename</b> <b>_Rep_type::node_type</b>
       <b>typedef</b> <b>_Alloc_traits::pointer</b> <b>pointer</b>
       <b>typedef</b> _Alloc_traits::reference <b>reference</b>
       <b>typedef</b> <b>_Rep_type::reverse_iterator</b> <b>reverse_iterator</b>
       <b>typedef</b> _Rep_type::size_type <b>size_type</b>
       <b>typedef</b> <b>std::pair</b>&lt; const <b>_Key</b>, _Tp &gt; <b>value_type</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>map</b> ()=<b>default</b>
           Default constructor creates no elements.
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>map</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last)
           Builds a map from a range.
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>map</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last, const _Compare
           &amp;__comp, const allocator_type &amp;__a=allocator_type())
           Builds a map from a range.
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>map</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last, const
           allocator_type &amp;__a)
           Allocator-extended range constructor.
       <b>map</b> (const _Compare &amp;__comp, const allocator_type &amp;__a=allocator_type())
           Creates a map with no elements.
       <b>map</b> (const allocator_type &amp;__a)
           Allocator-extended default constructor.
       <b>map</b> (const <b>map</b> &amp;)=<b>default</b>
           Map copy constructor.
       <b>map</b> (const <b>map</b> &amp;<b>__m</b>, const <b>__type_identity_t</b>&lt; allocator_type &gt; &amp;__a)
           Allocator-extended copy constructor.
       <b>map</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>, const _Compare &amp;__comp=_Compare(), const allocator_type
           &amp;__a=allocator_type())
           Builds a map from an initializer_list.
       <b>map</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>, const allocator_type &amp;__a)
           Allocator-extended initialier-list constructor.
       <b>map</b> (<b>map</b> &amp;&amp;)=<b>default</b>
           Map move constructor.
       <b>map</b> (<b>map</b> &amp;&amp;<b>__m</b>, const <b>__type_identity_t</b>&lt; allocator_type &gt; &amp;__a) noexcept(<b>is_nothrow_copy_constructible</b>&lt;
           _Compare &gt;::value &amp;&amp;_Alloc_traits::_S_always_equal())
           Allocator-extended move constructor.
       <b>~map</b> ()=<b>default</b>
       mapped_type &amp; <b>at</b> (const <b>key_type</b> &amp;<b>__k</b>)
           Access to map data.
       const mapped_type &amp; <b>at</b> (const <b>key_type</b> &amp;<b>__k</b>) const
       <b>const_iterator</b> <b>begin</b> () const noexcept
       <b>iterator</b> <b>begin</b> () noexcept
       <b>const_iterator</b> <b>cbegin</b> () const noexcept
       <b>const_iterator</b> <b>cend</b> () const noexcept
       <b>void</b> <b>clear</b> () noexcept
       <b>const_reverse_iterator</b> <b>crbegin</b> () const noexcept
       <b>const_reverse_iterator</b> <b>crend</b> () const noexcept
       template&lt;typename... _Args&gt; <b>std::pair</b>&lt; <b>iterator</b>, bool &gt; <b>emplace</b> (<b>_Args</b> &amp;&amp;... <b>__args</b>)
           Attempts to build and insert a std::pair into the map.
       template&lt;typename... _Args&gt; <b>iterator</b> <b>emplace_hint</b> (<b>const_iterator</b> <b>__pos</b>, <b>_Args</b> &amp;&amp;... <b>__args</b>)
           Attempts to build and insert a std::pair into the map.
       bool <b>empty</b> () const noexcept
       <b>const_iterator</b> <b>end</b> () const noexcept
       <b>iterator</b> <b>end</b> () noexcept
       size_type <b>erase</b> (const <b>key_type</b> &amp;__x)
           Erases elements according to the provided key.
       <b>iterator</b> <b>erase</b> (<b>const_iterator</b> __first, <b>const_iterator</b> __last)
           Erases a [first,last) range of elements from a map.
       node_type <b>extract</b> (const <b>key_type</b> &amp;__x)
           Extract a node.
       node_type <b>extract</b> (<b>const_iterator</b> <b>__pos</b>)
           Extract a node.
       allocator_type <b>get_allocator</b> () const noexcept
           Get a copy of the memory allocation object.
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; <b>void</b> <b>insert</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last)
           Template function that attempts to insert a range of elements.
       <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__hint</b>, node_type &amp;&amp;<b>__nh</b>)
           Re-insert an extracted node.
       insert_return_type <b>insert</b> (node_type &amp;&amp;<b>__nh</b>)
           Re-insert an extracted node.
       <b>void</b> <b>insert</b> (<b>std::initializer_list</b>&lt; <b>value_type</b> &gt; <b>__list</b>)
           Attempts to insert a list of std::pairs into the map.
       template&lt;<b>typename</b> _Obj &gt; <b>pair</b>&lt; <b>iterator</b>, bool &gt; <b>insert_or_assign</b> (const <b>key_type</b> &amp;<b>__k</b>, _Obj &amp;&amp;<b>__obj</b>)
           Attempts to insert or assign a std::pair into the map.
       template&lt;<b>typename</b> _Obj &gt; <b>iterator</b> <b>insert_or_assign</b> (<b>const_iterator</b> <b>__hint</b>, const <b>key_type</b> &amp;<b>__k</b>, _Obj
           &amp;&amp;<b>__obj</b>)
           Attempts to insert or assign a std::pair into the map.
       template&lt;<b>typename</b> _Obj &gt; <b>iterator</b> <b>insert_or_assign</b> (<b>const_iterator</b> <b>__hint</b>, <b>key_type</b> &amp;&amp;<b>__k</b>, _Obj &amp;&amp;<b>__obj</b>)
       template&lt;<b>typename</b> _Obj &gt; <b>pair</b>&lt; <b>iterator</b>, bool &gt; <b>insert_or_assign</b> (<b>key_type</b> &amp;&amp;<b>__k</b>, _Obj &amp;&amp;<b>__obj</b>)
       key_compare <b>key_comp</b> () const
       size_type <b>max_size</b> () const noexcept
       template&lt;<b>typename</b> <b>_Cmp2</b> &gt; <b>void</b> <b>merge</b> (<b>map</b>&lt; <b>_Key</b>, _Tp, <b>_Cmp2</b>, _Alloc &gt; &amp;&amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_Cmp2</b> &gt; <b>void</b> <b>merge</b> (<b>map</b>&lt; <b>_Key</b>, _Tp, <b>_Cmp2</b>, _Alloc &gt; &amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_Cmp2</b> &gt; <b>void</b> <b>merge</b> (<b>multimap</b>&lt; <b>_Key</b>, _Tp, <b>_Cmp2</b>, _Alloc &gt; &amp;&amp;<b>__source</b>)
       template&lt;<b>typename</b> <b>_Cmp2</b> &gt; <b>void</b> <b>merge</b> (<b>multimap</b>&lt; <b>_Key</b>, _Tp, <b>_Cmp2</b>, _Alloc &gt; &amp;<b>__source</b>)
       <b>map</b> &amp; <b>operator=</b> (const <b>map</b> &amp;)=<b>default</b>
           Map assignment operator.
       <b>map</b> &amp; <b>operator=</b> (<b>initializer_list</b>&lt; <b>value_type</b> &gt; <b>__l</b>)
           Map list assignment operator.
       <b>map</b> &amp; <b>operator=</b> (<b>map</b> &amp;&amp;)=<b>default</b>
           Move assignment operator.
       mapped_type &amp; <b>operator[]</b> (const <b>key_type</b> &amp;<b>__k</b>)
           Subscript ( [] ) access to map data.
       mapped_type &amp; <b>operator[]</b> (<b>key_type</b> &amp;&amp;<b>__k</b>)
       <b>const_reverse_iterator</b> <b>rbegin</b> () const noexcept
       <b>reverse_iterator</b> <b>rbegin</b> () noexcept
       <b>const_reverse_iterator</b> <b>rend</b> () const noexcept
       <b>reverse_iterator</b> <b>rend</b> () noexcept
       size_type <b>size</b> () const noexcept
       <b>void</b> <b>swap</b> (<b>map</b> &amp;__x) noexcept(/*<b>conditional</b> */)
           Swaps data with another map.
       template&lt;typename... _Args&gt; <b>pair</b>&lt; <b>iterator</b>, bool &gt; <b>try_emplace</b> (const <b>key_type</b> &amp;<b>__k</b>, <b>_Args</b> &amp;&amp;... <b>__args</b>)
           Attempts to build and insert a std::pair into the map.
       template&lt;typename... _Args&gt; <b>iterator</b> <b>try_emplace</b> (<b>const_iterator</b> <b>__hint</b>, const <b>key_type</b> &amp;<b>__k</b>, <b>_Args</b> &amp;&amp;...
           <b>__args</b>)
           Attempts to build and insert a std::pair into the map.
       template&lt;typename... _Args&gt; <b>iterator</b> <b>try_emplace</b> (<b>const_iterator</b> <b>__hint</b>, <b>key_type</b> &amp;&amp;<b>__k</b>, <b>_Args</b> &amp;&amp;...
           <b>__args</b>)
       template&lt;typename... _Args&gt; <b>pair</b>&lt; <b>iterator</b>, bool &gt; <b>try_emplace</b> (<b>key_type</b> &amp;&amp;<b>__k</b>, <b>_Args</b> &amp;&amp;... <b>__args</b>)
       value_compare <b>value_comp</b> () const

           <b>std::pair</b>&lt; <b>iterator</b>, bool &gt; <b>insert</b> (const <b>value_type</b> &amp;__x)
               Attempts to insert a std::pair into the map.
           <b>std::pair</b>&lt; <b>iterator</b>, bool &gt; <b>insert</b> (<b>value_type</b> &amp;&amp;__x)
               Attempts to insert a std::pair into the map.
           template&lt;<b>typename</b> <b>_Pair</b> &gt; __enable_if_t&lt; <b>is_constructible</b>&lt; <b>value_type</b>, <b>_Pair</b> &gt;::value, <b>pair</b>&lt;
               <b>iterator</b>, bool &gt; &gt; <b>insert</b> (<b>_Pair</b> &amp;&amp;__x)
               Attempts to insert a std::pair into the map.

           <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__position</b>, const <b>value_type</b> &amp;__x)
               Attempts to insert a std::pair into the map.
           <b>iterator</b> <b>insert</b> (<b>const_iterator</b> <b>__position</b>, <b>value_type</b> &amp;&amp;__x)
               Attempts to insert a std::pair into the map.
           template&lt;<b>typename</b> <b>_Pair</b> &gt; __enable_if_t&lt; <b>is_constructible</b>&lt; <b>value_type</b>, <b>_Pair</b> &gt;::value, <b>iterator</b> &gt;
               <b>insert</b> (<b>const_iterator</b> <b>__position</b>, <b>_Pair</b> &amp;&amp;__x)
               Attempts to insert a std::pair into the map.

           <b>iterator</b> <b>erase</b> (<b>const_iterator</b> <b>__position</b>)
               Erases an element from a map.
           _GLIBCXX_ABI_TAG_CXX11 <b>iterator</b> <b>erase</b> (<b>iterator</b> <b>__position</b>)
               Erases an element from a map.

           <b>iterator</b> <b>find</b> (const <b>key_type</b> &amp;__x)
               Tries to locate an element in a map.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>find</b> (const <b>_Kt</b> &amp;__x) -&gt; <b>decltype</b>(_M_t._M_find_tr(__x))
               Tries to locate an element in a map.

           <b>const_iterator</b> <b>find</b> (const <b>key_type</b> &amp;__x) const
               Tries to locate an element in a map.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>find</b> (const <b>_Kt</b> &amp;__x) const -&gt; <b>decltype</b>(_M_t._M_find_tr(__x))
               Tries to locate an element in a map.

           size_type <b>count</b> (const <b>key_type</b> &amp;__x) const
               Finds the number of elements with given key.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>count</b> (const <b>_Kt</b> &amp;__x) const -&gt; <b>decltype</b>(_M_t._M_count_tr(__x))
               Finds the number of elements with given key.

           bool <b>contains</b> (const <b>key_type</b> &amp;__x) const
               Finds whether an element with the given key exists.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>contains</b> (const <b>_Kt</b> &amp;__x) const -&gt; <b>decltype</b>(_M_t._M_find_tr(__x),
               <b>void</b>(), <b>true</b>)
               Finds whether an element with the given key exists.

           <b>iterator</b> <b>lower_bound</b> (const <b>key_type</b> &amp;__x)
               Finds the beginning of a subsequence matching given key.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>lower_bound</b> (const <b>_Kt</b> &amp;__x) -&gt;
               <b>decltype</b>(<b>iterator</b>(_M_t._M_lower_bound_tr(__x)))
               Finds the beginning of a subsequence matching given key.

           <b>const_iterator</b> <b>lower_bound</b> (const <b>key_type</b> &amp;__x) const
               Finds the beginning of a subsequence matching given key.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>lower_bound</b> (const <b>_Kt</b> &amp;__x) const -&gt;
               <b>decltype</b>(<b>const_iterator</b>(_M_t._M_lower_bound_tr(__x)))
               Finds the beginning of a subsequence matching given key.

           <b>iterator</b> <b>upper_bound</b> (const <b>key_type</b> &amp;__x)
               Finds the end of a subsequence matching given key.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>upper_bound</b> (const <b>_Kt</b> &amp;__x) -&gt;
               <b>decltype</b>(<b>iterator</b>(_M_t._M_upper_bound_tr(__x)))
               Finds the end of a subsequence matching given key.

           <b>const_iterator</b> <b>upper_bound</b> (const <b>key_type</b> &amp;__x) const
               Finds the end of a subsequence matching given key.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>upper_bound</b> (const <b>_Kt</b> &amp;__x) const -&gt;
               <b>decltype</b>(<b>const_iterator</b>(_M_t._M_upper_bound_tr(__x)))
               Finds the end of a subsequence matching given key.

           <b>std::pair</b>&lt; <b>iterator</b>, <b>iterator</b> &gt; <b>equal_range</b> (const <b>key_type</b> &amp;__x)
               Finds a subsequence matching given key.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>equal_range</b> (const <b>_Kt</b> &amp;__x) -&gt; <b>decltype</b>(<b>pair</b>&lt; <b>iterator</b>, <b>iterator</b>
               &gt;(_M_t._M_equal_range_tr(__x)))
               Finds a subsequence matching given key.

           <b>std::pair</b>&lt; <b>const_iterator</b>, <b>const_iterator</b> &gt; <b>equal_range</b> (const <b>key_type</b> &amp;__x) const
               Finds a subsequence matching given key.
           template&lt;<b>typename</b> <b>_Kt</b> &gt; <b>auto</b> <b>equal_range</b> (const <b>_Kt</b> &amp;__x) const -&gt; <b>decltype</b>(<b>pair</b>&lt; <b>const_iterator</b>,
               <b>const_iterator</b> &gt;(_M_t._M_equal_range_tr(__x)))
               Finds a subsequence matching given key.

   <b>Friends</b>
       template&lt;<b>typename</b> <b>_K1</b> , <b>typename</b> _T1 , <b>typename</b> <b>_C1</b> , <b>typename</b> <b>_A1</b> &gt; bool <b>operator&lt;</b> (const <b>map</b>&lt; <b>_K1</b>, _T1,
           <b>_C1</b>, <b>_A1</b> &gt; &amp;, const <b>map</b>&lt; <b>_K1</b>, _T1, <b>_C1</b>, <b>_A1</b> &gt; &amp;)
       template&lt;<b>typename</b> <b>_K1</b> , <b>typename</b> _T1 , <b>typename</b> <b>_C1</b> , <b>typename</b> <b>_A1</b> &gt; bool <b>operator==</b> (const <b>map</b>&lt; <b>_K1</b>,
           _T1, <b>_C1</b>, <b>_A1</b> &gt; &amp;, const <b>map</b>&lt; <b>_K1</b>, _T1, <b>_C1</b>, <b>_A1</b> &gt; &amp;)
       template&lt;<b>typename</b> , <b>typename</b> &gt; <b>struct</b> <b>std::_Rb_tree_merge_helper</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Key,</b> <b>typename</b> <b>_Tp,</b> <b>typename</b> <b>_Compare</b> <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b> <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b>
       class std::map&lt; _Key, _Tp, _Compare, _Alloc &gt;"A standard container made up of (key,value) pairs, which
       can be retrieved based on a key, in logarithmic time.

       <b>Since</b>
           C++98

       <b>Template</b> <b>Parameters</b>
           <b>_</b><u>Key</u> Type of key objects.
           <b>_</b><u>Tp</u> Type of mapped objects.
           <b>_</b><u>Compare</u> Comparison function object type, defaults to less&lt;_Key&gt;.
           <b>_</b><u>Alloc</u> Allocator type, defaults to allocator&lt;pair&lt;const _Key, _Tp&gt;.

       Meets the requirements of a container, a reversible container, and an associative container (using unique
       keys). For a map&lt;Key,T&gt; the key_type is Key, the mapped_type is T, and the value_type is std::pair&lt;const
       Key,T&gt;.

       Maps support bidirectional iterators.

       The private tree data is declared exactly the same way for map and multimap; the distinction is made
       entirely in how the tree functions are called (*_unique versus *_equal, same as the standard).

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b> <b>()</b> <b>[default]</b>
       Default constructor creates no elements.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b> <b>(const</b> <b>_Compare</b>
       <b>&amp;</b> <b>__comp,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline],</b>  <b>[explicit]</b>
       Creates a map with no elements.

       <b>Parameters</b>
           <b>__</b><u>comp</u> A comparison object.
           <b>__</b><u>a</u> An allocator object.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b> <b>(const</b> <b>map&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;)</b> <b>[default]</b>
       Map copy constructor. Whether the allocator is copied depends on the allocator traits.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b> <b>(map&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;)</b> <b>[default]</b>
       Map move constructor. The newly-created map contains the exact contents of the moved instance. The moved
       instance is a valid, but unspecified, map.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b>
       <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l,</b> <b>const</b> <b>_Compare</b> <b>&amp;</b> <b>__comp</b> <b>=</b> <b>_Compare(),</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b>
       <b>allocator_type())</b> <b>[inline]</b>
       Builds a map from an initializer_list.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.
           <b>__</b><u>comp</u> A comparison object.
           <b>__</b><u>a</u> An allocator object.

       Create a map consisting of copies of the elements in the initializer_list <b>__</b><u>l</u>. This is linear in N if the
       range is already sorted, and NlogN otherwise (where N is <b>__</b><u>l.size()</u>).

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b> <b>(const</b>
       <b>allocator_type</b> <b>&amp;</b> <b>__a)</b> <b>[inline],</b>  <b>[explicit]</b>
       Allocator-extended default constructor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b> <b>(const</b> <b>map&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__m,</b> <b>const</b> <b>__type_identity_t&lt;</b> <b>allocator_type</b> <b>&gt;</b> <b>&amp;</b> <b>__a)</b> <b>[inline]</b>
       Allocator-extended copy constructor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b> <b>(map&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__m,</b> <b>const</b> <b>__type_identity_t&lt;</b> <b>allocator_type</b> <b>&gt;</b> <b>&amp;</b> <b>__a)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Allocator-extended move constructor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b>
       <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a)</b> <b>[inline]</b>
       Allocator-extended initialier-list constructor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b> <b>(_InputIterator</b> <b>__first,</b> <b>_InputIterator</b> <b>__last,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a)</b>
       <b>[inline]</b>
       Allocator-extended range constructor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b> <b>(_InputIterator</b> <b>__first,</b> <b>_InputIterator</b> <b>__last)</b> <b>[inline]</b>
       Builds a map from a range.

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.

       Create a map consisting of copies of the elements from [__first,__last). This is linear in N if the range
       is already sorted, and NlogN otherwise (where N is distance(__first,__last)).

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::map</b> <b>(_InputIterator</b> <b>__first,</b> <b>_InputIterator</b> <b>__last,</b> <b>const</b> <b>_Compare</b> <b>&amp;</b> <b>__comp,</b> <b>const</b>
       <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline]</b>
       Builds a map from a range.

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.
           <b>__</b><u>comp</u> A comparison functor.
           <b>__</b><u>a</u> An allocator object.

       Create a map consisting of copies of the elements from [__first,__last). This is linear in N if the range
       is already sorted, and NlogN otherwise (where N is distance(__first,__last)).

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::~map</b> <b>()</b> <b>[default]</b>
       The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to
       memory is not touched in any way. Managing the pointer is the user's responsibility.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>mapped_type</b> <b>&amp;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::at</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__k)</b> <b>[inline]</b>
       Access to map data.

       <b>Parameters</b>
           <b>__</b><u>k</u> The key for which data should be retrieved.

       <b>Returns</b>
           A reference to the data whose key is equivalent to <b>__</b><u>k</u>, if such a data is present in the map.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If no such data is present.

       References <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::end()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::key_comp()</b>, and <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::lower_bound()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>const_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::begin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points to the first pair in the map. Iteration is done in
       ascending order according to the keys.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::begin</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write iterator that points to the first pair in the map. Iteration is done in ascending
       order according to the keys.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>const_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::cbegin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points to the first pair in the map. Iteration is done in
       ascending order according to the keys.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>const_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::cend</b>
       <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points one past the last pair in the map. Iteration is done
       in ascending order according to the keys.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>void</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::clear</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Erases all elements in a map. Note that this function only erases the elements, and that if the elements
       themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the
       user's responsibility.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::contains</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b> <b>decltype(_M_t._M_find_tr(__x),</b> <b>void(),</b> <b>true)</b>
             [inline]"

       Finds whether an element with the given key exists.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pairs to be located.

       <b>Returns</b>
           True if there is an element with the specified key.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>bool</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::contains</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Finds whether an element with the given key exists.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pairs to be located.

       <b>Returns</b>
           True if there is an element with the specified key.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::count</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b> <b>decltype(_M_t._M_count_tr(__x))</b>
             [inline]"

       Finds the number of elements with given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pairs to be located.

       <b>Returns</b>
           Number of elements with specified key.

       This function only makes sense for multimaps; for map the result will either be 0 (not present) or 1
       (present).

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>size_type</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::count</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Finds the number of elements with given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pairs to be located.

       <b>Returns</b>
           Number of elements with specified key.

       This function only makes sense for multimaps; for map the result will either be 0 (not present) or 1
       (present).

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>const_reverse_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::crbegin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reverse iterator that points to the last pair in the map. Iteration is
       done in descending order according to the keys.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>const_reverse_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::crend</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reverse iterator that points to one before the first pair in the map.
       Iteration is done in descending order according to the keys.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename...</b> <b>_Args&gt;</b> <b>std::pair&lt;</b> <b>iterator,</b> <b>bool</b> <b>&gt;</b>
       <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::emplace</b> <b>(_Args</b> <b>&amp;&amp;...</b> <b>__args)</b> <b>[inline]</b>
       Attempts to build and insert a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>args</u> Arguments used to generate a new pair instance (see std::piecewise_contruct for passing
           arguments to each part of the pair constructor).

       <b>Returns</b>
           A pair, of which the first element is an iterator that points to the possibly inserted pair, and the
           second is a bool that is true if the pair was actually inserted.

       This function attempts to build and insert a (key, value) pair into the map. A map relies on unique keys
       and thus a pair is only inserted if its first element (the key) is not already present in the map.

       Insertion requires logarithmic time.

       References <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::emplace_hint()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::end()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::key_comp()</b>, and <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::lower_bound()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename...</b> <b>_Args&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::emplace_hint</b> <b>(const_iterator</b> <b>__pos,</b> <b>_Args</b> <b>&amp;&amp;...</b> <b>__args)</b> <b>[inline]</b>
       Attempts to build and insert a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>pos</u> An iterator that serves as a hint as to where the pair should be inserted.
           <b>__</b><u>args</u> Arguments used to generate a new pair instance (see std::piecewise_contruct for passing
           arguments to each part of the pair constructor).

       <b>Returns</b>
           An iterator that points to the element with key of the std::pair built from <b>__</b><u>args</u> (may or may not be
           that std::pair).

       This function is not concerned about whether the insertion took place, and thus does not return a boolean
       like the single-argument emplace() does. Note that the first parameter is only a hint and can potentially
       improve the performance of the insertion process. A bad hint would cause no gains in efficiency.

       See https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       for more on <u>hinting</u>.

       Insertion requires logarithmic time (if the hint is not taken).

       Referenced by <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::emplace()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::insert()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert_or_assign()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::insert_or_assign()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::try_emplace()</b>, and <b>std::map&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::try_emplace()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>bool</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::empty</b> <b>()</b> <b>const</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Returns true if the map is empty. (Thus begin() would equal end().)

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>const_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::end</b>
       <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points one past the last pair in the map. Iteration is done
       in ascending order according to the keys.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::end</b> <b>()</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write iterator that points one past the last pair in the map. Iteration is done in
       ascending order according to the keys.

       Referenced by <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::at()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::emplace()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::extract()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::insert()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert_or_assign()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::operator[]()</b>, and <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::try_emplace()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>-&gt;</b> <b>decltype(pair&lt;iterator,</b>
       <b>iterator&gt;(_M_t._M_equal_range_tr(__x)))</b>
             [inline]"

       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pairs to be located.

       <b>Returns</b>
           Pair of iterators that possibly points to the subsequence matching given key.

       This function is equivalent to

       std::make_pair(c.lower_bound(val),
                      c.upper_bound(val))

        (but is faster than making the calls separately).

       This function probably only makes sense for multimaps.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b> <b>decltype(pair&lt;const_iterator,</b> <b>const_iterator&gt;(</b>
                  _M_t._M_equal_range_tr(__x)))       [inline]"

       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pairs to be located.

       <b>Returns</b>
           Pair of read-only (constant) iterators that possibly points to the subsequence matching given key.

       This function is equivalent to

       std::make_pair(c.lower_bound(val),
                      c.upper_bound(val))

        (but is faster than making the calls separately).

       This function probably only makes sense for multimaps.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::pair&lt;</b> <b>iterator,</b> <b>iterator</b> <b>&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pairs to be located.

       <b>Returns</b>
           Pair of iterators that possibly points to the subsequence matching given key.

       This function is equivalent to

       std::make_pair(c.lower_bound(val),
                      c.upper_bound(val))

        (but is faster than making the calls separately).

       This function probably only makes sense for multimaps.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::pair&lt;</b> <b>const_iterator,</b> <b>const_iterator</b> <b>&gt;</b> <b>std::map&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::equal_range</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Finds a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pairs to be located.

       <b>Returns</b>
           Pair of read-only (constant) iterators that possibly points to the subsequence matching given key.

       This function is equivalent to

       std::make_pair(c.lower_bound(val),
                      c.upper_bound(val))

        (but is faster than making the calls separately).

       This function probably only makes sense for multimaps.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>size_type</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::erase</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Erases elements according to the provided key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of element to be erased.

       <b>Returns</b>
           The number of elements erased.

       This function erases all the elements located by the given key from a map. Note that this function only
       erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in
       any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::erase</b>
       <b>(const_iterator</b> <b>__first,</b> <b>const_iterator</b> <b>__last)</b> <b>[inline]</b>
       Erases a [first,last) range of elements from a map.

       <b>Parameters</b>
           <b>__</b><u>first</u> Iterator pointing to the start of the range to be erased.
           <b>__</b><u>last</u> Iterator pointing to the end of the range to be erased.

       <b>Returns</b>
           The iterator <b>__</b><u>last</u>.

       This function erases a sequence of elements from a map. Note that this function only erases the element,
       and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing
       the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::erase</b>
       <b>(const_iterator</b> <b>__position)</b> <b>[inline]</b>
       Erases an element from a map.

       <b>Parameters</b>
           <b>__</b><u>position</u> An iterator pointing to the element to be erased.

       <b>Returns</b>
           An iterator pointing to the element immediately following <u>position</u> prior to the element being erased.
           If no such element exists, end() is returned.

       This function erases an element, pointed to by the given iterator, from a map. Note that this function
       only erases the element, and that if the element is itself a pointer, the pointed-to memory is not
       touched in any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>_GLIBCXX_ABI_TAG_CXX11</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::erase</b> <b>(iterator</b> <b>__position)</b> <b>[inline]</b>
       Erases an element from a map.

       <b>Parameters</b>
           <b>__</b><u>position</u> An iterator pointing to the element to be erased.

       <b>Returns</b>
           An iterator pointing to the element immediately following <u>position</u> prior to the element being erased.
           If no such element exists, end() is returned.

       This function erases an element, pointed to by the given iterator, from a map. Note that this function
       only erases the element, and that if the element is itself a pointer, the pointed-to memory is not
       touched in any way. Managing the pointer is the user's responsibility.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>node_type</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::extract</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Extract a node.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>node_type</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::extract</b>
       <b>(const_iterator</b> <b>__pos)</b> <b>[inline]</b>
       Extract a node.

       References <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::find</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>-&gt;</b> <b>decltype(_M_t._M_find_tr(__x))</b>
             [inline]"

       Tries to locate an element in a map.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns an iterator pointing to the sought after pair. If unsuccessful it returns the past-the-
       end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::find</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b> <b>decltype(_M_t._M_find_tr(__x))</b>
             [inline]"

       Tries to locate an element in a map.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Read-only (constant) iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns a constant iterator pointing to the sought after pair. If unsuccessful it returns the
       past-the-end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::find</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Tries to locate an element in a map.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns an iterator pointing to the sought after pair. If unsuccessful it returns the past-the-
       end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>const_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::find</b>
       <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Tries to locate an element in a map.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Read-only (constant) iterator pointing to sought-after element, or end() if not found.

       This function takes a key and tries to locate the element with which the key matches. If successful the
       function returns a constant iterator pointing to the sought after pair. If unsuccessful it returns the
       past-the-end ( end() ) iterator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>allocator_type</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::get_allocator</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Get a copy of the memory allocation object.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>&gt;</b> <b>void</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(_InputIterator</b> <b>__first,</b> <b>_InputIterator</b> <b>__last)</b> <b>[inline]</b>
       Template function that attempts to insert a range of elements.

       <b>Parameters</b>
           <b>__</b><u>first</u> Iterator pointing to the start of the range to be inserted.
           <b>__</b><u>last</u> Iterator pointing to the end of the range.

       Complexity similar to that of the range constructor.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Pair</b> <b>&gt;</b> <b>__enable_if_t&lt;</b> <b>is_constructible&lt;</b>
       <b>value_type,</b> <b>_Pair</b> <b>&gt;::value,</b> <b>pair&lt;</b> <b>iterator,</b> <b>bool</b> <b>&gt;</b> <b>&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(_Pair</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline]</b>
       Attempts to insert a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           A pair, of which the first element is an iterator that points to the possibly inserted pair, and the
           second is a bool that is true if the pair was actually inserted.

       This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a
       pair is only inserted if its first element (the key) is not already present in the map.

       Insertion requires logarithmic time.

       References <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::emplace_hint()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::end()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::key_comp()</b>, and <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::lower_bound()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::pair&lt;</b> <b>iterator,</b> <b>bool</b> <b>&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::insert</b> <b>(const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Attempts to insert a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           A pair, of which the first element is an iterator that points to the possibly inserted pair, and the
           second is a bool that is true if the pair was actually inserted.

       This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a
       pair is only inserted if its first element (the key) is not already present in the map.

       Insertion requires logarithmic time.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(const_iterator</b> <b>__hint,</b> <b>node_type</b> <b>&amp;&amp;</b> <b>__nh)</b> <b>[inline]</b>
       Re-insert an extracted node.

       References <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Pair</b> <b>&gt;</b> <b>__enable_if_t&lt;</b> <b>is_constructible&lt;</b>
       <b>value_type,</b> <b>_Pair</b> <b>&gt;::value,</b> <b>iterator</b> <b>&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert</b> <b>(const_iterator</b>
       <b>__position,</b> <b>_Pair</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline]</b>
       Attempts to insert a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>position</u> An iterator that serves as a hint as to where the pair should be inserted.
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           An iterator that points to the element with key of <b>__</b><u>x</u> (may or may not be the pair passed in).

       This function is not concerned about whether the insertion took place, and thus does not return a boolean
       like the single-argument insert() does. Note that the first parameter is only a hint and can potentially
       improve the performance of the insertion process. A bad hint would cause no gains in efficiency.

       See https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       for more on <u>hinting</u>.

       Insertion requires logarithmic time (if the hint is not taken).

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(const_iterator</b> <b>__position,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Attempts to insert a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>position</u> An iterator that serves as a hint as to where the pair should be inserted.
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           An iterator that points to the element with key of <b>__</b><u>x</u> (may or may not be the pair passed in).

       This function is not concerned about whether the insertion took place, and thus does not return a boolean
       like the single-argument insert() does. Note that the first parameter is only a hint and can potentially
       improve the performance of the insertion process. A bad hint would cause no gains in efficiency.

       See https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       for more on <u>hinting</u>.

       Insertion requires logarithmic time (if the hint is not taken).

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(const_iterator</b> <b>__position,</b> <b>value_type</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline]</b>
       Attempts to insert a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>position</u> An iterator that serves as a hint as to where the pair should be inserted.
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           An iterator that points to the element with key of <b>__</b><u>x</u> (may or may not be the pair passed in).

       This function is not concerned about whether the insertion took place, and thus does not return a boolean
       like the single-argument insert() does. Note that the first parameter is only a hint and can potentially
       improve the performance of the insertion process. A bad hint would cause no gains in efficiency.

       See https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       for more on <u>hinting</u>.

       Insertion requires logarithmic time (if the hint is not taken).

       References <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>insert_return_type</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::insert</b> <b>(node_type</b> <b>&amp;&amp;</b> <b>__nh)</b> <b>[inline]</b>
       Re-insert an extracted node.

       References <b>std::move()</b>.

       Referenced by <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert()</b>, and <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::operator[]()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>void</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(std::initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__list)</b> <b>[inline]</b>
       Attempts to insert a list of std::pairs into the map.

       <b>Parameters</b>
           <b>__</b><u>list</u> A std::initializer_list&lt;value_type&gt; of pairs to be inserted.

       Complexity similar to that of the range constructor.

       References <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>std::pair&lt;</b> <b>iterator,</b> <b>bool</b> <b>&gt;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::insert</b> <b>(value_type</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline]</b>
       Attempts to insert a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>x</u> Pair to be inserted (see std::make_pair for easy creation of pairs).

       <b>Returns</b>
           A pair, of which the first element is an iterator that points to the possibly inserted pair, and the
           second is a bool that is true if the pair was actually inserted.

       This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a
       pair is only inserted if its first element (the key) is not already present in the map.

       Insertion requires logarithmic time.

       References <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Obj</b> <b>&gt;</b> <b>pair&lt;</b> <b>iterator,</b> <b>bool</b> <b>&gt;</b> <b>std::map&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert_or_assign</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__k,</b> <b>_Obj</b> <b>&amp;&amp;</b> <b>__obj)</b> <b>[inline]</b>
       Attempts to insert or assign a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>k</u> Key to use for finding a possibly existing pair in the map.
           <b>__</b><u>obj</u> Argument used to generate the .second for a pair instance.

       <b>Returns</b>
           A pair, of which the first element is an iterator that points to the possibly inserted pair, and the
           second is a bool that is true if the pair was actually inserted.

       This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a
       pair is only inserted if its first element (the key) is not already present in the map. If the pair was
       already in the map, the .second of the pair is assigned from __obj.

       Insertion requires logarithmic time.

       References <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::emplace_hint()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::end()</b>, <b>std::forward_as_tuple()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::key_comp()</b>, <b>std::map&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::lower_bound()</b>, and <b>std::piecewise_construct</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Obj</b> <b>&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert_or_assign</b> <b>(const_iterator</b> <b>__hint,</b> <b>const</b> <b>key_type</b> <b>&amp;</b> <b>__k,</b> <b>_Obj</b> <b>&amp;&amp;</b> <b>__obj)</b>
       <b>[inline]</b>
       Attempts to insert or assign a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>hint</u> An iterator that serves as a hint as to where the pair should be inserted.
           <b>__</b><u>k</u> Key to use for finding a possibly existing pair in the map.
           <b>__</b><u>obj</u> Argument used to generate the .second for a pair instance.

       <b>Returns</b>
           An iterator that points to the element with key of <b>__</b><u>x</u> (may or may not be the pair passed in).

       This function attempts to insert a (key, value) pair into the map. A map relies on unique keys and thus a
       pair is only inserted if its first element (the key) is not already present in the map. If the pair was
       already in the map, the .second of the pair is assigned from __obj.

       Insertion requires logarithmic time.

       References <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::emplace_hint()</b>, <b>std::forward_as_tuple()</b>, and
       <b>std::piecewise_construct</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>key_compare</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::key_comp</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Returns the key comparison object out of which the map was constructed.

       Referenced by <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::at()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::emplace()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::insert_or_assign()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::operator[]()</b>, and <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::try_emplace()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::lower_bound</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>-&gt;</b> <b>decltype(iterator(_M_t._M_lower_bound_tr(__x)))</b>
             [inline]"

       Finds the beginning of a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Iterator pointing to first element equal to or greater than key, or end().

       This function returns the first element of a subsequence of elements that matches the given key. If
       unsuccessful it returns an iterator pointing to the first element that has a greater value than given key
       or end() if no such element exists.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::lower_bound</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b> <b>decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))</b>
             [inline]"

       Finds the beginning of a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Read-only (constant) iterator pointing to first element equal to or greater than key, or end().

       This function returns the first element of a subsequence of elements that matches the given key. If
       unsuccessful it returns an iterator pointing to the first element that has a greater value than given key
       or end() if no such element exists.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::lower_bound</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Finds the beginning of a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Iterator pointing to first element equal to or greater than key, or end().

       This function returns the first element of a subsequence of elements that matches the given key. If
       unsuccessful it returns an iterator pointing to the first element that has a greater value than given key
       or end() if no such element exists.

       Referenced by <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::at()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::emplace()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::insert()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::insert_or_assign()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::operator[]()</b>, and <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::try_emplace()</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>const_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::lower_bound</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Finds the beginning of a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Read-only (constant) iterator pointing to first element equal to or greater than key, or end().

       This function returns the first element of a subsequence of elements that matches the given key. If
       unsuccessful it returns an iterator pointing to the first element that has a greater value than given key
       or end() if no such element exists.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>size_type</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::max_size</b>
       <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the maximum size of the map.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>map</b> <b>&amp;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::operator=</b>
       <b>(const</b> <b>map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;)</b> <b>[default]</b>
       Map assignment operator. Whether the allocator is copied depends on the allocator traits.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>map</b> <b>&amp;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::operator=</b>
       <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l)</b> <b>[inline]</b>
       Map list assignment operator.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.

       This function fills a map with copies of the elements in the initializer list <b>__</b><u>l</u>.

       Note that the assignment completely changes the map and that the resulting map's size is the same as the
       number of elements assigned.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>map</b> <b>&amp;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::operator=</b>
       <b>(map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;)</b> <b>[default]</b>
       Move assignment operator.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>mapped_type</b> <b>&amp;</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::operator[]</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__k)</b> <b>[inline]</b>
       Subscript ( [] ) access to map data.

       <b>Parameters</b>
           <b>__</b><u>k</u> The key for which data should be retrieved.

       <b>Returns</b>
           A reference to the data of the (key,data) pair.

       Allows for easy lookup with the subscript ( [] ) operator. Returns data associated with the key specified
       in subscript. If the key does not exist, a pair with that key is created using default values, which is
       then returned.

       Lookup requires logarithmic time.

       References <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::end()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::insert()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::key_comp()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::lower_bound()</b>, and <b>std::piecewise_construct</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>const_reverse_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::rbegin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reverse iterator that points to the last pair in the map. Iteration is
       done in descending order according to the keys.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>reverse_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::rbegin</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write reverse iterator that points to the last pair in the map. Iteration is done in
       descending order according to the keys.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>const_reverse_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::rend</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reverse iterator that points to one before the first pair in the map.
       Iteration is done in descending order according to the keys.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>reverse_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::rend</b> <b>()</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns a read/write reverse iterator that points to one before the first pair in the map. Iteration is
       done in descending order according to the keys.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>size_type</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::size</b> <b>()</b>
       <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the size of the map.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>void</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::swap</b> <b>(map&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Swaps data with another map.

       <b>Parameters</b>
           <b>__</b><u>x</u> A map of the same element and allocator types.

       This exchanges the elements between two maps in constant time. (It is only swapping a pointer, an
       integer, and an instance of the Compare type (which itself is often stateless and empty), so it should be
       quite fast.) Note that the global std::swap() function is specialized such that std::swap(m1,m2) will
       feed to this function.

       Whether the allocators are swapped depends on the allocator traits.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename...</b> <b>_Args&gt;</b> <b>pair&lt;</b> <b>iterator,</b> <b>bool</b> <b>&gt;</b> <b>std::map&lt;</b>
       <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::try_emplace</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__k,</b> <b>_Args</b> <b>&amp;&amp;...</b> <b>__args)</b> <b>[inline]</b>
       Attempts to build and insert a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>k</u> Key to use for finding a possibly existing pair in the map.
           <b>__</b><u>args</u> Arguments used to generate the .second for a new pair instance.

       <b>Returns</b>
           A pair, of which the first element is an iterator that points to the possibly inserted pair, and the
           second is a bool that is true if the pair was actually inserted.

       This function attempts to build and insert a (key, value) pair into the map. A map relies on unique keys
       and thus a pair is only inserted if its first element (the key) is not already present in the map. If a
       pair is not inserted, this function has no effect.

       Insertion requires logarithmic time.

       References <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::emplace_hint()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::end()</b>, <b>std::forward_as_tuple()</b>, <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::key_comp()</b>, <b>std::map&lt;</b> <b>_Key,</b>
       <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::lower_bound()</b>, and <b>std::piecewise_construct</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename...</b> <b>_Args&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b>
       <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::try_emplace</b> <b>(const_iterator</b> <b>__hint,</b> <b>const</b> <b>key_type</b> <b>&amp;</b> <b>__k,</b> <b>_Args</b> <b>&amp;&amp;...</b> <b>__args)</b>
       <b>[inline]</b>
       Attempts to build and insert a std::pair into the map.

       <b>Parameters</b>
           <b>__</b><u>hint</u> An iterator that serves as a hint as to where the pair should be inserted.
           <b>__</b><u>k</u> Key to use for finding a possibly existing pair in the map.
           <b>__</b><u>args</u> Arguments used to generate the .second for a new pair instance.

       <b>Returns</b>
           An iterator that points to the element with key of the std::pair built from <b>__</b><u>args</u> (may or may not be
           that std::pair).

       This function is not concerned about whether the insertion took place, and thus does not return a boolean
       like the single-argument try_emplace() does. However, if insertion did not take place, this function has
       no effect. Note that the first parameter is only a hint and can potentially improve the performance of
       the insertion process. A bad hint would cause no gains in efficiency.

       See https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       for more on <u>hinting</u>.

       Insertion requires logarithmic time (if the hint is not taken).

       References <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;::emplace_hint()</b>, <b>std::forward_as_tuple()</b>, and
       <b>std::piecewise_construct</b>.

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::upper_bound</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>-&gt;</b> <b>decltype(iterator(_M_t._M_upper_bound_tr(__x)))</b>
             [inline]"

       Finds the end of a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Iterator pointing to the first element greater than key, or end().

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>template&lt;typename</b> <b>_Kt</b> <b>&gt;</b> <b>auto</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b>
       <b>_Alloc</b> <b>&gt;::upper_bound</b> <b>(const</b> <b>_Kt</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>-&gt;</b> <b>decltype(const_iterator(_M_t._M_upper_bound_tr(__x)))</b>
             [inline]"

       Finds the end of a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Read-only (constant) iterator pointing to first iterator greater than key, or end().

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::upper_bound</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline]</b>
       Finds the end of a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Iterator pointing to the first element greater than key, or end().

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>const_iterator</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::upper_bound</b> <b>(const</b> <b>key_type</b> <b>&amp;</b> <b>__x)</b> <b>const</b> <b>[inline]</b>
       Finds the end of a subsequence matching given key.

       <b>Parameters</b>
           <b>__</b><u>x</u> Key of (key, value) pair to be located.

       <b>Returns</b>
           Read-only (constant) iterator pointing to first iterator greater than key, or end().

   <b>template&lt;typename</b> <b>_Key</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>std::less&lt;_Key&gt;,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b>
       <b>std::allocator&lt;std::pair&lt;const</b> <b>_Key,</b> <b>_Tp&gt;</b> <b>&gt;&gt;</b> <b>value_compare</b> <b>std::map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_Compare,</b> <b>_Alloc</b>
       <b>&gt;::value_comp</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Returns a value comparison object, built from the key comparison object out of which the map was
       constructed.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++      <u>std::map&lt;</u> <b>_</b><u>Key,</u> <b>_</b><u>Tp,</u> <b>_</b><u>Compare,</u> <b>_</b><u>Alloc</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>