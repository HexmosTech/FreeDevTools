<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>global - A global name registration facility.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       global - A global name registration facility.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module consists of the following services:

         * Registration of global names

         * Global locks

         * Maintenance of the fully connected network

       These  services  are  controlled  through  the  process <u>global_name_server</u> that exists on every node. The
       global name server starts automatically when a node is started. With the term  <u>global</u>  is  meant  over  a
       system consisting of many Erlang nodes.

       The  ability  to  globally  register  names is a central concept in the programming of distributed Erlang
       systems. In  this  module,  the  equivalent  of  the  <u>register/2</u>  and  <u>whereis/1</u>  BIFs  (for  local  name
       registration)  are  provided,  but  for  a  network  of Erlang nodes. A registered name is an alias for a
       process identifier (pid). The global  name  server  monitors  globally  registered  pids.  If  a  process
       terminates, the name is also globally unregistered.

       The  registered names are stored in replica global name tables on every node. There is no central storage
       point. Thus, the translation of a name to a pid is fast, as it is always done  locally.  For  any  action
       resulting in a change to the global name table, all tables on other nodes are automatically updated.

       Global locks have lock identities and are set on a specific resource. For example, the specified resource
       can  be a pid. When a global lock is set, access to the locked resource is denied for all resources other
       than the lock requester.

       Both the registration and lock services are atomic. All nodes involved in these  actions  have  the  same
       view of the information.

       The  global  name  server  also  performs  the  critical  task of continuously monitoring changes in node
       configuration. If a node that runs a  globally  registered  process  goes  down,  the  name  is  globally
       unregistered.  To  this  end, the global name server subscribes to <u>nodeup</u> and <u>nodedown</u> messages sent from
       module <u>net_kernel</u>. Relevant Kernel application variables in this context are <u>net_setuptime</u>, <u>net_ticktime</u>,
       and <u>dist_auto_connect</u>. See also <u><a href="../man7/kernel.7.html">kernel</a>(7)</u>.

       The name server also maintains a fully connected network. For example, if node <u>N1</u>  connects  to  node  <u>N2</u>
       (which  is  already  connected to <u>N3</u>), the global name servers on the nodes <u>N1</u> and <u>N3</u> ensure that also <u>N1</u>
       and <u>N3</u> are connected. If this is not desired, command-line flag <u>-connect_all</u> <u>false</u> can be used (see  also
       <u><a href="../man1/erl.1.html">erl</a>(1)</u>). In this case, the name registration service cannot be used, but the lock mechanism still works.

       If  the  global name server fails to connect nodes (<u>N1</u> and <u>N3</u> in the example), a warning event is sent to
       the error logger. The presence of such an event does not exclude the nodes to connect later (you can, for
       example, try command <u>rpc:call(N1,</u> <u>net_adm,</u> <u>ping,</u> <u>[N2])</u> in the Erlang shell), but it indicates  a  network
       problem.

   <b>Note:</b>
       If the fully connected network is not set up properly, try first to increase the value of <u>net_setuptime</u>.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>id()</b> = {ResourceId :: term(), LockRequesterId :: term()}

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>del_lock(Id)</b> <b>-&gt;</b> <b>true</b>

       <b>del_lock(Id,</b> <b>Nodes)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Id = id()
                 Nodes = [node()]

              Deletes the lock <u>Id</u> synchronously.

       <b>notify_all_name(Name,</b> <b>Pid1,</b> <b>Pid2)</b> <b>-&gt;</b> <b>none</b>

              Types:

                 Name = term()
                 Pid1 = Pid2 = pid()

              Can be used as a name resolving function for <u>register_name/3</u> and <u>re_register_name/3</u>.

              The function unregisters both pids and sends the message <u>{global_name_conflict,</u> <u>Name,</u> <u>OtherPid}</u> to
              both processes.

       <b>random_exit_name(Name,</b> <b>Pid1,</b> <b>Pid2)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Name = term()
                 Pid1 = Pid2 = pid()

              Can be used as a name resolving function for <u>register_name/3</u> and <u>re_register_name/3</u>.

              The function randomly selects one of the pids for registration and kills the other one.

       <b>random_notify_name(Name,</b> <b>Pid1,</b> <b>Pid2)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Name = term()
                 Pid1 = Pid2 = pid()

              Can be used as a name resolving function for <u>register_name/3</u> and <u>re_register_name/3</u>.

              The  function  randomly  selects  one  of  the  pids  for  registration,  and  sends  the  message
              <u>{global_name_conflict,</u> <u>Name}</u> to the other pid.

       <b>re_register_name(Name,</b> <b>Pid)</b> <b>-&gt;</b> <b>yes</b>

       <b>re_register_name(Name,</b> <b>Pid,</b> <b>Resolve)</b> <b>-&gt;</b> <b>yes</b>

              Types:

                 Name = term()
                 Pid = pid()
                 Resolve = method()
                 <b>method()</b> =
                     fun((Name :: term(), Pid :: pid(), Pid2 :: pid()) -&gt;
                             pid() | none)
                   {<u>Module</u>, <u>Function</u>} is also allowed.

              Atomically changes the registered name <u>Name</u> on all nodes to refer to <u>Pid</u>.

              Function <u>Resolve</u> has the same behavior as in <u>register_name/2,3</u>.

       <b>register_name(Name,</b> <b>Pid)</b> <b>-&gt;</b> <b>yes</b> <b>|</b> <b>no</b>

       <b>register_name(Name,</b> <b>Pid,</b> <b>Resolve)</b> <b>-&gt;</b> <b>yes</b> <b>|</b> <b>no</b>

              Types:

                 Name = term()
                 Pid = pid()
                 Resolve = method()
                 <b>method()</b> =
                     fun((Name :: term(), Pid :: pid(), Pid2 :: pid()) -&gt;
                             pid() | none)
                   {<u>Module</u>, <u>Function</u>} is also allowed for backward compatibility, but its use is deprecated.

              Globally associates name <u>Name</u> with a pid, that is, globally notifies all nodes  of  a  new  global
              name in a network of Erlang nodes.

              When  new  nodes are added to the network, they are informed of the globally registered names that
              already exist. The network is also informed of any global names in newly connected nodes.  If  any
              name  clashes  are  discovered,  function <u>Resolve</u> is called. Its purpose is to decide which pid is
              correct. If the function crashes, or returns anything other than one of  the  pids,  the  name  is
              unregistered. This function is called once for each name clash.

          <b>Warning:</b>
              If  you  plan  to  change  code  without restarting your system, you must use an external fun (<u>fun</u>
              <u>Module:Function/Arity</u>) as function <u>Resolve</u>. If you use a local fun, you can never replace the code
              for the module that the fun belongs to.

              Three  predefined  resolve  functions   exist:   <u>random_exit_name/3</u>,   <u>random_notify_name/3</u>,   and
              <u>notify_all_name/3</u>.  If  no  <u>Resolve</u> function is defined, <u>random_exit_name</u> is used. This means that
              one of the two registered processes is selected as correct while the other is killed.

              This function is completely synchronous, that is, when this function returns, the name  is  either
              registered on all nodes or none.

              The  function returns <u>yes</u> if successful, <u>no</u> if it fails. For example, <u>no</u> is returned if an attempt
              is made to register an already registered process or to register a process with  a  name  that  is
              already in use.

          <b>Note:</b>
              Releases  up  to and including Erlang/OTP R10 did not check if the process was already registered.
              The global name table could therefore become inconsistent. The old (buggy) behavior can be  chosen
              by giving the Kernel application variable <u>global_multi_name_action</u> the value <u>allow</u>.

              If  a  process with a registered name dies, or the node goes down, the name is unregistered on all
              nodes.

       <b>registered_names()</b> <b>-&gt;</b> <b>[Name]</b>

              Types:

                 Name = term()

              Returns a list of all globally registered names.

       <b>send(Name,</b> <b>Msg)</b> <b>-&gt;</b> <b>Pid</b>

              Types:

                 Name = Msg = term()
                 Pid = pid()

              Sends message <u>Msg</u> to the pid globally registered as <u>Name</u>.

              If <u>Name</u> is not a globally registered name, the calling function exits with reason <u>{badarg,</u>  <u>{Name,</u>
              <u>Msg}}</u>.

       <b>set_lock(Id)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>set_lock(Id,</b> <b>Nodes)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>set_lock(Id,</b> <b>Nodes,</b> <b>Retries)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Id = id()
                 Nodes = [node()]
                 Retries = retries()
                 <b>id()</b> = {ResourceId :: term(), LockRequesterId :: term()}
                 <b>retries()</b> = integer() &gt;= 0 | infinity

              Sets  a  lock  on  the  specified  nodes (or on all nodes if none are specified) on <u>ResourceId</u> for
              <u>LockRequesterId</u>.  If  a  lock  already  exists  on   <u>ResourceId</u>   for   another   requester   than
              <u>LockRequesterId</u>,  and  <u>Retries</u>  is  not  equal  to  <u>0</u>, the process sleeps for a while and tries to
              execute the action later. When <u>Retries</u> attempts have been made, <u>false</u> is returned, otherwise <u>true</u>.
              If <u>Retries</u> is <u>infinity</u>, <u>true</u> is eventually returned (unless the lock is never released).

              If no value for <u>Retries</u> is specified, <u>infinity</u> is used.

              This function is completely synchronous.

              If a process that holds a lock dies, or the node goes down, the locks  held  by  the  process  are
              deleted.

              The  global  name  server  keeps  track  of  all  processes sharing the same lock, that is, if two
              processes set the same lock, both processes must delete the lock.

              This function does not address the problem of a deadlock. A deadlock can never occur  as  long  as
              processes only lock one resource at a time. A deadlock can occur if some processes try to lock two
              or more resources. It is up to the application to detect and rectify a deadlock.

          <b>Note:</b>
              Avoid the following values of <u>ResourceId</u>, otherwise Erlang/OTP does not work properly:

                * <u>dist_ac</u>

                * <u>global</u>

                * <u>mnesia_adjust_log_writes</u>

                * <u>mnesia_table_lock</u>

       <b>sync()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason</b> <b>::</b> <b>term()}</b>

              Synchronizes  the  global  name server with all nodes known to this node. These are the nodes that
              are returned from <u>erlang:nodes()</u>. When this function returns,  the  global  name  server  receives
              global  information  from  all  nodes. This function can be called when new nodes are added to the
              network.

              The only possible error reason <u>Reason</u> is <u>{"global_groups</u> <u>definition</u> <u>error",</u> <u>Error}</u>.

       <b>trans(Id,</b> <b>Fun)</b> <b>-&gt;</b> <b>Res</b> <b>|</b> <b>aborted</b>

       <b>trans(Id,</b> <b>Fun,</b> <b>Nodes)</b> <b>-&gt;</b> <b>Res</b> <b>|</b> <b>aborted</b>

       <b>trans(Id,</b> <b>Fun,</b> <b>Nodes,</b> <b>Retries)</b> <b>-&gt;</b> <b>Res</b> <b>|</b> <b>aborted</b>

              Types:

                 Id = id()
                 Fun = trans_fun()
                 Nodes = [node()]
                 Retries = retries()
                 Res = term()
                 <b>retries()</b> = integer() &gt;= 0 | infinity
                 <b>trans_fun()</b> = function() | {module(), atom()}

              Sets a lock on <u>Id</u> (using <u>set_lock/3</u>). If this succeeds, <u>Fun()</u> is evaluated and the result  <u>Res</u>  is
              returned.  Returns  <u>aborted</u>  if  the  lock  attempt  fails.  If  <u>Retries</u>  is  set to <u>infinity</u>, the
              transaction does not abort.

              <u>infinity</u> is the default setting and is used if no value is specified for <u>Retries</u>.

       <b>unregister_name(Name)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Name = term()

              Removes the globally registered name <u>Name</u> from the network of Erlang nodes.

       <b>whereis_name(Name)</b> <b>-&gt;</b> <b>pid()</b> <b>|</b> <b>undefined</b>

              Types:

                 Name = term()

              Returns the pid with the globally registered name <u>Name</u>. Returns  <u>undefined</u>  if  the  name  is  not
              globally registered.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/global_group.3erl.html">global_group</a>(3erl)</u>, <u><a href="../man3erl/net_kernel.3erl.html">net_kernel</a>(3erl)</u>

Ericsson AB                                        kernel 8.2                                       <u><a href="../man3erl/global.3erl.html">global</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>