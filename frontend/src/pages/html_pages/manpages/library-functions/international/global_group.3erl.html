<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>global_group - Grouping nodes to global name registration groups.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       global_group - Grouping nodes to global name registration groups.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  makes  it possible to partition the nodes of a system into <u>global</u> <u>groups</u>. Each global group
       has its own global namespace, see <u><a href="../man3erl/global.3erl.html">global</a>(3erl)</u>.

       The main advantage of dividing systems into global groups is that the background load decreases while the
       number of nodes to be updated is reduced when manipulating globally registered names.

       The Kernel configuration parameter <u>global_groups</u> defines  the  global  groups  (see  also  <u><a href="../man7/kernel.7.html">kernel</a>(7)</u>  and
       <u><a href="../man5/config.5.html">config</a>(5)</u>):

       {global_groups, [GroupTuple :: group_tuple()]}

       For  the processes and nodes to run smoothly using the global group functionality, the following criteria
       must be met:

         * An instance of the global group server, <u>global_group</u>, must be running on each node. The processes are
           automatically started and synchronized when a node is started.

         * All involved nodes must agree on the global group definition, otherwise the behavior of the system is
           undefined.

         * <u>All</u> nodes in the system must belong to exactly one global group.

       In the following descriptions, a <u>group</u> <u>node</u> is a node belonging to the same global  group  as  the  local
       node.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>group_tuple()</b> =
           {GroupName :: group_name(), [node()]} |
           {GroupName :: group_name(),
            PublishType :: publish_type(),
            [node()]}

              A <u>GroupTuple</u> without <u>PublishType</u> is the same as a <u>GroupTuple</u> with <u>PublishType</u> equal to <u>normal</u>.

       <b>group_name()</b> = atom()

       <b>publish_type()</b> = hidden | normal

              A  node  started with command-line flag <u>-hidden</u> (see <u><a href="../man1/erl.1.html">erl</a>(1)</u>) is said to be a <u>hidden</u> node. A hidden
              node establishes hidden connections to nodes not  part  of  the  same  global  group,  but  normal
              (visible) connections to nodes part of the same global group.

              A  global  group defined with <u>PublishType</u> equal to <u>hidden</u> is said to be a hidden global group. All
              nodes in a hidden global group are hidden nodes, whether they are started with  command-line  flag
              <u>-hidden</u> or not.

       <b>name()</b> = atom()

              A registered name.

       <b>where()</b> = {node, node()} | {group, group_name()}

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>global_groups()</b> <b>-&gt;</b> <b>{GroupName,</b> <b>GroupNames}</b> <b>|</b> <b>undefined</b>

              Types:

                 GroupName = group_name()
                 GroupNames = [GroupName]

              Returns  a  tuple  containing the name of the global group that the local node belongs to, and the
              list of all other known group names. Returns <u>undefined</u> if no global groups are defined.

       <b>info()</b> <b>-&gt;</b> <b>[info_item()]</b>

              Types:

                 <b>info_item()</b> =
                     {state, State :: sync_state()} |
                     {own_group_name, GroupName :: group_name()} |
                     {own_group_nodes, Nodes :: [node()]} |
                     {synched_nodes, Nodes :: [node()]} |
                     {sync_error, Nodes :: [node()]} |
                     {no_contact, Nodes :: [node()]} |
                     {other_groups, Groups :: [group_tuple()]} |
                     {monitoring, Pids :: [pid()]}
                 <b>sync_state()</b> = no_conf | synced

              Returns a list containing information about the global groups. Each list element is a  tuple.  The
              order of the tuples is undefined.

                <u>{state,</u> <u>State}</u>:
                  If the local node is part of a global group, <u>State</u> is equal to <u>synced</u>. If no global groups are
                  defined, <u>State</u> is equal to <u>no_conf</u>.

                <u>{own_group_name,</u> <u>GroupName}</u>:
                  The name (atom) of the group that the local node belongs to.

                <u>{own_group_nodes,</u> <u>Nodes}</u>:
                  A list of node names (atoms), the group nodes.

                <u>{synced_nodes,</u> <u>Nodes}</u>:
                  A list of node names, the group nodes currently synchronized with the local node.

                <u>{sync_error,</u> <u>Nodes}</u>:
                  A list of node names, the group nodes with which the local node has failed to synchronize.

                <u>{no_contact,</u> <u>Nodes}</u>:
                  A list of node names, the group nodes to which there are currently no connections.

                <u>{other_groups,</u> <u>Groups}</u>:
                  <u>Groups</u>  is  a  list  of  tuples <u>{GroupName,</u> <u>Nodes}</u>, specifying the name and nodes of the other
                  global groups.

                <u>{monitoring,</u> <u>Pids}</u>:
                  A list of pids, specifying the processes that have subscribed to <u>nodeup</u> and <u>nodedown</u> messages.

       <b>monitor_nodes(Flag)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Flag = boolean()

              Depending on <u>Flag</u>,  the  calling  process  starts  subscribing  (<u>Flag</u>  equal  to  <u>true</u>)  or  stops
              subscribing (<u>Flag</u> equal to <u>false</u>) to node status change messages.

              A  process  that  has  subscribed receives the messages <u>{nodeup,</u> <u>Node}</u> and <u>{nodedown,</u> <u>Node}</u> when a
              group node connects or disconnects, respectively.

       <b>own_nodes()</b> <b>-&gt;</b> <b>Nodes</b>

              Types:

                 Nodes = [Node :: node()]

              Returns the names of all group nodes, regardless of their current status.

       <b>registered_names(Where)</b> <b>-&gt;</b> <b>Names</b>

              Types:

                 Where = where()
                 Names = [Name :: name()]

              Returns a list of all names that are globally registered on the specified node or in the specified
              global group.

       <b>send(Name,</b> <b>Msg)</b> <b>-&gt;</b> <b>pid()</b> <b>|</b> <b>{badarg,</b> <b>{Name,</b> <b>Msg}}</b>

       <b>send(Where,</b> <b>Name,</b> <b>Msg)</b> <b>-&gt;</b> <b>pid()</b> <b>|</b> <b>{badarg,</b> <b>{Name,</b> <b>Msg}}</b>

              Types:

                 Where = where()
                 Name = name()
                 Msg = term()

              Searches for <u>Name</u>, globally registered on the specified node or in the specified global group,  or
              (if  argument  <u>Where</u>  is  not provided) in any global group. The global groups are searched in the
              order that they appear in the value of configuration parameter <u>global_groups</u>.

              If <u>Name</u> is found, message <u>Msg</u> is sent to the corresponding pid. The pid is also the  return  value
              of the function. If the name is not found, the function returns <u>{badarg,</u> <u>{Name,</u> <u>Msg}}</u>.

       <b>sync()</b> <b>-&gt;</b> <b>ok</b>

              Synchronizes the group nodes, that is, the global name servers on the group nodes. Also checks the
              names  globally  registered in the current global group and unregisters them on any known node not
              part of the group.

              If synchronization is not possible, an error  report  is  sent  to  the  error  logger  (see  also
              <u><a href="../man3erl/error_logger.3erl.html">error_logger</a>(3erl)</u>.

              Returns   <u>{error,</u>   <u>{'invalid</u>   <u>global_groups</u>   <u>definition',</u>   <u>Bad}}</u>  if  configuration  parameter
              <u>global_groups</u> has an invalid value <u>Bad</u>.

       <b>whereis_name(Name)</b> <b>-&gt;</b> <b>pid()</b> <b>|</b> <b>undefined</b>

       <b>whereis_name(Where,</b> <b>Name)</b> <b>-&gt;</b> <b>pid()</b> <b>|</b> <b>undefined</b>

              Types:

                 Where = where()
                 Name = name()

              Searches for <u>Name</u>, globally registered on the specified node or in the specified global group,  or
              (if  argument  <u>Where</u>  is  not provided) in any global group. The global groups are searched in the
              order that they appear in the value of configuration parameter <u>global_groups</u>.

              If <u>Name</u> is found, the corresponding pid is returned. If  the  name  is  not  found,  the  function
              returns <u>undefined</u>.

</pre><h4><b>NOTES</b></h4><pre>
         * In  the  situation  where a node has lost its connections to other nodes in its global group, but has
           connections to nodes in other global groups, a request from  another  global  group  can  produce  an
           incorrect  or misleading result. For example, the isolated node can have inaccurate information about
           registered names in its global group.

         * Function <u>send/2,3</u> is not secure.

         * Distribution of applications is  highly  dependent  of  the  global  group  definitions.  It  is  not
           recommended  that  an application is distributed over many global groups, as the registered names can
           be moved to another global group at failover/takeover. Nothing prevents this  to  be  done,  but  the
           application code must then handle the situation.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/global.3erl.html">global</a>(3erl)</u>, <u><a href="../man1/erl.1.html">erl</a>(1)</u>

Ericsson AB                                        kernel 8.2                                 <u><a href="../man3erl/global_group.3erl.html">global_group</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>