<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App::Rad - Rapid (and easy!) creation of command line applications</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libapp-rad-perl">libapp-rad-perl_1.05-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       App::Rad - Rapid (and easy!) creation of command line applications

</pre><h4><b>VERSION</b></h4><pre>
       Version 1.04

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This is your smallest working application (let's call it <u>myapp.pl</u>)

           use App::Rad;
           App::Rad-&gt;run();

       That's it, your program already works and you can use it directly via the command line (try it!)

           [user@host]$ ./myapp.pl
           Usage: myapp.pl command [arguments]

           Available Commands:
               help    show syntax and available commands

       Next, start creating your own functions (e.g.) inside <u>myapp.pl</u>:

           sub hello {
               return "Hello, World!";
           }

       And now your simple command line program <u>myapp.pl</u> has a 'hello' command!

           [user@host]$ ./myapp.pl
           Usage: myapp.pl command [arguments]

           Available Commands:
               hello
               help    show syntax and available commands

          [user@host]$ ./myapp.pl hello
          Hello, World!

       You could easily add a customized help message for your command through the '<b>Help()</b>' attribute:

           sub hello
           :Help(give a nice compliment)
           {
               return "Hello, World!";
           }

       And then, as expected:

           [user@host]$ ./myapp.pl
           Usage: myapp.pl command [arguments]

           Available Commands:
               hello   give a nice compliment
               help    show syntax and available commands

       App::Rad also lets you expand your applications, providing a lot of flexibility for every command, with
       embedded help, argument and options parsing, configuration file, default behavior, and much more:

           use App::Rad;
           App::Rad-&gt;run();

           sub setup {
               my $c = shift;

               $c-&gt;register_commands( {
                       foo =&gt; 'expand your foo!',
                       bar =&gt; 'have a drink! arguments: --drink=DRINK',
                   });
           }

           sub foo {
               my $c = shift;
               $c-&gt;load_config('myapp.conf');

               return 'foo expanded to ' . baz() * $c-&gt;config-&gt;{'myfoo'};
           }

           # note that 'baz' was not registered as a command,
           # so it can't be called from the outside.
           sub baz { <a href="../man10/rand.10.html">rand</a>(10) }

           sub bar {
               my $c = shift;
               if ( $c-&gt;options-&gt;{'drink'} ) {
                   return 'you asked for a ' . $c-&gt;options-&gt;{'drink'};
               }
               else {
                   return 'you need to ask for a drink';
               }
           }

       You can try on the command line:

          [user@host]$ ./myapp.pl
           Usage: myapp.pl command [arguments]

           Available Commands:
               bar     have a drink! arguments: --drink=DRINK
               foo     expand your foo!
               help    show syntax and available commands

          [user@host]$ ./myapp.pl bar --drink=martini
           you asked for a martini

</pre><h4><b>WARNING</b></h4><pre>
       This module is very young, likely to change in strange ways and to have some bugs (please report if you
       find any!). I will try to keep the API stable, but even that is subject to change (let me know if you
       find anything annoying or have a wishlist). You have been warned!

</pre><h4><b>DESCRIPTION</b></h4><pre>
       App::Rad aims to be a simple yet powerful framework for developing your command-line applications. It can
       easily transform your Perl <u>one-liners</u> into reusable subroutines than can be called directly by the user
       of your program.

       It also tries to provide a handy interface for your common command-line tasks. <b>If</b> <b>you</b> <b>have</b> <b>a</b> <b>feature</b>
       <b>request</b> <b>to</b> <b>easen</b> <b>out</b> <b>your</b> <b>tasks</b> <b>even</b> <b>more,</b> <b>please</b> <b>drop</b> <b>me</b> <b>an</b> <b>email</b> <b>or</b> <b>a</b> <b>RT</b> <b>feature</b> <b>request.</b>

   <b>Extending</b> <b>App::Rad</b> <b>-</b> <b>Plugins!</b>
       App::Rad plugins can be loaded by naming them as arguments to the "use App::Rad" statement. Just ommit
       the "App::Rad::Plugin" prefix from the plugin name. For example:

          use App::Rad  qw(My::Module);

       will load the "App::Rad::Plugin::My::Module" plugin for you!

       Developers are <b>strongly</b> encouraged to publish their App::Rad plugins under the "App::Rad::Plugin"
       namespace. But, if your plugin start with a name other than that, you can fully qualify the name by using
       an unary plus sign:

         use App::Rad  qw(
                 My::Module
                 +Fully::Qualified::Plugin::Name
         );

       Note that plugins are loaded in the order in which they appear.

       <b>Please</b> <b>refer</b> <b>to</b> <b>the</b> <b>actual</b> <b>plugin</b> <b>documentation</b> <b>for</b> <b>specific</b> <b>usage</b>. And check out App::Rad::Plugin if you
       want to create your own plugins.

</pre><h4><b>INSTANTIATION</b></h4><pre>
       These are the main execution calls for the application. In your App::Rad programs, the <b>*ONLY*</b> thing your
       script needs to actually (and actively) call is one of the instantiation (or dispatcher) methods. Leave
       all the rest to your subs. Currently, the only available dispatcher is <b>run()</b>:

   <b>run()</b>
       You'll be able to access all of your program's commands directly through the command line, as shown in
       the synopsis.

</pre><h4><b>BUILT-IN</b> <b>COMMANDS</b></h4><pre>
       This module comes with the following default commands. You are free to override them as you see fit.

   <b>help</b>
       Shows help information for your program. This built-in function displays the program name and all
       available commands (including the ones you added yourself) if a user types the 'help' command, or no
       command at all, or any command that does not exist (as they'd fall into the 'default' control function
       which (by default) calls 'help').

       You can also display specific embedded help for your commands, either explicitly registering them with
       "$c-&gt;register()" or "$c-&gt;register_commands()" inside "$c-&gt;setup()" (see respective sections below) or
       with the <b>Help()</b> attribute:

           use App::Rad;
           App::Rad-&gt;run();

           sub mycmd
           :Help(display a nice welcome message)
           {
               return "Welcome!";
           }

       the associated help text would go like this:

           [user@host]$ ./myapp.pl
           Usage: myapp.pl command [arguments]

           Available Commands:
               help    show syntax and available commands
               mycmd   display a nice welcome message

</pre><h4><b>OTHER</b> <b>BUILT</b> <b>IN</b> <b>COMMANDS</b> <b>(OPT-IN)</b></h4><pre>
       The 'include' and 'exclude' commands below let the user include and exclude commands to your program and,
       as this might be dangerous when the user is not yourself, you have to opt-in on them:

          use App::Rad qw(include);  # add the 'include' command
          use App::Rad qw(exclude);  # add the 'exclude' command

       though you'll probably want to set them both:

          use App::Rad qw(include exclude);

   <b>include</b> <u><b>[command_name]</b></u> <u><b>-perl_params</b></u> <u><b>'your</b></u> <u><b>subroutine</b></u> <u><b>code'</b></u>
       Includes the given subroutine into your program on-the-fly, just as you would writing it directly into
       your program.

       Let's say you have your simple <u>'myapp.pl'</u> program that uses App::Rad sitting on your system quietly. One
       day, perhaps during your sysadmin's tasks, you create a really amazing one-liner to solve a really hairy
       problem, and want to keep it for posterity (reusability is always a good thing!).

       For instance, to change a CSV file in place, adding a column on position #2 containing the line number,
       you might do something like this (this is merely illustrative, it's not actually the best way to do it):

           $ perl -i -paF, -le 'splice @F,1,0,$.; $_=join ",",@F' somesheet.csv

       And you just found out that you might use this other times. What do you do? App::Rad to the rescue!

       In the one-liner above, just switch <u>'perl'</u> to <u>'myapp.pl</u> <u>include</u> <u>SUBNAME'</u> and remove the trailing
       parameters (<u>somesheet.csv</u>):

           $ myapp.pl include addcsvcol -i -paF, -le 'splice @F,1,0,$.; $_=join ",",@F'

       That's it! Now myapp.pl has the 'addcsvcol' command (granted, not the best name) and you can call it
       directly whenever you want:

           $ myapp.pl addcsvcol somesheet.csv

       App::Rad not only transforms and adjusts your one-liner so it can be used inside your program, but also
       automatically formats it with Perl::Tidy (if you have it). This is what the one-liner above would look
       like inside your program:

           sub addcsvcol {
               my $c = shift;

               local ($^I) = "";
               local ($/)  = "\n";
               local ($\)  = "\n";
             LINE: while ( defined( $_ = &lt;ARGV&gt; ) ) {
                   chomp $_;
                   our (@F) = split( /,/, $_, 0 );
                   splice @F, 1, 0, $.;
                   $_ = join( ',', @F );
               }
               continue {
                   die "-p destination: $!\n" unless print $_;
               }
           }

       With so many arguments (-i, -p, -a -F,, -l -e), this is about as bad as it gets. And still one might find
       this way easier to document and mantain than a crude one-liner stored in your <a href="file:~/.bash_history">~/.bash_history</a> or similar.

       <b>Note:</b> If you don't supply a name for your command, App::Rad will make one up for you (cmd1, cmd2, ...).
       But don't do that, as you'll have a hard time figuring out what that specific command does.

       <b>Another</b> <b>Note:</b> <b>App::Rad</b> <b>tries</b> <b>to</b> <b>adjust</b> <b>the</b> <b>command</b> <b>to</b> <b>its</b> <b>interface,</b> <b>but</b> <b>please</b> <b>keep</b> <b>in</b> <b>mind</b> <b>this</b> <b>module</b>
       <b>is</b> <b>still</b> <b>in</b> <b>its</b> <b>early</b> <b>stages</b> <b>so</b> <b>it's</b> <b>not</b> <b>guaranteed</b> <b>to</b> <b>work</b> <b>every</b> <b>time.</b> <b>*PLEASE*</b> <b>let</b> <b>me</b> <b>know</b> <b>via</b> <b>email</b> <b>or</b>
       <b>RT</b> <b>bug</b> <b>request</b> <b>if</b> <b>your</b> <b>one-liner</b> <b>was</b> <b>not</b> <b>correctly</b> <b>translated</b> <b>into</b> <b>an</b> <b>App::Rad</b> <b>command.</b> <b>Thanks!</b>

   <b>exclude</b> <u><b>command_name</b></u>
       Removes the requested function from your program. Note that this will delete the actual code from your
       program, so be *extra* careful. It is strongly recommended that you do not use this command and either
       remove the subroutine yourself or add the function to your excluded list inside <u><b>setup()</b></u>.

       Note that built-in commands such as 'help' cannot be removed via <u>exclude</u>. They have to be added to your
       excluded list inside <u><b>setup()</b></u>.

</pre><h4><b>ROLLING</b> <b>YOUR</b> <b>OWN</b> <b>COMMANDS</b></h4><pre>
       Creating a new command is as easy as writing any sub inside your program. Some names ("setup", "default",
       "invalid", "pre_process", "post_process" and "teardown") are reserved for special purposes (see the
       <u>Control</u> <u>Functions</u> section of this document). App::Rad provides a nice interface for reading command line
       input and writing formatted output:

   <b>The</b> <b>Controller</b>
       Every command (sub) you create receives the controller object "$c" (sometimes referred as "$self" in
       other projects) as an argument. The controller is the main interface to App::Rad and has several methods
       to easen your command manipulation and execution tasks.

   <b>Reading</b> <b>arguments</b>
       When someone types in a command, she may pass some arguments to it. Those arguments can be accessed in
       four different ways, depending on what you want. This way it's up to you to control which and how many
       arguments (if at all) you want to receive and/or use. They are:

       <u>@ARGV</u>

       Perl's @ARGV array has all the arguments passed to your command, without the command name (use "$c-&gt;cmd"
       for this) and without any processing (even if you explicitly use "$c-&gt;getopt", which will change $c-&gt;argv
       instead, see below). Since the command itself won't be in the @ARGV parameters, you can use it in each
       command as if they were stand-alone programs.

       <u>$c-&gt;options</u>

       App::Rad lets you automatically retrieve any POSIX syntax command line options (<u>getopt-style</u>) passed to
       your command via the $c-&gt;options method. This method returns a hash reference with keys as given
       parameters and values as... well... values. The 'options' method automatically supports two simple
       argument structures:

       Extended (long) option. Translates "--parameter or --parameter=value" into "$c-&gt;options-&gt;{parameter}". If
       no value is supplied, it will be set to 1.

       Single-letter option. Translates "-p" into "$c-&gt;options-&gt;{p}".

       Single-letter options can be nested together, so "-abc" will be parsed into "$c-&gt;options-&gt;{a}",
       "$c-&gt;options-&gt;{b}" and "$c-&gt;options{c}", while "--abc" will be parsed into "$c-&gt;options-&gt;{abc}". We
       could, for instance, create a dice-rolling command like this:

           sub roll {
               my $c = shift;

               my $value = 0;
               for ( 1..$c-&gt;options-&gt;{'times'} ) {
                   $value += ( int(rand ($c-&gt;options-&gt;{'faces'}) + 1));
               }
               return $value;
           }

       And now you can call your 'roll' command like:

           [user@host]$ ./myapp.pl roll --faces=6 --times=2

       Note that App::Rad does not control which arguments can or cannot be passed: they are all parsed into
       "$c-&gt;options" and it's up to you to use whichever you want. For a more advanced use and control, see the
       "$c-&gt;getopt" method below.

       Also note that single-letter options will be set to 1. However, if a user types them more than once, the
       value will be incremented accordingly. For example, if a user calls your program like so:

          [user@host]$ ./myapp.pl some_command -vvv

       or

          [user@host]$ ./myapp.pl some_command -v -v -v

       then, in both cases, "$c-&gt;options-&gt;{v}" will be set to 3. This will let you easily keep track of how many
       times any given option was chosen, and still let you just check for definedness if you don't care about
       that.

       <u>$c-&gt;argv</u>

       The array reference "$c-&gt;argv" contains every argument passed to your command that have <b>not</b> been parsed
       into "$c-&gt;options". This is usually a list of every provided argument that didn't start with a dash (-),
       unless you've called "$c-&gt;getopt" and used something like 'param=s' (again, see below).

       <u>$c-&gt;getopt</u> <u>(Advanced</u> <u>Getopt</u> <u>usage)</u>

       App::Rad is also smoothly integrated with Getopt::Long, so you can have even more flexibility and power
       while parsing your command's arguments, such as aliases and types. Call the "$c-&gt;getopt()" method anytime
       inside your commands (or just once in your "pre_process" function to always have the same interface)
       passing a simple array with your options, and refer back to $c-&gt;options to see them. For instance:

           sub roll {
               my $c = shift;

               $c-&gt;getopt( 'faces|f=i', 'times|t=i' )
                   or $c-&gt;execute('usage') and return undef;

               # and now you have $c-&gt;options-&gt;{'faces'}
               # and $c-&gt;options-&gt;{'times'} just like above.
           }

       This becomes very handy for complex or feature-rich commands. Please refer to the Getopt::Long module for
       more usage examples.

       <b>So,</b> <b>in</b> <b>order</b> <b>to</b> <b>manipulate</b> <b>and</b> <b>use</b> <b>any</b> <b>arguments,</b> <b>remember:</b>

       •     The given command name does not appear in the argument list;

       •     All given arguments are in @ARGV

       •     Automatically processed arguments are in "$c-&gt;options"

       •     Non-processed arguments (the ones "$c-&gt;options" didn't catch) are in $c-&gt;argv

       •     You can use "$c-&gt;getopt" to have "Getopt::Long" parse your arguments (it will <b>not</b> change @ARGV)

   <b>Sharing</b> <b>Data:</b> <b>"$c-&gt;stash"</b>
       The "stash" is a universal hash for storing data among your Commands:

           $c-&gt;stash-&gt;{foo} = 'bar';
           $c-&gt;stash-&gt;{herculoids} = [ qw(igoo tundro zok gloop gleep) ];
           $c-&gt;stash-&gt;{application} = { name =&gt; 'My Application' };

       You can use it for more granularity and control over your program. For instance, you can email the output
       of a command if (and only if) something happened:

           sub command {
               my $c = shift;
               my $ret = do_something();

               if ( $ret =~ /critical error/ ) {
                   $c-&gt;stash-&gt;{mail} = 1;
               }
               return $ret;
           }

           sub post_process {
               my $c = shift;

               if ( $c-&gt;stash-&gt;{mail} ) {
                   # send email alert...
               }
               else {
                   print $c-&gt;output . "\n";
               }
           }

   <b>Returning</b> <b>output</b>
       Once you're through, return whatever you want to give as output for your command:

           my $ret = "Here's the list: ";
           $ret .= join ', ', 1..5;
           return $ret;

           # this prints "Here's the list: 1, 2, 3, 4, 5"

       App::Rad  lets  you  post-process the returned value of every command, so refrain from printing to STDOUT
       directly whenever possible as it will give much more power  to  your  programs.  See  the  <u><b>post_process()</b></u>
       control function further below in this document.

</pre><h4><b>HELPER</b> <b>METHODS</b></h4><pre>
       App::Rad's  controller  comes with several methods to help you manage your application easily. <b>If</b> <b>you</b> <b>can</b>
       <b>think</b> <b>of</b> <b>any</b> <b>other</b> <b>useful</b> <b>command</b> <b>that</b> <b>is</b> <b>not</b> <b>here,</b> <b>please</b> <b>drop</b> <b>me</b> <b>a</b> <b>line</b> <b>or</b> <b>RT</b> <b>request</b>.

   <b>$c-&gt;execute(</b> <u><b>COMMAND_NAME</b></u> <b>)</b>
       Runs the given command. If no command is given, runs the one stored in "$c-&gt;cmd". If the command does not
       exist, the  'default'  command  is  ran  instead.  Each  <u><b>execute()</b></u>  call  also  invokes  pre_process  and
       post_process, so you can easily manipulate income and outcome of every command.

   <b>$c-&gt;cmd</b>
       Returns  a  string containing the name of the command (that is, the first argument of your program), that
       will be called right after pre_process.

       <u>$c-&gt;command</u>

       Alias for "$c-&gt;cmd". This longer form is discouraged and may be removed in future versions,  as  one  may
       confuse it with the "$c-&gt;commands()" method, explained below. You have been warned.

   <b>$c-&gt;commands()</b>
       Returns a list of available commands (<u>functions</u>) inside your program

   <b>$c-&gt;is_command</b> <b>(</b> <u><b>COMMAND_NAME</b></u> <b>)</b>
       Returns 1 (true) if the given <u>COMMAND_NAME</u> is available, 0 (false) otherwise.

   <b>$c-&gt;create_command_name()</b>
       Returns  a valid name for a command (i.e. a name slot that's not been used by your program). This goes in
       the form of 'cmd1', 'cmd2', etc., so don't use unless you absolutely have  to.  App::Rad,  for  instance,
       uses this whenever you try to <u>include</u> (see below) a new command but do not supply a name for it.

   <b>$c-&gt;load_config(</b> <u><b>FILE</b></u> <u><b>(FILE2,</b></u> <u><b>FILE3,</b></u> <u><b>...)</b></u> <b>)</b>
       This method lets you easily load into your program one or more configuration files written like this:

           # comments and blank lines are discarded
           key1 value1
           key2:value2
           key3=value3
           key5           # stand-alone attribute (and inline-comment)

   <b>$c-&gt;config</b>
       Returns a hash reference with any loaded config values (see "$c-&gt;load_config()" above).

   <b>$c-&gt;register</b> <b>(</b> <u><b>NAME</b></u><b>,</b> <u><b>CODEREF</b></u> <b>[,</b> <u><b>INLINE_HELP</b></u> <b>])</b>
       Registers  a  coderef as a callable command. Note that you don't have to call this in order to register a
       sub inside your program as a command, <b>run()</b> will already do this for you - and if  you  don't  want  some
       subroutines  to  be  issued  as  commands  you can always use "$c-&gt;register_commands()" (note the plural)
       inside <b>setup()</b>. This is just an interface to dinamically include commands in your programs. The  function
       returns the command name in case of success, undef otherwise.

       It is also very useful for creating aliases for your commands:

           sub setup {
               my $c = shift;
               $c-&gt;register_commands();

               $c-&gt;register('myalias', \&amp;command);
           }

           sub command { return "Hi!" }

       and, on the command line:

           [user@host]$ ./myapp.pl command
           Hi!

           [user@host]@ ./myapp.pl myalias
           Hi!

       The last parameter is optional and lets you add inline help to your command:

           $c-&gt;register('cmd_name', \&amp;cmd_func, 'display secret of life');

       <u>$c-&gt;register_command</u> <u>(</u> <u>NAME,</u> <u>CODEREF</u> <u>[,</u> <u>INLINE_HELP</u> <u>]</u> <u>)</u>

       Longer   alias   for   "$c-&gt;register()".   It's   use  is  disencouraged  as  one  may  confuse  it  with
       "register_commands" (note the plural) below. Plus you type more :) As such, this method may be removed in
       future versions. You have been warned!

   <b>$c-&gt;register_commands()</b>
       This method, usually called during <b>setup()</b>, tells App::Rad to register subroutines as valid commands.  If
       called  without  any  parameters, it will register <b>all</b> subroutines in your main program as valid commands
       (note that the default behavior of App::Rad is to ignore subroutines starting with  an  underscore  '_').
       You can easily change this behavior using some of the options below:

       <u>Adding</u> <u>single</u> <u>commands</u>

           $c-&gt;register_commands( qw/foo bar baz/ );

       The code above will register <b>only</b> the subs "foo", "bar" and "baz" as commands. Other subroutines will <b>not</b>
       be  valid  commands,  so they can be used as internal subs for your program. You can change this behavior
       with the bundled options - see 'Adding several commands' and 'Putting it all together' below.

       <u>Adding</u> <u>single</u> <u>commands</u> <u>(with</u> <u>inline</u> <u>help)</u>

           $c-&gt;register_commands(
                   {
                       dos2unix =&gt; 'convert text files from DOS to Unix format',
                       unix2dos =&gt; 'convert text files from Unix to DOS format',
                   }
           );

       You can pass a hash reference containing commands as keys and a small help string as  their  values.  The
       code  above  will register <b>only</b> the subs "dos2unix" and "unix2dos", and the default help for your program
       will become something like this:

           [user@host]$ ./myapp.pl
           Usage: myapp.pl command [arguments]

           Available Commands:
               dos2unix    convert text files from DOS to Unix format
               help        show syntax and available commands
               unix2dos    convert text files from Unix to DOS format

       <u>Adding</u> <u>several</u> <u>commands</u>

       You can pass a hash reference as an argument, letting you choose which subroutines to  add  as  commands.
       The following keys may be used (note the dash preceding each key):

       •   "-ignore_prefix": subroutine names starting with the given string won't be added as commands

       •   "-ignore_suffix": subroutine names ending with the given string won't be added as commands

       •   "-ignore_regexp": subroutine names matching the given regular expression (as a string) won't be added
           as commands

       For example:

           use App::Rad;
           App::Rad-&gt;run();

           sub setup {
               my $c = shift;
               $c-&gt;register_commands( { -ignore_prefix =&gt; '_' } );
           }

           sub foo  {}  # will become a command
           sub bar  {}  # will become a command
           sub _baz {}  # will *NOT* become a command

       This  way  you  can  easily  segregate  between commands and helper functions, making your code even more
       reusable without jeopardizing the command line interface (As of  version  1.04,  ignoring  commands  with
       underscore '_' prefixes is also the default App::Rad behavior).

       <u>Putting</u> <u>it</u> <u>all</u> <u>together</u>

       You can combine some of the options above to have even more flexibility:

           $c-&gt;register_commands(
                   'foo',
                   { -ignore_suffix =&gt; 'foo' },
                   { bar =&gt; 'all your command line are belong to us' },
           );

       The  code  above  will register as commands all subs with names <b>not</b> ending in 'foo', but it <b>will</b> register
       the 'foo' sub as well. It will also give the 'bar' command the help string. This behavior  is  handy  for
       registering  several  commands  and having a few exceptions, or to add your commands and only have inline
       help for a few of them (as you see fit).

       You don't have to worry about the order of your elements passed, App::Rad will figure them out for you in
       a DWIM fashion.

           # this does the same as the code above
           $c-&gt;register_commands(
                   { bar =&gt; 'all your command line are belong to us' },
                   'foo',
                   { -ignore_suffix =&gt; 'foo' },
           );

       You can even bundle the hash reference to include your "cmd =&gt; help" and special keys:

           # this behaves the same way as the code above:
           $c-&gt;register_commands(
               'foo',
               {
                   -ignore_suffix =&gt; 'foo',
                   bar =&gt; 'all your command line are belong to us',
               }
           );

   <b>$c-&gt;unregister_command</b> <b>(</b> <u><b>NAME</b></u> <b>)</b>
       Longer alias for "$c-&gt;unregister()". The use of the shorter form is encouraged, and  this  alias  may  be
       removed in future versions. You have been warned.

       <u>$c-&gt;unregister</u> <u>(</u> <u>NAME</u> <u>)</u>

       Unregisters  a  given  command name so it's not available anymore. Note that the subroutine will still be
       there to be called from inside your program - it just won't be accessible via command line anymore.

   <b>$c-&gt;debug(</b> <u><b>MESSAGE</b></u> <b>)</b>
       Will print the given message on screen only if the debug flag is enabled:

           use App::Rad  qw( debug );

       Note that, if debug is enabled, App::Rad itself will print several debug  messages  stating  its  current
       flow, so you can easily find out where everything is happening.

   <b>$c-&gt;plugins()</b>
       Returns a list of all loaded plugins, in the order in which they were loaded.

   <b>$c-&gt;load_plugin(</b> <u><b>PLUGIN</b></u> <u><b>NAME</b></u> <b>)</b>
       This  method  will dinamically load the given plugin. The plugin needs to be under the "App::Rad::Plugin"
       namespace, and the name should be relative to this path (i.e.  $c-&gt;load_plugin('MyPlugin')  will  try  to
       load 'App::Rad::Plugin::MyPlugin'). If you want to load a plugin by its fully qualified name, you need to
       prepend  a  plus sign to the name ('+Fully::Qualified::Plugin::Name'). <b>This</b> <b>is</b> <b>an</b> <b>internal</b> <b>method</b> and you
       really should refrain from using it. Instead,  plugins  should  be  loaded  as  parameters  to  the  "use
       App::Rad" statement, as explained above.

</pre><h4><b>CONTROL</b> <b>FUNCTIONS</b> <b>(to</b> <b>possibly</b> <b>override)</b></h4><pre>
       App::Rad  implements  some  control functions which are expected to be overridden by implementing them in
       your program. They are as follows:

   <b>setup()</b>
       This function is responsible for setting up what your program can and cannot do, plus everything you need
       to set before actually running any command (connecting to a database or host, check and validate  things,
       download   a   document,   whatever).   Note   that,   if   you   override   <b>setup()</b>,   you  <b>*must*</b>  call
       "$c-&gt;register_commands()" or at least "$c-&gt;register()" so your subs  are  classified  as  valid  commands
       (check $c-&gt;<b>register_commands()</b> above for more information).

       Another  interesting thing you can do with setup is to manipulate the command list. For instance, you may
       want to be able to use the "include" and "exclude" commands, but not let them available for all users. So
       instead of writing:

           use App::Rad qw(include exclude);
           App::Rad-&gt;run();

       you can write something like this:

           use App::Rad;
           App::Rad-&gt;run();

           sub setup {
               my $c = shift;
               $c-&gt;register_commands();

               # EUID is 'root'
               if ( $&gt; == 0 ) {
                   $c-&gt;register('include', \&amp;App::Rad::include);
                   $c-&gt;register('exclude', \&amp;App::Rad::exclude);
               }
           }

       to get something like this:

           [user@host]$ myapp.pl help
           Usage: myapp.pl command [arguments]

           Available Commands:
              help

           [user@host]$ sudo myapp.pl help
           Usage: myapp.pl command [arguments]

           Available Commands:
              exclude
              help
              include

   <b>default()</b>
       If no command is given to your application, it will fall in here. Please note that invalid (non-existant)
       command will fall here too, but you can change this behavior with the <b>invalid()</b> function below  (although
       usually you don't want to).

       Default's default (grin) is just an alias for the help command.

           sub default {
               my $c = shift;

               # will fall here if the given
               # command isn't valid.
           }

       You  are free (and encouraged) to change the default behavior to whatever you want. This is rather useful
       for when your program will only do one thing, and as such it receives only parameters instead of  command
       names. In those cases, use the ""default()"" sub as your main program's sub and parse the parameters with
       "$c-&gt;argv" and "$c-&gt;getopt" as you would in any other command.

   <b>invalid()</b>
       This  is  a  special  function  to  provide  even  more  flexibility  while  creating  your  command line
       applications. This is called when the  user  requests  a  command  that  does  not  exist.  The  built-in
       "invalid()"  will  simply  redirect  itself to "default()" (see above), so usually you just have to worry
       about this when you want to differentiate  between  "no  command  given"  (with  or  without  getopt-like
       arguments) and "invalid command given" (with or without getopt-like arguments).

   <b>teardown()</b>
       If  implemented,  this  function  is  called automatically after your application runs. It can be used to
       clean up after your operations, removing temporary files, disconnecting a database connection established
       in the setup function, logging, sending data over a  network,  or  even  storing  state  information  via
       Storable or whatever.

   <b>pre_process()</b>
       If  implemented,  this function is called automatically right before the actual wanted command is called.
       This way you have an optional pre-run hook, which permits functionality to be added, such  as  preventing
       some commands to be run from a specific uid (e.g. <u>root</u>):

           sub pre_process {
               my $c = shift;

               if ( $c-&gt;cmd eq 'some_command' and $&gt; != 0 ) {
                   $c-&gt;cmd = 'default'; # or some standard error message
               }
           }

   <b>post_process()</b>
       If  implemented,  this  function  is called automatically right after the requested function returned. It
       receives the Controller object right after a given command has been executed  (and  hopefully  with  some
       output  returned),  so  you can manipulate it at will. In fact, the default "post_process" function is as
       goes:

           sub post_process {
               my $c = shift;

               if ( $c-&gt;output() ) {
                   print $c-&gt;output() . "\n";
               }
           }

       You can override this function to include a default header/footer for your programs (either  a  label  or
       perhaps  a  "Content-type:  "  string), parse the output in any ways you see fit (CPAN is your friend, as
       usual), etc.

</pre><h4><b>IMPORTANT</b> <b>NOTE</b> <b>ON</b> <b>PRINTING</b> <b>INSIDE</b> <b>YOUR</b> <b>COMMANDS</b></h4><pre>
       <b>The</b> <b>post_process()</b> <b>function</b> <b>above</b> <b>is</b> <b>why</b> <b>your</b> <b>application</b> <b>should</b> <b>*NEVER*</b> <b>print</b> <b>to</b> <b>STDOUT</b>. Using <u>print</u> (or
       <u>say</u>, in 5.10) to send output to STDOUT is exclusively the domain of the <b>post_process()</b> function. Breaking
       this rule is a common source of errors. If you want your functions to be interactive (for  instance)  and
       print  everything  themselves,  you  should  disable  post-processing  in  <b>setup()</b>,  or  create  an empty
       post_process function or make your functions return <u>undef</u> (so <u><b>post_process()</b></u> will only add a  blank  line
       to the output).

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       If  you  see a '1' printed on the screen after a command is issued, it's probably because that command is
       returning a "true" value instead of an output string. If you don't want to return the command output  for
       post  processing(you'll  loose  some  nice  features, though) you can return undef or make <b>post_process()</b>
       empty.

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
       App::Rad requires no configuration files or environment variables.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       App::Rad  depends  only  on  5.8  core  modules  (Carp  for  errors,   Getopt::Long   for   "$c-&gt;getopt",
       Attribute::Handlers for "help" and O/B::Deparse for the "include" command).

       If you have Perl::Tidy installed, the "include" command will tidy up your code before inclusion.

       The test suite depends on Test::More, FindBin and File::Temp, also core modules.

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       None reported.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       Please report any bugs or feature requests to "bug-app-easy at rt.cpan.org", or through the web interface
       at   &lt;<a href="http://rt.cpan.org/garu/ReportBug.html">http://rt.cpan.org/garu/ReportBug.html</a>?Queue=App-Rad&gt;.    I  will  be  notified,  and  then  you'll
       automatically be notified of progress on your bug as I make changes.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc App::Rad

       Although this Module comes without any warraties whatsoever (see DISCLAIMER below), I try really hard  to
       provide some quality assurance for the users. This means I not only try to close all reported bugs in the
       minimum amount of time but I also try to find some on my own.

       This  version  of  App::Rad  comes  with  183  tests  and  I  keep  my  eye  constantly  on  CPAN Testers
       &lt;<a href="http://www.cpantesters.org/show/App-Rad.html">http://www.cpantesters.org/show/App-Rad.html</a>&gt; to ensure it passes all of them, in all platforms. You can
       send me your own App::Rad tests if you feel I'm missing something  and  I'll  hapilly  add  them  to  the
       distribution.

       Since  I  take  user's  feedback  very  seriously, I really hope you send me any wishlist/TODO you'd like
       App::Rad to have (please try to send them via RT so other people can give their own suggestions).

       You can also look for information at:

       •   RT: CPAN's request tracker

           &lt;<a href="http://rt.cpan.org/garu/Bugs.html">http://rt.cpan.org/garu/Bugs.html</a>?Dist=App-Rad&gt;

       •   AnnoCPAN: Annotated CPAN documentation

           &lt;<a href="http://annocpan.org/dist/App-Rad">http://annocpan.org/dist/App-Rad</a>&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/App-Rad">http://cpanratings.perl.org/d/App-Rad</a>&gt;

       •   Search CPAN

           &lt;<a href="http://search.cpan.org/dist/App-Rad">http://search.cpan.org/dist/App-Rad</a>&gt;

   <b>IRC</b>
          #app-rad  on irc.perl.org

</pre><h4><b>TODO</b></h4><pre>
       This is a small list of features I plan to add in the near future (in no particular order). Feel free  to
       contribute with your wishlist and comentaries!

       •   Shell-like environment

       •   Loadable commands (in an external container file)

       •   Modularized commands (similar to App::Cmd::Commands ?)

       •   app-starter

       •   command inclusion by prefix, suffix and regexp (feature request by fco)

       •   command inclusion and exclusion also by attributes

       •   some extra integration, maybe IPC::Cmd and IO::Prompt

</pre><h4><b>AUTHOR</b></h4><pre>
       Breno G. de Oliveira, "&lt;garu at cpan.org&gt;"

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       (in alphabetical order)

       Ben Hengst

       Fernando Correa

       Flavio Glock

       Thanks to everyone for contributing! Please let me know if I've skipped your name by accident.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       This  module  was  inspired  by  Kenichi  Ishigaki's  presentation <u>"Web</u> <u>is</u> <u>not</u> <u>the</u> <u>only</u> <u>one</u> <u>that</u> <u>requires</u>
       <u>frameworks"</u> during YAPC::Asia::2008 and the modules it exposed (mainly App::Cmd and App::CLI).

       Also, many thanks to CGI::App(now Titanium)'s Mark Stosberg and all the Catalyst developers, as  some  of
       App::Rad's functionality was taken from those (web) frameworks.

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright 2008 Breno G. de Oliveira "&lt;garu at cpan.org&gt;". All rights reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself. See perlartistic.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE,  TO  THE  EXTENT
       PERMITTED  BY  APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
       PARTIES PROVIDE THE SOFTWARE "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND,  EITHER  EXPRESSED  OR  IMPLIED,
       INCLUDING,  BUT  NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
       PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF  THE  SOFTWARE  IS  WITH  YOU.  SHOULD  THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN  NO  EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY
       OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE  LIABLE
       TO  YOU  FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF
       THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING BUT NOT  LIMITED  TO  LOSS  OF  DATA  OR  DATA  BEING
       RENDERED  INACCURATE  OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO OPERATE
       WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF  SUCH
       DAMAGES.

perl v5.36.0                                       2022-10-13                                      <u>App::<a href="../man3pm/Rad.3pm.html">Rad</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>