<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>opus_multistream - Opus Multistream API</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libopus-doc">libopus-doc_1.5.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       opus_multistream - Opus Multistream API

        - The multistream API allows individual Opus streams to be combined into a single packet, enabling
       support for up to 255 channels.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Typedefs</b>
       typedef struct <b>OpusMSEncoder</b> <b>OpusMSEncoder</b>
           Opus multistream encoder state.
       typedef struct <b>OpusMSDecoder</b> <b>OpusMSDecoder</b>
           Opus multistream decoder state.

   <b>Multistream</b> <b>encoder</b> <b>functions</b>
       <b>opus_int32</b> <b>opus_multistream_encoder_get_size</b> (int streams, int coupled_streams)
           Gets the size of an OpusMSEncoder structure.
       <b>opus_int32</b> <b>opus_multistream_surround_encoder_get_size</b> (int channels, int mapping_family)
       <b>OpusMSEncoder</b> * <b>opus_multistream_encoder_create</b> (<b>opus_int32</b> Fs, int channels, int streams, int
           coupled_streams, const unsigned char *mapping, int application, int *error)
           Allocates and initializes a multistream encoder state.
       <b>OpusMSEncoder</b> * <b>opus_multistream_surround_encoder_create</b> (<b>opus_int32</b> Fs, int channels, int
           mapping_family, int *streams, int *coupled_streams, unsigned char *mapping, int application, int
           *error)
       int <b>opus_multistream_encoder_init</b> (<b>OpusMSEncoder</b> *st, <b>opus_int32</b> Fs, int channels, int streams, int
           coupled_streams, const unsigned char *mapping, int application)
           Initialize a previously allocated multistream encoder state.
       int <b>opus_multistream_surround_encoder_init</b> (<b>OpusMSEncoder</b> *st, <b>opus_int32</b> Fs, int channels, int
           mapping_family, int *streams, int *coupled_streams, unsigned char *mapping, int application)
       int <b>opus_multistream_encode</b> (<b>OpusMSEncoder</b> *st, const <b>opus_int16</b> *pcm, int frame_size, unsigned char
           *data, <b>opus_int32</b> max_data_bytes)
           Encodes a multistream Opus frame.
       int <b>opus_multistream_encode_float</b> (<b>OpusMSEncoder</b> *st, const float *pcm, int frame_size, unsigned char
           *data, <b>opus_int32</b> max_data_bytes)
           Encodes a multistream Opus frame from floating point input.
       void <b>opus_multistream_encoder_destroy</b> (<b>OpusMSEncoder</b> *st)
           Frees an OpusMSEncoder allocated by <b>opus_multistream_encoder_create()</b>.
       int <b>opus_multistream_encoder_ctl</b> (<b>OpusMSEncoder</b> *st, int request,...)
           Perform a CTL function on a multistream Opus encoder.

   <b>Multistream</b> <b>decoder</b> <b>functions</b>
       <b>opus_int32</b> <b>opus_multistream_decoder_get_size</b> (int streams, int coupled_streams)
           Gets the size of an OpusMSDecoder structure.
       <b>OpusMSDecoder</b> * <b>opus_multistream_decoder_create</b> (<b>opus_int32</b> Fs, int channels, int streams, int
           coupled_streams, const unsigned char *mapping, int *error)
           Allocates and initializes a multistream decoder state.
       int <b>opus_multistream_decoder_init</b> (<b>OpusMSDecoder</b> *st, <b>opus_int32</b> Fs, int channels, int streams, int
           coupled_streams, const unsigned char *mapping)
           Initialize a previously allocated decoder state object.
       int <b>opus_multistream_decode</b> (<b>OpusMSDecoder</b> *st, const unsigned char *data, <b>opus_int32</b> len, <b>opus_int16</b>
           *pcm, int frame_size, int decode_fec)
           Decode a multistream Opus packet.
       int <b>opus_multistream_decode_float</b> (<b>OpusMSDecoder</b> *st, const unsigned char *data, <b>opus_int32</b> len, float
           *pcm, int frame_size, int decode_fec)
           Decode a multistream Opus packet with floating point output.
       int <b>opus_multistream_decoder_ctl</b> (<b>OpusMSDecoder</b> *st, int request,...)
           Perform a CTL function on a multistream Opus decoder.
       void <b>opus_multistream_decoder_destroy</b> (<b>OpusMSDecoder</b> *st)
           Frees an OpusMSDecoder allocated by <b>opus_multistream_decoder_create()</b>.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       The multistream API allows individual Opus streams to be combined into a single packet, enabling support
       for up to 255 channels.

       Unlike an elementary Opus stream, the encoder and decoder must negotiate the channel configuration before
       the decoder can successfully interpret the data in the packets produced by the encoder. Some basic
       information, such as packet duration, can be computed without any special negotiation.

       The format for multistream Opus packets is defined in RFC 7845 and is based on the self-delimited Opus
       framing described in Appendix B of RFC 6716. Normal Opus packets are just a degenerate case of
       multistream Opus packets, and can be encoded or decoded with the multistream API by setting streams to 1
       when initializing the encoder or decoder.

       Multistream Opus streams can contain up to 255 elementary Opus streams. These may be either 'uncoupled'
       or 'coupled', indicating that the decoder is configured to decode them to either 1 or 2 channels,
       respectively. The streams are ordered so that all coupled streams appear at the beginning.

       A mapping table defines which decoded channel i should be used for each input/output (I/O) channel j.
       This table is typically provided as an unsigned char array. Let i = mapping[j] be the index for I/O
       channel j. If i &lt; 2*coupled_streams, then I/O channel j is encoded as the left channel of stream (i/2) if
       i is even, or as the right channel of stream (i/2) if i is odd. Otherwise, I/O channel j is encoded as
       mono in stream (i - coupled_streams), unless it has the special value 255, in which case it is omitted
       from the encoding entirely (the decoder will reproduce it as silence). Each value i must either be the
       special value 255 or be less than streams + coupled_streams.

       The output channels specified by the encoder should use the Vorbis channel ordering. A decoder may wish
       to apply an additional permutation to the mapping the encoder used to achieve a different output channel
       order (e.g. for outputting in WAV order).

       Each multistream packet contains an Opus packet for each stream, and all of the Opus packets in a single
       multistream packet must have the same duration. Therefore the duration of a multistream packet can be
       extracted from the TOC sequence of the first stream, which is located at the beginning of the packet,
       just like an elementary Opus stream:

       int nb_samples;
       int nb_frames;
       nb_frames = opus_packet_get_nb_frames(data, len);
       if (nb_frames &lt; 1)
         return nb_frames;
       nb_samples = opus_packet_get_samples_per_frame(data, 48000) * nb_frames;

       The general encoding and decoding process proceeds exactly the same as in the normal <b>Opus</b> <b>Encoder</b> and
       <b>Opus</b> <b>Decoder</b> APIs. See their documentation for an overview of how to use the corresponding multistream
       functions.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>struct</b> <b>OpusMSDecoder</b> <b>OpusMSDecoder</b>
       Opus multistream decoder state. This contains the complete state of a multistream Opus decoder. It is
       position independent and can be freely copied.

       <b>See</b> <b>also</b>
           <b>opus_multistream_decoder_create</b>

           <b>opus_multistream_decoder_init</b>

   <b>typedef</b> <b>struct</b> <b>OpusMSEncoder</b> <b>OpusMSEncoder</b>
       Opus multistream encoder state. This contains the complete state of a multistream Opus encoder. It is
       position independent and can be freely copied.

       <b>See</b> <b>also</b>
           <b>opus_multistream_encoder_create</b>

           <b>opus_multistream_encoder_init</b>

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>int</b> <b>opus_multistream_decode</b> <b>(OpusMSDecoder</b> <b>*</b> <b>st,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>data,</b> <b>opus_int32</b> <b>len,</b> <b>opus_int16</b> <b>*</b>
       <b>pcm,</b> <b>int</b> <b>frame_size,</b> <b>int</b> <b>decode_fec)</b>
       Decode a multistream Opus packet.

       <b>Parameters</b>
           <u>st</u> OpusMSDecoder*: Multistream decoder state.
           <u>data</u> const unsigned char*: Input payload. Use a NULL pointer to indicate packet loss.
           <u>len</u> opus_int32: Number of bytes in payload.
           <u>pcm</u> opus_int16*: Output signal, with interleaved samples. This must contain room for
           frame_size*channels samples.
           <u>frame_size</u> int: The number of samples per channel of available space in <u>pcm</u>. If this is less than the
           maximum packet duration (120 ms; 5760 for 48kHz), this function will not be capable of decoding some
           packets. In the case of PLC (data==NULL) or FEC (decode_fec=1), then frame_size needs to be exactly
           the duration of audio that is missing, otherwise the decoder will not be in the optimal state to
           decode the next incoming packet. For the PLC and FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.
           <u>decode_fec</u> int: Flag (0 or 1) to request that any in-band forward error correction data be decoded.
           If no such data is available, the frame is decoded as if it were lost.

       <b>Returns</b>
           Number of samples decoded on success or a negative error code (see <b>Error</b> <b>codes</b>) on failure.

   <b>int</b> <b>opus_multistream_decode_float</b> <b>(OpusMSDecoder</b> <b>*</b> <b>st,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>data,</b> <b>opus_int32</b> <b>len,</b> <b>float</b> <b>*</b>
       <b>pcm,</b> <b>int</b> <b>frame_size,</b> <b>int</b> <b>decode_fec)</b>
       Decode a multistream Opus packet with floating point output.

       <b>Parameters</b>
           <u>st</u> OpusMSDecoder*: Multistream decoder state.
           <u>data</u> const unsigned char*: Input payload. Use a NULL pointer to indicate packet loss.
           <u>len</u> opus_int32: Number of bytes in payload.
           <u>pcm</u> opus_int16*: Output signal, with interleaved samples. This must contain room for
           frame_size*channels samples.
           <u>frame_size</u> int: The number of samples per channel of available space in <u>pcm</u>. If this is less than the
           maximum packet duration (120 ms; 5760 for 48kHz), this function will not be capable of decoding some
           packets. In the case of PLC (data==NULL) or FEC (decode_fec=1), then frame_size needs to be exactly
           the duration of audio that is missing, otherwise the decoder will not be in the optimal state to
           decode the next incoming packet. For the PLC and FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.
           <u>decode_fec</u> int: Flag (0 or 1) to request that any in-band forward error correction data be decoded.
           If no such data is available, the frame is decoded as if it were lost.

       <b>Returns</b>
           Number of samples decoded on success or a negative error code (see <b>Error</b> <b>codes</b>) on failure.

   <b>OpusMSDecoder</b> <b>*</b> <b>opus_multistream_decoder_create</b> <b>(opus_int32</b> <b>Fs,</b> <b>int</b> <b>channels,</b> <b>int</b> <b>streams,</b> <b>int</b>
       <b>coupled_streams,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>mapping,</b> <b>int</b> <b>*</b> <b>error)</b>
       Allocates and initializes a multistream decoder state. Call <b>opus_multistream_decoder_destroy()</b> to release
       this object when finished.

       <b>Parameters</b>
           <u>Fs</u> opus_int32: Sampling rate to decode at (in Hz). This must be one of 8000, 12000, 16000, 24000, or
           48000.
           <u>channels</u> int: Number of channels to output. This must be at most 255. It may be different from the
           number of coded channels (streams + coupled_streams).
           <u>streams</u> int: The total number of streams coded in the input. This must be no more than 255.
           <u>coupled_streams</u> int: Number of streams to decode as coupled (2 channel) streams. This must be no
           larger than the total number of streams. Additionally, The total number of coded channels (streams +
           coupled_streams) must be no more than 255.
           <u>mapping</u> const unsigned char[channels]: Mapping from coded channels to output channels, as described
           in <b>Opus</b> <b>Multistream</b> <b>API</b>.
           <u>error</u> int *: Returns <b>OPUS_OK</b> on success, or an error code (see <b>Error</b> <b>codes</b>) on failure.

   <b>int</b> <b>opus_multistream_decoder_ctl</b> <b>(OpusMSDecoder</b> <b>*</b> <b>st,</b> <b>int</b> <b>request,</b>  <b>...)</b>
       Perform a CTL function on a multistream Opus decoder. Generally the request and subsequent arguments are
       generated by a convenience macro.

       <b>Parameters</b>
           <u>st</u> OpusMSDecoder*: Multistream decoder state.
           <u>request</u> This and all remaining parameters should be replaced by one of the convenience macros in
           <b>Generic</b> <b>CTLs</b>, <b>Decoder</b> <b>related</b> <b>CTLs</b>, or <b>Multistream</b> <b>specific</b> <b>encoder</b> <b>and</b> <b>decoder</b> <b>CTLs</b>.

       <b>See</b> <b>also</b>
           <b>Generic</b> <b>CTLs</b>

           <b>Decoder</b> <b>related</b> <b>CTLs</b>

           <b>Multistream</b> <b>specific</b> <b>encoder</b> <b>and</b> <b>decoder</b> <b>CTLs</b>

   <b>void</b> <b>opus_multistream_decoder_destroy</b> <b>(OpusMSDecoder</b> <b>*</b> <b>st)</b>
       Frees an OpusMSDecoder allocated by <b>opus_multistream_decoder_create()</b>.

       <b>Parameters</b>
           <u>st</u> OpusMSDecoder: Multistream decoder state to be freed.

   <b>opus_int32</b> <b>opus_multistream_decoder_get_size</b> <b>(int</b> <b>streams,</b> <b>int</b> <b>coupled_streams)</b>
       Gets the size of an OpusMSDecoder structure.

       <b>Parameters</b>
           <u>streams</u> int: The total number of streams coded in the input. This must be no more than 255.
           <u>coupled_streams</u> int: Number streams to decode as coupled (2 channel) streams. This must be no larger
           than the total number of streams. Additionally, The total number of coded channels (streams +
           coupled_streams) must be no more than 255.

       <b>Returns</b>
           The size in bytes on success, or a negative error code (see <b>Error</b> <b>codes</b>) on error.

   <b>int</b> <b>opus_multistream_decoder_init</b> <b>(OpusMSDecoder</b> <b>*</b> <b>st,</b> <b>opus_int32</b> <b>Fs,</b> <b>int</b> <b>channels,</b> <b>int</b> <b>streams,</b> <b>int</b>
       <b>coupled_streams,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>mapping)</b>
       Initialize a previously allocated decoder state object. The memory pointed to by <u>st</u> must be at least the
       size returned by <b>opus_multistream_encoder_get_size()</b>. This is intended for applications which use their
       own allocator instead of malloc. To reset a previously initialized state, use the <b>OPUS_RESET_STATE</b> CTL.

       <b>See</b> <b>also</b>
           <b>opus_multistream_decoder_create</b>

           opus_multistream_deocder_get_size

       <b>Parameters</b>
           <u>st</u> OpusMSEncoder*: Multistream encoder state to initialize.
           <u>Fs</u> opus_int32: Sampling rate to decode at (in Hz). This must be one of 8000, 12000, 16000, 24000, or
           48000.
           <u>channels</u> int: Number of channels to output. This must be at most 255. It may be different from the
           number of coded channels (streams + coupled_streams).
           <u>streams</u> int: The total number of streams coded in the input. This must be no more than 255.
           <u>coupled_streams</u> int: Number of streams to decode as coupled (2 channel) streams. This must be no
           larger than the total number of streams. Additionally, The total number of coded channels (streams +
           coupled_streams) must be no more than 255.
           <u>mapping</u> const unsigned char[channels]: Mapping from coded channels to output channels, as described
           in <b>Opus</b> <b>Multistream</b> <b>API</b>.

       <b>Returns</b>
           <b>OPUS_OK</b> on success, or an error code (see <b>Error</b> <b>codes</b>) on failure.

   <b>int</b> <b>opus_multistream_encode</b> <b>(OpusMSEncoder</b> <b>*</b> <b>st,</b> <b>const</b> <b>opus_int16</b> <b>*</b> <b>pcm,</b> <b>int</b> <b>frame_size,</b> <b>unsigned</b> <b>char</b> <b>*</b>
       <b>data,</b> <b>opus_int32</b> <b>max_data_bytes)</b>
       Encodes a multistream Opus frame.

       <b>Parameters</b>
           <u>st</u> OpusMSEncoder*: Multistream encoder state.
           <u>pcm</u> const opus_int16*: The input signal as interleaved samples. This must contain frame_size*channels
           samples.
           <u>frame_size</u> int: Number of samples per channel in the input signal. This must be an Opus frame size
           for the encoder's sampling rate. For example, at 48 kHz the permitted values are 120, 240, 480, 960,
           1920, and 2880. Passing in a duration of less than 10 ms (480 samples at 48 kHz) will prevent the
           encoder from using the LPC or hybrid modes.
           <u>data</u> unsigned char*: Output payload. This must contain storage for at least <u>max_data_bytes</u>.
           <u>max_data_bytes</u> opus_int32: Size of the allocated memory for the output payload. This may be used to
           impose an upper limit on the instant bitrate, but should not be used as the only bitrate control. Use
           <b>OPUS_SET_BITRATE</b> to control the bitrate.

       <b>Returns</b>
           The length of the encoded packet (in bytes) on success or a negative error code (see <b>Error</b> <b>codes</b>) on
           failure.

   <b>int</b> <b>opus_multistream_encode_float</b> <b>(OpusMSEncoder</b> <b>*</b> <b>st,</b> <b>const</b> <b>float</b> <b>*</b> <b>pcm,</b> <b>int</b> <b>frame_size,</b> <b>unsigned</b> <b>char</b> <b>*</b>
       <b>data,</b> <b>opus_int32</b> <b>max_data_bytes)</b>
       Encodes a multistream Opus frame from floating point input.

       <b>Parameters</b>
           <u>st</u> OpusMSEncoder*: Multistream encoder state.
           <u>pcm</u> const float*: The input signal as interleaved samples with a normal range of +/-1.0. Samples with
           a range beyond +/-1.0 are supported but will be clipped by decoders using the integer API and should
           only be used if it is known that the far end supports extended dynamic range. This must contain
           frame_size*channels samples.
           <u>frame_size</u> int: Number of samples per channel in the input signal. This must be an Opus frame size
           for the encoder's sampling rate. For example, at 48 kHz the permitted values are 120, 240, 480, 960,
           1920, and 2880. Passing in a duration of less than 10 ms (480 samples at 48 kHz) will prevent the
           encoder from using the LPC or hybrid modes.
           <u>data</u> unsigned char*: Output payload. This must contain storage for at least <u>max_data_bytes</u>.
           <u>max_data_bytes</u> opus_int32: Size of the allocated memory for the output payload. This may be used to
           impose an upper limit on the instant bitrate, but should not be used as the only bitrate control. Use
           <b>OPUS_SET_BITRATE</b> to control the bitrate.

       <b>Returns</b>
           The length of the encoded packet (in bytes) on success or a negative error code (see <b>Error</b> <b>codes</b>) on
           failure.

   <b>OpusMSEncoder</b> <b>*</b> <b>opus_multistream_encoder_create</b> <b>(opus_int32</b> <b>Fs,</b> <b>int</b> <b>channels,</b> <b>int</b> <b>streams,</b> <b>int</b>
       <b>coupled_streams,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>mapping,</b> <b>int</b> <b>application,</b> <b>int</b> <b>*</b> <b>error)</b>
       Allocates and initializes a multistream encoder state. Call <b>opus_multistream_encoder_destroy()</b> to release
       this object when finished.

       <b>Parameters</b>
           <u>Fs</u> opus_int32: Sampling rate of the input signal (in Hz). This must be one of 8000, 12000, 16000,
           24000, or 48000.
           <u>channels</u> int: Number of channels in the input signal. This must be at most 255. It may be greater
           than the number of coded channels (streams + coupled_streams).
           <u>streams</u> int: The total number of streams to encode from the input. This must be no more than the
           number of channels.
           <u>coupled_streams</u> int: Number of coupled (2 channel) streams to encode. This must be no larger than the
           total number of streams. Additionally, The total number of encoded channels (streams +
           coupled_streams) must be no more than the number of input channels.
           <u>mapping</u> const unsigned char[channels]: Mapping from encoded channels to input channels, as described
           in <b>Opus</b> <b>Multistream</b> <b>API</b>. As an extra constraint, the multistream encoder does not allow encoding
           coupled streams for which one channel is unused since this is never a good idea.
           <u>application</u> int: The target encoder application. This must be one of the following:

           <b>OPUS_APPLICATION_VOIP</b>
               Process signal for improved speech intelligibility.

           <b>OPUS_APPLICATION_AUDIO</b>
               Favor faithfulness to the original input.

           <b>OPUS_APPLICATION_RESTRICTED_LOWDELAY</b>
               Configure the minimum possible coding delay by disabling certain modes of operation.

           <u>error</u> int *: Returns <b>OPUS_OK</b> on success, or an error code (see <b>Error</b> <b>codes</b>) on failure.

   <b>int</b> <b>opus_multistream_encoder_ctl</b> <b>(OpusMSEncoder</b> <b>*</b> <b>st,</b> <b>int</b> <b>request,</b>  <b>...)</b>
       Perform  a CTL function on a multistream Opus encoder. Generally the request and subsequent arguments are
       generated by a convenience macro.

       <b>Parameters</b>
           <u>st</u> OpusMSEncoder*: Multistream encoder state.
           <u>request</u> This and all remaining parameters should be replaced by one  of  the  convenience  macros  in
           <b>Generic</b> <b>CTLs</b>, <b>Encoder</b> <b>related</b> <b>CTLs</b>, or <b>Multistream</b> <b>specific</b> <b>encoder</b> <b>and</b> <b>decoder</b> <b>CTLs</b>.

       <b>See</b> <b>also</b>
           <b>Generic</b> <b>CTLs</b>

           <b>Encoder</b> <b>related</b> <b>CTLs</b>

           <b>Multistream</b> <b>specific</b> <b>encoder</b> <b>and</b> <b>decoder</b> <b>CTLs</b>

   <b>void</b> <b>opus_multistream_encoder_destroy</b> <b>(OpusMSEncoder</b> <b>*</b> <b>st)</b>
       Frees an OpusMSEncoder allocated by <b>opus_multistream_encoder_create()</b>.

       <b>Parameters</b>
           <u>st</u> OpusMSEncoder*: Multistream encoder state to be freed.

   <b>opus_int32</b> <b>opus_multistream_encoder_get_size</b> <b>(int</b> <b>streams,</b> <b>int</b> <b>coupled_streams)</b>
       Gets the size of an OpusMSEncoder structure.

       <b>Parameters</b>
           <u>streams</u> int: The total number of streams to encode from the input. This must be no more than 255.
           <u>coupled_streams</u> int: Number of coupled (2 channel) streams to encode. This must be no larger than the
           total   number   of   streams.  Additionally,  The  total  number  of  encoded  channels  (streams  +
           coupled_streams) must be no more than 255.

       <b>Returns</b>
           The size in bytes on success, or a negative error code (see <b>Error</b> <b>codes</b>) on error.

   <b>int</b> <b>opus_multistream_encoder_init</b> <b>(OpusMSEncoder</b>  <b>*</b>  <b>st,</b>  <b>opus_int32</b>  <b>Fs,</b>  <b>int</b>  <b>channels,</b>  <b>int</b>  <b>streams,</b>  <b>int</b>
       <b>coupled_streams,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>mapping,</b> <b>int</b> <b>application)</b>
       Initialize a previously allocated multistream encoder state. The memory pointed to by <u>st</u> must be at least
       the  size  returned  by  <b>opus_multistream_encoder_get_size()</b>. This is intended for applications which use
       their own allocator instead of malloc. To reset a previously initialized state, use the  <b>OPUS_RESET_STATE</b>
       CTL.

       <b>See</b> <b>also</b>
           <b>opus_multistream_encoder_create</b>

           <b>opus_multistream_encoder_get_size</b>

       <b>Parameters</b>
           <u>st</u> OpusMSEncoder*: Multistream encoder state to initialize.
           <u>Fs</u>  opus_int32:  Sampling  rate  of the input signal (in Hz). This must be one of 8000, 12000, 16000,
           24000, or 48000.
           <u>channels</u> int: Number of channels in the input signal. This must be at most 255.  It  may  be  greater
           than the number of coded channels (streams + coupled_streams).
           <u>streams</u>  int:  The  total  number  of streams to encode from the input. This must be no more than the
           number of channels.
           <u>coupled_streams</u> int: Number of coupled (2 channel) streams to encode. This must be no larger than the
           total  number  of  streams.  Additionally,  The  total  number  of  encoded   channels   (streams   +
           coupled_streams) must be no more than the number of input channels.
           <u>mapping</u>  const unsigned char[channels]: Mapping from encoded channels to input channels, as described
           in <b>Opus</b> <b>Multistream</b> <b>API</b>. As an extra constraint, the multistream  encoder  does  not  allow  encoding
           coupled streams for which one channel is unused since this is never a good idea.
           <u>application</u> int: The target encoder application. This must be one of the following:

           <b>OPUS_APPLICATION_VOIP</b>
               Process signal for improved speech intelligibility.

           <b>OPUS_APPLICATION_AUDIO</b>
               Favor faithfulness to the original input.

           <b>OPUS_APPLICATION_RESTRICTED_LOWDELAY</b>
               Configure the minimum possible coding delay by disabling certain modes of operation.

       <b>Returns</b>
           <b>OPUS_OK</b> on success, or an error code (see <b>Error</b> <b>codes</b>) on failure.

   <b>OpusMSEncoder</b>  <b>*</b>  <b>opus_multistream_surround_encoder_create</b>  <b>(opus_int32</b> <b>Fs,</b> <b>int</b> <b>channels,</b> <b>int</b> <b>mapping_family,</b>
       <b>int</b> <b>*</b> <b>streams,</b> <b>int</b> <b>*</b> <b>coupled_streams,</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>mapping,</b> <b>int</b> <b>application,</b> <b>int</b> <b>*</b> <b>error)</b>
   <b>opus_int32</b> <b>opus_multistream_surround_encoder_get_size</b> <b>(int</b> <b>channels,</b> <b>int</b> <b>mapping_family)</b>
   <b>int</b>  <b>opus_multistream_surround_encoder_init</b>  <b>(OpusMSEncoder</b>  <b>*</b>  <b>st,</b>  <b>opus_int32</b>   <b>Fs,</b>   <b>int</b>   <b>channels,</b>   <b>int</b>
       <b>mapping_family,</b> <b>int</b> <b>*</b> <b>streams,</b> <b>int</b> <b>*</b> <b>coupled_streams,</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>mapping,</b> <b>int</b> <b>application)</b>
</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for Opus from the source code.

Version 1.5.2                                Wed Jul 3 2024 11:41:33                         <u><a href="../man3/opus_multistream.3.html">opus_multistream</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>