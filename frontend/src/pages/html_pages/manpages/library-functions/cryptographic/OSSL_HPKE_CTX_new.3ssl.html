<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSSL_HPKE_CTX_new, OSSL_HPKE_CTX_free, OSSL_HPKE_encap, OSSL_HPKE_decap, OSSL_HPKE_seal, OSSL_HPKE_open,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       OSSL_HPKE_CTX_new, OSSL_HPKE_CTX_free, OSSL_HPKE_encap, OSSL_HPKE_decap, OSSL_HPKE_seal, OSSL_HPKE_open,
       OSSL_HPKE_export, OSSL_HPKE_suite_check, OSSL_HPKE_str2suite, OSSL_HPKE_keygen,
       OSSL_HPKE_get_grease_value, OSSL_HPKE_get_ciphertext_size, OSSL_HPKE_get_public_encap_size,
       OSSL_HPKE_get_recommended_ikmelen, OSSL_HPKE_CTX_set1_psk, OSSL_HPKE_CTX_set1_ikme,
       OSSL_HPKE_CTX_set1_authpriv, OSSL_HPKE_CTX_set1_authpub, OSSL_HPKE_CTX_get_seq, OSSL_HPKE_CTX_set_seq -
       Hybrid Public Key Encryption (HPKE) functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/hpke.h&gt;

        typedef struct {
            uint16_t    kem_id;
            uint16_t    kdf_id;
            uint16_t    aead_id;
        } OSSL_HPKE_SUITE;

        OSSL_HPKE_CTX *OSSL_HPKE_CTX_new(int mode, OSSL_HPKE_SUITE suite, int role,
                                         OSSL_LIB_CTX *libctx, const char *propq);
        void OSSL_HPKE_CTX_free(OSSL_HPKE_CTX *ctx);

        int OSSL_HPKE_encap(OSSL_HPKE_CTX *ctx,
                            unsigned char *enc, size_t *enclen,
                            const unsigned char *pub, size_t publen,
                            const unsigned char *info, size_t infolen);
        int OSSL_HPKE_seal(OSSL_HPKE_CTX *ctx,
                           unsigned char *ct, size_t *ctlen,
                           const unsigned char *aad, size_t aadlen,
                           const unsigned char *pt, size_t ptlen);

        int OSSL_HPKE_keygen(OSSL_HPKE_SUITE suite,
                             unsigned char *pub, size_t *publen, EVP_PKEY **priv,
                             const unsigned char *ikm, size_t ikmlen,
                             OSSL_LIB_CTX *libctx, const char *propq);
        int OSSL_HPKE_decap(OSSL_HPKE_CTX *ctx,
                            const unsigned char *enc, size_t enclen,
                            EVP_PKEY *recippriv,
                            const unsigned char *info, size_t infolen);
        int OSSL_HPKE_open(OSSL_HPKE_CTX *ctx,
                           unsigned char *pt, size_t *ptlen,
                           const unsigned char *aad, size_t aadlen,
                           const unsigned char *ct, size_t ctlen);

        int OSSL_HPKE_export(OSSL_HPKE_CTX *ctx,
                             unsigned char *secret, size_t secretlen,
                             const unsigned char *label, size_t labellen);

        int OSSL_HPKE_CTX_set1_authpriv(OSSL_HPKE_CTX *ctx, EVP_PKEY *priv);
        int OSSL_HPKE_CTX_set1_authpub(OSSL_HPKE_CTX *ctx,
                                       unsigned char *pub, size_t publen);
        int OSSL_HPKE_CTX_set1_psk(OSSL_HPKE_CTX *ctx,
                                   const char *pskid,
                                   const unsigned char *psk, size_t psklen);

        int OSSL_HPKE_CTX_get_seq(OSSL_HPKE_CTX *ctx, uint64_t *seq);
        int OSSL_HPKE_CTX_set_seq(OSSL_HPKE_CTX *ctx, uint64_t seq);

        int OSSL_HPKE_CTX_set1_ikme(OSSL_HPKE_CTX *ctx,
                                    const unsigned char *ikme, size_t ikmelen);

        int OSSL_HPKE_suite_check(OSSL_HPKE_SUITE suite);
        int OSSL_HPKE_get_grease_value(const OSSL_HPKE_SUITE *suite_in,
                                       OSSL_HPKE_SUITE *suite,
                                       unsigned char *enc, size_t *enclen,
                                       unsigned char *ct, size_t ctlen,
                                       OSSL_LIB_CTX *libctx, const char *propq);

        int OSSL_HPKE_str2suite(const char *str, OSSL_HPKE_SUITE *suite);
        size_t OSSL_HPKE_get_ciphertext_size(OSSL_HPKE_SUITE suite, size_t clearlen);
        size_t OSSL_HPKE_get_public_encap_size(OSSL_HPKE_SUITE suite);
        size_t OSSL_HPKE_get_recommended_ikmelen(OSSL_HPKE_SUITE suite);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions provide an API for using the form of Hybrid Public Key Encryption (HPKE) defined in
       RFC9180. Understanding the HPKE specification is likely required before using these APIs.  HPKE is used
       by various other IETF specifications, including the TLS Encrypted Client Hello (ECH) specification and
       others.

       HPKE is a standardised, highly flexible construct for encrypting "to" a public key that supports
       combinations of a key encapsulation method (KEM), a key derivation function (KDF) and an authenticated
       encryption with additional data (AEAD) algorithm, with optional sender authentication.

       The sender and a receiver here will generally be using some application or protocol making use of HPKE.
       For example, with ECH, the sender will be a browser and the receiver will be a web server.

   <b>Data</b> <b>Structures</b>
       <b>OSSL_HPKE_SUITE</b> is a structure that holds identifiers for the algorithms used for KEM, KDF and AEAD
       operations.

       <b>OSSL_HPKE_CTX</b> is a context that maintains internal state as HPKE operations are carried out. Separate
       <b>OSSL_HPKE_CTX</b> objects must be used for the sender and receiver. Attempting to use a single context for
       both will result in errors.

   <b>OSSL_HPKE_SUITE</b> <b>Identifiers</b>
       The identifiers used by <b>OSSL_HPKE_SUITE</b> are:

       The KEM identifier <u>kem_id</u> is one of the following:

       0x10 <b>OSSL_HPKE_KEM_ID_P256</b>
       0x11 <b>OSSL_HPKE_KEM_ID_P384</b>
       0x12 <b>OSSL_HPKE_KEM_ID_P521</b>
       0x20 <b>OSSL_HPKE_KEM_ID_X25519</b>
       0x21 <b>OSSL_HPKE_KEM_ID_X448</b>

       The KDF identifier <u>kdf_id</u> is one of the following:

       0x01 <b>OSSL_HPKE_KDF_ID_HKDF_SHA256</b>
       0x02 <b>OSSL_HPKE_KDF_ID_HKDF_SHA384</b>
       0x03 <b>OSSL_HPKE_KDF_ID_HKDF_SHA512</b>

       The AEAD identifier <u>aead_id</u> is one of the following:

       0x01 <b>OSSL_HPKE_AEAD_ID_AES_GCM_128</b>
       0x02 <b>OSSL_HPKE_AEAD_ID_AES_GCM_256</b>
       0x03 <b>OSSL_HPKE_AEAD_ID_CHACHA_POLY1305</b>
       0xFFFF <b>OSSL_HPKE_AEAD_ID_EXPORTONLY</b>
           The  last  identifier above indicates that AEAD operations are not needed.  <b>OSSL_HPKE_export()</b> can be
           used, but <b>OSSL_HPKE_open()</b> and <b>OSSL_HPKE_seal()</b> will return an error if called with a  context  using
           that AEAD identifier.

   <b>HPKE</b> <b>Modes</b>
       HPKE supports the following variants of Authentication using a mode Identifier:

       <b>OSSL_HPKE_MODE_BASE</b>, 0x00
           Authentication is not used.

       <b>OSSL_HPKE_MODE_PSK</b>, 0x01
           Authenticates possession of a pre-shared key (PSK).

       <b>OSSL_HPKE_MODE_AUTH</b>, 0x02
           Authenticates possession of a KEM-based sender private key.

       <b>OSSL_HPKE_MODE_PSKAUTH</b>, 0x03
           A  combination  of  <b>OSSL_HPKE_MODE_PSK</b>  and  <b>OSSL_HPKE_MODE_AUTH</b>.   Both  the  PSK  and  the  senders
           authentication public/private must be supplied before the encapsulation/decapsulation operation  will
           work.

       For  further  information  related  to  authentication  see  "Pre-Shared  Key  HPKE  modes"  and "Sender-
       authenticated HPKE Modes".

   <b>HPKE</b> <b>Roles</b>
       HPKE contexts have a role - either sender or receiver. This is used to control  which  functions  can  be
       called and so that senders do not reuse a key and nonce with different plaintexts.

       <b>OSSL_HPKE_CTX_free()</b>,  <b>OSSL_HPKE_export()</b>,  <b>OSSL_HPKE_CTX_set1_psk()</b>,  and <b>OSSL_HPKE_CTX_get_seq()</b> can be
       called regardless of role.

       <b>OSSL_HPKE_ROLE_SENDER</b>, 0
           An  <u>OSSL_HPKE_CTX</u>  with  this  role   can   be   used   with   <b>OSSL_HPKE_encap()</b>,   <b>OSSL_HPKE_seal()</b>,
           <b>OSSL_HPKE_CTX_set1_ikme()</b> and <b>OSSL_HPKE_CTX_set1_authpriv()</b>.

       <b>OSSL_HPKE_ROLE_RECEIVER</b>, 1
           An   <u>OSSL_HPKE_CTX</u>   with   this   role   can   be  used  with  <b>OSSL_HPKE_decap()</b>,  <b>OSSL_HPKE_open()</b>,
           <b>OSSL_HPKE_CTX_set1_authpub()</b> and <b>OSSL_HPKE_CTX_set_seq()</b>.

       Calling a function with an incorrect role set on <u>OSSL_HPKE_CTX</u> will result in an error.

   <b>Parameter</b> <b>Size</b> <b>Limits</b>
       In order to improve interoperability, RFC9180, section 7.2.1 suggests a RECOMMENDED maximum  size  of  64
       octets  for  various  input  parameters.   In  this  implementation we apply a limit of 66 octets for the
       <u>ikmlen</u>, <u>psklen</u>, and <u>labellen</u> parameters, and for the length of the string <u>pskid</u> for HPKE functions below.
       The constant <u>OSSL_HPKE_MAX_PARMLEN</u> is defined as the limit of this value.  (We chose 66 octets so that we
       can validate all the test vectors present in RFC9180, Appendix A.)

       In accordance with RFC9180, section 9.5, we define a constant <u>OSSL_HPKE_MIN_PSKLEN</u> with a value of 32 for
       the minimum length of a pre-shared key, passed in <u>psklen</u>.

       While RFC9180 also RECOMMENDS a 64 octet limit for the <u>infolen</u> parameter, that is not sufficient for  TLS
       Encrypted  ClientHello  (ECH)  processing, so we enforce a limit of <u>OSSL_HPKE_MAX_INFOLEN</u> with a value of
       1024 as the limit for the <u>infolen</u> parameter.

   <b>Context</b> <b>Construct/Free</b>
       <b>OSSL_HPKE_CTX_new()</b> creates a <b>OSSL_HPKE_CTX</b> context object used for subsequent HPKE operations,  given  a
       <u>mode</u>  (See  "HPKE  Modes"),  <u>suite</u> (see "OSSL_HPKE_SUITE Identifiers") and a <u>role</u> (see "HPKE Roles"). The
       <u>libctx</u> and <u>propq</u> are used when fetching algorithms from providers and may be set to NULL.

       <b>OSSL_HPKE_CTX_free()</b>  frees  the  <u>ctx</u>  <b>OSSL_HPKE_CTX</b>  that  was  created  previously   by   a   call   to
       <b>OSSL_HPKE_CTX_new()</b>.  If the argument to <b>OSSL_HPKE_CTX_free()</b> is NULL, nothing is done.

   <b>Sender</b> <b>APIs</b>
       A sender's goal is to use HPKE to encrypt using a public key, via use of a KEM, then a KDF and finally an
       AEAD.   The  first  step  is to encapsulate (using <b>OSSL_HPKE_encap()</b>) the sender's public value using the
       recipient's public key, (<u>pub</u>) and to internally derive secrets. This  produces  the  encapsulated  public
       value (<u>enc</u>) to be sent to the recipient in whatever protocol is using HPKE. Having done the encapsulation
       step,  the  sender  can  then  make one or more calls to <b>OSSL_HPKE_seal()</b> to encrypt plaintexts using the
       secret stored within <u>ctx</u>.

       <b>OSSL_HPKE_encap()</b> uses the HPKE context <u>ctx</u>, the recipient public  value  <u>pub</u>  of  size  <u>publen</u>,  and  an
       optional  <u>info</u>  parameter of size <u>infolen</u>, to produce the encapsulated public value <u>enc</u>.  On input <u>enclen</u>
       should contain the maximum size of the <u>enc</u> buffer, and returns the output size. An error  will  occur  if
       the  input <u>enclen</u> is smaller than the value returned from <b>OSSL_HPKE_get_public_encap_size()</b>.  <u>info</u> may be
       used to bind other protocol or application artefacts such as identifiers.   Generally,  the  encapsulated
       public value <u>enc</u> corresponds to a single-use ephemeral private value created as part of the encapsulation
       process. Only a single call to <b>OSSL_HPKE_encap()</b> is allowed for a given <b>OSSL_HPKE_CTX</b>.

       <b>OSSL_HPKE_seal()</b>  takes the <b>OSSL_HPKE_CTX</b> context <u>ctx</u>, the plaintext buffer <u>pt</u> of size <u>ptlen</u> and optional
       additional authenticated data buffer <u>aad</u> of size <u>aadlen</u>, and returns the ciphertext <u>ct</u> of size <u>ctlen</u>.  On
       input <u>ctlen</u> should contain the maximum size of the <u>ct</u> buffer, and returns the output size. An error  will
       occur if the input <u>ctlen</u> is smaller than the value returned from <b>OSSL_HPKE_get_public_encap_size()</b>.

       <b>OSSL_HPKE_encap()</b>  must  be  called before the <b>OSSL_HPKE_seal()</b>.  <b>OSSL_HPKE_seal()</b> may be called multiple
       times, with an internal "nonce" being incremented by one after each call.

   <b>Recipient</b> <b>APIs</b>
       Recipients using HPKE require a typically less ephemeral private value so that the public  value  can  be
       distributed  to  potential  senders via whatever protocol is using HPKE. For this reason, recipients will
       generally first generate a key pair and will need to  manage  their  private  key  value  using  standard
       mechanisms  outside the scope of this API. Private keys use normal <b><a href="../man3/EVP_PKEY.3.html">EVP_PKEY</a></b>(3) pointers so normal private
       key management mechanisms can be used for the relevant values.

       In order to enable encapsulation, the recipient needs to make it's public value available to the  sender.
       There  is  no generic HPKE format defined for that - the relevant formatting is intended to be defined by
       the application/protocols that makes use of HPKE. ECH for example defines  an  ECHConfig  data  structure
       that combines the public value with other ECH data items. Normal library functions must therefore be used
       to extract the public value in the required format based on the <b><a href="../man3/EVP_PKEY.3.html">EVP_PKEY</a></b>(3) for the private value.

       <b>OSSL_HPKE_keygen()</b>  provides  a  way  for recipients to generate a key pair based on the HPKE <u>suite</u> to be
       used. It returns a <b><a href="../man3/EVP_PKEY.3.html">EVP_PKEY</a></b>(3) pointer for the private value <u>priv</u> and a encoded public key  <u>pub</u>  of  size
       <u>publen</u>.   On input <u>publen</u> should contain the maximum size of the <u>pub</u> buffer, and returns the output size.
       An error will occur if the input <u>publen</u> is too small.  The  <u>libctx</u>  and  <u>propq</u>  are  used  when  fetching
       algorithms  from  providers  and may be set to NULL.  The HPKE specification also defines a deterministic
       key generation scheme where the  private  value  is  derived  from  initial  keying  material  (IKM),  so
       <b>OSSL_HPKE_keygen()</b>  also  has  an  option  to use that scheme, using the <u>ikm</u> parameter of size <u>ikmlen</u>. If
       either <u>ikm</u> is NULL or <u>ikmlen</u> is zero, then a randomly generated  key  for  the  relevant  <u>suite</u>  will  be
       produced.  If required <u>ikmlen</u> should be greater than or equal to <b>OSSL_HPKE_get_recommended_ikmelen()</b>.

       <b>OSSL_HPKE_decap()</b>  takes  as  input  the sender's encapsulated public value produced by <b>OSSL_HPKE_encap()</b>
       (<u>enc</u>) and the recipient's <b><a href="../man3/EVP_PKEY.3.html">EVP_PKEY</a></b>(3) pointer (<u>prov</u>), and then re-generates the internal  secret  derived
       by  the  sender.  As  before,  an  optional  <u>info</u>  parameter  allows binding that derived secret to other
       application/protocol artefacts.  Only  a  single  call  to  <b>OSSL_HPKE_decap()</b>  is  allowed  for  a  given
       <b>OSSL_HPKE_CTX</b>.

       <b>OSSL_HPKE_open()</b>  is  used  by the recipient to decrypt the ciphertext <u>ct</u> of size <u>ctlen</u> using the <u>ctx</u> and
       additional authenticated data <u>aad</u> of size <u>aadlen</u>, to produce the plaintext <u>pt</u> of size  <u>ptlen</u>.   On  input
       <u>ptlen</u>  should contain the maximum size of the <u>pt</u> buffer, and returns the output size. A <u>pt</u> buffer that is
       the same size as the <u>ct</u> buffer will suffice - generally the plaintext output will  be  a  little  smaller
       than the ciphertext input.  An error will occur if the input <u>ptlen</u> is too small.  <b>OSSL_HPKE_open()</b> may be
       called  multiple  times,  but as with <b>OSSL_HPKE_seal()</b> there is an internally incrementing nonce value so
       ciphertexts need to be presented in the same order as used by the <b>OSSL_HPKE_seal()</b>.  See  "Re-sequencing"
       if you need to process multiple ciphertexts in a different order.

   <b>Exporting</b> <b>Secrets</b>
       HPKE defines a way to produce exported secrets for use by the application.

       <b>OSSL_HPKE_export()</b>  takes  as  input  the  <b>OSSL_HPKE_CTX</b>, and an application supplied label <u>label</u> of size
       <u>labellen</u>, to produce a secret <u>secret</u> of size <u>secretlen</u>. The sender must first call <b>OSSL_HPKE_encap()</b>, and
       the receiver must call <b>OSSL_HPKE_decap()</b> in order to derive the same shared secret.

       Multiple  calls  to  <b>OSSL_HPKE_export()</b>  with  the  same   inputs   will   produce   the   same   secret.
       <u>OSSL_HPKE_AEAD_ID_EXPORTONLY</u>   may   be   used   as   the  <b>OSSL_HPKE_SUITE</b>  <u>aead_id</u>  that  is  passed  to
       <b>OSSL_HPKE_CTX_new()</b> if the user needs to produce a shared secret, but  does  not  wish  to  perform  HPKE
       encryption.

   <b>Sender-authenticated</b> <b>HPKE</b> <b>Modes</b>
       HPKE    defines    modes   that   support   KEM-based   sender-authentication   <b>OSSL_HPKE_MODE_AUTH</b>   and
       <b>OSSL_HPKE_MODE_PSKAUTH</b>. This works by binding the sender's authentication private/public values into  the
       encapsulation  and  decapsulation  operations.  The key used for such modes must also use the same KEM as
       used for the overall exchange. <b>OSSL_HPKE_keygen()</b> can be used to generate the private value required.

       <b>OSSL_HPKE_CTX_set1_authpriv()</b> can be used by the sender to set the senders private <u>priv</u> <b>EVP_PKEY</b> key into
       the <b>OSSL_HPKE_CTX</b> <u>ctx</u> before calling <b>OSSL_HPKE_encap()</b>.

       <b>OSSL_HPKE_CTX_set1_authpub()</b> can be used by the receiver to set the senders encoded pub key <u>pub</u>  of  size
       <u>publen</u> into the <b>OSSL_HPKE_CTX</b> <u>ctx</u> before calling <b>OSSL_HPKE_decap()</b>.

   <b>Pre-Shared</b> <b>Key</b> <b>HPKE</b> <b>modes</b>
       HPKE  also  defines  a  symmetric equivalent to the authentication described above using a pre-shared key
       (PSK) and a PSK identifier. PSKs can be  used  with  the  <b>OSSL_HPKE_MODE_PSK</b>  and  <b>OSSL_HPKE_MODE_PSKAUTH</b>
       modes.

       <b>OSSL_HPKE_CTX_set1_psk()</b> sets the PSK identifier <u>pskid</u> string, and PSK buffer <u>psk</u> of size <u>psklen</u> into the
       <u>ctx</u>.  If  required this must be called before <b>OSSL_HPKE_encap()</b> or <b>OSSL_HPKE_decap()</b>.  As per RFC9180, if
       required, both <u>psk</u> and <u>pskid</u> must be set to non-NULL values.  As PSKs are symmetric the same  calls  must
       happen on both sender and receiver sides.

   <b>Deterministic</b> <b>key</b> <b>generation</b> <b>for</b> <b>senders</b>
       Normally  the  senders  ephemeral  private key is generated randomly inside <b>OSSL_HPKE_encap()</b> and remains
       secret.  <b>OSSL_HPKE_CTX_set1_ikme()</b> allows the user to override this behaviour by setting a  deterministic
       input  key material <u>ikm</u> of size <u>ikmlen</u> into the <b>OSSL_HPKE_CTX</b> <u>ctx</u>.  If required <b>OSSL_HPKE_CTX_set1_ikme()</b>
       can optionally  be  called  before  <b>OSSL_HPKE_encap()</b>.   <u>ikmlen</u>  should  be  greater  than  or  equal  to
       <b>OSSL_HPKE_get_recommended_ikmelen()</b>.

       It is generally undesirable to use <b>OSSL_HPKE_CTX_set1_ikme()</b>, since it exposes the relevant secret to the
       application  rather  then  preserving  it  within  the  library,  and  is more likely to result in use of
       predictable values or values that leak.

   <b>Re-sequencing</b>
       Some protocols may have to deal with packet loss while still  being  able  to  decrypt  arriving  packets
       later.  We  provide  a  way  to  set  the  increment  used  for  the nonce to the next subsequent call to
       <b>OSSL_HPKE_open()</b> (but not to <b>OSSL_HPKE_seal()</b> as explained below).  The <b>OSSL_HPKE_CTX_set_seq()</b>  API  can
       be  used for such purposes with the <u>seq</u> parameter value resetting the internal nonce increment to be used
       for the next call.

       A baseline nonce value is established based on the encapsulation or decapsulation operation and  is  then
       incremented  by  1  for  each  call to seal or open. (In other words, the first <u>seq</u> increment defaults to
       zero.)

       If a caller needs to determine how many calls to seal or open have been made the  <b>OSSL_HPKE_CTX_get_seq()</b>
       API  can be used to retrieve the increment (in the <u>seq</u> output) that will be used in the next call to seal
       or open. That would return 0 before the first call a sender made to <b>OSSL_HPKE_seal()</b>  and  1  after  that
       first call.

       Note  that  reuse  of  the same nonce and key with different plaintexts would be very dangerous and could
       lead to loss of confidentiality and integrity.  We therefore only support application  control  over  <u>seq</u>
       for decryption (i.e. <b>OSSL_HPKE_open()</b>) operations.

       For compatibility with other implementations these <u>seq</u> increments are represented as <u>uint64_t</u>.

   <b>Protocol</b> <b>Convenience</b> <b>Functions</b>
       Additional  convenience  APIs  allow  the  caller to access internal details of local HPKE support and/or
       algorithms, such as parameter lengths.

       <b>OSSL_HPKE_suite_check()</b> checks if a specific <b>OSSL_HPKE_SUITE</b> <u>suite</u> is supported locally.

       To assist with memory allocation, <b>OSSL_HPKE_get_ciphertext_size()</b> provides a way for the caller  to  know
       by  how  much ciphertext will be longer than a plaintext of length <u>clearlen</u>.  (AEAD algorithms add a data
       integrity tag, so there is a small amount of ciphertext expansion.)

       <b>OSSL_HPKE_get_public_encap_size()</b> provides a way for senders to know  how  big  the  encapsulated  public
       value will be for a given HPKE <u>suite</u>.

       <b>OSSL_HPKE_get_recommended_ikmelen()</b>  returns  the  recommended  Input  Key Material size (in bytes) for a
       given <u>suite</u>. This is needed in cases where the same public value needs to  be  regenerated  by  a  sender
       before calling <b>OSSL_HPKE_seal()</b>.  <u>ikmlen</u> should be at least this size.

       <b>OSSL_HPKE_get_grease_value()</b>  produces  values of the appropriate length for a given <u>suite_in</u> value (or a
       random value if <u>suite_in</u> is NULL) so that a protocol using HPKE can send so-called GREASE  (see  RFC8701)
       values  that  are  harder  to distinguish from a real use of HPKE. The buffer sizes should be supplied on
       input. The output <u>enc</u> value will have an appropriate length for <u>suite_out</u> and a random value, and the  <u>ct</u>
       output   will   be   a   random   value.   The   relevant   sizes   for   buffers   can  be  found  using
       <b>OSSL_HPKE_get_ciphertext_size()</b> and <b>OSSL_HPKE_get_public_encap_size()</b>.

       <b>OSSL_HPKE_str2suite()</b> maps input <u>str</u> strings to an <b>OSSL_HPKE_SUITE</b> object.  The input  <u>str</u>  should  be  a
       comma-separated   string   with   a   KEM,   KDF   and   AEAD   name   in   that   order,   for   example
       "x25519,hkdf-sha256,aes128gcm".  This can be used by command line tools that accept string form names for
       HPKE codepoints. Valid (case-insensitive) names are: "p-256", "p-384", "p-521", "x25519" and  "x448"  for
       KEM,   "hkdf-sha256",   "hkdf-sha384"  and  "hkdf-sha512"  for  KDF,  and  "aes-gcm-128",  "aes-gcm-256",
       "chacha20-poly1305" and "exporter" for AEAD.  String variants of the numbers listed  in  "OSSL_HPKE_SUITE
       Identifiers" can also be used.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>OSSL_HPKE_CTX_new()</b> returns an OSSL_HPKE_CTX pointer or NULL on error.

       <b>OSSL_HPKE_get_ciphertext_size()</b>,  <b>OSSL_HPKE_get_public_encap_size()</b>,  <b>OSSL_HPKE_get_recommended_ikmelen()</b>
       all return a size_t with the relevant value or zero on error.

       All other functions return 1 for success or zero for error.

</pre><h4><b>EXAMPLES</b></h4><pre>
       This example demonstrates a minimal round-trip using HPKE.

           #include &lt;stddef.h&gt;
           #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
           #include &lt;openssl/hpke.h&gt;
           #include &lt;openssl/evp.h&gt;

           /*
            * this is big enough for this example, real code would need different
            * handling
            */
           #define LBUFSIZE 48

           /* Do a round-trip, generating a key, encrypting and decrypting */
           int main(int argc, char **argv)
           {
               int ok = 0;
               int hpke_mode = OSSL_HPKE_MODE_BASE;
               OSSL_HPKE_SUITE hpke_suite = OSSL_HPKE_SUITE_DEFAULT;
               OSSL_HPKE_CTX *sctx = NULL, *rctx = NULL;
               EVP_PKEY *priv = NULL;
               unsigned char pub[LBUFSIZE];
               size_t publen = sizeof(pub);
               unsigned char enc[LBUFSIZE];
               size_t enclen = sizeof(enc);
               unsigned char ct[LBUFSIZE];
               size_t ctlen = sizeof(ct);
               unsigned char clear[LBUFSIZE];
               size_t clearlen = sizeof(clear);
               const unsigned char *pt = "a message not in a bottle";
               size_t ptlen = strlen((char *)pt);
               const unsigned char *info = "Some info";
               size_t infolen = strlen((char *)info);
               unsigned char aad[] = { 1, 2, 3, 4, 5, 6, 7, 8 };
               size_t aadlen = sizeof(aad);

               /*
                * Generate receiver's key pair.
                * The receiver gives this public key to the sender.
                */
               if (OSSL_HPKE_keygen(hpke_suite, pub, &amp;publen, &amp;priv,
                                    NULL, 0, NULL, NULL) != 1)
                   goto err;

               /* sender's actions - encrypt data using the receivers public key */
               if ((sctx = OSSL_HPKE_CTX_new(hpke_mode, hpke_suite,
                                             OSSL_HPKE_ROLE_SENDER,
                                             NULL, NULL)) == NULL)
                   goto err;
               if (OSSL_HPKE_encap(sctx, enc, &amp;enclen, pub, publen, info, infolen) != 1)
                   goto err;
               if (OSSL_HPKE_seal(sctx, ct, &amp;ctlen, aad, aadlen, pt, ptlen) != 1)
                   goto err;

               /* receiver's actions - decrypt data using the receivers private key */
               if ((rctx = OSSL_HPKE_CTX_new(hpke_mode, hpke_suite,
                                             OSSL_HPKE_ROLE_RECEIVER,
                                             NULL, NULL)) == NULL)
                   goto err;
               if (OSSL_HPKE_decap(rctx, enc, enclen, priv, info, infolen) != 1)
                   goto err;
               if (OSSL_HPKE_open(rctx, clear, &amp;clearlen, aad, aadlen, ct, ctlen) != 1)
                   goto err;
               ok = 1;
           err:
               /* clean up */
               printf(ok ? "All Good!\n" : "Error!\n");
               OSSL_HPKE_CTX_free(rctx);
               OSSL_HPKE_CTX_free(sctx);
               EVP_PKEY_free(priv);
               return 0;
           }

</pre><h4><b>WARNINGS</b></h4><pre>
       Note that the <b>OSSL_HPKE_CTX_set_seq()</b> API could be dangerous - if used with GCM that could lead to nonce-
       reuse, which is a known danger. So avoid that entirely, or be very very careful when using that API.

       Use  of  an  IKM   value   for   deterministic   key   generation   (via   <b>OSSL_HPKE_CTX_set1_ikme()</b>   or
       <b>OSSL_HPKE_keygen()</b>)  creates  the  potential  for  leaking  keys (or IKM values). Only use that if really
       needed and if you understand how keys or IKM values could be abused.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The RFC9180 specification: https://datatracker.ietf.org/doc/rfc9180/

</pre><h4><b>HISTORY</b></h4><pre>
       This functionality described here was added in OpenSSL 3.2.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2022-2025 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                            <u><a href="../man3SSL/OSSL_HPKE_CTX_NEW.3SSL.html">OSSL_HPKE_CTX_NEW</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>