<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badger::Filesystem::Path - generic filesystem path object</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbadger-perl">libbadger-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Badger::Filesystem::Path - generic filesystem path object

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # using Badger::Filesytem constructor subroutine
           use Badger::Filesystem 'Path';

           # use native OS-specific paths:
           $path = Path('/path/to/something');

           # or generic OS-independant paths
           $path = Path('path', 'to', 'something');

           # manual object construction
           use Badger::Filesystem::Path;

           # positional arguments
           $path = Badger::Filesystem::Path-&gt;new('/path/to/something');
           $path = Badger::Filesystem::Path-&gt;new(['path', 'to', 'something']);

           # named parameters
           $path = Badger::Filesystem::Path-&gt;new(
               path =&gt; '/path/to/something'
           );
           $path = Badger::Filesystem::Path-&gt;new(
               path =&gt; ['path', 'to', 'something']
           );

           # path inspection methods
           $path-&gt;path;                    # current path
           $path-&gt;base;                    # parent directory or path itself
           $path-&gt;parent;                  # directory object for base
           $path-&gt;extension                # filename .XXX extension
           $path-&gt;basename                 # filename without .XXX extension
           $path-&gt;is_absolute;             # path is absolute
           $path-&gt;is_relative;             # path is relative
           $path-&gt;exists;                  # returns true/false
           $path-&gt;must_exist;              # throws error if not
           @stats = $path-&gt;stat;           # returns list
           $stats = $path-&gt;stat;           # returns list ref

           # path translation methods
           $path-&gt;relative;                # relative to cwd
           $path-&gt;relative($base);         # relative to $base
           $path-&gt;absolute;                # relative to filesystem root
           $path-&gt;definitive;              # physical file location
           $path-&gt;collapse;                # resolve '.' and '..' in $path

           # path comparison methods
           $path-&gt;above($another_path);    # $path is ancestor of $another_path
           $path-&gt;below($another_path);    # $path is descendant of $another_path

</pre><h4><b>INTRODUCTION</b></h4><pre>
       This is the documentation for the "Badger::Filesystem::Path" module.  It defines a base class object for
       the Badger::Filesystem::File and Badger::Filesystem::Directory objects which inherit (and in some cases
       redefine) the methods described below.

       In other words, you should read this documentation first if you're working with Badger::Filesystem::File
       or Badger::Filesystem::Directory objects.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "Badger::Filesystem::Path" module defines a base class object for representing paths in a real or
       virtual file system.

       You can create a generic path object (e.g. to represent a path that doesn't relate to a specific file or
       directory in a file system), using the "Path" constructor method in Badger::Filesystem.

           use Badger::Filesystem 'Path';

           my $path = Path('/path/to/something');

       However in most cases you'll want to create a file or directory subclass object. The easiest way to do
       that is like this:

           use Badger::Filesystem 'File Path';

           my $file = File('/path/to/file');
           my $dir  = Dir('/path/to/dir');

       If you're concerned about portability to other operating systems and/or file systems, then you can
       specify paths as a list or reference to a list of component names.

           my $file = File('path', 'to', 'file');
           my $dir  = Dir(['path', 'to', 'dir']);

</pre><h4><b>METHODS</b></h4><pre>
   <b>new($path)</b>
       Constructor method to create a new "Badger::Filesystem::Path" object.  The path can be specified as a
       single positional argument, either as a text string or reference to list of path components.

           # single text string
           $path = Badger::Filesystem::Path-&gt;new('/path/to/something');

           # reference to list
           $path = Badger::Filesystem::Path-&gt;new(['path', 'to', 'something']);

       It can also be specified as a "path" named parameter.

           # named parameter list
           $path = Badger::Filesystem::Path-&gt;new(
               path =&gt; '/path/to/something'
           );

           # reference to hash of named parameter(s)
           $path = Badger::Filesystem::Path-&gt;new({
               path =&gt; '/path/to/something'
           });

       The constructor method also recognises the "filesystem" named parameter which can contain a reference to
       the Badger::Filesystem object or class that created it. In most cases you can rely on the
       Badger::Filesystem to create path objects for you, using either the <b>path()</b> method, or the <b>Path()</b>
       subroutine.

           use Badger::Filesystem 'FS Path';

           # FS is alias for 'Badger::Filesystem'
           # Path() is constructor subrooutine
           my $path;

           # using the path() method
           $path = FS-&gt;path('/path/to/something');
           $path = FS-&gt;path('path', 'to', 'something');
           $path = FS-&gt;path(['path', 'to', 'something']);

           # using the Path() subroutine
           $path = Path('/path/to/something');
           $path = Path('path', 'to', 'something');
           $path = Path(['path', 'to', 'something']);

       The examples that follow will use the "Path()" constructor subroutine.

   <b>init(\%config)</b>
       Default initialisation method which subclasses (e.g.  Badger::Filesystem::Directory and
       Badger::Filesystem::File) can redefine.

   <b>path()</b>
       This method returns the path as a text string.  It is called automatically whenever the path object is
       stringified.

   <b>is_absolute()</b>
       Returns true if the path is absolute, false if not.

   <b>is_relative()</b>
       Returns true if the path is relative, false if not.

   <b>absolute($base)</b>
       Returns an absolute representation of the path, relative to the $base path passed as an argument, or the
       current working directory if $base is not specified.

           # assume cwd is /foo/bar,
           my $path = Path('/baz/bam');

           print $path-&gt;absolute;                  # /foo/bar/baz/bam
           print $path-&gt;absolute('/wiz');          # /wiz/baz/bam

   <b>relative($base)</b>
       Returns a relative representation of the path, relative to the $base path passed as an argument, or the
       current working directory if $base is not specified.

           # assume cwd is /foo/bar,
           my $path = Path('/foo/bar/baz/bam');

           print $path-&gt;relative;                  # /baz/bam
           print $path-&gt;relative('/foo');          # /bar/baz/bam

   <b>definitive()</b>
       Returns the definitive representation of the path which in most cases will be the same as the <b>absolute()</b>
       path.

       However, if you're using a virtual filesystem, then the <u>definitive</u> path <u>will</u> include the virtual root
       directory, whereas a the <u>absolute</u> path will <u>not</u>.

           my $vfs  = Badger::Filesystem::Virtual-&gt;new( root =&gt; '/my/vfs' );
           my $path = $vfs-&gt;file('/foo/bar');
           print $path-&gt;absolute;              # /foo/bar
           print $path-&gt;definitive;            # /my/vfs/foo/bar

   <b>canonical()</b>
       This method returns the canonical representation of the path. In most cases this is the same as the
       absolute path (in fact the base class aliases the "canonical()" method directly to the <b>absolute()</b>
       method).

           print Path('foo')-&gt;canonical;               # /your/current/path/foo
           print Path('/foo/bar')-&gt;canonical;          # /foo/bar
           print Path('/foo/bar/')-&gt;canonical;         # /foo/bar
           print Path('/foo/bar.txt')-&gt;canonical;      # /foo/bar.txt

       Note that the "Badger::Filesystem::Path" base class will <u>remove</u> any trailing slashes (or whatever the
       appropriate directory separator is for your filesystem) from the end of an absolute path.

       In the case of directories, implemented by the Badger::Filesystem::Directory subclass, a trailing slash
       (or relevant separator for your filesystem) will be added.

           print Dir('/foo/bar')-&gt;canonical;          # /foo/bar/

       This is done by delegation to the <b>slash_directory()</b> method in Badger::Filesystem.

   <b>collapse()</b>
       Reduces the path to its simplest form by resolving and removing any "."  (current directory) and ".."
       (parent directory) components (or whatever the corresponding tokens are for the current and parent
       directories of your filesystem).

           my $path = Path('/foo/bar/../baz')-&gt;collapse;
           print $path;   # /foo/baz

       See the <b>collapse_dir()</b> method in Badger::Filesystem for further information.

   <b>above($child)</b>
       Returns true if the path is "above" the $child path passed as an argument.  Formally, we say that the
       path is an <u>ancestor</u> of $child meaning that it is the parent directory, or grand-parent, or great-grand-
       parent, and so on.

           my $parent = Path('/foo/bar');
           my $child  = Path('/foo/bar/baz');
           $parent-&gt;above($child);                 # true

       This is implemented as a simple prefix match. That is, the parent path must appear at the start of the
       child path. Consequently, this method will not account for symbolic links or other similar filesystem
       features, and it may not work properly on systems that don't follow this convention (although there are
       none that I'm aware of).

   <b>below($parent)</b>
       Returns true if the path is "below" the $parent path passed as an argument.  Formally, we say that the
       path is a <u>descendant</u> of $parent meaning that it is an immediate sub-directory, or sub-sub-directory, and
       so on.

           my $parent = Path('/foo/bar');
           my $child  = Path('/foo/bar/baz');
           $child-&gt;below($parent);                 # true

       Like <b>above()</b>, this is implemented using a simple prefix match.

   <b>base()</b>
       Returns the base directory of a path. For Badger::Filesystem::Path and Badger::Filesystem::Directory
       objects, this method will return the complete path.

           print Path('/foo/bar')-&gt;base;           # /foo/bar
           print Directory('/foo/bar')-&gt;base;      # /foo/bar

       However the Badger::Filesystem::File module returns the parent directory in which the file is located.

           print File('/foo/bar')-&gt;base;           # /foo

   <b>parent($skip_generations)</b> <b>/</b> <b>up($skip_generations)</b>
       Returns a Badger::Filesystem::Directory object representing the parent directory for a path.

           Path-&gt;('/foo/bar')-&gt;parent;             # path object for /foo

       A numerical argument can be provided to indicate the number of generation you want to skip.  A value of 0
       is the same as providing no argument - it returns the parent.  A value of 1 skips the parent and returns
       the grand-parent, and so on.

           Path-&gt;('/foo/bar/baz/bam')-&gt;<a href="../man2/parent.2.html">parent</a>(2);  # path object for /foo

       The root directory will be returned if you try to skip too many generations.

           Path-&gt;('/foo/bar/baz/bam')-&gt;<a href="../man20/parent.20.html">parent</a>(20); # path object for /

   <b>path_up()</b>
       This returns a text string representing the parent of a path.  If the path contains multiple items (e.g.
       '/foo/bar' or 'foo/bar') then the last item will be removed (e.g. resulting in '/foo' or 'foo'
       respectively).  If an absolute path contains one item or none (e.g. '/foo' or '/') then the root
       directory ('/') will be returned.  A relative path with only one item (e.g. 'foo') is assumed to be
       relative to the current working directory which will be returned (e.g. '/path/to/current/dir').

   <b>exists()</b>
       Returns true if the path exists in the filesystem (e.g. as a file, directory, or some other entry), or
       false if not.

           if ($path-&gt;exists) {
               print "$path already exists\n";
           }
           else {
               print "Creating $path\n";
               # ...etc...
           }

   <b>must_exist($create)</b>
       Checks that the path exists (by calling <b>exists()</b>) and throws an error if it doesn't.

           $path-&gt;must_exist;                      # no need to check return value

       The $create flag can be set to have it attempt to <b>create()</b> itself if it doesn't already exist.  However,
       this only makes sense for file and directory subclasses and not base class paths.

           $dir-&gt;<a href="../man1/must_exist.1.html">must_exist</a>(1);                    # create if it doesn't

   <b>create()</b>
       In the base class this will method will throw an error. You can't physically create an abstract path
       unless you know what kind of concrete entity (e.g.  file or directory) it maps onto. In other words, the
       <b>create()</b> method will only work for the Badger::Filesystem::File and Badger::Filesystem::Directory
       subclasses.

           $path-&gt;create;                          # FAIL
           $dir-&gt;create;                           # OK
           $file-&gt;create;                          # OK

   <b>chmod($perms)</b>
       This method changes the file permissions on a file or directory.

           $file-&gt;<a href="../man0775/chmod.0775.html">chmod</a>(0775);

   <b>stat()</b>
       Performs a filesystem "stat" on the path and returns a list (in list context), or a reference to a list
       (in scalar context) containing the 13 information elements.

           @list = $path-&gt;stat;                    # list context
           $list = $path-&gt;stat;                    # scalar context

       A summary of the fields is shown below. See "perldoc -f stat" for complete details. Each of the
       individual fields can also be accessed via their own methods, also listed in the table.

           Field   Method          Description
           ------------------------------------------------------------------------
             0     device()        device number of filesystem
             1     inoode()        inode number
             2     mode()          file mode  (type and permissions)
             3     links()         number of (hard) links to the file
             4     user()          numeric user ID of file’s owner
             5     group()         numeric group ID of file’s owner
             6     device_type()   the device identifier (special files only)
             7     size()          total size of file, in bytes
             8     atime()         last access time in seconds since the epoch
             9     mtime()         last modify time in seconds since the epoch
            10     ctime()         inode change time in seconds since the epoch (*)
            11     block_size()    preferred block size for file system I/O
            12     blocks()        actual number of blocks allocated

       In addition to those that are returned by Perl's inbuilt "stat" function, this method returns four
       additional flags.

            13     readable()      file is readable by current process
            14     writeable()     file is writeable by current process
            15     executable()    file is executable by current process
            16     owner()         file is owned by current process

   <b>stats()</b>
       A wrapper around the <b>stat()</b> method which caches the results to avoid making repeated filesystem calls.

           @list = $path-&gt;stats;                   # list context
           $list = $path-&gt;stats;                   # scalar context

       Note that the <b>accessed()</b>, <b>created()</b> and <b>modified()</b> methods also cache the Badger::Timestamp objects they
       create to represent the access, creation and modification times respectively.

   <b>restat()</b>
       Clears any cached values stored by the <b>stats()</b>, <b>accessed()</b>, <b>created()</b> and <b>modified()</b> methods and calls
       <b>stats()</b> to reload (and re-cache) the data from a <b>stat()</b> call.

   <b>device()</b>
       Returns the device number for the file.  See <b>stat()</b>.

   <b>inode()</b>
       Returns the inode number for the file.  See <b>stat()</b>.

   <b>mode()</b>
       Returns the file mode for the file.  Note that this contains both the file type and permissions.  See
       <b>stat()</b>.

   <b>permissions()</b> <b>/</b> <b>perms()</b>
       Returns the file permissions.  This is equivalent to "$file-&gt;mode &amp; 0777".

   <b>links()</b>
       Returns the number of hard links to the file.  See <b>stat()</b>.

   <b>user()</b>
       Returns the numeric user ID of the file's owner.  See <b>stat()</b>.

   <b>group()</b>
       Returns the numeric group ID of the file's group.  See <b>stat()</b>.

   <b>device_type()</b>
       Returns the device identifier (for special files only).  See <b>stat()</b>.

   <b>size()</b>
       Returns the total size of the file in bytes.  See <b>stat()</b>.

   <b>atime()</b>
       Returns the time (in seconds since the epoch) that the file was last accessed.  See <b>stat()</b>.

   <b>accessed()</b>
       Returns a Badger::Timestamp object for the <b>atime()</b> value.  This object will auto-stringify to produce an
       ISO-8601 formatted date.  You can also call various methods to access different parts of the time and/or
       date.

           print $file-&gt;accessed;              # 2009/04/20 16:25:00
           print $file-&gt;accessed-&gt;date;        # 2009/04/20
           print $file-&gt;accessed-&gt;year;        # 2009

   <b>mtime()</b>
       Returns the time (in seconds since the epoch) that the file was last modified.  See <b>stat()</b>.

   <b>modified()</b>
       Returns a Badger::Timestamp object for the <b>mtime()</b> value.

           print $file-&gt;modified;              # 2009/04/20 16:25:00
           print $file-&gt;modified-&gt;time;        # 16:25:0
           print $file-&gt;modified-&gt;hour;        # 16

   <b>ctime()</b>
       Returns the time (in seconds since the epoch) that the file was created. See <b>stat()</b>.

   <b>created()</b>
       Returns a Badger::Timestamp object for the <b>ctime()</b> value.

           print $file-&gt;created;               # 2009/04/20 16:25:00
           print $file-&gt;created-&gt;date;         # 2009/04/20
           print $file-&gt;created-&gt;time;         # 16:25:00

   <b>block_size()</b>
       Returns the preferred block size for file system I/O on the file. See <b>stat()</b>.

   <b>blocks()</b>
       Returns the actual number of blocks allocated to the file. See <b>stat()</b>.

   <b>readable()</b>
       Returns a true value if the file is readable by the current user (i.e. the owner of the current process),
       false if not.  See <b>stat()</b>.

   <b>writeable()</b>
       Returns a true value if the file is writeable by the current user (i.e. the owner of the current
       process), false if not.  See <b>stat()</b>.

   <b>executable()</b>
       Returns a true value if the file is executable by the current user (i.e. the owner of the current
       process), false if not.  See <b>stat()</b>.

   <b>owner()</b>
       Returns a true value if the file is owned by the current user (i.e. the owner of the current process),
       false if not.  See <b>stat()</b>.

   <b>filesystem()</b>
       Returns a reference to a Badger::Filesystem object, or the name of the filesystem class (e.g.
       Badger::Filesystem or a subclass) that created the path object.  If this is undefined then the default
       value defined in the $FILESYSTEM class variable is returned.   Unless you've changed it, or re-defined it
       in a subclass, this value will be "Badger::Filesystem".

       The end result is that you can use the "filesystem" method to access a Badger::Filesystem object or class
       through which you can perform other filesystem related operations.  This is used internally by a number
       of method.

           # access filesystem via existing path
           $path-&gt;filesystem-&gt;dir('/a/new/directory/object');

           # same as
           Badger::Filesystem-&gt;dir('/a/new/directory/object');

   <b>visit($visitor)</b>
       Entry point for a filesystem visitor to visit a filesystem path.  A reference to a
       Badger::Filesystem::Visitor object (or subclass) should be passed as the first argument.

           use Badger::Filesystem::Visitor;

           my $visitor = Badger::Filesystem::Visitor-&gt;new( recurse =&gt; 1 );
           $path-&gt;visit($visitor);

       Alternately, a list or reference to a hash array of named parameters may be provided. These will be used
       to instantiate a new Badger::Filesystem::Visitor object (via the Badger::Filesystem <b>visitor()</b> method)
       which will then be applied to the path.  If no arguments are passed then a visitor is created with a
       default configuration.

           # either list of named params
           $path-&gt;visit( recurse =&gt; 1 );

           # or reference to hash array
           $path-&gt;visit({ recurse =&gt; 1});

       The method then calls the visitor <b>visit()</b> passing $self as an argument to begin the visit.

   <b>accept($visitor)</b>
       This method is called to dispatch a visitor to the correct method for a filesystem object. In the
       Badger::Filesystem::Path base class, it calls the visitor <b>visit_path()</b> method, passing the $self object
       reference as an argument. Subclasses redefine this method to call other visitor methods.

   <b>enter($visitor)</b>
       This is a special case of the <b>accept()</b> method which subclasses (e.g.  directory) use to differentiate
       between the initial entry point of a visitor and subsequent visits to directories contained therein.  In
       the base class it simply delegates to the <b>accept()</b> method.

   <b>collect(\%params)</b>
       This is a short-cut to call the <b>visit()</b> method and then the <b>collect()</b> method on the
       Badger::Filesystem::Visitor object returned.

           # short form
           my @items = $path-&gt;collect( files =&gt; 1, dirs =&gt; 0 );

           # long form
           my @items = $path-&gt;visit( files =&gt; 1, dirs =&gt; 0 )-&gt;collect;

   <b>metadata()</b> <b>/</b> <b>meta()</b>
       This method allows you to associate metadata with a path.  The method accepts multiple arguments to set
       metadata:

           $path-&gt;metadata( title =&gt; 'An Example', author =&gt; 'Arthur Dent' );

       It also accepts a single argument to fetch a metadata item:

           print $path-&gt;metadata('author');        # Arthur Dent

       You can also call it without arguments.  The method returns a reference to a hash array of metadata
       items.

           my $meta = $path-&gt;metadata;
           print $meta-&gt;{ author };                # Arthur Dent

</pre><h4><b>STUB</b> <b>METHODS</b></h4><pre>
       The following methods serve little or no purpose in the "Badger::Filesystem::Path" base class. They are
       redefined by the "Badger::Filesystem::Directory" and "Badger::Filesystem::File" modules to do the right
       thing.

   <b>is_file()</b>
       This method always returns false in the "Badger::Filesystem::Path" base class. The
       "Badger::Filesystem::File" subclass redefines this to return true.  NOTE: this may be changed to examine
       the filesystem and return true if the path references a file.

   <b>is_directory()</b> <b>/</b> <b>is_dir()</b>
       This method always returns false in the "Badger::Filesystem::Path" base class. The
       "Badger::Filesystem::Directory" subclass redefines this to return true.  NOTE: this may be changed to
       examine the filesystem and return true if the path references a file.

   <b>volume()</b> <b>/</b> <b>vol()</b>
       Returns any volume defined as part of the path. This method does nothing in the
       "Badger::Filesystem::Path" base class.

   <b>directory()</b> <b>/</b> <b>dir()</b>
       Returns the directory portion of a path. This method does nothing in the "Badger::Filesystem::Path" base
       class.

   <b>name()</b>
       Returns the file name portion of a path. This method does nothing in the "Badger::Filesystem::Path" base
       class.

   <b>extension()</b> <b>/</b> <b>ext()</b>
       Returns any file extension portion following the final "." in the path.  This works in the
       "Badger::Filesystem::Path" base class by looking at the full path.

           print Path('/foo/bar.txt')-&gt;extension;      # txt

   <b>basename()</b> <b>/</b> <b>base_name()</b>
       Returns the filename <u>without</u> the file extension following the final "." in the path.  This works (for
       some definition of "works") in the "Badger::Filesystem::Path" base class by looking at the path <b>name()</b>,
       if defined, or the full "path" if not.  Note that this will produce unexpected results in some cases due
       to the fact that the base class does not define a value for <b>name()</b>.  e.g.

           print Path('/foo/bar.txt')-&gt;basename;       # /foo/bar

       However, in most cases you would be using this through a Badger::Filesystem::File subclass which will
       product the correct results.

           print File('/foo/bar.txt')-&gt;basename;       # bar

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley &lt;<a href="http://wardley.org/">http://wardley.org/</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2005-2009 Andy Wardley. All rights reserved.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       The "Badger::Filesystem" modules are built around a number of existing Perl modules, including
       File::Spec, File::Path, Cwd, IO::File, IO::Dir and draw heavily on ideas in Path::Class.

       Please see the ACKNOWLEDGEMENTS in Badger::Filesystem for further information.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Badger::Filesystem, Badger::Filesystem::File, Badger::Filesystem::Directory, Badger::Filesystem::Visitor.

perl v5.36.0                                       2023-08-28                      <u>Badger::Filesystem::<a href="../man3pm/Path.3pm.html">Path</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>