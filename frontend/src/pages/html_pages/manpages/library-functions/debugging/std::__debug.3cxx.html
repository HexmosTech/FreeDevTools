<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::__debug - GNU debug code, replaces standard behavior with debug behavior.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::__debug - GNU debug code, replaces standard behavior with debug behavior.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Classes</b>
       class <b>bitset</b>
           Class std::bitset with additional safety/checking/debug instrumentation.
       class <b>deque</b>
           Class std::deque with safety/checking/debug instrumentation.
       class <b>forward_list</b>
           Class std::forward_list with safety/checking/debug instrumentation.
       class <b>list</b>
           Class std::list with safety/checking/debug instrumentation.
       class <b>map</b>
           Class std::map with safety/checking/debug instrumentation.
       class <b>multimap</b>
           Class std::multimap with safety/checking/debug instrumentation.
       class <b>multiset</b>
           Class std::multiset with safety/checking/debug instrumentation.
       class <b>set</b>
           Class std::set with safety/checking/debug instrumentation.
       class <b>unordered_map</b>
           Class std::unordered_map with safety/checking/debug instrumentation.
       class <b>unordered_multimap</b>
           Class std::unordered_multimap with safety/checking/debug instrumentation.
       class <b>unordered_multiset</b>
           Class std::unordered_multiset with safety/checking/debug instrumentation.
       class <b>unordered_set</b>
           Class std::unordered_set with safety/checking/debug instrumentation.
       class <b>vector</b>
           Class std::vector with safety/checking/debug instrumentation.

   <b>Functions</b>
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_ValT</b>  = typename
           iterator_traits&lt;_InputIterator&gt;::value_type, <b>typename</b> <b>_Allocator</b>  = allocator&lt;_ValT&gt;, <b>typename</b>  =
           _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>deque</b> (<b>_InputIterator</b>,
           <b>_InputIterator</b>, <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>deque</b>&lt; <b>_ValT</b>, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b>  = allocator&lt;_Tp&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt;
           <b>deque</b> (size_t, _Tp, <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>deque</b>&lt; _Tp, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_ValT</b>  = typename
           iterator_traits&lt;_InputIterator&gt;::value_type, <b>typename</b> <b>_Allocator</b>  = allocator&lt;_ValT&gt;, <b>typename</b>  =
           _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>forward_list</b>
           (<b>_InputIterator</b>, <b>_InputIterator</b>, <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>forward_list</b>&lt; <b>_ValT</b>, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b>  = allocator&lt;_Tp&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt;
           <b>forward_list</b> (size_t, _Tp, <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>forward_list</b>&lt; _Tp, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_ValT</b>  = typename
           iterator_traits&lt;_InputIterator&gt;::value_type, <b>typename</b> <b>_Allocator</b>  = allocator&lt;_ValT&gt;, <b>typename</b>  =
           _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>list</b> (<b>_InputIterator</b>,
           <b>_InputIterator</b>, <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>list</b>&lt; <b>_ValT</b>, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b>  = allocator&lt;_Tp&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt;
           <b>list</b> (size_t, _Tp, <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>list</b>&lt; _Tp, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>map</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, <b>_Allocator</b>) -&gt; <b>map</b>&lt;
           <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt;, __iter_val_t&lt; <b>_InputIterator</b> &gt;, <b>less</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt;
           &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> _Compare  = less&lt;__iter_key_t&lt;_InputIterator&gt;&gt;, <b>typename</b>
           <b>_Allocator</b>  = allocator&lt;__iter_to_alloc_t&lt;_InputIterator&gt;&gt;, <b>typename</b>  =
           _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>  = _RequireNotAllocator&lt;_Compare&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>map</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, _Compare=_Compare(),
           <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>map</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt;, __iter_val_t&lt; <b>_InputIterator</b> &gt;,
           _Compare, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt;
           <b>map</b> (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;, <b>_Allocator</b>) -&gt; <b>map</b>&lt; <b>_Key</b>, _Tp, <b>less</b>&lt; <b>_Key</b> &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare  = less&lt;_Key&gt;, <b>typename</b> <b>_Allocator</b>  =
           allocator&lt;pair&lt;const _Key, _Tp&gt;&gt;, <b>typename</b>  = _RequireNotAllocator&lt;_Compare&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>map</b> (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;, _Compare=_Compare(),
           <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>multimap</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, <b>_Allocator</b>) -&gt;
           <b>multimap</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt;, __iter_val_t&lt; <b>_InputIterator</b> &gt;, <b>less</b>&lt; <b>__iter_key_t</b>&lt;
           <b>_InputIterator</b> &gt; &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> _Compare  = less&lt;__iter_key_t&lt;_InputIterator&gt;&gt;, <b>typename</b>
           <b>_Allocator</b>  = allocator&lt;__iter_to_alloc_t&lt;_InputIterator&gt;&gt;, <b>typename</b>  =
           _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>  = _RequireNotAllocator&lt;_Compare&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>multimap</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, _Compare=_Compare(),
           <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>multimap</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt;, __iter_val_t&lt; <b>_InputIterator</b> &gt;,
           _Compare, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt;
           <b>multimap</b> (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;, <b>_Allocator</b>) -&gt; <b>multimap</b>&lt; <b>_Key</b>, _Tp, <b>less</b>&lt; <b>_Key</b> &gt;,
           <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare  = less&lt;_Key&gt;, <b>typename</b> <b>_Allocator</b>  =
           allocator&lt;pair&lt;const _Key, _Tp&gt;&gt;, <b>typename</b>  = _RequireNotAllocator&lt;_Compare&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>multimap</b> (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;, _Compare=_Compare(),
           <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>multiset</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, <b>_Allocator</b>) -&gt;
           <b>multiset</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt; <b>_InputIterator</b> &gt;::value_type, <b>less</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt;
           <b>_InputIterator</b> &gt;::value_type &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> _Compare  = less&lt;typename
           iterator_traits&lt;_InputIterator&gt;::value_type&gt;, <b>typename</b> <b>_Allocator</b>  = allocator&lt;typename
           iterator_traits&lt;_InputIterator&gt;::value_type&gt;, <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>
           = _RequireNotAllocator&lt;_Compare&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>multiset</b>
           (<b>_InputIterator</b>, <b>_InputIterator</b>, _Compare=_Compare(), <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>multiset</b>&lt; <b>typename</b>
           <b>iterator_traits</b>&lt; <b>_InputIterator</b> &gt;::value_type, _Compare, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>multiset</b>
           (<b>initializer_list</b>&lt; <b>_Key</b> &gt;, <b>_Allocator</b>) -&gt; <b>multiset</b>&lt; <b>_Key</b>, <b>less</b>&lt; <b>_Key</b> &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare  = less&lt;_Key&gt;, <b>typename</b> <b>_Allocator</b>  = allocator&lt;_Key&gt;,
           <b>typename</b>  = _RequireNotAllocator&lt;_Compare&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>multiset</b>
           (<b>initializer_list</b>&lt; <b>_Key</b> &gt;, _Compare=_Compare(), <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>multiset</b>&lt; <b>_Key</b>, _Compare,
           <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator!=</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const
           <b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator!=</b> (const <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lx</b>, const
           <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__ly</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator!=</b> (const <b>list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const <b>list</b>&lt;
           _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator!=</b> (const
           <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator!=</b> (const
           <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt;
           &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator!=</b> (const <b>multiset</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multiset</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator!=</b> (const <b>set</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>set</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator!=</b> (const <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const
           <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;size_t _Nb&gt; constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; <b>operator&amp;</b> (const <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp;__x, const <b>bitset</b>&lt; <b>_Nb</b> &gt;
           &amp;__y) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&lt;</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const <b>deque</b>&lt;
           _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&lt;</b> (const <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lx</b>, const
           <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__ly</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&lt;</b> (const <b>list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const <b>list</b>&lt;
           _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&lt;</b> (const
           <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&lt;</b> (const
           <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt;
           &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&lt;</b> (const <b>multiset</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multiset</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&lt;</b> (const <b>set</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>set</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&lt;</b> (const <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const
           <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits , size_t _Nb&gt; <b>std::basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;
           <b>operator&lt;&lt;</b> (<b>std::basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;<b>__os</b>, const <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp;__x)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&lt;=</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const
           <b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&lt;=</b> (const <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lx</b>, const
           <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__ly</b>)
           Based on operator&lt;.
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&lt;=</b> (const <b>list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const <b>list</b>&lt;
           _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&lt;=</b> (const
           <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&lt;=</b> (const
           <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt;
           &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&lt;=</b> (const <b>multiset</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multiset</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&lt;=</b> (const <b>set</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>set</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&lt;=</b> (const <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const
           <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator==</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const
           <b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator==</b> (const <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lx</b>, const
           <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__ly</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator==</b> (const <b>list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const <b>list</b>&lt;
           _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator==</b> (const
           <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator==</b> (const
           <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt;
           &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator==</b> (const <b>multiset</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multiset</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator==</b> (const <b>set</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>set</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Pred</b> , <b>typename</b> _Alloc &gt; bool
           <b>operator==</b> (const <b>unordered_map</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>_Pred</b>, _Alloc &gt; &amp;__x, const <b>unordered_map</b>&lt; <b>_Key</b>,
           _Tp, <b>_Hash</b>, <b>_Pred</b>, _Alloc &gt; &amp;__y)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Pred</b> , <b>typename</b> _Alloc &gt; bool
           <b>operator==</b> (const <b>unordered_multimap</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>_Pred</b>, _Alloc &gt; &amp;__x, const
           <b>unordered_multimap</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>_Pred</b>, _Alloc &gt; &amp;__y)
       template&lt;<b>typename</b> _Value , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Pred</b> , <b>typename</b> _Alloc &gt; bool <b>operator==</b> (const
           <b>unordered_multiset</b>&lt; _Value, <b>_Hash</b>, <b>_Pred</b>, _Alloc &gt; &amp;__x, const <b>unordered_multiset</b>&lt; _Value, <b>_Hash</b>,
           <b>_Pred</b>, _Alloc &gt; &amp;__y)
       template&lt;<b>typename</b> _Value , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Pred</b> , <b>typename</b> _Alloc &gt; bool <b>operator==</b> (const
           <b>unordered_set</b>&lt; _Value, <b>_Hash</b>, <b>_Pred</b>, _Alloc &gt; &amp;__x, const <b>unordered_set</b>&lt; _Value, <b>_Hash</b>, <b>_Pred</b>, _Alloc
           &gt; &amp;__y)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator==</b> (const <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const
           <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&gt;</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const <b>deque</b>&lt;
           _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&gt;</b> (const <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lx</b>, const
           <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__ly</b>)
           Based on operator&lt;.
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&gt;</b> (const <b>list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const <b>list</b>&lt;
           _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&gt;</b> (const
           <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&gt;</b> (const
           <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt;
           &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&gt;</b> (const <b>multiset</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multiset</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&gt;</b> (const <b>set</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>set</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&gt;</b> (const <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const
           <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&gt;=</b> (const <b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const
           <b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&gt;=</b> (const <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lx</b>, const
           <b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__ly</b>)
           Based on operator&lt;.
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&gt;=</b> (const <b>list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const <b>list</b>&lt;
           _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&gt;=</b> (const
           <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&gt;=</b> (const
           <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt;
           &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&gt;=</b> (const <b>multiset</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>multiset</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; bool <b>operator&gt;=</b> (const <b>set</b>&lt; <b>_Key</b>,
           _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, const <b>set</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; bool <b>operator&gt;=</b> (const <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, const
           <b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__rhs</b>)
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits , size_t _Nb&gt; <b>std::basic_istream</b>&lt; _CharT, _Traits &gt; &amp;
           <b>operator&gt;&gt;</b> (<b>std::basic_istream</b>&lt; _CharT, _Traits &gt; &amp;<b>__is</b>, <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp;__x)
       template&lt;size_t _Nb&gt; constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; <b>operator^</b> (const <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp;__x, const <b>bitset</b>&lt; <b>_Nb</b> &gt;
           &amp;__y) noexcept
       template&lt;size_t _Nb&gt; constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; <b>operator|</b> (const <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp;__x, const <b>bitset</b>&lt; <b>_Nb</b> &gt;
           &amp;__y) noexcept
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>set</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, <b>_Allocator</b>) -&gt; <b>set</b>&lt;
           <b>typename</b> <b>iterator_traits</b>&lt; <b>_InputIterator</b> &gt;::value_type, <b>less</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt;
           <b>_InputIterator</b> &gt;::value_type &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> _Compare  = less&lt;typename
           iterator_traits&lt;_InputIterator&gt;::value_type&gt;, <b>typename</b> <b>_Allocator</b>  = allocator&lt;typename
           iterator_traits&lt;_InputIterator&gt;::value_type&gt;, <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>
           = _RequireNotAllocator&lt;_Compare&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>set</b> (<b>_InputIterator</b>,
           <b>_InputIterator</b>, _Compare=_Compare(), <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>set</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt;
           <b>_InputIterator</b> &gt;::value_type, _Compare, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>set</b>
           (<b>initializer_list</b>&lt; <b>_Key</b> &gt;, <b>_Allocator</b>) -&gt; <b>set</b>&lt; <b>_Key</b>, <b>less</b>&lt; <b>_Key</b> &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare  = less&lt;_Key&gt;, <b>typename</b> <b>_Allocator</b>  = allocator&lt;_Key&gt;,
           <b>typename</b>  = _RequireNotAllocator&lt;_Compare&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>set</b>
           (<b>initializer_list</b>&lt; <b>_Key</b> &gt;, _Compare=_Compare(), <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>set</b>&lt; <b>_Key</b>, _Compare,
           <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; <b>void</b> <b>swap</b> (<b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, <b>deque</b>&lt; _Tp, _Alloc &gt;
           &amp;<b>__rhs</b>) noexcept(/*<b>conditional</b> */)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; <b>void</b> <b>swap</b> (<b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lx</b>, <b>forward_list</b>&lt;
           _Tp, _Alloc &gt; &amp;<b>__ly</b>) noexcept(noexcept(__lx.swap(<b>__ly</b>)))
           See std::forward_list::swap().
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; <b>void</b> <b>swap</b> (<b>list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, <b>list</b>&lt; _Tp, _Alloc &gt;
           &amp;<b>__rhs</b>) noexcept(/*<b>conditional</b> */)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; <b>void</b> <b>swap</b> (<b>map</b>&lt; <b>_Key</b>,
           _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, <b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
           noexcept(/*<b>conditional</b> */)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; <b>void</b> <b>swap</b> (<b>multimap</b>&lt;
           <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__lhs</b>, <b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, <b>_Allocator</b> &gt; &amp;<b>__rhs</b>)
           noexcept(/*<b>conditional</b> */)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; <b>void</b> <b>swap</b> (<b>multiset</b>&lt; <b>_Key</b>, _Compare,
           <b>_Allocator</b> &gt; &amp;__x, <b>multiset</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;__y) noexcept(/*<b>conditional</b> */)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> <b>_Allocator</b> &gt; <b>void</b> <b>swap</b> (<b>set</b>&lt; <b>_Key</b>, _Compare,
           <b>_Allocator</b> &gt; &amp;__x, <b>set</b>&lt; <b>_Key</b>, _Compare, <b>_Allocator</b> &gt; &amp;__y) noexcept(/*<b>conditional</b> */)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Pred</b> , <b>typename</b> _Alloc &gt; <b>void</b> <b>swap</b>
           (<b>unordered_map</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>_Pred</b>, _Alloc &gt; &amp;__x, <b>unordered_map</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>_Pred</b>,
           _Alloc &gt; &amp;__y) noexcept(noexcept(__x.swap(__y)))
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Pred</b> , <b>typename</b> _Alloc &gt; <b>void</b> <b>swap</b>
           (<b>unordered_multimap</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>_Pred</b>, _Alloc &gt; &amp;__x, <b>unordered_multimap</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>,
           <b>_Pred</b>, _Alloc &gt; &amp;__y) noexcept(noexcept(__x.swap(__y)))
       template&lt;<b>typename</b> _Value , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Pred</b> , <b>typename</b> _Alloc &gt; <b>void</b> <b>swap</b>
           (<b>unordered_multiset</b>&lt; _Value, <b>_Hash</b>, <b>_Pred</b>, _Alloc &gt; &amp;__x, <b>unordered_multiset</b>&lt; _Value, <b>_Hash</b>, <b>_Pred</b>,
           _Alloc &gt; &amp;__y) noexcept(noexcept(__x.swap(__y)))
       template&lt;<b>typename</b> _Value , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Pred</b> , <b>typename</b> _Alloc &gt; <b>void</b> <b>swap</b> (<b>unordered_set</b>&lt;
           _Value, <b>_Hash</b>, <b>_Pred</b>, _Alloc &gt; &amp;__x, <b>unordered_set</b>&lt; _Value, <b>_Hash</b>, <b>_Pred</b>, _Alloc &gt; &amp;__y)
           noexcept(noexcept(__x.swap(__y)))
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; <b>void</b> <b>swap</b> (<b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__lhs</b>, <b>vector</b>&lt; _Tp, _Alloc &gt;
           &amp;<b>__rhs</b>) noexcept(/*<b>conditional</b> */)
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, <b>_Allocator</b>)
           -&gt; <b>unordered_map</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt;, __iter_val_t&lt; <b>_InputIterator</b> &gt;, <b>hash</b>&lt; <b>__iter_key_t</b>&lt;
           <b>_InputIterator</b> &gt; &gt;, <b>equal_to</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt; &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, <b>typename</b>
           <b>unordered_map</b>&lt; int, int &gt;::size_type, <b>_Allocator</b>) -&gt; <b>unordered_map</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt;,
           __iter_val_t&lt; <b>_InputIterator</b> &gt;, <b>hash</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt; &gt;, <b>equal_to</b>&lt; <b>__iter_key_t</b>&lt;
           <b>_InputIterator</b> &gt; &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  =
           _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>  = _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, <b>typename</b> <b>unordered_map</b>&lt;
           int, int &gt;::size_type, <b>_Hash</b>, <b>_Allocator</b>) -&gt; <b>unordered_map</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt;,
           __iter_val_t&lt; <b>_InputIterator</b> &gt;, <b>_Hash</b>, <b>equal_to</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt; &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Hash</b>  = hash&lt;__iter_key_t&lt;_InputIterator&gt;&gt;, <b>typename</b> <b>_Pred</b>
           = equal_to&lt;__iter_key_t&lt;_InputIterator&gt;&gt;, <b>typename</b> <b>_Allocator</b>  =
           allocator&lt;__iter_to_alloc_t&lt;_InputIterator&gt;&gt;, <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>
           = _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  = _RequireNotAllocator&lt;_Pred&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, <b>typename</b> <b>unordered_map</b>&lt;
           int, int &gt;::size_type={}, <b>_Hash</b>=<b>_Hash</b>(), <b>_Pred</b>=<b>_Pred</b>(), <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>unordered_map</b>&lt;
           <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt;, __iter_val_t&lt; <b>_InputIterator</b> &gt;, <b>_Hash</b>, <b>_Pred</b>, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt;
           <b>unordered_map</b> (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;, <b>_Allocator</b>) -&gt; <b>unordered_map</b>&lt; <b>_Key</b>, _Tp, <b>hash</b>&lt;
           <b>_Key</b> &gt;, <b>equal_to</b>&lt; <b>_Key</b> &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt;
           <b>unordered_map</b> (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;, <b>typename</b> <b>unordered_map</b>&lt; int, int &gt;::size_type,
           <b>_Allocator</b>) -&gt; <b>unordered_map</b>&lt; <b>_Key</b>, _Tp, <b>hash</b>&lt; <b>_Key</b> &gt;, <b>equal_to</b>&lt; <b>_Key</b> &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  =
           _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b>
           (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;, <b>typename</b> <b>unordered_map</b>&lt; int, int &gt;::size_type, <b>_Hash</b>,
           <b>_Allocator</b>) -&gt; <b>unordered_map</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>equal_to</b>&lt; <b>_Key</b> &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Hash</b>  = hash&lt;_Key&gt;, <b>typename</b> <b>_Pred</b>  = equal_to&lt;_Key&gt;,
           <b>typename</b> <b>_Allocator</b>  = allocator&lt;pair&lt;const _Key, _Tp&gt;&gt;, <b>typename</b>  =
           _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  = _RequireNotAllocator&lt;_Pred&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_map</b> (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;, <b>typename</b>
           <b>unordered_map</b>&lt; int, int &gt;::size_type={}, <b>_Hash</b>=<b>_Hash</b>(), <b>_Pred</b>=<b>_Pred</b>(), <b>_Allocator</b>=<b>_Allocator</b>()) -&gt;
           <b>unordered_map</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>_Pred</b>, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_multimap</b> (<b>_InputIterator</b>, <b>_InputIterator</b>,
           <b>_Allocator</b>) -&gt; <b>unordered_multimap</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt;, __iter_val_t&lt; <b>_InputIterator</b> &gt;,
           <b>hash</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt; &gt;, <b>equal_to</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt; &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_multimap</b> (<b>_InputIterator</b>, <b>_InputIterator</b>,
           <b>unordered_multimap</b>&lt; int, int &gt;::size_type, <b>_Allocator</b>) -&gt; <b>unordered_multimap</b>&lt; <b>__iter_key_t</b>&lt;
           <b>_InputIterator</b> &gt;, __iter_val_t&lt; <b>_InputIterator</b> &gt;, <b>hash</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt; &gt;, <b>equal_to</b>&lt;
           <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt; &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  =
           _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>  = _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_multimap</b> (<b>_InputIterator</b>, <b>_InputIterator</b>,
           <b>unordered_multimap</b>&lt; int, int &gt;::size_type, <b>_Hash</b>, <b>_Allocator</b>) -&gt; <b>unordered_multimap</b>&lt; <b>__iter_key_t</b>&lt;
           <b>_InputIterator</b> &gt;, __iter_val_t&lt; <b>_InputIterator</b> &gt;, <b>_Hash</b>, <b>equal_to</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt; &gt;,
           <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Hash</b>  = hash&lt;__iter_key_t&lt;_InputIterator&gt;&gt;, <b>typename</b> <b>_Pred</b>
           = equal_to&lt;__iter_key_t&lt;_InputIterator&gt;&gt;, <b>typename</b> <b>_Allocator</b>  =
           allocator&lt;__iter_to_alloc_t&lt;_InputIterator&gt;&gt;, <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>
           = _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  = _RequireNotAllocator&lt;_Pred&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_multimap</b> (<b>_InputIterator</b>, <b>_InputIterator</b>,
           <b>unordered_multimap</b>&lt; int, int &gt;::size_type={}, <b>_Hash</b>=<b>_Hash</b>(), <b>_Pred</b>=<b>_Pred</b>(), <b>_Allocator</b>=<b>_Allocator</b>())
           -&gt; <b>unordered_multimap</b>&lt; <b>__iter_key_t</b>&lt; <b>_InputIterator</b> &gt;, __iter_val_t&lt; <b>_InputIterator</b> &gt;, <b>_Hash</b>, <b>_Pred</b>,
           <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt;
           <b>unordered_multimap</b> (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;, <b>_Allocator</b>) -&gt; <b>unordered_multimap</b>&lt; <b>_Key</b>,
           _Tp, <b>hash</b>&lt; <b>_Key</b> &gt;, <b>equal_to</b>&lt; <b>_Key</b> &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt;
           <b>unordered_multimap</b> (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;, <b>unordered_multimap</b>&lt; int, int &gt;::size_type,
           <b>_Allocator</b>) -&gt; <b>unordered_multimap</b>&lt; <b>_Key</b>, _Tp, <b>hash</b>&lt; <b>_Key</b> &gt;, <b>equal_to</b>&lt; <b>_Key</b> &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  =
           _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_multimap</b>
           (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;, <b>unordered_multimap</b>&lt; int, int &gt;::size_type, <b>_Hash</b>, <b>_Allocator</b>)
           -&gt; <b>unordered_multimap</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>equal_to</b>&lt; <b>_Key</b> &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Hash</b>  = hash&lt;_Key&gt;, <b>typename</b> <b>_Pred</b>  = equal_to&lt;_Key&gt;,
           <b>typename</b> <b>_Allocator</b>  = allocator&lt;pair&lt;const _Key, _Tp&gt;&gt;, <b>typename</b>  =
           _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  = _RequireNotAllocator&lt;_Pred&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_multimap</b> (<b>initializer_list</b>&lt; <b>pair</b>&lt; <b>_Key</b>, _Tp &gt; &gt;,
           <b>unordered_multimap</b>&lt; int, int &gt;::size_type={}, <b>_Hash</b>=<b>_Hash</b>(), <b>_Pred</b>=<b>_Pred</b>(), <b>_Allocator</b>=<b>_Allocator</b>())
           -&gt; <b>unordered_multimap</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>_Pred</b>, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_multiset</b> (<b>_InputIterator</b>, <b>_InputIterator</b>,
           <b>unordered_multiset</b>&lt; int &gt;::size_type, <b>_Allocator</b>) -&gt; <b>unordered_multiset</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt;
           <b>_InputIterator</b> &gt;::value_type, <b>hash</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt; <b>_InputIterator</b> &gt;::value_type &gt;,
           <b>equal_to</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt; <b>_InputIterator</b> &gt;::value_type &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  =
           _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>  = _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_multiset</b> (<b>_InputIterator</b>, <b>_InputIterator</b>,
           <b>unordered_multiset</b>&lt; int &gt;::size_type, <b>_Hash</b>, <b>_Allocator</b>) -&gt; <b>unordered_multiset</b>&lt; <b>typename</b>
           <b>iterator_traits</b>&lt; <b>_InputIterator</b> &gt;::value_type, <b>_Hash</b>, <b>equal_to</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt;
           <b>_InputIterator</b> &gt;::value_type &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Hash</b>  = hash&lt;typename
           iterator_traits&lt;_InputIterator&gt;::value_type&gt;, <b>typename</b> <b>_Pred</b>  = equal_to&lt;typename
           iterator_traits&lt;_InputIterator&gt;::value_type&gt;, <b>typename</b> <b>_Allocator</b>  = allocator&lt;typename
           iterator_traits&lt;_InputIterator&gt;::value_type&gt;, <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>
           = _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  = _RequireNotAllocator&lt;_Pred&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_multiset</b> (<b>_InputIterator</b>, <b>_InputIterator</b>,
           <b>unordered_multiset</b>&lt; int &gt;::size_type={}, <b>_Hash</b>=<b>_Hash</b>(), <b>_Pred</b>=<b>_Pred</b>(), <b>_Allocator</b>=<b>_Allocator</b>()) -&gt;
           <b>unordered_multiset</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt; <b>_InputIterator</b> &gt;::value_type, <b>_Hash</b>, <b>_Pred</b>, <b>_Allocator</b>
           &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt;
           <b>unordered_multiset</b> (<b>initializer_list</b>&lt; _Tp &gt;, <b>unordered_multiset</b>&lt; int &gt;::size_type, <b>_Allocator</b>) -&gt;
           <b>unordered_multiset</b>&lt; _Tp, <b>hash</b>&lt; _Tp &gt;, <b>equal_to</b>&lt; _Tp &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  =
           _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_multiset</b>
           (<b>initializer_list</b>&lt; _Tp &gt;, <b>unordered_multiset</b>&lt; int &gt;::size_type, <b>_Hash</b>, <b>_Allocator</b>) -&gt;
           <b>unordered_multiset</b>&lt; _Tp, <b>_Hash</b>, <b>equal_to</b>&lt; _Tp &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Hash</b>  = hash&lt;_Tp&gt;, <b>typename</b> <b>_Pred</b>  = equal_to&lt;_Tp&gt;, <b>typename</b> <b>_Allocator</b>
           = allocator&lt;_Tp&gt;, <b>typename</b>  = _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  =
           _RequireNotAllocator&lt;_Pred&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_multiset</b>
           (<b>initializer_list</b>&lt; _Tp &gt;, <b>unordered_multiset</b>&lt; int &gt;::size_type={}, <b>_Hash</b>=<b>_Hash</b>(), <b>_Pred</b>=<b>_Pred</b>(),
           <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>unordered_multiset</b>&lt; _Tp, <b>_Hash</b>, <b>_Pred</b>, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_set</b> (<b>_InputIterator</b>, <b>_InputIterator</b>,
           <b>unordered_set</b>&lt; int &gt;::size_type, <b>_Allocator</b>) -&gt; <b>unordered_set</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt;
           <b>_InputIterator</b> &gt;::value_type, <b>hash</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt; <b>_InputIterator</b> &gt;::value_type &gt;,
           <b>equal_to</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt; <b>_InputIterator</b> &gt;::value_type &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  =
           _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>  = _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_set</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, <b>unordered_set</b>&lt; int
           &gt;::size_type, <b>_Hash</b>, <b>_Allocator</b>) -&gt; <b>unordered_set</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt; <b>_InputIterator</b>
           &gt;::value_type, <b>_Hash</b>, <b>equal_to</b>&lt; <b>typename</b> <b>iterator_traits</b>&lt; <b>_InputIterator</b> &gt;::value_type &gt;, <b>_Allocator</b>
           &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_Hash</b>  = hash&lt;typename
           iterator_traits&lt;_InputIterator&gt;::value_type&gt;, <b>typename</b> <b>_Pred</b>  = equal_to&lt;typename
           iterator_traits&lt;_InputIterator&gt;::value_type&gt;, <b>typename</b> <b>_Allocator</b>  = allocator&lt;typename
           iterator_traits&lt;_InputIterator&gt;::value_type&gt;, <b>typename</b>  = _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>
           = _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  = _RequireNotAllocator&lt;_Pred&gt;, <b>typename</b>  =
           _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_set</b> (<b>_InputIterator</b>, <b>_InputIterator</b>, <b>unordered_set</b>&lt; int
           &gt;::size_type={}, <b>_Hash</b>=<b>_Hash</b>(), <b>_Pred</b>=<b>_Pred</b>(), <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>unordered_set</b>&lt; <b>typename</b>
           <b>iterator_traits</b>&lt; <b>_InputIterator</b> &gt;::value_type, <b>_Hash</b>, <b>_Pred</b>, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_set</b>
           (<b>initializer_list</b>&lt; _Tp &gt;, <b>unordered_set</b>&lt; int &gt;::size_type, <b>_Allocator</b>) -&gt; <b>unordered_set</b>&lt; _Tp, <b>hash</b>&lt;
           _Tp &gt;, <b>equal_to</b>&lt; _Tp &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Allocator</b> , <b>typename</b>  =
           _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_set</b>
           (<b>initializer_list</b>&lt; _Tp &gt;, <b>unordered_set</b>&lt; int &gt;::size_type, <b>_Hash</b>, <b>_Allocator</b>) -&gt; <b>unordered_set</b>&lt; _Tp,
           <b>_Hash</b>, <b>equal_to</b>&lt; _Tp &gt;, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Hash</b>  = hash&lt;_Tp&gt;, <b>typename</b> <b>_Pred</b>  = equal_to&lt;_Tp&gt;, <b>typename</b> <b>_Allocator</b>
           = allocator&lt;_Tp&gt;, <b>typename</b>  = _RequireNotAllocatorOrIntegral&lt;_Hash&gt;, <b>typename</b>  =
           _RequireNotAllocator&lt;_Pred&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>unordered_set</b>
           (<b>initializer_list</b>&lt; _Tp &gt;, <b>unordered_set</b>&lt; int &gt;::size_type={}, <b>_Hash</b>=<b>_Hash</b>(), <b>_Pred</b>=<b>_Pred</b>(),
           <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>unordered_set</b>&lt; _Tp, <b>_Hash</b>, <b>_Pred</b>, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> <b>_ValT</b>  = typename
           iterator_traits&lt;_InputIterator&gt;::value_type, <b>typename</b> <b>_Allocator</b>  = allocator&lt;_ValT&gt;, <b>typename</b>  =
           _RequireInputIter&lt;_InputIterator&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt; <b>vector</b> (<b>_InputIterator</b>,
           <b>_InputIterator</b>, <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>vector</b>&lt; <b>_ValT</b>, <b>_Allocator</b> &gt;
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Allocator</b>  = allocator&lt;_Tp&gt;, <b>typename</b>  = _RequireAllocator&lt;_Allocator&gt;&gt;
           <b>vector</b> (size_t, _Tp, <b>_Allocator</b>=<b>_Allocator</b>()) -&gt; <b>vector</b>&lt; _Tp, <b>_Allocator</b> &gt;

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       GNU debug code, replaces standard behavior with debug behavior.

       Macros and namespaces used by the implementation outside of debug wrappers to verify certain properties.
       The __glibcxx_requires_xxx macros are merely wrappers around the __glibcxx_check_xxx wrappers when we are
       compiling with debug mode, but disappear when we are in release mode so that there is no checking
       performed in, e.g., the standard library algorithms.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>bool</b> <b>std::__debug::operator&lt;=</b> <b>(const</b> <b>forward_list&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b>
       <b>__lx,</b> <b>const</b> <b>forward_list&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__ly)</b> <b>[inline],</b>  <b>[protected]</b>
       Based on operator&lt;.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>bool</b> <b>std::__debug::operator&gt;</b> <b>(const</b> <b>forward_list&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b>
       <b>__lx,</b> <b>const</b> <b>forward_list&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__ly)</b> <b>[inline],</b>  <b>[protected]</b>
       Based on operator&lt;.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>bool</b> <b>std::__debug::operator&gt;=</b> <b>(const</b> <b>forward_list&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b>
       <b>__lx,</b> <b>const</b> <b>forward_list&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__ly)</b> <b>[inline],</b>  <b>[protected]</b>
       Based on operator&lt;.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>void</b> <b>std::__debug::swap</b> <b>(forward_list&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__lx,</b>
       <b>forward_list&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__ly)</b> <b>[inline],</b>  <b>[protected],</b>  <b>[noexcept]</b>
       See std::forward_list::swap().

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                                 <u>std::</u><b>__</b><u><a href="../man3cxx/debug.3cxx.html">debug</a></u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>