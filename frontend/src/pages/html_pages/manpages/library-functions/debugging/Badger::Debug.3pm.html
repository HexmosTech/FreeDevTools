<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badger::Debug - base class mixin module implement debugging methods</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbadger-perl">libbadger-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Badger::Debug - base class mixin module implement debugging methods

</pre><h4><b>SYNOPSIS</b></h4><pre>
           package Your::Module;

           use Badger::Debug
               default =&gt; 0;   # default value for $DEBUG and DEBUG

           sub some_method {
               my $self = shift;

               # DEBUG is a compile-time constant, so very efficient
               $self-&gt;debug("First Message") if DEBUG;

               # $DEBUG is a runtime variable, so more flexible
               $self-&gt;debug("Second Message") if $DEBUG;
           }

           package main;
           use Your::Module;

           Your::Module-&gt;some_method;      # no output, debugging off by default
           Your::Module-&gt;<a href="../man1/debugging.1.html">debugging</a>(1);     # turns runtime debugging on
           Your::Module-&gt;some_method;      # [Your::Module line 13] Second Message

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This mixin module implements a number of methods for debugging. Read "The Whole Caboodle" if you just
       want to get started quickly. Read "Picky Picky Picky" if you want to get all picky about what you want to
       use or want more information on the individual features.

       Note that all of the debugging methods described below work equally well as both object and class methods
       even if we don't explicitly show them being used both ways.

           # class method
           Your::Module-&gt;debug('called as a class method');

           # object method
           my $object = Your::Module-&gt;new;
           $object-&gt;debug('called as an object method');

   <b>The</b> <b>Whole</b> <b>Caboodle</b>
       The default import option is the all-in-one option that enables all debugging features. The value you
       specify with it will be used as the default debugging status. Use 0 if you want debugging off by default,
       or any true value if you want it on.

           package Your::Module;

           use Badger::Debug
               default =&gt; 0;

       The default option imports the <b>debug()</b> and <b>debugging()</b> methods, the $DEBUG package variable (set to the
       default value you specified unless it's already defined to be something else), and the DEBUG constant
       subroutine (defined to have the same value as the $DEBUG variable).

       In your module's methods you can call the <b>debug()</b> method to generate debugging messages. You can use the
       DEBUG constant or the $DEBUG variable as a condition so that messages only get displayed when debugging
       is enbled.

           sub some_method {
               my $self = shift;

               # DEBUG is a compile-time constant, so very efficient
               $self-&gt;debug("First Message") if DEBUG;

               # $DEBUG is a runtime variable, so more flexible
               $self-&gt;debug("Second Message") if $DEBUG;
           }

       The DEBUG constant is resolved at compile time so it results in more efficient code. When debugging is
       off, Perl will completely eliminate the first call to the <b>debug()</b> method in the above example.  The end
       result is that there's no performance overhead incurred by including debugging statements like these.

       The $DEBUG package variable is a little more flexible because you can change the value at any point
       during the execution of your program. You might want to do this from inside the module (say to enable
       debugging in one particular method that's causing problems), or outside the module from a calling program
       or another module. The <b>debugging()</b> method is provided as a convenient way to change the $DEBUG package
       variable for a module.

           Your::Module-&gt;<a href="../man0/debugging.0.html">debugging</a>(0);     # turn runtime debugging off
           Your::Module-&gt;<a href="../man1/debugging.1.html">debugging</a>(1);     # turn runtime debugging on

       The downside is that checking the $DEBUG variable at runtime is less efficient than using the DEBUG
       compile time constant. Unless you're working on performance critical code, it's probably not something
       that you should worry about.

       However, if you are the worrying type then you can use "Badger::Debug" to get some of the best bits of
       both worlds.  When your module is loaded, both DEBUG and $DEBUG will be set to the default value you
       specified <u>unless</u> <u>$DEBUG</u> <u>is</u> <u>already</u> <u>defined</u>.  If it is defined then the DEBUG constant will be set to
       whatever value it has.  So if you define the $DEBUG package variable <u>before</u> loading the module then
       you'll be able to enable both run time and compile time debugging messages without having to go and edit
       the source code of your module.

           $Your::Module::DEBUG = 1;
           require Your::Module;

       Alternately, you can let "Badger::Debug" do it for you.  The modules import option allows you to specify
       one or more modules that you want debugging enabled for.

           use Badger::Debug
               modules =&gt; 'My::Module::One My::Module::Two';

           use My::Module::One;        # both runtime and compile time
           use My::Module::Two;        # debugging enabled in both modules

       The benefit of this approach is that it happens at compile time.  If you do it <u>before</u> you "use" your
       modules, then you'll get both compile time and run time debugging enabled.  If you do it after then
       you'll get just runtime debugging enabled.  Best of all - you don't need to change any of your existing
       code to load modules via "require" instead of "use"

   <b>Picky</b> <b>Picky</b> <b>Picky</b>
       The "Badger::Debug" module allow you to be more selective about what you want to use.  This section
       described the individual debugging methods and the DEBUG and $DEBUG flags that can be used to control
       debugging.

       In the simplest case, you can import the <b>debug()</b> method into your own module for generating debugging
       messages.

           package Your::Module;
           use Badger::Debug 'debug';

           sub some_method {
               my $self = shift;
               $self-&gt;debug("Hello from some_method()");
           }

       In most cases you'll want to be able to turn debugging messages on and off.  You could do something like
       this:

           # initialise $DEBUG if it's not already set
           our $DEBUG = 0 unless defined $DEBUG;

           sub some_method {
               my $self = shift;
               $self-&gt;debug("Hello from some_method()") if $DEBUG;
           }

       If you use the "unless defined $DEBUG" idiom shown in the example shown above then it will also allow you
       to set the $DEBUG flag <u>before</u> your module is loaded. This is particularly useful if the module is auto-
       loaded on demand by another module or your own code.

           # set $DEBUG flag for your module
           $Your::Module::DEBUG = 1;

           # later...
           require Your::Module;       # debugging is enabled

       You can also achieve the same effect at compile time using the "Badger::Debug" modules export option.

           use Badger::Debug
               modules =&gt; 'Your::Module';  # sets $Your::Module::DEBUG = 1
           use Your::Module;               # debugging is enabled

       The advantage of using the $DEBUG package variable is that you can change the value at any point to turn
       debugging on or off. For example, if you've got a section of code that requires debugging enabled to
       track down a particular bug then you can write something like this:

           sub gnarly_method {
               my $self = shift;

               local $DEBUG = 1;
               $self-&gt;debug("Trying to track down the cause bug 666");

               # the rest of your code...
               $self-&gt;some_method;
           }

       Making the change to $DEBUG "local" means that it'll only stay set to 1 until the end of the
       "gnarly_method()". It's a good idea to add a debugging message any time you make temporary changes like
       this. The message generated will contain the file and line number so that you can easily find it later
       when the bug has been squashed and either comment it out (for next time) or remove it.

       The "Badger::Debug" module has a $DEBUG export hook which will define the the $DEBUG variable for you.
       The value you provide will be used as the default for $DEBUG if it isn't already defined.

           package Your::Module;

           use Badger::Debug
               'debug',
               '$DEBUG' =&gt; 0;

           sub some_method {
               my $self = shift;
               $self-&gt;debug("Hello from some_method()") if $DEBUG;
           }

       The <b>debugging()</b> method can also be imported from "Badger::Debug".  This provides a simple way to set the
       $DEBUG variable.

           Your::Module-&gt;<a href="../man1/debugging.1.html">debugging</a>(1);     # debugging on
           Your::Module-&gt;<a href="../man0/debugging.0.html">debugging</a>(0);     # debugging off

       The downside to using a package variable is that it slows your code down every time you check the $DEBUG
       flag.  In all but the most extreme cases, this should be of no concern to you whatsoever.  Write your
       code in the way that is most convenient for you, not the machine.

       <b>WARNING:</b> Do not even begin to consider entertaining the merest thought of optimising your code to make it
       run faster until your company is on the verge of financial ruin due to your poorly performing application
       and your boss has told you (with confirmation in writing, countersigned by at least 3 members of the
       board of directors) that you will be fired first thing tomorrow morning unless you make the code run
       faster <u>RIGHT</u> <u>NOW</u>.

       Another approach is to define a constant DEBUG value.

           package Your::Module;

           use Badger::Debug 'debug';
           use constant DEBUG =&gt; 0;

           sub some_method {
               my $self = shift;
               $self-&gt;debug("Hello from some_method()") if DEBUG;
           }

       This is an all-or-nothing approach.  Debugging is on or off and there's nothing you can do about it
       except for changing the constant definition in the source code and running the program again.  The
       benefit of this approach is that DEBUG is defined as a compile time constant.  When DEBUG is set to 0,
       Perl will effectively remove the entire debugging line at compile time because it's based on a premise
       ("if DEBUG") that is known to be false.  The end result is that there's no runtime performance penalty
       whatsoever.

       "Badger::Debug" also provides the DEBUG hook if this is the kind of thing you want.

           package Your::Module;

           use Badger::Debug
               'debug',
               'DEBUG' =&gt; 0;

           sub some_method {
               my $self = shift;
               $self-&gt;debug("Hello from some_method()") if DEBUG;
           }

       What makes this extra-special is that you're only specifying the <u>default</u> value for the "DEBUG" constant.
       If the $DEBUG package variable is defined when the module is loaded then that value will be used instead.
       So although it's not possible to enable or disable debugging for different parts of a module, you can
       still enable debugging for the whole module by setting the $DEBUG package variable before loading it.

           # set $DEBUG flag for your module
           $Your::Module::DEBUG = 1;

           # later...
           require Your::Module;       # debugging is enabled

       Here's a reminder of the other way to achieve the same thing at compile time using the "Badger::Debug"
       modules export option.

           use Badger::Debug
               modules =&gt; 'Your::Module';  # sets $Your::Module::DEBUG = 1
           use Your::Module;               # debugging is enabled

       You can combine the use of both $DEBUG and DEBUG in your code, for a two-level approach to debugging. The
       DEBUG tests will always be resolved at compile time so they're suitable for low-level debugging that
       either has a performance impact or is rarely required. The $DEBUG tests will be resolved at run time, so
       they can be enabled or disabled at any time or place.

           sub some_method {
               my $self = shift;
               $self-&gt;debug("Hello from some_method()") if DEBUG;
               $self-&gt;debug("Goodbye from some_method()") if $DEBUG;
           }

</pre><h4><b>IMPORT</b> <b>OPTIONS</b></h4><pre>
       All of the debugging methods can be imported selectively into your module. For example:

           use Badger::Debug 'debug debugging debug_caller';

       The following import options are also provided.

   <b>default</b>
       Used to set the default debugging value and import various debugging methods and flags.

           use Badger::Debug
               default =&gt; 0;           # debugging off by default

       It imports the <b>debug()</b> and <b>debugging()</b> methods along with the $DEBUG package variable and DEBUG constant.

       See "The Whole Caboodle" for further discussion on using it.

   <b>$DEBUG</b>
       Used to define a $DEBUG variable in your module.  A default value should be specified which will be used
       to set the $DEBUG value if it isn't already defined.

           use Badger::Debug
               '$DEBUG' =&gt; 0;           # debugging off by default

           print $DEBUG;                # 0

   <b>DEBUG</b>
       Used to define a "DEBUG" constant in your module.  If the $DEBUG package variable is defined then the
       "DEBUG" constant will be set to whatever value it contains.  Otherwise it will be set to the default
       value you provide.

           use Badger::Debug
               'DEBUG' =&gt; 0;            # debugging off by default

           print DEBUG;                 # 0

   <b>modules</b>
       This option can be used to set the $DEBUG value true in one or more packages.  This ensures that any
       debugging will be enabled in those modules.

           use Badger::Debug
               modules =&gt; 'My::Module::One My::Module::Two';

           use My::Module::One;        # debugging enabled in both modules
           use My::Module::Two;

       Modules that haven't yet been loaded will have both compile time (DEBUG) and run time ($DEBUG) debugging
       enabled.  Modules that have already been loaded will only have run time debugging enabled.

   <b>dumps</b>
       This option can be used to construct a specialised <b>dump()</b> method for your module.  The method is used to
       display nested data in serialised text form for debugging purposes.  The default <b>dump()</b> method for an
       object will display all items stored within the object.  The "dumps" import option can be used to limit
       the dump to only display the fields specified.

           package Your::Module;
           use Badger::Debug dumps =&gt; 'foo bar baz';
           # ...more code...

           package main;
           my $object = Your::Module-&gt;new;
           print $object-&gt;dump;            # dumps foo, bar and baz

   <b>colour</b> <b>/</b> <b>color</b>
       Either of these (depending on your spelling preference) can be used to enable colourful (or colorful)
       debugging.

           use Badger::Debug 'colour';

       Debugging messages will then appear in colour (on a terminal supporting ANSI escape sequences).  See the
       Badger::Test module for an example of this in use.

   <b>:debug</b>
       Imports all of the <b>debug()</b>, <b>debugging()</b>, <b>debug_up()</b>, <b>debug_caller()</b>, debug_callers and <b>debug_args()</b>
       methods.

   <b>:dump</b>
       Imports all of the <b>dump()</b>, <b>dump_ref()</b>, <b>dump_hash()</b>, <b>dump_list()</b>, <b>dump_text()</b>, <b>dump_data()</b> and
       <b>dump_data_inline()</b> methods.

</pre><h4><b>DEBUGGING</b> <b>METHODS</b></h4><pre>
   <b>debug($msg1,</b> <b>$msg2,</b> <b>...)</b>
       This method can be used to generate debugging messages.

           $object-&gt;debug("Hello ", "World\n");

       It prints all argument to STDERR with a prefix indicating the class name, file name and line number from
       where the "debug()" method was called.

           [Badger::Example line 42] Hello World

       At some point in the future this will be extended to allow you to tie in debug hooks, e.g. to forward to
       a logging module.

   <b>debugf($format,</b> <b>$arg1,</b> <b>$arg2,</b> <b>...)</b>
       This method provides a "printf()"-like wrapper around <b>debug()</b>.

           $object-&gt;debugf('%s is %s', e =&gt; 2.718);    # e is 2.718

   <b>debug_up($n,</b> <b>$msg1,</b> <b>$msg2,</b> <b>...)</b>
       The <b>debug()</b> method generates a message showing the file and line number from where the method was called.
       The "debug_up()" method can be used to report the error from somewhere higher up the call stack. This is
       typically used when you create your own debugging methods, as shown in the following example.

           sub parse {
               my $self = shift;

               while (my ($foo, $bar) = $self-&gt;get_foo_bar) {
                   $self-&gt;trace($foo, $bar);               # report line here
                   # do something
               }
           }

           sub trace {
               my ($self, $foo, $bar) = @_;
               $self-&gt;debug_up(2, "foo: $foo  bar: $bar"); # not here
           }

       The "trace()" method calls the <b>debug_up()</b> method telling it to look <u>two</u> levels up in the caller stack
       instead of the usual <u>one</u> (thus "debug_up(1,...)" has the same effect as "debug(...)").  So instead of
       reporting the line number in the "trace()" subroutine (which would be the case if we called "debug(...)"
       or "debug_up(1,...)"), it will correctly reporting the line number of the call to "trace()" in the
       "parse()" method.

   <b>debug_at($info,</b> <b>$message)</b>
       This method is a wrapper around <b>debug()</b> that allows you to specify a different location to be added to
       the message generated.

           $at-&gt;debug_at(
               {
                   where =&gt; 'At the edge of time',
                   line  =&gt; 420
               },
               'Flying sideways'
           );

       This generates the following debug message:

           [At the edge of time line 420] Flying sideways

       Far out, man!

       You can change the $FORMAT package variable to define a different message structure.  As well as the pre-
       defined placeholders (see the $FORMAT documentation) you can also define your own custom placeholders
       like "&lt;server&gt;" in the following example.

           $Badger::Debug::FORMAT = '&lt;server&gt;: &lt;msg&gt; at line &lt;line&gt; of &lt;file&gt;';

       You must then provide values for the additional placeholder in the $info hash array when you call the
       <b>debug_at()</b> method.

           $at-&gt;debug_at(
               { server =&gt; 'Alpha' },
               'Normality is resumed'
           );

       You can also specify a custom format in the $info hash array.

           $at-&gt;debug_at(
               { format =&gt; '&lt;msg&gt; at line &lt;line&gt; of &lt;file&gt;' },
               'Normality is resumed'
           );

   <b>debug_caller()</b>
       Prints debugging information about the current caller.

           sub wibble {
               my $self = shift;
               $self-&gt;debug_caller;
           }

   <b>debug_callers()</b>
       Prints debugging information about the complete call stack.

           sub wibble {
               my $self = shift;
               $self-&gt;debug_callers;
           }

   <b>debug_args()</b>
       Prints debugging information about the arguments passed.

           sub wibble {
               my $self = shift;
               $self-&gt;debug_args(@_);
           }

   <b>debugging($flag)</b>
       This method of convenience can be used to set the $DEBUG variable for a module.  It can be called as a
       class or object method.

           Your::Module-&gt;<a href="../man1/debugging.1.html">debugging</a>(1);     # turn debugging on
           Your::Module-&gt;<a href="../man0/debugging.0.html">debugging</a>(0);     # turn debugging off

   <b>debug_modules(@modules)</b>
       This method can be used to set the $DEBUG true in one or more modules.  Modules can be specified as a
       list of package names, a reference to a list, or a whitespace delimited string.

           Badger::Debug-&gt;debug_modules('Your::Module::One Your::Module::Two');

       The method is also accessible via the modules import option.

</pre><h4><b>DATA</b> <b>INSPECTION</b> <b>METHODS</b></h4><pre>
       These methods of convenience can be used to inspect data structures.  The emphasis is on brevity for the
       sake of debugging rather than full blown inspection.  Use Data::Dumper or on of the other fine modules
       available from CPAN if you want something more thorough.

       The methods below are recursive, so <b>dump_list()</b>, on finding a hash reference in the list will call
       <b>dump_hash()</b> and so on.  However, this recursion is deliberately limited to no more than $MAX_DEPTH levels
       deep (3 by default).  Remember, the emphasis here is on being able to see enough of the data you're
       dealing with, neatly formatted for debugging purposes, rather than being overwhelmed with the big
       picture.

       If any of the methods encounter an object then they will call its <b>dump()</b> method if it has one.  Otherwise
       they fall back on <b>dump_ref()</b> to expose the internals of the underlying data type.  You can create your
       own custom <b>dump()</b> method for you objects or use the dumps import option to have a custom <b>dump()</b> method
       defined for you.

   <b>dump()</b>
       Debugging method which returns a text representation of the object internals.

           print STDERR $object-&gt;dump();

       You can define your own "dump()" for an object and this will be called whenever your object is dumped.
       The dumps import option can be used to generate a custom "dump()" method.

   <b>dump_ref($ref)</b>
       Does The Right Thing to call the appropriate dump method for a reference of some kind.

   <b>dump_hash(\%hash)</b>
       Debugging method which returns a text representation of the hash array passed by reference as the first
       argument.

           print STDERR $object-&gt;dump_hash(\%hash);

   <b>dump_list(\@list)</b>
       Debugging method which returns a text representation of the array passed by reference as the first
       argument.

           print STDERR $object-&gt;dump_list(\@list);

   <b>dump_text($text)</b>
       Debugging method which returns a truncated and sanitised representation of the text string passed
       (directly or by reference) as the first argument.

           print STDERR $object-&gt;dump_text($text);

       The string will be truncated to $MAX_TEXT characters and any newlines will be converted to "\n"
       representations.

   <b>dump_data($item)</b>
       Debugging method which calls the appropriate dump method for the item passed as the first argument.  If
       it is an object with a <b>dump()</b> method then that will be called, otherwise it will fall back on <b>dump_ref()</b>,
       as it will for any other non-object references.  Non-references are passed to the <b>dump_text()</b> method.

           print STDERR $object-&gt;dump_data($item);

   <b>dump_data_inline($item)</b>
       Wrapper around <b>dump_data()</b> which strips any newlines from the generated output, suitable for a more
       compact debugging output.

           print STDERR $object-&gt;dump_data_inline($item);

</pre><h4><b>MISCELLANEOUS</b> <b>METHODS</b></h4><pre>
   <b>enable_colour()</b>
       Enables colourful debugging and error messages.

           Badger::Debug-&gt;enable_colour;

</pre><h4><b>PACKAGE</b> <b>VARIABLES</b></h4><pre>
   <b>$FORMAT</b>
       The <b>debug()</b> method uses the message format in the $FORMAT package variable to generate debugging
       messages.  The default value is:

           [&lt;where&gt; line &lt;line&gt;] &lt;msg&gt;

       The "&lt;where&lt;gt"&gt;, "&lt;line&gt;" and "&lt;msg&gt;" markers denote the positions where the class name, line number and
       debugging message are inserted.  You can embed any of the following placeholders into the message format:

           msg     The debugging message
           file    The name of the file where the debug() method was called from
           line    The line number that it was called from
           pkg     The package that it was called from
           class   The class name of the object that the method was called against
           where   A summary of the package and class
           date    The current date
           time    The current time

       If the "class" is the same as the "pkg" then "where" will contain the same value. If they are different
       then "where" will be set equivalent to "&lt;pkg&gt; (&lt;class&gt;)". This is the case when the <b>debug()</b> method is
       called from a base class method ("pkg" will be the base class name from where the call was made) against
       a subclass object ("class" will be the subclass name).

       See also the <b>debug_at()</b> method which allows you to specify a custom format and/or additional placeholder
       values.

   <b>$MAX_DEPTH</b>
       The maximum depth that the data inspection methods will recurse to.

   <b>$MAX_TEXT</b>
       The maximum length of text that will be returned by <b>dump_text()</b>.

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley &lt;<a href="http://wardley.org/">http://wardley.org/</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 1996-2009 Andy Wardley.  All Rights Reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2023-08-28                                 <u>Badger::<a href="../man3pm/Debug.3pm.html">Debug</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>