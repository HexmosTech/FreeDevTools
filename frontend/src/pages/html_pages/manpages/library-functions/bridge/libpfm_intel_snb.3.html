<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libpfm_intel_snb - support for Intel Sandy Bridge core PMU</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpfm4-dev">libpfm4-dev_4.13.0+git99-gc5587f9-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libpfm_intel_snb - support for Intel Sandy Bridge core PMU

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;perfmon/pfmlib.h&gt;</b>

       <b>PMU</b> <b>name:</b> <b>snb</b>
       <b>PMU</b> <b>desc:</b> <b>Intel</b> <b>Sandy</b> <b>Bridge</b>
       <b>PMU</b> <b>name:</b> <b>snb_ep</b>
       <b>PMU</b> <b>desc:</b> <b>Intel</b> <b>Sandy</b> <b>Bridge</b> <b>EP</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  library supports the Intel Sandy Bridge core PMU. It should be noted that this PMU model only covers
       each core's PMU and not the socket level PMU. For that refer to the Sandy Bridge uncore PMU support.

       On Sandy Bridge, the number of generic counters depends on the Hyperthreading (HT) mode.  When HT is  on,
       then  only  4  generic counters are available. When HT is off, then 8 generic counters are available. The
       <b>pfm_get_pmu_info()</b> function returns the maximum number of generic counters in <b>num_cntrs.</b>

</pre><h4><b>MODIFIERS</b></h4><pre>
       The following modifiers are supported on Intel Sandy Bridge processors:

       <b>u</b>      Measure at user level which includes privilege levels 1, 2, 3. This corresponds to <b>PFM_PLM3</b>.  This
              is a boolean modifier.

       <b>k</b>      Measure at kernel level which includes privilege level 0. This corresponds to <b>PFM_PLM0</b>.  This is a
              boolean modifier.

       <b>i</b>      Invert the meaning of the event. The counter will now count cycles  in  which  the  event  is  <b>not</b>
              occurring. This is a boolean modifier

       <b>e</b>      Enable edge detection, i.e., count only when there is a state transition from no occurrence of the
              event  to at least one occurrence. This modifier must be combined with a counter mask modifier (m)
              with a value greater or equal to one.  This is a boolean modifier.

       <b>c</b>      Set the counter mask value. The mask acts as a threshold. The counter will  count  the  number  of
              cycles  in which the number of occurrences of the event is greater or equal to the threshold. This
              is an integer modifier with values in the range [0:255].

       <b>t</b>      Measure on both threads at the same time assuming hyper-threading is enabled. This  is  a  boolean
              modifier.

       <b>ldlat</b>  Pass  a  latency  threshold  to  the  MEM_TRANS_RETIRED:LATENCY_ABOVE_THRESHOLD event.  This is an
              integer attribute that must be in the range [1:65535]. It is required for this event.   Note  that
              the event must be used with precise sampling (PEBS).

</pre><h4><b>OFFCORE_RESPONSE</b> <b>events</b></h4><pre>
       Intel  Sandy  Bridge  provides  two  offcore_response  events,  like  Intel  Westmere.   They  are called
       OFFCORE_RESPONSE_0 and OFFCORE_RESPONSE_1.

       Those events need special treatment in the performance monitoring infrastructure because each event  uses
       an  extra  register  to store some settings. Thus, in case multiple offcore_response events are monitored
       simultaneously, the kernel needs to manage the sharing of that extra register.

       The offcore_response events are exposed as a normal events by the library. The extra settings are exposed
       as regular umasks. The library takes care of encoding the  events  according  to  the  underlying  kernel
       interface.

       On  Intel  Sandy  Bridge,  the umasks are divided into three categories: request, supplier and snoop. The
       user must provide at least  one  umask  for  each  category.  The  categories  are  shown  in  the  umask
       descriptions.

       There  is  also the special response umask called <b>ANY_RESPONSE</b>. When this umask is used then it overrides
       any supplier and snoop umasks. In other words, users can specify either <b>ANY_RESPONSE</b> <b>OR</b> any  combinations
       of supplier + snoops.

       In case no supplier or snoop is specified, the library defaults to using <b>ANY_RESPONSE</b>.

       For instance, the following are valid event selections:

       <b>OFFCORE_RESPONSE_0:DMND_DATA_RD:ANY_RESPONSE</b>

       <b>OFFCORE_RESPONSE_0:ANY_REQUEST</b>

       <b>OFFCORE_RESPONSE_0:ANY_RFO:LLC_HITM:SNOOP_ANY</b>

       But the following are illegal:

       <b>OFFCORE_RESPONSE_0:ANY_RFO:LLC_HITM:ANY_RESPONSE</b>

       <b>OFFCORE_RESPONSE_0:ANY_RFO:LLC_HITM:SNOOP_ANY:ANY_RESPONSE</b>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/libpfm_snb_unc.3.html">libpfm_snb_unc</a>(3)

</pre><h4><b>AUTHORS</b></h4><pre>
       Stephane Eranian &lt;<a href="mailto:eranian@gmail.com">eranian@gmail.com</a>&gt;

                                                  January, 2011                                        <u><a href="../man3/LIBPFM.3.html">LIBPFM</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>