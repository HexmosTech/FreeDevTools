<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gsvj1 - gsvj1: step in gesvj</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gsvj1 - gsvj1: step in gesvj

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>cgsvj1</b> (jobv, m, n, n1, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork,
           info)
           <b>CGSVJ1</b> pre-processor for the routine cgesvj, applies Jacobi rotations targeting only particular
           pivots.
       subroutine <b>dgsvj1</b> (jobv, m, n, n1, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork,
           info)
           <b>DGSVJ1</b> pre-processor for the routine dgesvj, applies Jacobi rotations targeting only particular
           pivots.
       subroutine <b>sgsvj1</b> (jobv, m, n, n1, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork,
           info)
           <b>SGSVJ1</b> pre-processor for the routine sgesvj, applies Jacobi rotations targeting only particular
           pivots.
       subroutine <b>zgsvj1</b> (jobv, m, n, n1, a, lda, d, sva, mv, v, ldv, eps, sfmin, tol, nsweep, work, lwork,
           info)
           <b>ZGSVJ1</b> pre-processor for the routine zgesvj, applies Jacobi rotations targeting only particular
           pivots.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>cgsvj1</b> <b>(character*1</b> <b>jobv,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>n1,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b>
       <b>integer</b> <b>lda,</b> <b>complex,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>d,</b> <b>real,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>sva,</b> <b>integer</b> <b>mv,</b> <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b>
       <b>)</b> <b>v,</b> <b>integer</b> <b>ldv,</b> <b>real</b> <b>eps,</b> <b>real</b> <b>sfmin,</b> <b>real</b> <b>tol,</b> <b>integer</b> <b>nsweep,</b> <b>complex,</b> <b>dimension(</b> <b>lwork</b> <b>)</b> <b>work,</b>
       <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>CGSVJ1</b> pre-processor for the routine cgesvj, applies Jacobi rotations targeting only particular pivots.

       <b>Purpose:</b>

            CGSVJ1 is called from CGESVJ as a pre-processor and that is its main
            purpose. It applies Jacobi rotations in the same way as CGESVJ does, but
            it targets only particular pivots and it does not check convergence
            (stopping criterion). Few tuning parameters (marked by [TP]) are
            available for the implementer.

            Further Details
            ~~~~~~~~~~~~~~~
            CGSVJ1 applies few sweeps of Jacobi rotations in the column space of
            the input M-by-N matrix A. The pivot pairs are taken from the (1,2)
            off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The
            block-entries (tiles) of the (1,2) off-diagonal block are marked by the
            [x]'s in the following scheme:

               | *  *  * [x] [x] [x]|
               | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.
               | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.
               |[x] [x] [x] *  *  * |
               |[x] [x] [x] *  *  * |
               |[x] [x] [x] *  *  * |

            In terms of the columns of A, the first N1 columns are rotated 'against'
            the remaining N-N1 columns, trying to increase the angle between the
            corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is
            tiled using quadratic tiles of side KBL. Here, KBL is a tuning parameter.
            The number of sweeps is given in NSWEEP and the orthogonality threshold
            is given in TOL.

       <b>Parameters</b>
           <u>JOBV</u>

                     JOBV is CHARACTER*1
                     Specifies whether the output from this procedure is used
                     to compute the matrix V:
                     = 'V': the product of the Jacobi rotations is accumulated
                            by postmultiplying the N-by-N array V.
                           (See the description of V.)
                     = 'A': the product of the Jacobi rotations is accumulated
                            by postmultiplying the MV-by-N array V.
                           (See the descriptions of MV and V.)
                     = 'N': the Jacobi rotations are not accumulated.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the input matrix A.
                     M &gt;= N &gt;= 0.

           <u>N1</u>

                     N1 is INTEGER
                     N1 specifies the 2 x 2 block partition, the first N1 columns are
                     rotated 'against' the remaining N-N1 columns of A.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, M-by-N matrix A, such that A*diag(D) represents
                     the input matrix.
                     On exit,
                     A_onexit * D_onexit represents the input matrix A*diag(D)
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of N1, D, TOL and NSWEEP.)

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is COMPLEX array, dimension (N)
                     The array D accumulates the scaling factors from the fast scaled
                     Jacobi rotations.
                     On entry, A*diag(D) represents the input matrix.
                     On exit, A_onexit*diag(D_onexit) represents the input matrix
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of N1, A, TOL and NSWEEP.)

           <u>SVA</u>

                     SVA is REAL array, dimension (N)
                     On entry, SVA contains the Euclidean norms of the columns of
                     the matrix A*diag(D).
                     On exit, SVA contains the Euclidean norms of the columns of
                     the matrix onexit*diag(D_onexit).

           <u>MV</u>

                     MV is INTEGER
                     If JOBV = 'A', then MV rows of V are post-multiplied by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'N',   then MV is not referenced.

           <u>V</u>

                     V is COMPLEX array, dimension (LDV,N)
                     If JOBV = 'V' then N rows of V are post-multiplied by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'A' then MV rows of V are post-multiplied by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'N',   then V is not referenced.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V,  LDV &gt;= 1.
                     If JOBV = 'V', LDV &gt;= N.
                     If JOBV = 'A', LDV &gt;= MV.

           <u>EPS</u>

                     EPS is REAL
                     EPS = SLAMCH('Epsilon')

           <u>SFMIN</u>

                     SFMIN is REAL
                     SFMIN = SLAMCH('Safe Minimum')

           <u>TOL</u>

                     TOL is REAL
                     TOL is the threshold for Jacobi rotations. For a pair
                     A(:,p), A(:,q) of pivot columns, the Jacobi rotation is
                     applied only if ABS(COS(angle(A(:,p),A(:,q)))) &gt; TOL.

           <u>NSWEEP</u>

                     NSWEEP is INTEGER
                     NSWEEP is the number of sweeps of Jacobi rotations to be
                     performed.

           <u>WORK</u>

                    WORK is COMPLEX array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                     LWORK is the dimension of WORK. LWORK &gt;= M.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, then the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributor:</b>
           Zlatko Drmac (Zagreb, Croatia)

   <b>subroutine</b> <b>dgsvj1</b> <b>(character*1</b> <b>jobv,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>n1,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b>
       <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>d,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>sva,</b> <b>integer</b> <b>mv,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>v,</b> <b>integer</b> <b>ldv,</b> <b>double</b> <b>precision</b> <b>eps,</b> <b>double</b> <b>precision</b> <b>sfmin,</b>
       <b>double</b> <b>precision</b> <b>tol,</b> <b>integer</b> <b>nsweep,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lwork</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b>
       <b>info)</b>
       <b>DGSVJ1</b> pre-processor for the routine dgesvj, applies Jacobi rotations targeting only particular pivots.

       <b>Purpose:</b>

            DGSVJ1 is called from DGESVJ as a pre-processor and that is its main
            purpose. It applies Jacobi rotations in the same way as DGESVJ does, but
            it targets only particular pivots and it does not check convergence
            (stopping criterion). Few tuning parameters (marked by [TP]) are
            available for the implementer.

            Further Details
            ~~~~~~~~~~~~~~~
            DGSVJ1 applies few sweeps of Jacobi rotations in the column space of
            the input M-by-N matrix A. The pivot pairs are taken from the (1,2)
            off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The
            block-entries (tiles) of the (1,2) off-diagonal block are marked by the
            [x]'s in the following scheme:

               | *  *  * [x] [x] [x]|
               | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.
               | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.
               |[x] [x] [x] *  *  * |
               |[x] [x] [x] *  *  * |
               |[x] [x] [x] *  *  * |

            In terms of the columns of A, the first N1 columns are rotated 'against'
            the remaining N-N1 columns, trying to increase the angle between the
            corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is
            tiled using quadratic tiles of side KBL. Here, KBL is a tuning parameter.
            The number of sweeps is given in NSWEEP and the orthogonality threshold
            is given in TOL.

       <b>Parameters</b>
           <u>JOBV</u>

                     JOBV is CHARACTER*1
                     Specifies whether the output from this procedure is used
                     to compute the matrix V:
                     = 'V': the product of the Jacobi rotations is accumulated
                            by postmultiplying the N-by-N array V.
                           (See the description of V.)
                     = 'A': the product of the Jacobi rotations is accumulated
                            by postmultiplying the MV-by-N array V.
                           (See the descriptions of MV and V.)
                     = 'N': the Jacobi rotations are not accumulated.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the input matrix A.
                     M &gt;= N &gt;= 0.

           <u>N1</u>

                     N1 is INTEGER
                     N1 specifies the 2 x 2 block partition, the first N1 columns are
                     rotated 'against' the remaining N-N1 columns of A.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, M-by-N matrix A, such that A*diag(D) represents
                     the input matrix.
                     On exit,
                     A_onexit * D_onexit represents the input matrix A*diag(D)
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of N1, D, TOL and NSWEEP.)

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     The array D accumulates the scaling factors from the fast scaled
                     Jacobi rotations.
                     On entry, A*diag(D) represents the input matrix.
                     On exit, A_onexit*diag(D_onexit) represents the input matrix
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of N1, A, TOL and NSWEEP.)

           <u>SVA</u>

                     SVA is DOUBLE PRECISION array, dimension (N)
                     On entry, SVA contains the Euclidean norms of the columns of
                     the matrix A*diag(D).
                     On exit, SVA contains the Euclidean norms of the columns of
                     the matrix onexit*diag(D_onexit).

           <u>MV</u>

                     MV is INTEGER
                     If JOBV = 'A', then MV rows of V are post-multiplied by a
                                    sequence of Jacobi rotations.
                     If JOBV = 'N', then MV is not referenced.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension (LDV,N)
                     If JOBV = 'V', then N rows of V are post-multiplied by a
                                    sequence of Jacobi rotations.
                     If JOBV = 'A', then MV rows of V are post-multiplied by a
                                    sequence of Jacobi rotations.
                     If JOBV = 'N', then V is not referenced.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V,  LDV &gt;= 1.
                     If JOBV = 'V', LDV &gt;= N.
                     If JOBV = 'A', LDV &gt;= MV.

           <u>EPS</u>

                     EPS is DOUBLE PRECISION
                     EPS = DLAMCH('Epsilon')

           <u>SFMIN</u>

                     SFMIN is DOUBLE PRECISION
                     SFMIN = DLAMCH('Safe Minimum')

           <u>TOL</u>

                     TOL is DOUBLE PRECISION
                     TOL is the threshold for Jacobi rotations. For a pair
                     A(:,p), A(:,q) of pivot columns, the Jacobi rotation is
                     applied only if DABS(COS(angle(A(:,p),A(:,q)))) &gt; TOL.

           <u>NSWEEP</u>

                     NSWEEP is INTEGER
                     NSWEEP is the number of sweeps of Jacobi rotations to be
                     performed.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                     LWORK is the dimension of WORK. LWORK &gt;= M.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, then the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Zlatko Drmac (Zagreb, Croatia) and Kresimir Veselic (Hagen, Germany)

   <b>subroutine</b> <b>sgsvj1</b> <b>(character*1</b> <b>jobv,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>n1,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b>
       <b>lda,</b> <b>real,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>d,</b> <b>real,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>sva,</b> <b>integer</b> <b>mv,</b> <b>real,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>v,</b> <b>integer</b>
       <b>ldv,</b> <b>real</b> <b>eps,</b> <b>real</b> <b>sfmin,</b> <b>real</b> <b>tol,</b> <b>integer</b> <b>nsweep,</b> <b>real,</b> <b>dimension(</b> <b>lwork</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b>
       <b>integer</b> <b>info)</b>
       <b>SGSVJ1</b> pre-processor for the routine sgesvj, applies Jacobi rotations targeting only particular pivots.

       <b>Purpose:</b>

            SGSVJ1 is called from SGESVJ as a pre-processor and that is its main
            purpose. It applies Jacobi rotations in the same way as SGESVJ does, but
            it targets only particular pivots and it does not check convergence
            (stopping criterion). Few tuning parameters (marked by [TP]) are
            available for the implementer.

            Further Details
            ~~~~~~~~~~~~~~~
            SGSVJ1 applies few sweeps of Jacobi rotations in the column space of
            the input M-by-N matrix A. The pivot pairs are taken from the (1,2)
            off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The
            block-entries (tiles) of the (1,2) off-diagonal block are marked by the
            [x]'s in the following scheme:

               | *  *  * [x] [x] [x]|
               | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.
               | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.
               |[x] [x] [x] *  *  * |
               |[x] [x] [x] *  *  * |
               |[x] [x] [x] *  *  * |

            In terms of the columns of A, the first N1 columns are rotated 'against'
            the remaining N-N1 columns, trying to increase the angle between the
            corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is
            tiled using quadratic tiles of side KBL. Here, KBL is a tuning parameter.
            The number of sweeps is given in NSWEEP and the orthogonality threshold
            is given in TOL.

       <b>Parameters</b>
           <u>JOBV</u>

                     JOBV is CHARACTER*1
                     Specifies whether the output from this procedure is used
                     to compute the matrix V:
                     = 'V': the product of the Jacobi rotations is accumulated
                            by postmultiplying the N-by-N array V.
                           (See the description of V.)
                     = 'A': the product of the Jacobi rotations is accumulated
                            by postmultiplying the MV-by-N array V.
                           (See the descriptions of MV and V.)
                     = 'N': the Jacobi rotations are not accumulated.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the input matrix A.
                     M &gt;= N &gt;= 0.

           <u>N1</u>

                     N1 is INTEGER
                     N1 specifies the 2 x 2 block partition, the first N1 columns are
                     rotated 'against' the remaining N-N1 columns of A.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     On entry, M-by-N matrix A, such that A*diag(D) represents
                     the input matrix.
                     On exit,
                     A_onexit * D_onexit represents the input matrix A*diag(D)
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of N1, D, TOL and NSWEEP.)

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is REAL array, dimension (N)
                     The array D accumulates the scaling factors from the fast scaled
                     Jacobi rotations.
                     On entry, A*diag(D) represents the input matrix.
                     On exit, A_onexit*diag(D_onexit) represents the input matrix
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of N1, A, TOL and NSWEEP.)

           <u>SVA</u>

                     SVA is REAL array, dimension (N)
                     On entry, SVA contains the Euclidean norms of the columns of
                     the matrix A*diag(D).
                     On exit, SVA contains the Euclidean norms of the columns of
                     the matrix onexit*diag(D_onexit).

           <u>MV</u>

                     MV is INTEGER
                     If JOBV = 'A', then MV rows of V are post-multiplied by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'N',   then MV is not referenced.

           <u>V</u>

                     V is REAL array, dimension (LDV,N)
                     If JOBV = 'V' then N rows of V are post-multiplied by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'A' then MV rows of V are post-multiplied by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'N',   then V is not referenced.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V,  LDV &gt;= 1.
                     If JOBV = 'V', LDV &gt;= N.
                     If JOBV = 'A', LDV &gt;= MV.

           <u>EPS</u>

                     EPS is REAL
                     EPS = SLAMCH('Epsilon')

           <u>SFMIN</u>

                     SFMIN is REAL
                     SFMIN = SLAMCH('Safe Minimum')

           <u>TOL</u>

                     TOL is REAL
                     TOL is the threshold for Jacobi rotations. For a pair
                     A(:,p), A(:,q) of pivot columns, the Jacobi rotation is
                     applied only if ABS(COS(angle(A(:,p),A(:,q)))) &gt; TOL.

           <u>NSWEEP</u>

                     NSWEEP is INTEGER
                     NSWEEP is the number of sweeps of Jacobi rotations to be
                     performed.

           <u>WORK</u>

                     WORK is REAL array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                     LWORK is the dimension of WORK. LWORK &gt;= M.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, then the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Zlatko Drmac (Zagreb, Croatia) and Kresimir Veselic (Hagen, Germany)

   <b>subroutine</b> <b>zgsvj1</b> <b>(character*1</b> <b>jobv,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>n1,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b>
       <b>integer</b> <b>lda,</b> <b>complex*16,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>d,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>sva,</b> <b>integer</b> <b>mv,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>v,</b> <b>integer</b> <b>ldv,</b> <b>double</b> <b>precision</b> <b>eps,</b> <b>double</b> <b>precision</b> <b>sfmin,</b> <b>double</b> <b>precision</b> <b>tol,</b>
       <b>integer</b> <b>nsweep,</b> <b>complex*16,</b> <b>dimension(</b> <b>lwork</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>ZGSVJ1</b> pre-processor for the routine zgesvj, applies Jacobi rotations targeting only particular pivots.

       <b>Purpose:</b>

            ZGSVJ1 is called from ZGESVJ as a pre-processor and that is its main
            purpose. It applies Jacobi rotations in the same way as ZGESVJ does, but
            it targets only particular pivots and it does not check convergence
            (stopping criterion). Few tuning parameters (marked by [TP]) are
            available for the implementer.

            Further Details
            ~~~~~~~~~~~~~~~
            ZGSVJ1 applies few sweeps of Jacobi rotations in the column space of
            the input M-by-N matrix A. The pivot pairs are taken from the (1,2)
            off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The
            block-entries (tiles) of the (1,2) off-diagonal block are marked by the
            [x]'s in the following scheme:

               | *  *  * [x] [x] [x]|
               | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.
               | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.
               |[x] [x] [x] *  *  * |
               |[x] [x] [x] *  *  * |
               |[x] [x] [x] *  *  * |

            In terms of the columns of A, the first N1 columns are rotated 'against'
            the remaining N-N1 columns, trying to increase the angle between the
            corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is
            tiled using quadratic tiles of side KBL. Here, KBL is a tuning parameter.
            The number of sweeps is given in NSWEEP and the orthogonality threshold
            is given in TOL.

       <b>Parameters</b>
           <u>JOBV</u>

                     JOBV is CHARACTER*1
                     Specifies whether the output from this procedure is used
                     to compute the matrix V:
                     = 'V': the product of the Jacobi rotations is accumulated
                            by postmultiplying the N-by-N array V.
                           (See the description of V.)
                     = 'A': the product of the Jacobi rotations is accumulated
                            by postmultiplying the MV-by-N array V.
                           (See the descriptions of MV and V.)
                     = 'N': the Jacobi rotations are not accumulated.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the input matrix A.
                     M &gt;= N &gt;= 0.

           <u>N1</u>

                     N1 is INTEGER
                     N1 specifies the 2 x 2 block partition, the first N1 columns are
                     rotated 'against' the remaining N-N1 columns of A.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, M-by-N matrix A, such that A*diag(D) represents
                     the input matrix.
                     On exit,
                     A_onexit * D_onexit represents the input matrix A*diag(D)
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of N1, D, TOL and NSWEEP.)

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is COMPLEX*16 array, dimension (N)
                     The array D accumulates the scaling factors from the fast scaled
                     Jacobi rotations.
                     On entry, A*diag(D) represents the input matrix.
                     On exit, A_onexit*diag(D_onexit) represents the input matrix
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of N1, A, TOL and NSWEEP.)

           <u>SVA</u>

                     SVA is DOUBLE PRECISION array, dimension (N)
                     On entry, SVA contains the Euclidean norms of the columns of
                     the matrix A*diag(D).
                     On exit, SVA contains the Euclidean norms of the columns of
                     the matrix onexit*diag(D_onexit).

           <u>MV</u>

                     MV is INTEGER
                     If JOBV = 'A', then MV rows of V are post-multiplied by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'N',   then MV is not referenced.

           <u>V</u>

                     V is COMPLEX*16 array, dimension (LDV,N)
                     If JOBV = 'V' then N rows of V are post-multiplied by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'A' then MV rows of V are post-multiplied by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'N',   then V is not referenced.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V,  LDV &gt;= 1.
                     If JOBV = 'V', LDV &gt;= N.
                     If JOBV = 'A', LDV &gt;= MV.

           <u>EPS</u>

                     EPS is DOUBLE PRECISION
                     EPS = DLAMCH('Epsilon')

           <u>SFMIN</u>

                     SFMIN is DOUBLE PRECISION
                     SFMIN = DLAMCH('Safe Minimum')

           <u>TOL</u>

                     TOL is DOUBLE PRECISION
                     TOL is the threshold for Jacobi rotations. For a pair
                     A(:,p), A(:,q) of pivot columns, the Jacobi rotation is
                     applied only if ABS(COS(angle(A(:,p),A(:,q)))) &gt; TOL.

           <u>NSWEEP</u>

                     NSWEEP is INTEGER
                     NSWEEP is the number of sweeps of Jacobi rotations to be
                     performed.

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                     LWORK is the dimension of WORK. LWORK &gt;= M.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, then the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributor:</b>
           Zlatko Drmac (Zagreb, Croatia)

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                              Sun Jul 20 2025 01:40:05                                    <u><a href="../man3/gsvj1.3.html">gsvj1</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>