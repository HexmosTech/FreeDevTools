<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libtty - a library for handling vt100-like pseudo-terminals</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtty-dev">libtty-dev_0.19-2.1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libtty - a library for handling vt100-like pseudo-terminals

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tty.h&gt;</b>

       Link with <u>-ltty</u>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Functions:</b>
       <b>tty</b>    <b>tty_init(int</b> <u>sx</u><b>,</b> <b>int</b> <u>sy</u><b>,</b> <b>int</b> <u>resizable</u><b>);</b>
           Creates  a  new  vt100  terminal, of size <u>sx</u>×<u>sy</u>.  If you want user input to be allowed to change that
           size, set <u>resizable</u> to non-zero.

       <b>int</b>    <b>tty_resize(tty</b> <u>vt</u><b>,</b> <b>int</b> <u>nsx</u><b>,</b> <b>int</b> <u>nsy</u><b>);</b>
           Resizes the <u>vt</u> to <u>nsx</u>×<u>nsy</u>.  This works even on terminals marked as non-resizable since that  prevents
           only user input from resizing, not you.

       <b>void</b>   <b>tty_reset(tty</b> <u>vt</u><b>);</b>
           Clears the screen and attributes.

       <b>void</b>   <b>tty_free(tty</b> <u>vt</u><b>);</b>
           Deallocates the <u>vt</u> and all its internal structures.

       <b>void</b>   <b>tty_write(tty</b> <u>vt</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>buf</u><b>,</b> <b>int</b> <u>len</u><b>);</b>
           Writes <u>len</u> bytes into the terminal, parsing them as vt100 codes.

       <b>void</b>   <b>tty_printf(tty</b> <u>vt</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>fmt</u><b>,</b> <u>...</u><b>);</b>
           Does a <b>printf</b> into the terminal.

       <b>tty</b>    <b>tty_copy(tty</b> <u>vt</u><b>);</b>
           Allocates  a  new  vt100 terminal, making it an exact copy of an existing one, including its internal
           state.  Attached event callbacks are not copied.

       <b>uint32_t</b> <b>tty_color_convert(uint32_t</b> <u>c</u><b>,</b> <b>uint32_t</b> <u>to</u><b>);</b>
           Converts   color   values   between   modes:   VT100_COLOR_OFF,   VT100_COLOR_16,    VT100_COLOR_256,
           VT100_COLOR_RGB.

   <b>Inside</b> <b>the</b> <b>terminal</b>
       You'll most likely be interested in the following fields of the structure:

       tty {
       int <u>sx</u>,<u>sy</u>;             // screen size
       int <u>cx</u>,<u>cy</u>;             // cursor position
       attrchar *<u>scr</u>;         // screen buffer
       int <u>attr</u>;              // current attribute
       char *<u>title</u>;           // window title

       <u>scr</u> is an array of character/attribute pairs, more exactly, each element is a struct "{ ucs ch; int attr;
       }".   The array is a flat one of <u>vt</u><b>-&gt;</b><u>sx</u>*<u>vt</u><b>-&gt;</b><u>sy</u> elements, arranged row by row.  A screen coordinate <u>x</u>,<u>y</u> is
       stored at <u>x</u>+<u>y</u>*<u>vt</u><b>-&gt;</b><u>sy</u>.

       For other fields, please RTFS the header itself: <b>tty.h</b>

   <b>TTY</b> <b>event</b> <b>callbacks</b>
       Well, you have written some data to the terminal.  Now you probably want to put it somewhere.  What  now?
       The tty structure has a number of <u>event</u> <u>hooks</u> that you can attach your functions to.

       These hooks are callbacks inside the <b>tty</b> structure that you can set.  The callback fields are:

       <b>void</b> <b>*l_data;</b>
           it's a place to put your private data in

       <b>void</b> <b>(*l_char)(tty</b> <u>vt</u><b>,</b> <b>int</b> <u>x</u><b>,</b> <b>int</b> <u>y</u><b>,</b> <b>ucs</b> <u>ch</u><b>,</b> <b>int</b> <u>attr</u><b>,</b> <b>int</b> <u>width</u><b>);</b>
           after  a  character  has  been  written  to the screen; the cursor advances by <u>width</u> which might be 1
           (regular) or 2 (CJK "fullwidth")

       <b>void</b> <b>(*l_cursor)(tty</b> <u>vt</u><b>,</b> <b>int</b> <u>x</u><b>,</b> <b>int</b> <u>y</u><b>);</b>
           after the cursor has moved

       <b>void</b> <b>(*l_clear)(tty</b> <u>vt</u><b>,</b> <b>int</b> <u>x</u><b>,</b> <b>int</b> <u>y</u><b>,</b> <b>int</b> <u>len</u><b>);</b>
           after a chunk of screen has been cleared

           If an endpoint spills outside of the current line, it will go all the way to an end of screen.

           If the cursor moves, you'll get a separate <u>l_cursor</u>, although it  is  already  in  place  during  the
           <u>l_clear</u> call.

       <b>void</b> <b>(*l_scroll)(tty</b> <u>vt</u><b>,</b> <b>int</b> <u>nl</u><b>);</b>
           after the region s1&lt;=y&lt;s2 is scrolled nl lines (nl&lt;0 -&gt; backwards, nl&gt;0 -&gt; forward).

           There's no separare <u>l_cursor</u> event, <u>cx</u> and <u>cy</u> are already updated.

       <b>void</b> <b>(*l_flag)(tty</b> <u>vt</u><b>,</b> <b>int</b> <u>f</u><b>,</b> <b>int</b> <u>v</u><b>);</b>
           when a flag changes to <u>v</u>.  Flags that are likely to be of interest to you are:

           •   <b>VT100_FLAG_CURSOR</b>

               cursor visibility

           •   <b>VT100_FLAG_KPAD</b>

               application keypad mode (more detailed codes for keypad arrow keys)

       <b>void</b> <b>(*l_osc)(tty</b> <u>vt</u><b>,</b> <b>int</b> <u>cmd</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>str</u><b>);</b>
           when  a string command has been issued; most commands alter a color palette, but the most interesting
           one is <b>0</b>: "set window title"

       <b>void</b> <b>(*l_resize)(tty</b> <u>vt</u><b>,</b> <b>int</b> <u>sx</u><b>,</b> <b>int</b> <u>sy</u><b>);</b>
           after the terminal has been resized

       <b>void</b> <b>(*l_flush)(tty</b> <u>vt</u><b>);</b>
           when a write chunk ends

       <b>void</b> <b>(*l_bell)(tty</b> <u>vt</u><b>);</b>
           upon a beep

       <b>void</b> <b>(*l_free)(tty</b> <u>vt</u><b>);</b>
           before the terminal is destroyed

   <b>Vt-on-vt</b> <b>redirection</b>
       For the case when you want the output go to a real terminal, there are:

       <b>void</b>   <b>vtvt_attach(tty</b> <u>vt</u><b>,</b> <b>FILE</b> <b>*</b><u>f</u><b>,</b> <b>int</b> <u>dump</u><b>);</b>
           Attaches the FILE stream <u>f</u> to terminal <u>vt</u>.  Usually, <u>f</u> will be <b>stdout</b>.  Whenever the contents  of  <u>vt</u>
           changes,  appropriate  data  will be written to the stream as well.  If <u>dump</u> is non-zero, the current
           state will be drawn, otherwise, only subsequent changes will be shown.

           The redirection will last until the terminal is destroyed by <b>tty_free()</b>.

       <b>void</b>   <b>vtvt_resize(tty</b> <u>vt</u><b>,</b> <b>int</b> <u>sx</u><b>,</b> <b>int</b> <u>sy</u><b>);</b>
           Tells libtty that the <b>real</b> terminal has been resized  (for  resizing  the  virtual  one,  please  use
           <b>tty_resize()</b>).

       <b>void</b>   <b>vtvt_dump(tty</b> <u>vt</u><b>);</b>
           Forces a full-screen redraw of the current contents of <u>vt</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/libttyrec.3.html">libttyrec</a></b>(3)

0.19                                               2024-04-01                                          <u><a href="../man3/LIBTTY.3.html">LIBTTY</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>