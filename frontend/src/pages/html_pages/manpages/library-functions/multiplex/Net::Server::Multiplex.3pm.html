<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::Server::Multiplex - Multiplex several connections within one process</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-server-perl">libnet-server-perl_2.014-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::Server::Multiplex - Multiplex several connections within one process

</pre><h4><b>SYNOPSIS</b></h4><pre>
           package MyPlexer;

           use base qw(Net::Server::Multiplex);

           sub mux_input {
               #...code...
           }

           __PACKAGE__-&gt;run();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This personality is designed to handle multiple connections all within one process.  It should only be
       used with protocols that are guaranteed to be able to respond quickly on a packet by packet basis.  If
       determining a response could take a while or an unknown period of time, all other connections established
       will block until the response completes.  If this condition might ever occur, this personality should
       probably not be used.

       This takes some nice features of Net::Server (like the server listen socket setup, configuration file
       processing, safe signal handling, convenient inet style STDIN/STDOUT handling, logging features,
       deamonization and pid tracking, and restartability -SIGHUP) and some nice features of IO::Multiplex
       (automatic buffered IO and per-file-handle objects) and combines them for an easy-to-use interface.

       See examples/samplechat.pl distributed with Net::Server for a simple chat server that uses several of
       these features.

</pre><h4><b>PROCESS</b> <b>FLOW</b></h4><pre>
       The process flow is written in an open, easy to override, easy to hook, fashion.  The basic flow is shown
       below.

           $self-&gt;configure_hook;

           $self-&gt;configure(@_);

           $self-&gt;post_configure;

           $self-&gt;post_configure_hook;

           $self-&gt;pre_bind;

           $self-&gt;bind;

           if (Restarting server) {
               $self-&gt;restart_open_hook();
           }

           $self-&gt;post_bind_hook;

           $self-&gt;post_bind;

           $self-&gt;pre_loop_hook;

           $self-&gt;loop; # This basically just runs IO::Multiplex::loop
           # For routines inside a $self-&gt;loop
           # See CLIENT PROCESSING below

           $self-&gt;pre_server_close_hook;

           $self-&gt;post_child_cleanup_hook;

           $self-&gt;server_close;

           if (Restarting server) {
               $self-&gt;restart_close_hook();
               $self-&gt;hup_server;
               # Redo process again starting with configure_hook
         }

       The server then exits.

</pre><h4><b>CLIENT</b> <b>PROCESSING</b></h4><pre>
       The following represents the client processing program flow:

           $self-&gt;{server}-&gt;{client} = Net::Server::Proto::TCP-&gt;accept();  # NOTE: Multiplexed with mux_input() below

           if (check_for_dequeue seconds have passed) {
               $self-&gt;run_dequeue();
           }

           $self-&gt;get_client_info;

           $self-&gt;post_accept_hook; # Net::Server style

           if ($self-&gt;allow_deny
               &amp;&amp; $self-&gt;allow_deny_hook) {

             # (Net::Server style $self-&gt;process_request() is never called.)

             # A unique client specific object is created
             # for all mux_* methods from this point on.
             $self = __PACKAGE__-&gt;new($self, client);

             $self-&gt;mux_connection; # IO::Multiplex style

             for (every packet received) {
               $self-&gt;mux_input;  # NOTE: Multiplexed with accept() above
             }

           } else {

             $self-&gt;request_denied_hook;

             # Notice that if either allow_deny or allow_deny_hook fails, then
             # new(), mux_connection(), and mux_input() will never be called.
             # mux_eof() and mux_close() will still be called, but using a
             # common listen socket callback object instead of a unique client
             # specific object.

           }

           $self-&gt;mux_eof;

           $self-&gt;post_process_request_hook;

           $self-&gt;mux_close;

       This process then loops multiplexing between the <b>accept()</b> for the next connection and <b>mux_input()</b> when
       input arrives to avoid blocking either one.

</pre><h4><b>HOOKS</b></h4><pre>
       The *_hook methods mentioned above are meant to be overridden with your own subroutines if you desire to
       provide additional functionality.

       The <b>loop()</b> method of Net::Server has been overridden to run the loop routine of IO::Multiplex instead.
       The Net::Server methods may access the IO::Multiplex object at "$self-&gt;{mux}" if desired.  The
       IO::Multiplex methods may access the Net::Server object at "$self-&gt;{net_server}" if desired.

       The <b>process_request()</b> method is never used with this personality.

       The other Net::Server hooks and methods should work the same.

       "$self-&gt;run_dequeue()"
           This  hook  only  gets  called  in conjunction with the check_for_dequeue setting.  It will run every
           check_for_dequeue seconds.  Since no forking is done, this hook should run fast in order  to  prevent
           blocking the rest of the processing.

</pre><h4><b>TIMEOUTS</b></h4><pre>
   <b>set_timeout</b>
       To  utilize  the  optional  timeout  feature of IO::Multiplex, you need to specify a timeout by using the
       set_timeout method.

       $self-&gt;{net_server}-&gt;{mux}-&gt;set_timeout($fh, $seconds_from_now);

       $fh may be either a client socket or a listen socket file descriptor within the  mux.   $seconds_from_now
       may  be fractional to achieve more precise timeouts.  This is used in conjunction with mux_timeout, which
       you should define yourself.

   <b>mux_timeout</b>
       The main <b>loop()</b> routine will call $obj-&gt;mux_timeout($mux, $fh) when the timeout specified in  set_timeout
       is  reached  where  $fh  is  the same as the one specified in <b>set_timeout()</b> and $obj is its corresponding
       object (either the unique client specific object or the main listen callback object) and $mux is the main
       IO::Multiplex object itself.

</pre><h4><b>CALLBACK</b> <b>INTERFACE</b></h4><pre>
       Callback objects should support the following interface.  You  do  not  have  to  provide  all  of  these
       methods, just provide the ones you are interested in.  These are just like the IO::Multiplex hooks except
       that  STDOUT  is  tied to the corresponding client socket handle for your convenience and to more closely
       emulate the Net::Server model.  However, unlike some other Net::Server personalities,  you  should  never
       read directly from STDIN yourself.  You should define one or more of the following methods:

   <b>mux_connection</b> <b>($mux,$fh)</b>
       (OPTIONAL)  Run  once  when  the  client  first  connects  if  the  allow_deny  passes.   Note  that  the
       "$self-&gt;{net_server}-&gt;{server}" property hash may be modified by future connections through  Net::Server.
       Any  values  within  it  that this object may need to use later should be copied within its own object at
       this point.

         Example:
         $self-&gt;{peerport} = $self-&gt;{net_server}-&gt;{server}-&gt;{peerport};

   <b>mux_input</b> <b>($mux,$fh,\$data)</b>
       (REQUIRED) Run each time a packet is read.  It should consume  $data  starting  at  the  left  and  leave
       unconsumed data in the scalar for future calls to mux_input.

   <b>mux_eof</b> <b>($mux,$fh,\$data)</b>
       (OPTIONAL)  Run  once  when  the  client  is  done  writing.   It  should consume the rest of $data since
       <b>mux_input()</b> will never be run again.

   <b>mux_close</b> <b>($mux,$fh)</b>
       (OPTIONAL) Run after the entire client socket has been closed.  No more attempts should be made  to  read
       or write to the client or to STDOUT.

   <b>mux_timeout</b> <b>($mux,$fh)</b>
       (OPTIONAL) Run once when the set_timeout setting expires as explained above.

</pre><h4><b>BUGS</b></h4><pre>
       This is only known to work with TCP servers.

       If  you  need  to  use  the  IO::Multiplex  style set_timeout / mux_timeout interface, you cannot use the
       Net::Server style check_for_dequeue / run_dequeue interface.  It will not work if  the  check_for_dequeue
       option  is  specified.   The  run_dequeue  method  is  just  a compatibility interface to comply with the
       Net::Server::Fork style run_dequeue but is implemented in terms of the  IO::Multiplex  style  set_timeout
       and mux_timeout methods.

</pre><h4><b>AUTHOR</b></h4><pre>
       Rob Brown &lt;<a href="mailto:bbb@cpan.org">bbb@cpan.org</a>&gt;

</pre><h4><b>MAINTAINER</b></h4><pre>
       Paul Seamons &lt;<a href="mailto:paul@seamons.com">paul@seamons.com</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
         This package may be distributed under the terms of either the
         GNU General Public License
            or the
         Perl Artistic License

         All rights reserved.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Net::Server by Paul Seamons &lt;<a href="mailto:paul@seamons.com">paul@seamons.com</a>&gt;,

       IO::Multiplex by Bruce Keeler &lt;<a href="mailto:bruce@gridpoint.com">bruce@gridpoint.com</a>&gt;.

perl v5.36.0                                       2023-06-11                        <u>Net::Server::<a href="../man3pm/Multiplex.3pm.html">Multiplex</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>