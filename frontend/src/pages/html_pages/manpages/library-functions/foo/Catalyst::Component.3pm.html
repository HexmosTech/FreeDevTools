<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catalyst::Component - Catalyst Component Base Class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcatalyst-perl">libcatalyst-perl_5.90132-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Catalyst::Component - Catalyst Component Base Class

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # lib/MyApp/Model/Something.pm
           package MyApp::Model::Something;

           use base 'Catalyst::Component';

           __PACKAGE__-&gt;config( foo =&gt; 'bar' );

           has foo =&gt; (
               is =&gt; 'ro',
           );

           sub test {
               my $self = shift;
               return $self-&gt;foo;
           }

           sub forward_to_me {
               my ( $self, $c ) = @_;
               $c-&gt;response-&gt;output( $self-&gt;foo );
           }

           1;

           # Methods can be a request step
           $c-&gt;forward(qw/MyApp::Model::Something forward_to_me/);

           # Or just methods
           print $c-&gt;comp('MyApp::Model::Something')-&gt;test;

           print $c-&gt;comp('MyApp::Model::Something')-&gt;foo;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is the universal base class for Catalyst components (Model/View/Controller).

       It provides you with a generic <b>new()</b> for component construction through Catalyst's component loader with
       <b>config()</b> support and a <b>process()</b> method placeholder.

       <b>Note</b> that calling "$self-&gt;config" inside a component is strongly not recommended - the correctly merged
       config should have already been passed to the constructor and stored in attributes - accessing the config
       accessor directly from an instance is likely to get the wrong values (as it only holds the class wide
       config, not things loaded from the config file!)

</pre><h4><b>METHODS</b></h4><pre>
   <b>new($app,</b> <b>$arguments)</b>
       Called by COMPONENT to instantiate the component; should return an object to be stored in the
       application's component hash.

   <b>COMPONENT</b>
       "my $component_instance = $component-&gt;COMPONENT($app, $arguments);"

       If this method is present (as it is on all Catalyst::Component subclasses), it is called by Catalyst
       during setup_components with the application class as $app and any config entry on the application for
       this component (for example, in the case of MyApp::Controller::Foo this would be
       "MyApp-&gt;config('Controller::Foo' =&gt; \%conf").

       The arguments are expected to be a hashref and are merged with the "__PACKAGE__-&gt;config" hashref before
       calling "-&gt;new" to instantiate the component.

       You can override it in your components to do custom construction, using something like this:

         sub COMPONENT {
             my ($class, $app, $args) = @_;
             $args = $class-&gt;merge_config_hashes($class-&gt;config, $args);
             return $class-&gt;new($app, $args);
         }

       <b>NOTE:</b> Generally when Catalyst starts, it initializes all the components and passes the hashref present in
       any configuration information to the COMPONENT method.  For example

           MyApp-&gt;config(
             'Model::Foo' =&gt; {
               bar =&gt; 'baz',
             });

       You would expect COMPONENT to be called like this -&gt;COMPONENT( 'MyApp', +{ bar=&gt;'baz'});

       This would happen ONCE during setup.

   <b>$c-&gt;config</b>
   <b>$c-&gt;config($hashref)</b>
   <b>$c-&gt;config($key,</b> <b>$value,</b> <b>...)</b>
       Accessor for this component's config hash. Config values can be set as key value pair, or you can specify
       a hashref. In either case the keys will be merged with any existing config settings. Each component in a
       Catalyst application has its own config hash.

       The component's config hash is merged with any config entry on the application for this component and
       passed to new() (as mentioned above at "COMPONENT"). The recommended practice to access the merged config
       is to use a Moose attribute for each config entry on the receiving component.

   <b>$c-&gt;process()</b>
       This is the default method called on a Catalyst component in the dispatcher.  For instance, Views
       implement this action to render the response body when you forward to them. The default is an abstract
       method.

   <b>$c-&gt;merge_config_hashes(</b> <b>$hashref,</b> <b>$hashref</b> <b>)</b>
       Merges two hashes together recursively, giving right-hand precedence.  Alias for the method in
       Catalyst::Utils.

   <b>$c-&gt;expand_modules(</b> <b>$setup_component_config</b> <b>)</b>
       Return a list of extra components that this component has created. By default, it just looks for a list
       of inner packages of this component

</pre><h4><b>OPTIONAL</b> <b>METHODS</b></h4><pre>
   <b>ACCEPT_CONTEXT($c,</b> <b>@args)</b>
       Catalyst components are normally initialized during server startup, either as a Class or a Instance.
       However, some components require information about the current request. To do so, they can implement an
       ACCEPT_CONTEXT method.

       If this method is present, it is called during $c-&gt;comp/controller/model/view with the current $c and any
       additional args (e.g. $c-&gt;model('Foo', qw/bar baz/) would cause your MyApp::Model::Foo instance's
       ACCEPT_CONTEXT to be called with ($c, 'bar', 'baz')) and the return value of this method is returned to
       the calling code in the application rather than the component itself.

       <b>NOTE:</b> All classes that are Catalyst::Components will have a COMPONENT method, but classes that are
       intended to be factories or generators will have ACCEPT_CONTEXT.  If you have initialization arguments
       (such as from configuration) that you wish to expose to the ACCEPT_CONTEXT you should proxy them in the
       factory instance.  For example:

           MyApp::Model::FooFactory;

           use Moose;
           extends 'Catalyst::Model';

           has type =&gt; (is=&gt;'ro', required=&gt;1);

           sub ACCEPT_CONTEXT {
             my ($self, $c, @args) = @_;
             return bless { args=&gt;\@args }, $self-&gt;type;
           }

           MyApp::Model::Foo-&gt;meta-&gt;make_immutable;
           MyApp::Model::Foo-&gt;config( type =&gt; 'Type1' );

       And in a controller:

           my $type = $c-&gt;model('FooFactory', 1,2,3,4): # $type-&gt;isa('Type1')

       <b>NOTE:</b> If you define a ACCEPT_CONTEXT method it MUST check to see if the second argument is blessed (is a
       context) or not (is an application class name) and it MUST return something valid for the case when the
       scope is application.  This is required because a component maybe be called from the application scope
       even if it requires a context and you must prevent errors from being issued if this happens.  Remember
       not all components that ACCEPT_CONTEXT actually need or use context information (and there is a school of
       thought that suggestions doing so is a design error anyway...)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Catalyst, Catalyst::Model, Catalyst::View, Catalyst::Controller.

</pre><h4><b>AUTHORS</b></h4><pre>
       Catalyst Contributors, see Catalyst.pm

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This library is free software. You can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2024-11-15                           <u>Catalyst::<a href="../man3pm/Component.3pm.html">Component</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>