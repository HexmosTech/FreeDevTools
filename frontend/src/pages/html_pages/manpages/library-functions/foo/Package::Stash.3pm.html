<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Package::Stash - Routines for manipulating stashes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpackage-stash-perl">libpackage-stash-perl_0.40-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Package::Stash - Routines for manipulating stashes

</pre><h4><b>VERSION</b></h4><pre>
       version 0.40

</pre><h4><b>SYNOPSIS</b></h4><pre>
         my $stash = Package::Stash-&gt;new('Foo');
         $stash-&gt;add_symbol('%foo', {bar =&gt; 1});
         # $Foo::foo{bar} == 1
         $stash-&gt;has_symbol('$foo') # false
         my $namespace = $stash-&gt;namespace;
         *{ $namespace-&gt;{foo} }{HASH} # {bar =&gt; 1}

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Manipulating stashes (Perl's symbol tables) is occasionally necessary, but incredibly messy, and easy to
       get wrong. This module hides all of that behind a simple API.

       NOTE: Most methods in this class require a variable specification that includes a sigil. If this sigil is
       absent, it is assumed to represent the IO slot.

       Due to limitations in the typeglob API available to perl code, and to typeglob manipulation in perl being
       quite slow, this module provides two implementations - one in pure perl, and one using XS. The XS
       implementation is to be preferred for most usages; the pure perl one is provided for cases where XS
       modules are not a possibility. The current implementation in use can be set by setting
       $ENV{PACKAGE_STASH_IMPLEMENTATION} or $Package::Stash::IMPLEMENTATION before loading Package::Stash (with
       the environment variable taking precedence), otherwise, it will use the XS implementation if possible,
       falling back to the pure perl one.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b> <b>$package_name</b>
       Creates a new "Package::Stash" object, for the package given as the only argument.

   <b>name</b>
       Returns the name of the package that this object represents.

   <b>namespace</b>
       Returns the raw stash itself.

   <b>add_symbol</b> <b>$variable</b> <b>$value</b> <b>%opts</b>
       Adds a new package symbol, for the symbol given as $variable, and optionally gives it an initial value of
       $value. $variable should be the name of variable including the sigil, so

         Package::Stash-&gt;new('Foo')-&gt;add_symbol('%foo')

       will create %Foo::foo.

       Valid options (all optional) are "filename", "first_line_num", and "last_line_num".

       $opts{filename}, $opts{first_line_num}, and $opts{last_line_num} can be used to indicate where the symbol
       should be regarded as having been defined.  Currently these values are only used if the symbol is a
       subroutine ('"&amp;"' sigil) and only if "$^P &amp; 0x10" is true, in which case the special %DB::sub hash is
       updated to record the values of "filename", "first_line_num", and "last_line_num" for the subroutine. If
       these are not passed, their values are inferred (as much as possible) from "caller" information.

   <b>remove_glob</b> <b>$name</b>
       Removes all package variables with the given name, regardless of sigil.

   <b>has_symbol</b> <b>$variable</b>
       Returns whether or not the given package variable (including sigil) exists.

   <b>get_symbol</b> <b>$variable</b>
       Returns the value of the given package variable (including sigil).

   <b>get_or_add_symbol</b> <b>$variable</b>
       Like "get_symbol", except that it will return an empty hashref or arrayref if the variable doesn't exist.

   <b>remove_symbol</b> <b>$variable</b>
       Removes the package variable described by $variable (which includes the sigil); other variables with the
       same name but different sigils will be untouched.

   <b>list_all_symbols</b> <b>$type_filter</b>
       Returns a list of package variable names in the package, without sigils. If a "type_filter" is passed, it
       is used to select package variables of a given type, where valid types are the slots of a typeglob
       ('SCALAR', 'CODE', 'HASH', etc). Note that if the package contained any "BEGIN" blocks, perl will leave
       an empty typeglob in the "BEGIN" slot, so this will show up if no filter is used (and similarly for
       "INIT", "END", etc).

   <b>get_all_symbols</b> <b>$type_filter</b>
       Returns a hashref, keyed by the variable names in the package. If $type_filter is passed, the hash will
       contain every variable of that type in the package as values, otherwise, it will contain the typeglobs
       corresponding to the variable names (basically, a clone of the stash).

       This is especially useful for debuggers and profilers, which use %DB::sub to determine where the source
       code for a subroutine can be found.  See &lt;<a href="http://perldoc.perl.org/perldebguts.html">http://perldoc.perl.org/perldebguts.html</a>#Debugger-Internals&gt;
       for more information about %DB::sub.

</pre><h4><b>WORKING</b> <b>WITH</b> <b>VARIABLES</b></h4><pre>
       It is important to note, that when working with scalar variables, the default behavior is to <b>copy</b> values.

         my $stash = Package::Stash-&gt;new('Some::Namespace');
         my $variable = 1;
         # $Some::Namespace::name is a copy of $variable
         $stash-&gt;add_symbol('$name', $variable);
         $variable++
         # $Some::Namespace::name == 1 , $variable == 2

       This will likely confuse people who expect it to work the same as typeglob assignment, which simply
       creates new references to existing variables.

         my $variable = 1;
         {
             no strict 'refs';
             # assign $Package::Stash::name = $variable
             *{'Package::Stash::name'} = \$variable;
         }
         $variable++ # affects both names

       If this behaviour is desired when working with Package::Stash, simply pass Package::Stash a scalar ref:

         my $stash = Package::Stash-&gt;new('Some::Namespace');
         my $variable = 1;
         # $Some::Namespace::name is now $variable
         $stash-&gt;add_symbol('$name', \$variable);
         $variable++
         # $Some::Namespace::name == 2 , $variable == 2

       This will be what you want as well if you're ever working with Readonly variables:

         use Readonly;
         Readonly my $value, 'hello';

         $stash-&gt;add_symbol('$name', \$value); # reference
         print $Some::Namespace::name; # hello
         # Tries to modify the read-only 'hello' and dies.
         $Some::Namespace::name .= " world";

         $stash-&gt;add_symbol('$name', $value); # copy
         print $Some::Namespace::name; # hello
         # No problem, modifying a copy, not the original
         $Some::Namespace::name .= " world";

</pre><h4><b>BUGS</b> <b>/</b> <b>CAVEATS</b></h4><pre>
       •   Prior to perl 5.10, scalar slots are only considered to exist if they are defined

           This  is due to a shortcoming within perl itself. See "Making References" in perlref point 7 for more
           information.

       •   GLOB and FORMAT variables are not (yet) accessible through this module.

       •   Also, see the BUGS section for the specific backends (Package::Stash::XS and Package::Stash::PP)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   Class::MOP::Package

           This module is a factoring out of code that used to live here

</pre><h4><b>HISTORY</b></h4><pre>
       Based on code from Class::MOP::Package, by Stevan Little and the Moose Cabal.

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs        may        be        submitted        through        the        RT        bug         tracker
       &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Package-Stash&gt;    (or    <a href="mailto:bug-Package-Stash@rt.cpan.org">bug-Package-Stash@rt.cpan.org</a>
       &lt;<a href="mailto:bug-Package-Stash@rt.cpan.org">mailto:bug-Package-Stash@rt.cpan.org</a>&gt;).

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Stevan Little &lt;<a href="mailto:stevan.little@iinteractive.com">stevan.little@iinteractive.com</a>&gt;

       •   Jesse Luehrs &lt;<a href="mailto:doy@tozt.net">doy@tozt.net</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Carlos Lima &lt;carlos@multi&gt;

       •   Christian Walde &lt;<a href="mailto:walde.christian@googlemail.com">walde.christian@googlemail.com</a>&gt;

       •   Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

       •   Justin Hunter &lt;<a href="mailto:justin.d.hunter@gmail.com">justin.d.hunter@gmail.com</a>&gt;

       •   Kent Fredric &lt;<a href="mailto:kentfredric@gmail.com">kentfredric@gmail.com</a>&gt;

       •   Niko Tyni &lt;<a href="mailto:ntyni@debian.org">ntyni@debian.org</a>&gt;

       •   Renee &lt;<a href="mailto:reb@perl-services.de">reb@perl-services.de</a>&gt;

       •   Tim Bunce &lt;<a href="mailto:Tim.Bunce@pobox.com">Tim.Bunce@pobox.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2022 by Jesse Luehrs.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.34.0                                       2022-02-25                                <u>Package::<a href="../man3pm/Stash.3pm.html">Stash</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>