<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBD::CSV - DBI driver for CSV files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbd-csv-perl">libdbd-csv-perl_0.6200-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBD::CSV - DBI driver for CSV files

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use DBI;
           # See "Creating database handle" below
           $dbh = DBI-&gt;connect ("dbi:CSV:", undef, undef, {
               f_ext      =&gt; ".csv/r",
               RaiseError =&gt; 1,
               }) or die "Cannot connect: $DBI::errstr";

           # Simple statements
           $dbh-&gt;do ("CREATE TABLE foo (id INTEGER, name CHAR (10))");

           # Selecting
           my $sth = $dbh-&gt;prepare ("select * from foo");
           $sth-&gt;execute;
           $sth-&gt;bind_columns (\my ($id, $name));
           while ($sth-&gt;fetch) {
               print "id: $id, name: $name\n";
               }

           # Updates
           my $sth = $dbh-&gt;prepare ("UPDATE foo SET name = ? WHERE id = ?");
           $sth-&gt;execute ("DBI rocks!", 1);
           $sth-&gt;finish;

           $dbh-&gt;disconnect;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The DBD::CSV module is yet another driver for the DBI (Database independent interface for Perl). This one
       is based on the SQL "engine" SQL::Statement and the abstract DBI driver DBD::File and implements access
       to so-called CSV files (Comma Separated Values). Such files are often used for exporting MS Access and MS
       Excel data.

       See DBI for details on DBI, SQL::Statement for details on SQL::Statement and DBD::File for details on the
       base class DBD::File.

   <b>Prerequisites</b>
       The only system dependent feature that DBD::File uses, is the "flock ()" function. Thus the module should
       run (in theory) on any system with a working "flock ()", in particular on all Unix machines and on
       Windows NT. Under Windows 95 and MacOS the use of "flock ()" is disabled, thus the module should still be
       usable.

       Unlike other DBI drivers, you don't need an external SQL engine or a running server. All you need are the
       following Perl modules, available from any CPAN mirror, for example

         <a href="http://search.cpan.org/">http://search.cpan.org/</a>

       DBI A recent version of the DBI (Database independent interface for Perl).  See below why.

       DBD::File
           This  is  the base class for DBD::CSV, and it is part of the DBI distribution. As DBD::CSV requires a
           matching version of DBD::File which is (partly) developed by the same team that  maintains  DBD::CSV.
           See META.json or Makefile.PL for the minimum versions.

       SQL::Statement
           A simple SQL engine. This module defines all of the SQL syntax for DBD::CSV, new SQL support is added
           with each release so you should look for updates to SQL::Statement regularly.

           It  is  possible  to  run  "DBD::CSV"  without  this  module  if  you define the environment variable
           $DBI_SQL_NANO to 1. This will reduce the SQL support  a  lot  though.  See  DBI::SQL::Nano  for  more
           details. Note that the test suite does only test in this mode in the development environment.

       Text::CSV_XS
           This module is used to read and write rows in a CSV file.

   <b>Installation</b>
       Installing  this  module  (and  the  prerequisites  from  above) is quite simple.  The simplest way is to
       install the bundle:

           $ cpan Bundle::DBD::CSV

       Alternatively, you can name them all

           $ cpan Text::CSV_XS DBI DBD::CSV

       or even trust "cpan" to resolve all dependencies for you:

           $ cpan DBD::CSV

       If you cannot, for whatever reason, use cpan, fetch all modules from CPAN,  and  build  with  a  sequence
       like:

           gzip -d &lt; DBD-CSV-0.40.tgz | tar xf -

       (this  is  for  Unix  users,  Windows  users would prefer WinZip or something similar) and then enter the
       following:

           cd DBD-CSV-0.40
           perl Makefile.PL
           make test

       If any tests fail, let us know. Otherwise go on with

           make install UNINST=1

       Note that you almost definitely need root or administrator permissions.  If you don't have them, read the
       ExtUtils::MakeMaker man page for details on installing in your own directories. ExtUtils::MakeMaker.

   <b>Supported</b> <b>SQL</b> <b>Syntax</b>
       All SQL processing for  DBD::CSV  is  done  by  SQL::Statement.  See  SQL::Statement  for  more  specific
       information about its feature set.  Features include joins, aliases, built-in and user-defined functions,
       and more.  See SQL::Statement::Syntax for a description of the SQL syntax supported in DBD::CSV.

       Table-  and  column-names  are  case  insensitive  unless  quoted.  Column names will be sanitized unless
       "raw_header" is true.

</pre><h4><b>Using</b> <b>DBD::CSV</b> <b>with</b> <b>DBI</b></h4><pre>
       For most things, DBD-CSV operates the same as any DBI driver.  See DBI for detailed usage.

   <b>Creating</b> <b>a</b> <b>database</b> <b>handle</b> <b>(connect)</b>
       Creating a database handle usually implies connecting to a database server.  Thus this command reads

           use DBI;
           my $dbh = DBI-&gt;connect ("dbi:CSV:", "", "", {
               f_dir =&gt; "/home/user/folder",
               });

       The directory tells the driver where it should create or open tables (a.k.a.  files). It defaults to  the
       current directory, so the following are equivalent:

           $dbh = DBI-&gt;connect ("dbi:CSV:");
           $dbh = DBI-&gt;connect ("dbi:CSV:", undef, undef, { f_dir =&gt; "." });
           $dbh = DBI-&gt;connect ("dbi:CSV:f_dir=.");

       We were told, that VMS might - for whatever reason - require:

           $dbh = DBI-&gt;connect ("dbi:CSV:f_dir=");

       The preferred way of passing the arguments is by driver attributes:

           # specify most possible flags via driver flags
           $dbh = DBI-&gt;connect ("dbi:CSV:", undef, undef, {
               f_schema         =&gt; undef,
               f_dir            =&gt; "data",
               f_dir_search     =&gt; [],
               f_ext            =&gt; ".csv/r",
               f_lock           =&gt; 2,
               f_encoding       =&gt; "utf8",

               csv_eol          =&gt; "\r\n",
               csv_sep_char     =&gt; ",",
               csv_quote_char   =&gt; '"',
               csv_escape_char  =&gt; '"',
               csv_class        =&gt; "Text::CSV_XS",
               csv_null         =&gt; 1,
               csv_bom          =&gt; 0,
               csv_tables       =&gt; {
                   syspwd =&gt; {
                       sep_char    =&gt; ":",
                       quote_char  =&gt; undef,
                       escape_char =&gt; undef,
                       file        =&gt; "<a href="file:/etc/passwd">/etc/passwd</a>",
                       col_names   =&gt; [qw( login password
                                           uid gid realname
                                           directory shell )],
                       },
                   },

               RaiseError       =&gt; 1,
               PrintError       =&gt; 1,
               FetchHashKeyName =&gt; "NAME_lc",
               }) or die $DBI::errstr;

       but you may set these attributes in the DSN as well, separated by semicolons.  Pay attention to the semi-
       colon  for  "csv_sep_char" (as seen in many CSV exports from MS Excel) is being escaped in below example,
       as is would otherwise be seen as attribute separator:

           $dbh = DBI-&gt;connect (
               "dbi:CSV:f_dir=$ENV{HOME}/csvdb;f_ext=.csv;f_lock=2;" .
               "f_encoding=utf8;csv_eol=\n;csv_sep_char=\\;;" .
               "csv_quote_char=\";csv_escape_char=\\;csv_class=Text::CSV_XS;" .
               "csv_null=1") or die $DBI::errstr;

       Using attributes in the DSN is easier to use when the DSN is derived from an outside source  (environment
       variable,  database entry, or configure file), whereas specifying entries in the attribute hash is easier
       to read and to maintain.

       The default value for "csv_binary" is 1 (True).

       The default value for "csv_auto_diag" is &lt;1&gt;. Note that this might cause trouble on perl  versions  older
       than  5.8.9,  so  up  to  and including perl version 5.8.8 it might be required to use ";csv_auto_diag=0"
       inside the "DSN" or "csv_auto_diag =" 0&gt; inside the attributes.

   <b>Creating</b> <b>and</b> <b>dropping</b> <b>tables</b>
       You can create and drop tables with commands like the following:

           $dbh-&gt;do ("CREATE TABLE $table (id INTEGER, name CHAR (64))");
           $dbh-&gt;do ("DROP TABLE $table");

       Note that currently only the column names will be stored and no other data.  Thus all  other  information
       including  column type (INTEGER or CHAR (x), for example), column attributes (NOT NULL, PRIMARY KEY, ...)
       will silently be discarded. This may change in a later release.

       A drop just removes the file without any warning.

       See DBI for more details.

       Table names cannot be arbitrary, due to restrictions of the SQL syntax.  I recommend that table names are
       valid SQL identifiers: The first character is alphabetic, followed by an arbitrary number of alphanumeric
       characters. If you want to use other files, the file names must start with "/", "./" or  "../"  and  they
       must not contain white space.

   <b>Inserting,</b> <b>fetching</b> <b>and</b> <b>modifying</b> <b>data</b>
       The  following examples insert some data in a table and fetch it back: First, an example where the column
       data is concatenated in the SQL string:

           $dbh-&gt;do ("INSERT INTO $table VALUES (1, ".
                      $dbh-&gt;quote ("foobar") . ")");

       Note the use of the quote method for escaping the word "foobar". Any string must be escaped, even  if  it
       does not contain binary data.

       Next, an example using parameters:

           $dbh-&gt;do ("INSERT INTO $table VALUES (?, ?)", undef, 2,
                     "It's a string!");

       Note  that  you  don't need to quote column data passed as parameters.  This version is particularly well
       designed for loops. Whenever performance is an issue, I recommend using this method.

       You might wonder about the "undef". Don't wonder, just take it as it is. :-) It's an  attribute  argument
       that I have never used and will be passed to the prepare method as the second argument.

       To retrieve data, you can use the following:

           my $query = "SELECT * FROM $table WHERE id &gt; 1 ORDER BY id";
           my $sth   = $dbh-&gt;prepare ($query);
           $sth-&gt;execute ();
           while (my $row = $sth-&gt;fetchrow_hashref) {
               print "Found result row: id = ", $row-&gt;{id},
                     ", name = ", $row-&gt;{name};
               }
           $sth-&gt;finish ();

       Again, column binding works: The same example again.

           my $sth = $dbh-&gt;prepare (qq;
               SELECT * FROM $table WHERE id &gt; 1 ORDER BY id;
               ;);
           $sth-&gt;execute;
           my ($id, $name);
           $sth-&gt;bind_columns (undef, \$id, \$name);
           while ($sth-&gt;fetch) {
               print "Found result row: id = $id, name = $name\n";
               }
           $sth-&gt;finish;

       Of course you can even use input parameters. Here's the same example for the third time:

           my $sth = $dbh-&gt;prepare ("SELECT * FROM $table WHERE id = ?");
           $sth-&gt;bind_columns (undef, \$id, \$name);
           for (my $i = 1; $i &lt;= 2; $i++) {
               $sth-&gt;execute ($id);
               if ($sth-&gt;fetch) {
                   print "Found result row: id = $id, name = $name\n";
                   }
               $sth-&gt;finish;
               }

       See DBI for details on these methods. See SQL::Statement for details on the WHERE clause.

       Data rows are modified with the UPDATE statement:

           $dbh-&gt;do ("UPDATE $table SET id = 3 WHERE id = 1");

       Likewise you use the DELETE statement for removing rows:

           $dbh-&gt;do ("DELETE FROM $table WHERE id &gt; 1");

   <b>Error</b> <b>handling</b>
       In the above examples we have never cared about return codes. Of course, this is not recommended. Instead
       we should have written (for example):

           my $sth = $dbh-&gt;prepare ("SELECT * FROM $table WHERE id = ?") or
               die "prepare: " . $dbh-&gt;errstr ();
           $sth-&gt;bind_columns (undef, \$id, \$name) or
               die "bind_columns: " . $dbh-&gt;errstr ();
           for (my $i = 1; $i &lt;= 2; $i++) {
               $sth-&gt;execute ($id) or
                   die "execute: " . $dbh-&gt;errstr ();
               $sth-&gt;fetch and
                   print "Found result row: id = $id, name = $name\n";
               }
           $sth-&gt;finish ($id) or die "finish: " . $dbh-&gt;errstr ();

       Obviously this is tedious. Fortunately we have DBI's <u>RaiseError</u> attribute:

           $dbh-&gt;{RaiseError} = 1;
           $@ = "";
           eval {
               my $sth = $dbh-&gt;prepare ("SELECT * FROM $table WHERE id = ?");
               $sth-&gt;bind_columns (undef, \$id, \$name);
               for (my $i = 1; $i &lt;= 2; $i++) {
                   $sth-&gt;execute ($id);
                   $sth-&gt;fetch and
                       print "Found result row: id = $id, name = $name\n";
                   }
               $sth-&gt;finish ($id);
               };
           $@ and die "SQL database error: $@";

       This is not only shorter, it even works when using DBI methods within subroutines.

</pre><h4><b>DBI</b> <b>database</b> <b>handle</b> <b>attributes</b></h4><pre>
   <b>Metadata</b>
       The following attributes are handled by DBI itself and not by DBD::File, thus they all work as expected:

           Active
           ActiveKids
           CachedKids
           CompatMode             (Not used)
           InactiveDestroy
           Kids
           PrintError
           RaiseError
           Warn                   (Not used)

       The following DBI attributes are handled by DBD::File:

       AutoCommit
           Always on

       ChopBlanks
           Works

       NUM_OF_FIELDS
           Valid after "$sth-&gt;execute"

       NUM_OF_PARAMS
           Valid after "$sth-&gt;prepare"

       NAME
       NAME_lc
       NAME_uc
           Valid after "$sth-&gt;execute"; undef for Non-Select statements.

       NULLABLE
           Not  really  working.  Always  returns an array ref of one's, as DBD::CSV does not verify input data.
           Valid after "$sth-&gt;execute"; undef for non-Select statements.

       These attributes and methods are not supported:

           bind_param_inout
           CursorName
           LongReadLen
           LongTruncOk

</pre><h4><b>DBD-CSV</b> <b>specific</b> <b>database</b> <b>handle</b> <b>attributes</b></h4><pre>
       In addition to the DBI attributes, you can use the following dbh attributes:

   <b>DBD::File</b> <b>attributes</b>
       f_dir
           This attribute is used for setting the directory where CSV files are opened. Usually you  set  it  in
           the  dbh  and  it defaults to the current directory ("."). However, it may be overridden in statement
           handles.

       f_dir_search
           This attribute optionally defines a list of extra directories to search when opening existing tables.
           It should be an anonymous list or an array reference listing all folders where tables could be found.

               my $dbh = DBI-&gt;connect ("dbi:CSV:", "", "", {
                   f_dir        =&gt; "data",
                   f_dir_search =&gt; [ "ref/data", "ref/old" ],
                   f_ext        =&gt; ".csv/r",
                   }) or die $DBI::errstr;

       f_ext
           This attribute is used for setting the file extension.

       f_schema
           This attribute allows you to set the database schema name.  The  default  is  to  use  the  owner  of
           "f_dir". "undef" is allowed, but not in the DSN part.

               my $dbh = DBI-&gt;connect ("dbi:CSV:", "", "", {
                   f_schema =&gt; undef,
                   f_dir    =&gt; "data",
                   f_ext    =&gt; ".csv/r",
                   }) or die $DBI::errstr;

       f_encoding
           This  attribute  allows you to set the encoding of the data. With CSV, it is not possible to set (and
           remember) the encoding on a column basis, but DBD::File now allows the encoding  to  be  set  on  the
           underlying file. If this attribute is not set, or undef is passed, the file will be seen as binary.

       f_lock
           With  this  attribute  you can specify a locking mode to be used (if locking is supported at all) for
           opening tables. By default, tables are opened with a shared lock for reading, and with  an  exclusive
           lock for writing. The supported modes are:

           0 Force no locking at all.

           1 Only shared locks will be used.

           2 Only exclusive locks will be used.

       But see "KNOWN BUGS" in DBD::File.

   <b>DBD::CSV</b> <b>specific</b> <b>attributes</b>
       csv_class
           The  attribute  <u>csv_class</u>  controls  the  CSV  parsing  engine.  This defaults to "Text::CSV_XS", but
           "Text::CSV" can be used in some cases, too.  Please be aware that "Text::CSV" does not care about any
           edge case as "Text::CSV_XS" does and that  "Text::CSV"  is  probably  about  100  times  slower  than
           "Text::CSV_XS".

           In  order  to  use  the  specified class other than "Text::CSV_XS", it needs to be loaded before use.
           "DBD::CSV" does not "require"/"use" the specified class itself.

   <b>Text::CSV_XS</b> <b>specific</b> <b>attributes</b>
       csv_eol
       csv_sep_char
       csv_quote_char
       csv_escape_char
       csv_csv
           The attributes <u>csv_eol</u>, <u>csv_sep_char</u>, <u>csv_quote_char</u> and <u>csv_escape_char</u>  are  corresponding  to  the
           respective  attributes  of  the  <u>csv_class</u>  (usually  Text::CSV_CS) object. You may want to set these
           attributes if you have unusual CSV files like <u><a href="file:/etc/passwd">/etc/passwd</a></u> or MS Excel  generated  CSV  files  with  a
           semicolon as separator. Defaults are "\015\012"", ",", """ and """, respectively.

           The  <u>csv_eol</u>  attribute  defines the end-of-line pattern, which is better known as a record separator
           pattern since it separates records.  The default is windows-style end-of-lines "\015\012" for  output
           (writing)  and  unset  for  input (reading), so if on unix you may want to set this to newline ("\n")
           like this:

             $dbh-&gt;{csv_eol} = "\n";

           It is also possible to use multi-character patterns as record separators.  For example this file uses
           newlines as field separators (sep_char) and the pattern "\n__ENDREC__\n"  as  the  record  separators
           (eol):

             name
             city
             __ENDREC__
             joe
             seattle
             __ENDREC__
             sue
             portland
             __ENDREC__

           To handle this file, you'd do this:

             $dbh-&gt;{eol}      = "\n__ENDREC__\n" ,
             $dbh-&gt;{sep_char} = "\n"

           The  attributes  are  used  to  create  an  instance of the class <u>csv_class</u>, by default Text::CSV_XS.
           Alternatively you may pass an instance as <u>csv_csv</u>, the latter takes precedence. Note that the  <u>binary</u>
           attribute <u>must</u> be set to a true value in that case.

           Additionally you may overwrite these attributes on a per-table base in the <u>csv_tables</u> attribute.

       csv_null
           With  this  option set, all new statement handles will set "always_quote" and "blank_is_undef" in the
           CSV parser and writer, so it knows how to distinguish between the empty string and "undef" or "NULL".
           You cannot reset it with a false value. You can pass it to connect, or set it later:

             $dbh = DBI-&gt;connect ("dbi:CSV:", "", "", { csv_null =&gt; 1 });

             $dbh-&gt;{csv_null} = 1;

       csv_bom
           With this option set, the CSV parser will try to detect BOM (Byte Order Mark)  in  the  header  line.
           This requires Text::CSV_XS version 1.22 or higher.

             $dbh = DBI-&gt;connect ("dbi:CSV:", "", "", { csv_bom =&gt; 1 });

             $dbh-&gt;{csv_bom} = 1;

       csv_tables
           This hash ref is used for storing table dependent metadata. For any table it contains an element with
           the table name as key and another hash ref with the following attributes:

           o   All  valid  attributes  to  the  CSV  parsing module. Any of them can optionally be prefixed with
               "csv_".

           o   All attributes valid to DBD::File

           If you pass it "f_file" or its alias "file", "f_ext" has no  effect,  but  "f_dir"  and  "f_encoding"
           still have.

             csv_tables =&gt; {
                 syspwd =&gt; {                   # Table name
                     csv_sep_char =&gt; ":",      # Text::CSV_XS
                     quote_char   =&gt; undef,    # Text::CSV_XS
                     escape_char  =&gt; undef,    # Text::CSV_XS
                     f_dir        =&gt; "<a href="file:/etc">/etc</a>",   # DBD::File
                     f_file       =&gt; "passwd", # DBD::File
                     col_names    =&gt;           # DBD::File
                       [qw( login password uid gid realname directory shell )],
                     },
                 },

       csv_*
           All  other  attributes  that  start  with  "csv_"  and  are  not  described  above  will be passed to
           "Text::CSV_XS" (without the "csv_" prefix). These extra options are only  likely  to  be  useful  for
           reading (select) handles. Examples:

             $dbh-&gt;{csv_allow_whitespace}    = 1;
             $dbh-&gt;{csv_allow_loose_quotes}  = 1;
             $dbh-&gt;{csv_allow_loose_escapes} = 1;

           See the "Text::CSV_XS" documentation for the full list and the documentation.

   <b>Driver</b> <b>specific</b> <b>attributes</b>
       f_file
           The name of the file used for the table; defaults to

               "$dbh-&gt;{f_dir}/$table"

       eol
       sep_char
       quote_char
       escape_char
       class
       csv These  correspond to the attributes <u>csv_eol</u>, <u>csv_sep_char</u>, <u>csv_quote_char</u>, <u>csv_escape_char</u>, <u>csv_class</u>
           and <u>csv_csv</u>.  The difference is that they work on a per-table basis.

       col_names
       skip_first_row
           By default DBD::CSV assumes that column names are stored in  the  first  row  of  the  CSV  file  and
           sanitizes  them  (see  "raw_header"  below).  If this is not the case, you can supply an array ref of
           table names with the <u>col_names</u> attribute. In that case the attribute <u>skip_first_row</u> will  be  set  to
           FALSE.

           If  you  supply  an  empty array ref, the driver will read the first row for you, count the number of
           columns and create column names like "col0", "col1", ...

           Note that column names that match reserved SQL words will  cause  unwanted  and  sometimes  confusing
           errors. If your CSV has headers that match reserved words, you will require these two attributes.

           If "test.csv" looks like

            select,from
            1,2

           the select query would result in "select select, from from test;", which obviously is illegal SQL.

       raw_header
           Due to the SQL standard, field names cannot contain special characters like a dot (".") or a space ("
           ")  unless  the  column  names are quoted.  Following the approach of mdb_tools, all these tokens are
           translated to an underscore ("_") when reading the first line of the CSV file, so all field names are
           'sanitized'. If you do not want this to happen, set "raw_header" to a true value and the  entries  in
           the  first  line  of the CSV data will be used verbatim for column headers and field names.  DBD::CSV
           cannot guarantee that any part in the toolchain will work if field names have those  characters,  and
           the chances are high that the SQL statements will fail.

           Currently, the sanitizing of headers is as simple as

             s/\W/_/g;

           Note  that  headers  (column  names)  might  be folded in other parts of the code stack, specifically
           SQL::Statement, whose docs mention:

            Wildcards are expanded to lower cased identifiers. This might
            confuse some people, but it was easier to implement.

           That means that in

            my $sth = $dbh-&gt;prepare ("select * from foo");
            $sth-&gt;execute;
            while (my $row = $sth-&gt;fetchrow_hashref) {
                say for keys %$row;
                }

           all keys will show as all lower case, regardless of the original header.

       It's strongly recommended to check the attributes supported by "Metadata" in DBD::File.

       Example: Suppose you want to use <u><a href="file:/etc/passwd">/etc/passwd</a></u> as a CSV file. :-) There simplest way is:

           use DBI;
           my $dbh = DBI-&gt;connect ("dbi:CSV:", undef, undef, {
               f_dir           =&gt; "<a href="file:/etc">/etc</a>",
               csv_sep_char    =&gt; ":",
               csv_quote_char  =&gt; undef,
               csv_escape_char =&gt; undef,
               });
           $dbh-&gt;{csv_tables}{passwd} = {
               col_names =&gt; [qw( login password uid gid realname
                                 directory shell )];
               };
           $sth = $dbh-&gt;prepare ("SELECT * FROM passwd");

       Another possibility where you leave all the defaults as they are and override them on a per table basis:

           require DBI;
           my $dbh = DBI-&gt;connect ("dbi:CSV:");
           $dbh-&gt;{csv_tables}{passwd} = {
               eol         =&gt; "\n",
               sep_char    =&gt; ":",
               quote_char  =&gt; undef,
               escape_char =&gt; undef,
               f_file      =&gt; "<a href="file:/etc/passwd">/etc/passwd</a>",
               col_names   =&gt; [qw( login password uid gid
                                   realname directory shell )],
               };
           $sth = $dbh-&gt;prepare ("SELECT * FROM passwd");

   <b>Driver</b> <b>private</b> <b>methods</b>
       These methods are inherited from DBD::File:

       data_sources
           The "data_sources" method returns a list of sub-directories of the  current  directory  in  the  form
           "dbi:CSV:directory=$dirname".

           If you want to read the sub-directories of another directory, use

               my $drh  = DBI-&gt;install_driver ("CSV");
               my @list = $drh-&gt;data_sources (f_dir =&gt; "/usr/local/csv_data");

       list_tables
           This method returns a list of file-names inside $dbh-&gt;{directory}.  Example:

               my $dbh  = DBI-&gt;connect ("dbi:CSV:directory=/usr/local/csv_data");
               my @list = $dbh-&gt;func ("list_tables");

           Note  that  the  list  includes  all files contained in the directory, even those that have non-valid
           table names, from the view of SQL. See "Creating and dropping tables" above.

</pre><h4><b>KNOWN</b> <b>ISSUES</b></h4><pre>
       •   The module is using flock () internally. However, this function is not available on  some  platforms.
           Use  of  flock  ()  is  disabled  on  MacOS and Windows 95: There's no locking at all (perhaps not so
           important on these operating systems, as they are for single users anyways).

</pre><h4><b>TODO</b></h4><pre>
       Tests
           Aim for a full 100% code coverage

            - eol      Make tests for different record separators.
            - csv_xs   Test with a variety of combinations for
                       sep_char, quote_char, and escape_char testing
            - quoting  $dbh-&gt;do ("drop table $_") for DBI-tables ();
            - errors   Make sure that all documented exceptions are tested.
                       . write to write-protected file
                       . read from badly formatted csv
                       . pass bad arguments to csv parser while fetching

           Add tests that specifically test DBD::File functionality where that is useful.

       RT  Attack all open DBD::CSV bugs in RT

       CPAN::Forum
           Attack all items in <a href="http://www.cpanforum.com/dist/DBD-CSV">http://www.cpanforum.com/dist/DBD-CSV</a>

       Documentation
           Expand on error-handling, and document all possible errors.  Use Text::CSV_XS::error_diag () wherever
           possible.

       Debugging
           Implement and document dbd_verbose.

       Data dictionary
           Investigate the possibility to store the data dictionary in a file like .sys$columns that  can  store
           the field attributes (type, key, nullable).

       Examples
           Make more real-life examples from the docs in examples/

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       DBI, Text::CSV_XS, SQL::Statement, DBI::SQL::Nano

       For help on the use of DBD::CSV, see the DBI users mailing list:

         <a href="http://lists.cpan.org/showlist.cgi">http://lists.cpan.org/showlist.cgi</a>?name=dbi-users

       For general information on DBI see

         <a href="http://dbi.perl.org/">http://dbi.perl.org/</a> and <a href="http://faq.dbi-support.com/">http://faq.dbi-support.com/</a>

</pre><h4><b>AUTHORS</b> <b>and</b> <b>MAINTAINERS</b></h4><pre>
       This module is currently maintained by

           H.Merijn Brand &lt;<a href="mailto:h.m.brand@xs4all.nl">h.m.brand@xs4all.nl</a>&gt;

       in close cooperation with and help from

           Jens Rehsack &lt;<a href="mailto:sno@NetBSD.org">sno@NetBSD.org</a>&gt;

       The original author is Jochen Wiedmann.  Previous maintainer was Jeff Zucker

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright  (C) 2009-2025 by H.Merijn Brand Copyright (C) 2004-2009 by Jeff Zucker Copyright (C) 1998-2004
       by Jochen Wiedmann

       All rights reserved.

       You may distribute this module under the terms of either the GNU General Public License or  the  Artistic
       License, as specified in the Perl README file.

perl v5.40.0                                       2025-01-31                                      <u>DBD::<a href="../man3pm/CSV.3pm.html">CSV</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>