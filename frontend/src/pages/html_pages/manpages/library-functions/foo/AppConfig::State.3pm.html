<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AppConfig::State - application configuration state</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libappconfig-perl">libappconfig-perl_1.71-2.3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       AppConfig::State - application configuration state

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use AppConfig::State;

           my $state = AppConfig::State-&gt;new(\%cfg);

           $state-&gt;define("foo");            # very simple variable definition
           $state-&gt;define("bar", \%varcfg);  # variable specific configuration
           $state-&gt;define("foo|bar=i@");     # compact format

           $state-&gt;set("foo", 123);          # trivial set/get examples
           $state-&gt;get("foo");

           $state-&gt;foo();                    # shortcut variable access
           $state-&gt;<a href="../man456/foo.456.html">foo</a>(456);                 # shortcut variable update

</pre><h4><b>OVERVIEW</b></h4><pre>
       AppConfig::State is a Perl5 module to handle global configuration variables for perl programs.  It
       maintains the state of any number of variables, handling default values, aliasing, validation, update
       callbacks and option arguments for use by other AppConfig::* modules.

       AppConfig::State is distributed as part of the AppConfig bundle.

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>USING</b> <b>THE</b> <b>AppConfig::State</b> <b>MODULE</b>
       To import and use the AppConfig::State module the following line should appear in your Perl script:

            use AppConfig::State;

       The AppConfig::State module is loaded automatically by the <b>new()</b> constructor of the AppConfig module.

       AppConfig::State is implemented using object-oriented methods.  A new AppConfig::State object is created
       and initialised using the <b>new()</b> method.  This returns a reference to a new AppConfig::State object.

           my $state = AppConfig::State-&gt;new();

       This will create a reference to a new AppConfig::State with all configuration options set to their
       default values.  You can initialise the object by passing a reference to a hash array containing
       configuration options:

           $state = AppConfig::State-&gt;new( {
               CASE      =&gt; 1,
               ERROR     =&gt; \&amp;my_error,
           } );

       The <b>new()</b> constructor of the AppConfig module automatically passes all parameters to the AppConfig::State
       <b>new()</b> constructor.  Thus, any global configuration values and variable definitions for AppConfig::State
       are also applicable to AppConfig.

       The following configuration options may be specified.

       CASE
           Determines  if  the  variable  names  are  treated  case  sensitively.  Any non-zero value makes case
           significant when naming variables.  By default, CASE is set to 0 and thus "Variable", "VARIABLE"  and
           "VaRiAbLe" are all treated as "variable".

       CREATE
           By default, CREATE is turned off meaning that all variables accessed via <b>set()</b> (which includes access
           via  shortcut  such as "$state-&gt;variable($value)" which delegates to <b>set()</b>) must previously have been
           defined via <b>define()</b>.  When CREATE is set to 1, calling set($variable, $value)  on  a  variable  that
           doesn't exist will cause it to be created automatically.

           When CREATE is set to any other non-zero value, it is assumed to be a regular expression pattern.  If
           the  variable  name  matches  the  regex,  the  variable  is  created.   This  can be used to specify
           configuration file blocks in which variables should be created, for example:

               $state = AppConfig::State-&gt;new( {
                   CREATE =&gt; '^define_',
               } );

           In a config file:

               [define]
               name = fred           # define_name gets created automatically

               [other]
               name = john           # other_name doesn't - warning raised

           Note that a regex pattern specified in CREATE is applied to the real variable name  rather  than  any
           alias by which the variables may be accessed.

       PEDANTIC
           The  PEDANTIC  option  determines  what  action  the configuration file (AppConfig::File) or argument
           parser (AppConfig::Args) should take on encountering  a  warning  condition  (typically  caused  when
           trying  to  set  an  undeclared variable).  If PEDANTIC is set to any true value, the parsing methods
           will immediately return a value of 0 on encountering such a condition.  If PEDANTIC is not  set,  the
           method  will  continue  to  parse the remainder of the current file(s) or arguments, returning 0 when
           complete.

           If no warnings or errors are encountered, the method returns 1.

           In the case of a system error (e.g. unable to open a file), the  method  returns  undef  immediately,
           regardless of the PEDANTIC option.

       ERROR
           Specifies  a  user-defined  error  handling  routine.  When the handler is called, a format string is
           passed as the first parameter, followed by any additional values, as per <a href="../man3C/printf.3C.html">printf</a>(3C).

       DEBUG
           Turns debugging on or off when set to 1 or 0 accordingly.  Debugging may also be activated by calling
           <b>_debug()</b>   as   an   object   method    ("$state-&gt;<a href="../man1/_debug.1.html">_debug</a>(1)")    or    as    a    package    function
           (AppConfig::State::<a href="../man1/_debug.1.html">_debug</a>(1)),  passing in a true/false value to set the debugging state accordingly.
           The package variable $AppConfig::State::DEBUG can also be set directly.

           The <b>_debug()</b> method returns the current debug value.  If a new value is passed in, the internal value
           is updated, but the previous value is returned.

           Note that any AppConfig::File or App::Config::Args objects that are instantiated with a reference  to
           an  App::State  will  inherit  the  DEBUG  (and  also  PEDANTIC)  values  of  the state at that time.
           Subsequent changes to the AppConfig::State debug value will not affect them.

       GLOBAL
           The GLOBAL option allows default values to be set for the DEFAULT,  ARGCOUNT,  EXPAND,  VALIDATE  and
           ACTION options for any subsequently defined variables.

               $state = AppConfig::State-&gt;new({
                   GLOBAL =&gt; {
                       DEFAULT  =&gt; '&lt;undef&gt;',     # default value for new vars
                       ARGCOUNT =&gt; 1,             # vars expect an argument
                       ACTION   =&gt; \&amp;my_set_var,  # callback when vars get set
                   }
               });

           Any attributes specified explicitly when a variable is defined will override any GLOBAL values.

           See "DEFINING VARIABLES" below which describes these options in detail.

   <b>DEFINING</b> <b>VARIABLES</b>
       The "define()" function is used to pre-declare a variable and specify its configuration.

           $state-&gt;define("foo");

       In  the  simple  example  above, a new variable called "foo" is defined.  A reference to a hash array may
       also be passed to specify configuration information for the variable:

           $state-&gt;define("foo", {
                   DEFAULT   =&gt; 99,
                   ALIAS     =&gt; 'metavar1',
               });

       Any variable-wide GLOBAL values passed to the <b>new()</b> constructor in the configuration hash  will  also  be
       applied.  Values explicitly specified in a variable's <b>define()</b> configuration will override the respective
       GLOBAL values.

       The following configuration options may be specified

       DEFAULT
           The DEFAULT value is used to initialise the variable.

               $state-&gt;define("drink", {
                       DEFAULT =&gt; 'coffee',
                   });

               print $state-&gt;drink();        # prints "coffee"

       ALIAS
           The  ALIAS  option  allows a number of alternative names to be specified for this variable.  A single
           alias should be specified as a string.  Multiple aliases can be specified as a reference to an  array
           of alternatives or as a string of names separated by vertical bars, '|'.  e.g.:

               # either
               $state-&gt;define("name", {
                       ALIAS  =&gt; 'person',
                   });

               # or
               $state-&gt;define("name", {
                       ALIAS =&gt; [ 'person', 'user', 'uid' ],
                   });

               # or
               $state-&gt;define("name", {
                       ALIAS =&gt; 'person|user|uid',
                   });

               $state-&gt;user('abw');     # equivalent to $state-&gt;name('abw');

       ARGCOUNT
           The  ARGCOUNT option specifies the number of arguments that should be supplied for this variable.  By
           default, no additional arguments are expected for variables (ARGCOUNT_NONE).

           The ARGCOUNT_* constants can be imported from the AppConfig module:

               use AppConfig ':argcount';

               $state-&gt;define('foo', { ARGCOUNT =&gt; ARGCOUNT_ONE });

           or can be accessed directly from the AppConfig package:

               use AppConfig;

               $state-&gt;define('foo', { ARGCOUNT =&gt; AppConfig::ARGCOUNT_ONE });

           The following values for ARGCOUNT may be specified.

           ARGCOUNT_NONE (0)
               Indicates that no additional arguments  are  expected.   If  the  variable  is  identified  in  a
               confirguration  file  or  in  the command line arguments, it is set to a value of 1 regardless of
               whatever arguments follow it.

           ARGCOUNT_ONE (1)
               Indicates that the variable expects a single argument to be provided.  The variable value will be
               overwritten with a new value each time it is encountered.

           ARGCOUNT_LIST (2)
               Indicates that the variable expects multiple arguments.  The variable value will be  appended  to
               the list of previous values each time it is encountered.

           ARGCOUNT_HASH (3)
               Indicates  that  the  variable  expects  multiple arguments and that each argument is of the form
               "key=value".  The argument will be split into a key/value pair and  inserted  into  the  hash  of
               values each time it is encountered.

       ARGS
           The  ARGS  option  can  also  be  used  to  specify  advanced  command  line  options  for  use  with
           AppConfig::Getopt,  which  itself  delegates  to  Getopt::Long.   See  those  two  modules  for  more
           information on the format and meaning of these options.

               $state-&gt;define("name", {
                       ARGS =&gt; "=i@",
                   });

       EXPAND
           The EXPAND option specifies how the AppConfig::File processor should expand embedded variables in the
           configuration  file values it reads.  By default, EXPAND is turned off (EXPAND_NONE) and no expansion
           is made.

           The EXPAND_* constants can be imported from the AppConfig module:

               use AppConfig ':expand';

               $state-&gt;define('foo', { EXPAND =&gt; EXPAND_VAR });

           or can be accessed directly from the AppConfig package:

               use AppConfig;

               $state-&gt;define('foo', { EXPAND =&gt; AppConfig::EXPAND_VAR });

           The following values for EXPAND may be specified.  Multiple values should be combined  with  vertical
           bars , '|', e.g. "EXPAND_UID | EXPAND_VAR").

           EXPAND_NONE
               Indicates that no variable expansion should be attempted.

           EXPAND_VAR
               Indicates  that  variables  embedded  as  $var  or $(var) should be expanded to the values of the
               relevant AppConfig::State variables.

           EXPAND_UID
               Indicates that '~' or '~uid' patterns in the string should be expanded to the current users ($&lt;),
               or specified user's home directory.  In the first case, "~" is  expanded  to  the  value  of  the
               "HOME"  environment  variable.   In  the  second  case,  the "getpwnam()" method is used if it is
               available on your system (which it isn't on Win32).

           EXPAND_ENV
               Inidicates that variables embedded as ${var} should be expanded to  the  value  of  the  relevant
               environment variable.

           EXPAND_ALL
               Equivalent to "EXPAND_VARS | EXPAND_UIDS | EXPAND_ENVS").

           EXPAND_WARN
               Indicates  that  embedded  variables that are not defined should raise a warning.  If PEDANTIC is
               set, this will cause the <b>read()</b> method to return 0 immediately.

       VALIDATE
           Each variable may have a sub-routine or regular expression defined which  is  used  to  validate  the
           intended value for a variable before it is set.

           If  VALIDATE  is  defined as a regular expression, it is applied to the value and deemed valid if the
           pattern matches.  In this case, the variable is then set to the new  value.   A  warning  message  is
           generated if the pattern match fails.

           VALIDATE may also be defined as a reference to a sub-routine which takes as its arguments the name of
           the variable and its intended value.  The sub-routine should return 1 or 0 to indicate that the value
           is  valid  or  invalid,  respectively.   An  invalid  value  will cause a warning error message to be
           generated.

           If the GLOBAL VALIDATE variable is set (see GLOBAL in DESCRIPTION above) then this value will be used
           as the default VALIDATE for each variable unless otherwise specified.

               $state-&gt;define("age", {
                       VALIDATE =&gt; '\d+',
                   });

               $state-&gt;define("pin", {
                       VALIDATE =&gt; \&amp;check_pin,
                   });

       ACTION
           The ACTION option allows a sub-routine to be bound to a variable  as  a  callback  that  is  executed
           whenever  the  variable is set.  The ACTION is passed a reference to the AppConfig::State object, the
           name of the variable and the value of the variable.

           The ACTION routine may be used, for example, to post-process variable data, update the value of  some
           other dependant variable, generate a warning message, etc.

           Example:

               $state-&gt;define("foo", { ACTION =&gt; \&amp;my_notify });

               sub my_notify {
                   my $state = shift;
                   my $var   = shift;
                   my $val   = shift;

                   print "$variable set to $value";
               }

               $state-&gt;<a href="../man42/foo.42.html">foo</a>(42);        # prints "foo set to 42"

           Be  aware  that  calling  "$state-&gt;set()" to update the same variable from within the ACTION function
           will cause a recursive loop as the ACTION function is repeatedly called.

   <b>DEFINING</b> <b>VARIABLES</b> <b>USING</b> <b>THE</b> <b>COMPACT</b> <b>FORMAT</b>
       Variables may be defined in a compact format which allows any ALIAS and ARGS values to  be  specified  as
       part  of  the  variable  name.   This  is  designed to mimic the behaviour of Johan Vromans' Getopt::Long
       module.

       Aliases for a variable should be specified after the variable name, separated by vertical bars, '|'.  Any
       ARGS parameter should be appended after the variable name(s) and/or aliases.

       The following examples are equivalent:

           $state-&gt;define("foo", {
                   ALIAS =&gt; [ 'bar', 'baz' ],
                   ARGS  =&gt; '=i',
               });

           $state-&gt;define("foo|bar|baz=i");

   <b>READING</b> <b>AND</b> <b>MODIFYING</b> <b>VARIABLE</b> <b>VALUES</b>
       AppConfig::State defines two methods to manipulate variable values:

           set($variable, $value);
           get($variable);

       Both functions take the variable name as the first parameter and "set()" takes  an  additional  parameter
       which  is  the new value for the variable.  "set()" returns 1 or 0 to indicate successful or unsuccessful
       update of the variable value.  If there is an ACTION routine associated  with  the  named  variable,  the
       value  returned  will be passed back from "set()".  The "get()" function returns the current value of the
       variable.

       Once defined, variables may be accessed directly as object methods where the method name is the  same  as
       the variable name.  i.e.

           $state-&gt;set("verbose", 1);

       is equivalent to

           $state-&gt;<a href="../man1/verbose.1.html">verbose</a>(1);

       Without  parameters,  the  current  value  of the variable is returned.  If a parameter is specified, the
       variable is set to that value and the result of the <b>set()</b> operation is returned.

           $state-&gt;<a href="../man29/age.29.html">age</a>(29);        # sets 'age' to 29, returns 1 (ok)

   <b>VARLIST</b>
       The <b>varlist()</b> method can be used to extract a number of variables into a hash array.  The first parameter
       should be a regular expression used for matching against the variable names.

           my %vars = $state-&gt;varlist("^file");   # all "file*" variables

       A second parameter may be specified (any true value) to indicate that  the  part  of  the  variable  name
       matching the regex should be removed when copied to the target hash.

           $state-&gt;file_name("/tmp/file");
           $state-&gt;file_path("/foo:/bar:/baz");

           my %vars = $state-&gt;varlist("^file_", 1);

           # %vars:
           #    name =&gt; /tmp/file
           #    path =&gt; "/foo:/bar:/baz"

   <b>INTERNAL</b> <b>METHODS</b>
       The interal (private) methods of the AppConfig::State class are listed below.

       They  aren't intended for regular use and potential users should consider the fact that nothing about the
       internal implementation is guaranteed to remain the same.  Having said that, the  AppConfig::State  class
       is  intended  to  co-exist  and  work  with  a  number of other modules and these are considered "friend"
       classes.  These methods are provided, in part, as services to them.  With this acknowledged  co-operation
       in mind, it is safe to assume some stability in this core interface.

       The <b>_varname()</b> method can be used to determine the real name of a variable from an alias:

           $varname-&gt;_varname($alias);

       Note  that  all  methods that take a variable name, including those listed below, can accept an alias and
       automatically resolve it to the correct variable name.  There is no need to call <b>_varname()</b> explicitly to
       do alias expansion.  The <b>_varname()</b> method will fold all  variables  names  to  lower  case  unless  CASE
       sensititvity is set.

       The <b>_exists()</b> method can be used to check if a variable has been defined:

           $state-&gt;_exists($varname);

       The <b>_default()</b> method can be used to reset a variable to its default value:

           $state-&gt;_default($varname);

       The <b>_expand()</b> method can be used to determine the EXPAND value for a variable:

           print "$varname EXPAND: ", $state-&gt;_expand($varname), "\n";

       The <b>_argcount()</b> method returns the value of the ARGCOUNT attribute for a variable:

           print "$varname ARGCOUNT: ", $state-&gt;_argcount($varname), "\n";

       The  <b>_validate()</b>  method  can  be  used  to  determine if a new value for a variable meets any validation
       criteria specified for it.  The variable name and intended  value  should  be  passed  in.   The  methods
       returns a true/false value depending on whether or not the validation succeeded:

           print "OK\n" if $state-&gt;_validate($varname, $value);

       The <b>_pedantic()</b> method can be called to determine the current value of the PEDANTIC option.

           print "pedantic mode is ", $state-&gt;_pedantic() ? "on" ; "off", "\n";

       The <b>_debug()</b> method can be used to turn debugging on or off (pass 1 or 0 as a parameter).  It can also be
       used  to  check  the debug state, returning the current internal value of $AppConfig::State::DEBUG.  If a
       new debug value is provided, the debug state is updated and the previous state is returned.

           $state-&gt;<a href="../man1/_debug.1.html">_debug</a>(1);               # debug on, returns previous value

       The _dump_var($varname) and <b>_dump()</b> methods may also be called for debugging purposes.

           $state-&gt;_dump_var($varname);    # show variable state
           $state-&gt;_dump();                # show internal state and all vars

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley, &lt;<a href="mailto:abw@wardley.org">abw@wardley.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 1997-2007 Andy Wardley.  All Rights Reserved.

       Copyright (C) 1997,1998 Canon Research Centre Europe Ltd.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       AppConfig, AppConfig::File, AppConfig::Args, AppConfig::Getopt

perl v5.36.0                                       2023-09-28                              <u>AppConfig::<a href="../man3pm/State.3pm.html">State</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>