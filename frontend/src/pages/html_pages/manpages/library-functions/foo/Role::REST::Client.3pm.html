<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Role::REST::Client - REST Client Role</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librole-rest-client-perl">librole-rest-client-perl_0.23-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Role::REST::Client - REST Client Role

</pre><h4><b>VERSION</b></h4><pre>
       version 0.23

</pre><h4><b>SYNOPSIS</b></h4><pre>
               {
                       package RESTExample;

                       use Moose;
                       with 'Role::REST::Client';

                       sub bar {
                               my ($self) = @_;
                               my $res = $self-&gt;post('/foo/bar/baz', {foo =&gt; 'bar'});
                               my $code = $res-&gt;code;
                               my $data = $res-&gt;data;
                               return $data if $code == 200;
                  }

               }

               my $foo = RESTExample-&gt;new(
                       server =&gt;      '<a href="http://localhost">http://localhost</a>:3000',
                       type   =&gt;      'application/json',
                       clientattrs =&gt; {timeout =&gt; 5},
               );

               $foo-&gt;bar;

               # controller
               sub foo : Local {
                       my ($self, $c) = @_;
                       my $res = $c-&gt;model('MyData')-&gt;post('/foo/bar/baz', {foo =&gt; 'bar'});
                       my $code = $res-&gt;code;
                       my $data = $res-&gt;data;
                       ...
               }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This REST Client role makes REST connectivity easy.

       Role::REST::Client will handle encoding and decoding when using the HTTP verbs.

               GET
               HEAD
               PUT
               POST
               DELETE
               OPTIONS

       Currently Role::REST::Client supports these encodings

               application/json
               application/x-www-form-urlencoded
               application/xml
               application/yaml

       x-www-form-urlencoded only works for GET and POST, and only for encoding, not decoding.

       Responses which claim to not be serialised data (eg "text/plain", "application/octet-stream") will by
       default not be serialised. When the response is none of these, and it is impossible to determine what
       encoding is used, the content will be treated as JSON by default.

</pre><h4><b>NAME</b></h4><pre>
       Role::REST::Client - REST Client Role

</pre><h4><b>METHODS</b></h4><pre>
   <b>methods</b>
       Role::REST::Client implements the standard HTTP 1.1 verbs as methods

       These methods can NOT have a request body

               get
               head

       These methods can take a request body.

               post
               put
               delete
               options

       All methods take these parameters

               url - The REST service
               data - The data structure (hashref, arrayref) to send. The data will be encoded
                       according to the value of the I&lt;type&gt; attribute.
               args - hashref with arguments to augment the way the call is handled.

       args - the optional argument parameter can have these entries

               deserializer - if you KNOW that the content-type of the response is incorrect,
               you can supply the correct content type, like

               my $res = $self-&gt;post('/foo/bar/baz', {foo =&gt; 'bar'}, {deserializer =&gt; 'application/yaml'});

               Alternatively, if you KNOW that the response is not serial data, you can
               disable deserialization by setting this to undef.

               preserve_headers - set this to true if you want to keep the headers between calls

       All methods return a response object dictated by _rest_response_class. Set to
       Role::REST::Client::Response by default.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
   <b>user_agent</b>
         sub _build_user_agent { HTTP::Thin-&gt;new }

       A User Agent object which has a "-&gt;request" method suitably compatible with HTTP::Tiny. It should accept
       arguments like this: "$ua-&gt;request($method, $uri, $opts)", and needs to return a hashref as HTTP::Tiny
       does, or an HTTP::Response object.  To set your own default, use a "_build_user_agent" method.

   <b>server</b>
       URL of the REST server.

       e.g. '<a href="http://localhost">http://localhost</a>:3000'

   <b>type</b>
       MIME Content-Type header,

       e.g. application/json

   <b>persistent_headers</b>
         $self-&gt;set_persistent_header('Header' =&gt; 'foo', ... );
         $self-&gt;get_persistent_header('Header-Name');
         $self-&gt;has_no_persistent_headers;
         $self-&gt;clear_persistent_headers;

       A hashref containing headers you want to use for all requests. Use the methods described above to
       manipulate it.

       To set your own defaults, override the default or call "set_persistent_header()" in your "BUILD" method.

         has '+persistent_headers' =&gt; (
           default =&gt; sub { ... },
         );

   <b>httpheaders</b>
         $self-&gt;set_header('Header' =&gt; 'foo', ... );
         $self-&gt;get_header('Header-Name');
         $self-&gt;has_no_headers;
         $self-&gt;clear_headers;

       You can set any http header you like with set_header, e.g.  $self-&gt;set_header($key, $value) but the
       content-type header will be overridden.

       http_headers will be reset after each request, unless there's a reserve_headers argument, but it's a
       hack. The recommended way to keep headers across requests is to store them in the persistent_headers.

       $self-&gt;httpheaders will return the combined hashref of persistent_headers and what's been added with
       set_header.

       For historical reasons, the two methods clear_headers and reset_headers are equal. Both will clear the
       headers for the current request, but NOT the persistent headers.

       To clear ALL headers, use

         $self-&gt;clear_all_headers;

   <b>clientattrs</b>
       Attributes to feed the user agent object (which defaults to HTTP::Thin)

       e.g. {timeout =&gt; 10}

   <b>serializer_class</b>
       You can override the serializer class and use your own. Default is 'Role::REST::Client::Serializer'

   <b>serializer_options</b>
       Options for the serializer instantiation.

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Breno G. de Oliveira, &lt;<a href="mailto:garu@cpan.org">garu@cpan.org</a>&gt;

       Mark Stosberg, &lt;<a href="mailto:mark@stosberg.com">mark@stosberg.com</a>&gt;

       Matt Phillips, (cpan:MATTP) &lt;<a href="mailto:mattp@cpan.org">mattp@cpan.org</a>&gt;

       Wallace Reis, &lt;<a href="mailto:wallace@reis.me">wallace@reis.me</a>&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to bug-role-rest-client at rt.cpan.org, or through the web
       interface at <a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=Role-REST-Client.

</pre><h4><b>AUTHOR</b></h4><pre>
       Kaare Rasmussen &lt;kaare at cpan dot org&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2018 by Kaare Rasmussen.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.28.0                                       2018-11-09                            <u>Role::REST::<a href="../man3pm/Client.3pm.html">Client</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>