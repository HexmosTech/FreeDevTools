<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::MakeMethods::Composite::Global - Global data</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-makemethods-perl">libclass-makemethods-perl_1.01-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::MakeMethods::Composite::Global - Global data

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package MyClass;
         use Class::MakeMethods::Composite::Global (
           scalar =&gt; [ 'foo' ],
           array  =&gt; [ 'my_list' ],
           hash   =&gt; [ 'my_index' ],
         );
         ...

         MyClass-&gt;foo( 'Foozle' );
         print MyClass-&gt;foo();

         print MyClass-&gt;new(...)-&gt;foo(); # same value for any instance
         print MySubclass-&gt;foo();        # ... and for any subclass

         MyClass-&gt;my_list(0 =&gt; 'Foozle', 1 =&gt; 'Bang!');
         print MyClass-&gt;<a href="../man1/my_list.1.html">my_list</a>(1);

         MyClass-&gt;my_index('broccoli' =&gt; 'Blah!', 'foo' =&gt; 'Fiddle');
         print MyClass-&gt;my_index('foo');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Composite::Global suclass of MakeMethods provides basic accessors for shared data.

   <b>Class::MakeMethods</b> <b>Calling</b> <b>Interface</b>
       When you "use" this package, the method declarations you provide as arguments cause subroutines to be
       generated and installed in your module.

       You can also omit the arguments to "use" and instead make methods at runtime by passing the declarations
       to a subsequent call to "make()".

       You may include any number of declarations in each call to "use" or "make()". If methods with the same
       name already exist, earlier calls to "use" or "make()" win over later ones, but within each call, later
       declarations superceed earlier ones.

       You can install methods in a different package by passing "-TargetClass =&gt; <u>package</u>" as your first
       arguments to "use" or "make".

       See Class::MakeMethods for more details.

   <b>Class::MakeMethods::Basic</b> <b>Declaration</b> <b>Syntax</b>
       The following types of Basic declarations are supported:

       •   <u>generator_type</u> =&gt; "<u>method_name</u>"

       •   <u>generator_type</u> =&gt; "<u>name_1</u> <u>name_2</u>..."

       •   <u>generator_type</u> =&gt; [ "<u>name_1</u>", "<u>name_2</u>", ...]

       See the "METHOD GENERATOR TYPES" section below for a list of the supported values of <u>generator_type</u>.

       For  each  method  name  you  provide, a subroutine of the indicated type will be generated and installed
       under that name in your module.

       Method names should start with a letter, followed by zero or more letters, numbers, or underscores.

   <b>Class::MakeMethods::Composite</b> <b>Declaration</b> <b>Syntax</b>
       The Composite syntax also provides several ways to optionally associate a hash of  additional  parameters
       with a given method name.

       •   <u>generator_type</u> =&gt; [ "<u>name_1</u>" =&gt; { <u>param</u>=&gt;<u>value</u>... }, ... ]

           A hash of parameters to use just for this method name.

           (Note:  to prevent confusion with self-contained definition hashes, described below, parameter hashes
           following a method name must not contain the key 'name'.)

       •   <u>generator_type</u> =&gt; [ [ "<u>name_1</u>", "<u>name_2</u>", ... ] =&gt; { <u>param</u>=&gt;<u>value</u>... } ]

           Each of these method names gets a copy of the same set of parameters.

       •   <u>generator_type</u> =&gt; [ { "name"=&gt;"<u>name_1</u>", <u>param</u>=&gt;<u>value</u>... }, ... ]

           By including the reserved parameter "name", you create a self-contained declaration  with  that  name
           and any associated hash values.

       Basic declarations, as described above, are given an empty parameter hash.

</pre><h4><b>METHOD</b> <b>GENERATOR</b> <b>TYPES</b></h4><pre>
   <b>scalar</b> <b>-</b> <b>Global</b> <b>Accessor</b>
       For each method name passed, uses a closure to generate a subroutine with the following characteristics:

       •   May  be  called as a class method, or on any instance or subclass, and behaves identically regardless
           of what it was called on.

       •   If called without any arguments returns the current value.

       •   If called with an argument, stores that as the value, and returns it,

       •   If called with multiple arguments, stores a  reference  to  a  new  array  with  those  arguments  as
           contents, and returns that array reference.

       Sample declaration and usage:

         package MyClass;
         use Class::MakeMethods::Composite::Global (
           scalar =&gt; 'foo',
         );
         ...

         # Store value
         MyClass-&gt;foo('Foozle');

         # Retrieve value
         print MyClass-&gt;foo;

   <b>array</b> <b>-</b> <b>Global</b> <b>Ref</b> <b>Accessor</b>
       For each method name passed, uses a closure to generate a subroutine with the following characteristics:

       •   May  be  called as a class method, or on any instance or subclass, and behaves identically regardless
           of what it was called on.

       •   The global value will be a reference to an array (or undef).

       •   If called without any arguments, returns the current array-ref value (or undef).

       •   If called with a single non-ref argument, uses that  argument  as  an  index  to  retrieve  from  the
           referenced array, and returns that value (or undef).

       •   If called with a single array ref argument, uses that list to return a slice of the referenced array.

       •   If  called  with  a list of argument pairs, each with a non-ref index and an associated value, stores
           the value at the given index in the referenced array. If the global value was previously undefined, a
           new array is autovivified. The current  value  in  each  position  will  be  overwritten,  and  later
           arguments with the same index will override earlier ones. Returns the current array-ref value.

       •   If called with a list of argument pairs, each with the first item being a reference to an array of up
           to two numbers, loops over each pair and uses those numbers to splice the value array.

           The  first  controlling number is the position at which the splice will begin. Zero will start before
           the first item in the list. Negative numbers count backwards from the end of the array.

           The second number is the number of items to be removed from the list. If it is omitted, or undefined,
           or zero, no items are removed. If it is a positive integer, that many items will be returned.

           If both numbers are omitted, or are both undefined, they  default  to  containing  the  entire  value
           array.

           If the second argument is undef, no values will be inserted; if it is a non-reference value, that one
           value will be inserted; if it is an array-ref, its values will be copied.

           The method returns the items that removed from the array, if any.

       Sample declaration and usage:

         package MyClass;
         use Class::MakeMethods::Composite::Global (
           array =&gt; 'bar',
         );
         ...

         # Clear and set contents of list
         print MyClass-&gt;bar([ 'Spume', 'Frost' ] );

         # Set values by position
         MyClass-&gt;bar(0 =&gt; 'Foozle', 1 =&gt; 'Bang!');

         # Positions may be overwritten, and in any order
         MyClass-&gt;bar(2 =&gt; 'And Mash', 1 =&gt; 'Blah!');

         # Retrieve value by position
         print MyClass-&gt;<a href="../man1/bar.1.html">bar</a>(1);

         # Direct access to referenced array
         print scalar @{ MyClass-&gt;bar() };

       There are also calling conventions for slice and splice operations:

         # Retrieve slice of values by position
         print join(', ', MyClass-&gt;bar( undef, [0, 2] ) );

         # Insert an item at position in the array
         MyClass-&gt;bar([3], 'Potatoes' );

         # Remove 1 item from position 3 in the array
         MyClass-&gt;bar([3, 1], undef );

         # Set a new value at position 2, and return the old value
         print MyClass-&gt;bar([2, 1], 'Froth' );

   <b>hash</b> <b>-</b> <b>Global</b> <b>Ref</b> <b>Accessor</b>
       For each method name passed, uses a closure to generate a subroutine with the following characteristics:

       •   May  be  called as a class method, or on any instance or subclass, and behaves identically regardless
           of what it was called on.

       •   The global value will be a reference to a hash (or undef).

       •   If called without any arguments, returns the contents  of  the  hash  in  list  context,  or  a  hash
           reference in scalar context (or undef).

       •   If  called  with one non-ref argument, uses that argument as an index to retrieve from the referenced
           hash, and returns that value (or undef).

       •   If called with one array-ref argument, uses the contents of that array to retrieve  a  slice  of  the
           referenced hash.

       •   If  called  with  one  hash-ref  argument,  sets  the  contents  of the referenced hash to match that
           provided.

       •   If called with a list of key-value pairs, stores the value under the  given  key  in  the  referenced
           hash.  If  the  global  value was previously undefined, a new hash is autovivified. The current value
           under each key will be overwritten, and later arguments with the same key will override earlier ones.
           Returns the contents of the hash in list context, or a hash reference in scalar context.

       Sample declaration and usage:

         package MyClass;
         use Class::MakeMethods::Composite::Global (
           hash =&gt; 'baz',
         );
         ...

         # Set values by key
         MyClass-&gt;baz('foo' =&gt; 'Foozle', 'bar' =&gt; 'Bang!');

         # Values may be overwritten, and in any order
         MyClass-&gt;baz('broccoli' =&gt; 'Blah!', 'foo' =&gt; 'Fiddle');

         # Retrieve value by key
         print MyClass-&gt;baz('foo');

         # Retrieve slice of values by position
         print join(', ', MyClass-&gt;baz( ['foo', 'bar'] ) );

         # Direct access to referenced hash
         print keys %{ MyClass-&gt;baz() };

         # Reset the hash contents to empty
         @{ MyClass-&gt;baz() } = ();

   <b>object</b> <b>-</b> <b>Global</b> <b>Ref</b> <b>Accessor</b>
       For each method name passed, uses a closure to generate a subroutine with the following characteristics:

       •   May be called as a class method, or on any instance or subclass, and behaves  identically  regardless
           of what it was called on.

       •   The global value will be a reference to an object (or undef).

       •   If called without any arguments returns the current value.

       •   If called with an argument, stores that as the value, and returns it,

       Sample declaration and usage:

         package MyClass;
         use Class::MakeMethods::Composite::Global (
           object =&gt; 'foo',
         );
         ...

         # Store value
         MyClass-&gt;foo( Foozle-&gt;new() );

         # Retrieve value
         print MyClass-&gt;foo;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See Class::MakeMethods for general information about this distribution.

       See Class::MakeMethods::Composite for more about this family of subclasses.

perl v5.36.0                                       2022-10-13                <u>MakeMethods::Composite::<a href="../man3pm/Global.3pm.html">Global</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>