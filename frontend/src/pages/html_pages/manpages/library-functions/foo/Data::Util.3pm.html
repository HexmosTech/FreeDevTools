<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Util - A selection of utilities for data and data types</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-util-perl">libdata-util-perl_0.67-1build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Util - A selection of utilities for data and data types

</pre><h4><b>VERSION</b></h4><pre>
       This document describes Data::Util version 0.67

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Data::Util qw(:validate);

               sub foo{
                       # they will die if invalid values are supplied
                       my $sref = scalar_ref(shift);
                       my $aref = array_ref(shift);
                       my $href = hash_ref(shift);
                       my $cref = code_ref(shift);
                       my $gref = glob_ref(shift);
                       my $rx   = rx(shift); # regular expression
                       my $obj  = instance(shift, 'Foo');
                       # ...
               }

               use Data::Util qw(:check);

               sub bar{
                       my $x = shift;
                       if(is_scalar_ref $x){
                               # $x is an array reference
                       }
                       # ...
                       elsif(is_instance $x, 'Foo'){
                               # $x is an instance of Foo
                       }
                       # ...
               }

               # miscelaneous
               use Data::Util qw(:all);

               my $x = anon_scalar();
               $x = anon_scalar($x); # OK

               my $stash = get_stash('Foo');

               install_subroutine('Foo',
                       hello  =&gt; sub{ "Hello!\n" },
                       goodby =&gt; sub{ "Goodby!\n" },
               );

               print Foo::hello(); # Hello!

               my($pkg, $name) = get_code_info(\&amp;Foo::hello); # =&gt; ('Foo', 'hello')
               my $fqn         = get_code_info(\&amp;Foo::hello); # =&gt;  'Foo::hello'
               my $code        = get_code_ref('Foo', 'hello');  # =&gt; \&amp;Foo::hello

               uninstall_subroutine('Foo', qw(hello goodby));

           # simple format for errro messages (not the same as Data::Dumper)
               print neat("Hello!\n"); # =&gt; "Hello!\n"
               print neat(3.14);       # =&gt; 3.14
               print neat(undef);      # =&gt; undef

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides utility functions for data and data types, including functions for subroutines and
       symbol table hashes (stashes).

       This module makes for a pure Perl and XS implementation.

       However, if you want to use the full capacity of it, we recommend you to opt for the XS backend.

       There are many benchmarks in the <u>DIST-DIR/benchmark/</u> directory.

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>Check</b> <b>functions</b>
       Check functions are introduced by the ":check" import tag, which check the argument type and return a
       bool.

       These functions also check for overloading magic, e.g. "${}" corresponds to a SCALAR reference.

       is_scalar_ref(value)
           Checks for a SCALAR reference.

       is_array_ref(value)
           Checks for an ARRAY reference.

       is_hash_ref(value)
           Checks for a HASH reference.

       is_code_ref(value)
           Checks for a CODE reference.

       is_glob_ref(value)
           Checks for a GLOB reference.

       is_rx(value)
           Checks for a regular expression reference generated by the "qr//" operator.

       is_instance(value, class)
           Checks for an instance of <u>class</u>.

           It is equivalent to the following statement: "Scalar::Util::blessed($value) &amp;&amp; $value-&gt;isa($class)".

       is_invocant(value)
           Checks for an invocant, i.e. a blessed reference or existent package name.

           If <u>value</u> is a valid class name but does not exist, it will return false.

       is_value(value)
           Checks whether <u>value</u> is a primitive value, i.e. a defined, non-ref, and non-type-glob value.

           This function has no counterpart for validation.

       is_string(value)
           Checks  whether  <u>value</u>  is a string with non-zero-length contents, equivalent to "is_value($value) &amp;&amp;
           length($value) &gt; 0".

           This function has no counterpart for validation.

       is_number(value)
           Checks whether <u>value</u> is a number.  Here, a <b>number</b> means that the perl parser can  understand  it  and
           that the perl numeric converter (e.g. invoked by "sprintf '%g', $value") doesn't complain about it.

           It  is similar to Scalar::Util::looks_like_number() but refuses "infinity", "not a number" and "0 but
           true".  Note that "9**9**9" makes "infinity" and "9**9**9 - 9**9**9" makes "not a number".

           This function has no counterpart for validation.

       is_integer(value)
           Checks whether <u>value</u> is an integer.  An <b>integer</b> is also a <b>number</b>, so this function refuses "infinity"
           and "not a number". See also is_number().

           This function has no counterpart for validation.

   <b>Validating</b> <b>functions</b>
       Validating functions are introduced by the ":validate" tag which checks for the argument and returns  the
       first argument.  These are like the ":check" functions but dies if the argument type is invalid.

       These functions also checks overloading magic, e.g. "${}" for a SCALAR reference.

       scalar_ref(value)
           Validates a SCALAR reference.

       array_ref(value)
           Validates an ARRAY reference.

       hash_ref(value)
           Validates a HASH reference.

       code_ref(value)
           Validates a CODE reference.

       glob_ref(value)
           Validates a GLOB reference.

       rx(value)
           Validates a regular expression reference.

       instance(value, class)
           Validates an instance of <u>class</u>.

       invocant(value)
           Validates an invocant, i.e. a blessed reference or existent package name.

           If  <u>value</u> is a valid class name and the class exists, then it returns the canonical class name, which
           is logically cleaned up. That is, it runs "$value =~ s/^::(?:main::)*//;" before returning it.

           NOTE: Canonization is done so due to an inconsistency between Perl versions.  For instance:

                   package ::Foo; # OK
                   my $x = bless {}, '::Foo'; # OK
                   ref($x)-&gt;isa('Foo'); # Fatal

           The last code snippet causes a fatal error: "Can't  call  method  "isa"  without  package  or  object
           reference".  However, "invocant(ref $x)-&gt;isa('Foo')" is always OK.

   <b>Miscellaneous</b> <b>utilities</b>
       There are some other utility functions you can import from this module.

       <b>anon_scalar()</b>
           Generates an anonymous scalar reference to "undef".

       anon_scalar(value)
           Generates an anonymous scalar reference to the copy of <u>value</u>.

           It is equivalent to "do{ my $tmp = $value; \$tmp; }".

       neat(value)
           Returns a neat string that is suitable to display.

           This is a smart version of "&lt;do{ defined($value) ? qq{"$value"} : 'undef' }"&gt;.

       get_stash(invocant)
           Returns the symbol table hash (also known as <b>stash</b>) of <u>invocant</u> if the stash exists.

       install_subroutine(package, name =&gt; subr [, ...])
           Installs <u>subr</u> into <u>package</u> as <u>name</u>.

           It is similar to "do{ no strict 'refs'; *{$package.'::'.$name} = \&amp;subr; }".  In addition, if <u>subr</u> is
           an anonymous subroutine, it is located into <u>package</u> as a named subroutine <u>&amp;package::name</u>.

           For example:

                   install_subroutine($pkg,   say =&gt; sub{ print @_, "\n" });
                   install_subroutine($pkg,
                           one =&gt; \&amp;_one,
                           two =&gt; \&amp;_two,
                   );

                   # accepts a HASH reference
                   install_subroutine($pkg, { say =&gt; sub{ print @_, "\n" }); #

           To re-install <u>subr</u>, use "no warnings 'redefine'" directive:

                   no warnings 'redefine';
                   install_subroutine($package, $name =&gt; $subr);

       uninstall_subroutine(package, names...)
           Uninstalls <u>names</u> from <u>package</u>.

           It is similar to Sub::Delete::delete_sub(), but uninstall multiple subroutines at a time.

           If you want to specify deleted subroutines, you can supply "name =&gt; \&amp;subr" pairs.

           For example:

                   uninstall_subroutine('Foo', 'hello');

                   uninstall_subroutine('Foo', hello =&gt; \&amp;Bar::hello);

                   uninstall_subroutine($pkg,
                           one =&gt; \&amp;_one,
                           two =&gt; \&amp;_two,
                   );

                   # accepts a HASH reference
                   uninstall_subroutine(\$pkg, { hello =&gt; \&amp;Bar::hello });

       get_code_info(subr)
           Returns a pair of elements, the package name and the subroutine name of <u>subr</u>.

           It  is  similar  to Sub::Identify::get_code_info(), but it returns the fully qualified name in scalar
           context.

       get_code_ref(package, name, flag?)
           Returns <u>&amp;package::name</u> if it exists, not touching the symbol in the stash.

           if <u>flag</u> is a string "-create", it returns <u>&amp;package::name</u> regardless of its existence. That is, it  is
           equivalent to "do{ no strict 'refs'; \&amp;{package . '::' . $name} }".

           For example:

                   $code = get_code_ref($pkg, $name);          # like  *{$pkg.'::'.$name}{CODE}
                   $code = get_code_ref($pkg, $name, -create); # like \&amp;{$pkg.'::'.$name}

       curry(subr, args and/or placeholders)
           Makes <u>subr</u> curried and returns the curried subroutine.

           This is also considered as lightweight closures.

           See also Data::Util::Curry.

       modify_subroutine(subr, ...)
           Modifies <u>subr</u> with subroutine modifiers and returns the modified subroutine.  This is also considered
           as lightweight closures.

           <u>subr</u> must be a code reference or callable object.

           Optional  arguments:  "before  =&gt;  [subroutine(s)]"  called before <u>subr</u>.  "around =&gt; [subroutine(s)]"
           called around <u>subr</u>.  "after  =&gt; [subroutine(s)]" called after  <u>subr</u>.

           This seems a constructor of modified subroutines and subroutine_modifier() is property accessors, but
           it does not bless the modified subroutines.

       subroutine_modifier(subr)
           Returns whether <u>subr</u> is a modified subroutine.

       subroutine_modifier(modified_subr, property)
           Gets <u>property</u> from <u>modified</u>.

           Valid properties are: "before", "around", "after".

       subroutine_modifier(modified_subr, modifier =&gt; [subroutine(s)])
           Adds subroutine <u>modifier</u> to <u>modified_subr</u>.

           Valid modifiers are: "before", "around", "after".

       mkopt(input, moniker, require_unique, must_be)
           Produces an array of an array reference from <u>input</u>.

           It is compatible with Data::OptList::mkopt(). In addition to it, <u>must_be</u> can be a HASH reference with
           "name =&gt; type" pairs.

           For example:

                   my $optlist = mkopt(['foo', bar =&gt; [42]], $moniker, $uniq, { bar =&gt; 'ARRAY' });
                   # $optlist == [[foo =&gt; undef], [bar =&gt; [42]]

       mkopt_hash(input, moniker, must_be)
           Produces a hash reference from <u>input</u>.

           It is compatible with Data::OptList::mkopt_hash(). In addition to it, <u>must_be</u> can be a HASH reference
           with "name =&gt; type" pairs.

           For example:

                   my $optlist = mkopt(['foo', bar =&gt; [42]], $moniker, { bar =&gt; 'ARRAY' });
                   # $optlist == {foo =&gt; undef, bar =&gt; [42]}

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
   <b>DATA_UTIL_PUREPERL</b>
       If true, "Data::Util" uses the pure Perl implementation.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       Perl 5.10 or later.

       If you have a C compiler, you can use the XS backend.

       A pure Perl backend/implementation is  also  made  available  in  case  you  have  no  C  compiler  handy
       (unlikely!).

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       No bugs have been reported.

       Please report any bugs or feature requests to the author.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Scalar::Util.

       overload.

       Params::Util.

       Sub::Install.

       Sub::Identify.

       Sub::Delete.

       Sub::Curry.

       Class::MOP.

       Class::Method::Modifiers.

       Data::OptList.

       Mouse

</pre><h4><b>AUTHOR</b></h4><pre>
       Goro Fuji(gfx) &lt;gfuji(at)cpan.org&gt;.

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2008-2010, Goro Fuji &lt;gfuji(at)cpan.org&gt;. All rights reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2024-10-20                                    <u>Data::<a href="../man3pm/Util.3pm.html">Util</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>