<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Util::JA - データとデータ型のためのユーティリティ集</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-util-perl">libdata-util-perl_0.67-1build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Util::JA - データとデータ型のためのユーティリティ集

</pre><h4><b>VERSION</b></h4><pre>
       This document describes Data::Util version 0.63

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Data::Util qw(:validate);

               sub foo{
                       # they will die if invalid values are supplied
                       my $sref = scalar_ref(shift);
                       my $aref = array_ref(shift);
                       my $href = hash_ref(shift);
                       my $cref = code_ref(shift);
                       my $gref = glob_ref(shift);
                       my $rref = regex_ref(shift);
                       my $obj  = instance(shift, 'Foo');
                       # ...
               }

               use Data::Util qw(:check);

               sub bar{
                       my $x = shift;
                       if(is_scalar_ref $x){
                               # $x is an array reference
                       }
                       # ...
                       elsif(is_instance $x, 'Foo'){
                               # $x is an instance of Foo
                       }
                       # ...
               }

               # miscelaneous
               use Data::Util qw(:all);

               my $x = anon_scalar();
               $x = anon_scalar($x); # OK

               my $stash = get_stash('Foo');

               install_subroutine('Foo',
                       hello  =&gt; sub{ "Hello!\n" },
                       goodby =&gt; sub{ "Goodby!\n" },
               );

               print Foo::hello(); # Hello!

               my($pkg, $name) = get_code_info(\&amp;Foo::hello); # =&gt; ('Foo', 'hello')
               my $fqn         = get_code_info(\&amp;Foo::hello); # =&gt;  'Foo::Hello'
               my $code        = get_code_ref($fqn);          # =&gt; \&amp;Foo::hello

               uninstall_subroutine('Foo', qw(hello goodby));

               print neat("Hello!\n"); # =&gt; "Hello!\n"
               print neat(3.14);       # =&gt; 3.14
               print neat(undef);      # =&gt; undef

</pre><h4><b>DESCRIPTION</b></h4><pre>
       このモジュールはデータとデータ型のためのユーティリティ関数を提供します。

       ユーティリティはチェック関数群と検証関数群とその他の関数群があります。
       チェック関数群は値の型を調べ，真偽値を返す機能を提供します。
       検証関数群は値の型を調べ，真であればその値自身を返し， 偽であれば致命的エラーとなる機能を提供します。
       その他の関数群は，無名スカラーリファレンスの生成やシンボルテーブルの操作，
       コードリファレンスの操作などの機能を提供します。
       これらユーティリティはいずれもコードの繰り返しを避けるために設計されました。

       このモジュールはXSとPure Perl双方で実装されており，Cコンパイラのある
       環境ではXSバックエンドが，ない環境ではPure Perlバックエンドが使用されます。
       なお，環境変数"DATA_UTIL_PUREPERL"を真に設定することで，強制的にPure Perl
       バックエンドを使用することができます。

       XSバックエンドは注意深く実装されており， Pure Perlバックエンドより2倍から10倍程度高速に動作します。
       実際，XSバックエンドが提供するほぼ全ての関数は，等価のPure Perlコードを
       インラインで展開したコードよりも更に高速です。

       ディストリビューションの<u>benchmark/</u>ディレクトリにベンチマークがあります。

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>Check</b> <b>functions</b>
       チェック関数群は":check"インポートタグによって導入できます。これらはある値
       の型が目的の型であれば真を，そうでなければ偽を返します。

       また，これらの関数はオーバーロードマジックも調べます。たとえば，"${}"が
       オーバーロードされているオブジェクトは，スカラーリファレンスとして扱われます。

       リファレンスの型チェックをする関数は，オブジェクトリファレンスに対しては，
       オーバーロードされていない限り常に偽を返します。
       これは，オブジェクトの実装に依存するコードを書かないようにするためです。

       is_scalar_ref(value)
           スカラーリファレンスかどうかのチェックを行います。

       is_array_ref(value)
           配列リファレンスかどうかのチェックを行います。

       is_hash_ref(value)
           ハッシュリファレンスかどうかのチェックを行います。

       is_code_ref(value)
           コードリファレンスかどうかのチェックを行います。

       is_glob_ref(value)
           グロブリファレンスかどうかのチェックを行います。

       is_regex_ref(value)
           "qr//"によって作られる正規表現かどうかのチェックを行います。

       is_instance(value, class)
           <u>class</u>のインスタンスかどうかのチェックを行います。

           "Scalar::Util::blessed($value) &amp;&amp; $value-&gt;isa($class)"というコードと ほぼ等価です。

           <u>class</u>が未定義値またはリファレンスであれば致命的エラーとなります。

       is_invocant(value)
           <u>value</u>に対してメソッドを起動できるかどうかをチェックします。

       is_value(value)
           <u>value</u>がプリミティブ値かどうかをチェックします。すなわち，定義済みであり，
           リファレンスではなく，型グロブでもなければ真を返します。

           この関数(および"is_string"/is_number()/is_integer())は，
           オブジェクトリファレンスに対しては常に偽を返します。
           たとえ<u>value</u>が文字列化/数値化/真偽値化オーバーロードメソッドを
           持っていたとしても，それはプリミティブ値としては判断しません。

           この関数には検証を行う対応関数がありません。

       is_string(value)
           <u>value</u>がプリミティブ値であり， かつ文字列化したときに1文字以上の内容を持つ値かどうかをチェックします。

           "do{ is_value($value) &amp;&amp; length($value) &gt; 0 }"と同じです。

           この関数には検証を行う対応関数がありません。

       is_number(value)
           <u>value</u>が数値かどうかをチェックします。     ここで<b>数値</b>とは，数値コンテキスト(たとえば"sprintf     '%g',
           $value"）                                                      で警告を出さずに数値に変換可能であり，
           かつPerlプログラム中にリテラルとしておくことができる値という意味です。

           すなわち，この関数はScalar::Util::looks_like_number()と異なり，
           "Infinity"や"NaN"はリテラルとしてプログラム中に置くことはできないため，
           数値として扱いません。また，数値化したときに警告を出さない例外である              "0              but
           true"も同じ理由で数値として扱いません。

           この関数には検証を行う対応関数がありません。

       is_integer(value)
           <u>value</u>が整数かどうかをチェックします。これはis_number()の判定に加えて，
           整数値かどうかをチェックします。

           この関数には検証を行う対応関数がありません。

   <b>Validating</b> <b>functions</b>
       検証関数は":validate"タグによって導入できます。これらはチェック関数と      同じ方法でチェックを行います。
       ただし，その結果が真であれば第一引数をそのまま返し， 偽であれば致命的エラーとなります。

       これらの関数もオーバーロードマジックを考慮します。

       scalar_ref(value)
           スカラーリファレンスかどうかの検証を行います。

       array_ref(value)
           配列リファレンスかどうかの検証を行います。

       hash_ref(value)
           ハッシュリファレンスかどうかの検証を行います。

       code_ref(value)
           コードリファレンスかどうかの検証を行います。

       glob_ref(value)
           グロブリファレンスかどうかの検証を行います。

       regex_ref(value)
           "qr//"によって作られる正規表現かどうかの検証を行います。

       instance(value, class)
           <u>class</u>のインスタンスかどうかの検証を行います。

           <u>class</u>が未定義値またはリファレンスであれば致命的エラーとなります。

       invocant(value)
           <u>value</u>に対してメソッドを起動できるかどうかの検証を行います。

           <u>value</u>がクラス名である場合，そのクラス名を正規化した文字列を返します。
           すなわち，"::Foo"や"main::Foo"を与えると"Foo"を返します。

   <b>Micellaneous</b> <b>utilities</b>
       その他，個別にインポートできるいくつかのユーティリティ関数があります。

       <b>anon_scalar()</b>
           "undef"を参照する匿名スカラーリファレンスを生成します。

       anon_scalar(value)
           <u>value</u>のコピーを参照する匿名スカラーリファレンスを生成します。

           これは"do{ my $tmp = $value; \$value; }"というコードと等価です。

       neat(value)
           <u>value</u>を表示に適するよう整形した文字列を返します。  "do{  defined($value)  ?  qq{"$value"}  :  'undef'
           }"を置き換える機能 として提供されますが，より高機能です。

       get_stash(invocant)
           <u>invocant</u>のスタッシュ <b>stash</b>，つまりシンボルテーブルハッシュが 存在すれば，そのスタッシュを返します。

           <u>invocant</u>がオブジェクトリファレンスであれば，そのオブジェクトのパッケージの スタッシュを返します。

           <u>invocant</u>がパッケージ名であり，そのパッケージが既に存在すれば， そのパッケージのスタッシュを返します。

       install_subroutine(package, name =&gt; subr [, ...])
           サブルーチン<u>subr</u>を<u>package</u>に<u>name</u>としてインストールします。

           "do{     no     strict     'refs';     *{$package.'::'.$name}     =     \&amp;subr;      }"というコードと
           ほぼ等価です。さらに，<u>subr</u>が匿名サブルーチンであれば，<u>package</u>に
           名前付きサブルーチン<u>&amp;package::name</u>として命名します(ただし，Pure
           Perl版のコードでは匿名サブルーチンの命名は行いません)。

           サブルーチンを再インストールするときは，"no warnings 'redefine'" ディレクティブを使ってください。

                   no warnings 'redefine';
                   install_subrouitne($package, $name =&gt; $subr);

           <u>package</u>か<u>name</u>が未定義値またはリファレンスであれば致命的エラーとなります。
           <u>subr</u>がコードリファレンスでないときも致命的エラーとなりますが， オーバーロードマジックは考慮されます。

           この関数は"no                                                                                  strict
           'refs'"を必要としないため，<b>strict無効化の誤謬</b>を犯す危険性がありません。strict無効化の誤謬とは，以下のような状況を指します。

                   my $property = ...;
                   # ...

                   no strict 'refs';
                   # simple read-only accessor
                   *{$pkg . '::' . $sub_name} = sub{
                           my($self) = @_;
                           return $self-&gt;{$property};
                   }

           これはオブジェクトのプロパティを参照するアクセサを生成するコードです。このアクセサは，正しく使う限りでは問題はありません。
           しかし，このアクセサをクラスメソッドとして呼び出すと，問題が顕在化します。
           つまりそのとき$selfに入っているのはクラスを表す文字列であり，
           "$self-&gt;{$property}"というコードはシンボリックリファレンスと解釈され，
           このアクセサが定義されたパッケージのグローバル変数としてデリファレンスされます。
           これは多くの場合，単に"undef"を返すだけでしょう。                    "&lt;use                     strict
           'refs'"&gt;はまさにこのような誤ったシンボリックリファレンスの
           デリファレンスを検出するために用意されている機能なのですが，ここではその恩恵を
           得ることができず，デバッグの難しいコードを生成してしまいます。

           このケースでstrictの恩恵を得るためには，以下のように無名関数内で再度                             "use
           strict"を有効にする必要があります。

                   no strict 'refs';
                   *{$pkg . '::' . $sub_name} = sub{
                           use strict 'refs';
                           my($self) = @_;
                           return $self-&gt;{$property};
                   }

           そこで，install_subroutine()を使うとも"strict"を使用する必要がなくなります。

                   install_subroutine $pkg =&gt; (
                           $sub_name =&gt; sub{
                                   my($self) = @_;
                                   return $self-&gt;{$property};
                           },
                   );

           このstrict無効化の誤謬については，"18.10"    in     "Perlベストプラクティス"     <u>「制約の無効化</u>     <u>-</u>
           <u>制約または警告を無効にする場合は，明示的に，段階的に，最も狭いスコープで行う」</u> に解説があります。

       uninstall_subroutine(package, name [=&gt; code], ...)
           サブルーチン<u>name</u>をパッケージ<u>package</u>から削除します。

           "undef                                          &amp;subr"が&amp;subrを未定義にして型グロブのコードスロットを
           そのままにするのに対して，"uninstall_subroutine"は型グロブを
           シンボルテーブルから削除し，コードスロットを以外の値をシンボルテーブルに                   戻します。
           この挙動は"namespace::clean"や"constant::lexical"を実現するためのものです。

           <u>name</u>に対して<u>code</u>が与えられている場合は，&amp;package::nameが<u>code</u>である
           場合のみ削除します。すなわち，以下の二つのコードは等価です。

                   uninstall_subroutine($pkg, $name) if \&amp;{$pkg . '::' . $name} == $code;
                   uninstall_subroutine($pkg, $name =&gt; $code);

           この関数はSub::Delete::delete_sub()と同じアルゴリズムに基づいていますが，
           複数のサブルーチンを一度に削除できます。

       get_code_info(subr)
           サブルーチン<u>subr</u>のパッケージと名前のペアを返します。
           これはSub::Identify::get_code_info()とほぼ同じ機能です。
           ただし，スカラーコンテキストでは完全修飾名を返します。

           <u>subr</u>の名前が不明なときは，リストコンテキストでは空リストを，
           スカラーコンテキストでは"undef"を返します。

       get_code_ref(package, name)
           <u>\&amp;package::name</u>が存在すれば，それを返します。  これは"do{  no  strict  'refs';  *{$package  .  '::' .
           $name}{CODE} }" に似ていますが，<u>\&amp;package::name</u>が存在しない場合でも <u>*package::name</u>を生成しません。

           第三引数として"-create"を与えると，<u>\&amp;package::name</u>が存在しなくても   スタブを生成してそれを返します。
           これは"do{ no strict 'refs'; \&amp;{$package . '::' . $name} }"と同じです。

       curry(subr, args and/or placeholders)
           サブルーチン<u>subr</u>のカリー化を行います。 つまり特定の引数を固定したクロージャを生成します。

           <u>args</u>               <u>and/or</u>              <u>placeholders</u>には，固定する引数か，カリー化サブルーチンの引数に
           置き換えられるプレースホルダを渡します。プレースホルダには，添え字<u>x</u>を参照
           する"\x"と，"\x"で参照した最大の添え字の以降の引数リストを参照する *_があります。

           たとえば，以下の$closureと$curriedは同じ機能を持つサブルーチンとなります。

                   my $class = 'Foo';
                   $closure = sub{ is_instance($_[0], $class) };
                   $curried = curry \&amp;is_instance, \0, $class;

                   $closure = sub{ install_subroutine($class, @_) };
                   $curried = curry \&amp;install_subroutine, $class, *_;

           なお，*_は"\x"で参照しなかった引数リストではないので注意してください。  たとえば，"curry(\&amp;subr,  *_,
           \1)-&gt;(0,            1,           2,           3)"というカリー化では，           "subr(2,           3,
           1)"が呼び出され，カリー化されたサブルーチンに与えられた $_[0](つまり0)が無視されます。

           カリー化はクロージャよりも生成・呼び出しが高速です。

           より詳しいサンプルコードがData::Util::Curryにあります。

       modify_subroutine(subr, modifier_type =&gt; [subroutines], ...)
           サブルーチン<u>subr</u>を<u>modifier_type</u>にしたがって<u>subroutines</u>で修飾し，
           無名関数<u>modified_subr</u>として返します。

           <u>modifier_type</u>には"before",                    "around",                     "after"があり，"before"は
           <u>subr</u>の呼び出し前に，"after"は<u>subr</u>の呼出し後に，<u>modified_subr</u>に
           与えられた引数で呼び出されます。"before"と"after"の戻り値は捨てられます。
           "around"は<u>subr</u>の入出力をフィルタリングするための修飾子です。

           その際，呼び出順は，"before"と"around"は後で定義されたものが先に呼び出され
           (last-defined-first-called)，"after"は先に定義されたものが先に呼び出されます(first-defined-first-called)。この呼び出し順はsubroutine_modifier()でも同じ
           です。

           たとえば：

                   $modified = modify_subroutine(\&amp;foo, around =&gt; [sub{
                           my $next = shift;
                           do_something();
                           goto &amp;{$next}; # continuation
                   }]);
                   $modified-&gt;();

                   $modified = modify_subroutine(\&amp;foo,
                           before =&gt; \@befores,
                           around =&gt; \@arounds,
                           after  =&gt; \@afters,
                   );
                   $modified-&gt;();

           XSによる実装では，サブルーチン修飾子のコストが非常に安くなっています。

           このディストリビューションに付属している<u>example/lib/Method/Modifiers.pm</u>
           (modify_subroutine()/subroutine_modifier()のデモ)のベンチマーク
           <u>benchmark/methext_bench.pl</u>によれば，メソッド修飾のコストはほぼ次のようになります：

                   with before modifier: 100% slower
                   with after  modifier: 100% slower
                   with around modifier: 200% slower

           特に，"before"と"after"は"SUPER::"疑似クラスによってメソッドを拡張するよりも高速です。

           各修飾子については，"Method               Modifiers"              in              Class::MOP::Classに
           詳しい解説があります。Class::Method::Modifiersにも解説があります。
           このモジュールが提供するAPIはこれらのモジュールより低水準ですが， 機能には互換性があります。

       subroutine_modifier(modified, modifier_type =&gt; subroutines, ...)
           modify_subroutine()で生成した<u>modified</u>を操作します。

           引数を<u>modified</u>のみ渡した場合は，その<u>modified</u>がmodify_subroutine()で
           生成されたものかどうかを示す真偽値を返します。

                   if(subroutine_modifier $subr){
                           # $subrは修飾子つきサブルーチン
                   }

           <u>modified</u>と<u>modifier_type</u>("before",                         "around",                          "after")
           を渡すと，その<u>modifier_type</u>に応じた修飾関数を返します。

                   @befores = subroutine_modifier $modified, 'before';

           このほか，更に関数のリストを渡した場合には，<u>modified</u>の<u>modifier_type</u>に その関数を追加します。

                   subroutine_modifier $modified, before =&gt; @befores;

       mkopt(input, moniker, require_unique, must_be)
           <u>input</u>を元に名前と値のペア配列からなる配列リファレンスを作成します。

           これはData::OptList::mkopt()に似ています。それに加えて，<u>must_be</u>は
           名前と型のペアからなるハッシュリファレンスでもかまいません。

           For example:

                   $array_ref = mkopt([qw(foo bar), baz =&gt; [42]], 'moniker');
                   # $array_ref == [ [foo =&gt; undef], [bar =&gt; undef], baz =&gt; [42] ]

       mkopt_hash(input, moniker, must_be)
           <u>input</u>を元にハッシュリファレンスを作成します。

           これはData::OptList::mkopt_hash()に似ています。それに加えて，<u>must_be</u>は
           名前と型のペアからなるハッシュリファレンスでもかまいません。

           For example:

                   $hash_ref = mkopt([qw(foo bar), baz =&gt; [42]], 'moniker');
                   # $hash_ref == { foo =&gt; undef, bar =&gt; undef, baz =&gt; [42] }

   <b>Error</b> <b>handling</b>
       検証関数によって放出される致命的エラーは，"Data::Util::Error"モジュールによって変更することができます。

               package Foo;
               use Data::Util::Error sub{ Foo::InvalidArgument-&gt;throw(@_) };
               use Data::Util qw(:validate);

               # ...

       このエラーハンドラはパッケージ毎に設定され，そのパッケージ内で"Data::Util"が発生させるエラーにはそのエラーハンドラが使われます。

</pre><h4><b>DISCUSSIONS</b></h4><pre>
</pre><h4><b>What</b> <b>is</b> <b>a</b> <b>X-reference?</b></h4><pre>
       「Xのリファレンス」とは何を指すのでしょうか。ここではハッシュリファレンスを例にとって考えます。
       まず，判断要素は以下の3つを想定します。

       1.  "ref($x) eq 'HASH'"

       2.  "Scalar::Util::reftype($x) eq 'HASH'"

       3.  "overload::Method($x, '%{}')"

       ref()は非常に高速なので，実用上はこれで事足りることが多いと思われます。しかし，これはオーバーロードマジックを考慮しません。

       reftype()を使うべきではありません。$xがオブジェクトである場合，オブジェクトの実装型を参照し，カプセル化を壊してしまうことになるからです。

       そして"overload::Method"が捕捉するのは，オブジェクトをある型のリファレンスとみなしてよい特殊なケースです。

       なお，直接$xをハッシュリファレンスとみなして参照すること("$x-&gt;{$key}")は避けるべきです。これは$xがハッシュリファレンスでない場合に正しく致命的エラーを発生させますが，ブレスされたハッシュリファレンスのときにはアクセスが成功します。しかし，そのアクセスの成功はオブジェクトの実装に依存しています。

       さて，それではis_hash_ref()は何を調べればいいのでしょうか。回答の一つは"Params::Util"が示しています。Version
       0.35の時点では，"P::U::_HASH"は(1)を，"P::U::_HASHLIKE"は(2)と(3)をチェックします。しかし先に述べたように，(1)は高速ですがオーバーロードマジックを考慮しないので不完全であり，(2)はオブジェクトのカプセル化を壊すため使うべきではありません。このように考えると，is_hash_ref()は(1)と(3)によるチェックを行うのが正しい実装ということになります。

       したがって，is_hash_ref()ではref()とoverload::Method()を使ってリファレンスの型を調べます。is_scalar_ref()，is_array_ref()，is_code_ref()，is_glob_ref()も同様です。

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
   <b>DATA_UTIL_PUREPERL</b>
       真であれば，Pure Perl版のバックエンドが使われます。

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       Perl 5.10 or later.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       No bugs have been reported.

       Please report any bugs or feature requests to the author.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       overload.

       Scalar::Util.

       Class::MOP.

       このモジュールのいくつかの機能は以下のモジュールの機能をXSに移植して
       最適化したものであり，またいくつかはそれに加えて更に拡張を施したものです。

       Params::Util.

       Sub::Install.

       Sub::Identify.

       Sub::Delete.

       Sub::Curry.

       Class::Method::Modifiers.

       Data::OptList.

</pre><h4><b>AUTHOR</b></h4><pre>
       Goro Fuji (gfx) &lt;gfuji(at)cpan.org&gt;

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2008-2009, Goro Fuji (gfx) &lt;gfuji(at)cpan.org&gt;. Some rights reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2024-10-20                                <u>Data::Util::<a href="../man3pm/JA.3pm.html">JA</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>