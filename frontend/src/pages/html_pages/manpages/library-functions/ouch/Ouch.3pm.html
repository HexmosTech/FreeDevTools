<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ouch - Exceptions that don't hurt.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libouch-perl">libouch-perl_0.0501-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Ouch - Exceptions that don't hurt.

</pre><h4><b>VERSION</b></h4><pre>
       version 0.0501

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Ouch;

        eval { ouch(404, 'File not found.'); };

        if (kiss 404) {
          check_elsewhere();
        }

        say $@;           # These two lines do the
        say $@-&gt;scalar;   # same thing.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Ouch provides a class for exception handling that doesn't require a lot of boilerplate, nor any up front
       definition. If Exception::Class is working for you, great! But if you want something that is faster,
       easier to use, requires less typing, and has no prereqs, but still gives you much of that same
       functionality, then Ouch is for you.

   <b>Why</b> <b>another</b> <b>exception</b> <b>handling</b> <b>module?</b>
       It really comes down to Carp isn't enough for me, and Exception::Class does what I want but makes me type
       way too much. Also, I tend to work on a lot of protocol-based systems that use error codes (HTTP, FTP,
       SMTP, JSON-RPC) rather than error classes, so that feels more natural to me. Consider the difference
       between these:

       <b>Ouch</b>

        use Ouch;
        ouch 404, 'File not found.', 'file';

       <b>Exception::Class</b>

        use Exception::Class (
           'FileNotFound' =&gt; {
               fields  =&gt; [ 'code', 'field' ],
           },
        );
        FileNotFound-&gt;throw( error =&gt; 'File not found.', code =&gt; 404, field =&gt; 'file' );

       And if you want to catch the exception you're looking at:

       <b>Ouch</b>

        if (kiss 404) {
          # do something
        }

       <b>Exception::Class</b>

        my $e;
        if ($e = Exception::Class-&gt;caught('FileNotFound')) {
          # do something
        }

       Those differences may not seem like a lot, but over any substantial program with lots of exceptions it
       can become a big deal.

   <b>Usage</b>
       Most of the time, all you need to do is:

        ouch $code, $message, $data;
        ouch -32700, 'Parse error.', $request; # JSON-RPC 2.0 error
        ouch 441, 'You need to specify an email address.', 'email'; # form processing error
        ouch 'missing_param', 'You need to specify an email address.', 'email';

       You can also go long form if you prefer:

        die Ouch-&gt;new($code, $message, $data);

       If you want to rethrow an Ouch, you can simply "die" it.

        eval { ouch(404, 'File not found.'); } ;
        die $@;

   <b>Functional</b> <b>Interface</b>
       <u>ouch</u>

       Some nice sugar instead of using the object oriented interface.

        ouch 2121, 'Did not do the big thing.';

       code
           An  error  code. An integer or string representing error type. Try to stick to codes used in whatever
           domain you happen to be working in. HTTP Status codes. JSON-RPC error codes, etc.

       message
           A human readable error message.

       data
           Optional. Anything you want to attach to the exception to help a developer catching it decide what to
           do. For example, if you're doing form processing, you might want this to be the  name  of  the  field
           that caused the exception.

           <b>WARNING:</b>  Do  not include objects or code refs in your data. This should only be stuff that is easily
           serializable like scalars, array refs, and hash refs.

       <u>kiss</u>

       Some nice sugar to trap an Ouch.

        if (kiss $code) {
           # make it go
        }

       code
           The code you're looking for.

       exception
           Optional. If you like you can pass the exception into "kiss". If not, it will just use whatever is in
           $@. You might want to do this if you've saved  the  exception  before  running  another  "eval",  for
           example.

       <u>hug</u>

       Some nice sugar to trap any exception.

        if (hug) {
          # make it stop
        }

       exception
           Optional.  If you like you can pass the exception into "hug". If not, it will just use whatever is in
           $@.

       <u>bleep</u>

       A little sugar to make exceptions human friendly. Returns a  clean  error  message  from  any  exception,
       including an Ouch.

        File not found.

       Rather than:

        File not found. at /Some/File.pm line 63.

       exception
           Optional.  If  you like you can pass the exception into "bleep". If not, it will just use whatever is
           in $@.

       <u>barf</u>

       Calls "bleep", and then exits with error code

       exception
           Optional. You can pass an exception into "barf" which then gets passed to "bleep" otherwise  it  will
           use whatever's in $@

   <b>Object-Oriented</b> <b>Interface</b>
       <u>new</u>

       Constructor for the object-oriented interface. Takes the same parameters as "ouch".

        Ouch-&gt;new($code, $message, $data);

       <u>scalar</u>

       Returns the scalar form of the error message:

        Crap! at /Some/File.pm line 43.

       Just as if you had done:

        die 'Crap!';

       Rather than:

        ouch $code, 'Crap!';

       <u>trace</u>

       Call this if you want the full stack trace that lead up to the ouch.

       <u>hashref</u>

       Returns  a formatted hash reference of the exception, which can be useful for handing off to a serializer
       like JSON.

        {
          code     =&gt; $code,
          message  =&gt; $message,
          data     =&gt; $data,
        }

       <u>code</u>

       Returns the "code" passed into the constructor.

       <u>message</u>

       Returns the "messsage" passed into the constructor.

       <u>data</u>

       Returns the "data" passed into the constructor.

   <b>Try::Tiny</b>
       Many Ouch users like to use Ouch with Try::Tiny.

        use Try::Tiny;
        use Ouch;

        try {
           ouch 404, 'File not found!';
        }
        catch {
           if (kiss(401, $_)) {
               # do something
           }
           else {
               die $_; # rethrow
           }
        };

       Some users are sticks in the mud who can't bring themselves to "ouch" and "kiss". For them, there is  the
       ":trytiny" interface. Here's how it works:

        use Try::Tiny;
        use Ouch qw(:trytiny);

        try {
           throw 404, 'File not found!';
        }
        catch {
           if (caught(401, $_)) {
               # do something
           }
           else {
               die $_; # rethrow
           }
        };

       Using  Try::Tiny has some impedence mismatch in that the exception is propagated through $_ instead of $@
       (the default used by Ouch). This forces to always include $_ when calling functions  in  Ouch,  which  is
       suboptimal. It's possible to do this:

          use Try::Tiny;
          use Ouch qw(:trytiny_var); # use Try::Tiny's variable $_

          try {
             throw 404, 'File not found!';
          }
          catch {
             if (kiss 401) {
                # do something
             }
             else {
                die $_; # rethrow
             }
          };

       i.e. you can use the regular Ouch syntax.

       This  behaviour is localized to the import, i.e. if Ouch is then imported in another place it is possible
       to decide again which is the default exception variable in that specific import:

          package I::Want::Try::Tiny;
          use Try::Tiny;
          use Ouch qw(:trytiny_var);
          # ... $_ is the default exception for kiss, hug, barf, and bleep

          package Gimme::Regular::Ouch;
          use Ouch;
          # ... $@ is the default exception object here

       It's also possible to mix the two approaches, i.e. use both ":trytiny" and ":trytiny_var".

       <u>throw</u>

       See "ouch" for details.

       <u>caught</u>

       See "kiss" for details.

       <u>caught_all</u>

       See "hug" for details.

</pre><h4><b>DEPRECATED</b></h4><pre>
       This functionality is deprecated and will be removed in a future release. Use Try::Tiny instead.

   <b>Traditional</b> <b>Interface</b>
       Some people just can't bring themselves to use the sugary  cuteness  of  Ouch.  For  them  there  is  the
       ":traditional" interface. Here's how it works:

        use Ouch qw(:traditional);

        my $e = try {
          throw 404, 'File not found.';
        };

        if ( catch 404, $e ) {
          # do the big thing
        }
        elsif ( catch_all $e ) {
          # make it stop
        }
        else {
          # make it go
        }

       <b>NOTE:</b>  "try"  also  populates  $@,  and  "catch" and "catch_all" will also use $@ if you don't specify an
       exception.

       <u>try</u>

       Returns an exception. Is basically just a nice wrapper around "eval".

       block
           Try accepts a code ref, anonymous subroutine, or a block.

           <b>NOTE:</b> You need a semi-colon at the end of a "try" block.

       <u>throw</u>

       Works exactly like "ouch". See "ouch" for details.

       <u>catch</u>

       Works exactly like "kiss". See "kiss" for details.

       <u>catch_all</u>

       Works exactly like "hug". See "hug" for details.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       Requires Perl 5.12 or higher.

</pre><h4><b>SUPPORT</b></h4><pre>
       Repository
           &lt;<a href="http://github.com/rizen/Ouch">http://github.com/rizen/Ouch</a>&gt;

       Bug Reports
           &lt;<a href="http://github.com/rizen/Ouch/issues">http://github.com/rizen/Ouch/issues</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       If you're looking for something lighter, check out Carp that ships with Perl. Or if  you're  looking  for
       something heavier check out Exception::Class.

</pre><h4><b>AUTHOR</b></h4><pre>
       JT Smith &lt;jt_at_plainblack_dot_com&gt;

</pre><h4><b>LEGAL</b></h4><pre>
       Ouch  is  Copyright  2011 Plain Black Corporation (&lt;<a href="http://www.plainblack.com">http://www.plainblack.com</a>&gt;) and is licensed under the
       same terms as Perl itself.

perl v5.36.0                                       2022-12-01                                          <u><a href="../man3pm/Ouch.3pm.html">Ouch</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>