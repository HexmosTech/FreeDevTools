<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hpsvx - {hp,sp}svx: factor and solve, expert</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       hpsvx - {hp,sp}svx: factor and solve, expert

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>chpsvx</b> (fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork,
           info)
            <b>CHPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>cspsvx</b> (fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork,
           info)
            <b>CSPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>dspsvx</b> (fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork,
           info)
            <b>DSPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>sspsvx</b> (fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork,
           info)
            <b>SSPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>zhpsvx</b> (fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork,
           info)
            <b>ZHPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>zspsvx</b> (fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork,
           info)
            <b>ZSPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>chpsvx</b> <b>(character</b> <b>fact,</b> <b>character</b> <b>uplo,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>nrhs,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ap,</b>
       <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>afp,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ipiv,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>x,</b> <b>integer</b> <b>ldx,</b> <b>real</b> <b>rcond,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ferr,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>berr,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>rwork,</b> <b>integer</b> <b>info)</b>
        <b>CHPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            CHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
            A = L*D*L**H to compute the solution to a complex system of linear
            equations A * X = B, where A is an N-by-N Hermitian matrix stored
            in packed format and X and B are N-by-NRHS matrices.

            Error bounds on the solution and a condition estimate are also
            provided.

       <b>Description:</b>

            The following steps are performed:

            1. If FACT = 'N', the diagonal pivoting method is used to factor A as
                  A = U * D * U**H,  if UPLO = 'U', or
                  A = L * D * L**H,  if UPLO = 'L',
               where U (or L) is a product of permutation and unit upper (lower)
               triangular matrices and D is Hermitian and block diagonal with
               1-by-1 and 2-by-2 diagonal blocks.

            2. If some D(i,i)=0, so that D is exactly singular, then the routine
               returns with INFO = i. Otherwise, the factored form of A is used
               to estimate the condition number of the matrix A.  If the
               reciprocal of the condition number is less than machine precision,
               INFO = N+1 is returned as a warning, but the routine still goes on
               to solve for X and compute error bounds as described below.

            3. The system of equations is solved for X using the factored form
               of A.

            4. Iterative refinement is applied to improve the computed solution
               matrix and calculate error bounds and backward error estimates
               for it.

       <b>Parameters</b>
           <u>FACT</u>

                     FACT is CHARACTER*1
                     Specifies whether or not the factored form of A has been
                     supplied on entry.
                     = 'F':  On entry, AFP and IPIV contain the factored form of
                             A.  AFP and IPIV will not be modified.
                     = 'N':  The matrix A will be copied to AFP and factored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the Hermitian matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

           <u>AFP</u>

                     AFP is COMPLEX array, dimension (N*(N+1)/2)
                     If FACT = 'F', then AFP is an input argument and on entry
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

                     If FACT = 'N', then AFP is an output argument and on exit
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     If FACT = 'F', then IPIV is an input argument and on entry
                     contains details of the interchanges and the block structure
                     of D, as determined by CHPTRF.
                     If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
                     interchanged and D(k,k) is a 1-by-1 diagonal block.
                     If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
                     columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
                     is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
                     IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
                     interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

                     If FACT = 'N', then IPIV is an output argument and on exit
                     contains details of the interchanges and the block structure
                     of D, as determined by CHPTRF.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     The N-by-NRHS right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,NRHS)
                     If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is REAL
                     The estimate of the reciprocal condition number of the matrix
                     A.  If RCOND is less than the machine precision (in
                     particular, if RCOND = 0), the matrix is singular to working
                     precision.  This condition is indicated by a return code of
                     INFO &gt; 0.

           <u>FERR</u>

                     FERR is REAL array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is REAL array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, and i is
                           &lt;= N:  D(i,i) is exactly zero.  The factorization
                                  has been completed but the factor D is exactly
                                  singular, so the solution and error bounds could
                                  not be computed. RCOND = 0 is returned.
                           = N+1: D is nonsingular, but RCOND is less than machine
                                  precision, meaning that the matrix is singular
                                  to working precision.  Nevertheless, the
                                  solution and error bounds are computed because
                                  there are a number of situations where the
                                  computed solution can be more accurate than the
                                  value of RCOND would suggest.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the Hermitian matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = conjg(aji))
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

   <b>subroutine</b> <b>cspsvx</b> <b>(character</b> <b>fact,</b> <b>character</b> <b>uplo,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>nrhs,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ap,</b>
       <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>afp,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ipiv,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>x,</b> <b>integer</b> <b>ldx,</b> <b>real</b> <b>rcond,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ferr,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>berr,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>rwork,</b> <b>integer</b> <b>info)</b>
        <b>CSPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            CSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
            A = L*D*L**T to compute the solution to a complex system of linear
            equations A * X = B, where A is an N-by-N symmetric matrix stored
            in packed format and X and B are N-by-NRHS matrices.

            Error bounds on the solution and a condition estimate are also
            provided.

       <b>Description:</b>

            The following steps are performed:

            1. If FACT = 'N', the diagonal pivoting method is used to factor A as
                  A = U * D * U**T,  if UPLO = 'U', or
                  A = L * D * L**T,  if UPLO = 'L',
               where U (or L) is a product of permutation and unit upper (lower)
               triangular matrices and D is symmetric and block diagonal with
               1-by-1 and 2-by-2 diagonal blocks.

            2. If some D(i,i)=0, so that D is exactly singular, then the routine
               returns with INFO = i. Otherwise, the factored form of A is used
               to estimate the condition number of the matrix A.  If the
               reciprocal of the condition number is less than machine precision,
               INFO = N+1 is returned as a warning, but the routine still goes on
               to solve for X and compute error bounds as described below.

            3. The system of equations is solved for X using the factored form
               of A.

            4. Iterative refinement is applied to improve the computed solution
               matrix and calculate error bounds and backward error estimates
               for it.

       <b>Parameters</b>
           <u>FACT</u>

                     FACT is CHARACTER*1
                     Specifies whether or not the factored form of A has been
                     supplied on entry.
                     = 'F':  On entry, AFP and IPIV contain the factored form
                             of A.  AP, AFP and IPIV will not be modified.
                     = 'N':  The matrix A will be copied to AFP and factored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the symmetric matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

           <u>AFP</u>

                     AFP is COMPLEX array, dimension (N*(N+1)/2)
                     If FACT = 'F', then AFP is an input argument and on entry
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

                     If FACT = 'N', then AFP is an output argument and on exit
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     If FACT = 'F', then IPIV is an input argument and on entry
                     contains details of the interchanges and the block structure
                     of D, as determined by CSPTRF.
                     If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
                     interchanged and D(k,k) is a 1-by-1 diagonal block.
                     If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
                     columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
                     is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
                     IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
                     interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

                     If FACT = 'N', then IPIV is an output argument and on exit
                     contains details of the interchanges and the block structure
                     of D, as determined by CSPTRF.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     The N-by-NRHS right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,NRHS)
                     If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is REAL
                     The estimate of the reciprocal condition number of the matrix
                     A.  If RCOND is less than the machine precision (in
                     particular, if RCOND = 0), the matrix is singular to working
                     precision.  This condition is indicated by a return code of
                     INFO &gt; 0.

           <u>FERR</u>

                     FERR is REAL array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is REAL array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, and i is
                           &lt;= N:  D(i,i) is exactly zero.  The factorization
                                  has been completed but the factor D is exactly
                                  singular, so the solution and error bounds could
                                  not be computed. RCOND = 0 is returned.
                           = N+1: D is nonsingular, but RCOND is less than machine
                                  precision, meaning that the matrix is singular
                                  to working precision.  Nevertheless, the
                                  solution and error bounds are computed because
                                  there are a number of situations where the
                                  computed solution can be more accurate than the
                                  value of RCOND would suggest.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the symmetric matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = aji)
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

   <b>subroutine</b> <b>dspsvx</b> <b>(character</b> <b>fact,</b> <b>character</b> <b>uplo,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>nrhs,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>ap,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>afp,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ipiv,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b>
       <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>x,</b> <b>integer</b> <b>ldx,</b> <b>double</b> <b>precision</b> <b>rcond,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ferr,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>berr,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>work,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>info)</b>
        <b>DSPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            DSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
            A = L*D*L**T to compute the solution to a real system of linear
            equations A * X = B, where A is an N-by-N symmetric matrix stored
            in packed format and X and B are N-by-NRHS matrices.

            Error bounds on the solution and a condition estimate are also
            provided.

       <b>Description:</b>

            The following steps are performed:

            1. If FACT = 'N', the diagonal pivoting method is used to factor A as
                  A = U * D * U**T,  if UPLO = 'U', or
                  A = L * D * L**T,  if UPLO = 'L',
               where U (or L) is a product of permutation and unit upper (lower)
               triangular matrices and D is symmetric and block diagonal with
               1-by-1 and 2-by-2 diagonal blocks.

            2. If some D(i,i)=0, so that D is exactly singular, then the routine
               returns with INFO = i. Otherwise, the factored form of A is used
               to estimate the condition number of the matrix A.  If the
               reciprocal of the condition number is less than machine precision,
               INFO = N+1 is returned as a warning, but the routine still goes on
               to solve for X and compute error bounds as described below.

            3. The system of equations is solved for X using the factored form
               of A.

            4. Iterative refinement is applied to improve the computed solution
               matrix and calculate error bounds and backward error estimates
               for it.

       <b>Parameters</b>
           <u>FACT</u>

                     FACT is CHARACTER*1
                     Specifies whether or not the factored form of A has been
                     supplied on entry.
                     = 'F':  On entry, AFP and IPIV contain the factored form of
                             A.  AP, AFP and IPIV will not be modified.
                     = 'N':  The matrix A will be copied to AFP and factored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the symmetric matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

           <u>AFP</u>

                     AFP is DOUBLE PRECISION array, dimension (N*(N+1)/2)
                     If FACT = 'F', then AFP is an input argument and on entry
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

                     If FACT = 'N', then AFP is an output argument and on exit
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     If FACT = 'F', then IPIV is an input argument and on entry
                     contains details of the interchanges and the block structure
                     of D, as determined by DSPTRF.
                     If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
                     interchanged and D(k,k) is a 1-by-1 diagonal block.
                     If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
                     columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
                     is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
                     IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
                     interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

                     If FACT = 'N', then IPIV is an output argument and on exit
                     contains details of the interchanges and the block structure
                     of D, as determined by DSPTRF.

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,NRHS)
                     The N-by-NRHS right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is DOUBLE PRECISION array, dimension (LDX,NRHS)
                     If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is DOUBLE PRECISION
                     The estimate of the reciprocal condition number of the matrix
                     A.  If RCOND is less than the machine precision (in
                     particular, if RCOND = 0), the matrix is singular to working
                     precision.  This condition is indicated by a return code of
                     INFO &gt; 0.

           <u>FERR</u>

                     FERR is DOUBLE PRECISION array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is DOUBLE PRECISION array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (3*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, and i is
                           &lt;= N:  D(i,i) is exactly zero.  The factorization
                                  has been completed but the factor D is exactly
                                  singular, so the solution and error bounds could
                                  not be computed. RCOND = 0 is returned.
                           = N+1: D is nonsingular, but RCOND is less than machine
                                  precision, meaning that the matrix is singular
                                  to working precision.  Nevertheless, the
                                  solution and error bounds are computed because
                                  there are a number of situations where the
                                  computed solution can be more accurate than the
                                  value of RCOND would suggest.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the symmetric matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = aji)
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

   <b>subroutine</b> <b>sspsvx</b> <b>(character</b> <b>fact,</b> <b>character</b> <b>uplo,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>nrhs,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ap,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>afp,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ipiv,</b> <b>real,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b> <b>real,</b>
       <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>x,</b> <b>integer</b> <b>ldx,</b> <b>real</b> <b>rcond,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ferr,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>berr,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>info)</b>
        <b>SSPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            SSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
            A = L*D*L**T to compute the solution to a real system of linear
            equations A * X = B, where A is an N-by-N symmetric matrix stored
            in packed format and X and B are N-by-NRHS matrices.

            Error bounds on the solution and a condition estimate are also
            provided.

       <b>Description:</b>

            The following steps are performed:

            1. If FACT = 'N', the diagonal pivoting method is used to factor A as
                  A = U * D * U**T,  if UPLO = 'U', or
                  A = L * D * L**T,  if UPLO = 'L',
               where U (or L) is a product of permutation and unit upper (lower)
               triangular matrices and D is symmetric and block diagonal with
               1-by-1 and 2-by-2 diagonal blocks.

            2. If some D(i,i)=0, so that D is exactly singular, then the routine
               returns with INFO = i. Otherwise, the factored form of A is used
               to estimate the condition number of the matrix A.  If the
               reciprocal of the condition number is less than machine precision,
               INFO = N+1 is returned as a warning, but the routine still goes on
               to solve for X and compute error bounds as described below.

            3. The system of equations is solved for X using the factored form
               of A.

            4. Iterative refinement is applied to improve the computed solution
               matrix and calculate error bounds and backward error estimates
               for it.

       <b>Parameters</b>
           <u>FACT</u>

                     FACT is CHARACTER*1
                     Specifies whether or not the factored form of A has been
                     supplied on entry.
                     = 'F':  On entry, AFP and IPIV contain the factored form of
                             A.  AP, AFP and IPIV will not be modified.
                     = 'N':  The matrix A will be copied to AFP and factored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is REAL array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the symmetric matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

           <u>AFP</u>

                     AFP is REAL array, dimension (N*(N+1)/2)
                     If FACT = 'F', then AFP is an input argument and on entry
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

                     If FACT = 'N', then AFP is an output argument and on exit
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     If FACT = 'F', then IPIV is an input argument and on entry
                     contains details of the interchanges and the block structure
                     of D, as determined by SSPTRF.
                     If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
                     interchanged and D(k,k) is a 1-by-1 diagonal block.
                     If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
                     columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
                     is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
                     IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
                     interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

                     If FACT = 'N', then IPIV is an output argument and on exit
                     contains details of the interchanges and the block structure
                     of D, as determined by SSPTRF.

           <u>B</u>

                     B is REAL array, dimension (LDB,NRHS)
                     The N-by-NRHS right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is REAL array, dimension (LDX,NRHS)
                     If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is REAL
                     The estimate of the reciprocal condition number of the matrix
                     A.  If RCOND is less than the machine precision (in
                     particular, if RCOND = 0), the matrix is singular to working
                     precision.  This condition is indicated by a return code of
                     INFO &gt; 0.

           <u>FERR</u>

                     FERR is REAL array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is REAL array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is REAL array, dimension (3*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, and i is
                           &lt;= N:  D(i,i) is exactly zero.  The factorization
                                  has been completed but the factor D is exactly
                                  singular, so the solution and error bounds could
                                  not be computed. RCOND = 0 is returned.
                           = N+1: D is nonsingular, but RCOND is less than machine
                                  precision, meaning that the matrix is singular
                                  to working precision.  Nevertheless, the
                                  solution and error bounds are computed because
                                  there are a number of situations where the
                                  computed solution can be more accurate than the
                                  value of RCOND would suggest.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the symmetric matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = aji)
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

   <b>subroutine</b> <b>zhpsvx</b> <b>(character</b> <b>fact,</b> <b>character</b> <b>uplo,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>nrhs,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ap,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>afp,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ipiv,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b>
       <b>ldb,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>x,</b> <b>integer</b> <b>ldx,</b> <b>double</b> <b>precision</b> <b>rcond,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>ferr,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>berr,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>rwork,</b> <b>integer</b> <b>info)</b>
        <b>ZHPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            ZHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
            A = L*D*L**H to compute the solution to a complex system of linear
            equations A * X = B, where A is an N-by-N Hermitian matrix stored
            in packed format and X and B are N-by-NRHS matrices.

            Error bounds on the solution and a condition estimate are also
            provided.

       <b>Description:</b>

            The following steps are performed:

            1. If FACT = 'N', the diagonal pivoting method is used to factor A as
                  A = U * D * U**H,  if UPLO = 'U', or
                  A = L * D * L**H,  if UPLO = 'L',
               where U (or L) is a product of permutation and unit upper (lower)
               triangular matrices and D is Hermitian and block diagonal with
               1-by-1 and 2-by-2 diagonal blocks.

            2. If some D(i,i)=0, so that D is exactly singular, then the routine
               returns with INFO = i. Otherwise, the factored form of A is used
               to estimate the condition number of the matrix A.  If the
               reciprocal of the condition number is less than machine precision,
               INFO = N+1 is returned as a warning, but the routine still goes on
               to solve for X and compute error bounds as described below.

            3. The system of equations is solved for X using the factored form
               of A.

            4. Iterative refinement is applied to improve the computed solution
               matrix and calculate error bounds and backward error estimates
               for it.

       <b>Parameters</b>
           <u>FACT</u>

                     FACT is CHARACTER*1
                     Specifies whether or not the factored form of A has been
                     supplied on entry.
                     = 'F':  On entry, AFP and IPIV contain the factored form of
                             A.  AFP and IPIV will not be modified.
                     = 'N':  The matrix A will be copied to AFP and factored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the Hermitian matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

           <u>AFP</u>

                     AFP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     If FACT = 'F', then AFP is an input argument and on entry
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

                     If FACT = 'N', then AFP is an output argument and on exit
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     If FACT = 'F', then IPIV is an input argument and on entry
                     contains details of the interchanges and the block structure
                     of D, as determined by ZHPTRF.
                     If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
                     interchanged and D(k,k) is a 1-by-1 diagonal block.
                     If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
                     columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
                     is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
                     IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
                     interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

                     If FACT = 'N', then IPIV is an output argument and on exit
                     contains details of the interchanges and the block structure
                     of D, as determined by ZHPTRF.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,NRHS)
                     The N-by-NRHS right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX*16 array, dimension (LDX,NRHS)
                     If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is DOUBLE PRECISION
                     The estimate of the reciprocal condition number of the matrix
                     A.  If RCOND is less than the machine precision (in
                     particular, if RCOND = 0), the matrix is singular to working
                     precision.  This condition is indicated by a return code of
                     INFO &gt; 0.

           <u>FERR</u>

                     FERR is DOUBLE PRECISION array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is DOUBLE PRECISION array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, and i is
                           &lt;= N:  D(i,i) is exactly zero.  The factorization
                                  has been completed but the factor D is exactly
                                  singular, so the solution and error bounds could
                                  not be computed. RCOND = 0 is returned.
                           = N+1: D is nonsingular, but RCOND is less than machine
                                  precision, meaning that the matrix is singular
                                  to working precision.  Nevertheless, the
                                  solution and error bounds are computed because
                                  there are a number of situations where the
                                  computed solution can be more accurate than the
                                  value of RCOND would suggest.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the Hermitian matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = conjg(aji))
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

   <b>subroutine</b> <b>zspsvx</b> <b>(character</b> <b>fact,</b> <b>character</b> <b>uplo,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>nrhs,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ap,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>afp,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ipiv,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b>
       <b>ldb,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>x,</b> <b>integer</b> <b>ldx,</b> <b>double</b> <b>precision</b> <b>rcond,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>ferr,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>berr,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>rwork,</b> <b>integer</b> <b>info)</b>
        <b>ZSPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            ZSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
            A = L*D*L**T to compute the solution to a complex system of linear
            equations A * X = B, where A is an N-by-N symmetric matrix stored
            in packed format and X and B are N-by-NRHS matrices.

            Error bounds on the solution and a condition estimate are also
            provided.

       <b>Description:</b>

            The following steps are performed:

            1. If FACT = 'N', the diagonal pivoting method is used to factor A as
                  A = U * D * U**T,  if UPLO = 'U', or
                  A = L * D * L**T,  if UPLO = 'L',
               where U (or L) is a product of permutation and unit upper (lower)
               triangular matrices and D is symmetric and block diagonal with
               1-by-1 and 2-by-2 diagonal blocks.

            2. If some D(i,i)=0, so that D is exactly singular, then the routine
               returns with INFO = i. Otherwise, the factored form of A is used
               to estimate the condition number of the matrix A.  If the
               reciprocal of the condition number is less than machine precision,
               INFO = N+1 is returned as a warning, but the routine still goes on
               to solve for X and compute error bounds as described below.

            3. The system of equations is solved for X using the factored form
               of A.

            4. Iterative refinement is applied to improve the computed solution
               matrix and calculate error bounds and backward error estimates
               for it.

       <b>Parameters</b>
           <u>FACT</u>

                     FACT is CHARACTER*1
                     Specifies whether or not the factored form of A has been
                     supplied on entry.
                     = 'F':  On entry, AFP and IPIV contain the factored form
                             of A.  AP, AFP and IPIV will not be modified.
                     = 'N':  The matrix A will be copied to AFP and factored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the symmetric matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

           <u>AFP</u>

                     AFP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     If FACT = 'F', then AFP is an input argument and on entry
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

                     If FACT = 'N', then AFP is an output argument and on exit
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     If FACT = 'F', then IPIV is an input argument and on entry
                     contains details of the interchanges and the block structure
                     of D, as determined by ZSPTRF.
                     If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
                     interchanged and D(k,k) is a 1-by-1 diagonal block.
                     If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
                     columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
                     is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
                     IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
                     interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

                     If FACT = 'N', then IPIV is an output argument and on exit
                     contains details of the interchanges and the block structure
                     of D, as determined by ZSPTRF.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,NRHS)
                     The N-by-NRHS right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX*16 array, dimension (LDX,NRHS)
                     If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is DOUBLE PRECISION
                     The estimate of the reciprocal condition number of the matrix
                     A.  If RCOND is less than the machine precision (in
                     particular, if RCOND = 0), the matrix is singular to working
                     precision.  This condition is indicated by a return code of
                     INFO &gt; 0.

           <u>FERR</u>

                     FERR is DOUBLE PRECISION array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is DOUBLE PRECISION array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, and i is
                           &lt;= N:  D(i,i) is exactly zero.  The factorization
                                  has been completed but the factor D is exactly
                                  singular, so the solution and error bounds could
                                  not be computed. RCOND = 0 is returned.
                           = N+1: D is nonsingular, but RCOND is less than machine
                                  precision, meaning that the matrix is singular
                                  to working precision.  Nevertheless, the
                                  solution and error bounds are computed because
                                  there are a number of situations where the
                                  computed solution can be more accurate than the
                                  value of RCOND would suggest.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the symmetric matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = aji)
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                               Thu Aug 7 2025 17:26:25                                    <u><a href="../man3/hpsvx.3.html">hpsvx</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>