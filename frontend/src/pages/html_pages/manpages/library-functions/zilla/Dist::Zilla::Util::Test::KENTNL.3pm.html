<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dist::Zilla::Util::Test::KENTNL - KENTNL's DZil plugin testing tool</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdist-zilla-util-test-kentnl-perl">libdist-zilla-util-test-kentnl-perl_1.005014-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Dist::Zilla::Util::Test::KENTNL - KENTNL's DZil plugin testing tool

</pre><h4><b>VERSION</b></h4><pre>
       version 1.005014

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is KENTNL's kit for testing Dist::Zilla.

       Most of his modules should be moving to using the `dztest` model instead which is more flexible source
       side.

</pre><h4><b>METHODS</b></h4><pre>
   <b>"dztest"</b>
       Creates a "Dist::Zilla::Util::Test::KENTNL" object.

       This is a much more sane approach to testing than "test_config"

   <b>test_config</b>
       This is pretty much why this module exists. Its a little perverse, but makes testing WAY easier.

         my $plugin = test_config({
           dist_root =&gt; 'corpus/dist/DZT',
           ini       =&gt; [
             'GatherDir',
             [ 'Prereqs' =&gt; { 'Test::Simple' =&gt; '0.88' } ],
           ],
           post_build_callback =&gt; sub {
               my $config = shift;
               # Handy place to put post-construction test code.
               die $config-&gt;{error} if $config-&gt;{error};
           },
           find_plugin =&gt; 'SomePluginName'
         });

       Additionally, you can add this section

         callback =&gt; {
           method =&gt; 'metadata',
           args   =&gt; [],
           code   =&gt; sub {
             my $data = shift;
             print "Errors ( if any ) $data-&gt;{error} ";
             dump  $data-&gt;{response}; # response from -&gt;metadata
             $data-&gt;{instance}-&gt;doMorestuffbyhand();
             # ok( .... 'good place for a test!' )
           },
         }

       Generally, I find it easier to do 1-off function wrappers, i.e.:

         sub make_plugin {
           my @args = @_;
           return test_config({
               dist_root =&gt; 'corpus/dist/DZT',
               ini =&gt; [
                 'GatherDir',
                 [ 'Prereqs' =&gt; {'Test::Simple' =&gt; '0.88' } ],
                 [ 'FakePlugin' =&gt; {@args } ],
               ],
               post_build_callback =&gt; sub {
                 my $config = shift;
                 die $config-&gt;{error} if $config-&gt;{error};
               },
               find_plugin =&gt; 'FakePlugin',
           });
         }

       Which lets us do

         ok( make_plugin( inherit_version =&gt; 1 )-&gt;inherit_version , 'inherit_verion = 1 propagates' );

       parameters

         my $foo = test_config({
             dist_root =&gt; 'Some/path'    # optional, strongly recommended.
             ini       =&gt; [              # optional, strongly recommended.
                 'BasicPlugin',
                 [ 'AdvancedPlugin' =&gt; { %pluginargs }],
             ],
             build    =&gt; 0/1              # works fine as 0, 1 tells it to call the -&gt;build() method.
             post_build_callback =&gt; sub {
               my ( $conf )  = shift;
               $conf-&gt;{error}    # any errors that occured during construction/build
               $conf-&gt;{instance} # the constructed instance
               # this is called immediately after construction, do what you will with this.
               # mostly for convenience
             },
             find_plugin =&gt; 'Some::Plugin::Name', # makes test_config find and return the plugin that matched that name instead of
                                                  # the config instance

             callback =&gt; {                        # overrides the return value of find_plugin if it is called
               method =&gt; 'method_to_call',
               args   =&gt; [qw( hello world )],
               code   =&gt; sub {
                 my ($conf) = shift;
                 $conf-&gt;{plugin}   # the constructed plugin instance
                 $conf-&gt;{error}    # any errors discovered when calling -&gt;method( args )
                 $conf-&gt;{instance} # the zilla instance
                 $conf-&gt;{response} # the return value of -&gt;method( args )
                 # mostly just another convenience of declarative nature.
                 return someValueHere # this value will be returned by test_config
               }
             },
         });

</pre><h4><b>AUTHOR</b></h4><pre>
       Kent Fredric &lt;<a href="mailto:kentnl@cpan.org">kentnl@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2017 by Kent Fredric &lt;<a href="mailto:kentnl@cpan.org">kentnl@cpan.org</a>&gt;.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.34.0                                       2022-06-13               <u>Dist::Zilla::Util::Test::<a href="../man3pm/KENTNL.3pm.html">KENTNL</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>