<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log::Agent - logging agent</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblog-agent-perl">liblog-agent-perl_1.005-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Log::Agent - logging agent

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Log::Agent;            # in all reusable components
        logerr "error";
        logtrc "notice:12", "notice that" if ...;
        logdie "log and die";

        use Log::Agent;            # in application's main
        logconfig(-prefix =&gt; $0);  # simplest, uses default driver

        use Log::Agent;                    # another more complex example
        require Log::Agent::Driver::File;  # logging made to file
        logconfig(-driver =&gt;
            Log::Agent::Driver::File-&gt;make(
                -prefix      =&gt; $0,
                -showpid     =&gt; 1,
                -channels    =&gt; {
                    'error'  =&gt; "$0.err",
                    'output' =&gt; "$0.out",
                    'debug'  =&gt; "$0.dbg",
                },
            )
        );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "Log::Agent" module provides an abstract layer for logging and tracing, which is independent from the
       actual method used to physically perform those activities. It acts as an agent (hence the name) that
       collects the requests and delegates processing to a sublayer: the logging driver.

       The "Log::Agent" module is meant to be used in all reusable components, since they cannot know in advance
       how the application which ends up using them will perform its logging activities: either by emitting
       messages on stdout and errors on stderr, or by directing messages to logfiles, or by using <b><a href="../man3/syslog.3.html">syslog</a></b>(3).

       The logging interface is common for all the logging drivers, and is therefore the result of a compromise
       between many logging schemes: any information given at this level must be either handled by all drivers,
       or may be ignored depending on the application's final choice.

</pre><h4><b>PRIORITIES</b> <b>AND</b> <b>LEVEL</b></h4><pre>
       The "Log::Agent" module can use both priorities (as defined by <b><a href="../man3/syslog.3.html">syslog</a></b>(3)) or logging levels, or either,
       in which case there is an implicit computation of the missing item (i.e. the level 4, for instance,
       corresponds to the "warning" priority, and vice-versa).  See Log::Agent::Priorities for more details.

       A logging level is defined as being a threshold: any level lesser than or equal to that threshold will be
       logged.

       At the "Log::Agent" level, it is possible to define a trace level and a debug level. Only the messages
       below those levels (inclusive) will be handed out to the underlying driver for logging. They are used by
       the <b>logtrc()</b> and <b>logdbg()</b> routines, respectively.

</pre><h4><b>CHANNELS</b></h4><pre>
       The "Log::Agent" class defines three logging channels, which are "error", "output" and "debug". Depending
       on the driver used for logging, those channels are ignored (typically with <b>syslog()</b>) or may be implicitly
       defined (default logging, i.e. the one achieved by the "Log::Agent::Driver::Default" driver, remaps
       "error" and "debug" to stderr, "output" to stdout).

</pre><h4><b>INTERFACE</b></h4><pre>
       Anywhere a <u>message</u> is expected, it can be a single string, or a <b>printf()</b>-like format string followed by
       the required arguments. The special macro %m is handled directly by "Log::Agent" and is replaced by the
       string version of $!, which is the last error message returned by the last failing system call.

       <b>NOTE</b>: There should not be any trailing "\n" in the <u>message</u> strings, nor any embededed one, although this
       is not enforced. Remember that the main purpose of "Log::Agent" is to specify logging messages in a
       standard way!  Therefore, most of the time, a "should" should be read as "must" and "should not" as "must
       not", which is the strongest interdiction form available in English, as far as I know.

       Here are valid <u>message</u> examples:

           "started since $time"
           "started since %s", $time
           "fork: %m"

       The following logging interface is made available to modules:

       logdbg <u>priority</u>, <u>message</u>
           Debug logging of <u>message</u> to the "debug" channel.

           You  may  specify  any priority you want, i.e.  a "debug" priority is not enforced here. You may even
           specify "notice:4" if you wish, to have the message logged if the debug level is set to  4  or  less.
           If handed over to <b><a href="../man3/syslog.3.html">syslog</a></b>(3), the message will nonetheless be logged at the "notice" priority.

       logtrc <u>priority</u>, <u>message</u>
           Trace logging of <u>message</u> to the "output" channel.

           Like  <b>logdbg()</b>  above, you are not restricted to the "info" priority. This routine checks the logging
           level (either explicit as in "info:14" or implicit as in "notice") against the trace level.

       logdebug <u>message</u>
           Log the message at the "debug" priority to the "output" channel.

           The difference with <b>logdbg()</b> is twofold: logging is done on the "output"  channel,  not  the  "debug"
           one, and the priority is implicit.

       loginfo <u>message</u>
           Log the message at the "info" priority to the "output" channel.

       logsay <u>message</u>
           Log  the  message  at  the "notice" priority to the "output" channel.  The logging always takes place
           under the default "-trace" settings, but only if the routine is called, naturally.   This  means  you
           can still say:

               logsay "some trace message" if $verbose;

           and control whether the message is emitted by using some external configuration for your module (e.g.
           by adding a -verbose flag to the creation routine of your class).

       logwarn <u>message</u>
           Log a warning message at the "warning" priority to the "error" channel.

       logcarp <u>message</u>
           Same  as  <b>logwarn()</b>, but issues a <b>Carp::<a href="../man3/carp.3.html">carp</a></b>(3) call instead, which will warn from the perspective of
           the routine's caller.

       logcluck <u>message</u>
           Same as <b>logwarn()</b>, but dumps a full stacktrace as well.

       logerr <u>message</u>
           Log an error message at the "error" priority to the "error" channel.

       logdie <u>message</u>
           Log a fatal message at the "critical" priority to the "error" channel, and then dies.

       logconfess <u>message</u>
           Same as <b>logdie()</b>, but issues a <b>Carp::<a href="../man3/confess.3.html">confess</a></b>(3) call  instead.   It  is  possible  to  configure  the
           "Log::Agent"  module  via the "-confess" switch to automatically redirect a <b>logdie()</b> to <b>logconfess()</b>,
           which is invaluable during unit testing.

       logcroak <u>message</u>
           Same as <b>logdie()</b>, but issues a  <b>Carp::<a href="../man3/croak.3.html">croak</a></b>(3)  call  instead.   It  is  possible  to  configure  the
           "Log::Agent" module via the "-confess" switch to automatically redirect a <b>logcroak()</b> to <b>logconfess()</b>,
           which is invaluable during unit testing.

       Log::Agent::inited
           Returns true when "Log::Agent" was initialized, either explicitly via a <b>logconfig()</b> or implicitly via
           any <b>logxxx()</b> call.

       Modules  sometimes  wish to report errors from the perspective of their caller's caller, not really their
       caller.  The following interface is therefore provided:

       logxcarp <u>offset</u>, <u>message</u>
           Same a <b>logcarp()</b>, but with an additional offset to be applied on the stack.  To warn one level  above
           your caller, set it to 1.

       logxcroak <u>offset</u>, <u>message</u>
           Same  a <b>logcroak()</b>, but with an additional offset to be applied on the stack.  To report an error one
           level above your caller, set it to 1.

       For applications that wish to implement a debug layer on top of "Log::Agent", the  following  routine  is
       provided.   Note  that  it  is not imported by default, i.e. it needs to be explicitly mentioned at "use"
       time, since it is not meant to be used directly under regular usage.

       logwrite <u>channel</u>, <u>priority</u>, <u>message</u>
           Unconditionally write the <u>message</u> at the given <u>priority</u> on  <u>channel</u>.   The  channel  can  be  one  of
           "debug", "error" or "output".

       At  the application level, one needs to commit once and for all about the logging scheme to be used. This
       is done thanks to the <b>logconfig()</b> routine which takes the following switches, in alphabetical order:

       "-caller" =&gt; [ <u>parameters</u> ]
           Request that caller information (relative to the <b>logxxx()</b> call) be part of the log message. The given
           <u>parameters</u> are handed off to the creation routine of  "Log::Agent::Tag::Caller"  and  are  documented
           there.

           I usually say something like:

            -caller =&gt; [ -display =&gt; '($sub/$line)', -postfix =&gt; 1 ]

           which  I  find  informative  enough.  On  occasion, I found myself using more complex sequences.  See
           Log::Agent::Tag::Caller.

       "-confess" =&gt; <u>flag</u>
           When true, all <b>logdie()</b> calls will be automatically masqueraded as <b>logconfess()</b>.

       "-debug" =&gt; <u>priority</u> <u>or</u> <u>level</u>
           Sets the priority threshold (can be expressed as a string or a number, the string being mapped  to  a
           logging level as described above in <b>PRIORITIES</b> <b>AND</b> <b>LEVEL</b>) for <b>logdbg()</b> calls.

           Calls  tagged  with  a level less than or equal to the given threshold will pass through, others will
           return prematurely without logging anything.

       "-driver" =&gt; <u>driver_object</u>
           This switch defines the driver object to be used, which must be an heir of  the  "Log::Agent::Driver"
           class. See <b>Log::Agent::<a href="../man3/Driver.3.html">Driver</a></b>(3) for a list of the available drivers.

       "-level" =&gt; <u>priority</u> <u>or</u> <u>level</u>
           Specifies both "-debug" and "-trace" levels at the same time, to a common value.

       "-prefix" =&gt; <u>name</u>
           Defines  the application name which will be pre-pended to all messages, followed by ": " (a colon and
           a space). Using this switch alone will configure the default driver to use that prefix (stripped down
           to its basename component).

           When a driver object is used, the "-prefix" switch is kept at the "Log::Agent" level only and is  not
           passed to the driver: it is up to the driver's creation routine to request the "-prefix". Having this
           information  in Log::Agent enables the module to die on critical errors with that error prefix, since
           it cannot rely on the logging driver for that, obviously.

       "-priority" =&gt; [ <u>parameters</u> ]
           Request that message priority information be part of the  log  message.   The  given  <u>parameters</u>  are
           handed off to the creation routine of "Log::Agent::Tag::Priority" and are documented there.

           I usually say something like:

                   -priority =&gt; [ -display =&gt; '[$priority]' ]

           which  will  display the whole priority name at the beginning of the messages, e.g. "[warning]" for a
           <b>logwarn()</b> or "[error]" for <b>logerr()</b>.  See Log::Agent::Tag::Priority and Log::Agent::Priorities.

           <b>NOTE</b>: Using "-priority" does not prevent the "-duperr" flag of the file driver to also  add  its  own
           hardwired prefixing in front of duplicated error messages.  The two options act at a different level.

       "-tags" =&gt; [ <u>list</u> <u>of</u> <u>"Log::Agent::Tag"</u> <u>objects</u> ]
           Specifies  user-defined  tags  to be added to each message.  The objects given here must inherit from
           "Log::Agent::Tag" and conform to its interface.  See Log::Agent::Tag for details.

           At runtime, well after <b>logconfig()</b> was issued, it may be desirable to add (or  remove)  a  user  tag.
           Use the "logtags()" routine for this purpose, and iteract directly with the tag list object.

           For  instance,  a  web  module might wish to tag all the messages with a session ID, information that
           might not have been available by the time <b>logconfig()</b> was issued.

       "-trace" =&gt; <u>priority</u> <u>or</u> <u>level</u>
           Same a "-debug" but applies to <b>logsay()</b>, <b>logwarn()</b>, <b>logerr()</b> and <b>logtrc()</b>.

           When unspecified, "Log::Agent" runs at the "notice" level.

       Additional routines, not exported by default, are:

       logtags
           Returns a "Log::Agent::Tag_List" object, which holds all user-defined tags that are to  be  added  to
           each log message.

           The initial list of tags is normally supplied by the application at <b>logconfig()</b> time, via the "-tags"
           argument.   To  add or remove tags after configuration time, one needs direct access to the tag list,
           obtained via this routine.  See Log::Agent::Tag_List for the operations that can be performed.

</pre><h4><b>KNOWN</b> <b>LIMITATIONS</b></h4><pre>
       The following limitations exist in this early version. They might be addressed in future versions if they
       are perceived as annoying limitatons instead of being just documented ones. :-)

       •   A module which calls <b>logdie()</b> may have  its  die  trapped  if  called  from  within  an  <b>eval()</b>,  but
           unfortunately,  the  value  of $@ is unpredictable: it may be prefixed or not depending on the driver
           used. This is harder to fix as one might think of at first glance.

       •   Some drivers lack customization and hardwire a few things that come from my personal taste, like  the
           prefixing  done  when  <u>duperr</u>  is  set  in Log::Agent::Driver::File, or the fact that the "debug" and
           "stderr" channels are merged as one in the Log::Agent::Driver::Default driver.

       •   When using <b>logcroak()</b> or <b>logconfess()</b>, the place where the call was made can still  be  visible  when
           -caller  is  used, since the addition of the caller information to the message is done before calling
           the logging driver.  Is this a problem?

</pre><h4><b>AUTHOR</b></h4><pre>
       Log::Agent was originally authored by Raphael  Manfredi  <u>&lt;<a href="mailto:Raphael_Manfredi@pobox.com">Raphael_Manfredi@pobox.com</a>&gt;</u>  and  is  currently
       maintained by Mark Rogaski <u>&lt;<a href="mailto:mrogaski@cpan.org">mrogaski@cpan.org</a>&gt;</u>.

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (c) 1999-2000 Raphael Manfredi.

       Copyright (c) 2002-2003, 2005, 2013 Mark Rogaski; all rights reserved.

       This  module  is free software.  You can redistribute it and/or modify it under the terms of the Artistic
       License 2.0.

       This program is distributed in the hope that it will be useful, but without any  warranty;  without  even
       the implied warranty of merchantability or fitness for a particular purpose.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>Log::Agent::<a href="../man3/Driver.3.html">Driver</a></b>(3), <b><a href="../man3/Carp.3.html">Carp</a></b>(3).

perl v5.36.0                                       2022-10-15                                         <u><a href="../man3pm/Agent.3pm.html">Agent</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>