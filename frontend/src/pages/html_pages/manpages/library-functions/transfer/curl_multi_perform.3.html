<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>curl_multi_perform - run all transfers until it would block</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       curl_multi_perform - run all transfers until it would block

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       CURLMcode curl_multi_perform(CURLM *multi_handle, int *running_handles);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  function performs transfers on all the added handles that need attention in a non-blocking fashion.
       The easy handles have previously been added to the multi handle with <u><a href="../man3/curl_multi_add_handle.3.html">curl_multi_add_handle</a>(3)</u>.

       When an application has found out there is data available for the multi_handle or a timeout has  elapsed,
       the application should call this function to read/write whatever there is to read or write right now etc.
       <u><a href="../man3/curl_multi_perform.3.html">curl_multi_perform</a>(3)</u>  returns  as soon as the reads/writes are done. This function does not require that
       there actually is any data available for reading or that data can be written, it can be  called  just  in
       case. It stores the number of handles that still transfer data in the second argument's integer-pointer.

       If  the  amount  of <u>running_handles</u> is changed from the previous call (or is less than the amount of easy
       handles you have added to the multi handle), you know that there is one or more transfers less "running".
       You can then call <u><a href="../man3/curl_multi_info_read.3.html">curl_multi_info_read</a>(3)</u> to get information about each  individual  completed  transfer,
       and  that  returned  info  includes  CURLcode and more. If an added handle fails quickly, it may never be
       counted as a running_handle. You could use <u><a href="../man3/curl_multi_info_read.3.html">curl_multi_info_read</a>(3)</u> to track actual status  of  the  added
       handles in that case.

       When  <u>running_handles</u> is set to zero (0) on the return of this function, there is no longer any transfers
       in progress.

       When this function returns error, the state of all transfers are uncertain and they cannot be  continued.
       <u><a href="../man3/curl_multi_perform.3.html">curl_multi_perform</a>(3)</u>  should  not  be  called  again  on  the  same multi handle after an error has been
       returned, unless first removing all the handles and adding new ones.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       int main(void)
       {
         int still_running;
         CURLM *multi = curl_multi_init();
         CURL *curl = curl_easy_init();
         if(curl) {
           curl_multi_add_handle(multi, curl);
           do {
             CURLMcode mc = curl_multi_perform(multi, &amp;still_running);

             if(!mc &amp;&amp; still_running)
               /* wait for activity, timeout or "nothing" */
               mc = curl_multi_poll(multi, NULL, 0, 1000, NULL);

             <a href="../manmc/if.mc.html">if</a>(mc) {
               fprintf(stderr, "curl_multi_poll() failed, code %d.\n", (int)mc);
               break;
             }

           /* if there are still transfers, loop */
           } while(still_running);
         }
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.9.6

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       This function returns a CURLMcode indicating success or error.

       CURLM_OK (0) means everything was OK, non-zero means an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>.

       This function returns errors regarding the whole multi stack. Problems on individual transfers  may  have
       occurred  even  when  this  function  returns  <u>CURLM_OK</u>.  Use  <u><a href="../man3/curl_multi_info_read.3.html">curl_multi_info_read</a>(3)</u>  to figure out how
       individual transfers did.

</pre><h4><b>TYPICAL</b> <b>USAGE</b></h4><pre>
       Most applications use <u><a href="../man3/curl_multi_poll.3.html">curl_multi_poll</a>(3)</u> to make  libcurl  wait  for  activity  on  any  of  the  ongoing
       transfers. As soon as one or more file descriptor has activity or the function times out, the application
       calls <u><a href="../man3/curl_multi_perform.3.html">curl_multi_perform</a>(3)</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/curl_multi_add_handle.3.html">curl_multi_add_handle</a></b>(3),     <b><a href="../man3/curl_multi_cleanup.3.html">curl_multi_cleanup</a></b>(3),     <b><a href="../man3/curl_multi_fdset.3.html">curl_multi_fdset</a></b>(3),    <b><a href="../man3/curl_multi_info_read.3.html">curl_multi_info_read</a></b>(3),
       <b><a href="../man3/curl_multi_init.3.html">curl_multi_init</a></b>(3), <b><a href="../man3/curl_multi_wait.3.html">curl_multi_wait</a></b>(3), <b><a href="../man3/libcurl-errors.3.html">libcurl-errors</a></b>(3)

libcurl                                            2025-06-16                              <u><a href="../man3/curl_multi_perform.3.html">curl_multi_perform</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>