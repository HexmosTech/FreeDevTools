<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>transfer::connect - Connection setup</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       transfer::connect - Connection setup

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>snit</b> <b>?1.0?</b>

       package require <b>transfer::connect</b> <b>?0.3?</b>

       <b>transfer::connect</b> <u>objectName</u> ?<u>options</u>...?

       <u>objectName</u> <b>method</b> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <u>objectName</u> <b>destroy</b>

       <u>objectName</u> <b>connect</b> <u>command</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  package  provides objects holding enough information to enable them to either actively connect to a
       counterpart, or to passively wait for a connection from said counterpart.  I.e.  any  object  created  by
       this  packages  is  always  in  one  of  two complementary modes, called <u>active</u> (the object initiates the
       connection) and <u>passive</u> (the object receives the connection).

       Of the two objects in a connecting pair one has to be configured for <u>active</u> mode, and the other then  has
       to  be  configured  for  <u>passive</u>  mode.  This establishes which of the two partners connects to whom (the
       <u>active</u> to the other), or, who is waiting on  whom  (the  <u>passive</u>  on  the  other).   Note  that  this  is
       completely  independent  of the direction of any data transmission using the connection after it has been
       established.  An active object can, after establishing the connection, either transmit or  receive  data.
       Equivalently the passive object can do the same after the waiting for its partner has ended.

</pre><h4><b>API</b></h4><pre>
   <b>PACKAGE</b> <b>COMMANDS</b>
       <b>transfer::connect</b> <u>objectName</u> ?<u>options</u>...?
              This  command  creates  a  new  connection  object  with  an  associated Tcl command whose name is
              <u>objectName</u>.  This <u>object</u> command is explained in full detail in the sections  <b>Object</b>  <b>command</b>  and
              <b>Object</b> <b>methods</b>. The set of supported <u>options</u> is explained in section <b>Options</b>.

              The  object  command  will  be  created under the current namespace if the <u>objectName</u> is not fully
              qualified, and in the specified namespace otherwise.  The  fully  qualified  name  of  the  object
              command is returned as the result of the command.

   <b>OBJECT</b> <b>COMMAND</b>
       All objects created by the <b>::transfer::connect</b> command have the following general form:

       <u>objectName</u> <b>method</b> ?<u>arg</u> <u>arg</u> <u>...</u>?
              The  method  <b>method</b>  and  its <u>arg</u>'uments determine the exact behavior of the command.  See section
              <b>Object</b> <b>methods</b> for the detailed specifications.

   <b>OBJECT</b> <b>METHODS</b>
       <u>objectName</u> <b>destroy</b>
              This method destroys the object.  This is safe to do for an <u>active</u> object when  a  connection  has
              been  started,  as the completion callback is synchronous.  For a <u>passive</u> object currently waiting
              for its partner to establish the connection however this is not safe and will cause  errors  later
              on, when the connection setup completes and tries to access the now missing data structures of the
              destroyed object.

       <u>objectName</u> <b>connect</b> <u>command</u>
              This  method  starts the connection setup per the configuration of the object. When the connection
              is established the callback <u>command</u> will be invoked with  one  additional  argument,  the  channel
              handle of the socket over which data can be transfered.

              The detailed behaviour of the method depends on the configured mode.

              <u>active</u> The  connection  setup  is  done  synchronously.  The  object waits until the connection is
                     established. The method returns the empty string as its result.

              <u>passive</u>
                     The connection setup is  done  asynchronously.  The  method  returns  immediately  after  a
                     listening  socket  has  been  set up. The connection will be established in the background.
                     The method returns the port number of the listening socket, for  use  by  the  caller.  One
                     important use is the transfer of this information to the counterpart so that it knows where
                     it has to connect to.

                     This  is  necessary  as  the  object  might  have  been configured for port <b>0</b>, allowing the
                     operating system to choose the actual port it will listen on.

                     The listening port is closed  immediately  when  the  connection  was  established  by  the
                     partner, to keep the time interval small within which a third party can connect to the port
                     too.   Even  so it is recommended to use additional measures in the protocol outside of the
                     connect  and  transfer  object  to  ensure  that  a  connection  is  not   used   with   an
                     unidentified/unauthorized  partner One possibility for this is the use of SSL/TLS.  See the
                     option <b>-socketcmd</b> and section <b>Secure</b> <b>connections</b> for information on how to do this.

   <b>OPTIONS</b>
       Connection objects support the set of options listed below.

       <b>-mode</b> <u>mode</u>
              This option specifies the mode the object is in. It is optional and defaults to <b>active</b>  mode.  The
              two possible modes are:

              <b>active</b> In this mode the two options <b>-host</b> and <b>-port</b> are relevant and specify the host and TCP port
                     the object has to connect to. The host is given by either name or IP address.

              <b>passive</b>
                     In this mode the option <b>-host</b> has no relevance and is ignored should it be configured.  The
                     only option the object needs is <b>-port</b>, and it specifies the TCP port on which the listening
                     socket is opened to await the connection from the partner.

       <b>-host</b> <u>hostname-or-ipaddr</u>
              This  option  specifies  the  host  to connect to in <u>active</u> mode, either by name or ip-address. An
              object configured for <u>passive</u> mode ignores this option.

       <b>-port</b> <u>int</u>
              For <u>active</u> mode this option specifies the port the object is expected to connect to.  For  <u>passive</u>
              mode  however  it  is  the  port  where  the  object  creates  the  listening socket waiting for a
              connection. It defaults to <b>0</b>, which allows the OS to choose the actual port to listen on.

       <b>-socketcmd</b> <u>command</u>
              This option allows the user to specify which command to use to open a socket. The  default  is  to
              use the builtin <b>::socket</b>. Any compatible with that command is allowed.

              The  envisioned main use is the specfication of <b>tls::socket</b>. I.e.  this option allows the creation
              of secure transfer channels, without making this package explicitly dependent on the <b>tls</b> package.

              See also section <b>Secure</b> <b>connections</b>.

       <b>-encoding</b> encodingname

       <b>-eofchar</b> eofspec

       <b>-translation</b> transspec
              These options are the same as are recognized by the builtin command <b>fconfigure</b>. They  provide  the
              configuration  to  be  set for the channel between the two partners after it has been established,
              but before the callback is invoked (See method <b>connect</b>).

</pre><h4><b>SECURE</b> <b>CONNECTIONS</b></h4><pre>
       One way to secure connections made by objects of this package is to require  the  package  <b>tls</b>  and  then
       configure the option <b>-socketcmd</b> to force the use of command <b>tls::socket</b> to open the socket.

                  # Load and initialize tls
                  package require tls
                  tls::init -cafile /path/to/ca/cert -keyfile ...

                  # Create a connector with secure socket setup,
                  transfer::connect C -socketcmd tls::socket ...
                  ...

</pre><h4><b>TLS</b> <b>SECURITY</b> <b>CONSIDERATIONS</b></h4><pre>
       This package uses the <b>TLS</b> package to handle the security for <b>https</b> urls and other socket connections.

       Policy  decisions like the set of protocols to support and what ciphers to use are not the responsibility
       of <b>TLS</b>, nor of this  package  itself  however.   Such  decisions  are  the  responsibility  of  whichever
       application  is  using  the package, and are likely influenced by the set of servers the application will
       talk to as well.

       For        example,        in        light        of        the        recent        <u>POODLE</u>        <u>attack</u>
       [<a href="http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html">http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html</a>]  discovered
       by Google many servers will  disable  support  for  the  SSLv3  protocol.   To  handle  this  change  the
       applications  using  <b>TLS</b>  must  be patched, and not this package, nor <b>TLS</b> itself.  Such a patch may be as
       simple as generally activating <b>tls1</b> support, as shown in the example below.

                  package require tls
                  tls::init -tls1 1 ;# forcibly activate support for the TLS1 protocol

                  ... your own application code ...

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category  <u>transfer</u>  of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       active, channel, connection, passive, secure, ssl, tls, transfer

</pre><h4><b>CATEGORY</b></h4><pre>
       Transfer module

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2006-2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 0.3                               <u>transfer::<a href="../man3tcl/connect.3tcl.html">connect</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>