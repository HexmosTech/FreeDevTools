<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ieee1284_nibble_read, ieee1284_compat_write, ieee1284_byte_read, ieee1284_epp_read_data,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libieee1284-3-dev">libieee1284-3-dev_0.2.11-14.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ieee1284_nibble_read, ieee1284_compat_write, ieee1284_byte_read, ieee1284_epp_read_data,
       ieee1284_epp_write_data, ieee1284_epp_read_addr, ieee1284_epp_write_addr, ieee1284_ecp_read_data,
       ieee1284_ecp_write_data, ieee1284_ecp_read_addr, ieee1284_ecp_write_addr - data transfer functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;ieee1284.h&gt;</b>

       <b>ssize_t</b> <b>ieee1284_nibble_read(struct</b> <b>parport</b> <b>*</b><u>port</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b> <b>size_t</b> <u>len</u><b>);</b>

       <b>ssize_t</b> <b>ieee1284_compat_write(struct</b> <b>parport</b> <b>*</b><u>port</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b> <b>size_t</b> <u>len</u><b>);</b>

       <b>ssize_t</b> <b>ieee1284_byte_read(struct</b> <b>parport</b> <b>*</b><u>port</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b> <b>size_t</b> <u>len</u><b>);</b>

       <b>ssize_t</b> <b>ieee1284_epp_read_data(struct</b> <b>parport</b> <b>*</b><u>port</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b> <b>size_t</b> <u>len</u><b>);</b>

       <b>ssize_t</b> <b>ieee1284_epp_write_data(struct</b> <b>parport</b> <b>*</b><u>port</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b> <b>size_t</b> <u>len</u><b>);</b>

       <b>ssize_t</b> <b>ieee1284_epp_read_addr(struct</b> <b>parport</b> <b>*</b><u>port</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b> <b>size_t</b> <u>len</u><b>);</b>

       <b>ssize_t</b> <b>ieee1284_epp_write_addr(struct</b> <b>parport</b> <b>*</b><u>port</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b> <b>size_t</b> <u>len</u><b>);</b>

       <b>ssize_t</b> <b>ieee1284_ecp_read_data(struct</b> <b>parport</b> <b>*</b><u>port</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b> <b>size_t</b> <u>len</u><b>);</b>

       <b>ssize_t</b> <b>ieee1284_ecp_write_data(struct</b> <b>parport</b> <b>*</b><u>port</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b> <b>size_t</b> <u>len</u><b>);</b>

       <b>ssize_t</b> <b>ieee1284_ecp_read_addr(struct</b> <b>parport</b> <b>*</b><u>port</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b> <b>size_t</b> <u>len</u><b>);</b>

       <b>ssize_t</b> <b>ieee1284_ecp_write_addr(struct</b> <b>parport</b> <b>*</b><u>port</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>buffer</u><b>,</b> <b>size_t</b> <u>len</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This set of functions is for tranferring bytes in the relevant transfer mode. For ECP and EPP modes two
       types of transfer are possible: data and address (usually referred to as channel in ECP).

       The supplied <u>port</u> must be a claimed port.

       The supplied <u>buffer</u> must be at least <u>len</u> bytes long. When reading, the transferred data is stored in the
       buffer; when writing the data to be transferred is taken from the buffer.

       For reads (peripheral to host): if no data is available and <b>F1284_NONBLOCK</b> is not in effect, the
       inactivity timer is started. If data becomes available before the inactivity time-out elapses it is read;
       otherwise the return value will be <b>E1284_TIMEDOUT</b>.

       For writes (host to peripheral): if the peripheral is not willing to accept data and <b>F1284_NONBLOCK</b> is
       not in effect, the inactivity timer is started. If the peripheral indicates that it is willing to accept
       data before the inactivity time-out elapses it is sent; otherwise the return value will be <b>E1284_TIMEDOUT</b>

       The <u>flags</u> may alter the behaviour slightly:

       <b>F1284_NONBLOCK</b>
           For reads (peripheral to host): if no data is available, return immediately (with <b>E1284_TIMEDOUT</b>).

           For writes (host to peripheral): if the peripheral is not willing to accept data, return immediately
           (with <b>E1284_TIMEDOUT</b>).

       <b>F1284_SWE</b>
           Don't use hardware assistance for the transfer, but instead set the parallel port pins according to
           the wire protocol.

       <b>F1284_RLE</b> (for ECP only)
           Use run length encoding. If the peripheral is in ECP mode with RLE, calls to <b>ieee1284_ecp_read_data</b>
           <u>must</u> set this flag in order for the RLE from the peripheral to be interpreted correctly, and calls to
           <b>ieee1284_ecp_write_data</b> <u>may</u> set this flag in order to take advantage of RLE.

       <b>F1284_FASTEPP</b> (for EPP only)
           Use multi-byte transfers. Several bytes at a time are transferred using hardware assistance, if
           supporting hardware is present. The price of this increased speed is that the return value will be
           less reliable when this flag is used.

       For ECP mode, a given direction is in force at any particular time, and it is up to the application to
       ensure that it is only writing when in forward mode, and reading when in reverse mode.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The return value is the number of bytes successfully transferred or, if negative, one of:

       <b>E1284_NOTIMPL</b>
           This transfer mode and flags combination is not yet implemented in libieee1284.

       <b>E1284_TIMEDOUT</b>
           Timed out waiting for peripheral to handshake.

       <b>E1284_NOMEM</b>
           Not enough memory is available.

       <b>E1284_SYS</b>
           There was a problem at the operating system level. The global variable <u>errno</u> has been set
           appropriately.

       <b>E1284_INVALIDPORT</b>
           The <u>port</u> parameter is invalid (for instance, perhaps the <u>port</u> is not claimed).

       If any bytes are successfully transferred, that number is returned. An error is returned only if no bytes
       are transferred.

       For host-to-peripheral transfers, all data is at the peripheral by the time the call returns.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/ieee1284_ecp_fwd_to_rev.3.html">ieee1284_ecp_fwd_to_rev</a></b>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>Tim</b> <b>Waugh</b> &lt;<a href="mailto:twaugh@redhat.com">twaugh@redhat.com</a>&gt;
           Author.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright Â© 2001-2003 Tim Waugh

                                                   09/18/2007                               <u><a href="../man3/IEEE1284_TRANSFER.3.html">IEEE1284_TRANSFER</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>