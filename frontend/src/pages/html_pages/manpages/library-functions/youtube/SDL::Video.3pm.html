<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDL::Video - Bindings to the video category in SDL API</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsdl-perl">libsdl-perl_2.548-5build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SDL::Video - Bindings to the video category in SDL API

</pre><h4><b>CATEGORY</b></h4><pre>
       Core, Video

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use SDL;
        use SDL::Video;
        use SDL::Surface;
        use SDL::Rect;

        # the size of the window box or the screen resolution if fullscreen
        my $screen_width   = 800;
        my $screen_height  = 600;

        SDL::init(SDL_INIT_VIDEO);

        # setting video mode
        my $screen_surface = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_ANYFORMAT);

        # drawing something somewhere
        my $mapped_color   = SDL::Video::map_RGB($screen_surface-&gt;format(), 0, 0, 255); # blue
        SDL::Video::fill_rect($screen_surface,
                              SDL::Rect-&gt;new($screen_width / 4, $screen_height / 4,
                                             $screen_width / 2, $screen_height / 2), $mapped_color);

        # update an area on the screen so its visible
        SDL::Video::update_rect($screen_surface, 0, 0, $screen_width, $screen_height);

        <a href="../man5/sleep.5.html">sleep</a>(5); # just to have time to see it

</pre><h4><b>CONSTANTS</b></h4><pre>
       The constants are exported by default. You can avoid this by doing:

        use SDL::Video ();

       and access them directly:

        SDL::Video::SDL_SWSURFACE;

       or by choosing the export tags below:

       Export tag: ':surface'

        SDL_ASYNCBLIT       Use asynchronous blit if possible
        SDL_SWSURFACE       Stored in the system memory.
        SDL_HWSURFACE       Stored in video memory

       Export tag: ':video'

        SDL_ANYFORMAT       Allow any pixel-format
        SDL_HWPALETTE       Have an exclusive palette
        SDL_DOUBLEBUF       Double buffered
        SDL_FULLSCREEN      Full screen surface
        SDL_OPENGL          Have an OpenGL context
        SDL_OPENGLBLIT      Support OpenGL blitting.
                            NOTE: This option is kept for compatibility only, and is not recommended for new code.
        SDL_RESIZABLE       Resizable surface
        SDL_NOFRAME         No window caption or edge frame
        SDL_HWACCEL         Use hardware acceleration blit
        SDL_SRCCOLORKEY     Use colorkey blitting
        SDL_RLEACCELOK      Private flag
        SDL_RLEACCEL        Accelerated colorkey blitting with RLE
        SDL_SRCALPHA        Use alpha blending blit
        SDL_PREALLOC        Use preallocated memory

       Export tag ':overlay'

        SDL_YV12_OVERLAY    Planar mode: Y + V + U  (3 planes)
        SDL_IYUV_OVERLAY    Planar mode: Y + U + V  (3 planes)
        SDL_YUY2_OVERLAY    Packed mode: Y0+U0+Y1+V0 (1 plane)
        SDL_UYVY_OVERLAY    Packed mode: U0+Y0+V0+Y1 (1 plane)
        SDL_YVYU_OVERLAY    Packed mode: Y0+V0+Y1+U0 (1 plane)

       Export tag ':palette'

        SDL_LOGPAL          Logical palette, which controls how blits are mapped to/from the surface
        SDL_PHYSPAL         Physical palette, which controls how pixels look on the screen

       Export tag ':grab'

        SDL_GRAB_QUERY
        SDL_GRAB_OFF
        SDL_GRAB_ON
        SDL_GRAB_FULLSCREEN Used internally

       Export tag ':gl'

        SDL_GL_RED_SIZE
        SDL_GL_GREEN_SIZE
        SDL_GL_BLUE_SIZE
        SDL_GL_ALPHA_SIZE
        SDL_GL_BUFFER_SIZE
        SDL_GL_DOUBLEBUFFER
        SDL_GL_DEPTH_SIZE
        SDL_GL_STENCIL_SIZE
        SDL_GL_ACCUM_RED_SIZE
        SDL_GL_ACCUM_GREEN_SIZE
        SDL_GL_ACCUM_BLUE_SIZE
        SDL_GL_ACCUM_ALPHA_SIZE
        SDL_GL_STEREO
        SDL_GL_MULTISAMPLEBUFFERS
        SDL_GL_MULTISAMPLESAMPLES
        SDL_GL_ACCELERATED_VISUAL
        SDL_GL_SWAP_CONTROL

</pre><h4><b>Core</b> <b>Functions</b></h4><pre>
   <b>get_video_surface</b>
        my $surface = SDL::Video::get_video_surface();

       This function returns the current display SDL::Surface. If SDL is doing format conversion on the display
       surface, this function returns the publicly visible surface, not the real video surface.

       Example:

        # somewhere after you set the video mode
        my $surface = SDL::Video::get_video_surface();

        printf( "our screen is %d pixels wide and %d pixels high\n", $surface-&gt;w, $surface-&gt;h );

   <b>get_video_info</b>
        my $video_info = SDL::Video::get_video_info();

       This function returns a read-only structure containing information about the video hardware. If it is
       called before SDL::Video::set_video_mode, the "vfmt" member of the returned structure will contain the
       pixel format of the <b>best</b> video mode.

       Example:

        use SDL;
        use SDL::Video;
        use SDL::VideoInfo;
        use SDL::PixelFormat;

        SDL::init(SDL_INIT_VIDEO);

        my $video_info = SDL::Video::get_video_info();

        printf( "we can have %dbits per pixel\n", $video_info-&gt;vfmt-&gt;BitsPerPixel );

   <b>video_driver_name</b>
        my $driver_name = SDL::Video::video_driver_name();

       This function will return the name of the initialized video driver up to a maximum of 1024 characters.
       The driver name is a simple one word identifier like "x11", "windib" or "directx".

       <b>Note</b>: Some platforms allow selection of the video driver through the "SDL_VIDEODRIVER" environment
       variable.

       Example:

        use SDL;
        use SDL::Video;

        SDL::init(SDL_INIT_VIDEO);

        print SDL::Video::video_driver_name() . "\n";

   <b>list_modes</b>
        my @modes = @{ SDL::Video::list_modes( $pixel_format, $flags ) };

       Returns a reference to an array:

       •   of available screen dimensions (as "SDL::Rect"'s) for the given format and video flags.

       •   with first array element 'all'. In this case you can set all modes.

       •   with first array element 'none' if no mode is available.

       <b>Note</b>: &lt;list_modes&gt; should be called before the video_mode ist set. Otherwise you will always get 'all'.

       Example:

        use SDL;
        use SDL::Video;
        use SDL::VideoInfo;
        use SDL::PixelFormat;
        use SDL::Rect;

        SDL::init(SDL_INIT_VIDEO);

        my $video_info = SDL::Video::get_video_info();

        my @modes = @{ SDL::Video::list_modes($video_info-&gt;vfmt, SDL_NOFRAME) };

        if($#modes &gt; 0)
        {
            print("available modes:\n");
            foreach my $mode ( @modes )
            {
                printf("%d x %d\n", $mode-&gt;w, $mode-&gt;h );
            }
        }
        elsif($#modes == 0)
        {
            printf("%s video modes available\n", $modes[0]);
        }

   <b>video_mode_ok</b>
        my $bpp_ok = SDL::Video::video_mode_ok( $width, $height, $bpp, $flags );

       This  function  is used to check whether the requested mode is supported by the current video device. The
       arguments passed to this function are the same as those you would pass to SDL::Video::set_video_mode.  It
       returns 0 if the mode is not supported at all, otherwise the suggested "bpp".

       Example:

        use SDL;
        use SDL::Video;

        SDL::init(SDL_INIT_VIDEO);

        my $video_mode_ok = SDL::Video::video_mode_ok( 800, 600, 32, SDL_SWSURFACE );

        unless($video_mode_ok)
        {
            printf( "this video mode is not supported\n" );
        }

   <b>set_video_mode</b>
        my $surface = SDL::Video::set_video_mode( 800, 600, 32, SDL_SWSURFACE|SDL_DOUBLEBUF|SDL_FULLSCREEN);

       Sets up a video mode with the  specified  width,  height,  bits-per-pixel  and  flags.   "set_video_mode"
       returns  a  SDL::Surface  on  success otherwise it returns undef on error, the error message is retrieved
       using "SDL::get_error".

       <u>List</u> <u>of</u> <u>available</u> <u>flags</u>

       "SDL_SWSURFACE"
           Create the video surface in system memory

       "SDL_HWSURFACE"
           Create the video surface in video memory

       "SDL_ASYNCBLIT"
           Enables the use of asynchronous updates of the display surface.  This will usually slow down blitting
           on single CPU machines, but may provide a speed increase on SMP systems.

       "SDL_ANYFORMAT"
           Normally, if a video surface of the requested bits-per-pixel (bpp) is not available, SDL will emulate
           one with a shadow surface.  Passing "SDL_ANYFORMAT" prevents this and causes SDL  to  use  the  video
           surface, regardless of its pixel depth.

       "SDL_HWPALETTE"
           Give  SDL  exclusive  palette access. Without this flag you may not always get the colors you request
           with SDL::set_colors or SDL::set_palette.

       "SDL_DOUBLEBUF"
           Enable hardware double buffering; only valid with "SDL_HWSURFACE". Calling SDL::Video::flip will flip
           the buffers and update the screen.  All drawing will take place on the surface that is not  displayed
           at  the  moment.   If double buffering could not be enabled then SDL::Video::flip will just perform a
           SDL::Video::update_rect on the entire screen.

       "SDL_FULLSCREEN"
           SDL will attempt to use a fullscreen mode. If a hardware  resolution  change  is  not  possible  (for
           whatever  reason), the next higher resolution will be used and the display window centered on a black
           background.

       "SDL_OPENGL"
           Create an OpenGL rendering context. You should have  previously  set  OpenGL  video  attributes  with
           SDL::Video::GL_set_attribute.

       "SDL_OPENGLBLIT"
           Create  an  OpenGL  rendering  context, like above, but allow normal blitting operations.  The screen
           (2D) surface may have an alpha channel, and SDL::update_rects must be used for  updating  changes  to
           the  screen  surface.   NOTE: This option is kept for compatibility only, and will be removed in next
           versions. Is not recommended for new code.

       "SDL_RESIZABLE"
           Create a resizable window.  When the window is resized by  the  user  a  "SDL_VIDEORESIZE"  event  is
           generated and SDL::Video::set_video_mode can be called again with the new size.

       "SDL_NOFRAME"
           If  possible,  SDL_NOFRAME  causes  SDL  to  create  a  window with no title bar or frame decoration.
           Fullscreen modes automatically have this flag set.

       <b>Note</b> <b>1</b>: Use "SDL_SWSURFACE" if you plan on doing per-pixel manipulations, or  blit  surfaces  with  alpha
       channels,  and  require  a  high  framerate.   When  you  use  hardware  surfaces  (by  passing  the flag
       "SDL_HWSURFACE" as parameter), SDL copies the surfaces from video memory to system memory when  you  lock
       them,  and  back  when  you  unlock  them.  This can cause a major performance hit. Be aware that you may
       request a hardware surface, but receive a software surface  because  the  video  driver  doesn't  support
       hardware  surface.  Many  platforms  can only provide a hardware surface when using "SDL_FULLSCREEN". The
       "SDL_HWSURFACE" flag is best used when the surfaces you'll be  blitting  can  also  be  stored  in  video
       memory.

       <b>Note</b> <b>2</b>: If you want to control the position on the screen when creating a windowed surface, you may do so
       by  setting  the environment variables "SDL_VIDEO_CENTERED=center" or "SDL_VIDEO_WINDOW_POS=x,y". You can
       also set them via "SDL::putenv".

       <b>Note</b> <b>3</b>: This function should be called in the main thread of your application.

       <b>User</b> <b>note</b> <b>1</b>: Some have found that enabling OpenGL  attributes  like  "SDL_GL_STENCIL_SIZE"  (the  stencil
       buffer size) before the video mode has been set causes the application to simply ignore those attributes,
       while enabling attributes after the video mode has been set works fine.

       <b>User</b>  <b>note</b>  <b>2</b>:  Also note that, in Windows, setting the video mode resets the current OpenGL context. You
       must execute again the OpenGL initialization code (set the clear color or  the  shade  model,  or  reload
       textures,  for  example)  after  calling  SDL::set_video_mode.  In Linux, however, it works fine, and the
       initialization code only needs  to  be  executed  after  the  first  call  to  SDL::Video::set_video_mode
       (although   there   is   no   harm   in   executing   the   initialization   code   after  each  call  to
       SDL::Video::set_video_mode, for example for a multiplatform application).

   <b>convert_surface</b>
        $converted_surface = SDL::Video::convert_surface( $surface, $format, $flags );

       Creates a new SDL::surface of the specified SDL::PixelFormat, and then copies and maps the given  surface
       to it.  It is also useful for making a copy of a surface.

       The  flags  parameter  is  passed  to SDL::Surface"-&gt;new" and has those semantics.  This function is used
       internally by SDL::Video::display_format.  This function can only be called after "SDL::init".

       it returns a SDL::Surface on success or "undef" on error.

   <b>display_format</b>
        $new_surface = SDL::Video::display_format( $surface );

       This function takes a surface and copies it to a new surface of the pixel format and colors of the  video
       framebuffer, suitable for fast blitting onto the display surface. It calls SDL::Video::convert_surface.

       If  you  want  to  take  advantage  of  hardware  colorkey or alpha blit acceleration, you should set the
       colorkey and alpha value before calling this function.

       If you want an alpha channel, see "SDL::Video::display_format_alpha".  Return Value

       <b>Note</b>: Remember to use a different variable for the returned surface, otherwise you have  a  memory  leak,
       since the original surface isn't freed.

   <b>display_format_alpha</b>
        $new_surface = SDL::Video::display_format_alpha( $surface );

       This  function takes a surface and copies it to a new surface of the pixel format and colors of the video
       framebuffer plus an alpha channel, suitable  for  fast  blitting  onto  the  display  surface.  It  calls
       SDL::Video::convert_surface.

       If  you  want  to  take  advantage  of  hardware  colorkey or alpha blit acceleration, you should set the
       colorkey and alpha value before calling this function.

       This function can be used to convert a colorkey to an alpha channel, if the "SDL_SRCCOLORKEY" flag is set
       on the surface. The generated surface will then be transparent  (alpha=0)  where  the  pixels  match  the
       colorkey, and opaque (alpha=255) elsewhere.

       <b>Note</b>:  The  video  surface  must  be initialised using SDL::Video::set_video_mode before this function is
       called, or it will segfault.

   <b>load_BMP</b>
        $surface = SDL::Video::load_BMP( $filename );

       Loads a SDL::Surface from a named Windows BMP file.  "SDL::Video::load_BMP"  returns  a  SDL::Surface  on
       success or "undef" on error.

       <b>Note</b>:  When  loading a 24-bit Windows BMP file, pixel data points are loaded as blue, green, red, and NOT
       red, green, blue (as one might expect).

        use SDL;
        use SDL::Video;
        use SDL::Rect;
        use SDL::Surface;

        my $screen_width  = 640;
        my $screen_height = 480;

        SDL::init(SDL_INIT_VIDEO);

        my $screen  = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_SWSURFACE);

        my $picture = SDL::Video::load_BMP('test.bmp');

        die(SDL::get_error) unless $picture;

        my $rect    = SDL::Rect-&gt;new(0, 0, $screen_width, $screen_height);

        SDL::Video::blit_surface( $picture, SDL::Rect-&gt;new(0, 0, $picture-&gt;w, $picture-&gt;h),
                                  $screen,  SDL::Rect-&gt;new(0, 0, $screen-&gt;w,  $screen-&gt;h) );

        SDL::Video::update_rect( $screen, 0, 0, $screen_width, $screen_height );

        <a href="../man2/sleep.2.html">sleep</a>(2);

   <b>save_BMP</b>
        $saved_BMP = SDL::Video::save_BMP( $surface, $filename );

       Saves the given SDL::Surface as a Windows BMP file named filename.  it returns 0  on  success  or  -1  on
       error.

   <b>set_color_key</b>
        $set_color_key = SDL::Video::set_color_key( $surface, $flag, $key );

       Sets  the  color  key  (transparent  pixel)  in  a  blittable  surface  and  enables or disables RLE blit
       acceleration.  $key can be an integer  or  an  SDL::Color  object.  If  you  pass  an  SDL::Color  object
       SDL::Video::map_RGB will be called on it before setting the color key.

       RLE  acceleration can substantially speed up blitting of images with large horizontal runs of transparent
       pixels (i.e., pixels that match the key value).  The key must be of the same pixel format as the surface,
       SDL::Video::map_RGB is often useful for obtaining an acceptable value.  If flag is "SDL_SRCCOLORKEY" then
       key is the transparent pixel value in the source image of a blit.

       If "flag" is OR'd with "SDL_RLEACCEL" then the surface will be drawn using RLE  acceleration  when  drawn
       with  SDL::Video::blit_surface.  The surface will actually be encoded for RLE acceleration the first time
       SDL::Video::blit_surface or "SDL::Video::display_format|/display_format" is called on  the  surface.   If
       "flag" is 0, this function clears any current color key.

       "SDL::Video::set_color_key" returns 0 on success or -1 on error.

   <b>set_alpha</b>
        $set_alpha = SDL::Video::set_alpha( $surface, $flag, $key );

       "set_alpha" is used for setting the per-surface alpha value and/or enabling and disabling alpha blending.

       The  surface  parameter specifies which SDL::surface whose alpha attributes you wish to adjust.  flags is
       used to specify whether alpha blending should be used ( "SDL_SRCALPHA" ) and whether the  surface  should
       use  RLE  acceleration  for  blitting  ( "SDL_RLEACCEL" ).  flags can be an OR'd combination of these two
       options, one of these options or 0.  If "SDL_SRCALPHA" is not passed as a flag then all alpha information
       is ignored when blitting the surface.  The alpha parameter is the per-surface alpha value; a surface need
       not have an alpha  channel  to  use  per-surface  alpha  and  blitting  can  still  be  accelerated  with
       "SDL_RLEACCEL".

       <b>Note</b>:  The  per-surface  alpha  value  of 128 is considered a special case and is optimised, so it's much
       faster than other per-surface values.

       Alpha affects surface blitting in the following ways:

       RGBA-&gt;RGB with "SDL_SRCALPHA"
           The source is alpha-blended with the destination, using the alpha channel.  SDL_SRCCOLORKEY  and  the
           per-surface alpha are ignored.

       RGBA-&gt;RGB without "SDL_SRCALPHA"
           The  RGB data is copied from the source. The source alpha channel and the per-surface alpha value are
           ignored.  If SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.

       RGB-&gt;RGBA with "SDL_SRCALPHA"
           The  source  is  alpha-blended  with  the  destination  using  the  per-surface  alpha   value.    If
           SDL_SRCCOLORKEY  is  set,  only  the  pixels  not  matching the colorkey value are copied.  The alpha
           channel of the copied pixels is set to opaque.

       RGB-&gt;RGBA without "SDL_SRCALPHA"
           The RGB data is copied from the source and the alpha value of the copied pixels is set to opaque.  If
           SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.

       RGBA-&gt;RGBA with "SDL_SRCALPHA"
           The source is alpha-blended with the destination using the source alpha channel.  The  alpha  channel
           in the destination surface is left untouched. SDL_SRCCOLORKEY is ignored.

       RGBA-&gt;RGBA without "SDL_SRCALPHA"
           The  RGBA  data is copied to the destination surface.  If SDL_SRCCOLORKEY is set, only the pixels not
           matching the colorkey value are copied.

       RGB-&gt;RGB with "SDL_SRCALPHA"
           The  source  is  alpha-blended  with  the  destination  using  the  per-surface  alpha   value.    If
           SDL_SRCCOLORKEY is set, only the pixels not matching the colorkey value are copied.

       RGB-&gt;RGB without "SDL_SRCALPHA"
           The  RGB data is copied from the source.  If SDL_SRCCOLORKEY is set, only the pixels not matching the
           colorkey value are copied.

       <b>Note</b>: When blitting, the presence or absence of "SDL_SRCALPHA" is relevant only on  the  source  surface,
       not  the  destination.   <b>Note</b>: Note that RGBA-&gt;RGBA blits (with "SDL_SRCALPHA" set) keep the alpha of the
       destination surface. This means that you cannot compose two arbitrary RGBA surfaces this way and get  the
       result you would expect from "overlaying" them; the destination alpha will work as a mask.

       <b>Note</b>:  Also  note  that per-pixel and per-surface alpha cannot be combined; the per-pixel alpha is always
       used if available.

       "SDL::Video::set_alpha" returns 0 on success or -1 on error.

   <b>fill_rect</b>
        $fill_rect = SDL::Video::fill_rect( $dest, $dest_rect, $pixel );

       This function performs a fast fill of the given SDL::Rect with the given SDL::PixelFormat.  If  dest_rect
       is NULL, the whole surface will be filled with color.

       The  color  should  be  a  pixel  of  the  format  used  by  the  surface,  and  can  be generated by the
       SDL::Video::map_RGB or "SDL::Video::map_RGBA|/map_RGBA" functions. If the color value contains  an  alpha
       value then the destination is simply "filled" with that alpha information, no blending takes place.

       If  there  is  a  clip  rectangle  set  on the destination (set via SDL::Video::set_clip_rect), then this
       function will clip based on the intersection of the clip rectangle and the  dstrect  rectangle,  and  the
       dstrect rectangle will be modified to represent the area actually filled.

       If  you  call  this on the video surface (ie: the value of SDL::Video::get_video_surface) you may have to
       update the video surface to see the result. This can happen if you are using a shadowed surface  that  is
       not double buffered in Windows XP using build 1.2.9.

       "SDL::Video::fill_rect" returns 0 on success or -1 on error.

       for an example see "SYNOPSIS".

</pre><h4><b>Surface</b> <b>Locking</b> <b>and</b> <b>Unlocking</b></h4><pre>
   <b>lock_surface</b>
        int SDL::Video::lock_surface( $surface );

       "SDL::Video::lock_surface"  sets  up  the  given SDL::Surface for directly accessing the pixels.  Between
       calls to SDL::lock_surface and SDL::unlock_surface, you can write to (  "surface-"set_pixels&gt;)  and  read
       from  (  "surface-"get_pixels&gt;  ), using the pixel format stored in "surface-"format&gt;.  Once you are done
       accessing the surface, you should use SDL::Video::unlock_surface to release the lock.

       Not all surfaces require locking. If SDL::Video::MUSTLOCK evaluates to 0, then reading and writing pixels
       to the surface can be performed at any time, and the pixel format of the surface  will  not  change.   No
       operating  system or library calls should be made between the lock/unlock pairs, as critical system locks
       may be held during this time.  "SDL::Video::lock_surface" returns 0 on success or -1 on error.

       <b>Note</b>: Since SDL 1.1.8, the surface locks are recursive. This means that you can lock a  surface  multiple
       times, but each lock must have a matching unlock.

        use strict;
        use warnings;
        use Carp;

        use SDL v2.3;
        use SDL::Video;
        use SDL::Event;
        use SDL::Events;
        use SDL::Surface;

        my $screen;

        sub putpixel
        {
            my($x, $y, $color) = @_;
            my $lineoffset     = $y * ($screen-&gt;pitch / 4);
            $screen-&gt;set_pixels( $lineoffset+ $x, $color);
        }

        sub render
        {
            if( SDL::Video::MUSTLOCK( $screen) )
            {
                return if (SDL::Video::lock_surface( $screen ) &lt; 0)
            }

            my $ticks                = SDL::get_ticks();
            my ($i, $y, $yofs, $ofs) = (0,0,0,0);
            for ($i = 0; $i &lt; 480; $i++)
            {
                for (my $j = 0, $ofs = $yofs; $j &lt; 640; $j++, $ofs++)
                {
                    $screen-&gt;set_pixels( $ofs, (  $i * $i + $j * $j + $ticks ) );
                }
                $yofs += $screen-&gt;pitch / 4;
            }

            putpixel(10, 10, 0xff0000);
            putpixel(11, 10, 0xff0000);
            putpixel(10, 11, 0xff0000);
            putpixel(11, 11, 0xff0000);

            SDL::Video::unlock_surface($screen) if (SDL::Video::MUSTLOCK($screen));

            SDL::Video::update_rect($screen, 0, 0, 640, 480);

            return 0;
        }

        sub main
        {
            Carp::cluck 'Unable to init SDL: '.SDL::get_error() if( SDL::init(SDL_INIT_VIDEO) &lt; 0);

            $screen = SDL::Video::set_video_mode( 640, 480, 32, SDL_SWSURFACE);

            Carp::cluck 'Unable to set 640x480x32 video' . SDL::get_error() if(!$screen);

            <a href="../man1/while.1.html">while</a>(1)
            {
                render();

                my $event = SDL::Event-&gt;new();

                while( SDL::Events::poll_event($event) )
                {
                    my $type = $event-&gt;type;
                    return 0 if( $type == SDL_KEYDOWN || $type == SDL_QUIT);
                }
                SDL::Events::pump_events();
            }
        }

        main();

   <b>unlock_surface</b>
        SDL::Video::unlock_surface( $surface );

       Surfaces   that   were   previously   locked   using   SDL::Video::lock_surface  must  be  unlocked  with
       "SDL::Video::unlock_surface".     Surfaces    should    be    unlocked    as    soon     as     possible.
       "SDL::Video::unlock_surface" doesn't return anything.

       <b>Note</b>: Since 1.1.8, the surface locks are recursive. See SDL::Video::lock_surface for more information.

   <b>MUSTLOCK</b>
        int SDL::Video::MUSTLOCK( $surface );

       "MUSTLOCK" returns 0 if the surface does not have to be locked during pixel operations, otherwise 1.

</pre><h4><b>Screen</b> <b>Updating</b> <b>Functions</b></h4><pre>
   <b>set_clip_rect</b>
        SDL::Video::set_clip_rect( $surface, $rect );

       Sets  the  clipping rectangle for the given SDL::Surface. When this surface is the destination of a blit,
       only the area within the clip rectangle will be drawn into.  The rectangle pointed to  by  rect  will  be
       clipped  to  the edges of the surface so that the clip rectangle for a surface can never fall outside the
       edges of the surface.  If rect is NULL the clipping rectangle will  be  set  to  the  full  size  of  the
       surface.  "SDL::Video::set_clip_rect" doesn't returns anything.

   <b>get_clip_rect</b>
        SDL::Video::get_clip_rect( $surface, $rect );

       Gets  the  clipping rectangle for the given SDL::Surface. When this surface is the destination of a blit,
       only the area within the clip rectangle is drawn into.  The rectangle pointed to by rect will  be  filled
       with the clipping rectangle of the surface.  "SDL::Video::get_clip_rect" doesn't returns anything;

        use SDL;
        use SDL::Video;
        use SDL::Rect;
        use SDL::Surface;

        my $screen_width  = 640;
        my $screen_height = 480;

        SDL::init(SDL_INIT_VIDEO);

        my $screen  = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_SWSURFACE);

        my $rect = SDL::Rect-&gt;new(0, 0, 0, 0);

        SDL::Video::get_clip_rect($screen, $rect);

        printf( "rect is %d, %d, %d, %d\n", $rect-&gt;x, $rect-&gt;y, $rect-&gt;w, $rect-&gt;h);

   <b>blit_surface</b>
        SDL::Video::blit_surface( $src_surface, $src_rect, $dest_surface, $dest_rect );

       This  performs a fast blit from the given source SDL::Surface to the given destination SDL::Surface.  The
       width and height in $src_rect determine the size of the copied rectangle. Only the position  is  used  in
       the  $dest_rect  (the  width and height are ignored). Blits with negative "dest_rect" coordinates will be
       clipped properly.  If $src_rect is "undef", the entire surface is copied. If $dest_rect is "undef",  then
       the  destination position (upper left corner) is (0, 0).  The final blit rectangle is saved in $dest_rect
       after all clipping is performed ($src_rect is not modified).  The blit function should not be called on a
       locked surface. I.e. when you use your own drawing functions you may need to lock a surface, but this  is
       not  the case with "SDL::Video::blit_surface". Like most surface manipulation functions in SDL, it should
       not be used together with OpenGL.

       The results of blitting operations vary greatly depending on whether "SDL_SRCALPHA" is set  or  not.  See
       SDL::Video::set_alpha  for  an  explanation  of  how  this  affects  your  results. Colorkeying and alpha
       attributes also interact with surface blitting.  "SDL::Video::blit_surface" doesn't returns anything.

       For an example see SDL::Video::load_BMP.

   <b>update_rect</b>
        update_rect( $surface, $left, $top, $width, $height );

       Makes sure the given area is updated on the given screen.  The rectangle  must  be  confined  within  the
       screen boundaries because there's no clipping.  update_rect doesn't returns any value.

       <b>Note</b>: This function should not be called while screen is locked by SDL::Video::lock_surface

       <b>Note2</b>: If "x", "y", "width" and "height" are all equal to 0, "update_rect" will update the entire screen.

       For an example see SYNOPSIS

   <b>update_rects</b>
        update_rects( $surface, @rects );

       Makes  sure  the given list of rectangles is updated on the given screen.  The rectangle must be confined
       within the screen boundaries because there's no clipping.  "update_rects" doesn't returns any value.

       <b>Note</b>: This function should not be called while screen is locked by SDL::Video::lock_surface.

       Example:

        use SDL;
        use SDL::Video;
        use SDL::Surface;
        use SDL::Rect;

        # the size of the window box or the screen resolution if fullscreen
        my $screen_width   = 800;
        my $screen_height  = 600;

        SDL::init(SDL_INIT_VIDEO);

        # setting video mode
        my $screen_surface = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_SWSURFACE);

        # drawing the whole screen blue
        my $mapped_color   = SDL::Video::map_RGB($screen_surface-&gt;format(), 0, 0, 255); # blue
        SDL::Video::fill_rect($screen_surface,
                              SDL::Rect-&gt;new(0, 0, $screen_width, $screen_height),
                              $mapped_color);

        my @rects = ();
        push(@rects, SDL::Rect-&gt;new(200,   0, 400, 600));
        push(@rects, SDL::Rect-&gt;new(  0, 150, 800, 300));

        # updating parts of the screen (should look like a cross)
        SDL::Video::update_rects($screen_surface, @rects);

        <a href="../man2/sleep.2.html">sleep</a>(2);

   <b>flip</b>
        $flip = SDL::Video::flip( $screen_surface );

       On hardware that supports double-buffering, this function sets up a flip and returns.  The hardware  will
       wait  for  vertical  retrace, and then swap video buffers before the next video surface blit or lock will
       return.  On hardware that doesn't support  double-buffering  or  if  "SDL_SWSURFACE"  was  set,  this  is
       equivalent to calling "SDL::Video::update_rect( $screen, 0, 0, 0, 0 )".

       A software screen surface is also updated automatically when parts of a SDL window are redrawn, caused by
       overlapping windows or by restoring from an iconified state. As a result there is no proper double buffer
       behavior in windowed mode for a software screen, in contrast to a full screen software mode.

       The "SDL_DOUBLEBUF" flag must have been passed to SDL::Video::set_video_mode, when setting the video mode
       for this function to perform hardware flipping.

       "flip" returns 0 on success or -1 on error.

       <b>Note</b>:   If   you  want  to  swap  the  buffers  of  an  initialized  OpenGL  context,  use  the  function
       SDL::Video::GL_swap_buffers instead.

       Example:

        use SDL;
        use SDL::Video;
        use SDL::Surface;

        # the size of the window box or the screen resolution if fullscreen
        my $screen_width   = 800;
        my $screen_height  = 600;

        SDL::init(SDL_INIT_VIDEO);

        # setting video mode
        my $screen_surface = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_DOUBLEBUF|SDL_FULLSCREEN);

        # do some video operations here

        # doing page flipping
        unless( SDL::Video::flip($screen_surface) == 0 )
        {
            printf( STDERR "failed to swap buffers: %s\n", SDL::get_error() );
        }

</pre><h4><b>Palette,</b> <b>Color</b> <b>and</b> <b>Pixel</b> <b>Functions</b></h4><pre>
   <b>set_colors</b>
        $set_colors = SDL::Video::set_colors( $surface, $start, $color1, $color2, ... )

       Sets a portion of the colormap for the given 8-bit surface.

       When surface is the surface associated with the current display, the display  colormap  will  be  updated
       with   the   requested   colors.    If  "SDL_HWPALETTE"  was  set  in  SDL::Video::set_video_mode  flags,
       "SDL::Video::set_colors" will always return 1, and the palette is  guaranteed  to  be  set  the  way  you
       desire,  even  if the window colormap has to be warped or run under emulation.  The color components of a
       SDL::Color structure are 8-bits in size, giving you a  total  of  2563  =  16777216  colors.   Palettized
       (8-bit)  screen  surfaces with the "SDL_HWPALETTE" flag have two palettes, a logical palette that is used
       for mapping blits to/from the surface and a physical palette (that determines how the hardware  will  map
       the  colors  to  the  display).   "SDL::Video::set_colors"  modifies  both  palettes (if present), and is
       equivalent to calling SDL::Video::set_palette with the flags set to ( "SDL_LOGPAL | SDL_PHYSPAL" ).

       If "surface" is not a palettized surface, this function does nothing, returning 0.  If all of the  colors
       were  set as passed to "SDL::Video::set_colors", it will return 1.  If not all the color entries were set
       exactly as given, it will return 0, and you should look at the surface palette to  determine  the  actual
       color palette.

   <b>set_palette</b>
        $set_palette = set_palette( $surface, $flags, $start, $color1, $color2, ... );

       Sets a portion of the palette for the given 8-bit surface.

       Palettized  (8-bit)  screen  surfaces  with the "SDL_HWPALETTE" flag have two palettes, a logical palette
       that is used for mapping blits to/from the surface and  a  physical  palette  (that  determines  how  the
       hardware  will  map  the  colors  to  the  display).   Non  screen  surfaces have a logical palette only.
       SDL::Video::blit always uses the logical palette when blitting surfaces (if it  has  to  convert  between
       surface  pixel  formats).  Because of this, it is often useful to modify only one or the other palette to
       achieve various special color effects (e.g., screen fading, color flashes, screen dimming).

       This function  can  modify  either  the  logical  or  physical  palette  by  specifying  "SDL_LOGPAL"  or
       "SDL_PHYSPAL" the in the flags parameter.

       When  surface  is  the  surface associated with the current display, the display colormap will be updated
       with  the  requested  colors.   If  "SDL_HWPALETTE"  was   set   in   SDL::Video::set_video_mode   flags,
       "SDL::Video::set_palette"  will  always  return  1,  and  the palette is guaranteed to be set the way you
       desire, even if the window colormap has to be warped or run under emulation.  The color components  of  a
       "SDL::Color" structure are 8-bits in size, giving you a total of 2563 = 16777216 colors.

       If  "surface"  is not a palettized surface, this function does nothing, returning 0. If all of the colors
       were set as passed to "set_palette", it will return 1. If not all the color entries were set  exactly  as
       given,  it  will  return  0,  and  you  should  look at the surface palette to determine the actual color
       palette.

   <b>set_gamma</b>
        $set_gamma = SDL::Video::set_gamma( $red_gamma, $green_gamma, $blue_gamma );

       Sets the "gamma function" for the display of each color component. Gamma controls the brightness/contrast
       of colors displayed on the screen.  A gamma value of 1.0 is identity (i.e., no adjustment is made).

       This function adjusts the gamma based on the "gamma function" parameter, you can directly specify  lookup
       tables for gamma adjustment with SDL::set_gamma_ramp.

       <b>Note</b>: Not all display hardware is able to change gamma.

       "SDL::Video::set_gamma" returns -1 on error.

       <b>Warning</b>:  Under  Linux  (X.org  Gnome and Xfce), gamma settings affects the entire display (including the
       desktop)!

       Example:

        use SDL;
        use SDL::Video;
        use SDL::Surface;
        use SDL::Rect;
        use Time::HiRes qw( usleep );

        # the size of the window box or the screen resolution if fullscreen
        my $screen_width   = 800;
        my $screen_height  = 600;

        SDL::init(SDL_INIT_VIDEO);

        # setting video mode
        my $screen_surface = SDL::Video::set_video_mode($screen_width, $screen_height, 32, SDL_SWSURFACE);

        # drawing something somewhere
        my $mapped_color   = SDL::Video::map_RGB($screen_surface-&gt;format(), 128, 128, 128); # gray
        SDL::Video::fill_rect($screen_surface,
                              SDL::Rect-&gt;new($screen_width / 4, $screen_height / 4, $screen_width / 2, $screen_height / 2),
                              $mapped_color);

        # update the whole screen
        SDL::Video::update_rect($screen_surface, 0, 0, $screen_width, $screen_height);

        <a href="../man500000/usleep.500000.html">usleep</a>(500000);

        for(1..20)
        {
           SDL::Video::set_gamma( 1 - $_ / 20, 1, 1 );
               <a href="../man40000/usleep.40000.html">usleep</a>(40000);
        }

        for(1..20)
        {
           SDL::Video::set_gamma( $_ / 20, 1, 1 );
               <a href="../man40000/usleep.40000.html">usleep</a>(40000);
        }

        SDL::Video::set_gamma( 1, 1, 1 );

        <a href="../man500000/usleep.500000.html">usleep</a>(500000);

   <b>get_gamma_ramp</b>
        $get_gamma_ramp = SDL::Video::get_gamma_ramp( \@red_table, \@green_table, \@blue_table );

       Gets the gamma translation lookup tables currently used by the display. Each table is  an  array  of  256
       Uint16 values.  "SDL::Video::get_gamma_ramp" returns -1 on error.

        use SDL;
        use SDL::Video;

        SDL::init(SDL_INIT_VIDEO);

        my (@red, @green, @blue);

        my $ret = SDL::Video::get_gamma_ramp( \@red, \@green, \@blue );

        if( -1 == $ret )
        {
            print( "an error occurred" );
        }
        else
        {
            printf( "for gamma = 1.0: red=0x%04X, green=0x%04X, blue=0x%04X\n", $red[255], $green[255], $blue[255] );
            printf( "for gamma = 0.5: red=0x%04X, green=0x%04X, blue=0x%04X\n", $red[127], $green[127], $blue[127] );
            printf( "for gamma = 0.0: red=0x%04X, green=0x%04X, blue=0x%04X\n", $red[0],   $green[0],   $blue[0]   );
        }

   <b>set_gamma_ramp</b>
        $set_gamma_ramp = SDL::Video::set_gamma_ramp( \@red_table, \@green_table, \@blue_table );

       Sets  the gamma lookup tables for the display for each color component. Each table is an array ref of 256
       Uint16 values, representing a mapping between the input and output for that channel.  The  input  is  the
       index  into the array, and the output is the 16-bit gamma value at that index, scaled to the output color
       precision.  You may pass NULL to any of the channels to leave them unchanged.

       This function adjusts the gamma based on lookup tables, you can also have the gamma calculated based on a
       "gamma function" parameter with SDL::Video::set_gamma.

       Not all display hardware is able to change gamma.  "SDL::Video::set_gamma_ramp" returns -1 on  error  (or
       if gamma adjustment is not supported).

       Example:

        use SDL;
        use SDL::Video;

        SDL::init(SDL_INIT_VIDEO);

        my (@red, @green, @blue);

        my $ret = SDL::Video::get_gamma_ramp( \@red, \@green, \@blue );

        $red[127] = 0xFF00;

           $ret = SDL::Video::set_gamma_ramp( \@red, \@green, \@blue );

           $ret = SDL::Video::get_gamma_ramp( \@red, \@green, \@blue );

        if( -1 == $ret )
        {
            print( "an error occurred" );
        }
        else
        {
            printf( "for gamma = 1.0: red=0x%04X, green=0x%04X, blue=0x%04X\n", $red[255], $green[255], $blue[255] );
            printf( "for gamma = 0.5: red=0x%04X, green=0x%04X, blue=0x%04X\n", $red[127], $green[127], $blue[127] );
            printf( "for gamma = 0.0: red=0x%04X, green=0x%04X, blue=0x%04X\n", $red[0],   $green[0],   $blue[0]   );
        }

   <b>map_RGB</b>
        $pixel = SDL::Video::map_RGB( $pixel_format, $r, $g, $b );

       Maps  the  RGB color value to the specified SDL::PixelFormat and returns the pixel value as a 32-bit int.
       If the format has a palette (8-bit) the index of the closest  matching  color  in  the  palette  will  be
       returned.   If the specified pixel format has an alpha component it will be returned as all 1 bits (fully
       opaque).

       "SDL::Video::map_RGB" returns a pixel value best approximating the given RGB  color  value  for  a  given
       pixel  format.   If  the  SDL::PixelFormat's  bpp (color depth) is less than 32-bpp then the unused upper
       bits of the return value can safely be ignored (e.g., with a  16-bpp  format  the  return  value  can  be
       assigned to a Uint16, and similarly a Uint8 for an 8-bpp format).

        use SDL;
        use SDL::Video;
        use SDL::PixelFormat;
        use SDL::Surface;

        SDL::init(SDL_INIT_VIDEO);

        my $screen_surface = SDL::Video::set_video_mode(640, 480, 16, SDL_SWSURFACE);
        #                                                          ^-- 16 bits per pixel

        $r = 0x9C;
        $g = 0xDC;
        $b = 0x67;

        printf( "for 24bpp it is: 0x%02X 0x%02X 0x%02X\n", $r, $g, $b);

        my $_16bit = SDL::Video::map_RGB( $screen_surface-&gt;format, $r, $g, $b );

        # 16bpp is 5 bits red, 6 bits green and 5 bits blue
        # we will obtain the values for each color and calculating them back to 24/32bit color system
        ($r, $g, $b) = @{ SDL::Video::get_RGB( $screen_surface-&gt;format, $_16bit ) };

        printf( "for 16bpp it is: 0x%02X 0x%02X 0x%02X\n", $r, $g, $b );

        # so color #9CDC67 becomes #9CDF63

   <b>map_RGBA</b>
        $pixel = SDL::Video::map_RGBA( $pixel_format, $r, $g, $b, $a );

       Maps  the RGBA color value to the specified SDL::PixelFormat and returns the pixel value as a 32-bit int.
       If the format has a palette (8-bit) the index of the closest  matching  color  in  the  palette  will  be
       returned.   If  the  specified pixel format has no alpha component the alpha value will be ignored (as it
       will be in formats with a palette).

       A pixel value best approximating the given RGBA color value for a  given  pixel  format.   If  the  pixel
       format bpp (color depth) is less than 32-bpp then the unused upper bits of the return value can safely be
       ignored  (e.g.,  with a 16-bpp format the return value can be assigned to a Uint16, and similarly a Uint8
       for an 8-bpp format).

   <b>get_RGB</b>
        $rgb_array_ref = SDL::Video::get_RGB( $pixel_format, $pixel );

       Returns RGB values from a pixel in the specified pixel format.  The  pixel  is  an  integer  (e.g.  16bit
       RGB565,  24/32bit  RGB888).   This  function  uses  the entire 8-bit [0..255] range when converting color
       components from pixel formats with less than 8-bits per RGB component (e.g., a completely white pixel  in
       16-bit RGB565 format would return [0xff, 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).

       For an example see SDL::Video::map_RGB.

   <b>get_RGBA</b>
        $rgba_array_ref = SDL::Video::get_RGBA( $pixel_format, $pixel );

       Gets  RGBA  values  from  a  pixel  in  the  specified pixel format.  This function uses the entire 8-bit
       [0..255] range when converting color components  from  pixel  formats  with  less  than  8-bits  per  RGB
       component  (e.g.,  a  completely  white pixel in 16-bit RGB565 format would return [0xff, 0xff, 0xff] not
       [0xf8, 0xfc, 0xf8]).

       If the surface has no alpha component, the alpha will be returned as 0xff (100% opaque).

</pre><h4><b>GL</b> <b>Methods</b></h4><pre>
   <b>GL_load_library</b>
        $gl_load_lib = SDL::Video::GL_load_library( 'path/to/static/glfunctions.dll' );

       If you wish, you may load the OpenGL library from the given path at runtime, this  must  be  done  before
       SDL::Video::set_video_mode  is  called.  You  must  then  use SDL::Video::GL_get_proc_address to retrieve
       function pointers to GL functions.

       "GL_load_library" returns 0 on success or -1 or error.

   <b>GL_get_proc_address</b>
        $proc_address = SDL::Video::GL_get_proc_address( $proc );

       Returns the address of the GL function proc, or NULL if the function is not found. If the GL  library  is
       loaded  at  runtime,  with SDL::Video::GL_load_library, then all GL functions must be retrieved this way.
       Usually this is used to retrieve function pointers to OpenGL extensions. Note that this function needs an
       OpenGL context to function properly, so it should be called  after  SDL::Video::set_video_mode  has  been
       called (with the "SDL_OPENGL" flag).

       It returns undef if the function is not found.

       Example:

        my $has_multitexture = 1;

        # Get function pointer
        $gl_active_texture_ARB_ptr = SDL::Video::GL_get_proc_address("glActiveTextureARB");

        # Check for a valid function ptr
        unless($gl_active_texture_ARB_ptr)
        {
            printf( STDERR "Multitexture Extensions not present.\n" );
            $has_multitexture = 0;
        }

        $gl_active_texture_ARB_ptr(GL_TEXTURE0_ARB) if $has_multitexture;

   <b>GL_get_attribute</b>
        $value = SDL::Video::GL_get_attribute( $attr );

       It  returns  SDL/OpenGL  attribute  "attr".  This is useful after a call to SDL::Video::set_video_mode to
       check whether your attributes have been set  as  you  expected.   "SDL::Video::GL_get_attribute"  returns
       "undef" if the attribute is not found.

       Example:

        print( SDL::Video::GL_set_attribute(SDL_GL_RED_SIZE) );

   <b>GL_set_attribute</b>
        $set_attr = SDL::Video::GL_set_attribute( $attr, $value );

       This  function  sets  the  given  OpenGL  attribute "attr" to "value". The requested attributes will take
       effect     after      a      call      to      SDL::Video::set_video_mode.       You      should      use
       "SDL::Video::GL_get_attribute|/GL_get_attribute"  to  check the values after a SDL::Video::set_video_mode
       call, since the values obtained can differ from the requested ones.

       Available attributes:

       •   "SDL_GL_RED_SIZE"

       •   "SDL_GL_GREEN_SIZE"

       •   "SDL_GL_BLUE_SIZE"

       •   "SDL_GL_ALPHA_SIZE"

       •   "SDL_GL_BUFFER_SIZE"

       •   "SDL_GL_DOUBLEBUFFER"

       •   "SDL_GL_DEPTH_SIZE"

       •   "SDL_GL_STENCIL_SIZE"

       •   "SDL_GL_ACCUM_RED_SIZE"

       •   "SDL_GL_ACCUM_GREEN_SIZE"

       •   "SDL_GL_ACCUM_BLUE_SIZE"

       •   "SDL_GL_ACCUM_ALPHA_SIZE"

       •   "SDL_GL_STEREO"

       •   "SDL_GL_MULTISAMPLEBUFFERS"

       •   "SDL_GL_MULTISAMPLESAMPLES"

       •   "SDL_GL_ACCELERATED_VISUAL"

       •   "SDL_GL_SWAP_CONTROL"

       "GL_set_attribute" returns 0 on success or -1 on error.

       <b>Note</b>: The "SDL_DOUBLEBUF" flag is not required to enable double buffering when setting  an  OpenGL  video
       mode. Double buffering is enabled or disabled using the "SDL_GL_DOUBLEBUFFER" attribute.

       Example:

        SDL::Video::GL_set_attribute(SDL_GL_RED_SIZE, 5);

   <b>GL_swap_buffers</b>
        SDL::Video::GL_swap_buffers();

       Swap the OpenGL buffers, if double-buffering is supported.  "SDL::Video::GL_swap_buffers" doesn't returns
       any value.

</pre><h4><b>Video</b> <b>Overlay</b> <b>Functions</b></h4><pre>
       see SDL::Overlay

   <b>lock_YUV_overlay</b>
        $lock_overlay = SDL::Video::lock_YUV_overlay( $overlay );

       Much  the  same  as  SDL::Video::lock_surface,  "lock_YUV_overlay" locks the overlay for direct access to
       pixel data.  It returns 0 on success or -1 on error.

   <b>unlock_YUV_overlay</b>
        SDL::Video::unlock_YUV_overlay( $overlay );

       The opposite to SDL::Video::lock_YUV_overlay. Unlocks a previously locked overlay.  An  overlay  must  be
       unlocked before it can be displayed. "unlock_YUV_overlay" does not return anything.

   <b>display_YUV_overlay</b>
        $display_overlay = SDL::Video::display_YUV_overlay( $overlay, $dstrect );

       Blit  the overlay to the display surface specified when the overlay was created. The SDL::Rect structure,
       "dstrect", specifies a rectangle on the display where the overlay is drawn. The "x"  and  "y"  fields  of
       "dstrect"  specify  the upper left location in display coordinates.  The overlay is scaled (independently
       in x and y dimensions) to the size specified by dstrect, and is "optimized" for 2x scaling

       It returns 0 on success or -1 on error.

</pre><h4><b>Window</b> <b>Management</b> <b>Functions</b></h4><pre>
   <b>wm_set_caption</b>
        SDL::Video::wm_set_caption( $title, $icon );

       Sets the title-bar and icon name of the display window.

       "title" is a UTF-8 encoded null-terminated string which will serve as the window title (the text  at  the
       top  of  the window). The function does not change the string. You may free the string after the function
       returns.

       "icon" is a UTF-8 encoded null-terminated string which will serve as the iconified window title (the text
       which is displayed in the menu bar or desktop when the window is minimized). As with  title  this  string
       may be freed after the function returns.

       Example:

        use SDL;
        use SDL::Video;
        use SDL::Surface;

        SDL::init(SDL_INIT_VIDEO);

        my $screen  = SDL::Video::set_video_mode(640, 480, 32, SDL_SWSURFACE);

        SDL::Video::wm_set_caption( 'maximized title', 'minimized title' );

        <a href="../man2/sleep.2.html">sleep</a>(2);

   <b>wm_get_caption</b>
        SDL::Video::wm_get_caption( $title, $icon );

       Retrieves the title-bar and icon name of the display window.

       Example:

        use SDL;
        use SDL::Video;
        use SDL::Surface;

        SDL::init(SDL_INIT_VIDEO);

        my $screen  = SDL::Video::set_video_mode(640, 480, 32, SDL_SWSURFACE);

        SDL::Video::wm_set_caption( 'maximized title', 'minimized title' );

        my ($title, $icon) = @{ SDL::Video::wm_get_caption() };

        printf( "title is '%s' and icon is '%s'\n", $title, $icon );

   <b>wm_set_icon</b>
        SDL::Video::wm_set_icon( $icon );

       Sets the icon for the display window. Win32 icons must be 32x32.

       This  function  must  be called before the first call to SDL::Video::set_video_mode. Note that this means
       SDL::Image cannot be used.

       The shape is determined by the colorkey or alpha channel of the icon, if any. If  neither  of  those  are
       present, the icon is made opaque (no transparency).

       Example:

        SDL::Video::wm_set_icon(SDL::Video::load_BMP("icon.bmp"));

       Another  option, if your icon image does not have a colorkey set, is to use the SDL::Video::set_color_key
       to set the transparency.

       Example:

        my $image = SDL::Video::load_BMP("icon.bmp");

        my colorkey = SDL::Video::map_RGB($image-&gt;format, 255, 0, 255); # specify the color that will be transparent

        SDL::Video::set_color_key($image, SDL_SRCCOLORKEY, $colorkey);

        SDL::Video::wm_set_icon($image);

   <b>wm_grab_input</b>
        $grab_mode = SDL::Video::wm_grab_input($mode);

       Grabbing means that the mouse is confined to the application window, and nearly  all  keyboard  input  is
       passed directly to the application, and not interpreted by a window manager, if any.

       When mode is "SDL_GRAB_QUERY" the grab mode is not changed, but the current grab mode is returned.

       "mode" and the return value of "wm_grab_input" can be one of the following:

       •   "SDL_GRAB_QUERY"

       •   "SDL_GRAB_OFF"

       •   "SDL_GRAB_ON"

   <b>wm_iconify_window</b>
        $iconify_window = SDL::Video::wm_iconify_window();

       If  the  application  is  running in a window managed environment SDL attempts to iconify/minimise it. If
       "wm_iconify_window" is successful, the  application  will  receive  a  "SDL_APPACTIVE"  loss  event  (see
       Application visibility events at SDL::Event).

       Returns non-zero on success or 0 if iconification is not supported or was refused by the window manager.

       Example:

        use SDL;
        use SDL::Video;
        use SDL::Surface;

        SDL::init(SDL_INIT_VIDEO);

        my $screen  = SDL::Video::set_video_mode(640, 480, 32, SDL_SWSURFACE);

        <a href="../man2/sleep.2.html">sleep</a>(2);

        SDL::Video::wm_iconify_window();

        <a href="../man2/sleep.2.html">sleep</a>(2);

   <b>wm_toggle_fullscreen</b>
        $toggle = SDL::Video::wm_toggle_fullscreen( $surface );

       Toggles  the  application  between  windowed  and  fullscreen mode, if supported. (X11 is the only target
       currently supported, BeOS support is experimental).

</pre><h4><b>AUTHORS</b></h4><pre>
       See "AUTHORS" in SDL.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
   <b>Category</b> <b>Objects</b>
       SDL::Surface, SDL::Overlay, SDL::Color, SDL::Rect, SDL::Palette, SDL::PixelFormat, SDL::VideoInfo

perl v5.40.0                                       2024-10-20                              <u>pods::SDL::<a href="../man3pm/Video.3pm.html">Video</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>