<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::RunSQL - run SQL from a file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-runsql-perl">libdbix-runsql-perl_0.25-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::RunSQL - run SQL from a file

</pre><h4><b>SYNOPSIS</b></h4><pre>
           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
           use strict;
           use DBIx::RunSQL;

           my $test_dbh = DBIx::RunSQL-&gt;create(
               dsn       =&gt; 'dbi:SQLite:dbname=:memory:',
               sql       =&gt; 'sql/create.sql',
               force     =&gt; 1,
               verbose   =&gt; 1,
               formatter =&gt; 'Text::Table',
               rotate    =&gt; 1,
               null      =&gt; '(Null)',
           );

           # now run your tests with a DB setup fresh from setup.sql

</pre><h4><b>METHODS</b></h4><pre>
   <b>"DBIx::RunSQL-&gt;create</b> <b>ARGS"</b>
   <b>"DBIx::RunSQL-&gt;run</b> <b>ARGS"</b>
       Runs the SQL commands and returns the database handle.  In list context, it returns the database handle
       and the suggested exit code.

       •   "sql" - name of the file containing the SQL statements

           The default is "sql/create.sql"

           If "sql" is a reference to a glob or a filehandle, the SQL will be read from that. <b>not</b> <b>implemented</b>

           If  "sql"  is  undefined,  the  $::DATA  or  the  0  filehandle  will  be read until exhaustion.  <b>not</b>
           <b>implemented</b>

           This allows one to create SQL-as-programs as follows:

             #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w -MDBIx::RunSQL -e 'create()'
             create table ...

           If you want to run SQL statements from a scalar, you can simply pass  in  a  reference  to  a  scalar
           containing the SQL:

               sql =&gt; \"update mytable set foo='bar';",

       •   "dsn", "user", "password", "options" - DBI parameters for connecting to the DB

       •   "dbh" - a premade database handle to be used instead of "dsn"

       •   "force" - continue even if errors are encountered

       •   "verbose" - print each SQL statement as it is run

       •   "verbose_handler" - callback to call with each SQL statement instead of "print"

       •   "verbose_fh" - filehandle to write to instead of "STDOUT"

   <b>"DBIx::RunSQL-&gt;run_sql_file</b> <b>ARGS"</b>
           my $dbh = DBI-&gt;connect(...)

           for my $file (sort glob '*.sql') {
               DBIx::RunSQL-&gt;run_sql_file(
                   verbose =&gt; 1,
                   dbh     =&gt; $dbh,
                   sql     =&gt; $file,
               );
           };

       Runs an SQL file on a prepared database handle.  Returns the number of errors encountered.

       If the statement returns rows, these are printed separated with tabs.

       •   "dbh" - a premade database handle

       •   "sql" - name of the file containing the SQL statements

       •   "fh" - filehandle to the file containing the SQL statements

       •   "force" - continue even if errors are encountered

       •   "verbose" - print each SQL statement as it is run

       •   "verbose_handler" - callback to call with each SQL statement instead of "print"

       •   "verbose_fh" - filehandle to write to instead of "STDOUT"

       •   "output_bool" - whether to exit with a nonzero exit code if any row is found

           This makes the function return a nonzero value even if there is no error but a row was found.

       •   "output_string" - whether to output the (one) row and column, without any headers

       •   "formatter" - see the "&lt;formatter"&gt; option of "-&gt;format_results"

       •   "rotate" - rotate the table by 90° , outputting columns as rows

       •   "null" - string to replace SQL "NULL" columns by

   <b>"DBIx::RunSQL-&gt;run_sql</b> <b>ARGS"</b>
           my $dbh = DBI-&gt;connect(...)

           DBIx::RunSQL-&gt;run_sql(
               verbose =&gt; 1,
               dbh     =&gt; $dbh,
               sql     =&gt; \@sql_statements,
           );

       Runs an SQL string on a prepared database handle.  Returns the number of errors encountered.

       If  the  statement  returns  rows,  these  are printed separated with tabs, but see the "output_bool" and
       "output_string" options.

       •   "dbh" - a premade database handle

       •   "sql" - string or array reference containing the SQL statements

       •   "force" - continue even if errors are encountered

       •   "verbose" - print each SQL statement as it is run

       •   "verbose_handler" - callback to call with each SQL statement instead of "print"

       •   "verbose_fh" - filehandle to write to instead of "STDOUT"

       •   "output_bool" - whether to exit with a nonzero exit code if any row is found

           This makes the function return a nonzero value even if there is no error but a row was found.

       •   "output_string" - whether to output the (one) row and column, without any headers

       •   "formatter" - see the "&lt;formatter"&gt; option of "-&gt;format_results"

       •   "rotate" - rotate the table by 90° , outputting columns as rows

       •   "null" - string to replace SQL "NULL" columns by

   <b>"DBIx::RunSQL-&gt;format_results</b> <b>%options"</b>
         my $sth= $dbh-&gt;prepare( 'select * from foo' );
         $sth-&gt;execute();
         print DBIx::RunSQL-&gt;format_results( sth =&gt; $sth );

       Executes "$sth-&gt;fetchall_arrayref" and returns the results either as tab separated  string  or  formatted
       using Text::Table if the module is available.

       If you find yourself using this often to create reports, you may really want to look at Querylet instead.

       •   "sth" - the executed statement handle

       •   "formatter"  -  if  you  want  to  force  "tab"  or  "Text::Table"  usage, you can do it through that
           parameter.  In fact, the module will use anything other than "tab" as the class name and assume  that
           the interface is compatible to "Text::Table".

       •   "no_header_when_empty" - don't print anything if there are no results

       •   "rotate" - rotate the table by 90° , outputting columns as rows

       •   "null" - string to replace SQL "NULL" columns by

       Note  that  the query results are returned as one large string, so you really do not want to run this for
       large(r) result sets.

   <b>"DBIx::RunSQL-&gt;split_sql</b> <b>ARGS"</b>
         my @statements= DBIx::RunSQL-&gt;split_sql( &lt;&lt;'SQL');
             create table foo (name <a href="../man64/varchar.64.html">varchar</a>(64));
             create trigger foo_insert on foo before insert;
                 new.name= 'foo-'||old.name;
             end;
             insert into foo name values ('bar');
         SQL
         # Returns three elements

       This is a helper subroutine to split a sequence  of  (semicolon-newline-delimited)  SQL  statements  into
       separate  statements.  It  is  documented because it is not a very smart subroutine and you might want to
       override or replace it. It might also be useful outside the context of DBIx::RunSQL if you need to  split
       up a large blob of SQL statements into smaller pieces.

       The  subroutine needs the whole sequence of SQL statements in memory.  If you are attempting to restore a
       large SQL dump backup into your database, this approach might not be suitable.

   <b>"DBIx::RunSQL-&gt;parse_command_line"</b>
           my $options = DBIx::RunSQL-&gt;parse_command_line( 'my_application', \@ARGV );

       Helper function to turn a command line array into options for  DBIx::RunSQL  invocations.  The  array  of
       command line items is modified in-place.

       If the reference to the array of command line items is missing, @ARGV will be modified instead.

   <b>"DBIx::RunSQL-&gt;handle_command_line"</b>
           DBIx::RunSQL-&gt;handle_command_line( 'my_application', \@ARGV );

       Helper function to run the module functionality from the command line. See below how to use this function
       in  a  good self-contained script.  This function passes the following command line arguments and options
       to "-&gt;create":

         --user
         --password
         --dsn
         --sql
         --quiet
         --format
         --force
         --verbose
         --bool
         --string
         --rotate
         --null

       In addition, it handles the following switches through Pod::Usage:

         --help
         --man

       If no SQL is given, this function will read the SQL from STDIN.

       If no dsn is given, this function will  use  "  dbi:SQLite:dbname=db/$appname.sqlite  "  as  the  default
       database.

       See also the section PROGRAMMER USAGE for a sample program to set up a database from an SQL file.

</pre><h4><b>PROGRAMMER</b> <b>USAGE</b></h4><pre>
       This  module abstracts away the "run these SQL statements to set up your database" into a module. In some
       situations you want to give the setup SQL to a database admin,  but  in  other  situations,  for  example
       testing, you want to run the SQL statements against an in-memory database. This module abstracts away the
       reading  of  SQL  from  a file and allows for various command line parameters to be passed in. A skeleton
       "create-db.pl" looks like this:

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
           use strict;
           use DBIx::RunSQL;

           my $exitcode = DBIx::RunSQL-&gt;handle_command_line('myapp', \@ARGV);
           exit $exitcode;

           =head1 NAME

           create-db.pl - Create the database

           =head1 SYNOPSIS

             create-db.pl "select * from mytable where 1=0"

           =head1 ABSTRACT

           This sets up the database. The following
           options are recognized:

           =head1 OPTIONS

           =over 4

           =item C&lt;--user&gt; USERNAME

           =item C&lt;--password&gt; PASSWORD

           =item C&lt;--dsn&gt; DSN

           The DBI DSN to use for connecting to
           the database

           =item C&lt;--sql&gt; SQLFILE

           The alternative SQL file to use
           instead of C&lt;sql/create.sql&gt;.

           =item C&lt;--quiet&gt;

           Output no headers for empty SELECT resultsets

           =item C&lt;--bool&gt;

           Set the exit code to 1 if at least one result row was found

           =item C&lt;--string&gt;

           Output the (single) column that the query returns as a string without
           any headers

           =item C&lt;--format&gt; formatter

           Use a different formatter for table output. Supported formatters are

             tab - output results as tab delimited columns

             Text::Table - output results as ASCII table

           =item C&lt;--force&gt;

           Don't stop on errors

           =item C&lt;--help&gt;

           Show this message.

           =back

           =cut

</pre><h4><b>NOTES</b></h4><pre>
   <b>COMMENT</b> <b>FILTERING</b>
       The module tries to keep the SQL as much  verbatim  as  possible.  It  filters  all  lines  that  end  in
       semicolons  but contain only SQL comments. All other comments are passed through to the database with the
       next statement.

   <b>TRIGGER</b> <b>HANDLING</b>
       This module uses a very simplicistic approach to recognize triggers.  Triggers  are  problematic  because
       they  consist of multiple SQL statements and this module does not implement a full SQL parser. An trigger
       is recognized by the following sequence of lines

           CREATE TRIGGER
               ...
           END;

       If your SQL dialect uses a different syntax, it might still work to put the whole  trigger  on  a  single
       line in the input file.

   <b>OTHER</b> <b>APPROACHES</b>
       If  you  find yourself wanting to write SELECT statements, consider looking at Querylet instead, which is
       geared towards that and even has an interface for Excel or HTML output.

       If you find yourself wanting  to  write  parametrized  queries  as  ".sql"  files,  consider  looking  at
       Data::Phrasebook::SQL or potentially DBIx::SQLHandler.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       ORLite::Migrate

       Test::SQLite - SQLite setup/teardown for tests, mostly geared towards testing, not general database setup

</pre><h4><b>REPOSITORY</b></h4><pre>
       The public repository of this module is &lt;https://github.com/Corion/DBIx--RunSQL&gt;.

</pre><h4><b>SUPPORT</b></h4><pre>
       The public support forum of this module is &lt;https://perlmonks.org/&gt;.

</pre><h4><b>BUG</b> <b>TRACKER</b></h4><pre>
       Please     report     bugs     in     this     module     via     the    RT    CPAN    bug    queue    at
       &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=DBIx-RunSQL&gt;       or        via        mail        to
       <a href="mailto:bug-dbix-runsql@rt.cpan.org">bug-dbix-runsql@rt.cpan.org</a>.

</pre><h4><b>AUTHOR</b></h4><pre>
       Max Maischein "<a href="mailto:corion@cpan.org">corion@cpan.org</a>"

</pre><h4><b>COPYRIGHT</b> <b>(c)</b></h4><pre>
       Copyright 2009-2021 by Max Maischein "<a href="mailto:corion@cpan.org">corion@cpan.org</a>".

</pre><h4><b>LICENSE</b></h4><pre>
       This module is released under the same terms as Perl itself.

perl v5.40.0                                       2024-08-17                                  <u>DBIx::<a href="../man3pm/RunSQL.3pm.html">RunSQL</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>