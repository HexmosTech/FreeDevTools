<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sqitchtutorial-mysql - A tutorial introduction to Sqitch change management on MySQL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/sqitch">sqitch_1.5.2-1_all</a> <br><br><pre>
</pre><h4><b>Name</b></h4><pre>
       sqitchtutorial-mysql - A tutorial introduction to Sqitch change management on MySQL

</pre><h4><b>Synopsis</b></h4><pre>
         sqitch *

</pre><h4><b>Description</b></h4><pre>
       This tutorial explains how to create a sqitch-enabled MySQL 5.7 project, use a VCS for deployment
       planning, and work with other developers to make sure changes remain in sync and in the proper order.

       We'll start by creating new project from scratch, a fictional antisocial networking site called Flipr.
       All examples use Git &lt;https://git-scm.com/&gt; as the VCS and MySQL &lt;https://dev.mysql.com/&gt; as the storage
       engine.

       If you'd like to manage a PostgreSQL database, see sqitchtutorial.

       If you'd like to manage an SQLite database, see sqitchtutorial-sqlite.

       If you'd like to manage an Oracle database, see sqitchtutorial-oracle.

       If you'd like to manage a Firebird database, see sqitchtutorial-firebird.

       If you'd like to manage a Vertica database, see sqitchtutorial-vertica.

       If you'd like to manage an Exasol database, see sqitchtutorial-exasol.

       If you'd like to manage a Snowflake database, see sqitchtutorial-snowflake.

</pre><h4><b>Starting</b> <b>a</b> <b>New</b> <b>Project</b></h4><pre>
       Usually the first thing to do when starting a new project is to create a source code repository. So let's
       do that with Git:

         &gt; mkdir flipr
         &gt; cd flipr
         &gt; git init .
         Initialized empty Git repository in /flipr/.git/
         &gt; touch README.md
         &gt; git add .
         &gt; git commit -am 'Initialize project, add README.'
         [main (root-commit) fdf2a40] Initialize project, add README.
          1 file changed, 38 insertions(+)
          create mode 100644 README.md

       If you're a Git user and want to follow along the history, the repository used in these examples is on
       GitHub &lt;https://github.com/sqitchers/sqitch-mysql-intro&gt;.

       Now that we have a repository, let's get started with Sqitch. Every Sqitch project must have a name
       associated with it, and, optionally, a unique URI. We recommend including the URI, as it increases the
       uniqueness of object identifiers internally, and will prevent the deployment of a different project with
       the same name. So let's specify one when we initialize Sqitch:

         &gt; sqitch init flipr --uri https://github.com/sqitchers/sqitch-mysql-intro/ --engine mysql
         Created sqitch.conf
         Created sqitch.plan
         Created deploy/
         Created revert/
         Created verify/

       Let's have a look at <u>sqitch.conf</u>:

         &gt; cat sqitch.conf
         [core]
               engine = mysql
               # plan_file = sqitch.plan
               # top_dir = .
         # [engine "mysql"]
               # target = db:mysql:
               # registry = sqitch
               # client = mysql

       Good, it picked up on the fact that we're creating changes for the MySQL engine, thanks to the "--engine
       mysql" option, and saved it to the file.  Furthermore, it wrote a commented-out "[engine "mysql"]"
       section with all the available MySQL engine-specific settings commented out and ready to be edited as
       appropriate.

       By default, Sqitch will read <u>sqitch.conf</u> in the current directory for settings. But it will also read
       <u><a href="file:~/.sqitch/sqitch.conf">~/.sqitch/sqitch.conf</a></u> for user-specific settings. Since MySQL's "mysql client"
       &lt;https://dev.mysql.com/doc/refman/5.7/en/mysql.html&gt; is not in the path on my system, let's go ahead an
       tell it where to find the client on our computer (don't bother if you're using the Docker image
       &lt;https://hub.docker.com/r/sqitch/sqitch/&gt; because it uses the client inside the container, not on your
       host machine):

         &gt; sqitch config --user engine.mysql.client /usr/local/mysql/bin/mysql

       And let's also tell it who we are, since this data will be used in all of our projects:

         &gt; sqitch config --user user.name 'Marge N. O’Vera'
         &gt; sqitch config --user user.email '<a href="mailto:marge@example.com">marge@example.com</a>'

       Have a look at <u><a href="file:~/.sqitch/sqitch.conf">~/.sqitch/sqitch.conf</a></u> and you'll see this:

         &gt; cat <a href="file:~/.sqitch/sqitch.conf">~/.sqitch/sqitch.conf</a>
         [engine "mysql"]
               client = /usr/local/mysql/bin/mysql
         [user]
               name = Marge N. O’Vera
               email = <a href="mailto:marge@example.com">marge@example.com</a>

       Which means that Sqitch should be able to find "mysql" for any project, and that it will always properly
       identify us when planning and committing changes.

       Back to the repository. Have a look at the plan file, <u>sqitch.plan</u>:

         &gt; cat sqitch.plan
         %syntax-version=1.0.0
         %project=flipr
         %uri=https://github.com/sqitchers/sqitch-mysql-intro/

       Note that it has picked up on the name and URI of the app we're building.  Sqitch uses this data to
       manage cross-project dependencies. The "%syntax-version" pragma is always set by Sqitch, so that it
       always knows how to parse the plan, even if the format changes in the future.

       Let's commit these changes and start creating the database changes.

         &gt; git add .
         &gt; git commit -am 'Initialize Sqitch configuration.'
         [main 79fe2cc] Initialize Sqitch configuration.
          2 files changed, 19 insertions(+)
          create mode 100644 sqitch.conf
          create mode 100644 sqitch.plan

</pre><h4><b>Our</b> <b>First</b> <b>Change</b></h4><pre>
       First, our app will need a database user, so let's create one. Run this command:

         &gt; sqitch add appuser -n 'Creates a an application user.'
         Created deploy/appuser.sql
         Created revert/appuser.sql
         Created verify/appuser.sql
         Added "appuser" to sqitch.plan

       The "add" command adds a database change to the plan and writes deploy, revert, and verify scripts that
       represent the change. Now we edit these files. The "deploy" script's job is to create the table. By
       default, the <u>deploy/appuser.sql</u> file looks like this:

         -- Deploy flipr:appuser to mysql

         BEGIN;

         -- XXX Add DDLs here.

         COMMIT;

       What we want to do is to replace the "XXX" comment with the "CREATE USER" statement, like so:

         -- Deploy flipr:users to mysql

         BEGIN;

         CREATE USER flipr;

         COMMIT;

       The "revert" script's job is to precisely revert the change to the deploy script, so we edit this to
       <u>revert/appuser.sql</u> to look like this:

         -- Revert flipr:users from mysql

         BEGIN;

         DROP USER flipr;

         COMMIT;

       Now we can try deploying this change. First, we need to create a database to deploy to:

         &gt; mysql -u root --execute 'CREATE DATABASE flipr_test'

       Now we tell Sqitch where to send the change via a database URI &lt;https://github.com/libwww-perl/uri-db/&gt;:

         &gt; sqitch deploy db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         Deploying changes to db:mysql:/<a href="file:/root">/root</a>@/flipr_test
           + appuser .. ok

       First Sqitch created the registry database and tables used to track database changes. The registry
       database is separate from the database to which the "appuser" change was deployed; by default, its name
       is "sqitch", and will be used to manage <u>all</u> projects on a single MySQL server. Ideally, only Sqitch data
       will be stored in this database, so it probably makes the most sense to create a superuser named "sqitch"
       or something similar and use it to deploy changes.

       If you'd like it to use a different database as the registry database, use "sqitch engine add mysql
       $name" to configure it (or via the "target" command; more below). This will be useful if you don't want
       to use the same registry database to manage multiple databases on the same server.

       Next, Sqitch deploys changes to the target database, which we specified on the command-line. We only have
       one change so far; the "+" reinforces the idea that the change is being <u>added</u> to the database.

       With this change deployed, if you connect to the database, you'll be able to see the user:

         &gt; mysql -u root --execute "SELECT user from mysql.user WHERE user = 'flipr';"
         +-------+
         | User  |
         +-------+
         | flipr |
         +-------+

   <b>Trust,</b> <b>But</b> <b>Verify</b>
       But that's too much work. do you really want to do something like that after every deploy?

       Here's where the "verify" script comes in. Its job is to test that the deploy did was it was supposed to.
       It should do so without regard to any data that might be in the database, and should throw an error if
       the deploy was not successful. The simplest way to see if a user exists is to check the "mysql.user"
       table.However, throwing an error in the event that the user does not exist is tricky in MySQL. To
       simplify things, on MySQL 5.5.0 and higher, Sqitch provides a custom function you can use in your tests,
       checkit(). It works kind of like a "CHECK" constraint in other databases: pass an expression as the first
       argument, and an error message as the second.  If the expression evaluates to false, an exception will be
       thrown with the error message.

       Give it a try. Put this query into <u>verify/appuser.sql</u>:

         SELECT sqitch.checkit(COUNT(*), 'User "flipr" does not exist')
           FROM mysql.user WHERE user = 'flipr';

       This will work well as long as we know that the registry database is named "sqitch". If you've set
       "engine.mysql.registry" to a different value, you will need to make sure you specify the correct database
       name in the script.

       In some configurations, Sqitch does not include checkit(). You can add it by connecting to the sqitch
       registry database as a super user and running:

         DELIMITER |
         CREATE FUNCTION checkit(doit INTEGER, message <a href="../man256/VARCHAR.256.html">VARCHAR</a>(256)) RETURNS INTEGER DETERMINISTIC
         BEGIN
             IF doit IS NULL OR doit = 0 THEN
                 SIGNAL SQLSTATE 'ERR0R' SET MESSAGE_TEXT = message;
             END IF;
             RETURN doit;
         END;
         |

       Now you can run the "verify" script with the "verify" command:

         &gt; sqitch verify db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         Verifying flipr_test
           * appuser .. ok
         Verify successful

       Looks good! If you want to make sure that the verify script correctly dies if the table doesn't exist,
       temporarily change the user name in the script to something that doesn't exist, something like:

         SELECT sqitch.checkit(COUNT(*), 'User "flipr" does not exist')
           FROM mysql.user WHERE user = 'nonesuch';

       Then "verify" again:

         &gt; sqitch verify db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         Verifying db:mysql:/<a href="file:/root">/root</a>@/flipr_test
           * appuser .. ERROR 1644 (ERR0R) at line 5 in file: 'verify/appuser.sql': User "flipr" does not exist
         # Verify script "verify/appuser.sql" failed.
         not ok

         Verify Summary Report
         ---------------------
         Changes: 1
         Errors:  1
         Verify failed

       The checkit() function is kind enough to use the error message to tell us what the problem is. Don't
       forget to change the table name back before continuing!

   <b>Status,</b> <b>Revert,</b> <b>Log,</b> <b>Repeat</b>
       For purely informational purposes, we can always see how a deployment was recorded via the "status"
       command, which reads the tables from the registry database:

         &gt; sqitch status db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         # On database db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         # Project:  flipr
         # Change:   f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
         # Name:     appuser
         # Deployed: 2013-12-31 13:13:17 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Nothing to deploy (up-to-date)

       Let's make sure that we can revert the change:

         &gt; sqitch revert db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         Revert all changes from db:mysql:/<a href="file:/root">/root</a>@/flipr_test? [Yes]
           - appuser .. ok

       The "revert" command first prompts to make sure that we really do want to revert. This is to prevent
       unnecessary accidents. You can pass the "-y" option to disable the prompt. Also, notice the "-" before
       the change name in the output, which reinforces that the change is being <u>removed</u> from the database. And
       now the schema should be gone:

         &gt; mysql -u root --execute "SELECT user from mysql.user WHERE user = 'flipr';"

       And the status message should reflect as much:

         &gt; sqitch status db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         # On database db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         No changes deployed

       Of course, since nothing is deployed, the "verify" command has nothing to verify:

         &gt; sqitch verify db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         Verifying db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         No changes deployed

       However, we still have a record that the change happened, visible via the "log" command:

         &gt; sqitch log db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         On database db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         Revert f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
         Name:      appuser
         Committer: Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         Date:      2013-12-31 13:26:39 -0800

             Creates a an application user.

         Deploy f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
         Name:      appuser
         Committer: Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         Date:      2013-12-31 13:13:17 -0800

             Creates a an application user.

       Note that the actions we took are shown in reverse chronological order, with the revert first and then
       the deploy.

       Cool. Now let's commit it.

         &gt; git add .
         &gt; git commit -m 'Add the "flipr" user.'
         [main c63acb9] Add the "flipr" user.
          4 files changed, 23 insertions(+)
          create mode 100644 deploy/appuser.sql
          create mode 100644 revert/appuser.sql
          create mode 100644 verify/appuser.sql

       And then deploy again. This time, let's use the "--verify" option, so that the "verify" script is applied
       when the change is deployed:

         &gt; sqitch deploy --verify db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         Deploying changes to db:mysql:/<a href="file:/root">/root</a>@/flipr_test
           + appuser .. ok

       And now the "flipr" user should be back:

         &gt; mysql -u root --execute "SELECT user from mysql.user WHERE user = 'flipr';"
         +-------+
         | user  |
         +-------+
         | flipr |
         +-------+

       When we look at the status, the deployment will be there:

         &gt; sqitch status db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         # On database db:mysql:/<a href="file:/root">/root</a>@/flipr_test
         # Project:  flipr
         # Change:   f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
         # Name:     appuser
         # Deployed: 2013-12-31 13:28:23 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Nothing to deploy (up-to-date)

</pre><h4><b>On</b> <b>Target</b></h4><pre>
       I'm getting a little tired of always having to type "db:mysql:/<a href="file:/root">/root</a>@/flipr_test", aren't you?  This
       database connection URI &lt;https://github.com/libwww-perl/uri-db/&gt; tells Sqitch how to connect to the
       deployment target, but we don't have to keep using the URI.  We can name the target:

         &gt; sqitch target add flipr_test db:mysql:/<a href="file:/root">/root</a>@/flipr_test

       The "target" command, inspired by "git-remote" &lt;https://git-scm.com/docs/git-remote&gt;, allows management
       of one or more named deployment targets. We've just added a target named "flipr_test", which means we can
       use the string "flipr_test" for the target, rather than the URI. But since we're doing so much testing,
       we can also tell Sqitch to deploy to the "flipr_test" target by default:

         &gt; sqitch engine add mysql flipr_test

       Now we can omit the target argument altogether, unless we need to deploy to another database. Which we
       will, eventually, but at least our examples will be simpler from here on in, e.g.:

         &gt; sqitch status
         # On database flipr_test
         # Project:  flipr
         # Change:   f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
         # Name:     appuser
         # Deployed: 2013-12-31 13:28:23 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Nothing to deploy (up-to-date)

       Yay, that allows things to be a little more concise. Let's also make sure that changes are verified after
       deploying them:

         &gt; sqitch config --bool deploy.verify true
         &gt; sqitch config --bool rebase.verify true

       We'll see the "rebase" command a bit later. In the meantime, let's commit the new configuration and and
       make some more changes!

         &gt; git commit -am 'Set default target and always verify.'
         [main c793050] Set default target and always verify.
          1 file changed, 8 insertions(+)

</pre><h4><b>Deploy</b> <b>with</b> <b>Dependency</b></h4><pre>
       Let's add another change, this time to create a table. Our app will need users, of course, so we'll
       create a table for them. First, add the new change:

         &gt; sqitch add users --requires appuser -n 'Creates table to track our users.'
         Created deploy/users.sql
         Created revert/users.sql
         Created verify/users.sql
         Added "users [appuser]" to sqitch.plan

       Note that we're requiring the "appuser" change as a dependency of the new "users" change. Although that
       change has already been added to the plan and therefore should always be applied before the "users"
       change, it's a good idea to be explicit about dependencies.

       Now edit the scripts. When you're done, <u>deploy/users.sql</u> should look like this:

         -- Deploy flipr:users to mysql
         -- requires: appuser

         BEGIN;

         CREATE TABLE users (
             nickname  <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512) PRIMARY KEY,
             password  <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512) NOT NULL,
             timestamp <a href="../man6/DATETIME.6.html">DATETIME</a>(6)  NOT NULL
         );

         GRANT SELECT ON TABLE users TO flipr;

         COMMIT;

       A few things to notice here. On the second line, the dependence on the "appuser" change has been listed.
       This doesn't do anything, but the default MySQL "deploy" template lists it here for your reference while
       editing the file. Useful, right?

       The "flipr" user has been granted "SELECT" access to the table. The app needs to read the data, right?
       This is why we need to require the "appuser" change.

       Now for the verify script. The simplest way to check that the table was created and has the expected
       columns without touching the data? Just select from the table with a false "WHERE" clause. Add this to
       <u>verify/users.sql</u>:

         SELECT nickname, password, timestamp
           FROM users
          WHERE 0;

       Now for the revert script: all we have to do is drop the table. Add this to <u>revert/users.sql</u>:

         DROP TABLE users;

       Couldn't be much simpler, right? Let's deploy this bad boy:

         &gt; sqitch deploy
         Deploying changes to flipr_test
           + users .. ok

       We know, since verification is enabled, that the table must have been created.  But for the purposes of
       visibility, let's have a quick look:

         &gt; mysql -u root -D flipr_test --execute 'SHOW TABLES'
         +----------------------+
         | Tables_in_flipr_test |
         +----------------------+
         | users                |
         +----------------------+

       We can also verify all currently deployed changes with the "verify" command:

         &gt; sqitch verify
         Verifying flipr_test
           * appuser .. ok
           * users .... ok
         Verify successful

       Now have a look at the status:

         &gt; sqitch status
         # On database flipr_test
         # Project:  flipr
         # Change:   2bd1190fdb324c2609f0c7f0cef73d8cb434ba0e
         # Name:     users
         # Deployed: 2013-12-31 13:34:25 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Nothing to deploy (up-to-date)

       Success! Let's make sure we can revert the change, as well:

         &gt; sqitch revert --to @HEAD^ -y
         Reverting changes to appuser from flipr_test
           - users .. ok

       Note that we've used the "--to" option to specify the change to revert to.  And what do we revert to? The
       symbolic tag @HEAD, when passed to "revert", always refers to the last change deployed to the database.
       (For other commands, it refers to the last change in the plan.)  Appending the caret ("^") tells Sqitch
       to select the change <u>prior</u> to the last deployed change. So we revert to "appuser", the penultimate
       change. The other potentially useful symbolic tag is @ROOT, which refers to the first change deployed to
       the database (or in the plan, depending on the command).

       Back to the database. The "users" table should be gone but the "flipr" user should still be around:

         &gt; mysql -u root -D flipr_test --execute 'SHOW TABLES'
         &gt; mysql -u root --execute "SELECT user from mysql.user WHERE user = 'flipr';"
         +-------+
         | User  |
         +-------+
         | flipr |
         +-------+

       The "status" command politely informs us that we have undeployed changes:

         &gt; sqitch status
         # On database flipr_test
         # Project:  flipr
         # Change:   f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
         # Name:     appuser
         # Deployed: 2013-12-31 13:28:23 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Undeployed change:
           * users

       As does the "verify" command:

         &gt; sqitch verify
         Verifying flipr_test
           * appuser .. ok
         Undeployed change:
           * users
         Verify successful

       Note that the verify is successful, because all currently-deployed changes are verified. The list of
       undeployed changes (just "users" here) reminds us about the current state.

       Okay, let's commit and deploy again:

         &gt; git add .
         &gt; git commit -am 'Add users table.'
         [main 7c99fb0] Add users table.
          4 files changed, 31 insertions(+)
          create mode 100644 deploy/users.sql
          create mode 100644 revert/users.sql
          create mode 100644 verify/users.sql
         &gt; sqitch deploy
         Deploying changes to flipr_test
           + users .. ok

       Looks good. Check the status:

         &gt; sqitch status
         # On database flipr_test
         # Project:  flipr
         # Change:   2bd1190fdb324c2609f0c7f0cef73d8cb434ba0e
         # Name:     users
         # Deployed: 2013-12-31 13:37:02 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Nothing to deploy (up-to-date)

       Excellent. Let's do some more!

</pre><h4><b>Add</b> <b>Two</b> <b>at</b> <b>Once</b></h4><pre>
       Let's add a couple more changes to add functions for managing users.

         &gt; sqitch add insert_user --requires users --requires appuser \
           -n 'Creates a function to insert a user.'
         Created deploy/insert_user.sql
         Created revert/insert_user.sql
         Created verify/insert_user.sql
         Added "insert_user [users appuser]" to sqitch.plan

         &gt; sqitch add change_pass --requires users --requires appuser \
           -n 'Creates a function to change a user password.'
         Created deploy/change_pass.sql
         Created revert/change_pass.sql
         Created verify/change_pass.sql
         Added "change_pass [users appuser]" to sqitch.plan

       Now might be a good time to have a look at the deployment plan:

         &gt; cat sqitch.plan
         %syntax-version=1.0.0
         %project=flipr
         %uri=https://github.com/sqitchers/sqitch-mysql-intro/

         appuser 2013-12-31T21:04:04Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a an application user.
         users [appuser] 2013-12-31T21:32:48Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates table to track our users.
         insert_user [users appuser] 2013-12-31T21:37:29Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to insert a user.
         change_pass [users appuser] 2013-12-31T21:37:36Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to change a user password.

       Each change appears on a single line with the name of the change, a bracketed list of dependencies, a
       timestamp, the name and email address of the user who planned the change, and a note.

       Let's write the code for the new changes. Here's what <u>deploy/insert_user.sql</u> should look like:

         -- Deploy flipr:insert_user to mysql
         -- requires: users
         -- requires: appuser

         BEGIN;

         DELIMITER //

         CREATE PROCEDURE insert_user(
             nickname <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512),
             password <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512)
         ) SQL SECURITY DEFINER
         BEGIN
             INSERT INTO users (nickname, password, timestamp)
             VALUES (nickname, md5(password), <a href="../man6/UTC_TIMESTAMP.6.html">UTC_TIMESTAMP</a>(6));
         END
         //

         DELIMITER ;

         GRANT EXECUTE ON PROCEDURE insert_user to flipr;

         COMMIT;

       Here's what <u>verify/insert_user.sql</u> might look like, using the Sqitch checkit() function again:

         -- Verify flipr:insert_user on mysql

         BEGIN;

         SELECT sqitch.checkit(COUNT(*), 'Procedure "insert_user" does not exist')
           FROM information_schema.routines
          WHERE routine_schema = database()
            AND routine_name = 'insert_user';

         ROLLBACK;

       We simply take advantage of the fact that the new procedure should be listed in the
       "information_schema.routines" table and throw an exception if it does not exist.

       And <u>revert/insert_user.sql</u> should look something like this:

         -- Revert flipr:insert_user from mysql
         BEGIN;
         DROP PROCEDURE insert_user;
         COMMIT;

       Now for "change_pass"; <u>deploy/change_pass.sql</u> might look like this:

         -- Deploy flipr:change_pass to mysql
         -- requires: users
         -- requires: appuser

         BEGIN;

         DELIMITER //

         CREATE FUNCTION change_pass(
             nickname <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512),
             oldpass  <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512),
             newpass  <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512)
         ) RETURNS INTEGER DETERMINISTIC SQL SECURITY DEFINER
         BEGIN
             UPDATE users
                SET password = md5(newpass)
              WHERE nickname = nickname
                AND password = md5(oldpass);
             RETURN ROW_COUNT();
         END;
         //

         DELIMITER ;

         GRANT EXECUTE ON FUNCTION change_pass to flipr;

         COMMIT;

       Use checkit() in <u>verify/change_pass.sql</u> again:

         BEGIN;
         SELECT sqitch.checkit(COUNT(*), 'Procedure "change_pass" does not exist')
           FROM information_schema.routines
          WHERE routine_schema = database()
            AND routine_name = 'change_pass';
         COMMIT;

       And of course, its "revert" script, <u>revert/change_pass.sql</u>, should look something like:

         -- Revert flipr:change_pass from mysql
         BEGIN;
         DROP FUNCTION change_pass;
         COMMIT;

       Try em out!

         &gt; sqitch deploy
         Deploying changes to flipr_test
           + insert_user .. ok
           + change_pass .. ok

       Do we have the functions? Of course we do, they were verified. Still, have a look:

         &gt; mysql -u root --execute "SELECT routine_name FROM information_schema.routines WHERE routine_schema = 'flipr_test'"
         +--------------+
         | routine_name |
         +--------------+
         | change_pass  |
         | insert_user  |
         +--------------+

       And what's the status?

         &gt; sqitch status
         # On database flipr_test
         # Project:  flipr
         # Change:   b0a598b91ce97cf1b95ded97a6452bf03231a2cd
         # Name:     change_pass
         # Deployed: 2013-12-31 13:39:49 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Nothing to deploy (up-to-date)

       Looks good. Let's make sure revert works:

         &gt; sqitch revert -y --to @HEAD^^
         Reverting changes to users from flipr_test
           - change_pass .. ok
           - insert_user .. ok
         &gt; mysql -u root --execute "SELECT routine_name FROM information_schema.routines WHERE routine_schema = 'flipr_test'"

       Note the use of "@HEAD^^" to specify that the revert be to two changes prior the last deployed change.
       Looks good. Let's do the commit and re-deploy dance:

         &gt; git add .
         &gt; git commit -m 'Add `insert_user()` and `change_pass()`.'
         [main 0f95e13] Add `insert_user()` and `change_pass()`.
          7 files changed, 86 insertions(+)
          create mode 100644 deploy/change_pass.sql
          create mode 100644 deploy/insert_user.sql
          create mode 100644 revert/change_pass.sql
          create mode 100644 revert/insert_user.sql
          create mode 100644 verify/change_pass.sql
          create mode 100644 verify/insert_user.sql

         &gt; sqitch deploy
         Deploying changes to flipr_test
           + insert_user .. ok
           + change_pass .. ok

         &gt; sqitch status
         # On database flipr_test
         # Project:  flipr
         # Change:   b0a598b91ce97cf1b95ded97a6452bf03231a2cd
         # Name:     change_pass
         # Deployed: 2013-12-31 13:40:40 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Nothing to deploy (up-to-date)

         &gt; sqitch verify
         Verifying flipr_test
           * appuser ...... ok
           * users ........ ok
           * insert_user .. ok
           * change_pass .. ok
         Verify successful

       Great, we're fully up-to-date!

</pre><h4><b>Ship</b> <b>It!</b></h4><pre>
       Let's do a first release of our app. Let's call it "1.0.0-dev1" Since we want to have it go out with
       deployments tied to the release, let's tag it:

         &gt; sqitch tag v1.0.0-dev1 -n 'Tag v1.0.0-dev1.'
         Tagged "change_pass" with @v1.0.0-dev1
         &gt; git commit -am 'Tag the database with v1.0.0-dev1.'
         [main 0595297] Tag the database with v1.0.0-dev1.
          1 file changed, 1 insertion(+)
         &gt; git tag v1.0.0-dev1 -am 'Tag v1.0.0-dev1'

       Now let's bundle everything up for release:

         &gt; sqitch bundle
         Bundling into bundle/
         Writing config
         Writing plan
         Writing scripts
           + appuser
           + users
           + insert_user
           + change_pass @v1.0.0-dev1

       Now we can package the <u>bundle</u> directory and distribute it. When it gets installed somewhere, users can
       use Sqitch to deploy to the database. We ought to try deploying it, but first we'll need to revert our
       existing databases, as a single Sqitch project cannot be deployed to two databases on the same server
       unless it uses a different registry database and the checkit() function is not used in verify scripts. We
       have used checkit() quite a bit, so we need to keep the Sqitch database name just where it is.
       Fortunately, it's easy to build the database again, so let's just revert it.

         &gt; sqitch revert -y
         Reverting all changes from flipr_test
           - change_pass .. ok
           - insert_user .. ok
           - users ........ ok
           - appuser ...... ok

       Now we can try deploying the bundle:

         &gt; cd bundle
         &gt; mysql -u root --execute 'CREATE DATABASE flipr_dev'
         &gt; sqitch deploy db:mysql:/<a href="file:/root">/root</a>@/flipr_dev
         Deploying changes to db:mysql:/<a href="file:/root">/root</a>@/flipr_dev
           + appuser ................... ok
           + users ..................... ok
           + insert_user ............... ok
           + change_pass @v1.0.0-dev1 .. ok

       Great, all four changes were deployed and "change_pass" was tagged with "@v1.0.0-dev1". Let's have a look
       at the status:

         &gt; sqitch status db:mysql:/<a href="file:/root">/root</a>@/flipr_dev
         # On database db:mysql:/<a href="file:/root">/root</a>@/flipr_dev
         # Project:  flipr
         # Change:   b0a598b91ce97cf1b95ded97a6452bf03231a2cd
         # Name:     change_pass
         # Tag:      @v1.0.0-dev1
         # Deployed: 2013-12-31 13:44:04 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Nothing to deploy (up-to-date)

       Looks good, eh? Go ahead and revert it:

         &gt; sqitch revert -y db:mysql:/<a href="file:/root">/root</a>@/flipr_dev
         Reverting all changes from db:mysql:/<a href="file:/root">/root</a>@/flipr_dev
           - change_pass @v1.0.0-dev1 .. ok
           - insert_user ............... ok
           - users ..................... ok
           - appuser ................... ok

       Now package it up and ship it!

         &gt; cd ..
         &gt; mv bundle flipr-v1.0.0-dev1
         &gt; tar -czf flipr-v1.0.0-dev1.tgz flipr-v1.0.0-dev1

</pre><h4><b>Flip</b> <b>Out</b></h4><pre>
       Now that we've got the basics of user management done, let's get to work on the core of our product, the
       "flip." Since other folks are working on other tasks in the repository, we'll work on a branch, so we can
       all stay out of each other's way. So let's branch:

         &gt; git checkout -b flips
         Switched to a new branch 'flips'

       Now we can add a new change to create a table for our flips.

         &gt; sqitch add flips -r appuser -r users -n 'Adds table for storing flips.'
         Created deploy/flips.sql
         Created revert/flips.sql
         Created verify/flips.sql
         Added "flips [appuser users]" to sqitch.plan

       You know the drill by now. Edit <u>deploy/flips.sql</u>:

         -- Deploy flipr:flips to mysql
         -- requires: appuser
         -- requires: users

         BEGIN;

         CREATE TABLE flips (
             id        BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
             nickname  <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512) NOT NULL REFERENCES users(nickname),
             body      <a href="../man180/VARCHAR.180.html">VARCHAR</a>(180) NOT NULL,
             timestamp <a href="../man6/DATETIME.6.html">DATETIME</a>(6)  NOT NULL
         );

         GRANT SELECT ON TABLE flips TO flipr;

         COMMIT;

       Edit <u>verify/flips.sql</u>:

         -- Verify flipr:flips on mysql

         BEGIN;

         SELECT id
              , nickname
              , body
              , timestamp
           FROM flipr.flips
          WHERE 0;

         ROLLBACK;

       And edit <u>revert/flips.sql</u>:

         -- Revert flipr:flips from mysql

         BEGIN;

         DROP TABLE flips;

         COMMIT;

       And give it a whirl:

         &gt; sqitch deploy
         Deploying changes to flipr_test
           + appuser ................... ok
           + users ..................... ok
           + insert_user ............... ok
           + change_pass @v1.0.0-dev1 .. ok

       Look good?

         &gt; sqitch status --show-tags
         # On database flipr_test
         # Project:  flipr
         # Change:   b3ccd37da58ac232c23edfa0adaf2d6f483842fd
         # Name:     flips
         # Deployed: 2013-12-31 13:55:04 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         # Tag:
         #   @v1.0.0-dev1 - 2013-12-31 13:55:04 -0800 - Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Nothing to deploy (up-to-date)

       Note the use of "--show-tags" to show all the deployed tags. Now make it so:

         &gt; git add .
         &gt; git commit -am 'Add flips table.'
         [flips ce1b53d] Add flips table.
          4 files changed, 37 insertions(+)
          create mode 100644 deploy/flips.sql
          create mode 100644 revert/flips.sql
          create mode 100644 verify/flips.sql

</pre><h4><b>Wash,</b> <b>Rinse,</b> <b>Repeat</b></h4><pre>
       Now comes the time to add functions to manage flips. I'm sure you have things nailed down now. Go ahead
       and add "insert_flip" and "delete_flip" changes and commit them. The "insert_flip" deploy script might
       look something like:

         -- Deploy flipr:insert_flip to mysql
         -- requires: flips
         -- requires: appuser

         BEGIN;

         DELIMITER //

         CREATE FUNCTION insert_flip(
             nickname <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512),
             body     <a href="../man180/VARCHAR.180.html">VARCHAR</a>(180)
         ) RETURNS BIGINT DETERMINISTIC SQL SECURITY DEFINER
         BEGIN
             INSERT INTO flips (nickname, body)
             VALUES (nickname, body);
             RETURN LAST_INSERT_ID();
         END;
         //

         DELIMITER ;

         GRANT EXECUTE ON FUNCTION insert_flip to flipr;

         COMMIT;

       And the "delete_flip" deploy script might look something like:

         -- Deploy flipr:delete_flip to mysql
         -- requires: flips
         -- requires: appuser

         BEGIN;

         DELIMITER //

         CREATE FUNCTION delete_flip(
             flip_id BIGINT
         ) RETURNS INTEGER DETERMINISTIC SQL SECURITY DEFINER
         BEGIN
             DELETE FROM flips WHERE id = flip_id;
             RETURN ROW_COUNT();
         END;
         //

         DELIMITER ;

         GRANT EXECUTE ON FUNCTION delete_flip to flipr;

         COMMIT;

       The "verify" scripts are:

         -- Verify flipr:insert_flip on mysql

         BEGIN;

         SELECT sqitch.checkit(COUNT(*), 'Function "insert_flip" does not exist')
           FROM information_schema.routines
          WHERE routine_schema = database()
            AND routine_name = 'insert_flip';

         ROLLBACK;

       And:

         -- Verify flipr:delete_flip on mysql

         BEGIN;

         SELECT sqitch.checkit(COUNT(*), 'Function "delete_flip" does not exist')
           FROM information_schema.routines
          WHERE routine_schema = database()
            AND routine_name = 'delete_flip';

         ROLLBACK;

       The "revert" scripts are:

         -- Revert flipr:insert_flip from mysql

         BEGIN;

         DROP FUNCTION insert_flip;

         COMMIT;

       And:

         -- Revert flipr:delete_flip from mysql

         BEGIN;

         DROP FUNCTION delete_flip;

         COMMIT;

       Check the example git repository &lt;https://github.com/sqitchers/sqitch-intro&gt; for the complete details.
       Test "deploy" and "revert", then commit it to the repository. The status should end up looking something
       like this:

         &gt; sqitch status --show-tags
         # On database flipr_test
         # Project:  flipr
         # Change:   7bf30e6b7b0a4e61f30dd4148f5b837bdddae086
         # Name:     delete_flip
         # Deployed: 2013-12-31 13:58:54 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         # Tag:
         #   @v1.0.0-dev1 - 2013-12-31 13:55:04 -0800 - Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Nothing to deploy (up-to-date)

       Good, we've finished this feature. Time to merge back into "main".

   <b>Emergency</b>
       Let's do it:

         &gt; git checkout main
         Switched to branch 'main'
         &gt; git pull
         Updating 0595297..5a58089
         Fast-forward
          deploy/delete_list.sql | 22 ++++++++++++++++++++++
          deploy/insert_list.sql | 25 +++++++++++++++++++++++++
          deploy/lists.sql       | 17 +++++++++++++++++
          revert/delete_list.sql |  7 +++++++
          revert/insert_list.sql |  7 +++++++
          revert/lists.sql       |  7 +++++++
          sqitch.plan            |  4 ++++
          verify/delete_list.sql | 10 ++++++++++
          verify/insert_list.sql | 10 ++++++++++
          verify/lists.sql       |  8 ++++++++
          10 files changed, 117 insertions(+)
          create mode 100644 deploy/delete_list.sql
          create mode 100644 deploy/insert_list.sql
          create mode 100644 deploy/lists.sql
          create mode 100644 revert/delete_list.sql
          create mode 100644 revert/insert_list.sql
          create mode 100644 revert/lists.sql
          create mode 100644 verify/delete_list.sql
          create mode 100644 verify/insert_list.sql
          create mode 100644 verify/lists.sql

       Hrm, that's interesting. Looks like someone made some changes to "main".  They added list support. Well,
       let's see what happens when we merge our changes.

         &gt; git merge --no-ff flips
         Auto-merging sqitch.plan
         CONFLICT (content): Merge conflict in sqitch.plan
         Automatic merge failed; fix conflicts and then commit the result.

       Oh, a conflict in <u>sqitch.plan</u>. Not too surprising, since both the merged "lists" branch and our "flips"
       branch added changes to the plan. Let's try a different approach.

       The truth is, we got lazy. Those changes when we pulled main from the origin should have raised a red
       flag. It's considered a bad practice not to look at what's changed in "main" before merging in a branch.
       What one <u>should</u> do is either:

       •   Rebase  the  <u>flips</u>  branch  from  main  before merging. This "rewinds" the branch changes, pulls from
           "main", and then replays the changes back on top of the pulled changes.

       •   Create a patch and apply <u>that</u> to main. This is the sort of thing you  might  have  to  do  if  you're
           sending changes to another user, especially if the VCS is not Git.

       So let's restore things to how they were at main:

         &gt; git reset --hard HEAD
         HEAD is now at 5a58089 Merge branch 'lists'

       That throws out our botched merge. Now let's go back to our branch and rebase it on "main":

         &gt; git checkout flips
         Switched to branch 'flips'
         &gt; git rebase main
         First, rewinding head to replay your work on top of it...
         Applying: Add flips table.
         Using index info to reconstruct a base tree...
         M     sqitch.plan
         Falling back to patching base and 3-way merge...
         Auto-merging sqitch.plan
         CONFLICT (content): Merge conflict in sqitch.plan
         Failed to merge in the changes.
         Patch failed at 0001 Add flips table.
         The copy of the patch that failed is found in:
            .git/rebase-apply/patch

         When you have resolved this problem, run "git rebase --continue".
         If you prefer to skip this patch, run "git rebase --skip" instead.
         To check out the original branch and stop rebasing, run "git rebase --abort".

       Oy,  that's  kind  of a pain. It seems like no matter what we do, we'll need to resolve conflicts in that
       file. Except in Git. Fortunately for us, we can tell Git to resolve conflicts in <u>sqitch.plan</u> differently.
       Because we only ever append lines to the file, we can have  it  use  the  "union"  merge  driver,  which,
       according to its docs &lt;https://git-scm.com/docs/gitattributes#_built-in_merge_drivers&gt;:

           Run  3-way  file  level  merge  for text files, but take lines from both versions, instead of leaving
           conflict markers. This tends to leave the added lines in the resulting file in random order  and  the
           user should verify the result. Do not use this if you do not understand the implications.

       This  has  the  effect  of  appending lines from all the merging files, which is exactly what we need. So
       let's give it a try. First, back out the botched rebase:

         &gt; git rebase --abort

       Now add the union merge driver to <u>.gitattributes</u> for <u>sqitch.plan</u> and rebase again:

         &gt; echo sqitch.plan merge=union &gt; .gitattributes
         &gt; git rebase main
         First, rewinding head to replay your work on top of it...
         Applying: Add flips table.
         Using index info to reconstruct a base tree...
         M     sqitch.plan
         Falling back to patching base and 3-way merge...
         Auto-merging sqitch.plan
         Applying: Add functions to insert and delete flips.
         Using index info to reconstruct a base tree...
         M     sqitch.plan
         Falling back to patching base and 3-way merge...
         Auto-merging sqitch.plan

       Ah, that looks a bit better. Let's have a look at the plan:

         &gt; cat sqitch.plan
         %syntax-version=1.0.0
         %project=flipr
         %uri=https://github.com/sqitchers/sqitch-mysql-intro/

         appuser 2013-12-31T21:04:04Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a an application user.
         users [appuser] 2013-12-31T21:32:48Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates table to track our users.
         insert_user [users appuser] 2013-12-31T21:37:29Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to insert a user.
         change_pass [users appuser] 2013-12-31T21:37:36Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to change a user password.
         @v1.0.0-dev1 2013-12-31T21:41:08Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Tag v1.0.0-dev1.

         lists [appuser users] 2013-12-31T21:46:22Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Adds table for storing lists.
         insert_list [lists appuser] 2013-12-31T21:48:14Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to insert a list.
         delete_list [lists appuser] 2013-12-31T21:49:41Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to insert a list.
         flips [appuser users] 2013-12-31T21:53:03Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Adds table for storing flips.
         insert_flip [flips appuser] 2013-12-31T21:56:12Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to insert a flip.
         delete_flip [flips appuser] 2013-12-31T21:56:22Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to delete a flip.

       Note that it has appended the changes from the merged "lists" branch, and then merged  the  changes  from
       our "flips" branch. Test it to make sure it works as expected:

         &gt; sqitch rebase -y
         Reverting all changes from flipr_test
           - delete_flip ............... ok
           - insert_flip ............... ok
           - flips ..................... ok
           - change_pass @v1.0.0-dev1 .. ok
           - insert_user ............... ok
           - users ..................... ok
           - appuser ................... ok
         Deploying changes to flipr_test
           + appuser ................... ok
           + users ..................... ok
           + insert_user ............... ok
           + change_pass @v1.0.0-dev1 .. ok
           + lists ..................... ok
           + insert_list ............... ok
           + delete_list ............... ok
           + flips ..................... ok
           + insert_flip ............... ok
           + delete_flip ............... ok

       Note  the  use of "rebase", which combines a "revert" and a "deploy" into a single command. Handy, right?
       It correctly reverted our changes, and then deployed them all again in the proper order. So let's  commit
       <u>.gitattributes</u>; seems worthwhile to keep that change:

         &gt; git add .
         &gt; git commit -m 'Add `.gitattributes` with union merge for `sqitch.plan`.'
         [flips d813f7c] Add `.gitattributes` with union merge for `sqitch.plan`.
          1 file changed, 1 insertion(+)
          create mode 100644 .gitattributes

   <b>Merges</b> <b>Mastered</b>
       And now, finally, we can merge into "main":

         &gt; git checkout main
         Switched to branch 'main'
         &gt; git merge --no-ff flips -m "Merge branch 'flips'"
         Merge made by the 'recursive' strategy.
          .gitattributes         |  1 +
          deploy/delete_flip.sql | 22 ++++++++++++++++++++++
          deploy/flips.sql       | 16 ++++++++++++++++
          deploy/insert_flip.sql | 24 ++++++++++++++++++++++++
          revert/delete_flip.sql |  7 +++++++
          revert/flips.sql       |  7 +++++++
          revert/insert_flip.sql |  7 +++++++
          sqitch.plan            |  3 +++
          verify/delete_flip.sql | 10 ++++++++++
          verify/flips.sql       | 12 ++++++++++++
          verify/insert_flip.sql | 10 ++++++++++
          11 files changed, 119 insertions(+)
          create mode 100644 .gitattributes
          create mode 100644 deploy/delete_flip.sql
          create mode 100644 deploy/flips.sql
          create mode 100644 deploy/insert_flip.sql
          create mode 100644 revert/delete_flip.sql
          create mode 100644 revert/flips.sql
          create mode 100644 revert/insert_flip.sql
          create mode 100644 verify/delete_flip.sql
          create mode 100644 verify/flips.sql
          create mode 100644 verify/insert_flip.sql

       And double-check our work:

         &gt; cat sqitch.plan
         %syntax-version=1.0.0
         %project=flipr
         %uri=https://github.com/sqitchers/sqitch-mysql-intro/

         appuser 2013-12-31T21:04:04Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a an application user.
         users [appuser] 2013-12-31T21:32:48Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates table to track our users.
         insert_user [users appuser] 2013-12-31T21:37:29Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to insert a user.
         change_pass [users appuser] 2013-12-31T21:37:36Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to change a user password.
         @v1.0.0-dev1 2013-12-31T21:41:08Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Tag v1.0.0-dev1.

         lists [appuser users] 2013-12-31T21:46:22Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Adds table for storing lists.
         insert_list [lists appuser] 2013-12-31T21:48:14Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to insert a list.
         delete_list [lists appuser] 2013-12-31T21:49:41Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to insert a list.
         flips [appuser users] 2013-12-31T21:53:03Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Adds table for storing flips.
         insert_flip [flips appuser] 2013-12-31T21:56:12Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to insert a flip.
         delete_flip [flips appuser] 2013-12-31T21:56:22Z Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt; # Creates a function to delete a flip.

       Much  much  better,  a nice clean main now. And because it is now identical to the "flips" branch, we can
       just carry on. Go ahead and tag it, bundle, and release:

         &gt; sqitch tag v1.0.0-dev2 -n 'Tag v1.0.0-dev2.'
         Tagged "delete_flip" with @v1.0.0-dev2
         &gt; git commit -am 'Tag the database with v1.0.0-dev2.'
         [main 76d6e15] Tag the database with v1.0.0-dev2.
          1 file changed, 1 insertion(+)
         &gt; git tag v1.0.0-dev2 -am 'Tag v1.0.0-dev2'
         &gt; sqitch bundle --dest-dir flipr-1.0.0-dev2
         Bundling into flipr-1.0.0-dev2
         Writing config
         Writing plan
         Writing scripts
           + appuser
           + users
           + insert_user
           + change_pass @v1.0.0-dev1
           + lists
           + insert_list
           + delete_list
           + flips
           + insert_flip
           + delete_flip @v1.0.0-dev2

       Note the use of the "--dest-dir" option to "sqitch bundle". Just a nicer  way  to  create  the  top-level
       directory name so we don't have to rename it from <u>bundle</u>.

</pre><h4><b>In</b> <b>Place</b> <b>Changes</b></h4><pre>
       Uh-oh, someone just noticed that MD5 hashing is not particularly secure. Why?  Have a look at this:

         &gt; mysql -u root -D flipr_test --execute "
             CALL insert_user('foo', 'secr3t');
             CALL insert_user('bar', 'secr3t');
             SELECT * FROM users;
         "
         +----------+----------------------------------+----------------------------+
         | nickname | password                         | timestamp                  |
         +----------+----------------------------------+----------------------------+
         | bar      | 9695da4dd567a19f9b92065f240c6725 | 2013-12-31 22:06:28.359118 |
         | foo      | 9695da4dd567a19f9b92065f240c6725 | 2013-12-31 22:06:28.358789 |
         +----------+----------------------------------+----------------------------+

       If  user  "foo"  ever got access to the database, she could quickly discover that user "bar" has the same
       password and thus be able to  exploit  the  account.  Not  a  great  idea.  So  we  need  to  modify  the
       insert_user() and change_pass() functions to fix that. How?

       We      can      use      MySQL's      ENCRYPT()     &lt;https://dev.mysql.com/doc/refman/5.7/en/encryption-
       functions.html#function_encrypt&gt; function to encrypt passwords with a salt, so that they're  all  unique.
       But how to deploy the changes to insert_user() and change_pass()?

       Normally,       modifying       functions       in       database       changes       is      a      PITA
       &lt;https://www.urbandictionary.com/define.php?term=pita&gt;. You have to make changes like these:

       1.  Copy <u>deploy/insert_user.sql</u> to <u>deploy/insert_user_encrypt.sql</u>.

       2.  Edit <u>deploy/insert_user_encrypt.sql</u> to switch from MD5() to ENCRYPT().

       3.  Copy <u>deploy/insert_user.sql</u> to <u>revert/insert_user_encrypt.sql</u>.  Yes, copy the original change  script
           to the new revert change.

       4.  Copy <u>verify/insert_user.sql</u> to <u>verify/insert_user_encrypt.sql</u>.

       5.  Edit <u>verify/insert_user_encrypt.sql</u> to test that the function now properly uses ENCRYPT().

       6.  Test the changes to make sure you can deploy and revert the "insert_user_encrypt" change.

       7.  Now do the same for the "change_pass" scripts.

       But  you  can  have  Sqitch  do  it  for  you.  The only requirement is that a tag appear between the two
       instances of a change we want to modify. In general, you're going to make a  change  like  this  after  a
       release,  which  you've  tagged  anyway,  right?  Well we have, with "@v1.0.0-dev2" added in the previous
       section. With that, we can let Sqitch do most of the hard work for us, thanks to  the  "rework"  command,
       which is similar to "add":

         &gt; sqitch rework insert_user -n 'Change insert_user to use encyrpt().'
         Added "insert_user [<a href="mailto:insert_user@v1.0.0-dev2">insert_user@v1.0.0-dev2</a>]" to sqitch.plan.
         Modify these files as appropriate:
           * deploy/insert_user.sql
           * revert/insert_user.sql
           * verify/insert_user.sql

       Oh,  so  we  can  edit  those files in place. Nice! How does Sqitch do it? Well, in point of fact, it has
       copied the files to stand in for the previous instance of the "insert_user" change, which we can see  via
       "git status":

         &gt; git status
         # On branch main
         # Your branch is ahead of 'origin/main' by 5 commits.
         #   (use "git push" to publish your local commits)
         #
         # Changes not staged for commit:
         #   (use "git add &lt;file&gt;..." to update what will be committed)
         #   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
         #
         #     modified:   revert/insert_user.sql
         #     modified:   sqitch.plan
         #
         # Untracked files:
         #   (use "git add &lt;file&gt;..." to include in what will be committed)
         #
         #     deploy/<a href="mailto:insert_user@v1.0.0-dev2.sql">insert_user@v1.0.0-dev2.sql</a>
         #     revert/<a href="mailto:insert_user@v1.0.0-dev2.sql">insert_user@v1.0.0-dev2.sql</a>
         #     verify/<a href="mailto:insert_user@v1.0.0-dev2.sql">insert_user@v1.0.0-dev2.sql</a>
         no changes added to commit (use "git add" and/or "git commit -a")

       The  "untracked  files"  part  of  the  output  is  the  first  thing  to  notice.  They  are  all  named
       "<a href="mailto:insert_user@v1.0.0-dev2.sql">insert_user@v1.0.0-dev2.sql</a>". What that means is: "the "insert_user" change as it was implemented as  of
       the  "@v1.0.0-dev2" tag."  These are copies of the original scripts, and thereafter Sqitch will find them
       when it needs to run scripts for the first instance of the "insert_user" change. As such, it's  important
       not to change them again. But hey, if you're reworking the change, you shouldn't need to.

       The  other  thing  to  notice  is  that  <u>revert/insert_user.sql</u> has changed.  Sqitch replaced it with the
       original deploy script. As of now, <u>deploy/insert_user.sql</u> and <u>revert/insert_user.sql</u> are identical.  This
       is on the assumption that the deploy script will be changed (we're reworking it, remember?), and that the
       revert  script should actually change things back to how they were before. Of course, the original deploy
       script may not be idempotent &lt;https://en.wikipedia.org/wiki/Idempotence&gt; -- that is, able to  be  applied
       multiple  times  without changing the result beyond the initial application. If it's not, you will likely
       need to modify it so that it properly restores things to how they were after the original  deploy  script
       was  deployed.  Or,  more  simply, it should revert changes back to how they were as-of the deployment of
       <u>deploy/<a href="mailto:insert_user@v1.0.0-dev2.sql">insert_user@v1.0.0-dev2.sql</a></u>.

       Had MySQL supported an "OR REPLACE" expression on "CREATE FUNCTION" and we  had  used  it,  our  function
       deploy scripts would already idempotent. No matter how many times they were run, the end results would be
       the same instance of the function, with no duplicates or errors.

       Alas,  such  is not the case for MySQL, so we will have to modify the scripts to drop the function before
       re-creating it. So let's do it. We'll modify the scripts drop and re-create the  functions  with  to  use
       ENCRYPT(). Make this change to <u>deploy/insert_user.sql</u>:

         @@ -6,13 +6,14 @@ BEGIN;

          DELIMITER //

         +DROP PROCEDURE insert_user;
          CREATE PROCEDURE insert_user(
              nickname <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512),
              password <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512)
          ) SQL SECURITY DEFINER
          BEGIN
              INSERT INTO users (nickname, password, timestamp)
         -    VALUES (nickname, md5(password), <a href="../man6/UTC_TIMESTAMP.6.html">UTC_TIMESTAMP</a>(6));
         +    VALUES (nickname, ENCRYPT(md5(password), md5(FLOOR(RAND() * 0xFFFFFFFF))), <a href="../man6/UTC_TIMESTAMP.6.html">UTC_TIMESTAMP</a>(6));
          END
          //

       We just need to add the "DROP" statement to the revert script, <u>revert/insert_user.sql</u>:

         @@ -6,6 +6,7 @@ BEGIN;

          DELIMITER //

         +DROP PROCEDURE insert_user;
          CREATE PROCEDURE insert_user(
              nickname <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512),
              password <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512)

       Go ahead and rework the "change_pass" change, too:

         &gt; sqitch rework change_pass -n 'Change change_pass to use encyrpt().'
         Added "change_pass [<a href="mailto:change_pass@v1.0.0-dev2">change_pass@v1.0.0-dev2</a>]" to sqitch.plan.
         Modify these files as appropriate:
           * deploy/change_pass.sql
           * revert/change_pass.sql
           * verify/change_pass.sql

       And make this change to <u>deploy/change_pass.sql</u>:

         @@ -6,6 +6,7 @@ BEGIN;

          DELIMITER //

         +DROP FUNCTION change_pass;
          CREATE FUNCTION change_pass(
              nickname <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512),
              oldpass  <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512),
         @@ -13,9 +14,9 @@ CREATE FUNCTION change_pass(
          ) RETURNS INTEGER DETERMINISTIC SQL SECURITY DEFINER
          BEGIN
              UPDATE users
         -       SET password = md5(newpass)
         +       SET password = ENCRYPT(md5(newpass), md5(FLOOR(RAND() * 0xFFFFFFFF)))
               WHERE nickname = nickname
         -       AND password = md5(oldpass);
         +       AND password = ENCRYPT(md5(oldpass), password);
              RETURN ROW_COUNT();
          END;
          //

       And add the "DROP FUNCTION" statement to its revert script, too:

         @@ -6,6 +6,7 @@ BEGIN;

          DELIMITER //

         +DROP FUNCTION change_pass;
          CREATE FUNCTION change_pass(
              nickname <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512),
              oldpass  <a href="../man512/VARCHAR.512.html">VARCHAR</a>(512),

       And now we're ready to try a deployment:

         &gt;     sqitch deploy
         Deploying changes to flipr_test
           + insert_user .. ok
           + change_pass .. ok

       So, are the changes deployed?

         &gt; mysql -u root -D flipr_test --execute "
             DELETE FROM users;
             CALL insert_user('foo', 'secr3t');
             CALL insert_user('bar', 'secr3t');
             SELECT * FROM users;
         "
         +----------+---------------+----------------------------+
         | nickname | password      | timestamp                  |
         +----------+---------------+----------------------------+
         | bar      | 0aasvM1.AzY0Y | 2013-12-31 22:14:45.554942 |
         | foo      | 80v1DpnRrqbwo | 2013-12-31 22:14:45.554457 |
         +----------+---------------+----------------------------+

       Awesome,  the  stored  passwords are different now. But can we revert, even though we haven't written any
       reversion scripts?

         &gt; sqitch revert --to @HEAD^^ -y
         Reverting changes to delete_flip @v1.0.0-dev2 from flipr_test
           - change_pass .. ok
           - insert_user .. ok

       Did that work, are the MD5() passwords back?

         &gt; mysql -u root -D flipr_test --execute "
             DELETE FROM users;
             CALL insert_user('foo', 'secr3t');
             CALL insert_user('bar', 'secr3t');
             SELECT * FROM users;
         "
         +----------+----------------------------------+----------------------------+
         | nickname | password                         | timestamp                  |
         +----------+----------------------------------+----------------------------+
         | bar      | 9695da4dd567a19f9b92065f240c6725 | 2013-12-31 22:15:29.843140 |
         | foo      | 9695da4dd567a19f9b92065f240c6725 | 2013-12-31 22:15:29.842700 |
         +----------+----------------------------------+----------------------------+

       Yes, it works! Sqitch properly finds the original instances of these changes in the new script files that
       include tags.

       But what about the verify script? How can we  verify  that  the  functions  have  been  modified  to  use
       ENCRYPT()?  I  think  the  simplest  thing  to  do  is to examine the body of the function as returned by
       "INFORMATION_SCHEMA.ROUTINES"       &lt;https://dev.mysql.com/doc/refman/5.7/en/information-schema-routines-
       table.html&gt; So the "insert_user" verify script looks like this:

         -- Verify flipr:insert_user on mysql

         BEGIN;

         SELECT sqitch.checkit(COUNT(*), 'Procedure "insert_user" does not exist or is not up-to-date')
           FROM information_schema.routines
          WHERE routine_schema = database()
            AND routine_name = 'insert_user'
            AND routine_definition LIKE '%ENCRYPT(md5(password), md5(FLOOR(RAND() * 0xFFFFFFFF))%';

         ROLLBACK;

       And the "change_pass" verify script looks like this:

         -- Verify flipr:change_pass on mysql

         BEGIN;

         SELECT sqitch.checkit(COUNT(*), 'Procedure "change_pass" does not exist or is not up-to-date')
           FROM information_schema.routines
          WHERE routine_schema = database()
            AND routine_name = 'change_pass'
            AND routine_definition LIKE '%ENCRYPT(md5(oldpass), password)%';

         ROLLBACK;

       Make sure these pass by re-deploying:

         &gt; sqitch deploy
         Deploying changes to flipr_test
           + insert_user .. ok
           + change_pass .. ok

       Excellent. Let's go ahead and commit these changes:

         &gt; git add .
         &gt; git commit -m 'Use encrypt() to encrypt passwords.'
         [main abcce73] Use encrypt() to encrypt passwords.
          13 files changed, 137 insertions(+), 9 deletions(-)
          create mode 100644 deploy/<a href="mailto:change_pass@v1.0.0-dev2.sql">change_pass@v1.0.0-dev2.sql</a>
          create mode 100644 deploy/<a href="mailto:insert_user@v1.0.0-dev2.sql">insert_user@v1.0.0-dev2.sql</a>
          create mode 100644 revert/<a href="mailto:change_pass@v1.0.0-dev2.sql">change_pass@v1.0.0-dev2.sql</a>
          create mode 100644 revert/<a href="mailto:insert_user@v1.0.0-dev2.sql">insert_user@v1.0.0-dev2.sql</a>
          create mode 100644 verify/<a href="mailto:change_pass@v1.0.0-dev2.sql">change_pass@v1.0.0-dev2.sql</a>
          create mode 100644 verify/<a href="mailto:insert_user@v1.0.0-dev2.sql">insert_user@v1.0.0-dev2.sql</a>

         &gt; sqitch status
         # On database flipr_test
         # Project:  flipr
         # Change:   6f2e1cd4b1c031a66930811328cfcdb0389d8320
         # Name:     change_pass
         # Deployed: 2013-12-31 14:16:45 -0800
         # By:       Marge N. O’Vera &lt;<a href="mailto:marge@example.com">marge@example.com</a>&gt;
         #
         Nothing to deploy (up-to-date)

</pre><h4><b>More</b> <b>to</b> <b>Come</b></h4><pre>
       Sqitch is a work in progress. Better integration with version control systems is planned to make managing
       idempotent reworkings even easier. Stay tuned.

</pre><h4><b>Author</b></h4><pre>
       David E. Wheeler &lt;<a href="mailto:david@justatheory.com">david@justatheory.com</a>&gt;

</pre><h4><b>License</b></h4><pre>
       Copyright (c) 2012-2025 David E. Wheeler, 2012-2021 iovation Inc.

       Permission  is  hereby  granted,  free  of  charge,  to  any person obtaining a copy of this software and
       associated documentation files (the "Software"), to deal in the Software without  restriction,  including
       without  limitation  the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to  the
       following conditions:

       The  above  copyright  notice  and  this permission notice shall be included in all copies or substantial
       portions of the Software.

       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  IMPLIED,  INCLUDING  BUT  NOT
       LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
       EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
       IN  AN  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
       THE USE OR OTHER DEALINGS IN THE SOFTWARE.

perl v5.40.1                                       2025-05-10                          <u><a href="../man3pm/sqitchtutorial-mysql.3pm.html">sqitchtutorial-mysql</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>