<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zip - Utility for reading and creating 'zip' archives.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zip - Utility for reading and creating 'zip' archives.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  archives  and  extracts files to and from a zip archive. The zip format is specified by the
       "ZIP Appnote.txt" file, available on the PKWARE web site www.pkware.com.

       The zip module supports zip archive versions up to 6.1. However, password-protection and  Zip64  are  not
       supported.

       By  convention,  the  name of a zip file is to end with <u>.zip</u>. To abide to the convention, add <u>.zip</u> to the
       filename.

         * To create zip archives, use function <u>zip/2</u> or <u>zip/3</u>.  They  are  also  available  as  <u>create/2,3</u>,  to
           resemble the <u>erl_tar</u> module.

         * To  extract  files  from  a  zip archive, use function <u>unzip/1</u> or <u>unzip/2</u>. They are also available as
           <u>extract/1,2</u>, to resemble the <u>erl_tar</u> module.

         * To fold a function over all files in a zip archive, use function <u>foldl/3</u>.

         * To return a list of the files in a zip archive, use function <u>list_dir/1</u> or <u>list_dir/2</u>. They are  also
           available as <u>table/1,2</u>, to resemble the <u>erl_tar</u> module.

         * To print a list of files to the Erlang shell, use function <u>t/1</u> or <u>tt/1</u>.

         * Sometimes  it  is  desirable  to open a zip archive, and to unzip files from it file by file, without
           having  to  reopen  the  archive.  This  can  be  done  by   functions   <u>zip_open/1,2</u>,   <u>zip_get/1,2</u>,
           <u>zip_list_dir/1</u>, and <u>zip_close/1</u>.

</pre><h4><b>LIMITATIONS</b></h4><pre>
         * Zip64 archives are not supported.

         * Password-protected and encrypted archives are not supported.

         * Only the DEFLATE (zlib-compression) and the STORE (uncompressed data) zip methods are supported.

         * The archive size is limited to 2 GB (32 bits).

         * Comments  for  individual files are not supported when creating zip archives. The zip archive comment
           for the whole zip archive is supported.

         * Changing a zip archive is not supported. To add or remove a file from an archive, the  whole  archive
           must be recreated.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>zip_comment()</b> = #zip_comment{comment = string()}

              The record <u>zip_comment</u> only contains the archive comment for a zip archive.

       <b>zip_file()</b> =
           #zip_file{name = string(),
                     info = file:file_info(),
                     comment = string(),
                     offset = integer() &gt;= 0,
                     comp_size = integer() &gt;= 0}

              The record <u>zip_file</u> contains the following fields:

                <u>name</u>:
                  The filename

                <u>info</u>:
                  File information as in <u>file:read_file_info/1</u> in Kernel

                <u>comment</u>:
                  The comment for the file in the zip archive

                <u>offset</u>:
                  The file offset in the zip archive (used internally)

                <u>comp_size</u>:
                  The size of the compressed file (the size of the uncompressed file is found in <u>info</u>)

       <b>filename()</b> = file:filename()

              The name of a zip file.

       <b>extension()</b> = string()

       <b>extension_spec()</b> =
           all |
           [Extension :: extension()] |
           {add, [Extension :: extension()]} |
           {del, [Extension :: extension()]}

       <b>create_option()</b> =
           memory | cooked | verbose |
           {comment, Comment :: string()} |
           {cwd, CWD :: file:filename()} |
           {compress, What :: extension_spec()} |
           {uncompress, What :: extension_spec()}

              These options are described in <u>create/3</u>.

       <b>handle()</b>

              As returned by <u>zip_open/2</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>foldl(Fun,</b> <b>Acc0,</b> <b>Archive)</b> <b>-&gt;</b> <b>{ok,</b> <b>Acc1}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Fun = fun((FileInArchive, GetInfo, GetBin, AccIn) -&gt; AccOut)
                 FileInArchive = file:name()
                 GetInfo = fun(() -&gt; file:file_info())
                 GetBin = fun(() -&gt; binary())
                 Acc0 = Acc1 = AccIn = AccOut = term()
                 Archive = file:name() | {file:name(), binary()}
                 Reason = term()

              Calls <u>Fun(FileInArchive,</u> <u>GetInfo,</u> <u>GetBin,</u> <u>AccIn)</u> on successive files in the <u>Archive</u>, starting with
              <u>AccIn</u> <u>==</u> <u>Acc0</u>.

              <u>FileInArchive</u> is the name that the file has in the archive.

              <u>GetInfo</u> is a fun that returns information about the file.

              <u>GetBin</u> returns the file contents.

              Both  <u>GetInfo</u>  and  <u>GetBin</u>  must be called within the <u>Fun</u>. Their behavior is undefined if they are
              called outside the context of <u>Fun</u>.

              The <u>Fun</u> must return a new accumulator, which is passed to the next call. <u>foldl/3</u> returns the final
              accumulator value. <u>Acc0</u> is returned if the archive is empty. It is not necessary to  iterate  over
              all  files  in  the  archive.  The  iteration  can  be ended prematurely in a controlled manner by
              throwing an exception.

              <u>Example:</u>

              &gt; Name = "dummy.zip".
              "dummy.zip"
              &gt; {ok, {Name, Bin}} = zip:create(Name, [{"foo", &lt;&lt;"FOO"&gt;&gt;}, {"bar", &lt;&lt;"BAR"&gt;&gt;}], [memory]).
              {ok,{"dummy.zip",
                   &lt;&lt;80,75,3,4,20,0,0,0,0,0,74,152,97,60,171,39,212,26,3,0,
                     0,0,3,0,0,...&gt;&gt;}}
              &gt; {ok, FileSpec} = zip:foldl(fun(N, I, B, Acc) -&gt; [{N, B(), I()} | Acc] end, [], {Name, Bin}).
              {ok,[{"bar",&lt;&lt;"BAR"&gt;&gt;,
                    {file_info,3,regular,read_write,
                               {{2010,3,1},{19,2,10}},
                               {{2010,3,1},{19,2,10}},
                               {{2010,3,1},{19,2,10}},
                               54,1,0,0,0,0,0}},
                   {"foo",&lt;&lt;"FOO"&gt;&gt;,
                    {file_info,3,regular,read_write,
                               {{2010,3,1},{19,2,10}},
                               {{2010,3,1},{19,2,10}},
                               {{2010,3,1},{19,2,10}},
                               54,1,0,0,0,0,0}}]}
              &gt; {ok, {Name, Bin}} = zip:create(Name, lists:reverse(FileSpec), [memory]).
              {ok,{"dummy.zip",
                   &lt;&lt;80,75,3,4,20,0,0,0,0,0,74,152,97,60,171,39,212,26,3,0,
                     0,0,3,0,0,...&gt;&gt;}}
              &gt; catch zip:foldl(fun("foo", _, B, _) -&gt; throw(B()); (_,_,_,Acc) -&gt; Acc end, [], {Name, Bin}).
              &lt;&lt;"FOO"&gt;&gt;

       <b>list_dir(Archive)</b> <b>-&gt;</b> <b>RetValue</b>

       <b>list_dir(Archive,</b> <b>Options)</b> <b>-&gt;</b> <b>RetValue</b>

       <b>table(Archive)</b> <b>-&gt;</b> <b>RetValue</b>

       <b>table(Archive,</b> <b>Options)</b> <b>-&gt;</b> <b>RetValue</b>

              Types:

                 Archive = file:name() | binary()
                 RetValue = {ok, CommentAndFiles} | {error, Reason :: term()}
                 CommentAndFiles = [zip_comment() | zip_file()]
                 Options = [Option]
                 Option = cooked

              <u>list_dir/1</u> retrieves all filenames in the zip archive <u>Archive</u>.

              <u>list_dir/2</u> provides options.

              <u>table/1</u> and <u>table/2</u> are provided as synonyms to resemble the <u>erl_tar</u> module.

              The result value is the tuple <u>{ok,</u> <u>List}</u>, where <u>List</u> contains the zip archive comment as the first
              element.

              One option is available:

                <u>cooked</u>:
                  By default, this function opens the zip file in <u>raw</u> mode, which is faster but does not allow a
                  remote (Erlang) file server to be used. Adding <u>cooked</u> to the mode list overrides  the  default
                  and opens the zip file without option <u>raw</u>.

       <b>t(Archive)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Archive = file:name() | binary() | ZipHandle
                 ZipHandle = handle()

              Prints all filenames in the zip archive <u>Archive</u> to the Erlang shell. (Similar to <u>tar</u> <u>t</u>.)

       <b>tt(Archive)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Archive = file:name() | binary() | ZipHandle
                 ZipHandle = handle()

              Prints  filenames  and information about all files in the zip archive <u>Archive</u> to the Erlang shell.
              (Similar to <u>tar</u> <u>tv</u>.)

       <b>unzip(Archive)</b> <b>-&gt;</b> <b>RetValue</b>

       <b>unzip(Archive,</b> <b>Options)</b> <b>-&gt;</b> <b>RetValue</b>

       <b>extract(Archive)</b> <b>-&gt;</b> <b>RetValue</b>

       <b>extract(Archive,</b> <b>Options)</b> <b>-&gt;</b> <b>RetValue</b>

              Types:

                 Archive = file:name() | binary()
                 Options = [Option]
                 Option =
                     {file_list, FileList} |
                     keep_old_files | verbose | memory |
                     {file_filter, FileFilter} |
                     {cwd, CWD}
                 FileList = [file:name()]
                 FileBinList = [{file:name(), binary()}]
                 FileFilter = fun((ZipFile) -&gt; boolean())
                 CWD = file:filename()
                 ZipFile = zip_file()
                 RetValue =
                     {ok, FileList} |
                     {ok, FileBinList} |
                     {error, Reason :: term()} |
                     {error, {Name :: file:name(), Reason :: term()}}

              <u>unzip/1</u> extracts all files from a zip archive.

              <u>unzip/2</u> provides options to extract some files, and more.

              <u>extract/1</u> and <u>extract/2</u> are provided as synonyms to resemble module <u>erl_tar</u>.

              If argument <u>Archive</u> is specified as a binary, the contents of the binary is assumed to  be  a  zip
              archive, otherwise a filename.

              Options:

                <u>{file_list,</u> <u>FileList}</u>:
                  By  default,  all files are extracted from the zip archive. With option <u>{file_list,</u> <u>FileList}</u>,
                  function <u>unzip/2</u> only extracts the files whose names are included in <u>FileList</u>. The full paths,
                  including the names of all subdirectories within the zip archive, must be specified.

                <u>cooked</u>:
                  By default, this function opens the zip file in <u>raw</u> mode, which is faster but does not allow a
                  remote (Erlang) file server to be used. Adding <u>cooked</u> to the mode list overrides  the  default
                  and opens the zip file without option <u>raw</u>. The same applies for the files extracted.

                <u>keep_old_files</u>:
                  By  default,  all  files  with the same name as files in the zip archive are overwritten. With
                  option <u>keep_old_files</u> set, function <u>unzip/2</u> does not overwrite  existing  files.  Notice  that
                  even  with  option <u>memory</u> specified, which means that no files are overwritten, existing files
                  are excluded from the result.

                <u>verbose</u>:
                  Prints an informational message for each extracted file.

                <u>memory</u>:
                  Instead of extracting to the current directory, the result  is  given  as  a  list  of  tuples
                  <u>{Filename,</u> <u>Binary}</u>, where <u>Binary</u> is a binary containing the extracted data of file <u>Filename</u> in
                  the zip archive.

                <u>{cwd,</u> <u>CWD}</u>:
                  Uses  the  specified  directory  as  current  directory.  It  is  prepended  to filenames when
                  extracting them from the zip archive. (Acting  like  <u>file:set_cwd/1</u>  in  Kernel,  but  without
                  changing the global <u>cwd</u> property.)

       <b>zip(Name,</b> <b>FileList)</b> <b>-&gt;</b> <b>RetValue</b>

       <b>zip(Name,</b> <b>FileList,</b> <b>Options)</b> <b>-&gt;</b> <b>RetValue</b>

       <b>create(Name,</b> <b>FileList)</b> <b>-&gt;</b> <b>RetValue</b>

       <b>create(Name,</b> <b>FileList,</b> <b>Options)</b> <b>-&gt;</b> <b>RetValue</b>

              Types:

                 Name = file:name()
                 FileList = [FileSpec]
                 FileSpec =
                     file:name() |
                     {file:name(), binary()} |
                     {file:name(), binary(), file:file_info()}
                 Options = [Option]
                 Option = create_option()
                 RetValue =
                     {ok, FileName :: filename()} |
                     {ok, {FileName :: filename(), binary()}} |
                     {error, Reason :: term()}
                 <b>create_option()</b> =
                     memory | cooked | verbose |
                     {comment, Comment :: string()} |
                     {cwd, CWD :: file:filename()} |
                     {compress, What :: extension_spec()} |
                     {uncompress, What :: extension_spec()}
                 <b>extension_spec()</b> =
                     all |
                     [Extension :: extension()] |
                     {add, [Extension :: extension()]} |
                     {del, [Extension :: extension()]}

              Creates a zip archive containing the files specified in <u>FileList</u>.

              <u>create/2</u> and <u>create/3</u> are provided as synonyms to resemble module <u>erl_tar</u>.

              <u>FileList</u>  is  a list of files, with paths relative to the current directory, which are stored with
              this path in the archive. Files can also be specified with data in binaries to create  an  archive
              directly from data.

              Files  are  compressed  using  the  DEFLATE  compression,  as described in the "Appnote.txt" file.
              However, files are stored without compression if they are  already  compressed.  <u>zip/2</u>  and  <u>zip/3</u>
              check  the file extension to determine if the file is to be stored without compression. Files with
              the following extensions are not compressed: <u>.Z</u>, <u>.zip</u>, <u>.zoo</u>, <u>.arc</u>, <u>.lzh</u>, <u>.arj</u>.

              It is possible to override the default behavior and control what types of files  that  are  to  be
              compressed  by  using  options <u>{compress,</u> <u>What}</u> and <u>{uncompress,</u> <u>What}</u>. It is also possible to use
              many <u>compress</u> and <u>uncompress</u> options.

              To trigger file compression, its extension must match with the <u>compress</u>  condition  and  must  not
              match  the  <u>uncompress</u> condition. For example, if <u>compress</u> is set to <u>["gif",</u> <u>"jpg"]</u> and <u>uncompress</u>
              is set to <u>["jpg"]</u>, only files with extension <u>"gif"</u> are compressed.

              Options:

                <u>cooked</u>:
                  By default, this function opens the zip file in mode <u>raw</u>, which is faster but does not allow a
                  remote (Erlang) file server to be used. Adding <u>cooked</u> to the mode list overrides  the  default
                  and opens the zip file without the <u>raw</u> option. The same applies for the files added.

                <u>verbose</u>:
                  Prints an informational message about each added file.

                <u>memory</u>:
                  The output is not to a file, but instead as a tuple <u>{FileName,</u> <u>binary()}</u>. The binary is a full
                  zip archive with header and can be extracted with, for example, <u>unzip/2</u>.

                <u>{comment,</u> <u>Comment}</u>:
                  Adds a comment to the zip archive.

                <u>{cwd,</u> <u>CWD}</u>:
                  Uses  the  specified directory as current work directory (<u>cwd</u>). This is prepended to filenames
                  when adding them, although not in the zip archive (acting like <u>file:set_cwd/1</u> in  Kernel,  but
                  without changing the global <u>cwd</u> property.).

                <u>{compress,</u> <u>What}</u>:
                  Controls  what  types of files to be compressed. Defaults to <u>all</u>. The following values of <u>What</u>
                  are allowed:

                  <u>all</u>:
                    All files are compressed (as long as they pass the <u>uncompress</u> condition).

                  <u>[Extension]</u>:
                    Only files with exactly these extensions are compressed.

                  <u>{add,[Extension]}</u>:
                    Adds these extensions to the list of compress extensions.

                  <u>{del,[Extension]}</u>:
                    Deletes these extensions from the list of compress extensions.

                <u>{uncompress,</u> <u>What}</u>:
                  Controls what types of files to be uncompressed. Defaults to <u>[".Z",</u>  <u>".zip",</u>  <u>".zoo",</u>  <u>".arc",</u>
                  <u>".lzh",</u> <u>".arj"]</u>. The following values of <u>What</u> are allowed:

                  <u>all</u>:
                    No files are compressed.

                  <u>[Extension]</u>:
                    Files with these extensions are uncompressed.

                  <u>{add,[Extension]}</u>:
                    Adds these extensions to the list of uncompress extensions.

                  <u>{del,[Extension]}</u>:
                    Deletes these extensions from the list of uncompress extensions.

       <b>zip_close(ZipHandle)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>einval}</b>

              Types:

                 ZipHandle = handle()

              Closes  a  zip  archive,  previously  opened  with <u>zip_open/1,2</u>. All resources are closed, and the
              handle is not to be used after closing.

       <b>zip_get(ZipHandle)</b> <b>-&gt;</b> <b>{ok,</b> <b>[Result]}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>zip_get(FileName,</b> <b>ZipHandle)</b> <b>-&gt;</b> <b>{ok,</b> <b>Result}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 FileName = file:name()
                 ZipHandle = handle()
                 Result = file:name() | {file:name(), binary()}
                 Reason = term()

              Extracts one or all files from an open archive.

              The files are unzipped to memory or to file,  depending  on  the  options  specified  to  function
              <u>zip_open/1,2</u> when opening the archive.

       <b>zip_list_dir(ZipHandle)</b> <b>-&gt;</b> <b>{ok,</b> <b>Result}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Result = [zip_comment() | zip_file()]
                 ZipHandle = handle()
                 Reason = term()

              Returns  the  file  list  of  an  open  zip archive. The first returned element is the zip archive
              comment.

       <b>zip_open(Archive)</b> <b>-&gt;</b> <b>{ok,</b> <b>ZipHandle}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>zip_open(Archive,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>ZipHandle}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Archive = file:name() | binary()
                 ZipHandle = handle()
                 Options = [Option]
                 Option = cooked | memory | {cwd, CWD :: file:filename()}
                 Reason = term()

              Opens a zip archive, and reads and saves its directory. This means that later reading  files  from
              the archive is faster than unzipping files one at a time with <u>unzip/1,2</u>.

              The archive must be closed with <u>zip_close/1</u>.

              The <u>ZipHandle</u> is closed if the process that originally opened the archive dies.

Ericsson AB                                        stdlib 3.17                                         <u><a href="../man3erl/zip.3erl.html">zip</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>