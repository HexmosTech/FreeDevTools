<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ustr - ustr string library functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libustr-dev">libustr-dev_1.0.4-6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ustr - ustr string library functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
  #include "ustr.h"

  struct Ustr *<b>USTR</b>(void *);
  struct Ustrp *<b>USTRP</b>(void *);
  struct Ustr *<b>USTR1</b>(symbol, const char[]);
  struct Ustr *<b>USTR2</b>(symbol, symbol, const char[]);
  struct Ustr *<b>USTR4</b>(symbol, symbol, symbol, symbol, const char[]);
  struct Ustr *<b>USTR1_CHK</b>(symbol, const char[]);
  struct Ustr *<b>USTR2_CHK</b>(symbol, symbol, const char[]);
  struct Ustr *<b>USTR4_CHK</b>(symbol, symbol, symbol, symbol, const char[]);
  struct Ustr *<b>USTRP1</b>(symbol, const char[]);
  struct Ustr *<b>USTRP2</b>(symbol, symbol, const char[]);
  struct Ustrp *<b>USTRP4</b>(symbol, symbol, symbol, symbol, const char[]);
  struct Ustr *<b>USTRP1_CHK</b>(symbol, const char[]);
  struct Ustr *<b>USTRP2_CHK</b>(symbol, symbol, const char[]);
  struct Ustrp *<b>USTRP4_CHK</b>(symbol, symbol, symbol, symbol, const char[]);

  size_t <b>USTR_SIZE_FIXED</b>(size_t);
  struct Ustr *<b>ustr_init_fixed</b>(void *, size_t, int, size_t);
  struct Ustr *<b>USTR_SC_INIT_AUTO</b>(char[], int, size_t);
  struct Ustr *<b>USTR_SC_INIT_AUTO_OSTR</b>(char[], int, size_t);

  int <b>ustr_assert_valid</b>(Ustr *);
  int <b>ustr_assert_valid_subustr</b>(Ustr *, size_t,  size_t);
  int <b>USTR_CNTL_MALLOC_CHECK_BEG</b>(int);
  int <b>USTR_CNTL_MALLOC_CHECK_LVL</b>(void);
  int <b>USTR_CNTL_MALLOC_CHECK_MEM</b>(void *);
  int <b>USTR_CNTL_MALLOC_CHECK_MEM_SZ</b>(void *, size_t);
  int <b>USTR_CNTL_MALLOC_CHECK_MEM_MINSZ</b>(void *, size_t);
  int <b>USTR_CNTL_MALLOC_CHECK_MEM_USTR</b>(Ustr *);
  int <b>USTR_CNTL_MALLOC_CHECK_MEM_USTRP</b>(Ustrp *);
  int <b>USTR_CNTL_MALLOC_CHECK_END</b>(void);
  int <b>USTR_CNTL_MALLOC_CHECK_ADD</b>(int);
  int <b>USTR_CNTL_MALLOC_CHECK_DEL</b>(int);

  size_t  <b>ustr_init_size</b>(size_t, size_t, int, size_t);
  struct Ustr *<b>ustr_init_alloc</b>(void *, size_t, size_t, size_t, int, int, size_t);
  struct Ustr *<b>ustr_dupx_empty</b>(size_t, size_t, int, int);
  struct Ustr *<b>ustr_dup_empty</b>(void);
  struct Ustr *<b>ustr_dupx_undef</b>(size_t, size_t, int, int, size_t);
  struct Ustr *<b>ustr_dup_undef</b>(size_t);
  struct Ustr *<b>ustr_dup</b>(const struct Ustr *);
  struct Ustr *<b>ustr_dupx</b>(size_t, size_t, int, int, const struct Ustr *);
  struct Ustr *<b>ustr_sc_dup</b>(struct Ustr **);
  struct Ustr *<b>ustr_sc_dupx</b>(size_t, size_t, int, int, struct Ustr **);
  struct Ustr *<b>ustr_dup_buf</b>(const void *, size_t);
  struct Ustr *<b>ustr_dupx_buf</b>(size_t, size_t, int, int, const void *, size_t);
  struct Ustr *<b>ustr_dup_cstr</b>(const char *);
  struct Ustr *<b>ustr_dupx_cstr</b>(size_t, size_t, int, int, const char *);
  struct Ustr *<b>USTR_DUP_OSTR</b>(const char []);
  struct Ustr *<b>USTR_DUP_OBJ</b>(...);
  struct Ustr *<b>ustr_dup_subustr</b>(const struct Ustr *, size_t, size_t);
  struct Ustr *<b>ustr_dupx_subustr</b>(size_t, size_t, int, int, const struct Ustr *, size_t, size_t);
  struct Ustr *<b>ustr_dup_rep_chr</b>(char, size_t);
  struct Ustr *<b>ustr_dupx_rep_chr</b>(size_t, size_t, int, int, char, size_t);
  struct Ustr *<b>ustr_sc_vjoin</b>(const struct Ustr *, const struct Ustr *, const struct Ustr *, va_list);
  struct Ustr *<b>ustr_sc_join</b>(const struct Ustr *, const struct Ustr *, const struct Ustr *, ...);
  struct  Ustr  *<b>ustr_sc_vjoinx</b>(size_t, size_t, int, int, const struct Ustr *, const struct Ustr *, const struct
                              Ustr *, va_list);
  struct Ustr *<b>ustr_sc_joinx</b>(size_t, size_t, int, int, const struct Ustr *, const struct Ustr  *,  const  struct
                             Ustr *, ...);
  struct Ustr *<b>ustr_sc_vconcat</b>(const struct Ustr *, va_list);
  struct Ustr *<b>ustr_sc_concat</b>(const struct Ustr *, ...);
  struct Ustr *<b>ustr_sc_vconcatx</b>(size_t, size_t, int, int, const struct Ustr *, va_list);
  struct Ustr *<b>ustr_sc_concatx</b>(size_t, size_t, int, int, const struct Ustr *, ...);

  void  <b>ustr_free</b>(struct Ustr *);
  void  <b>ustrp_free</b>(struct Ustr_pool *, struct Ustrp *);
  void  <b>ustr_sc_free</b>(struct Ustr **);
  void  <b>ustr_sc_free2</b>(struct Ustr **, struct Ustr *);
  void  <b>ustr_sc_free_shared</b>(struct Ustr **);
  int  <b>ustr_del</b>(struct Ustr **, size_t);
  int  <b>ustr_del_subustr</b>(struct Ustr **, size_t,  size_t);
  void  <b>ustr_sc_del</b>(struct Ustr **);

  int <b>ustr_add_undef</b>(struct Ustr **, size_t);
  int <b>ustr_add_buf</b>(struct Ustr **, const void *, size_t);
  int  <b>ustr_add_cstr</b>(struct Ustr **, const char *);
  int  <b>USTR_ADD_OSTR</b>(struct Ustr **, const char []);
  int  <b>USTR_ADD_OBJ</b>(struct Ustr **, ...);
  int  <b>ustr_add</b>(struct Ustr **, const struct Ustr *);
  int  <b>ustr_add_subustr</b>(struct Ustr **, const struct Ustr *, size_t, size_t);
  int  <b>ustr_add_rep_chr</b>(struct Ustr **, char, size_t);

  int  <b>ustr_set_undef</b>(struct Ustr **,  size_t);
  int <b>ustr_set_empty</b>(struct Ustr **);
  int <b>ustr_set_buf</b>(struct Ustr **,  const void *, size_t);
  int <b>ustr_set_cstr</b>(struct Ustr **, const char *);
  int <b>USTR_SET_OSTR</b>(struct Ustr **, const char []);
  int <b>USTR_SET_OBJ</b>(struct Ustr **, ...);
  int <b>ustr_set</b>(struct Ustr **, const struct Ustr *);
  int <b>ustr_set_subustr</b>(struct Ustr **, const struct Ustr *, size_t, size_t);
  int <b>ustr_set_rep_chr</b>(struct Ustr **, char, size_t);

  int <b>ustr_ins_undef</b>(struct Ustr **, size_t, size_t);
  int <b>ustr_ins_buf</b>(struct Ustr **, size_t, const void *, size_t);
  int  <b>ustr_ins_cstr</b>(struct Ustr **, size_t, const char *);
  int  <b>USTR_INS_OSTR</b>(struct Ustr **, size_t, const char []);
  int  <b>USTR_INS_OBJ</b>(struct Ustr **, size_t, ...);
  int  <b>ustr_ins</b>(struct Ustr **, size_t, const struct Ustr *);
  int  <b>ustr_ins_subustr</b>(struct Ustr **, size_t, const struct Ustr *, size_t, size_t);
  int  <b>ustr_ins_rep_chr</b>(struct Ustr **, size_t, char, size_t);

  int  <b>ustr_add_vfmt_lim</b>(struct Ustr **, size_t, const char *, va_list);
  int  <b>ustr_add_vfmt</b>(struct Ustr **, const char *, va_list);
  int  <b>ustr_add_fmt_lim</b>(struct Ustr **, size_t, const char *, ...);
  int  <b>ustr_add_fmt</b>(struct Ustr **, const char *, ...);
  struct Ustr *<b>ustr_dup_vfmt_lim</b>(size_t, const char *, va_list);
  struct Ustr *<b>ustr_dup_vfmt</b>(size_t, const char *, va_list);
  struct Ustr *<b>ustr_dup_fmt_lim</b>(size_t, const char *, ...);
  struct Ustr *<b>ustr_dup_fmt</b>(const char *, ...);
  struct Ustr *<b>ustr_dupx_fmt_lim</b>(size_t, size_t, int, int, size_t, const char *, ...);
  struct Ustr *<b>ustr_dupx_fmt</b>(size_t, size_t, int, int, const char *, ...);
  int  <b>ustr_set_vfmt_lim</b>(struct Ustr **, size_t, const char *, va_list);
  int  <b>ustr_set_vfmt</b>(struct Ustr **, const char *, va_list);
  int  <b>ustr_set_fmt_lim</b>(struct Ustr **, size_t, const char *, ...);
  int  <b>ustr_set_fmt</b>(struct Ustr **, const char *, ...);
  int  <b>ustr_ins_vfmt_lim</b>(struct Ustr **, size_t, size_t, const char *, va_list);
  int  <b>ustr_ins_vfmt</b>(struct Ustr **, size_t, const char *, va_list);
  int  <b>ustr_ins_fmt_lim</b>(struct Ustr **, size_t, size_t, const char *, ...);
  int  <b>ustr_ins_fmt</b>(struct Ustr **, size_t, const char *, ...);
  int  <b>ustr_sub_vfmt_lim</b>(struct Ustr **, size_t, size_t, const char *, va_list);
  int  <b>ustr_sub_vfmt</b>(struct Ustr **, size_t, const char *, va_list);
  int  <b>ustr_sub_fmt_lim</b>(struct Ustr **, size_t, size_t, const char *, ...);
  int  <b>ustr_sub_fmt</b>(struct Ustr **, size_t, const char *, ...);
  int  <b>ustr_sc_sub_vfmt_lim</b>(struct Ustr **, size_t, size_t, size_t, const char *, va_list);
  int  <b>ustr_sc_sub_vfmt</b>(struct Ustr **, size_t, size_t, const char *, va_list);
  int  <b>ustr_sc_sub_fmt_lim</b>(struct Ustr **, size_t, size_t, size_t, const char *, ...);
  int  <b>ustr_sc_sub_fmt</b>(struct Ustr **, size_t, size_t, const char *, ...);

  size_t  <b>ustr_len</b>(const struct Ustr *);
  const char *<b>ustr_cstr</b>(const struct Ustr *);
  char *<b>ustr_wstr</b>(struct Ustr *);
  int <b>ustr_alloc</b>(const struct Ustr *);
  int <b>ustr_exact</b>(const struct Ustr *);
  int  <b>ustr_sized</b>(const struct Ustr *);
  int <b>ustr_ro</b>(const struct Ustr *);
  int  <b>ustr_fixed</b>(const struct Ustr *);
  int  <b>ustr_enomem</b>(const struct Ustr *);
  int  <b>ustr_shared</b>(const struct Ustr *);
  int  <b>ustr_limited</b>(const struct Ustr *);
  int  <b>ustr_owner</b>(const struct Ustr *);
  size_t  <b>ustr_size</b>(const struct Ustr *);
  size_t  <b>ustr_size_alloc</b>(const struct Ustr *);
  size_t  <b>ustr_size_overhead</b>(const struct Ustr *);
  void  <b>ustr_conf</b>(const struct Ustr *, size_t *, size_t *, int *, size_t *, size_t *);

  int  <b>ustr_setf_enomem_err</b>(struct Ustr *);
  int  <b>ustr_setf_enomem_clr</b>(struct Ustr *);
  int  <b>ustr_setf_share</b>(struct Ustr *);
  int  <b>ustr_setf_owner</b>(struct Ustr *);

  int  <b>ustr_cmp_buf</b>(const struct Ustr *, const void *, size_t);
  int  <b>ustr_cmp</b>(const struct Ustr *, const struct Ustr *);
  int  <b>ustr_cmp_subustr</b>(const struct Ustr *, const struct Ustr *, size_t, size_t);
  int  <b>ustr_cmp_cstr</b>(const struct Ustr *, const char *);
  int  <b>ustr_cmp_fast_buf</b>(const struct Ustr *, const void *, size_t);
  int  <b>ustr_cmp_fast</b>(const struct Ustr *, const struct Ustr *);
  int  <b>ustr_cmp_fast_subustr</b>(const struct Ustr *, const struct Ustr *, size_t, size_t);
  int  <b>ustr_cmp_fast_cstr</b>(const struct Ustr *, const char *);
  int  <b>ustr_cmp_case_buf</b>(const struct Ustr *, const void *, size_t);
  int  <b>ustr_cmp_case</b>(const struct Ustr *, const struct Ustr *);
  int  <b>ustr_cmp_case_subustr</b>(const struct Ustr *, const struct Ustr *, size_t, size_t);
  int  <b>ustr_cmp_case_cstr</b>(const struct Ustr *, const char *);
  int  <b>ustr_cmp_eq</b>(const struct Ustr *, const struct Ustr *);
  int  <b>ustr_cmp_buf_eq</b>(const struct Ustr *, const void *, size_t);
  int  <b>ustr_cmp_subustr_eq</b>(const struct Ustr *, const struct Ustr *, size_t, size_t);
  int  <b>ustr_cmp_cstr_eq</b>(const struct Ustr *, const char *);
  int  <b>ustr_cmp_case_eq</b>(const struct Ustr *, const struct Ustr *);
  int  <b>ustr_cmp_case_buf_eq</b>(const struct Ustr *, const void *, size_t);
  int  <b>ustr_cmp_case_subustr_eq</b>(const struct Ustr *, const struct Ustr *, size_t, size_t);
  int  <b>ustr_cmp_case_cstr_eq</b>(const struct Ustr *, const char *);
  int  <b>ustr_cmp_prefix_eq</b>(const struct Ustr *, const struct Ustr *);
  int  <b>ustr_cmp_prefix_buf_eq</b>(const struct Ustr *, const void *, size_t);
  int  <b>ustr_cmp_prefix_cstr_eq</b>(const struct Ustr *, const char *);
  int  <b>ustr_cmp_prefix_subustr_eq</b>(const struct Ustr *, const struct Ustr *, size_t, size_t);
  int  <b>ustr_cmp_case_prefix_eq</b>(const struct Ustr *, const struct Ustr *);
  int  <b>ustr_cmp_case_prefix_buf_eq</b>(const struct Ustr *, const void *, size_t);
  int  <b>ustr_cmp_case_prefix_cstr_eq</b>(const struct Ustr *, const char *);
  int  <b>ustr_cmp_case_prefix_subustr_eq</b>(const struct Ustr *, const struct Ustr *, size_t, size_t);
  int  <b>ustr_cmp_suffix_eq</b>(const struct Ustr *, const struct Ustr *);
  int  <b>ustr_cmp_suffix_buf_eq</b>(const struct Ustr *, const void *, size_t);
  int  <b>ustr_cmp_suffix_cstr_eq</b>(const struct Ustr *, const char *);
  int  <b>ustr_cmp_suffix_subustr_eq</b>(const struct Ustr *, const struct Ustr *, size_t, size_t);
  int  <b>ustr_cmp_case_suffix_eq</b>(const struct Ustr *, const struct Ustr *);
  int  <b>ustr_cmp_case_suffix_buf_eq</b>(const struct Ustr *, const void *, size_t);
  int  <b>ustr_cmp_case_suffix_cstr_eq</b>(const struct Ustr *, const char *);
  int  <b>ustr_cmp_case_suffix_subustr_eq</b>(const struct Ustr *, const struct Ustr *, size_t, size_t);

  size_t  <b>ustr_srch_chr_fwd</b>(const struct Ustr *, size_t, char);
  size_t  <b>ustr_srch_chr_rev</b>(const struct Ustr *, size_t, char);
  size_t  <b>ustr_srch_buf_fwd</b>(const struct Ustr *, size_t, const void *, size_t);
  size_t  <b>ustr_srch_buf_rev</b>(const struct Ustr *, size_t, const void *, size_t);
  size_t  <b>ustr_srch_fwd</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_srch_rev</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_srch_cstr_fwd</b>(const struct Ustr *, size_t, const char *);
  size_t  <b>ustr_srch_cstr_rev</b>(const struct Ustr *, size_t, const char *);
  size_t  <b>ustr_srch_subustr_fwd</b>(const struct Ustr *, size_t, const struct Ustr *, size_t, size_t);
  size_t  <b>ustr_srch_subustr_rev</b>(const struct Ustr *,  size_t, const struct Ustr *, size_t, size_t);
  size_t  <b>ustr_srch_case_chr_fwd</b>(const struct Ustr *, size_t, char);
  size_t  <b>ustr_srch_case_chr_rev</b>(const struct Ustr *, size_t, char);
  size_t  <b>ustr_srch_case_buf_fwd</b>(const struct Ustr *, size_t, const void *, size_t);
  size_t  <b>ustr_srch_case_buf_rev</b>(const struct Ustr *, size_t, const void *, size_t);
  size_t  <b>ustr_srch_case_fwd</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_srch_case_rev</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_srch_case_cstr_fwd</b>(const struct Ustr *, size_t, const char *);
  size_t  <b>ustr_srch_case_cstr_rev</b>(const struct Ustr *, size_t, const char *);
  size_t  <b>ustr_srch_case_subustr_fwd</b>(const struct Ustr *, size_t, const struct Ustr *, size_t, size_t);
  size_t  <b>ustr_srch_case_subustr_rev</b>(const struct Ustr *,  size_t, const struct Ustr *, size_t, size_t);

  size_t  <b>ustr_spn_chr_fwd</b>(const struct Ustr *, size_t, char);
  size_t  <b>ustr_spn_chr_rev</b>(const struct Ustr *, size_t, char);
  size_t  <b>ustr_spn_chrs_fwd</b>(const struct Ustr *, size_t, const char *, size_t);
  size_t  <b>ustr_spn_chrs_rev</b>(const struct Ustr *, size_t, const char *, size_t);
  size_t  <b>ustr_spn_fwd</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_spn_rev</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_spn_cstr_fwd</b>(const struct Ustr *, size_t, const char *);
  size_t  <b>ustr_spn_cstr_rev</b>(const struct Ustr *, size_t, const char *);
  size_t  <b>ustr_cspn_chr_fwd</b>(const struct Ustr *, size_t, char);
  size_t  <b>ustr_cspn_chr_rev</b>(const struct Ustr *, size_t, char);
  size_t  <b>ustr_cspn_chrs_fwd</b>(const struct Ustr *, size_t, const char *, size_t);
  size_t  <b>ustr_cspn_chrs_rev</b>(const struct Ustr *, size_t, const char *, size_t);
  size_t  <b>ustr_cspn_fwd</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_cspn_rev</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_cspn_cstr_fwd</b>(const struct Ustr *, size_t, const char *);
  size_t  <b>ustr_cspn_cstr_rev</b>(const struct Ustr *, size_t, const char *);
  size_t  <b>ustr_utf8_spn_chrs_fwd</b>(const struct Ustr *, size_t, const char *, size_t);
  size_t  <b>ustr_utf8_spn_chrs_rev</b>(const struct Ustr *, size_t, const char *, size_t);
  size_t  <b>ustr_utf8_spn_fwd</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_utf8_spn_rev</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_utf8_spn_cstr_fwd</b>(const struct Ustr *, size_t, const char *);
  size_t  <b>ustr_utf8_spn_cstr_rev</b>(const struct Ustr *, size_t, const char *);
  size_t  <b>ustr_utf8_cspn_chrs_fwd</b>(const struct Ustr *, size_t, const char *, size_t);
  size_t  <b>ustr_utf8_cspn_chrs_rev</b>(const struct Ustr *, size_t, const char *, size_t);
  size_t  <b>ustr_utf8_cspn_fwd</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_utf8_cspn_rev</b>(const struct Ustr *, size_t, const struct Ustr *);
  size_t  <b>ustr_utf8_cspn_cstr_fwd</b>(const struct Ustr *, size_t, const char *);
  size_t  <b>ustr_utf8_cspn_cstr_rev</b>(const struct Ustr *, size_t, const char *);

  int  <b>ustr_io_get</b>(struct Ustr **, FILE *, size_t, size_t *);
  int  <b>ustr_io_getfile</b>(struct Ustr **, FILE *);
  int  <b>ustr_io_getfilename</b>(struct Ustr **, const char *);
  int  <b>ustr_io_getdelim</b>(struct Ustr **, FILE *, char);
  int  <b>ustr_io_getline</b>(struct Ustr **, FILE *);
  int <b>ustr_io_put</b>(struct Ustr **, FILE *, size_t);
  int  <b>ustr_io_putline</b>(struct Ustr **, FILE *, size_t);
  int  <b>ustr_io_putfile</b>(struct Ustr **, FILE *);
  int  <b>ustr_io_putfileline</b>(struct Ustr **, FILE *);
  int  <b>ustr_io_putfilename</b>(struct Ustr **, const char *, const char *);

  int  <b>ustr_sub_undef</b>(struct Ustr **, size_t, size_t);
  int  <b>ustr_sub_buf</b>(struct Ustr **, size_t, const void *, size_t);
  int  <b>ustr_sub_cstr</b>(struct Ustr **, size_t, const char *);
  int  <b>USTR_SUB_OSTR</b>(struct Ustr **, size_t, const char []);
  int  <b>USTR_SUB_OBJ</b>(struct Ustr **, size_t, ...);
  int  <b>ustr_sub</b>(struct Ustr **, size_t, const struct Ustr *);
  int  <b>ustr_sub_subustr</b>(struct Ustr **, size_t, const struct Ustr *, size_t, size_t);
  int  <b>ustr_sc_sub_undef</b>(struct Ustr **, size_t, size_t, size_t);
  int  <b>ustr_sc_sub_buf</b>(struct Ustr **, size_t , size_t , const void *, size_t );
  int  <b>ustr_sc_sub_cstr</b>(struct Ustr **, size_t, size_t, const char *);
  int  <b>ustr_sc_sub</b>(struct Ustr **, size_t, size_t, const struct Ustr *);
  int  <b>ustr_sc_sub_subustr</b>(struct Ustr **, size_t, size_t, const struct Ustr *, size_t, size_t);
  int  <b>USTR_SC_SUB_OSTR</b>(struct Ustr **, size_t, size_t, const char []);
  int  <b>USTR_SC_SUB_OBJ</b>(struct Ustr **, size_t, size_t, ...);
  size_t  <b>ustr_replace_buf</b>(struct Ustr **, const void *, size_t, const void *, size_t, size_t);
  size_t  <b>ustr_replace_cstr</b>(struct Ustr **, const char *, const char *, size_t);
  int  <b>ustr_replace</b>(struct Ustr **, const struct Ustr *, const struct Ustr *, size_t);
  size_t <b>ustr_replace_rep_chr</b>(struct Ustr **ps1, char, size_t, char, size_t nlen, size_t lim);

  struct Ustr *<b>ustr_split_buf</b>(const struct Ustr *, size_t *, const void *, size_t, struct Ustr *, unsigned int);
  struct Ustr *<b>ustr_split</b>(const struct Ustr *, size_t *, const struct Ustr *, struct Ustr *, unsigned int);
  struct Ustr *<b>ustr_split_cstr</b>(const struct Ustr *, size_t *, const char *, struct Ustr *, unsigned int);
  struct  Ustr *<b>ustr_split_spn_chrs</b>(const struct Ustr *, size_t *, const char *, size_t, struct Ustr *, unsigned
                                   int);
  struct Ustr *<b>ustr_split_spn_cstr</b>(const struct Ustr *, size_t *, const char *, struct Ustr *, unsigned int);
  struct Ustr *<b>ustr_split_spn</b>(const struct Ustr *, size_t *, const struct Ustr *, struct Ustr *, unsigned int);

  int  <b>ustr_utf8_valid</b>(const struct Ustr *);
  size_t  <b>ustr_utf8_len</b>(const struct Ustr *);
  ssize_t  <b>ustr_utf8_width</b>(const struct Ustr *);
  size_t  <b>ustr_utf8_chars2bytes</b>(const struct Ustr *, size_t, size_t, size_t *);
  size_t  <b>ustr_utf8_bytes2chars</b>(const struct Ustr *, size_t, size_t, size_t *);
  int <b>ustr_sc_utf8_reverse</b>(struct Ustr **);

  uintmax_t  <b>ustr_parse_uintmaxx</b>(const struct Ustr *, size_t, unsigned int, uintmax_t, uintmax_t, const char  *,
                                 size_t *, unsigned int *);
  uintmax_t  <b>ustr_parse_uintmax</b>(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
  intmax_t  <b>ustr_parse_intmax</b>(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
  unsigned  long  <b>ustr_parse_ulongx</b>(const struct Ustr *,  size_t,  unsigned int,  unsigned long,  unsigned long,
                                   const char *,  size_t *, unsigned int *);
  unsigned long  <b>ustr_parse_ulong</b>(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
  long  <b>ustr_parse_long</b>(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
  unsigned int  <b>ustr_parse_uint</b>(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
  int  <b>ustr_parse_int</b>(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
  unsigned short  <b>ustr_parse_ushort</b>(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);
  short  <b>ustr_parse_short</b>(const struct Ustr *, size_t, unsigned int, size_t *, unsigned int *);

  int  <b>ustr_sc_ensure_owner</b>(struct Ustr **);
  char *<b>ustr_sc_wstr</b>(struct Ustr **);
  char *<b>ustr_sc_export_subustr</b>(const struct Ustr *, size_t, size_t, void *(*)(size_t));
  char *<b>ustr_sc_export</b>(const struct Ustr *, void *(*)(size_t));
  char *<b>ustrp_sc_export_subustrp</b>(struct Ustr_pool *, const struct Ustr *, size_t, size_t, void *(*)(size_t));
  char *<b>ustrp_sc_export</b>(struct Ustr_pool *, const struct Ustr *, void *(*)(size_t));
  int  <b>ustr_sc_reverse</b>(struct Ustr **);
  int  <b>ustr_sc_tolower</b>(struct Ustr **);
  int  <b>ustr_sc_toupper</b>(struct Ustr **);
  int  <b>ustr_sc_ltrim_chrs</b>(struct Ustr **, const char *, size_t);
  int  <b>ustr_sc_ltrim</b>(struct Ustr **, const struct Ustr *);
  int  <b>ustr_sc_ltrim_cstr</b>(struct Ustr **, const char *);
  int  <b>ustr_sc_rtrim_chrs</b>(struct Ustr **, const char *, size_t);
  int  <b>ustr_sc_rtrim</b>(struct Ustr **, const struct Ustr *);
  int  <b>ustr_sc_rtrim_cstr</b>(struct Ustr **, const char *);
  int  <b>ustr_sc_trim_chrs</b>(struct Ustr **, const char *, size_t);
  int  <b>ustr_sc_trim</b>(struct Ustr **, const struct Ustr *);
  int  <b>ustr_sc_trim_cstr</b>(struct Ustr **, const char *);

  int  <b>ustr_add_b_uint16</b>(struct Ustr **, uint_least16_t);
  int  <b>ustr_add_b_uint32</b>(struct Ustr **, uint_least32_t);
  int  <b>ustr_add_b_uint64</b>(struct Ustr **, uint_least64_t);

  uint_least16_t  <b>ustr_parse_b_uint16</b>(const struct Ustr *, size_t);
  uint_least32_t  <b>ustr_parse_b_uint32</b>(const struct Ustr *, size_t);
  uint_least64_t  <b>ustr_parse_b_uint64</b>(const struct Ustr *, size_t);

  int <b>ustr_realloc</b>(struct Ustr **, size_t);
  int  <b>ustr_cntl_opt</b>(int, ...);

  struct Ustr_pool *<b>ustr_pool_ll_make</b>(void);
  struct Ustr_pool *<b>ustr_pool_make_subpool</b>(struct Ustr_pool *);
  void <b>ustr_pool_free</b>(struct Ustr_pool *);
  void <b>ustr_pool_clear</b>(struct Ustr_pool *);

</pre><h4><b>DESCRIPTION</b></h4><pre>
        A very simple overview is that you can  use  ustr_dup_cstr()  to  convert  a  C-style  to  a  Ustr,  and
       ustr_cstr()  to  convert  it  back.  You  can  also use USTR1() to create constant/read-only strings, and
       USTR_SC_INIT_AUTO() to create strings that use stack space up to a certain amount.
        Use is somewhat unique in that, by default, it has  an  average  overhead  of  only  55%  overhead  over
       strdup(),  for  strings  in the range of 0 to 20 bytes. Or, to put it another way it only uses 8 bytes to
       store a 2 byte string where strdup() uses 3.

</pre><h4><b>Creating</b> <b>read-only</b> <b>Ustr</b> <b>functions</b></h4><pre>
     <b>Function:</b>  USTR()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to Ustr data
       Type<b>[1]</b>: void *

       <b>Explanation:</b>

         This macro function is normally used with the empty string "".

       <b>Note:</b>

         There is basically just a simple cast behind the macro.

     <b>Function:</b>  USTRP()
       Returns: Ustrp string
       Type: struct Ustrp *

       Parameter<b>[1]</b>: Pointer to Ustrp data
       Type<b>[1]</b>: void *

       <b>Explanation:</b>

         This macro function is normally used with the empty string "".

       <b>Note:</b>

         There is basically just a simple cast behind the macro.

     <b>Function:</b>  USTR1()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Encoded number of the length of Ustr string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Data for Ustr string
       Type<b>[2]</b>: const char[]

       <b>Explanation:</b>

         This macro function simplifies the creation of read-only Ustr string's. And is normally used like...

         USTR1(\x4, "abcd")

        ...it is worth pointing out that running with debugging turned on
        (USTR_CONF_USE_ASSERT) will complain if the length isn't encoded correctly, as in...

         USTR1(\x3, "abcd")

        ...here ustr_assert_valid() will fail, which is called before most functions do
        anything in debugging mode. Note also that extra debugging  (USTR_CONF_USE_EOS_MARK)  will  still  catch
       cases like...

         USTR1(\x3, "abc\0d")

        ...at least using debugging is esp. important if you are putting UTF-8
        characters into the strings.

       <b>Note:</b>

         Having  ustr_ro()  return  true  means  that  the Ustr cannot be written to without be reallocated into
       allocation space ... not that ustr_add() etc. will fail.
         There is now USTR1_CHK() which performs a compile time check so you can never have an invalid ustr.

     <b>Function:</b>  USTR2()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Encoded 2nd byte of number of the length of Ustr string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Encoded 1st byte of number of the length of Ustr string
       Type<b>[2]</b>: symbol

       Parameter<b>[3]</b>: Data for Ustr string
       Type<b>[3]</b>: const char[]

       <b>Explanation:</b>

         This function works in the same way as USTR1() but takes two length bytes, so the read-only string  can
       be up to 65,535 (2**16 - 1) bytes in length.

     <b>Function:</b>  USTR4()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Encoded 4th byte of number of the length of Ustr string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Encoded 3rd byte of number of the length of Ustr string
       Type<b>[2]</b>: symbol

       Parameter<b>[3]</b>: Encoded 2nd byte of number of the length of Ustr string
       Type<b>[3]</b>: symbol

       Parameter<b>[4]</b>: Encoded 1st byte of number of the length of Ustr string
       Type<b>[4]</b>: symbol

       Parameter<b>[5]</b>: Data for Ustr string
       Type<b>[5]</b>: const char[]

       <b>Explanation:</b>

         This function works in the same way as USTR1() but takes four length bytes, so the read-only string can
       be up to 2**32 - 1 bytes in length.

     <b>Function:</b>  USTR1_CHK()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Encoded number of the length of Ustr string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Data for Ustr string
       Type<b>[2]</b>: const char[]

       <b>Explanation:</b>

         This function works in the same way as USTR1() but it does a check against the length of (Parameter[2])
       using sizeof() - 1.

       <b>Note:</b>

         If  the  check  fails the returned Ustr * will be "", so you can check ustr_len() to see if you screwed
       something up.

     <b>Function:</b>  USTR2_CHK()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Encoded 2nd byte of number of the length of Ustr string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Encoded 1st byte of number of the length of Ustr string
       Type<b>[2]</b>: symbol

       Parameter<b>[3]</b>: Data for Ustr string
       Type<b>[3]</b>: const char[]

       <b>Explanation:</b>

         This function works in the same way as USTR2() but it does a check against the length of (Parameter[2])
       using sizeof() - 1.

       <b>Note:</b>

         If the check fails the returned Ustr * will be "".

     <b>Function:</b>  USTR4_CHK()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Encoded 4th byte of number of the length of Ustr string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Encoded 3rd byte of number of the length of Ustr string
       Type<b>[2]</b>: symbol

       Parameter<b>[3]</b>: Encoded 2nd byte of number of the length of Ustr string
       Type<b>[3]</b>: symbol

       Parameter<b>[4]</b>: Encoded 1st byte of number of the length of Ustr string
       Type<b>[4]</b>: symbol

       Parameter<b>[5]</b>: Data for Ustr string
       Type<b>[5]</b>: const char[]

       <b>Explanation:</b>

         This function works in the same way as USTR4() but it does a check against the length of (Parameter[2])
       using sizeof() - 1.

       <b>Note:</b>

         If the check fails the returned Ustr * will be "".

     <b>Function:</b>  USTRP1()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Encoded number of the length of Ustr string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Data for Ustr string
       Type<b>[2]</b>: const char[]

       <b>Explanation:</b>

         This function works like USTR1(), but returns a Ustrp instead.

     <b>Function:</b>  USTRP2()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Encoded 2nd byte of number of the length of Ustr string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Encoded 1st byte of number of the length of Ustr string
       Type<b>[2]</b>: symbol

       Parameter<b>[3]</b>: Data for Ustr string
       Type<b>[3]</b>: const char[]

       <b>Explanation:</b>

         This function works like USTR4(), but returns a Ustrp instead.

     <b>Function:</b>  USTRP4()
       Returns: Ustrp string
       Type: struct Ustrp *

       Parameter<b>[1]</b>: Encoded 4th byte of number of the length of Ustrp string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Encoded 3rd byte of number of the length of Ustrp string
       Type<b>[2]</b>: symbol

       Parameter<b>[3]</b>: Encoded 2nd byte of number of the length of Ustrp string
       Type<b>[3]</b>: symbol

       Parameter<b>[4]</b>: Encoded 1st byte of number of the length of Ustrp string
       Type<b>[4]</b>: symbol

       Parameter<b>[5]</b>: Data for Ustr string
       Type<b>[5]</b>: const char[]

       <b>Explanation:</b>

         This function works like USTR2(), but returns a Ustrp instead.

     <b>Function:</b>  USTRP1_CHK()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Encoded number of the length of Ustr string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Data for Ustr string
       Type<b>[2]</b>: const char[]

       <b>Explanation:</b>

         This function works like USTR1_CHK(), but returns a Ustrp instead.

     <b>Function:</b>  USTRP2_CHK()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Encoded 2nd byte of number of the length of Ustr string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Encoded 1st byte of number of the length of Ustr string
       Type<b>[2]</b>: symbol

       Parameter<b>[3]</b>: Data for Ustr string
       Type<b>[3]</b>: const char[]

       <b>Explanation:</b>

         This function works like USTR4_CHK(), but returns a Ustrp instead.

     <b>Function:</b>  USTRP4_CHK()
       Returns: Ustrp string
       Type: struct Ustrp *

       Parameter<b>[1]</b>: Encoded 4th byte of number of the length of Ustrp string
       Type<b>[1]</b>: symbol

       Parameter<b>[2]</b>: Encoded 3rd byte of number of the length of Ustrp string
       Type<b>[2]</b>: symbol

       Parameter<b>[3]</b>: Encoded 2nd byte of number of the length of Ustrp string
       Type<b>[3]</b>: symbol

       Parameter<b>[4]</b>: Encoded 1st byte of number of the length of Ustrp string
       Type<b>[4]</b>: symbol

       Parameter<b>[5]</b>: Data for Ustr string
       Type<b>[5]</b>: const char[]

       <b>Explanation:</b>

         This function works like USTR2_CHK(), but returns a Ustrp instead.

</pre><h4><b>Creating</b> <b>fixed</b> <b>Ustr</b> <b>functions</b></h4><pre>
     <b>Function:</b>  USTR_SIZE_FIXED()
       Returns: Size of area of memory
       Type: size_t

       Parameter<b>[1]</b>: Size of area of memory
       Type<b>[1]</b>: size_t

       <b>Explanation:</b>

         This macro function is replaced by a static conversion from the max length  desired  (Parameter[1])  to
       the  storage  size  needed.  In other words it works out what ustr_size_overhead() will be, and adds that
       value.

       <b>Note:</b>

         This is useful is you want a small fixed size allocation, as you can declare it like so:

         char buf[<a href="../man4/USTR_SIZE_FIXED.4.html">USTR_SIZE_FIXED</a>(4)];
        ...to give you exactly 4 bytes as a maximum, this is esp. useful if you want
        a limited (ustr_limited() == USTR_TRUE) Ustr string.

     <b>Function:</b>  ustr_init_fixed()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to area of memory to use as a Ustr string
       Type<b>[1]</b>: void *

       Parameter<b>[2]</b>: Size of area of memory
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Whether the fixed size Ustr should be limited
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: The initial length of the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This creates a new Ustr string, which is "fixed". This means the Ustr storage is managed outside of the
       ustr_* API, it is often used for stack allocated strings.
         As you add data to the Ustr past the size allowed via. the fixed storge the Ustr will automatically  be
       converted into an allocated Ustr. So if this is possible you should always call ustr_free(), as this does
       nothing if given a fixed size Ustr.

       <b>Note:</b>

         For simplicity you probably want to use USTR_SC_INIT_AUTO() or USTR_SC_INIT_AUTO() when possible.

     <b>Function:</b>  USTR_SC_INIT_AUTO()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Area of memory to use as a Ustr string
       Type<b>[1]</b>: char[]

       Parameter<b>[2]</b>: Whether the fixed size Ustr should be limited
       Type<b>[2]</b>: int

       Parameter<b>[3]</b>: The initial length of the Ustr
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This calls ustr_init_fixed() with sizeof() the area of memory (Parameter[1]) as the second argument.

       <b>Note:</b>

         This  does  mean  that the first argument must be the correct size, as far as sizeof() is concerned, as
       in...

        char buf_sz[1024];
        Ustr *s1 = USTR_SC_INIT_AUTO(buf_sz, USTR_FALSE, 0);

        ...so passing pointers to memory from malloc() will probably just return NULL.

     <b>Function:</b>  USTR_SC_INIT_AUTO_OSTR()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Area of memory to use as a Ustr string
       Type<b>[1]</b>: char[]

       Parameter<b>[2]</b>: Whether the fixed size Ustr should be limited
       Type<b>[2]</b>: int

       Parameter<b>[3]</b>: The initial string in the buffer, as a constant string
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This calls ustr_init_fixed() with sizeof() the area of memory (Parameter[1]) as  the  second  argument,
       given as an "object string".

       <b>Note:</b>

         This  does  mean  that the first argument must be the correct size, as far as sizeof() is concerned, as
       in...

        char buf_sz[1024] = USTR_BEG_FIXED2 "abcd";
        Ustr *s1 = USTR_SC_INIT_AUTO_OSTR(buf_sz, USTR_FALSE, "abcd");

        ...so passing pointers to memory from malloc() will probably just return NULL.

</pre><h4><b>Debugging</b> <b>functions</b></h4><pre>
     <b>Function:</b>  ustr_assert_valid()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a Ustr string
       Type<b>[1]</b>: Ustr *

       <b>Explanation:</b>

         This function asserts a few internal consistency checks, and can help point out when a Ustr is invalid.

       <b>Note:</b>

         This calls ustr_assert_ret() so that when USTR_DEBUG if off the checks  are  still  performed  and  the
       result is returned.

     <b>Function:</b>  ustr_assert_valid_subustr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a Ustr string
       Type<b>[1]</b>: Ustr *

       Parameter<b>[2]</b>: Position in the Ustr
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length to delete from the Ustr
       Type<b>[3]</b>:  size_t

       <b>Explanation:</b>

         This  function  calls  ustr_assert_valid()  and also checks that the position and length are within the
       Ustr. If they aren't valid it returns 0, if they are valid it returns ustr_len().

     <b>Function:</b>  USTR_CNTL_MALLOC_CHECK_BEG()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Condition for begin malloc checking or not
       Type<b>[1]</b>: int

       <b>Explanation:</b>

         This function begins malloc checking, meaning all ustr allocations will go  through  the  malloc  check
       routines, but it fails if the condition check (Parameter[1]) fails.

       <b>Note:</b>

         Turning  malloc  checking  on  after  one  or more allocations has happened will lead to false failures
       unless you really known what you are doing.
         You can automatically turn malloc checking on by giving the USTR_CNTL_MC environment variable the value
       of "1", "yes" or "on".

     <b>Function:</b>  USTR_CNTL_MALLOC_CHECK_LVL()
       Returns: Level of current malloc check
       Type: int

       Parameter<b>[1]</b>: Nothing
       Type<b>[1]</b>: void

       <b>Explanation:</b>

         This function returns the current "level" of the malloc check, with  0  indicating  that  malloc  check
       isn't enabled.
         The  level goes up by one whenever USTR_CNTL_MALLOC_CHECK_BEG() or USTR_CNTL_MALLOC_CHECK_ADD() returns
       success, and goes down  by  one  whenever  USTR_CNTL_MALLOC_CHECK_DEL()  or  USTR_CNTL_MALLOC_CHECK_END()
       returns success.

     <b>Function:</b>  USTR_CNTL_MALLOC_CHECK_MEM()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer returned from malloc check
       Type<b>[1]</b>: void *

       <b>Explanation:</b>

         This function asserts that the pointer (Parameter[1]) was allocated from malloc checking.

       <b>Note:</b>

         Unless you are doing something special, or using a builtin Ustr_pool it is very likely you want to just
       call USTR_CNTL_MALLOC_CHECK_MEM_USTR().

     <b>Function:</b>  USTR_CNTL_MALLOC_CHECK_MEM_SZ()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer returned from malloc check
       Type<b>[1]</b>: void *

       Parameter<b>[2]</b>: Length of allocated memory
       Type<b>[2]</b>: size_t

       <b>Explanation:</b>

         This  function  asserts that the pointer (Parameter[1]) was allocated from malloc checking, and has the
       specified size (Parameter[2]).

       <b>Note:</b>

         Unless you are doing something special, or using a builtin Ustr_pool it is very likely you want to just
       call USTR_CNTL_MALLOC_CHECK_MEM_USTR().

     <b>Function:</b>  USTR_CNTL_MALLOC_CHECK_MEM_MINSZ()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer returned from malloc check
       Type<b>[1]</b>: void *

       Parameter<b>[2]</b>: Length of allocated memory
       Type<b>[2]</b>: size_t

       <b>Explanation:</b>

         This function asserts that the pointer (Parameter[1]) was allocated from malloc checking,  and  has  at
       least the specified size (Parameter[2]).

       <b>Note:</b>

         Unless you are doing something special, or using a builtin Ustr_pool it is very likely you want to just
       call USTR_CNTL_MALLOC_CHECK_MEM_USTR().

     <b>Function:</b>  USTR_CNTL_MALLOC_CHECK_MEM_USTR()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a Ustr string
       Type<b>[1]</b>: Ustr *

       <b>Explanation:</b>

         This  function asserts that the pointer (Parameter[1]) is a Ustr allocated from malloc checking, if the
       Ustr is allocated (if not it returns TRUE).

       <b>Note:</b>

         Because of the layering between the Ustr code and the pool code, if you allocate  an  implicitly  sized
       Ustrp  from  a  pool  and then delete some data from it (which fails) the Ustr layer will think it has an
       implicit   less   than   the   actual   size   so   this   function   will    fail.    This    is    what
       USTR_CNTL_MALLOC_CHECK_MEM_USTRP() is for.

     <b>Function:</b>  USTR_CNTL_MALLOC_CHECK_MEM_USTRP()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a Ustrp string
       Type<b>[1]</b>: Ustrp *

       <b>Explanation:</b>

         This  function  asserts  that  the pointer (Parameter[1]) is a Ustr allocated from a builtin pool using
       malloc checking, if the Ustr is allocated (if not it returns TRUE).

     <b>Function:</b>  USTR_CNTL_MALLOC_CHECK_END()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Nothing
       Type<b>[1]</b>: void

       <b>Explanation:</b>

         This macro will cleanup any memory used by malloc check, and assert that no memory is left allocated.

       <b>Note:</b>

         If any memory is left allocated, each one found is output to stderr with the file/line/function of  the
       level it was allocated from.

     <b>Function:</b>  USTR_CNTL_MALLOC_CHECK_ADD()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Condition to begin malloc checking or not
       Type<b>[1]</b>: int

       <b>Explanation:</b>

         This   function   works   like  USTR_CNTL_MALLOC_CHECK_END()  but  it  fails  if  the  condition  check
       (Parameter[1]) fails, or if USTR_CNTL_MALLOC_CHECK_LVL() is zero.

     <b>Function:</b>  USTR_CNTL_MALLOC_CHECK_DEL()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Condition to end malloc checking or not
       Type<b>[1]</b>: int

       <b>Explanation:</b>

         This  function  works  like  USTR_CNTL_MALLOC_CHECK_END()  but  it  fails  if   the   condition   check
       (Parameter[1]) fails, or if USTR_CNTL_MALLOC_CHECK_LVL() is one.

       <b>Note:</b>

         The  condition  (Parameter[1])  to  this  macro  should  almost  certainly  be  the  return  value from
       USTR_CNTL_MALLOC_CHECK_ADD().

</pre><h4><b>Creating</b> <b>allocated</b> <b>Ustr</b> <b>functions</b></h4><pre>
     <b>Function:</b>  ustr_init_size()
       Returns: Size that needs to be allocated
       Type: size_t

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: Length of data in the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function finds out the exact size of memory needed to  store  the  specified  Ustr  of  the  given
       configuration.

     <b>Function:</b>  ustr_init_alloc()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to area of memory to use as a Ustr string
       Type<b>[1]</b>: void *

       Parameter<b>[2]</b>: Size of area of memory
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Whether Ustr should store the size
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Number of bytes to use for references
       Type<b>[4]</b>: size_t

       Parameter<b>[5]</b>: Whether the Ustr should use exact allocations
       Type<b>[5]</b>: int

       Parameter<b>[6]</b>: Whether the Ustr should have the "enomem" flag set
       Type<b>[6]</b>: int

       Parameter<b>[7]</b>: The initial length of the Ustr
       Type<b>[7]</b>: size_t

       <b>Explanation:</b>

         This  creates  a  new  Ustr  string, you should have allocated the data via.  USTR_CONF_MALLOC() or bad
       things will happen if the Ustr string is ever free'd or reallocated.

     <b>Function:</b>  ustr_dupx_empty()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocation flag
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       <b>Explanation:</b>

         This function creates an empty Ustr, owned by you, that is allocated from system memory, or it  returns
       NULL.
         The  size  is  the  desired  allocation size for the entire Ustr, including overhead for metadata. This
       value will be rounded up, if it's too small, so passing 1 as the size means you want a stored size but to
       allocate the smallest amount of memory possible.
         The exact memory allocation flag says if the Ustr should round allocations up to the nearest half power
       of two or should be no more than needed.
         The ENOMEM memory error flag sets the iniital state of the user  visible  flag  for  memory  allocation
       errors. Eg. ustr_enomem(), ustr_setf_enomem_clr() and ustr_setf_enomem_err()

       <b>Note:</b>

         The  reference  byte count can only be one of the following values: 0, 1, 2 or 4, or 8 (on environments
       with a 64bit size_t).
         It can be useful to ensure that the Ustr is in system memory, so that you can  add  things  to  it  and
       check for errors with ustr_enomem().
         If  you  chose  to  store  the  allocated  size  in the Ustr then the number of bytes allocated for the
       reference count will be a minimum of 2.

     <b>Function:</b>  ustr_dup_empty()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Nothing
       Type<b>[1]</b>: void

       <b>Explanation:</b>

         This function is the same as calling ustr_dupx_empty() with the current set of default options.

     <b>Function:</b>  ustr_dupx_undef()
       Returns: Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: Length of new undefined data
       Type<b>[5]</b>: size_t

       <b>Explanation:</b>

         This function works like you called ustr_dupx_empty() and then ustr_add_undef().

     <b>Function:</b>  ustr_dup_undef()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Length of new undefined data
       Type<b>[1]</b>: size_t

       <b>Explanation:</b>

         This function is the same as calling ustr_dupx_undef() with the current set of default options.

     <b>Function:</b>  ustr_dup()
       Returns: A pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function tries to increase the reference count on the passed Ustr string,  and  if  that  succeeds
       returns that as an argument. If that fails it tries creates a new Ustr string that looks identical to the
       old Ustr string, apart from the reference count.

       <b>Note:</b>

         Because  the new Ustr string is configured identically to the old Ustr string this means the result can
       be very different to what you get if you call ustr_dup_buf() with ustr_cstr()  and  ustr_len()  from  the
       original string where the configuration would be whatever the default is.
         Esp. worth of note is that if you ustr_dup() a Ustr string with an explicit size of 900 but a length of
       1,  and  the  reference  count is full the returned Ustr string will have a size of 900 bytes and so will
       have allocated a little over that. ustr_dup_buf(), even with a sized configuration  would  only  allocate
       about 12 bytes and have a size a little less than that.

     <b>Function:</b>  ustr_dupx()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: Pointer to a constant Ustr string
       Type<b>[5]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  tries  to  add  a  reference  if  the  value of the size, reference bytes, exact memory
       allocations and ENOMEM are the same as those in the passed Ustr string (Parameter[5]). If the  comparison
       fails  or  the  addition  of  a  reference  fails  it  works  like  ustr_dupx_buf() using ustr_cstr() and
       ustr_len().

     <b>Function:</b>  ustr_sc_dup()
       Returns: A pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       <b>Explanation:</b>

         This function works like calling ustr_dup(), but if the reference count is maxed out then and so a  new
       Ustr  string  has  been allocated then that is stored in the passed argument (Parameter[1]) and the "old"
       Ustr string is returned.

       <b>Note:</b>

         The reason to use this is that if you have a "main" Ustr string  pointer  that  a  lot  of  things  are
       getting  references  too then when the reference count maxes out you'll degrade into worst case behaviour
       which acts as though there are no reference counts. This function stops that problem.
         As an example, if you have a 1 byte reference count and have 255 * 2 references then  using  ustr_dup()
       will create 256 Ustr strings using this function will create 4 Ustr strings.

     <b>Function:</b>  ustr_sc_dupx()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: A pointer to a pointer to a Ustr string
       Type<b>[5]</b>: struct Ustr **

       <b>Explanation:</b>

         This function works like calling ustr_dupx(), but if the reference count is maxed out then and so a new
       Ustr  string  is  allocated  then that is stored in the passed argument (Parameter[1]) and the "old" Ustr
       string is returned.
         If the configurations of the new Ustr string and the old Ustr string are not the  same,  this  function
       works identically to ustr_dupx().

       <b>Note:</b>

         The  reason  to  use  this  is  that  if you have a "main" Ustr string pointer that a lot of things are
       getting references too then when the reference count maxes out you'll degrade into worst  case  behaviour
       which acts as though there are no reference counts. This function stops that problem.
         As  an example, if you have a 1 byte reference count and have 255 * 2 references then using ustr_dupx()
       will create 256 Ustr strings using this function will create 4 Ustr strings.

     <b>Function:</b>  ustr_dup_buf()
       Returns: A pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to data
       Type<b>[1]</b>: const void *

       Parameter<b>[2]</b>: Length of data
       Type<b>[2]</b>: size_t

       <b>Explanation:</b>

         This function works as if you had called ustr_dup_undef()  and  then  copied  the  data  into  the  new
       undefined space.

     <b>Function:</b>  ustr_dupx_buf()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: Pointer to data
       Type<b>[5]</b>: const void *

       Parameter<b>[6]</b>: Length of data
       Type<b>[6]</b>: size_t

       <b>Explanation:</b>

         This  function  works  as  if  you  had  called ustr_dupx_undef() and then copied the data into the new
       undefined space.

     <b>Function:</b>  ustr_dup_cstr()
       Returns: A pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to constant C-style string
       Type<b>[1]</b>: const char *

       <b>Explanation:</b>

         This function works as if you had called ustr_dup_buf() and passed strlen() as the length.

     <b>Function:</b>  ustr_dupx_cstr()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: Pointer to constant C-style string
       Type<b>[5]</b>: const char *

       <b>Explanation:</b>

         This function works as if you had called ustr_dupx_buf() and passed strlen() as the length.

     <b>Function:</b>  USTR_DUP_OSTR()
       Returns: A pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: A constant C-style string
       Type<b>[1]</b>: const char []

       <b>Explanation:</b>

         This function works as if you had called ustr_dup_buf() and passed sizeof() - 1 as the length.

     <b>Function:</b>  USTR_DUP_OBJ()
       Returns: A pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: A symbol
       Type<b>[1]</b>: ...

       <b>Explanation:</b>

         This function works as if you had called ustr_dup_buf() and passed sizeof() as the length.

       <b>Note:</b>

         In most cases you'll want to use USTR_DUP_OSTR().

     <b>Function:</b>  ustr_dup_subustr()
       Returns: A pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Position in the Ustr
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length to add from the Ustr
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function mostly works as if you had called ustr_dup_buf() with the ustr_cstr() + position - 1  and
       length values of the Ustr string to be added.

       <b>Note:</b>

         If the position is 1 and the length is the length of the Ustr string then it just calls ustr_dup().

     <b>Function:</b>  ustr_dupx_subustr()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: A pointer to a constant Ustr string
       Type<b>[5]</b>: const struct Ustr *

       Parameter<b>[6]</b>: Position in the Ustr
       Type<b>[6]</b>: size_t

       Parameter<b>[7]</b>: Length to add from the Ustr
       Type<b>[7]</b>: size_t

       <b>Explanation:</b>

         This function mostly works as if you had called ustr_dupx_buf() with the ustr_cstr() + position - 1 and
       length values of the Ustr string to be added.

       <b>Note:</b>

         If the position is 1 and the length is the length of the Ustr string then it just calls ustr_dupx().

     <b>Function:</b>  ustr_dup_rep_chr()
       Returns: A pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Byte value of data
       Type<b>[1]</b>: char

       Parameter<b>[2]</b>: Length of bytes as data
       Type<b>[2]</b>: size_t

       <b>Explanation:</b>

         This  function  works  as  if  you  had  called ustr_dup_undef() and then copied the byte value to each
       position.

     <b>Function:</b>  ustr_dupx_rep_chr()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: Byte value of data
       Type<b>[5]</b>: char

       Parameter<b>[6]</b>: Length of bytes as data
       Type<b>[6]</b>: size_t

       <b>Explanation:</b>

         This function works as if you had called ustr_dupx_undef() and then  copied  the  byte  value  to  each
       position.

     <b>Function:</b>  ustr_sc_vjoin()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Separator to go between Ustr strings
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to the first constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: A pointer to the second constant Ustr string
       Type<b>[3]</b>: const struct Ustr *

       Parameter<b>[4]</b>: Variable argument list variable, from va_start()
       Type<b>[4]</b>: va_list

       <b>Explanation:</b>

         This  function  works  as  if  you  called ustr_dup() on the first Ustr string (Parameter[2]), and then
       ustr_add()  on  the  separator  (Parameter[1])  followed  by  ustr_add()  on  the  second   Ustr   string
       (Parameter[3]).  This  process  then  repeats  for  all  the  Ustr  strings in the variable argument list
       (Parameter[4]) until a USTR_NULL is reached.

       <b>Note:</b>

         This function doesn't guarantee to just take a reference to one of the passed  Ustr  strings,  even  if
       that is what would happen if you called the above manually.

     <b>Function:</b>  ustr_sc_join()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Separator to go between Ustr strings
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to the first constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: A pointer to the second constant Ustr string
       Type<b>[3]</b>: const struct Ustr *

       Parameter<b>[4]</b>: Zero or more pointers to constant Ustr strings and then USTR_NULL
       Type<b>[4]</b>: ...

       <b>Explanation:</b>

         This function calls va_start() to get a variable argument list and then calls ustr_sc_vjoin().

       <b>Note:</b>

         This  function  doesn't  guarantee  to just take a reference to one of the passed Ustr strings, even if
       that is what would happen if you called the above manually.

     <b>Function:</b>  ustr_sc_vjoinx()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: Separator to go between Ustr strings
       Type<b>[5]</b>: const struct Ustr *

       Parameter<b>[6]</b>: A pointer to the first constant Ustr string
       Type<b>[6]</b>: const struct Ustr *

       Parameter<b>[7]</b>: A pointer to the second constant Ustr string
       Type<b>[7]</b>: const struct Ustr *

       Parameter<b>[8]</b>: Variable argument list variable, from va_start()
       Type<b>[8]</b>: va_list

       <b>Explanation:</b>

         This function works as if you called ustr_dupx() on the first  Ustr  string  (Parameter[2]),  and  then
       ustr_add()   on   the  separator  (Parameter[1])  followed  by  ustr_add()  on  the  second  Ustr  string
       (Parameter[3]). This process then repeats for  all  the  Ustr  strings  in  the  variable  argument  list
       (Parameter[4]) until a USTR_NULL is reached.

       <b>Note:</b>

         This  function  doesn't  guarantee  to just take a reference to one of the passed Ustr strings, even if
       that is what would happen if you called the above manually.

     <b>Function:</b>  ustr_sc_joinx()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: Separator to go between Ustr strings
       Type<b>[5]</b>: const struct Ustr *

       Parameter<b>[6]</b>: A pointer to the first constant Ustr string
       Type<b>[6]</b>: const struct Ustr *

       Parameter<b>[7]</b>: A pointer to the second constant Ustr string
       Type<b>[7]</b>: const struct Ustr *

       Parameter<b>[8]</b>: Zero or more pointers to constant Ustr strings and then USTR_NULL
       Type<b>[8]</b>: ...

       <b>Explanation:</b>

         This function calls va_start() to get a variable argument list and then calls ustr_sc_vjoinx().

     <b>Function:</b>  ustr_sc_vconcat()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: A pointer to the first constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Variable argument list variable, from va_start()
       Type<b>[2]</b>: va_list

       <b>Explanation:</b>

         This function works as if you called ustr_dup() on the  first  Ustr  string  (Parameter[1]),  and  then
       ustr_add()  on  the second Ustr string (Parameter[3]). This process then repeats for all the Ustr strings
       in the variable argument list (Parameter[4]) until a USTR_NULL is reached.

       <b>Note:</b>

         This function doesn't guarantee to just take a reference to one of the passed  Ustr  strings,  even  if
       that is what would happen if you called the above manually.

     <b>Function:</b>  ustr_sc_concat()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: A pointer to the first constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Zero or more pointers to constant Ustr strings and then USTR_NULL
       Type<b>[2]</b>: ...

       <b>Explanation:</b>

         This function calls va_start() to get a variable argument list and then calls ustr_sc_vconcat().

     <b>Function:</b>  ustr_sc_vconcatx()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: A pointer to the first constant Ustr string
       Type<b>[5]</b>: const struct Ustr *

       Parameter<b>[6]</b>: Variable argument list variable, from va_start()
       Type<b>[6]</b>: va_list

       <b>Explanation:</b>

         This  function  works  as  if  you called ustr_dupx() on the first Ustr string (Parameter[1]), and then
       ustr_add() on the second Ustr string (Parameter[3]). This process then repeats for all the  Ustr  strings
       in the variable argument list (Parameter[4]) until a USTR_NULL is reached.

       <b>Note:</b>

         This  function  doesn't  guarantee  to just take a reference to one of the passed Ustr strings, even if
       that is what would happen if you called the above manually.

     <b>Function:</b>  ustr_sc_concatx()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: A pointer to the first constant Ustr string
       Type<b>[5]</b>: const struct Ustr *

       Parameter<b>[6]</b>: Zero or more pointers to constant Ustr strings and then USTR_NULL
       Type<b>[6]</b>: ...

       <b>Explanation:</b>

         This function calls va_start() to get a variable argument list and then calls ustr_sc_vconcatx().

</pre><h4><b>Deleting</b> <b>a</b> <b>Ustr,</b> <b>or</b> <b>data</b> <b>within</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_free()
       Returns: Nothing
       Type: void

       Parameter<b>[1]</b>: Pointer to a Ustr
       Type<b>[1]</b>: struct Ustr *

       <b>Explanation:</b>

         This function decrements the reference count on a Ustr, if there  is  one,  and  free's  it  if  it  is
       allocated and the reference count becomes zero.

       <b>Note:</b>

         This function does nothing if passed USTR_NULL.

     <b>Function:</b>  ustrp_free()
       Returns: Nothing
       Type: void

       Parameter<b>[1]</b>: Pointer to a Ustr pool object
       Type<b>[1]</b>: struct Ustr_pool *

       Parameter<b>[2]</b>: Pointer to a Ustrp (pool allocated Ustr)
       Type<b>[2]</b>: struct Ustrp *

       <b>Explanation:</b>

         This  function  works  like  ustr_free()  but  calls  the  pool_free  member  function of the Ustr_pool
       (Parameter[1]) instead of the ustr system free.

     <b>Function:</b>  ustr_sc_free()
       Returns: Nothing
       Type: void

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       <b>Explanation:</b>

         This function calls ustr_free() and then sets the pointer (Parameter[1]) to USTR_NULL, which is a  noop
       when passed to ustr_free(). This can be used to help prevent "double free" errors.

       <b>Note:</b>

         While  the  point  to  the  pointer  must  be non-NULL, this function also accepts a NULL ustr and does
       nothing. So you can pass the same pointer to this function multiple times and only the first one will  do
       anything.

     <b>Function:</b>  ustr_sc_free2()
       Returns: Nothing
       Type: void

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Pointer to a Ustr string
       Type<b>[2]</b>: struct Ustr *

       <b>Explanation:</b>

         This  function works like ustr_sc_free() but instead of setting the pointer (Parameter[1]) to USTR_NULL
       it sets it to the Ustr string (Parameter[2]).

       <b>Note:</b>

         While the point to the pointer must be non-NULL, this function also accepts a NULL ustr  to  be  free'd
       and does nothing. So you can pass the same pointer to ustr_sc_free() and then this function safely.
         The  passed  value  (Parameter[2])  shouldn't  be  USTR_NULL,  and  in debugging mode the function will
       assert() that it isn't.

     <b>Function:</b>  ustr_sc_free_shared()
       Returns: Nothing
       Type: void

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       <b>Explanation:</b>

         This function is a simple way to "free" a Ustr string  that  has  been  shared  (ustr_shared()  returns
       USTR_TRUE),  normally ustr_free() is ignored on a shared Ustr string. It just calls ustr_setf_owner() and
       then ustr_sc_free().

     <b>Function:</b>  ustr_del()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Length to delete from the Ustr
       Type<b>[2]</b>: size_t

       <b>Explanation:</b>

         This function deletes data from the end of Ustr, possibly re-sizing the Ustr at the same time.

       <b>Note:</b>

         The Ustr is never re-sized when the size is stored explicitly, so the pointer never changes.

     <b>Function:</b>  ustr_del_subustr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position in the Ustr
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length to delete from the Ustr
       Type<b>[3]</b>:  size_t

       <b>Explanation:</b>

         This function works like ustr_del() but can delete an arbitrary section of the Ustr.

     <b>Function:</b>  ustr_sc_del()
       Returns: Nothing
       Type: void

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       <b>Explanation:</b>

         This function is like calling ustr_del() with ustr_len() as the length, however if that fails it does a
       ustr_free() and then sets the pointer to USTR("").

       <b>Note:</b>

         While the benefit is that you don't have to check for memory failure  errors,  if  there  is  a  memory
       failure and you have a non-default configuration the configuration will revert back to the default.

</pre><h4><b>Adding</b> <b>data</b> <b>to</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_add_undef()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Length of new undefined data
       Type<b>[2]</b>: size_t

       <b>Explanation:</b>

         The  Ustr  string is expanded (possibly reallocated) so that it can contain length (Parameter[2]) extra
       data, if the length is not zero the Ustr will be writable. Or it'll return USTR_FALSE (zero) on failure.

     <b>Function:</b>  ustr_add_buf()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Pointer to data
       Type<b>[2]</b>: const void *

       Parameter<b>[3]</b>: Length of data
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works as if you had called ustr_add_undef()  and  then  copied  the  data  into  the  new
       undefined space.

     <b>Function:</b>  ustr_add_cstr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Pointer to constant C-style string
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works as if you had called ustr_add_buf() and passed strlen() as the length.

     <b>Function:</b>  USTR_ADD_OSTR()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A constant C-style string
       Type<b>[2]</b>: const char []

       <b>Explanation:</b>

         This function works as if you had called ustr_add_buf() and passed sizeof() - 1 as the length.

     <b>Function:</b>  USTR_ADD_OBJ()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A symbol
       Type<b>[2]</b>: ...

       <b>Explanation:</b>

         This function works as if you had called ustr_add_buf() and passed sizeof() as the length.

       <b>Note:</b>

         In most cases you'll want to use USTR_ADD_OSTR().

     <b>Function:</b>  ustr_add()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  mostly  works  as  if you had called ustr_add_buf() with the ustr_cstr() and ustr_len()
       values of the Ustr string to be added.

       <b>Note:</b>

         If the Ustr string is zero length and isn't writable this function may just add a  reference,  this  is
       fine  for  Ustr  strings that are "constant" because if the Ustr is read-only then the memory will not be
       written to.

     <b>Function:</b>  ustr_add_subustr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to add from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function mostly works as if you had called ustr_add_buf() with the ustr_cstr() + position - 1  and
       length values of the Ustr string to be added. The exception being if you add a ustr to itself, while only
       having  a  single  reference  count, the simple method would access a free'd ustr, but this function just
       works.

       <b>Note:</b>

         If the position is 1 and the length is the length of the Ustr string then it just calls ustr_add().

     <b>Function:</b>  ustr_add_rep_chr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Byte value of data
       Type<b>[2]</b>: char

       Parameter<b>[3]</b>: Length of bytes as data
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works as if you had called ustr_add_undef() and  then  copied  the  byte  value  to  each
       position.

</pre><h4><b>Setting</b> <b>a</b> <b>Ustr</b> <b>to</b> <b>some</b> <b>data</b></h4><pre>
     <b>Function:</b>  ustr_set_undef()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>:  size_t
       Type<b>[2]</b>:  size_t

       <b>Explanation:</b>

         This function works as if you had called ustr_del() for the entire string and the ustr_add_undef().

     <b>Function:</b>  ustr_set_empty()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       <b>Explanation:</b>

         This  function  works as if you had called ustr_del() for the entire string, however the string will be
       allocated if this completes.

     <b>Function:</b>  ustr_set_buf()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Buffer containing data
       Type<b>[2]</b>:  const void *

       Parameter<b>[3]</b>: Length of Buffer
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works as if you had called ustr_del() for the entire string and the ustr_add_buf().

     <b>Function:</b>  ustr_set_cstr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works as if you had called ustr_del() for the entire string and then ustr_add_cstr().

     <b>Function:</b>  USTR_SET_OSTR()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A constant C-style string
       Type<b>[2]</b>: const char []

       <b>Explanation:</b>

         This function works as if you had called ustr_del() for the entire string and then USTR_ADD_OSTR().

     <b>Function:</b>  USTR_SET_OBJ()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A symbol
       Type<b>[2]</b>: ...

       <b>Explanation:</b>

         This function works as if you had called ustr_del() for the entire string and then USTR_ADD_OBJ().

       <b>Note:</b>

         In most cases you'll want to use USTR_SET_OSTR().

     <b>Function:</b>  ustr_set()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works as if you had called ustr_del() for the entire string and the ustr_add().

     <b>Function:</b>  ustr_set_subustr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to set from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works as if you had called ustr_del() for the entire string and  the  ustr_add_subustr().
       The  exception  being if you set a ustr to itself, while only having a single reference count, the simple
       method would access a free'd ustr data, but this function just works.

     <b>Function:</b>  ustr_set_rep_chr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Byte value of data
       Type<b>[2]</b>: char

       Parameter<b>[3]</b>: Length of bytes as data
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works as if you had called ustr_del() for the entire string and the ustr_add_rep_chr().

</pre><h4><b>Inserting</b> <b>data</b> <b>into</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_ins_undef()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of new undefined data
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         The Ustr string is expanded (possibly reallocated) so that it can contain length  (Parameter[2])  extra
       data,  from  after  the  required position. If the length is not zero the Ustr will be writable. Or it'll
       return USTR_FALSE (zero) on failure. The data in the Ustr is moved as needed  to  put  the  new  data  at
       position (Parameter[2]) + 1.

     <b>Function:</b>  ustr_ins_buf()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Pointer to data
       Type<b>[3]</b>: const void *

       Parameter<b>[4]</b>: Length of data
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This  function  works  as  if  you  had  called  ustr_ins_undef() and then copied the data into the new
       undefined space.

     <b>Function:</b>  ustr_ins_cstr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Pointer to constant C-style string
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This function works as if you had called ustr_ins_buf() and passed strlen() as the length.

     <b>Function:</b>  USTR_INS_OSTR()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A constant C-style string
       Type<b>[3]</b>: const char []

       <b>Explanation:</b>

         This function works as if you had called ustr_ins_buf() and passed sizeof() - 1 as the length.

     <b>Function:</b>  USTR_INS_OBJ()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A symbol
       Type<b>[3]</b>: ...

       <b>Explanation:</b>

         This function works as if you had called ustr_ins_buf() and passed sizeof() as the length.

       <b>Note:</b>

         In most cases you'll want to use USTR_INS_OSTR().

     <b>Function:</b>  ustr_ins()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works as if you had called ustr_ins_buf() with the ustr_cstr() and ustr_len()  values  of
       the Ustr string to be added.

     <b>Function:</b>  ustr_ins_subustr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to ins from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function mostly as if you had called ustr_ins_buf() with the ustr_cstr() + position - 1 and length
       values  of  the  Ustr  string to be insed. The exception being if you insert a ustr to itself, while only
       having a single reference count, the simple method would access a free'd ustr  data,  but  this  function
       just works.

     <b>Function:</b>  ustr_ins_rep_chr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[2]</b>: Byte value of data
       Type<b>[2]</b>: char

       Parameter<b>[3]</b>: Length of bytes as data
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This  function  works  as  if  you  had  called ustr_ins_undef() and then copied the byte value to each
       position.

</pre><h4><b>Adding,</b> <b>duplicating</b> <b>and</b> <b>setting</b> <b>formatted</b> <b>data</b> <b>to</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_add_vfmt_lim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Limit of data to add
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Variable argument list variable, from va_start()
       Type<b>[4]</b>: va_list

       <b>Explanation:</b>

         This function works like calling the system vsnprintf() with the limit (Parameter[2]) as the  limit  to
       vsnprintf() and then calling ustr_add_buf().

     <b>Function:</b>  ustr_add_vfmt()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: Variable argument list variable, from va_start()
       Type<b>[3]</b>: va_list

       <b>Explanation:</b>

         This function works like calling the system vsnprintf() and then calling ustr_add_buf().

     <b>Function:</b>  ustr_add_fmt_lim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Limit of data to add
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Options depending on value of Parameter[3]
       Type<b>[4]</b>: ...

       <b>Explanation:</b>

         This  function  works  like calling the system snprintf() with the limit (Parameter[2]) as the limit to
       snprintf() and then calling ustr_add_buf().

     <b>Function:</b>  ustr_add_fmt()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: Options depending on value of Parameter[2]
       Type<b>[3]</b>: ...

       <b>Explanation:</b>

         This function works like calling the system snprintf() and then calling ustr_add_buf().

     <b>Function:</b>  ustr_dup_vfmt_lim()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Limit of data to dup
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Pointer to a constant Ustr string
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: Variable argument list variable, from va_start()
       Type<b>[3]</b>: va_list

       <b>Explanation:</b>

         This function works like calling the system vsnprintf() with the limit (Parameter[2]) as the  limit  to
       vsnprintf() and then calling ustr_dup_buf().

     <b>Function:</b>  ustr_dup_vfmt()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Limit of data to dup
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Pointer to a constant Ustr string
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: Variable argument list variable, from va_start()
       Type<b>[3]</b>: va_list

       <b>Explanation:</b>

         This function works like calling the system vsnprintf() and then calling ustr_dup_buf().

     <b>Function:</b>  ustr_dup_fmt_lim()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Limit of data to dup
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Pointer to a constant Ustr string
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: Options depending on value of Parameter[2]
       Type<b>[3]</b>: ...

       <b>Explanation:</b>

         This  function  works  like calling the system snprintf() with the limit (Parameter[2]) as the limit to
       snprintf() and then calling ustr_dup_buf().

     <b>Function:</b>  ustr_dup_fmt()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to a constant Ustr string
       Type<b>[1]</b>: const char *

       Parameter<b>[2]</b>: Options depending on value of Parameter[1]
       Type<b>[2]</b>: ...

       <b>Explanation:</b>

         This function works like calling the system snprintf() and then calling ustr_dup_buf().

     <b>Function:</b>  ustr_dupx_fmt_lim()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: Limit of data to dup
       Type<b>[5]</b>: size_t

       Parameter<b>[6]</b>: Pointer to a constant Ustr string
       Type<b>[6]</b>: const char *

       Parameter<b>[7]</b>: Options depending on value of Parameter[6]
       Type<b>[7]</b>: ...

       <b>Explanation:</b>

         This function works like calling the system snprintf() with the limit (Parameter[2]) as  the  limit  to
       snprintf() and then calling ustr_dupx_buf().

     <b>Function:</b>  ustr_dupx_fmt()
       Returns: Pointer to a Ustr string
       Type: struct Ustr *

       Parameter<b>[1]</b>: Size of allocated storage
       Type<b>[1]</b>: size_t

       Parameter<b>[2]</b>: Number of bytes to use for reference count
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Exact memory allocations
       Type<b>[3]</b>: int

       Parameter<b>[4]</b>: ENOMEM, memory error flag
       Type<b>[4]</b>: int

       Parameter<b>[5]</b>: Pointer to a constant Ustr string
       Type<b>[5]</b>: const char *

       Parameter<b>[6]</b>: Options depending on value of Parameter[5]
       Type<b>[6]</b>: ...

       <b>Explanation:</b>

         This function works like calling the system snprintf() and then calling ustr_dup_bufx().

     <b>Function:</b>  ustr_set_vfmt_lim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Limit of data to set
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Variable argument list variable, from va_start()
       Type<b>[4]</b>: va_list

       <b>Explanation:</b>

         This function works like calling ustr_del() for all the data and then ustr_add_vfmt_lim().

     <b>Function:</b>  ustr_set_vfmt()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: Variable argument list variable, from va_start()
       Type<b>[3]</b>: va_list

       <b>Explanation:</b>

         This function works like calling ustr_del() for all the data and then ustr_add_vfmt().

     <b>Function:</b>  ustr_set_fmt_lim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Limit of data to set
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Options depending on value of Parameter[3]
       Type<b>[4]</b>: ...

       <b>Explanation:</b>

         This function works like calling ustr_del() for all the data and then ustr_add_fmt_lim().

     <b>Function:</b>  ustr_set_fmt()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: Options depending on value of Parameter[2]
       Type<b>[3]</b>: ...

       <b>Explanation:</b>

         This function works like calling ustr_del() for all the data and then ustr_add_fmt().

     <b>Function:</b>  ustr_ins_vfmt_lim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Limit of data to insert
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: A pointer to a constant C-style string
       Type<b>[4]</b>: const char *

       Parameter<b>[5]</b>: Variable argument list variable, from va_start()
       Type<b>[5]</b>: va_list

       <b>Explanation:</b>

         This  function  works like calling the system vsnprintf() with the limit (Parameter[3]) as the limit to
       vsnprintf() and then calling ustr_ins_buf().

     <b>Function:</b>  ustr_ins_vfmt()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Variable argument list variable, from va_start()
       Type<b>[4]</b>: va_list

       <b>Explanation:</b>

         This function works like calling the system vsnprintf() and then calling ustr_ins_buf().

     <b>Function:</b>  ustr_ins_fmt_lim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Limit of data to insert
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: A pointer to a constant C-style string
       Type<b>[4]</b>: const char *

       Parameter<b>[5]</b>: Options depending on value of Parameter[4]
       Type<b>[5]</b>: ...

       <b>Explanation:</b>

         This function works like calling the system snprintf() with the limit (Parameter[3]) as  the  limit  to
       snprintf() and then calling ustr_ins_buf().

     <b>Function:</b>  ustr_ins_fmt()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position after which the data should be added
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Options depending on value of Parameter[3]
       Type<b>[4]</b>: ...

       <b>Explanation:</b>

         This function works like calling the system snprintf() and then calling ustr_ins_buf().

     <b>Function:</b>  ustr_sub_vfmt_lim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Limit of data to substitute
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: A pointer to a constant C-style string
       Type<b>[4]</b>: const char *

       Parameter<b>[5]</b>: Variable argument list variable, from va_start()
       Type<b>[5]</b>: va_list

       <b>Explanation:</b>

         This  function  works like calling the system vsnprintf() with the limit (Parameter[3]) as the limit to
       vsnprintf() and then calling ustr_sub_buf().

     <b>Function:</b>  ustr_sub_vfmt()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Variable argument list variable, from va_start()
       Type<b>[4]</b>: va_list

       <b>Explanation:</b>

         This function works like calling the system vsnprintf() and then calling ustr_sub_buf().

     <b>Function:</b>  ustr_sub_fmt_lim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Limit of data to substitute
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: A pointer to a constant C-style string
       Type<b>[4]</b>: const char *

       Parameter<b>[5]</b>: Options depending on value of Parameter[4]
       Type<b>[5]</b>: ...

       <b>Explanation:</b>

         This function works like calling the system snprintf() with the limit (Parameter[3]) as  the  limit  to
       snprintf() and then calling ustr_sub_buf().

     <b>Function:</b>  ustr_sub_fmt()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Options depending on value of Parameter[3]
       Type<b>[4]</b>: ...

       <b>Explanation:</b>

         This function works like calling the system snprintf() and then calling ustr_sub_buf().

     <b>Function:</b>  ustr_sc_sub_vfmt_lim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of substitution
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Limit of data to substitute
       Type<b>[4]</b>: size_t

       Parameter<b>[5]</b>: A pointer to a constant C-style string
       Type<b>[5]</b>: const char *

       Parameter<b>[6]</b>: Variable argument list variable, from va_start()
       Type<b>[6]</b>: va_list

       <b>Explanation:</b>

         This  function  works like calling the system vsnprintf() with the limit (Parameter[4]) as the limit to
       vsnprintf() and then calling ustr_sc_sub_buf().

     <b>Function:</b>  ustr_sc_sub_vfmt()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of substitution
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: A pointer to a constant C-style string
       Type<b>[4]</b>: const char *

       Parameter<b>[5]</b>: Variable argument list variable, from va_start()
       Type<b>[5]</b>: va_list

       <b>Explanation:</b>

         This function works like calling the system vsnprintf() and then calling ustr_sc_sub_buf().

     <b>Function:</b>  ustr_sc_sub_fmt_lim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of substitution
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Limit of data to substitute
       Type<b>[4]</b>: size_t

       Parameter<b>[5]</b>: A pointer to a constant C-style string
       Type<b>[5]</b>: const char *

       Parameter<b>[6]</b>: Options depending on value of Parameter[5]
       Type<b>[6]</b>: ...

       <b>Explanation:</b>

         This function works like calling the system snprintf() with the limit (Parameter[3]) as  the  limit  to
       snprintf() and then calling ustr_sc_sub_buf().

     <b>Function:</b>  ustr_sc_sub_fmt()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of substitution
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: A pointer to a constant C-style string
       Type<b>[4]</b>: const char *

       Parameter<b>[5]</b>: Options depending on value of Parameter[5]
       Type<b>[5]</b>: ...

       <b>Explanation:</b>

         This function works like calling the system snprintf() and then calling ustr_sc_sub_buf().

</pre><h4><b>Accessing</b> <b>the</b> <b>variables</b> <b>of</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_len()
       Returns: The length of the Ustr
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  returns  the length of the data within the Ustr, much like strlen() but without getting
       the value wrong in the case of extra NIL bytes.

     <b>Function:</b>  ustr_cstr()
       Returns: Read-only pointer to the start of data in the Ustr
       Type: const char *

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function returns a read-only pointer to the start of the data of the Ustr  string.  Due  to  there
       always being a terminating NIL byte in a Ustr, this is also a valid C-style string.

     <b>Function:</b>  ustr_wstr()
       Returns: Writable pointer to the start of data in the Ustr, or NULL
       Type: char *

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: struct Ustr *

       <b>Explanation:</b>

         This  function  returns  a  writable  pointer to the start of the data of the Ustr string. Due to there
       always being a terminating NIL byte in a Ustr, this is also a valid C-style string.
         If the ustr is read-only (ustr_ro() == USTR_TRUE) then this function will return NULL.

       <b>Note:</b>

         Unless the string is owned (ustr_owner() == USTR_TRUE) it can be a very bad idea to use this to  change
       data, as then all references will be updated. See ustr_sc_wstr().

     <b>Function:</b>  ustr_alloc()
       Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function says if the Ustr is currently in allocated storage.

     <b>Function:</b>  ustr_exact()
       Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  says  if  the  Ustr  is doing exact allocations, so as the Ustr grows it will only have
       storage allocated exactly as required and not in half powers of two.

       <b>Note:</b>

         This will always be USTR_FALSE for read-only Ustr strings (ustr_ro() ==  USTR_TRUE),  even  though  the
       default may be to used exact sized allocations when  adding data to them etc.

     <b>Function:</b>  ustr_sized()
       Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  says  if the Ustr stores an explicit allocation size, if not the size is implied as the
       next highest half power of two.

     <b>Function:</b>  ustr_ro()
       Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function says if the Ustr is current in read-only storage.
         Read-only storage is not writable but can be referenced via. ustr_dup() an infinite number of times.

     <b>Function:</b>  ustr_fixed()
       Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function says if the Ustr is current in fixed size storage.
         Fixed size storage is writable but cannot be referenced.

       <b>Note:</b>

         Fixed size storage always explicitly stores the size of the storage.

     <b>Function:</b>  ustr_enomem()
       Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function just returns the value of the user settable  flag  in  the  Ustr.  It  can  be  set  via.
       ustr_setf_enomem_err() and cleared by ustr_setf_enomem_clr().
         This function is automatically set to on whever a memory allocation failure happens for a Ustr.

       <b>Note:</b>

         If a Ustr is referenced multiple times, ustr_setf_enomem_err() will fail.
         This always fails for Ustr's in read-only storage.

     <b>Function:</b>  ustr_shared()
       Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  says  if  the  Ustr  is in the "shared" mode. It can be set via. ustr_setf_shared() and
       cleared by ustr_setf_owner() on allocated Ustr's.
         Shared mode means that a Ustr can be referenced and unreferenced an infinite number of times.

       <b>Note:</b>

         This always succeeds for Ustr's in read-only storage.
         This always fails for Ustr's in fixed size storage.

     <b>Function:</b>  ustr_limited()
       Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function says if the Ustr is currently in fixed size storage and cannot move to allocated storage.

       <b>Note:</b>

         This always fails for Ustr's in allocated storage.
         This always fails for Ustr's in read-only storage.

     <b>Function:</b>  ustr_owner()
       Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function says if there is only a single reference to the Ustr string.

       <b>Note:</b>

         This always fails for Ustr's in read-only storage.
         This always succeeds for Ustr's in fixed size storage.

     <b>Function:</b>  ustr_size()
       Returns: size_t
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function calculates the maximum amount of data that could  be  stored  (Ie.  the  max  ustr_len())
       without having to re-size the Ustr string.

     <b>Function:</b>  ustr_size_alloc()
       Returns: size_t
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function returns the size of the storage for the Ustr.

     <b>Function:</b>  ustr_size_overhead()
       Returns: size_t
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  returns  the  difference between the size of the storage and the maximum amount of data
       that could be stored without having to re-size the Ustr string.

     <b>Function:</b>  ustr_conf()
       Returns: Nothing
       Type: void

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Return size allocated number
       Type<b>[2]</b>: size_t *

       Parameter<b>[3]</b>: Return number of bytes used in the reference count
       Type<b>[3]</b>: size_t *

       Parameter<b>[4]</b>: Return exact allocations flag
       Type<b>[4]</b>: int *

       Parameter<b>[5]</b>: Return number of bytes used in the length
       Type<b>[5]</b>: size_t *

       Parameter<b>[5]</b>: Return number of references to this Ustr
       Type<b>[5]</b>: size_t *

       <b>Explanation:</b>

         This function gives the configuration of the current Ustr needed to duplicate it via. the ustr_dupx_*()
       functions. It also gives the number of bytes used for the length and the number of references, which  are
       mainly informational.

       <b>Note:</b>

         This  function  differs  from  calling  the  ustr_exact()  etc. functions in that it returns the global
       options if this Ustr isn't allocated, thus telling you what the configuration would be if  the  Ustr  was
       turned into an allocated Ustr by adding data etc.
         Zero  references for an allocated Ustr with a non-zero number of bytes for a reference count means it's
       in "shared" mode).

</pre><h4><b>Setting</b> <b>the</b> <b>flags</b> <b>of</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_setf_enomem_err()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr *

       <b>Explanation:</b>

         This function sets the enomem flag, which can be observed via. the ustr_enomem() function.
         The implication of setting this flag is that a memory error has occurred in a previous function call on
       this Ustr.

       <b>Note:</b>

         This function fails if ustr_owner() fails for the Ustr.

     <b>Function:</b>  ustr_setf_enomem_clr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr *

       <b>Explanation:</b>

         This function clears the enomem flag, which can be observed via. the ustr_enomem() function.
         The implication of this flag being set is that a memory error has occurred in a previous function  call
       on this Ustr, so on clearing the flag you should know you have brought the Ustr back to a known state.

       <b>Note:</b>

         This function fails if ustr_owner() fails for the Ustr.

     <b>Function:</b>  ustr_setf_share()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr *

       <b>Explanation:</b>

         This function sets the shared mode, which can be observed via. the ustr_shared() function.
         This  is  used  on a Ustr so that it can have more references than it is able to hold in it's reference
       count. After this call the Ustr can be referenced and unreferenced an infinite number of times.

       <b>Note:</b>

         After this call the Ustr will never be deleted until ustr_setf_owner() is called.
         This function fails if ustr_alloc() fails for the Ustr.

     <b>Function:</b>  ustr_setf_owner()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr *

       <b>Explanation:</b>

         This function removes the shared mode, which can be observed via. the ustr_shared() function.
         This is used so that a Ustr in shared mode can be free'd.

       <b>Note:</b>

         This function fails if ustr_alloc() fails for the Ustr.

</pre><h4><b>Comparing</b> <b>data</b> <b>in</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_cmp_buf()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to constant bytes, to compare
       Type<b>[2]</b>: const void *

       Parameter<b>[3]</b>: Length of comparison bytes
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works like memcmp() on the Ustr and the passed data.

     <b>Function:</b>  ustr_cmp()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like ustr_cmp_buf() but  with  the  data  from  ustr_cstr()  and  the  length  from
       ustr_len().

     <b>Function:</b>  ustr_cmp_subustr()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to compare from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works like ustr_cmp() but with a limit on the data and length.

     <b>Function:</b>  ustr_cmp_cstr()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_cmp_buf() but with a length from strlen().

     <b>Function:</b>  ustr_cmp_fast_buf()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to constant bytes, to compare
       Type<b>[2]</b>: const void *

       Parameter<b>[3]</b>: Length of comparison bytes
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works like ustr_cmp_buf() but the order of comparison is optimized for speed, but is much
       less friendly to humans.

     <b>Function:</b>  ustr_cmp_fast()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  works  like  ustr_cmp_fast_buf() but with the data from ustr_cstr() and the length from
       ustr_len().

     <b>Function:</b>  ustr_cmp_fast_subustr()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to compare from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works like ustr_cmp_fast() but with a limit on the data and length.

     <b>Function:</b>  ustr_cmp_fast_cstr()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_cmp_fast_buf() but with a length from strlen().

     <b>Function:</b>  ustr_cmp_case_buf()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to constant bytes, to compare
       Type<b>[2]</b>: const void *

       Parameter<b>[3]</b>: Length of comparison bytes
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works like ustr_cmp_buf() but the order of comparison ignores ASCII case.

     <b>Function:</b>  ustr_cmp_case()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like ustr_cmp_case_buf() but with the data from ustr_cstr()  and  the  length  from
       ustr_len().

     <b>Function:</b>  ustr_cmp_case_subustr()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to compare from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works like ustr_cmp_case() but with a limit on the data and length.

     <b>Function:</b>  ustr_cmp_case_cstr()
       Returns: Less then zero, zero or greater than zero depending on comparison
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_cmp_case_buf() but with a length from strlen().

     <b>Function:</b>  ustr_cmp_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like comparing ustr_cmp() against 0.

     <b>Function:</b>  ustr_cmp_buf_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to constant bytes, to compare
       Type<b>[2]</b>: const void *

       Parameter<b>[3]</b>: Length of comparison bytes
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_buf() against 0.

     <b>Function:</b>  ustr_cmp_subustr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to compare from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_subustr() against 0.

     <b>Function:</b>  ustr_cmp_cstr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_cstr() against 0.

     <b>Function:</b>  ustr_cmp_case_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_case() against 0.

     <b>Function:</b>  ustr_cmp_case_buf_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to constant bytes, to compare
       Type<b>[2]</b>: const void *

       Parameter<b>[3]</b>: Length of comparison bytes
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_case_buf() against 0.

     <b>Function:</b>  ustr_cmp_case_subustr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to compare from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_case_subustr() against 0.

     <b>Function:</b>  ustr_cmp_case_cstr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_case_cstr() against 0.

     <b>Function:</b>  ustr_cmp_prefix_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like comparing ustr_cmp() against 0, but the comparison is limited to the length of
       the right hand side.

     <b>Function:</b>  ustr_cmp_prefix_buf_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to constant bytes, to compare
       Type<b>[2]</b>: const void *

       Parameter<b>[3]</b>: Length of comparison bytes
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This  function  works  like  comparing  ustr_cmp_buf()  against 0, but the comparison is limited to the
       length of the right hand side (Parameter[3]).

     <b>Function:</b>  ustr_cmp_prefix_cstr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_cstr() against 0, but the  comparison  is  limited  to  the
       length of the right hand side.

     <b>Function:</b>  ustr_cmp_prefix_subustr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to compare from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This  function  works like comparing ustr_cmp_subustr() against 0, but the comparison is limited to the
       given length (Parameter[4]).

     <b>Function:</b>  ustr_cmp_case_prefix_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_case() against 0, but the  comparison  is  limited  to  the
       length of the right hand side.

     <b>Function:</b>  ustr_cmp_case_prefix_buf_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to constant bytes, to compare
       Type<b>[2]</b>: const void *

       Parameter<b>[3]</b>: Length of comparison bytes
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This  function works like comparing ustr_cmp_case_buf() against 0, but the comparison is limited to the
       length of the right hand side (Parameter[3]).

     <b>Function:</b>  ustr_cmp_case_prefix_cstr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_case_cstr() against 0, but the comparison is limited to the
       length of the right hand side.

     <b>Function:</b>  ustr_cmp_case_prefix_subustr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to compare from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_case_subustr() against 0, but the comparison is limited  to
       the given length (Parameter[4]).

     <b>Function:</b>  ustr_cmp_suffix_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like ustr_cmp_prefix_eq() but compares the end of the left hand side.

     <b>Function:</b>  ustr_cmp_suffix_buf_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to constant bytes, to compare
       Type<b>[2]</b>: const void *

       Parameter<b>[3]</b>: Length of comparison bytes
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works like ustr_cmp_prefix_buf_eq() but compares the end of the left hand side.

     <b>Function:</b>  ustr_cmp_suffix_cstr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_cmp_prefix_cstr_eq() but compares the end of the left hand side.

     <b>Function:</b>  ustr_cmp_suffix_subustr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to compare from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This  function works like comparing ustr_cmp_subustr() against 0, but compares the end of the left hand
       side.

     <b>Function:</b>  ustr_cmp_case_suffix_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like ustr_cmp_case_prefix_eq() but compares the end of the left hand side.

     <b>Function:</b>  ustr_cmp_case_suffix_buf_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to constant bytes, to compare
       Type<b>[2]</b>: const void *

       Parameter<b>[3]</b>: Length of comparison bytes
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works like ustr_cmp_case_prefix_buf_eq() but compares the end of the left hand side.

     <b>Function:</b>  ustr_cmp_case_suffix_cstr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant C-style string
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_cmp_case_prefix_cstr_eq() but compares the end of the left hand side.

     <b>Function:</b>  ustr_cmp_case_suffix_subustr_eq()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to compare from the Ustr
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works like comparing ustr_cmp_case_subustr() against 0, but compares the end of the  left
       hand side.

</pre><h4><b>Searching</b> <b>for</b> <b>data</b> <b>in</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_srch_chr_fwd()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Byte data to search for
       Type<b>[3]</b>: char

       <b>Explanation:</b>

         This  function  searches  for  the  data  (Parameter[3]) in the Ustr, skipping an offset (Parameter[2])
       number of bytes.

     <b>Function:</b>  ustr_srch_chr_rev()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Byte data to search for
       Type<b>[3]</b>: char

       <b>Explanation:</b>

         This function works like ustr_srch_chr_fwd() but it  searches  from  the  end  of  the  string  to  the
       beginning.

       <b>Note:</b>

         The  searching starts from the end of the string, and so the offset is the offset from the end. However
       the position of a byte is always relative to the beginning, so to do a loop you need to take the position
       from the length.

     <b>Function:</b>  ustr_srch_buf_fwd()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to data to search for
       Type<b>[3]</b>: const void *

       Parameter<b>[4]</b>: Length of the data to search for
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function searches for the data (Parameter[3]) of length (Parameter[4]) in the  Ustr,  skipping  an
       offset (Parameter[2]) number of bytes.

     <b>Function:</b>  ustr_srch_buf_rev()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to data to search for
       Type<b>[3]</b>: const void *

       Parameter<b>[4]</b>: Length of the data to search for
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This  function  works  like  ustr_srch_buf_fwd()  but  it  searches  from  the end of the string to the
       beginning.

       <b>Note:</b>

         The searching starts from the end of the string, and so the offset is the offset from the end.  However
       the position of a byte is always relative to the beginning, so to do a loop you need to take the position
       from the length.

     <b>Function:</b>  ustr_srch_fwd()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string, to search for
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  works  like ustr_srch_buf_fwd() but it gets the data pointer by calling ustr_cstr() and
       the length by calling ustr_len() on the passed Ustr (Parameter[3]).

     <b>Function:</b>  ustr_srch_rev()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string, to search for
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like ustr_srch_fwd() but it searches from the end of the string to the beginning.

       <b>Note:</b>

         The searching starts from the end of the string, and so the offset is the offset from the end.  However
       the position of a byte is always relative to the beginning, so to do a loop you need to take the position
       from the length.

     <b>Function:</b>  ustr_srch_cstr_fwd()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to C-style string data, to search for
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This  function  works like ustr_srch_buf_fwd() but it gets the length by calling strlen() on the passed
       data (Parameter[3]).

     <b>Function:</b>  ustr_srch_cstr_rev()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to C-style string data, to search for
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_srch_cstr_fwd() but it searches  from  the  end  of  the  string  to  the
       beginning.

       <b>Note:</b>

         The  searching starts from the end of the string, and so the offset is the offset from the end. However
       the position of a byte is always relative to the beginning, so to do a loop you need to take the position
       from the length.

     <b>Function:</b>  ustr_srch_subustr_fwd()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string
       Type<b>[3]</b>: const struct Ustr *

       Parameter<b>[4]</b>: Position in the Ustr
       Type<b>[4]</b>: size_t

       Parameter<b>[5]</b>: Length of data to search, from the Ustr
       Type<b>[5]</b>: size_t

       <b>Explanation:</b>

         This function works like ustr_srch_fwd() but it moves the data to start at  the  correct  position  and
       limits the length to the value specified.

     <b>Function:</b>  ustr_srch_subustr_rev()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>:  size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string
       Type<b>[3]</b>: const struct Ustr *

       Parameter<b>[4]</b>: Position in the Ustr
       Type<b>[4]</b>: size_t

       Parameter<b>[5]</b>: Length of data to search, from the Ustr
       Type<b>[5]</b>: size_t

       <b>Explanation:</b>

         This  function  works  like  ustr_srch_rev() but it moves the data to start at the correct position and
       limits the length to the value specified.

       <b>Note:</b>

         The searching starts from the end of the string, and so the offset is the offset from the end.  However
       the position of a byte is always relative to the beginning, so to do a loop you need to take the position
       from the length.

     <b>Function:</b>  ustr_srch_case_chr_fwd()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Byte data to search for
       Type<b>[3]</b>: char

       <b>Explanation:</b>

         This function works like ustr_srch_chr_fwd(), but treats ASCII uppercase and lowercase as equivalent.

     <b>Function:</b>  ustr_srch_case_chr_rev()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Byte data to search for
       Type<b>[3]</b>: char

       <b>Explanation:</b>

         This function works like ustr_srch_chr_fwd(), but treats ASCII uppercase and lowercase as equivalent.

     <b>Function:</b>  ustr_srch_case_buf_fwd()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to data to search for
       Type<b>[3]</b>: const void *

       Parameter<b>[4]</b>: Length of the data to search for
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works like ustr_srch_buf_fwd(), but treats ASCII uppercase and lowercase as equivalent.

     <b>Function:</b>  ustr_srch_case_buf_rev()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to data to search for
       Type<b>[3]</b>: const void *

       Parameter<b>[4]</b>: Length of the data to search for
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works like ustr_srch_buf_rev(), but treats ASCII uppercase and lowercase as equivalent.

     <b>Function:</b>  ustr_srch_case_fwd()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string, to search for
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like ustr_srch_fwd(), but treats ASCII uppercase and lowercase as equivalent.

     <b>Function:</b>  ustr_srch_case_rev()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string, to search for
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like ustr_srch_rev(), but treats ASCII uppercase and lowercase as equivalent.

     <b>Function:</b>  ustr_srch_case_cstr_fwd()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to C-style string data, to search for
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_srch_cstr_fwd(), but treats ASCII uppercase and lowercase as equivalent.

     <b>Function:</b>  ustr_srch_case_cstr_rev()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to C-style string data, to search for
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_srch_cstr_rev(), but treats ASCII uppercase and lowercase as equivalent.

     <b>Function:</b>  ustr_srch_case_subustr_fwd()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string
       Type<b>[3]</b>: const struct Ustr *

       Parameter<b>[4]</b>: Position in the Ustr
       Type<b>[4]</b>: size_t

       Parameter<b>[5]</b>: Length of data to search, from the Ustr
       Type<b>[5]</b>: size_t

       <b>Explanation:</b>

         This  function  works  like  ustr_srch_subustr_fwd(),  but  treats  ASCII  uppercase  and  lowercase as
       equivalent.

     <b>Function:</b>  ustr_srch_case_subustr_rev()
       Returns: Position in the Ustr, or zero if not found
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start searching at
       Type<b>[2]</b>:  size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string
       Type<b>[3]</b>: const struct Ustr *

       Parameter<b>[4]</b>: Position in the Ustr
       Type<b>[4]</b>: size_t

       Parameter<b>[5]</b>: Length of data to search, from the Ustr
       Type<b>[5]</b>: size_t

       <b>Explanation:</b>

         This function  works  like  ustr_srch_subustr_rev(),  but  treats  ASCII  uppercase  and  lowercase  as
       equivalent.

</pre><h4><b>Span</b> <b>lengths</b> <b>of</b> <b>data</b> <b>in</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_spn_chr_fwd()
       Returns: Number of bytes in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Byte data
       Type<b>[3]</b>: char

       <b>Explanation:</b>

         This  function returns the length of the start of the Ustr (Parameter[1]) that only contains bytes that
       are equal to the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

     <b>Function:</b>  ustr_spn_chr_rev()
       Returns: Number of bytes in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Byte data
       Type<b>[3]</b>: char

       <b>Explanation:</b>

         This function returns the length of the end of the Ustr (Parameter[1]) that only  contains  bytes  that
       are equal to the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

     <b>Function:</b>  ustr_spn_chrs_fwd()
       Returns: Number of bytes in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Array of byte data, for spanning
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Length of byte data, for spanning
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This  function returns the length of the start of the Ustr (Parameter[1]) that only contains bytes that
       are equal to any byte in the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

     <b>Function:</b>  ustr_spn_chrs_rev()
       Returns: Number of bytes in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Array of byte data
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Length of byte data
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function returns the length of the end of the Ustr (Parameter[1]) that only  contains  bytes  that
       are equal to any byte in the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

     <b>Function:</b>  ustr_spn_fwd()
       Returns: Number of bytes in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string, containing spanning bytes
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like ustr_spn_buf_fwd() but passing ustr_cstr() and ustr_len()

     <b>Function:</b>  ustr_spn_rev()
       Returns: Number of bytes in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string, containing spanning bytes
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like ustr_spn_buf_rev() but passing ustr_cstr() and ustr_len()

     <b>Function:</b>  ustr_spn_cstr_fwd()
       Returns: Number of bytes in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string, containing spanning bytes
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_spn_buf_fwd() but passing strlen() for the length.

     <b>Function:</b>  ustr_spn_cstr_rev()
       Returns: Number of bytes in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string, containing spanning bytes
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_spn_buf_rev() but passing strlen() for the length.

     <b>Function:</b>  ustr_cspn_chr_fwd()
       Returns: Number of bytes not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Byte data
       Type<b>[3]</b>: char

       <b>Explanation:</b>

         This  function returns the length of the start of the Ustr (Parameter[1]) that only contains bytes that
       are not equal to the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

     <b>Function:</b>  ustr_cspn_chr_rev()
       Returns: Number of bytes not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Byte data
       Type<b>[3]</b>: char

       <b>Explanation:</b>

         This function returns the length of the end of the Ustr (Parameter[1]) that only  contains  bytes  that
       are not equal to the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

     <b>Function:</b>  ustr_cspn_chrs_fwd()
       Returns: Number of bytes not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Array of byte data
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Length of byte data
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This  function returns the length of the start of the Ustr (Parameter[1]) that only contains bytes that
       are not equal to any byte in the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

     <b>Function:</b>  ustr_cspn_chrs_rev()
       Returns: Number of bytes not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Array of byte data
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Length of byte data
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function returns the length of the end of the Ustr (Parameter[1]) that only  contains  bytes  that
       are not equal to any byte in the data (Parameter[3]), skipping offset (Parameter[2]) bytes.

     <b>Function:</b>  ustr_cspn_fwd()
       Returns: Number of bytes not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string, containing spanning bytes
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like ustr_cspn_buf_fwd() but passing ustr_cstr() and ustr_len()

     <b>Function:</b>  ustr_cspn_rev()
       Returns: Number of bytes not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string, containing spanning bytes
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works like ustr_cspn_buf_rev() but passing ustr_cstr() and ustr_len()

     <b>Function:</b>  ustr_cspn_cstr_fwd()
       Returns: Number of bytes not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string, containing spanning bytes
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_cspn_buf_fwd() but passing strlen() for the length.

     <b>Function:</b>  ustr_cspn_cstr_rev()
       Returns: Number of bytes not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string, containing spanning bytes
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_cspn_buf_rev() but passing strlen() for the length.

     <b>Function:</b>  ustr_utf8_spn_chrs_fwd()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style UTF-8 string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Length of the C-style UTF-8 string
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This  function  works  like  ustr_spn_chrs_fwd() but the return value, offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_spn_chrs_fwd()  but  given  "xy"  as  a  multi-byte  UTF-8  character  it
       understands that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

     <b>Function:</b>  ustr_utf8_spn_chrs_rev()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style UTF-8 string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>:
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This  function  works  like  ustr_spn_chrs_rev() but the return value, offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_spn_chrs_rev()  but  given  "xy"  as  a  multi-byte  UTF-8  character  it
       understands that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

     <b>Function:</b>  ustr_utf8_spn_fwd()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  works  like  ustr_spn_fwd()  but  the  return  value,  offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_spn_fwd() but given "xy" as a multi-byte UTF-8 character  it  understands
       that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

     <b>Function:</b>  ustr_utf8_spn_rev()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  works  like  ustr_spn_rev()  but  the  return  value,  offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_spn_rev() but given "xy" as a multi-byte UTF-8 character  it  understands
       that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

     <b>Function:</b>  ustr_utf8_spn_cstr_fwd()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style UTF-8 string
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This  function  works  like  ustr_spn_cstr_fwd() but the return value, offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_spn_cstr_fwd()  but  given  "xy"  as  a  multi-byte  UTF-8  character  it
       understands that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

     <b>Function:</b>  ustr_utf8_spn_cstr_rev()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style UTF-8 string
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This  function  works  like  ustr_spn_cstr_rev() but the return value, offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_spn_cstr_rev()  but  given  "xy"  as  a  multi-byte  UTF-8  character  it
       understands that the span over "xyxz" is 1 UTF-8 character and not 3 bytes.

     <b>Function:</b>  ustr_utf8_cspn_chrs_fwd()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style UTF-8 string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Length of the C-style UTF-8 string
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This  function  works  like ustr_cspn_chrs_fwd() but the return value, offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_cspn_chrs_fwd() but  given  "xy"  as  a  multi-byte  UTF-8  character  it
       understands that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

     <b>Function:</b>  ustr_utf8_cspn_chrs_rev()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style UTF-8 string
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Length of the C-style UTF-8 string
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This  function  works  like ustr_cspn_chrs_rev() but the return value, offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_cspn_chrs_rev() but  given  "xy"  as  a  multi-byte  UTF-8  character  it
       understands that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

     <b>Function:</b>  ustr_utf8_cspn_fwd()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr UTF-8 string, containing spanning data
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  works  like  ustr_cspn_fwd()  but  the  return  value, offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_cspn_fwd() but given "xy" as a multi-byte UTF-8 character it  understands
       that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

     <b>Function:</b>  ustr_utf8_cspn_rev()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to constant Ustr UTF-8 string data, containing spanning data
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  works  like  ustr_cspn_rev()  but  the  return  value, offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_cspn_rev() but given "xy" as a multi-byte UTF-8 character it  understands
       that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

     <b>Function:</b>  ustr_utf8_cspn_cstr_fwd()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to constant C-style UTF-8 string data, containing spanning data
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This  function  works  like ustr_cspn_cstr_fwd() but the return value, offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_cspn_cstr_fwd() but  given  "xy"  as  a  multi-byte  UTF-8  character  it
       understands that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

     <b>Function:</b>  ustr_utf8_cspn_cstr_rev()
       Returns: Number of UTF-8 characters not in the span
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr UTF-8 string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string, in UTF-8 characters, to start compliment spanning from
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to C-style UTF-8 string data, containing spanning data
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This  function  works  like ustr_cspn_cstr_rev() but the return value, offset, and length all use UTF-8
       characters and not bytes.

       <b>Note:</b>

         This is much slower than ustr_spn_cstr_rev()  but  given  "xy"  as  a  multi-byte  UTF-8  character  it
       understands that the compliment span over "xzxy" is 1 UTF-8 character and not 0 bytes.

</pre><h4><b>Doing</b> <b>IO</b> <b>from</b> <b>or</b> <b>to</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_io_get()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a C file object
       Type<b>[2]</b>: FILE *

       Parameter<b>[3]</b>: Number of bytes to read
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Returned number of bytes read
       Type<b>[4]</b>: size_t *

       <b>Explanation:</b>

         This  function  tries to read a minimum number of bytes from the file object, into the Ustr string. The
       exact number read is returned, unless (Parameter[4]) is NULL.

     <b>Function:</b>  ustr_io_getfile()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a C file object
       Type<b>[2]</b>: FILE *

       <b>Explanation:</b>

         This function calls ustr_io_get() rpeatedly until EOF is encountered.

       <b>Note:</b>

         The errno value when this function ends could either be from fopen(), fread(), or if both of the  those
       succeeded from fclose().

     <b>Function:</b>  ustr_io_getfilename()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A C-style string of a filename
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This  function  opens  a  specified  file, and then calls ustr_io_getfile(). Finally closing the FILE *
       object.

     <b>Function:</b>  ustr_io_getdelim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a C file object
       Type<b>[2]</b>: FILE *

       Parameter<b>[3]</b>: A delimiter byte to stop reading at
       Type<b>[3]</b>: char

       <b>Explanation:</b>

         This function reads bytes from the file until it hits the delimiter byte.

       <b>Note:</b>

         The delimiter is included, use ustr_del() to remove 1 byte from the end if you don't want it.
         This function assumes a delimiter will happen every 80 bytes or so.

     <b>Function:</b>  ustr_io_getline()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a C file object
       Type<b>[2]</b>: FILE *

       <b>Explanation:</b>

         This function works like calling ustr_io_getdelim() with '\n' as the delimiter.

     <b>Function:</b>  ustr_io_put()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a C file object
       Type<b>[2]</b>: FILE *

       Parameter<b>[3]</b>: Number of bytes to write
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function is the opposite of ustr_io_get(), taking bytes from the beginning of the Ustr and writing
       them to the file.

       <b>Note:</b>

         Deleting bytes from the beginning of a Ustr string is the most  inefficient  thing  to  do,  so  it  is
       recommended to use ustr_io_putfile().

     <b>Function:</b>  ustr_io_putline()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a C file object
       Type<b>[2]</b>: FILE *

       Parameter<b>[3]</b>: Number of bytes to write
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function works like calling ustr_io_put(), and then writing a '\n' to the file.

       <b>Note:</b>

         This  doesn't  write  a  line  from the Ustr to the file, if you want that call ustr_io_put() directly,
       using the return from ustr_srch_chr_fwd() (with a '\n') as the number of bytes argument.

     <b>Function:</b>  ustr_io_putfile()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a C file object
       Type<b>[2]</b>: FILE *

       <b>Explanation:</b>

         This function works like calling ustr_io_put() with ustr_len() as the number of bytes.

     <b>Function:</b>  ustr_io_putfileline()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a C file object
       Type<b>[2]</b>: FILE *

       <b>Explanation:</b>

         This function works like calling ustr_io_putline() with ustr_len() as the number of bytes.

     <b>Function:</b>  ustr_io_putfilename()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A C-style string of a filename
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: A C-style string of a filemode (the second argument to fopen)
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This function opens a specified file, and then calls ustr_io_putfile().  Finally  closing  the  FILE  *
       object.

       <b>Note:</b>

         The errno value when this function ends could either be from fopen(), fwrite(), or if both of the those
       succeeded from fclose().

</pre><h4><b>String</b> <b>substitution/replacement</b></h4><pre>
     <b>Function:</b>  ustr_sub_undef()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of undefined data
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         The  Ustr  string  is  expanded  as  required  (possibly  reallocated)  so  that  it can contain length
       (Parameter[2]) data, from the required position. If the length is not zero the Ustr will be writable.  Or
       it'll return USTR_FALSE (zero) on failure.

       <b>Note:</b>

         You  can  think  of  the  operation as two separate tasks, one which makes the current data in the Ustr
       undefined and the second which adds undefined data to the ustr to accommodate the desired length.

     <b>Function:</b>  ustr_sub_buf()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Buffer containing substitution string
       Type<b>[3]</b>: const void *

       Parameter<b>[4]</b>: Length of buffer
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works as if you had called ustr_sub_undef()  and  then  copied  the  data  into  the  new
       undefined space.

     <b>Function:</b>  ustr_sub_cstr()
       Returns: success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant C-style string, which is the substitution
       Type<b>[3]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_sub_buf() but the length is worked out automatically by strlen().

     <b>Function:</b>  USTR_SUB_OSTR()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A constant C-style string
       Type<b>[3]</b>: const char []

       <b>Explanation:</b>

         This function works as if you had called ustr_sub_buf() and passed sizeof() - 1 as the length.

     <b>Function:</b>  USTR_SUB_OBJ()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A symbol
       Type<b>[3]</b>: ...

       <b>Explanation:</b>

         This function works as if you had called ustr_sub_buf() and passed sizeof() as the length.

       <b>Note:</b>

         In most cases you'll want to use USTR_SUB_OSTR().

     <b>Function:</b>  ustr_sub()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string
       Type<b>[3]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  works as if you had called ustr_sub_buf() with the ustr_cstr() and ustr_len() values of
       the Ustr string to be added. The exception being if you substitute a ustr into itself, while only  having
       a  single  reference  count,  the  simple  method could access a free'd ustr data, but this function just
       works.

     <b>Function:</b>  ustr_sub_subustr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: A pointer to a constant Ustr string
       Type<b>[3]</b>: const struct Ustr *

       Parameter<b>[4]</b>: Position in the Ustr
       Type<b>[4]</b>: size_t

       Parameter<b>[5]</b>: Length to substitute from the Ustr
       Type<b>[5]</b>: size_t

       <b>Explanation:</b>

         This function mostly as if you had called ustr_sub_buf() with the ustr_cstr() + position - 1 and length
       values of the Ustr string to be insed. The exception being if you insert a ustr  to  itself,  while  only
       having  a  single  reference  count, the simple method would access a free'd ustr data, but this function
       just works.

     <b>Function:</b>  ustr_sc_sub_undef()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of substitution
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length of undefined data
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works as if you had done ustr_del_subustr() followed by ustr_ins_undef(), however  it  is
       significantly more efficient.

     <b>Function:</b>  ustr_sc_sub_buf()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of substitution
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Buffer containing substitute data
       Type<b>[4]</b>: const void *

       Parameter<b>[5]</b>: Length of Buffer
       Type<b>[5]</b>: size_t

       <b>Explanation:</b>

         This  function  will  substitute a specific number of characters in a Ustr with the data from a buffer,
       this function does the job of one or more of ustr_add_buf(), ustr_sub_buf() and ustr_del().

     <b>Function:</b>  ustr_sc_sub_cstr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start replacement
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of substitution
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: A pointer to a constant C-style string, containing spanning bytes
       Type<b>[4]</b>: const char *

       <b>Explanation:</b>

         This function works like ustr_sc_sub_buf() but the length is worked out automatically by strlen().

     <b>Function:</b>  ustr_sc_sub()
       Returns: success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of substitution
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Pointer to a Ustr containing the substitute string
       Type<b>[4]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function works as if you had called ustr_sc_sub_buf() with the ustr_cstr() and  ustr_len()  values
       of  the  Ustr  string  to  be added. The exception being if you substitute a ustr into itself, while only
       having a single reference count, the simple method could access a free'd ustr  data,  but  this  function
       just works.

     <b>Function:</b>  ustr_sc_sub_subustr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of substitution
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: A pointer to a constant Ustr string
       Type<b>[4]</b>: const struct Ustr *

       Parameter<b>[5]</b>: Position in the Ustr
       Type<b>[5]</b>: size_t

       Parameter<b>[6]</b>: Length to substitute from the Ustr
       Type<b>[6]</b>: size_t

       <b>Explanation:</b>

         This  function  mostly  as  if you had called ustr_sc_sub_buf() with the ustr_cstr() + position - 1 and
       length values of the Ustr string to be insed. The exception being if you insert a ustr to  itself,  while
       only  having  a  single  reference  count,  the  simple  method would access a free'd ustr data, but this
       function just works.

     <b>Function:</b>  USTR_SC_SUB_OSTR()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of substitution
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: A constant C-style string
       Type<b>[4]</b>: const char []

       <b>Explanation:</b>

         This function works as if you had called ustr_sc_sub_buf() and passed sizeof() - 1 as the length.

     <b>Function:</b>  USTR_SC_SUB_OBJ()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Position where to start substitution
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of substitution
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: A symbol
       Type<b>[4]</b>: ...

       <b>Explanation:</b>

         This function works as if you had called ustr_sc_sub_buf() and passed sizeof() as the length.

       <b>Note:</b>

         In most cases you'll want to use USTR_SUB_OSTR().

     <b>Function:</b>  ustr_replace_buf()
       Returns: Number of tokens replaced
       Type: size_t

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr (haystack)
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Buffer containing search data
       Type<b>[2]</b>: const void *

       Parameter<b>[3]</b>: Length of search buffer
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Buffer containing replacement data
       Type<b>[4]</b>: const void *

       Parameter<b>[5]</b>: Length of replacement buffer
       Type<b>[5]</b>: size_t

       Parameter<b>[6]</b>: Maximum number of matches to replace (0 for unlimited)
       Type<b>[6]</b>: size_t

       <b>Explanation:</b>

         This  function  scans  the  "haystack"  (Parameter[1])  for  "needle"   (Parameter[2])   and   replaces
       max_replacements (Parameter[6]) matches with the "replacement" (Parameter[4]).

       <b>Note:</b>

         If max_replacements (Parameter[6]) is 0, this function will replace ALL occurrences.

     <b>Function:</b>  ustr_replace_cstr()
       Returns: Number of tokens replaced
       Type: size_t

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr (haystack)
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant C-style string, containing search bytes
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: A pointer to a constant C-style string, containing replacement bytes
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Maximum number of matches to replace (0 for unlimited)
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This  function  works  like  ustr_replace_buf()  but gets the lengths for the buffer automatically from
       strlen().

     <b>Function:</b>  ustr_replace()
       Returns: Number of tokens replaced
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr (haystack)
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Ustr to search for (needle)
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Ustr to replace needle with
       Type<b>[3]</b>: const struct Ustr *

       Parameter<b>[4]</b>: Maximum number of matches to replace (0 for unlimited)
       Type<b>[4]</b>: size_t

       <b>Explanation:</b>

         This function works like ustr_replace_buf() but gets the lengths from the ustr automatically.

     <b>Function:</b>  ustr_replace_rep_chr()
       Returns: number of replacements made
       Type: size_t

       Parameter<b>[1]</b>: pointer to a pointer to a Ustr to be modified
       Type<b>[1]</b>: struct Ustr **ps1

       Parameter<b>[2]</b>: character to replace
       Type<b>[2]</b>: char

       Parameter<b>[3]</b>: number of characters to replace
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: character to replace with
       Type<b>[4]</b>: char

       Parameter<b>[5]</b>: number of characters to replace with
       Type<b>[5]</b>: size_t nlen

       Parameter<b>[6]</b>: maximum number of replacements to make (use 0 for unlimited)
       Type<b>[6]</b>: size_t lim

       <b>Explanation:</b>

         This function  replaces  a  repeating  sequence  of  characters  with  another  repeating  sequence  of
       characters.
         For example...

         Ustr *data = ustr_dup_cstr("xxxBxxCxDxxx");
         ustr_replace_rep_chr(&amp;data,'x',2,'y',1, 0)

        ...would change data to be "yxByCxDyx".

       <b>Note:</b>

         Changing  the same letter the same number of times is considered a No-op since it is a vast performance
       improvement this way. So passing in  (&amp;data,'y',2,'y',2 ,0) will have a return value of 0 and the  string
       will be unchanged.

</pre><h4><b>Splitting</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_split_buf()
       Returns: pointer to a Ustr representing the next token
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to a constant Ustr to be split
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Pointer to an offset
       Type<b>[2]</b>: size_t *

       Parameter<b>[3]</b>: Buffer to use as split search pattern
       Type<b>[3]</b>: const void *

       Parameter<b>[4]</b>: Length of buffer
       Type<b>[4]</b>: size_t

       Parameter<b>[5]</b>: Pointer to a Ustr to be used as the return value
       Type<b>[5]</b>: struct Ustr *

       Parameter<b>[6]</b>: Flags with the prefix USTR_FLAG_SPLIT_
       Type<b>[6]</b>: unsigned int

       <b>Explanation:</b>

         This  function  works  in  a  manner  similar to strtok(). Each time the function is called, the string
       inside of the buffer (Parameter[3]) is used as a search pattern at which to split. If the pattern is  not
       found,  the  entire  string will be returned. A USTR_NULL return value indicates there are no more tokens
       remaining.
         Parameter[5] is a a pointer to a Ustr where the return value will be placed.  Passing  a  USTR_NULL  to
       this parameter will cause the string to be allocated and <b>MUST</b> be freed <b>manually</b>. If, however, you pass in
       a  non-null  Ustr  to this parameter, each call to ustr_split_buf() will free what is in this pointer and
       place the new token there (when USTR_NULL is  returned,  nothing  needs  to  be  free'd).   For  example,
       given...

         Ustr *data = ...;
         Ustr *tok = USTR_NULL;
         const char *sep = ",";
         size_t off = 0;
         unsigned int flags = USTR_FLAGS_SPLIT_DEF;

        ...there are two options...

         while ((tok = ustr_split_buf(data, &amp;off, sep, strlen(sep), tok, flags)))
         {
           /* Do something with tok -- but next iteration of the loop will free
            * and overwrite tok, so you must ustr_dup() if you want to keep it */
         }
         /* tok is now NULL again after the loop */

        ...or...

         while ((tok = ustr_split_buf(data, &amp;off, sep, strlen(sep), USTR_NULL, flags)))
         {
           /* Do something with tok, and it will NOT be freed in the next iteration of
            * the loop */
             ustr_free(tok); /* have to free to avoid mem leaks */
         }

        ...the former of which being the safer option.

       <b>Note:</b>

         There are several flags that will alter the behaviour of this function, all of which have a common with
       the default being USTR_FLAG_SPLIT_DEF.
         If  you  are calling this function directly, it is very likely that you'd want to use ustr_split_cstr()
       instead.

     <b>Function:</b>  ustr_split()
       Returns: Pointer to a Ustr representing the next token
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to a constant Ustr to be split
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Pointer to an offset variable
       Type<b>[2]</b>: size_t *

       Parameter<b>[3]</b>: Pointer to a constant Ustr to use as the split search pattern
       Type<b>[3]</b>: const struct Ustr *

       Parameter<b>[4]</b>: Pointer to a Ustr where the return value will be placed
       Type<b>[4]</b>: struct Ustr *

       Parameter<b>[5]</b>: Flags
       Type<b>[5]</b>: unsigned int

       <b>Explanation:</b>

          Works like ustr_split_buf() but takes a Ustr as the split search pattern
         instead.

     <b>Function:</b>  ustr_split_cstr()
       Returns: Pointer to a Ustr representing the next token
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to a constant Ustr to be split
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Pointer to an offset variable
       Type<b>[2]</b>: size_t *

       Parameter<b>[3]</b>: C string to use as split search pattern
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Pointer to a Ustr where the return value will be placed
       Type<b>[4]</b>: struct Ustr *

       Parameter<b>[5]</b>: Flags
       Type<b>[5]</b>: unsigned int

       <b>Explanation:</b>

         Works like ustr_split_buf() but takes a C string as the split search pattern, and so  gets  the  length
       via. strlen().

     <b>Function:</b>  ustr_split_spn_chrs()
       Returns: Pointer to a Ustr representing the next token
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to a Ustr to be split
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Pointer to an offset variable
       Type<b>[2]</b>: size_t *

       Parameter<b>[3]</b>: String representing a set of bytes to use as split chars
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Length of the string of set of bytes
       Type<b>[4]</b>: size_t

       Parameter<b>[5]</b>: Pointer to a Ustr where the return value will be placed
       Type<b>[5]</b>: struct Ustr *

       Parameter<b>[6]</b>: flags
       Type<b>[6]</b>: unsigned int

       <b>Explanation:</b>

         Works  like ustr_split_buf() but uses the individual ASCII bytes in the separator string (Parameter[3])
       as search patterns. It will split if <b>ANY</b> of these individual characters are matched (much like strtok()).
       For example: if splitting "this, is,a test" with the separator string ", " the tokens returned  would  be
       {"this" "is" "a" "test"};

       <b>Note:</b>

         If   you   are   calling   this   function  directly,  it  is  very  likely  that  you'd  want  to  use
       ustr_split_spn_cstr() instead.

     <b>Function:</b>  ustr_split_spn_cstr()
       Returns: Pointer to a Ustr representing the next token
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to a Ustr to be split
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Pointer to an offset variable
       Type<b>[2]</b>: size_t *

       Parameter<b>[3]</b>: String representing a set of bytes to use as split chars
       Type<b>[3]</b>: const char *

       Parameter<b>[4]</b>: Pointer to a Ustr where the return value will be placed
       Type<b>[4]</b>: struct Ustr *

       Parameter<b>[5]</b>: flags
       Type<b>[5]</b>: unsigned int

       <b>Explanation:</b>

         Works like ustr_split_spn_chrs() but gets the length automatically via. strlen().

     <b>Function:</b>  ustr_split_spn()
       Returns: Pointer to a Ustr representing the next token
       Type: struct Ustr *

       Parameter<b>[1]</b>: Pointer to a constant Ustr to be split
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Pointer to an offset variable
       Type<b>[2]</b>: size_t *

       Parameter<b>[3]</b>: Pointer to a constant Ustr to use as the split search pattern
       Type<b>[3]</b>: const struct Ustr *

       Parameter<b>[4]</b>: Pointer to a Ustr where the return value will be placed
       Type<b>[4]</b>: struct Ustr *

       Parameter<b>[5]</b>: Flags
       Type<b>[5]</b>: unsigned int

       <b>Explanation:</b>

         Works like ustr_split_spn_chrs() but takes a Ustr as the split chars instead.

</pre><h4><b>Dealing</b> <b>with</b> <b>UTF-8</b> <b>in</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_utf8_valid()
       Returns: A boolean flag of either USTR_TRUE or USTR_FALSE
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function tries it's best to find out if the string is a valid utf-8 string.

     <b>Function:</b>  ustr_utf8_len()
       Returns: The number of the utf-8 characters in the Ustr
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function counts the number of utf-8 characters inn the Ustr.

       <b>Note:</b>

         This function gives undefined answers on strings that aren't utf-8 valid.

     <b>Function:</b>  ustr_utf8_width()
       Returns: ssize_t
       Type: ssize_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       <b>Explanation:</b>

         This function returns the visible width of the string, assuming it is a valid  utf-8  string.  This  is
       like converting to wide characters and using wcwidth().

     <b>Function:</b>  ustr_utf8_chars2bytes()
       Returns: Length of span in bytes
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Position of a span in utf-8 characters
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of a span in utf-8 characters
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Returns the position of the span in bytes
       Type<b>[4]</b>: size_t *

       <b>Explanation:</b>

         This function converts a span, in utf-8 characters, to the same span in bytes.

     <b>Function:</b>  ustr_utf8_bytes2chars()
       Returns: Returns the position of a span in utf-8 characters
       Type: size_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Position of a span in bytes
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length of a span in bytes
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Returns length of a span in utf-8 characters
       Type<b>[4]</b>: size_t *

       <b>Explanation:</b>

         This function converts a span, in bytes, to the same span in utf-8 characters.

       <b>Note:</b>

         Because  a  byte span can start or end within a utf-8 character, converting the return values back into
       bytes via. ustr_utf8_chars2bytes() may make the span be slightly bigger (position slightly  earlier,  and
       the length slightly longer).

     <b>Function:</b>  ustr_sc_utf8_reverse()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       <b>Explanation:</b>

         This function reverses the utf-8 characters in the Ustr string, assuming it is a valid utf-8 string, so
       the last one becomes the first and the second to last becomes the second etc.

</pre><h4><b>Parsing</b> <b>ASCII</b> <b>integer</b> <b>numbers</b> <b>from</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_parse_uintmaxx()
       Returns: Parsed number, or zero on error
       Type: uintmax_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
       Type<b>[3]</b>: unsigned int

       Parameter<b>[4]</b>: Absolute minimum value
       Type<b>[4]</b>: uintmax_t

       Parameter<b>[5]</b>: Absolute maximum value
       Type<b>[5]</b>: uintmax_t

       Parameter<b>[6]</b>: Thousands separator
       Type<b>[6]</b>: const char *

       Parameter<b>[7]</b>: Return length of parsed number
       Type<b>[7]</b>: size_t *

       Parameter<b>[8]</b>: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
       Type<b>[8]</b>: unsigned int *

       <b>Explanation:</b>

         This  function  parses  an  ASCII representation of a number from a Ustr (Parameter[1]) starting at the
       offset (Parameter[2]).

       <b>Note:</b>

         If stdint.h isn't available this function won't be available.

     <b>Function:</b>  ustr_parse_uintmax()
       Returns: Parsed number, or zero on error
       Type: uintmax_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
       Type<b>[3]</b>: unsigned int

       Parameter<b>[4]</b>: Return length of parsed number
       Type<b>[4]</b>: size_t *

       Parameter<b>[5]</b>: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
       Type<b>[5]</b>: unsigned int *

       <b>Explanation:</b>

         This function works like ustr_parse_uintmaxx() with the minimum and  maximum  values  taken  as  0  and
       UINTMAX_MAX, and the thousands separator as "_".

       <b>Note:</b>

         If stdint.h isn't available this function won't be available.

     <b>Function:</b>  ustr_parse_intmax()
       Returns: Parsed number, or zero on error
       Type: intmax_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
       Type<b>[3]</b>: unsigned int

       Parameter<b>[4]</b>: Return length of parsed number
       Type<b>[4]</b>: size_t *

       Parameter<b>[5]</b>: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
       Type<b>[5]</b>: unsigned int *

       <b>Explanation:</b>

         This function works like ustr_parse_uintmaxx() with the minimum and maximum values taken as -INTMAX_MIN
       and INTMAX_MAX, and the thousands separator as "_".

       <b>Note:</b>

         If stdint.h isn't available this function won't be available.

     <b>Function:</b>  ustr_parse_ulongx()
       Returns: Parsed number, or zero on error
       Type: unsigned long

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>:  size_t

       Parameter<b>[3]</b>: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
       Type<b>[3]</b>:  unsigned int

       Parameter<b>[4]</b>: Absolute minimum value
       Type<b>[4]</b>:  unsigned long

       Parameter<b>[5]</b>: Absolute maximum value
       Type<b>[5]</b>:  unsigned long

       Parameter<b>[6]</b>: Thousands separator
       Type<b>[6]</b>: const char *

       Parameter<b>[7]</b>: Return length of parsed number
       Type<b>[7]</b>:  size_t *

       Parameter<b>[8]</b>: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
       Type<b>[8]</b>: unsigned int *

       <b>Explanation:</b>

         This  function  works  like  ustr_parse_uintmaxx() but returns an unsigned long, it is always available
       even when stdint.h isn't.

     <b>Function:</b>  ustr_parse_ulong()
       Returns: Parsed number, or zero on error
       Type: unsigned long

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
       Type<b>[3]</b>: unsigned int

       Parameter<b>[4]</b>: Return length of parsed number
       Type<b>[4]</b>: size_t *

       Parameter<b>[5]</b>: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
       Type<b>[5]</b>: unsigned int *

       <b>Explanation:</b>

         This function works like ustr_parse_ulongx() with the  minimum  and  maximum  values  taken  as  0  and
       ULONG_MAX, and the thousands separator as "_".

     <b>Function:</b>  ustr_parse_long()
       Returns: Parsed number, or zero on error
       Type: long

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
       Type<b>[3]</b>: unsigned int

       Parameter<b>[4]</b>: Return length of parsed number
       Type<b>[4]</b>: size_t *

       Parameter<b>[5]</b>: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
       Type<b>[5]</b>: unsigned int *

       <b>Explanation:</b>

         This function works like ustr_parse_ulongx() with the minimum and maximum values taken as -LONG_MIN and
       LONG_MAX, and the thousands separator as "_".

     <b>Function:</b>  ustr_parse_uint()
       Returns: Parsed number, or zero on error
       Type: unsigned int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
       Type<b>[3]</b>: unsigned int

       Parameter<b>[4]</b>: Return length of parsed number
       Type<b>[4]</b>: size_t *

       Parameter<b>[5]</b>: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
       Type<b>[5]</b>: unsigned int *

       <b>Explanation:</b>

         This  function  works  like  ustr_parse_ulongx()  with  the  minimum  and maximum values taken as 0 and
       UINT_MAX, and the thousands separator as "_".

     <b>Function:</b>  ustr_parse_int()
       Returns: Parsed number, or zero on error
       Type: int

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
       Type<b>[3]</b>: unsigned int

       Parameter<b>[4]</b>: Return length of parsed number
       Type<b>[4]</b>: size_t *

       Parameter<b>[5]</b>: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
       Type<b>[5]</b>: unsigned int *

       <b>Explanation:</b>

         This function works like ustr_parse_ulongx() with the minimum and maximum values taken as -INT_MIN  and
       INT_MAX, and the thousands separator as "_".

     <b>Function:</b>  ustr_parse_ushort()
       Returns: Parsed number, or zero on error
       Type: unsigned short

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
       Type<b>[3]</b>: unsigned int

       Parameter<b>[4]</b>: Return length of parsed number
       Type<b>[4]</b>: size_t *

       Parameter<b>[5]</b>: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
       Type<b>[5]</b>: unsigned int *

       <b>Explanation:</b>

         This  function  works  like  ustr_parse_ulongx()  with  the  minimum  and maximum values taken as 0 and
       USHRT_MAX, and the thousands separator as "_".

     <b>Function:</b>  ustr_parse_short()
       Returns: Parsed number, or zero on error
       Type: short

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Base (2-36) and flags, starting with USTR_FLAG_PARSE_NUM_
       Type<b>[3]</b>: unsigned int

       Parameter<b>[4]</b>: Return length of parsed number
       Type<b>[4]</b>: size_t *

       Parameter<b>[5]</b>: Return error code, starting with USTR_TYPE_PARSE_NUM_ERR_
       Type<b>[5]</b>: unsigned int *

       <b>Explanation:</b>

         This function works like ustr_parse_ulongx() with the minimum and maximum values taken as -SHRT_MIN and
       SHRT_MAX, and the thousands separator as "_".

</pre><h4><b>Misc</b> <b>shortcut</b> <b>helper</b> <b>functions</b> <b>for</b> <b>Ustrs</b></h4><pre>
     <b>Function:</b>  ustr_sc_ensure_owner()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       <b>Explanation:</b>

         This function makes sure that the Ustr string is  owned  when  it  returns  (Ie.  ustr_owner()  returns
       USTR_TRUE), or it fails to allocate.

     <b>Function:</b>  ustr_sc_wstr()
       Returns: Writable pointer to the start of data in the Ustr, or NULL
       Type: char *

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       <b>Explanation:</b>

         This  function works like calling ustr_sc_ensure_owner(), to make sure the Ustr string is writable, and
       if that succeeds it returns ustr_wstr(). On failure it returns NULL.

     <b>Function:</b>  ustr_sc_export_subustr()
       Returns: A pointer to newly allocated block of memory
       Type: char *

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Position in the Ustr
       Type<b>[2]</b>: size_t

       Parameter<b>[3]</b>: Length to export from the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Allocation function (like malloc)
       Type<b>[4]</b>: void *(*)(size_t)

       <b>Explanation:</b>

         This function allocates a block of memory of  size  Length  (Parameter[3])  +  1   using  the  provided
       allocation  function  (Parameter[4]) and copies the data starting from Position (Parameter[2]) within the
       ustr.

     <b>Function:</b>  ustr_sc_export()
       Returns: A pointer to newly allocated block of memory
       Type: char *

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Allocation function (like malloc)
       Type<b>[2]</b>: void *(*)(size_t)

       <b>Explanation:</b>

         This function works like calling ustr_sc_export_subustr()  with  a  position  of  1  and  a  length  of
       ustr_len().

     <b>Function:</b>  ustrp_sc_export_subustrp()
       Returns: A pointer to newly allocated block of memory
       Type: char *

       Parameter<b>[1]</b>: Pointer to a Ustr pool object
       Type<b>[1]</b>: struct Ustr_pool *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Position in the Ustr
       Type<b>[3]</b>: size_t

       Parameter<b>[4]</b>: Length to export from the Ustr
       Type<b>[4]</b>: size_t

       Parameter<b>[5]</b>: Allocation function (like malloc), or NULL
       Type<b>[5]</b>: void *(*)(size_t)

       <b>Explanation:</b>

         This  function allocates a block of memory of size Length (Parameter[4]) + 1  using either the provided
       allocation function (Parameter[5]), or from the pool object if the allocation function is NUL, and copies
       the data starting from Position (Parameter[3]) within the ustr.

     <b>Function:</b>  ustrp_sc_export()
       Returns: A pointer to newly allocated block of memory
       Type: char *

       Parameter<b>[1]</b>: Pointer to a Ustr pool object
       Type<b>[1]</b>: struct Ustr_pool *

       Parameter<b>[2]</b>: A pointer to a constant Ustr string
       Type<b>[2]</b>: const struct Ustr *

       Parameter<b>[3]</b>: Allocation function (like malloc)
       Type<b>[3]</b>: void *(*)(size_t)

       <b>Explanation:</b>

         This function works like calling ustrp_sc_export_subustrp() with a  position  of  1  and  a  length  of
       ustrp_len().

     <b>Function:</b>  ustr_sc_reverse()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       <b>Explanation:</b>

         This  function  reverses  all  the  bytes in the Ustr string, so the last one becomes the first and the
       second to last becomes the second etc.

     <b>Function:</b>  ustr_sc_tolower()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       <b>Explanation:</b>

         This function changes any ASCII upper case bytes into ASCII lower case bytes.

     <b>Function:</b>  ustr_sc_toupper()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       <b>Explanation:</b>

         This function changes any ASCII lower case bytes into ASCII upper case bytes.

     <b>Function:</b>  ustr_sc_ltrim_chrs()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Array of bytes, containing trimming data
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: Length of byte data
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function deletes the bytes at the beginning of the  Ustr  (Parameter[1])  that  are  in  the  span
       (Parameter[2]) of the specificed length (parameter[2]).

     <b>Function:</b>  ustr_sc_ltrim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant Ustr string, containing trimming bytes
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  works  as  if you had called ustr_sc_ltrim_chrs() and passed ustr_cstr() and ustr_len()
       values of the Ustr string (Parameter[2]).

     <b>Function:</b>  ustr_sc_ltrim_cstr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant C-style string, containing trimming bytes
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works as if you had called ustr_sc_ltrim_chrs() and passed strlen() as the length.

     <b>Function:</b>  ustr_sc_rtrim_chrs()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Array of bytes, containing trimming data
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: Length of byte data
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function deletes the  bytes  at  the  end  of  the  Ustr  (Parameter[1])  that  are  in  the  span
       (Parameter[2]) of the specificed length (parameter[2]).

     <b>Function:</b>  ustr_sc_rtrim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant Ustr string, containing trimming bytes
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  works  as  if you had called ustr_sc_rtrim_chrs() and passed ustr_cstr() and ustr_len()
       values of the Ustr string (Parameter[2]).

     <b>Function:</b>  ustr_sc_rtrim_cstr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant C-style string, containing trimming bytes
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works as if you had called ustr_sc_rtrim_chrs() and passed strlen() as the length.

     <b>Function:</b>  ustr_sc_trim_chrs()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Array of bytes, containing trimming data
       Type<b>[2]</b>: const char *

       Parameter<b>[3]</b>: Length of byte data
       Type<b>[3]</b>: size_t

       <b>Explanation:</b>

         This function deletes the bytes at the beginning or end of the Ustr (Parameter[1]) that are in the span
       (Parameter[2]) of the specificed length (parameter[2]).

       <b>Note:</b>

         Calling  this  function  is  much  more  efficient   than   calling   ustr_sc_rtrim_chrs()   and   then
       ustr_sc_ltrim_chrs(), as both ends are trimmed in a single pass.

     <b>Function:</b>  ustr_sc_trim()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant Ustr string, containing trimming bytes
       Type<b>[2]</b>: const struct Ustr *

       <b>Explanation:</b>

         This  function  works  as  if  you had called ustr_sc_trim_chrs() and passed ustr_cstr() and ustr_len()
       values of the Ustr string (Parameter[2]).

     <b>Function:</b>  ustr_sc_trim_cstr()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: A pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: A pointer to a constant C-style string, containing trimming bytes
       Type<b>[2]</b>: const char *

       <b>Explanation:</b>

         This function works as if you had called ustr_sc_trim_chrs() and passed strlen() as the length.

</pre><h4><b>Adding</b> <b>binary</b> <b>data</b> <b>to</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_add_b_uint16()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Binary value to add to the Ustr
       Type<b>[2]</b>: uint_least16_t

       <b>Explanation:</b>

         This function adds a binary representation of a value (Parameter[2]) to the Ustr (Parameter[1]).

     <b>Function:</b>  ustr_add_b_uint32()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Binary value to add to the Ustr
       Type<b>[2]</b>: uint_least32_t

       <b>Explanation:</b>

         This function adds a binary representation of a value (Parameter[2]) to the Ustr (Parameter[1]).

     <b>Function:</b>  ustr_add_b_uint64()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Binary value to add to the Ustr
       Type<b>[2]</b>: uint_least64_t

       <b>Explanation:</b>

         This function adds a binary representation of a value (Parameter[2]) to the Ustr (Parameter[1]).

</pre><h4><b>Parsing</b> <b>binary</b> <b>data</b> <b>from</b> <b>a</b> <b>Ustr</b></h4><pre>
     <b>Function:</b>  ustr_parse_b_uint16()
       Returns: uint_least16_t
       Type: uint_least16_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       <b>Explanation:</b>

         This function parses a binary representation  from  a  Ustr  (Parameter[1])   starting  at  the  offset
       (Parameter[2]).

     <b>Function:</b>  ustr_parse_b_uint32()
       Returns: uint_least32_t
       Type: uint_least32_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       <b>Explanation:</b>

         This  function  parses  a  binary  representation  from  a  Ustr (Parameter[1])  starting at the offset
       (Parameter[2]).

     <b>Function:</b>  ustr_parse_b_uint64()
       Returns: uint_least64_t
       Type: uint_least64_t

       Parameter<b>[1]</b>: A pointer to a constant Ustr string
       Type<b>[1]</b>: const struct Ustr *

       Parameter<b>[2]</b>: Offset within string to start parsing at
       Type<b>[2]</b>: size_t

       <b>Explanation:</b>

         This function parses a binary representation  from  a  Ustr  (Parameter[1])   starting  at  the  offset
       (Parameter[2]).

</pre><h4><b>Misc.</b> <b>functions</b></h4><pre>
     <b>Function:</b>  ustr_realloc()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Pointer to a pointer to a Ustr string
       Type<b>[1]</b>: struct Ustr **

       Parameter<b>[2]</b>: Size of allocation
       Type<b>[2]</b>: size_t

       <b>Explanation:</b>

         This function is re-sizes the Ustr to the specified size (Parameter[2]).
         This is mostly used to shrink a sized Ustr that is now significantly smaller than it once was. Although
       this function can also grow a Ustr.

       <b>Note:</b>

         To  have a size that isn't implied from the length the Ustr must store a size value as well as a length
       (ustr_sized() must return USTR_TRUE).

     <b>Function:</b>  ustr_cntl_opt()
       Returns: Success or failure
       Type: int

       Parameter<b>[1]</b>: Optional value starting with USTR_CNTL_OPT_
       Type<b>[1]</b>: int

       Parameter<b>[2]</b>: Arguments to option
       Type<b>[2]</b>: ...

       <b>Explanation:</b>

         This function views and/or changes global Ustr  options,  like  whether  ustr's  have  an  implicit  or
       explicit size (USTR_CNTL_OPT_GET_HAS_SIZE).

</pre><h4><b>Simple</b> <b>Ustr</b> <b>pool</b> <b>API</b></h4><pre>
     <b>Function:</b>  ustr_pool_ll_make()
       Returns: Pointer to a Ustr pool object
       Type: struct Ustr_pool *

       Parameter<b>[1]</b>: Nothing
       Type<b>[1]</b>: void

       <b>Explanation:</b>

         This  allocates  a new pool using the "linked list" strategy, each allocation in the pool is added to a
       linked list ... and any allocations not freed directly are freed by the pool when it is cleared or freed.

     <b>Function:</b>  ustr_pool_make_subpool()
       Returns: Pointer to a Ustr pool object
       Type: struct Ustr_pool *

       Parameter<b>[1]</b>: struct Ustr_pool *
       Type<b>[1]</b>: struct Ustr_pool *

       <b>Explanation:</b>

         This allocates a new pool as a child of the passed in pool (Parameter[1]), The pool can  be  freed  and
       cleared  independently  of  the  parent  pool  however  free  and clear operations on the parent pool are
       automatically applied to all child pools.

     <b>Function:</b>  ustr_pool_free()
       Returns: Nothing
       Type: void

       Parameter<b>[1]</b>: Pointer to a Ustr pool object
       Type<b>[1]</b>: struct Ustr_pool *

       <b>Explanation:</b>

         This deallocates a pool, and all sub-pools.

       <b>Note:</b>

         This also operates on all sub-pools.

     <b>Function:</b>  ustr_pool_clear()
       Returns: Nothing
       Type: void

       Parameter<b>[1]</b>: Pointer to a Ustr pool object
       Type<b>[1]</b>: struct Ustr_pool *

       <b>Explanation:</b>

         This allows all the data in the pool to be reused, it may also free some/all of the data in  the  pool,
       from the pool API.

       <b>Note:</b>

         This also operates on all sub-pools.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/ustr_const.3.html">ustr_const</a></b>(3)

Ustr 1.0.4                                         05-Mar-2008                                           <u><a href="../man3/ustr.3.html">ustr</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>