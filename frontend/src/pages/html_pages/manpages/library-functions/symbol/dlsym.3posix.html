<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       dlsym — get the address of a symbol from a symbol table handle

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/dlfcn.h">dlfcn.h</a>&gt;

       void *dlsym(void *restrict <u>handle</u>, const char *restrict <u>name</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>dlsym</u>()  function  shall  obtain  the  address  of  a symbol (a function identifier or a data object
       identifier) defined in the symbol table identified by the <u>handle</u>  argument.  The  <u>handle</u>  argument  is  a
       symbol  table handle returned from a call to <u>dlopen</u>() (and which has not since been released by a call to
       <u>dlclose</u>()), and <u>name</u> is the symbol's name as a character string. The return value from <u>dlsym</u>(), cast to a
       pointer to the type of the named symbol, can be used to call (in the case of a function)  or  access  the
       contents of (in the case of a data object) the named symbol.

       The  <u>dlsym</u>() function shall search for the named symbol in the symbol table referenced by <u>handle</u>.  If the
       symbol table was created with lazy loading (see RTLD_LAZY in <u>dlopen</u>()), load ordering shall  be  used  in
       <u>dlsym</u>()  operations  to  relocate  executable  object  files  needed  to  resolve  the symbol. The symbol
       resolution algorithm used shall be dependency order as described in <u>dlopen</u>().

       The RTLD_DEFAULT and RTLD_NEXT symbolic constants (which may be defined in <u>&lt;dlfcn.h&gt;</u>)  are  reserved  for
       future use as special values that applications may be allowed to use for <u>handle</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon  successful completion, if <u>name</u> names a function identifier, <u>dlsym</u>() shall return the address of the
       function converted from type pointer to function to type pointer to <b>void</b>; otherwise, <u>dlsym</u>() shall return
       the address of the data object associated with the data object identifier named by <u>name</u> converted from  a
       pointer  to the type of the data object to a pointer to <b>void</b>.  If <u>handle</u> does not refer to a valid symbol
       table handle or if the symbol named by <u>name</u> cannot be found in the symbol table associated  with  <u>handle</u>,
       <u>dlsym</u>() shall return a null pointer.

       More detailed diagnostic information shall be available through <u>dlerror</u>().

</pre><h4><b>ERRORS</b></h4><pre>
       No errors are defined.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  example  shows how <u>dlopen</u>() and <u>dlsym</u>() can be used to access either a function or a data
       object. For simplicity, error checking has been omitted.

           void *handle;
           int (*fptr)(int), *iptr, result;
           /* open the needed symbol table */
           handle = dlopen("/usr/home/me/libfoo.so", RTLD_LOCAL | RTLD_LAZY);
           /* find the address of the function my_function */
           fptr = (int (*)(int))dlsym(handle, "my_function");
           /* find the address of the data object my_object */
           iptr = (int *)dlsym(handle, "my_OBJ");
           /* invoke my_function, passing the value of my_OBJ as the parameter */
           result = (*fptr)(*iptr);

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       The following special purpose values for <u>handle</u> are reserved  for  future  use  and  have  the  indicated
       meanings:

       RTLD_DEFAULT
                   The identifier lookup happens in the normal global scope; that is, a search for an identifier
                   using <u>handle</u> would find the same definition as a direct use of this identifier in the program
                   code.

       RTLD_NEXT   Specifies  the next executable object file after this one that defines <u>name</u>.  This one refers
                   to the executable object file containing the invocation  of  <u>dlsym</u>().   The  next  executable
                   object file is the one found upon the application of a load order symbol resolution algorithm
                   (see  <u>dlopen</u>()).  The next symbol is either one of global scope (because it was introduced as
                   part of the original process image  or  because  it  was  added  with  a  <u>dlopen</u>()  operation
                   including  the RTLD_GLOBAL flag), or is in an executable object file that was included in the
                   same <u>dlopen</u>() operation that loaded this one.

       The RTLD_NEXT flag is useful to navigate an intentionally created hierarchy of  multiply-defined  symbols
       created  through  interposition. For example, if a program wished to create an implementation of <u>malloc</u>()
       that embedded some statistics gathering about memory allocations, such an implementation  could  use  the
       real  <u>malloc</u>() definition to perform the memory allocation — and itself only embed the necessary logic to
       implement the statistics gathering function.

       Note that conversion from a <b>void</b> <b>*</b> pointer to a function pointer as in:

           fptr = (int (*)(int))dlsym(handle, "my_function");

       is not defined by the ISO C standard. This  standard  requires  this  conversion  to  work  correctly  on
       conforming implementations.

</pre><h4><b>RATIONALE</b></h4><pre>
       None.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>dlclose</u>(), <u>dlerror</u>(), <u>dlopen</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;dlfcn.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                         <u><a href="../man3POSIX/DLSYM.3POSIX.html">DLSYM</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>