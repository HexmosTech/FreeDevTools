<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::Filesystem - class offering std::filesystem facilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::Filesystem - class offering std::filesystem facilities

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/filesystem&gt;</b>
       Linking option: <u>-lbobcat</u>

       This header file also includes the <u>std::chrono</u> header file.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  Bobcat  class <b>FileSystem</b> is a plain wrapper around the facilities offered by the <b>C++</b> <u>std::filesystem</u>
       namespace. <b>FileSystem</b> was developed because the use  of  the  <u>std::filesystem</u>  facilities  is  considered
       overly  complex:  too many free functions having signatures resembling <b>C</b>, and therefore not object-based.
       Its <u>std::filesystem::path</u> type offers several nice features which are then usable  via  the  <u>path</u>  member
       functions,  but  functions manipulating the file system aren’t members, but are defined as free functions
       requiring <u>path</u> arguments.

       The class <b>FileSystem</b> offers almost all <u>std::filesystem</u> facilities via its member  functions.  Except  for
       some (static) members all facilities operate on data stored inside <b>FileSystem</b> objects.

       The  class  <b>FileSystem</b>  is  an extensive class: over-all it contains about 60 constructors, operators and
       members. It’ll probably take a while before a mental picture of what the class offers has been  attained,
       but at least it embeds all components of the <u>std::filesystem</u> namespace.

       Note:

       o      The  class  <b>FileSystem</b> uses <u>std::chrono::file_clock</u>, which is available since the <u>C++-2a</u> standard:
              specify the <u>--std=c++2a</u> (or more recent) compiler option when using <b>FileSystem</b>.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All constructors, members, operators and manipulators, mentioned in this man-page,  are  defined  in  the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       <u>FBB::FS</u> - internally used only, covered in this man-page

</pre><h4><b>TYPEDEFS</b> <b>AND</b> <b>ENUMS</b></h4><pre>
       <b>Typedefs:</b>

       o      <b>DirEntry</b> - <u>std::filesystem::directory_entry</u>

       o      <b>DirIter</b> - <u>std::filesystem::directory_iterator</u>

       o      <b>EC</b> - <u>std::error_code</u>

       o      <b>FileClock</b> - <u>std::chrono::file_clock</u>

       o      <b>FileType</b> - <u>std::filesystem::file_type</u>

       o      <b>Path</b> - <u>std::filesystem::path</u>

       o      <b>Perms</b> - <u>std::filesystem::perms</u>

       o      <b>RecursiveIter</b> - <u>std::filesystem::recursive_directory_iterator</u>

       o      <b>FileStatus</b> - <u>std::filesystem::file_status</u>

       o      <b>SystemClock</b> - <u>std::chrono::system_clock</u>

       <b>FSOptions:</b>

       o      <b>enum</b> <b>FSOptions</b>:
              contains  the  following values, inherited by <u>FileSystem</u>. Options up to <u>CP_MASK</u> are primarily used
              by the <u>copy</u> member, options beyond <u>CP_MASK</u> are used by <u>setPermissions</u>:

                  NEW             copy is only performed if the destination
                                  doesn’t yet exist
                  REPLACE         copy is only performed if the destination
                                  exists but it is replaced
                  UPDATE          copy is only performed if the destination
                                  is older than the filesystem entry to copy
                  RECURSIVE       directories are recursively copied; can be
                                  combined with CP_SYMLINKS, SKIP_SYMLINKS,
                                  ONLY_DIRS
                  CP_SYMLINKS     symlinks are copied as symlinks
                  SKIP_SYMLINKS   symlinks are ignored
                  ONLY_DIRS       only the directory structure is copied
                                  other entries in directories are ignored
                  SYMLINK         with copy: define a symlink to the current
                                  entry
                  HARDLINK        with copy: define a hard link to the current
                                  entry
                  FILE            with copy: only files are processed, not
                                  directories
                  CP_SYMLINK      copies a symlink to a symlink
                  NEW_SYMLINK     defines a non-existing (directory) symlink
                  NEW_LINK        create_hard-link
                  CP_MASK         all the above enum values

                  RESET           replace the current permissions
                  ADD             add to the current permissions
                  REMOVE          remove the specified permissions

       All bit-wise operators are available for <b>FSOptions</b> values.

</pre><h4><b>STATIC</b> <b>DATA</b> <b>MEMBER</b></h4><pre>
       The class <u>FileSystem</u> defines one static data member: <u>std::error_code</u> <u>s_errorCode</u>. All <u>FileSystem</u>  objects
       can use this <u>error_code</u> object after calling their function call operator. E.g.,

           FileSystem fs;
           fs();

       Once  <u>fs()</u>  has  been  called members called by <u>fs</u> accepting <u>error_code</u> arguments receive <u>s_error_code</u> as
       their argument. It’s also possible to use other <u>error_code</u> objects, or not to  use  <u>error_code</u>  arguments
       (which is the default). See also the description of the function call operator below.

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       <u>Path</u>  arguments  can  also  be  arguments  of  types  from  which  <u>Path</u> objects can be constructed (e.g.,
       <u>std::string,</u> <u>char</u> <u>const</u> <u>*</u>, raw string literal).

       <u>FileSystem</u> objects contain two data members: a <u>Path</u> and an <u>EC</u> <u>*</u>. When <u>FileSystem</u> objects are  initialized
       their <u>EC</u> <u>*</u> is set to 0.

       o      <b>Filesystem()</b>:
              The  default  constructor  constructs  an  empty  object, not using the class’s static <u>s_errorCode</u>
              object;

       o      <b>Filesystem(Path</b> <b>const</b> <b>&amp;path,</b> <b>bool</b> <b>useEC</b> <b>=</b> <b>true)</b>:
              The object is initialized with a copy of <u>path</u>. By default <u>useEC</u> <u>==</u> <u>true</u>, in which case it uses the
              class’s static <u>s_errorCode</u> object;

       o      <b>Filesystem(Path</b> <b>&amp;&amp;path,</b> <b>EC</b> <b>&amp;ec)</b>:
              The object is initialized with a copy of <u>path</u>, passing <u>ec</u> to members supporting <u>EC</u> arguments;

       o      <b>Filesystem(Path</b> <b>const</b> <b>&amp;tmp,</b> <b>bool</b> <b>useEC</b> <b>=</b> <b>true)</b>:
              The object moves <u>tmp</u> to its internal <u>path</u>. By default <u>useEC</u> <u>==</u> <u>true</u>, in which  case  it  uses  the
              class’s static <u>s_errorCode</u> object;

       o      <b>Filesystem(Path</b> <b>&amp;&amp;tmp,</b> <b>EC</b> <b>&amp;ec)</b>:
              The object moves <u>tmp</u> to its internal <u>path</u>, passing <u>ec</u> to members supporting <u>EC</u> arguments.

       Copy  and  move constructors (and assignment operators) are available.  The newly constructed or assigned
       object use the same <u>EC</u> specification as their source (right-hand side) objects.

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
       <u>Type</u> arguments can be arguments of type <u>FileSystem,</u>  <u>Path</u>  or  types  from  which  <u>Path</u>  objects  can  be
       constructed (e.g., <u>std::string,</u> <u>char</u> <u>const</u> <u>*</u>, raw string literal).

       o      <b>std::istream</b> <b>&amp;operator&gt;&gt;(std::istream</b> <b>&amp;in,</b> <b>FileSystem</b> <b>&amp;rhs)</b>:
              extracts a <u>path</u> specification from <u>in</u>, and initializes <u>rhs</u> with the extracted path;

       o      <b>std::ostream</b> <b>&amp;operator&lt;&lt;(std::ostream</b> <b>&amp;out,</b> <b>FileSystem</b> <b>const</b> <b>&amp;rhs)</b>:
              inserts the object’s <u>path</u> into <u>out</u>;

       o      <b>bool</b> <b>operator==(FileSystem</b> <b>const</b> <b>&amp;lhs,</b> <b>FileSystem</b> <b>const</b> <b>&amp;rhs)</b>:
              returns  <u>true</u>  if  <u>lhs</u>  and  <u>rhs</u> refer to the same file system entry. An exception is thrown if at
              least one argument doesn’t refer to an existing file system  entry  and  the  <u>lhs</u>  operand  hasn’t
              specified  an  <u>EC</u>  (see  <u>operator()()</u>  below).  This  operator calls the member <u>sameAs</u> for its <u>lhs</u>
              argument;

       o      <b>FileSystem</b> <b>&amp;operator/=(Type</b> <b>const</b> <b>&amp;arg)</b>:
              <u>arg</u> is appended to the object’s <u>path</u> data member. If the <u>path</u> data member did not already  end  in
              <u>’/’</u> then <u>/arg</u> is appended;

       o      <b>FileSystem</b> <b>&amp;operator+=(Type</b> <b>const</b> <b>&amp;arg)</b>:
              <u>arg</u> is appended to the object’s <u>path</u> data member;

       o      <b>FileSystem</b> <b>[const]</b> <b>&amp;operator()(EC</b> <b>&amp;ec</b> <b>=</b> <b>s_errorCode)</b> <b>[const]</b>:
              this  operator  activates  passing  <u>EC</u>  arguments  to member function accepting such arguments. By
              calling  this  operator  without  argument  member  functions  receive  <u>FileSystem’s</u>  <u>s_errorCode</u>.
              Alternatively  another (e.g., local) <u>error_code</u> object can be specified  which will then be passed
              to members accepting <u>error_code</u> arguments. Example:

                  std::error_code ec;
                  FileSystem fs;
                  fs(ec);

              Using <u>EC</u> arguments is configured separately for each <u>FileSystem</u> object. The  member  <u>noEC</u>  can  be
              used to suppress passing  <u>EC</u> arguments to <u>std::filesystem</u> functions;

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       <u>Type</u>  arguments  can  be  arguments  of  type  <u>FileSystem,</u>  <u>Path</u>  or types from which <u>Path</u> objects can be
       constructed (e.g., <u>std::string,</u> <u>char</u> <u>const</u> <u>*</u>, raw string literal).

       All members can use <u>EC</u> objects to prevent exceptions being thrown when the members cannot  perform  their
       tasks.

       o      <b>FileSystem</b> <b>absolute()</b> <b>const</b>:
              returns  a <u>FileSystem</u> object containing the absolute path of the calling object’s <u>Path</u>, which does
              not have to exist. Relative directory  specifications  are  kept:  <u>absolute</u>  simply  prefixes  the
              current working directory to the calling object’s <u>Path</u>;

       o      <b>FileSystem</b> <b>canonical()</b> <b>const</b>:
              returns  a  <u>FileSystem</u> object containing the canonical absolute path of the calling object’s <u>Path</u>,
              from which all relative specifications have been removed. <u>Path</u> must  refer  to  an  existing  file
              system entry;

       o      <b>bool</b> <b>copy(Type</b> <b>const</b> <b>&amp;dest,</b> <b>FSOptions</b> <b>cpOptions</b> <b>=</b> <b>DEFAULT)</b>:
              copies the object’s file system entry to <u>dest</u>. It is covered in detail in the section <b>COPYING</b> <b>FILE</b>
              <b>SYSTEM</b> <b>ENTRIES</b> below;

       o      <b>uintmax_t</b> <b>count()</b> <b>const</b>:
              returns  the  number  of  hard-link counts of the calling <u>FileSystem</u> object. The file system entry
              must exist;

       o      <b>char</b> <b>const</b> <b>*c_str()</b> <b>const</b>:
              returns the calling object’s <u>PATH</u> specification as a NTBS;

       o      <b>static</b> <b>FileSystem</b> <b>cwd([EC</b> <b>&amp;ec])</b>:
              this static member returns the current working directory (cwd). If the cwd  cannot  be  determined
              then  an  exception  is  thrown, unless an <u>EC</u> argument is specified, in which case the <u>EC</u> argument
              provides information about the failure;

       o      <b>FileSystem</b> <b>destination()</b> <b>const</b>:
              returns a <u>FileSystem</u> object containing the (symlink) destination of the calling object, which must
              refer to a symlink;

       o      <b>DirEntry</b> <b>directory()</b> <b>const</b>:
              returns a <u>DirEntry</u> for the calling object. The  calling  object  does  not  have  to  refer  to  a
              directory, and not even to an existing file system entry;

       o      <b>Ranger&lt;DirIter&gt;</b> <b>dirRange()</b> <b>const</b>:
              returns  a  pair  of  directory  iterators non-recursively visiting all entries referred to by the
              calling object, which must specify a directory name (see also the member <u>recursiveRange</u>). Example:

                  for (auto const &amp;entry: fs.dirRange())
                      cout &lt;&lt; entry &lt;&lt; ’\n’;

       o      <b>static</b> <b>std::error_code</b> <b>&amp;errorCode()</b>:
              this static member returns a reference to <u>FileSystem’s</u> static (modifiable) <u>EC</u> data member.

       o      <b>bool</b> <b>exists()</b> <b>const</b>:
              returns <u>true</u> if the current object’s file system entry exists;

       o      <b>static</b> <b>bool</b> <b>exists(FileStatus</b> <b>status)</b>:
              returns <u>true</u> if <u>status</u> indicates that the current file system entry exists (see  also  the  member
              <u>status</u> below);

       o      <b>std::string</b> <b>extension()</b> <b>const</b>:
              returns the extension (including the initial dot (.) of the calling object);

       o      <b>FileClock::time_point</b> <b>fcModification()</b> <b>const</b>:
              returns  the  <u>FileClock::time_point</u> of the (existing) file system entry represented by the calling
              object;

       o      <b>std::string</b> <b>filename()</b> <b>const</b>:
              returns the filename (i.e., the path name from which all but the last element has  been  removed).
              If  the  calling  object  doesn’t  contain  a  filename (as with <u>./</u> or <u>/</u>) then and empty <u>string</u> is
              returned;

       o      <b>bool</b> <b>hasExtension()</b> <b>const</b>:
              returns <u>true</u> if the calling object’s <u>Path</u> has an extension;

       o      <b>bool</b> <b>hasFilename()</b> <b>const</b>:
              returns <u>true</u> if the calling object’s <u>Path</u> contains characters after its final <u>/</u> character;

       o      <b>bool</b> <b>isAbsolute()</b> <b>const</b>:
              returns <u>true</u> if the calling object’s <u>Path</u> starts with <u>/</u>;

       o      <b>bool</b> <b>isRelative()</b> <b>const</b>:
              returns <u>true</u> if the calling object’s <u>Path</u> does not start with <u>/</u>;

       o      <b>bool</b> <b>knownStatus()</b> <b>const</b>:
              this member only returns <u>false</u> for <u>std::filesystem::file_status{}</u>. The member <u>status</u>  is  probably
              more useful: non-existing entries show status values <u>FileType::not_found</u> or <u>FileType::unknown</u>.
              To check for specific statuses the functions
              <u>bool</u> <u>is_WHATEVER(file_status</u> <u>status)</u> or
              <u>bool</u> <u>is_WHATEVER(path</u> <u>const</u> <u>&amp;entry</u> <u>[,</u> <u>EC</u> <u>&amp;ec])</u>
              can also be used;

       o      <b>bool</b> <b>mkDir()</b> <b>const</b>:
              returns  <u>true</u>  if  the  (plain) directory name stored in the calling oblect could be created. This
              member does not create nested sub-directories, but  the  directory  name  specified  as  the  last
              (<u>/</u>-separated)  component of the calling object’s <u>Path</u> is created if its parent directories already
              exist;

       o      <b>bool</b> <b>mkDir(Type</b> <b>const</b> <b>&amp;reference)</b> <b>const</b>:
              same as the previous member, but the created directory receives the same attributes  (permissions)
              as <u>reference</u>;

       o      <b>bool</b> <b>mkDirs()</b> <b>const</b>:
              returns  true  if the last component of the  calling object’s <u>Path</u> could be created and its parent
              components could either be created or already existed as directories.  Only  the  directories  are
              constructed,  not  their  entries.  Use  the  <u>copy</u> member (see section <u>COPYING</u> <u>FILE</u> <u>SYSTEM</u> <u>ENTRIES</u>
              below) to copy directories and their file system entries;

       o      <b>SystemClock::time_point</b> <b>modification()</b> <b>const</b>:
              returns the <u>SystemClock::time_point</u> of the (existing) file system entry represented by the calling
              object;

       o      <b>FileSystem</b> <b>[const]</b> <b>&amp;noEC()</b> <b>[const]</b>:
              if the calling object uses an <u>EC</u>, then the <u>EC</u> won’t be used anymore after calling this member;

       o      <b>FileSystem</b> <b>parent()</b> <b>const</b>:
              returns a <u>FileSystem</u> object initialized with the parent <u>Path</u> of the calling object. The <u>parent</u>  is
              equal  to  the  calling object’s <u>Path</u> from which its <u>filename</u> has been removed (returning an empty
              object if the calling object merely contains `<u>/</u>’);

       o      <b>Path</b> <b>const</b> <b>&amp;path()</b> <b>const</b>:
              returns the current object’s <u>Path</u> data member. When inserting  <u>path()</u>  into  an  <u>ostream</u>  <u>Path</u>  is
              surrounded by double quotes. If that’s not required call the <u>string</u> member;

       o      <b>Perms</b> <b>permissions()</b> <b>const</b>:
              returns  the permissions of the calling object, which must refer to an existing file system entry.
              The returned <u>Perms</u> value consists of bitwise  or-ed  values  of  the  <u>std::filesystem::perms</u>  <u>enum</u>
              <u>class</u>, but can be statically cast to <u>mode_t</u> values which are used as argument to <b><a href="../man2/chmod.2.html">chmod</a></b>(2);

       o      <b>Ranger&lt;[Const]Iter&gt;</b> <b>range()</b> <b>[const]</b>:
              returns a pair of iterators visiting all components of the calling object’s <u>Path</u>.Example:

                  for (auto const &amp;comp: fs.range())
                      cout &lt;&lt; comp &lt;&lt; ’\n’;

       o      <b>FileSystem</b> <b>relative()</b> <b>const</b>:
              returns a copy of the calling object from which an initial `<u>/</u>’ has been removed;

       o      <b>bool</b> <b>remove()</b> <b>const</b>:
              returns <u>true</u> if the current object’s file system entry has been removed;

       o      <b>size_t</b> <b>removeAll()</b> <b>const</b>:
              returns  the  number of (recursively) removed file system entries starting at the calling object’s
              <u>Path</u>. The calling object doesn’t have to specify a directory;

       o      <b>bool</b> <b>rename(Type</b> <b>const</b> <b>&amp;newName)</b> <b>const</b>:
              returns <u>true</u> if the current file system entry could be renamed to <u>newName</u>.  The  calling  object’s
              <u>Path</u> is not altered;

       o      <b>bool</b> <b>resize(std::uintmax_t</b> <b>size)</b> <b>const</b>:
              returns <u>true</u> if the current file system entry could be resized to <u>size</u>;

       o      <b>bool</b> <b>sameAs(Type</b> <b>const</b> <b>&amp;other)</b> <b>const</b>:
              returns  <u>true</u> if <u>other</u> refers to the same file system entry as the calling object. It is called by
              <u>operator==</u> as its <u>lhs</u> member;

       o      <b>FileSystem</b> <b>&amp;setCwd()</b>:
              changes the current process’s current working directory to the directory specified by the  calling
              object;

       o      <b>static</b> <b>FileSystem</b> <b>setCwd(Path</b> <b>const</b> <b>&amp;path</b> <b>[,</b> <b>EC</b> <b>&amp;ec])</b>:
              this  static  member  changes  the  current  process’s  current working directory to the directory
              specified by its <u>Path</u> argument;

       o      <b>FileSystem</b> <b>&amp;setExtension(std::string</b> <b>const</b> <b>&amp;ext)</b>:
              changes the filename extension of the current object to <u>ext</u>. A dot (<u>.</u>) is  used  to  separate  the
              current  object’s  <u>stem</u>  (see  below) and the extension. The resulting file name only has a single
              dot;

       o      <b>FileSystem</b> <b>&amp;setFilename(std::string</b> <b>const</b> <b>&amp;newName)</b>:
              changes the current object’s file name (including its extension) to <u>newName</u>. If the current object
              refers to an existing file system entry then that file system entry is kept as-is;

       o      <b>bool</b> <b>setModification(FBB::DateTime</b> <b>const</b> <b>&amp;time)</b>:
              changes the modification time of the current file system entry to the <u>time</u> time-specification;

       o      <b>bool</b> <b>setModification(SystemClock::time_point</b> <b>const</b> <b>&amp;time)</b>:
              changes the modification time of the current file system entry to the <u>time</u> time-specification;

       o      <b>FileSystem</b> <b>[const]</b> <b>&amp;setPermissions(PermType</b> <b>perms,</b> <b>FSOptions</b> <b>opt</b> <b>=</b> <b>RESET)</b> <b>[const]</b>:
              changes the permissions of the current file system  entry  to  <u>perms</u>,  which  must  be  statically
              castable to <u>Perms</u>. Example:

                          // change "entry’s" permissions to -rw-------
                  FileSystem{ "entry" }.<a href="../man0600/setPermissions.0600.html">setPermissions</a>(0600);

       o      <b>bool</b> <b>setType(FileType</b> <b>type,</b> <b>bool</b> <b>destination</b> <b>=</b> <b>true)</b>:
              it’s  unclear  what  this  function  is  used  for.  It  calls <u>filesystem::(symlink_)status</u>, using
              <u>symlink_status</u> when called as <u>type(false)</u>. It returns <u>false</u> if <u>type</u> doesn’t match the current file
              system entry referred, but the type itself isn’t modified;

       o      <b>uintmax_t</b> <b>size()</b> <b>const</b>:
              returns the size in bytes of the current file system entry;

       o      <b>FileStatus</b> <b>status(bool</b> <b>destination</b> <b>=</b> <b>true)</b> <b>const</b>:
              returns the <u>filesystem::status</u> of the current file system  entry.  If  the  current  object  is  a
              symlink and the symlink’s status is requested then call <u>status(false)</u>;

       o      <b>FileSystem</b> <b>stem()</b> <b>const</b>:
              returns the file name of the current object without its extension;

       o      <b>std::string</b> <b>string()</b> <b>const</b>:
              returns the current object’s <u>Path</u> data member as a <u>std::string</u>;

       o      <b>static</b> <b>FileSystem</b> <b>tmpDir(Type</b> <b>arg</b> <b>[=</b> <b>true])</b>:
              this  static  member  returns  the  file system’s directory which is by default used for temporary
              files. By default <u>tmpDir</u> uses <u>FileSystem::s_errorCode</u> objct,  when  calling  <u>tmpDir(false)</u>  no  <u>EC</u>
              object is used;

       o      <b>static</b> <b>FileSystem</b> <b>tmpDir(EC</b> <b>&amp;ec)</b>:
              this  static  member  returns  the  file  system’s  directory   using the specified <u>EC</u> object when
              determining the temporay directory;

       o      <b>FileType</b> <b>type(bool</b> <b>destination</b> <b>=</b> <b>true)</b> <b>const</b>:
              returns the <u>FileType</u> of the current file system entry. If the current object refers to  a  symlink
              call <u>type(false)</u> to receive the symlink’s type.

</pre><h4><b>COPYING</b> <b>FILE</b> <b>SYSTEM</b> <b>ENTRIES</b></h4><pre>
       The  member  <u>copy(Type</u> <u>const</u> <u>&amp;dest,</u> <u>FSOptions</u> <u>cpOptions</u> <u>=</u> <u>DEFAULT)’s</u> first argument specifies the name of
       the copied file or directory. It’s second argument specifies the type of the copy-operation. Options  can
       be combined using binary operators (usually <u>bit_or</u>). The following combinations are valid:

       o      <u>FILE</u> - unconditionally copies the current entry to <u>dest</u>;

       o      <u>FILE</u> <u>|</u> <u>NEW</u> - the current entry is copied to <u>dest</u> if <u>dest</u> does not yet exist;

       o      <u>FILE</u> <u>|</u> <u>REPLACE</u> - the current entry is copied to <u>dest</u> if <u>dest</u> already exists;

       o      <u>FILE</u> <u>|</u> <u>UPDATE</u> - the current entry is only copied to <u>dest</u> if it is younger than <u>dest</u>;

       o      <u>CP_SYMLINK</u>  - the current entry must be a symlink, <u>dest</u> may not yet exist and becomes a symlink to
              the same destination as the current entry’s destination;

       o      <u>NEW_LINK</u> - <u>dest</u> may not yet exist. It becomes a hard-link to the current entry. The current object
              must exist;

       o      <u>NEW_SYMLINK</u> - <u>dest</u> may not yet exist. It becomes a symlink to the current entry.  If  the  current
              entry  is  itself a symlink then <u>dest</u> becomes a symlink to the current entry, and not to the entry
              the current object refers to. The current object does not have  to  be  an  existing  file  system
              entry;

       o      <u>RECURSIVE</u>  -  the  current  entry  is  recursively  copied  to  <u>dest</u>. If the current entry isn’t a
              directory then the entry itself is copied as if <u>RECURSIVE</u> was not specified;

       o      <u>RECURSIVE</u> <u>|</u> <u>CP_SYMLINKS</u> - like using <u>RECURSIVE</u> but existing symlinks are copied as symlinks;

       o      <u>RECURSIVE</u> <u>|</u> <u>ONLY_DIRS</u> - like using <u>RECURSIVE</u> but only the directory structure is copied;

       o      <u>RECURSIVE</u> <u>|</u> <u>SKIP_SYMLINKS</u> - like using <u>RECURSIVE</u> but existing symlinks are not copied;

</pre><h4><b>EXAMPLE</b></h4><pre>
       #include &lt;iostream&gt;
       #include &lt;string&gt;
       #include &lt;exception&gt;

       #include &lt;bobcat/filesystem&gt;

       using namespace std;
       using namespace FBB;

       int main(int argc, char **argv)
       {
           if (argc == 1)
           {
               cout &lt;&lt; "1st arg: an existing file\n"
                       "2nd arg (optional): a directory owned by the caller\n";
               return 1;
           }

           FileSystem fs{ argv[1] };
           if (not fs.exists())
               cout &lt;&lt; "No such file " &lt;&lt; argv[1] &lt;&lt; ’\n’;
           else
               cout &lt;&lt; "last modification date of " &lt;&lt; argv[1] &lt;&lt; ": " &lt;&lt;
                                                   fs.modification() &lt;&lt; ’\n’;

           cout &lt;&lt; oct &lt;&lt; "Permissions: 0" &lt;&lt;
                           static_cast&lt;size_t&gt;(fs.permissions()) &lt;&lt; dec &lt;&lt; ’\n’;

           if (argc &gt; 2)
           {
               cout &lt;&lt; "Entries of " &lt;&lt; argv[2] &lt;&lt; ":\n";
               FileSystem fs2{ argv[2] };
               for (auto const &amp;entry: fs2.dirRange())
                   cout &lt;&lt; "   " &lt;&lt; entry &lt;&lt; ’\n’;
               cout &lt;&lt; fs2.errorCode().message() &lt;&lt; ’\n’;
           }
       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/filesystem</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7), <b><a href="../man2/chmod.2.html">chmod</a></b>(2), <b><a href="../man3bobcat/datetime.3bobcat.html">datetime</a></b>(3bobcat), <b><a href="../man3bobcat/ranger.3bobcat.html">ranger</a></b>(3bobcat)

</pre><h4><b>BUGS</b></h4><pre>
       None Reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>: debian package containing the static library, headers, manual pages, and  developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                           <u>FBB::<a href="../man3bobcat/FileSystem.3bobcat.html">FileSystem</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>