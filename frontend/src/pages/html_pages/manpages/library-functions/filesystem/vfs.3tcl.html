<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>::vfs - Commands and Procedures to create virtual filesystems</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl-vfs">tcl-vfs_1.4.2~20230906-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ::vfs - Commands and Procedures to create virtual filesystems

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>package</b> <b>require</b> <b>Tcl</b>

       <b>package</b> <b>require</b> <b>vfs</b> <b>?1.4?</b>

       <b>vfs::filesystem</b> <u>info</u>

       <b>vfs::filesystem</b> <u>mount</u>

       <b>vfs::filesystem</b> <u>unmount</u>

       <b>vfs::accessMode</b> <u>mode</u>

       <b>vfs::matchDirectories</b> <u>types</u>

       <b>vfs::matchFiles</b> <u>types</u>

       <b>vfs::matchCorrectTypes</b> <u>types</u> <u>filelist</u> <u>?inDir?</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>::vfs</b> package provides commands to query, mount and unmount virtual filesystems, and provides as Tcl
       libraries some facilities for helping the writing of new virtual filesystems  in  Tcl.   Once  a  virtual
       filesystem  is  in place, the standard Tcl <b>file</b>, <b>glob</b>, <b>cd</b>, <b>pwd</b>, <b>open</b> commands, including all their C APIs
       in the Tcl library (e.g. <b>Tcl_FSOpenFileChannel</b>,  <b>Tcl_FSMatchInDirectory</b>,...),  can  be  used  within  the
       filesystem  (and  indeed,  properly  written extensions such as Tk which may open or read files will also
       transparently access the virtual filesystem).  Because all of Tcl's FS activity passes through  a  single
       layer,  it  can all be intercepted.  This package does just that.  Notice that this is quite different to
       overloading the <b>file</b> command in Tcl.  We are actually providing vfs  replacements  for  C  commands  like
       <b>access</b>,  <b>stat</b>.  By implementing just a handful of commands at this low level, we ensure that all commands
       at higher levels function irrespective of what is going on inside the FS layer.

       Tcl's filesystem hooks operate on a per-process basis.  This means every  Tcl  interpreter  in  the  same
       process/application sees the same filesystem, including any virtual filesystems.

       The  <b>package</b>  <b>require</b>  <b>vfs</b> command should be used to access this library.  It automatically registers the
       vfs hooks into Tcl's filesystem, and these will not be removed until Tcl exits (if desired, control  over
       this  could  be  exposed to Tcl in the future).  However, the vfs package will at that stage not have any
       new filesystems mounted, so it will have little effect.  Note that <b>package</b> <b>require</b> <b>vfs</b> has  two  effects.
       First  of all, when it is issued in <b>any</b> Tcl interpreter it will ensure the vfs hooks have been registered
       with Tcl's core just once (and if any of those interpreters are later deleted, the vfs hooks  will  still
       remain  registered  -  they  remain  until  Tcl  exits).   The  second  effect  is to provide the command
       <b>vfs::filesystem</b> which allows the interpreter to intercept filesystem commands and handle  them  with  Tcl
       code in that interpreter.

       There are three somewhat unsupported subcommands of <b>vfs::filesystem</b>, <b>fullynormalize</b> <b>path</b>, <b>posixerror</b> <b>int</b>,
       <b>internalerror</b>  <b>?script?</b>,  which are used to normalize a path (including any final symlink), to register a
       posix error code with a  Tcl  error,  and  to  trap/report  internal  errors  in  tclvfs  implementations
       respectively.

       <b>vfs::filesystem</b> <u>mount</u> <u>?-volume?</u> <u>path</u> <u>command</u>
              To use a virtual filesystem, it must be 'mounted'.  Mounting involves declaring to the vfs package
              that  any  subdirectories of a given <u>path</u> in the filesystem should be handled by the given <u>command</u>
              which should be a Tcl command or procedure in the interpreter  in  which  the  <b>vfs::filesystem</b>  is
              executed.  If the <u>?-volume?</u>  flag is given, the given mount point is also registered with Tcl as a
              new volume (like a new drive which will appear in <u>file</u> <u>volumes</u>).  This is useful (and required for
              reasonable  operation) for mounts like <u>ftp://</u>.  For paths mounted inside the native filesystem, it
              should of course not be given.  The new filesystem mounts will  be  observed  immediately  in  all
              interpreters  in  the  current process.  If the interpreter is later deleted, all mounts which are
              intercepted by it will be automatically removed  (and  will  therefore  affect  the  view  of  the
              filesystem seen by all interpreters).

       <b>vfs::filesystem</b> <u>unmount</u> <u>path</u>
              This  unmounts  the  virtual  filesystem  which  was mounted at <u>path</u> (hence removing it from Tcl's
              filesystem), or throws an error if no filesystem was mounted there.

       <b>vfs::filesystem</b> <u>info</u> <u>?path?</u>
              If no arguments are given, this returns a list of all filesystems mounted (in  all  interpreters).
              If a path argument is given, then the <u>command</u> to be used for that path is returned, or an error is
              thrown  if no vfs is mounted for that path.  There is currently no facility for examining in which
              interpreter each command will be evaluated.

       <b>vfs::filesystem</b> <u>fullynormalize</u> <u>path</u>
              Performs a full expansion of <u>path</u>, (as per 'file normalize'), but including following any links in
              the last element of path.

</pre><h4><b>IMPLEMENTING</b> <b>A</b> <b>TCL</b> <b>ONLY</b> <b>VFS</b></h4><pre>
       The vfs package will intercept every filesystem operation which falls within a  given  mount  point,  and
       pass  the  operation  on  to the mount point's <u>command</u> in the interpreter which registered it. In general
       this occurs by the C equivalent of an evaluation like this: <u>eval</u> <u>$command</u> <u>[list</u> <u>$subcmd</u>  <u>$root</u>  <u>$relative</u>
       <u>$actualpath]</u> <u>$args</u>.

       Here   <u>subcmd</u>  may  be  any  of  the  following:  <u>access</u>,  <u>createdirectory</u>,  <u>deletefile</u>,  <u>fileattributes</u>,
       <u>matchindirectory</u>, <u>open</u>, <u>removedirectory</u>, <u>stat</u>, <u>utime</u>. If <u>command</u> takes appropriate  action  for  each  of
       these  cases,  a complete, perfect virtual filesystem will be achieved, indistinguishable to Tcl from the
       native filesystem.  (CAVEATS: right now I don't  expose  to  Tcl  all  the  permission-related  flags  of
       'glob').

       The  remaining  arguments specify a file path on which to operate (all commands operate on one of these),
       and any additional arguments which may be required to carry out the action.  The file path  is  specified
       by  three  arguments:  <u>root</u>  is  the  part  of the path which lies outside this filesystem's mount point,
       <u>relative</u> is the part of the path which lies  inside  this  filesytem,  and  <u>actualpath</u>  is  the  original
       (unnormalized)  name  of the path which was used in the current command wherever it originated (in Tcl or
       C).  For example, if <u>C:/foo/bar/mount.zip/xxx/yyy</u> is a path in your filesystem, where <u>mount.zip</u> is a  zip
       archive which has been mounted (on top of itself) and contains <u>xxx/yyy</u>, and the current working directory
       is  inside  <u>xxx</u>,  and we evaluate a command like <u>file</u> <u>exists</u> <u>yyy</u>, then <u>root</u> will be <u>C:/foo/bar/mount.zip</u>,
       <u>relative</u> will be <u>xxx/yyy</u>, and <u>actualpath</u> will be <u>yyy</u>. The file separator between the <u>root</u> and <u>relative</u> is
       omitted.

       Note that most filesystem operations will only require the <u>relative</u> argument to work correctly,  but  the
       other arguments are actually required for correct operation of some subcommands.

       Almost all of these commands should either return correctly (i.e. with a TCL_OK result at the C level) or
       they should use vfs::filesystem posixerror to signal the appropriate posix error code.  If a Tcl error is
       thrown,  that  should  be  considered  a bug, but it will be interpreted as an unknown posix error in the
       filesystem call.  The exceptions to these rules are those filesystem commands which are able to specify a
       Tcl error message directly: open (when an interpreter is given), matchindirectory and fileattributes (for
       a set or get operation only).  These three commands are allowed to throw any Tcl error message which will
       be passed along to the caller, or they may throw a posix error which will be handled appropriately.

       The actual commands are as follows (where  <u>r-r-a</u>  represents  the  standard  argument  triplet  of  <u>root</u>,
       <u>relative</u> and <u>actualpath</u>):

       <u>command</u> <u>access</u> <u>r-r-a</u> <u>mode</u>
              Return  TCL_OK  or  throw  a  posix  error depending on whether the given access mode (which is an
              integer) is compatible with the file.

       <u>command</u> <u>createdirectory</u> <u>r-r-a</u>
              Create a directory with the given name.  The command can assume that all  sub-directories  in  the
              path  exist  and are valid, and that the actual desired path does not yet exist (Tcl takes care of
              all of that for us).

       <u>command</u> <u>deletefile</u> <u>r-r-a</u>
              Delete the given file.

       <u>command</u> <u>fileattributes</u> <u>r-r-a</u> <u>?index?</u> <u>?value?</u>
              If neither index nor value is given, then return a list of all  acceptable  attribute  names.   If
              <u>index</u> is given, but no value, then retrieve the value of the <u>index</u>'th attribute (counting in order
              over  the  list  returned when no argument is given) for the given file.  If a value is also given
              then set the <u>index</u>'th attribute of the given file to that value.

       <u>command</u> <u>matchindirectory</u> <u>r-r-a</u> <u>pattern</u> <u>types</u>
              Return the list of files or directories in the given path (which is always the name of an existing
              directory), which match the <u>pattern</u> and are compatible with the <u>types</u> given.  It is very important
              that the command correctly handle <u>types</u> requests for directories only (and files only), because to
              handle any kind of recursive globbing, Tcl will  actually  generate  requests  for  directory-only
              matches from the filesystem.  See <b>vfs::matchDirectories</b> below for help.

       <u>command</u> <u>open</u> <u>r-r-a</u> <u>mode</u> <u>permissions</u>
              For this command, <u>mode</u> is any of "r", "w", "a", "w+", "a+".  If the open involves creating a file,
              then <u>permissions</u> dictates what modes to create it with.  If the open operation was not successful,
              an  error should be thrown.  If the open operation is successful, the command should return a list
              of either one or two items.  The first item (which is obligatory) is the name of the channel which
              has been created.  The second item, if given, is a Tcl-callback to be used  when  the  channel  is
              closed,  so that the vfs can clean up as appropriate.  This callback will be evaluated by Tcl just
              before the channel is closed.  The channel will still exist, and all available data will have been
              flushed into it.  The callback can, for example, seek to the beginning of the  channel,  read  its
              contents  and  store  that contents elsewhere (e.g. compressed or on a remote ftp site, etc).  The
              return code or any errors returned by the callback are ignored (if the callback wishes  to  signal
              an  error,  it  must  do so asycnhronously, with bgerror, for example), unless the 'internalerror'
              script has been specified, when they are passed to that script for further action.

       <u>command</u> <u>removedirectory</u> <u>r-r-a</u> <u>recursive</u>
              Delete the given directory.  <u>recursive</u> is either 0 or 1. If it is 1 then even if the directory  is
              non-empty,  an  attempt  should be made to recursively delete it and its contents.  If it is 0 and
              the directory is non-empty, a posix error (ENOTEMPTY) should be thrown.

       <u>command</u> <u>stat</u> <u>r-r-a</u>
              Return a list of even length containing field-name and value pairs for  the  contents  of  a  stat
              structure.   The order is not important.  The option names are dev (long), ino (long), mode (int),
              nlink (long), uid (long), gid (long), size (long), atime (long), mtime (long), ctime (long),  type
              (string  which  is  either  "directory"  or  "file"),  where the type of each argument is given in
              brackets.  The procedure should therefore return with something like <u>return</u> <u>[list</u> <u>dev</u> <u>0</u> <u>type</u>  <u>file</u>
              <u>mtime</u> <u>1234</u> <u>...]</u>.

       <u>command</u> <u>utime</u> <u>r-r-a</u> <u>actime</u> <u>mtime</u>
              Set the access and modification times of the given file (these are read with 'stat').

</pre><h4><b>VFS</b> <b>HELPERS</b></h4><pre>
       The  vfslib  provides a number of Tcl procedures which can help with writing command procedures to handle
       the above possibilities.  These are:

       <b>vfs::accessMode</b> <u>mode</u>
              converts an integer <u>access</u> mode to a somewhat more preferable string, any of F X W XW R RX RW.

       <b>vfs::matchDirectories</b> <u>types</u>
              Does <u>types</u> want directories included?

       <b>vfs::matchFiles</b> <u>types</u>
              Does <u>types</u> want files included?

       <b>vfs::matchCorrectTypes</b> <u>types</u> <u>filelist</u> <u>?inDir?</u>
              Returns that subset of the <u>filelist</u> (which are either absolute paths or names of files  in  <u>inDir</u>)
              which are compatible with the <u>types</u> given.

</pre><h4><b>VFS</b> <b>DEBUGGING</b></h4><pre>
       Use  something like this to debug problems in your implementation: vfs::filesystem internalerror report ;
       proc report {} { puts stderr $::errorInfo }

</pre><h4><b>LIMITATIONS</b></h4><pre>
       There are very few limitations to the vfs code.  One subtlety that you may encounter is if  you  mount  a
       case-sensitive  virtual filesystem into a case-insensitive system (e.g. the standard Windows or MacOS fs)
       and your code relies on case-insensitivity, then it will not run properly in the virtual filesystem.   Of
       course  if  your code relies on case-insensitivity, it wouldn't run under Tcl on Unix either, so the best
       solution is to fix your code!

       We may add <u>link</u> and <u>lstat</u> commands in the future to allow virtual  filesystems  to  support  reading  and
       writing links - this is supported by the C API, but has simply not been exposed to Tcl in this extension,
       yet.

       The  Tcl  'Tcl_FSMatchInDirectory'  function  takes  a  variety of type information in a Tcl_GlobTypeData
       structure.  We currently only expose the 'type' field from that structure (so the 'permissions' and MacOS
       type/creator fields are ignored).

</pre><h4><b>KEYWORDS</b></h4><pre>
       vfs, filesystem, file

Vfs                                                    1.4                                             <u><a href="../man3tcl/vfs.3tcl.html">vfs</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>