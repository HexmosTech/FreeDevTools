<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       pthread_attr_destroy, pthread_attr_init — destroy and initialize the thread attributes object

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;

       int pthread_attr_destroy(pthread_attr_t *<u>attr</u>);
       int pthread_attr_init(pthread_attr_t *<u>attr</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>pthread_attr_destroy</u>() function shall destroy a thread attributes object. An implementation may cause
       <u>pthread_attr_destroy</u>()  to  set  <u>attr</u>  to  an  implementation-defined  invalid  value.  A  destroyed <u>attr</u>
       attributes object can be reinitialized using <u>pthread_attr_init</u>(); the results  of  otherwise  referencing
       the object after it has been destroyed are undefined.

       The  <u>pthread_attr_init</u>() function shall initialize a thread attributes object <u>attr</u> with the default value
       for all of the individual attributes used by a given implementation.

       The resulting attributes object (possibly modified by setting individual attribute values) when  used  by
       <u>pthread_create</u>()  defines the attributes of the thread created. A single attributes object can be used in
       multiple simultaneous calls to <u>pthread_create</u>().  Results are undefined if <u>pthread_attr_init</u>() is  called
       specifying an already initialized <u>attr</u> attributes object.

       The  behavior is undefined if the value specified by the <u>attr</u> argument to <u>pthread_attr_destroy</u>() does not
       refer to an initialized thread attributes object.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, <u>pthread_attr_destroy</u>() and <u>pthread_attr_init</u>() shall return  a  value  of  0;
       otherwise, an error number shall be returned to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>pthread_attr_init</u>() function shall fail if:

       <b>ENOMEM</b> Insufficient memory exists to initialize the thread attributes object.

       These functions shall not return an error code of <b>[EINTR]</b>.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       None.

</pre><h4><b>RATIONALE</b></h4><pre>
       Attributes  objects  are provided for threads, mutexes, and condition variables as a mechanism to support
       probable future standardization in these areas without requiring that the function itself be changed.

       Attributes objects provide clean isolation of the configurable aspects of threads. For  example,  ``stack
       size''  is  an  important  attribute  of  a  thread,  but it cannot be expressed portably. When porting a
       threaded program, stack sizes often need to be adjusted. The  use  of  attributes  objects  can  help  by
       allowing  the changes to be isolated in a single place, rather than being spread across every instance of
       thread creation.

       Attributes objects can be used to set up ``classes' of threads  with  similar  attributes;  for  example,
       ``threads  with large stacks and high priority'' or ``threads with minimal stacks''. These classes can be
       defined in a single place and then referenced wherever threads need to be created. Changes  to  ``class''
       decisions become straightforward, and detailed analysis of each <u>pthread_create</u>() call is not required.

       The  attributes objects are defined as opaque types as an aid to extensibility. If these objects had been
       specified as structures, adding new attributes would force recompilation of all  multi-threaded  programs
       when the attributes objects are extended; this might not be possible if different program components were
       supplied by different vendors.

       Additionally,  opaque  attributes  objects  present  opportunities  for  improving  performance. Argument
       validity can be checked once when attributes are  set,  rather  than  each  time  a  thread  is  created.
       Implementations  often  need  to  cache  kernel  objects  that are expensive to create. Opaque attributes
       objects provide an efficient mechanism to detect when cached objects  become  invalid  due  to  attribute
       changes.

       Since assignment is not necessarily defined on a given opaque type, implementation-defined default values
       cannot  be  defined  in a portable way. The solution to this problem is to allow attributes objects to be
       initialized dynamically by attributes object initialization functions, so  that  default  values  can  be
       supplied automatically by the implementation.

       The following proposal was provided as a suggested alternative to the supplied attributes:

        1. Maintain  the  style  of  passing  a  parameter  formed  by  the bitwise-inclusive OR of flags to the
           initialization routines (<u>pthread_create</u>(), <u>pthread_mutex_init</u>(), <u>pthread_cond_init</u>()).  The parameter
           containing the flags should be an opaque  type  for  extensibility.  If  no  flags  are  set  in  the
           parameter,  then  the objects are created with default characteristics. An implementation may specify
           implementation-defined flag values and associated behavior.

        2. If further specialization of mutexes  and  condition  variables  is  necessary,  implementations  may
           specify additional procedures that operate on the <b>pthread_mutex_t</b> and <b>pthread_cond_t</b> objects (instead
           of on attributes objects).

       The difficulties with this solution are:

        1. A  bitmask  is  not opaque if bits have to be set into bitvector attributes objects using explicitly-
           coded bitwise-inclusive OR operations. If the set of options exceeds an <b>int</b>, application  programmers
           need to know the location of each bit. If bits are set or read by encapsulation (that is, get and set
           functions),  then  the bitmask is merely an implementation of attributes objects as currently defined
           and should not be exposed to the programmer.

        2. Many attributes are not Boolean or very small integral values. For example, scheduling policy may  be
           placed  in 3-bit or 4-bit, but priority requires 5-bit or more, thereby taking up at least 8 bits out
           of a possible 16 bits on machines with 16-bit  integers.  Because  of  this,  the  bitmask  can  only
           reasonably  control  whether  particular  attributes  are  set  or  not,  and  it cannot serve as the
           repository of the value itself. The value needs to be specified as a  function  parameter  (which  is
           non-extensible),  or  by setting a structure field (which is non-opaque), or by get and set functions
           (making the bitmask a redundant addition to the attributes objects).

       Stack size is defined as an optional attribute because the very notion of a stack is inherently  machine-
       dependent.  Some implementations may not be able to change the size of the stack, for example, and others
       may not need to because stack pages may be discontiguous and can be allocated and released on demand.

       The attribute mechanism has been designed in large measure for extensibility. Future  extensions  to  the
       attribute  mechanism  or  to  any attributes object defined in this volume of POSIX.1‐2017 has to be done
       with care so as not to affect binary-compatibility.

       Attributes objects, even if allocated by means of dynamic allocation functions such as <u>malloc</u>(), may have
       their size fixed at compile time. This means, for example, a <u>pthread_create</u>() in an  implementation  with
       extensions  to  <b>pthread_attr_t</b>  cannot look beyond the area that the binary application assumes is valid.
       This suggests that implementations should maintain a size field in the  attributes  object,  as  well  as
       possibly  version  information, if extensions in different directions (possibly by different vendors) are
       to be accommodated.

       If an implementation detects that the value specified by the <u>attr</u> argument to <u>pthread_attr_destroy</u>() does
       not refer to an initialized thread attributes object, it is recommended that the function should fail and
       report an <b>[EINVAL]</b> error.

       If an implementation detects that the value specified by the <u>attr</u> argument to <u>pthread_attr_init</u>()  refers
       to  an  already initialized thread attributes object, it is recommended that the function should fail and
       report an <b>[EBUSY]</b> error.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>pthread_attr_getstacksize</u>(), <u>pthread_attr_getdetachstate</u>(), <u>pthread_create</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;pthread.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                          <u><a href="../man3POSIX/PTHREAD_ATTR_DESTROY.3POSIX.html">PTHREAD_ATTR_DESTROY</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>