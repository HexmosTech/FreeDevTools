<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hwlocality_memattrs - Comparing memory node attributes for finding where to allocate on</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhwloc-doc">libhwloc-doc_2.12.0-4build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       hwlocality_memattrs - Comparing memory node attributes for finding where to allocate on

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Data</b> <b>Structures</b>
       struct <b>hwloc_location</b>

   <b>Typedefs</b>
       typedef unsigned <b>hwloc_memattr_id_t</b>

   <b>Enumerations</b>
       enum <b>hwloc_memattr_id_e</b> { <b>HWLOC_MEMATTR_ID_CAPACITY</b>, <b>HWLOC_MEMATTR_ID_LOCALITY</b>,
           <b>HWLOC_MEMATTR_ID_BANDWIDTH</b>, <b>HWLOC_MEMATTR_ID_READ_BANDWIDTH</b>, <b>HWLOC_MEMATTR_ID_WRITE_BANDWIDTH</b>,
           <b>HWLOC_MEMATTR_ID_LATENCY</b>, <b>HWLOC_MEMATTR_ID_READ_LATENCY</b>, <b>HWLOC_MEMATTR_ID_WRITE_LATENCY</b>,
           <b>HWLOC_MEMATTR_ID_MAX</b> }
       enum <b>hwloc_location_type_e</b> { <b>HWLOC_LOCATION_TYPE_CPUSET</b>, <b>HWLOC_LOCATION_TYPE_OBJECT</b> }
       enum <b>hwloc_local_numanode_flag_e</b> { <b>HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY</b>,
           <b>HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY</b>, <b>HWLOC_LOCAL_NUMANODE_FLAG_ALL</b> }

   <b>Functions</b>
       int <b>hwloc_memattr_get_by_name</b> (<b>hwloc_topology_t</b> topology, const char *name, <b>hwloc_memattr_id_t</b> *id)
       int <b>hwloc_get_local_numanode_objs</b> (<b>hwloc_topology_t</b> topology, struct <b>hwloc_location</b> *location, unsigned
           *nr, <b>hwloc_obj_t</b> *nodes, unsigned long flags)
       int <b>hwloc_topology_get_default_nodeset</b> (<b>hwloc_topology_t</b> topology, <b>hwloc_nodeset_t</b> nodeset, unsigned long
           flags)
       int <b>hwloc_memattr_get_value</b> (<b>hwloc_topology_t</b> topology, <b>hwloc_memattr_id_t</b> attribute, <b>hwloc_obj_t</b>
           target_node, struct <b>hwloc_location</b> *initiator, unsigned long flags, hwloc_uint64_t *value)
       int <b>hwloc_memattr_get_best_target</b> (<b>hwloc_topology_t</b> topology, <b>hwloc_memattr_id_t</b> attribute, struct
           <b>hwloc_location</b> *initiator, unsigned long flags, <b>hwloc_obj_t</b> *best_target, hwloc_uint64_t *value)
       int <b>hwloc_memattr_get_best_initiator</b> (<b>hwloc_topology_t</b> topology, <b>hwloc_memattr_id_t</b> attribute,
           <b>hwloc_obj_t</b> target_node, unsigned long flags, struct <b>hwloc_location</b> *best_initiator, hwloc_uint64_t
           *value)
       int <b>hwloc_memattr_get_targets</b> (<b>hwloc_topology_t</b> topology, <b>hwloc_memattr_id_t</b> attribute, struct
           <b>hwloc_location</b> *initiator, unsigned long flags, unsigned *nr, <b>hwloc_obj_t</b> *targets, hwloc_uint64_t
           *values)
       int <b>hwloc_memattr_get_initiators</b> (<b>hwloc_topology_t</b> topology, <b>hwloc_memattr_id_t</b> attribute, <b>hwloc_obj_t</b>
           target_node, unsigned long flags, unsigned *nr, struct <b>hwloc_location</b> *initiators, hwloc_uint64_t
           *values)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Platforms with heterogeneous memory require ways to decide whether a buffer should be allocated on 'fast'
       memory (such as HBM), 'normal' memory (DDR) or even 'slow' but large-capacity memory (non-volatile
       memory). These memory nodes are called 'Targets' while the CPU accessing them is called the 'Initiator'.
       Access performance depends on their locality (NUMA platforms) as well as the intrinsic performance of the
       targets (heterogeneous platforms).

       The following attributes describe the performance of memory accesses from an Initiator to a memory
       Target, for instance their latency or bandwidth. Initiators performing these memory accesses are usually
       some PUs or Cores (described as a CPU set). Hence a Core may choose where to allocate a memory buffer by
       comparing the attributes of different target memory nodes nearby.

       There are also some attributes that are system-wide. Their value does not depend on a specific initiator
       performing an access. The memory node Capacity is an example of such attribute without initiator.

       One way to use this API is to start with a cpuset describing the Cores where a program is bound. The best
       target NUMA node for allocating memory in this program on these Cores may be obtained by passing this
       cpuset as an initiator to <b>hwloc_memattr_get_best_target()</b> with the relevant memory attribute. For
       instance, if the code is latency limited, use the Latency attribute.

       A more flexible approach consists in getting the list of local NUMA nodes by passing this cpuset to
       <b>hwloc_get_local_numanode_objs()</b>. Attribute values for these nodes, if any, may then be obtained with
       <b>hwloc_memattr_get_value()</b> and manually compared with the desired criteria.

       Memory attributes are also used internally to build Memory Tiers which provide an easy way to distinguish
       NUMA nodes of different kinds, as explained in <b>Heterogeneous</b> <b>Memory</b>.

       Beside tiers, hwloc defines a set of 'default' nodes where normal memory allocations should be made from
       (see <b>hwloc_topology_get_default_nodeset()</b>). This is also useful for dividing the machine into a set of
       non-overlapping NUMA domains, for instance for binding tasks per domain.

       <b>See</b> <b>also</b>
           An example is available in doc/examples/memory-attributes.c in the source tree.

       <b>Note</b>
           The API also supports specific objects as initiator, but it is currently not used internally by
           hwloc. Users may for instance use it to provide custom performance values for host memory accesses
           performed by GPUs.

           The interface actually also accepts targets that are not NUMA nodes.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>unsigned</b> <b>hwloc_memattr_id_t</b>
       A memory attribute identifier. hwloc predefines some commonly-used attributes in <b>hwloc_memattr_id_e</b>. One
       may then dynamically register custom ones with <b>hwloc_memattr_register()</b>, they will be assigned IDs
       immediately after the predefined ones. See <b>Managing</b> <b>memory</b> <b>attributes</b> for more information about existing
       attribute IDs.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>hwloc_local_numanode_flag_e</b>
       Flags for selecting target NUMA nodes.

       <b>Enumerator</b>

       <u>HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY</u>
              Select NUMA nodes whose locality is larger than the given cpuset. For instance, if a single PU (or
              its cpuset) is given in initiator, select all nodes close to the package that contains this PU.

       <u>HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY</u>
              Select  NUMA nodes whose locality is smaller than the given cpuset. For instance, if a package (or
              its cpuset) is given in initiator, also select nodes that are attached to  only  a  half  of  that
              package.

       <u>HWLOC_LOCAL_NUMANODE_FLAG_ALL</u>
              Select all NUMA nodes in the topology. The initiator initiator is ignored.

   <b>enum</b> <b>hwloc_location_type_e</b>
       Type of location.

       <b>Enumerator</b>

       <u>HWLOC_LOCATION_TYPE_CPUSET</u>
              Location is given as a cpuset, in the location cpuset union field.

       <u>HWLOC_LOCATION_TYPE_OBJECT</u>
              Location is given as an object, in the location object union field.

   <b>enum</b> <b>hwloc_memattr_id_e</b>
       Predefined  memory attribute IDs. See <b>hwloc_memattr_id_t</b> for the generic definition of IDs for predefined
       or custom attributes.

       <b>Enumerator</b>

       <u>HWLOC_MEMATTR_ID_CAPACITY</u>
              The "Capacity" is returned in bytes (local_memory attribute in objects). Best capacity  nodes  are
              nodes with <b>higher</b> <b>capacity</b>.

       No  initiator  is  involved  when  looking  at  this  attribute.  The  corresponding  attribute flags are
       <b>HWLOC_MEMATTR_FLAG_HIGHER_FIRST</b>.

       Capacity values may not be modified using <b>hwloc_memattr_set_value()</b>.

       <u>HWLOC_MEMATTR_ID_LOCALITY</u>
              The "Locality" is returned as the number of PUs in that locality (e.g. the weight of its  cpuset).
              Best  locality  nodes are nodes with <b>smaller</b> <b>locality</b> (nodes that are local to very few PUs). Poor
              locality nodes are nodes with larger locality (nodes that are local to the entire machine).

       No initiator is  involved  when  looking  at  this  attribute.  The  corresponding  attribute  flags  are
       <b>HWLOC_MEMATTR_FLAG_HIGHER_FIRST</b>.

       Locality values may not be modified using <b>hwloc_memattr_set_value()</b>.

       <u>HWLOC_MEMATTR_ID_BANDWIDTH</u>
              The  "Bandwidth"  is  returned in MiB/s, as seen from the given initiator location. Best bandwidth
              nodes are nodes with <b>higher</b> <b>bandwidth</b>.

       The      corresponding      attribute      flags      are       <b>HWLOC_MEMATTR_FLAG_HIGHER_FIRST</b>       and
       <b>HWLOC_MEMATTR_FLAG_NEED_INITIATOR</b>.

       This  is  the average bandwidth for read and write accesses. If the platform provides individual read and
       write bandwidths but no explicit average value, hwloc computes and returns the average.

       <u>HWLOC_MEMATTR_ID_READ_BANDWIDTH</u>
              The "ReadBandwidth" is returned in  MiB/s,  as  seen  from  the  given  initiator  location.  Best
              bandwidth nodes are nodes with <b>higher</b> <b>bandwidth</b>.

       The       corresponding       attribute      flags      are      <b>HWLOC_MEMATTR_FLAG_HIGHER_FIRST</b>      and
       <b>HWLOC_MEMATTR_FLAG_NEED_INITIATOR</b>.

       <u>HWLOC_MEMATTR_ID_WRITE_BANDWIDTH</u>
              The "WriteBandwidth" is returned in MiB/s,  as  seen  from  the  given  initiator  location.  Best
              bandwidth nodes are nodes with <b>higher</b> <b>bandwidth</b>.

       The       corresponding       attribute      flags      are      <b>HWLOC_MEMATTR_FLAG_HIGHER_FIRST</b>      and
       <b>HWLOC_MEMATTR_FLAG_NEED_INITIATOR</b>.

       <u>HWLOC_MEMATTR_ID_LATENCY</u>
              The "Latency" is returned as nanoseconds, as seen from the given initiator location. Best  latency
              nodes are nodes with <b>smaller</b> <b>latency</b>.

       The       corresponding       attribute       flags      are      <b>HWLOC_MEMATTR_FLAG_LOWER_FIRST</b>      and
       <b>HWLOC_MEMATTR_FLAG_NEED_INITIATOR</b>.

       This is the average latency for read and write accesses. If the platform  provides  individual  read  and
       write latencies but no explicit average value, hwloc computes and returns the average.

       <u>HWLOC_MEMATTR_ID_READ_LATENCY</u>
              The  "ReadLatency"  is  returned  as  nanoseconds, as seen from the given initiator location. Best
              latency nodes are nodes with <b>smaller</b> <b>latency</b>.

       The      corresponding      attribute      flags       are       <b>HWLOC_MEMATTR_FLAG_LOWER_FIRST</b>       and
       <b>HWLOC_MEMATTR_FLAG_NEED_INITIATOR</b>.

       <u>HWLOC_MEMATTR_ID_WRITE_LATENCY</u>
              The  "WriteLatency"  is  returned  as nanoseconds, as seen from the given initiator location. Best
              latency nodes are nodes with <b>smaller</b> <b>latency</b>.

       The      corresponding      attribute      flags       are       <b>HWLOC_MEMATTR_FLAG_LOWER_FIRST</b>       and
       <b>HWLOC_MEMATTR_FLAG_NEED_INITIATOR</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>int</b>  <b>hwloc_get_local_numanode_objs</b>  <b>(hwloc_topology_t</b>  <b>topology,</b> <b>struct</b> <b>hwloc_location</b> <b>*</b> <b>location,</b> <b>unsigned</b> <b>*</b>
       <b>nr,</b> <b>hwloc_obj_t</b> <b>*</b> <b>nodes,</b> <b>unsigned</b> <b>long</b> <b>flags)</b>
       Return an array of local NUMA nodes. By default only select the NUMA nodes whose locality is exactly  the
       given  location.  More  nodes  may  be  selected  if  additional  flags  are  given  as  a  OR'ed  set of
       <b>hwloc_local_numanode_flag_e</b>.

       If location is given as an explicit object, its CPU set is used to find NUMA nodes with the corresponding
       locality. If the object does not have a CPU set (e.g. I/O object), the CPU parent (where the  I/O  object
       is attached) is used.

       On  input,  nr points to the number of nodes that may be stored in the nodes array. On output, nr will be
       changed to the number of stored nodes, or the number of nodes that would have been stored if  there  were
       enough room.

       <b>Returns</b>
           0 on success or -1 on error.

       <b>Note</b>
           Some of these NUMA nodes may not have any memory attribute values and hence not be reported as actual
           targets in other functions.

           The  number  of  NUMA  nodes  in  the  topology (obtained by <b>hwloc_bitmap_weight()</b> on the root object
           nodeset) may be used to allocate the nodes array.

           When an object CPU set is given as locality, for instance a Package,  and  when  flags  contain  both
           <b>HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY</b>    and    <b>HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY</b>,   the
           returned array corresponds to the nodeset of that object.

   <b>int</b> <b>hwloc_memattr_get_best_initiator</b> <b>(hwloc_topology_t</b> <b>topology,</b>  <b>hwloc_memattr_id_t</b>  <b>attribute,</b>  <b>hwloc_obj_t</b>
       <b>target_node,</b> <b>unsigned</b> <b>long</b> <b>flags,</b> <b>struct</b> <b>hwloc_location</b> <b>*</b> <b>best_initiator,</b> <b>hwloc_uint64_t</b> <b>*</b> <b>value)</b>
       Return  the  best  initiator  for  the  given  attribute  and target NUMA node. If value is non NULL, the
       corresponding value is returned there.

       If multiple initiators have the same attribute values, only one is returned  (and  there  is  no  way  to
       clarify  how  that  one  is  chosen).  Applications that want to detect initiators with identical/similar
       values, or that want to look at values for multiple  attributes,  should  rather  get  all  values  using
       <b>hwloc_memattr_get_value()</b> and manually select the initiator they consider the best.

       The returned initiator should not be modified or freed, it belongs to the topology.

       target_node cannot be NULL.

       flags must be 0 for now.

       <b>Returns</b>
           0 on success.

           -1 with errno set to ENOENT if there are no matching initiators.

           -1  with  errno  set  to EINVAL if the attribute does not relate to a specific initiator (it does not
           have the flag <b>HWLOC_MEMATTR_FLAG_NEED_INITIATOR</b>).

   <b>int</b>  <b>hwloc_memattr_get_best_target</b>   <b>(hwloc_topology_t</b>   <b>topology,</b>   <b>hwloc_memattr_id_t</b>   <b>attribute,</b>   <b>struct</b>
       <b>hwloc_location</b> <b>*</b> <b>initiator,</b> <b>unsigned</b> <b>long</b> <b>flags,</b> <b>hwloc_obj_t</b> <b>*</b> <b>best_target,</b> <b>hwloc_uint64_t</b> <b>*</b> <b>value)</b>
       Return  the best target NUMA node for the given attribute and initiator. If the attribute does not relate
       to a specific initiator (it does not have the flag <b>HWLOC_MEMATTR_FLAG_NEED_INITIATOR</b>), location initiator
       is ignored and may be NULL.

       If value is non NULL, the corresponding value is returned there.

       If multiple targets have the same attribute values, only one is returned (and there is no way to  clarify
       how  that one is chosen). Applications that want to detect targets with identical/similar values, or that
       want  to  look  at   values   for   multiple   attributes,   should   rather   get   all   values   using
       <b>hwloc_memattr_get_value()</b> and manually select the target they consider the best.

       flags must be 0 for now.

       <b>Returns</b>
           0 on success.

           -1 with errno set to ENOENT if there are no matching targets.

           -1 with errno set to EINVAL if flags are invalid, or no such attribute exists.

       <b>Note</b>
           The  initiator  initiator  should  be  of  type  <b>HWLOC_LOCATION_TYPE_CPUSET</b> when refering to accesses
           performed by CPU cores. <b>HWLOC_LOCATION_TYPE_OBJECT</b> is currently unused internally by hwloc, but users
           may for instance use it to provide custom information about host memory accesses performed by GPUs.

   <b>int</b> <b>hwloc_memattr_get_by_name</b> <b>(hwloc_topology_t</b> <b>topology,</b> <b>const</b> <b>char</b> <b>*</b> <b>name,</b> <b>hwloc_memattr_id_t</b> <b>*</b> <b>id)</b>
       Return the identifier of the memory attribute with the given name.

       <b>Returns</b>
           0 on success.

           -1 with errno set to EINVAL if no such attribute exists.

   <b>int</b>  <b>hwloc_memattr_get_initiators</b>  <b>(hwloc_topology_t</b>  <b>topology,</b>  <b>hwloc_memattr_id_t</b>  <b>attribute,</b>   <b>hwloc_obj_t</b>
       <b>target_node,</b>  <b>unsigned</b>  <b>long</b>  <b>flags,</b>  <b>unsigned</b> <b>*</b> <b>nr,</b> <b>struct</b> <b>hwloc_location</b> <b>*</b> <b>initiators,</b> <b>hwloc_uint64_t</b> <b>*</b>
       <b>values)</b>
       Return the initiators that have values for a given attribute for a  specific  target  NUMA  node.  Return
       initiators  for  the  given attribute and target node in the initiators array. If values is not NULL, the
       corresponding attribute values are stored in the array it points to.

       On input, nr points to the number of initiators that may be stored in the array initiators (and  values).
       On  output,  nr points to the number of initiators (and values) that were actually found, even if some of
       them couldn't be stored in the array. Initiators that couldn't be stored are ignored,  but  the  function
       still  returns success (0). The caller may find out by comparing the value pointed by nr before and after
       the function call.

       The returned initiators should not be modified or freed, they belong to the topology.

       target_node cannot be NULL.

       flags must be 0 for now.

       If  the  attribute  does  not  relate  to  a  specific   initiator   (it   does   not   have   the   flag
       <b>HWLOC_MEMATTR_FLAG_NEED_INITIATOR</b>), no initiator is returned.

       <b>Returns</b>
           0 on success or -1 on error.

       <b>Note</b>
           This  function  is  meant  for  tools  and  debugging  (listing internal information) rather than for
           application   queries.   Applications   should    rather    select    useful    NUMA    nodes    with
           <b>hwloc_get_local_numanode_objs()</b> and then look at their attribute values for some relevant initiators.

   <b>int</b> <b>hwloc_memattr_get_targets</b> <b>(hwloc_topology_t</b> <b>topology,</b> <b>hwloc_memattr_id_t</b> <b>attribute,</b> <b>struct</b> <b>hwloc_location</b>
       <b>*</b> <b>initiator,</b> <b>unsigned</b> <b>long</b> <b>flags,</b> <b>unsigned</b> <b>*</b> <b>nr,</b> <b>hwloc_obj_t</b> <b>*</b> <b>targets,</b> <b>hwloc_uint64_t</b> <b>*</b> <b>values)</b>
       Return  the  target  NUMA nodes that have some values for a given attribute. Return targets for the given
       attribute in the targets array (for the given initiator if any). If values is not NULL, the corresponding
       attribute values are stored in the array it points to.

       On input, nr points to the number of targets that may be stored in the array  targets  (and  values).  On
       output,  nr  points  to the number of targets (and values) that were actually found, even if some of them
       couldn't be stored in the array. Targets that couldn't be stored are  ignored,  but  the  function  still
       returns  success  (0).  The caller may find out by comparing the value pointed by nr before and after the
       function call.

       The returned targets should not be modified or freed, they belong to the topology.

       Argument initiator is ignored if the attribute does not relate to a specific initiator (it does not  have
       the  flag  <b>HWLOC_MEMATTR_FLAG_NEED_INITIATOR</b>). Otherwise initiator may be non NULL to report only targets
       that have a value for that initiator.

       flags must be 0 for now.

       <b>Note</b>
           This function is meant for tools  and  debugging  (listing  internal  information)  rather  than  for
           application    queries.    Applications    should    rather    select    useful   NUMA   nodes   with
           <b>hwloc_get_local_numanode_objs()</b> and then look at their attribute values.

       <b>Returns</b>
           0 on success or -1 on error.

       <b>Note</b>
           The initiator initiator should be of  type  <b>HWLOC_LOCATION_TYPE_CPUSET</b>  when  referring  to  accesses
           performed by CPU cores. <b>HWLOC_LOCATION_TYPE_OBJECT</b> is currently unused internally by hwloc, but users
           may for instance use it to provide custom information about host memory accesses performed by GPUs.

   <b>int</b>   <b>hwloc_memattr_get_value</b>   <b>(hwloc_topology_t</b>   <b>topology,</b>   <b>hwloc_memattr_id_t</b>   <b>attribute,</b>   <b>hwloc_obj_t</b>
       <b>target_node,</b> <b>struct</b> <b>hwloc_location</b> <b>*</b> <b>initiator,</b> <b>unsigned</b> <b>long</b> <b>flags,</b> <b>hwloc_uint64_t</b> <b>*</b> <b>value)</b>
       Return an attribute value for a specific target NUMA node. If the attribute does not relate to a specific
       initiator (it does not have the flag <b>HWLOC_MEMATTR_FLAG_NEED_INITIATOR</b>), location  initiator  is  ignored
       and may be NULL.

       target_node  cannot  be NULL. If attribute is <b>HWLOC_MEMATTR_ID_CAPACITY</b>, target_node must be a NUMA node.
       If it is <b>HWLOC_MEMATTR_ID_LOCALITY</b>, target_node must have a CPU set.

       flags must be 0 for now.

       <b>Returns</b>
           0 on success.

           -1 on error, for instance with errno set to EINVAL if flags are invalid or no such attribute exists.

       <b>Note</b>
           The initiator initiator should be  of  type  <b>HWLOC_LOCATION_TYPE_CPUSET</b>  when  refering  to  accesses
           performed by CPU cores. <b>HWLOC_LOCATION_TYPE_OBJECT</b> is currently unused internally by hwloc, but users
           may for instance use it to provide custom information about host memory accesses performed by GPUs.

   <b>int</b>  <b>hwloc_topology_get_default_nodeset</b>  <b>(hwloc_topology_t</b>  <b>topology,</b>  <b>hwloc_nodeset_t</b> <b>nodeset,</b> <b>unsigned</b> <b>long</b>
       <b>flags)</b>
       Return the set of default NUMA nodes.  In  machines  with  heterogeneous  memory,  some  NUMA  nodes  are
       considered  the  default  ones,  i.e. where basic allocations should be made from. These are usually DRAM
       nodes.

       Other nodes may be reserved for specific use (I/O  device  memory,  e.g.  GPU  memory),  small  but  high
       performance  (HBM),  large but slow memory (NVM), etc. Buffers should usually not be allocated from there
       unless explicitly required.

       This function fills nodeset with the bits of NUMA nodes considered default.

       It is guaranteed that these nodes have non-intersecting CPU sets, i.e. cores may not have multiple  local
       NUMA  nodes  anymore.  Hence  this  may  be  used to iterate over the platform divided into separate NUMA
       localities, for instance for binding one task per NUMA domain.

       Any core that had some local NUMA node(s) in the initial topology should still have one  in  the  default
       nodeset.  Corner cases where this would be wrong consist in asymmetric platforms with missing DRAM nodes,
       or topologies that were already restricted to less NUMA nodes.

       The returned nodeset may be passed to  <b>hwloc_topology_restrict()</b>  with  <b>HWLOC_RESTRICT_FLAG_BYNODESET</b>  to
       remove  all  non-default  nodes  from  the  topology.  The  resulting topology will be easier to use when
       iterating over (now homogeneous) NUMA nodes.

       The heuristics for finding default nodes relies on memory tiers and subtypes (see  <b>Heterogeneous</b>  <b>Memory</b>)
       as well as the assumption that hardware vendors list default nodes first in hardware tables.

       flags must be 0 for now.

       <b>Returns</b>
           0 on success.

           -1 on error.

       <b>Note</b>
           The returned nodeset usually contains all nodes from a single memory tier, likely the DRAM one.

           The    returned    nodeset   is   included   in   the   list   of   available   nodes   returned   by
           <b>hwloc_topology_get_topology_nodeset()</b>. It is  strictly  smaller  if  the  machine  has  heterogeneous
           memory.

           The  heuristics  may return a suboptimal set of nodes if hwloc could not guess memory types and/or if
           some default nodes were removed earlier from the topology (e.g. with <b>hwloc_topology_restrict()</b>).

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for Hardware Locality (hwloc) from the source code.

Hardware Locality (hwloc)                        Version 2.12.0                           <u><a href="../man3/hwlocality_memattrs.3.html">hwlocality_memattrs</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>