<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO::CaptureOutput - (DEPRECATED) capture STDOUT and STDERR from Perl code, subprocesses or XS</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-captureoutput-perl">libio-captureoutput-perl_1.1105-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IO::CaptureOutput - (DEPRECATED) capture STDOUT and STDERR from Perl code, subprocesses or XS

</pre><h4><b>VERSION</b></h4><pre>
       version 1.1105

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use IO::CaptureOutput qw(capture qxx qxy);

           # STDOUT and STDERR separately
           capture { noisy_sub(@args) } \$stdout, \$stderr;

           # STDOUT and STDERR together
           capture { noisy_sub(@args) } \$combined, \$combined;

           # STDOUT and STDERR from external command
           ($stdout, $stderr, $success) = qxx( @cmd );

           # STDOUT and STDERR together from external command
           ($combined, $success) = qxy( @cmd );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>This</b> <b>module</b> <b>is</b> <b>no</b> <b>longer</b> <b>recommended</b> <b>by</b> <b>the</b> <b>maintainer</b> - see Capture::Tiny instead.

       This module provides routines for capturing STDOUT and STDERR from perl subroutines, forked system calls
       (e.g. system(), fork()) and from XS or C modules.

</pre><h4><b>NAME</b></h4><pre>
</pre><h4><b>FUNCTIONS</b></h4><pre>
       The following functions will be exported on demand.

   <b>capture()</b>
           capture \&amp;subroutine, \$stdout, \$stderr;

       Captures everything printed to "STDOUT" and "STDERR" for the duration of &amp;subroutine. $stdout and $stderr
       are optional scalars that will contain "STDOUT" and "STDERR" respectively.

       capture() uses a code prototype so the first argument can be specified directly within brackets if
       desired.

           # shorthand with prototype
           capture C&lt; print __PACKAGE__ &gt; \$stdout, \$stderr;

       Returns the return value(s) of &amp;subroutine. The sub is called in the same context as capture() was called
       e.g.:

           @rv = capture C&lt; wantarray &gt; ; # returns true
           $rv = capture C&lt; wantarray &gt; ; # returns defined, but not true
           capture C&lt; wantarray &gt;;       # void, returns undef

       capture() is able to capture output from subprocesses and C code, which traditional tie() methods of
       output capture are unable to do.

       <b>Note:</b> capture() will only capture output that has been written or flushed to the filehandle.

       If the two scalar references refer to the same scalar, then "STDERR" will be merged to "STDOUT" before
       capturing and the scalar will hold the combined output of both.

           capture \&amp;subroutine, \$combined, \$combined;

       Normally, capture() uses anonymous, temporary files for capturing output.  If desired, specific file
       names may be provided instead as additional options.

           capture \&amp;subroutine, \$stdout, \$stderr, $out_file, $err_file;

       Files provided will be clobbered, overwriting any previous data, but will persist after the call to
       capture() for inspection or other manipulation.

       By default, when no references are provided to hold STDOUT or STDERR, output is captured and silently
       discarded.

           # Capture STDOUT, discard STDERR
           capture \&amp;subroutine, \$stdout;

           # Discard STDOUT, capture STDERR
           capture \&amp;subroutine, undef, \$stderr;

       However, even when using "undef", output can be captured to specific files.

           # Capture STDOUT to a specific file, discard STDERR
           capture \&amp;subroutine, \$stdout, undef, $outfile;

           # Discard STDOUT, capture STDERR to a specific file
           capture \&amp;subroutine, undef, \$stderr, undef, $err_file;

           # Discard both, capture merged output to a specific file
           capture \&amp;subroutine, undef, undef, $mergedfile;

       It is a fatal error to merge STDOUT and STDERR and request separate, specific files for capture.

           # ERROR:
           capture \&amp;subroutine, \$stdout, \$stdout, $out_file, $err_file;
           capture \&amp;subroutine, undef, undef, $out_file, $err_file;

       If either STDOUT or STDERR should be passed through to the terminal instead of captured, provide a
       reference to undef -- "\undef" -- instead of a capture variable.

           # Capture STDOUT, display STDERR
           capture \&amp;subroutine, \$stdout, \undef;

           # Display STDOUT, capture STDERR
           capture \&amp;subroutine, \undef, \$stderr;

   <b>capture_exec()</b>
           ($stdout, $stderr, $success, $exit_code) = capture_exec(@args);

       Captures and returns the output from system(@args). In scalar context, capture_exec() will return what
       was printed to "STDOUT". In list context, it returns what was printed to "STDOUT" and "STDERR" as well as
       a success flag and the exit value.

           $stdout = capture_exec('perl', '-e', 'print "hello world"');

           ($stdout, $stderr, $success, $exit_code) =
               capture_exec('perl', '-e', 'warn "Test"');

       "capture_exec" passes its arguments to system() and on MSWin32 will protect arguments with shell quotes
       if necessary.  This makes it a handy and slightly more portable alternative to backticks, piped open()
       and "IPC::Open3".

       The $success flag returned will be true if the command ran successfully and false if it did not (if the
       command could not be run or if it ran and returned a non-zero exit value).  On failure, the raw exit
       value of the system() call is available both in the $exit_code returned and in the $? variable.

         ($stdout, $stderr, $success, $exit_code) =
             capture_exec('perl', '-e', 'warn "Test" and exit 1');

         if ( ! $success ) {
             print "The exit code was " . ($exit_code &gt;&gt; 8) . "\n";
         }

       See perlvar for more information on interpreting a child process exit code.

   <b>capture_exec_combined()</b>
           ($combined, $success, $exit_code) = capture_exec_combined(
               'perl', '-e', 'print "hello\n"', 'warn "Test\n"
           );

       This is just like capture_exec(), except that it merges "STDERR" with "STDOUT" before capturing output.

       <b>Note:</b> there is no guarantee that text printed to "STDOUT" and "STDERR" in the subprocess will be appear
       in order. The actual order will depend on how IO buffering is handled in the subprocess.

   <b>qxx()</b>
       This is an alias for capture_exec().

   <b>qxy()</b>
       This is an alias for capture_exec_combined().

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   Capture::Tiny

       •   IPC::Open3

       •   IO::Capture

       •   IO::Utils

       •   IPC::System::Simple

</pre><h4><b>SUPPORT</b></h4><pre>
   <b>Bugs</b> <b>/</b> <b>Feature</b> <b>Requests</b>
       Please     report    any    bugs    or    feature    requests    through    the    issue    tracker    at
       &lt;https://github.com/dagolden/IO-CaptureOutput/issues&gt;.   You  will  be  notified  automatically  of   any
       progress on your issue.

   <b>Source</b> <b>Code</b>
       This  is open source software.  The code repository is available for public review and contribution under
       the terms of the license.

       &lt;https://github.com/dagolden/IO-CaptureOutput&gt;

         git clone https://github.com/dagolden/IO-CaptureOutput.git

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Simon Flack &lt;<a href="mailto:simonflk@cpan.org">simonflk@cpan.org</a>&gt;

       •   David Golden &lt;<a href="mailto:dagolden@cpan.org">dagolden@cpan.org</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   David Golden &lt;<a href="mailto:xdg@xdg.me">xdg@xdg.me</a>&gt;

       •   José Joaquín Atria &lt;<a href="mailto:jjatria@gmail.com">jjatria@gmail.com</a>&gt;

       •   Mike Latimer &lt;<a href="mailto:mlatimer@suse.com">mlatimer@suse.com</a>&gt;

       •   Olivier Mengué &lt;<a href="mailto:dolmen@cpan.org">dolmen@cpan.org</a>&gt;

       •   Tony Cook &lt;<a href="mailto:tony@develop-help.com">tony@develop-help.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2019 by Simon Flack and David Golden.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.38.2                                       2024-03-06                             <u>IO::<a href="../man3pm/CaptureOutput.3pm.html">CaptureOutput</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>