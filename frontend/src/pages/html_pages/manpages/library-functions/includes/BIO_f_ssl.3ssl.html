<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIO_do_handshake, BIO_f_ssl, BIO_set_ssl, BIO_get_ssl, BIO_set_ssl_mode, BIO_set_ssl_renegotiate_bytes,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       BIO_do_handshake, BIO_f_ssl, BIO_set_ssl, BIO_get_ssl, BIO_set_ssl_mode, BIO_set_ssl_renegotiate_bytes,
       BIO_get_num_renegotiates, BIO_set_ssl_renegotiate_timeout, BIO_new_ssl, BIO_new_ssl_connect,
       BIO_new_buffer_ssl_connect, BIO_ssl_copy_session_id, BIO_ssl_shutdown - SSL BIO

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/bio.h&gt;
        #include &lt;openssl/ssl.h&gt;

        const BIO_METHOD *BIO_f_ssl(void);

        long BIO_set_ssl(BIO *b, SSL *ssl, long c);
        long BIO_get_ssl(BIO *b, SSL **sslp);
        long BIO_set_ssl_mode(BIO *b, long client);
        long BIO_set_ssl_renegotiate_bytes(BIO *b, long num);
        long BIO_set_ssl_renegotiate_timeout(BIO *b, long seconds);
        long BIO_get_num_renegotiates(BIO *b);

        BIO *BIO_new_ssl(SSL_CTX *ctx, int client);
        BIO *BIO_new_ssl_connect(SSL_CTX *ctx);
        BIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx);
        int BIO_ssl_copy_session_id(BIO *to, BIO *from);
        void BIO_ssl_shutdown(BIO *bio);

        long BIO_do_handshake(BIO *b);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>BIO_f_ssl()</b> returns the SSL BIO method. This is a filter BIO which is a wrapper round the OpenSSL SSL
       routines adding a BIO "flavour" to SSL I/O.

       I/O performed on an SSL BIO communicates using the SSL protocol with the SSLs read and write BIOs. If an
       SSL connection is not established then an attempt is made to establish one on the first I/O call.

       If a BIO is appended to an SSL BIO using <b>BIO_push()</b> it is automatically used as the SSL BIOs read and
       write BIOs.

       Calling <b>BIO_reset()</b> on an SSL BIO closes down any current SSL connection by calling <b>SSL_shutdown()</b>.
       <b>BIO_reset()</b> is then sent to the next BIO in the chain: this will typically disconnect the underlying
       transport.  The SSL BIO is then reset to the initial accept or connect state.

       If the close flag is set when an SSL BIO is freed then the internal SSL structure is also freed using
       <b>SSL_free()</b>.

       <b>BIO_set_ssl()</b> sets the internal SSL pointer of SSL BIO <b>b</b> to <b>ssl</b> using the close flag <b>c</b>.

       <b>BIO_get_ssl()</b> retrieves the SSL pointer of SSL BIO <b>b</b>, it can then be manipulated using the standard SSL
       library functions.

       <b>BIO_set_ssl_mode()</b> sets the SSL BIO mode to <b>client</b>. If <b>client</b> is 1 client mode is set. If <b>client</b> is 0
       server mode is set.

       <b>BIO_set_ssl_renegotiate_bytes()</b> sets the renegotiate byte count of SSL BIO <b>b</b> to <b>num</b>. When set after every
       <b>num</b> bytes of I/O (read and write) the SSL session is automatically renegotiated. <b>num</b> must be at least 512
       bytes.

       <b>BIO_set_ssl_renegotiate_timeout()</b> sets the renegotiate timeout of SSL BIO <b>b</b> to <b>seconds</b>.  When the
       renegotiate timeout elapses the session is automatically renegotiated.

       <b>BIO_get_num_renegotiates()</b> returns the total number of session renegotiations due to I/O or timeout of
       SSL BIO <b>b</b>.

       <b>BIO_new_ssl()</b> allocates an SSL BIO using SSL_CTX <b>ctx</b> and using client mode if <b>client</b> is non zero.

       <b>BIO_new_ssl_connect()</b> creates a new BIO chain consisting of an SSL BIO (using <b>ctx</b>) followed by a connect
       BIO.

       <b>BIO_new_buffer_ssl_connect()</b> creates a new BIO chain consisting of a buffering BIO, an SSL BIO (using
       <b>ctx</b>), and a connect BIO.

       <b>BIO_ssl_copy_session_id()</b> copies an SSL session id between BIO chains <b>from</b> and <b>to</b>. It does this by
       locating the SSL BIOs in each chain and calling <b>SSL_copy_session_id()</b> on the internal SSL pointer.

       <b>BIO_ssl_shutdown()</b> closes down an SSL connection on BIO chain <b>bio</b>. It does this by locating the SSL BIO
       in the chain and calling <b>SSL_shutdown()</b> on its internal SSL pointer.

       <b>BIO_do_handshake()</b> attempts to complete an SSL handshake on the supplied BIO and establish the SSL
       connection.  For non-SSL BIOs the connection is done typically at TCP level.  If domain name resolution
       yields multiple IP addresses all of them are tried after <b>connect()</b> failures.  The function returns 1 if
       the connection was established successfully.  A zero or negative value is returned if the connection
       could not be established.  The call <b>BIO_should_retry()</b> should be used for nonblocking connect BIOs to
       determine if the call should be retried.  If a connection has already been established this call has no
       effect.

</pre><h4><b>NOTES</b></h4><pre>
       SSL BIOs are exceptional in that if the underlying transport is non blocking they can still request a
       retry in exceptional circumstances. Specifically this will happen if a session renegotiation takes place
       during a <b>BIO_read_ex()</b> operation, one case where this happens is when step up occurs.

       The SSL flag SSL_AUTO_RETRY can be set to disable this behaviour. That is when this flag is set an SSL
       BIO using a blocking transport will never request a retry.

       Since unknown <b>BIO_ctrl()</b> operations are sent through filter BIOs the servers name and port can be set
       using <b>BIO_set_host()</b> on the BIO returned by <b>BIO_new_ssl_connect()</b> without having to locate the connect
       BIO first.

       Applications do not have to call <b>BIO_do_handshake()</b> but may wish to do so to separate the handshake
       process from other I/O processing.

       <b>BIO_set_ssl()</b>, <b>BIO_get_ssl()</b>, <b>BIO_set_ssl_mode()</b>, <b>BIO_set_ssl_renegotiate_bytes()</b>,
       <b>BIO_set_ssl_renegotiate_timeout()</b>, <b>BIO_get_num_renegotiates()</b>, and <b>BIO_do_handshake()</b> are implemented as
       macros.

       <b>BIO_ssl_copy_session_id()</b> is not currently supported on QUIC SSL objects and fails if called on such an
       object.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>BIO_f_ssl()</b> returns the SSL <b>BIO_METHOD</b> structure.

       <b>BIO_set_ssl()</b>, <b>BIO_get_ssl()</b>, <b>BIO_set_ssl_mode()</b>, <b>BIO_set_ssl_renegotiate_bytes()</b>,
       <b>BIO_set_ssl_renegotiate_timeout()</b> and <b>BIO_get_num_renegotiates()</b> return 1 on success or a value which is
       less than or equal to 0 if an error occurred.

       <b>BIO_new_ssl()</b>, <b>BIO_new_ssl_connect()</b> and <b>BIO_new_buffer_ssl_connect()</b> return a valid <b>BIO</b> structure on
       success or <b>NULL</b> if an error occurred.

       <b>BIO_ssl_copy_session_id()</b> returns 1 on success or 0 on error, or if called on a QUIC SSL object.

       <b>BIO_do_handshake()</b> returns 1 if the connection was established successfully.  A zero or negative value is
       returned if the connection could not be established.

</pre><h4><b>EXAMPLES</b></h4><pre>
       This SSL/TLS client example attempts to retrieve a page from an SSL/TLS web server. The I/O routines are
       identical to those of the unencrypted example in <b><a href="../man3/BIO_s_connect.3.html">BIO_s_connect</a></b>(3).

        BIO *sbio, *out;
        int len;
        char tmpbuf[1024];
        SSL_CTX *ctx;
        SSL *ssl;

        /* XXX Seed the PRNG if needed. */

        ctx = SSL_CTX_new(TLS_client_method());

        /* XXX Set verify paths and mode here. */

        sbio = BIO_new_ssl_connect(ctx);
        BIO_get_ssl(sbio, &amp;ssl);
        if (ssl == NULL) {
            fprintf(stderr, "Can't locate SSL pointer\n");
            ERR_print_errors_fp(stderr);
            <a href="../man1/exit.1.html">exit</a>(1);
        }

        /* XXX We might want to do other things with ssl here */

        /* An empty host part means the loopback address */
        BIO_set_conn_hostname(sbio, ":https");

        out = BIO_new_fp(stdout, BIO_NOCLOSE);
        if (BIO_do_connect(sbio) &lt;= 0) {
            fprintf(stderr, "Error connecting to server\n");
            ERR_print_errors_fp(stderr);
            <a href="../man1/exit.1.html">exit</a>(1);
        }

        /* XXX Could examine ssl here to get connection info */

        BIO_puts(sbio, "GET / HTTP/1.0\n\n");
        for (;;) {
            len = BIO_read(sbio, tmpbuf, 1024);
            if (len &lt;= 0)
                break;
            BIO_write(out, tmpbuf, len);
        }
        BIO_free_all(sbio);
        BIO_free(out);

       Here is a simple server example. It makes use of a buffering BIO to allow lines to be read from the SSL
       BIO using BIO_gets.  It creates a pseudo web page containing the actual request from a client and also
       echoes the request to standard output.

        BIO *sbio, *bbio, *acpt, *out;
        int len;
        char tmpbuf[1024];
        SSL_CTX *ctx;
        SSL *ssl;

        /* XXX Seed the PRNG if needed. */

        ctx = SSL_CTX_new(TLS_server_method());
        if (!SSL_CTX_use_certificate_file(ctx, "server.pem", SSL_FILETYPE_PEM)
                || !SSL_CTX_use_PrivateKey_file(ctx, "server.pem", SSL_FILETYPE_PEM)
                || !SSL_CTX_check_private_key(ctx)) {
            fprintf(stderr, "Error setting up SSL_CTX\n");
            ERR_print_errors_fp(stderr);
            <a href="../man1/exit.1.html">exit</a>(1);
        }

        /* XXX Other things like set verify locations, EDH temp callbacks. */

        /* New SSL BIO setup as server */
        sbio = BIO_new_ssl(ctx, 0);
        BIO_get_ssl(sbio, &amp;ssl);
        if (ssl == NULL) {
            fprintf(stderr, "Can't locate SSL pointer\n");
            ERR_print_errors_fp(stderr);
            <a href="../man1/exit.1.html">exit</a>(1);
        }

        bbio = BIO_new(BIO_f_buffer());
        sbio = BIO_push(bbio, sbio);
        acpt = BIO_new_accept("4433");

        /*
         * By doing this when a new connection is established
         * we automatically have sbio inserted into it. The
         * BIO chain is now 'swallowed' by the accept BIO and
         * will be freed when the accept BIO is freed.
         */
        BIO_set_accept_bios(acpt, sbio);
        out = BIO_new_fp(stdout, BIO_NOCLOSE);

        /* First call to BIO_do_accept() sets up accept BIO */
        if (BIO_do_accept(acpt) &lt;= 0) {
            fprintf(stderr, "Error setting up accept BIO\n");
            ERR_print_errors_fp(stderr);
            <a href="../man1/exit.1.html">exit</a>(1);
        }

       /* Second call to <b>BIO_do_accept()</b> waits for incoming connection */
        if (BIO_do_accept(acpt) &lt;= 0) {
           fprintf(stderr, "Error accepting connection\n");
           ERR_print_errors_fp(stderr);
           <b><a href="../man1/exit.1.html">exit</a></b>(1);
        }

        /* We only want one connection so remove and free accept BIO */
        sbio = BIO_pop(acpt);
        BIO_free_all(acpt);

        if (BIO_do_handshake(sbio) &lt;= 0) {
            fprintf(stderr, "Error in SSL handshake\n");
            ERR_print_errors_fp(stderr);
            <a href="../man1/exit.1.html">exit</a>(1);
        }

        BIO_puts(sbio, "HTTP/1.0 200 OK\r\nContent-type: text/plain\r\n\r\n");
        BIO_puts(sbio, "\r\nConnection Established\r\nRequest headers:\r\n");
        BIO_puts(sbio, "--------------------------------------------------\r\n");

        for (;;) {
            len = BIO_gets(sbio, tmpbuf, 1024);
            if (len &lt;= 0)
                break;
            BIO_write(sbio, tmpbuf, len);
            BIO_write(out, tmpbuf, len);
            /* Look for blank line signifying end of headers*/
            if (tmpbuf[0] == '\r' || tmpbuf[0] == '\n')
                break;
        }

        BIO_puts(sbio, "--------------------------------------------------\r\n");
        BIO_puts(sbio, "\r\n");
        BIO_flush(sbio);
        BIO_free_all(sbio);

</pre><h4><b>HISTORY</b></h4><pre>
       In OpenSSL before 1.0.0 the <b>BIO_pop()</b> call was handled incorrectly, the I/O BIO reference count was
       incorrectly incremented (instead of decremented) and dissociated with the SSL BIO even if the SSL BIO was
       not explicitly being popped (e.g. a pop higher up the chain). Applications which included workarounds for
       this bug (e.g. freeing BIOs more than once) should be modified to handle this fix or they may free up an
       already freed BIO.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2000-2023 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                    <u><a href="../man3SSL/BIO_F_SSL.3SSL.html">BIO_F_SSL</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>