<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::GSL::INTEG - PDL interface to numerical integration routines in GSL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/pdl">pdl_2.074-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::GSL::INTEG - PDL interface to numerical integration routines in GSL

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is an interface to the numerical integration package present in the GNU Scientific Library, which is
       an implementation of QUADPACK.

       Functions are named <b>gslinteg_{algorithm}</b> where {algorithm} is the QUADPACK naming convention. The
       available functions are:

       gslinteg_qng: Non-adaptive Gauss-Kronrod integration
       gslinteg_qag: Adaptive integration
       gslinteg_qags: Adaptive integration with singularities
       gslinteg_qagp: Adaptive integration with known singular points
       gslinteg_qagi: Adaptive integration on infinite interval of the form (-\infty,\infty)
       gslinteg_qagiu: Adaptive integration on infinite interval of the form (la,\infty)
       gslinteg_qagil: Adaptive integration on infinite interval of the form (-\infty,lb)
       gslinteg_qawc: Adaptive integration for Cauchy principal values
       gslinteg_qaws: Adaptive integration for singular functions
       gslinteg_qawo: Adaptive integration for oscillatory functions
       gslinteg_qawf: Adaptive integration for Fourier integrals

       Each  algorithm  computes  an approximation to the integral, I, of the function f(x)w(x), where w(x) is a
       weight function (for general integrands w(x)=1). The user provides absolute  and  relative  error  bounds
       (epsabs,epsrel) which specify the following accuracy requirement:

       |RESULT - I|  &lt;= max(epsabs, epsrel |I|)

       The  routines  will  fail  to  converge if the error bounds are too stringent, but always return the best
       approximation obtained up to that stage

       All functions return the result, and estimate of the absolute error and an error flag (which is  zero  if
       there  were no problems).  You are responsible for checking for any errors, no warnings are issued unless
       the option {Warn =&gt; 'y'} is specified in which case the reason of failure will be printed.

       You can nest integrals up to 20 levels. If you find yourself in the  unlikely  situation  that  you  need
       more,  you  can  change  the  value  of 'max_nested_integrals' in the first line of the file 'FUNC.c' and
       recompile.

</pre><h4><b>NOMENCLATURE</b></h4><pre>
       Throughout this documentation we strive to use the same variables that are present in  the  original  GSL
       documentation  (see  See Also). Oftentimes those variables are called "a" and "b". Since good Perl coding
       practices discourage the use of Perl variables $a and $b, here we refer to Parameters "a" and "b" as  $pa
       and $pb, respectively, and Limits (of domain or integration) as $la and $lb.

       Please check the GSL documentation for more information.

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use PDL;
          use PDL::GSL::INTEG;

          my $la = 1.2;
          my $lb = 3.7;
          my $epsrel = 0;
          my $epsabs = 1e-6;

          # Non adaptive integration
          my ($res,$abserr,$ierr,$neval) = gslinteg_qng(\&amp;myf,$la,$lb,$epsrel,$epsabs);
          # Warnings on
          my ($res,$abserr,$ierr,$neval) = gslinteg_qng(\&amp;myf,$la,$lb,$epsrel,$epsabs,{Warn=&gt;'y'});

          # Adaptive integration with warnings on
          my $limit = 1000;
          my $key = 5;
          my ($res,$abserr,$ierr) = gslinteg_qag(\&amp;myf,$la,$lb,$epsrel,
                                            $epsabs,$limit,$key,{Warn=&gt;'y'});

          sub myf{
            my ($x) = @_;
            return exp(-$x**2);
          }
       #line 132 "INTEG.pm"

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>qng_meat</b>
         Signature: (double a(); double b(); double epsabs();
                          double epsrel(); double [o] result(); double [o] abserr();
                          int [o] neval(); int [o] ierr(); int gslwarn(); SV* function)

       info not available

       qng_meat  does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>qag_meat</b>
         Signature: (double a(); double b(); double epsabs();double epsrel(); int limit();
                          int key(); double [o] result(); double [o] abserr();int n();int [o] ierr();int gslwarn();; SV* function)

       info not available

       qag_meat does not process bad values.  It will set the bad-value flag of all output ndarrays if the  flag
       is set for any of the input ndarrays.

   <b>qags_meat</b>
         Signature: (double a(); double b(); double epsabs();double epsrel(); int limit();
                          double [o] result(); double [o] abserr();int n();int [o] ierr();int gslwarn();; SV* function)

       info not available

       qags_meat does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>qagp_meat</b>
         Signature: (double pts(l); double epsabs();double epsrel();int limit();
                          double [o] result(); double [o] abserr();int n();int [o] ierr();int gslwarn();; SV* function)

       info not available

       qagp_meat does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>qagi_meat</b>
         Signature: (double epsabs();double epsrel(); int limit();
                          double [o] result(); double [o] abserr(); int n(); int [o] ierr();int gslwarn();; SV* function)

       info not available

       qagi_meat does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>qagiu_meat</b>
         Signature: (double a(); double epsabs();double epsrel();int limit();
                          double [o] result(); double [o] abserr();int n();int [o] ierr();int gslwarn();; SV* function)

       info not available

       qagiu_meat  does  not  process  bad values.  It will set the bad-value flag of all output ndarrays if the
       flag is set for any of the input ndarrays.

   <b>qagil_meat</b>
         Signature: (double b(); double epsabs();double epsrel();int limit();
                          double [o] result(); double [o] abserr();int n();int [o] ierr();int gslwarn();; SV* function)

       info not available

       qagil_meat does not process bad values.  It will set the bad-value flag of all  output  ndarrays  if  the
       flag is set for any of the input ndarrays.

   <b>qawc_meat</b>
         Signature: (double a(); double b(); double c(); double epsabs();double epsrel();int limit();
                          double [o] result(); double [o] abserr();int n();int [o] ierr();int gslwarn();; SV* function)

       info not available

       qawc_meat does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>qaws_meat</b>
         Signature: (double a(); double b();double epsabs();double epsrel();int limit();
                        double [o] result(); double [o] abserr();int n();
                        double alpha(); double beta(); int mu(); int nu();int [o] ierr();int gslwarn();; SV* function)

       info not available

       qaws_meat does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>qawo_meat</b>
         Signature: (double a(); double b();double epsabs();double epsrel();int limit();
                        double [o] result(); double [o] abserr();int n();
                        int sincosopt(); double omega(); double L(); int nlevels();int [o] ierr();int gslwarn();; SV* function)

       info not available

       qawo_meat does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>qawf_meat</b>
         Signature: (double a(); double epsabs();int limit();
                        double [o] result(); double [o] abserr();int n();
                        int sincosopt(); double omega(); int nlevels();int [o] ierr();int gslwarn();; SV* function)

       info not available

       qawf_meat does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>gslinteg_qng</b> <b>-</b> <b>Non-adaptive</b> <b>Gauss-Kronrod</b> <b>integration</b>
       This  function  applies  the Gauss-Kronrod 10-point, 21-point, 43-point and 87-point integration rules in
       succession until an estimate of the integral of f over ($la,$lb) is achieved within the desired  absolute
       and relative error limits, $epsabs and $epsrel.  It is meant for fast integration of smooth functions. It
       returns  an  array  with  the  result, an estimate of the absolute error, an error flag and the number of
       function evaluations performed.

       Usage:

         ($res,$abserr,$ierr,$neval) = gslinteg_qng($function_ref,$la,$lb,
                                                    $epsrel,$epsabs,[{Warn =&gt; $warn}]);

       Example:

          my ($res,$abserr,$ierr,$neval) = gslinteg_qng(\&amp;f,0,1,0,1e-9);
          # with warnings on
          my ($res,$abserr,$ierr,$neval) = gslinteg_qng(\&amp;f,0,1,0,1e-9,{Warn =&gt; 'y'});

          sub f{
            my ($x) = @_;
            return ($x**2.6)*log(1.0/$x);
          }

   <b>gslinteg_qag</b> <b>-</b> <b>Adaptive</b> <b>integration</b>
       This function applies an integration rule adaptively  until  an  estimate  of  the  integral  of  f  over
       ($la,$lb) is achieved within the desired absolute and relative error limits, $epsabs and $epsrel. On each
       iteration  the  adaptive  integration  strategy bisects the interval with the largest error estimate; the
       maximum number of allowed subdivisions is given  by  the  parameter  $limit.   The  integration  rule  is
       determined  by  the value of $key, which has to be one of (1,2,3,4,5,6) and correspond to the 15, 21, 31,
       41, 51 and 61  point Gauss-Kronrod rules respectively.  It returns an array with the result, an  estimate
       of the absolute error and an error flag.

       Please check the GSL documentation for more information.

       Usage:

         ($res,$abserr,$ierr) = gslinteg_qag($function_ref,$la,$lb,$epsrel,
                                             $epsabs,$limit,$key,[{Warn =&gt; $warn}]);

       Example:

         my ($res,$abserr,$ierr) = gslinteg_qag(\&amp;f,0,1,0,1e-10,1000,1);
         # with warnings on
         my ($res,$abserr,$ierr) = gslinteg_qag(\&amp;f,0,1,0,1e-10,1000,1,{Warn =&gt; 'y'});

         sub f{
            my ($x) = @_;
            return ($x**2.6)*log(1.0/$x);
          }

   <b>gslinteg_qags</b> <b>-</b> <b>Adaptive</b> <b>integration</b> <b>with</b> <b>singularities</b>
       This  function  applies  the  Gauss-Kronrod 21-point integration rule adaptively until an estimate of the
       integral of f over ($la,$lb) is achieved within the desired absolute and relative error  limits,  $epsabs
       and $epsrel. The algorithm is such that it accelerates the convergence of the integral in the presence of
       discontinuities  and  integrable  singularities.   The maximum number of allowed subdivisions done by the
       adaptive algorithm must be supplied in the parameter $limit.

       Please check the GSL documentation for more information.

       Usage:

         ($res,$abserr,$ierr) = gslinteg_qags($function_ref,$la,$lb,$epsrel,
                                              $epsabs,$limit,[{Warn =&gt; $warn}]);

       Example:

         my ($res,$abserr,$ierr) = gslinteg_qags(\&amp;f,0,1,0,1e-10,1000);
         # with warnings on
         ($res,$abserr,$ierr) = gslinteg_qags(\&amp;f,0,1,0,1e-10,1000,{Warn =&gt; 'y'});

         sub f{
            my ($x) = @_;
            return ($x)*log(1.0/$x);
          }

   <b>gslinteg_qagp</b> <b>-</b> <b>Adaptive</b> <b>integration</b> <b>with</b> <b>known</b> <b>singular</b> <b>points</b>
       This function applies the adaptive integration algorithm used by gslinteg_qags taking  into  account  the
       location  of singular points until an estimate of the integral of f over ($la,$lb) is achieved within the
       desired absolute and relative error limits, $epsabs and $epsrel.  Singular points  are  supplied  in  the
       ndarray  $points,  whose endpoints determine the integration range.  So, for example, if the function has
       singular points at x_1 and x_2 and the integral is desired from a to b (a &lt; x_1 &lt; x_2  &lt;  b),  $points  =
       pdl(a,x_1,x_2,b).   The  maximum  number  of  allowed subdivisions done by the adaptive algorithm must be
       supplied in the parameter $limit.

       Please check the GSL documentation for more information.

       Usage:

         ($res,$abserr,$ierr) = gslinteg_qagp($function_ref,$points,$epsabs,
                                              $epsrel,$limit,[{Warn =&gt; $warn}])

       Example:

         my $points = pdl(0,1,<a href="../man2/sqrt.2.html">sqrt</a>(2),3);
         my ($res,$abserr,$ierr) = gslinteg_qagp(\&amp;f,$points,0,1e-3,1000);
         # with warnings on
         ($res,$abserr,$ierr) = gslinteg_qagp(\&amp;f,$points,0,1e-3,1000,{Warn =&gt; 'y'});

         sub f{
           my ($x) = @_;
           my $x2 = $x**2;
           my $x3 = $x**3;
           return $x3 * log(abs(($x2-1.0)*($x2-2.0)));
         }

   <b>gslinteg_qagi</b> <b>-</b> <b>Adaptive</b> <b>integration</b> <b>on</b> <b>infinite</b> <b>interval</b>
       This function estimates the integral of the function  f  over  the  infinite  interval  (-\infty,+\infty)
       within  the desired absolute and relative error limits, $epsabs and $epsrel.  After a transformation, the
       algorithm of gslinteg_qags with a 15-point Gauss-Kronrod rule is used.  The  maximum  number  of  allowed
       subdivisions done by the adaptive algorithm must be supplied in the parameter $limit.

       Please check the GSL documentation for more information.

       Usage:

         ($res,$abserr,$ierr) = gslinteg_qagi($function_ref,$epsabs,
                                              $epsrel,$limit,[{Warn =&gt; $warn}]);

       Example:

         my ($res,$abserr,$ierr) = gslinteg_qagi(\&amp;myfn,1e-7,0,1000);
         # with warnings on
         ($res,$abserr,$ierr) = gslinteg_qagi(\&amp;myfn,1e-7,0,1000,{Warn =&gt; 'y'});

         sub myfn{
           my ($x) = @_;
           return exp(-$x - $x*$x) ;
         }

   <b>gslinteg_qagiu</b> <b>-</b> <b>Adaptive</b> <b>integration</b> <b>on</b> <b>infinite</b> <b>interval</b>
       This function estimates the integral of the function f over the infinite interval (la,+\infty) within the
       desired  absolute  and relative error limits, $epsabs and $epsrel.  After a transformation, the algorithm
       of gslinteg_qags with a 15-point Gauss-Kronrod rule is used.  The maximum number of allowed  subdivisions
       done by the adaptive algorithm must be supplied in the parameter $limit.

       Please check the GSL documentation for more information.

       Usage:

         ($res,$abserr,$ierr) = gslinteg_qagiu($function_ref,$la,$epsabs,
                                               $epsrel,$limit,[{Warn =&gt; $warn}]);

       Example:

         my $alfa = 1;
         my ($res,$abserr,$ierr) = gslinteg_qagiu(\&amp;f,99.9,1e-7,0,1000);
         # with warnings on
         ($res,$abserr,$ierr) = gslinteg_qagiu(\&amp;f,99.9,1e-7,0,1000,{Warn =&gt; 'y'});

         sub f{
           my ($x) = @_;
           if (($x==0) &amp;&amp; ($alfa == 1)) {return 1;}
           if (($x==0) &amp;&amp; ($alfa &gt; 1)) {return 0;}
           return ($x**($alfa-1))/((1+10*$x)**2);
         }

   <b>gslinteg_qagil</b> <b>-</b> <b>Adaptive</b> <b>integration</b> <b>on</b> <b>infinite</b> <b>interval</b>
       This function estimates the integral of the function f over the infinite interval (-\infty,lb) within the
       desired  absolute  and relative error limits, $epsabs and $epsrel.  After a transformation, the algorithm
       of gslinteg_qags with a 15-point Gauss-Kronrod rule is used.  The maximum number of allowed  subdivisions
       done by the adaptive algorithm must be supplied in the parameter $limit.

       Please check the GSL documentation for more information.

       Usage:

         ($res,$abserr,$ierr) = gslinteg_qagl($function_ref,$lb,$epsabs,
                                              $epsrel,$limit,[{Warn =&gt; $warn}]);

       Example:

         my ($res,$abserr,$ierr) = gslinteg_qagil(\&amp;myfn,1.0,1e-7,0,1000);
         # with warnings on
         ($res,$abserr,$ierr) = gslinteg_qagil(\&amp;myfn,1.0,1e-7,0,1000,{Warn =&gt; 'y'});

         sub myfn{
           my ($x) = @_;
           return exp($x);
         }

   <b>gslinteg_qawc</b> <b>-</b> <b>Adaptive</b> <b>integration</b> <b>for</b> <b>Cauchy</b> <b>principal</b> <b>values</b>
       This  function  computes the Cauchy principal value of the integral of f over (la,lb), with a singularity
       at c, I = \int_{la}^{lb} dx f(x)/(x - c). The integral is  estimated  within  the  desired  absolute  and
       relative  error  limits,  $epsabs  and  $epsrel.   The maximum number of allowed subdivisions done by the
       adaptive algorithm must be supplied in the parameter $limit.

       Please check the GSL documentation for more information.

       Usage:

         ($res,$abserr,$ierr) = gslinteg_qawc($function_ref,$la,$lb,$c,$epsabs,$epsrel,$limit)

       Example:

         my ($res,$abserr,$ierr) = gslinteg_qawc(\&amp;f,-1,5,0,0,1e-3,1000);
         # with warnings on
         ($res,$abserr,$ierr) = gslinteg_qawc(\&amp;f,-1,5,0,0,1e-3,1000,{Warn =&gt; 'y'});

         sub f{
           my ($x) = @_;
           return 1.0 / (5.0 * $x * $x * $x + 6.0) ;
         }

   <b>gslinteg_qaws</b> <b>-</b> <b>Adaptive</b> <b>integration</b> <b>for</b> <b>singular</b> <b>functions</b>
       The algorithm in gslinteg_qaws is designed for integrands with algebraic-logarithmic singularities at the
       end-points of an integration region.  Specifically, this function computes the  integral  given  by  I  =
       \int_{la}^{lb}  dx  f(x) (x-la)^alpha (lb-x)^beta log^mu (x-la) log^nu (lb-x).  The integral is estimated
       within the desired absolute and relative error limits,  $epsabs  and  $epsrel.   The  maximum  number  of
       allowed subdivisions done by the adaptive algorithm must be supplied in the parameter $limit.

       Please check the GSL documentation for more information.

       Usage:

         ($res,$abserr,$ierr) =
             gslinteg_qawc($function_ref,$alpha,$beta,$mu,$nu,$la,$lb,
                           $epsabs,$epsrel,$limit,[{Warn =&gt; $warn}]);

       Example:

         my ($res,$abserr,$ierr) = gslinteg_qaws(\&amp;f,0,0,1,0,0,1,0,1e-7,1000);
         # with warnings on
         ($res,$abserr,$ierr) = gslinteg_qaws(\&amp;f,0,0,1,0,0,1,0,1e-7,1000,{Warn =&gt; 'y'});

         sub f{
           my ($x) = @_;
           if($x==0){return 0;}
           else{
             my $u = log($x);
             my $v = 1 + $u*$u;
             return 1.0/($v*$v);
           }
         }

   <b>gslinteg_qawo</b> <b>-</b> <b>Adaptive</b> <b>integration</b> <b>for</b> <b>oscillatory</b> <b>functions</b>
       This  function  uses  an  adaptive  algorithm  to  compute the integral of f over (la,lb) with the weight
       function sin(omega*x) or cos(omega*x) -- which of sine or cosine is used is determined by  the  parameter
       $opt  ('cos' or 'sin').  The integral is estimated within the desired absolute and relative error limits,
       $epsabs and $epsrel.  The maximum number of allowed subdivisions done by the adaptive algorithm  must  be
       supplied in the parameter $limit.

       Please check the GSL documentation for more information.

       Usage:

         ($res,$abserr,$ierr) = gslinteg_qawo($function_ref,$omega,$sin_or_cos,
                                       $la,$lb,$epsabs,$epsrel,$limit,[opt])

       Example:

         my $PI = 3.14159265358979323846264338328;
         my ($res,$abserr,$ierr) = PDL::GSL::INTEG::gslinteg_qawo(\&amp;f,10*$PI,'sin',0,1,0,1e-7,1000);
         # with warnings on
         ($res,$abserr,$ierr) = PDL::GSL::INTEG::gslinteg_qawo(\&amp;f,10*$PI,'sin',0,1,0,1e-7,1000,{Warn =&gt; 'y'});

         sub f{
           my ($x) = @_;
           if($x==0){return 0;}
           else{ return log($x);}
         }

   <b>gslinteg_qawf</b> <b>-</b> <b>Adaptive</b> <b>integration</b> <b>for</b> <b>Fourier</b> <b>integrals</b>
       This  function  attempts  to compute a Fourier integral of the function f over the semi-infinite interval
       [la,+\infty). Specifically, it attempts tp compute I = \int_{la}^{+\infty} dx  f(x)w(x),  where  w(x)  is
       sin(omega*x)  or  cos(omega*x)  --  which  of  sine or cosine is used is determined by the parameter $opt
       ('cos' or 'sin').  The integral is estimated within  the  desired  absolute  error  limit  $epsabs.   The
       maximum  number  of allowed subdivisions done by the adaptive algorithm must be supplied in the parameter
       $limit.

       Please check the GSL documentation for more information.

       Usage:

         gslinteg_qawf($function_ref,$omega,$sin_or_cos,$la,$epsabs,$limit,[opt])

       Example:

         my ($res,$abserr,$ierr) = gslinteg_qawf(\&amp;f,$PI/2.0,'cos',0,1e-7,1000);
         # with warnings on
         ($res,$abserr,$ierr) = gslinteg_qawf(\&amp;f,$PI/2.0,'cos',0,1e-7,1000,{Warn =&gt; 'y'});

         sub f{
           my ($x) = @_;
           if ($x == 0){return 0;}
           return 1.0/sqrt($x)
         }

</pre><h4><b>BUGS</b></h4><pre>
       Feedback  is  welcome.  Log  bugs  in  the  PDL  bug  database  (the  database  is  always  linked   from
       &lt;<a href="http://pdl.perl.org">http://pdl.perl.org</a>&gt;).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       PDL

       The       GSL       documentation       for       numerical       integration      is      online      at
       &lt;https://www.gnu.org/software/gsl/doc/html/integration.html&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       This file copyright (C) 2003,2005 Andres Jordan  &lt;<a href="mailto:ajordan@eso.org">ajordan@eso.org</a>&gt;  All  rights  reserved.  There  is  no
       warranty.  You  are  allowed  to  redistribute  this software documentation under certain conditions. For
       details, see the file COPYING  in  the  PDL  distribution.  If  this  file  is  separated  from  the  PDL
       distribution, the copyright notice should be included in the file.

       The  GSL  integration  routines  were  written by Brian Gough. QUADPACK was written by Piessens, Doncker-
       Kapenga, Uberhuber and Kahaner.

perl v5.34.0                                       2022-02-08                                         <u><a href="../man3pm/INTEG.3pm.html">INTEG</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>