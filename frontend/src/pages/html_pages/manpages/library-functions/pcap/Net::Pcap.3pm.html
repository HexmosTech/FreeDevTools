<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::Pcap - Interface to the pcap(3) LBL packet capture library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-pcap-perl">libnet-pcap-perl_0.21-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::Pcap - Interface to the <a href="../man3/pcap.3.html">pcap</a>(3) LBL packet capture library

</pre><h4><b>VERSION</b></h4><pre>
       Version 0.21

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Net::Pcap;

           my $err = '';
           my $dev = pcap_lookupdev(\$err);  # find a device

           # open the device for live listening
           my $pcap = pcap_open_live($dev, 1024, 1, 0, \$err);

           # loop over next 10 packets
           pcap_loop($pcap, 10, \&amp;process_packet, "just for the demo");

           # close the device
           pcap_close($pcap);

           sub process_packet {
               my ($user_data, $header, $packet) = @_;
               # do something ...
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Net::Pcap" is a Perl binding to the LBL <b><a href="../man3/pcap.3.html">pcap</a></b>(3) library and its Win32 counterpart, the WinPcap library.
       Pcap (packet capture) is a portable API to capture network packet: it allows applications to capture
       packets at link-layer, bypassing the normal protocol stack. It also provides features like kernel-level
       packet filtering and access to internal statistics.

       Common applications include network statistics collection, security monitoring, network debugging, etc.

</pre><h4><b>NOTES</b></h4><pre>
   <b>Signals</b> <b>handling</b>
       Since version 5.7.3, Perl uses a mechanism called "deferred signals" to delay signals delivery until
       "safe" points in the interpreter.  See "Deferred Signals (Safe Signals)" in perlipc for a detailed
       explanation.

       Since "Net::Pcap" version 0.08, released in October 2005, the module modified the internal variable
       "PL_signals" to re-enable immediate signals delivery in Perl 5.8 and later within some XS functions
       (CPAN-RT #6320). However, it can create situations where the Perl interpreter is less stable and can
       crash (CPAN-RT #43308). Therefore, as of version 0.17, "Net::Pcap" no longer modifies "PL_signals" by
       itself, but provides facilities so the user has full control of how signals are delivered.

       First, the pcap_perl_settings() function allows one to select how signals are handled:

           pcap_perl_settings(PERL_SIGNALS_UNSAFE);
           pcap_loop($pcap, 10, \&amp;process_packet, "");
           pcap_perl_settings(PERL_SIGNALS_SAFE);

       Then, to easily make code interruptable, "Net::Pcap" provides the "UNSAFE_SIGNALS" pseudo-bloc:

           UNSAFE_SIGNALS {
               pcap_loop($pcap, 10, \&amp;process_packet, "");
           };

       (Stolen from Rafael Garcia-Suarez's "Perl::Unsafe::Signals")

</pre><h4><b>EXPORTS</b></h4><pre>
       "Net::Pcap" supports the following "Exporter" tags:

       •   ":bpf" exports a few BPF related constants:

               BPF_ALIGNMENT  BPF_MAJOR_VERSION  BPF_MAXBUFSIZE  BPF_MAXINSNS
               BPF_MEMWORDS  BPF_MINBUFSIZE  BPF_MINOR_VERSION  BPF_RELEASE

       •   ":datalink" exports the data link types macros:

               DLT_AIRONET_HEADER  DLT_APPLE_IP_OVER_IEEE1394  DLT_ARCNET
               DLT_ARCNET_LINUX  DLT_ATM_CLIP  DLT_ATM_RFC1483  DLT_AURORA
               DLT_AX25  DLT_CHAOS  DLT_CHDLC  DLT_CISCO_IOS  DLT_C_HDLC
               DLT_DOCSIS  DLT_ECONET  DLT_EN10MB  DLT_EN3MB  DLT_ENC  DLT_FDDI
               DLT_FRELAY  DLT_HHDLC  DLT_IBM_SN  DLT_IBM_SP  DLT_IEEE802
               DLT_IEEE802_11  DLT_IEEE802_11_RADIO DLT_IEEE802_11_RADIO_AVS
               DLT_IPFILTER  DLT_IP_OVER_FC  DLT_JUNIPER_ATM1 DLT_JUNIPER_ATM2
               DLT_JUNIPER_ES  DLT_JUNIPER_GGSN  DLT_JUNIPER_MFR DLT_JUNIPER_MLFR
               DLT_JUNIPER_MLPPP  DLT_JUNIPER_MONITOR  DLT_JUNIPER_SERVICES
               DLT_LINUX_IRDA  DLT_LINUX_SLL  DLT_LOOP  DLT_LTALK  DLT_NULL
               DLT_OLD_PFLOG  DLT_PCI_EXP  DLT_PFLOG  DLT_PFSYNC  DLT_PPP
               DLT_PPP_BSDOS  DLT_PPP_ETHER  DLT_PPP_SERIAL  DLT_PRISM_HEADER
               DLT_PRONET  DLT_RAW  DLT_RIO  DLT_SLIP  DLT_SLIP_BSDOS  DLT_SUNATM
               DLT_SYMANTEC_FIREWALL  DLT_TZSP  DLT_USER0  DLT_USER1  DLT_USER2
               DLT_USER3  DLT_USER4  DLT_USER5  DLT_USER6  DLT_USER7  DLT_USER8
               DLT_USER9  DLT_USER10  DLT_USER11  DLT_USER12  DLT_USER13
               DLT_USER14  DLT_USER15

       •   ":pcap" exports the following "pcap" constants:

               PCAP_ERRBUF_SIZE    PCAP_IF_LOOPBACK
               PCAP_VERSION_MAJOR  PCAP_VERSION_MINOR

       •   ":mode" exports the following constants:

               MODE_CAPT  MODE_MON  MODE_STAT

       •   ":openflag" exports the following constants:

               OPENFLAG_PROMISCUOUS  OPENFLAG_DATATX_UDP  OPENFLAG_NOCAPTURE_RPCAP

       •   ":source" exports the following constants:

               PCAP_SRC_FILE  PCAP_SRC_IFLOCAL  PCAP_SRC_IFREMOTE

       •   ":sample" exports the following constants:

               PCAP_SAMP_NOSAMP  PCAP_SAMP_1_EVERY_N  PCAP_SAMP_FIRST_AFTER_N_MS

       •   ":rpcap" exports the following constants:

               RMTAUTH_NULL  RMTAUTH_PWD

       •   ":functions"  short  names  of  the  functions (without the "pcap_" prefix) for those which would not
           cause a clash with an already defined name.  Namely, the following functions  are  not  available  in
           short  form:  open(),  close(),  next(),  dump(),  file(),  fileno().  Using these short names is now
           discouraged, and may be removed in the future.

       By default, this module exports the symbols from the ":datalink" and ":pcap" tags, and all the functions,
       with the same names as the C library.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       All functions defined by "Net::Pcap" are direct mappings to the libpcap functions.  Consult  the  <b><a href="../man3/pcap.3.html">pcap</a></b>(3)
       documentation and source code for more information.

       Arguments  that  change  a  parameter,  for  example  pcap_lookupdev(),  are  passed  that parameter as a
       reference.  This is to retain compatibility with previous versions of "Net::Pcap".

   <b>Lookup</b> <b>functions</b>
       <b>pcap_lookupdev(\$err)</b>
           Returns the name of a network device that can be used with pcap_open_live() function.  On error,  the
           $err parameter is filled with an appropriate error message else it is undefined.

           <b>Example</b>

               $dev = pcap_lookupdev();

       <b>pcap_findalldevs(\%devinfo,</b> <b>\$err)</b>
           Returns  a  list  of  all  network  device names that can be used with pcap_open_live() function.  On
           error, the $err parameter is filled with an appropriate error message else it is undefined.

           <b>Example</b>

               @devs = pcap_findalldevs(\%devinfo, \$err);
               for my $dev (@devs) {
                   print "$dev : $devinfo{$dev}\n"
               }

           <b>Note</b>
               For backward compatibility reasons,  this  function  can  also  be  called  using  the  following
               signatures:

                   @devs = pcap_findalldevs(\$err);

                   @devs = pcap_findalldevs(\$err, \%devinfo);

               The  first  form  was  introduced  by Marco Carnut in "Net::Pcap" version 0.05 and kept intact in
               versions 0.06 and 0.07.  The second form was introduced by Jean-Louis Morel for the Windows only,
               ActivePerl port of "Net::Pcap", in versions 0.04.01 and 0.04.02.

               The new syntax has been introduced for consistency with the rest of the Perl API and the C API of
               <a href="../man3/libpcap.3.html">libpcap</a>(3), where $err is always the last argument.

       <b>pcap_lookupnet($dev,</b> <b>\$net,</b> <b>\$mask,</b> <b>\$err)</b>
           Determine the network number and netmask for the device specified in $dev.  The function returns 0 on
           success and sets the $net and $mask parameters with values.  On failure it returns -1  and  the  $err
           parameter is filled with an appropriate error message.

   <b>Packet</b> <b>capture</b> <b>functions</b>
       <b>pcap_open_live($dev,</b> <b>$snaplen,</b> <b>$promisc,</b> <b>$to_ms,</b> <b>\$err)</b>
           Returns  a  packet  capture  descriptor  for  looking  at packets on the network.  The $dev parameter
           specifies which network interface to capture packets from.   The  $snaplen  and  $promisc  parameters
           specify  the  maximum  number  of bytes to capture from each packet, and whether to put the interface
           into promiscuous mode, respectively.  The $to_ms parameter specifies a read timeout in  milliseconds.
           The  packet  descriptor will be undefined if an error occurs, and the $err parameter will be set with
           an appropriate error message.

           <b>Example</b>

               $dev = pcap_lookupdev();
               $pcap = pcap_open_live($dev, 1024, 1, 0, \$err)
                   or die "Can't open device $dev: $err\n";

       <b>pcap_open_dead($linktype,</b> <b>$snaplen)</b>
           Creates and returns a new packet descriptor to use when calling the other functions in "libpcap".  It
           is typically used when just using "libpcap" for compiling BPF code.

           <b>Example</b>

               $pcap = pcap_open_dead(0, 1024);

       <b>pcap_open_offline($filename,</b> <b>\$err)</b>
           Return  a  packet  capture  descriptor  to  read  from a previously created "savefile".  The returned
           descriptor is undefined if there was an error and in this case the $err  parameter  will  be  filled.
           Savefiles are created using the "pcap_dump_*" commands.

           <b>Example</b>

               $pcap = pcap_open_offline($dump, \$err)
                   or die "Can't read '$dump': $err\n";

       <b>pcap_loop($pcap,</b> <b>$count,</b> <b>\&amp;callback,</b> <b>$user_data)</b>
           Read  $count  packets  from  the packet capture descriptor $pcap and call the perl function &amp;callback
           with an argument of $user_data.  If $count is negative, then the function loops forever or  until  an
           error  occurs.  Returns 0 if $count is exhausted, -1 on error, and -2 if the loop terminated due to a
           call to <b>pcap_breakloop()</b> before any packets were processed.

           The callback function is also passed packet header information and packet data like so:

               sub process_packet {
                   my ($user_data, $header, $packet) = @_;

                   ...
               }

           The header information is a reference to a hash containing the following fields.

           •   "len" - the total length of the packet.

           •   "caplen" - the actual captured length of the packet  data.   This  corresponds  to  the  snapshot
               length parameter passed to open_live().

           •   "tv_sec" - seconds value of the packet timestamp.

           •   "tv_usec" - microseconds value of the packet timestamp.

           <b>Example</b>

               pcap_loop($pcap, 10, \&amp;process_packet, "user data");

               sub process_packet {
                   my ($user_data, $header, $packet) = @_;
                   # ...
               }

       <b>pcap_breakloop($pcap)</b>
           Sets  a flag  that will force pcap_dispatch() or pcap_loop() to return rather than looping; they will
           return the number of packets that have been processed so far, or -2 if no packets have been processed
           so far.

           This routine is safe to use inside a signal handler on UNIX or a console control handler on  Windows,
           as it merely sets a flag that is checked within the loop.

           Please see the section on pcap_breakloop() in <b><a href="../man3/pcap.3.html">pcap</a></b>(3) for more information.

       <b>pcap_close($pcap)</b>
           Close the packet capture device associated with the descriptor $pcap.

       <b>pcap_dispatch($pcap,</b> <b>$count,</b> <b>\&amp;callback,</b> <b>$user_data)</b>
           Collect  $count  packets  and  process  them  with callback function &amp;callback.  if $count is -1, all
           packets currently buffered are processed.  If $count is 0, process all packets until an error occurs.

       <b>pcap_next($pcap,</b> <b>\%header)</b>
           Return the next available packet on the interface associated with packet descriptor $pcap.  Into  the
           %header  hash is stored the received packet header.  If not packet is available, the return value and
           header is undefined.

       <b>pcap_next_ex($pcap,</b> <b>\%header,</b> <b>\$packet)</b>
           Reads the next available packet on the interface associated with packet descriptor $pcap, stores  its
           header in "\%header" and its data in "\$packet" and returns a success/failure indication:

           •   1 means that the packet was read without problems;

           •   0 means that packets are being read from a live capture, and the timeout expired;

           •   -1 means that an error occurred while reading the packet;

           •   -2  packets  are  being  read  from  a  dump file, and there are no more packets to read from the
               savefile.

       <b>pcap_compile($pcap,</b> <b>\$filter,</b> <b>$filter_str,</b> <b>$optimize,</b> <b>$netmask)</b>
           Compile the filter string contained in $filter_str and store it in $filter.   A  description  of  the
           filter  language  can  be  found in the libpcap source code, or the manual page for <b><a href="../man8/tcpdump.8.html">tcpdump</a></b>(8) .  The
           filter is optimized if the $optimize variable is true.  The netmask of the  network  device  must  be
           specified in the $netmask parameter.  The function returns 0 if the compilation was successful, or -1
           if there was a problem.

       <b>pcap_compile_nopcap($snaplen,</b> <b>$linktype,</b> <b>\$filter,</b> <b>$filter_str,</b> <b>$optimize,</b> <b>$netmask)</b>
           Similar  to  compile()  except  that  instead  of passing a $pcap descriptor, one passes $snaplen and
           $linktype directly. Returns -1 if there was an error, but the error message is not available.

       <b>pcap_setfilter($pcap,</b> <b>$filter)</b>
           Associate the compiled filter stored in $filter with the packet capture descriptor $pcap.

       <b>pcap_freecode($filter)</b>
           Used to free the allocated memory used by a compiled filter, as created by pcap_compile().

       <b>pcap_offline_filter($filter,</b> <b>\%header,</b> <b>$packet)</b>
           Check whether $filter matches the packet described by header %header and packet data $packet. Returns
           true if the packet matches.

       <b>pcap_setnonblock($pcap,</b> <b>$mode,</b> <b>\$err)</b>
           Set the <u>non-blocking</u> mode of a live capture descriptor, depending on the  value  of  $mode  (zero  to
           activate  and non-zero to deactivate). It has no effect on offline descriptors. If there is an error,
           it returns -1 and sets $err.

           In non-blocking mode, an attempt to read from the capture descriptor with pcap_dispatch() will, if no
           packets are currently available to be read, return 0  immediately rather than  blocking  waiting  for
           packets to arrive.  pcap_loop() and pcap_next() will not work in non-blocking mode.

       <b>pcap_getnonblock($pcap,</b> <b>\$err)</b>
           Returns  the  <u>non-blocking</u>  state of the capture descriptor $pcap.  Always returns 0 on savefiles. If
           there is an error, it returns -1 and sets $err.

   <b>Savefile</b> <b>commands</b>
       <b>pcap_dump_open($pcap,</b> <b>$filename)</b>
           Open a savefile for writing and return a descriptor for doing  so.   If  $filename  is  "-"  data  is
           written to standard output.  On error, the return value is undefined and pcap_geterr() can be used to
           retrieve the error text.

       <b>pcap_dump($dumper,</b> <b>\%header,</b> <b>$packet)</b>
           Dump  the  packet described by header %header and packet data $packet to the savefile associated with
           $dumper.  The packet header has the same format as that passed to the pcap_loop() callback.

           <b>Example</b>

               my $dump_file = 'network.dmp';
               my $dev = pcap_lookupdev();
               my $pcap = pcap_open_live($dev, 1024, 1, 0, \$err);

               my $dumper = pcap_dump_open($pcap, $dump_file);
               pcap_loop($pcap, 10, \&amp;process_packet, '');
               pcap_dump_close($dumper);

               sub process_packet {
                   my ($user_data, $header, $packet) = @_;
                   pcap_dump($dumper, $header, $packet);
               }

       <b>pcap_dump_file($dumper)</b>
           Returns the filehandle associated with a savefile opened with pcap_dump_open().

       <b>pcap_dump_flush($dumper)</b>
           Flushes the output buffer  to  the  corresponding  save  file,  so  that  any  packets  written  with
           pcap_dump() but not yet written to the save file will be written. Returns -1 on error, 0 on success.

       <b>pcap_dump_close($dumper)</b>
           Close the savefile associated with the descriptor $dumper.

   <b>Status</b> <b>functions</b>
       <b>pcap_datalink($pcap)</b>
           Returns the link layer type associated with the given pcap descriptor.

           <b>Example</b>

               $linktype = pcap_datalink($pcap);

       <b>pcap_set_datalink($pcap,</b> <b>$linktype)</b>
           Sets  the  data link type of the given pcap descriptor to the type specified by $linktype. Returns -1
           on failure.

       <b>pcap_datalink_name_to_val($name)</b>
           Translates a data link type name, which is a "DLT_"  name  with  the  "DLT_"  part  removed,  to  the
           corresponding data link type value. The translation is case-insensitive. Returns -1 on failure.

           <b>Example</b>

               $linktype = pcap_datalink_name_to_val('LTalk');  # returns DLT_LTALK

       <b>pcap_datalink_val_to_name($linktype)</b>
           Translates a data link type value to the corresponding data link type name.

           <b>Example</b>

               $name = pcap_datalink_val_to_name(DLT_LTALK);  # returns 'LTALK'

       <b>pcap_datalink_val_to_description($linktype)</b>
           Translates a data link type value to a short description of that data link type.

           <b>Example</b>

               $descr = pcap_datalink_val_to_description(DLT_LTALK);  # returns 'Localtalk'

       <b>pcap_snapshot($pcap)</b>
           Returns the snapshot length (snaplen) specified in the call to pcap_open_live().

       <b>pcap_is_swapped($pcap)</b>
           This  function  returns  true  if the endianness of the currently open savefile is different from the
           endianness of the machine.

       <b>pcap_major_version($pcap)</b>
           Return the major version number of the pcap library used to write the currently open savefile.

       <b>pcap_minor_version($pcap)</b>
           Return the minor version of the pcap library used to write the currently open savefile.

       <b>pcap_stats($pcap,</b> <b>\%stats)</b>
           Returns a hash containing information about the status of packet  capture  device  $pcap.   The  hash
           contains the following fields.

           This  function  is  supported  only  on  live captures, not on savefiles; no statistics are stored in
           savefiles, so no statistics are available when reading from a savefile.

           •   "ps_recv" - the number of packets received by the packet capture software.

           •   "ps_drop" - the number of packets dropped by the packet capture software.

           •   "ps_ifdrop" - the number of packets dropped by the network interface.

       <b>pcap_file($pcap)</b>
           Returns the filehandle associated with a savefile opened with pcap_open_offline() or "undef"  if  the
           device was opened with pcap_open_live().

       <b>pcap_fileno($pcap)</b>
           Returns the file number of the network device opened with pcap_open_live().

       <b>pcap_get_selectable_fd($pcap)</b>
           Returns,  on  Unix,  a file descriptor number for a file descriptor on which one can do a select() or
           poll() to wait for it to be possible to read packets without blocking, if such a  descriptor  exists,
           or -1, if no such descriptor exists. Some network devices opened with pcap_open_live() do not support
           select() or poll(), so -1 is returned for those devices.  See <b><a href="../man3/pcap.3.html">pcap</a></b>(3) for more details.

   <b>Error</b> <b>handling</b>
       <b>pcap_geterr($pcap)</b>
           Returns an error message for the last error associated with the packet capture device $pcap.

       <b>pcap_strerror($errno)</b>
           Returns a string describing error number $errno.

       <b>pcap_perror($pcap,</b> <b>$prefix)</b>
           Prints  the  text  of  the last error associated with descriptor $pcap on standard error, prefixed by
           $prefix.

   <b>Information</b>
       <b>pcap_lib_version()</b>
           Returns the name and version of the "pcap" library the module was linked against.

   <b>Perl</b> <b>specific</b> <b>functions</b>
       The following functions are specific to the Perl binding of libpcap.

       <b>pcap_perl_settings($setting)</b>
           Modify internal behaviour of the Perl interpreter.

           •   "PERL_SIGNALS_SAFE", "PERL_SIGNALS_UNSAFE" respectively enable safe or unsafe  signals  delivery.
               Returns the previous value of "PL_signals".  See "Signals handling".

               <b>Example:</b>

                   local $SIG{ALRM} = sub { pcap_breakloop() };
                   alarm 60;

                   pcap_perl_settings(PERL_SIGNALS_UNSAFE);
                   pcap_loop($pcap, 10, \&amp;process_packet, "");
                   pcap_perl_settings(PERL_SIGNALS_SAFE);

   <b>WinPcap</b> <b>specific</b> <b>functions</b>
       The following functions are only available with WinPcap, the Win32 port of the Pcap library.  If a called
       function is not available, it will cleanly croak().

       <b>pcap_createsrcstr(\$source,</b> <b>$type,</b> <b>$host,</b> <b>$port,</b> <b>$name,</b> <b>\$err)</b>
           Accepts  a  set of strings (host name, port, ...), and stores the complete source string according to
           the new format (e.g. "rpcap://1.2.3.4/eth0") in $source.

           This function is provided in order to help the user creating the source string according to  the  new
           format.  An unique source string is used in order to make easy for old applications to use the remote
           facilities.  Think about <b><a href="../man1/tcpdump.1.html">tcpdump</a>(1)</b>, for example, which has only one way to specify the interface  on
           which  the  capture  has  to  be started. However, GUI-based programs can find more useful to specify
           hostname, port and interface name separately. In that case, they can use this function to create  the
           source string before passing it to the pcap_open() function.

           Returns  0  if  everything  is  fine,  -1 if some errors occurred. The string containing the complete
           source is returned in the $source variable.

       <b>pcap_parsesrcstr($source,</b> <b>\$type,</b> <b>\$host,</b> <b>\$port,</b> <b>\$name,</b> <b>\$err)</b>
           Parse the source string and stores the pieces in which the source can be split in  the  corresponding
           variables.

           This  call  is the other way round of pcap_createsrcstr(). It accepts a null-terminated string and it
           returns the parameters related to the source.  This includes:

           •   the type of the source (file, WinPcap on a remote adapter, WinPcap on local  adapter),  which  is
               determined by the source prefix ("PCAP_SRC_IF_STRING" and so on);

           •   the host on which the capture has to be started (only for remote captures);

           •   the  raw  name  of the source (file name, name of the remote adapter, name of the local adapter),
               without the source prefix. The string returned does not include the type  of  the  source  itself
               (i.e. the string returned does not include "file://" or "rpcap://" or such).

           The user can omit some parameters in case it is not interested in them.

           Returns 0 if everything is fine, -1 if some errors occurred. The requested values (host name, network
           port, type of the source) are returned into the proper variables passed by reference.

       <b>pcap_open($source,</b> <b>$snaplen,</b> <b>$flags,</b> <b>$read_timeout,</b> <b>\$auth,</b> <b>\$err)</b>
           Open a generic source in order to capture / send (WinPcap only) traffic.

           The pcap_open() replaces all the pcap_open_xxx() functions with a single call.

           This  function  hides  the  differences  between  the different pcap_open_xxx() functions so that the
           programmer does not have to manage different opening function. In this way, the <u>true</u> open()  function
           is  decided  according  to  the source type, which is included into the source string (in the form of
           source prefix).

           Returns a pointer to a pcap descriptor which can be used  as  a  parameter  to  the  following  calls
           (compile()  and  so on) and that specifies an opened WinPcap session. In case of problems, it returns
           "undef" and the $err variable keeps the error message.

       <b>pcap_setbuff($pcap,</b> <b>$dim)</b>
           Sets the size of the kernel buffer associated with an adapter.  $dim specifies the size of the buffer
           in bytes.  The return value is 0 when the call succeeds, -1 otherwise.

           If an old buffer was already created with a previous call to setbuff(), it is deleted and its content
           is discarded.  open_live() creates a 1 MB buffer by default.

       <b>pcap_setmode($pcap,</b> <b>$mode)</b>
           Sets the working mode of the interface $pcap to  $mode.   Valid  values  for  $mode  are  "MODE_CAPT"
           (default capture mode) and "MODE_STAT" (statistical mode).

       <b>pcap_setmintocopy($pcap_t,</b> <b>$size)</b>
           Changes  the  minimum  amount of data in the kernel buffer that causes a read from the application to
           return (unless the timeout expires).

       <b>pcap_getevent($pcap)</b>
           Returns the "Win32::Event" object associated with the interface $pcap. Can be used to wait until  the
           driver's buffer contains some data without performing a read. See Win32::Event.

       <b>pcap_sendpacket($pcap,</b> <b>$packet)</b>
           Send  a  raw  packet  to  the  network.  $pcap is the interface that will be used to send the packet,
           $packet contains the data of the packet to send (including the various protocol headers). The MAC CRC
           doesn't need to be included, because  it  is  transparently  calculated  and  added  by  the  network
           interface driver. The return value is 0 if the packet is successfully sent, -1 otherwise.

       <b>pcap_sendqueue_alloc($memsize)</b>
           This  function allocates and returns a send queue, i.e. a buffer containing a set of raw packets that
           will be transmitted on the network with sendqueue_transmit().

           $memsize is the size, in bytes, of the queue, therefore it determines the maximum amount of data that
           the queue will contain. This memory is automatically deallocated when the queue ceases to exist.

       <b>pcap_sendqueue_queue($queue,</b> <b>\%header,</b> <b>$packet)</b>
           Adds a packet at the end of the send queue pointed by $queue. The packet header %header has the  same
           format as that passed to the loop() callback. $ackekt is a buffer with the data of the packet.

           The %headerr header structure is the same used by WinPcap and libpcap to store the packets in a file,
           therefore  sending a capture file is straightforward. "Raw packet" means that the sending application
           will have to include the protocol headers, since every packet is sent to the network <u>as</u> <u>is</u>.  The  CRC
           of  the  packets  needs  not  to be calculated, because it will be transparently added by the network
           interface.

       <b>pcap_sendqueue_transmit($pcap,</b> <b>$queue,</b> <b>$sync)</b>
           This function transmits the content of a queue to the wire. $pcapt is  the  interface  on  which  the
           packets will be sent, $queue is to a "send_queue" containing the packets to send, $sync determines if
           the  send  operation  must  be  synchronized:  if it is non-zero, the packets are sent respecting the
           timestamps, otherwise they are sent as fast as possible.

           The return value is the amount of bytes actually sent. If it is smaller than the size  parameter,  an
           error  occurred  during  the  send.  The  error  can  be  caused by a driver/adapter problem or by an
           inconsistent/bogus send queue.

</pre><h4><b>CONSTANTS</b></h4><pre>
       "Net::Pcap" exports by default the names of several  constants  in  order  to  ease  the  development  of
       programs. See "EXPORTS" for details about which constants are exported.

       Here  are  the  descriptions  of  a  few data link types. See <b><a href="../man3/pcap.3.html">pcap</a></b>(3) for a more complete description and
       semantics associated with each data link.

       •   "DLT_NULL" - BSD loopback encapsulation

       •   "DLT_EN10MB" - Ethernet (10Mb, 100Mb, 1000Mb, and up)

       •   "DLT_RAW" - raw IP

       •   "DLT_IEEE802" - IEEE 802.5 Token Ring

       •   "DLT_IEEE802_11" - IEEE 802.11 wireless LAN

       •   "DLT_FRELAY" - Frame Relay

       •   "DLT_FDDI" - FDDI

       •   "DLT_SLIP" - Serial Line IP

       •   "DLT_PPP" - PPP (Point-to-point Protocol)

       •   "DLT_PPP_SERIAL" - PPP over serial with HDLC encapsulation

       •   "DLT_PPP_ETHER" - PPP over Ethernet

       •   "DLT_IP_OVER_FC" - RFC  2625  IP-over-Fibre  Channel

       •   "DLT_AX25" - Amateur Radio AX.25

       •   "DLT_LINUX_IRDA" - Linux-IrDA

       •   "DLT_LTALK" - Apple  LocalTalk

       •   "DLT_APPLE_IP_OVER_IEEE1394" - Apple IP-over-IEEE 1394 (a.k.a. Firewire)

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       "arg%d not a scalar ref"
       "arg%d not a hash ref"
       "arg%d not a reference"
           <b>(F)</b> These errors occur if you forgot to give a reference to a function which expect one  or  more  of
           its arguments to be references.

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to "<a href="mailto:bug-Net-Pcap@rt.cpan.org">bug-Net-Pcap@rt.cpan.org</a>", or through the web interface at
       &lt;<a href="http://rt.cpan.org/Dist/Display.html">http://rt.cpan.org/Dist/Display.html</a>?Queue=Net-Pcap&gt;.  I will be notified, and then you'll automatically
       be notified of progress on your bug as I make changes.

       Currently known bugs:

       •   the "ps_recv" field is not correctly set; see <u>t/07-stats.t</u>

       •   pcap_file()  seems  to  always  returns "undef" for live connection and causes segmentation fault for
           dump files; see <u>t/10-fileno.t</u>

       •   pcap_fileno() is documented to return -1 when called on save file, but  seems  to  always  return  an
           actual file number.  See <u>t/10-fileno.t</u>

       •   pcap_dump_file() seems to corrupt something somewhere, and makes scripts dump core. See <u>t/05-dump.t</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       See the <u>eg/</u> and <u>t/</u> directories of the "Net::Pcap" distribution for examples on using this module.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
   <b>Perl</b> <b>Modules</b>
       the NetPacket or Net::Frame modules to assemble and disassemble packets.

       Net::Pcap::Reassemble for reassembly of TCP/IP fragments.

       POE::Component::Pcap for using "Net::Pcap" within POE-based programs.

       AnyEvent::Pcap for using "Net::Pcap" within AnyEvent-based programs.

       Net::Packet or NetPacket for decoding and creating network packets.

       Net::Pcap::Easy  is  a module which provides an easier, more Perl-ish API than "Net::Pcap" and integrates
       some facilities from Net::Netmask and NetPacket.

   <b>Base</b> <b>Libraries</b>
       <b><a href="../man3/pcap.3.html">pcap</a></b>(3), <b><a href="../man8/tcpdump.8.html">tcpdump</a></b>(8)

       The source code for the <a href="../man3/pcap.3.html">pcap</a>(3) library is available from &lt;<a href="http://www.tcpdump.org/">http://www.tcpdump.org/</a>&gt;

       The source code and binary for the Win32  version  of  the  pcap  library,  WinPcap,  is  available  from
       &lt;<a href="http://www.winpcap.org/">http://www.winpcap.org/</a>&gt;

   <b>Articles</b>
       <u>Hacking</u>  <u>Linux</u>  <u>Exposed:</u>  <u>Sniffing</u>  <u>with</u>  <u>Net::Pcap</u>  <u>to</u>  <u>stealthily</u>  <u>managing</u>  <u>iptables</u>  <u>rules</u>  <u>remotely</u>,
       &lt;<a href="http://www.hackinglinuxexposed.com/articles/20030730.html">http://www.hackinglinuxexposed.com/articles/20030730.html</a>&gt;

       <u>PerlMonks</u> <u>node</u> <u>about</u> <u>Net::Pcap</u>, &lt;<a href="http://perlmonks.org/">http://perlmonks.org/</a>?node_id=170648&gt;

</pre><h4><b>AUTHORS</b></h4><pre>
       Current maintainer is Sébastien Aperghis-Tramoni (SAPER) with the help of Tim Wilde (TWILDE).

       Complete list of authors &amp; contributors:

       •   Bo Adler (BOADLER) &lt;thumper (at) alumni.caltech.edu&gt;

       •   Craig Davison

       •   David Farrell

       •   David N. Blank-Edelman &lt;dnb (at) ccs.neu.edu&gt;

       •   James Rouzier (ROUZIER)

       •   Jean-Louis Morel (JLMOREL) &lt;jl_morel (at) bribes.org&gt;

       •   Marco Carnut (KCARNUT) &lt;kiko (at) tempest.com.br&gt;

       •   Patrice Auffret (GOMOR)

       •   Peter Lister (PLISTER) &lt;p.lister (at) cranfield.ac.uk&gt;

       •   Rafaël Garcia-Suarez (RGARCIA)

       •   Sébastien Aperghis-Tramoni (SAPER) &lt;sebastien (at) aperghis.net&gt;

       •   Tim Potter (TIMPOTTER) &lt;tpot (at) frungy.org&gt;

       •   Tim Wilde (TWILDE)

</pre><h4><b>HISTORY</b></h4><pre>
       The original version of "Net::Pcap", version 0.01, was written by Peter Lister using SWIG.

       Version 0.02 was created by Bo Adler with a few bugfixes but not uploaded to CPAN. It could be found  at:
       &lt;<a href="http://www.buttsoft.com/~thumper/software/perl/Net-Pcap/">http://www.buttsoft.com/~thumper/software/perl/Net-Pcap/</a>&gt;

       Versions 0.03 and 0.04 were created by Tim Potter who entirely rewrote "Net::Pcap" using XS and wrote the
       documentation, with the help of David N. Blank-Edelman for testing and general polishing.

       Version 0.05 was released by Marco Carnut with fixes to make it work with Cygwin and WinPcap.

       Version  0.04.02  was  independently  created by Jean-Louis Morel but not uploaded on the CPAN. It can be
       found here: &lt;<a href="http://www.bribes.org/perl/wnetpcap.html">http://www.bribes.org/perl/wnetpcap.html</a>&gt;

       Based on Tim Potter's version 0.04, it included fixes for WinPcap and  added  wrappers  for  several  new
       libpcap functions as well as WinPcap specific functions.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       To  Paul Johnson for his module Devel::Cover and his patience for helping me using it with XS code, which
       revealed very useful for writing more tests.

       To the beta-testers: Jean-Louis Morel, Max Maischen, Philippe Bruhat, David Morel, Scott Lanning,  Rafael
       Garcia-Suarez, Karl Y. Pradene.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2005-2016 Sébastien Aperghis-Tramoni and contributors.  All rights reserved.

       Copyright (C) 2003 Marco Carnut. All rights reserved.

       Copyright (C) 1999, 2000 Tim Potter. All rights reserved.

       Copyright (C) 1998 Bo Adler. All rights reserved.

       Copyright (C) 1997 Peter Lister. All rights reserved.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2024-10-20                                          <u><a href="../man3pm/Pcap.3pm.html">Pcap</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>