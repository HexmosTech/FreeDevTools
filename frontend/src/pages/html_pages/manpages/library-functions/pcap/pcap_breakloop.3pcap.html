<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pcap_breakloop - force a pcap_dispatch() or pcap_loop() call to return</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpcap0.8-dev">libpcap0.8-dev_1.10.5-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pcap_breakloop - force a pcap_dispatch() or pcap_loop() call to return

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;pcap/pcap.h&gt;</b>

       <b>void</b> <b>pcap_breakloop(pcap_t</b> <b>*);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>pcap_breakloop</b>()  sets  a  flag that will force <b><a href="../man3PCAP/pcap_dispatch.3PCAP.html">pcap_dispatch</a></b>(3PCAP) or <b><a href="../man3PCAP/pcap_loop.3PCAP.html">pcap_loop</a></b>(3PCAP) to return rather
       than looping; they will return the number of packets that have been processed so far, or <b>PCAP_ERROR_BREAK</b>
       if no packets have been processed so far.  If the loop  is  currently  blocked  waiting  for  packets  to
       arrive,  <b>pcap_breakloop</b>()  will  also,  on  some  platforms, wake up the thread that is blocked.  In this
       version of libpcap, the only platforms on which a wakeup is caused  by  <b>pcap_breakloop</b>()  are  Linux  and
       Windows,  and  the wakeup will only be caused when capturing on network interfaces; it will not be caused
       on other operating systems, and will not be caused on any OS when capturing on other types of devices.

       This routine is safe to use inside a signal handler on UNIX or a console control handler on  Windows,  or
       in  a  thread  other  than the one in which the loop is running, as it merely sets a flag that is checked
       within the loop and, on some platforms, performs a signal-safe and thread-safe API call.

       The flag is checked in loops reading packets from the OS -  a  signal  by  itself  will  not  necessarily
       terminate those loops - as well as in loops processing a set of packets returned by the OS.  <b>Note</b> <b>that</b> <b>if</b>
       <b>you</b> <b>are</b> <b>catching</b> <b>signals</b> <b>on</b> <b>UNIX</b> <b>systems</b> <b>that</b> <b>support</b> <b>restarting</b> <b>system</b> <b>calls</b> <b>after</b> <b>a</b> <b>signal,</b> <b>and</b> <b>calling</b>
       <b>pcap_breakloop()</b>  <b>in</b> <b>the</b> <b>signal</b> <b>handler,</b> <b>you</b> <b>must</b> <b>specify,</b> <b>when</b> <b>catching</b> <b>those</b> <b>signals,</b> <b>that</b> <b>system</b> <b>calls</b>
       <b>should</b> <b>NOT</b> <b>be</b> <b>restarted</b> <b>by</b> <b>that</b> <b>signal.</b>  <b>Otherwise,</b> <b>if</b> <b>the</b> <b>signal</b> <b>interrupted</b> <b>a</b> <b>call</b> <b>reading</b> <b>packets</b> <b>in</b> <b>a</b>
       <b>live</b> <b>capture,</b> <b>when</b> <b>your</b>  <b>signal</b>  <b>handler</b>  <b>returns</b>  <b>after</b>  <b>calling</b>  <b>pcap_breakloop(),</b>  <b>the</b>  <b>call</b>  <b>will</b>  <b>be</b>
       <b>restarted,</b> <b>and</b> <b>the</b> <b>loop</b> <b>will</b> <b>not</b> <b>terminate</b> <b>until</b> <b>more</b> <b>packets</b> <b>arrive</b> <b>and</b> <b>the</b> <b>call</b> <b>completes.</b>

       <b>Note</b>  <b>also</b>  <b>that,</b>  <b>in</b>  <b>a</b>  <b>multi-threaded</b>  <b>application,</b>  <b>if</b>  <b>one</b>  <b>thread</b>  <b>is</b>  <b>blocked</b>  <b>in</b> <b>pcap_dispatch(),</b>
       <b>pcap_loop(),</b> <b><a href="../man3PCAP/pcap_next.3PCAP.html">pcap_next</a>(3PCAP),</b> <b>or</b> <b><a href="../man3PCAP/pcap_next_ex.3PCAP.html">pcap_next_ex</a>(3PCAP),</b> <b>a</b> <b>call</b> <b>to</b> <b>pcap_breakloop()</b> <b>in</b> <b>a</b>  <b>different</b>  <b>thread</b>
       <b>will</b> <b>only</b> <b>unblock</b> <b>that</b> <b>thread</b> <b>on</b> <b>the</b> <b>platforms</b> <b>and</b> <b>capture</b> <b>devices</b> <b>listed</b> <b>above.</b>

       If  a  non-zero packet buffer timeout is set on the <b>pcap_t</b>, and you are capturing on a network interface,
       the thread will be unblocked with the timeout expires.  This is not guaranteed to happen unless at  least
       one  packet  has  arrived;  the  only platforms on which it happens are macOS, the BSDs, Solaris 11, AIX,
       Tru64 UNIX, and Windows.

       If you want to ensure that the loop will eventually be unblocked on any  other  platforms,  or  unblocked
       when capturing on a device other than a network interface, you will need to use whatever mechanism the OS
       provides  for  breaking  a  thread  out  of blocking calls in order to unblock the thread, such as thread
       cancellation or thread signalling in systems that support POSIX threads.

       <b>Note</b> <b>that</b> <b>if</b> <b>pcap_breakloop()</b> <b>unblocks</b> <b>the</b> <b>thread</b> <b>capturing</b> <b>packets,</b> <b>and</b> <b>you</b> <b>are</b> <b>running</b>  <b>on</b>  <b>a</b>  <b>platform</b>
       <b>that</b>  <b>supports</b>  <b>packet</b> <b>buffering,</b> <b>there</b> <b>may</b> <b>be</b> <b>packets</b> <b>in</b> <b>the</b> <b>buffer</b> <b>that</b> <b>arrived</b> <b>before</b> <b>pcap_breakloop()</b>
       <b>were</b> <b>called</b> <b>but</b> <b>that</b> <b>weren't</b> <b>yet</b> <b>provided</b> <b>to</b> <b>libpcap,</b> <b>those</b> <b>packets</b>  <b>will</b>  <b>not</b>  <b>have</b>  <b>been</b>  <b>processed</b>  <b>by</b>
       <b>pcap_dispatch()</b>  <b>or</b>  <b>pcap_loop().</b>   <b>If</b>  <b>pcap_breakloop()</b>  <b>was</b>  <b>called</b>  <b>in</b>  <b>order</b> <b>to</b> <b>terminate</b> <b>the</b> <b>capture</b>
       <b>process,</b> <b>then,</b> <b>in</b> <b>order</b> <b>to</b> <b>process</b> <b>those</b> <b>packets,</b> <b>you</b> <b>would</b> <b>have</b> <b>to</b>  <b>call</b>  <b>pcap_dispatch()</b>  <b>one</b>  <b>time</b>  <b>in</b>
       <b>order</b> <b>to</b> <b>process</b> <b>the</b> <b>last</b> <b>batch</b> <b>of</b> <b>packets.</b>  <b>This</b> <b>may</b> <b>block</b> <b>until</b> <b>the</b> <b>packet</b> <b>buffer</b> <b>timeout</b> <b>expires,</b> <b>so</b> <b>a</b>
       <b>non-zero</b> <b>packet</b> <b>buffer</b> <b>timeout</b> <b>must</b> <b>be</b> <b>used.</b>

       Note  that <b>pcap_next</b>() and <b>pcap_next_ex</b>() will, on some platforms, loop reading packets from the OS; that
       loop will not necessarily be terminated by a signal, so <b>pcap_breakloop</b>()  should  be  used  to  terminate
       packet processing even if <b>pcap_next</b>() or <b>pcap_next_ex</b>() is being used.

       <b>pcap_breakloop</b>()  does  not  guarantee  that  no  further packets will be processed by <b>pcap_dispatch</b>() or
       <b>pcap_loop</b>() after it is called; at most one more packet might be processed.

       If <b>PCAP_ERROR_BREAK</b> is returned from <b>pcap_dispatch</b>() or <b>pcap_loop</b>(), the flag is cleared, so a subsequent
       call will resume reading packets.  If a positive number is returned,  the  flag  is  not  cleared,  so  a
       subsequent call will return <b>PCAP_ERROR_BREAK</b> and clear the flag.

</pre><h4><b>BACKWARD</b> <b>COMPATIBILITY</b></h4><pre>
       This function became available in libpcap release 0.8.1.

       In releases prior to libpcap 1.10.0, <b>pcap_breakloop</b>() will not wake up a blocked thread on any platform.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3PCAP/pcap.3PCAP.html">pcap</a></b>(3PCAP)

                                                 8 December 2022                           <u><a href="../man3PCAP/PCAP_BREAKLOOP.3PCAP.html">PCAP_BREAKLOOP</a></u>(3PCAP)
</pre>
 </div>
</div></section>
</div>
</body>
</html>