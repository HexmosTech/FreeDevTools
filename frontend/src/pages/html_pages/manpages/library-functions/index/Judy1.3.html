<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Judy1  -  C  library  for creating and accessing a dynamic array of bits, using any value of a word as an</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libjudy-dev">libjudy-dev_1.0.5-5.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Judy1  -  C  library  for creating and accessing a dynamic array of bits, using any value of a word as an
       index.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>cc</b> <b>[flags]</b> <u>sourcefiles</u> <b>-lJudy</b>

       <b>#include</b> <b>&lt;Judy.h&gt;</b>

       <b>int</b>     <b>Rc_int;</b>                          <b>//</b> <b>return</b> <b>code</b> <b>-</b> <b>integer</b>
       <b>Word_t</b>  <b>Rc_word;</b>                         <b>//</b> <b>return</b> <b>code</b> <b>-</b> <b>unsigned</b> <b>word</b>
       <b>Word_t</b>  <b>Index,</b> <b>Index1,</b> <b>Index2,</b> <b>Nth;</b>

       <b>Pvoid_t</b> <b>PJ1Array</b> <b>=</b> <b>(Pvoid_t)</b> <b>NULL;</b>       <b>//</b> <b>initialize</b> <b>Judy1</b> <b>array</b>

       <b>J1S(</b> <b>Rc_int,</b>  <b>PJ1Array,</b> <b>Index);</b>          <b>//</b> <b>Judy1Set()</b>
       <b>J1U(</b> <b>Rc_int,</b>  <b>PJ1Array,</b> <b>Index);</b>          <b>//</b> <b>Judy1Unset()</b>
       <b>J1T(</b> <b>Rc_int,</b>  <b>PJ1Array,</b> <b>Index);</b>          <b>//</b> <b>Judy1Test()</b>
       <b>J1C(</b> <b>Rc_word,</b> <b>PJ1Array,</b> <b>Index1,</b> <b>Index2);</b> <b>//</b> <b>Judy1Count()</b>
       <b>J1BC(Rc_int,</b>  <b>PJ1Array,</b> <b>Nth,</b> <b>Index);</b>     <b>//</b> <b>Judy1ByCount()</b>
       <b>J1FA(Rc_word,</b> <b>PJ1Array);</b>                 <b>//</b> <b>Judy1FreeArray()</b>
       <b>J1MU(Rc_word,</b> <b>PJ1Array);</b>                 <b>//</b> <b>Judy1MemUsed()</b>
       <b>J1F(</b> <b>Rc_int,</b>  <b>PJ1Array,</b> <b>Index);</b>          <b>//</b> <b>Judy1First()</b>
       <b>J1N(</b> <b>Rc_int,</b>  <b>PJ1Array,</b> <b>Index);</b>          <b>//</b> <b>Judy1Next()</b>
       <b>J1L(</b> <b>Rc_int,</b>  <b>PJ1Array,</b> <b>Index);</b>          <b>//</b> <b>Judy1Last()</b>
       <b>J1P(</b> <b>Rc_int,</b>  <b>PJ1Array,</b> <b>Index);</b>          <b>//</b> <b>Judy1Prev()</b>
       <b>J1FE(Rc_int,</b>  <b>PJ1Array,</b> <b>Index);</b>          <b>//</b> <b>Judy1FirstEmpty()</b>
       <b>J1NE(Rc_int,</b>  <b>PJ1Array,</b> <b>Index);</b>          <b>//</b> <b>Judy1NextEmpty()</b>
       <b>J1LE(Rc_int,</b>  <b>PJ1Array,</b> <b>Index);</b>          <b>//</b> <b>Judy1LastEmpty()</b>
       <b>J1PE(Rc_int,</b>  <b>PJ1Array,</b> <b>Index);</b>          <b>//</b> <b>Judy1PrevEmpty()</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A Judy1 array is the equivalent of a bit array or bit map.  A bit is addressed by an  <b>Index</b>  (key).   The
       array  may be sparse, and the <b>Index</b> may be any word-sized <b>Value</b>.  If an index is present, it represents a
       set bit (a bit set represents an index present).  If an index is absent, it represents an  unset  bit  (a
       bit unset represents an absent index).

       A Judy1 array is allocated with a <b>NULL</b> pointer

       Pvoid_t PJ1Array = (Pvoid_t) NULL;
       Memory  to  support the array is allocated as bits are set, and released as bits are unset.  If the Judy1
       pointer (<b>PJ1Array</b>) is NULL, all bits are unset (and the Judy1 array requires no memory).

       As with an ordinary array, a Judy1 array contains no duplicate indexes.

       Using the macros described here, rather than the <b>Judy1</b> <b>function</b> <b>calls</b>, the default error handling sends a
       message to the standard error and terminates the program with <b><a href="../man1/exit.1.html">exit</a>(1)</b>.  For other error handling methods,
       see the <u>ERRORS</u> section.

       Because the macro forms are sometimes faster and  have  a  simpler  error  handling  interface  than  the
       equivalent <u>functions</u>, they are the preferred way of calling the Judy1 functions.

        <b>J1S(Rc_int,</b> <b>PJ1Array,</b> <b>Index);</b> // <b>Judy1Set()</b>
                      Set <b>Index</b>'s bit in the Judy1 array <b>PJ1Array</b>.

                      Return  <b>Rc_int</b>  set  to 1 if <b>Index</b>'s bit was previously unset (successful), otherwise 0 if
                      the bit was already set (unsuccessful).

        <b>J1U(Rc_int,</b> <b>PJ1Array,</b> <b>Index);</b> // <b>Judy1Unset()</b>
                      Unset <b>Index</b>'s bit in the Judy1 array <b>PJ1Array</b>; that is, remove <b>Index</b> from the Judy1 array.

                      Return <b>Rc_int</b> set to 1 if <b>Index</b>'s bit was previously set (successful), otherwise 0 if  the
                      bit was already unset (unsuccessful).

        <b>J1T(Rc_int,</b> <b>PJ1Array,</b> <b>Index);</b> // <b>Judy1Test()</b>
                      Test if <b>Index</b>'s bit is set in the Judy1 array <b>PJ1Array</b>.

                      Return  <b>Rc_int</b>  set to 1 if <b>Index</b>'s bit is set (<b>Index</b> is present), 0 if it is unset (<b>Index</b>
                      is absent).

        <b>J1C(Rc_word,</b> <b>PJ1Array,</b> <b>Index1,</b> <b>Index2);</b> // <b>Judy1Count()</b>
                      Count the number of indexes present in the Judy1 array <b>PJ1Array</b> between <b>Index1</b> and  <b>Index2</b>
                      (inclusive).

                      Return  <b>Rc_word</b>  set to the count.  A return <b>Value</b> of 0 can be valid as a count, or it can
                      indicate  a  special  case  for  fully  populated  array  (32-bit  machines  only).    See
                      <b>Judy1Count()</b> for ways to resolve this.

                      To count all indexes present (population) in a Judy1 bit array, use:

                      J1C(Rc_word, PJ1Array, 0, -1);
                      <b>Note:</b> The -1 promotes to the maximum index, that is, all ones.

        <b>J1BC(Rc_int,</b> <b>PJ1Array,</b> <b>Nth,</b> <b>Index);</b> // <b>Judy1ByCount()</b>
                      Locate  the  <b>Nth</b>  index  that  is present in the Judy1 array <b>PJ1Array</b> (<b>Nth</b> = 1 returns the
                      first index present).  To refer to the last index in a fully populated array (all  indexes
                      present, which is rare), use <b>Nth</b> = 0.

                      Return  <b>Rc_int</b>  set  to 1 and <b>Index</b> set to the <b>Nth</b> index if found, otherwise return <b>Rc_int</b>
                      set to 0 (the <b>Value</b> of <b>Index</b> contains no useful information).

        <b>J1FA(Rc_word,</b> <b>PJ1Array);</b> // <b>Judy1FreeArray()</b>
                      Free the entire Judy1 array <b>PJ1Array</b> (much faster than using a <b>J1N()</b>, <b>J1U()</b> loop).

                      Return <b>Rc_word</b> set to the number of bytes freed, and <b>PJ1Array</b> set to <b>NULL</b>.

        <b>J1MU(Rc_word,</b> <b>PJ1Array);</b> // <b>Judy1MemUsed()</b>
                      Return <b>Rc_word</b> set to the number of bytes of  memory  currently  in  use  by  Judy1  array
                      <b>PJ1Array</b>.  This  is  a very fast routine, and may be used after a <b>J1S()</b> or <b>J1U()</b> call with
                      little performance impact.

        <b>Judy1</b> <b>Search</b> <b>Functions</b>
                      The Judy1 search functions allow you to search for set or unset bits in  the  array.   You
                      may  search  inclusively  or exclusively, in either forward or reverse directions.  All of
                      the search functions use a similar calling sequence.  <b>Rc_int</b> is returned set to  1  for  a
                      successful  search  and  the  found <b>Index</b> is returned.  <b>Rc_int</b> is returned set to 0 for an
                      unsuccessful search, and <b>Index</b> contains no useful information.   The  return  code  <b>Rc_int</b>
                      must be checked prior to using the returned <b>Index</b>, since a search failure is possible.

        <b>J1F(Rc_int,</b> <b>PJ1Array,</b> <b>Index);</b> // <b>Judy1First()</b>
                      Search (inclusive) for the first index present that is equal to or greater than the passed
                      <b>Index</b>.   (Start  with <b>Index</b> = 0 to find the first index in the array.)  <b>J1F()</b> is typically
                      used to <u>begin</u> a sorted-order scan of the indexes present in a Judy1 array.

        <b>J1N(Rc_int,</b> <b>PJ1Array,</b> <b>Index);</b> // <b>Judy1Next()</b>
                      Search (exclusive) for the next index present that  is  greater  than  the  passed  <b>Index</b>.
                      <b>J1N()</b>  is typically used to <u>continue</u> a sorted-order scan of the indexes present in a Judy1
                      array, or to locate a "neighbor" of a given index.

        <b>J1L(Rc_int,</b> <b>PJ1Array,</b> <b>Index);</b> // <b>Judy1Last()</b>
                      Search (inclusive) for the last index present that is equal to or  less  than  the  passed
                      <b>Index</b>.   (Start  with <b>Index</b> = -1, that is, all ones, to find the last index in the array.)
                      <b>J1L()</b> is typically used to <u>begin</u> a reverse-sorted-order scan of the indexes present  in  a
                      Judy1 array.

        <b>J1P(Rc_int,</b> <b>PJ1Array,</b> <b>Index);</b> // <b>Judy1Prev()</b>
                      Search  (exclusive)  for  the  previous  index present that is less than the passed <b>Index</b>.
                      <b>J1P()</b> is typically used to <u>continue</u> a reverse-sorted-order scan of the indexes present  in
                      a Judy1 array, or to locate a "neighbor" of a given index.

        <b>J1FE(Rc_int,</b> <b>PJ1Array,</b> <b>Index);</b> // <b>Judy1FirstEmpty()</b>
                      Search  (inclusive) for the first absent index that is equal to or greater than the passed
                      <b>Index</b>.  (Start with <b>Index</b> = 0 to find the first index absent in the array.)

        <b>J1NE(Rc_int,</b> <b>PJ1Array,</b> <b>Index);</b> // <b>Judy1NextEmpty()</b>
                      Search (exclusive) for the next absent index that is greater than the passed <b>Index</b>.

        <b>J1LE(Rc_int,</b> <b>PJ1Array,</b> <b>Index);</b> // <b>Judy1LastEmpty()</b>
                      Search (inclusive) for the last absent index that is equal to  or  less  than  the  passed
                      <b>Index</b>.  (Start with <b>Index</b> = -1 to find the last index absent in the array.)

        <b>J1PE(Rc_int,</b> <b>PJ1Array,</b> <b>Index);</b> // <b>Judy1PrevEmpty()</b>
                      Search (exclusive) for the previous absent index that is less than the passed <b>Index</b>.

<b>ERRORS:</b> <b>See:</b> <u><b>Judy_3.htm#ERRORS</b></u>
</pre><h4><b>EXAMPLE</b></h4><pre>
       In  the  following  example,  errors  in  the  <b>J1S()</b>  or  <b>J1U()</b>  calls  go  to  a user-defined procedure,
       process_malloc_failure.  This is not needed when you use the default <b>JUDYERROR()</b> macro, since the default
       causes your program to exit on all failures, including <u>malloc()</u> failure.

       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;Judy.h&gt;

       int main()                       // Example program of Judy1 macro APIs
       {
          Word_t Index;                 // index (or key)
          Word_t Rcount;                // count of indexes (or bits set)
          Word_t Rc_word;               // full word return value
          int    Rc_int;                // boolean values returned (0 or 1)

          Pvoid_t PJ1Array = (Pvoid_t) NULL; // initialize Judy1 array

          Index = 123456;
          J1S(Rc_int, J1Array, Index);  // set bit at 123456
          if (Rc_int == JERR) goto process_malloc_failure;
          if (Rc_int == 1) printf("OK - bit successfully set at %lu\n", Index);
          if (Rc_int == 0) printf("BUG - bit already set at %lu\n", Index);

          Index = 654321;
          J1T(Rc_int, J1Array, Index);  // test if bit set at 654321
          if (Rc_int == 1) printf("BUG - set bit at %lu\n", Index);
          if (Rc_int == 0) printf("OK - bit not set at %lu\n", Index);

          J1C(Rcount, J1Array, 0, -1);  // count all bits set in array
          printf("%lu bits set in Judy1 array\n", Rcount);

          Index = 0;
          J1F(Rc_int, J1Array, Index);  // find first bit set in array
          if (Rc_int == 1) printf("OK - first bit set is at %lu\n", Index);
          if (Rc_int == 0) printf("BUG - no bits set in array\n");

          J1MU(Rc_word, J1Array);       // how much memory was used?
          printf("%lu Indexes used %lu bytes of memory\n", Rcount, Rc_word);

          Index = 123456;
          J1U(Rc_int, J1Array, Index);  // unset bit at 123456
          if (Rc_int == JERR) goto process_malloc_failure;
          if (Rc_int == 1) printf("OK - bit successfully unset at %lu\n", Index);
          if (Rc_int == 0) printf("BUG - bit was not set at %lu\n", Index);

          <a href="../man0/return.0.html">return</a>(0);
       }

</pre><h4><b>AUTHOR</b></h4><pre>
       Judy was invented by Doug Baskins and implemented -Packard.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/Judy.3.html">Judy</a></u>(3), <u><a href="../man3/JudyL.3.html">JudyL</a></u>(3), <u><a href="../man3/JudySL.3.html">JudySL</a></u>(3), <u><a href="../man3/JudyHS.3.html">JudyHS</a></u>(3),
       <u>malloc()</u>,
       the Judy website, <u><a href="http://judy.sourceforge.net">http://judy.sourceforge.net</a></u>, for more information and Application Notes.

                                                                                                        <u><a href="../man3/Judy1.3.html">Judy1</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>