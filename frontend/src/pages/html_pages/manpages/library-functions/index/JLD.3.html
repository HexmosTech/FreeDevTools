<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JudyL - C library for creating and accessing a dynamic array of words, using a word as an index.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libjudy-dev">libjudy-dev_1.0.5-5.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       JudyL - C library for creating and accessing a dynamic array of words, using a word as an index.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>cc</b> <b>[flags]</b> <u>sourcefiles</u> <b>-lJudy</b>

       <b>#include</b> <b>&lt;Judy.h&gt;</b>

       <b>int</b>      <b>Rc_int;</b>                          <b>//</b> <b>return</b> <b>code</b> <b>-</b> <b>integer</b>
       <b>Word_t</b>   <b>Rc_word;</b>                         <b>//</b> <b>return</b> <b>code</b> <b>-</b> <b>unsigned</b> <b>word</b>
       <b>Word_t</b>   <b>Index,</b> <b>Index1,</b> <b>Index2,</b> <b>Nth;</b>
       <b>PWord_t</b>  <b>PValue;</b>                          <b>//</b> <b>pointer</b> <b>to</b> <b>return</b> <b>value</b>
       <b>Pvoid_t</b> <b>PJLArray</b> <b>=</b> <b>(Pvoid_t)</b> <b>NULL;</b>        <b>//</b> <b>initialize</b> <b>JudyL</b> <b>array</b>

       <b>JLI(</b> <b>PValue,</b>  <b>PJLArray,</b> <b>Index);</b>          <b>//</b> <b>JudyLIns()</b>
       <b>JLD(</b> <b>Rc_int,</b>  <b>PJLArray,</b> <b>Index);</b>          <b>//</b> <b>JudyLDel()</b>
       <b>JLG(</b> <b>PValue,</b>  <b>PJLArray,</b> <b>Index);</b>          <b>//</b> <b>JudyLGet()</b>
       <b>JLC(</b> <b>Rc_word,</b> <b>PJLArray,</b> <b>Index1,</b> <b>Index2);</b> <b>//</b> <b>JudyLCount()</b>
       <b>JLBC(PValue,</b>  <b>PJLArray,</b> <b>Nth,</b> <b>Index);</b>     <b>//</b> <b>JudyLByCount()</b>
       <b>JLFA(Rc_word,</b> <b>PJLArray);</b>                 <b>//</b> <b>JudyLFreeArray()</b>
       <b>JLMU(Rc_word,</b> <b>PJLArray);</b>                 <b>//</b> <b>JudyLMemUsed()</b>
       <b>JLF(</b> <b>PValue,</b>  <b>PJLArray,</b> <b>Index);</b>          <b>//</b> <b>JudyLFirst()</b>
       <b>JLN(</b> <b>PValue,</b>  <b>PJLArray,</b> <b>Index);</b>          <b>//</b> <b>JudyLNext()</b>
       <b>JLL(</b> <b>PValue,</b>  <b>PJLArray,</b> <b>Index);</b>          <b>//</b> <b>JudyLLast()</b>
       <b>JLP(</b> <b>PValue,</b>  <b>PJLArray,</b> <b>Index);</b>          <b>//</b> <b>JudyLPrev()</b>
       <b>JLFE(Rc_int,</b>  <b>PJLArray,</b> <b>Index);</b>          <b>//</b> <b>JudyLFirstEmpty()</b>
       <b>JLNE(Rc_int,</b>  <b>PJLArray,</b> <b>Index);</b>          <b>//</b> <b>JudyLNextEmpty()</b>
       <b>JLLE(Rc_int,</b>  <b>PJLArray,</b> <b>Index);</b>          <b>//</b> <b>JudyLLastEmpty()</b>
       <b>JLPE(Rc_int,</b>  <b>PJLArray,</b> <b>Index);</b>          <b>//</b> <b>JudyLPrevEmpty()</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A  JudyL  array  is  the  equivalent  of an array of word-sized values.  A <b>Value</b> is addressed by an <b>Index</b>
       (key).  The array may be sparse, and the <b>Index</b> may be any word-sized number.  Memory to support the array
       is allocated as index/value pairs are inserted, and released as index/value pairs are deleted.   A  JudyL
       array can also be thought of as a mapper, that is "map" a word to another word/pointer.

       As with an ordinary array, there are no duplicate indexes in a JudyL array.

       The  value  may  be  used as a scalar, or a pointer to a structure or block of data (or even another Judy
       array).

       A JudyL array is allocated with a <b>NULL</b> pointer

       Pvoid_t PJLArray = (Pvoid_t) NULL;

       Using the macros described here, rather than the <b>JudyL</b> <b>function</b> <b>calls</b>, the default error handling sends a
       message to the standard error and terminates  the  program  with  <u><a href="../man1/exit.1.html">exit</a>(1);</u>.   For  other  error  handling
       methods, see the <u>ERRORS</u> section.  <u>JLI</u>( PValue,  PJLArray, Index);          // <b>JudyLIns()</b>

       Because  the  macro  forms  are  sometimes  faster  and  have a simpler error handling interface than the
       equivalent <b>JudyL</b> <b>functions</b>, they are the preferred way of calling the JudyL functions.

        <b>JLI(PValue,</b> <b>PJLArray,</b> <b>Index)</b> // <b>JudyLIns()</b>
                      Insert an <b>Index</b> and <b>Value</b> into the JudyL array <b>PJLArray</b>.  If  the  <b>Index</b>  is  successfully
                      inserted,  the  <b>Value</b>  is initialized to 0. If the <b>Index</b> was already present, the <b>Value</b> is
                      not modified.

                      Return <b>PValue</b> pointing to <b>Value</b>.  Your program can use this  pointer  to  read  or  modify
                      <b>Value</b>  until  the next <b>JLI()</b> (insert), <b>JLD()</b> (delete) or <b>JLFA()</b> (freearray) is executed on
                      <b>PJLArray</b>. Examples:

                      *PValue = 1234;
                      Value = *PValue;

                      Return <b>PValue</b> set to <b>PJERR</b> if a <u>malloc()</u> fail occured.  <b>Note</b>: <b>JLI()</b> and  <b>JLD()</b>  reorganize
                      the  JudyL array.  Therefore, <b>PValue</b> returned from previous <b>JudyL</b> calls become invalid and
                      must be re-acquired.

        <b>JLD(Rc_int,</b> <b>PJLArray,</b> <b>Index)</b> // <b>JudyLDel()</b>
                      Delete the <b>Index</b>/<b>Value</b> pair from the JudyL array.

                      Return <b>Rc_int</b> set to 1 if successful.  Return <b>Rc_int</b> set to 0 if <b>Index</b>  was  not  present.
                      Return <b>Rc_int</b> set to <b>JERR</b> if a <u>malloc()</u> fail occured.

        <b>JLG(PValue,</b> <b>PJLArray,</b> <b>Index)</b> // <b>JudyLGet()</b>
                      Get the pointer <b>PValue</b> associated with <b>Index</b> in the <b>PJLArray</b> Judy array.

                      Return  <b>PValue</b> pointing to <b>Value</b>.  Return <b>PValue</b> set to <b>NULL</b> if the <b>Index</b> was not present.
                      Return <b>PValue</b> set to <b>PJERR</b> if a <u>malloc()</u> fail occured.

        <b>JLC(Rc_word,</b> <b>PJLArray,</b> <b>Index1,</b> <b>Index2)</b> // <b>JudyLCount()</b>
                      Count the number of indexes present in the JudyL array <b>PJLArray</b> between <b>Index1</b> and  <b>Index2</b>
                      (inclusive).

                      Return <b>Rc_word</b> set to the count.  A return value of 0 can be valid as a count.

                      To count all indexes present in a JudyL array, use:

                      JLC(Rc_word, PJLArray, 0, -1);

        <b>JLBC(PValue,</b> <b>PJLArray,</b> <b>Nth,</b> <b>Index)</b> // <b>JudyLByCount()</b>
                      Locate  the  <b>Nth</b>  index  that  is present in the JudyL array <b>PJLArray</b> (<b>Nth</b> = 1 returns the
                      first index present).

                      Return <b>PValue</b> pointing to its <b>Value</b> and <b>Index</b> set to the <b>Nth</b>  index  if  found,  otherwise
                      return <b>PValue</b> set to <b>NULL</b> (the value of <b>Index</b> is undefined).

        <b>JLFA(Rc_word,</b> <b>PJLArray)</b> // <b>JudyLFreeArray()</b>
                      Given  a  pointer to a JudyL array, free the entire array (much faster than using a <b>JLN()</b>,
                      <b>JLD()</b> loop).

                      Return <b>Rc_word</b> set to the number of bytes freed and <b>PJLArray</b> set to <b>NULL</b>.

        <b>JLMU(Rc_word,</b> <b>PJLArray)</b> // <b>JudyLMemUsed()</b>
                      Return <b>Rc_word</b> set to the number of bytes of memory <u>malloc()</u>'ed by <b>PJLArray</b>.   This  is  a
                      very  fast  routine,  and  may  be used before and after a <b>JLI()</b> or <b>JLD()</b> call with little
                      performance impact.

        <b>JudyL</b> <b>Search</b> <b>Functions</b>
                      <b>JLF()</b>, <b>JLN()</b>, <b>JLL()</b>, <b>JLP()</b> allow you to search for indexes in the array.  You  may  search
                      inclusively or exclusively, in either forward or reverse directions.  If successful, <b>Index</b>
                      is  returned  set  to  the found index, and <b>PValue</b> is returned set to a pointer to <b>Index</b>'s
                      <b>Value</b>.  If unsuccessful, <b>PValue</b> is returned set to <b>NULL</b>,  and  <b>Index</b>  contains  no  useful
                      information.   <b>PValue</b>  must  be  tested  for non-<b>NULL</b> prior to using <b>Index</b>, since a search
                      failure is possible.

                      <b>JLFE()</b>, <b>JLNE()</b>, <b>JLLE()</b>, <b>JLPE()</b> allow you to  search  for  indexes  that  are  not  present
                      ("empty")  in  the array.  You may search inclusively or exclusively, in either forward or
                      reverse directions.  If successful, <b>Index</b> is returned  set  to  a  not  present  ("empty")
                      index, and <b>Rc_int</b> is returned set to 1.  If unsuccessful, <b>Rc_int</b> is returned set to 0, and
                      and  <b>Index</b>  contains  no useful information.  <b>Rc_int</b> must be checked prior to using <b>Index</b>,
                      since a search failure is possible.

        <b>JLF(PValue,</b> <b>PJLArray,</b> <b>Index)</b> // <b>JudyLFirst()</b>
                      Search (inclusive) for the first index present that is equal to or greater than the passed
                      <b>Index</b>.  (Start with <b>Index</b> = 0 to find the first index in the array.)  <b>JLF()</b>  is  typically
                      used to <u>begin</u> a sorted-order scan of the indexes present in a JudyL array.

        <b>JLN(PValue,</b> <b>PJLArray,</b> <b>Index)</b> // <b>JudyLNext()</b>
                      Search  (exclusive)  for  the  next  index  present that is greater than the passed <b>Index</b>.
                      <b>JLN()</b> is typically used to <u>continue</u> a sorted-order scan of the indexes present in a  JudyL
                      array, or to locate a "neighbor" of a given index.

        <b>JLL(PValue,</b> <b>PJLArray,</b> <b>Index)</b> // <b>JudyLLast()</b>
                      Search  (inclusive)  for  the  last index present that is equal to or less than the passed
                      <b>Index</b>.  (Start with <b>Index</b> = -1, that is, all ones, to find the last index in  the  array.)
                      <b>JLL()</b>  is  typically used to <u>begin</u> a reverse-sorted-order scan of the indexes present in a
                      JudyL array.

        <b>JLP(PValue,</b> <b>PJLArray,</b> <b>Index)</b> // <b>JudyLPrev()</b>
                      Search (exclusive) for the previous index present that is  less  than  the  passed  <b>Index</b>.
                      <b>JLP()</b>  is typically used to <u>continue</u> a reverse-sorted-order scan of the indexes present in
                      a JudyL array, or to locate a "neighbor" of a given index.

        <b>JLFE(Rc_int,</b> <b>PJLArray,</b> <b>Index)</b> // <b>JudyLFirstEmpty()</b>
                      Search (inclusive) for the first index absent that is equal to or greater than the  passed
                      <b>Index</b>.  (Start with <b>Index</b> = 0 to find the first index absent in the array.)

        <b>JLNE(Rc_int,</b> <b>PJLArray,</b> <b>Index)</b> // <b>JudyLNextEmpty()</b>
                      Search (exclusive) for the next index absent that is greater than the passed <b>Index</b>.

        <b>JLLE(Rc_int,</b> <b>PJLArray,</b> <b>Index)</b> // <b>JudyLLastEmpty()</b>
                      Search  (inclusive)  for  the  last  index absent that is equal to or less than the passed
                      <b>Index</b>.  (Start with <b>Index</b> = -1, that is, all ones, to find the last index  absent  in  the
                      array.)

        <b>JLPE(Rc_int,</b> <b>PJLArray,</b> <b>Index)</b> // <b>JudyLPrevEmpty()</b>
                      Search (exclusive) for the previous index absent that is less than the passed <b>Index</b>.

</pre><h4><b>Multi-dimensional</b> <b>JudyL</b> <b>Arrays</b></h4><pre>
       Storing  a  pointer  to  another  JudyL array in a JudyL array's <b>Value</b> is a simple way to support dynamic
       multi-dimensional arrays.  These arrays (or trees) built using JudyL arrays  are  very  fast  and  memory
       efficient.  (In  fact, that is how JudySL and JudyHS are implemented).  An arbitrary number of dimensions
       can be realized this way.  To terminate the number of dimensions (or tree), the <b>Value</b> pointer  is  marked
       to  <b>NOT</b>  point  to another Judy array. A <b>JLAP_INVALID</b> flag is used in the least significant bit(s) of the
       pointer.  After the flag <b>JLAP_INVALID</b> is removed, it is used as a pointer to the users data.  The  <b>Judy.h</b>
       header file defines <b>JLAP_INVALID</b>.  See code fragment below.

       Note:  The  current version of <b>Judy.h</b> changed this flag from 0x4 to 0x1 to allow for a <u>malloc()</u> that does
       not deliver memory on an 8 byte aligned boundry (such as old versions of valgrind).

       The following example code segment can be used to determine whether or not a pointer  points  to  another
       JudyL:

       PValue = (PWord_t)PMultiDimArray;

       for (Dim = 0; ;Dim++)
       {
          if (PValue == (PWord_t)NULL) goto IndexNotFound;

          /* Advance to next dimension in array */
          JLG(PValue, (Pvoid_t)*PValue, Index[Dim]);

          /* Check if pointer to user buffer: */
          if (*PValue &amp; JLAP_INVALID)) break;
       }
       UPointer = (UPointer_t) (*PValue &amp; ~JLAP_INVALID);  // mask and cast.
       printf("User object pointer is 0x%lx\n", (Word_t) UPointer);
              &amp;.&amp;.&amp;.

       Note:  This works because <u>malloc()</u> guarantees to return a pointer with the least bit(s) == 0x0.  You must
       remove <b>JLAP_INVALID</b> before using the pointer.

<b>ERRORS:</b> <b>See:</b> <u><b>Judy_3.htm#ERRORS</b></u>
</pre><h4><b>EXAMPLE</b></h4><pre>
       Read a series of index/value pairs from the standard input, store in a JudyL array, and then print out in
       sorted order.

       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;Judy.h&gt;

       Word_t   Index;                     // array index
       Word_t   Value;                     // array element value
       Word_t * PValue;                    // pointer to array element value
       int      Rc_int;                    // return code

       Pvoid_t  PJLArray = (Pvoid_t) NULL; // initialize JudyL array

       while (scanf("%lu %lu", &amp;Index, &amp;Value))
       {
           JLI(PValue, PJLArray, Index);
           If (PValue == PJERR) goto process_malloc_failure;
           *PValue = Value;                 // store new value
       }
       // Next, visit all the stored indexes in sorted order, first ascending,
       // then descending, and delete each index during the descending pass.

       Index = 0;
       JLF(PValue, PJLArray, Index);
       while (PValue != NULL)
       {
           printf("%lu %lu\n", Index, *PValue));
           JLN(PValue, PJLArray, Index);
       }

       Index = -1;
       JLL(PValue, PJLArray, Index);
       while (PValue != NULL)
       {
           printf("%lu %lu\n", Index, *PValue));

           JLD(Rc_int, PJLArray, Index);
           if (Rc_int == JERR) goto process_malloc_failure;

           JLP(PValue, PJLArray, Index);
       }

</pre><h4><b>AUTHOR</b></h4><pre>
       Judy was invented by Doug Baskins and implemented -Packard.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/Judy.3.html">Judy</a></u>(3), <u><a href="../man3/Judy1.3.html">Judy1</a></u>(3), <u><a href="../man3/JudySL.3.html">JudySL</a></u>(3), <u><a href="../man3/JudyHS.3.html">JudyHS</a></u>(3),
       <u>malloc()</u>,
       <u><a href="http://judy.sourceforge.net">http://judy.sourceforge.net</a></u>, for more information and Application Notes.

                                                                                                        <u><a href="../man3/JudyL.3.html">JudyL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>