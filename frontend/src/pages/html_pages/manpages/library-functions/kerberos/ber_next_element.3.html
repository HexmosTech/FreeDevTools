<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ber_get_next,   ber_skip_tag,   ber_peek_tag,   ber_scanf,  ber_get_int,  ber_get_enum,  ber_get_stringb,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libldap-dev">libldap-dev_2.6.9+dfsg-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ber_get_next,   ber_skip_tag,   ber_peek_tag,   ber_scanf,  ber_get_int,  ber_get_enum,  ber_get_stringb,
       ber_get_stringa, ber_get_stringal, ber_get_stringbv,  ber_get_null,  ber_get_boolean,  ber_get_bitstring,
       ber_first_element,  ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for
       decoding

</pre><h4><b>LIBRARY</b></h4><pre>
       OpenLDAP LBER (liblber, -llber)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;lber.h&gt;</b>

       <b>ber_tag_t</b> <b>ber_get_next(Sockbuf</b> <b>*</b><u>sb</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>,</b> <b>BerElement</b> <b>*</b><u>ber</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_skip_tag(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_peek_tag(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_scanf(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>fmt</u><b>,</b> <b>...);</b>

       <b>ber_tag_t</b> <b>ber_get_int(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_int_t</b> <b>*</b><u>num</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_enum(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_int_t</b> <b>*</b><u>num</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_stringb(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>char</b> <b>*</b><u>buf</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_stringa(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>char</b> <b>**</b><u>buf</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_stringal(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>struct</b> <b>berval</b> <b>**</b><u>bv</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_stringbv(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>struct</b> <b>berval</b> <b>*</b><u>bv</u><b>,</b> <b>int</b> <u>alloc</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_null(BerElement</b> <b>*</b><u>ber</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_boolean(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_int_t</b> <b>*</b><u>bool</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_get_bitstringa(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>char</b> <b>**</b><u>buf</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>blen</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_first_element(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>,</b> <b>char</b> <b>**</b><u>cookie</u><b>);</b>

       <b>ber_tag_t</b> <b>ber_next_element(BerElement</b> <b>*</b><u>ber</u><b>,</b> <b>ber_len_t</b> <b>*</b><u>len</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>cookie</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These routines provide a subroutine interface to a simplified implementation of the Basic Encoding  Rules
       of  ASN.1.   The  version  of  BER  these routines support is the one defined for the LDAP protocol.  The
       encoding rules are the same as BER, except that only definite form lengths are used, and  bitstrings  and
       octet strings are always encoded in primitive form.  This man page describes the decoding routines in the
       lber  library.   See  <b><a href="../man3/lber-encode.3.html">lber-encode</a></b>(3)  for  details on the corresponding encoding routines.  Consult <b><a href="../man3/lbertypes.3.html">lber-</a></b>
       <b><a href="../man3/lbertypes.3.html">types</a></b>(3) for information about types, allocators, and deallocators.

       Normally, the only routines that need to be called by an application are <b>ber_get_next</b>() to get  the  next
       BER element and <b>ber_scanf</b>() to do the actual decoding.  In some cases, <b>ber_peek_tag</b>() may also need to be
       called  in  normal  usage.  The other routines are provided for those applications that need more control
       than <b>ber_scanf</b>() provides.  In general, these  routines  return  the  tag  of  the  element  decoded,  or
       LBER_ERROR if an error occurred.

       The  <b>ber_get_next</b>()  routine  is used to read the next BER element from the given Sockbuf, <u>sb</u>.  It strips
       off and returns the leading tag, strips off and returns the length of the entire element in <u>len</u>, and sets
       up <u>ber</u> for subsequent calls to <b>ber_scanf</b>() et al to decode the element. See <b><a href="../man3/lber-sockbuf.3.html">lber-sockbuf</a></b>(3)  for  details
       of the Sockbuf implementation of the <u>sb</u> parameter.

       The  <b>ber_scanf</b>()  routine  is  used to decode a BER element in much the same way that <b><a href="../man3/scanf.3.html">scanf</a></b>(3) works.  It
       reads from <u>ber</u>, a pointer to a BerElement such  as  returned  by  <b>ber_get_next</b>(),  interprets  the  bytes
       according  to  the  format  string  <u>fmt</u>,  and stores the results in its additional arguments.  The format
       string contains conversion specifications which are used to direct the interpretation of the BER element.
       The format string can contain the following characters.

              <b>a</b>  Octet string.  A char ** should be supplied.  Memory is allocated, filled with the contents  of
                 the  octet  string, null-terminated, and returned in the parameter.  The caller should free the
                 returned string using <b>ber_memfree</b>().

              <b>A</b>  Octet string.  A variant of "<b>a</b>".  A char ** should be supplied.  Memory  is  allocated,  filled
                 with the contents of the octet string, null-terminated, and returned in the parameter, unless a
                 zero-length  string would result; in that case, the arg is set to NULL.  The caller should free
                 the returned string using <b>ber_memfree</b>().

              <b>s</b>  Octet string.  A char * buffer should be  supplied,  followed  by  a  pointer  to  a  ber_len_t
                 initialized  to  the  size of the buffer.  Upon return, the null-terminated octet string is put
                 into the buffer, and the ber_len_t is set to the actual size of the octet string.

              <b>O</b>  Octet string.  A struct  ber_val  **  should  be  supplied,  which  upon  return  points  to  a
                 dynamically  allocated  struct  berval  containing the octet string and its length.  The caller
                 should free the returned structure using <b>ber_bvfree</b>().

              <b>o</b>  Octet string.  A  struct  ber_val  *  should  be  supplied,  which  upon  return  contains  the
                 dynamically  allocated  octet string and its length.  The caller should free the returned octet
                 string using <b>ber_memfree</b>().

              <b>m</b>  Octet string.  A struct ber_val * should be supplied, which  upon  return  contains  the  octet
                 string  and  its length.  The string resides in memory assigned to the BerElement, and must not
                 be freed by the caller.

              <b>b</b>  Boolean.  A pointer to a ber_int_t should be supplied.

              <b>e</b>  Enumeration.  A pointer to a ber_int_t should be supplied.

              <b>i</b>  Integer.  A pointer to a ber_int_t should be supplied.

              <b>B</b>  Bitstring.  A char ** should be supplied which will point to the  dynamically  allocated  bits,
                 followed by a ber_len_t *, which will point to the length (in bits) of the bitstring returned.

              <b>n</b>  Null.  No parameter is required.  The element is simply skipped if it is recognized.

              <b>v</b>  Sequence  of  octet  strings.   A  char  ***  should be supplied, which upon return points to a
                 dynamically allocated null-terminated array of char *'s containing the octet strings.  NULL  is
                 returned if the sequence is empty.  The caller should free the returned array and octet strings
                 using <b>ber_memvfree</b>().

              <b>V</b>  Sequence  of  octet  strings  with lengths.  A struct berval *** should be supplied, which upon
                 return points to a dynamically allocated null-terminated array of struct berval *'s  containing
                 the  octet  strings  and their lengths.  NULL is returned if the sequence is empty.  The caller
                 should free the returned structures using <b>ber_bvecfree</b>().

              <b>W</b>  Sequence of octet strings with lengths.  A BerVarray * should be supplied,  which  upon  return
                 points  to  a  dynamically  allocated array of struct berval's containing the octet strings and
                 their lengths. The array is terminated by a struct berval with a NULL  bv_val  string  pointer.
                 NULL  is  returned  if  the  sequence is empty.  The caller should free the returned structures
                 using <b>ber_bvarray_free</b>().

              <b>M</b>  Sequence of octet strings with lengths.  This is a  generalized  form  of  the  previous  three
                 formats.   A  void ** (ptr) should be supplied, followed by a ber_len_t * (len) and a ber_len_t
                 (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of
                 size (*len).  A struct berval will be filled starting at offset (off)  in  each  element.   The
                 strings in each struct berval reside in memory assigned to the BerElement and must not be freed
                 by  the  caller.  The array is terminated by a struct berval with a NULL bv_val string pointer.
                 NULL is returned if the sequence is empty.  The number of elements in the array is also  stored
                 in (*len) on return.  The caller should free the returned array using <b>ber_memfree</b>().

              <b>l</b>  Length of the next element.  A pointer to a ber_len_t should be supplied.

              <b>t</b>  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

              <b>T</b>  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

              <b>x</b>  Skip element.  The next element is skipped.

              <b>{</b>  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

              <b>}</b>  End sequence.  No parameter is required and no action is taken.

              <b>[</b>  Begin set.  No parameter is required.  The initial set tag and length are skipped.

              <b>]</b>  End set.  No parameter is required and no action is taken.

       The <b>ber_get_int</b>() routine tries to interpret the next element as an integer, returning the result in <u>num</u>.
       The tag of whatever it finds is returned on success, LBER_ERROR (-1) on failure.

       The  <b>ber_get_stringb</b>()  routine  is  used  to  read  an octet string into a preallocated buffer.  The <u>len</u>
       parameter should be initialized to the size of the buffer, and will  contain  the  length  of  the  octet
       string  read  upon  return.   The  buffer  should  be  big  enough  to take the octet string value plus a
       terminating NULL byte.

       The <b>ber_get_stringa</b>() routine is used to dynamically allocate space into which an octet string  is  read.
       The caller should free the returned string using <b>ber_memfree().</b>

       The  <b>ber_get_stringal</b>()  routine is used to dynamically allocate space into which an octet string and its
       length are read.  It takes a struct berval **, and returns the result  in  this  parameter.   The  caller
       should free the returned structure using <b>ber_bvfree().</b>

       The  <b>ber_get_stringbv</b>()  routine  is used to read an octet string and its length into the provided struct
       berval *. If the <u>alloc</u> parameter is zero, the string will reside in memory assigned  to  the  BerElement,
       and  must  not be freed by the caller. If the <u>alloc</u> parameter is non-zero, the string will be copied into
       dynamically allocated space which should be returned using <b>ber_memfree</b>().

       The <b>ber_get_null</b>() routine is used to read a NULL element.  It returns the tag of the  element  it  skips
       over.

       The  <b>ber_get_boolean</b>()  routine  is  used  to  read  a  boolean  value.   It  is called the same way that
       <b>ber_get_int</b>() is called.

       The <b>ber_get_enum</b>() routine is used to read  a  enumeration  value.   It  is  called  the  same  way  that
       <b>ber_get_int</b>() is called.

       The  <b>ber_get_bitstringa</b>()  routine is used to read a bitstring value.  It takes a char ** which will hold
       the dynamically allocated bits, followed by an ber_len_t *, which will point to the length (in  bits)  of
       the bitstring returned.  The caller should free the returned string using <b>ber_memfree</b>().

       The  <b>ber_first_element</b>()  routine  is  used to return the tag and length of the first element in a set or
       sequence.  It also returns in <u>cookie</u> a magic cookie parameter that should be passed to  subsequent  calls
       to ber_next_element(), which returns similar information.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Assume the variable <u>ber</u> contains a lightweight BER encoding of the following ASN.1 object:

             AlmostASearchRequest := SEQUENCE {
                 baseObject      DistinguishedName,
                 scope           ENUMERATED {
                     baseObject    (0),
                     singleLevel   (1),
                     wholeSubtree  (2)
                 },
                 derefAliases    ENUMERATED {
                     neverDerefaliases   (0),
                     derefInSearching    (1),
                     derefFindingBaseObj (2),
                     alwaysDerefAliases  (3)
                 },
                 sizelimit       INTEGER (0 .. 65535),
                 timelimit       INTEGER (0 .. 65535),
                 attrsOnly       BOOLEAN,
                 attributes      SEQUENCE OF AttributeType
             }

       The element can be decoded using <b>ber_scanf</b>() as follows.

             ber_int_t    scope, deref, size, time, attrsonly;
             char   *dn, **attrs;
             ber_tag_t tag;

             tag = ber_scanf( ber, "{aeeiib{v}}",
                 &amp;dn, &amp;scope, &amp;deref,
                 &amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

             if( tag == LBER_ERROR ) {
                     /* error */
             } else {
                     /* success */
             }

             ber_memfree( dn );
             ber_memvfree( attrs );

</pre><h4><b>ERRORS</b></h4><pre>
       If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

</pre><h4><b>NOTES</b></h4><pre>
       The return values for all of these functions are declared in the <b>&lt;lber.h&gt;</b> header file.  Some routines may
       dynamically allocate memory which must be freed by the caller using supplied deallocation routines.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/lber-encode.3.html">lber-encode</a></b>(3), <b><a href="../man3/lber-memory.3.html">lber-memory</a></b>(3), <b><a href="../man3/lber-sockbuf.3.html">lber-sockbuf</a></b>(3), <b><a href="../man3/lber-types.3.html">lber-types</a></b>(3)

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       <b>OpenLDAP</b>  <b>Software</b>  is  developed  and  maintained  by  The  OpenLDAP Project &lt;<a href="http://www.openldap.org/">http://www.openldap.org/</a>&gt;.
       <b>OpenLDAP</b> <b>Software</b> is derived from the University of Michigan LDAP 3.3 Release.

OpenLDAP 2.6.9+dfsg-2ubuntu1                       2024/11/26                                     <u><a href="../man3/LBER_DECODE.3.html">LBER_DECODE</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>