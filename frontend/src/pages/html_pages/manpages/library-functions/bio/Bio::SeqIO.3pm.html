<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::SeqIO - Handler for SeqIO Formats</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-perl-perl">libbio-perl-perl_1.7.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::SeqIO - Handler for SeqIO Formats

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Bio::SeqIO;

           $in  = Bio::SeqIO-&gt;new(-file =&gt; "inputfilename" ,
                                  -format =&gt; 'Fasta');
           $out = Bio::SeqIO-&gt;new(-file =&gt; "&gt;outputfilename" ,
                                  -format =&gt; 'EMBL');

           while ( my $seq = $in-&gt;next_seq() ) {
               $out-&gt;write_seq($seq);
           }

         # Now, to actually get at the sequence object, use the standard Bio::Seq
         # methods (look at Bio::Seq if you don't know what they are)

           use Bio::SeqIO;

           $in  = Bio::SeqIO-&gt;new(-file =&gt; "inputfilename" ,
                                  -format =&gt; 'genbank');

           while ( my $seq = $in-&gt;next_seq() ) {
              print "Sequence ",$seq-&gt;id, " first 10 bases ",
                    $seq-&gt;subseq(1,10), "\n";
           }

         # The SeqIO system does have a filehandle binding. Most people find this
         # a little confusing, but it does mean you can write the world's
         # smallest reformatter

           use Bio::SeqIO;

           $in  = Bio::SeqIO-&gt;newFh(-file =&gt; "inputfilename" ,
                                    -format =&gt; 'Fasta');
           $out = Bio::SeqIO-&gt;newFh(-format =&gt; 'EMBL');

           # World's shortest Fasta&lt;-&gt;EMBL format converter:
           print $out $_ while &lt;$in&gt;;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Bio::SeqIO is a handler module for the formats in the SeqIO set (eg, Bio::SeqIO::fasta). It is the
       officially sanctioned way of getting at the format objects, which most people should use.

       The Bio::SeqIO system can be thought of like biological file handles.  They are attached to filehandles
       with smart formatting rules (eg, genbank format, or EMBL format, or binary trace file format) and can
       either read or write sequence objects (Bio::Seq objects, or more correctly, Bio::SeqI implementing
       objects, of which Bio::Seq is one such object). If you want to know what to do with a Bio::Seq object,
       read Bio::Seq.

       The idea is that you request a stream object for a particular format.  All the stream objects have a
       notion of an internal file that is read from or written to. A particular SeqIO object instance is
       configured for either input or output. A specific example of a stream object is the Bio::SeqIO::fasta
       object.

       Each stream object has functions

          $stream-&gt;next_seq();

       and

          $stream-&gt;write_seq($seq);

       As an added bonus, you can recover a filehandle that is tied to the SeqIO object, allowing you to use the
       standard &lt;&gt; and print operations to read and write sequence objects:

           use Bio::SeqIO;

           $stream = Bio::SeqIO-&gt;newFh(-format =&gt; 'Fasta',
                                       -fh     =&gt; \*ARGV);
           # read from standard input or the input filenames

           while ( $seq = &lt;$stream&gt; ) {
               # do something with $seq
           }

       and

           print $stream $seq; # when stream is in output mode

       This makes the simplest ever reformatter

           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
           use strict;
           my $format1 = shift;
           my $format2 = shift || die
              "Usage: reformat format1 format2 &lt; input &gt; output";

           use Bio::SeqIO;

           my $in  = Bio::SeqIO-&gt;newFh(-format =&gt; $format1, -fh =&gt; \*ARGV );
           my $out = Bio::SeqIO-&gt;newFh(-format =&gt; $format2 );
           # Note: you might want to quote -format to keep older
           # perl's from complaining.

           print $out $_ while &lt;$in&gt;;

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
   <b>Bio::SeqIO-&gt;new()</b>
          $seqIO = Bio::SeqIO-&gt;new(-file   =&gt; 'seqs.fasta', -format =&gt; $format);
          $seqIO = Bio::SeqIO-&gt;new(-fh     =&gt; \*FILEHANDLE, -format =&gt; $format);
          $seqIO = Bio::SeqIO-&gt;new(-string =&gt; $string     , -format =&gt; $format);
          $seqIO = Bio::SeqIO-&gt;new(-format =&gt; $format);

       The <b>new()</b> class method constructs a new Bio::SeqIO object. The returned object can be used to retrieve or
       print Seq objects. <b>new()</b> accepts the following parameters:

       -file
            A file path to be opened for reading or writing.  The usual Perl conventions apply:

               'file'       # open file for reading
               '&gt;file'      # open file for writing
               '&gt;&gt;file'     # open file for appending
               '+&lt;file'     # open file read/write

            To read from or write to a piped command, open a filehandle and use the -fh option.

       -fh  You  may use <b>new()</b> with a opened filehandle, provided as a glob reference. For example, to read from
            STDIN:

               my $seqIO = Bio::SeqIO-&gt;new(-fh =&gt; \*STDIN);

            A string filehandle is handy if you want to modify the output in the memory, before printing it out.
            The following program reads in EMBL formatted entries from a file  and  prints  them  out  in  fasta
            format with some HTML tags:

              use Bio::SeqIO;
              use IO::String;
              my $in = Bio::SeqIO-&gt;new(-file =&gt; "emblfile",
                                       -format =&gt; 'EMBL');
              while ( my $seq = $in-&gt;next_seq() ) {
                  # the output handle is reset for every file
                  my $stringio = IO::String-&gt;new($string);
                  my $out = Bio::SeqIO-&gt;new(-fh =&gt; $stringio,
                                            -format =&gt; 'fasta');
                  # output goes into $string
                  $out-&gt;write_seq($seq);
                  # modify $string
                  $string =~ s|(&gt;)(\w+)|$1&lt;font color="Red"&gt;$2&lt;/font&gt;|g;
                  # print into STDOUT
                  print $string;
              }

            Filehandles can also be used to read from or write to a piped command:

              use Bio::SeqIO;
              #convert .fastq.gz to .fasta
              open my $zcat, 'zcat seq.fastq.gz |' or die $!;
              my $in=Bio::SeqIO-&gt;new(-fh=&gt;$zcat,
                                     -format=&gt;'fastq');
              my $out=Bio::SeqIO-&gt;new(-file=&gt;'&gt;seq.fasta',
                                      -format=&gt;'fasta');
              while (my $seq=$in-&gt;next_seq) {
                  $out-&gt;write_seq($seq)
              }

       -string
            A string to read the sequences from. For example:

               my $string = "&gt;seq1\nACGCTAGCTAGC\n";
               my $seqIO = Bio::SeqIO-&gt;new(-string =&gt; $string);

       -format
            Specify  the format of the file.  Supported formats include fasta, genbank, embl, swiss (SwissProt),
            Entrez Gene and tracefile formats such as abi (ABI) and scf. There are many  more,  for  a  complete
            listing see the SeqIO HOWTO (&lt;<a href="http://bioperl.org/howtos/SeqIO_HOWTO.html">http://bioperl.org/howtos/SeqIO_HOWTO.html</a>&gt;).

            If  no format is specified and a filename is given then the module will attempt to deduce the format
            from the filename suffix. If there is no suffix that Bioperl understands then  it  will  attempt  to
            guess the format based on file content. If this is unsuccessful then SeqIO will throw a fatal error.

            The format name is case-insensitive: 'FASTA', 'Fasta' and 'fasta' are all valid.

       -alphabet
            Sets  the  alphabet  ('dna',  'rna',  or  'protein'). When the alphabet is set then Bioperl will not
            attempt to guess what the alphabet is. This may be important because Bioperl does not  always  guess
            correctly.

       -flush
            By  default,  all  files  (or  filehandles)  opened for writing sequences will be flushed after each
            <b>write_seq()</b> (making the file immediately usable).  If you do not need this facility and  would  like
            to marginally improve the efficiency of writing multiple sequences to the same file (or filehandle),
            pass the -flush option '0' or any other value that evaluates as defined but false:

              my $gb = Bio::SeqIO-&gt;new(-file   =&gt; "&lt;gball.gbk",
                                       -format =&gt; "gb");
              my $fa = Bio::SeqIO-&gt;new(-file   =&gt; "&gt;gball.fa",
                                       -format =&gt; "fasta",
                                       -flush  =&gt; 0); # go as fast as we can!
              while($seq = $gb-&gt;next_seq) { $fa-&gt;write_seq($seq) }

       -seqfactory
            Provide a Bio::Factory::SequenceFactoryI object. See the <b>sequence_factory()</b> method.

       -locfactory
            Provide a Bio::Factory::LocationFactoryI object. See the <b>location_factory()</b> method.

       -objbuilder
            Provide a Bio::Factory::ObjectBuilderI object. See the <b>object_builder()</b> method.

   <b>Bio::SeqIO-&gt;newFh()</b>
          $fh = Bio::SeqIO-&gt;newFh(-fh =&gt; \*FILEHANDLE, -format=&gt;$format);
          $fh = Bio::SeqIO-&gt;newFh(-format =&gt; $format);
          # etc.

       This  constructor behaves like <b>new()</b>, but returns a tied filehandle rather than a Bio::SeqIO object.  You
       can read sequences from this object using the familiar &lt;&gt; operator, and write to it using  <b>print()</b>.   The
       usual  array  and  $_  semantics work.  For example, you can read all sequence objects into an array like
       this:

         @sequences = &lt;$fh&gt;;

       Other operations, such as <b>read()</b>, <b>sysread()</b>, <b>write()</b>, <b>close()</b>, and <b>printf()</b> are not supported.

</pre><h4><b>OBJECT</b> <b>METHODS</b></h4><pre>
       See below for more detailed summaries.  The main methods are:

   <b>$sequence</b> <b>=</b> <b>$seqIO-&gt;next_seq()</b>
       Fetch the next sequence from the stream, or nothing if no more.

   <b>$seqIO-&gt;write_seq($sequence</b> <b>[,$another_sequence,...])</b>
       Write the specified sequence(s) to the stream.

   <b>TIEHANDLE(),</b> <b>READLINE(),</b> <b>PRINT()</b>
       These provide the tie interface.  See perltie for more details.

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>Lists</b>
       User feedback is an integral part of the evolution of this and other Bioperl modules. Send your  comments
       and suggestions preferably to one of the Bioperl mailing lists.

       Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list:

        <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>

       rather  than to the module maintainer directly. Many experienced and responsive experts will be able look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>Bugs</b>
       Report bugs to the Bioperl bug tracking system to help us keep track the bugs and their resolution.   Bug
       reports can be submitted via the web:

         https://github.com/bioperl/bioperl-live/issues

</pre><h4><b>AUTHOR</b> <b>-</b> <b>Ewan</b> <b>Birney,</b> <b>Lincoln</b> <b>Stein</b></h4><pre>
       Email <a href="mailto:birney@ebi.ac.uk">birney@ebi.ac.uk</a>
             <a href="mailto:lstein@cshl.org">lstein@cshl.org</a>

</pre><h4><b>APPENDIX</b></h4><pre>
       The  rest  of the documentation details each of the object methods. Internal methods are usually preceded
       with a _

   <b>new</b>
        Title   : new
        Usage   : $stream = Bio::SeqIO-&gt;new(-file =&gt; 'sequences.fasta',
                                            -format =&gt; 'fasta');
        Function: Returns a new sequence stream
        Returns : A Bio::SeqIO stream initialised with the appropriate format
        Args    : Named parameters indicating where to read the sequences from or to
                  write them to:
                    -file   =&gt; filename, OR
                    -fh     =&gt; filehandle to attach to, OR
                    -string =&gt; string

                  Additional arguments, all with reasonable defaults:
                    -format     =&gt; format of the sequences, usually auto-detected
                    -alphabet   =&gt; 'dna', 'rna', or 'protein'
                    -flush      =&gt; 0 or 1 (default: flush filehandles after each write)
                    -seqfactory =&gt; sequence factory
                    -locfactory =&gt; location factory
                    -objbuilder =&gt; object builder

       See Bio::SeqIO::Handler

   <b>newFh</b>
        Title   : newFh
        Usage   : $fh = Bio::SeqIO-&gt;newFh(-file=&gt;$filename,-format=&gt;'Format')
        Function: Does a new() followed by an fh()
        Example : $fh = Bio::SeqIO-&gt;newFh(-file=&gt;$filename,-format=&gt;'Format')
                  $sequence = &lt;$fh&gt;;   # read a sequence object
                  print $fh $sequence; # write a sequence object
        Returns : filehandle tied to the Bio::SeqIO::Fh class
        Args    :

       See Bio::SeqIO::Fh

   <b>fh</b>
        Title   : fh
        Usage   : $obj-&gt;fh
        Function: Get or set the IO filehandle
        Example : $fh = $obj-&gt;fh;      # make a tied filehandle
                  $sequence = &lt;$fh&gt;;   # read a sequence object
                  print $fh $sequence; # write a sequence object
        Returns : filehandle tied to Bio::SeqIO class
        Args    : none

   <b>next_seq</b>
        Title   : next_seq
        Usage   : $seq = stream-&gt;next_seq
        Function: Reads the next sequence object from the stream and returns it.

                  Certain driver modules may encounter entries in the stream
                  that are either misformatted or that use syntax not yet
                  understood by the driver. If such an incident is
                  recoverable, e.g., by dismissing a feature of a feature
                  table or some other non-mandatory part of an entry, the
                  driver will issue a warning. In the case of a
                  non-recoverable situation an exception will be thrown.  Do
                  not assume that you can resume parsing the same stream
                  after catching the exception. Note that you can always turn
                  recoverable errors into exceptions by calling
                  $stream-&gt;<a href="../man2/verbose.2.html">verbose</a>(2).

        Returns : a Bio::Seq sequence object, or nothing if no more sequences
                  are available

        Args    : none

       See Bio::Root::RootI, Bio::Factory::SeqStreamI, Bio::Seq

   <b>write_seq</b>
        Title   : write_seq
        Usage   : $stream-&gt;write_seq($seq)
        Function: writes the $seq object into the stream
        Returns : 1 for success and 0 for error
        Args    : Bio::Seq object

   <b>format</b>
        Title   : format
        Usage   : $format = $stream-&gt;format()
        Function: Get the sequence format
        Returns : sequence format, e.g. fasta, fastq
        Args    : none

   <b>alphabet</b>
        Title   : alphabet
        Usage   : $self-&gt;alphabet($newval)
        Function: Set/get the molecule type for the Seq objects to be created.
        Example : $seqio-&gt;alphabet('protein')
        Returns : value of alphabet: 'dna', 'rna', or 'protein'
        Args    : newvalue (optional)
        Throws  : Exception if the argument is not one of 'dna', 'rna', or 'protein'

   <b>_load_format_module</b>
        Title   : _load_format_module
        Usage   : *INTERNAL SeqIO stuff*
        Function: Loads up (like use) a module at run time on demand
        Example :
        Returns :
        Args    :

   <b>_concatenate_lines</b>
        Title   : _concatenate_lines
        Usage   : $s = _concatenate_lines($line, $continuation_line)
        Function: Private. Concatenates two strings assuming that the second stems
                  from a continuation line of the first. Adds a space between both
                  unless the first ends with a dash.

                  Takes care of either arg being empty.
        Example :
        Returns : A string.
        Args    :

   <b>_filehandle</b>
        Title   : _filehandle
        Usage   : $obj-&gt;_filehandle($newval)
        Function: This method is deprecated. Call _fh() instead.
        Example :
        Returns : value of _filehandle
        Args    : newvalue (optional)

   <b>_guess_format</b>
        Title   : _guess_format
        Usage   : $obj-&gt;_guess_format($filename)
        Function: guess format based on file suffix
        Example :
        Returns : guessed format of filename (lower case)
        Args    :
        Notes   : formats that _filehandle() will guess include fasta,
                  genbank, scf, pir, embl, raw, gcg, ace, bsml, swissprot,
                  fastq and phd/phred

   <b>sequence_factory</b>
        Title   : sequence_factory
        Usage   : $seqio-&gt;sequence_factory($seqfactory)
        Function: Get/Set the Bio::Factory::SequenceFactoryI
        Returns : Bio::Factory::SequenceFactoryI
        Args    : [optional] Bio::Factory::SequenceFactoryI

   <b>object_factory</b>
        Title   : object_factory
        Usage   : $obj-&gt;object_factory($newval)
        Function: This is an alias to sequence_factory with a more generic name.
        Example :
        Returns : value of object_factory (a scalar)
        Args    : on set, new value (a scalar or undef, optional)

   <b>sequence_builder</b>
        Title   : sequence_builder
        Usage   : $seqio-&gt;sequence_builder($seqfactory)
        Function: Get/Set the Bio::Factory::ObjectBuilderI used to build sequence
                  objects. This applies to rich sequence formats only, e.g. genbank
                  but not fasta.

                  If you do not set the sequence object builder yourself, it
                  will in fact be an instance of L&lt;Bio::Seq::SeqBuilder&gt;, and
                  you may use all methods documented there to configure it.

        Returns : a Bio::Factory::ObjectBuilderI compliant object
        Args    : [optional] a Bio::Factory::ObjectBuilderI compliant object

   <b>location_factory</b>
        Title   : location_factory
        Usage   : $seqio-&gt;location_factory($locfactory)
        Function: Get/Set the Bio::Factory::LocationFactoryI object to be used for
                  location string parsing
        Returns : a Bio::Factory::LocationFactoryI implementing object
        Args    : [optional] on set, a Bio::Factory::LocationFactoryI implementing
                  object.

perl v5.32.1                                       2021-08-15                                    <u>Bio::<a href="../man3pm/SeqIO.3pm.html">SeqIO</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>