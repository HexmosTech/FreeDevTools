<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Graphics::Glyph - Base class for Bio::Graphics::Glyph objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-graphics-perl">libbio-graphics-perl_2.40-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Graphics::Glyph - Base class for Bio::Graphics::Glyph objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
       See Bio::Graphics::Panel.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Bio::Graphics::Glyph is the base class for all glyph objects.  Each glyph is a wrapper around an
       Bio:SeqFeatureI object, knows how to render itself on an Bio::Graphics::Panel, and has a variety of
       configuration variables.

       End developers will not ordinarily work directly with Bio::Graphics::Glyph objects, but with
       Bio::Graphics::Glyph::generic and its subclasses.  Similarly, most glyph developers will want to subclass
       from Bio::Graphics::Glyph::generic because the latter provides labeling and arrow-drawing facilities.

</pre><h4><b>METHODS</b></h4><pre>
       This section describes the class and object methods for Bio::Graphics::Glyph.

   <b>CONSTRUCTORS</b>
       Bio::Graphics::Glyph objects are constructed automatically by an Bio::Graphics::Glyph::Factory, and are
       not usually created by end-developer code.

       $glyph = Bio::Graphics::Glyph-&gt;new(-feature=&gt;$feature,-factory=&gt;$factory)
           Given  a  sequence  feature,  creates  an  Bio::Graphics::Glyph  object  to display it.  The <b>-feature</b>
           argument  points  to  the  Bio:SeqFeatureI   object   to   display,   and   <b>-factory</b>   indicates   an
           Bio::Graphics::Glyph::Factory  object  from which the glyph will fetch all its run-time configuration
           information.  Factories are created and manipulated by the Bio::Graphics::Panel object.

           A standard set of options are recognized.  See OPTIONS.

   <b>OBJECT</b> <b>METHODS</b>
       Once a glyph is created, it responds to a large number of methods.  In this section,  these  methods  are
       grouped into related categories.

       Retrieving glyph context:

       $factory = $glyph-&gt;factory
           Get the Bio::Graphics::Glyph::Factory associated with this object.  This cannot be changed once it is
           set.

       $panel = $glyph-&gt;panel
           Get the Bio::Graphics::Panel associated with this object.  This cannot be changed once it is set.

       $feature = $glyph-&gt;feature
           Get the sequence feature associated with this object.  This cannot be changed once it is set.

       $feature = $glyph-&gt;<b>parent_feature()</b>
           Within  callbacks  only,  the  <b>parent_feature()</b>  method returns the parent of the current feature, if
           there is one. Called with a numeric argument, ascends  the  parentage  tree:  <b><a href="../man1/parent_feature.1.html">parent_feature</a></b>(1)  will
           return the parent, <b><a href="../man2/parent_feature.2.html">parent_feature</a></b>(2) will return the grandparent, etc. If there is no parent, returns
           undef.

       $feature = $glyph-&gt;add_feature(@features)
           Add  the  list  of features to the glyph, creating subparts.  This is most common done with the track
           glyph returned by Bio::Graphics::Panel-&gt;<b>add_track()</b>.

           If the Bio::Graphics::Panel was initialized with <b>-feature_limit</b> set to a non-zero value,  then  calls
           to  a  track glyph's <b>add_feature()</b> method will maintain a count of features added to the track.  Once
           the feature count exceeds the value set in -feature_limit, additional features will displace existing
           ones in a way that effects a uniform sampling of the total feature set. This  is  useful  to  protect
           against  excessively large tracks. The total number of features added can be retrieved by calling the
           glyph's <b>feature_count()</b> method.

       $feature = $glyph-&gt;add_group(@features)
           This is similar to <b>add_feature()</b>, but the list  of  features  is  treated  as  a  group  and  can  be
           configured as a set.

       $glyph-&gt;finished
           When  you are finished with a glyph, you can call its <b>finished()</b> method in order to break cycles that
           would otherwise cause memory leaks.  <b>finished()</b> is typically only used by the Panel object.

       $subglyph = $glyph-&gt;make_subglyph($level,@sub_features)
           This method is called to create subglyphs from a  list  of  subfeatures.  The  $level  indicates  the
           current level of the glyph (top-level glyphs are level 0, subglyphs are level 1, etc).

           Ordinarily  this method simply calls $self-&gt;factory-&gt;make_subglyph($level,@sub_features). Override it
           in subclasses to create subglyphs of a particular type. For example:

            sub make_subglyph {
               my $self = shift;
               my $level = shift;
               my $factory = $self-&gt;factory;
               $factory-&gt;make_glyph($factory,'arrow',@_);
            }

       $count = $glyph-&gt;<b>feature_count()</b>
           Return the number of features added to this glyph via <b>add_feature()</b>.

       $flag = $glyph-&gt;<b>features_clipped()</b>
           If  the  panel  was  initialized  with  -feature_limit  set  to  a  non-zero  value,  then  calls  to
           <b>add_features()</b>  will  limit  the number of glyphs to the indicated value. If this value was exceeded,
           then <b>features_clipped()</b> will return true.

       Retrieving glyph options:

       $fgcolor = $glyph-&gt;fgcolor
       $bgcolor = $glyph-&gt;bgcolor
       $fontcolor = $glyph-&gt;fontcolor
       $fontcolor = $glyph-&gt;font2color
       $fillcolor = $glyph-&gt;fillcolor
           These methods return the configured foreground, background, font, alternative font, and  fill  colors
           for the glyph in the form of a GD::Image color index.

       $color = $glyph-&gt;tkcolor
           This  method returns a color to be used to flood-fill the entire glyph before drawing (currently used
           by the "track" glyph).

       ($left,$top,$right,$bottom) = $glyph-&gt;bounds($dx,$dy)
           Given the topleft coordinates of the glyph, return the bounding box of  its  contents,  exclusive  of
           padding.  This is typically called by the <b>draw()</b> and <b>draw_component()</b> methods to recover the position
           of the glyph.

       ($left,$top,$right,$bottom) = $glyph-&gt;calculate_boundaries($dx,$dy)
           An alias for <b>bounds()</b>, used by some glyphs for compatibility with older versions of this module.

       $width = $glyph-&gt;width([$newwidth])
           Return the width of the glyph,  not  including  left  or  right  padding.   This  is  ordinarily  set
           internally based on the size of the feature and the scale of the panel.

       $width = $glyph-&gt;layout_width
           Returns the width of the glyph including left and right padding.

       $width = $glyph-&gt;height
           Returns  the  height  of the glyph, not including the top or bottom padding.  This is calculated from
           the "height" option and cannot be changed.

       $font = $glyph-&gt;font
           Return the font for the glyph.

       $option = $glyph-&gt;option($option)
           Return the value of the indicated option.

       $index = $glyph-&gt;color($option_name)
           Given an option name that corresponds to a color (e.g. 'fgcolor') look up the option and translate it
           into a GD color index.

       $index = $glyph-&gt;translate_color($color)
           Given a symbolic or #RRGGBB-form color name, returns its GD index.

       $level = $glyph-&gt;level
           The "level" is the nesting level of the glyph.  Groups are level -1, top level glyphs  are  level  0,
           subparts (e.g. exons) are level 1 and so forth.

       @parts = $glyph-&gt;parts
           For  glyphs  that can contain subparts (e.g. the segments glyph), this method will return the list of
           subglyphs it contains. Subglyphs are created automatically  by  the  <b>new()</b>  method  and  are  created
           subject  to  the  maximum  recursion  depth  specified  by the <b>maxdepth()</b> method and/or the -maxdepth
           option.

       Setting an option:

       $glyph-&gt;configure(-name=&gt;$value)
           You may change a glyph option after it is created using <b>set_option()</b>.  This is most commonly used  to
           configure track glyphs.

       Retrieving information about the sequence:

       $start = $glyph-&gt;start
       $end   = $glyph-&gt;end
           These methods return the start and end of the glyph in base pair units.

       $offset = $glyph-&gt;offset
           Returns the offset of the segment (the base pair at the far left of the image).

       $length = $glyph-&gt;length
           Returns the length of the sequence segment.

       Retrieving formatting information:

       $top = $glyph-&gt;top
       $left = $glyph-&gt;left
       $bottom = $glyph-&gt;bottom
       $right = $glyph-&gt;right
           These methods return the top, left, bottom and right of the glyph in pixel coordinates.

       $height = $glyph-&gt;height
           Returns the height of the glyph.  This may be somewhat larger or smaller than the height suggested by
           the GlyphFactory, depending on the type of the glyph.

       $scale = $glyph-&gt;scale
           Get the scale for the glyph in pixels/bp.

       $height = $glyph-&gt;labelheight
           Return the height of the label, if any.

       $label = $glyph-&gt;label
           Return a human-readable label for the glyph.

       These methods are called by Bio::Graphics::Track during the layout process:

       $glyph-&gt;move($dx,$dy)
           Move the glyph in pixel coordinates by the indicated delta-x and delta-y values.

       ($x1,$y1,$x2,$y2) = $glyph-&gt;box
           Return the current position of the glyph.

       These methods are intended to be overridden in subclasses:

       $glyph-&gt;calculate_height
           Calculate the height of the glyph.

       $glyph-&gt;calculate_left
           Calculate the left side of the glyph.

       $glyph-&gt;calculate_right
           Calculate the right side of the glyph.

       $glyph-&gt;draw($gd,$left,$top)
           Optionally offset the glyph by the indicated amount and draw it onto the GD::Image object.

       $glyph-&gt;draw_label($gd,$left,$top)
           Draw the label for the glyph onto the provided GD::Image object, optionally offsetting by the amounts
           indicated in $left and $right.

       $glyph-&gt;<b>maxdepth()</b>
           This  returns  the  maximum number of levels of feature subparts that the glyph will recurse through.
           For example, returning 0 indicates that the glyph will only draw the top-level feature.  Returning  1
           indicates that it will only draw the top-level feature and one level of subfeatures. Returning 2 will
           descend  down  two  levels.  Overriding this method will speed up rendering by avoiding creating of a
           bunch of subglyphs that will never be drawn.

           The default behavior is to return undef (unlimited levels of descent) unless the -maxdepth option  is
           passed, in which case this number is returned.

           Note  that  Bio::Graphics::Glyph::generic  overrides  <b>maxdepth()</b> to return 0, meaning no descent into
           subparts will be performed.

       These methods are useful utility routines:

       @pixels = $glyph-&gt;map_pt(@bases);
           Map the list of base position, given in base pair units, into pixels, using  the  current  scale  and
           glyph position. This method will accept a single base position or an array.

       $glyph-&gt;filled_box($gd,$x1,$y1,$x2,$y2)
           Draw  a  filled  rectangle  with  the  appropriate foreground and fill colors, and pen width onto the
           GD::Image object given by $gd, using the provided rectangle coordinates.

       $glyph-&gt;filled_oval($gd,$x1,$y1,$x2,$y2)
           As above, but draws an oval inscribed on the rectangle.

       $glyph-&gt;exceeds_depth
           Returns true if descending into another level of  subfeatures  will  exceed  the  value  returned  by
           <b>maxdepth()</b>.

   <b>OPTIONS</b>
       The following options are standard among all Glyphs.  See individual glyph pages for more options.

       Also  try  out  the  glyph_help.pl  script,  which  attempts to document each glyph's shared and specific
       options and provides an interface for graphically inspecting the effect of different options.

         Option      Description                      Default
         ------      -----------                      -------

         -fgcolor      Foreground color               black

         -bgcolor      Background color               turquoise

         -fillcolor    Synonym for -bgcolor

         -linewidth    Line width                     1

         -height       Height of glyph                10

         -font         Glyph font                     gdSmallFont

         -connector    Connector type                 undef (false)

         -connector_color
                       Connector color                black

         -strand_arrow Whether to indicate            undef (false)
                        strandedness

         -stranded     Whether to indicate            undef (false)
                        strandedness
                        (same as above))

         -label        Whether to draw a label        undef (false)

         -description  Whether to draw a description  undef (false)

         -no_subparts  Set to true to prevent         undef (false)
                       drawing of the subparts
                       of a feature.

         -ignore_sub_part Give the types/methods of   undef
                       subparts to ignore (as a
                       space delimited list).

         -maxdepth     Specifies the maximum number   undef (unlimited)
                       child-generations to decend
                       when getting subfeatures

         -sort_order   Specify layout sort order      "default"

         -always_sort  Sort even when bumping is off  undef (false)

         -bump_limit   Maximum number of levels to bump undef (unlimited)

         -hilite       Highlight color                undef (no color)

         -link, -title, -target
                      These options are used when creating imagemaps
                      for display on the web.  See L&lt;Bio::Graphics::Panel/"Creating Imagemaps"&gt;.

       For glyphs that consist of multiple segments, the <b>-connector</b> option controls  what's  drawn  between  the
       segments.  The default is undef (no connector).  Options include:

          "hat"     an upward-angling conector
          "solid"   a straight horizontal connector
          "quill"   a decorated line with small arrows indicating strandedness
                    (like the UCSC Genome Browser uses)
          "dashed"  a horizontal dashed line.
          "crossed" a straight horizontal connector with an "X" on it
                     (Can be used when segments are not yet validated
                      by some internal experiments...)

       The <b>-connector_color</b> option controls the color of the connector, if any.

       The  label is printed above the glyph.  You may pass an anonymous subroutine to <b>-label</b>, in which case the
       subroutine will be invoked with the feature as its single argument and is expected to return  the  string
       to  use  as  the  label.   If you provide the numeric value "1" to <b>-label</b>, the label will be read off the
       feature's <b>seqname()</b>, <b>info()</b> and <b>primary_tag()</b> methods will be called until a suitable name is found.   To
       create a label with the text "1", pass the string "1 ".  (A 1 followed by a space).

       The  description  is  printed  below the glyph.  You may pass an anonymous subroutine to <b>-description</b>, in
       which case the subroutine will be invoked with the feature as its single  argument  and  is  expected  to
       return  the  string to use as the description.  If you provide the numeric value "1" to <b>-description</b>, the
       description will be read off the feature's <b>source_tag()</b> method.  To create a description  with  the  text
       "1", pass the string "1 ".  (A 1 followed by a space).

       In  the  case  of  ACEDB  Ace::Sequence feature objects, the feature's <b>info()</b>, <b>Brief_identification()</b> and
       <b>Locus()</b> methods will be called to create a suitable description.

       The <b>-strand_arrow</b> option, if true, requests that the glyph indicate which strand it  is  on,  usually  by
       drawing an arrowhead.  Not all glyphs will respond to this request.  For historical reasons, <b>-stranded</b> is
       a  synonym  for  this option. Multisegmented features will draw an arrowhead on each component unless you
       specify a value of "ends" to -strand_arrow, in which case only the  rightmost  component  (for  +  strand
       features) or the leftmost component (for - strand features) will have arrowheads.

       <b>sort_order</b>:  By  default,  features  are  drawn  with a layout based only on the position of the feature,
       assuring a maximal "packing" of the glyphs when bumped.  In  some  cases,  however,  it  makes  sense  to
       display the glyphs sorted by score or some other comparison, e.g. such that more "important" features are
       nearer  the  top  of the display, stacked above less important features.  The -sort_order option allows a
       few different built-in values for changing  the  default  sort  order  (which  is  by  "left"  position):
       "low_score"  (or  "high_score")  will  cause  features to be sorted from lowest to highest score (or vice
       versa).  "left" (or "default") and "right" values will cause features to be sorted by their  position  in
       the  sequence.   "longest"  (or  "shortest")  will  cause the longest (or shortest) features to be sorted
       first, and "strand" will cause the features to be sorted by strand: "+1" (forward) then "0" (unknown,  or
       NA) then "-1" (reverse).  Finally, "name" will sort by the display_name of the features.

       In  all  cases,  the  "left" position will be used to break any ties.  To break ties using another field,
       options may be strung together using a "|"  character;  e.g.  "strand|low_score|right"  would  cause  the
       features  to  be  sorted first by strand, then score (lowest to highest), then by "right" position in the
       sequence.

       Finally, a subroutine coderef with a $$ prototype  can  be  provided.   It  will  receive  two  <b>glyph</b>  as
       arguments  and  should return -1, 0 or 1 (see Perl's <b>sort()</b> function for more information).  For example,
       to sort a set of database search hits by bits (stored in the features' "score" fields), scaled by the log
       of the alignment length (with "start" position breaking any ties):

         sort_order = sub ($$) {
           my ($glyph1,$glyph2) = @_;
           my $a = $glyph1-&gt;feature;
           my $b = $glyph2-&gt;feature;
           ( $b-&gt;score/log($b-&gt;length)
                 &lt;=&gt;
             $a-&gt;score/log($a-&gt;length) )
                 ||
           ( $a-&gt;start &lt;=&gt; $b-&gt;start )
         }

       It is important to remember to use the $$ prototype as shown in  the  example.   Otherwise  Bio::Graphics
       will  quit  with  an  exception.  The  arguments are subclasses of Bio::Graphics::Glyph, not the features
       themselves.  While glyphs implement some, but not all, of the feature methods, to be safe  call  the  two
       glyphs' <b>feature()</b> methods in order to convert them into the actual features.

       The  '-always_sort' option, if true, will sort features even if bumping is turned off.  This is useful if
       you would like overlapping features to stack in a particular order.  Features towards the end of the list
       will overlay those towards the beginning of the sort order.

       The <b>-hilite</b> option draws a colored box behind each feature using the indicated color. Typically you  will
       pass it a code ref that returns a color name.  For example:

         -hilite =&gt; sub { my $name = shift-&gt;display_name;
                          return 'yellow' if $name =~ /XYZ/ }

       The  <b>-no_subparts</b>  option  will  prevent  the  glyph from searching its feature for subfeatures. This may
       enhance performance if you know in advance that none of your features contain subfeatures.

</pre><h4><b>SUBCLASSING</b> <b>Bio::Graphics::Glyph</b></h4><pre>
       By convention, subclasses are all lower-case.  Begin each subclass with a preamble like this one:

        package Bio::Graphics::Glyph::crossbox;

        use strict;
        use base qw(Bio::Graphics::Glyph);

       Then override the methods you need to.  Typically, just the <b>draw()</b> method will  need  to  be  overridden.
       However,  if you need additional room in the glyph, you may override <b>calculate_height()</b>, <b>calculate_left()</b>
       and <b>calculate_right()</b>.  Do not directly override <b>height()</b>, <b>left()</b> and <b>right()</b>, as  their  purpose  is  to
       cache the values returned by their calculating cousins in order to avoid time-consuming recalculation.

       A simple <b>draw()</b> method looks like this:

        sub draw {
         my $self = shift;
         $self-&gt;SUPER::draw(@_);
         my $gd = shift;

         # and draw a cross through the box
         my ($x1,$y1,$x2,$y2) = $self-&gt;calculate_boundaries(@_);
         my $fg = $self-&gt;fgcolor;
         $gd-&gt;line($x1,$y1,$x2,$y2,$fg);
         $gd-&gt;line($x1,$y2,$x2,$y1,$fg);
        }

       This  subclass  draws  a simple box with two lines criss-crossed through it.  We first call our inherited
       <b>draw()</b> method to generate the filled box and label.  We then call <b>calculate_boundaries()</b>  to  return  the
       coordinates  of the glyph, disregarding any extra space taken by labels.  We call <b>fgcolor()</b> to return the
       desired foreground color, and then call $gd-&gt;<b>line()</b> twice to generate the criss-cross.

       For more complex <b>draw()</b> methods, see Bio::Graphics::Glyph::transcript and Bio::Graphics::Glyph::segments.

       Please avoid using a specific image class (via "use GD" for example) within your glyph package.  Instead,
       rely  on  the  image  package  passed  to the <b>draw()</b> method. This approach allows for future expansion of
       supported image classes without requiring glyph redesign. If  you  need  access  to  the  specific  image
       classes such as Polygon, Image, or Font, generate them like such:

        sub draw {
         my $self = shift;
         my $image_class = shift;

         my $polygon_package = $self-&gt;polygon_package-&gt;new()
         ...
         }

</pre><h4><b>BUGS</b></h4><pre>
       Please report them.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Bio::DB::GFF::Feature,         Ace::Sequence,         Bio::Graphics::Panel,         Bio::Graphics::Track,
       Bio::Graphics::Glyph::Factory,   Bio::Graphics::Glyph::alignment,   Bio::Graphics::Glyph::anchored_arrow,
       Bio::Graphics::Glyph::arrow,         Bio::Graphics::Glyph::box,        Bio::Graphics::Glyph::broken_line,
       Bio::Graphics::Glyph::cds,     Bio::Graphics::Glyph::christmas_arrow,     Bio::Graphics::Glyph::crossbox,
       Bio::Graphics::Glyph::dashed_line,        Bio::Graphics::Glyph::diamond,       Bio::Graphics::Glyph::dna,
       Bio::Graphics::Glyph::dot,         Bio::Graphics::Glyph::dumbbell,         Bio::Graphics::Glyph::ellipse,
       Bio::Graphics::Glyph::ex,        Bio::Graphics::Glyph::extending_arrow,       Bio::Graphics::Glyph::flag,
       Bio::Graphics::Glyph::gene,     Bio::Graphics::Glyph::generic,     Bio::Graphics::Glyph::graded_segments,
       Bio::Graphics::Glyph::group,  Bio::Graphics::Glyph::heterogeneous_segments,  Bio::Graphics::Glyph::image,
       Bio::Graphics::Glyph::lightning,      Bio::Graphics::Glyph::line,      Bio::Graphics::Glyph::merge_parts,
       Bio::Graphics::Glyph::merged_alignment,     Bio::Graphics::Glyph::minmax,     Bio::Graphics::Glyph::oval,
       Bio::Graphics::Glyph::pentagram,     Bio::Graphics::Glyph::pinsertion,     Bio::Graphics::Glyph::primers,
       Bio::Graphics::Glyph::processed_transcript,                                Bio::Graphics::Glyph::protein,
       Bio::Graphics::Glyph::ragged_ends,                                    Bio::Graphics::Glyph::redgreen_box,
       Bio::Graphics::Glyph::redgreen_segment,                            Bio::Graphics::Glyph::repeating_shape,
       Bio::Graphics::Glyph::rndrect,    Bio::Graphics::Glyph::ruler_arrow,     Bio::Graphics::Glyph::saw_teeth,
       Bio::Graphics::Glyph::segmented_keyglyph,                                 Bio::Graphics::Glyph::segments,
       Bio::Graphics::Glyph::so_transcript,    Bio::Graphics::Glyph::span,    Bio::Graphics::Glyph::splice_site,
       Bio::Graphics::Glyph::stackedplot, Bio::Graphics::Glyph::ternary_plot, Bio::Graphics::Glyph::text_in_box,
       Bio::Graphics::Glyph::three_letters,   Bio::Graphics::Glyph::tic_tac_toe,  Bio::Graphics::Glyph::toomany,
       Bio::Graphics::Glyph::track,     Bio::Graphics::Glyph::transcript,     Bio::Graphics::Glyph::transcript2,
       Bio::Graphics::Glyph::translation,    Bio::Graphics::Glyph::triangle,    Bio::Graphics::Glyph::two_bolts,
       Bio::Graphics::Glyph::wave,   Bio::Graphics::Glyph::weighted_arrow,    Bio::Graphics::Glyph::whiskerplot,
       Bio::Graphics::Glyph::xyplot

</pre><h4><b>AUTHOR</b></h4><pre>
       Lincoln Stein &lt;<a href="mailto:lstein@cshl.org">lstein@cshl.org</a>&gt;

       Copyright (c) 2001 Cold Spring Harbor Laboratory

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.  See DISCLAIMER.txt for disclaimers of warranty.

perl v5.30.0                                       2019-11-25                          <u>Bio::Graphics::<a href="../man3pm/Glyph.3pm.html">Glyph</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>