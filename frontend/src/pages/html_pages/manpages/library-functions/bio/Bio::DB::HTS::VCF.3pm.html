<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copyright [2015-2018] EMBL-European Bioinformatics Institute</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-db-hts-perl">libbio-db-hts-perl_3.01-5_amd64</a> <br><br><pre>
</pre><h4><b>LICENSE</b></h4><pre>
       Copyright [2015-2018] EMBL-European Bioinformatics Institute

       Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
       compliance with the License.  You may obtain a copy of the License at

            <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>

       Unless required by applicable law or agreed to in writing, software distributed under the License is
       distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and limitations under the License.

</pre><h4><b>AUTHORS</b></h4><pre>
       Rishi Nag &lt;<a href="mailto:rishi@ebi.ac.uk">rishi@ebi.ac.uk</a>&gt;, original author.

       Alessandro Vullo "&lt;avullo at cpan.org&gt;", the current developer and maintainer.

</pre><h4><b>NAME</b></h4><pre>
       Bio::DB::HTS::VCF -- Read VCF/BCF data files

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides a Perl interface to the HTSlib library for reading variant calls stored in VCF and
       BCF file databases.

       The functions provided are for opening a VCF/BCF file, reading header values, querying specific
       chromosome intervals and then reading row values.

       A sweep set of methods allows running through rows one by one, either backwards or forwards through the
       file.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Bio::DB::HTS::VCF ;

         ### File Open ###
         my $v = Bio::DB::HTS::VCF-&gt;new( filename =&gt; "/path/to/myfile.vcf.gz" );

         # once the file has been opened, various global values can be read from the header
         my $h = $v-&gt;header();

         $h-&gt;get_seqnames() ;
         $h-&gt;version() ;  # read the VCF file version

         $h-&gt;num_samples() ;
         $h-&gt;get_sample_names() ; #return an array of sample names

         $h-&gt;num_seqnames() ;
         $h-&gt;get_seqnames() ; # return an array of sequence names

         ### Individual rows can be read in and fields accessed ###
         my $row = $v-&gt;next() ;

         # row functions
         $row-&gt;chromosome($h) ;
         $row-&gt;position() ;
         $row-&gt;id() ;
         $row-&gt;num_filters() ;
         $row-&gt;quality() ;

         # retrieve alleles
         my $num_alleles = $row-&gt;num_alleles();
         my $alleles = $row-&gt;get_alleles();
         my $allele_index = 1;
         for my $a (@$alleles) {
           printf( "(%s, %s)\n", $a, $row-&gt;get_variant_type($allele_index++) ) ;
         }

         # query filters
         $row-&gt;has_filter($h,"DP50");
         $row-&gt;has_filter($h,"."); # PASS filter check

         $row-&gt;get_info_type($h, "AF"); # one of "String", "Integer", "Float" or "Flag".
         $info_result = $row-&gt;get_info($h, "NS"); # [3]

         $row-&gt;get_format_type($h, "GT") ; # "String"
         $row-&gt;get_format($h, "DP") ; # [ 1, 8, 5 ]

         ### free memory associated with the row
         Bio::DB::HTS::VCF::Row-&gt;destroy($row);

         ### query specific locations
         my $iter = $v-&gt;query("20:1000000-1231000");
         while (my $result = $iter-&gt;next) {
           print $result-&gt;chromosome($h), $result-&gt;position(), $result-&gt;id(), $result-&gt;num_filters(), $result-&gt;quality(), "\n";
         }

</pre><h4><b>METHODS</b></h4><pre>
   <b>"new"</b>
       Opens a VCF/BCF file for reading. If the file is indexed (i.e. tabix for VCF, csi for BCF) the index is
       opened and used for querying arbitrary locations on the chromosomes.

       $vcf = Bio::DB::HTS::VCF-&gt;new($filepath)
        Returns an instance of Bio::DB::HTS::VCF.

   <b>"header"</b>
       Returns instance of Bio::DB::HTS::VCF::Header, representing the header of the file.

       $header = $vcf-&gt;<b>header()</b>

   <b>"num_variants"</b>
       Returns the number of variants (i.e. rows) of the file.

       $nv = $vcf-&gt;<b>num_variants()</b>;

   <b>"close"</b>
       Close the VCF/BCF file, allocated memory will be released, included the index, if present.

       $vcf-&gt;<b>close()</b>

   <b>"next"</b>
       Returns the next row (starting from the first one) read from the file.

       $row = $vcf-&gt;<b>next()</b>
           Returns an instance of Bio::DB::HTS::VCF::Row or undef if end of file is reached.

</pre><h4><b>Querying</b> <b>an</b> <b>indexed</b> <b>VCF/BCF</b> <b>file</b></h4><pre>
       If  the  file  is  indexed,  the  file can be queried for variants on a specified region.  Regions can be
       specified using either the "chr", "chr:start" or "chr:start-end" format, with start &lt;= end.

       Once an iterator is obtained, individual rows belonging to the result set can be sequentially accessed by
       iteratively invoking the iterator next method until it returns nothing.

   <b>"query"</b>
       $iterator = $vcf-&gt;query($region);
        Returns an instance of Bio::DB::HTS::VCF::Iterator or undef if the chromosome is not found in the  index
        or raises an exception in case the underlying HTSlib library cannot parse the region.

</pre><h4><b>HEADER</b> <b>METHODS</b></h4><pre>
       Once the file has been opened, various global values can be read from the header.

   <b>"version"</b>
       Returns the VCF file version, as a string

       $h-&gt;<b>version()</b>

   <b>"num_samples"</b>
       Returns the number of samples

       $h-&gt;<b>num_samples()</b>

   <b>"get_sample_names"</b>
       Returns the list of sample names

       $sample_names = $h-&gt;<b>get_sample_names()</b>
        Returns an array ref of strings representing the sample names

   <b>"get_seqnames"</b>
       Returns the number of sequence names

       $h-&gt;<b>num_seqnames()</b>

   <b>"get_seqnames"</b>
       Returns the list of sequence names

       $h-&gt;<b>get_seqnames()</b>
        Returns an array ref of strings representing the sequence names

   <b>"fmt_text"</b>
       Get header formatted text, as a string

       $h-&gt;<b>fmt_text()</b>
        Returns the text string representing the content of the header

</pre><h4><b>ROW</b> <b>METHODS</b></h4><pre>
       Individual  rows can be read in and fields accessed. To read a row use the next function, which returns a
       Bio::DB::HTS::VCF::Row instance.

       Various fields can then be read from the row object. Some of the functions to read these fields will need
       the header object supplied.

       $row-&gt;print($header)
             Returns a formatted textual representation of the row.

       $row-&gt;chromosome($header)
       $row-&gt;<b>position()</b>
       $row-&gt;<b>id()</b>
       $row-&gt;<b>quality()</b>
       $row-&gt;<b>reference()</b>

   <b>Accessing</b> <b>alleles</b> <b>information</b>
       $row-&gt;<b>num_alleles()</b>
         Returns the number of alleles

       $row-&gt;<b>get_alleles()</b>
         Returns the alleles as strings in an array ref

       The variant type of an allele can be determined using the index of the allele. The index  starts  from  1
       for the first allele:

       $row-&gt;<b>is_snp()</b>
         Returns a true value if the row refers to a SNP.

       $row-&gt;get_variant_type($allele_index)
         This will return one of the values as defined in htslib. As of v1.3.1 these are as follows.

         VCF_REF   0
         VCF_SNP   1
         VCF_MNP   2
         VCF_INDEL 4
         VCF_OTHER 8

   <b>Row</b> <b>filters</b>
       Each row object has filters that may or may not have been applied to it.

       $row-&gt;<b>num_filters()</b>
         Returns the number of filters of the row.

       $row-&gt;has_filter($header, $filter)
         Returns 0 if the filter is not present, 1 if it is present. The PASS filter is represented by a dot.

   <b>Accessing</b> <b>info</b> <b>fields</b>
       Each row may have additional info fields associated with each allele in the row.

       $row-&gt;get_info_type($header, $info_id)
         Returns  the  type  of  the  info  ID  as specified in the VCF file header, one of "String", "Integer",
         "Float" or "Flag".

       $row-&gt;get_info($header, $info_id) or $row-&gt;get_info($header)
         If an info_id string is passed, returns an array ref of values for that particular info field, one  for
         each  allele  in  the  row.  If the row does not have an item of that info, or it does not exist in the
         file, a string "ID_NOT_FOUND" will be returned.

         Alternatively, the <b>get_info()</b> method can be invoked by just passing the header. In this case, the whole
         info field is returned organised as a hash ref where keys are the info IDs  and  values  are  the  info
         fields for the corresponding ID.

   <b>Accessing</b> <b>format</b> <b>fields</b>
       Formats are dealt with similarly to info fields.

       $row-&gt;get_format_type($header, $format_id)
         Returns  the  type  of  the  format ID as specified in the VCF file header, one of "String", "Integer",
         "Float" or "Flag".

       $row-&gt;get_format($header, $format_id) or $row-&gt;get_format($header)
         If a format_id string is passed, returns an array ref of values for that particular format ID.  If  the
         row  does  not  have  an item of that format, or it does not exist in the file, a string "ID_NOT_FOUND"
         will be returned.

         Alternatively, the <b>get_format()</b> method can be invoked by just passing the  header.  In  this  case,  it
         returns the complete format specification as a hash ref of FORMAT_ID =&gt; [ FORMAT_ID_VALUE, ... ].

   <b>Accessing</b> <b>genotypes</b>
       Genotype records are currently returned as a series of integers, across all the samples for the row.

       $row-&gt;get_genotypes($header)
        Returns an array reference of integers representing genotype records.

</pre><h4><b>VCF</b> <b>SWEEP</b> <b>OBJECTS</b></h4><pre>
       Open  the file and process using sweeps. Note that the two methods maintain pointers that are independant
       of one another. Using the <b>next_row()</b> will start at the first row in the file and go on to the next row in
       subsequent reads. This is independant of <b>previous_row()</b> calls.  Similarly <b>previous_row()</b>  will  start  at
       the  last  row  and  read  backwards. However a call to <b>next_row()</b> is needed beforehand as the read fails
       otherwise.

       At the time of writing there are issues which seem to be due to the underlying HTSlib API calls, so using
       the <b>next()</b> function is preferable to using sweeps.

         use Bio::DB::HTS::VCF ;

         my $sweep = Bio::DB::HTS::VCFSweep-&gt;new(filename =&gt; "data/test.vcf.gz");
         $sweep-&gt;header;
         my $row_forwards = $sweep-&gt;next_row(); #returns first row in file
         my $row_backwards = $sweep-&gt;previous_row(); #returns last row in file
         my $row_forwards = $sweep-&gt;next_row(); # returns second row in file
         my $row_backwards = $sweep-&gt;previous_row(); #returns penultimate row in file

perl v5.40.0                                       2024-10-31                             <u>Bio::DB::HTS::<a href="../man3pm/VCF.3pm.html">VCF</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>