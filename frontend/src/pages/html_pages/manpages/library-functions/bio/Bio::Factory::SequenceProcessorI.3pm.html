<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Factory::SequenceProcessorI - Interface for chained sequence</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-perl-perl">libbio-perl-perl_1.7.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Factory::SequenceProcessorI - Interface for chained sequence
                                          processing algorithms

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Bio::SeqIO;
           use MySeqProcessor; # is-a Bio::Factory::SequenceProcessorI

           # obtain your source stream, e.g., an EMBL file
           my $seqin = Bio::SeqIO-&gt;new(-fh =&gt; \*STDIN, -format =&gt; 'embl');
           # create your processor (it must implement this interface)
           my $seqalgo = MySeqProcessor-&gt;new();
           # chain together
           $seqalgo-&gt;source_stream($seqin);
           # you could create more processors and chain them one after another
           # ...
           # finally, the last link in the chain is your SeqIO stream
           my $seqpipe = $seqalgo;

           # once you've established the pipeline, proceed as if you had a
           # single SeqIO stream
           while(my $seq = $seqpipe-&gt;next_seq()) {
               # ... do something ...
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This defines an interface that allows seamless chaining of sequence processing algorithms encapsulated in
       modules while retaining the overall Bio::SeqIO interface at the end of the pipeline.

       This is especially useful if you want an easily configurable processing pipeline of re-usable algorithms
       as building blocks instead of (hard-)coding the whole algorithm in a single script.

       There are literally no restrictions as to what an individual module can do with a sequence object it
       obtains from the source stream before it makes it available through its own <b>next_seq()</b> method. It can
       manipulate the sequence object, but otherwise keep it intact, but it can also create any number of new
       sequence objects from it, or it can discard some, or any combination thereof. The only requirement is
       that its <b>next_seq()</b> method return Bio::PrimarySeqI compliant objects. In order to play nice, if a
       processor creates new objects it should try to use the same sequence factory that the source stream uses,
       but this is not strongly mandated.

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>Lists</b>
       User feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments
       and suggestions preferably to the Bioperl mailing list.  Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list:

       <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather than to the module maintainer directly. Many experienced and reponsive experts will be able look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>Bugs</b>
       Report bugs to the Bioperl bug tracking system to help us keep track of the bugs and their resolution.
       Bug reports can be submitted via the web:

         https://github.com/bioperl/bioperl-live/issues

</pre><h4><b>AUTHOR</b> <b>-</b> <b>Hilmar</b> <b>Lapp</b></h4><pre>
       Email hlapp at gmx.net

</pre><h4><b>APPENDIX</b></h4><pre>
       The rest of the documentation details each of the object methods.  Internal methods are usually preceded
       with a _

   <b>source_stream</b>
        Title   : source_stream
        Usage   : $obj-&gt;source_stream($newval)
        Function: Get/set the source sequence stream for this sequence
                  processor.

                  An implementation is not required to allow set, but will
                  usually do so.

        Example :
        Returns : A Bio::Factory::SequenceStreamI compliant object
        Args    : on set, new value (a Bio::Factory::SequenceStreamI compliant
                  object)

</pre><h4><b>Bio::Factory::SequenceStreamI</b> <b>methods</b></h4><pre>
        The requirement to implement these methods is inherited from
        L&lt;Bio::Factory::SequenceStreamI&gt;. An implementation may not
        necessarily have to implement all methods in a meaningful way. Which
        methods will be necessary very much depends on the context in which
        an implementation of this interface is used. E.g., if it is only used
        for post-processing sequences read from a SeqIO stream, write_seq()
        will not be used and hence does not need to be implemented in a
        meaningful way (it may in fact even throw an exception).

        Also, since an implementor will already receive built objects from a
        sequence stream, sequence_factory() may or may not be relevant,
        depending on whether the processing method does or does not involve
        creating new objects.

   <b>next_seq</b>
        Title   : next_seq
        Usage   : $seq = stream-&gt;next_seq
        Function: Reads the next sequence object from the stream and returns it.

                  In the case of a non-recoverable situation an exception
                  will be thrown.  Do not assume that you can resume parsing
                  the same stream after catching the exception. Note that you
                  can always turn recoverable errors into exceptions by
                  calling $stream-&gt;<a href="../man2/verbose.2.html">verbose</a>(2).

        Returns : a Bio::Seq sequence object
        Args    : none

       See Bio::Root::RootI

   <b>write_seq</b>
        Title   : write_seq
        Usage   : $stream-&gt;write_seq($seq)
        Function: writes the $seq object into the stream
        Returns : 1 for success and 0 for error
        Args    : Bio::Seq object

   <b>sequence_factory</b>
        Title   : sequence_factory
        Usage   : $seqio-&gt;sequence_factory($seqfactory)
        Function: Get the Bio::Factory::SequenceFactoryI
        Returns : Bio::Factory::SequenceFactoryI
        Args    : none

perl v5.32.1                                       2021-08-15              <u>Bio::Factory::<a href="../man3pm/SequenceProcessorI.3pm.html">SequenceProcessorI</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>