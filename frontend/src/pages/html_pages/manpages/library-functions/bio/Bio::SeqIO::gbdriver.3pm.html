<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::SeqIO::gbdriver - GenBank handler-based push parser</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-perl-perl">libbio-perl-perl_1.7.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::SeqIO::gbdriver - GenBank handler-based push parser

</pre><h4><b>SYNOPSIS</b></h4><pre>
         #It is probably best not to use this object directly, but
         #rather go through the SeqIO handler:

         $stream = Bio::SeqIO-&gt;new(-file =&gt; $filename,
                                   -format =&gt; 'gbdriver');

         while ( my $seq = $stream-&gt;next_seq() ) {
             # do something with $seq
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This object can transform Bio::Seq objects to and from GenBank flat file databases. The key difference
       between this parser and the tried-and-true Bio::SeqIO::genbank parser is this version separates the
       parsing and data manipulation into a 'driver' method (next_seq) and separate object handlers which deal
       with the data passed to it.

   <b>The</b> <b>Driver</b>
       The main purpose of the driver routine, in this case <b>next_seq()</b>, is to carve out the data into meaningful
       chunks which are passed along to relevant handlers (see below).

       Each chunk of data in the has a NAME tag attached to it, similar to that for XML parsing. This designates
       the type of data passed (annotation type or seqfeature) and the handler to be called for processing the
       data.

       For GenBank annotations, the data is divided up and passed along to handlers according to whether the
       data is tagged with a field name (i.e. LOCUS) and whether the field name represents 'primary' annotation
       (in this case, is present at the beginning of the line, such as REFERENCE). If the field is primary, it
       is assigned to the NAME tag. Field names which aren't primary (have at least 2 spaces before the name,
       like ORGANISM) are appended to the preceding primary field name as additional tags.

       For feature table data each new feature name signals the beginning of a new chunk of data. 'FEATURES' is
       attached to NAME, the feature key ('CDS', 'gene', etc) is attached as the PRIMARY_ID, and the location is
       assigned to it's own tag name (LOCATION). Feature qualifiers are added as additional keys, with multiple
       keys included in an array.

       Once a particular event occurs (new primary tag, sequence, end of record), the data is passed along to be
       processed by a handler or (if no handler is defined) tossed away.

       Internally, the hash ref for a representative annotation (here a REFERENCE) looks like this:

         $VAR1 = {
                   'JOURNAL' =&gt; 'Unpublished (2003)',
                   'TITLE' =&gt; 'The DNA sequence of Homo sapiens',
                   'NAME' =&gt; 'REFERENCE',
                   'REFERENCE' =&gt; '1  (bases 1 to 10001)',
                   'AUTHORS' =&gt; 'International Human Genome Sequencing Consortium.'
                 };

       and a SeqFeature as this:

         $VAR1 = {
                   'db_xref' =&gt; [
                                  'GeneID:127086',
                                  'InterimID:127086'
                                ],
                   'LOCATION' =&gt; 'complement(3024..6641)',
                   'NAME' =&gt; 'FEATURES',
                   'FEATURE_KEY' =&gt; 'gene',
                   'gene' =&gt; 'LOC127086',
                   'note' =&gt; 'Derived by automated computational analysis using
                              gene prediction method: GNOMON.'
                 };

       Note that any driver implementation would suffice as long as it fulfilled the requirements above.

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>Lists</b>
       User feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments
       and suggestions preferably to one of the Bioperl mailing lists.  Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list:

       <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather than to the module maintainer directly. Many experienced and reponsive experts will be able look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>Bugs</b>
       Report bugs to the Bioperl bug tracking system to help us keep track the bugs and their resolution. Bug
       reports can be submitted via the web:

         https://github.com/bioperl/bioperl-live/issues

</pre><h4><b>AUTHOR</b> <b>-</b> <b>Bioperl</b> <b>Project</b></h4><pre>
       bioperl-l at bioperl.org

       Original author Elia Stupka, elia -at- tigem.it

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Ewan Birney birney at ebi.ac.uk Jason Stajich jason at bioperl.org Chris Mungall cjm at
       fruitfly.bdgp.berkeley.edu Lincoln Stein lstein at cshl.org Heikki Lehvaslaiho, heikki at ebi.ac.uk
       Hilmar Lapp, hlapp at gmx.net Donald G. Jackson, donald.jackson at bms.com James Wasmuth, james.wasmuth
       at ed.ac.uk Brian Osborne, bosborne at alum.mit.edu

</pre><h4><b>APPENDIX</b></h4><pre>
       The rest of the documentation details each of the object methods. Internal methods are usually preceded
       with a _

   <b>next_seq</b>
        Title   : next_seq
        Usage   : $seq = $stream-&gt;next_seq()
        Function: returns the next sequence in the stream
        Returns : Bio::Seq object
        Args    :

   <b>write_seq</b>
        Title   : write_seq
        Usage   : $stream-&gt;write_seq($seq)
        Function: writes the $seq object (must be seq) to the stream
        Returns : 1 for success and 0 for error
        Args    : array of 1 to n Bio::SeqI objects

   <b>seqhandler</b>
        Title   : seqhandler
        Usage   : $stream-&gt;seqhandler($handler)
        Function: Get/Set the Bio::Seq::HandlerBaseI object
        Returns : Bio::Seq::HandlerBaseI
        Args    : Bio::Seq::HandlerBaseI

perl v5.32.1                                       2021-08-15                          <u>Bio::SeqIO::<a href="../man3pm/gbdriver.3pm.html">gbdriver</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>