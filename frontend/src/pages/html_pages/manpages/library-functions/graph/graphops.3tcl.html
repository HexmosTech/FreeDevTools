<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>struct::graph::op - Operation for (un)directed graph objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       struct::graph::op - Operation for (un)directed graph objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.6</b> <b>9</b>

       package require <b>struct::graph::op</b> <b>?0.11.4?</b>

       <b>struct::graph::op::toAdjacencyMatrix</b> <u>g</u>

       <b>struct::graph::op::toAdjacencyList</b> <u>G</u> ?<u>options</u>...?

       <b>struct::graph::op::kruskal</b> <u>g</u>

       <b>struct::graph::op::prim</b> <u>g</u>

       <b>struct::graph::op::isBipartite?</b> <u>g</u> ?<u>bipartvar</u>?

       <b>struct::graph::op::tarjan</b> <u>g</u>

       <b>struct::graph::op::connectedComponents</b> <u>g</u>

       <b>struct::graph::op::connectedComponentOf</b> <u>g</u> <u>n</u>

       <b>struct::graph::op::isConnected?</b> <u>g</u>

       <b>struct::graph::op::isCutVertex?</b> <u>g</u> <u>n</u>

       <b>struct::graph::op::isBridge?</b> <u>g</u> <u>a</u>

       <b>struct::graph::op::isEulerian?</b> <u>g</u> ?<u>tourvar</u>?

       <b>struct::graph::op::isSemiEulerian?</b> <u>g</u> ?<u>pathvar</u>?

       <b>struct::graph::op::dijkstra</b> <u>g</u> <u>start</u> ?<u>options</u>...?

       <b>struct::graph::op::distance</b> <u>g</u> <u>origin</u> <u>destination</u> ?<u>options</u>...?

       <b>struct::graph::op::eccentricity</b> <u>g</u> <u>n</u> ?<u>options</u>...?

       <b>struct::graph::op::radius</b> <u>g</u> ?<u>options</u>...?

       <b>struct::graph::op::diameter</b> <u>g</u> ?<u>options</u>...?

       <b>struct::graph::op::BellmanFord</b> <u>G</u> <u>startnode</u>

       <b>struct::graph::op::Johnsons</b> <u>G</u> ?<u>options</u>...?

       <b>struct::graph::op::FloydWarshall</b> <u>G</u>

       <b>struct::graph::op::MetricTravellingSalesman</b> <u>G</u>

       <b>struct::graph::op::Christofides</b> <u>G</u>

       <b>struct::graph::op::GreedyMaxMatching</b> <u>G</u>

       <b>struct::graph::op::MaxCut</b> <u>G</u> <u>U</u> <u>V</u>

       <b>struct::graph::op::UnweightedKCenter</b> <u>G</u> <u>k</u>

       <b>struct::graph::op::WeightedKCenter</b> <u>G</u> <u>nodeWeights</u> <u>W</u>

       <b>struct::graph::op::GreedyMaxIndependentSet</b> <u>G</u>

       <b>struct::graph::op::GreedyWeightedMaxIndependentSet</b> <u>G</u> <u>nodeWeights</u>

       <b>struct::graph::op::VerticesCover</b> <u>G</u>

       <b>struct::graph::op::EdmondsKarp</b> <u>G</u> <u>s</u> <u>t</u>

       <b>struct::graph::op::BusackerGowen</b> <u>G</u> <u>desiredFlow</u> <u>s</u> <u>t</u>

       <b>struct::graph::op::ShortestsPathsByBFS</b> <u>G</u> <u>s</u> <u>outputFormat</u>

       <b>struct::graph::op::BFS</b> <u>G</u> <u>s</u> ?<u>outputFormat</u>...?

       <b>struct::graph::op::MinimumDiameterSpanningTree</b> <u>G</u>

       <b>struct::graph::op::MinimumDegreeSpanningTree</b> <u>G</u>

       <b>struct::graph::op::MaximumFlowByDinic</b> <u>G</u> <u>s</u> <u>t</u> <u>blockingFlowAlg</u>

       <b>struct::graph::op::BlockingFlowByDinic</b> <u>G</u> <u>s</u> <u>t</u>

       <b>struct::graph::op::BlockingFlowByMKM</b> <u>G</u> <u>s</u> <u>t</u>

       <b>struct::graph::op::createResidualGraph</b> <u>G</u> <u>f</u>

       <b>struct::graph::op::createAugmentingNetwork</b> <u>G</u> <u>f</u> <u>path</u>

       <b>struct::graph::op::createLevelGraph</b> <u>Gf</u> <u>s</u>

       <b>struct::graph::op::TSPLocalSearching</b> <u>G</u> <u>C</u>

       <b>struct::graph::op::TSPLocalSearching3Approx</b> <u>G</u> <u>C</u>

       <b>struct::graph::op::createSquaredGraph</b> <u>G</u>

       <b>struct::graph::op::createCompleteGraph</b> <u>G</u> <u>originalEdges</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  package  described by this document, <b>struct::graph::op</b>, is a companion to the package <b>struct::graph</b>.
       It provides a series of common operations and algorithms applicable to (un)directed graphs.

       Despite being a companion the package is not directly dependent on <b>struct::graph</b>, only on the API defined
       by that package. I.e. the operations of this package can be applied to any and all  graph  objects  which
       provide the same API as the objects created through <b>struct::graph</b>.

</pre><h4><b>OPERATIONS</b></h4><pre>
       <b>struct::graph::op::toAdjacencyMatrix</b> <u>g</u>
              This command takes the graph <u>g</u> and returns a nested list containing the adjacency matrix of <u>g</u>.

              The  elements  of  the  outer  list  are the rows of the matrix, the inner elements are the column
              values in each row. The matrix has "<b>n</b>+1" rows and columns, with the first row and column (index 0)
              containing the name of the node the row/column is for. All other elements are boolean values, <b>True</b>
              if there is an arc between the 2 nodes of the respective row and column, and <b>False</b> otherwise.

              Note that the matrix is symmetric. It does not represent the directionality of  arcs,  only  their
              presence between nodes. It is also unable to represent parallel arcs in <u>g</u>.

       <b>struct::graph::op::toAdjacencyList</b> <u>G</u> ?<u>options</u>...?
              Procedure  creates  for  input  graph  <u>G</u>,  it's representation as <u>Adjacency</u> <u>List</u>.  It handles both
              directed and undirected graphs (default is undirected).  It returns dictionary that for each  node
              (key)  returns  list of nodes adjacent to it. When considering weighted version, for each adjacent
              node there is also weight of the edge included.

              Arguments:

                     Graph object <u>G</u> (input)
                            A graph to convert into an <u>Adjacency</u> <u>List</u>.

              Options:

                     <b>-directed</b>
                            By default <u>G</u> is operated as if it were an <u>Undirected</u> <u>graph</u>.  Using this option tells
                            the command to handle <u>G</u> as the directed graph it is.

                     <b>-weights</b>
                            By default any weight information the graph <u>G</u>  may  have  is  ignored.   Using  this
                            option tells the command to put weight information into the result.  In that case it
                            is  expected  that  all arcs have a proper weight, and an error is thrown if that is
                            not the case.

       <b>struct::graph::op::kruskal</b> <u>g</u>
              This command takes the graph <u>g</u> and returns a list containing the names of the arcs in <u>g</u> which span
              up a minimum weight spanning tree (MST), or, in the case  of  an  un-connected  graph,  a  minimum
              weight  spanning  forest  (except  for  the  1-vertex  components). Kruskal's algorithm is used to
              compute the tree or forest.  This algorithm has a time complexity of <u>O(E*log</u> <u>E)</u> or  <u>O(E*</u>  <u>log</u>  <u>V)</u>,
              where <u>V</u> is the number of vertices and <u>E</u> is the number of edges in graph <u>g</u>.

              The command will throw an error if one or more arcs in <u>g</u> have no weight associated with them.

              A  note regarding the result, the command refrains from explicitly listing the nodes of the MST as
              this information is implicitly provided in the arcs already.

       <b>struct::graph::op::prim</b> <u>g</u>
              This command takes the graph <u>g</u> and returns a list containing the names of the arcs in <u>g</u> which span
              up a minimum weight spanning tree (MST), or, in the case  of  an  un-connected  graph,  a  minimum
              weight  spanning  forest (except for the 1-vertex components). Prim's algorithm is used to compute
              the tree or forest.  This algorithm has  a  time  complexity  between  <u>O(E+V*log</u>  <u>V)</u>  and  <u>O(V*V)</u>,
              depending  on  the  implementation  (Fibonacci heap + Adjacency list versus Adjacency Matrix).  As
              usual <u>V</u> is the number of vertices and <u>E</u> the number of edges in graph <u>g</u>.

              The command will throw an error if one or more arcs in <u>g</u> have no weight associated with them.

              A note regarding the result, the command refrains from explicitly listing the nodes of the MST  as
              this information is implicitly provided in the arcs already.

       <b>struct::graph::op::isBipartite?</b> <u>g</u> ?<u>bipartvar</u>?
              This  command  takes  the  graph  <u>g</u> and returns a boolean value indicating whether it is bipartite
              (<b>true</b>) or not (<b>false</b>). If the variable <u>bipartvar</u> is specified the two partitions of the graph  are
              there  as  a list, if, and only if the graph is bipartit. If it is not the variable, if specified,
              is not touched.

       <b>struct::graph::op::tarjan</b> <u>g</u>
              This command computes the set of <u>strongly</u> <u>connected</u> components (SCCs) of the graph <u>g</u>.  The  result
              of  the  command is a list of sets, each of which contains the nodes for one of the SCCs of <u>g</u>. The
              union of all SCCs covers the whole graph, and no two SCCs intersect with each other.

              The graph <u>g</u> is <u>acyclic</u> if all SCCs in the result contain only  a  single  node.  The  graph  <u>g</u>  is
              <u>strongly</u> <u>connected</u> if the result contains only a single SCC containing all nodes of <u>g</u>.

       <b>struct::graph::op::connectedComponents</b> <u>g</u>
              This  command  computes  the  set  of <u>connected</u> components (CCs) of the graph <u>g</u>. The result of the
              command is a list of sets, each of which contains the nodes for one of the CCs of <u>g</u>. The union  of
              all CCs covers the whole graph, and no two CCs intersect with each other.

              The graph <u>g</u> is <u>connected</u> if the result contains only a single SCC containing all nodes of <u>g</u>.

       <b>struct::graph::op::connectedComponentOf</b> <u>g</u> <u>n</u>
              This  command  computes  the  <u>connected</u>  component  (CC) of the graph <u>g</u> containing the node <u>n</u>. The
              result of the command is a sets which contains the nodes for the CC of <u>n</u> in <u>g</u>.

              The command will throw an error if <u>n</u> is not a node of the graph <u>g</u>.

       <b>struct::graph::op::isConnected?</b> <u>g</u>
              This is a convenience command determining whether the graph <u>g</u> is <u>connected</u> or not.  The result  is
              a boolean value, <b>true</b> if the graph is connected, and <b>false</b> otherwise.

       <b>struct::graph::op::isCutVertex?</b> <u>g</u> <u>n</u>
              This  command  determines  whether  the  node  <u>n</u>  in the graph <u>g</u> is a <u>cut</u> <u>vertex</u> (aka <u>articulation</u>
              <u>point</u>). The result is a boolean value, <b>true</b> if the node is a cut vertex, and <b>false</b> otherwise.

              The command will throw an error if <u>n</u> is not a node of the graph <u>g</u>.

       <b>struct::graph::op::isBridge?</b> <u>g</u> <u>a</u>
              This command determines whether the arc <u>a</u> in the graph <u>g</u> is a <u>bridge</u> (aka <u>cut</u> <u>edge</u>,  or  <u>isthmus</u>).
              The result is a boolean value, <b>true</b> if the arc is a bridge, and <b>false</b> otherwise.

              The command will throw an error if <u>a</u> is not an arc of the graph <u>g</u>.

       <b>struct::graph::op::isEulerian?</b> <u>g</u> ?<u>tourvar</u>?
              This  command  determines  whether the graph <u>g</u> is <u>eulerian</u> or not.  The result is a boolean value,
              <b>true</b> if the graph is eulerian, and <b>false</b> otherwise.

              If the graph is eulerian and <u>tourvar</u> is specified then an euler  tour  is  computed  as  well  and
              stored  in the named variable. The tour is represented by the list of arcs traversed, in the order
              of traversal.

       <b>struct::graph::op::isSemiEulerian?</b> <u>g</u> ?<u>pathvar</u>?
              This command determines whether the graph <u>g</u> is <u>semi-eulerian</u> or not.   The  result  is  a  boolean
              value, <b>true</b> if the graph is semi-eulerian, and <b>false</b> otherwise.

              If  the graph is semi-eulerian and <u>pathvar</u> is specified then an euler path is computed as well and
              stored in the named variable. The path is represented by the list of arcs traversed, in the  order
              of traversal.

       <b>struct::graph::op::dijkstra</b> <u>g</u> <u>start</u> ?<u>options</u>...?
              This  command determines distances in the weighted <u>g</u> from the node <u>start</u> to all other nodes in the
              graph. The options specify how to traverse graphs, and the format of the result.

              Two options are recognized

              <b>-arcmode</b> mode
                     The accepted mode values are <b>directed</b> and <b>undirected</b>.  For directed traversal all arcs  are
                     traversed  from  source  to  target. For undirected traversal all arcs are traversed in the
                     opposite direction as well. Undirected traversal is the default.

              <b>-outputformat</b> format
                     The accepted format values are <b>distances</b> and <b>tree</b>. In both cases the result is a dictionary
                     keyed by the names of all nodes in the graph. For <b>distances</b> the value is  the  distance  of
                     the node to <u>start</u>, whereas for <b>tree</b> the value is the path from the node to <u>start</u>, excluding
                     the node itself, but including <u>start</u>. Tree format is the default.

       <b>struct::graph::op::distance</b> <u>g</u> <u>origin</u> <u>destination</u> ?<u>options</u>...?
              This  command determines the (un)directed distance between the two nodes <u>origin</u> and <u>destination</u> in
              the graph <u>g</u>. It accepts the option <b>-arcmode</b> of <b>struct::graph::op::dijkstra</b>.

       <b>struct::graph::op::eccentricity</b> <u>g</u> <u>n</u> ?<u>options</u>...?
              This command determines the (un)directed <u>eccentricity</u> of the node <u>n</u> in the graph <u>g</u>. It accepts the
              option <b>-arcmode</b> of <b>struct::graph::op::dijkstra</b>.

              The (un)directed <u>eccentricity</u> of a node is the maximal (un)directed distance between the node  and
              any other node in the graph.

       <b>struct::graph::op::radius</b> <u>g</u> ?<u>options</u>...?
              This  command determines the (un)directed <u>radius</u> of the graph <u>g</u>. It accepts the option <b>-arcmode</b> of
              <b>struct::graph::op::dijkstra</b>.

              The (un)directed <u>radius</u> of a graph is the minimal (un)directed <u>eccentricity</u> of all  nodes  in  the
              graph.

       <b>struct::graph::op::diameter</b> <u>g</u> ?<u>options</u>...?
              This  command  determines the (un)directed <u>diameter</u> of the graph <u>g</u>. It accepts the option <b>-arcmode</b>
              of <b>struct::graph::op::dijkstra</b>.

              The (un)directed <u>diameter</u> of a graph is the maximal (un)directed <u>eccentricity</u> of all nodes in  the
              graph.

       <b>struct::graph::op::BellmanFord</b> <u>G</u> <u>startnode</u>
              Searching  for  <b>shortests</b>  <b>paths</b>  between  chosen  node  and  all other nodes in graph <u>G</u>. Based on
              relaxation method. In comparison to <b>struct::graph::op::dijkstra</b> it doesn't  need  assumption  that
              all weights on edges in input graph <u>G</u> have to be positive.

              That  generality  sets  the complexity of algorithm to - <u>O(V*E)</u>, where <u>V</u> is the number of vertices
              and <u>E</u> is number of edges in graph <u>G</u>.

              Arguments:

                     Graph object <u>G</u> (input)
                            Directed, connected and edge  weighted  graph  <u>G</u>,  without  any  negative  cycles  (
                            presence  of  cycles with the negative sum of weight means that there is no shortest
                            path, since the total weight becomes lower each  time  the  cycle  is  traversed  ).
                            Negative weights on edges are allowed.

                     Node <u>startnode</u> (input)
                            The node for which we find all shortest paths to each other node in graph <u>G</u>.

              Result:
                     Dictionary containing for each node (key) distances to each other node in graph <u>G</u>.

       <u>Note:</u> If algorithm finds a negative cycle, it will return error message.

       <b>struct::graph::op::Johnsons</b> <u>G</u> ?<u>options</u>...?
              Searching  for  <b>shortest</b>  <b>paths</b>  between  all  pairs  of  vertices  in  graph.  For  sparse graphs
              asymptotically quicker than <b>struct::graph::op::FloydWarshall</b> algorithm. Johnson's  algorithm  uses
              <b>struct::graph::op::BellmanFord</b> and <b>struct::graph::op::dijkstra</b> as subprocedures.

              Time  complexity:  <u>O(n**2*<a href="../man3tcl/log.3tcl.html">log</a>(3tcl)</u>  <u>+n*m)</u>,  where <u>n</u> is the number of nodes and <u>m</u> is the number of
              edges in graph <u>G</u>.

              Arguments:

                     Graph object <u>G</u> (input)
                            Directed graph <u>G</u>, weighted on edges and not containing any cycles with negative  sum
                            of  weights ( the presence of such cycles means there is no shortest path, since the
                            total weight becomes lower each time the cycle is traversed ). Negative  weights  on
                            edges are allowed.

              Options:

                     <b>-filter</b>
                            Returns  only  existing  distances, cuts all <u>Inf</u> values for non-existing connections
                            between pairs of nodes.

              Result:
                     Dictionary containing distances between all pairs of vertices.

       <b>struct::graph::op::FloydWarshall</b> <u>G</u>
              Searching for <b>shortest</b> <b>paths</b> between all pairs of edges in weighted graphs.

              Time complexity: <u>O(V^3)</u> - where <u>V</u> is number of vertices.

              Memory complexity: <u>O(V^2)</u>.

              Arguments:

                     Graph object <u>G</u> (input)
                            Directed and weighted graph <u>G</u>.

              Result:
                     Dictionary containing shortest distances to each node from each node.

              <u>Note:</u> Algorithm finds solutions dynamically. It compares all  possible  paths  through  the  graph
              between each pair of vertices. Graph shouldn't possess any cycle with negative sum of weights (the
              presence of such cycles means there is no shortest path, since the total weight becomes lower each
              time the cycle is traversed).

              On  the  other hand algorithm can be used to find those cycles - if any shortest distance found by
              algorithm for any nodes <u>v</u> and <u>u</u> (when <u>v</u> is the same node as  <u>u</u>)  is  negative,  that  node  surely
              belong to at least one negative cycle.

       <b>struct::graph::op::MetricTravellingSalesman</b> <u>G</u>
              Algorithm  for  solving  a  metric  variation  of <b>Travelling</b> <b>salesman</b> <b>problem</b>.  <u>TSP</u> <u>problem</u> is <u>NP-</u>
              <u>Complete</u>, so there is no efficient algorithm to solve it. Greedy  methods  are  getting  extremely
              slow, with the increase in the set of nodes.

              Arguments:

                     Graph object <u>G</u> (input)
                            Undirected, weighted graph <u>G</u>.

              Result:
                     Approximated  solution  of  minimum  <u>Hamilton</u>  <u>Cycle</u> - closed path visiting all nodes, each
                     exactly one time.

              <u>Note:</u> <b>It's</b> <b>2-approximation</b> <b>algorithm.</b>

       <b>struct::graph::op::Christofides</b> <u>G</u>
              Another algorithm for solving <b>metric</b> <u>TSP</u> <u>problem</u>.  Christofides implementation uses  <u>Max</u>  <u>Matching</u>
              for reaching better approximation factor.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Undirected, weighted graph <u>G</u>.

              Result:
                     Approximated  solution  of  minimum  <u>Hamilton</u>  <u>Cycle</u> - closed path visiting all nodes, each
                     exactly one time.

       <u>Note:</u> <b>It's</b> <b>is</b> <b>a</b> <b>3/2</b> <b>approximation</b> <b>algorithm.</b>

       <b>struct::graph::op::GreedyMaxMatching</b> <u>G</u>
              <u>Greedy</u> <u>Max</u> <u>Matching</u> procedure, which finds <b>maximal</b> <b>matching</b> (not maximum) for given  graph  <u>G</u>.  It
              adds edges to solution, beginning from edges with the lowest cost.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Undirected graph <u>G</u>.

              Result:
                     Set of edges - the max matching for graph <u>G</u>.

       <b>struct::graph::op::MaxCut</b> <u>G</u> <u>U</u> <u>V</u>
              Algorithm solving a <b>Maximum</b> <b>Cut</b> <b>Problem</b>.

              Arguments:

                     Graph Object <u>G</u> (input)
                            The graph to cut.

                     List <u>U</u> (output)
                            Variable storing first set of nodes (cut) given by solution.

                     List <u>V</u> (output)
                            Variable storing second set of nodes (cut) given by solution.

              Result:
                     Algorithm returns number of edges between found two sets of nodes.

              <u>Note:</u> <u>MaxCut</u> is a <b>2-approximation</b> <b>algorithm.</b>

       <b>struct::graph::op::UnweightedKCenter</b> <u>G</u> <u>k</u>
              Approximation algorithm that solves a <b>k-center</b> <b>problem</b>.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Undirected complete graph <u>G</u>, which satisfies triangle inequality.

                     Integer <u>k</u> (input)
                            Positive integer that sets the number of nodes that will be included in <u>k-center</u>.

              Result:
                     Set of nodes - <u>k</u> center for graph <u>G</u>.

              <u>Note:</u> <u>UnweightedKCenter</u> is a <b>2-approximation</b> <b>algorithm.</b>

       <b>struct::graph::op::WeightedKCenter</b> <u>G</u> <u>nodeWeights</u> <u>W</u>
              Approximation algorithm that solves a weighted version of <b>k-center</b> <b>problem</b>.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Undirected complete graph <u>G</u>, which satisfies triangle inequality.

                     Integer <u>W</u> (input)
                            Positive  integer  that  sets  the  maximum  possible  weight  of  <u>k-center</u> found by
                            algorithm.

                     List <u>nodeWeights</u> (input)
                            List of nodes and its weights in graph <u>G</u>.

              Result:
                     Set of nodes, which is solution found by algorithm.

              <u>Note:WeightedKCenter</u> is a <b>3-approximation</b> <b>algorithm.</b>

       <b>struct::graph::op::GreedyMaxIndependentSet</b> <u>G</u>
              A <u>maximal</u> <u>independent</u> <u>set</u> is an <u>independent</u> <u>set</u> such that adding any other node to the set  forces
              the set to contain an edge.

              Algorithm  for  input  graph <u>G</u> returns set of nodes (list), which are contained in Max Independent
              Set found by algorithm.

       <b>struct::graph::op::GreedyWeightedMaxIndependentSet</b> <u>G</u> <u>nodeWeights</u>
              Weighted variation of <u>Maximal</u> <u>Independent</u> <u>Set</u>. It takes as an input argument not only graph <u>G</u>  but
              also set of weights for all vertices in graph <u>G</u>.

              <u>Note:</u> Read also <u>Maximal</u> <u>Independent</u> <u>Set</u> description for more info.

       <b>struct::graph::op::VerticesCover</b> <u>G</u>
              <u>Vertices</u>  <u>cover</u>  is a set of vertices such that each edge of the graph is incident to at least one
              vertex of the set. This 2-approximation algorithm searches for minimum <u>vertices</u> <u>cover</u>, which is  a
              classical  optimization  problem  in  computer  science  and  is  a  typical example of an <u>NP-hard</u>
              optimization problem that has an approximation algorithm.  For input graph <u>G</u> algorithm returns the
              set of edges (list), which is Vertex Cover found by algorithm.

       <b>struct::graph::op::EdmondsKarp</b> <u>G</u> <u>s</u> <u>t</u>
              Improved Ford-Fulkerson's algorithm, computing the <b>maximum</b> <b>flow</b> in given flow network <u>G</u>.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Weighted and directed graph. Each edge should have set integer attribute  considered
                            as maximum throughputs that can be carried by that link (edge).

                     Node <u>s</u> (input)
                            The node that is a source for graph <u>G</u>.

                     Node <u>t</u> (input)
                            The node that is a sink for graph <u>G</u>.

              Result:
                     Procedure  returns  the dictionary containing throughputs for all edges. For each key ( the
                     edge between nodes <u>u</u> and <u>v</u> in the form of <u>list</u> <u>u</u> <u>v</u> ) there is a value that is a  throughput
                     for  that  key.  Edges where throughput values are equal to 0 are not returned ( it is like
                     there was no link in the flow network between nodes connected by such edge).

       The general idea of algorithm is finding the shortest augumenting paths in  graph  <u>G</u>,  as  long  as  they
       exist,  and  for each path updating the edge's weights along that path, with maximum possible throughput.
       The final (maximum) flow is found when there is no other augumenting path from source to sink.

       <u>Note:</u> Algorithm complexity : <u>O(V*E)</u>, where <u>V</u> is the number of nodes and <u>E</u> is the number of edges in graph
       <u>G</u>.

       <b>struct::graph::op::BusackerGowen</b> <u>G</u> <u>desiredFlow</u> <u>s</u> <u>t</u>
              Algorithm finds solution for a <b>minimum</b> <b>cost</b> <b>flow</b> <b>problem</b>. So, the goal is to find  a  flow,  whose
              max  value  can  be  <u>desiredFlow</u>, from source node <u>s</u> to sink node <u>t</u> in given flow network <u>G</u>.  That
              network except throughputs at edges has also defined a non-negative cost on each edge  -  cost  of
              using  that  edge  when directing flow with that edge ( it can illustrate e.g. fuel usage, time or
              any other measure dependent on usages ).

              Arguments:

                     Graph Object <u>G</u> (input)
                            Flow  network  (directed  graph),  each  edge  in  graph  should  have  two  integer
                            attributes: <u>cost</u> and <u>throughput</u>.

                     Integer <u>desiredFlow</u> (input)
                            Max value of the flow for that network.

                     Node <u>s</u> (input)
                            The source node for graph <u>G</u>.

                     Node <u>t</u> (input)
                            The sink node for graph <u>G</u>.

              Result:
                     Dictionary  containing  values  of  used  throughputs  for  each  edge  (  key ).  found by
                     algorithm.

              <u>Note:</u> Algorithm complexity : <u>O(V**2*desiredFlow)</u>, where <u>V</u> is the number of nodes in graph <u>G</u>.

       <b>struct::graph::op::ShortestsPathsByBFS</b> <u>G</u> <u>s</u> <u>outputFormat</u>
              Shortest pathfinding algorithm using BFS method. In comparison to  <b>struct::graph::op::dijkstra</b>  it
              can  work  with negative weights on edges. Of course negative cycles are not allowed. Algorithm is
              better than dijkstra for sparse graphs, but also there exist some pathological cases (those  cases
              generally  don't  appear  in  practise)  that make time complexity increase exponentially with the
              growth of the number of nodes.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Input graph.

                     Node <u>s</u> (input)
                            Source node for which all distances to each other node in graph <u>G</u> are computed.

              Options and result:

                     <b>distances</b>
                            When selected <u>outputFormat</u> is <b>distances</b> - procedure  returns  dictionary  containing
                            distances between source node <u>s</u> and each other node in graph <u>G</u>.

                     <b>paths</b>  When  selected  <u>outputFormat</u>  is <b>paths</b> - procedure returns dictionary containing for
                            each node <u>v</u>, a list of nodes, which is a path between source node <u>s</u> and node <u>v</u>.

       <b>struct::graph::op::BFS</b> <u>G</u> <u>s</u> ?<u>outputFormat</u>...?
              Breadth-First Search - algorithm creates the BFS Tree.  Memory and  time  complexity:  <u>O(V</u>  <u>+</u>  <u>E)</u>,
              where <u>V</u> is the number of nodes and <u>E</u> is number of edges.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Input graph.

                     Node <u>s</u> (input)
                            Source node for BFS procedure.

              Options and result:

                     <b>graph</b>  When   selected  <b>outputFormat</b>  is  <b>graph</b>  -  procedure  returns  a  graph  structure
                            (<b>struct::graph</b>), which is equivalent to BFS tree found by algorithm.

                     <b>tree</b>   When  selected  <b>outputFormat</b>  is  <b>tree</b>  -  procedure  returns   a   tree   structure
                            (<b>struct::tree</b>), which is equivalent to BFS tree found by algorithm.

       <b>struct::graph::op::MinimumDiameterSpanningTree</b> <u>G</u>
              The goal is to find for input graph <u>G</u>, the <u>spanning</u> <u>tree</u> that has the minimum <u>diameter</u> value.

              General  idea  of  algorithm  is to run <u>BFS</u> over all vertices in graph <u>G</u>. If the diameter <u>d</u> of the
              tree is odd, then we are sure that tree given by <u>BFS</u>  is  minimum  (considering  diameter  value).
              When, diameter <u>d</u> is even, then optimal tree can have minimum <u>diameter</u> equal to <u>d</u> or <u>d-1</u>.

              In that case, what algorithm does is rebuilding the tree given by <u>BFS</u>, by adding a vertice between
              root node and root's child node (nodes), such that subtree created with child node as root node is
              the  greatest  one  (has  the  greatests height). In the next step for such rebuilded tree, we run
              again <u>BFS</u> with new node as root node. If the height of the tree didn't changed, we  have  found  a
              better solution.

              For  input  graph  <u>G</u> algorithm returns the graph structure (<b>struct::graph</b>) that is a spanning tree
              with minimum diameter found by algorithm.

       <b>struct::graph::op::MinimumDegreeSpanningTree</b> <u>G</u>
              Algorithm finds for input graph <u>G</u>, a spanning tree  <u>T</u>  with  the  minimum  possible  degree.  That
              problem is <u>NP-hard</u>, so algorithm is an approximation algorithm.

              Let  <u>V</u>  be the set of nodes for graph <u>G</u> and let <u>W</u> be any subset of <u>V</u>. Lets assume also that <u>OPT</u> is
              optimal solution and <u>ALG</u> is solution found by algorithm for input graph <u>G</u>.

              It can be proven that solution found with the algorithm must fulfil inequality:

              <u>((|W|</u> <u>+</u> <u>k</u> <u>-</u> <u>1)</u> <u>/</u> <u>|W|)</u> <u>&lt;=</u> <u>ALG</u> <u>&lt;=</u> <u>2*OPT</u> <u>+</u> <u><a href="../man3tcl/log2.3tcl.html">log2</a>(3tcl)</u> <u>+</u> <u>1</u>.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Undirected simple graph.

              Result:
                     Algorithm returns graph structure,  which  is  equivalent  to  spanning  tree  <u>T</u>  found  by
                     algorithm.

       <b>struct::graph::op::MaximumFlowByDinic</b> <u>G</u> <u>s</u> <u>t</u> <u>blockingFlowAlg</u>
              Algorithm  finds  <b>maximum</b>  <b>flow</b>  for  the  flow network represented by graph <u>G</u>. It is based on the
              blocking-flow finding methods, which give us different complexities what makes a  better  fit  for
              different graphs.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Directed  graph  <u>G</u>  representing  the  flow network. Each edge should have attribute
                            <u>throughput</u> set with integer value.

                     Node <u>s</u> (input)
                            The source node for the flow network <u>G</u>.

                     Node <u>t</u> (input)
                            The sink node for the flow network <u>G</u>.

              Options:

                     <b>dinic</b>  Procedure will find  maximum  flow  for  flow  network  <u>G</u>  using  Dinic's  algorithm
                            (<b>struct::graph::op::BlockingFlowByDinic</b>) for blocking flow computation.

                     <b>mkm</b>    Procedure  will  find  maximum  flow  for  flow  network <u>G</u> using Malhotra, Kumar and
                            Maheshwari's  algorithm  (<b>struct::graph::op::BlockingFlowByMKM</b>)  for  blocking  flow
                            computation.

              Result:
                     Algorithm returns dictionary containing it's flow value for each edge (key) in network <u>G</u>.

       <u>Note:</u>        <b>struct::graph::op::BlockingFlowByDinic</b>       gives       <u>O(m*n^2)</u>       complexity       and
       <b>struct::graph::op::BlockingFlowByMKM</b> gives <u>O(n^3)</u> complexity, where <u>n</u> is the number of nodes and <u>m</u> is the
       number of edges in flow network <u>G</u>.

       <b>struct::graph::op::BlockingFlowByDinic</b> <u>G</u> <u>s</u> <u>t</u>
              Algorithm for given network <u>G</u> with source <u>s</u> and sink <u>t</u>, finds a <b>blocking</b> <b>flow</b>, which can  be  used
              to obtain a <u>maximum</u> <u>flow</u> for that network <u>G</u>.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Directed  graph  <u>G</u>  representing  the  flow network. Each edge should have attribute
                            <u>throughput</u> set with integer value.

                     Node <u>s</u> (input)
                            The source node for the flow network <u>G</u>.

                     Node <u>t</u> (input)
                            The sink node for the flow network <u>G</u>.

              Result:
                     Algorithm returns dictionary containing it's blocking flow value for  each  edge  (key)  in
                     network <u>G</u>.

              <u>Note:</u>  Algorithm's  complexity  is  <u>O(n*m)</u>,  where <u>n</u> is the number of nodes and <u>m</u> is the number of
              edges in flow network <u>G</u>.

       <b>struct::graph::op::BlockingFlowByMKM</b> <u>G</u> <u>s</u> <u>t</u>
              Algorithm for given network <u>G</u> with source <u>s</u> and sink <u>t</u>, finds a <b>blocking</b> <b>flow</b>, which can  be  used
              to obtain a <u>maximum</u> <u>flow</u> for that <u>network</u> <u>G</u>.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Directed  graph  <u>G</u>  representing  the  flow network. Each edge should have attribute
                            <u>throughput</u> set with integer value.

                     Node <u>s</u> (input)
                            The source node for the flow network <u>G</u>.

                     Node <u>t</u> (input)
                            The sink node for the flow network <u>G</u>.

              Result:
                     Algorithm returns dictionary containing it's blocking flow value for  each  edge  (key)  in
                     network <u>G</u>.

              <u>Note:</u> Algorithm's complexity is <u>O(n^2)</u>, where <u>n</u> is the number of nodes in flow network <u>G</u>.

       <b>struct::graph::op::createResidualGraph</b> <u>G</u> <u>f</u>
              Procedure creates a <u>residual</u> <u>graph</u> (or <b>residual</b> <b>network</b> ) for network <u>G</u> and given flow <u>f</u>.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Flow network (directed graph where each edge has set attribute: <u>throughput</u> ).

                     dictionary <u>f</u> (input)
                            Current flows in flow network <u>G</u>.

              Result:
                     Procedure  returns graph structure that is a <u>residual</u> <u>graph</u> created from input flow network
                     <u>G</u>.

       <b>struct::graph::op::createAugmentingNetwork</b> <u>G</u> <u>f</u> <u>path</u>
              Procedure creates an <b>augmenting</b> <b>network</b> for a given residual network <u>G</u> ,  flow  <u>f</u>  and  augmenting
              path <u>path</u>.

              Arguments:

                     Graph Object <u>G</u> (input)
                            Residual  network  (directed  graph),  where  for  every  edge  there  are  set  two
                            attributes: throughput and cost.

                     Dictionary <u>f</u> (input)
                            Dictionary which contains for every edge (key), current value of the  flow  on  that
                            edge.

                     List <u>path</u> (input)
                            Augmenting path, set of edges (list) for which we create the network modification.

              Result:
                     Algorithm returns graph structure containing the modified augmenting network.

       <b>struct::graph::op::createLevelGraph</b> <u>Gf</u> <u>s</u>
              For given residual graph <u>Gf</u> procedure finds the <b>level</b> <b>graph</b>.

              Arguments:

                     Graph Object <u>Gf</u> (input)
                            Residual  network,  where  each  edge has it's attribute <u>throughput</u> set with certain
                            value.

                     Node <u>s</u> (input)
                            The source node for the residual network <u>Gf</u>.

              Result:
                     Procedure returns a <u>level</u> <u>graph</u> created from input <u>residual</u> <u>network</u>.

       <b>struct::graph::op::TSPLocalSearching</b> <u>G</u> <u>C</u>
              Algorithm is a <u>heuristic</u> <u>of</u> <u>local</u> <u>searching</u> for <u>Travelling</u> <u>Salesman</u> <u>Problem</u>. For some solution  of
              <u>TSP</u>  <u>problem</u>,  it  checks  if  it's  possible  to find a better solution. As <u>TSP</u> is well known NP-
              Complete problem, so algorithm is a approximation algorithm (with 2 approximation factor).

              Arguments:

                     Graph Object <u>G</u> (input)
                            Undirected and complete graph with attributes "weight" set on each single edge.

                     List <u>C</u> (input)
                            A list of edges being <u>Hamiltonian</u> <u>cycle</u>, which is solution of <u>TSP</u> <u>Problem</u> for  graph
                            <u>G</u>.

              Result:
                     Algorithm returns the best solution for <u>TSP</u> <u>problem</u>, it was able to find.

              <u>Note:</u>  The  solution  depends  on the choosing of the beginning cycle <u>C</u>. It's not true that better
              cycle assures that better solution will be found, but practise shows that we should give  starting
              cycle with as small sum of weights as possible.

       <b>struct::graph::op::TSPLocalSearching3Approx</b> <u>G</u> <u>C</u>
              Algorithm  is a <u>heuristic</u> <u>of</u> <u>local</u> <u>searching</u> for <u>Travelling</u> <u>Salesman</u> <u>Problem</u>. For some solution of
              <u>TSP</u> <u>problem</u>, it checks if it's possible to find a better  solution.  As  <u>TSP</u>  is  well  known  NP-
              Complete problem, so algorithm is a approximation algorithm (with 3 approximation factor).

              Arguments:

                     Graph Object <u>G</u> (input)
                            Undirected and complete graph with attributes "weight" set on each single edge.

                     List <u>C</u> (input)
                            A  list of edges being <u>Hamiltonian</u> <u>cycle</u>, which is solution of <u>TSP</u> <u>Problem</u> for graph
                            <u>G</u>.

              Result:
                     Algorithm returns the best solution for <u>TSP</u> <u>problem</u>, it was able to find.

              <u>Note:</u>  In  practise  3-approximation  algorithm  turns  out  to  be  far   more   effective   than
              2-approximation,  but  it gives worser approximation factor. Further heuristics of local searching
              (e.g. 4-approximation) doesn't give enough boost to square the increase of  approximation  factor,
              so 2 and 3 approximations are mainly used.

       <b>struct::graph::op::createSquaredGraph</b> <u>G</u>
              X-Squared  graph  is  a  graph with the same set of nodes as input graph <u>G</u>, but a different set of
              edges. X-Squared graph has edge <u>(u,v)</u>, if and only if, the distance between <u>u</u> and <u>v</u> nodes  is  not
              greater than X and <u>u</u> <u>!=</u> <u>v</u>.

              Procedure for input graph <u>G</u>, returns its two-squared graph.

              <u>Note:</u> Distances used in choosing new set of edges are considering the number of edges, not the sum
              of weights at edges.

       <b>struct::graph::op::createCompleteGraph</b> <u>G</u> <u>originalEdges</u>
              For  input  graph  <u>G</u>  procedure  adds  missing  arcs to make it a <u>complete</u> <u>graph</u>. It also holds in
              variable <u>originalEdges</u> the set of arcs that graph <u>G</u> possessed before that operation.

</pre><h4><b>BACKGROUND</b> <b>THEORY</b> <b>AND</b> <b>TERMS</b></h4><pre>
   <b>SHORTEST</b> <b>PATH</b> <b>PROBLEM</b>
       Definition (<u>single-pair</u> <u>shortest</u> <u>path</u> <u>problem</u>):
              Formally, given a weighted graph (let <u>V</u> be the set of vertices, and <u>E</u> a set  of  edges),  and  one
              vertice  <u>v</u>  of  <u>V</u>, find a path <u>P</u> from <u>v</u> to a <u>v'</u> of V so that the sum of weights on edges along the
              path is minimal among all paths connecting v to v'.

       Generalizations:

              •      <u>The</u> <u>single-source</u> <u>shortest</u> <u>path</u> <u>problem</u>, in which we have to find  shortest  paths  from  a
                     source vertex v to all other vertices in the graph.

              •      <u>The</u>  <u>single-destination</u> <u>shortest</u> <u>path</u> <u>problem</u>, in which we have to find shortest paths from
                     all vertices in the graph to a single destination vertex v. This  can  be  reduced  to  the
                     single-source shortest path problem by reversing the edges in the graph.

              •      <u>The</u>  <u>all-pairs</u> <u>shortest</u> <u>path</u> <u>problem</u>, in which we have to find shortest paths between every
                     pair of vertices v, v' in the graph.

              <u>Note:</u> The result of <u>Shortest</u> <u>Path</u> <u>problem</u> can be <u>Shortest</u> <u>Path</u> <u>tree</u>, which  is  a  subgraph  of  a
              given  (possibly weighted) graph constructed so that the distance between a selected root node and
              all other nodes is minimal. It is a tree because if there are two paths between the root node  and
              some  vertex  v  (i.e. a cycle), we can delete the last edge of the longer path without increasing
              the distance from the root node to any node in the subgraph.

   <b>TRAVELLING</b> <b>SALESMAN</b> <b>PROBLEM</b>
       Definition:
              For given edge-weighted (weights on edges should be positive) graph the goal is to find the  cycle
              that visits each node in graph exactly once (<u>Hamiltonian</u> <u>cycle</u>).

       Generalizations:

              •      <u>Metric</u> <u>TSP</u> - A very natural restriction of the <u>TSP</u> is to require that the distances between
                     cities form a <u>metric</u>, i.e., they satisfy <u>the</u> <u>triangle</u> <u>inequality</u>. That is, for any 3 cities
                     <u>A</u>,  <u>B</u> and <u>C</u>, the distance between <u>A</u> and <u>C</u> must be at most the distance from <u>A</u> to <u>B</u> plus the
                     distance from <u>B</u> to <u>C</u>. Most natural instances of <u>TSP</u> satisfy this constraint.

              •      <u>Euclidean</u> <u>TSP</u> - Euclidean TSP, or <u>planar</u> <u>TSP</u>, is  the  <u>TSP</u>  with  the  distance  being  the
                     ordinary  <u>Euclidean</u>  <u>distance</u>.   <u>Euclidean</u>  <u>TSP</u>  is  a particular case of <u>TSP</u> with <u>triangle</u>
                     <u>inequality</u>, since distances in plane obey triangle inequality.  However,  it  seems  to  be
                     easier than general <u>TSP</u> with <u>triangle</u> <u>inequality</u>. For example, <u>the</u> <u>minimum</u> <u>spanning</u> <u>tree</u> of
                     the  graph  associated  with  an  instance of <u>Euclidean</u> <u>TSP</u> is a <u>Euclidean</u> <u>minimum</u> <u>spanning</u>
                     <u>tree</u>, and so can be computed in expected <u>O(n</u> <u>log</u> <u>n)</u> time for <u>n</u>  points  (considerably  less
                     than  the  number of edges). This enables the simple <u>2-approximation</u> <u>algorithm</u> for TSP with
                     triangle inequality above to operate more quickly.

              •      <u>Asymmetric</u> <u>TSP</u> - In most cases, the distance between two nodes in the <u>TSP</u>  network  is  the
                     same  in  both  directions.   The  case  where the distance from <u>A</u> to <u>B</u> is not equal to the
                     distance from <u>B</u> to <u>A</u> is called <u>asymmetric</u> <u>TSP</u>.  A practical application  of  an  <u>asymmetric</u>
                     <u>TSP</u>  is  route  optimisation using street-level routing (asymmetric due to one-way streets,
                     slip-roads and motorways).

   <b>MATCHING</b> <b>PROBLEM</b>
       Definition:
              Given a graph <u>G</u> <u>=</u> <u>(V,E)</u>, a matching or <u>edge-independent</u> <u>set</u> <u>M</u> in <u>G</u>  is  a  set  of  pairwise  non-
              adjacent edges, that is, no two edges share a common vertex. A vertex is <u>matched</u> if it is incident
              to an edge in the <u>matching</u> <u>M</u>.  Otherwise the vertex is <u>unmatched</u>.

       Generalizations:

              •      <u>Maximal</u> <u>matching</u> - a matching <u>M</u> of a graph G with the property that if any edge not in <u>M</u> is
                     added  to <u>M</u>, it is no longer a <u>matching</u>, that is, <u>M</u> is maximal if it is not a proper subset
                     of any other <u>matching</u> in graph G.  In other words, a <u>matching</u> <u>M</u> of a graph G is maximal  if
                     every edge in G has a non-empty intersection with at least one edge in <u>M</u>.

              •      <u>Maximum</u> <u>matching</u> - a matching that contains the largest possible number of edges. There may
                     be  many  <u>maximum</u>  <u>matchings</u>.   The  <u>matching</u>  <u>number</u> of a graph G is the size of a <u>maximum</u>
                     <u>matching</u>. Note that every <u>maximum</u> <u>matching</u> is <u>maximal</u>, but not every <u>maximal</u> <u>matching</u> is  a
                     <u>maximum</u> <u>matching</u>.

              •      <u>Perfect</u>  <u>matching</u>  -  a  matching  which  matches all vertices of the graph. That is, every
                     vertex of the graph is incident to exactly one edge of the matching. Every <u>perfect</u> <u>matching</u>
                     is <u>maximum</u> and hence <u>maximal</u>. In some literature, the term <u>complete</u>  <u>matching</u>  is  used.  A
                     <u>perfect</u>  <u>matching</u>  is  also  a  <u>minimum-size</u>  <u>edge</u>  <u>cover</u>.  Moreover, the size of a <u>maximum</u>
                     <u>matching</u> is no larger than the size of a <u>minimum</u> <u>edge</u> <u>cover</u>.

              •      <u>Near-perfect</u> <u>matching</u> - a matching in which exactly one vertex is unmatched. This can  only
                     occur  when  the  graph has an odd number of vertices, and such a <u>matching</u> must be <u>maximum</u>.
                     If, for every vertex in a graph, there is a near-perfect  matching  that  omits  only  that
                     vertex, the graph is also called <u>factor-critical</u>.

       Related terms:

              •      <u>Alternating</u>  <u>path</u>  -  given  a matching <u>M</u>, an <u>alternating</u> <u>path</u> is a path in which the edges
                     belong alternatively to the matching and not to the matching.

              •      <u>Augmenting</u> <u>path</u> - given a matching <u>M</u>, an <u>augmenting</u> <u>path</u> is an <u>alternating</u> <u>path</u> that starts
                     from and ends on free (unmatched) vertices.

   <b>CUT</b> <b>PROBLEMS</b>
       Definition:
              A <u>cut</u> is a partition of the vertices of a graph into two <u>disjoint</u> <u>subsets</u>. The <u>cut-set</u> of the  <u>cut</u>
              is  the set of edges whose end points are in different subsets of the partition. Edges are said to
              be crossing the cut if they are in its <u>cut-set</u>.

              Formally:

              •      a <u>cut</u> <u>C</u> <u>=</u> <u>(S,T)</u> is a partition of <u>V</u> of a graph <u>G</u> <u>=</u> <u>(V,</u> <u>E)</u>.

              •      an <u>s-t</u> <u>cut</u> <u>C</u> <u>=</u> <u>(S,T)</u> of a <u>flow</u> <u>network</u> <u>N</u> <u>=</u> <u>(V,</u> <u>E)</u> is a cut of <u>N</u> such that <u>s</u> is included  in
                     <u>S</u> and <u>t</u> is included in <u>T</u>, where <u>s</u> and <u>t</u> are the <u>source</u> and the <u>sink</u> of <u>N</u> respectively.

              •      The  <u>cut-set</u>  of  a <u>cut</u> <u>C</u> <u>=</u> <u>(S,T)</u> is such set of edges from graph <u>G</u> <u>=</u> <u>(V,</u> <u>E)</u> that each edge
                     <u>(u,</u> <u>v)</u> satisfies condition that <u>u</u> is included in <u>S</u> and <u>v</u> is included in <u>T</u>.

       In an <u>unweighted</u> <u>undirected</u> graph, the size or weight of a cut is the number of edges crossing  the  cut.
       In a <u>weighted</u> <u>graph</u>, the same term is defined by the sum of the weights of the edges crossing the cut.

       In  a <u>flow</u> <u>network</u>, an <u>s-t</u> <u>cut</u> is a cut that requires the <u>source</u> and the <u>sink</u> to be in different subsets,
       and its <u>cut-set</u> only consists of edges going from the <u>source's</u> side to the <u>sink's</u> side. The  capacity  of
       an <u>s-t</u> <u>cut</u> is defined by the sum of capacity of each edge in the <u>cut-set</u>.

       The <u>cut</u> of a graph can sometimes refer to its <u>cut-set</u> instead of the partition.

       Generalizations:

              •      <u>Minimum</u>  <u>cut</u>  -  A cut is minimum if the size of the cut is not larger than the size of any
                     other cut.

              •      <u>Maximum</u> <u>cut</u> - A cut is maximum if the size of the cut is not smaller than the size  of  any
                     other cut.

              •      <u>Sparsest</u>  <u>cut</u>  -  The <u>Sparsest</u> <u>cut</u> <u>problem</u> is to bipartition the vertices so as to minimize
                     the ratio of the number of edges across the cut divided by the number of  vertices  in  the
                     smaller half of the partition.

   <b>K-CENTER</b> <b>PROBLEM</b>
       Definitions:

              <u>Unweighted</u> <u>K-Center</u>
                     For  any  set  <u>S</u>  (  which is subset of <u>V</u> ) and node <u>v</u>, let the <u>connect(v,S)</u> be the cost of
                     cheapest edge connecting <u>v</u> with any node in <u>S</u>. The goal is to find such <u>S</u>, that <u>|S|</u> <u>=</u> <u>k</u> and
                     <u>max_v{connect(v,S)}</u> is possibly small.

                     In other words, we can use it i.e. for finding best locations in the city ( nodes of  input
                     graph  ) for placing k buildings, such that those buildings will be as close as possible to
                     all other locations in town.

              <u>Weighted</u> <u>K-Center</u>
                     The variation of <u>unweighted</u> <u>k-center</u> <u>problem</u>. Besides  the  fact  graph  is  edge-weighted,
                     there are also weights on vertices of input graph <u>G</u>. We've got also restriction <u>W</u>. The goal
                     is  to choose such set of nodes <u>S</u> ( which is a subset of <u>V</u> ), that it's total weight is not
                     greater than <u>W</u> and also function: <u>max_v</u> <u>{</u> <u>min_u</u> <u>{</u> <u>cost(u,v)</u> <u>}}</u> has  the  smallest  possible
                     worth ( <u>v</u> is a node in <u>V</u> and <u>u</u> is a node in <u>S</u> ).

   <b>FLOW</b> <b>PROBLEMS</b>
       Definitions:

              •      <u>the</u>  <u>maximum</u>  <u>flow</u>  <u>problem</u>  - the goal is to find a feasible flow through a single-source,
                     single-sink flow network that is maximum.  The <u>maximum</u>  <u>flow</u>  <u>problem</u>  can  be  seen  as  a
                     special  case  of more complex network flow problems, such as the <u>circulation</u> <u>problem</u>.  The
                     maximum value of an <u>s-t</u> <u>flow</u> is equal to the minimum capacity of an <u>s-t</u> <u>cut</u> in the network,
                     as stated in the <u>max-flow</u> <u>min-cut</u> <u>theorem</u>.

                     More formally for flow network <u>G</u> <u>=</u> <u>(V,E)</u>, where for each edge <u>(u,</u> <u>v)</u> we have its throuhgput
                     <u>c(u,v)</u> defined. As <u>flow</u> <u>F</u> we define set of non-negative integer attributes <u>f(u,v)</u>  assigned
                     to edges, satisfying such conditions:

                     [1]    for  each  edge  <u>(u,</u> <u>v)</u> in <u>G</u> such condition should be satisfied:      0 &lt;= f(u,v) &lt;=
                            c(u,v)

                     [2]    Network <u>G</u> has source node <u>s</u> such that the flow <u>F</u> is equal to the  sum  of  outcoming
                            flow decreased by the sum of incoming flow from that source node <u>s</u>.

                     [3]    Network  <u>G</u>  has  sink  node  <u>t</u> such that the the <u>-F</u> value is equal to the sum of the
                            incoming flow decreased by the sum of outcoming flow from that sink node <u>t</u>.

                     [4]    For each node that is not a <u>source</u> or <u>sink</u> the sum  of  incoming  flow  and  sum  of
                            outcoming flow should be equal.

              •      <u>the</u>  <u>minimum</u> <u>cost</u> <u>flow</u> <u>problem</u> - the goal is finding the cheapest possible way of sending a
                     certain amount of flow through a <u>flow</u> <u>network</u>.

              •      <u>blocking</u> <u>flow</u> - a <u>blocking</u> <u>flow</u> for a <u>residual</u> <u>network</u> <u>Gf</u> we name such flow <u>b</u> in <u>Gf</u> that:

                     [1]    Each path from <u>sink</u> to <u>source</u> is the shortest path in <u>Gf</u>.

                     [2]    Each shortest path in <u>Gf</u> contains an edge with fully used throughput in <u>Gf+b</u>.

              •      <u>residual</u> <u>network</u> - for a flow network <u>G</u> and flow <u>f</u> <u>residual</u> <u>network</u>  is  built  with  those
                     edges, which can send larger flow. It contains only those edges, which can send flow larger
                     than 0.

              •      <u>level</u>  <u>network</u>  -  it has the same set of nodes as <u>residual</u> <u>graph</u>, but has only those edges
                     <u>(u,v)</u> from <u>Gf</u> for which such equality is satisfied: <u>distance(s,u)+1</u> <u>=</u> <u>distance(s,v)</u>.

              •      <u>augmenting</u> <u>network</u> - it is a modification of <u>residual</u>  <u>network</u>  considering  the  new  flow
                     values.  Structure  stays  unchanged  but  values  of  throughputs  and  costs at edges are
                     different.

   <b>APPROXIMATION</b> <b>ALGORITHM</b>
       k-approximation algorithm:
              Algorithm is a k-approximation, when for <u>ALG</u> (solution returned by  algorithm)  and  <u>OPT</u>  (optimal
              solution), such inequality is true:

              •      for minimalization problems: <u>ALG/OPT</u> <u>&lt;=</u> <u>k</u>

              •      for maximalization problems: <u>OPT/ALG</u> <u>&lt;=</u> <u>k</u>

</pre><h4><b>REFERENCES</b></h4><pre>
       [1]    <u>Adjacency</u> <u>matrix</u> [<a href="http://en.wikipedia.org/wiki/Adjacency_matrix">http://en.wikipedia.org/wiki/Adjacency_matrix</a>]

       [2]    <u>Adjacency</u> <u>list</u> [<a href="http://en.wikipedia.org/wiki/Adjacency_list">http://en.wikipedia.org/wiki/Adjacency_list</a>]

       [3]    <u>Kruskal's</u> <u>algorithm</u> [<a href="http://en.wikipedia.org/wiki/Kruskal">http://en.wikipedia.org/wiki/Kruskal</a>%27s_algorithm]

       [4]    <u>Prim's</u> <u>algorithm</u> [<a href="http://en.wikipedia.org/wiki/Prim">http://en.wikipedia.org/wiki/Prim</a>%27s_algorithm]

       [5]    <u>Bipartite</u> <u>graph</u> [<a href="http://en.wikipedia.org/wiki/Bipartite_graph">http://en.wikipedia.org/wiki/Bipartite_graph</a>]

       [6]    <u>Strongly</u> <u>connected</u> <u>components</u> [<a href="http://en.wikipedia.org/wiki/Strongly_connected_components">http://en.wikipedia.org/wiki/Strongly_connected_components</a>]

       [7]    <u>Tarjan's</u>              <u>strongly</u>              <u>connected</u>             <u>components</u>             <u>algorithm</u>
              [<a href="http://en.wikipedia.org/wiki/Tarjan">http://en.wikipedia.org/wiki/Tarjan</a>%27s_strongly_connected_components_algorithm]

       [8]    <u>Cut</u> <u>vertex</u> [<a href="http://en.wikipedia.org/wiki/Cut_vertex">http://en.wikipedia.org/wiki/Cut_vertex</a>]

       [9]    <u>Bridge</u> [<a href="http://en.wikipedia.org/wiki/Bridge_">http://en.wikipedia.org/wiki/Bridge_</a>(graph_theory)]

       [10]   <u>Bellman-Ford's</u> <u>algorithm</u> [<a href="http://en.wikipedia.org/wiki/Bellman-Ford_algorithm">http://en.wikipedia.org/wiki/Bellman-Ford_algorithm</a>]

       [11]   <u>Johnson's</u> <u>algorithm</u> [<a href="http://en.wikipedia.org/wiki/Johnson_algorithm">http://en.wikipedia.org/wiki/Johnson_algorithm</a>]

       [12]   <u>Floyd-Warshall's</u> <u>algorithm</u> [<a href="http://en.wikipedia.org/wiki/Floyd-Warshall_algorithm">http://en.wikipedia.org/wiki/Floyd-Warshall_algorithm</a>]

       [13]   <u>Travelling</u> <u>Salesman</u> <u>Problem</u> [<a href="http://en.wikipedia.org/wiki/Travelling_salesman_problem">http://en.wikipedia.org/wiki/Travelling_salesman_problem</a>]

       [14]   <u>Christofides</u> <u>Algorithm</u> [<a href="http://en.wikipedia.org/wiki/Christofides_algorithm">http://en.wikipedia.org/wiki/Christofides_algorithm</a>]

       [15]   <u>Max</u> <u>Cut</u> [<a href="http://en.wikipedia.org/wiki/Maxcut">http://en.wikipedia.org/wiki/Maxcut</a>]

       [16]   <u>Matching</u> [<a href="http://en.wikipedia.org/wiki/Matching">http://en.wikipedia.org/wiki/Matching</a>]

       [17]   <u>Max</u> <u>Independent</u> <u>Set</u> [<a href="http://en.wikipedia.org/wiki/Maximal_independent_set">http://en.wikipedia.org/wiki/Maximal_independent_set</a>]

       [18]   <u>Vertex</u> <u>Cover</u> [<a href="http://en.wikipedia.org/wiki/Vertex_cover_problem">http://en.wikipedia.org/wiki/Vertex_cover_problem</a>]

       [19]   <u>Ford-Fulkerson's</u> <u>algorithm</u> [<a href="http://en.wikipedia.org/wiki/Ford-Fulkerson_algorithm">http://en.wikipedia.org/wiki/Ford-Fulkerson_algorithm</a>]

       [20]   <u>Maximum</u> <u>Flow</u> <u>problem</u> [<a href="http://en.wikipedia.org/wiki/Maximum_flow_problem">http://en.wikipedia.org/wiki/Maximum_flow_problem</a>]

       [21]   <u>Busacker-Gowen's</u> <u>algorithm</u> [<a href="http://en.wikipedia.org/wiki/Minimum_cost_flow_problem">http://en.wikipedia.org/wiki/Minimum_cost_flow_problem</a>]

       [22]   <u>Dinic's</u> <u>algorithm</u> [<a href="http://en.wikipedia.org/wiki/Dinic">http://en.wikipedia.org/wiki/Dinic</a>'s_algorithm]

       [23]   <u>K-Center</u> <u>problem</u> [<a href="http://www.csc.kth.se/~viggo/wwwcompendium/node128.html">http://www.csc.kth.se/~viggo/wwwcompendium/node128.html</a>]

       [24]   <u>BFS</u> [<a href="http://en.wikipedia.org/wiki/Breadth-first_search">http://en.wikipedia.org/wiki/Breadth-first_search</a>]

       [25]   <u>Minimum</u> <u>Degree</u> <u>Spanning</u> <u>Tree</u> [<a href="http://en.wikipedia.org/wiki/Degree-constrained_spanning_tree">http://en.wikipedia.org/wiki/Degree-constrained_spanning_tree</a>]

       [26]   <u>Approximation</u> <u>algorithm</u> [<a href="http://en.wikipedia.org/wiki/Approximation_algorithm">http://en.wikipedia.org/wiki/Approximation_algorithm</a>]

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report     such     in     the     category     <u>struct</u>     <u>::</u>    <u>graph</u>    of    the    <u>Tcllib</u>    <u>Trackers</u>
       [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please also report any ideas for enhancements you may  have  for
       either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       adjacency  list, adjacency matrix, adjacent, approximation algorithm, arc, articulation point, augmenting
       network, augmenting path, bfs, bipartite, blocking flow, bridge, complete graph, connected component, cut
       edge, cut vertex, degree, degree constrained spanning tree, diameter, dijkstra,  distance,  eccentricity,
       edge,  flow  network,  graph,  heuristic,  independent  set, isthmus, level graph, local searching, loop,
       matching, max cut, maximum flow, minimal spanning tree, minimum cost flow, minimum degree spanning  tree,
       minimum  diameter  spanning  tree, neighbour, node, radius, residual graph, shortest path, squared graph,
       strongly connected component, subgraph, travelling salesman, vertex, vertex cover

</pre><h4><b>CATEGORY</b></h4><pre>
       Data structures

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2008 Alejandro Paz &lt;<a href="mailto:vidriloco@gmail.com">vidriloco@gmail.com</a>&gt;
       Copyright (c) 2008 (docs) Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;
       Copyright (c) 2009 Michal Antoniewski &lt;<a href="mailto:antoniewski.m@gmail.com">antoniewski.m@gmail.com</a>&gt;

tcllib                                               0.11.4                              <u>struct::graph::<a href="../man3tcl/op.3tcl.html">op</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>