<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph::Easy::Parser - Parse Graph::Easy from textual description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgraph-easy-perl">libgraph-easy-perl_0.76-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Graph::Easy::Parser - Parse Graph::Easy from textual description

</pre><h4><b>SYNOPSIS</b></h4><pre>
               # creating a graph from a textual description
               use Graph::Easy::Parser;
               my $parser = Graph::Easy::Parser-&gt;new();

               my $graph = $parser-&gt;from_text(
                       '[ Bonn ] =&gt; [ Berlin ]'.
                       '[ Berlin ] =&gt; [ Rostock ]'.
               );
               print $graph-&gt;as_ascii();

               print $parser-&gt;from_file('mygraph.txt')-&gt;as_ascii();

               # Also works automatically on graphviz code:
               print Graph::Easy::Parser-&gt;from_file('mygraph.dot')-&gt;as_ascii();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Graph::Easy::Parser" lets you parse simple textual descriptions of graphs, and constructs a
       "Graph::Easy" object from them.

       The resulting object can than be used to layout and output the graph.

   <b>Input</b>
       The input consists of text describing the graph, encoded in UTF-8.

       Example:

               [ Bonn ]      --&gt; [ Berlin ]
               [ Frankfurt ] &lt;=&gt; [ Dresden ]
               [ Bonn ]      --&gt; [ Frankfurt ]
               [ Bonn ]      = &gt; [ Frankfurt ]

       <u>Graphviz</u>

       In addition there is a bit of magic that detects graphviz code, so input of the following form will also
       work:

               digraph Graph1 {
                       "Bonn" -&gt; "Berlin"
               }

       Note that the magic detection only works for <b>named</b> graphs or graph with "digraph" at their start, so the
       following will not be detected as graphviz code because it looks exactly like valid Graph::Easy code at
       the start:

               graph {
                       "Bonn" -&gt; "Berlin"
               }

       See Graph::Easy::Parser::Graphviz for more information about parsing graphs in the DOT language.

       <u>VCG</u>

       In addition there is a bit of magic that detects VCG code, so input of the following form will also work:

               graph: {
                       node: { title: Bonn; }
                       node: { title: Berlin; }
                       edge: { sourcename: Bonn; targetname: Berlin; }
               }

       See Graph::Easy::Parser::VCG for more information about parsing graphs in the VCG language.

   <b>Input</b> <b>Syntax</b>
       This is a <b>very</b> brief description of the syntax for the Graph::Easy language, for a full specification,
       please see Graph::Easy::Manual.

       nodes
         Nodes are rendered (or "quoted", if you wish) with enclosing square brackets:

                 [ Single node ]
                 [ Node A ] --&gt; [ Node B ]

         Anonymous nodes do not have a name and cannot be referred to again:

                 [ ] -&gt; [ Bonn ] -&gt; [ ]

         This creates three nodes, two of them anonymous.

       edges
         The edges between the nodes can have the following styles:

                 -&gt;              solid
                 =&gt;              double
                 .&gt;              dotted
                 ~&gt;              wave

                 - &gt;             dashed
                 .-&gt;             dot-dash
                 ..-&gt;            dot-dot-dash
                 = &gt;             double-dash

         There  are also the styles "bold", "wide" and "broad". Unlike the others, these can only be set via the
         (optional) edge attributes:

                 [ AB ] --&gt; { style: bold; } [ ABC ]

         You can repeat each of the style-patterns as much as you like:

                 ---&gt;
                 ==&gt;
                 =&gt;
                 ~~~~~&gt;
                 ..-..-..-&gt;

         Note that in patterns longer than  one  character,  the  entire  pattern  must  be  repeated  e.g.  all
         characters of the pattern must be present. Thus:

                 ..-..-..-&gt;      # valid dot-dot-dash
                 ..-..-..&gt;       # invalid!

                 .-.-.-&gt;         # valid dot-dash
                 .-.-&gt;           # invalid!

         In addition to the styles, the following two directions are possible:

                  --             edge without arrow heads
                  --&gt;            arrow at target node (end point)
                 &lt;--&gt;            arrow on both the source and target node
                                 (end and start point)

         Of  course  you  can  combine  all  directions with all styles. However, note that edges without arrows
         cannot use the shortcuts for styles:

                 ---             # valid
                 .-.-            # valid
                 .-              # invalid!
                 -               # invalid!
                 ~               # invalid!

         Just remember to use at least two repititions of the full pattern for arrow-less edges.

         You can also give edges a label, either by inlining it into  the  style,  or  by  setting  it  via  the
         attributes:

                 [ AB ] --&gt; { style: bold; label: foo; } [ ABC ]

                 -- foo --&gt;
                 ... baz ...&gt;

                 -- solid --&gt;
                 == double ==&gt;
                 .. dotted ..&gt;
                 ~~ wave ~~&gt;

                 -  dashed - &gt;
                 =  double-dash = &gt;
                 .- dot-dash .-&gt;
                 ..- dot-dot-dash ..-&gt;

         Note  that  the  two  patterns on the left and right of the label must be the same, and that there is a
         space between the left pattern and the label, as well as the label and the right pattern.

         You may use inline label only with edges that have an arrow. Thus:

                 &lt;-- label --&gt;   # valid
                 -- label --&gt;    # valid

                 -- label --     # invalid!

         To use a label with an edge without arrow heads, use the attributes:

                 [ AB ] -- { label: edgelabel; } [ CD ]

       groups
         Round brackets are used to group nodes together:

                 ( Cities:

                         [ Bonn ] -&gt; [ Berlin ]
                 )

         Anonymous groups do not have a name and cannot be referred to again:

                 ( [ Bonn ] ) -&gt; [ Berlin ]

         This creates an anonymous group with the node "Bonn" in it, and links it to the node "Berlin".

       Please see Graph::Easy::Manual for a full description of the syntax rules.

   <b>Output</b>
       The output will be a Graph::Easy object (unless overridden with "use_class()"), see the documentation for
       Graph::Easy what you can do with it.

</pre><h4><b>EXAMPLES</b></h4><pre>
       See Graph::Easy for an extensive list of examples.

</pre><h4><b>METHODS</b></h4><pre>
       "Graph::Easy::Parser" supports the following methods:

   <b>new()</b>
               use Graph::Easy::Parser;
               my $parser = Graph::Easy::Parser-&gt;new();

       Creates a new parser object. The valid parameters are:

               debug
               fatal_errors

       The first will enable debug output to STDERR:

               my $parser = Graph::Easy::Parser-&gt;new( debug =&gt; 1 );
               $parser-&gt;from_text('[A] -&gt; [ B ]');

       Setting "fatal_errors" to 0 will make parsing errors not die, but just set an error string, which can  be
       retrieved with <b>error()</b>.

               my $parser = Graph::Easy::Parser-&gt;new( fatal_errors =&gt; 0 );
               $parser-&gt;from_text(' foo ' );
               print $parser-&gt;error();

       See also <b>catch_messages()</b> for how to catch errors and warnings.

   <b>reset()</b>
               $parser-&gt;reset();

       Reset  the  status  of  the  parser,  clear  errors  etc.  Automatically  called when you call any of the
       "from_XXX()" methods below.

   <b>use_class()</b>
               $parser-&gt;use_class('node', 'Graph::Easy::MyNode');

       Override the class to be used to constructs objects while parsing. The first parameter can be one of  the
       following:

               node
               edge
               graph
               group

       The second parameter should be a class that is a subclass of the appropriate base class:

               package Graph::Easy::MyNode;

               use base qw/Graph::Easy::Node/;

               # override here methods for your node class

               ######################################################
               # when overriding nodes, we also need ::Anon

               package Graph::Easy::MyNode::Anon;

               use base qw/Graph::Easy::MyNode/;
               use base qw/Graph::Easy::Node::Anon/;

               ######################################################
               # and :::Empty

               package Graph::Easy::MyNode::Empty;

               use base qw/Graph::Easy::MyNode/;

               ######################################################
               package main;

               use Graph::Easy::Parser;
               use Graph::Easy;

               use Graph::Easy::MyNode;
               use Graph::Easy::MyNode::Anon;
               use Graph::Easy::MyNode::Empty;

               my $parser = Graph::Easy::Parser;

               $parser-&gt;use_class('node', 'Graph::Easy::MyNode');

               my $graph = $parser-&gt;from_text(...);

       The   object   $graph   will  now  contain  nodes  that  are  of  your  custom  class  instead  of  plain
       "Graph::Easy::Node".

       When  overriding  nodes,  you  also  should  provide   subclasses   for   "Graph::Easy::Node::Anon"   and
       "Graph::Easy::Node::Empty",  and  make  these  subclasses  of  your custom node class as shown above. For
       edges, groups and graphs, you need just one subclass.

   <b>from_text()</b>
               my $graph = $parser-&gt;from_text( $text );

       Create a Graph::Easy object from the textual description in $text.

       Returns undef for error, you can find out what the error was with <b>error()</b>.

       This method will reset any previous error, and thus the $parser object can be re-used to parse  different
       texts by just calling "from_text()" multiple times.

   <b>from_file()</b>
               my $graph = $parser-&gt;from_file( $filename );
               my $graph = Graph::Easy::Parser-&gt;from_file( $filename );

       Creates a Graph::Easy object from the textual description in the file $filename.

       The  second calling style will create a temporary "Graph::Easy::Parser" object, parse the file and return
       the resulting "Graph::Easy" object.

       Returns undef for error, you can find out what the error was with <b>error()</b> when using  the  first  calling
       style.

   <b>error()</b>
               my $error = $parser-&gt;error();

       Returns the last error, or the empty string if no error occurred.

       If you want to catch warnings from the parser, enable catching of warnings or errors:

               $parser-&gt;<a href="../man1/catch_messages.1.html">catch_messages</a>(1);

               # Or individually:
               # $parser-&gt;<a href="../man1/catch_warnings.1.html">catch_warnings</a>(1);
               # $parser-&gt;<a href="../man1/catch_errors.1.html">catch_errors</a>(1);

               # something which warns or throws an error:
               ...

               if ($parser-&gt;error())
                 {
                 my @errors = $parser-&gt;errors();
                 }
               if ($parser-&gt;warning())
                 {
                 my @warnings = $parser-&gt;warnings();
                 }

       See Graph::Easy::Base for more details on error/warning message capture.

   <b>parse_error()</b>
               $parser-&gt;parse_error( $msg_nr, @params);

       Sets  an  error  message from a message number and replaces embedded templates like "##param1##" with the
       passed parameters.

   <b>_parse_attributes()</b>
               my $attributes = $parser-&gt;_parse_attributes( $txt, $class );
               my ($att, $multiples) = $parser-&gt;_parse_attributes( $txt, $class );

       <b>Internal</b> <b>usage</b> <b>only</b>. Takes a text like this:

               attribute: value;  attribute2 : value2;

       and returns a hash with the attributes.

       In list context, also returns the max count of multiple attributes, e.g.  3 when it encounters  something
       like "red|green|blue". When

</pre><h4><b>EXPORT</b></h4><pre>
       Exports nothing.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Graph::Easy. Graph::Easy::Parser::Graphviz and Graph::Easy::Parser::VCG.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) 2004 - 2007 by Tels &lt;<a href="http://bloodgate.com">http://bloodgate.com</a>&gt;

       See the LICENSE file for information.

perl v5.36.0                                       2022-11-20                           <u>Graph::Easy::<a href="../man3pm/Parser.3pm.html">Parser</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>