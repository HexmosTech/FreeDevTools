<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph::Easy - Convert or render graphs (as ASCII, HTML, SVG or via Graphviz)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgraph-easy-perl">libgraph-easy-perl_0.76-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Graph::Easy - Convert or render graphs (as ASCII, HTML, SVG or via Graphviz)

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Graph::Easy;

               my $graph = Graph::Easy-&gt;new();

               # make a fresh copy of the graph
               my $new_graph = $graph-&gt;copy();

               $graph-&gt;add_edge ('Bonn', 'Berlin');

               # will not add it, since it already exists
               $graph-&gt;add_edge_once ('Bonn', 'Berlin');

               print $graph-&gt;as_ascii( );              # prints:

               # +------+     +--------+
               # | Bonn | --&gt; | Berlin |
               # +------+     +--------+

               #####################################################
               # alternatively, let Graph::Easy parse some text:

               my $graph = Graph::Easy-&gt;new( '[Bonn] -&gt; [Berlin]' );

               #####################################################
               # slightly more verbose way:

               my $graph = Graph::Easy-&gt;new();

               my $bonn = $graph-&gt;add_node('Bonn');
               $bonn-&gt;set_attribute('border', 'solid 1px black');

               my $berlin = $graph-&gt;add_node('Berlin');

               $graph-&gt;add_edge ($bonn, $berlin);

               print $graph-&gt;as_ascii( );

               # You can use plain scalars as node names and for the edge label:
               $graph-&gt;add_edge ('Berlin', 'Frankfurt', 'via train');

               # adding edges with attributes:

               my $edge = Graph::Easy::Edge-&gt;new();
               $edge-&gt;set_attributes( {
                       label =&gt; 'train',
                       style =&gt; 'dotted',
                       color =&gt; 'red',
               } );

               # now with the optional edge object
               $graph-&gt;add_edge ($bonn, $berlin, $edge);

               # raw HTML section
               print $graph-&gt;as_html( );

               # complete HTML page (with CSS)
               print $graph-&gt;as_html_file( );

               # Other possibilities:

               # SVG (possible after you installed Graph::Easy::As_svg):
               print $graph-&gt;as_svg( );

               # Graphviz:
               my $graphviz = $graph-&gt;as_graphviz();
               open $DOT, '|dot -Tpng -o graph.png' or die ("Cannot open pipe to dot: $!");
               print $DOT $graphviz;
               close $DOT;

               # Please see also the command line utility 'graph-easy'

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Graph::Easy" lets you generate graphs consisting of various shaped nodes connected by edges (with
       optional labels).

       It can read and write graphs in a variety of formats, as well as render them via its own grid-based
       layouter.

       Since the layouter works on a grid (manhattan layout), the output is most useful for flow charts, network
       diagrams, or hierarchy trees.

   <b>Input</b>
       Apart from driving the module with Perl code, you can also use "Graph::Easy::Parser" to parse graph
       descriptions like:

               [ Bonn ]      --&gt; [ Berlin ]
               [ Frankfurt ] &lt;=&gt; [ Dresden ]
               [ Bonn ]      --  [ Frankfurt ]

       See the "EXAMPLES" section below for how this might be rendered.

   <b>Creating</b> <b>graphs</b>
       First, create a graph object:

               my $graph = Graph::Easy-&gt;new();

       Then add a node to it:

               my $node = $graph-&gt;add_node('Koblenz');

       Don't worry, adding the node again will do nothing:

               $node = $graph-&gt;add_node('Koblenz');

       You can get back a node by its name with "node()":

               $node = $graph-&gt;node('Koblenz');

       You can either add another node:

               my $second = $graph-&gt;node('Frankfurt');

       Or add an edge straight-away:

               my ($first,$second,$edge) = $graph-&gt;add_edge('Mainz','Ulm');

       Adding the edge the second time creates another edge from 'Mainz' to 'Ulm':

               my $other_edge;
                ($first,$second,$other_edge) = $graph-&gt;add_edge('Mainz','Ulm');

       This can be avoided by using "add_edge_once()":

               my $edge = $graph-&gt;add_edge_once('Mainz','Ulm');
               if (defined $edge)
                 {
                 # the first time the edge was added, do something with it
                 $edge-&gt;set_attribute('color','blue');
                 }

       You can set attributes on nodes and edges:

               $node-&gt;attribute('fill', 'yellow');
               $edge-&gt;attribute('label', 'train');

       It is possible to add an edge with a label:

               $graph-&gt;add_edge('Cottbus', 'Berlin', 'my label');

       You can also add self-loops:

               $graph-&gt;add_edge('Bremen','Bremen');

       Adding multiple nodes is easy:

               my ($bonn,$rom) = Graph::Easy-&gt;add_nodes('Bonn','Rom');

       You can also have subgraphs (these are called groups):

               my ($group) = Graph::Easy-&gt;add_group('Cities');

       Only nodes can be part of a group, edges are automatically considered to be in the group if they lead
       from one node inside the group to another node in the same group. There are multiple ways to add one or
       more nodes into a group:

               $group-&gt;add_member($bonn);
               $group-&gt;add_node($rom);
               $group-&gt;add_nodes($rom,$bonn);

       For more options please see the online manual: &lt;<a href="http://bloodgate.com/perl/graph/manual/">http://bloodgate.com/perl/graph/manual/</a>&gt; .

   <b>Output</b>
       The output can be done in various styles:

       ASCII ART
         Uses things like "+", "-" "&lt;" and "|" to render the boxes.

       BOXART
         Uses Unicode box art drawing elements to output the graph.

       HTML
         HTML tables with CSS making everything "pretty".

       SVG
         Creates a Scalable Vector Graphics output.

       Graphviz
         Creates graphviz code that can be feed to 'dot', 'neato' or similar programs.

       GraphML
         Creates a textual description of the graph in the GraphML format.

       GDL/VCG
         Creates a textual description of the graph in the VCG or GDL (Graph Description Language) format.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following examples are given in the simple text format that is understood by Graph::Easy::Parser.

       You can also see many more examples at:

       &lt;<a href="http://bloodgate.com/perl/graph/">http://bloodgate.com/perl/graph/</a>&gt;

   <b>One</b> <b>node</b>
       The most simple graph (apart from the empty one :) is a graph consisting of only one node:

               [ Dresden ]

   <b>Two</b> <b>nodes</b>
       A simple graph consisting of two nodes, linked together by a directed edge:

               [ Bonn ] -&gt; [ Berlin ]

   <b>Three</b> <b>nodes</b>
       A graph consisting of three nodes, and both are linked from the first:

               [ Bonn ] -&gt; [ Berlin ]
               [ Bonn ] -&gt; [ Hamburg ]

   <b>Three</b> <b>nodes</b> <b>in</b> <b>a</b> <b>chain</b>
       A graph consisting of three nodes, showing that you can chain connections together:

               [ Bonn ] -&gt; [ Berlin ] -&gt; [ Hamburg ]

   <b>Two</b> <b>not</b> <b>connected</b> <b>graphs</b>
       A graph consisting of two separate parts, both of them not connected to each other:

               [ Bonn ] -&gt; [ Berlin ]
               [ Freiburg ] -&gt; [ Hamburg ]

   <b>Three</b> <b>nodes,</b> <b>interlinked</b>
       A graph consisting of three nodes, and two of the are connected from the first node:

               [ Bonn ] -&gt; [ Berlin ]
               [ Berlin ] -&gt; [ Hamburg ]
               [ Bonn ] -&gt; [ Hamburg ]

   <b>Different</b> <b>edge</b> <b>styles</b>
       A graph consisting of a couple of nodes, linked with the different possible edge styles.

               [ Bonn ] &lt;-&gt; [ Berlin ]         # bidirectional
               [ Berlin ] ==&gt; [ Rostock ]      # double
               [ Hamburg ] ..&gt; [ Altona ]      # dotted
               [ Dresden ] - &gt; [ Bautzen ]     # dashed
               [ Leipzig ] ~~&gt; [ Kirchhain ]   # wave
               [ Hof ] .-&gt; [ Chemnitz ]        # dot-dash
               [ Magdeburg ] &lt;=&gt; [ Ulm ]       # bidrectional, double etc
               [ Magdeburg ] -- [ Ulm ]        # arrow-less edge

       More examples at: &lt;<a href="http://bloodgate.com/perl/graph/">http://bloodgate.com/perl/graph/</a>&gt;

</pre><h4><b>ANIMATION</b> <b>SUPPORT</b></h4><pre>
       <b>Note:</b> <b>Animations</b> <b>are</b> <b>not</b> <b>yet</b> <b>implemented!</b>

       It is possible to add animations to a graph. This is done by adding <u>steps</u> via the pseudo-class "step":

               step.0 {
                 target: Bonn;         # find object with id=Bonn, or
                                       # if this fails, the node named
                                       # "Bonn".
                 animate: fill:        # animate this attribute
                 from: yellow;         # start value (0% of duration)
                 via: red;             # at 50% of the duration
                 to: yellow;           # and 100% of duration
                 wait: 0;              # after triggering, wait so many seconds
                 duration: 5;          # entire time to go from "from" to "to"
                 trigger: onload;      # when to trigger this animation
                 repeat: 2;            # how often to repeat ("2" means two times)
                                       # also "infinite", then "next" will be ignored
                 next: 1;              # which step to take after repeat is up
               }
               step.1 {
                 from: white;          # set to white
                 to: white;
                 duration: 0.1;        # 100ms
                 next: 0;              # go back to step.0
               }

       Here two steps are created, <u>0</u> and <u>1</u> and the animation will be going like this:

                                      0.1s
                                    +-------------------------------+
                                    v                               |
               +--------+  0s   +--------+  5s   +--------+  5s   +--------+
               | onload | ----&gt; | step.0 | ----&gt; | step.0 | ----&gt; | step.1 |
               +--------+       +--------+       +--------+       +--------+

       You can generate a a graph with the animation flow via "animation_as_graph()".

   <b>Output</b>
       Currently no output formats supports animations yet.

</pre><h4><b>METHODS</b></h4><pre>
       "Graph::Easy" supports the following methods:

   <b>new()</b>
               use Graph::Easy;

               my $graph = Graph::Easy-&gt;new( );

       Creates a new, empty "Graph::Easy" object.

       Takes optional a hash reference with a list of options. The following are valid options:

               debug                   if true, enables debug output
               timeout                 timeout (in seconds) for the layouter
               fatal_errors            wrong attributes are fatal errors, default: true
               strict                  test attribute names for being valid, default: true
               undirected              create an undirected graph, default: false

   <b>copy()</b>
           my $copy = $graph-&gt;copy( );

       Create a copy of this graph and return it as a new Graph::Easy object.

   <b>error()</b>
               my $error = $graph-&gt;error();

       Returns the last error or '' for none.  Optionally, takes an error message to be set.

               $graph-&gt;error( 'Expected Foo, but found Bar.' );

       See  <b>warn()</b>  on  how  to  catch  error  messages.  See also <b>non_fatal_errors()</b> on how to turn errors into
       warnings.

   <b>warn()</b>
               my $warning = $graph-&gt;warn();

       Returns the last warning or '' for none.  Optionally, takes a warning message to be output to STDERR:

               $graph-&gt;warn( 'Expected Foo, but found Bar.' );

       If you want to catch warnings from the layouter, enable catching of warnings or errors:

               $graph-&gt;<a href="../man1/catch_messages.1.html">catch_messages</a>(1);

               # Or individually:
               # $graph-&gt;<a href="../man1/catch_warnings.1.html">catch_warnings</a>(1);
               # $graph-&gt;<a href="../man1/catch_errors.1.html">catch_errors</a>(1);

               # something which warns or throws an error:
               ...

               if ($graph-&gt;error())
                 {
                 my @errors = $graph-&gt;errors();
                 }
               if ($graph-&gt;warning())
                 {
                 my @warnings = $graph-&gt;warnings();
                 }

       See Graph::Easy::Base for more details on error/warning message capture.

   <b>add_edge()</b>
               my ($first, $second, $edge) = $graph-&gt;add_edge( 'node 1', 'node 2');

   <b>add_edge()</b>
               my ($first, $second, $edge) = $graph-&gt;add_edge( 'node 1', 'node 2');
               my $edge = $graph-&gt;add_edge( $x, $y, $edge);
               $graph-&gt;add_edge( $x, $y);

       Add an edge between nodes X and Y. The optional edge object  defines  the  style  of  the  edge,  if  not
       present, a default object will be used.

       When  called in scalar context, will return $edge. In array/list context it will return the two nodes and
       the edge object.

       $x and $y should be either plain scalars with the names of the nodes, or  objects  of  Graph::Easy::Node,
       while the optional $edge should be Graph::Easy::Edge.

       Note: "Graph::Easy" graphs are multi-edged, and adding the same edge twice will result in two edges going
       from $x to $y! See "add_edge_once()" on how to avoid that.

       You can also use "edge()" to check whether an edge from X to Y already exists in the graph.

   <b>add_edge_once()</b>
               my ($first, $second, $edge) = $graph-&gt;add_edge_once( 'node 1', 'node 2');
               my $edge = $graph-&gt;add_edge_once( $x, $y, $edge);
               $graph-&gt;add_edge_once( $x, $y);

               if (defined $edge)
                 {
                 # got added once, so do something with it
                 $edge-&gt;set_attribute('label','unique');
                 }

       Adds  an  edge  between  nodes  X and Y, unless there exists already an edge between these two nodes. See
       "add_edge()".

       Returns undef when an edge between X and Y already exists.

       When called in scalar context, will return $edge. In array/list context it will return the two nodes  and
       the edge object.

   <b>flip_edges()</b>
               my $graph = Graph::Easy-&gt;new();
               $graph-&gt;add_edge('Bonn','Berlin');
               $graph-&gt;add_edge('Berlin','Bonn');

               print $graph-&gt;as_ascii();

               #   +--------------+
               #   v              |
               # +--------+     +------+
               # | Berlin | --&gt; | Bonn |
               # +--------+     +------+

               $graph-&gt;flip_edges('Bonn', 'Berlin');

               print $graph-&gt;as_ascii();

               #   +--------------+
               #   |              v
               # +--------+     +------+
               # | Berlin | --&gt; | Bonn |
               # +--------+     +------+

       Turn around (transpose) all edges that are going from the first node to the second node.

   <b>add_node()</b>
               my $node = $graph-&gt;add_node( 'Node 1' );
               # or if you already have a Graph::Easy::Node object:
               $graph-&gt;add_node( $x );

       Add  a single node X to the graph. $x should be either a "Graph::Easy::Node" object, or a unique name for
       the node. Will do nothing if the node already exists in the graph.

       It returns an Graph::Easy::Node object.

   <b>add_anon_node()</b>
               my $anon_node = $graph-&gt;add_anon_node( );

       Creates a single, anonymous node and adds  it  to  the  graph,  returning  the  "Graph::Easy::Node::Anon"
       object.

       The created node is equal to one created via " [ ] " in the Graph::Easy text description.

   <b>add_nodes()</b>
               my @nodes = $graph-&gt;add_nodes( 'Node 1', 'Node 2' );

       Add  all  the given nodes to the graph. The arguments should be either a "Graph::Easy::Node" object, or a
       unique name for the node. Will do nothing if the node already exists in the graph.

       It returns a list of Graph::Easy::Node objects.

   <b>rename_node()</b>
               $node = $graph-&gt;rename_node($node, $new_name);

       Changes the name of a node. If the passed node is not part of this graph or just a  string,  it  will  be
       added with the new name to this graph.

       If  the  node  was  part  of another graph, it will be deleted there and added to this graph with the new
       name, effectively moving the node from the old to the new graph and renaming it at the same time.

   <b>del_node()</b>
               $graph-&gt;del_node('Node name');
               $graph-&gt;del_node($node);

       Delete the node with the given name from the graph.

   <b>del_edge()</b>
               $graph-&gt;del_edge($edge);

       Delete the given edge object from the graph. You can use "edge()" to find an edge from Node A to B:

               $graph-&gt;del_edge( $graph-&gt;edge('A','B') );

   <b>merge_nodes()</b>
               $graph-&gt;merge_nodes( $first_node, $second_node );
               $graph-&gt;merge_nodes( $first_node, $second_node, $joiner );

       Merge two nodes. Will delete all connections between the two nodes, then move over any connection to/from
       the second node to the first, then delete the second node from the graph.

       Any attributes on the second node will be lost.

       If present, the optional $joiner argument will be used to join the label of the second node to the  label
       of  the first node. If not present, the label of the second node will be dropped along with all the other
       attributes:

               my $graph = Graph::Easy-&gt;new('[A]-&gt;[B]-&gt;[C]-&gt;[D]');

               # this produces "[A]-&gt;[C]-&gt;[D]"
               $graph-&gt;merge_nodes( 'A', 'B' );

               # this produces "[A C]-&gt;[D]"
               $graph-&gt;merge_nodes( 'A', 'C', ' ' );

               # this produces "[A C \n D]", note single quotes on the third argument!
               $graph-&gt;merge_nodes( 'A', 'C', ' \n ' );

   <b>get_attribute()</b>
               my $value = $graph-&gt;get_attribute( $class, $name );

       Return the value of attribute $name from class $class.

       Example:

               my $color = $graph-&gt;attribute( 'node', 'color' );

       You can also call all the various attribute related  methods  on  members  of  the  graph  directly,  for
       instance:

               $node-&gt;get_attribute('label');
               $edge-&gt;get_attribute('color');
               $group-&gt;get_attribute('fill');

   <b>attribute()</b>
               my $value = $graph-&gt;attribute( $class, $name );

       Is an alias for get_attribute.

   <b>color_attribute()</b>
               # returns f.i. #ff0000
               my $color = $graph-&gt;get_color_attribute( 'node', 'color' );

       Just like <b>get_attribute()</b>, but only for colors, and returns them as hex, using the current colorscheme.

   <b>get_color_attribute()</b>
       Is an alias for <b>color_attribute()</b>.

   <b>get_attributes()</b>
               my $att = $object-&gt;get_attributes();

       Return  all  effective  attributes  on this object (graph/node/group/edge) as an anonymous hash ref. This
       respects inheritance and default values.

       Note that this does not include custom attributes.

       See also get_custom_attributes and <b>raw_attributes()</b>.

   <b>get_custom_attributes()</b>
               my $att = $object-&gt;get_custom_attributes();

       Return all the custom attributes on this object (graph/node/group/edge) as an anonymous hash ref.

   <b>custom_attributes()</b>
               my $att = $object-&gt;custom_attributes();

       "custom_attributes()" is an alias for get_custom_attributes.

   <b>raw_attributes()</b>
               my $att = $object-&gt;raw_attributes();

       Return all set attributes on this object (graph, node, group or edge) as an anonymous hash ref. Thus  you
       get all the locally active attributes for this object.

       Inheritance  is  respected,  e.g.  attributes  that have the value "inherit" and are inheritable, will be
       inherited from the base class.

       But default values for unset attributes are skipped. Here is an example:

               node { color: red; }

               [ A ] { class: foo; color: inherit; }

       This will return:

               { class =&gt; foo, color =&gt; red }

       As you can see, attributes like "background" etc. are not included, while the color value  was  inherited
       properly.

       See also <b>get_attributes()</b>.

   <b>default_attribute()</b>
               my $def = $graph-&gt;default_attribute($class, 'fill');

       Returns the default value for the given attribute <b>in</b> <b>the</b> <b>class</b> of the object.

       The  default  attribute  is the value that will be used if the attribute on the object itself, as well as
       the attribute on the class is unset.

       To find out what attribute is on the class, use the three-arg form of attribute on the graph:

               my $g = Graph::Easy-&gt;new();
               my $node = $g-&gt;add_node('Berlin');

               print $node-&gt;attribute('fill'), "\n";           # print "white"
               print $node-&gt;default_attribute('fill'), "\n";   # print "white"
               print $g-&gt;attribute('node','fill'), "\n";       # print "white"

               $g-&gt;set_attribute('node','fill','red');         # class is "red"
               $node-&gt;set_attribute('fill','green');           # this object is "green"

               print $node-&gt;attribute('fill'), "\n";           # print "green"
               print $node-&gt;default_attribute('fill'), "\n";   # print "white"
               print $g-&gt;attribute('node','fill'), "\n";       # print "red"

       See also <b>raw_attribute()</b>.

   <b>raw_attribute()</b>
               my $value = $object-&gt;raw_attribute( $name );

       Return the value of attribute $name from the object it this method is called on (graph, node, edge, group
       etc.). If the attribute is not set on the object itself, returns undef.

       This method respects inheritance, so an attribute value of 'inherit' on an object will  make  the  method
       return the inherited value:

               my $g = Graph::Easy-&gt;new();
               my $n = $g-&gt;add_node('A');

               $g-&gt;set_attribute('color','red');

               print $n-&gt;raw_attribute('color');               # undef
               $n-&gt;set_attribute('color','inherit');
               print $n-&gt;raw_attribute('color');               # 'red'

       See also <b>attribute()</b>.

   <b>raw_color_attribute()</b>
               # returns f.i. #ff0000
               my $color = $graph-&gt;raw_color_attribute('color' );

       Just like <b>raw_attribute()</b>, but only for colors, and returns them as hex, using the current colorscheme.

       If the attribute is not set on the object, returns "undef".

   <b>raw_attributes()</b>
               my $att = $object-&gt;raw_attributes();

       Returns  a  hash  with  all  the raw attributes of that object.  Attributes that are no set on the object
       itself, but on the class this object belongs to are <b>not</b> included.

       This method respects inheritance, so an attribute value of 'inherit' on an object will  make  the  method
       return the inherited value.

   <b>set_attribute()</b>
               # Set the attribute on the given class.
               $graph-&gt;set_attribute( $class, $name, $val );

               # Set the attribute on the graph itself. This is synonymous
               # to using 'graph' as class in the form above.
               $graph-&gt;set_attribute( $name, $val );

       Sets a given attribute named $name to the new value $val in the class specified in $class.

       Example:

               $graph-&gt;set_attribute( 'graph', 'gid', '123' );

       The  class can be one of "graph", "edge", "node" or "group". The last three can also have subclasses like
       in "node.subclassname".

       You can also call the various attribute related methods on members of the graph directly, for instance:

               $node-&gt;set_attribute('label', 'my node');
               $edge-&gt;set_attribute('color', 'red');
               $group-&gt;set_attribute('fill', 'green');

   <b>set_attributes()</b>
               $graph-&gt;set_attributes( $class, $att );

       Given a class name in $class and a hash of mappings between attribute names and values in $att, will  set
       all these attributes.

       The  class can be one of "graph", "edge", "node" or "group". The last three can also have subclasses like
       in "node.subclassname".

       Example:

               $graph-&gt;set_attributes( 'node', { color =&gt; 'red', background =&gt; 'none' } );

   <b>del_attribute()</b>
               $graph-&gt;del_attribute('border');

       Delete the attribute with the given name from the object.

       You can also call the various attribute related methods on members of the graph directly, for instance:

               $node-&gt;del_attribute('label');
               $edge-&gt;del_attribute('color');
               $group-&gt;del_attribute('fill');

   <b>unquote_attribute()</b>
               # returns '"Hello World!"'
               my $value = $self-&gt;unquote_attribute('node','label','"Hello World!"');
               # returns 'red'
               my $color = $self-&gt;unquote_attribute('node','color','"red"');

       Return the attribute unquoted except for labels and titles, that is it removes double quotes at the start
       and the end of the string, unless these are escaped with a backslash.

   <b>border_attribute()</b>
               my $border = $graph-&gt;border_attribute();

       Return the combined border attribute like "1px solid red" from the border(style|color|width) attributes.

   <b>split_border_attributes()</b>
               my ($style,$width,$color) = $graph-&gt;split_border_attribute($border);

       Split the border attribute (like "1px solid red") into the three different parts.

   <b>quoted_comment()</b>
               my $cmt = $node-&gt;comment();

       Comment of this object, quoted suitable as to be embedded into HTML/SVG.  Returns  the  empty  string  if
       this object doesn't have a comment set.

   <b>flow()</b>
               my $flow = $graph-&gt;flow();

       Returns the flow of the graph, as absolute number in degress.

   <b>source_nodes()</b>
               my @roots = $graph-&gt;source_nodes();

       Returns all nodes that have only outgoing edges, e.g. are the root of a tree, in no particular order.

       Isolated nodes (no edges at all) will <b>not</b> be included, see <b>predecessorless_nodes()</b> to get these, too.

       In scalar context, returns the number of source nodes.

   <b>predecessorless_nodes()</b>
               my @roots = $graph-&gt;predecessorless_nodes();

       Returns  all nodes that have no incoming edges, regardless of whether they have outgoing edges or not, in
       no particular order.

       Isolated nodes (no edges at all) <b>will</b> be included in the list.

       See also <b>source_nodes()</b>.

       In scalar context, returns the number of predecessorless nodes.

   <b>root_node()</b>
               my $root = $graph-&gt;root_node();

       Return the root node as Graph::Easy::Node object, if it was set with the 'root' attribute.

   <b>timeout()</b>
               print $graph-&gt;timeout(), " seconds timeout for layouts.\n";
               $graph-&gt;<a href="../man12/timeout.12.html">timeout</a>(12);

       Get/set the timeout for layouts in seconds. If the layout process did not finish after that time, it will
       be stopped and a warning will be printed.

       The default timeout is 5 seconds.

   <b>strict()</b>
               print "Graph has strict checking\n" if $graph-&gt;strict();
               $graph-&gt;strict(undef);          # disable strict attribute checks

       Get/set the strict option. When set to a true value, all attribute names  and  values  will  be  strictly
       checked and unknown/invalid one will be rejected.

       This option is on by default.

   <b>type()</b>
               print "Graph is " . $graph-&gt;type() . "\n";

       Returns the type of the graph as string, either "directed" or "undirected".

   <b>layout()</b>
               $graph-&gt;layout();
               $graph-&gt;layout( type =&gt; 'force', timeout =&gt; 60 );

       Creates the internal structures to layout the graph.

       This  method  will  be  called  automatically  when you call any of the "as_FOO" methods or "output()" as
       described below.

       The options are:

               type            the type of the layout, possible values:
                               'force'         - force based layouter
                               'adhoc'         - the default layouter
               timeout         timeout in seconds

       See also: <b>timeout()</b>.

   <b>output_format()</b>
               $graph-&gt;output_format('html');

       Set the outputformat. One of 'html', 'ascii', 'graphviz', 'svg' or 'txt'.  See also <b>output()</b>.

   <b>output()</b>
               my $out = $graph-&gt;output();

       Output the graph in the format set by "output_format()".

   <b>as_ascii()</b>
               print $graph-&gt;as_ascii();

       Return the graph layout in ASCII art, in utf-8.

   <b>as_ascii_file()</b>
               print $graph-&gt;as_ascii_file();

       Is an alias for as_ascii.

   <b>as_ascii_html()</b>
               print $graph-&gt;as_ascii_html();

       Return the graph layout in ASCII art, suitable to be embedded into an HTML page. Basically it  wraps  the
       output from <b>as_ascii()</b> into "&lt;pre&gt; &lt;/pre&gt;" and inserts real HTML links. The returned string is in utf-8.

   <b>as_boxart()</b>
               print $graph-&gt;as_box();

       Return the graph layout as box drawing using Unicode characters (in utf-8, as always).

   <b>as_boxart_file()</b>
               print $graph-&gt;as_boxart_file();

       Is an alias for "as_box".

   <b>as_boxart_html()</b>
               print $graph-&gt;as_boxart_html();

       Return  the  graph  layout as box drawing using Unicode characters, as chunk that can be embedded into an
       HTML page.

       Basically it wraps the output from <b>as_boxart()</b> into "&lt;pre&gt; &lt;/pre&gt;"  and  inserts  real  HTML  links.  The
       returned string is in utf-8.

   <b>as_boxart_html_file()</b>
               print $graph-&gt;as_boxart_html_file();

       Return the graph layout as box drawing using Unicode characters, as a full HTML page complete with header
       and footer.

   <b>as_html()</b>
               print $graph-&gt;as_html();

       Return  the  graph layout as HTML section. See <b>css()</b> to get the CSS section to go with that HTML code. If
       you want a complete HTML page then use <b>as_html_file()</b>.

   <b>as_html_page()</b>
               print $graph-&gt;as_html_page();

       Is an alias for "as_html_file".

   <b>as_html_file()</b>
               print $graph-&gt;as_html_file();

       Return the graph layout as HTML complete with headers, CSS section and  footer.  Can  be  viewed  in  the
       browser of your choice.

   <b>add_group()</b>
               my $group = $graph-&gt;add_group('Group name');

       Add a group to the graph and return it as Graph::Easy::Group object.

   <b>group()</b>
               my $group = $graph-&gt;group('Name');

       Returns the group with the name "Name" as Graph::Easy::Group object.

   <b>rename_group()</b>
               $group = $graph-&gt;rename_group($group, $new_name);

       Changes  the  name of the given group. If the passed group is not part of this graph or just a string, it
       will be added with the new name to this graph.

       If the group was part of another graph, it will be deleted there and added to this  graph  with  the  new
       name, effectively moving the group from the old to the new graph and renaming it at the same time.

   <b>groups()</b>
               my @groups = $graph-&gt;groups();

       Returns the groups of the graph as Graph::Easy::Group objects, in arbitrary order.

   <b>groups_within()</b>
               # equivalent to $graph-&gt;groups():
               my @groups = $graph-&gt;groups_within();           # all
               my @toplevel_groups = $graph-&gt;<a href="../man0/groups_within.0.html">groups_within</a>(0); # level 0 only

       Return the groups that are inside this graph, up to the specified level, in arbitrary order.

       The default level is -1, indicating no bounds and thus all contained groups are returned.

       A level of 0 means only the direct children, and hence only the toplevel groups will be returned. A level
       1 means the toplevel groups and their toplevel children, and so on.

   <b>anon_groups()</b>
               my $anon_groups = $graph-&gt;anon_groups();

       In scalar context, returns the number of anon groups (aka Graph::Easy::Group::Anon) the graph has.

       In list context, returns all anon groups as objects, in arbitrary order.

   <b>del_group()</b>
               $graph-&gt;del_group($name);

       Delete the group with the given name.

   <b>edges(),</b> <b>edges_within()</b>
               my @edges = $graph-&gt;edges();

       Returns the edges of the graph as Graph::Easy::Edge objects, in arbitrary order.

       <b>edges_within()</b> is an alias for "edges()".

   <b>is_simple_graph(),</b> <b>is_simple()</b>
               if ($graph-&gt;is_simple())
                 {
                 }

       Returns  true  if  the  graph does not have multiedges, e.g. if it does not have more than one edge going
       from any node to any other node or group.

       Since this method has to look at all edges, it is costly in terms of both CPU and memory.

   <b>is_directed()</b>
               if ($graph-&gt;is_directed())
                 {
                 }

       Returns true if the graph is directed.

   <b>is_undirected()</b>
               if ($graph-&gt;is_undirected())
                 {
                 }

       Returns true if the graph is undirected.

   <b>parent()</b>
               my $parent = $graph-&gt;parent();

       Returns the parent graph, for graphs this is undef.

   <b>label()</b>
               my $label = $graph-&gt;label();

       Returns the label of the graph.

   <b>title()</b>
               my $title = $graph-&gt;title();

       Returns the (mouseover) title of the graph.

   <b>link()</b>
               my $link = $graph-&gt;link();

       Return a potential link (for the graphs label), build from  the  attributes  "linkbase"  and  "link"  (or
       autolink). Returns '' if there is no link.

   <b>as_graphviz()</b>
               print $graph-&gt;as_graphviz();

       Return the graph as graphviz code, suitable to be feed to a program like "dot" etc.

   <b>as_graphviz_file()</b>
               print $graph-&gt;as_graphviz_file();

       Is an alias for <b>as_graphviz()</b>.

   <b>angle()</b>
               my $degrees = Graph::Easy-&gt;angle( 'south' );
               my $degrees = Graph::Easy-&gt;angle( 120 );

       Check  an  angle  for  being  valid  and  return a value between -359 and 359 degrees. The special values
       "south", "north", "west", "east", "up" and "down" are also valid and converted to degrees.

   <b>nodes()</b>
               my $nodes = $graph-&gt;nodes();

       In scalar context, returns the number of nodes/vertices the graph has.

       In list context, returns all nodes as objects, in arbitrary order.

   <b>anon_nodes()</b>
               my $anon_nodes = $graph-&gt;anon_nodes();

       In scalar context, returns the number of anon nodes (aka Graph::Easy::Node::Anon) the graph has.

       In list context, returns all anon nodes as objects, in arbitrary order.

   <b>html_page_header()</b>
               my $header = $graph-&gt;html_page_header();
               my $header = $graph-&gt;html_page_header($css);

       Return the header of an HTML page. Used together with html_page_footer by  as_html_page  to  construct  a
       complete HTML page.

       Takes  an  optional parameter with the CSS styles to be inserted into the header. If $css is not defined,
       embedds the result of "$self-&gt;css()".

   <b>html_page_footer()</b>
               my $footer = $graph-&gt;html_page_footer();

       Return the footer of an HTML page. Used together with html_page_header by  as_html_page  to  construct  a
       complete HTML page.

   <b>css()</b>
               my $css = $graph-&gt;css();

       Return CSS code for that graph. See <b>as_html()</b>.

   <b>as_txt()</b>
               print $graph-&gt;as_txt();

       Return the graph as a normalized textual representation, that can be parsed with Graph::Easy::Parser back
       to the same graph.

       This does not call <b>layout()</b> since the actual text representation is just a dump of the graph.

   <b>as_txt_file()</b>
               print $graph-&gt;as_txt_file();

       Is an alias for <b>as_txt()</b>.

   <b>as_svg()</b>
               print $graph-&gt;as_svg();

       Return  the  graph  as SVG (Scalable Vector Graphics), which can be embedded into HTML pages. You need to
       install Graph::Easy::As_svg first to make this work.

       See also <b>as_svg_file()</b>.

       <b>Note:</b> You need Graph::Easy::As_svg installed for this to work!

   <b>as_svg_file()</b>
               print $graph-&gt;as_svg_file();

       Returns SVG just like "as_svg()", but this time as standalone SVG, suitable for storing it in a file  and
       referencing it externally.

       After  calling  "as_svg_file()" or "as_svg()", you can retrieve some SVG information, notable "width" and
       "height" via "svg_information".

       <b>Note:</b> You need Graph::Easy::As_svg installed for this to work!

   <b>svg_information()</b>
               my $info = $graph-&gt;svg_information();

               print "Size: $info-&gt;{width}, $info-&gt;{height}\n";

       Return information about the graph created by the last "as_svg()" or "as_svg_file()" call.

       The following fields are set:

               width           width of the SVG in pixels
               height          height of the SVG in pixels

       <b>Note:</b> You need Graph::Easy::As_svg installed for this to work!

   <b>as_vcg()</b>
               print $graph-&gt;as_vcg();

       Return the graph as VCG text. VCG is a subset of GDL (Graph Description Language).

       This does not call <b>layout()</b> since the actual text representation is just a dump of the graph.

   <b>as_vcg_file()</b>
               print $graph-&gt;as_vcg_file();

       Is an alias for <b>as_vcg()</b>.

   <b>as_gdl()</b>
               print $graph-&gt;as_gdl();

       Return the graph as GDL (Graph Description Language) text. GDL is a superset of VCG.

       This does not call <b>layout()</b> since the actual text representation is just a dump of the graph.

   <b>as_gdl_file()</b>
               print $graph-&gt;as_gdl_file();

       Is an alias for <b>as_gdl()</b>.

   <b>as_graphml()</b>
               print $graph-&gt;as_graphml();

       Return the graph as a GraphML representation.

       This does not call <b>layout()</b> since the actual text representation is just a dump of the graph.

       The output contains only  the  set  attributes,  e.g.  default  attribute  values  are  not  specifically
       mentioned. The attribute names and values are the in the format that "Graph::Easy" defines.

   <b>as_graphml_file()</b>
               print $graph-&gt;as_graphml_file();

       Is an alias for <b>as_graphml()</b>.

   <b>sorted_nodes()</b>
               my $nodes =
                $graph-&gt;sorted_nodes( );               # default sort on 'id'
               my $nodes =
                $graph-&gt;sorted_nodes( 'name' );        # sort on 'name'
               my $nodes =
                $graph-&gt;sorted_nodes( 'layer', 'id' ); # sort on 'layer', then on 'id'

       In scalar context, returns the number of nodes/vertices the graph has.  In list context returns a list of
       all  the  node  objects  (as  reference), sorted by their attribute(s) given as arguments. The default is
       'id', e.g. their internal ID number, which amounts more or less to the order they have been inserted.

       This routine will sort the nodes by their group first, so the requested sort order will be only valid  if
       there are no groups or inside each group.

   <b>as_debug()</b>
               print $graph-&gt;as_debug();

       Return  debugging  information  like version numbers of used modules, and a textual representation of the
       graph.

       This does not call <b>layout()</b> since the actual text representation is more a dump  of  the  graph,  than  a
       certain layout.

   <b>node()</b>
               my $node = $graph-&gt;node('node name');

       Return node by unique name (case sensitive). Returns undef if the node does not exist in the graph.

   <b>edge()</b>
               my $edge = $graph-&gt;edge( $x, $y );

       Returns  the  edge  objects  between  nodes $x and $y. Both $x and $y can be either scalars with names or
       "Graph::Easy::Node" objects.

       Returns undef if the edge does not yet exist.

       In list context it will return all edges from $x to $y,  in  scalar  context  it  will  return  only  one
       (arbitrary) edge.

   <b>id()</b>
               my $graph_id = $graph-&gt;id();
               $graph-&gt;id('123');

       Returns the id of the graph. You can also set a new ID with this routine. The default is ''.

       The  graph's  ID is used to generate unique CSS classes for each graph, in the case you want to have more
       than one graph in an HTML page.

   <b>seed()</b>
               my $seed = $graph-&gt;seed();
               $graph-&gt;<a href="../man2/seed.2.html">seed</a>(2);

       Get/set the random seed for the graph object. See <b>randomize()</b> for a method to set a random seed.

       The seed is used to create random numbers for the layouter. For the same graph, the same seed will always
       lead to the same layout.

   <b>randomize()</b>
               $graph-&gt;randomize();

       Set a random seed for the graph object. See <b>seed()</b>.

   <b>debug()</b>
               my $debug = $graph-&gt;debug();    # get
               $graph-&gt;<a href="../man1/debug.1.html">debug</a>(1);               # enable
               $graph-&gt;<a href="../man0/debug.0.html">debug</a>(0);               # disable

       Enable, disable or read out the debug status. When the debug status is true,  additional  debug  messages
       will be printed on STDERR.

   <b>score()</b>
               my $score = $graph-&gt;score();

       Returns the score of the graph, or undef if <b>layout()</b> has not yet been called.

       Higher  scores are better, although you cannot compare scores for different graphs. The score should only
       be used to compare different layouts of the same graph against each other:

               my $max = undef;

               $graph-&gt;randomize();
               my $seed = $graph-&gt;seed();

               $graph-&gt;layout();
               $max = $graph-&gt;score();

               for (1..10)
                 {
                 $graph-&gt;randomize();                  # select random seed
                 $graph-&gt;layout();                     # layout with that seed
                 if ($graph-&gt;score() &gt; $max)
                   {
                   $max = $graph-&gt;score();             # store the new max store
                   $seed = $graph-&gt;seed();             # and it's seed
                   }
                 }

               # redo the best layout
               if ($seed ne $graph-&gt;seed())
                 {
                 $graph-&gt;seed($seed);
                 $graph-&gt;layout();
                 }
               # output graph:
               print $graph-&gt;as_ascii();               # or as_html() etc

   <b>valid_attribute()</b>
               my $graph = Graph::Easy-&gt;new();
               my $new_value =
                 $graph-&gt;valid_attribute( $name, $value, $class );

               if (ref($new_value) eq 'ARRAY' &amp;&amp; @$new_value == 0)
                 {
                 # throw error
                 die ("'$name' is not a valid attribute name for '$class'")
                       if $self-&gt;{_warn_on_unused_attributes};
                 }
               elsif (!defined $new_value)
                 {
                 # throw error
                 die ("'$value' is no valid '$name' for '$class'");
                 }

       Deprecated, please use <b>validate_attribute()</b>.

       Check that a "$name,$value" pair is a valid attribute in class $class, and returns a new value.

       It returns an array ref if the attribute name is invalid, and undef if the value is invalid.

       The return value can differ from the passed in value, f.i.:

               print $graph-&gt;valid_attribute( 'color', 'red' );

       This would print '#ff0000';

   <b>validate_attribute()</b>
               my $graph = Graph::Easy-&gt;new();
               my ($rc,$new_name, $new_value) =
                 $graph-&gt;validate_attribute( $name, $value, $class );

       Checks a given attribute name and value (or values, in case of a value like "red|green") for being valid.
       It returns a new attribute name (in case  of  "font-color"  =&gt;  "fontcolor")  and  either  a  single  new
       attribute, or a list of attribute values as array ref.

       If $rc is defined, it is the error number:

               1                       unknown attribute name
               2                       invalid attribute value
               4                       found multiple attributes, but these arent
                                       allowed at this place

   <b>color_as_hex()</b>
               my $hexred   = Graph::Easy-&gt;color_as_hex( 'red' );
               my $hexblue  = Graph::Easy-&gt;color_as_hex( '#0000ff' );
               my $hexcyan  = Graph::Easy-&gt;color_as_hex( '#f0f' );
               my $hexgreen = Graph::Easy-&gt;color_as_hex( 'rgb(0,255,0)' );

       Takes  a  valid  color  name  or  definition  (hex,  short hex, or RGB) and returns the color in hex like
       "#ff00ff".

   <b>color_value($color_name,</b> <b>$color_scheme)</b>
               my $color = Graph::Easy-&gt;color_name( 'red' );   # #ff0000
               print Graph::Easy-&gt;color_name( '#ff0000' );     # #ff0000

               print Graph::Easy-&gt;color_name( 'snow', 'x11' );

       Given a color name, returns the color in hex. See color_name for  a  list  of  possible  values  for  the
       optional $color_scheme parameter.

   <b>color_name($color_value,</b> <b>$color_scheme)</b>
               my $color = Graph::Easy-&gt;color_name( 'red' );   # red
               print Graph::Easy-&gt;color_name( '#ff0000' );     # red

               print Graph::Easy-&gt;color_name( 'snow', 'x11' );

       Takes a hex color value and returns the name of the color.

       The optional parameter is the color scheme, where the following values are possible:

        w3c                    (the default)
        x11                    (what graphviz uses as default)

       Plus the following ColorBrewer schemes are supported, see the online manual for examples and their usage:

        accent3 accent4 accent5 accent6 accent7 accent8

        blues3 blues4 blues5 blues6 blues7 blues8 blues9

        brbg3 brbg4 brbg5 brbg6 brbg7 brbg8 brbg9 brbg10 brbg11

        bugn3 bugn4 bugn5 bugn6 bugn7 bugn8 bugn9 bupu3 bupu4 bupu5 bupu6 bupu7
        bupu8 bupu9

        dark23 dark24 dark25 dark26 dark27 dark28

        gnbu3 gnbu4 gnbu5 gnbu6 gnbu7 gnbu8 gnbu9

        greens3 greens4 greens5 greens6 greens7 greens8 greens9

        greys3 greys4 greys5 greys6 greys7 greys8 greys9

        oranges3 oranges4 oranges5 oranges6 oranges7 oranges8 oranges9

        orrd3 orrd4 orrd5 orrd6 orrd7 orrd8 orrd9

        paired3 paired4 paired5 paired6 paired7 paired8 paired9 paired10 paired11
        paired12

        pastel13 pastel14 pastel15 pastel16 pastel17 pastel18 pastel19

        pastel23 pastel24 pastel25 pastel26 pastel27 pastel28

        piyg3 piyg4 piyg5 piyg6 piyg7 piyg8 piyg9 piyg10 piyg11

        prgn3 prgn4 prgn5 prgn6 prgn7 prgn8 prgn9 prgn10 prgn11

        pubu3 pubu4 pubu5 pubu6 pubu7 pubu8 pubu9

        pubugn3 pubugn4 pubugn5 pubugn6 pubugn7 pubugn8 pubugn9

        puor3 puor4 puor5 puor6 puor7 puor8 puor9 puor10 puor11

        purd3 purd4 purd5 purd6 purd7 purd8 purd9

        purples3 purples4 purples5 purples6 purples7 purples8 purples9

        rdbu3 rdbu4 rdbu5 rdbu6 rdbu7 rdbu8 rdbu9 rdbu10 rdbu11

        rdgy3 rdgy4 rdgy5 rdgy6 rdgy7 rdgy8 rdgy9

        rdpu3 rdpu4 rdpu5 rdpu6 rdpu7 rdpu8 rdpu9 rdgy10 rdgy11

        rdylbu3 rdylbu4 rdylbu5 rdylbu6 rdylbu7 rdylbu8 rdylbu9 rdylbu10 rdylbu11

        rdylgn3 rdylgn4 rdylgn5 rdylgn6 rdylgn7 rdylgn8 rdylgn9 rdylgn10 rdylgn11

        reds3 reds4 reds5 reds6 reds7 reds8 reds9

        set13 set14 set15 set16 set17 set18 set19

        set23 set24 set25 set26 set27 set28

        set33 set34 set35 set36 set37 set38 set39 set310 set311 set312

        spectral3 spectral4 spectral5 spectral6 spectral7 spectral8 spectral9
        spectral10 spectral11

        ylgn3 ylgn4 ylgn5 ylgn6 ylgn7 ylgn8 ylgn9

        ylgnbu3 ylgnbu4 ylgnbu5 ylgnbu6 ylgnbu7 ylgnbu8 ylgnbu9

        ylorbr3 ylorbr4 ylorbr5 ylorbr6 ylorbr7 ylorbr8 ylorbr9

        ylorrd3 ylorrd4 ylorrd5 ylorrd6 ylorrd7 ylorrd8 ylorrd9

   <b>color_names()</b>
               my $names = Graph::Easy-&gt;color_names();

       Return a hash with name =&gt; value mapping for all known colors.

   <b>text_style()</b>
               if ($graph-&gt;text_style('bold, italic'))
                 {
                 ...
                 }

       Checks the given style list for being valid.

   <b>text_styles()</b>
               my $styles = $graph-&gt;text_styles();     # or $edge-&gt;text_styles() etc.

               if ($styles-&gt;{'italic'})
                 {
                 print 'is italic\n';
                 }

       Return a hash with the given text-style properties, aka 'underline', 'bold' etc.

   <b>text_styles_as_css()</b>
               my $styles = $graph-&gt;text_styles_as_css();      # or $edge-&gt;...() etc.

       Return the text styles as a chunk of CSS styling that can be embedded into a " style="" " parameter.

   <b>use_class()</b>
               $graph-&gt;use_class('node', 'Graph::Easy::MyNode');

       Override  the  class  to  be  used  to  constructs  objects  when  calling "add_edge()", "add_group()" or
       "add_node()".

       The first parameter can be one of the following:

               node
               edge
               group

       Please see the documentation about "use_class()" in "Graph::Easy::Parser" for examples and details.

   <b>animation_as_graph()</b>
               my $graph_2 = $graph-&gt;animation_as_graph();
               print $graph_2-&gt;as_ascii();

       Returns the animation of $graph as a graph describing the flow of the  animation.  Useful  for  debugging
       animation flows.

   <b>add_cycle()</b>
               $graph-&gt;add_cycle('A','B','C');         # A -&gt; B -&gt; C -&gt; A

       Compatibility  method  for  Graph,  adds  the  edges between each node and back from the last node to the
       first. Returns the graph.

   <b>add_path()</b>
               $graph-&gt;add_path('A','B','C');          # A -&gt; B -&gt; C

       Compatibility method for Graph, adds the edges between each node.  Returns the graph.

   <b>add_vertex()</b>
               $graph-&gt;add_vertex('A');

       Compatibility method for Graph, adds the node and returns the graph.

   <b>add_vertices()</b>
               $graph-&gt;add_vertices('A','B');

       Compatibility method for Graph, adds these nodes and returns the graph.

   <b>has_edge()</b>
               $graph-&gt;has_edge('A','B');

       Compatibility method for Graph, returns true if at least one edge between A and B exists.

   <b>vertices()</b>
       Compatibility method for Graph, returns in scalar context the number of nodes this  graph  has,  in  list
       context a (arbitrarily sorted) list of node objects.

   <b>set_vertex_attribute()</b>
               $graph-&gt;set_vertex_attribute( 'A', 'fill', '#deadff' );

       Compatibility method for Graph, set the named vertex attribute.

       Please  note  that  this  routine will only accept Graph::Easy attribute names and values. If you want to
       attach custom attributes, you need to start their name with 'x-':

               $graph-&gt;set_vertex_attribute( 'A', 'x-foo', 'bar' );

   <b>get_vertex_attribute()</b>
               my $fill = $graph-&gt;get_vertex_attribute( 'A', 'fill' );

       Compatibility method for Graph, get the named vertex attribute.

       Please note that this routine will only accept Graph::Easy attribute names. See <b>set_vertex_attribute()</b>.

</pre><h4><b>EXPORT</b></h4><pre>
       Exports nothing.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Graph, Graph::Convert, Graph::Easy::As_svg, Graph::Easy::Manual and Graph::Easy::Parser.

   <b>Related</b> <b>Projects</b>
       Graph::Layout::Aesthetic, Graph and Text::Flowchart.

       There is also an very  old,  unrelated  project  from  ca.  1995,  which  does  something  similar.   See
       &lt;<a href="http://rw4.cs.uni-sb.de/users/sander/html/gsvcg1.html">http://rw4.cs.uni-sb.de/users/sander/html/gsvcg1.html</a>&gt;.

       Testcases and more examples under:

       &lt;<a href="http://bloodgate.com/perl/graph/">http://bloodgate.com/perl/graph/</a>&gt;.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       This  module  is now quite complete, but there are still some limitations.  Hopefully further development
       will lift these.

   <b>Scoring</b>
       Scoring is not yet implemented, each generated graph will be the same regardless of the random seed.

   <b>Layouter</b>
       The layouter can not yet handle links between groups (or between a group and  a  node,  or  vice  versa).
       These links will thus only appear in <b>as_graphviz()</b> or <b>as_txt()</b> output.

   <b>Paths</b>
       No optimizations
         In complex graphs, non-optimal layout part like this one might appear:

                 +------+     +--------+
                 | Bonn | --&gt; | Berlin | --&gt; ...
                 +------+     +--------+
                                ^
                                |
                                |
                 +---------+    |
                 | Kassel  | ---+
                 +---------+

         A second-stage optimizer that simplifies these layouts is not yet implemented.

         In addition the general placement/processing strategy as well as the local strategy might be improved.

       attributes
         The following attributes are currently ignored by the layouter:

                 undirected graphs
                 autosplit/autojoin for edges
                 tail/head label/title/link for edges

       groups
         The layouter is not fully recursive yet, so groups do not properly nest.

         In addition, links to/from groups are missing, too.

   <b>Output</b> <b>formats</b>
       Some  output  formats  are  not  yet  complete  in  their implementation. Please see the online manual at
       &lt;<a href="http://bloodgate.com/perl/graph/manual">http://bloodgate.com/perl/graph/manual</a>&gt; under "Output" for details.

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software; you can redistribute it and/or modify it under the terms of the GPL 2.0 or
       a later version.

       See the LICENSE file for a copy of the GPL.

       This   product   includes   color   specifications   and   designs   developed    by    Cynthia    Brewer
       (<a href="http://colorbrewer.org/">http://colorbrewer.org/</a>).  See  the  LICENSE  file for the full license text that applies to these color
       schemes.

</pre><h4><b>NAME</b> <b>CHANGE</b></h4><pre>
       The package was formerly known as "Graph::Simple". The name was changed for two reasons:

       • In graph theory, a "simple" graph is a special type of graph. This  software,  however,  supports  more
         than simple graphs.

       • Creating graphs should be easy even when the graphs are quite complex.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) 2004 - 2008 by Tels &lt;<a href="http://bloodgate.com">http://bloodgate.com</a>&gt;

perl v5.36.0                                       2022-11-20                                   <u>Graph::<a href="../man3pm/Easy.3pm.html">Easy</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>