<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>digraph_utils - Algorithms for directed graphs.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       digraph_utils - Algorithms for directed graphs.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides algorithms based on depth-first traversal of directed graphs. For basic functions on
       directed graphs, see the <u><a href="../man3erl/digraph.3erl.html">digraph</a>(3erl)</u> module.

         * A  <u>directed</u> <u>graph</u> (or just "digraph") is a pair (V, E) of a finite set V of <u>vertices</u> and a finite set
           E of <u>directed</u> <u>edges</u> (or just "edges"). The set of edges E is a subset of V x V (the Cartesian product
           of V with itself).

         * Digraphs can be annotated with more information. Such information can be attached to the vertices and
           to the edges of the digraph. An annotated digraph is called a <u>labeled</u> <u>digraph</u>,  and  the  information
           attached to a vertex or an edge is called a <u>label</u>.

         * An edge e = (v, w) is said to <u>emanate</u> from vertex v and to be <u>incident</u> on vertex w.

         * If an edge is emanating from v and incident on w, then w is said to be an <u>out-neighbor</u> of v, and v is
           said to be an <u>in-neighbor</u> of w.

         * A  <u>path</u>  P  from  v[1]  to  v[k] in a digraph (V, E) is a non-empty sequence v[1], v[2], ..., v[k] of
           vertices in V such that there is an edge (v[i],v[i+1]) in E for 1 &lt;= i &lt; k.

         * The <u>length</u> of path P is k-1.

         * Path P is a <u>cycle</u> if the length of P is not zero and v[1] = v[k].

         * A <u>loop</u> is a cycle of length one.

         * An <u>acyclic</u> <u>digraph</u> is a digraph without cycles.

         * A <u>depth-first</u> <u>traversal</u> of a directed digraph can be viewed as a process that visits all vertices  of
           the  digraph.  Initially,  all  vertices  are  marked  as  unvisited.  The  traversal  starts with an
           arbitrarily chosen vertex, which is marked as visited, and follows an edge  to  an  unmarked  vertex,
           marking that vertex. The search then proceeds from that vertex in the same fashion, until there is no
           edge  leading  to  an  unvisited  vertex.  At  that  point  the process backtracks, and the traversal
           continues as long as there are unexamined edges. If unvisited vertices remain when all edges from the
           first vertex have been examined, some so far unvisited vertex is chosen, and the process is repeated.

         * A <u>partial</u> <u>ordering</u> of a set S is a transitive, antisymmetric,  and  reflexive  relation  between  the
           objects of S.

         * The problem of <u>topological</u> <u>sorting</u> is to find a total ordering of S that is a superset of the partial
           ordering.  A  digraph  G  = (V, E) is equivalent to a relation E on V (we neglect that the version of
           directed graphs provided by the <u>digraph</u> module  allows  multiple  edges  between  vertices).  If  the
           digraph  has  no cycles of length two or more, the reflexive and transitive closure of E is a partial
           ordering.

         * A <u>subgraph</u> G' of G is a digraph whose vertices and edges form subsets of the vertices and edges of G.

         * G' is <u>maximal</u> with respect to a property P if all other subgraphs that include the vertices of G'  do
           not have property P.

         * A  <u>strongly</u>  <u>connected</u> <u>component</u> is a maximal subgraph such that there is a path between each pair of
           vertices.

         * A <u>connected</u> <u>component</u> is a maximal subgraph such that there is a path between each pair of  vertices,
           considering all edges undirected.

         * An  <u>arborescence</u>  is  an  acyclic digraph with a vertex V, the <u>root</u>, such that there is a unique path
           from V to every other vertex of G.

         * A <u>tree</u> is an acyclic non-empty digraph such that there  is  a  unique  path  between  every  pair  of
           vertices, considering all edges undirected.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>arborescence_root(Digraph)</b> <b>-&gt;</b> <b>no</b> <b>|</b> <b>{yes,</b> <b>Root}</b>

              Types:

                 Digraph = digraph:graph()
                 Root = digraph:vertex()

              Returns <u>{yes,</u> <u>Root}</u> if <u>Root</u> is the root of the arborescence <u>Digraph</u>, otherwise <u>no</u>.

       <b>components(Digraph)</b> <b>-&gt;</b> <b>[Component]</b>

              Types:

                 Digraph = digraph:graph()
                 Component = [digraph:vertex()]

              Returns  a  list of connected components. Each component is represented by its vertices. The order
              of the vertices and the order of the components are arbitrary.  Each  vertex  of  digraph  <u>Digraph</u>
              occurs in exactly one component.

       <b>condensation(Digraph)</b> <b>-&gt;</b> <b>CondensedDigraph</b>

              Types:

                 Digraph = CondensedDigraph = digraph:graph()

              Creates  a digraph where the vertices are the strongly connected components of <u>Digraph</u> as returned
              by <u>strong_components/1</u>. If X and Y are two different strongly connected components, and vertices x
              and y exist in X and Y, respectively, such that there is an edge emanating from x and incident  on
              y, then an edge emanating from X and incident on Y is created.

              The  created  digraph  has the same type as <u>Digraph</u>. All vertices and edges have the default label
              <u>[]</u>.

              Each cycle is included in some strongly connected component,  which  implies  that  a  topological
              ordering of the created digraph always exists.

       <b>cyclic_strong_components(Digraph)</b> <b>-&gt;</b> <b>[StrongComponent]</b>

              Types:

                 Digraph = digraph:graph()
                 StrongComponent = [digraph:vertex()]

              Returns  a  list  of  strongly connected components. Each strongly component is represented by its
              vertices. The order of the vertices and the order of the components are arbitrary.  Only  vertices
              that  are  included in some cycle in <u>Digraph</u> are returned, otherwise the returned list is equal to
              that returned by <u>strong_components/1</u>.

       <b>is_acyclic(Digraph)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Digraph = digraph:graph()

              Returns <u>true</u> if and only if digraph <u>Digraph</u> is acyclic.

       <b>is_arborescence(Digraph)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Digraph = digraph:graph()

              Returns <u>true</u> if and only if digraph <u>Digraph</u> is an arborescence.

       <b>is_tree(Digraph)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Digraph = digraph:graph()

              Returns <u>true</u> if and only if digraph <u>Digraph</u> is a tree.

       <b>loop_vertices(Digraph)</b> <b>-&gt;</b> <b>Vertices</b>

              Types:

                 Digraph = digraph:graph()
                 Vertices = [digraph:vertex()]

              Returns a list of all vertices of <u>Digraph</u> that are included in some loop.

       <b>postorder(Digraph)</b> <b>-&gt;</b> <b>Vertices</b>

              Types:

                 Digraph = digraph:graph()
                 Vertices = [digraph:vertex()]

              Returns all vertices of digraph <u>Digraph</u>. The order is given by  a  depth-first  traversal  of  the
              digraph,  collecting  visited  vertices  in  postorder. More precisely, the vertices visited while
              searching from an arbitrarily chosen vertex are collected in postorder, and  all  those  collected
              vertices are placed before the subsequently visited vertices.

       <b>preorder(Digraph)</b> <b>-&gt;</b> <b>Vertices</b>

              Types:

                 Digraph = digraph:graph()
                 Vertices = [digraph:vertex()]

              Returns  all  vertices  of  digraph  <u>Digraph</u>. The order is given by a depth-first traversal of the
              digraph, collecting visited vertices in preorder.

       <b>reachable(Vertices,</b> <b>Digraph)</b> <b>-&gt;</b> <b>Reachable</b>

              Types:

                 Digraph = digraph:graph()
                 Vertices = Reachable = [digraph:vertex()]

              Returns an unsorted list of digraph vertices such that for each vertex in the  list,  there  is  a
              path  in  <u>Digraph</u>  from  some  vertex  of <u>Vertices</u> to the vertex. In particular, as paths can have
              length zero, the vertices of <u>Vertices</u> are included in the returned list.

       <b>reachable_neighbours(Vertices,</b> <b>Digraph)</b> <b>-&gt;</b> <b>Reachable</b>

              Types:

                 Digraph = digraph:graph()
                 Vertices = Reachable = [digraph:vertex()]

              Returns an unsorted list of digraph vertices such that for each vertex in the  list,  there  is  a
              path  in  <u>Digraph</u>  of  length  one  or  more  from  some  vertex  of  <u>Vertices</u> to the vertex. As a
              consequence, only those vertices of <u>Vertices</u> that are included in some cycle are returned.

       <b>reaching(Vertices,</b> <b>Digraph)</b> <b>-&gt;</b> <b>Reaching</b>

              Types:

                 Digraph = digraph:graph()
                 Vertices = Reaching = [digraph:vertex()]

              Returns an unsorted list of digraph vertices such that for each vertex in the  list,  there  is  a
              path from the vertex to some vertex of <u>Vertices</u>. In particular, as paths can have length zero, the
              vertices of <u>Vertices</u> are included in the returned list.

       <b>reaching_neighbours(Vertices,</b> <b>Digraph)</b> <b>-&gt;</b> <b>Reaching</b>

              Types:

                 Digraph = digraph:graph()
                 Vertices = Reaching = [digraph:vertex()]

              Returns  an  unsorted  list  of digraph vertices such that for each vertex in the list, there is a
              path of length one or more from the vertex to  some  vertex  of  <u>Vertices</u>.  Therefore  only  those
              vertices of <u>Vertices</u> that are included in some cycle are returned.

       <b>strong_components(Digraph)</b> <b>-&gt;</b> <b>[StrongComponent]</b>

              Types:

                 Digraph = digraph:graph()
                 StrongComponent = [digraph:vertex()]

              Returns  a  list  of  strongly connected components. Each strongly component is represented by its
              vertices. The order of the vertices and the order of the components are arbitrary. Each vertex  of
              digraph <u>Digraph</u> occurs in exactly one strong component.

       <b>subgraph(Digraph,</b> <b>Vertices)</b> <b>-&gt;</b> <b>SubGraph</b>

       <b>subgraph(Digraph,</b> <b>Vertices,</b> <b>Options)</b> <b>-&gt;</b> <b>SubGraph</b>

              Types:

                 Digraph = SubGraph = digraph:graph()
                 Vertices = [digraph:vertex()]
                 Options = [{type, SubgraphType} | {keep_labels, boolean()}]
                 SubgraphType = inherit | [digraph:d_type()]

              Creates  a  maximal  subgraph  of  <u>Digraph</u>  having  as vertices those vertices of <u>Digraph</u> that are
              mentioned in <u>Vertices</u>.

              If the value of option <u>type</u> is <u>inherit</u>, which is the default, the type of <u>Digraph</u> is used for  the
              subgraph as well. Otherwise the option value of <u>type</u> is used as argument to <u>digraph:new/1</u>.

              If the value of option <u>keep_labels</u> is <u>true</u>, which is the default, the labels of vertices and edges
              of  <u>Digraph</u> are used for the subgraph as well. If the value is <u>false</u>, default label <u>[]</u> is used for
              the vertices and edges of the subgroup.

              <u>subgraph(Digraph,</u> <u>Vertices)</u> is equivalent to <u>subgraph(Digraph,</u> <u>Vertices,</u> <u>[])</u>.

              If any of the arguments are invalid, a <u>badarg</u> exception is raised.

       <b>topsort(Digraph)</b> <b>-&gt;</b> <b>Vertices</b> <b>|</b> <b>false</b>

              Types:

                 Digraph = digraph:graph()
                 Vertices = [digraph:vertex()]

              Returns a topological ordering of the vertices of digraph <u>Digraph</u>  if  such  an  ordering  exists,
              otherwise <u>false</u>. For each vertex in the returned list, no out-neighbors occur earlier in the list.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/digraph.3erl.html">digraph</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                               <u><a href="../man3erl/digraph_utils.3erl.html">digraph_utils</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>