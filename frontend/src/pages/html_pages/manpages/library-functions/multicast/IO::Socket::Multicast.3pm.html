<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO::Socket::Multicast - Send and receive multicast messages</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-socket-multicast-perl">libio-socket-multicast-perl_1.12-3build5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IO::Socket::Multicast - Send and receive multicast messages

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use IO::Socket::Multicast;

         # create a new UDP socket ready to read datagrams on port 1100
         my $s = IO::Socket::Multicast-&gt;new(LocalPort=&gt;1100);

         # Add a multicast group
         $s-&gt;mcast_add('225.0.1.1');

         # Add a multicast group to eth0 device
         $s-&gt;mcast_add('225.0.0.2','eth0');

         # now receive some multicast data
         $s-&gt;recv($data,1024);

         # Drop a multicast group
         $s-&gt;mcast_drop('225.0.0.1');

         # Set outgoing interface to eth0
         $s-&gt;mcast_if('eth0');

         # Set time to live on outgoing multicast packets
         $s-&gt;<a href="../man10/mcast_ttl.10.html">mcast_ttl</a>(10);

         # Turn off loopbacking
         $s-&gt;<a href="../man0/mcast_loopback.0.html">mcast_loopback</a>(0);

         # Multicast a message to group 225.0.0.1
         $s-&gt;mcast_send('hello world!','225.0.0.1:1200');
         $s-&gt;mcast_set('225.0.0.2:1200');
         $s-&gt;mcast_send('hello again!');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The IO::Socket::Multicast module subclasses IO::Socket::INET to enable you to manipulate multicast
       groups.  With this module (and an operating system that supports multicasting), you will be able to
       receive incoming multicast transmissions and generate your own outgoing multicast packets.

       This module requires IO::Interface version 0.94 or higher.

   <b>INTRODUCTION</b>
       Multicasting is designed for streaming multimedia applications and for conferencing systems in which one
       transmitting machines needs to distribute data to a large number of clients.

       IP addresses in the range 224.0.0.0 and 239.255.255.255 are reserved for multicasting.  These addresses
       do not correspond to individual machines, but to multicast groups.  Messages sent to these addresses will
       be delivered to a potentially large number of machines that have registered their interest in receiving
       transmissions on these groups.  They work like TV channels.  A program tunes in to a multicast group to
       receive transmissions to it, and tunes out when it no longer wishes to receive the transmissions.

       To receive transmissions <b>from</b> a multicast group, you will use IO::Socket::Multicast-&gt;<b>new()</b> to create a
       UDP socket and bind it to a local network port.  You will then subscribe one or more multicast groups
       using the <b>mcast_add()</b> method.  Subsequent calls to the standard <b>recv()</b> method will now receive messages
       incoming messages transmitted to the subscribed groups using the selected port number.

       To send transmissions <b>to</b> a multicast group, you can use the standard <b>send()</b> method to send messages to
       the multicast group and port of your choice.  The <b>mcast_set()</b> and <b>mcast_send()</b> methods are provided as
       convenience functions.  <b>Mcast_set()</b> will set a default multicast destination for messages which you then
       send with <b>mcast_send()</b>.

       To set the number of hops (routers) that outgoing multicast messages will cross, call <b>mcast_ttl()</b>.  To
       activate or deactivate the looping back of multicast messages (in which a copy of the transmitted
       messages is received by the local machine), call <b>mcast_loopback()</b>.

   <b>CONSTRUCTORS</b>
       $socket = IO::Socket::Multicast-&gt;new([LocalPort=&gt;$port,...])
           The <b>new()</b> method is the constructor for the IO::Socket::Multicast class.  It takes the same arguments
           as IO::Socket::INET, except that the <b>Proto</b> argument, rather than defaulting to "tcp", will default to
           "udp", which is more appropriate for multicasting.

           To create a UDP socket suitable for sending outgoing multicast messages, call <b>new()</b> without arguments
           (or  with  "Proto=&gt;'udp'").   To  create  a  UDP  socket  that  can  also  receive incoming multicast
           transmissions on a specific port, call <b>new()</b> with the <b>LocalPort</b> argument.

           If you plan to run the client and server on the same machine, you may  wish  to  set  the  IO::Socket
           <b>ReuseAddr</b>  argument  to  a  true  value.   This allows multiple multicast sockets to bind to the same
           address.

   <b>METHODS</b>
       $success = $socket-&gt;mcast_add($multicast_address [,$interface])
           The <b>mcast_add()</b> method will add the provided multicast address to the list  of  subscribed  multicast
           groups.  The address may be provided either as a dotted-quad decimal, or as a packed IP address (such
           as produced by the <b>inet_aton()</b> function).  On success, the method will return a true value.

           The  optional  $interface  argument  can  be used to specify on which network interface to listen for
           incoming multicast messages.  If the IO::Interface module is installed, you may use the  device  name
           for  the  interface  (e.g.  "tu0").   Otherwise,  you  must use the IP address of the desired network
           interface.  Either dotted quad form  or  packed  IP  address  is  acceptable.   If  no  interface  is
           specified,  then  the  multicast  group is joined on INADDR_ANY, meaning that multicast transmissions
           received on <b>any</b> of the host's network interfaces will be forwarded to the socket.

           Note that <b>mcast_add()</b> operates on the underlying interface(s) and not on  the  socket.  If  you  have
           multiple  sockets  listening  on  a  port,  and  you  <b>mcast_add()</b>  a  group  to one of those sockets,
           subsequently <b>all</b> the sockets will receive mcast messages on this group. To filter messages  that  can
           be  received by a socket so that only those sent to a particular multicast address are received, pass
           the <b>LocalAddr</b> option to the socket at the time you create it:

             my $socket = IO::Socket::Multicast-&gt;new(LocalPort=&gt;2000,
                                                     LocalAddr=&gt;226.1.1.2',
                                                     ReuseAddr=&gt;1);
             $socket-&gt;mcast_add('226.1.1.2');

           By combining this technique with IO::Select, you can  write  applications  that  listen  to  multiple
           multicast  groups  and distinguish which group a message was addressed to by identifying which socket
           it was received on.

       $success = $socket-&gt;mcast_drop($multicast_address)
           This reverses the action of <b>mcast_add()</b>, removing the indicated multicast address from  the  list  of
           subscribed groups.

       $loopback = $socket-&gt;mcast_loopback
       $previous = $socket-&gt;mcast_loopback($new)
           The  <b>mcast_loopback()</b> method controls whether the socket will receive its own multicast transmissions
           (default yes).  Called without arguments, the method returns the current state of the loopback  flag.
           Called with a boolean argument, the method will set the loopback flag, and return its previous value.

       $ttl = $socket-&gt;mcast_ttl
       $previous = $socket-&gt;mcast_ttl($new)
           The  <b>mcast_ttl()</b> method examines or sets the time to live (TTL) for outgoing multicast messages.  The
           TTL controls the numbers of routers the packet can cross before being expired.  The default TTL is 1,
           meaning that the message is confined to the local area network.  Values between 0 and 255 are valid.

           Called without arguments, this method returns the socket's current TTL.  Called with  a  value,  this
           method sets the TTL and returns its previous value.

       $interface = $socket-&gt;mcast_if
       $previous = $socket-&gt;mcast_if($new)
           By default, the OS will pick the network interface to use for outgoing multicasts automatically.  You
           can  control  this  process  by  using  the  <b>mcast_if()</b>  method to set the outgoing network interface
           explicitly.  Called without arguments, returns the current interface.  Called with  the  name  of  an
           interface, sets the outgoing interface and returns its previous value.

           You  can  use  the device name for the interface (e.g. "tu0") if the IO::Interface module is present.
           Otherwise, you must use the interface's dotted IP address.

           <b>NOTE</b>: To set the interface used for <b>incoming</b> multicasts, use the <b>mcast_add()</b> method.

       $dest = $socket-&gt;mcast_dest
       $previous = $socket-&gt;mcast_dest($new)
           The <b>mcast_dest()</b> method is a convenience function that allows you  to  set  the  default  destination
           group for outgoing multicasts.  Called without arguments, returns the current destination as a packed
           binary  sockaddr_in  data  structure.   Called  with  a  new destination address, the method sets the
           default destination and returns the previous one, if any.

           Destination  addresses  may  be  provided  as  packed  sockaddr_in  structures,  or   in   the   form
           "XX.XX.XX.XX:YY" where the first part is the IP address, and the second the port number.

       $bytes = $socket-&gt;mcast_send($data [,$dest])
           <b>Mcast_send()</b>  is  a convenience function that simplifies the sending of multicast messages.  $data is
           the message contents, and $dest is an optional destination group.  You can use either the  dotted  IP
           form  of  the  destination  address  and  its port number, or a packed sockaddr_in structure.  If the
           destination is not supplied, it will default to the most  recent  value  set  in  <b>mcast_dest()</b>  or  a
           previous call to <b>mcast_send()</b>.

           The method returns the number of bytes successfully queued for delivery.

           As a side-effect, the method will call <b>mcast_dest()</b> to remember the destination address.

           Example:

             $socket-&gt;mcast_send('Hi there group members!','225.0.1.1:1900') || die;
             $socket-&gt;mcast_send("How's the weather?") || die;

           Note  that you may still call IO::Socket::Multicast-&gt;<b>new()</b> with a <b>PeerAddr</b>, and IO::Socket::INET will
           perform a <b>connect()</b>, creating a default destination for calls to <b>send()</b>.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following is an example of a multicast server.  Every 10 seconds it transmits the  current  time  and
       the  list  of  logged-in users to the local network using multicast group 226.1.1.2, port 2000 (these are
       chosen arbitrarily).

        #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
        # server
        use strict;
        use IO::Socket::Multicast;

        use constant DESTINATION =&gt; '226.1.1.2:2000';
        my $sock = IO::Socket::Multicast-&gt;new(Proto=&gt;'udp',PeerAddr=&gt;DESTINATION);

        while (1) {
          my $message = localtime;
          $message .= "\n" . `who`;
          $sock-&gt;send($message) || die "Couldn't send: $!";
        } continue {
          sleep 10;
        }

       This is the corresponding client.  It listens for transmissions on group 226.1.1.2, port 2000, and echoes
       the messages to standard output.

        #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
        # client

        use strict;
        use IO::Socket::Multicast;

        use constant GROUP =&gt; '226.1.1.2';
        use constant PORT  =&gt; '2000';

        my $sock = IO::Socket::Multicast-&gt;new(Proto=&gt;'udp',LocalPort=&gt;PORT);
        $sock-&gt;mcast_add(GROUP) || die "Couldn't set group: $!\n";

        while (1) {
          my $data;
          next unless $sock-&gt;recv($data,1024);
          print $data;
        }

   <b>EXPORT</b>
       None by default.  However, if you wish to call <b>mcast_add()</b>, <b>mcast_drop()</b>,  <b>mcast_if()</b>,  <b>mcast_loopback()</b>,
       mcast_ttl,  <b>mcast_dest()</b>  and <b>mcast_send()</b> as functions you may import them explicitly on the <b>use</b> line or
       by importing the tag ":functions".

   <b>BUGS</b>
       The <b>mcast_if()</b>, <b>mcast_ttl()</b> and <b>mcast_loopback()</b> methods will cause a crash on versions of Linux  earlier
       than 2.2.0 because of a kernel bug in the implementation of the multicast socket options.

</pre><h4><b>AUTHOR</b></h4><pre>
       Lincoln Stein, <a href="mailto:lstein@cshl.org">lstein@cshl.org</a>.

       This module is distributed under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b>IO::<a href="../man3/Socket.3.html">Socket</a></b>(3), <b>IO::Socket::<a href="../man3/INET.3.html">INET</a></b>(3).

perl v5.40.0                                       2024-10-20                         <u>IO::Socket::<a href="../man3pm/Multicast.3pm.html">Multicast</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>