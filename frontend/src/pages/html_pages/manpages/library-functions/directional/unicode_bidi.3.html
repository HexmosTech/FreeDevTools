<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unicode_bidi, unicode_bidi_calc_levels, unicode_bidi_calc_types, unicode_bidi_calc, unicode_bidi_reorder,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcourier-unicode-dev">libcourier-unicode-dev_2.3.2-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unicode_bidi, unicode_bidi_calc_levels, unicode_bidi_calc_types, unicode_bidi_calc, unicode_bidi_reorder,
       unicode_bidi_cleanup, unicode_bidi_cleaned_size, unicode_bidi_logical_order, unicode_bidi_combinings,
       unicode_bidi_needs_embed, unicode_bidi_embed, unicode_bidi_embed_paragraph_level, unicode_bidi_direction,
       unicode_bidi_type, unicode_bidi_setbnl, unicode_bidi_mirror, unicode_bidi_bracket_type - unicode
       bi-directional algorithm

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;courier-unicode.h&gt;</b>

       <b>unicode_bidi_level_t</b> <b>lr=UNICODE_BIDI_LR;</b>

       <b>void</b> <b>unicode_bidi_calc_types(const</b> <b>char32_t</b> <b>*</b><u>p</u><b>,</b> <b>size_t</b> <u>n</u><b>,</b> <b>unicode_bidi_type_t</b> <b>*</b><u>types</u><b>);</b>

       <b>struct</b> <b>unicode_bidi_direction</b> <b>unicode_bidi_calc_levels(const</b> <b>char32_t</b> <b>*</b><u>p</u><b>,</b>
                                                              <b>const</b> <b>unicode_bidi_type_t</b> <b>*</b><u>types</u><b>,</b> <b>size_t</b> <u>n</u><b>,</b>
                                                              <b>unicode_bidi_level_t</b> <b>*</b><u>levels</u><b>,</b>
                                                              <b>const</b> <b>unicode_bidi_level_t</b> <b>*</b><u>initial_embedding_level</u><b>);</b>

       <b>struct</b> <b>unicode_bidi_direction</b> <b>unicode_bidi_calc(const</b> <b>char32_t</b> <b>*</b><u>p</u><b>,</b> <b>size_t</b> <u>n</u><b>,</b>
                                                       <b>unicode_bidi_level_t</b> <b>*</b><u>levels</u><b>,</b>
                                                       <b>const</b> <b>unicode_bidi_level_t</b> <b>*</b><u>initial_embedding_level</u><b>);</b>

       <b>void</b> <b>unicode_bidi_reorder(char32_t</b> <b>*</b><u>string</u><b>,</b> <b>unicode_bidi_level_t</b> <b>*</b><u>levels</u><b>,</b> <b>size_t</b> <u>n</u><b>,</b>
                                 <b>void</b> <b>(*</b><u>reorder_callback</u><b>)(size_t,</b> <b>size_t,</b> <b>void</b> <b>*),</b> <b>void</b> <b>*</b><u>arg</u><b>);</b>

       <b>size_t</b> <b>unicode_bidi_cleanup(char32_t</b> <b>*</b><u>string</u><b>,</b> <b>unicode_bidi_level_t</b> <b>*</b><u>levels</u><b>,</b> <b>size_t</b> <u>n</u><b>,</b> <b>int</b> <u>options</u><b>,</b>
                                   <b>void</b> <b>(*</b><u>removed_callback</u><b>)(size_t,</b> <b>size_t,</b> <b>void</b> <b>*),</b> <b>void</b> <b>*</b><u>arg</u><b>);</b>

       <b>size_t</b> <b>unicode_bidi_cleaned_size(const</b> <b>char32_t</b> <b>*</b><u>string</u><b>,</b> <b>size_t</b> <u>n</u><b>,</b> <b>int</b> <u>options</u><b>);</b>

       <b>void</b> <b>unicode_bidi_logical_order(char32_t</b> <b>*</b><u>string</u><b>,</b> <b>unicode_bidi_level_t</b> <b>*</b><u>levels</u><b>,</b> <b>size_t</b> <u>n</u><b>,</b>
                                       <b>unicode_bidi_level_t</b> <u>paragraph_embedding</u><b>,</b>
                                       <b>void</b> <b>(*</b><u>reorder_callback</u><b>)(size_t</b> <b>index,</b> <b>size_t</b> <b>n,</b> <b>void</b> <b>*arg),</b> <b>void</b> <b>*</b><u>arg</u><b>);</b>

       <b>void</b> <b>unicode_bidi_combinings(const</b> <b>char32_t</b> <b>*</b><u>string</u><b>,</b> <b>const</b> <b>unicode_bidi_level_t</b> <b>*</b><u>levels</u><b>,</b> <b>size_t</b> <u>n</u><b>,</b>
                                    <b>void</b> <b>(*</b><u>combinings</u><b>)(unicode_bidi_level_t</b> <b>level,</b> <b>size_t</b> <b>level_start,</b> <b>size_t</b> <b>n_chars,</b> <b>size_t</b> <b>comb_start,</b> <b>size_t</b> <b>n_comb_chars,</b> <b>void</b> <b>*arg),</b>
                                    <b>void</b> <b>*</b><u>arg</u><b>);</b>

       <b>int</b> <b>unicode_bidi_needs_embed(const</b> <b>char32_t</b> <b>*</b><u>string</u><b>,</b> <b>const</b> <b>unicode_bidi_level_t</b> <b>*</b><u>levels</u><b>,</b> <b>size_t</b> <u>n</u><b>,</b>
                                    <b>const</b> <b>unicode_bidi_level_t</b> <u>*paragraph_embedding</u><b>);</b>

       <b>size_t</b> <b>unicode_bidi_embed(const</b> <b>char32_t</b> <b>*</b><u>string</u><b>,</b> <b>const</b> <b>unicode_bidi_level_t</b> <b>*</b><u>levels</u><b>,</b> <b>size_t</b> <u>n</u><b>,</b>
                                 <b>unicode_bidi_level_t</b> <u>paragraph_embedding</u><b>,</b>
                                 <b>void</b> <b>(*</b><u>emit</u><b>)(const</b> <b>char32_t</b> <b>*string,</b> <b>size_t</b> <b>n,</b> <b>int</b> <b>is_part_of_string,</b> <b>void</b> <b>*arg),</b>
                                 <b>void</b> <b>*</b><u>arg</u><b>);</b>

       <b>char32_t</b> <b>unicode_bidi_embed_paragraph_level(const</b> <b>char32_t</b> <b>*</b><u>string</u><b>,</b> <b>size_t</b> <u>n</u><b>,</b>
                                                   <b>unicode_bidi_level_t</b> <u>paragraph_embedding</u><b>);</b>

       <b>char32_t</b> <b>bidi_mirror(char32_t</b> <u>c</u><b>);</b>

       <b>char32_t</b> <b>bidi_bracket_type(char32_t</b> <u>c</u><b>,</b> <b>unicode_bracket_type_t</b> <b>*</b><u>ret</u><b>);</b>

       <b>struct</b> <b>unicode_bidi_direction</b> <b>unicode_bidi_get_direction(char32_t</b> <b>*</b><u>c</u><b>,</b> <b>size_t</b> <u>n</u><b>);</b>

       <b>enum_bidi_type_t</b> <b>unicode_bidi_type(char32_t</b> <u>c</u><b>);</b>

       <b>void</b> <b>unicode_bidi_setbnl(char32_t</b> <b>*</b><u>p</u><b>,</b> <b>const</b> <b>unicode_bidi_type_t</b> <b>*</b><u>types</u><b>,</b> <b>size_t</b> <u>n</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions are related to the <b>Unicode</b> <b>Bi-Directional</b> <b>algorithm</b>[1]. They implement the algorithm up
       to and including step L2, and provide additional functionality of returning miscellaneous
       bi-directional-related metadata of Unicode characters. There's also a basic algorithm that “reverses” the
       bi-directional algorithm and produces a Unicode string with bi-directional markers that results in the
       same bi-directional string after reapplying the algorithm.

   <b>Calculating</b> <b>bi-directional</b> <b>rendering</b> <b>order</b>
       The following process computes the rendering order of characters according to the Unicode Bi-Directional
       algorithm:

        1. Allocate an array of unicode_bidi_type_t that's the same size as the Unicode string.

        2. Allocate an array of unicode_bidi_level_t that's the same size as the Unicode string.

        3. Use <b>unicode_bidi_calc_types</b>() to compute the Unicode string's characters' bi-directional types, and
           populate the unicode_bidi_type_t buffer.

        4. Use <b>unicode_bidi_calc_levels</b>() to compute the Unicode string's characters' bi-directional embedding
           level (executes the Bi-Directional algorithm up to and including step L1). This populates the
           unicode_bidi_level_t buffer.

        5. Alternatively: allocate only the unicode_bidi_level_t array and use <b>unicode_bidi_calc</b>(), which
           <b>malloc</b>()s the unicode_bidi_type_t buffer, calls <b>unicode_bidi_calc_levels</b>(), and then <b>free</b>()s the
           buffer.

        6. Use <b>unicode_bidi_reorder</b>() to reverse any characters in the string, according to the algorithm (step
           L2), with an optional callback that reports which ranges of characters get reversed.

        7. Use <b>unicode_bidi_cleanup</b>() to remove the characters from the string which are used by the
           bi-directional algorithm, and are not needed for rendering the text.  <b>unicode_bidi_cleaned_size</b>() is
           available to determine, in advance, how many characters will remain.

       The parameters to <b>unicode_bidi_calc_types</b>() are:

       •   A pointer to the Unicode string.

       •   Number of characters in the Unicode string.

       •   A pointer to an array of unicode_bidi_type_t values. The caller is responsible for allocating and
           deallocating this array, which has the same size as the Unicode string.

       The parameters to <b>unicode_bidi_calc_levels</b>() are:

       •   A pointer to the Unicode string.

       •   A pointer to the buffer that was passed to <b>unicode_bidi_calc_types</b>().

       •   Number of characters in the Unicode string and the unicode_bidi_type_t buffer.

       •   A pointer to an array of unicode_bidi_level_t values. The caller is responsible for allocating and
           deallocating this array, which has the same size as the Unicode string.

       •   An optional pointer to a UNICODE_BIDI_LR or UNICODE_BIDI_RL value. This sets the default paragraph
           direction level. A null pointer computes the default paragraph direction level based on the string,
           as specified by the "P" rules of the bi-directional algorithm.

       The parameters to <b>unicode_bidi_calc</b>() are the same except for the unicode_bidi_type_t pointer.
       <b>unicode_bidi_calc</b>() allocates this buffer by itself and calls <b>unicode_bidi_calc_types</b>, and destroys the
       buffer before returning.

       <b>unicode_bidi_calc</b>() and <b>unicode_bidi_calc_levels</b>() fill in the unicode_bidi_level_t array with the values
       corresponding to the embedding level of the corresponding character, according the Unicode Bidirection
       Algorithm (even values for left-to-right ordering, and odd values for right-to-left ordering). A value of
       UNICODE_BIDI_SKIP designates directional markers (from step X9).

       <b>unicode_bidi_calc</b>() and <b>unicode_bidi_calc_levels</b>() return the resolved paragraph direction level, which
       always matches the passed in level, if specified, else it reports the derived one. These functions return
       a unicode_bidi_direction structure:
       struct unicode_bidi_direction {
           unicode_bidi_level_t   <u>direction</u>;
           int                    <u>is_explicit</u>;
       };

       <u>direction</u> gives the paragraph embedding level, UNICODE_BIDI_LR or UNICODE_BIDI_RL.  <u>is_explicit</u> indicates
       whether: the optional pointer to a UNICODE_BIDI_LR or UNICODE_BIDI_RL value was specified (and returned
       in <u>direction</u>), or whether the <u>direction</u> comes from an character with an explicit direction indication.

       <b>unicode_bidi_reorder</b>() takes the actual unicode string together with the embedding values from
       <b>unicode_bidi_calc</b> or <b>unicode_bidi_calc_levels</b>(), then reverses the bi-directional string, as specified by
       step L2 of the bi-directional algorithm. The parameters to <b>unicode_bidi_reorder</b>() are:

       •   A pointer to the Unicode string.

       •   A pointer to an array of unicode_bidi_level_t values.

       •   Number of characters in the Unicode string and the unicode_bidi_level_t array.

       •   An optional <u>reorder_callback</u> function pointer.

       A non-NULL <u>reorder_callback</u> gets invoked to report each reversed character range. The callback's first
       parameter is the index of the first reversed character, the second parameter is the number of reversed
       characters, starting at the given index of the Unicode string. The third parameter is the <u>arg</u> passthrough
       parameter.

       <b>unicode_bidi_reorder</b> modifies its <u>string</u> and <u>levels</u>.  <u>reorder_callback</u> gets invoked after reversing each
       consecutive range of values in the <u>string</u> and <u>levels</u> buffers. For example: “reorder_callback(5, 7, arg)”
       reports that character indexes #5 through #11 got reversed.

       A NULL <u>string</u> pointer leaves the <u>levels</u> buffer unchanged, but still invokes the <u>reorder_callback</u> as if
       the character string, and their embedding values, were reversed.

       The resulting string and embedding levels are in “rendering order”, but still contain bi-directional
       embedding, override, boundary-neutral, isolate, and marker characters.  <b>unicode_bidi_cleanup</b> removes
       these characters and directional markers.

       The parameters to <b>unicode_bidi_cleanup</b>() are:

       •   The pointer to the unicode string.

       •   A non-null pointer to the directional embedding level buffer, of the same size as the string, also
           removes the corresponding values from the buffer, and the remaining values in the embedding level
           buffer get reset to levels UNICODE_BIDI_LR and UNICODE_BIDI_RL, only.

       •   The size of the unicode string and the directional embedding buffer (if not NULL).

       •   A a bitmask that selects the following options (or 0 if no options):

           UNICODE_BIDI_CLEANUP_EXTRA
               In addition to removing all embedding, override, and boundry-neutral characters as specified by
               step X9 of the bi-directional algorithm (the default behavior without this flag), also remove all
               isolation markers and implicit markers.

           UNICODE_BIDI_CLEANUP_BNL
               Replace all characters classified as paragraph separators with a newline character.

           UNICODE_BIDI_CLEANUP_CANONICAL
               A combined set of UNICODE_BIDI_CLEANUP_EXTRA and UNICODE_BIDI_CLEANUP_BNL,

       •   A pointer to a function that gets repeatedly invoked with the index of the character that gets
           removed from the Unicode string.

       •   An opaque pointer that gets forwarded to the callback.

       The function pointer (if not NULL) gets invoked to report the index of each removed character. The
       reported index is the index from the original string, and the callback gets invoked in strict order, from
       the first to the last removed character (if any).

       The character string and the embedding level values resulting from <b>unicode_bidi_cleanup</b>() with the
       UNICODE_BIDI_CLEANUP_CANONICAL are in “canonical rendering order”.  <b>unicode_bidi_logical_order</b>(),
       <b>unicode_bidi_needs_embed</b>() and <b>unicode_bidi_embed</b>() require the canonical rendering order for their
       string and embedding level values.

       The parameters to <b>unicode_bidi_cleaned_size</b>() are a pointer to the unicode string, its size, and the
       bitmask option to <b>unicode_bidi_cleanup</b>().

   <b>Embedding</b> <b>bi-directional</b> <b>markers</b> <b>in</b> <b>Unicode</b> <b>text</b> <b>strings</b>
       <b>unicode_bidi_logical_order</b>() rearranges the string from rendering to its logical order.
       <b>unicode_bidi_embed</b>() adds various bi-directional markers to a Unicode string in canonical rendering
       order. The resulting string is not guaranteed to be identical to the original Unicode bi-directional
       string. The algorithm is fairly basic, but the resulting bi-directional string produces the same
       canonical rendering order after applying <b>unicode_bidi_calc()</b> or <b>unicode_bidi_calc_levels</b>(),
       <b>unicode_reorder()</b> and <b>unicode_bidi_cleanup()</b> (with the canonical option), with the same
       paragraph_embedding level.  <b>unicode_bidi_needs_embed</b>() attempts to heuristically determine whether
       <b>unicode_bidi_embed</b>() is required.

       <b>unicode_bidi_logical_order</b>() gets called first, followed by <b>unicode_bidi_embed</b>() (or
       <b>unicode_bidi_needs_embed</b>() in order to determine whether bi-directional markers are required). Finally,
       <b>unicode_bidi_embed_paragraph_level</b>() optionally determines whether the resulting string's default
       paragraph embedding level matches the one used for the actual embedding direction, and if not returns a
       directional marker to be prepended to the Unicode character string, as a hint.

       <b>unicode_bidi_logical_order</b>() factors in the characters' embedding values, and the provided paragraph
       embedding value (UNICODE_BIDI_LR or UNICODE_BIDI_RL), and rearranges the characters and the embedding
       levels in left-to-right order, while simultaneously invoking the supplied reorder_callback indicating
       each range of characters whose relative order gets reversed. The <b>reorder_callback</b>() receives, as
       parameters:

       •   The starting index of the first reversed character, in the string.

       •   Number of reversed characters.

       •   Forwarded <u>arg</u> pointer value.

       This specifies a consecutive range of characters (and directional embedding values) that get reversed
       (first character in the range becomes the last character, and the last character becomes the first
       character).

       After <b>unicode_bidi_logical_order</b>(), <b>unicode_bidi_embed</b>() progressively invokes the passed-in callback
       with the contents of a bi-directional unicode string. The parameters to <b>unicode_bidi_embed</b>() are:

       •   The Unicode string.

       •   The directional embedding buffer, in canonical rendering order.

       •   The size of the string and the embedding level buffer.

       •   The paragraph embedding level, either UNICODE_BIDI_LR or UNICODE_BIDI_RL.

       •   The pointer to the callback function.

       •   An opaque pointer argument that gets forwarded to the callback function.

       The callback receives pointers to various parts of the original string that gets passed to
       <b>unicode_bidi_embed</b>(), intermixed with bi-directional markers, overrides, and isolates. The callback's
       parameters are:

       •   The pointer to a Unicode string.

               <b>Note</b>
               It is not a given that the callback receives pointers to progressively increasing pointers of the
               original string that gets passed to <b>unicode_bidi_embed</b>(). Some calls will be for individual
               bi-directional markers, and <b>unicode_bidi_embed</b>() also performs some additional internal
               reordering, on the fly, after <b>unicode_bidi_logical_order</b>()'s big hammer.

       •   Number of characters in the Unicode string.

       •   Indication whether the Unicode string pointer is pointing to a part of the original Unicode string
           that's getting embedded. Otherwise this must be some marker character that's not present in the
           original Unicode string.

       •   Forwarded <u>arg</u> pointer value.

       The assembled unicode string should produce the same canonical rendering order, for the same paragraph
       embedding level.  <b>unicode_bidi_embed_paragraph_level</b>() checks if the specified Unicode string computes
       the given default paragraph embedding level and returns 0 if it matches. Otherwise it returns a
       directional marker that should be <u>prepended</u> to the Unicode string to allow <b>unicode_bidi_calc</b>'s (or
       <b>unicode_bidi_calc_levels</b>()) optional paragraph embedding level pointer's value to be NULL, but derive the
       same default embedding level. The parameters to <b>unicode_bidi_embed_paragraph_level</b>() are:

       •   The Unicode string.

       •   The size of the string.

       •   The paragraph embedding level, either UNICODE_BIDI_LR or UNICODE_BIDI_RL.

       <b>unicode_bidi_needs_embed</b>() attempts to heuristically determine whether the Unicode string, in logical
       order, requires bi-directional markers. The parameters to <b>unicode_bidi_embed_paragraph_level</b>() are:

       •   The Unicode string.

       •   The directional embedding buffer, in logical order.

       •   The size of the string and the embedding level buffer.

       •   A pointer to an explicit paragraph embedding level, either UNICODE_BIDI_LR or UNICODE_BIDI_RL; or a
           NULL pointer (see <b>unicode_bidi_calc_types</b>()'s explanation for this parameter).

       <b>unicode_bidi_needs_embed</b>() returns 0 if the Unicode string does not need explicit directional markers, or
       1 if it does. This is done by using <b>unicode_bidi_calc()</b>, <b>unicode_bidi_reorder()</b>,
       <b>unicode_bidi_logical_order</b> and then checking if the end result is different from what was passed in.

   <b>Combining</b> <b>character</b> <b>ranges</b>
       <b>unicode_bidi_combinings</b>() reports consecutive sequences of one or more combining marks in bidirectional
       text (which can be either in rendering or logical order) that have the same embedding level. It takes the
       following parameters:

       •   The Unicode string.

       •   The directional embedding buffer, in logical or rendering order. A NULL value for this pointer is
           equivalent to a directional embedding buffer with a level of 0 for every character in the Unicode
           string.

       •   Number of characters in the Unicode string.

       •   The pointer to the callback function.

       •   An opaque pointer argument that gets forwarded to the callback function.

       The callback function gets invoked for every consecutive sequence of one or more characters that have a
       canonical combining class other than 0, and with the same embedding level. The parameters to the callback
       function are:

       •   The embedding level of the combining characters.

       •   The starting index of a consecutive sequence of all characters with the same embedding level.

       •   The number of characters with the same embedding level.

       •   The starting index of a consecutive sequence of all characters with the same embedding level and a
           canonical combining class other than 0. This will always be equal to or greater than the value of the
           second parameter.

       •   The number of consecutive characters with the characters with the same embedding level and a
           canonical combining class other than 0. The last character included in this sequence will always be
           less than or equal to the last character in the sequence defined by the second and the third
           parameters.

       •   The opaque pointer argument that was passed to <b>unicode_bidi_combinings</b>.

       A consecutive sequence of Unicode characters with non-0 combining classes but different embedding levels
       gets reported individually, for each consecutive sequence with the same embedding level.

       This function helps with reordering the combining characters in right-to-left-rendered text.
       Right-to-left text reversed by <b>unicode_bidi_reorder</b>() results in combining characters preceding their
       starter character. They get reversed no differently than any other character. The same thing also occurs
       after <b>unicode_bidi_logical_order</b>() reverses everything back. Use <b>unicode_bidi_combinings</b> to identify
       consecutive sequences of combining characters followed by their original starter.

       The callback may reorder the characters identified by its third and the fourth parameters in the manner
       described below.  <b>unicode_bidi_reorder</b>'s parameter is pointers to a constant Unicode string; but it can
       modify the string (via an out-of-band mutable pointer) subject to the following conditions:

       •   The characters identified by the third and the fourth parameter may be modified.

       •   If the last character in this sequence is not the last character included in the range specified by
           the first and the second character, then one more character after the last character may also be
           modified.

           This is, presumably, the original starter that preceded the combining characters before the entire
           sequence was reversed.

       Here's an example of a callback that reverses combining characters and their immediately-following
       starter character:

           void reorder_right_to_left_combining(unicode_bidi_level_t level,
                                                size_t level_start,
                                                size_t n_chars,
                                                size_t comb_start,
                                                size_t n_comb_chars,
                                                void *arg)
           {
               /* Let's say that this is the Unicode string */
               char32_t *buf=(char32_t *)arg;

               if ((level &amp; 1) == 0)
                   return; /* Left-to-right text not reversed */

               char32_t *b=buf+comb_start;
               char32_t *e=b+n_comb_chars;

               /*
               ** Include the starter characters in the reversed range.
               ** The semantics of the combining characters with different
               ** embedding levels -- so they get reported here separately -- is
               ** not specified. This will reverse just the combining marks, and
               ** they're on their own.
               */

               if (comb_start + n_comb_chars &lt; level_start + n_chars)
                   ++e;

               while (b &lt; e)
               {
                   char32_t t;

                   --e;
                   t=*b;
                   *b=*e;
                   *e=t;
                   ++b;
               }
           }

   <b>Miscellaneous</b> <b>utility</b> <b>functions</b>
       <b>unicode_bidi_get_direction</b> takes a pointer to a unicode string, the number of characters in the unicode
       string, and determines default paragraph level level.  <b>unicode_bidi_get_direction</b> returns a struct with
       the following fields:

       <u>direction</u>
           This value is either UNICODE_BIDI_LR or UNICODE_BIDI_RL (left to right or right to left).

       <u>is_explicit</u>
           This value is a flag. A non-0 value indicates that the embedding level was derived from an explicit
           character type (L, R or AL) from the stirng. A 0 value indicates the default paragraph direction, no
           explicit character was found in the string.

       <b>unicode_bidi_type</b> looks up each character's bi-directional character type.

       <b>unicode_bidi_setbnl</b> takes a pointer to a unicode string, a pointer to an array of enum_bidi_type_t values
       and the number of characters in the string and the array.  <b>unicode_bidi_setbnl</b> replaces all paragraph
       separators in the unicode string with a newline character (same as the UNICODE_BIDI_CLEANUP_BNL option to
       <b>unicode_bidi_cleanup</b>.

       <b>unicode_bidi_mirror</b> returns the glyph that's a mirror image of the parameter (i.e. an open parenthesis
       for a close parenthesis, and vice versa); or the same value if there is no mirror image (this is the
       Bidi_Mirrored=Yes property).

       <b>unicode_bidi_bracket_type</b> looks up each bracket character and returns its opposite, or the same value if
       the character is not a bracket that has an opposing bracket character (this is the
       Bidi_Paired_Bracket_type property). A non-NULL <u>ret</u> gets initialized to either UNICODE_BIDI_o,
       UNICODE_BIDI_c or UNICODE_BIDI_n.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>TR-9</b>[1], <b>unicode::<a href="../man3/bidi.3.html">bidi</a></b>(3), <b><a href="../man7/courier-unicode.7.html">courier-unicode</a></b>(7),

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>Sam</b> <b>Varshavchik</b>
           Author

</pre><h4><b>NOTES</b></h4><pre>
        1. Unicode Bi-Directional algorithm
           https://www.unicode.org/reports/tr9/tr9-48.html

Courier Unicode Library                            05/18/2024                                    <u><a href="../man3/UNICODE_BIDI.3.html">UNICODE_BIDI</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>