<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zmq_ppoll - input/output multiplexing with signal mask</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libzmq3-dev">libzmq3-dev_4.3.5-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zmq_ppoll - input/output multiplexing with signal mask

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>int</b> <b>zmq_ppoll</b> <b>(zmq_pollitem_t</b> <u>*items</u><b>,</b> <b>int</b> <u>nitems</u><b>,</b> <b>long</b> <u>timeout</u><b>,</b> <b>const</b> <b>sigset_t</b> <u>*sigmask</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The relationship between <u>zmq_poll()</u> and <u>zmq_ppoll()</u> is analogous to the relationship between <a href="../man2/poll.2.html">poll</a>(2) and
       <a href="../man2/ppoll.2.html">ppoll</a>(2) and between <a href="../man2/select.2.html">select</a>(2) and <a href="../man2/pselect.2.html">pselect</a>(2): <u>zmq_ppoll()</u> allows an application to safely wait until
       either a file descriptor becomes ready or until a signal is caught.

       When using <u>zmq_ppoll()</u> with <u>sigmask</u> set to NULL, its behavior is identical to that of <u>zmq_poll()</u>. See
       <b><a href="../man3/zmq_poll.3.html">zmq_poll</a></b>(3) for more on this.

       To make full use of <u>zmq_ppoll()</u>, a non-NULL pointer to a signal mask must be constructed and passed to
       <u>sigmask</u>. See <a href="../man2/sigprocmask.2.html">sigprocmask</a>(2) for more details. When this is done, inside the actual <u>ppoll()</u> (or <u>pselect()</u>,
       see note below) system call, an atomic operation consisting of three steps is performed: 1. The current
       signal mask is replaced by the one pointed to by <u>sigmask</u>. 2. The actual <u>poll()</u> call is done. 3. The
       original signal mask is restored. Because these operations are done atomically, there is no opportunity
       for race conditions in between the calls changing the signal mask and the poll/select system call. This
       means that only during this (atomic) call, we can unblock certain signals, so that they can be handled <b>at</b>
       <b>that</b> <b>time</b> <b>only</b>, not outside of the call. This means that effectively, we extend our poller into a
       function that not only watches sockets for changes, but also watches the "POSIX signal socket" for
       incoming signals. At other times, these signals will be blocked, and we will not have to deal with
       interruptions in system calls at these other times.

           <b>Note</b>

           The <u>zmq_ppoll()</u> function may be implemented or emulated using operating system interfaces other than
           <u>ppoll()</u>, and as such may be subject to the limits of those interfaces in ways not defined in this
           documentation.

           <b>Note</b>

           There is no <u>ppoll</u> or <u>pselect</u> on Windows, so <u>zmq_ppoll()</u> is not supported in Windows builds. It is
           still callable, but its <u>sigmask</u> has void pointer type (because <u>sigset_t</u> is also not available on
           Windows) and <u>zmq_ppoll()</u> will return with an error (see error section below).

</pre><h4><b>THREAD</b> <b>SAFETY</b></h4><pre>
       The <b>zmq_pollitem_t</b> array must only be used by the thread which will/is calling <u>zmq_ppoll</u>.

       If a socket is contained in multiple <b>zmq_pollitem_t</b> arrays, each owned by a different thread, the socket
       itself needs to be thead-safe (Server, Client, ...). Otherwise, behaviour is undefined.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, the <u>zmq_ppoll()</u> function shall return the number of <b>zmq_pollitem_t</b> structures
       with events signaled in <u>revents</u> or 0 if no events have been signaled. Upon failure, <u>zmq_ppoll()</u> shall
       return -1 and set <u>errno</u> to one of the values defined below.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>ETERM</b>
           At least one of the members of the <u>items</u> array refers to a <u>socket</u> whose associated 0MQ <u>context</u> was
           terminated.

       <b>EFAULT</b>
           The provided <u>items</u> was not valid (NULL).

       <b>EINTR</b>
           The operation was interrupted by delivery of a signal before any events were available.

       <b>EINTR</b>
           The operation was interrupted by delivery of a signal before any events were available.

       <b>ENOTSUP</b>
           <u>zmq_ppoll()</u> was not activated in this build.

</pre><h4><b>EXAMPLE</b></h4><pre>
       <b>Polling</b> <b>indefinitely</b> <b>for</b> <b>input</b> <b>events</b> <b>on</b> <b>both</b> <b>a</b> <b>0MQ</b> <b>socket</b> <b>and</b> <b>a</b> <b>standard</b> <b>socket.</b>. See the <u>example</u>
       <u>section</u> of <b><a href="../man3/zmq_poll.3.html">zmq_poll</a></b>(3). One only needs to replace the <u>zmq_poll</u> call with <u>zmq_ppoll</u> and add a <u>NULL</u>
       argument for the <u>sigmask</u> parameter.

       <b>Handle</b> <b>SIGTERM</b> <b>during</b> <b>zmq_ppoll</b> <b>(and</b> <b>block</b> <b>it</b> <b>otherwise).</b>.

           // simple global signal handler for SIGTERM
           static bool sigterm_received = false;
           void handle_sigterm (int signum) {
               sigterm_received = true;
           }

           // set up signal mask and install handler for SIGTERM
           sigset_t sigmask, sigmask_without_sigterm;
           sigemptyset(&amp;sigmask);
           sigaddset(&amp;sigmask, SIGTERM);
           sigprocmask(SIG_BLOCK, &amp;sigmask, &amp;sigmask_without_sigterm);
           struct sigaction sa;
           memset(&amp;sa, '\0', sizeof(sa));
           sa.sa_handler = handle_sigterm;

           // poll
           zmq_pollitem_t items [1];
           // Just one item, which refers to 0MQ socket 'socket' */
           items[0].socket = socket;
           items[0].events = ZMQ_POLLIN;
           // Poll for events indefinitely, but also exit on SIGTERM
           int rc = zmq_poll (items, 2, -1, &amp;sigmask_without_sigterm);
           if (rc &lt; 0 &amp;&amp; errno == EINTR &amp;&amp; sigterm_received) {
             // do your SIGTERM business
           } else {
             // do your non-SIGTERM error handling
           }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/zmq_poll.3.html">zmq_poll</a></b>(3) <b><a href="../man3/zmq_socket.3.html">zmq_socket</a></b>(3) <b><a href="../man3/zmq_send.3.html">zmq_send</a></b>(3) <b><a href="../man3/zmq_recv.3.html">zmq_recv</a></b>(3) <b><a href="../man7/zmq.7.html">zmq</a></b>(7)

       Your operating system documentation for the <u>poll()</u> system call.

</pre><h4><b>AUTHORS</b></h4><pre>
       This page was written by the 0MQ community. To make a change please read the 0MQ Contribution Policy at
       <b><a href="http://www.zeromq.org/docs">http://www.zeromq.org/docs</a>:contributing</b>.

0MQ 4.3.5                                          03/31/2024                                        <u><a href="../man3/ZMQ_POLL.3.html">ZMQ_POLL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>