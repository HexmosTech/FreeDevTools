<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       sigtimedwait, sigwaitinfo — wait for queued signals

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;

       int sigtimedwait(const sigset_t *restrict <u>set</u>,
           siginfo_t *restrict <u>info</u>,
           const struct timespec *restrict <u>timeout</u>);
       int sigwaitinfo(const sigset_t *restrict <u>set</u>,
           siginfo_t *restrict <u>info</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>sigtimedwait</u>()  function  shall  be  equivalent  to <u>sigwaitinfo</u>() except that if none of the signals
       specified by <u>set</u> are pending, <u>sigtimedwait</u>() shall wait for the time interval specified in  the  <b>timespec</b>
       structure  referenced  by <u>timeout</u>.  If the <b>timespec</b> structure pointed to by <u>timeout</u> is zero-valued and if
       none of the signals specified by <u>set</u> are pending, then <u>sigtimedwait</u>() shall return  immediately  with  an
       error.  If  <u>timeout</u>  is  the null pointer, the behavior is unspecified.  If the Monotonic Clock option is
       supported, the CLOCK_MONOTONIC clock shall be used to measure the time interval specified by the  <u>timeout</u>
       argument.

       The  <u>sigwaitinfo</u>()  function  selects  the  pending  signal from the set specified by <u>set</u>.  Should any of
       multiple pending signals in the range SIGRTMIN to SIGRTMAX be selected, it shall be the  lowest  numbered
       one.  The  selection  order  between  realtime and non-realtime signals, or between multiple pending non-
       realtime signals, is unspecified. If no signal in <u>set</u> is pending at the time of  the  call,  the  calling
       thread  shall  be suspended until one or more signals in <u>set</u> become pending or until it is interrupted by
       an unblocked, caught signal.

       The <u>sigwaitinfo</u>() function shall be equivalent to the <u>sigwait</u>() function, except that  the  return  value
       and  the  error  reporting method are different (see RETURN VALUE), and that if the <u>info</u> argument is non-
       NULL, the selected signal number shall be stored in the <u>si_signo</u> member, and  the  cause  of  the  signal
       shall  be  stored  in  the  <u>si_code</u> member. If any value is queued to the selected signal, the first such
       queued value shall be dequeued and, if the <u>info</u> argument is non-NULL, the value shall be  stored  in  the
       <u>si_value</u>  member of <u>info</u>.  The system resource used to queue the signal shall be released and returned to
       the system for other use. If no value is queued, the content of the <u>si_value</u> member is undefined.  If  no
       further  signals  are  queued  for  the  selected signal, the pending indication for that signal shall be
       reset.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion (that is, one of the signals specified by <u>set</u>  is  pending  or  is  generated)
       <u>sigwaitinfo</u>()  and  <u>sigtimedwait</u>() shall return the selected signal number. Otherwise, the function shall
       return a value of -1 and set <u>errno</u> to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>sigtimedwait</u>() function shall fail if:

       <b>EAGAIN</b> No signal specified by <u>set</u> was generated within the specified timeout period.

       The <u>sigtimedwait</u>() and <u>sigwaitinfo</u>() functions may fail if:

       <b>EINTR</b>  The wait was interrupted by an  unblocked,  caught  signal.  It  shall  be  documented  in  system
              documentation whether this error causes these functions to fail.

       The <u>sigtimedwait</u>() function may also fail if:

       <b>EINVAL</b> The  <u>timeout</u>  argument  specified  a <u>tv_nsec</u> value less than zero or greater than or equal to 1000
              million.

       An implementation should only check for this error if no signal is pending in <u>set</u> and it is necessary  to
       wait.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       The  <u>sigtimedwait</u>()  function times out and returns an <b>[EAGAIN]</b> error. Application developers should note
       that this is inconsistent with other functions such as <u>pthread_cond_timedwait</u>() that return <b>[ETIMEDOUT]</b>.

       Note that in order to ensure that generated signals are queued and signal values passed to <u>sigqueue</u>() are
       available in <u>si_value</u>, applications which use <u>sigwaitinfo</u>() or <u>sigtimedwait</u>() need to set the  SA_SIGINFO
       flag for each signal in the set (see <u>Section</u> <u>2.4</u>, <u>Signal</u> <u>Concepts</u>).  This means setting each signal to be
       handled  by  a  three-argument signal-catching function, even if the handler will never be called.  It is
       not possible (portably) to set a signal handler to SIG_DFL while setting  the  SA_SIGINFO  flag,  because
       assigning to the <u>sa_handler</u> member of <b>struct</b> <b>sigaction</b> instead of the <u>sa_sigaction</u> member would result in
       undefined  behavior,  and  SIG_DFL  need  not  be  assignment-compatible  with  <u>sa_sigaction</u>.  Even if an
       assignment of SIG_DFL to <u>sa_sigaction</u> is accepted by the compiler, the implementation need not treat this
       value as special—it could just be taken as the address of a signal-catching function.

</pre><h4><b>RATIONALE</b></h4><pre>
       Existing programming practice on realtime systems uses the ability to pause waiting for a selected set of
       events and handle the first event that occurs in-line instead of  in  a  signal-handling  function.  This
       allows  applications  to  be written in an event-directed style similar to a state machine. This style of
       programming is useful for largescale transaction  processing  in  which  the  overall  throughput  of  an
       application  and  the ability to clearly track states are more important than the ability to minimize the
       response time of individual event handling.

       It is possible to construct a signal-waiting macro function out of the realtime signal function mechanism
       defined in this volume of POSIX.1‐2017. However, such  a  macro  has  to  include  the  definition  of  a
       generalized  handler  for  all  signals to be waited on. A significant portion of the overhead of handler
       processing can be avoided if the signal-waiting function is  provided  by  the  kernel.  This  volume  of
       POSIX.1‐2017  therefore  provides two signal-waiting functions—one that waits indefinitely and one with a
       timeout—as part of the overall realtime signal function specification.

       The specification of a function with a timeout allows an application to be written that can be broken out
       of a wait after a set period of time if no event has occurred. It was argued that setting a  timer  event
       before  the wait and recognizing the timer event in the wait would also implement the same functionality,
       but at a lower performance level. Because of the performance degradation associated with  the  user-level
       specification  of  a  timer  event  and  the  subsequent  cancellation of that timer event after the wait
       completes for a valid event, and the  complexity  associated  with  handling  potential  race  conditions
       associated with the user-level method, the separate function has been included.

       Note  that  the  semantics  of  the  <u>sigwaitinfo</u>() function are nearly identical to that of the <u>sigwait</u>()
       function defined by this volume of POSIX.1‐2017. The only difference is that  <u>sigwaitinfo</u>()  returns  the
       queued  signal  value  in  the  <u>value</u>  argument.  The  return  of  the  queued  value is required so that
       applications can differentiate between multiple events queued to the same signal number.

       The two distinct functions are being maintained because some implementations may choose to implement  the
       POSIX  Threads  Extension  functions  and not implement the queued signals extensions. Note, though, that
       <u>sigwaitinfo</u>() does not return the queued value if the <u>value</u>  argument  is  NULL,  so  the  POSIX  Threads
       Extension <u>sigwait</u>() function can be implemented as a macro on <u>sigwaitinfo</u>().

       The  <u>sigtimedwait</u>()  function was separated from the <u>sigwaitinfo</u>() function to address concerns regarding
       the overloading of the <u>timeout</u> pointer  to  indicate  indefinite  wait  (no  timeout),  timed  wait,  and
       immediate return, and concerns regarding consistency with other functions where the conditional and timed
       waits  were  separate  functions  from  the  pure  blocking function. The semantics of <u>sigtimedwait</u>() are
       specified such that <u>sigwaitinfo</u>() could be implemented as a macro with a null pointer for <u>timeout</u>.

       The <u>sigwait</u> functions provide a synchronous mechanism for threads to  wait  for  asynchronously-generated
       signals. One important question was how many threads that are suspended in a call to a <u>sigwait</u>() function
       for a signal should return from the call when the signal is sent. Four choices were considered:

        1. Return an error for multiple simultaneous calls to <u>sigwait</u> functions for the same signal.

        2. One or more threads return.

        3. All waiting threads return.

        4. Exactly one thread returns.

       Prohibiting  multiple calls to <u>sigwait</u>() for the same signal was felt to be overly restrictive. The ``one
       or more'' behavior made implementation of conforming packages  easy  at  the  expense  of  forcing  POSIX
       threads  clients to protect against multiple simultaneous calls to <u>sigwait</u>() in application code in order
       to achieve predictable behavior. There was concern that the ``all waiting threads'' behavior would result
       in ``signal broadcast storms'', consuming excessive CPU resources  by  replicating  the  signals  in  the
       general  case.  Furthermore,  no  convincing  examples could be presented that delivery to all was either
       simpler or more powerful than delivery to one.

       Thus, the consensus was that exactly one thread that was suspended in a call to a <u>sigwait</u> function for  a
       signal should return when that signal occurs. This is not an onerous restriction as:

        *  A multi-way signal wait can be built from the single-way wait.

        *  Signals  should  only be handled by application-level code, as library routines cannot guess what the
           application wants to do with signals generated for the entire process.

        *  Applications can thus arrange for a single thread to wait for any given signal and  call  any  needed
           routines upon its arrival.

       In  an  application  that is using signals for interprocess communication, signal processing is typically
       done in one place. Alternatively, if the signal is being caught so that process cleanup can be done,  the
       signal  handler  thread  can  call separate process cleanup routines for each portion of the application.
       Since the application main line started each portion of the application, it is at the  right  abstraction
       level to tell each portion of the application to clean up.

       Certainly,  there exist programming styles where it is logical to consider waiting for a single signal in
       multiple threads. A simple <u>sigwait_multiple</u>() routine can be constructed to achieve this goal. A possible
       implementation would be to have each <u>sigwait_multiple</u>() caller registered as having expressed interest in
       a set of signals.  The caller then waits on a thread-specific condition variable. A single server  thread
       calls  a  <u>sigwait</u>() function on the union of all registered signals. When the <u>sigwait</u>() function returns,
       the appropriate state is set and condition variables are broadcast. New  <u>sigwait_multiple</u>()  callers  may
       cause  the pending <u>sigwait</u>() call to be canceled and reissued in order to update the set of signals being
       waited for.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u> <u>2.4</u>, <u>Signal</u> <u>Concepts</u>, <u>Section</u> <u>2.8.1</u>, <u>Realtime</u> <u>Signals</u>, <u>pause</u>(),  <u>pthread_sigmask</u>(),  <u>sigaction</u>(),
       <u>sigpending</u>(), <u>sigsuspend</u>(), <u>sigwait</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;signal.h&gt;</b>, <b>&lt;time.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                  <u><a href="../man3POSIX/SIGTIMEDWAIT.3POSIX.html">SIGTIMEDWAIT</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>