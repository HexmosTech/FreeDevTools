<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       pthread_sigmask, sigprocmask — examine and change blocked signals

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;

       int pthread_sigmask(int <u>how</u>, const sigset_t *restrict <u>set</u>,
           sigset_t *restrict <u>oset</u>);
       int sigprocmask(int <u>how</u>, const sigset_t *restrict <u>set</u>,
           sigset_t *restrict <u>oset</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>pthread_sigmask</u>()  function  shall  examine  or  change  (or both) the calling thread's signal mask,
       regardless of the number of threads in the process. The function shall be  equivalent  to  <u>sigprocmask</u>(),
       without the restriction that the call be made in a single-threaded process.

       In  a  single-threaded  process,  the <u>sigprocmask</u>() function shall examine or change (or both) the signal
       mask of the calling thread.

       If the argument <u>set</u> is not a null pointer, it points to a set  of  signals  to  be  used  to  change  the
       currently blocked set.

       The  argument  <u>how</u>  indicates  the  way  in which the set is changed, and the application shall ensure it
       consists of one of the following values:

       SIG_BLOCK   The resulting set shall be the union of the current set and the signal set pointed to by <u>set</u>.

       SIG_SETMASK The resulting set shall be the signal set pointed to by <u>set</u>.

       SIG_UNBLOCK The resulting set shall be the intersection of the current set  and  the  complement  of  the
                   signal set pointed to by <u>set</u>.

       If  the argument <u>oset</u> is not a null pointer, the previous mask shall be stored in the location pointed to
       by <u>oset</u>.  If <u>set</u> is a null pointer, the value of the argument <u>how</u> is not  significant  and  the  thread's
       signal mask shall be unchanged; thus the call can be used to enquire about currently blocked signals.

       If there are any pending unblocked signals after the call to <u>sigprocmask</u>(), at least one of those signals
       shall be delivered before the call to <u>sigprocmask</u>() returns.

       It  is not possible to block those signals which cannot be ignored.  This shall be enforced by the system
       without causing an error to be indicated.

       If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are generated while they are blocked, the result
       is undefined, unless the signal was generated by the  action  of  another  process,  or  by  one  of  the
       functions <u>kill</u>(), <u>pthread_kill</u>(), <u>raise</u>(), or <u>sigqueue</u>().

       If <u>sigprocmask</u>() fails, the thread's signal mask shall not be changed.

       The use of the <u>sigprocmask</u>() function is unspecified in a multi-threaded process.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion <u>pthread_sigmask</u>() shall return 0; otherwise, it shall return the corresponding
       error number.

       Upon successful completion, <u>sigprocmask</u>() shall return 0; otherwise, -1 shall be returned, <u>errno</u> shall be
       set to indicate the error, and the signal mask of the process shall be unchanged.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>pthread_sigmask</u>() and <u>sigprocmask</u>() functions shall fail if:

       <b>EINVAL</b> The value of the <u>how</u> argument is not equal to one of the defined values.

       The <u>pthread_sigmask</u>() function shall not return an error code of <b>[EINTR]</b>.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Signaling</b> <b>in</b> <b>a</b> <b>Multi-Threaded</b> <b>Process</b>
       This  example  shows  the  use  of  <u>pthread_sigmask</u>()  in  order to deal with signals in a multi-threaded
       process. It provides a fairly general framework that could be easily adapted/extended.

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;
           #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
           #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
           #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
           ...

           static sigset_t   signal_mask;  /* signals to block         */

           int main (int argc, char *argv[])
           {
               pthread_t  sig_thr_id;      /* signal handler thread ID */
               int        rc;              /* return code              */

               sigemptyset (&amp;signal_mask);
               sigaddset (&amp;signal_mask, SIGINT);
               sigaddset (&amp;signal_mask, SIGTERM);
               rc = pthread_sigmask (SIG_BLOCK, &amp;signal_mask, NULL);
               if (rc != 0) {
                   /* handle error */
                   ...
               }
               /* any newly created threads inherit the signal mask */

               rc = pthread_create (&amp;sig_thr_id, NULL, signal_thread, NULL);
               if (rc != 0) {
                   /* handle error */
                   ...
               }

               /* APPLICATION CODE */
               ...
           }

           void *signal_thread (void *arg)
           {
               int       sig_caught;    /* signal caught       */
               int       rc;            /* returned code       */

               rc = sigwait (&amp;signal_mask, &amp;sig_caught);
               if (rc != 0) {
                   /* handle error */
               }
               switch (sig_caught)
               {
               case SIGINT:     /* process SIGINT  */
                   ...
                   break;
               case SIGTERM:    /* process SIGTERM */
                   ...
                   break;
               default:         /* should normally not happen */
                   fprintf (stderr, "\nUnexpected signal %d\n", sig_caught);
                   break;
               }
           }

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       None.

</pre><h4><b>RATIONALE</b></h4><pre>
       When a thread's signal mask is changed in a signal-catching function that is  installed  by  <u>sigaction</u>(),
       the restoration of the signal mask on return from the signal-catching function overrides that change (see
       <u>sigaction</u>()).   If  the  signal-catching  function was installed with <u>signal</u>(), it is unspecified whether
       this occurs.

       See <u>kill</u>() for a discussion of the requirement on delivery of signals.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>exec</u>,  <u>kill</u>(),  <u>sigaction</u>(),  <u>sigaddset</u>(),  <u>sigdelset</u>(),  <u>sigemptyset</u>(),   <u>sigfillset</u>(),   <u>sigismember</u>(),
       <u>sigpending</u>(), <u>sigqueue</u>(), <u>sigsuspend</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;signal.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                               <u><a href="../man3POSIX/PTHREAD_SIGMASK.3POSIX.html">PTHREAD_SIGMASK</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>