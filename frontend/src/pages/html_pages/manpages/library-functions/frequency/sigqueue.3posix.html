<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       sigqueue — queue a signal to a process

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;

       int sigqueue(pid_t <u>pid</u>, int <u>signo</u>, union sigval <u>value</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>sigqueue</u>() function shall cause the signal specified by <u>signo</u> to be sent with the value specified by
       <u>value</u> to the process specified by <u>pid</u>.  If <u>signo</u> is zero (the null signal), error checking  is  performed
       but no signal is actually sent. The null signal can be used to check the validity of <u>pid</u>.

       The  conditions  required  for  a process to have permission to queue a signal to another process are the
       same as for the <u>kill</u>() function.

       The <u>sigqueue</u>() function shall return immediately. If SA_SIGINFO is set for <u>signo</u>  and  if  the  resources
       were  available  to  queue  the  signal, the signal shall be queued and sent to the receiving process. If
       SA_SIGINFO is not set for <u>signo</u>, then <u>signo</u> shall be sent at least once to the receiving process;  it  is
       unspecified whether <u>value</u> shall be sent to the receiving process as a result of this call.

       If the value of <u>pid</u> causes <u>signo</u> to be generated for the sending process, and if <u>signo</u> is not blocked for
       the  calling  thread and if no other thread has <u>signo</u> unblocked or is waiting in a <u>sigwait</u>() function for
       <u>signo</u>, either <u>signo</u> or at least the pending, unblocked signal shall be delivered to  the  calling  thread
       before  the  <u>sigqueue</u>()  function  returns.  Should any multiple pending signals in the range SIGRTMIN to
       SIGRTMAX be selected for delivery, it shall be the lowest numbered  one.   The  selection  order  between
       realtime and non-realtime signals, or between multiple pending non-realtime signals, is unspecified.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon  successful  completion,  the  specified  signal shall have been queued, and the <u>sigqueue</u>() function
       shall return a value of zero. Otherwise, the function shall return  a  value  of  -1  and  set  <u>errno</u>  to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>sigqueue</u>() function shall fail if:

       <b>EAGAIN</b> No  resources  are  available  to  queue the signal. The process has already queued {SIGQUEUE_MAX}
              signals that are still pending at the receiver(s),  or  a  system-wide  resource  limit  has  been
              exceeded.

       <b>EINVAL</b> The value of the <u>signo</u> argument is an invalid or unsupported signal number.

       <b>EPERM</b>  The process does not have appropriate privileges to send the signal to the receiving process.

       <b>ESRCH</b>  The process <u>pid</u> does not exist.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       None.

</pre><h4><b>RATIONALE</b></h4><pre>
       The <u>sigqueue</u>() function allows an application to queue a realtime signal to itself or to another process,
       specifying  the  application-defined  value. This is common practice in realtime applications on existing
       realtime systems.  It was felt that specifying another function in the <u>sig</u>...  name space already  carved
       out for signals was preferable to extending the interface to <u>kill</u>().

       Such  a  function  became necessary when the put/get event function of the message queues was removed. It
       should be noted that  the  <u>sigqueue</u>()  function  implies  reduced  performance  in  a  security-conscious
       implementation  as the access permissions between the sender and receiver have to be checked on each send
       when the <u>pid</u> is resolved into a target process. Such access checks were necessary only at  message  queue
       open in the previous interface.

       The  standard developers required that <u>sigqueue</u>() have the same semantics with respect to the null signal
       as <u>kill</u>(), and that the same permission checking be used. But because of the difficulty  of  implementing
       the  ``broadcast''  semantic of <u>kill</u>() (for example, to process groups) and the interaction with resource
       allocation, this semantic was not adopted. The <u>sigqueue</u>() function queues a signal to  a  single  process
       specified by the <u>pid</u> argument.

       The  <u>sigqueue</u>()  function  can  fail  if  the  system  has insufficient resources to queue the signal. An
       explicit limit on the number of queued signals that a process could send was introduced. While the  limit
       is  ``per-sender'',  this volume of POSIX.1‐2017 does not specify that the resources be part of the state
       of the sender. This would require either that the sender be maintained after exit until all signals  that
       it  had sent to other processes were handled or that all such signals that had not yet been acted upon be
       removed from the queue(s) of the receivers. This volume of POSIX.1‐2017 does not preclude this  behavior,
       but  an  implementation that allocated queuing resources from a system-wide pool (with per-sender limits)
       and that leaves queued signals pending after the sender exits is also permitted.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u> <u>2.8.1</u>, <u>Realtime</u> <u>Signals</u>

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;signal.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                      <u><a href="../man3POSIX/SIGQUEUE.3POSIX.html">SIGQUEUE</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>