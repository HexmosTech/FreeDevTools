<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bgexec  -  Run  programs  in  the  background while handling Tk events.  kill - Terminate program or send</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/blt-dev">blt-dev_2.5.3+dfsg-8_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       bgexec  -  Run  programs  in  the  background while handling Tk events.  kill - Terminate program or send
       signal.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>blt::bgexec</b> <u>varName</u> ?<u>switches</u>? <u>program</u> ?<u>arg</u>?...
       <b>blt::kill</b> <u>processid</u> ?<u>signal</u>?
_________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>kill</b> command terminates a <u>processid</u> or under unix sends a signal.

       The <b>bgexec</b> command executes a <u>program</u> pipleline  using  the  <b>Tcl</b>  event-loop  allowing  other  events  to
       continue  to  be  serviced.   Upon completion it sets the global variable <u>varName</u> with a list of 4 status
       values: a text token, the process-id, the exit code, and a text message.   <b>Bgexec</b>  provides  capabilities
       similar to the <b>exec</b> command, but with added support for callbacks, output to variables and termination.

       When  used  with no options, the returned value from <b>bgexec</b> is the output from the <u>program</u>.  But when the
       last <u>arg</u> is an ampersand (&amp;) the <u>program</u> runs detached, and <b>bgexec</b> immediately returns with a list of the
       process ids created in the command pipeline.  Detached processes can be interrupted and terminated simply
       by setting <u>varName</u>.

       The valid <u>switches</u> are as follows:

       <b>-check</b> <u>num</u>
              Interval in ms to poll for the exiting processes.  The default is 1000.

       <b>-closeonkill</b> <u>millisecs</u>
              Force close of stdin/stdout on kill after the given interval.  This lets kill finalize  processes,
              even  uninterruptably  sleeping ones unable to receive signals.  The default is <b>0</b> for do not force
              close.

       <b>-command</b> <u>script</u>
              Specifies a command to call upon command completion/termination.  Two extra arguments are appended
              before the call.  The data output from the command, and the status info as set into <u>varName</u>.

       <b>-decodeerror</b> <u>encodingName</u>
              Specifies the encoding of the stderr  channel.   This  affects  only  data  returned  to  the  Tcl
              interpreter.   No translation is done on file redirection.  For example if data is to be converted
              from Unicode for use in Tcl, you would  use  the  "unicode"  encoding.  The  default  is  that  no
              tranlation is performed.

       <b>-decodeoutput</b> <u>encodingName</u>
              Specifies  the  encoding  of  the  stdout  channels.   This  affects only data returned to the Tcl
              interpreter.  No translation is done on file redirection.  For example if data is to be  converted
              from  Unicode  for  use  in  Tcl,  you  would  use  the "unicode" encoding. The default is that no
              tranlation is performed.

       <b>-echo</b> <u>boolean</u>
              Indicates if the pipeline's stderr stream should be echoed.  <u>Note:</u> <u>this</u> <u>option</u> <u>is</u> <u>deprecated.</u>

       <b>-error</b> <u>varName</u>
              Specifies that a global variable <u>varName</u> is to be set  with  the  contents  of  stderr  after  the
              program has completed.

       <b>-keepnewline</b> <u>boolean</u>
              Specifies  that  a  trailing  newline  should  be  retained in the output. If <u>boolean</u> is true, the
              trailing newline is truncated from the output of the <b>-onoutput</b> and <b>-output</b> variables.  The default
              value is <b>true</b>.

       <b>-killsignal</b> <u>signal</u>
              Specifies the signal to be sent to the program when terminating. This option is available only  on
              Unix.  <u>Signal</u> can either be a number (typically 1-32) or a mnemonic (such as SIGINT). If <u>signal</u> is
              the empty string, then no signal is sent.  The default signal is <b>9</b> (SIGKILL).

       <b>-lasterror</b> <u>varName</u>
              Specifies  a  variable <u>varName</u> that is updated whenever data becomes available from standard error
              of the program.  <u>VarName</u> is a global variable. Unlike the <b>-error</b> option, data is available as soon
              as it arrives.

       <b>-lastoutput</b> <u>varName</u>
              Specifies a variable <u>varName</u> that is updated whenever data becomes available from standard  output
              of  the  program.   <u>VarName</u>  is a global variable. Unlike the <b>-output</b> option, data is available as
              soon as it arrives.

       <b>-limit</b> <u>numBytes</u>
              Limit the size of the returned data to <u>numBytes</u>, terminating the program if exceeded.   The  limit
              applies to both stdout and stderr.

       <b>-linebuffered</b> <u>boolean</u>
              Specifies  that  updates  should  be  made  on  a  line-by-line  basis.  Normally when new data is
              available <b>bgexec</b> will set the variable (<b>-lastoutput</b> and <b>-lasterror</b> options) or invoke the  command
              (<b>-onoutput</b>  and  <b>-onerror</b> options) delivering all the new data currently available.  If <u>boolean</u> is
              true, only one line at a time will be delivered.  This can be useful when you want to process  the
              output on a line-by-line basis.  The default value is <b>false</b>.

       <b>-local</b> <u>boolean</u>
              When  <u>boolean</u>  is  true,  any unqualified variables or command options are treated as local to the
              current namespace.  This is mostly useful for non-detaching (no ampersand)  commands.   Note  that
              using  this  flag  with a detached command will use variables from the current namespace, not from
              the current proc stack-frame.

       <b>-onerror</b> <u>command</u>
              Specifies the start of a Tcl command that will be executed whenever new  data  is  available  from
              standard error. The data is appended to the command as an extra argument before it is executed.

       <b>-onoutput</b> <u>command</u>
              Specifies  the  start  of  a Tcl command that will be executed whenever new data is available from
              standard output. The data is appended to the command as an extra argument before it is executed.

       <b>-output</b> <u>varName</u>
              Specifies a global variable <u>varName</u> to be set with the output of the program, upon completion.

       <b>-raise</b> <u>boolean</u>
              When <u>boolean</u> is <b>true</b>, a non-zero return code from a non-detached command will raise an error  (.ie
              emulates  <b>exec</b>).   The default is <b>false</b> an error is generated only if one of the following occurs:
              invalid options are given, a redirection  error,  or  process  creation  failure  (eg.  executable
              program not found).  Detached commands, of course, never raise an error on a non-zero return code.

       <b>--</b>     This  marks  the  end  of  the  options.   The following argument will be considered the name of a
              program even if it starts with a dash (<b>-</b>).

</pre><h4><b>USAGE</b></h4><pre>
       Invoking <b>bgexec</b> without a trailing ampersand will block and wait for result.  However, other  Tcl  events
       continue to be serviced.  This prevents Tcl from hanging, eg:

              pack [text .t]
              set val [blt::bgexec myStatus du -s]

       Note that text widget .t continues to respond to events.

</pre><h4><b>CALLBACKS</b></h4><pre>
       Here is an example that invokes the Unix <b>du</b> program with a <b>-command</b> callback.

              proc Done {data status} {  puts "Done($status)\n$data" }

              blt::bgexec myStatus  -command Done   du -s $dir &amp;

       When  <b>du</b>  has  completed,  the  handler  <b>Done</b>  is called with data and status.  Also, the global variable
       <u>myStatus</u> is set to contain the program's exit status, eg:

              EXITED 26811 0 {child completed normally}

       If <u>myStatus</u> is set before <b>du</b> has completed, the process will be killed. Under Unix, this sends  a  signal
       (SIGKILL by default).  Under Win32, <b>TerminateProcess</b> is called.

</pre><h4><b>VARIABLE</b></h4><pre>
       Here is another example, this time using the <b>-output</b> option to direct output to a variable.

              global myStatus myOutput
              blt::bgexec myStatus -output myOutput du -s $dir
              puts "Disk usage for $dir is $myOutput"

       Upon completion, <b>MyOutput</b> will contain the output of the program.

</pre><h4><b>STDERR</b></h4><pre>
       Various <b>bgexec</b> options can be used to capture <b>stderr</b> separately from <b>stdout</b>.

              global myStatus myOutput myErrs
              blt::bgexec myStatus -output myOutput -error myErrs du -s $dir

       The  <b>-error</b>  option is similar to <b>-output</b> in that it sets a variable when the program completes with data
       written to stderr.

</pre><h4><b>LOCAL</b></h4><pre>
       By default, <b>bgexec</b> treats variable or command options as being  in  the  global  namespace.   The  <b>-local</b>
       option  can  change  this  to  use  the current namespace.  Thus data can be collected to namespace-local
       variables even those inside of procs,  eg.

              proc Work {} {
                blt::bgexec myStatus -local 1 -output val -error err du -s
                puts "VAL=$val"
                puts "ERR=$err"
              }

       which collects data to local variables.

       For detached processes, <b>-local</b> will cause data to aggregate to namespace variables, ie. outside the proc,
       eg.

              namespace eval ::Ns {
                set pval {}
                set perr {}
                proc Work {} {
                  blt::bgexec myStatus -local 1 -output pval -error perr du -s &amp;
                }
              }

       This collects data to <b>::Ns::pval</b> and stderr to  <b>::Ns::perr</b>.  Similarly, proc names (eg <b>-onoutput</b>) will be
       relative to the current namespace.

</pre><h4><b>PROGRESS</b></h4><pre>
       The <b>-output</b> and <b>-error</b> variables are set only after the program completes.  But if a program runs  for  a
       long  time,  you can gather data as it becomes available using the <b>-onoutput</b> option.  As new data becomes
       available, this command is executed, with data appended as an argument.

              proc GetInfo { data } { puts $data }

              blt::bgexec myStatus -onoutput GetInfo du -s $dir

       The <b>-onerror</b> option performs a similar function for the stderr data stream.

</pre><h4><b>ERROR</b> <b>HANDLING</b></h4><pre>
       Like <b>exec</b>, <b>bgexec</b> returns an error if the exit code of the program is non-zero.  To  handle  this  invoke
       <b>bgexec</b> from within a <b>catch</b>.

              catch { blt::bgexec myStatus -output myOutput du -s $dir }

       Detached  jobs  will generate an error only if the program startup failed.  Otherwise the only indication
       is the status code set in <u>myStatus</u>.

</pre><h4><b>TKWAIT</b></h4><pre>
       By default, <b>bgexec</b> waits for a program to finish and returns the resulting output.  To detach  a  program
       simply append an ampersand (&amp;) as the last argument on the command line, eg.

              global myStatus myOutput
              blt::bgexec myStatus -output myOutput du -s $dir &amp;

       <b>Bgexec</b>  will then return immediately with the spawned process ids as the result.  If needed <b>tkwait</b> can be
       used to wait for the program to finish:

              global myStatus myOutput
              blt::bgexec myStatus -output myOutput du -s $dir &amp;
                    ...
              tkwait variable myStatus

       Note however that using <b>tkwait</b> can be dangerous.   Multiple  <b>tkwait</b>/<b>vwait</b>  calls  must  complete  in  the
       reverse order called.  The BLT <b>busy</b> command can be used to try and enforce this, but a better alternative
       is to just use <b>-command</b> instead.

</pre><h4><b>DIFFERENCES</b> <b>WITH</b> <b>EXEC</b></h4><pre>
       Using  <b>bgexec</b> without an ampersand will not hang Tcl: events continue to be serviced by the event handler
       while the call blocks.  Also unlike <b>exec</b>, an error will not be generated if output is appears on  <b>stderr</b>.
       And  output  from  <b>stderr</b>  can be separately managed and collected (without having to redirect to files).
       Finally, <b>bgexec</b> ensures that invoked processes get properly cleaned up at termination.

</pre><h4><b>DIFFERENCES</b> <b>WITH</b> <b>FILEEVENT</b></h4><pre>
       Since Tk 4.0, a subset of <b>bgexec</b> can be achieved using the <b>fileevent</b> command.  The steps  for  running  a
       program in the background are:

       Execute the program with the <b>open</b> command (using the "|" syntax) and save the file handle.

                global fileId
                set fileId [open "|du -s $dir" r]

       Next  register  a  Tcl  code  snippet  with  <b>fileevent</b> to be run whenever output is available on the file
       handle.  The code snippet will read from the file handle and save the output in a variable.

              fileevent fileId readable {
                if { [gets $fileId line] &lt; 0 } {
                    close $fileId
                    set output $temp
                    unset fileId temp
                } else {
                    append temp $line
                }
              }

       However, <b>Bgexec</b> is simpler and less error prone than using <b>open</b> + <b>fileevent</b>.  You  don't  have  to  worry
       about non-blocking I/O.  Everything is handled for you automatically.

       Moreover,  <b>bgexec</b>  can  run  programs  that <b>fileevent</b> can not.  <b>Fileevent</b> assumes that the when stdout is
       closed the program has completed.  But some programs, like the  Unix  <b>compress</b>  program,  reopen  stdout,
       fooling  <b>fileevent</b>  into  thinking  the program has terminated.  In the example above, we assume that the
       program will write and flush its  output  line-by-line.   However  when  running  another  program,  your
       application can block in the <b>gets</b> command reading a partial line.

       <b>Bgexec</b>  gives  you  get  back  the  exit  status of the program.  It also lets you reliably kill detached
       processes and allows you to collect data from both stdout and stderr individually.  Finally,  since  data
       collection is handled in C code, <b>bgexec</b> is faster and more efficient.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       busy, exec, tkwait, vwait

</pre><h4><b>KEYWORDS</b></h4><pre>
       exec, background, busy

BLT                                                    2.5                                     <u>blt::<a href="../man3tcl/bgexec.3tcl.html">bgexec</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>