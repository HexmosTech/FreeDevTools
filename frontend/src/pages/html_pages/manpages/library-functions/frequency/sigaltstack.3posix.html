<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       sigaltstack — set and get signal alternate stack context

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;

       int sigaltstack(const stack_t *restrict <u>ss</u>, stack_t *restrict <u>oss</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>sigaltstack</u>()  function  allows  a process to define and examine the state of an alternate stack for
       signal handlers for the current thread. Signals that have been explicitly  declared  to  execute  on  the
       alternate stack shall be delivered on the alternate stack.

       If  <u>ss</u>  is not a null pointer, it points to a <b>stack_t</b> structure that specifies the alternate signal stack
       that shall take effect upon return from <u>sigaltstack</u>().  The  <u>ss_flags</u>  member  specifies  the  new  stack
       state.  If  it  is set to SS_DISABLE, the stack is disabled and <u>ss_sp</u> and <u>ss_size</u> are ignored. Otherwise,
       the stack shall be enabled, and the <u>ss_sp</u> and <u>ss_size</u> members specify the new address  and  size  of  the
       stack.

       The  range  of  addresses  starting  at  <u>ss_sp</u>  up to but not including <u>ss_sp</u>+<u>ss_size</u> is available to the
       implementation for use as the stack. This function makes no assumptions regarding which end is the  stack
       base and in which direction the stack grows as items are pushed.

       If  <u>oss</u>  is  not  a  null  pointer, upon successful completion it shall point to a <b>stack_t</b> structure that
       specifies the alternate signal stack that was in effect prior to the call to  <u>sigaltstack</u>().   The  <u>ss_sp</u>
       and <u>ss_size</u> members specify the address and size of that stack. The <u>ss_flags</u> member specifies the stack's
       state, and may contain one of the following values:

       SS_ONSTACK  The  process  is  currently  executing on the alternate signal stack.  Attempts to modify the
                   alternate signal stack while the process is executing on it fail.  This  flag  shall  not  be
                   modified by processes.

       SS_DISABLE  The alternate signal stack is currently disabled.

       The  value  SIGSTKSZ  is  a system default specifying the number of bytes that would be used to cover the
       usual case when manually allocating an alternate stack area. The value MINSIGSTKSZ is defined to  be  the
       minimum  stack size for a signal handler. In computing an alternate stack size, a program should add that
       amount to its stack  requirements  to  allow  for  the  system  implementation  overhead.  The  constants
       SS_ONSTACK, SS_DISABLE, SIGSTKSZ, and MINSIGSTKSZ are defined in <u>&lt;signal.h&gt;</u>.

       After  a  successful  call  to one of the <u>exec</u> functions, there are no alternate signal stacks in the new
       process image.

       In some implementations, a signal (whether or not indicated to execute  on  the  alternate  stack)  shall
       always  execute  on the alternate stack if it is delivered while another signal is being caught using the
       alternate stack.

       Use of this function by library threads that are  not  bound  to  kernel-scheduled  entities  results  in
       undefined behavior.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon  successful completion, <u>sigaltstack</u>() shall return 0; otherwise, it shall return -1 and set <u>errno</u> to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>sigaltstack</u>() function shall fail if:

       <b>EINVAL</b> The <u>ss</u> argument is not a null pointer, and the <u>ss_flags</u> member pointed to  by  <u>ss</u>  contains  flags
              other than SS_DISABLE.

       <b>ENOMEM</b> The size of the alternate stack area is less than MINSIGSTKSZ.

       <b>EPERM</b>  An attempt was made to modify an active stack.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Allocating</b> <b>Memory</b> <b>for</b> <b>an</b> <b>Alternate</b> <b>Stack</b>
       The following example illustrates a method for allocating memory for an alternate stack.

           #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
           ...
           if ((sigstk.ss_sp = malloc(SIGSTKSZ)) == NULL)
               /* Error return. */
           sigstk.ss_size = SIGSTKSZ;
           sigstk.ss_flags = 0;
           if (sigaltstack(&amp;sigstk,(stack_t *)0) &lt; 0)
               perror("sigaltstack");

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       On  some  implementations,  stack  space  is  automatically extended as needed. On those implementations,
       automatic extension is typically not available for an  alternate  stack.  If  the  stack  overflows,  the
       behavior is undefined.

</pre><h4><b>RATIONALE</b></h4><pre>
       None.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u> <u>2.4</u>, <u>Signal</u> <u>Concepts</u>, <u>exec</u>, <u>sigaction</u>(), <u>sigsetjmp</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;signal.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                   <u><a href="../man3POSIX/SIGALTSTACK.3POSIX.html">SIGALTSTACK</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>