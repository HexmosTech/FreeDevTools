<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CURLOPT_NOSIGNAL - skip all signal handling</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CURLOPT_NOSIGNAL - skip all signal handling

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       CURLcode curl_easy_setopt(CURL *handle, CURLOPT_NOSIGNAL, long onoff);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       If <u>onoff</u> is 1, libcurl uses no functions that install signal handlers or any functions that cause signals
       to be sent to the process. This option is here to allow multi-threaded Unix applications to still set/use
       all timeout options etc, without risking getting signals.

       If  this  option is set and libcurl has been built with the standard name resolver, timeouts cannot occur
       while the name resolve takes place. Consider building  libcurl  with  the  c-ares  or  threaded  resolver
       backends  to  enable  asynchronous  DNS  lookups, to enable timeouts for name resolves without the use of
       signals.

       Setting <u><a href="../man3/CURLOPT_NOSIGNAL.3.html">CURLOPT_NOSIGNAL</a>(3)</u> to 1 makes libcurl NOT ask  the  system  to  ignore  SIGPIPE  signals,  which
       otherwise  are  sent by the system when trying to send data to a socket which is closed in the other end.
       libcurl makes an effort to never cause such SIGPIPE signals to trigger, but some operating  systems  have
       no  way to avoid them and even on those that have there are some corner cases when they may still happen,
       contrary to our desire.

</pre><h4><b>DEFAULT</b></h4><pre>
       0

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       int main(void)
       {
         CURL *curl = curl_easy_init();
         if(curl) {
           CURLcode res;
           curl_easy_setopt(curl, CURLOPT_URL, "https://example.com/");

           curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);

           res = curl_easy_perform(curl);

           curl_easy_cleanup(curl);
         }
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.10

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a>(3)</u> returns a CURLcode indicating success or error.

       CURLE_OK (0) means everything was OK, non-zero means an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/CURLOPT_TIMEOUT.3.html">CURLOPT_TIMEOUT</a></b>(3)

libcurl                                            2025-06-16                                <u><a href="../man3/CURLOPT_NOSIGNAL.3.html">CURLOPT_NOSIGNAL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>