<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       sigsuspend — wait for a signal

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;

       int sigsuspend(const sigset_t *<u>sigmask</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>sigsuspend</u>()  function  shall  replace the current signal mask of the calling thread with the set of
       signals pointed to by <u>sigmask</u> and then suspend the thread until delivery of  a  signal  whose  action  is
       either  to execute a signal-catching function or to terminate the process. This shall not cause any other
       signals that may have been pending on the process to become pending on the thread.

       If the action is to terminate the process then <u>sigsuspend</u>() shall never  return.  If  the  action  is  to
       execute  a  signal-catching  function,  then <u>sigsuspend</u>() shall return after the signal-catching function
       returns, with the signal mask restored to the set that existed prior to the <u>sigsuspend</u>() call.

       It is not possible to block signals that cannot be ignored.  This  is  enforced  by  the  system  without
       causing an error to be indicated.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Since  <u>sigsuspend</u>()  suspends  thread  execution  indefinitely,  there is no successful completion return
       value. If a return occurs, -1 shall be returned and <u>errno</u> set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>sigsuspend</u>() function shall fail if:

       <b>EINTR</b>  A signal is caught by the calling  process  and  control  is  returned  from  the  signal-catching
              function.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       Normally,  at  the  beginning of a critical code section, a specified set of signals is blocked using the
       <u>sigprocmask</u>() function. When the thread has completed the critical section and  needs  to  wait  for  the
       previously  blocked  signal(s),  it pauses by calling <u>sigsuspend</u>() with the mask that was returned by the
       <u>sigprocmask</u>() call.

</pre><h4><b>RATIONALE</b></h4><pre>
       Code which wants to avoid the ambiguity of the signal mask for thread cancellation handlers  can  install
       an additional cancellation handler which resets the signal mask to the expected value.

           void cleanup(void *arg)
           {
               sigset_t *ss = (sigset_t *) arg;
               pthread_sigmask(SIG_SETMASK, ss, NULL);
           }

           int call_sigsuspend(const sigset_t *mask)
           {
               sigset_t oldmask;
               int result;
               pthread_sigmask(SIG_SETMASK, NULL, &amp;oldmask);
               pthread_cleanup_push(cleanup, &amp;oldmask);
               result = sigsuspend(sigmask);
               <a href="../man0/pthread_cleanup_pop.0.html">pthread_cleanup_pop</a>(0);
               return result;
           }

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u> <u>2.4</u>, <u>Signal</u> <u>Concepts</u>, <u>pause</u>(), <u>sigaction</u>(), <u>sigaddset</u>(), <u>sigdelset</u>(), <u>sigemptyset</u>(), <u>sigfillset</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;signal.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                    <u><a href="../man3POSIX/SIGSUSPEND.3POSIX.html">SIGSUSPEND</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>