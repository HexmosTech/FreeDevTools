<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vmod_blob - Utilities for the VCL blob type, encoding and decoding</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/varnish">varnish_7.7.0-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       vmod_blob - Utilities for the VCL blob type, encoding and decoding

</pre><h4><b>SYNOPSIS</b></h4><pre>
          import blob [as name] [from "path"]

          BLOB decode(ENUM decoding, INT length, STRING encoded)

          STRING encode(ENUM encoding, ENUM case, BLOB blob)

          STRING transcode(ENUM decoding, ENUM encoding, ENUM case, INT length, STRING encoded)

          BOOL same(BLOB, BLOB)

          BOOL equal(BLOB, BLOB)

          INT length(BLOB)

          BLOB sub(BLOB, BYTES length, BYTES offset)

          new xblob = blob.blob(ENUM decoding, STRING encoded)

              BLOB xblob.get()

              STRING xblob.encode(ENUM encoding, ENUM case)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  VMOD  provides  utility  functions  and  an  object  for  the VCL data type <b>BLOB</b>, which may contain
       arbitrary data of any length.

       Examples:

          sub vcl_init {
              # Create blob objects from encodings such as base64 or hex.
              new myblob   = blob.blob(BASE64, "Zm9vYmFy");
              new yourblob = blob.blob(encoded="666F6F", decoding=HEX);
          }

          sub vcl_deliver {
              # The .get() method retrieves the BLOB from an object.
              set resp.http.MyBlob-As-Hex
                  = blob.encode(blob=myblob.get(), encoding=HEX);

              # The .encode() method efficiently retrieves an encoding.
              set resp.http.YourBlob-As-Base64 = yourblob.encode(BASE64);

              # decode() and encode() functions convert blobs to text and
              # vice versa at runtime.
              set resp.http.Base64-Encoded
                  = blob.encode(BASE64,
                                blob=blob.decode(HEX,
                                                 encoded=req.http.Hex-Encoded));
          }

          sub vcl_recv {
              # transcode() converts from one encoding to another.
              # case=UPPER specifies upper-case hex digits A-F.
              set req.http.Hex-Encoded
                  = blob.transcode(decoding=BASE64, encoding=HEX,
                                   case=UPPER, encoded="YmF6");

              # transcode() from URL to IDENTITY effects a URL decode.
              set req.url = blob.transcode(encoded=req.url, decoding=URL);

              # transcode() from IDENTITY to URL effects a URL encode.
              set req.http.url_urlcoded
                  = blob.transcode(encoded=req.url, encoding=URL);
          }

   <b>ENCODING</b> <b>SCHEMES</b>
       Binary-to-text encoding schemes are specified by ENUMs in the VMOD's constructor, methods and  functions.
       Decodings  convert  a  (possibly  concatenated) string into a blob, while encodings convert a blob into a
       string.

       ENUM values for an encoding scheme can be one of:

       • <b>IDENTITY</b>

       • <b>BASE64</b>

       • <b>BASE64URL</b>

       • <b>BASE64URLNOPAD</b>

       • <b>BASE64CF</b>

       • <b>HEX</b>

       • <b>URL</b>

       Empty strings are decoded into a "null blob" (of length 0), and conversely a null blob is encoded as  the
       empty string.

       For  encodings  with  <b>HEX</b> or <b>URL</b>, you may also specify a <u>case</u> ENUM with one of the values <b>LOWER</b>, <b>UPPER</b> or
       <b>DEFAULT</b> to produce a string with lower- or uppercase hex digits (in <b>[a-f]</b> or <b>[A-F]</b>).  The  default  value
       for <u>case</u> is <b>DEFAULT</b>, which for <b>HEX</b> and <b>URL</b> means the same as <b>LOWER</b>.

       The  <u>case</u>  ENUM  is  not  relevant  for decodings; <b>HEX</b> or <b>URL</b> strings to be decoded as BLOBs may have hex
       digits in either case, or in mixed case.

       The <u>case</u> ENUM MUST be set to <b>DEFAULT</b> for the other encodings (<b>BASE64*</b> and  <b>IDENTITY</b>).   You  cannot,  for
       example,  produce an uppercase string by using the <b>IDENTITY</b> scheme with <b>case=UPPER</b>. To change the case of
       a string, use the <b>std.toupper()</b> or <b>std.tolower()</b> functions from <u><a href="../man3/vmod_std.3.html">vmod_std</a>(3)</u>.

   <b>IDENTITY</b>
       The  simplest  encoding  converts  between  the  BLOB  and  STRING  data  types,  leaving  the   contents
       byte-identical.

       Note  that  a BLOB may contain a null byte at any position before its end; if such a BLOB is decoded with
       <b>IDENTITY</b>, the resulting STRING will have a null byte at that position. Since VCL strings, like C strings,
       are represented with a terminating null byte, the string will be truncated,  appearing  to  contain  less
       data than the original blob. For example:

          # Decode from the hex encoding for "foo\0bar".
          # The header will be seen as "foo".
          set resp.http.Trunced-Foo1
              = blob.encode(IDENTITY, blob=blob.decode(HEX,
                                                       encoded="666f6f00626172"));

       <b>IDENTITY</b> is the default encoding and decoding. So the above can also be written as:

          # Decode from the hex encoding for "foo\0bar".
          # The header will be seen as "foo".
          set resp.http.Trunced-Foo2
            = blob.encode(blob=blob.decode(HEX, encoded="666f6f00626172"));

       The <u>case</u> ENUM MUST be set to <b>DEFAULT</b> for <b>IDENTITY</b> encodings.

   <b>BASE64*</b>
       The  base64  encoding  schemes  use 4 characters to encode 3 bytes. There are no newlines or maximal line
       lengths -- whitespace is not permitted.

       The <b>BASE64</b> encoding uses the alphanumeric characters, <b>+</b> and <b>/</b>; and encoded strings are padded with the  <b>=</b>
       character so that their length is always a multiple of four.

       The  <b>BASE64URL</b> encoding also uses the alphanumeric characters, but <b>-</b> and <b>_</b> instead of <b>+</b> and <b>/</b>, so that an
       encoded string can be used safely in a URL. This scheme also uses the padding character <b>=</b>.

       The <b>BASE64URLNOPAD</b> encoding uses the same alphabet as <b>BASE6URL</b>, but leaves  out  the  padding.  Thus  the
       length of an encoding with this scheme is not necessarily a multiple of four.

       The  <b>BASE64CF`</b>  <b>is</b>  <b>similar</b>  <b>to</b>  <b>``BASE64URL</b>,  with the following changes to <b>BASE64</b>: <b>+</b> replaced with <b>-</b>, <b>/</b>
       replaced with <b>~</b> and <b>_</b> as the padding character. It is used by a certain CDN provider  who  also  inspired
       the name.

       The <u>case</u> ENUM MUST be set to <b>DEFAULT</b> for all of the <b>BASE64*</b> encodings.

   <b>HEX</b>
       The  <b>HEX</b>  encoding  scheme converts hex strings into blobs and vice versa. For encodings, you may use the
       <u>case</u> ENUM to specify upper- or lowercase hex digits <b>A</b> through <b>f</b> (default <b>DEFAULT</b>, which means the same as
       <b>LOWER</b>).  A prefix such as <b>0x</b> is not used for an encoding and is illegal for a decoding.

       If a hex string to be decoded has an odd number of digits, it is decoded as if a <b>0</b> is  prepended  to  it;
       that  is,  the first digit is interpreted as representing the least significant nibble of the first byte.
       For example:

          # The concatenated string is "abcdef0", and is decoded as "0abcdef0".
          set resp.http.First = "abc";
          set resp.http.Second = "def0";
          set resp.http.Hex-Decoded
              = blob.encode(HEX, blob=blob.decode(HEX,
                                 encoded=resp.http.First + resp.http.Second));

   <b>URL</b>
       The <b>URL</b> decoding replaces any <b>%&lt;2-hex-digits&gt;</b> substrings with the binary value of the hexadecimal  number
       after the <b>%</b> sign.

       The  <b>URL</b>  encoding implements "percent encoding" as per RFC3986. The <u>case</u> ENUM determines the case of the
       hex digits, but does not affect alphabetic characters that are not percent-encoded.

   <b>BLOB</b> <b>decode(ENUM</b> <b>decoding,</b> <b>INT</b> <b>length,</b> <b>STRING</b> <b>encoded)</b>
          BLOB decode(
             ENUM {IDENTITY, BASE64, BASE64URL, BASE64URLNOPAD, BASE64CF, HEX, URL} decoding=IDENTITY,
             INT length=0,
             STRING encoded
          )

       Returns the BLOB derived from the string <u>encoded</u> according to the scheme specified by <u>decoding</u>.

       If <u>length</u> &gt; 0, only decode the first <u>length</u> characters of the encoded string. If <u>length</u> &lt;= 0  or  greater
       than the length of the string, then decode the entire string. The default value of <u>length</u> is 0.

       <u>decoding</u> defaults to IDENTITY.

       Example:

          blob.decode(BASE64, encoded="Zm9vYmFyYmF6");

          # same with named parameters
          blob.decode(encoded="Zm9vYmFyYmF6", decoding=BASE64);

          # convert string to blob
          blob.decode(encoded="foo");

   <b>STRING</b> <b>encode(ENUM</b> <b>encoding,</b> <b>ENUM</b> <b>case,</b> <b>BLOB</b> <b>blob)</b>
          STRING encode(
             ENUM {IDENTITY, BASE64, BASE64URL, BASE64URLNOPAD, BASE64CF, HEX, URL} encoding=IDENTITY,
             ENUM {LOWER, UPPER, DEFAULT} case=DEFAULT,
             BLOB blob
          )

       Returns  a  string  representation of the BLOB <u>blob</u> as specified by <u>encoding</u>. <u>case</u> determines the case of
       hex digits for the <b>HEX</b> and <b>URL</b> encodings, and is ignored for the other encodings.

       <u>encoding</u> defaults to <b>IDENTITY</b>, and <u>case</u> defaults to <b>DEFAULT</b>.  <b>DEFAULT</b> is interpreted as <b>LOWER</b> for the <b>HEX</b>
       and <b>URL</b> encodings, and is the required value for the other encodings.

       Example:

          set resp.http.encode1
              = blob.encode(HEX,
                            blob=blob.decode(BASE64, encoded="Zm9vYmFyYmF6"));

          # same with named parameters
          set resp.http.encode2
              = blob.encode(blob=blob.decode(encoded="Zm9vYmFyYmF6",
                                                     decoding=BASE64),
                                encoding=HEX);

          # convert blob to string
          set resp.http.encode3
              = blob.encode(blob=blob.decode(encoded="foo"));

   <b>STRING</b> <b>transcode(ENUM</b> <b>decoding,</b> <b>ENUM</b> <b>encoding,</b> <b>ENUM</b> <b>case,</b> <b>INT</b> <b>length,</b> <b>STRING</b> <b>encoded)</b>
          STRING transcode(
             ENUM {IDENTITY, BASE64, BASE64URL, BASE64URLNOPAD, BASE64CF, HEX, URL} decoding=IDENTITY,
             ENUM {IDENTITY, BASE64, BASE64URL, BASE64URLNOPAD, BASE64CF, HEX, URL} encoding=IDENTITY,
             ENUM {LOWER, UPPER, DEFAULT} case=DEFAULT,
             INT length=0,
             STRING encoded
          )

       Translates from one encoding to another, by first decoding the string <u>encoded</u>  according  to  the  scheme
       <u>decoding</u>,  and  then  returning the encoding of the resulting blob according to the scheme <u>encoding</u>. <u>case</u>
       determines the case of hex digits for the <b>HEX</b> and <b>URL</b> encodings, and is ignored for other encodings.

       As with blob.decode(): If <u>length</u> &gt; 0, only decode the first <u>length</u>  characters  of  the  encoded  string,
       otherwise decode the entire string. The default value of <u>length</u> is 0.

       <u>decoding</u>  and <u>encoding</u> default to IDENTITY, and <u>case</u> defaults to <b>DEFAULT</b>. <b>DEFAULT</b> is interpreted as <b>LOWER</b>
       for the <b>HEX</b> and <b>URL</b> encodings, and is the required value for the other encodings.

       Example:

          set resp.http.Hex2Base64-1
               = blob.transcode(HEX, BASE64, encoded="666f6f");

           # same with named parameters
           set resp.http.Hex2Base64-2
              = blob.transcode(encoded="666f6f",
                                    encoding=BASE64, decoding=HEX);

           # URL decode -- recall that IDENTITY is the default encoding.
           set resp.http.urldecoded
              = blob.transcode(encoded="foo%20bar", decoding=URL);

           # URL encode
           set resp.http.urlencoded
               = blob.transcode(encoded="foo bar", encoding=URL);

   <b>BOOL</b> <b>same(BLOB,</b> <b>BLOB)</b>
       Returns <b>true</b> if and only if the two BLOB arguments are the same object, i.e.  they  specify  exactly  the
       same region of memory, or both are empty.

       If  the  BLOBs are both empty (length is 0 and/or the internal pointer is <b>NULL</b>), then blob.same() returns
       <b>true</b>. If any non-empty BLOB is compared to an empty BLOB, then blob.same() returns <b>false</b>.

   <b>BOOL</b> <b>equal(BLOB,</b> <b>BLOB)</b>
       Returns true if and only if the two BLOB arguments have equal  contents  (possibly  in  different  memory
       regions).

       As  with  blob.same(): If the BLOBs are both empty, then blob.equal() returns <b>true</b>. If any non-empty BLOB
       is compared to an empty BLOB, then blob.equal() returns <b>false</b>.

   <b>INT</b> <b>length(BLOB)</b>
       Returns the length of the BLOB.

   <b>BLOB</b> <b>sub(BLOB,</b> <b>BYTES</b> <b>length,</b> <b>BYTES</b> <b>offset=0)</b>
       Returns a new BLOB formed from <u>length</u> bytes of the BLOB argument starting at <u>offset</u> bytes from the  start
       of its memory region. The default value of <u>offset</u> is <b>0B</b>.

       blob.sub()  fails  and  returns  NULL  if the BLOB argument is empty, or if <b>offset</b> <b>+</b> <b>length</b> requires more
       bytes than are available in the BLOB.

   <b>new</b> <b>xblob</b> <b>=</b> <b>blob.blob(ENUM</b> <b>decoding,</b> <b>STRING</b> <b>encoded)</b>
          new xblob = blob.blob(
             ENUM {IDENTITY, BASE64, BASE64URL, BASE64URLNOPAD, BASE64CF, HEX, URL} decoding=IDENTITY,
             STRING encoded
          )

       Creates an object that contains the BLOB  derived  from  the  string  <u>encoded</u>  according  to  the  scheme
       <u>decoding</u>.

       Example:

          new theblob1 = blob.blob(BASE64, encoded="YmxvYg==");

          # same with named arguments
          new theblob2 = blob.blob(encoded="YmxvYg==", decoding=BASE64);

          # string as a blob
          new stringblob = blob.blob(encoded="bazz");

   <b>BLOB</b> <b>xblob.get()</b>
       Returns the BLOB created by the constructor.

       Example:

          set resp.http.The-Blob1 =
              blob.encode(blob=theblob1.get());

          set resp.http.The-Blob2 =
              blob.encode(blob=theblob2.get());

          set resp.http.The-Stringblob =
              blob.encode(blob=stringblob.get());

   <b>STRING</b> <b>xblob.encode(ENUM</b> <b>encoding,</b> <b>ENUM</b> <b>case)</b>
          STRING xblob.encode(
                ENUM {IDENTITY, BASE64, BASE64URL, BASE64URLNOPAD, BASE64CF, HEX, URL} encoding=IDENTITY,
                ENUM {LOWER, UPPER, DEFAULT} case=DEFAULT
          )

       Returns an encoding of BLOB created by the constructor, according to the scheme <u>encoding</u>. <u>case</u> determines
       the case of hex digits for the <b>HEX</b> and <b>URL</b> encodings, and MUST be set to <b>DEFAULT</b> for the other encodings.

       Example:

          # blob as text
          set resp.http.The-Blob = theblob1.encode();

          # blob as base64
          set resp.http.The-Blob-b64 = theblob1.encode(BASE64);

       For  any  blob.blob()  object,  <u>encoding</u>  and  <u>case</u>,  encodings  via  the  xblob.encode()  method and the
       blob.encode() function are equal:

          # Always true:
          blob.encode(ENC, CASE, blob.get()) == blob.encode(ENC, CASE)

       But the xblob.encode() object method is more efficient -- the encoding is computed once and cached  (with
       allocation  in  heap  memory),  and  the  cached  encoding  is  retrieved  on  every subsequent call. The
       blob.encode() function computes the encoding on every call, allocating space for the  string  in  Varnish
       workspaces.

       So  if  the data in a BLOB are fixed at VCL initialization time, so that its encodings will always be the
       same, it is better to create a blob.blob() object. The VMOD's functions should be used for data that  are
       not known until runtime.

</pre><h4><b>ERRORS</b></h4><pre>
       The  encoders,  decoders and blob.sub() may fail if there is insufficient space to create the new blob or
       string. Decoders may also fail if the encoded string is  an  illegal  format  for  the  decoding  scheme.
       Encoders will fail for the <b>IDENTITY</b> and <b>BASE64*</b> encoding schemes if the <u>case</u> ENUM is not set to <b>DEFAULT</b>.

       If  any  of  the  VMOD's  methods, functions or constructor fail, then VCL failure is invoked, just as if
       <b>return(fail)</b> had been called in the VCL source. This means that:

       • If the blob.blob() object constructor fails, or if any methods or  functions  fail  during  <b>vcl_init{}</b>,
         then the VCL program will fail to load, and the VCC compiler will emit an error message.

       • If a method or function fails in any other VCL subroutine besides <b>vcl_synth{}</b>, then control is directed
         to  <b>vcl_synth{}</b>.  The  response  status is set to 503 with the reason string <b>"VCL</b> <b>failed"</b>, and an error
         message will be written to the <u><a href="../man7/vsl.7.html">vsl</a>(7)</u> using the tag <b>VCL_Error</b>.

       • If the failure occurs during <b>vcl_synth{}</b>, then <b>vcl_synth{}</b> is  aborted.  The  response  line  <b>"503</b>  <b>VCL</b>
         <b>failed"</b> is returned, and the <b>VCL_Error</b> message is written to the log.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       The  VMOD  allocates  memory  in  various  ways for new blobs and strings. The blob.blob() object and its
       methods allocate memory from the heap, and hence they are only limited by available virtual memory.

       The blob.encode(), blob.decode() and blob.transcode()  functions  allocate  Varnish  workspace,  as  does
       blob.sub()  for  the  newly created BLOB.  If these functions are failing, as indicated by "out of space"
       messages in the Varnish log (with the <b>VCL_Error</b> tag),  then  you  will  need  to  increase  the  varnishd
       parameters <b>workspace_client</b> and/or <b>workspace_backend</b>.

       The  blob.transcode()  function  also allocates space on the stack for a temporary BLOB. If this function
       causes stack overflow, you may need to increase the varnishd parameter <b>thread_pool_stack</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       • <u><a href="../man1/varnishd.1.html">varnishd</a>(1)</u>

       • <u><a href="../man7/vcl.7.html">vcl</a>(7)</u>

       • <u><a href="../man7/vsl.7.html">vsl</a>(7)</u>

       • <u><a href="../man3/vmod_std.3.html">vmod_std</a>(3)</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
          This document is licensed under the same conditions as Varnish itself.
          See LICENSE for details.

          SPDX-License-Identifier: BSD-2-Clause

          Authors: Nils Goroll &lt;<a href="mailto:nils.goroll@uplex.de">nils.goroll@uplex.de</a>&gt;
                   Geoffrey Simmons &lt;<a href="mailto:geoffrey.simmons@uplex.de">geoffrey.simmons@uplex.de</a>&gt;

                                                                                                    <u><a href="../man3/VMOD_BLOB.3.html">VMOD_BLOB</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>