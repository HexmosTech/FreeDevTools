<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_ClassGetMetadata,       Tcl_ClassSetMetadata,      Tcl_CopyObjectInstance,      Tcl_GetClassAsObject,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_ClassGetMetadata,       Tcl_ClassSetMetadata,      Tcl_CopyObjectInstance,      Tcl_GetClassAsObject,
       Tcl_GetObjectAsClass,        Tcl_GetObjectCommand,        Tcl_GetObjectFromObj,        Tcl_GetObjectName,
       Tcl_GetObjectNamespace,       Tcl_NewObjectInstance,       Tcl_ObjectDeleted,      Tcl_ObjectGetMetadata,
       Tcl_ObjectGetMethodNameMapper, Tcl_ObjectSetMetadata, Tcl_ObjectSetMethodNameMapper - manipulate  objects
       and classes

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tclOO.h&gt;</b>

       Tcl_Object
       <b>Tcl_GetObjectFromObj</b>(<u>interp,</u> <u>objPtr</u>)

       Tcl_Object
       <b>Tcl_GetClassAsObject</b>(<u>class</u>)

       Tcl_Class
       <b>Tcl_GetObjectAsClass</b>(<u>object</u>)

       Tcl_Obj *
       <b>Tcl_GetObjectName</b>(<u>interp,</u> <u>object</u>)

       Tcl_Command
       <b>Tcl_GetObjectCommand</b>(<u>object</u>)

       Tcl_Namespace *
       <b>Tcl_GetObjectNamespace</b>(<u>object</u>)

       Tcl_Object
       <b>Tcl_NewObjectInstance</b>(<u>interp,</u> <u>class,</u> <u>name,</u> <u>nsName,</u> <u>objc,</u> <u>objv,</u> <u>skip</u>)

       Tcl_Object
       <b>Tcl_CopyObjectInstance</b>(<u>interp,</u> <u>object,</u> <u>name,</u> <u>nsName</u>)

       int
       <b>Tcl_ObjectDeleted</b>(<u>object</u>)

       void *
       <b>Tcl_ObjectGetMetadata</b>(<u>object,</u> <u>metaTypePtr</u>)

       <b>Tcl_ObjectSetMetadata</b>(<u>object,</u> <u>metaTypePtr,</u> <u>metadata</u>)

       void *
       <b>Tcl_ClassGetMetadata</b>(<u>class,</u> <u>metaTypePtr</u>)

       <b>Tcl_ClassSetMetadata</b>(<u>class,</u> <u>metaTypePtr,</u> <u>metadata</u>)

       Tcl_ObjectMapMethodNameProc
       <b>Tcl_ObjectGetMethodNameMapper</b>(<u>object</u>)

       <b>Tcl_ObjectSetMethodNameMapper</b>(<u>object</u>, <u>methodNameMapper</u>)

       Tcl_Class                                                                                                 2
       <b>Tcl_GetClassOfObject</b>(<u>object</u>)                                                                              2

       Tcl_Obj *                                                                                                 2
       <b>Tcl_GetObjectClassName</b>(<u>interp</u>, <u>object</u>)                                                                    2

</pre><h4><b>ARGUMENTS</b></h4><pre>
       Tcl_Interp <u>*interp</u> (in/out)  Interpreter  providing the context for looking up or creating an object, and
                                    into whose result error messages will be written on failure.

       Tcl_Obj <u>*objPtr</u> (in)         The name of the object to look up.

       Tcl_Object <u>object</u> (in)       Reference to the object to operate upon.

       Tcl_Class <u>class</u> (in)         Reference to the class to operate upon.

       const char <u>*name</u> (in)        The name of the object to create, or NULL if a new  unused  name  is  to  be
                                    automatically selected.

       const char <u>*nsName</u> (in)      The name of the namespace to create for the object's private use, or NULL if
                                    a  new  unused  name is to be automatically selected. The namespace must not
                                    already exist.

       Tcl_Size <u>objc</u> (in)           The number of elements in the <u>objv</u> array.

       Tcl_Obj *const <u>*objv</u> (in)    The arguments to the command to create the instance of the class.

       Tcl_Size <u>skip</u> (in)           The number of arguments at the start of the argument array, <u>objv</u>,  that  are
                                    not  arguments  to  any  constructors. This allows the generation of correct
                                    error messages even when complicated calling patterns are  used  (e.g.,  via
                                    the <b>next</b> command).

       Tcl_ObjectMetadataType <u>*metaTypePtr</u> (in)
                                    The  type  of <u>metadata</u> being set with <b>Tcl_ClassSetMetadata</b> or retrieved with
                                    <b>Tcl_ClassGetMetadata</b>.

       void <u>*metadata</u> (in)          An item of metadata to attach to the class, or NULL to remove  the  metadata
                                    associated with a particular <u>metaTypePtr</u>.

       Tcl_ObjectMapMethodNameProc <u>methodNameMapper</u> (in)
                                    A  pointer to a function to call to adjust the mapping of objects and method
                                    names to implementations, or NULL when no such mapping is required.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Objects are typed entities that have a set of operations ("methods") associated with  them.  Classes  are
       objects  that  can manufacture objects. Each class can be viewed as an object itself; the object view can
       be retrieved using <b>Tcl_GetClassAsObject</b> which always returns the object when applied to  a  non-destroyed
       class,  and  an  object  can  be viewed as a class with the aid of the <b>Tcl_GetObjectAsClass</b> (which either
       returns the class, or NULL if the object is  not  a  class).  An  object  may  be  looked  up  using  the
       <b>Tcl_GetObjectFromObj</b>  function,  which  either  returns  an  object or NULL (with an error message in the
       interpreter result) if the object cannot be found. The correct way to look up a class by name is to  look
       up the object with that name, and then to use <b>Tcl_GetObjectAsClass</b>.

       Every object has its own command and namespace associated with it. The command may be retrieved using the
       <b>Tcl_GetObjectCommand</b>  function,  the  name  of  the  object  (and  hence  the  name  of the command) with
       <b>Tcl_GetObjectName</b>, and the namespace may be retrieved using  the  <b>Tcl_GetObjectNamespace</b>  function.  Note
       that  the Tcl_Obj reference returned by <b>Tcl_GetObjectName</b> is a shared reference. You can also get whether
       the object has been marked for deletion with <b>Tcl_ObjectDeleted</b> (it returns true if deletion of the object
       has begun); this can be useful during the processing of methods.  The class of an object can be retrieved 2
       with <b>Tcl_GetClassOfObject</b>, and the name of the class of an object with <b>Tcl_GetObjectClassName</b>; note  that 2
       these  two  <u>may</u>  return  NULL  during  deletion of an object (this is transient, and only occurs when the 2
       object is a long way through being deleted).

       Instances of classes are created using <b>Tcl_NewObjectInstance</b>, which creates an object from any class (and
       which is internally called by both the  <b>create</b>  and  <b>new</b>  methods  of  the  <b>oo::class</b>  class).  It  takes
       parameters  that  optionally  give the name of the object and namespace to create, and which describe the
       arguments to pass to the class's constructor (if any). The result  of  the  function  will  be  either  a
       reference to the newly created object, or NULL if the creation failed (when an error message will be left
       in  the  interpreter  result).  In  addition, objects may be copied by using <b>Tcl_CopyObjectInstance</b> which
       creates a copy of an object without running any constructors.

       Note that the lifetime management of objects is  handled  internally  within  TclOO,  and  does  not  use
       <b>Tcl_Preserve</b>. <u>It</u> <u>is</u> <u>not</u> <u>safe</u> <u>to</u> <u>put</u> <u>a</u> <u>Tcl_Object</u> <u>handle</u> <u>in</u> <u>a</u> <u>C</u> <u>structure</u> <u>with</u> <u>a</u> <u>lifespan</u> <u>different</u> <u>to</u> <u>the</u>
       <u>object;</u>  you  should  use  the object's command name (as retrieved with <b>Tcl_GetObjectName</b>) instead. It is
       safe to use a Tcl_Object handle for the lifespan of a call of a method on that  object;  handles  do  not
       become  invalid while there is an outstanding call on their object (even if the only operation guaranteed
       to be safe on them is <b>Tcl_ObjectDeleted</b>; the other operations are only guaranteed to work on  non-deleted
       objects).

</pre><h4><b>OBJECT</b> <b>AND</b> <b>CLASS</b> <b>METADATA</b></h4><pre>
       Every  object  and every class may have arbitrary amounts of metadata attached to it, which the object or
       class attaches no meaning to beyond what is described in  a  Tcl_ObjectMetadataType  structure  instance.
       Metadata  to be attached is described by the type of the metadata (given in the <u>metaTypePtr</u> argument) and
       an  arbitrary  pointer  (the  <u>metadata</u>  argument)   that   are   given   to   <b>Tcl_ObjectSetMetadata</b>   and
       <b>Tcl_ClassSetMetadata</b>,  and  a  particular  piece  of  metadata  can  be  retrieved  given  its type using
       <b>Tcl_ObjectGetMetadata</b> and <b>Tcl_ClassGetMetadata</b>. If the <u>metadata</u> parameter to either <b>Tcl_ObjectSetMetadata</b>
       or <b>Tcl_ClassSetMetadata</b> is NULL, the metadata  is  removed  if  it  was  attached,  and  the  results  of
       <b>Tcl_ObjectGetMetadata</b>  and  <b>Tcl_ClassGetMetadata</b> are NULL if the given type of metadata was not attached.
       It is not an error to request or remove a piece of metadata that was not attached.

   <b>TCL_OBJECTMETADATATYPE</b> <b>STRUCTURE</b>
       The contents of the Tcl_ObjectMetadataType structure are as follows:

              typedef const struct {
                  int <u>version</u>;
                  const char *<u>name</u>;
                  Tcl_ObjectMetadataDeleteProc *<u>deleteProc</u>;
                  Tcl_CloneProc *<u>cloneProc</u>;
              } <b>Tcl_ObjectMetadataType</b>;

       The <u>version</u> field allows for future expansion of the structure, and should always be  declared  equal  to
       TCL_OO_METADATA_VERSION_CURRENT.  The  <u>name</u>  field  provides  a  human-readable name for the type, and is
       reserved for debugging.

       The <u>deleteProc</u> field gives a function of type Tcl_ObjectMetadataDeleteProc  that  is  used  to  delete  a
       particular  piece of metadata, and is called when the attached metadata is replaced or removed; the field
       must not be NULL.

       The <u>cloneProc</u> field gives a function that is used to copy a piece of metadata (used when  a  copy  of  an
       object is created using <b>Tcl_CopyObjectInstance</b>); if NULL, the metadata will be just directly copied.

   <b>TCL_OBJECTMETADATADELETEPROC</b> <b>FUNCTION</b> <b>SIGNATURE</b>
       Functions matching this signature are used to delete metadata associated with a class or object.

              typedef void <b>Tcl_ObjectMetadataDeleteProc</b>(
                      void *<u>metadata</u>);

       The <u>metadata</u> argument gives the address of the metadata to be deleted.

   <b>TCL_CLONEPROC</b> <b>FUNCTION</b> <b>SIGNATURE</b>
       Functions  matching  this  signature  are  used  to  create copies of metadata associated with a class or
       object.

              typedef int <b>Tcl_CloneProc</b>(
                      Tcl_Interp *<u>interp</u>,
                      void *<u>srcMetadata</u>,
                      void **<u>dstMetadataPtr</u>);

       The <u>interp</u> argument gives a place to write an error message when the attempt to clone the  object  is  to
       fail,  in  which  case the clone procedure must also return TCL_ERROR; it should return TCL_OK otherwise.
       The <u>srcMetadata</u> argument gives the address of the metadata to be cloned, and the cloned  metadata  should
       be written into the variable pointed to by <u>dstMetadataPtr</u>; a NULL should be written if the metadata is to
       not be cloned but the overall object copy operation is still to succeed.

</pre><h4><b>OBJECT</b> <b>METHOD</b> <b>NAME</b> <b>MAPPING</b></h4><pre>
       It  is  possible  to control, on a per-object basis, what methods are invoked when a particular method is
       invoked. Normally this is done by looking up the method  name  in  the  object  and  then  in  the  class
       hierarchy, but fine control of exactly what the value used to perform the look up is afforded through the
       ability  to  set  a  method name mapper callback via <b>Tcl_ObjectSetMethodNameMapper</b> (and its introspection
       counterpart, <b>Tcl_ObjectGetMethodNameMapper</b>, which returns the current mapper).  The  current  mapper  (if
       any) is invoked immediately before looking up what chain of method implementations is to be used.

   <b>TCL_OBJECTMAPMETHODNAMEPROC</b> <b>FUNCTION</b> <b>SIGNATURE</b>
       The <u>Tcl_ObjectMapMethodNameProc</u> callback is defined as follows:

              typedef int <b>Tcl_ObjectMapMethodNameProc</b>(
                      Tcl_Interp *<u>interp</u>,
                      Tcl_Object <u>object</u>,
                      Tcl_Class *<u>startClsPtr</u>,
                      Tcl_Obj *<u>methodNameObj</u>);

       If the result is TCL_OK, the remapping is assumed to have been done. If the result is TCL_ERROR, an error
       message  will  have  been  left  in <u>interp</u> and the method call will fail. If the result is TCL_BREAK, the
       standard method name lookup rules will  be  used;  the  behavior  of  other  result  codes  is  currently
       undefined. The <u>object</u> parameter says which object is being processed. The <u>startClsPtr</u> parameter points to
       a  variable that contains the first class to provide a definition in the method chain to process, or NULL
       if the whole chain is to be processed (the argument itself is never NULL); this variable may  be  updated
       by  the  callback. The <u>methodNameObj</u> parameter gives an unshared object containing the name of the method
       being invoked, as provided by the user; this object may be updated by the callback.

</pre><h4><b>REFERENCE</b> <b>COUNT</b> <b>MANAGEMENT</b></h4><pre>
       The <u>objPtr</u> argument to <b>Tcl_GetObjectFromObj</b> will not have  its  reference  count  manipulated,  but  this
       function may modify the interpreter result (to report any error) so interpreter results should not be fed
       into this without an additional reference being used.

       The  result  of  <b>Tcl_GetObjectName</b>  is  a value that is owned by the object that is regenerated when this
       function is first called after the object is renamed.  If the value is to be retained at all, the  caller
       should increment the reference count.

       The  first  <u>objc</u>  values  in  the <u>objv</u> argument to <b>Tcl_NewObjectInstance</b> are the arguments to pass to the
       constructor. They must have a reference count of at least 1, and may have their reference counts  changed
       during the running of the constructor. Constructors may modify the interpreter result, which consequently
       means  that  interpreter  results  should  not be used as arguments without an additional reference being
       taken.

       The <u>methodNameObj</u> argument to a  Tcl_ObjectMapMethodNameProc  implementation  will  be  a  value  with  a
       reference  count  of at least 1 where at least one reference is not held by the interpreter result. It is
       expected that method name mappers will only read their <u>methodNameObj</u> arguments.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/Method.3tcl.html">Method</a>(3tcl), oo::<a href="../man3tcl/class.3tcl.html">class</a>(3tcl), oo::<a href="../man3tcl/copy.3tcl.html">copy</a>(3tcl), oo::<a href="../man3tcl/define.3tcl.html">define</a>(3tcl), oo::<a href="../man3tcl/object.3tcl.html">object</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       class, constructor, object

TclOO                                                  0.1                                       <u><a href="../man3tcl/Tcl_Class.3tcl.html">Tcl_Class</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>