<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ConnectManip,  DragManip, ManipGroup, TextManip, VertexManip - Manipulator subclasses for defining common</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ivtools-dev">ivtools-dev_2.0.11d.a1-3build7_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ConnectManip,  DragManip, ManipGroup, TextManip, VertexManip - Manipulator subclasses for defining common
       direct-manipulation semantics

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;Unidraw/manips.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Manipulator is an abstract base class for objects that encapsulate the mechanics of direct  manipulation.
       Subclasses support different manipulation semantics.  The DragManip subclass implements a downclick-drag-
       upclick  style  of  interaction, with optional constraints on motion (for example, horizontal or vertical
       only).  ConnectManip is a DragManip subclass that adds a  gravitational  bias  towards  connector  views.
       VertexManip  is  a  DragManip  that  supports  multiple  downclick-and-drag  interactions terminated by a
       distinguished downclick.  TextManip provides a text  editing  interface.   Finally,  ManipGroup  composes
       manipulator instances so that their interaction may proceed concurrently.

</pre><h4><b>DRAGMANIP</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>DragManip(</b>
           <b>Viewer*,</b> <b>Rubberband*,</b> <b>Transformer*</b> <b>=</b> <b>nil,</b> <b>Tool*</b> <b>=</b> <b>nil,</b>
           <b>DragConstraint</b> <b>=</b> <b>None</b>
       <b>)</b>

       <b>DragManip(</b>
           <b>Viewer*,</b> <b>Rubberband*,</b> <b>Transformer*,</b> <b>Tool*,</b>
           <b>DragConstraint,</b> <b>Coord,</b> <b>Coord</b>
       <b>)</b>
              A  DragManip  uses a rubberband to animate the manipulation.  The constructor takes the rubberband
              as a parameter along with the viewer in which it  should  appear,  a  transformer  reflecting  the
              transformation  that component views undergo in the viewer, the tool that created the manipulator,
              and a DragConstraint that effectively restricts mouse motion in one or  more  ways.   By  default,
              motion  is  constrained  when  the  Shift key is held down.  The second constructor adds two Coord
              parameters.  The DragManip will use these values to override the event coordinates when  Grasp  is
              first called.

       <b>virtual</b> <b>void</b> <b>Grasp(Event&amp;)</b>
              DragManip  redefines  Grasp  operation  to  call  the  rubberband's Track operation, supplying the
              coordinates in the event.  Grasp calls Constrain (described below) on the event prior  to  passing
              the coordinate information.  The rubberband will not be drawn until Grasp is called.

       <b>virtual</b> <b>boolean</b> <b>Manipulating(Event&amp;)</b>
              If  the  event is a MotionEvent, Manipulating calls Track with the event's coordinates and returns
              <u>true</u>.  Manipulating simply returns <u>false</u> if the event is an UpEvent.  Like DragManip::Grasp,  this
              operation calls Constrain on the event prior to passing the coordinate information.

       <b>virtual</b> <b>void</b> <b>Effect(Event&amp;)</b>
              Effect simply erases the rubberband by calling its Erase operation.

       <b>virtual</b> <b>void</b> <b>SetViewer(Viewer*)</b>
       <b>virtual</b> <b>void</b> <b>SetRubberband(Rubberband*)</b>
       <b>virtual</b> <b>void</b> <b>SetTransformer(Transformer*)</b>
       <b>virtual</b> <b>void</b> <b>SetTool(Tool*)</b>
       <b>virtual</b> <b>void</b> <b>SetConstraint(DragConstraint)</b>

       <b>virtual</b> <b>Viewer*</b> <b>GetViewer()</b>
       <b>virtual</b> <b>Rubberband*</b> <b>GetRubberband()</b>
       <b>virtual</b> <b>Transformer*</b> <b>GetTransformer()</b>
       <b>virtual</b> <b>Tool*</b> <b>GetTool()</b>
       <b>virtual</b> <b>DragConstraint</b> <b>GetConstraint()</b>
              Set and get the various parameters supplied to the DragManip in its constructor.

       <b>const</b> <b>Event&amp;</b> <b>GraspEvent()</b>
              Return the event supplied to the last call to Grasp.

</pre><h4><b>DRAGMANIP</b> <b>PROTECTED</b> <b>OPERATIONS</b></h4><pre>
       <b>void</b> <b>Init(</b>
           <b>Viewer*,</b> <b>Rubberband*,</b> <b>Transformer*,</b> <b>Tool*,</b> <b>DragConstraint</b>
       <b>)</b>
              Assign the various constructor values common to both DragManip constructors.

       <b>virtual</b> <b>void</b> <b>Constrain(Event&amp;)</b>
              Constrain the event to reflect the DragConstraint.  The event coordinates are constrained when the
              event  indicates  that  the  shift  key is held down for all DragConstraint values except Gravity,
              which constrains the coordinates unconditionally with the viewer's Constrain operation.

</pre><h4><b>CONNECTMANIP</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>ConnectManip(</b>
           <b>Viewer*,</b> <b>Rubberband*,</b> <b>Transformer*</b> <b>=</b> <b>nil,</b> <b>Tool*</b> <b>=</b> <b>nil</b>
       <b>)</b>
              ConnectManip supports the same type of interaction as DragManip, except the rubberband tracking is
              affected by a graviational bias towards connector views.  Whenever the user drags near a connector
              view, the tracking coordinates are suddenly  constrained  to  coincide  with  the  center  of  the
              connector  view.   The  rubberband  will not change its appearance thereafter until the user drags
              beyond the gravity threshold, which corresponds to SLOP (see <a href="../man3U/globals.3U.html">globals</a>(3U)) units beyond the nearest
              point on the connector view.

       <b>virtual</b> <b>boolean</b> <b>Manipulating(Event&amp;)</b>
              ConnectManip redefines Manipulating to support the gravitational effect.

       <b>ConnectorView*</b> <b>GetTarget()</b>
              Return the connector view that has captured the rubberband, if any.

</pre><h4><b>VERTEXMANIP</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>VertexManip(</b>
           <b>Viewer*,</b> <b>GrowingVertices*,</b> <b>Transformer*</b> <b>=</b> <b>nil,</b>
           <b>Tool*</b> <b>=</b> <b>nil,</b> <b>DragConstraint</b> <b>=</b> <b>None</b>
       <b>)</b>
              VertexManip is like DragManip but supports multiple drags and clicks  in  one  manipulation.   The
              VertexManip constructor restricts the rubberband to be an instance of GrowingVertices.

       <b>virtual</b> <b>boolean</b> <b>Manipulating(Event&amp;)</b>
              This  operation  is  similar  to  DragManip's, except it calls AppendVertex on the GrowingVertices
              rubberband on each down-click and returns <u>false</u> if and only if the middle button is pressed.

       <b>GrowingVertices*</b> <b>GetGrowingVertices()</b>
              Return the GrowingVertices instance.  Use this operation as an alternative to  GetRubberband  when
              that operation isn't specific enough.

</pre><h4><b>TEXTMANIP</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>TextManip(Viewer*,</b> <b>Painter*,</b> <b>Coord</b> <b>tabwidth,</b> <b>Tool*</b> <b>=</b> <b>nil)</b>
       <b>TextManip(</b>
           <b>Viewer*,</b> <b>Painter*,</b> <b>Coord</b> <b>lineheight,</b> <b>Coord</b> <b>tabwidth,</b>
           <b>Tool*</b> <b>=</b> <b>nil</b>
       <b>)</b>
              Create  a  TextManip,  supplying  (at  minimum)  a  viewer,  a painter with which to draw (usually
              reflecting graphics attributes defined by the enclosing editor object), and the  width  of  a  tab
              character.   Tab  characters  in  the  text  will  position the following character at an integral
              multiple of <u>tabwidth</u> from the beginning of the line.  The distance between baselines in  the  text
              can  be  specified  with  the  second  constructor;  this  value corresponds to the font height by
              default.  These constructors create text manipulators containing no text initially; the lower left
              corner of the first line of text (including the descender) will be positioned at  the  coordinates
              in the event passed to the Grasp operation.

       <b>TextManip(</b>
           <b>Viewer*,</b> <b>const</b> <b>char*</b> <b>buf,</b> <b>int</b> <b>bufsize,</b> <b>Coord</b> <b>x,</b> <b>Coord</b> <b>y,</b>
           <b>Painter*,</b> <b>Coord</b> <b>tabwidth,</b> <b>Tool*</b> <b>=</b> <b>nil</b>
       <b>)</b>

       <b>TextManip(</b>
           <b>Viewer*,</b> <b>const</b> <b>char*</b> <b>buf,</b> <b>int</b> <b>bufsize,</b> <b>Coord</b> <b>x,</b> <b>Coord</b> <b>y,</b>
           <b>Painter*,</b> <b>Coord</b> <b>lineheight,</b> <b>Coord</b> <b>tabwidth,</b> <b>Tool*</b> <b>=</b> <b>nil</b>
       <b>)</b>
              Create  text  manipulators initialized with text by passing a buffer of text and its size.  A copy
              of the buffer is used internally.  The <u>x</u> and <u>y</u> parameters specify the position of the  lower  left
              corner  of  the first line of text (including the descender).  These coordinates will override the
              coordinates specified by the event passed to Grasp.

       <b>virtual</b> <b>void</b> <b>Grasp(Event&amp;)</b>
              Positions and draws the text.  If the position-specifing constructors  were  used  to  create  the
              instance,  then  the  manipulator  will  use  the  event  coordinates to set the insertion point's
              position in the text.

       <b>virtual</b> <b>boolean</b> <b>Manipulating(Event&amp;)</b>
              Handle keystrokes and/or mouse motion events to support basic text  editing.   Motion  events  are
              interpreted  to  support  text  selection;  selected  text  is  displayed  in reverse colors.  The
              Manipulating operation returns <u>false</u> if a downclick is detected outside the text or  if  HandleKey
              (described below) returns <u>false</u>.

       <b>virtual</b> <b>void</b> <b>Effect(Event&amp;)</b>
              Effect damages the viewer area that TextManip corrupted during editing.

       <b>virtual</b> <b>Painter*</b> <b>GetPainter()</b>
       <b>virtual</b> <b>Coord</b> <b>GetLineHeight()</b>
       <b>virtual</b> <b>Coord</b> <b>GetTabWidth()</b>
       <b>virtual</b> <b>const</b> <b>char*</b> <b>GetText(int&amp;)</b>
       <b>virtual</b> <b>void</b> <b>GetPosition(Coord&amp;,</b> <b>Coord&amp;)</b>
              Return various parameters specified in the constructor.  GetText returns a pointer to the internal
              buffer containing the text; the reference parameter returns the buffer's size.

       <b>const</b> <b>Event&amp;</b> <b>GraspEvent()</b>
              Return the event supplied to the last call to Grasp.

</pre><h4><b>TEXTMANIP</b> <b>PROTECTED</b> <b>OPERATIONS</b></h4><pre>
       <b>virtual</b> <b>boolean</b> <b>HandleKey(Event&amp;)</b>
              This  operation  defines  TextManip's  default  key bindings as described below.  Unless otherwise
              noted below, this function returns <u>true</u>.

              <b>(^P)</b> backward line

              <b>(^N)</b> forward line

              <b>(^B)</b> backward character

              <b>(^F)</b> forward character

              <b>(ESC)</b> terminate text entry, causing HandleKey to return <u>false</u>

              <b>(^A)</b> beginning of line

              <b>(^E)</b> end of line

              <b>(^D)</b> delete character

              <b>(DEL)</b> <b>(^H)</b> delete backward character

       <b>int</b> <b>Dot()</b>
       <b>int</b> <b>Mark()</b>
              The current selection is bounded by two indices into the text buffer.  By convention these indices
              are called dot and mark.  Dot is the position at which text will be inserted  and  deleted.   Mark
              locates  the  end of the selection that moves as the selection is modified.  When the selection is
              empty (an insertion point), dot and mark are equal.

       <b>void</b> <b>InsertText(const</b> <b>char*</b> <b>string,</b> <b>int</b> <b>count)</b>
       <b>void</b> <b>InsertCharacter(char)</b>
       <b>void</b> <b>DeleteText(int</b> <b>count)</b>
       <b>void</b> <b>DeleteCharacter(int)</b>
       <b>void</b> <b>DeleteLine()</b>
       <b>void</b> <b>DeleteSelection()</b>
              Edit the text buffer at the current selection.  InsertText inserts count  characters  from  string
              after  dot.   The  selection  becomes  an  insertion  point  following  the  newly  inserted text.
              InsertCharacter replaces the selected characters with a single character. DeleteText deletes count
              characters at dot.  If count is positive, the characters following dot are deleted;  if  count  is
              negative  the  characters before dot are deleted.  The selection becomes an insertion point in the
              place of the deleted text.  DeleteSelection deletes the text between dot and  mark,  changing  the
              selection  to  an insertion point.  DeleteCharacter is identical to DeleteText if the dot and mark
              are not the same; otherwise it  is  identical  to  DeleteSelection.   DeleteCharacter  provides  a
              convenient  way  to  express  the  behavior  of  the  backspace  and  delete operations.  Finally,
              DeleteLine deletes the line of text containing mark.  The selection becomes an insertion point  at
              mark.

       <b>void</b> <b>BackwardCharacter(int</b> <b>count)</b>
       <b>void</b> <b>ForwardCharacter(int</b> <b>count)</b>
       <b>void</b> <b>BackwardLine(int</b> <b>count)</b>
       <b>void</b> <b>ForwardLine(int</b> <b>count)</b>
       <b>void</b> <b>BackwardWord(int</b> <b>count)</b>
       <b>void</b> <b>ForwardWord(int</b> <b>count)</b>
              Move  the  current  selection  forward or backward by the specified number of the specified units.
              The default movement is one unit.  The selection is not moved before the beginning  of  after  the
              end of the text.

       <b>void</b> <b>BeginningOfLine()</b>
       <b>void</b> <b>EndOfLine()</b>
       <b>void</b> <b>BeginningOfWord()</b>
       <b>void</b> <b>EndOfWord()</b>
       <b>void</b> <b>BeginningOfSelection()</b>
       <b>void</b> <b>EndOfSelection()</b>
       <b>void</b> <b>BeginningOfText()</b>
       <b>void</b> <b>EndOfText()</b>
              Move the current selection forwards or backwards to the specified feature of the text.

       <b>void</b> <b>Select(int</b> <b>dot)</b>
       <b>void</b> <b>Select(int</b> <b>dot,</b> <b>int</b> <b>mark)</b>
       <b>void</b> <b>SelectMore(int</b> <b>mark)</b>
       <b>void</b> <b>SelectAll()</b>
              Modify the current selection in terms of text indices.  With a single parameter, Select moves both
              dot  and  mark  to  the  specified  index.   With  two  parameters, dot and mark can be controlled
              independently.  SelectMore leaves dot unchanged and moves mark.  SelectAll sets dot to the end  of
              the text and mark to the beginning.

       <b>int</b> <b>Locate(Coord</b> <b>x,</b> <b>Coord</b> <b>y)</b>
       <b>boolean</b> <b>Contains(Coord,</b> <b>Coord)</b>
              Locate  returns  the  text index most closely matching the point (<u>x</u>, <u>y</u>).  Contains returns whether
              the text contains the point (<u>x</u>, <u>y</u>).

</pre><h4><b>MANIPGROUP</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>ManipGroup(Viewer*</b> <b>=</b> <b>nil,</b> <b>Tool*</b> <b>=</b> <b>nil)</b>
              Create a ManipGroup, optionally supplying a viewer and a tool.

       <b>virtual</b> <b>void</b> <b>Grasp(Event&amp;)</b>
              The Grasp operation simply calls Grasp on each child in insertion order.

       <b>virtual</b> <b>boolean</b> <b>Manipulating(Event&amp;)</b>
              Manipulating calls the corresponding operation on each child, skipping those  children  that  have
              returned  <u>false</u>  in  previous  calls (up to the last Grasp).  This function returns <u>false</u> when all
              children have done so.

       <b>virtual</b> <b>void</b> <b>Effect(Event&amp;)</b>
              ManipGroup's Effect operation calls Effect on each child.

       <b>virtual</b> <b>void</b> <b>SetViewer(Viewer*)</b>
       <b>virtual</b> <b>void</b> <b>SetTool(Tool*)</b>
       <b>virtual</b> <b>Viewer*</b> <b>GetViewer()</b>
       <b>virtual</b> <b>Tool*</b> <b>GetTool()</b>
              Set and get the ManipGroup's viewer and tool.  The set operations set the ManipGroup's values  for
              these  parameters  and  call  the  corresponding operations on their children.  The get operations
              simply return the ManipGroup's values.

       <b>virtual</b> <b>void</b> <b>First(Iterator&amp;)</b>
       <b>virtual</b> <b>void</b> <b>Last(Iterator&amp;)</b>
       <b>virtual</b> <b>void</b> <b>Next(Iterator&amp;)</b>
       <b>virtual</b> <b>void</b> <b>Prev(Iterator&amp;)</b>
       <b>virtual</b> <b>boolean</b> <b>Done(Iterator)</b>
              Operations for iterating over the ManipGroup's children, if any.  First  and  Last  initialize  an
              iterator to point to the beginning and end of the list of children, respectively.  Next increments
              the  iterator  to point to the following child, while Prev decrements the iterator to point to the
              preceding child.  Done returns whether or not the iterator points beyond the first or  last  child
              in the list.

       <b>Manipulator*</b> <b>GetManip(Iterator)</b>
       <b>void</b> <b>SetManip(Manipulator*,</b> <b>Iterator&amp;)</b>
              GetManip  returns  the  child  manipulator  to  which an iterator points.  SetManip initializes an
              iterator to point to a particular child; it initializes the iterator to point to a nil instance if
              the given Manipulator is not a child of the ManipGroup.

       <b>void</b> <b>Append(</b>
           <b>Manipulator*,</b>
           <b>Manipulator*</b> <b>=</b> <b>nil,</b> <b>Manipulator*</b> <b>=</b> <b>nil,</b> <b>Manipulator*</b> <b>=</b> <b>nil</b>
       <b>)</b>

       <b>void</b> <b>Prepend(</b>
           <b>Manipulator*,</b>
           <b>Manipulator*</b> <b>=</b> <b>nil,</b> <b>Manipulator*</b> <b>=</b> <b>nil,</b> <b>Manipulator*</b> <b>=</b> <b>nil</b>
       <b>)</b>

       <b>void</b> <b>InsertBefore(Iterator,</b> <b>Manipulator*)</b>
       <b>void</b> <b>InsertAfter(Iterator,</b> <b>Manipulator*)</b>
       <b>void</b> <b>Remove(Manipulator*)</b>
       <b>void</b> <b>Remove(Iterator&amp;)</b>
              Operations for modifying the ManipGroup's list of children.  Append and Prepend  add  up  to  four
              child manipulators, in order, to the end and the beginning of the list, respectively.  InsertAfter
              and  InsertBefore  insert  a  child  after  and before the manipulator pointed to by the iterator,
              respectively.  The Remove operations remove a child from the list (without deleting it).  You  can
              remove  a  child  by  referring  to it explicitly or by specifying an iterator.  If an iterator is
              supplied, the Remove operation will advance it to point to the following child as a side effect.

</pre><h4><b>MANIPGROUP</b> <b>PROTECTED</b> <b>OPERATIONS</b></h4><pre>
       <b>UList*</b> <b>Elem(Iterator)</b>
       <b>Manipulator*</b> <b>Manip(UList*)</b>
              ManipGroup stores its children on a UList, which is accessible via  the  <b>_</b><u>kids</u>  protected  member.
              The  Selection's  iteration  operations  store  the  UList  containing  the current child in their
              iterator.  Elem is a convenience function for returning the UList to which an iterator points, and
              Manip extracts the child that a UList element contains.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3U/Connector.3U.html">Connector</a>(3U),   <a href="../man3I/Event.3I.html">Event</a>(3I),   <a href="../man3U/Iterator.3U.html">Iterator</a>(3U),   <a href="../man3U/Manipulator.3U.html">Manipulator</a>(3U),   <a href="../man3I/Painter.3I.html">Painter</a>(3I),   <a href="../man3I/Rubband.3I.html">Rubband</a>(3I),    <a href="../man3U/Tool.3U.html">Tool</a>(3U),
       <a href="../man3I/Transformer.3I.html">Transformer</a>(3I), <a href="../man3U/UList.3U.html">UList</a>(3U), <a href="../man3U/Viewer.3U.html">Viewer</a>(3U), <a href="../man3U/globals.3U.html">globals</a>(3U)

Unidraw                                           1 August 1990                                       <u><a href="../man3U/manips.3U.html">manips</a></u>(3U)
</pre>
 </div>
</div></section>
</div>
</body>
</html>