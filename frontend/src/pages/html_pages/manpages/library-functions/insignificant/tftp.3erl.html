<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tftp - Trivial FTP.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tftp - Trivial FTP.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Interface module for the <u>tftp</u> application.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <u>ServiceConfig</u> <u>=</u> <u>Options</u>

       <u>Options</u> <u>=</u> <u>[option()]</u>

       Most  of  the  options  are  common  for  both the client and the server side, but some of them differs a
       little. The available <u>option()</u>s are as follows:

         <u>{debug,</u> <u>Level}</u>:
           <u>Level</u> <u>=</u> <u>none</u> <u>|</u> <u>error</u> <u>|</u> <u>warning</u> <u>|</u> <u>brief</u> <u>|</u> <u>normal</u> <u>|</u> <u>verbose</u> <u>|</u> <u>all</u>

           Controls the level of debug printouts. Default is <u>none</u>.

         <u>{host,</u> <u>Host}</u>:
           <u>Host</u> <u>=</u> <u>hostname()</u>, see <a href="../man3erl/inet.3erl.html">inet</a>(3erl).

           The name or IP address of the host where the TFTP daemon resides. This option is  only  used  by  the
           client.

         <u>{port,</u> <u>Port}</u>:
           <u>Port</u> <u>=</u> <u>int()</u>

           The  TFTP  port where the daemon listens. Defaults is the standardized number 69. On the server side,
           it can sometimes make sense to set it to 0, meaning that the daemon just picks a free port (which one
           is returned by function <u>info/1</u>).

           If a socket is connected already, option <u>{udp,</u> <u>[{fd,</u> <u>integer()}]}</u> can be used to pass the  open  file
           descriptor  to  <u>gen_udp</u>.  This can be automated by using a command-line argument stating the prebound
           file descriptor number. For example, if  the  port  is  69  and  file  descriptor  22  is  opened  by
           <u>setuid_socket_wrap</u>, the command-line argument "-tftpd_69 22" triggers the prebound file descriptor 22
           to  be  used instead of opening port 69. The UDP option <u>{udp,</u> <u>[{fd,</u> <u>22}]}</u> is automatically added. See
           <u>init:get_argument/</u> about command-line arguments and <u>gen_udp:open/2</u> about UDP options.

         <u>{port_policy,</u> <u>Policy}</u>:
           <u>Policy</u> <u>=</u> <u>random</u> <u>|</u> <u>Port</u> <u>|</u> <u>{range,</u> <u>MinPort,</u> <u>MaxPort}</u>

           <u>Port</u> <u>=</u> <u>MinPort</u> <u>=</u> <u>MaxPort</u> <u>=</u> <u>int()</u>

           Policy for the selection of the temporary port that is used by  the  server/client  during  the  file
           transfer.  Default  is  <u>random</u>,  which is the standardized policy. With this policy a randomized free
           port is used. A single port or a range of ports can be  useful  if  the  protocol  passes  through  a
           firewall.

         <u>{udp,</u> <u>Options}</u>:
           <u>Options</u> <u>=</u> <u>[Opt]</u>, see gen_udp:open/2.

         <u>{use_tsize,</u> <u>Bool}</u>:
           <u>Bool</u> <u>=</u> <u>bool()</u>

           Flag for automated use of option <u>tsize</u>. With this set to <u>true</u>, the <u>write_file/3</u> client determines the
           filesize  and  sends it to the server as the standardized <u>tsize</u> option. A <u>read_file/3</u> client acquires
           only a filesize from the server by sending a zero <u>tsize</u>.

         <u>{max_tsize,</u> <u>MaxTsize}</u>:
           <u>MaxTsize</u> <u>=</u> <u>int()</u> <u>|</u> <u>infinity</u>

           Threshold for the maximal filesize in bytes. The transfer  is  aborted  if  the  limit  is  exceeded.
           Default is <u>infinity</u>.

         <u>{max_conn,</u> <u>MaxConn}</u>:
           <u>MaxConn</u> <u>=</u> <u>int()</u> <u>|</u> <u>infinity</u>

           Threshold  for  the  maximal  number  of  active  connections.  The  daemon  rejects the setup of new
           connections if the limit is exceeded. Default is <u>infinity</u>.

         <u>{TftpKey,</u> <u>TftpVal}</u>:
           <u>TftpKey</u> <u>=</u> <u>string()</u>
           <u>TftpVal</u> <u>=</u> <u>string()</u>

           Name and value of a TFTP option.

         <u>{reject,</u> <u>Feature}</u>:
           <u>Feature</u> <u>=</u> <u>Mode</u> <u>|</u> <u>TftpKey</u>
            <u>Mode</u> <u>=</u> <u>read</u> <u>|</u> <u>write</u>
            <u>TftpKey</u> <u>=</u> <u>string()</u>

           Controls which features to reject. This is mostly useful for the server as it can restrict the use of
           certain TFTP options or read/write access.

         <u>{callback,</u> <u>{RegExp,</u> <u>Module,</u> <u>State}}</u>:
           <u>RegExp</u> <u>=</u> <u>string()</u>
           <u>Module</u> <u>=</u> <u>atom()</u>
           <u>State</u> <u>=</u> <u>term()</u>

           Registration of a callback module. When a file is to be transferred, its local filename is matched to
           the regular expressions of the registered callbacks. The first matching callback is used  during  the
           transfer. See read_file/3 and write_file/3.

           The callback module must implement the <u>tftp</u> behavior, see CALLBACK FUNCTIONS.

         <u>{logger,</u> <u>Module}</u>:
           <u>Module</u> <u>=</u> <u>module()</u>

           Callback  module  for  customized logging of errors, warnings, and info messages. The callback module
           must implement the <u>tftp_logger</u> behavior, see LOGGER FUNCTIONS. The default module is <u>tftp_logger</u>.

         <u>{max_retries,</u> <u>MaxRetries}</u>:
           <u>MaxRetries</u> <u>=</u> <u>int()</u>

           Threshold for the maximal number of retries. By default the server/client tries to resend  a  message
           up to five times when the time-out expires.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>change_config(daemons,</b> <b>Options)</b> <b>-&gt;</b> <b>[{Pid,</b> <b>Result}]</b>

              Types:

                 Options = [option()]
                 Pid = pid()
                 Result = ok | {error, Reason}
                 Reason = term()

              Changes configuration for all TFTP daemon processes.

       <b>change_config(servers,</b> <b>Options)</b> <b>-&gt;</b> <b>[{Pid,</b> <b>Result}]</b>

              Types:

                 Options = [option()]
                 Pid = pid()
                 Result = ok | {error, Reason}
                 Reason = term()

              Changes configuration for all TFTP server processes.

       <b>change_config(Pid,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Pid = pid()
                 Options = [option()]
                 Result = ok | {error, Reason}
                 Reason = term()

              Changes configuration for a TFTP daemon, server, or client process.

       <b>info(daemons)</b> <b>-&gt;</b> <b>[{Pid,</b> <b>Options}]</b>

              Types:

                 Pid = [pid()]
                 Options = [option()]
                 Reason = term()

              Returns information about all TFTP daemon processes.

       <b>info(servers)</b> <b>-&gt;</b> <b>[{Pid,</b> <b>Options}]</b>

              Types:

                 Pid = [pid()]
                 Options = [option()]
                 Reason = term()

              Returns information about all TFTP server processes.

       <b>info(Pid)</b> <b>-&gt;</b> <b>{ok,</b> <b>Options}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Options = [option()]
                 Reason = term()

              Returns information about a TFTP daemon, server, or client process.

       <b>read_file(RemoteFilename,</b> <b>LocalFilename,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>LastCallbackState}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 RemoteFilename = string()
                 LocalFilename = binary | string()
                 Options = [option()]
                 LastCallbackState = term()
                 Reason = term()

              Reads a (virtual) file <u>RemoteFilename</u> from a TFTP server.

              If  <u>LocalFilename</u>  is the atom <u>binary</u>, <u>tftp_binary</u> is used as callback module. It concatenates all
              transferred blocks and returns them as one single binary in <u>LastCallbackState</u>.

              If <u>LocalFilename</u> is a string and there are no registered callback modules, <u>tftp_file</u>  is  used  as
              callback  module. It writes each transferred block to the file named <u>LocalFilename</u> and returns the
              number of transferred bytes in <u>LastCallbackState</u>.

              If <u>LocalFilename</u> is a string and there are registered callback modules,  <u>LocalFilename</u>  is  tested
              against  the regexps of these and the callback module corresponding to the first match is used, or
              an error tuple is returned if no matching regexp is found.

       <b>start(Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>Pid}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Options = [option()]
                 Pid = pid()
                 Reason = term()

              Starts a daemon process listening for UDP packets on a port. When it receives a request  for  read
              or write, it spawns a temporary server process handling the actual transfer of the (virtual) file.

       <b>write_file(RemoteFilename,</b> <b>LocalFilename,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>LastCallbackState}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 RemoteFilename = string()
                 LocalFilename = binary() | string()
                 Options = [option()]
                 LastCallbackState = term()
                 Reason = term()

              Writes a (virtual) file <u>RemoteFilename</u> to a TFTP server.

              If  <u>LocalFilename</u>  is  a binary, <u>tftp_binary</u> is used as callback module. The binary is transferred
              block by block and the number of transferred bytes is returned in <u>LastCallbackState</u>.

              If <u>LocalFilename</u> is a string and there are no registered callback modules, <u>tftp_file</u>  is  used  as
              callback  module.  It  reads the file named <u>LocalFilename</u> block by block and returns the number of
              transferred bytes in <u>LastCallbackState</u>.

              If <u>LocalFilename</u> is a string and there are registered callback modules,  <u>LocalFilename</u>  is  tested
              against  the regexps of these and the callback module corresponding to the first match is used, or
              an error tuple is returned if no matching regexp is found.

</pre><h4><b>CALLBACK</b> <b>FUNCTIONS</b></h4><pre>
       A <u>tftp</u> callback module is to be implemented as a <u>tftp</u> behavior and export the  functions  listed  in  the
       following.

       On  the  server  side,  the callback interaction starts with a call to <u>open/5</u> with the registered initial
       callback state. <u>open/5</u> is expected to open the (virtual) file. Then either function <u>read/1</u> or <u>write/2</u>  is
       invoked  repeatedly,  once  per  transferred  block.  At  each function call, the state returned from the
       previous call is obtained. When the last block is encountered, function <u>read/1</u> or <u>write/2</u> is expected  to
       close  the  (virtual)  file and return its last state. Function <u>abort/3</u> is only used in error situations.
       Function <u>prepare/5</u> is not used on the server side.

       On the client side, the callback interaction is the same, but it starts and ends a  bit  differently.  It
       starts  with  a  call  to  <u>prepare/5</u>  with  the  same arguments as <u>open/5</u> takes. <u>prepare/5</u> is expected to
       validate the TFTP options suggested by the user and to return the subset of them that  it  accepts.  Then
       the  options  are  sent  to  the  server,  which performs the same TFTP option negotiation procedure. The
       options that are accepted by the server are forwarded to function <u>open/5</u>  on  the  client  side.  On  the
       client  side,  function  <u>open/5</u>  must  accept  all option as-is or reject the transfer. Then the callback
       interaction follows the same pattern as described for the server side. When the last block is encountered
       in <u>read/1</u> or <u>write/2</u>, the returned state is forwarded to  the  user  and  returned  from  <u>read_file</u>/3  or
       <u>write_file/3</u>.

       If  a  callback (performing the file access in the TFTP server) takes too long time (more than the double
       TFTP time-out), the server aborts the connection and sends an error reply to  the  client.  This  implies
       that  the  server  releases  resources  attached  to the connection faster than before. The server simply
       assumes that the client has given up.

       If the TFTP server receives yet another request from the same  client  (same  host  and  port)  while  it
       already has an active connection to the client, it ignores the new request if the request is equal to the
       first  one  (same filename and options). This implies that the (new) client will be served by the already
       ongoing connection on the server side. By not setting up yet another connection,  in  parallel  with  the
       ongoing one, the server consumes less resources.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>Module:abort(Code,</b> <b>Text,</b> <b>State)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Code = undef | enoent | eacces | enospc
                  | badop | eexist | baduser | badopt
                  | int()
                 Text = string()
                 State = term()

              Invoked when the file transfer is aborted.

              The  callback function is expected to clean up its used resources after the aborted file transfer,
              such as closing open file descriptors and so on. The function is not invoked if any of  the  other
              callback  functions  returns  an  error,  as  it is expected that they already have cleaned up the
              necessary resources. However, it is invoked if the functions fail (crash).

       <b>Module:open(Peer,</b> <b>Access,</b> <b>Filename,</b> <b>Mode,</b> <b>SuggestedOptions,</b> <b>State)</b> <b>-&gt;</b> <b>{ok,</b> <b>AcceptedOptions,</b>  <b>NewState}</b>  <b>|</b>
       <b>{error,</b> <b>{Code,</b> <b>Text}}</b>

              Types:

                 Peer = {PeerType, PeerHost, PeerPort}
                 PeerType = inet | inet6
                 PeerHost = ip_address()
                 PeerPort = integer()
                 Access = read | write
                 Filename = string()
                 Mode = string()
                 SuggestedOptions = AcceptedOptions = [{Key, Value}]
                  Key = Value = string()
                 State = InitialState | term()
                  InitialState = [] | [{root_dir, string()}]
                 NewState = term()
                 Code = undef | enoent | eacces | enospc
                  | badop | eexist | baduser | badopt
                  | int()
                 Text = string()

              Opens a file for read or write access.

              On  the  client  side, where the <u>open/5</u> call has been preceded by a call to <u>prepare/5</u>, all options
              must be accepted or rejected.

              On the server side, where there is no preceding <u>prepare/5</u> call, no new options can be  added,  but
              those present in <u>SuggestedOptions</u> can be omitted or replaced with new values in <u>AcceptedOptions</u>.

       <b>Module:prepare(Peer,</b>  <b>Access,</b>  <b>Filename,</b>  <b>Mode,</b>  <b>SuggestedOptions,</b> <b>InitialState)</b> <b>-&gt;</b> <b>{ok,</b> <b>AcceptedOptions,</b>
       <b>NewState}</b> <b>|</b> <b>{error,</b> <b>{Code,</b> <b>Text}}</b>

              Types:

                 Peer = {PeerType, PeerHost, PeerPort}
                 PeerType = inet | inet6
                 PeerHost = ip_address()
                 PeerPort = integer()
                 Access = read | write
                 Filename = string()
                 Mode = string()
                 SuggestedOptions = AcceptedOptions = [{Key, Value}]
                  Key = Value = string()
                 InitialState = [] | [{root_dir, string()}]
                 NewState = term()
                 Code = undef | enoent | eacces | enospc
                  | badop | eexist | baduser | badopt
                  | int()
                 Text = string()

              Prepares to open a file on the client side.

              No new options can be added, but those present in <u>SuggestedOptions</u> can be omitted or replaced with
              new values in <u>AcceptedOptions</u>.

              This is followed by a call to <u>open/4</u> before any read/write access is performed. <u>AcceptedOptions</u> is
              sent to the server, which replies with the options that it accepts. These are  then  forwarded  to
              <u>open/4</u> as <u>SuggestedOptions</u>.

       <b>Module:read(State)</b> <b>-&gt;</b> <b>{more,</b> <b>Bin,</b> <b>NewState}</b> <b>|</b> <b>{last,</b> <b>Bin,</b> <b>FileSize}</b> <b>|</b> <b>{error,</b> <b>{Code,</b> <b>Text}}</b>

              Types:

                 State = NewState = term()
                 Bin = binary()
                 FileSize = int()
                 Code = undef | enoent | eacces | enospc
                  | badop | eexist | baduser | badopt
                  | int()
                 Text = string()

              Reads a chunk from the file.

              The  callback function is expected to close the file when the last file chunk is encountered. When
              an error is encountered, the callback function is expected to clean  up  after  the  aborted  file
              transfer,  such  as  closing open file descriptors, and so on. In both cases there will be no more
              calls to any of the callback functions.

       <b>Module:write(Bin,</b> <b>State)</b> <b>-&gt;</b> <b>{more,</b> <b>NewState}</b> <b>|</b> <b>{last,</b> <b>FileSize}</b> <b>|</b> <b>{error,</b> <b>{Code,</b> <b>Text}}</b>

              Types:

                 Bin = binary()
                 State = NewState = term()
                 FileSize = int()
                 Code = undef | enoent | eacces | enospc
                  | badop | eexist | baduser | badopt
                  | int()
                 Text = string()

              Writes a chunk to the file.

              The callback function is expected to close the file when the last file chunk is encountered.  When
              an  error  is  encountered,  the  callback function is expected to clean up after the aborted file
              transfer, such as closing open file descriptors, and so on. In both cases there will  be  no  more
              calls to any of the callback functions.

</pre><h4><b>LOGGER</b> <b>FUNCTIONS</b></h4><pre>
       A  <u>tftp_logger</u>  callback  module  is to be implemented as a <u>tftp_logger</u> behavior and export the following
       functions:

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>Logger:error_msg(Format,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>exit(Reason)</b>

              Types:

                 Format = string()
                 Data = [term()]
                 Reason = term()

              Logs an error message. See <u>error_logger:error_msg/2</u> for details.

       <b>Logger:info_msg(Format,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>exit(Reason)</b>

              Types:

                 Format = string()
                 Data = [term()]
                 Reason = term()

              Logs an info message. See <u>error_logger:info_msg/2</u> for details.

       <b>Logger:warning_msg(Format,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>exit(Reason)</b>

              Types:

                 Format = string()
                 Data = [term()]
                 Reason = term()

              Logs a warning message. See <u>error_logger:warning_msg/2</u> for details.

Ericsson AB                                        tftp 1.0.3                                         <u><a href="../man3erl/tftp.3erl.html">tftp</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>