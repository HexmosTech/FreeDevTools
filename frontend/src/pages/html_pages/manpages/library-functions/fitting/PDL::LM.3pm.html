<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::Fit::LM -- Levenberg-Marquardt fitting routine for PDL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpdl-fit-perl">libpdl-fit-perl_2.100-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::Fit::LM -- Levenberg-Marquardt fitting routine for PDL

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides fitting functions for PDL. Currently, only Levenberg-Marquardt fitting is
       implemented. Other procedures should be added as required. For a fairly concise overview on fitting see
       Numerical Recipes, chapter 15 "Modeling of data".

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PDL::Fit::LM;
        $ym = lmfit $x, $y, $sigma, \&amp;expfunc, $initp, {Maxiter =&gt; 300};

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>lmfit</b>
       Levenberg-Marquardt fitting of a user supplied model function

        ($ym,$finalp,$covar,$iters) =
             lmfit $x, $y, $sigma, \&amp;expfunc, $initp, {Maxiter =&gt; 300, Eps =&gt; 1e-3};

       where $x is the independent variable and $y the value of the dependent variable at each $x, $sigma is the
       estimate of the uncertainty (i.e., standard deviation) of $y at each data point, the fourth argument is a
       subroutine reference (see below), and $initp the initial values of the parameters to be adjusted.

       Options:

        Maxiter:  maximum number of iterations before giving up
        Eps:      convergence criterion for fit; success when normalized change
                  in chisquare smaller than Eps

       The user supplied sub routine reference should accept 4 arguments

       •   a vector of independent values $x

       •   a vector of fitting parameters

       •   a vector of dependent variables that will be assigned upon return

       •   a  matrix  of  partial  derivatives with respect to the fitting parameters that will be assigned upon
           return

       As an example take this definition of a single exponential with 3 parameters (width, amplitude, offset):

        sub expdec {
          my ($x,$par,$ym,$dyda) = @_;
          my ($width,$amp,$off) = map {$par-&gt;slice("($_)")} (0..2);
          my $arg = $x/$width;
          my $ex = exp($arg);
          $ym .= $amp*$ex+$off;
          my (@dy) = map {$dyda-&gt;slice(",($_)")} (0..2);
          $dy[0] .= -$amp*$ex*$arg/$width;
          $dy[1] .= $ex;
          $dy[2] .= 1;
        }

       Note usage of the ".=" operator for assignment

       In scalar context returns a vector of the fitted dependent  variable.  In  list  context  returns  fitted
       y-values,  vector of fitted parameters, an estimate of the covariance matrix (as an indicator of goodness
       of fit) and number of iterations performed.

       An extended example script that uses lmfit is included below.  This nice example  was  provided  by  John
       Gehman  and  should  help  you  to  master  the  initial hurdles. It can also be found in the <u>Example/Fit</u>
       directory.

          use PDL;
          use PDL::Math;
          use PDL::Fit::LM;
          use strict;

          ### fit using pdl's lmfit (Marquardt-Levenberg non-linear least squares fitting)
          ###
          ### `lmfit' Syntax:
          ###
          ### ($ym,$finalp,$covar,$iters)
          ###  = lmfit $x, $y, $sigma, \&amp;fn, $initp, {Maxiter =&gt; 300, Eps =&gt; 1e-3};
          ###
          ### Explanation of variables
          ###
          ### OUTPUT
          ### $ym     = pdl of fitted values
          ### $finalp = pdl of parameters
          ### $covar  = covariance matrix
          ### $iters  = number of iterations actually used
          ###
          ### INPUT
          ### $x      = x data
          ### $y      = y data
          ### $sigma  = ndarray of y-uncertainties for each value of $y (can be set to scalar 1 for equal weighting)
          ### \&amp;fn    = reference to function provided by user (more on this below)
          ### $initp  = initial values for floating parameters
          ###               (needs to be explicitly set prior to use of lmfit)
          ### Maxiter = maximum iterations
          ### Eps     = convergence criterion (maximum normalized change in Chi Sq.)

          ### Example:
          # make up experimental data:
          my $xdata = pdl sequence 5;
          my $ydata = pdl [1.1,1.9,3.05,4,4.9];

          # set initial prameters in a pdl (order in accord with fit function below)
          my $initp = pdl [0,1];

          # Weight all y data equally (else specify different uncertainties in a pdl)
          my $sigma = 1;

          # Use lmfit. Fourth input argument is reference to user-defined
          # subroutine ( here \&amp;linefit ) detailed below.
          my ($yf,$pf,$cf,$if) = lmfit $xdata, $ydata, $sigma, \&amp;linefit, $initp;

          # Note output
          print "\nXDATA\n$xdata\nY DATA\n$ydata\n\nY DATA FIT\n$yf\n\n";
          print "Slope and Intercept\n$pf\n\nCOVARIANCE MATRIX\n$cf\n\n";
          print "NUMBER ITERATIONS\n$if\n\n";

          # simple example of user defined fit function. Guidelines included on
          # how to write your own function subroutine.
          sub linefit {

                  # leave this line as is
                  my ($x,$par,$ym,$dyda) = @_;

                  # $m and $c are fit parameters, internal to this function
                  # call them whatever make sense to you, but replace (0..1)
                  # with (0..x) where x is equal to your number of fit parameters
                  # minus 1
                  my ($m,$c) = map { $par-&gt;slice("($_)") } (0..1);

                  # Write function with dependent variable $ym,
                  # independent variable $x, and fit parameters as specified above.
                  # Use the .= (dot equals) assignment operator to express the equality
                  # (not just a plain equals)
                  $ym .= $m * $x + $c;

                  # Edit only the (0..1) part to (0..x) as above
                  my (@dy) = map {$dyda -&gt; slice(",($_)") } (0..1);

                  # Partial derivative of the function with respect to first
                  # fit parameter ($m in this case). Again, note .= assignment
                  # operator (not just "equals")
                  $dy[0] .= $x;

                  # Partial derivative of the function with respect to next
                  # fit parameter ($y in this case)
                  $dy[1] .= 1;

                  # Add $dy[ ] .= () lines as necessary to supply
                  # partial derivatives for all floating parameters.
          }

   <b>tlmfit</b>
       broadcasted version of Levenberg-Marquardt fitting routine mfit

        tlmfit $x, $y, <a href="../man1/float.1.html">float</a>(1)-&gt;<a href="../man0/dummy.0.html">dummy</a>(0), $na, <a href="../man200/float.200.html">float</a>(200), float(1e-4),
              $ym=null, $afit=null, \&amp;expdec;

         Signature: tlmfit(x(n);y(n);sigma(n);<a href="../manm/initp.m.html">initp</a>(m);iter();eps();[o] ym(n);[o] <a href="../manm/finalp.m.html">finalp</a>(m);
                  OtherPar =&gt; subref)

       a broadcasted version of "lmfit" by using  perl  broadcasting.  Direct  broadcasting  in  "lmfit"  seemed
       difficult since we have an if condition in the iteration. In principle that can be worked around by using
       "where" but .... Send a broadcasted "lmfit" version if you work it out!

       Since  we  are using perl broadcasting here speed is not really great but it is just convenient to have a
       broadcasted version for many applications (no explicit for-loops required, etc). Suffers from some of the
       current limitations of perl level broadcasting.

</pre><h4><b>BUGS</b></h4><pre>
       Not known yet.

</pre><h4><b>AUTHOR</b></h4><pre>
       This file copyright (C) 1999, Christian Soeller (<a href="mailto:c.soeller@auckland.ac.nz">c.soeller@auckland.ac.nz</a>).  All rights  reserved.  There
       is no warranty. You are allowed to redistribute this software documentation under certain conditions. For
       details,  see  the  file  COPYING  in  the  PDL  distribution.  If  this  file  is separated from the PDL
       distribution, the copyright notice should be included in the file.

perl v5.40.1                                       2025-04-12                                            <u><a href="../man3pm/LM.3pm.html">LM</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>