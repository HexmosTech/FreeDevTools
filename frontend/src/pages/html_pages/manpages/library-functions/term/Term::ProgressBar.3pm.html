<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Term::ProgressBar - provide a progress meter on a standard terminal</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libterm-progressbar-perl">libterm-progressbar-perl_2.23-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Term::ProgressBar - provide a progress meter on a standard terminal

</pre><h4><b>VERSION</b></h4><pre>
       Version 2.23

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Term::ProgressBar;

           my $progress = Term::ProgressBar-&gt;new ({count =&gt; 10_000});
           $progress-&gt;<a href="../man5_000/update.5_000.html">update</a>(5_000);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Term::ProgressBar provides a simple progress bar on the terminal, to let the user know that something is
       happening, roughly how much stuff has been done, and maybe an estimate at how long remains.

       A typical use sets up the progress bar with a number of items to do, and then calls update to update the
       bar whenever an item is processed.

       Often, this would involve updating the progress bar many times with no user-visible change.  To avoid
       unnecessary work, the update method returns a value, being the update value at which the user will next
       see a change.  By only calling update when the current value exceeds the next update value, the call
       overhead is reduced.

       Remember to call the "$progress-&gt;update($max_value)" when the job is done to get a nice 100% done bar.

       A progress bar by default is simple; it just goes from left-to-right, filling the bar with '='
       characters.  These are called <b>major</b> characters.  For long-running jobs, this may be too slow, so two
       additional features are available: a linear completion time estimator, and/or a <b>minor</b> character: this is
       a character that <u>moves</u> from left-to-right on the progress bar (it does not fill it as the major character
       does), traversing once for each major-character added.  This exponentially increases the granularity of
       the bar for the same width.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>A</b> <b>really</b> <b>simple</b> <b>use</b>
           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>

           use Term::ProgressBar 2.00;
           use constant MAX =&gt; 100_000;

           my $progress = Term::ProgressBar-&gt;new(MAX);

           for (0..MAX) {
               my $is_power = 0;
               for (my $i = 0; 2**$i &lt;= $_; $i++) {
                   $is_power = 1 if 2**$i == $_;
               }

               if ($is_power) {
                   $progress-&gt;update($_);
               }
           }

       see eg/simle_use.pl

       Here is a simple example.  The process considers all the numbers between 0 and MAX, and updates the
       progress bar whenever it finds one.  Note that the progress bar update will be very erratic.  See below
       for a smoother example.  Note also that the progress bar will never complete; see below to solve this.

       The complete text of this example is in <u>examples/powers</u> in the distribution set (it is not installed as
       part of the module).

   <b>A</b> <b>smoother</b> <b>bar</b> <b>update</b>
           my $progress = Term::ProgressBar-&gt;new($max);

           for (0..$max) {
               my $is_power = 0;
               for (my $i = 0; 2**$i &lt;= $_; $i++) {
                   $is_power = 1 if 2**$i == $_;
               }

               $progress-&gt;update($_)
           }

       See eg/smooth_bar.pl

       This example calls update for each value considered.  This will result in a much smoother progress
       update, but more program time is spent updating the bar than doing the "real" work.  See below to remedy
       this.  This example does <u>not</u> call "$progress-&gt;update($max);" at the end, since it is unnecessary, and
       ProgressBar will throw an exception at an attempt to update a finished bar.

       The complete text of this example is in <u>examples/powers2</u> in the distribution set (it is not installed as
       part of the module.

   <b>A</b> <b>(much)</b> <b>more</b> <b>efficient</b> <b>update</b>
           my $progress = Term::ProgressBar-&gt;new({name =&gt; 'Powers', count =&gt; $max, remove =&gt; 1});
           $progress-&gt;<a href="../man0/minor.0.html">minor</a>(0);
           my $next_update = 0;

           for (0..$max) {
               my $is_power = 0;
               for (my $i = 0; 2**$i &lt;= $_; $i++) {
                   $is_power = 1 if 2**$i == $_;
               }

               $next_update = $progress-&gt;update($_) if $_ &gt;= $next_update;
           }

           $progress-&gt;update($max) if $max &gt;= $next_update;

       This example does two things to improve efficiency: firstly, it uses the value returned by update to only
       call it again when needed; secondly, it switches off the use of minor characters to update a lot less
       frequently ("$progress-&gt;<a href="../man0/minor.0.html">minor</a>(0);".  The use of the return value of update means that the call of
       "$progress-&gt;update($max);" at the end is required to ensure that the bar ends on 100%, which gives the
       user a nice feeling.

       This example also sets the name of the progress bar.

       This example also demonstrates the use of the 'remove' flag, which removes the progress bar from the
       terminal when done.

       The complete text of this example is in <u>examples/powers3</u> in the distribution set (it is not installed as
       part of the module.

   <b>When</b> <b>the</b> <b>maximum</b> <b>number</b> <b>of</b> <b>items</b> <b>is</b> <b>sometimes</b> <b>unknown</b>
       Sometimes you may wish to use the progress bar when the number of items may or may not be known. One
       common example is when you write a script that can take input piped from the output of another command,
       and then pipe the output to yet another command. eg:

         some_command --arg value | my_script.pl | some_other_command

       Or ...

         my_script.pl input_file output_file

       This example shows how you can iterate over a file specified on the command line with the progress bar.
       Since the input file may be read from STDIN, the number of lines may not be known. Term::ProgressBar
       handles this by just taking '-1' as the count value and with no further changes to the code. By calling
       update with the same count value, you ensure the progress bar is removed afterwards.

           my $input_file = shift;
           my $output_file = shift;
           my $in_fh = \*STDIN;
           my $out_fh = \*STDOUT;
           my $message_fh = \*STDERR;
           my $num_lines = -1;

           if (defined($input_file) and $input_file ne '-') {
               open($in_fh, $input_file) or die "Couldn't open file, '$input_file': $!";
               my $wc_output = `wc -l $input_file`;
               chomp($wc_output);
               $wc_output =~ /^\s*(\d+)(\D.*)?/ or die "Couldn't parse wc output: $wc_output";
               $num_lines = $1;
           }

           if(defined($output_file)) {
               !-f $output_file or die "Specified output file, '$output_file', already exists";
               open($out_fh, '&gt;', $output_file) or die "Couldn't open output file, '$output_file': $!";
           }

           my $progress = Term::ProgressBar-&gt;new({
               name   =&gt; 'file processor',
               count  =&gt; $num_lines,
               remove =&gt; 1,
               fh     =&gt; $message_fh,
           });

           while (my $line = &lt;$in_fh&gt;) {
               chomp($line);
               print $out_fh "I found a line: $line\n";
               $progress-&gt;message("Found 10000!") if($line =~ /10000/);
               $progress-&gt;update();
           }

           $progress-&gt;update($num_lines);

           print $message_fh "Finished\n";

       When the file is defined explicitly, the progress bar displays the linewise progress through the file.
       Since the progress bar by default prints output to stderr, your scripts output to STDOUT will not be
       affected.

   <b>Using</b> <b>Completion</b> <b>Time</b> <b>Estimation</b>
           my $progress = Term::ProgressBar-&gt;new({
               name  =&gt; 'Powers',
               count =&gt; $max,
               ETA   =&gt; 'linear',
           });
           $progress-&gt;<a href="../man1/max_update_rate.1.html">max_update_rate</a>(1);
           my $next_update = 0;

           for (0..$max) {
               my $is_power = 0;
               for (my $i = 0; 2**$i &lt;= $_; $i++) {
               if ( 2**$i == $_ ) {
                   $is_power = 1;
                   $progress-&gt;message(sprintf "Found %8d to be 2 ** %2d", $_, $i);
               }
           }

           $next_update = $progress-&gt;update($_)
             if $_ &gt; $next_update;
         }
         $progress-&gt;update($max)
             if $max &gt;= $next_update;

       This example uses the ETA option to switch on completion estimation.  Also, the update return is tuned to
       try to update the bar approximately once per second, with the max_update_rate call.  See the
       documentation for the new method for details of the format(s) used.

       This example also provides an example of the use of the message function to output messages to the same
       filehandle whilst keeping the progress bar intact

       The complete text of this example is in <u>examples/powers5</u> in the distribution set (it is not installed as
       part of the module.

</pre><h4><b>INSTANCE</b> <b>CONSTRUCTION</b></h4><pre>
   <b>new</b>
       Create &amp; return a new Term::ProgressBar instance.

       ARGUMENTS
           If  one  argument  is  provided,  and it is a hashref, then the hash is treated as a set of key/value
           pairs, with the following keys; otherwise, it is treated as a number, being equivalent to the "count"
           key.

           count
               The item count.  The progress is marked at 100% when update <u>count</u> is invoked, and  proportionally
               until then.

               If you specify a count less than zero, just the name (if specified) will be displayed and (if the
               remove  flag is set) removed when the progress bar is updated with a number lower than zero. This
               allows you to use the progress bar when the count is sometimes known and  sometimes  not  without
               making multiple changes throughout your code.

           name
               A name to prefix the progress bar with.

           fh  The  filehandle  to  output to.  Defaults to stderr.  Do not try to use *foo{THING} syntax if you
               want Term capabilities; it does not work.  Pass in a globref instead.

           term_width
               Sometimes we can't correctly determine the terminal width. You can use this parameter to force  a
               term width of a particular size. Use a positive integer, please :)

           silent
               If  passed  a  true  value, Term::ProgressBar will do nothing at all. Useful in scripts where the
               progress bar is optional (or just plain doesn't work due to issues with modules it relies on).

               Instead, tell the constructor you want it to be silent and you don't need to change the  rest  of
               your program:

                   my $progress = Term::ProgressBar-&gt;new( { count =&gt; $count, silent =&gt; $silent } );
                   # later
                   $progress-&gt;update; # does nothing

           ETA A  total  time  estimation  to use.  If enabled, a time finished estimation is printed on the RHS
               (once sufficient updates have been performed to make such an  estimation  feasible).   Naturally,
               this is an <u>estimate</u>; no guarantees are made.  The format of the estimate

               Note  that  the  format  is  intended to be as compact as possible while giving over the relevant
               information.  Depending upon  the  time  remaining,  the  format  is  selected  to  provide  some
               resolution  whilst  remaining  compact.  Since the time remaining decreases, the format typically
               changes over time.

               As the ETA approaches, the format will state minutes &amp; seconds left.  This is identifiable by the
               word 'Left' at the RHS of the line.  If the ETA  is  further  away,  then  an  estimate  time  of
               completion  (rather  than time left) is given, and is identifiable by 'ETA' at the LHS of the ETA
               box (on the right of the progress bar).  A time or date may be presented; these are of  the  form
               of  a  24  hour  clock,  e.g. '13:33', a time plus days (e.g., ' 7PM+3' for around in over 3 days
               time) or a day/date, e.g. ' 1Jan' or '27Feb'.

               If ETA is switched on, the return value of update is also affected: the idea here is that if  the
               progress  bar  seems  to be moving quicker than the eye would normally care for (and thus a great
               deal of time is spent doing progress  updates  rather  than  "real"  work),  the  next  value  is
               increased to slow it.  The maximum rate aimed for is tunable via the max_update_rate component.

               The available values for this are:

               undef
                   Do not do estimation.  The default.

               linear
                   Perform  linear  estimation.   This is simply that the amount of time between the creation of
                   the progress bar and now is divided by the current  amount  done,  and  completion  estimated
                   linearly.

       EXAMPLES
             my $progress = Term::ProgressBar-&gt;<a href="../man100/new.100.html">new</a>(100); # count from 1 to 100
             my $progress = Term::ProgressBar-&gt;new({ count =&gt; 100 }); # same

             # Count to 200 thingies, outputting to stdout instead of stderr,
             # prefix bar with 'thingy'
             my $progress = Term::ProgressBar-&gt;new({ count =&gt; 200,
                                                     fh    =&gt; \*STDOUT,
                                                     name  =&gt; 'thingy' });

</pre><h4><b>INSTANCE</b> <b>COMPONENTS</b></h4><pre>
   <b>Scalar</b> <b>Components.</b>
       See "get_set" in Class::MethodMaker for usage.

       target
           The final target.  Updates are measured in terms of this.  Changes will have no effect until the next
           update, but the next update value should be relative to the new target.  So

             $p = Term::ProgressBar({count =&gt; 20});
             # Halfway
             $p-&gt;<a href="../man10/update.10.html">update</a>(10);
             # Double scale
             $p-&gt;<a href="../man40/target.40.html">target</a>(40)
             $p-&gt;<a href="../man21/update.21.html">update</a>(21);

           will cause the progress bar to update to 52.5%

       max_update_rate
           This  value is taken as being the maximum speed between updates to aim for.  <b>It</b> <b>is</b> <b>only</b> <b>meaningful</b> <b>if</b>
           <b>ETA</b> <b>is</b> <b>switched</b> <b>on.</b> It defaults to 0.5, being the number of seconds between updates.

   <b>Boolean</b> <b>Components</b>
       See "get_set" in Class::MethodMaker for usage.

       minor
           Default: set.  If unset, no minor scale will be calculated or updated.

           Minor characters are used on the progress bar to give the user the idea of progress even  when  there
           are  so  many  more  tasks  than  the  terminal  is wide that the granularity would be too great.  By
           default, Term::ProgressBar makes a guess as to when minor characters would be valuable.  However,  it
           may  not  always  guess  right,  so  this  method may be called to force it one way or the other.  Of
           course, the efficiency saving is minimal unless the client is utilizing the return value of update.

           See <u>examples/powers4</u> and <u>examples/powers3</u> to see minor characters  in  action,  and  not  in  action,
           respectively.

   <b>Configuration</b>
       lbrack
           Left bracket ( defaults to [ )

            $progress-&gt;lbrack('&lt;');

       rbrack
           Right bracket ( defaults to ] )

            $progress-&gt;rbrack('&gt;');

</pre><h4><b>INSTANCE</b> <b>HIGHER-LEVEL</b> <b>PROCEDURES</b></h4><pre>
   <b>update</b>
       Update the progress bar.

       ARGUMENTS
           so_far
               Current progress point, in whatever units were passed to "new".

               If  not  defined, assumed to be 1+ whatever was the value last time "update" was called (starting
               at 0).

       RETURNS
           next_call
               The next value of so_far at which to call "update".

   <b>message</b>
       Output a message.  This is very much like print, but we try not to disturb the terminal.

       ARGUMENTS
           string
               The message to output.

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       via RT: &lt;https://rt.cpan.org/Dist/Display.html?Name=Term-ProgressBar&gt;

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       If exactly two arguments are provided, then new operates in v1  compatibility  mode:  the  arguments  are
       considered  to be name, and item count.  Various other defaults are set to emulate version one (e.g., the
       major output character is '#', the bar width is set to 50 characters and the  output  filehandle  is  not
       treated as a terminal). This mode is deprecated.

</pre><h4><b>AUTHOR</b></h4><pre>
       Martyn J. Pearce <a href="mailto:fluffy@cpan.org">fluffy@cpan.org</a>

       Significant contributions from Ed Avis, amongst others.

</pre><h4><b>MAINTAINER</b></h4><pre>
       Gabor Szabo &lt;<a href="http://szabgab.com/">http://szabgab.com/</a>&gt; &lt;<a href="http://perlmaven.com/">http://perlmaven.com/</a>&gt;

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright  (c)  2001,  2002,  2003,  2004, 2005 Martyn J. Pearce.  This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

perl v5.36.0                                       2022-10-09                             <u>Term::<a href="../man3pm/ProgressBar.3pm.html">ProgressBar</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>