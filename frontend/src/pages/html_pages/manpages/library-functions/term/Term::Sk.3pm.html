<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Term::Sk - Perl extension for displaying a progress indicator on a terminal.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libterm-sk-perl">libterm-sk-perl_0.18-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Term::Sk - Perl extension for displaying a progress indicator on a terminal.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Term::Sk;

         my $ctr = Term::Sk-&gt;new('%d Elapsed: %8t %21b %4p %2d (%8c of %11m)',
           {quiet =&gt; 0, freq =&gt; 10, base =&gt; 0, target =&gt; 100, pdisp =&gt; '!'});

         $ctr-&gt;up for (1..100);

         $ctr-&gt;down for (1..100);

         $ctr-&gt;whisper('abc');

         my last_line = $ctr-&gt;get_line;

         $ctr-&gt;close;

         print "Number of ticks: ", $ctr-&gt;ticks, "\n";

</pre><h4><b>EXAMPLES</b></h4><pre>
       Term::Sk is a class to implement a progress indicator ("Sk" is a short form for "Show Key"). This is used
       to provide immediate feedback for long running processes.

       A sample code fragment that uses Term::Sk:

         use Term::Sk;

         print qq{This is a test of "Term::Sk"\n\n};

         my $target = 2_845;
         my $format = '%2d Elapsed: %8t %21b %4p %2d (%8c of %11m)';

         my $ctr = Term::Sk-&gt;new($format,
           {freq =&gt; 10, base =&gt; 0, target =&gt; $target, pdisp =&gt; '!'});

         for (1..$target) {
             $ctr-&gt;up;
             do_something();
         }

         $ctr-&gt;close;

         sub do_something {
             my $test = 0;
             for my $i (0..10_000) {
                 $test += sin($i) * cos($i);
             }
         }

       Another example that counts upwards:

         use Term::Sk;

         my $format = '%21b %4p';

         my $ctr = Term::Sk-&gt;new($format, {freq =&gt; 's', base =&gt; 0, target =&gt; 70});

         for (1..10) {
             $ctr-&gt;<a href="../man7/up.7.html">up</a>(7);
             sleep 1;
         }

         $ctr-&gt;close;

       At any time, after Term::Sk-&gt;<b>new()</b>, you can query the number of ticks (i.e. number of calls to $ctr-&gt;up
       or $ctr-&gt;down) using the method 'ticks':

         use Term::Sk;

         my $ctr = Term::Sk-&gt;new('%6c', {freq =&gt; 's', base =&gt; 0, target =&gt; 70});

         for (1..4288) {
             $ctr-&gt;up;
         }

         $ctr-&gt;close;

         print "Number of ticks: ", $ctr-&gt;ticks, "\n";

       This example uses a simple progress bar in quiet mode (nothing is printed to STDOUT), but instead, the
       content of what would have been printed can now be extracted using the <b>get_line()</b> method:

         use Term::Sk;

         my $format = 'Ctr %4c';

         my $ctr = Term::Sk-&gt;new($format, {freq =&gt; 2, base =&gt; 0, target =&gt; 10, quiet =&gt; 1});

         my $line = $ctr-&gt;get_line;
         $line =~ s/\010/&lt;/g;
         print "This is what would have been printed upon new(): [$line]\n";

         for my $i (1..10) {
             $ctr-&gt;up;

             $line = $ctr-&gt;get_line;
             $line =~ s/\010/&lt;/g;
             print "This is what would have been printed upon $i. call to up(): [$line]\n";
         }

         $ctr-&gt;close;

         $line = $ctr-&gt;get_line;
         $line =~ s/\010/&lt;/g;
         print "This is what would have been printed upon close(): [$line]\n";

       Here are some examples that show different values for option {num =&gt; ...}

         my $format = 'act %c max %m';

         my $ctr1 = Term::Sk-&gt;new($format, {base =&gt; 1234567, target =&gt; 2345678});
         # The following numbers are shown: act 1_234_567 max 2_345_678

         my $ctr2 = Term::Sk-&gt;new($format, {base =&gt; 1234567, target =&gt; 2345678, num =&gt; q{9,999}});
         # The following numbers are shown: act 1,234,567 max 2,345,678

         my $ctr3 = Term::Sk-&gt;new($format, {base =&gt; 1234567, target =&gt; 2345678, num =&gt; q{9'99}});
         # The following numbers are shown: act 1'23'45'67 max 2'34'56'78

         my $ctr4 = Term::Sk-&gt;new($format, {base =&gt; 1234567, target =&gt; 2345678, num =&gt; q{9}});
         # The following numbers are shown: act 1234567 max 2345678

         my $ctr5 = Term::Sk-&gt;new($format, {base =&gt; 1234567, target =&gt; 2345678,
           commify =&gt; sub{ join '!', split m{}xms, $_[0]; }});
         # The following numbers are shown: act 1!2!3!4!5!6!7 max 2!3!4!5!6!7!8

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Format</b> <b>strings</b>
       The first parameter to <b>new()</b> is the format string which contains the following special characters:

       characters '%d'
           a revolving dash, format '/-\|'

       characters '%t'
           time elapsed, format 'hh:mm:ss'

       characters '%b'
           progress bar, format '#####_____'

       characters '%p'
           Progress in percentage, format '999%'

       characters '%c'
           Actual counter value (commified by '_'), format '99_999_999'

       characters '%m'
           Target maximum value (commified by '_'), format '99_999_999'

       characters '%k'
           Token which updates its value before being displayed.  An example use of this would be a loop wherein
           every step of the loop could be identified by a particular string.  For example:

               my $ctr = Term::Sk-&gt;new('Processing %k counter %c',
                 {base =&gt; 0, token =&gt; 'Albania'});
               foreach my $country (@list_of_european_nations) {
                 $ctr-&gt;token($country);
                 for (1..500) {
                     $ctr-&gt;up;
                     ## do something...
                 }
               };
               $ctr-&gt;close;

           You can also have more than one token on a single line. Here is an example:

               my $ctr = Term::Sk-&gt;new('Processing %k Region %k counter %c',
                 {base =&gt; 0, token =&gt; ['Albania', 'South']});
               foreach my $country (@list_of_european_nations) {
                 $ctr-&gt;token([$country, 'North']);
                 for (1..500) {
                     $ctr-&gt;up;
                     ## do something...
                 }
               };
               $ctr-&gt;close;

           The "token" method is used to update the token value immediately on the screen.

           The "tok_maybe" method is used to set the token value, but the screen is not refreshed immediately.

           If '%k' is used, then the counter must be instantiated with an initial value for the token.

       characters '%P'
           The '%' character itself

   <b>Options</b>
       The second parameter are the following options:

       option {freq =&gt; 999}
           This  option sets the refresh-frequency on STDOUT to every 999 <b>up()</b> or <b>down()</b> calls. If {freq =&gt; 999}
           is not specified at all, then the refresh-frequency is set by default to every <b>up()</b> or <b>down()</b> call.

       option {freq =&gt; 's'}
           This is a special case whereby the refresh-frequency on STDOUT  is set to every second.

       option {freq =&gt; 'd'}
           This is a special case whereby the refresh-frequency on STDOUT  is set to every 1/10th of a second.

       option {base =&gt; 0}
           This specifies the base value from which to count. The default is 0

       option {target =&gt; 10_000}
           This specifies the maximum value to which to count. The default is 10_000.

       option {pdisp =&gt; '!'}
           This option (with the exclamation mark) is obsolete and has no  effect  whatsoever.  The  progressbar
           will always be displayed using the hash-symbol "#".

       option {quiet =&gt; 1}
           This  option  disables most printing to STDOUT, but the content of the would be printed line is still
           available using the method <b>get_line()</b>. The whisper-method, however, still shows its output.

           The default is in fact {quiet =&gt; !-t STDOUT}

       option {num =&gt; '9_999'}
           This option configures the output number format for the counters.

       option {commify =&gt; sub{...}}
           This option allows one to register a subroutine that formats the counters.

       option {test =&gt; 1}
           This option is used for testing purposes only, it disables all printing to STDOUT, even  the  whisper
           shows  no  output.  But  again, the content of the would be printed line is still available using the
           method <b>get_line()</b>.

   <b>Processing</b>
       The <b>new()</b> method immediately displays the initial values on screen. From now on, nothing must be  printed
       to  STDOUT  and/or  STDERR.  However,  you  can  write  to  STDOUT  during the operation using the method
       <b>whisper()</b>.

       We can either count upwards, $ctr-&gt;up, or downwards, $ctr-&gt;down. Everytime we do so, the value is  either
       incremented  or decremented and the new value is replaced on STDOUT. We should do so regularly during the
       process. Both methods, $ctr-&gt;<a href="../man99/up.99.html">up</a>(99) and $ctr-&gt;<a href="../man99/down.99.html">down</a>(99) can take an optional argument, in which  case  the
       value is incremented/decremented by the specified amount.

       When  our  process has finished, we must close the counter ($ctr-&gt;close). By doing so, the last displayed
       value is removed from STDOUT, as if nothing had happened. Now we are allowed to  print  again  to  STDOUT
       and/or STDERR.

   <b>Post</b> <b>hoc</b> <b>transformation</b>
       In  some cases it makes sense to redirected STDOUT to a flat file. In this case, the backspace characters
       remain in the flat file.

       There is a function "<b>rem_backspace()</b>" that removes the backspaces (including the characters that they are
       supposed to remove) from a redirected file.

       Here is a simplified example:

         use Term::Sk qw(rem_backspace);

         my $flatfile = "Test hijabc\010\010\010xyzklmttt\010\010yzz";

         printf "before (len=%3d): '%s'\n", length($flatfile), $flatfile;

         rem_backspace(\$flatfile);

         printf "after  (len=%3d): '%s'\n", length($flatfile), $flatfile;

</pre><h4><b>AUTHOR</b></h4><pre>
       Klaus Eichner, January 2008

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2008-2011 by Klaus Eichner

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-10-13                                      <u>Term::<a href="../man3pm/Sk.3pm.html">Sk</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>