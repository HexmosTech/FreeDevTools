<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Term::VT102 - a class to emulate a DEC VT102 terminal</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libterm-vt102-perl">libterm-vt102-perl_0.91-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Term::VT102 - a class to emulate a DEC VT102 terminal

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Term::VT102;

         my $vt = Term::VT102-&gt;new ('cols' =&gt; 80, 'rows' =&gt; 24);
         while (&lt;&gt;) { $vt-&gt;process ($_); }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The VT102 class provides emulation of most of the functions of a DEC VT102 terminal.  Once initialised,
       data passed to a VT102 object is processed and the in-memory "screen" modified accordingly.  This
       "screen" can be interrogated by the external program in a variety of ways.

       This allows your program to interface with full-screen console programs by running them in a subprocess
       and passing their output to a VT102 class.  You can then see what the application has written on the
       screen by querying the class appropriately.

</pre><h4><b>OPTIONS</b></h4><pre>
       Setting <b>cols</b> or <b>rows</b> in the <b>new()</b> hash allows you to change the size of the terminal being emulated.  If
       you do not specify a size, the default is 80 columns by 24 rows.

       After initialisation, you can read and set the following terminal options using the <b>option_read()</b> and
       <b>option_set()</b> methods:

         LINEWRAP      line wrapping; 1=on, 0=off. Default is OFF.
         LFTOCRLF      treat LF (\n) as CRLF (\r\n); 1=on, 0=off. Default OFF.
         IGNOREXOFF    ignore XON/XOFF characters; 1=on (ignore). Default ON.

</pre><h4><b>METHODS</b></h4><pre>
       The following methods are provided:

       <b>attr_pack</b> (<u>$fg</u>,<u>$bg</u>,<u>$bo</u>,<u>$fa</u>,<u>$st</u>,<u>$ul</u>,<u>$bl</u>,<u>$rv</u>)
           Returns  the  packed  version  of  the given attribute settings, which are given in the same order as
           returned by <b>attr_unpack</b>.  The packed version will be a binary string not longer than 2 bytes.

       <b>attr_unpack</b> (<u>$data</u>)
           Returns  a  list  of  the  contents  of  the  given  packed   attribute   settings,   of   the   form
           (<u>$fg</u>,<u>$bg</u>,<u>$bo</u>,<u>$fa</u>,<u>$st</u>,<u>$ul</u>,<u>$bl</u>,<u>$rv</u>).

           <u>$fg</u> and <u>$bg</u> are the ANSI foreground and background text colours, and <u>$bo</u>, <u>$fa</u>, <u>$st</u>, <u>$ul</u>, <u>$bl</u>, and <u>$rv</u>
           are flags (1 = on, 0 = off) for bold, faint, standout, underline, blink and reverse respectively.

       <b>callback_call</b> (<u>$name</u>, <u>$par1</u>, <u>$par2</u>)
           Calls the callback <u>$name</u> (eg <b>'ROWCHANGE'</b>) with parameters <u>$par1</u> and <u>$par2</u>, as if the VT102 module had
           called it.  Does nothing if that callback has not been set with <b>callback_set</b> <b>()</b>.

       <b>callback_set</b> (<u>$callback</u>, <u>$ref</u>, <u>$private</u>)
           Sets the callback <u>callback</u> to function reference <u>ref</u> with private data <u>$private</u>.

           See the section on <b>CALLBACKS</b> below.

       <b>new</b> (<u>%config</u>)
           Returns a new VT102 object with options specified in <u>%config</u> (see the <b>OPTIONS</b> section for details).

       <b>option_read</b> (<u>$option</u>)
           Returns  the  current  value  of  terminal option <u>$option</u> (see <b>OPTIONS</b> for details), or <u>undef</u> if that
           option does not exist.  Note that you cannot read the terminal size with this call;  use  <b>size()</b>  for
           that.

       <b>option_set</b> (<u>$option</u>, <u>$value</u>)
           Sets  the  current value of terminal option <u>$option</u> to <u>$value</u>, returning the old value or <u>undef</u> if no
           such terminal option exists or you have specified an undefined <u>$value</u>.  Note that you  cannot  resize
           the terminal with this call; use <b>resize()</b> for that.

       <b>process</b> (<u>$string</u>)
           Processes  the  string  <u>$string</u> (which can be zero-length), updating the VT102 object accordingly and
           calling any necessary callbacks on the way.

       <b>resize</b> (<u>$cols</u>, <u>$rows</u>)
           Resizes the VT102 terminal to <u>cols</u> columns by <u>rows</u> rows, eg <b>$vt-</b>&gt;<b>resize</b> <b>(80,</b> <b>24)</b>.  The virtual screen
           is cleared first.

       <b>reset</b> ()
           Resets the object to its "power-on" state.

       <b>row_attr</b> (<u>$row</u>, [<u>$startcol</u>, <u>$endcol</u>])
           Returns the attributes for row <u>$row</u> (or <u>undef</u> if out of range) as a string of packed attributes, each
           character cell's attributes being 2 bytes long.  To unpack the  attributes  for  a  given  cell,  use
           <b>substr()</b>,  eg <b>$attr=substr($row,4,2)</b> would set <u>$attr</u> to the attributes for cell 3 (steps of 2: 0 .. 2
           .. 4, so 4 means the 3rd character).  You would then use the  <b>attr_unpack()</b>  method  to  unpack  that
           character cell's attributes.

           If  <u>$startcol</u> and <u>$endcol</u> are defined, only returns the part of the row between columns <u>$startcol</u> and
           <u>$endcol</u> inclusive instead of the whole row.

       <b>row_text</b> (<u>$row</u>, [<u>$startcol</u>, <u>$endcol</u>])
           Returns the textual contents of row <u>$row</u> (or <u>undef</u> if out of range), with totally  unused  characters
           being  represented  as NULL (\0).  If <u>$startcol</u> and <u>$endcol</u> are defined, only returns the part of the
           row between columns <u>$startcol</u> and <u>$endcol</u> inclusive instead of the whole row.

       <b>row_plaintext</b> (<u>$row</u>, [<u>$startcol</u>, <u>$endcol</u>])
           Returns the textual contents of row <u>$row</u> (or <u>undef</u> if out of range),  with  unused  characters  being
           represented  as  spaces.   If  <u>$startcol</u>  and  <u>$endcol</u>  are defined, only returns the part of the row
           between columns <u>$startcol</u> and <u>$endcol</u> inclusive instead of the whole row.

       <b>row_sgrtext</b> (<u>$row</u>, [<u>$startcol</u>, <u>$endcol</u>])
           Returns the textual contents of row <u>$row</u> (or <u>undef</u> if out of range),  with  unused  characters  being
           represented  as  spaces,  and  ANSI/ECMA-48  escape  sequences  (CSI SGR) used to set the colours and
           attributes as appropriate.  If <u>$startcol</u> and <u>$endcol</u> are defined, only returns the part  of  the  row
           between columns <u>$startcol</u> and <u>$endcol</u> inclusive instead of the whole row.

           Use  <b>row_sgrtext</b>  to  get a row if you want to output it to a real terminal and preserve all colours,
           bold, etc.

       <b>sgr_change</b> (<u>$source</u>, <u>$dest</u>)
           Returns a string containing ANSI/ECMA-48 escape sequences  to  change  colours  and  attributes  from
           <u>$source</u>  to  <u>$dest</u>,  which  are  both  packed attributes (see <b>attr_pack</b>).  This is used internally by
           <b>row_sgrtext</b>.

       <b>cols</b> ()
           Return the number of columns in the VT102 object.

       <b>rows</b> ()
           Return the number of rows in the VT102 object.

       <b>size</b> ()
           Return a pair of values (<u>columns</u>,<u>rows</u>) denoting the size of the terminal in the VT102 object.

       <b>x</b> ()
           Return the current cursor X co-ordinate (1 being leftmost).

           <b>Note:</b> It is possible for the current X co-ordinate to be 1 more than  the  number  of  columns.  This
           happens when the end of a row is reached such that the next character would wrap on to the next row.

       <b>y</b> ()
           Return the current cursor Y co-ordinate (1 being topmost).

       <b>cursor</b> ()
           Return the current cursor state (1 being on, 0 being off).

       <b>xtitle</b> ()
           Return the current xterm window title.

       <b>xicon</b> ()
           Return the current xterm window icon name.

       <b>status</b> ()
           Return a list of values (<u>$x</u>,<u>$y</u>,<u>$attr</u>,<u>$ti</u>,<u>$ic</u>), where <u>$x</u> and <u>$y</u> are the cursor co-ordinates (1,1 = top
           left), <u>$attr</u> is a packed version of the current attributes (see <b>attr_unpack</b>), <u>$ti</u> is the xterm window
           title, and <u>$ic</u> is the xterm window icon name.

       <b>version</b> ()
           Return the version of the VT102 module being used.

</pre><h4><b>CALLBACKS</b></h4><pre>
       Callbacks  are  the  processing loop's way of letting your main program know that something has happened.
       They are called while in a <b>process()</b> loop.

       To specify a callback, use the <b>callback_set</b> interface, giving a reference to the function to call.   Your
       function  should  take five scalar arguments: the VT102 object being processed, the name of the callback,
       and two arguments whose value depends on the callback, as shown below.  The final argument is the private
       data scalar you passed when you called <b>callback_set</b>.

       The name of the callback is passed to the callback function so that you can have one function  to  handle
       all callbacks if you wish.

       Available callback names are:

         BELL          BEL (beep, \007) character received
         CLEAR         screen about to be cleared
         OUTPUT        data (arg1) to be sent back to data source
         ROWCHANGE     screen row (row number is argument 1) content has changed
         SCROLL_DOWN   about to scroll down (arg1=top row, arg2=num to scroll)
         SCROLL_UP     about to scroll up (ditto)
         UNKNOWN       unknown/unsupported code (arg1=name, arg2=code/sequence)
         STRING        string received (arg1=source, eg PM, APC, arg2=string)
         XICONNAME     xterm icon name to be changed to arg1
         XWINTITLE     xterm title name to be changed to arg1
         LINEFEED      line feed about to be processed (arg1=row)
         GOTO          cursor about to be moved (args=new pos)

       Note  that  the  wording of the above is significant in terms of exactly <b>when</b> the callback is called. For
       instance, <b>CLEAR</b> is called just before the screen is cleared, whereas <b>ROWCHANGE</b> is called <u>after</u> the  given
       row has been changed.

       A  good callback handler for <b>OUTPUT</b> is to simply <b>syswrite()</b> argument 1 to your data source - eg if you're
       reading from a telnet session, write that argument straight to  it.   It  is  used  for  cursor  position
       request responses and suchlike.

       Note that <b>SCROLL_DOWN</b> is called when scrolling down, so text is about to move UP the screen; <u>arg1</u> will be
       the row number of the bottom of the scrolling region, and <u>arg2</u> will be the number of rows to be scrolled.
       Likewise,  <b>SCROLL_UP</b> is called when text is about to move down; <u>arg1</u> will be the row number of the top of
       the scrolling region.

       The <b>STRING</b> callback is called for escape sequences that contain a string that would otherwise be ignored,
       such as DSC, PM, and APC. The first argument is the escape sequence that contained the  string,  such  as
       DSC, and the second argument is the string itself. This callback doesn't get called for OSC strings.

       The <b>LINEFEED</b> callback can be thought of as "line completed", it's called when LF, NEL or IND are about to
       be  processed  or  just  before  a line wraps, so it generally indicates that an application has finished
       updating a particular line on the screen.  Handy for scrollback buffer processing.

       The <b>GOTO</b> callback is only called just before the cursor is explicitly moved, by one  of  CUU,  CUD,  VPR,
       CUF, HPR, CUB, CNL, CPL, CHA, HPA, CUP, HVP.  The parameters give the destination column and row, without
       taking scrolling and boundaries into account.

       Finally,  note  that  <b>ROWCHANGE</b>  is only triggered when text is being entered; screen scrolling or screen
       clearance does not trigger it, that would trigger a <b>SCROLL_DOWN</b> or <b>SCROLL_UP</b> or <b>CLEAR</b>.  Line or character
       insertion or deletion will cause one or more <b>ROWCHANGE</b> callbacks, however.

</pre><h4><b>SUPPORTED</b> <b>CODES</b></h4><pre>
       The following sequences are supported:

          007 (BEL)   beep
          010 (BS)    backspace
          011 (HT)    horizontal tab to next tab stop
          012 (LF)    line feed
          013 (VT)    line feed
          014 (FF)    line feed
          015 (CR)    carriage return
          021 (XON)   resume transmission (only if option IGNOREXOFF is cleared)
          023 (XOFF)  stop transmission (only if option IGNOREXOFF is cleared)
          030 (CAN)   interrupt escape sequence
          032 (SUB)   interrupt escape sequence
          033 (ESC)   start escape sequence
          177 (DEL)   ignored
          233 (CSI)   same as ESC [

          ESC 7 (DECSC)   save state
          ESC 8 (DECRC)   restore most recently saved state
          ESC H (HTS)     set tab stop at current column
          ESC g           visual beep - treated as BEL

          ESC # 8 (DECALN)  DEC screen alignment test - fill screen with E's

          CSI @ (ICH)     insert blank characters
          CSI A (CUU)     move cursor up
          CSI B (CUD)     move cursor down
          CSI C (CUF)     move cursor right
          CSI D (CUB)     move cursor left
          CSI E (CNL)     move cursor down and to column 1
          CSI F (CPL)     move cursor up and to column 1
          CSI G (CHA)     move cursor to column in current row
          CSI H (CUP)     move cursor to row, column
          CSI J (ED)      erase display
          CSI K (EL)      erase line
          CSI L (IL)      insert blank lines
          CSI M (DL)      delete lines
          CSI P (DCH)     delete characters on current line
          CSI X (ECH)     erase characters on current line
          CSI a (HPR)     move cursor right
          CSI c (DA)      return ESC [ ? 6 c (VT102)
          CSI d (VPA)     move to row (current column)
          CSI e (VPR)     move cursor down
          CSI f (HVP)     move cursor to row, column
          CSI m (SGR)     set graphic rendition
          CSI n (DSR)     device status report
          CSI r (DECSTBM) set scrolling region to (top, bottom) rows
          CSI s (CUPSV)   save cursor position
          CSI u (CUPRS)   restore cursor position
          CSI ` (HPA)     move cursor to column in current row
          CSI g (TBC)     clear tab stop (CSI 3 g = clear all stops)

</pre><h4><b>LIMITATIONS</b></h4><pre>
       Unknown escape sequences and  control  characters  are  ignored.   All  escape  sequences  pertaining  to
       character sets are ignored.

       The following known control characters / sequences are ignored:

          005 (ENQ)   trigger answerback message
          016 (SO)    activate G1 charset, carriage return
          017 (SI)    activate G0 charset

       The following known escape sequences are ignored:

          ESC %@ (CSDFL)    select default charset (ISO646/8859-1)
          ESC %G (CSUTF8)   select UTF-8
          ESC %8 (CSUTF8)   select UTF-8 (obsolete)
          ESC (8 (G0DFL)    G0 charset = default mapping (ISO8859-1)
          ESC (0 (G0GFX)    G0 charset = VT100 graphics mapping
          ESC (U (G0ROM)    G0 charset = null mapping (straight to ROM)
          ESC (K (G0USR)    G0 charset = user defined mapping
          ESC (B (G0TXT)    G0 charset = ASCII mapping
          ESC )8 (G1DFL)    G1 charset = default mapping (ISO8859-1)
          ESC )0 (G1GFX)    G1 charset = VT100 graphics mapping
          ESC )U (G1ROM)    G1 charset = null mapping (straight to ROM)
          ESC )K (G1USR)    G1 charset = user defined mapping
          ESC )B (G1TXT)    G1 charset = ASCII mapping
          ESC *8 (G2DFL)    G2 charset = default mapping (ISO8859-1)
          ESC *0 (G2GFX)    G2 charset = VT100 graphics mapping
          ESC *U (G2ROM)    G2 charset = null mapping (straight to ROM)
          ESC *K (G2USR)    G2 charset = user defined mapping
          ESC +8 (G3DFL)    G3 charset = default mapping (ISO8859-1)
          ESC +0 (G3GFX)    G3 charset = VT100 graphics mapping
          ESC +U (G3ROM)    G3 charset = null mapping (straight to ROM)
          ESC +K (G3USR)    G3 charset = user defined mapping
          ESC &gt;  (DECPNM)   set numeric keypad mode
          ESC =  (DECPAM)   set application keypad mode
          ESC N  (SS2)      select G2 charset for next char only
          ESC O  (SS3)      select G3 charset for next char only
          ESC P  (DCS)      device control string (ended by ST)
          ESC X  (SOS)      start of string
          ESC ^  (PM)       privacy message (ended by ST)
          ESC _  (APC)      application program command (ended by ST)
          ESC \  (ST)       string terminator
          ESC n  (LS2)      invoke G2 charset
          ESC o  (LS3)      invoke G3 charset
          ESC |  (LS3R)     invoke G3 charset as GR
          ESC }  (LS2R)     invoke G2 charset as GR
          ESC ~  (LS1R)     invoke G1 charset as GR

       The following known CSI (ESC [) sequences are ignored:

          CSI q (DECLL)   set keyboard LEDs

       The following known CSI (ESC [) sequences are only partially supported:

          CSI h (SM)      set mode (only support CSI ? 25 h, cursor on/off)
          CSI l (RM)      reset mode (as above)

</pre><h4><b>EXAMPLES</b></h4><pre>
       For  some  examples,  including  how  to interface Term::VT102 with Net::Telnet or a command such as SSH,
       please see the <b>examples/</b> directory in the distribution.

</pre><h4><b>AUTHORS</b></h4><pre>
       Copyright (C) 2003 Andrew Wood "&lt;andrew dot wood at ivarch dot com&gt;".  Distributed under the terms of the
       Artistic License 2.0.

       Credit is also due to:

         Charles Harker &lt;CHarker at interland.com&gt;
           - reported and helped to diagnose a bug in the handling of TABs

         Steve van der Burg &lt;steve.vanderburg at lhsc.on.ca&gt;
           - supplied basis for an example script using Net::Telnet

         Chris R. Donnelly &lt;cdonnelly at digitalmotorworks.com&gt;
           - added support for DECTCEM, partial support for SM/RM

         Paul L. Stoddard
           - reported a possible bug in cursor movement handling

         Joerg Walter
           - provided a patch for Unicode handling

</pre><h4><b>THINGS</b> <b>TO</b> <b>WATCH</b> <b>OUT</b> <b>FOR</b></h4><pre>
       Make sure that your code understands NULL (\000) - you will get this in strings where  nothing  has  been
       printed  on the screen.  For instance, the sequence "12\e[C34" ("12", "CUF (move right)", "34") you might
       think would yield the string "12 34", but in fact it can also yield "12\00034" - that is,  "12"  followed
       by a zero byte followed by "34".  This is because the screen's contents defaults to zeroes, not spaces.

       To avoid that, use <b>row_plaintext</b>, which will convert NULLs to spaces, instead of <b>row_text</b>.

       Different  types  of  terminal  disagree  on certain corner cases. For example, <b>gnome-terminal</b> and <b>screen</b>
       handle TAB stops and TABbing past the end of the screen in slightly different ways. Term::VT102 is closer
       to <b>screen</b> in the way it handles this sort of thing.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man4/console_codes.4.html">console_codes</a></b>(4), <b>IO::<a href="../man3/Pty.3.html">Pty</a></b>(3)

perl v5.36.0                                       2022-11-19                                         <u><a href="../man3pm/VT102.3pm.html">VT102</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>