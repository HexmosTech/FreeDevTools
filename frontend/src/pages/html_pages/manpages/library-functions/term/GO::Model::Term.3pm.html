<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GO::Model::Term - a term or concept in an ontology</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgo-perl">libgo-perl_0.15-10_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       GO::Model::Term - a term or concept in an ontology

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # From a file
         use GO::Parser;
         my $parser = new GO::Parser({handler=&gt;'obj'}); # create parser object
         $parser-&gt;parse("gene_ontology.obo"); # parse file -&gt; objects
         my $graph = $parser-&gt;handler-&gt;graph;  # get L&lt;GO::Model::Graph&gt; object
         my $term = $graph-&gt;get_term("GO:0001303");   # fetch a term by ID
         printf "Term %s %s\n", $term-&gt;name, $term-&gt;acc;

         # From a GO Database (requires go-db-perl)
         my apph = GO::AppHandle-&gt;connect(-dbname=&gt;$dbname);
         my $term = $apph-&gt;get_term({acc=&gt;00003677});
         printf "Term:%s (%s)\nDefinition:%s\nSynonyms:%s\n",
           $term-&gt;name,
           $term-&gt;public_acc,
           $term-&gt;definition,
           join(", ", @{$term-&gt;synonym_list});

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Represents an Ontology term; the same class is used for process, compartment and function

       currently, a Term is not aware of its Relationships; to find out how a term is related to other terms,
       use the a GO::Model::Graph object, which will give you the GO::Model::Relationship objects; for example

         $rels = $graph-&gt;get_parent_relationships($term-&gt;acc);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       GO::Model::Relationship GO::Model::Graph GO::Model::Xref GO::Model::Association

</pre><h4><b>NOTES</b></h4><pre>
       Like all the GO::Model::* classes, this uses accessor methods to get or set the attributes. by using the
       accessor method without any arguments gets the value of the attribute. if you pass in an argument, then
       the attribuet will be set according to that argument.

       for single-valued attributes

         # this sets the value of the attribute
         $my_object-&gt;attribute_name("my value");

         # this gets the value of the attribute
         $my_value = $my_object-&gt;attribute_name();

       for lists:

         # this sets the values of the attribute
         $my_object-&gt;attribute_name(\@my_values);

         # this gets the values of the attribute
         $my_values = $my_object-&gt;attribute_name();

   <b>acc</b>
         Usage   - print $term-&gt;acc()
         Alias   - public_acc
         Returns -
         Args    -

       accessor: gets/sets GO ID/accession [as an integer]

       throws: exception if you try to pass in a non-integer

       if you want to use IDs in the format GO:0000nnn, then use the method <b>public_acc()</b>

   <b>name</b>
         Usage   - print $term-&gt;name;
         Returns -
         Args    -

       accessor: gets/sets "name" attribute

   <b>subset_list</b>
         Usage   - foreach (@{$term-&gt;subset_list || []}) { printf " $_\n" }
         Returns - list of strings
         Args    - list of strings [optional]

       List of subset Accs for a term

       Subsets are also known as GO Slims

   <b>in_subset</b>
         Usage   - if ($term-&gt;in_subset('goslim_prok');
         Returns - bool
         Args    - subset-name str

       Tests if the term belongs to a subset

   <b>definition</b>
         Usage   - print $term-&gt;definition;
         Returns -
         Args    -

       accessor: gets/sets "definition" attribute

   <b>primary_xref</b>
        Title   : primary_xref
        Usage   :
        Function:
        Example :
        Returns : GO::Model::Xref
        Args    :

       The same as <b>acc()</b>, except the ID is returned as a GO::Model::Xref rather than a string

   <b>comment</b>
        Title   : comment
        Usage   : $obj-&gt;comment($newval)
        Function:
        Example :
        Returns : value of comment (a scalar)
        Args    : on set, new value (a scalar or undef, optional)

   <b>definition_dbxref_list</b>
        Title   : definition_dbxref_list
        Usage   : $obj-&gt;definition_dbxref(\@xrefs)
        Function:
        Example :
        Returns : definition_dbxref_list hashlist (of GO::Model::Xref)
        Args    : on set, new values (GO::Model::Xref hashlist)

       GO::Model::Xref

   <b>add_definition_dbxref</b>
         - Usage : $term-&gt;add_definition_dbxref($xref);
         - Args  : GO::Term::Xref

       GO::Model::Xref

   <b>has_synonym</b>
         Usage   - if ($term-&gt;has_synonym("autotrophy") {...}
         Returns - bool
         Args    - string

   <b>add_synonym</b>
         Usage   - $term-&gt;add_synonym("calcineurin");
         Usage   - $term-&gt;add_synonym(@synonym_strings);
         Returns -
         Args    -

       Adds a synonym; loses type information (the synonym type in blank)

   <b>synonym_list</b>
         Usage   - my $syn_l = $term-&gt;synonym_list;
         Usage   - $term-&gt;synonym_list([$syn1, $syn2]);
         Returns - arrayref
         Args    - arrayref [optional]

       accessor: gets/set list of synonyms [array reference]

       each synonym is represented as a string - this method loses synonym typing information. If used as a
       setter, will set the type for each synonym to null

   <b>add_synonym_by_type</b>
         Usage   - $term-&gt;add_synonym_by_type('exact', $syn);
         Returns -
         Args    -

   <b>synonyms_by_type</b>
         Usage   - $synstrs = $term-&gt;synonyms_by_type('exact');
         Usage   - $term-&gt;synonyms_by_type('exact', \@exact_syns);
         Returns - arrayref of strings
         Args    - type string, arrayref of strings [optional]

       in getter mode, gets a list of synonyms of a particular type

       in setter mode, sets a list of synonyms for a particular type

   <b>alt_id_list</b>
         Usage   - my $syn_l = $term-&gt;alt_id_list;
         Usage   - $term-&gt;alt_id_list([$syn1, $syn2]);
         Returns - arrayref
         Args    - arrayref [optional]

       accessor: gets/set list of synonyms [array reference]

   <b>add_alt_id</b>
         Usage   - $term-&gt;add_alt_id('GO:0000001');
         Returns -
         Args    - id string, or list of id strings

   <b>namespace</b> <b>(INHERITED)</b>
         Usage   - print $term-&gt;namespace();     # getting the type
         Usage   - $term-&gt;namespace("molecular_function"); # setting the type
         Alias   - type
         Alias   - term_type
         Alias   - category
         Alias   - ontology
         Returns - string representing type
         Args    - string represnting type [optional]

       The OBO namespace for the GO::Model::Term or GO::Model::Relationship

       This method is inherited from the superclass

   <b>set_namespace_by_code</b>
         Usage   - $term-&gt;set_namespace_by_code("P");
         Returns -
         Args    - String: M, P or C

       Currently the mapping is hardcoded

         ('F'=&gt;'molecular_function',
          'P'=&gt;'biological_process',
          'C'=&gt;'cellular_component');

   <b>get_code_from_namespace</b>
         Usage   - $code = $term-&gt;get_code_from_namespace;
         Returns - String: M, P or F
         Args    - String (if omitted will use current namespace)

       Returns the code for the current namespace (or any given namespace if supplied)

   <b>add_dbxref</b>
         - Usage : $term-&gt;add_dbxref($xref);
         - Args  : GO::Term::Xref

       GO::Model::Xref

   <b>dbxref_list</b>
         - Usage : $term-&gt;dbxref_list($xref);
         - Args  : optional listref of GO::Term::Xref
         - Returns  : listref of GO::Term::Xref

       accessor: gets/sets list of dbxref [array reference]

   <b>is_obsolete</b>
       accessor: gets/set obsolete flag [boolean

   <b>is_root</b>
       accessor: gets/set is_root flag [boolean]

</pre><h4><b>TERM</b> <b>ASSOCIATION</b> <b>METHODS</b></h4><pre>
   <b>association_list</b>
         Usage   - $assoc_l = $term-&gt;association_list
         Returns - arrayref of GO::Model::Association
         Args    - arrayref of GO::Model::Association [optional]

       accessor: gets/set list of associations [array reference]

       if this is undefined, the datasource will be queried for the associations

   <b>selected_association_list</b>
         Usage   - $assoc_l = $term-&gt;selected_association_list
         Returns - arrayref of GO::Model::Association
         Args    - arrayref of GO::Model::Association [optional]

       accessor: gets list of SELECTED associations [array reference]

       [this method is only of use if you are using it in conjunction with GO::AppHandle in the go-db-perl
       distro]

       this in not the total list of all associations associated with a term; if the term was created via a
       query on products, this will include those associations

       GO::Model::Association

   <b>add_association</b>
         Usage   - $term-&gt;add_association($assoc);
         Returns -
         Args    - GO::Model::Association

       GO::Model::Association

   <b>add_selected_association</b>
         Usage   -
         Returns -
         Args    -

       GO::Model::Association

   <b>association_hash</b>
       returns associations as listref of unique GeneProduct objects

       GO::Model::Association

   <b>get_all_associations</b>
         Usage   - my $al = $term-&gt;get_all_associations
         Returns - GO::Model::Association list
         Args    -

       returns all associations for the term and the terms beneath it in the GO DAG

       same as $apph-&gt;get_all_associations($term)

       GO::Model::Association

   <b>n_associations</b>
         Usage   - my $n = $term-&gt;n_associations
         Returns -
         Args    -

   <b>product_list</b>
         Usage   - $prods = $term-&gt;product_list
         Returns - L&lt;GO::Model::GeneProduct&gt; listref
         Args    -

       Returns a reference to an array of gene products that are attached directly to this term.

       (if the products have not been fetched, this method will call $term-&gt;association_list, cache the results,
       and use the associations to build the product list. succeeding calls of product_list to this term will
       hence be faster)

       See GO::Model::GeneProduct

   <b>deep_product_list</b>
         Usage   -
         Returns - GO::Model::GeneProduct listref
         Args    -

       finds all products attached to this term and all terms below in the graph

       GO::Model::GeneProduct

   <b>n_deep_products</b>
         Usage   - my $count = $term-&gt;n_deep_products;
         Returns - int
         Args    - filter (hashref) - or string "recount"

       gets the count for the *dsitinct* number of GO::Model::GeneProduct entries annotated at OR BELOW this
       level. if you have set the filters in GO::AppHandle then these filters will be used in determining the
       count.

       Remember, if you did not explicitly set the filters, then the default filter will be used, which is
       [!IEA] (i.e. curated associations only, see www.geneontology.org for a discussion of evidence codes).

       Note: currently only the speciesdb filter is respected. It turns out to be very expensive to do the set
       arithmetic for distinct recursive gene counts with different evidence combinations. Because each product
       belongs to one speciesdb only, the speciesdb counts are mutually exclusive, which makes this easier.

         # get the number of gene products that have been annotated
         # as transcription factors in worm and fly discounting
         # uncurated automatic annotations
         $apph-&gt;filters({evcodes=&gt;["!IEA"], speciesdbs=&gt;["SGD", "FB"]});
         $term = $apph-&gt;get_term({name=&gt;"transcription factor"});
         print $term-&gt;n_deep_products;

       The count will be cached, so if you alter the filter parameters be sure to get a recount like this:

         my $count = $term-&gt;n_deep_products("recount");

       TODO: make the recount automatic if the filter is changed

       PERFORMANCE NOTE 1: When you ask the AppHandle to give you a list of GO::Model::Term objects, it may
       decide to populate this attribute when building the terms in a fast and efficient way. Therefore you
       should avoid setting the filters *after* you have created the objects otherwise it will have to refetch
       all these values slowing things down.

       PERFORMANCE NOTE 2: If you are using the SQL GO::AppHandle implementation, then this call will probably
       involve a query to the *gene_produc_count* table. If you populated the database you are using yourself,
       make sure this table is filled otherwise this will be an expensive query.

       GO::Model::GeneProduct

   <b>n_products</b>
         Usage   - as n_deep_products
         Returns -
         Args    -

       see docs for n_deep_products

       gets a count of products AT THIS LEVEL ONLY

       GO::Model::GeneProduct

   <b>loadtime</b>
        Title   : loadtime
        Usage   :
        Function:
        Example :
        Returns : time term was loaded into datasource
        Args    : none

perl v5.36.0                                       2023-12-18                               <u>GO::Model::<a href="../man3pm/Term.3pm.html">Term</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>