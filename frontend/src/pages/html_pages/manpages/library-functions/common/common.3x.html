<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>common - common functions used in other examples libAfterImage/tutorials/common.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libafterimage-dev">libafterimage-dev_2.2.12-18_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>common</b> - common functions used in other examples libAfterImage/tutorials/common.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Generic Xlib related functionality, common for all the tutorials.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       libAfterImage, ASView, ASScale, ASTile, ASMerge, ASGrad, ASFlip, ASText
       libAfterImage/tutorials/_XA_WM_DELETE_WINDOW

</pre><h4><b>NAME_XA_WM_DELETE_WINDOW</b></h4><pre>
</pre><h4><b>SYNOPSIS</b></h4><pre>
       _XA_WM_DELETE_WINDOW - stores value of X Atom "WM_DELETE_WINDOW".

</pre><h4><b>DESCRIPTION</b></h4><pre>
       In  X  all  client's  top  level  windows are managed by window manager.  That includes moving, resizing,
       decorating, focusing and closing of windows. Interactions between window manager and  client  window  are
       governed  by ICCCM specification.  All the parts of this specification are completely optional, but it is
       recommended that the following minimum  set  of  hints  be  supplied  for  any  client  window:  Window's
       title(WM_NAME),  iconified  window  title(WM_ICON_NAME),  class  hint  (WM_CLASS) and supported protocols
       (WM_PROTOCOLS). It is recommended also that WM_DELETE_WINDOW protocol be supported,  as  otherwise  there
       are  no  way  to  safely  close  client  window,  but  to  kill it.  All of the above mentioned hints are
       identified by atoms that have standard preset values, except for WM_DELETE_WINDOW. As the result we  need
       to obtain WM_DELETE_WINDOW atoms ID explicitly. We use _XA_WM_DELETE_WINDOW to store the ID of that atom,
       so it is accessible anywhere from our application.

</pre><h4><b>SOURCE</b></h4><pre>
           Atom _XA_WM_DELETE_WINDOW = None;

       libAfterImage/tutorials/create_top_level_window()

</pre><h4><b>NAMEcreate_top_level_window()</b></h4><pre>
</pre><h4><b>SYNOPSIS</b></h4><pre>
       Window create_top_level_window( ASVisual *asv, Window root,
                                       int x, int y,
                                       unsigned int width,
                                       unsigned int height,
                                       unsigned int border_width,
                                       unsigned long attr_mask,
                                       XSetWindowAttributes *attr,
                                       char *app_class );

</pre><h4><b>INPUTS</b></h4><pre>
       asv    - pointer to valid preinitialized ASVisual structure.

       root   - root window of the screen on which to create window.

       x,     y - desired position of the window

       width, height - desired window size.

       border_width
              -  desired  initial  border  width  of  the  window (may not have any effect due to Window Manager
              intervention.

       attr_mask
              - mask of the attributes that has to be set on the window

       attr   - values of the attributes to be set.

       app_class
              - title of the application to be used as its window Title and resources class.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       ID of the created window.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       create_top_level_window() is autyomating process of creating top level  application  window.  It  creates
       window  for  specified  ASVisual,  and  then  sets up basic ICCCM hints for that window, such as WM_NAME,
       WM_ICON_NAME, WM_CLASS and WM_PROTOCOLS.

</pre><h4><b>SOURCE</b></h4><pre>
           Window create_top_level_window( ASVisual *asv, Window root, int x, int y,
                                    unsigned int width, unsigned int height,
                                    unsigned int border_width,
                                    unsigned long attr_mask,
                                    XSetWindowAttributes *attr,
                                    const char *app_class, const char *app_name ) {
               Window w = None; #ifndef X_DISPLAY_MISSING
               char *tmp ;
               XTextProperty name;
               XClassHint class1;

               w = create_visual_window(asv, root, x, y, width, height, border_width,
                                        InputOutput, attr_mask, attr );

               tmp = (app_name==NULL)?(char*)get_application_name():(char*)app_name;
               XStringListToTextProperty (&amp;tmp, 1, &amp;name);

               class1.res_name = tmp;  /* for future use */
               class1.res_class = (char*)app_class;
               XSetWMProtocols (asv-&gt;dpy, w, &amp;_XA_WM_DELETE_WINDOW, 1);
               XSetWMProperties (asv-&gt;dpy, w, &amp;name, &amp;name, NULL, 0, NULL, NULL, &amp;class1);
               /* final cleanup */
               XFree ((char *) name.value);

           #endif /* X_DISPLAY_MISSING */
               return w; }

       libAfterImage/tutorials/set_window_background_and_free()

</pre><h4><b>NAMEset_window_background_and_free()</b></h4><pre>
</pre><h4><b>SYNOPSIS</b></h4><pre>
       Pixmap set_window_background_and_free( Window w, Pixmap p );

</pre><h4><b>INPUTS</b></h4><pre>
       w      - ID of the window background of which we need to set.

       p      - Pixmap to set background to.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       None on success. Pixmap ID of original Pixmap on failure.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       set_window_background_and_free() will set window's background to specified Pixmap,  Then  refresh  window
       contents  so  that  background  is  drawn by the server, flush all the requests to force it to be sent to
       server to be processed as fast as possible.

</pre><h4><b>NOTES</b></h4><pre>
       After Window's background has been set to Pixmap - X server makes hidden copy of this  Pixmap  for  later
       window  refreshing.  As  the  result  original  Pixmap  is  no longer needed and can be freed to conserve
       resources.

</pre><h4><b>SOURCE</b></h4><pre>
           Pixmap set_window_background_and_free( Window w, Pixmap p ) { #ifndef X_DISPLAY_MISSING
               if( p != None &amp;&amp; w != None )
               {
                   Display *dpy = get_default_asvisual()-&gt;dpy;

                   if (dpy)
                   {
                       XSetWindowBackgroundPixmap( dpy, w, p );
                       XClearWindow( dpy, w );
                       XFlush( dpy );
                       XFreePixmap( dpy, p );
                       p = None ;
                   }
               } #endif /* X_DISPLAY_MISSING */
               return p ; }

       libAfterImage/tutorials/wait_closedown()

</pre><h4><b>NAMEwait_closedown()</b></h4><pre>
</pre><h4><b>SYNOPSIS</b></h4><pre>
       void wait_closedown( Window w );

</pre><h4><b>INPUTS</b></h4><pre>
       w      - ID of the window from which to wait for events.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       User action requesting window to be closed is generally received first by Window Manager. Window  Manager
       is  then  handles  it down to the window by sending it ClientMessage event with first 32 bit word of data
       set to the value of WM_DELETE_WINDOW Atom.  Accordingly, all client has to do is wait for such event from
       X server and, when received, it should destroy its window and generally exit.

</pre><h4><b>NOTES</b></h4><pre>
       It is recommended that XFlush() is issued right after  XDestroyWindow()  as  Window  Manager  itself  may
       attempt to do something with the window until it receives DestroyNotify event.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       ICCCM, Window

</pre><h4><b>SOURCE</b></h4><pre>
           void wait_closedown( Window w ) { #ifndef X_DISPLAY_MISSING
               Display *dpy = get_default_asvisual()-&gt;dpy;

               if(dpy)
               {
                   if (w)
                   {
                       XSelectInput (dpy, w, ( StructureNotifyMask |
                                               ButtonPressMask|
                                               ButtonReleaseMask));

                       while(w != None)
                       {
                           XEvent event ;

                           XNextEvent (dpy, &amp;event);
                           switch(event.type)
                           {
                               case ClientMessage:
                                   if ((event.xclient.format != 32) ||
                                       (event.xclient.data.l[0] != _XA_WM_DELETE_WINDOW))
                                       break ;
                               case ButtonPress:
                                   XDestroyWindow( dpy, w );
                                   XFlush( dpy );
                                   w = None ;
                                   break ;
                           }
                       }
                   }
                   XCloseDisplay (dpy);
               } #endif }

3rd Berkeley Distribution                      AfterStep v.2.2.12                                     <u><a href="../man3x/common.3x.html">common</a></u>(3x)
</pre>
 </div>
</div></section>
</div>
</body>
</html>