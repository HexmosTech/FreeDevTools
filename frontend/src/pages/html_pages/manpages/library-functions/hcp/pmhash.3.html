<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>__pmHashInit,  __pmHashPreAlloc,  __pmHashAdd, __pmHashDel, __pmHashSearch, __pmHashWalk, __pmHashWalkCB,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpcp3-dev">libpcp3-dev_6.3.8-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>__pmHashInit</b>,  <b>__pmHashPreAlloc</b>,  <b>__pmHashAdd</b>, <b>__pmHashDel</b>, <b>__pmHashSearch</b>, <b>__pmHashWalk</b>, <b>__pmHashWalkCB</b>,
       <b>__pmHashFree</b>, <b>__pmHashClear</b> - general purpose hashing routines

</pre><h4><b>C</b> <b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;pcp/pmapi.h&gt;</b>
       <b>#include</b> <b>&lt;pcp/libpcp.h&gt;</b>

       <b>void</b> <b>__pmHashInit(__pmHashCtl</b> <b>*</b><u>hcp</u><b>);</b>
       <b>int</b> <b>__pmHashPreAlloc(int</b> <u>hsize</u><b>,</b> <b>__pmHashCtl</b> <b>*</b><u>hcp</u><b>);</b>
       <b>int</b> <b>__pmHashAdd(unsigned</b> <b>int</b> <u>key</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>,</b> <b>__pmHashCtl</b> <b>*</b><u>hcp</u><b>);</b>
       <b>int</b> <b>__pmHashDel(unsigned</b> <b>int</b> <u>key</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>,</b> <b>__pmHashCtl</b> <b>*</b><u>hcp</u><b>);</b>
       <b>__pmHashNode</b> <b>*__pmHashSearch(unsigned</b> <b>int</b> <u>key</u><b>,</b> <b>__pmHashCtl</b> <b>*</b><u>hcp</u><b>);</b>
       <b>__pmHashNode</b> <b>*__pmHashWalk(__pmHashCtl</b> <b>*</b><u>hcp</u><b>,</b> <b>__pmHashWalkState</b> <u>state</u><b>);</b>
       <b>void</b> <b>__pmHashWalkCB(__pmHashWalkCallback</b> <u>cb</u><b>,</b> <b>void</b> <b>*</b><u>cdata</u><b>,</b> <b>const</b> <b>__pmHashCtl</b> <b>*</b><u>hcp</u><b>);</b>
       <b>void</b> <b>__pmHashFree(__pmHashCtl</b> <b>*</b><u>hcp</u><b>);</b>
       <b>void</b> <b>__pmHashClear(__pmHashCtl</b> <b>*</b><u>hcp</u><b>);</b>

       <b>cc</b> <b>...</b> <b>-lpcp</b>

</pre><h4><b>CAVEAT</b></h4><pre>
       This documentation is intended for internal Performance Co-Pilot (PCP) developer use.

       These interfaces are not part of the PCP APIs that are guaranteed to remain fixed across releases, and at
       some point in the future they may not work or may provide different semantics.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>__pmHash</b> group of routines implement a generalized suite of linear hashing services based  on  a  <u>key</u>
       that  is an unsigned int and <u>data</u> that is an opaque pointer to information the caller wishes to associate
       with <u>key</u>.

       The data type of <u>key</u> makes is suitable for hashed access based on metric identifier (<b>pmID</b>), instance  do‐
       main number (<b>pmInDom</b>) or internal instance identifiers within an instance domain.

       Multiple  hash  tables may exist, each identified by a hash control struct (<b>__pmHashCtl</b>) <b>hcp</b> which is de‐
       clared by the caller and initialized by calling <b>__pmHashInit</b>.  Refer to the <b>HASH</b> <b>CONTROL</b>  and  <b>HASH</b>  <b>NODE</b>
       sections below for more information on the hash table internal data structures.

       The  hash  table  is initially empty but dynamically grows by approximate doubling in size as entries are
       added, and this may cause some organizational overhead in relinking the hash chains when the  hash  table
       grows.   This  overhead  can be avoided by optionally calling <b>__pmHashPreAlloc</b> with an initial hash table
       size of <u>hsize</u> entries, but this must be done after calling <b>__pmHashInit</b> and before any entries are added.

       Entries are added to a hash table by calling <b>__pmHashAdd</b>.  The opaque <u>data</u> is typically a  pointer  to  a
       block of additional information to be associated with the <u>key</u>, although it may be <b>NULL</b> if there is no ad‐
       ditional information required or currently available.

       Although  usually  not  required, duplicate <u>key</u> values can be stored in a hash table and <b>__pmHashAdd</b> will
       silently add these (presumably with a different <u>data</u> pointer).  If uniqueness of <u>key</u>s is required, it  is
       necessary  to  call  <b>__pmHashSearch</b>  first  to  determine  that there is no entry for <u>key</u>, before calling
       <b>__pmHashAdd</b>.

       Entries may be removed from a hash table using <b>__pmHashDel</b> where the entry to be deleted is the <u>first</u> one
       with a matching <u>key</u> and <u>data</u> pointer.  See the note above about duplicate keys to understand why the <u>data</u>
       parameter is needed.

       <b>__pmHashSearch</b> finds the <u>first</u> entry with a matching <u>key</u>.  If duplicate keys are being stored,  then  the
       caller will have to follow the <u>hp</u>-&gt;<u>next</u> chain looking for additional entries with the same <u>key</u>.  Refer to
       the <b>HASH</b> <b>CONTROL</b> and <b>HASH</b> <b>NODE</b> sections below for more information on the hash table internal data struc‐
       tures.

       <b>__pmHashWalk</b>  provides a stateful interface to walk each node in the hash table.  It is first called with
       <u>state</u> set to <b>PM_HASH_WALK_START</b> to retrieve the first entry and then repeatedly called with <u>state</u> set  to
       <b>PM_HASH_WALK_NEXT</b> to retrieve subsequent entries.

       <b>__pmHashWalkCB</b>  provides  an  alternative method to traverse the hash table.  The callback function <u>cb</u> is
       called with two arguments, a pointer to the current hash entry and <u>cdata</u> (the latter allows the caller to
       pass auxiliary information into the callback function, but can be <b>NULL</b> if this  is  not  required).   The
       callback function must return one of the following <b>__pmHashWalkState</b> values:
       <b>PM_HASH_WALK_NEXT</b>
           continue the traversal
       <b>PM_HASH_WALK_STOP</b>
           terminate the traversal
       <b>PM_HASH_DELETE_NEXT</b>
           delete the current node from the hash table and continue the traversal
       <b>PM_HASH_DELETE_STOP</b>
           delete the current node from the hash table and terminate the traversal

       <b>__pmHashFree</b>  will  release  all  storage associated with the hash table and return the hash table to the
       empty state, just like after <b>__pmHashInit</b> has been called.  But <b>__pmHashFree</b> cannot free any storage  at‐
       tached  via the <u>data</u> argument to <b>__pmHashAdd</b> calls.  So the most appropriate way to clean up the hash ta‐
       ble is to first traverse the table releasing any <u>data</u> and then call <b>__pmHashFree</b>  as  the  example  below
       shows.

           __pmHashCtl    hash;

           __pmHashWalkState
           mycallback(const __pmHashNode *hp, void *cp)
           {
               (void)cp;
               if (hp-&gt;data) {
                /*
                 * free() if malloc'd or some datum-specific
                 * method, e.g. __pmFreeProfile()
                 */
                   free(hp-&gt;data);
               }
               return PM_HASH_WALK_NEXT;
           }

           ...
               __pmHashWalkCB(mycallback, NULL, &amp;hash);
               __pmHashFree(&amp;hash);
           }

       <b>__pmHashClear</b>  returns  the  hash table to the empty state, just like after <b>__pmHashInit</b> has been called.
       Beware that <b>__pmHashClear</b> does not release any storage associated with hash entries, and so risks leaking
       memory, however the following example shows how to release all memory in a single traversal of  the  hash
       table with <b>__pmHashWalkCB</b> before calling <b>__pmHashClear</b>.

           __pmHashCtl    hash;

           __pmHashWalkState
           mycallback(const __pmHashNode *hp, void *cp)
           {
               (void)cp;
               if (hp-&gt;data) {
                /*
                 * free() if malloc'd or some datum-specific
                 * method, e.g. __pmFreeProfile()
                 */
                   free(hp-&gt;data);
               }
               /*
                * compared to the previous example, this difference
                * is important and frees each hash node
                */
               return PM_HASH_DELETE_NEXT;
           }

           ...
               __pmHashWalkCB(mycallback, NULL, &amp;hash);
               __pmHashClear(&amp;hash);
           }

</pre><h4><b>HASH</b> <b>CONTROL</b></h4><pre>
       The <b>__pmHashCtl</b> struct is defined as:

           typedef struct __pmHashCtl {
               int                 nodes;
               int                 hsize;
               __pmHashNode        **hash;
               __pmHashNode        *next;
               unsigned int        index;
           } __pmHashCtl;

       The  hash table <u>hash</u> contains <u>hsize</u> entries, each of which may point to a linked list of hash nodes.  The
       total number of hash nodes is held in <u>nodes</u>.  The <u>index</u> and <u>next</u> fields are used to maintain state during
       hash table walk operations.

</pre><h4><b>HASH</b> <b>NODE</b></h4><pre>
       The <b>__pmHashNode</b> struct is defined as:

           typedef struct __pmHashNode {
               struct __pmHashNode *next;
               unsigned int        key;
               void                *data;
           } __pmHashNode;

       Each node holds the <u>key</u>, the opaque pointer (<u>data</u>) and <u>next</u> implements the linked list of hash nodes from
       each entry in the hash table.

</pre><h4><b>DIAGNOSTICS</b> <b>AND</b> <b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>__pmHashPreAlloc</b> returns -1 if the hash table is not empty, else a value &lt; 0 to indicate an error, proba‐
       bly from <b><a href="../man3/calloc.3.html">calloc</a></b>(3), that can be turned into an error message by calling <b><a href="../man3/pmErrStr.3.html">pmErrStr</a></b>(3).

       <b>__pmHashAdd</b> returns 1 for success, else a value &lt; 0 to indicate an error, probably from <b><a href="../man3/calloc.3.html">calloc</a></b>(3).

       Return values from <b>__pmHashDel</b> are 0 if no matching entry is found, else 1 if a matching entry was delet‐
       ed.

       <b>__pmHashSearch</b> returns with a pointer to the entry if found, else <b>NULL</b>.

       <b>__pmHashWalk</b> returns with a pointer to the next entry if found, else <b>NULL</b> when all entries have been tra‐
       versed.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/PMAPI.3.html">PMAPI</a></b>(3), <b><a href="../man3/calloc.3.html">calloc</a></b>(3), <b><a href="../man3/free.3.html">free</a></b>(3) and <b><a href="../man3/pmErrStr.3.html">pmErrStr</a></b>(3).

Performance Co-Pilot                                   PCP                                             <u><a href="../man3/PMHASH.3.html">PMHASH</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>