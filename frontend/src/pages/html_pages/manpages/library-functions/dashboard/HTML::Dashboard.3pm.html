<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Dashboard - Spreadsheet-like formatting for HTML tables, with data-dependent coloring and</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-dashboard-perl">libhtml-dashboard-perl_0.03-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Dashboard - Spreadsheet-like formatting for HTML tables, with data-dependent coloring and
       highlighting: formatted reports

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use HTML::Dashboard;

         my $dash = HTML::Dashboard-&gt;new();

         $dash-&gt;set_data_without_captions( [ [ 'A', 2, 'foo' ],
                                             [ 'B', 0, 'bar' ],
                                             [ 'C', 1, 'baz' ],
                                             [ 'D', 8, 'mog' ],
                                             [ 'E', 4, 'duh' ] ] );

         $dash-&gt;set_captions( qw( Code Number Name ) );
         $dash-&gt;set_cell_low( 1, sub { $_[0] &lt; 1 }, 'lime' );
         $dash-&gt;set_cell_hi(  1, sub { $_[0] &gt; 5 },
                              style =&gt; "background-color: red; font-weight: bold" );

         print $dash-&gt;as_HTML();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module tries to achieve spreadsheet-like formatting for HTML tables.

       Rather than having to build up an HTML table from data, row by row and cell by cell, applying formatting
       rules at every step, this module allows the user to specify a set of simple rules with the desired
       formatting options. The module will evaluate the rules and apply the formatting options as necessary.

       The following features are supported:

       •   User-defined formatting of first, last, even, and odd rows or columns.

       •   Conditional formatting, based on the contents of each cell.

       •   Sorting (on any column or combination of columns, with user defined sort-order).

       •   Pagination of the data set.

       •   Definition of "views", i.e. restriction of the set of columns shown.

       •   User-defined column captions.

       •   On-the-fly formatting and collating of the data.

       As an example, the code in the synopsis above yields the following HTML table (only visible in HTML):

       More       examples       can       be       found      on      the      author's      project      page:
       <a href="http://www.beyondcode.org/projects/dashboard/gallery.html">http://www.beyondcode.org/projects/dashboard/gallery.html</a>

       Please read the Rationale section below to understand the purpose of this module.

</pre><h4><b>PUBLIC</b> <b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
   <b>Constructor</b>
       HTML::Dashboard-&gt;<b>new()</b>
           Constructs a new dashboard object. By default, this generates an HTML  table  with  "border='1'"  and
           sets  the background color of all even rows to light grey (#eeeeee). These defaults can be overridden
           (cf. below).

   <b>Setting</b> <b>Data</b>
       $dash-&gt;set_data_without_captions( $data )
       $dash-&gt;set_data_with_captions( $data )
           Takes a <u>reference</u> to an array of <u>array</u> <u>references</u> of rows (i.e. a two-dimensional  array).  All  rows
           <u>must</u> contain the same number of columns.

           Use   "set_data_without_captions"   if   the   array   contains  only  data,  without  captions.  Use
           "set_data_with_captions" if the array contains captions in the first row (as  is  common,  e.g.,  for
           data  returned  from  database queries). Captions can be specified or overridden using "set_captions"
           (cf. below).

           The data set is only accessed by reference, i.e. it is <u>not</u> copied.  This should be  advantageous  for
           large  data sets, but will lead to strange results if the data set changes after having been set, but
           before any one of the output routines is called.

   <b>Output</b>
       $dash-&gt;<b>as_text()</b>
       $dash-&gt;as_text( $page )
           Returns the data as tab-delimited text string, after  content  formatters  (or  collaters),  sorting,
           views,  and  pagination  have  been  applied.  No other formatting directives (e.g. odd/even rows, or
           hi/med/low triggers) are applied. The string will include captions (if they have been set).

           In the resulting text string, columns are separated by  tabs  (\t),  rows  are  separated  by  single
           newlines  (\n). Tabs, newlines, and backslashes in the data are escaped through a preceding backslash
           (\).

       $dash-&gt;<b>as_HTML()</b>
       $dash-&gt;as_HTML( $page )
           Returns the data as a single HTML string. The  string  contains  an  HTML  table,  from  the  opening
           "&lt;table&gt;" to the closing "&lt;/table&gt;" tag.

           No  HTML-escaping  of  data  (i.e. of cell content) is performed. If required, specify an appropriate
           formatter for the data to perform any conversions.

       Both functions can be called with an optional integer argument. If no argument is supplied, all rows  are
       returned. If an integer argument in the range

         0 &lt;= $page &lt; $dash-&gt;pagecount()

       is  supplied, only the rows in the specified page (plus captions, if any) are returned. If a page outside
       the legal range is specified, a warning is emitted and all rows are returned.  (Do  not  forget  to  call
       "$dash-&gt;set_pagesize(...)"  before  using this feature. By default, the pagesize is set to infinity, i.e.
       all rows are returned.)

   <b>Captions,</b> <b>Pagination,</b> <b>Views,</b> <b>Sorting</b>
       $dash-&gt;set_captions( @captions )
       $array_ref = $dash-&gt;<b>get_captions()</b>
           Sets captions for the columns. The captions will be rendered on every page (if pagination  is  used),
           using "&lt;th&gt;" tags.  The number of captions provided <u>must</u> match the number of columns in the data.  If
           captions  have been set explicitly using this function, these captions will be used, even if the data
           itself  contains  captions  in  the  first   row   (i.e.   if   the   data   has   been   set   using
           "set_data_with_captions()").

       $dash-&gt;set_pagesize( $rows_per_page )
       $rows_per_page = $dash-&gt;<b>get_pagesize()</b>
       $pages = $dash-&gt;<b>get_pagecount()</b>
           Restricts  the  number  of  data rows per page (i.e. not counting captions).  Setting the pagesize to
           anything but a positive integer turns pagination <u>off</u>, so that all rows will be returned.

       $dash-&gt;set_view( @column_indices )
       $array_ref = $dash-&gt;<b>get_view()</b>
           The set of columns shown can be restricted using "set_view()". This function takes an array of column
           indices (0..$num_of_cols) to be shown.  Defaults to all columns.

       $dash-&gt;set_sort( sub { ... } )
           Sets a comparator routine which will be used to sort the rows before rendering them.  The  comparator
           routine will be given two rows (as array references) and must return "an integer less than, equal to,
           or  greater than 0", depending on how the rows are to be ordered (cf. Camel, entry on "sort"). Entire
           rows are passed to the comparator, before views (if any) are applied.

           <b>Note</b> <b>that</b> <b>the</b> <b>comparator</b> <b>will</b> <b>be</b> <b>called</b> <b>as</b> <b>a</b> <b>regular</b> <b>routine!</b> This implies  in  particular  that  the
           comparator  must parse @_ itself - arguments will not be passed through the "global" variables $a and
           $b as for the "sort" built-in.

           Example:

             $dash-&gt;set_sort( sub { my ( $x, $y ) = @_; $x-&gt;[0] &lt;=&gt; $y-&gt;[0] } )

           This sorts the rows numerically on the contents of the first column.

   <b>Formatting</b> <b>Options</b>
       There are three groups of formatting options:

       •   Options applied to plain HTML tags (i.e. the "&lt;table&gt;", "&lt;tr&gt;", "&lt;th&gt;", and "&lt;td&gt;" tags).

       •   Options to generate "striped reports" (i.e. tables, where the formatting is dependent on the row-  or
           column-index).

       •   Options which are only applied when a data-dependent condition is fulfilled.

       The last group is more complicated, because not only do the actual formatting options have to be set, but
       also the "trigger" and the range of table cells to which it is supposed to be applied.

       Formatting options can be set using three different ways:

       1.  Single argument: e.g. "$dash-&gt;set_table( "border='1'" )" or "$dash-&gt;set_first_row( 'red' )".

       2.  As  explicit  CSS  style  directive:  e.g.   "$dash-&gt;set_th(  style  =&gt;  'font-size:  x-large'  )" or
           "$dash-&gt;set_even_row( style =&gt; 'background-color: yellow' )".

       3.  By naming a CSS class: e.g.  "$dash-&gt;set_td( class =&gt; 'highlighted' )" or "$dash-&gt;set_even_col( class
           =&gt; 'evencol' )". (Obviously, the class set in this way should be defined in a  stylesheet  referenced
           by the HTML page containing the dashboard.)

       When  using  the  "style"  and  "class"  methods,  a  "style"  or  "class"  argument is included into the
       appropriate HTML tags, and set to the supplied value. Note that repeated calls  to  these  functions  are
       additive, <u>not</u> exclusive. In other words, the following two code samples are equivalent:

         $dash-&gt;set_even_row( style =&gt; 'background-color: yellow' );
         $dash-&gt;set_even_row( style =&gt; 'font-size: x-large' );

       is equivalent to:

         $dash-&gt;set_even_row( style =&gt; 'background-color: yellow; font-size: x-large' );

       (The  module  will  supply  semicolons  between  different style directives when merging the results from
       repeated calls.)

       To erase previous style directives, assign "undef" explicitly: "$dash-&gt;set_even_row( style =&gt; undef )".

       The single-argument version is intended as a short-cut and has a slightly different meaning, depending on
       the group of formatting option it is applied to. When applied to a direct HTML option  (i.e.   when  used
       with  "set_table()",  "set_tr()",  "set_th()", or "set_td()"), the argument is pasted unmodified into the
       corresponding HTML tag.  When used with any other option, the argument  is  interpreted  as  the  <u>desired</u>
       <u>background</u>  <u>color</u>  for  the  cell,  row,  or column. The specified background color will be applied as an
       explicit "style" argument, <u>not</u> as a "bgcolor" argument. In other words, the following calls are  (almost)
       equivalent:

         $dash-&gt;set_first_row( 'cyan' );
         $dash-&gt;set_first_row( style =&gt; 'background-color: cyan' );

       It  is  legal  to  set  conflicting  formatting  options  and will not prevent generation of HTML output.
       However, no guarantees are made about the appearance of the dashboard in the browser in this case.

       <b>In</b> <b>the</b> <b>following,</b> <b>"[format]"</b> <b>always</b> <b>stand</b> <b>for</b> <b>formatting</b> <b>options</b> <b>in</b> <b>any</b> <b>one</b> <b>of</b>  <b>the</b>  <b>three</b>  <b>legal</b>  <b>syntax</b>
       <b>variants</b> <b>as</b> <b>discussed</b> <b>above!</b>

       <u>General</u> <u>HTML</u> <u>Options</u>

       $dash-&gt;set_table( "[format]" )
       $dash-&gt;set_tr( "[format]" )
       $dash-&gt;set_th( "[format]" )
       $dash-&gt;set_td( "[format]" )
       $hash_ref = $dash-&gt;<b>get_table()</b>
       $hash_ref = $dash-&gt;<b>get_tr()</b>
       $hash_ref = $dash-&gt;<b>get_th()</b>
       $hash_ref = $dash-&gt;<b>get_td()</b>
           If  set,  these  options are always included into all tags. This is mostly useful to style the entire
           table, or cells in the header row.

       <u>Striped</u> <u>Reports</u>

       $dash-&gt;set_first_row( "[format]" )
       $dash-&gt;set_odd_row( "[format]" )
       $dash-&gt;set_even_row( "[format]" )
       $dash-&gt;set_last_row( "[format]" )
       $hash_ref = $dash-&gt;<b>get_first_row()</b>
       $hash_ref = $dash-&gt;<b>get_odd_row()</b>
       $hash_ref = $dash-&gt;<b>get_even_row()</b>
       $hash_ref = $dash-&gt;<b>get_last_row()</b>
       $dash-&gt;set_first_col( "[format]" )
       $dash-&gt;set_odd_col( "[format]" )
       $dash-&gt;set_even_col( "[format]" )
       $dash-&gt;set_last_col( "[format]" )
       $hash_ref = $dash-&gt;<b>get_first_col()</b>
       $hash_ref = $dash-&gt;<b>get_odd_col()</b>
       $hash_ref = $dash-&gt;<b>get_even_col()</b>
       $hash_ref = $dash-&gt;<b>get_last_col()</b>
           Options set with these functions are applied to rows or columns  as  appropriate.  Note  that  first,
           last, even, and odd is understood with reference to the page or the view, <u>not</u> the total data set.

           Options  for  first and last prevail over options for even and odd.  Options for columns prevail over
           options for rows.

       <u>Conditional</u> <u>Formatting</u> <u>(Triggers)</u>

       Formatting options in this group are only applied if  a  "trigger"  evaluates  to  true.  Therefore,  the
       functions below all take a function reference as argument, besides the actual formatting options.

       All  triggers  have  a "priority" from highest (hi), over intermediate (med) to lowest (low). If multiple
       triggers evaluate to true for a certain part of the dashboard (say, a cell),  then  only  the  formatting
       option with the highest priority is applied.

       The  intended  application  is to show whether a set of data is "in the green" or "in the red". Given the
       prioritization logic of the triggers, this can be easily achieved, without the need for exclusive  bounds
       or conditions across the set of triggers, using code like this:

         $dash-&gt;set_row_low( sub{ ...; $x &lt; 3  }, 'green' );
         $dash-&gt;set_row_med( sub{ ...; $x &lt; 7  }, 'yellow' );
         $dash-&gt;set_row_hi(  sub{ ...; $x &gt; 10 }, 'red' );

       $dash-&gt;set_row_hi(  sub{ my ( $row_ref ) = @_; ... }, "[format]" )
       $dash-&gt;set_row_med( sub{ my ( $row_ref ) = @_; ... }, "[format]" )
       $dash-&gt;set_row_low( sub{ my ( $row_ref ) = @_; ... }, "[format]" )
           If  the  triggers evaluates to true, the formatting option is applied to the entire row. The argument
           to the trigger is an array-ref to the current row. (Additional arguments: index of row in  page,  and
           index of row in data set.)

       $dash-&gt;set_col_hi(  $col, sub{ my ( $cell ) = @_; ... }, "[format]" )
       $dash-&gt;set_col_med( $col, sub{ my ( $cell ) = @_; ... }, "[format]" )
       $dash-&gt;set_col_low( $col, sub{ my ( $cell ) = @_; ... }, "[format]" )
           The  first argument to this function is the index of the column <u>in</u> <u>the</u> <u>data</u> <u>set</u> (not in the view!) to
           which the formatting should be applied.  If the triggers evaluates to true, the formatting option  is
           applied  to  all cells in the column. The argument to the trigger is the contents of the current cell
           in the specified column.(Additional arguments: the index in the view and in the data set.)

       $dash-&gt;set_cell_hi(  $col, sub{ my ( $cell ) = @_; ... }, "[format]" )
       $dash-&gt;set_cell_med( $col, sub{ my ( $cell ) = @_; ... }, "[format]" )
       $dash-&gt;set_cell_low( $col, sub{ my ( $cell ) = @_; ... }, "[format]" )
           The first argument to this function is the index of the column <u>in</u> <u>the</u> <u>data</u> <u>set</u> (not in the view!)  to
           which  the formatting should be applied.  If the triggers evaluates to true, the formatting option is
           applied to the current cell only. The argument to the trigger is the contents of the current cell  in
           the specified column.(Additional arguments: the index in the view and in the data set.)

       Options set with triggers are <u>merged</u> (do not clobber) with options set for first/last and even/odd. (This
       allows one to have a striped report, and use triggers to change the text color only.)

       Options  with  high  (hi) priority prevail over (clobber) options with intermediate (med) priority, which
       prevail over options with low priority.  Options for  cells  prevail  over  options  for  columns,  which
       prevail over options for rows.

   <b>Content</b> <b>Formatters</b>
       $dash-&gt;set_format( $column, sub { ... } )
       $dash-&gt;set_collate( $column, sub { ... } )
           If  set,  the  registered  function  is  called  for each row. Its output is used as contents for the
           current row's cell in the column with index $column.

           A formatter set with the first function is given the contents of the data in the current cell,  while
           a collater set with the second function is given the entire row (as array).

           Examples:

             $dash-&gt;set_format( 1, sub { my ( $x ) = @_; sprintf( "%.2f", $x ) } )
             $dash-&gt;set_collate( 1, sub { my ( $r ) = @_; $r[1] . ':' . $r[2] } )

</pre><h4><b>RATIONALE</b></h4><pre>
       It  was  important  to  me  to  define a module that would be easy to use, with reasonable defaults and a
       reasonably small API.

       In particular, I wanted a solution which would free the user entirely from  having  to  deal  with  (i.e.
       explicitly  loop  over)  individual  rows  and  cells.  Furthermore,  the user should not have to specify
       information that is already present in the data (such as the number of  rows  and  columns).  Finally,  I
       wanted  to  free  the  user  from  having to address individual cells (e.g. by their location) to provide
       formatting instructions.

       All this required a rule-based system --- you specify the high-level rules, the module  makes  sure  they
       are applied as necessary.

       Below are some further questions that have been asked --- with answers:

       Why  not just use CSS? Answer: All of this <u>is</u> done through CSS. The difficulty is deciding to which cells
       to apply the CSS style directives (if this is to be done in a data dependent manner).  This  module  does
       just that, by inserting the correct CSS "class" arguments into the appropriate cell tags (etc).

       Why not go with a templating solution? Answer: Templates establish the layout of a table from the outset,
       which  makes  it  hard to do cell-content-dependent formatting from within the template. And it is simply
       not convenient, and not in the spirit of the thing, to build templates with lots of conditional  code  in
       the  template.  (I  know,  having  used eg. "HTML::Template" quite extensively.) Given the data-dependent
       nature of the problem, the table must be built-up row by row and  cell  by  cell  individually,  applying
       triggers  and formatters as we go along.  This is what this module does --- and since we are already must
       touch each cell individually, we might as well print its HTML as we go along.   Using  templates  in  the
       implementation would not help.

       Why  not  use  Excel,  PDF,  or  what  have  you?  Because I want to deliver my reports via the web, so I
       specifically want HTML output. (Duh!)

       Why the name? Because I wanted something more specific and tangible than "FormattedReport" or some  such.
       The  name  points  to the source of the idea for this module: corporate metrics dashboards. What managers
       want to see are the key metrics of the business (sales, orders, what-have-you), with outliers highlighted
       to make it easy to see which metrics are "in the green" and which are "in the red".  This  module  allows
       you to do just that. (And more.)

</pre><h4><b>TO</b> <b>DO</b></h4><pre>
       Several ideas:

       •   Instead  of setting the actual data, it would be nice to set merely a query (and a DB handle) and let
           the dashboard pull its own data from the DB.

       •   When there are subsequent rows, which have identical entries in  some  columns  it  can  be  neat  to
           suppress   (leave   blank)   the   repeated   entries  (e.g.  "set_skip_repeats(  @skip_cols  )"  and
           "get_skip_repeats()").

       •   When setting data using an array-ref, it would be nice  to  specify  an  optional  integer  parameter
           $extend_by, which would extend the range of accessible columns. These new columns would be empty, but
           could  be  used  with "set_collate()" to build new column values on the fly. (This is never necessary
           when using a DB query, since one can always include constants in the "SELECT" clause.)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       I    maintain    a    "gallery"     of     examples     (with     code)     on     my     website     at:
       <a href="http://www.beyondcode.org/projects/dashboard/gallery.html">http://www.beyondcode.org/projects/dashboard/gallery.html</a>

       The module HTML::Tabulate seems close in intent to the present module and may be an alternative. (The API
       is much larger than the one for the present module and I am not entirely sure how it works.)

       Several  modules  provide very thin wrappers around the actual HTML of a table, they include HTML::Table,
       HTML::EasyTable, HTML::ElementTable.

       To generate tables directly from SQL queries, check out Class::DBI::Plugin::FilterOnClick.

</pre><h4><b>AUTHOR</b></h4><pre>
       Philipp K. Janert, &lt;janert at ieee dot org&gt;, <a href="http://www.beyondcode.org">http://www.beyondcode.org</a>

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2007 by Philipp K. Janert

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself, either Perl version 5.8.8 or, at your option, any later version of Perl 5 you may have available.

perl v5.36.0                                       2022-10-15                               <u>HTML::<a href="../man3pm/Dashboard.3pm.html">Dashboard</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>