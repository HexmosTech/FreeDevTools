<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>coroutine, yield, yieldto, coroinject, coroprobe - Create and produce values from coroutines</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       coroutine, yield, yieldto, coroinject, coroprobe - Create and produce values from coroutines

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>coroutine</b> <u>name</u> <u>command</u> ?<u>arg...</u>?

       <b>yield</b> ?<u>value</u>?
       <b>yieldto</b> <u>command</u> ?<u>arg...</u>?
       <u>name</u> ?<u>value...</u>?

       <b>coroinject</b> <u>coroName</u> <u>command</u> ?<u>arg...</u>?                                                                      2
       <b>coroprobe</b> <u>coroName</u> <u>command</u> ?<u>arg...</u>?                                                                       2
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>coroutine</b>  command creates a new coroutine context (with associated command) named <u>name</u> and executes
       that context by calling <u>command</u>, passing in the other remaining arguments without further interpretation.
       Once <u>command</u> returns normally or with an exception  (e.g.,  an  error)  the  coroutine  context  <u>name</u>  is
       deleted.

       Within  the  context,  values  may  be  generated  as  results by using the <b>yield</b> command; if no <u>value</u> is
       supplied, the empty string is used.  When that is called, the context  will  suspend  execution  and  the
       <b>coroutine</b>  command will return the argument to <b>yield</b>. The execution of the context can then be resumed by
       calling the context command, optionally passing in the <u>single</u> value to use as the  result  of  the  <b>yield</b>
       call  that  caused the context to be suspended. If the coroutine context never yields and instead returns
       conventionally, the result of the <b>coroutine</b> command will be the result of the evaluation of the context.

       The coroutine may also suspend its execution by use of the <b>yieldto</b> command, which instead  of  returning,
       cedes  execution  to  some command called <u>command</u> (resolved in the context of the coroutine) and to which
       <u>any</u> <u>number</u> of arguments may be passed. Since every coroutine has a context command, <b>yieldto</b> can  be  used
       to  transfer control directly from one coroutine to another (this is only advisable if the two coroutines
       are expecting this to happen) but <u>any</u> command may be the target. If a  coroutine  is  suspended  by  this
       mechanism,  the  coroutine processing can be resumed by calling the context command optionally passing in
       an arbitrary number of arguments. The return value of the <b>yieldto</b> call will  be  the  list  of  arguments
       passed to the context command; it is up to the caller to decide what to do with those values.

       The  recommended  way  of writing a version of <b>yield</b> that allows resumption with multiple arguments is by
       using <b>yieldto</b> and the <b>return</b> command, like this:

              proc yieldMultiple {value} {
                  tailcall <b>yieldto</b> string cat $value
              }

       The coroutine can also be deleted by destroying the command <u>name</u>, and the name of the  current  coroutine
       can  be  retrieved by using <b>info</b> <b>coroutine</b>.  If there are deletion traces on variables in the coroutine's
       implementation, they will fire at the point when the coroutine is explicitly deleted (or,  naturally,  if
       the command returns conventionally).

       At the point when <u>command</u> is called, the current namespace will be the global namespace and there will be
       no  stack  frames  above  it  (in the sense of <b>upvar</b> and <b>uplevel</b>). However, which command to call will be
       determined in the namespace that the <b>coroutine</b> command was called from.

       A suspended coroutine (i.e., one that has  <b>yield</b>ed  or  <b>yieldto</b>-d)  may  have  its  state  inspected  (or 2
       modified)  at  that point by using <b>coroprobe</b> to run a command at the point where the coroutine is at. The 2
       command takes the name of the coroutine to run the command in, <u>coroName</u>, and the name of a  command  (any 2
       any  arguments it requires) to immediately run at that point. The result of that command is the result of 2
       the <b>coroprobe</b> command, and the gross state of the  coroutine  remains  the  same  afterwards  (i.e.,  the 2
       coroutine  is still expecting the results of a <b>yield</b> or <b>yieldto</b> as before) though variables may have been 2
       changed.                                                                                                  2

       Similarly, the <b>coroinject</b> command may be used to place a command to be run inside a  suspended  coroutine 2
       (when  it  is  resumed)  to process arguments, with quite a bit of similarity to <b>coroprobe</b>. However, with 2
       <b>coroinject</b> there are several key differences:

       •      The coroutine is not immediately resumed after the injection has been done.  A consequence of this 2
              is that multiple injections may be done before the coroutine is resumed. The injected commands are 2
              performed in <u>reverse</u> <u>order</u> <u>of</u> <u>definition</u> (that is, they are internally stored on a stack).

       •      An additional two arguments are appended to the list of arguments to be run (that is, the  <u>command</u> 2
              and  its  <u>args</u> are extended by two elements).  The first is the name of the command that suspended 2
              the coroutine (<b>yield</b> or <b>yieldto</b>), and the second is the argument (or list  of  arguments,  in  the 2
              case of <b>yieldto</b>) that is the current resumption value.

       •      The  result  of the injected command is used as the result of the <b>yield</b> or <b>yieldto</b> that caused the 2
              coroutine to become suspended. Where there are multiple  injected  commands,  the  result  of  one 2
              becomes the resumption value processed by the next.                                                2

       The injection is a one-off. It is not retained once it has been executed. It may <b>yield</b> or <b>yieldto</b> as part 2
       of its execution.                                                                                         2

       Note  that  running  coroutines may be neither probed nor injected; the operations may only be applied to 2
       coroutines that are suspended. (If a coroutine is running then any introspection  code  would  be  merely 2
       inspecting  the  state  of  where  it  is currently running; <b>coroinject</b>/<b>coroprobe</b> are unnecessary in that 2
       case.)

</pre><h4><b>EXAMPLES</b></h4><pre>
       This example shows a coroutine that will produce an infinite sequence of even values,  and  a  loop  that
       consumes the first ten of them.

              proc allNumbers {} {
                  <b>yield</b>
                  set i 0
                  while 1 {
                      <b>yield</b> $i
                      incr i 2
                  }
              }
              <b>coroutine</b> nextNumber allNumbers
              for {set i 0} {$i &lt; 10} {incr i} {
                  puts "received [<u>nextNumber</u>]"
              }
              rename nextNumber {}

       In this example, the coroutine acts to add up the arguments passed to it.

              <b>coroutine</b> accumulator apply {{} {
                  set x 0
                  while 1 {
                      incr x [<b>yield</b> $x]
                  }
              }}
              for {set i 0} {$i &lt; 10} {incr i} {
                  puts "$i -&gt; [<u>accumulator</u> $i]"
              }

       This  example demonstrates the use of coroutines to implement the classic Sieve of Eratosthenes algorithm
       for finding prime numbers. Note the creation of coroutines inside a coroutine.

              proc filterByFactor {source n} {
                  <b>yield</b> [info coroutine]
                  while 1 {
                      set x [<u>$source</u>]
                      if {$x % $n} {
                          <b>yield</b> $x
                      }
                  }
              }
              <b>coroutine</b> allNumbers apply {{} {while 1 {<b>yield</b> [incr x]}}}
              <b>coroutine</b> eratosthenes apply {c {
                  <b>yield</b>
                  while 1 {
                      set n [<u>$c</u>]
                      <b>yield</b> $n
                      set c [<b>coroutine</b> prime$n filterByFactor $c $n]
                  }
              }} allNumbers
              for {set i 1} {$i &lt;= 20} {incr i} {
                  puts "prime#$i = [<u>eratosthenes</u>]"
              }

       This example shows how a value can be passed around a group of three coroutines that yield to each other:

              proc juggler {name target {value ""}} {
                  if {$value eq ""} {
                      set value [<b>yield</b> [info coroutine]]
                  }
                  while {$value ne ""} {
                      puts "$name : $value"
                      set value [string range $value 0 end-1]
                      lassign [<b>yieldto</b> <u>$target</u> $value] value
                  }
              }
              <b>coroutine</b> j1 juggler Larry [
                  <b>coroutine</b> j2 juggler Curly [
                      <b>coroutine</b> j3 juggler Moe j1]] "Nyuck!Nyuck!Nyuck!"

       This example shows a simple coroutine that collects non-empty values and returns a list of them when  not 2
       given  an  argument. It also shows how we can look inside the coroutine to find out what it is doing, and 2
       how we can modify the input on a one-off basis.                                                           2

              proc collectorImpl {} {                                                                            2
                  set me [info coroutine]                                                                        2
                  set accumulator {}                                                                             2
                  for {set val [<b>yield</b> $me]} {$val ne ""} {set val [<b>yield</b>]} {                                     2
                      lappend accumulator $val                                                                   2
                  }                                                                                              2
                  return $accumulator                                                                            2
              }                                                                                                  2

              <b>coroutine</b> collect collectorImpl                                                                    2
              <u>collect</u> 123                                                                                        2
              <u>collect</u> "abc def"                                                                                  2
              <u>collect</u> 456                                                                                        2

              puts [<b>coroprobe</b> <u>collect</u> set accumulator]                                                           2
              # ==&gt; 123 {abc def} 456                                                                            2

              <u>collect</u> "pqr"                                                                                      2

              <b>coroinject</b> <u>collect</u> apply {{type value} {                                                           2
                  puts "Received '$value' at a $type in [info coroutine]"                                        2
                  return [string toupper $value]                                                                 2
              }}                                                                                                 2

              <u>collect</u> rst                                                                                        2
              # ==&gt; Received 'rst' at a yield in ::collect                                                       2
              <u>collect</u> xyz                                                                                        2

              puts [<u>collect</u>]                                                                                     2
              # ==&gt; 123 {abc def} 456 pqr RST xyz                                                                2

   <b>DETAILED</b> <b>SEMANTICS</b>
       This example demonstrates that coroutines start from the global namespace, and  that  <u>command</u>  resolution
       happens before the coroutine stack is created.

              proc report {where level} {
                  # Where was the caller called from?
                  set ns [uplevel 2 {namespace current}]
                  <b>yield</b> "made $where $level context=$ns name=[info coroutine]"
              }
              proc example {} {
                  report outer [info level]
              }
              namespace eval demo {
                  proc example {} {
                      report inner [info level]
                  }
                  proc makeExample {} {
                      puts "making from [info level]"
                      puts [<b>coroutine</b> coroEg example]
                  }
                  makeExample
              }

       Which  produces  the  output  below.  In  particular,  we  can  see  that stack manipulation has occurred
       (comparing the levels from the first and second line) and that the parent level in the coroutine  is  the
       global  namespace.  We  can  also  see  that  coroutine  names  are local to the current namespace if not
       qualified, and that coroutines may yield at depth (e.g., in called procedures).

              making from 2
              made inner 1 context=:: name=::demo::coroEg

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/apply.3tcl.html">apply</a>(3tcl), <a href="../man3tcl/info.3tcl.html">info</a>(3tcl), <a href="../man3tcl/proc.3tcl.html">proc</a>(3tcl), <a href="../man3tcl/return.3tcl.html">return</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       coroutine, generator

Tcl                                                    8.6                                       <u><a href="../man3tcl/coroutine.3tcl.html">coroutine</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>