<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::Arg - A singleton class interfacing command line arguments</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::Arg - A singleton class interfacing command line arguments

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/arg&gt;</b>
       Linking option: <u>-lbobcat</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Singleton class (see Gamma <u>et</u> <u>al.</u>, 1995) built around <b>getopt_long()</b>(3). The class handles short- and long
       command-line options,

       <b>NOTE:</b> since <b>bobcat</b> version 6.07.00 <b>FBB::Arg::Type::None</b> was renamed to <b>FBB::Arg::Type::NoArg</b>.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All  constructors,  members,  operators  and manipulators, mentioned in this man-page, are defined in the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       -

</pre><h4><b>ENUMERATION</b></h4><pre>
       The <b>FBB::Arg::Type</b> enumeration is defined by the <b>FBB::Arg</b> class. It is used to  specify  whether  or  not
       long options require arguments. It defines the following values: <b>NoArg,</b> <b>Required,</b> <b>Optional</b>.

       o      <b>NoArg</b>: the long option does not use an argument;

       o      <b>Required</b>: the long option requires an argument value;

       o      <b>Optional</b>: the long option may optionally be provided with  an argument value;

       These  values  are  used when defining long options (like <u>--version</u>), which are defined as objects of the
       (nested) class <b>FBB::Arg::LongOption</b>.

</pre><h4><b>THE</b> <b>NESTED</b> <b>CLASS</b> <b>FBB::Arg::LongOption</b></h4><pre>
       Long options are defined using objects of the nested class <b>FBB::Arg::LongOption</b>. This class provides  the
       following constructors:

       o      <b>FBB::Arg::LongOption(char</b> <b>const</b> <b>*name,</b> <b>FBB::Arg::Type</b> <b>type</b> <b>=</b> <b>FBB::Arg::NoArg)</b>:
              This  constructor  is  used  to  define  a  long option for which no corresponding short option is
              defined. The parameter <u>name</u> is the name of the long option (without specifying the  --  characters
              which are only required when specifying a long option when calling a program).

       o      <b>FBB::Arg::LongOption(char</b> <b>const</b> <b>*name,</b> <b>int</b> <b>optionChar)</b>:
              This  constructor  is  used  to  define  a  long  option for which a corresponding short option is
              defined. The parameter <u>name</u> is the name of the long option (without specifying the  --  characters
              which are only required when specifying a long option when calling a program).

       To define long options use the following procedure:

       o      First, construct an array

                  FBB::Arg::LongOption longOptions[] = { c1, c2, ..., cn };

              Where <u>c1,</u> <u>c2,</u> <u>...,</u> <u>cn</u> are <u>n</u> constructor invocations of <b>FBB::Arg::LongOption()</b> constructors

       o      Next,  pass  <u>longOptions,</u>  <u>LongOptions</u> <u>+</u> <u>n</u> as arguments to an <u>Arg::initialize</u> member that supports
              long options.

       Objects of the class <u>LongOptions</u> are normally used internally by the <u>Arg</u> object, but  they  can  also  be
       used outside of the <u>Arg</u> object. For that situation the following members are available:

       o      <b>std::string</b> <b>const</b> <b>&amp;longName()</b> <b>const</b>:
              returns the <u>LongOption’s</u> long option name;

       o      <b>int</b> <b>optionChar()</b> <b>const</b>:
              returns  the <u>LongOption’s</u> option character (or one of the <u>Arg::Type</u> enumeration values if there is
              no option character associated with the <u>LongOption</u>).

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       Since the class <u>Arg</u> is a <u>singleton</u>  there  are  no  public  constructors.  Instead,  static  members  are
       available to initialize and to access the single <b>FBB::Arg</b> object.

</pre><h4><b>STATIC</b> <b>MEMBERS</b></h4><pre>
       All  <u>initialize</u>  members  initialize the <b>FBB::Arg</b> singleton, and can only be called once. An exception is
       thrown when called multiple times. All <u>initialize</u> members return  a  reference  to  the  initialized  <u>Arg</u>
       singleton object.

       All  <u>initialize</u> members define the parameters <u>argc</u> and <u>argv</u> which are interpreted as <u>main’s</u> <u>argc</u> and <u>argv</u>
       parameters.  When an <u>argv</u> element points to two consecutive dashes (<u>--</u>) then that element is ignored, and
       all of <u>argv’s</u> subsequent elements are considered arguments instead of options.

       o      <b>FBB::Arg</b> <b>&amp;Arg::initialize(char</b> <b>const</b> <b>*optstring,</b> <b>int</b> <b>argc,</b> <b>char</b> <b>**argv)</b>:
              The parameter <u>optstring</u> is a null-terminated byte string  (NTBS)  optionally  starting  with  a  +
              character,  but  otherwise  containing  option  characters.  One or two colons may be postfixed to
              option characters:

              o      a single colon (:) indicates that the option requires an option value.

              o      a double colon (::) indicates that the option has an optional argument. With short  options
                     the  option  value  is  considered  absent unless it is attached to the short option (e.g.,
                     <u>-tvalue</u>). Long options optionally accepting arguments should always immediately be followed
                     by an assignment character (=), immediately followed by  the  option’s  value  (which  must
                     start  with  a  non-blank  character).  E.g.,  <u>--value=</u>  indicates  an absent option value,
                     <u>--value=text</u> indicates the option’s value equals <u>text</u>.  If an option value itself  contains
                     blanks,  it  must  be  surrounded  by  single  or  double  quotes (e.g., <u>-t’this</u> <u>value’</u>, or
                     <u>--text=’this</u> <u>value’</u>). The surrounding quotes are not part of the option’s value.

              When <u>optstring’s</u> first character is + then all non-specified  options  are  considered  arguments,
              appearing in the final arguments list at their current argument positions. E.g., when <u>optstring</u> is
              <u>+ab</u> and no long options are defined, then calling

                  prog -a -z -b -yvalue --long arg1 arg2

              results  in  the member <u>argv</u> returning a vector containing the elements <u>-z,</u> <u>-yvalue,</u> <u>--long,</u> <u>arg1,</u>
              and <u>arg2</u>. If <u>optstring’s</u> first character isn’t + and an undefined option is  encountered  then  an
              exception is thrown.

       o      <b>FBB::Arg</b> <b>&amp;Arg::initialize(int</b> <b>accept,</b> <b>char</b> <b>const</b> <b>*optstring,</b> <b>int</b> <b>argc,</b> <b>char</b> <b>**argv)</b>:
              Acts  like  the previous member, but in addition defines the parameter <u>accept</u> specifying an option
              character from where all subsequent arguments and options  are  considered  arguments.  To  ignore
              <u>accept</u>  the  value 0 (not the character ’0’) can be specified or an <u>initialize</u> members can be used
              that does not define an <u>accept</u> parameter.

              When arguments contain both an <u>accept</u> option and two consecutive dashes  then  the  first  one  is
              interpreted,  resulting  in  all  remaining <u>argv</u> elements being interpreted as mere arguments. For
              example, when specifying <u>initialize(’t’,</u> <u>...)</u> and calling

                  prog one -ttwo -c -- three

              then the member <u>argv</u> returns a vector containing the elements <u>one,</u> <u>-tttwo,</u> <u>-c,</u> <u>--</u>, and <u>three</u>  (see
              also the member <u>beyondDashes</u> below).

       o      <b>FBB::Arg</b>   <b>&amp;Arg::initialize(char</b>   <b>const</b>   <b>*optstring,</b>   <b>Arg::LongOption</b>   <b>const</b>   <b>*const</b>   <b>begin,</b>
              <b>Arg::LongOption</b> <b>const</b> <b>*const</b> <b>end,</b> <b>int</b> <b>argc,</b> <b>char</b> <b>**argv)</b>:

              Acts like the first <u>Arg::initialize</u> member, but in addition defines two parameters specifying  the
              range  of  elements  of an array of <u>Arg::LongOption</u> objects specifying long options. The parameter
              <u>begin</u> points to the first element of the range, the parameter <u>end</u>  points  just  beyond  the  last
              element of the range. E.g., after defining

                  FBB::Arg::LongOption longOptions[] = { c1, c2, ..., cn };

              the arguments passed to <u>begin</u> and <u>end</u> could be specified as

                  initialize(..., longOptions, longOptions + size(longOptions), ...);

       o      <b>FBB::Arg</b>  <b>&amp;Arg::initialize(char</b>  <b>accept,</b>  <b>char</b>  <b>const</b>  <b>*optstring,</b>  <b>LongOption</b> <b>const</b> <b>*const</b> <b>begin,</b>
              <b>LongOption</b> <b>const</b> <b>*const</b> <b>end,</b> <b>int</b> <b>argc,</b> <b>char</b> <b>**argv)</b>:

              Acts like the previous <u>Arg::initialize</u> member, but in addition  defines  an  <u>accept</u>  parameter  as
              defined by the second <u>Arg::initialize</u> member.

       o      <b>FBB::Arg</b> <b>&amp;Arg::instance()</b>:
              Once  an  <u>Arg::initialize</u>  member  has  been called this member can be called from anywhere in the
              program (and it can be called multiple times),  returning  a  reference  to  the  initialized  <b>Arg</b>
              object.

              If it is called before an <u>Arg::initialize</u> member has been called an exception is thrown.

</pre><h4><b>OVERLOADED</b> <b>OPERATOR</b></h4><pre>
       o      <b>char</b> <b>const</b> <b>*operator[](size_t</b> <b>idx)</b> <b>const</b>:
              Returns  <u>argument[idx]</u>,  after  all  options  have  been  removed.   It  returns 0 if no <u>arg[x]</u> is
              available.  The program’s name (<u>argv[0]</u>) is  NOT  counted  here:  index  0  refers  to  the  first
              ARGUMENT, e.g., the program’s <u>argv[1]</u>.

</pre><h4><b>NON-STATIC</b> <b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       o      <b>string</b> <b>const</b> <b>&amp;argv0()</b> <b>const</b>:
              Returns the program’s name as specified by <u>argv[0]</u> (see also the member <u>basename</u>);

       o      <b>char</b> <b>const</b> <b>**argPointers()</b> <b>const</b>:
              Returns  <u>argv</u>-like set of pointers to all remaining arguments. Element <u>nArgs()</u> <u>+</u> <u>1</u> is a 0-pointer.
              The first <u>nArgs()</u> elements point to the respective values of the NTBS arguments that  were  passed
              to the program, after having removed the options.

              The  caller  is  responsible  for  returning  the array of pointers returned by this member to the
              common pool, but the caller should not delete the NTBSs to which the pointers point as illustrated
              by the following two statements:

                  char const **ptr = Arg::instance().argPointers();
                  delete[] ptr;   // don’t delete ptr[idx] elements!

       o      <b>std::vector&lt;std::string&gt;</b> <b>const</b> <b>&amp;args()</b> <b>const</b>:
              Returns a vector of strings containing all  arguments  after  having  removed  all  options.   The
              program’s  name  (<u>argv[0]</u>)  is  NOT included here: its first element refers to the first ARGUMENT,
              e.g., the program’s <u>argv[1]</u>;

       o      <b>std::string</b> <b>const</b> <b>&amp;basename()</b> <b>const</b>:
              Returns the program’s basename (i.e., <u>argv0()’s</u> value beyond the last directory separator);

       o      <b>std::vector&lt;std::string&gt;::const_iterator</b> <b>begin()</b> <b>const</b>:
              Returns the iterator to the program’s first  argument  (i.e.,  <u>args().begin()</u>).  This  member,  in
              combination with the member <u>end</u>, allows processing of all arguments by generic algorithms;

       o      <b>size_t</b> <b>beyondDashes()</b> <b>const</b>:
              Returns  the index of the first argument beyond the <u>--</u> argument or returns the index of the <u>accept</u>
              argument (whichever comes first) or returns <u>nArgs()</u> if no <u>--</u> or <u>accept</u> argument  was  encountered.
              See also the member <u>nArgs</u> below;

       o      <b>std::vector&lt;std::string&gt;::const_iterator</b> <b>end()</b> <b>const</b>:
              Returns  the  iterator  pointing  beyond  the  program’s  last argument (i.e., <u>args().end()</u>). This
              member, in combination with the member <u>begin</u>,  allows  processing  of  all  arguments  by  generic
              algorithms;

       o      <b>void</b> <b>help()</b> <b>const</b>:
              If  the  member  <u>versionHelp</u> (see below) was called then this member calls the <u>usage</u> function that
              was passed to <u>versionHelp</u>. If <u>versionHelp</u> has not been called (i.e., if no <u>usage</u> function has been
              specified) an exception is thrown;

       o      <b>size_t</b> <b>nArgs()</b> <b>const</b>:
              Returns the number of arguments after having removed the options (i.e., it returns <u>args().size()</u>).
              Note that the program’s name is not counted here;

       o      <b>size_t</b> <b>nLongOptions()</b> <b>const</b>:
              Returns the number of long options not having short  option  synonyms.   Multiply  specified  long
              options are each counted;

       o      <b>size_t</b> <b>nOptions()</b> <b>const</b>:
              Returns  the  number  of  specified  single  character  options. If short options have long option
              synonyms, then these long option synonyms  are  counted  as  if  they  were  specified  as  single
              character  options.  If  single  character  options  (or  their long option synonyms) are multiply
              specified, then each specification is separately counted;

       o      <b>size_t</b> <b>option(int</b> <b>option)</b> <b>const</b>:
              Returns the number of times `option’ was specified (or its long option synonym, if defined);

       o      <b>size_t</b> <b>option(std::string</b> <b>const</b> <b>&amp;options)</b> <b>const</b>:
              Returns the number of times each of the options specified in the `option’ argument were  specified
              (or   their   long  option  synonyms).  Note  that  each  character  in  <u>options</u>  must  specify  a
              single-character option;

       o      <b>size_t</b> <b>option(string</b> <b>*value,</b> <b>int</b> <b>option)</b> <b>const</b>:
              Returns the number of times the provided option (or its long option synonym) was present.  If  the
              return  value  is  non-zero  then  the  value  of the first occurrence of this option is stored in
              <u>*value</u>, which is left  untouched  if  `option’  was  not  present.  The  parameter  <u>value</u>  may  be
              initialized  to  0  if  the  option  does  not have a value or if the option’s value should not be
              stored;

       o      <b>size_t</b> <b>option(size_t</b> <b>idx,</b> <b>string</b> <b>*value,</b> <b>int</b> <b>option)</b> <b>const</b>:
              Returns the number of times the provided option (or its long option synonym) was present.  If  the
              return value is non-zero then the value of the <u>idx</u>th occurrence (0-based offset) of this option is
              stored  in <u>*value</u>, which is left untouched if `option’ was not present or if <u>idx</u> is or exceeds the
              number of specifications of the provided option. 0 may be specified for <b>value</b> if the  option  does
              not have a value or if the value should not be stored;

       o      <b>size_t</b> <b>option(size_t</b> <b>*idx,</b> <b>string</b> <b>*value,</b> <b>int</b> <b>option)</b> <b>const</b>:
              Returns  the  number of times the provided option (or its long option synonym) was present. If the
              return value is non-zero then the offset (within the series of <u>option</u> specifications) of the first
              option having a non-empty option value is returned in <u>*idx</u>, while its option value  is  stored  in
              <u>*value</u>.  Both  <u>*value</u>  and <u>*idx</u> are left untouched if `option’ was not present. 0 may be specified
              for <b>value</b> if the option does not have a value or if the value should not be stored;

       o      <b>size_t</b> <b>option(string</b> <b>*value,</b> <b>char</b> <b>const</b> <b>*longOption)</b> <b>const</b>:
              Returns the number of times the specified long option (not having a single-character synonym)  was
              present.  Its  value  is then stored in <u>*value</u>, which is left untouched if the long option was not
              present. 0 may be specified for <b>value</b> if the option does not have a value or if the  value  should
              not be stored;

       o      <b>size_t</b> <b>option(size_t</b> <b>idx,</b> <b>string</b> <b>*value,</b> <b>char</b> <b>const</b> <b>*</b> <b>longOption)</b> <b>const</b>:
              Returns  the  number of times the provided long option (not having a single-character synonym) was
              present. If the return value is non-zero then the value of the <u>idx</u>th occurrence  (0-based  offset)
              of  this  long  option  is  stored  in  <u>*value</u>, which is left untouched if the long option was not
              present or if <u>idx</u> is or exceeds the number of specifications of the provided long option. 0 may be
              specified for <b>value</b> if the long option does not have a value or if the value should not be stored;

       o      <b>size_t</b> <b>option(size_t</b> <b>*idx,</b> <b>string</b> <b>*value,</b> <b>int</b> <b>longOption)</b> <b>const</b>:
              Returns the number of times the provided long option (not having a single-character  synonym)  was
              present.  If  the  return value is non-zero then the offset (within the series of this long option
              specifications) of the first long option having a non-empty option  value  is  returned  in  <u>*idx</u>,
              while its option value is stored in <u>*value</u>. Both <u>*value</u> and <u>*idx</u> are left untouched if long option
              was  not  present. 0 may be specified for <b>value</b> if the long option does not have a value or if the
              value should not be stored;

       o      <b>void</b> <b>versionHelp(void</b> <b>(*usage)(std::string</b> <b>const</b> <b>&amp;progname),</b> <b>char</b> <b>const</b> <b>*version,</b> <b>size_t</b>  <b>minArgs,</b>
              <b>int</b> <b>helpFlag</b> <b>=</b> <b>’h’,</b> <b>int</b> <b>versionFlag</b> <b>=</b> <b>’v’)</b> <b>const</b>:
              If  the  <u>helpFlag</u>  was specified <u>usage()</u> is called with argument <b>basename()</b> whereafter the program
              throws <u>int</u> <u>0</u>.

              If <u>versionFlag</u> was specified the program’s name (using basename()) and  version  is  displayed  to
              <u>std::cout</u> whereafter the program throws <u>int</u> <u>0</u>.

              If  there  are  fewer  arguments  than  <u>minArgs</u> <u>usage()</u> is called with argument <b>basename()</b> and the
              program ends with exit value 1.

              Note that <u>versionhelp</u> compares <u>minArgs</u> against <u>nArgs</u>. If <u>minArgs</u> should be compaired  against  the
              number  of  arguments  up to a possible `--’ argument (i.e., <u>beyondDashes</u>’ return value), then add
              <u>nArgs()</u> <u>-</u> <u>beyondDashes()</u> to the <u>minArg</u> argument. E.g.,

                  arg.versionHelp(usage, version, 2 + arg.nArgs()
                                                    - arg.beyondDashes());

              The address of the <u>usage()</u> function, the current version and the minimum number of arguments  must
              be specified. Default argument values are provided for the option flags.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The  following  example  illustrates  defining  long  options  and  shows  an initialization. It is not a
       full-fledched example in the sense of a small runnable program.

       #include &lt;bobcat/arg&gt;

       using namespace FBB;
       using namespace std;

       namespace   // the anonymous namespace can be used here
       {
           Arg::LongOption longOptions[] =
           {
               Arg::LongOption{"debug"},
               Arg::LongOption{"filenames", ’f’},
               Arg::LongOption{"help", ’h’},
               Arg::LongOption{"version", ’v’},
           };
           auto longEnd = longOptions + size(longOptions);
       }

       int main(int argc, char **argv)
       try
       {
           Arg &amp;arg = Arg::initialize("df:hv",
                           longOptions, longEnd,
                           argc, argv);

           // code using arg, etc.
       }
       catch (exception const &amp;err)     // handle exceptions
       {
           cerr &lt;&lt; err.what() &lt;&lt; ’\n’;
           return 1;
       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/arg</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7)

</pre><h4><b>BUGS</b></h4><pre>
       None Reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>: debian package containing the static library, headers, manual pages, and  developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                                  <u>FBB::<a href="../man3bobcat/Arg.3bobcat.html">Arg</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>