<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FormValidator::Simple - validation with simple chains of constraints</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libformvalidator-simple-perl">libformvalidator-simple-perl_0.29-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FormValidator::Simple - validation with simple chains of constraints

</pre><h4><b>SYNOPSIS</b></h4><pre>
           my $query = CGI-&gt;new;
           $query-&gt;param( param1 =&gt; 'ABCD' );
           $query-&gt;param( param2 =&gt;  12345 );
           $query-&gt;param( mail1  =&gt; '<a href="mailto:lyo.kato@gmail.com">lyo.kato@gmail.com</a>' );
           $query-&gt;param( mail2  =&gt; '<a href="mailto:lyo.kato@gmail.com">lyo.kato@gmail.com</a>' );
           $query-&gt;param( year   =&gt; 2005 );
           $query-&gt;param( month  =&gt;   11 );
           $query-&gt;param( day    =&gt;   27 );

           my $result = FormValidator::Simple-&gt;check( $query =&gt; [
               param1 =&gt; ['NOT_BLANK', 'ASCII', ['LENGTH', 2, 5]],
               param2 =&gt; ['NOT_BLANK', 'INT'  ],
               mail1  =&gt; ['NOT_BLANK', 'EMAIL_LOOSE'],
               mail2  =&gt; ['NOT_BLANK', 'EMAIL_LOOSE'],
               { mails =&gt; ['mail1', 'mail2'       ] } =&gt; ['DUPLICATION'],
               { date  =&gt; ['year',  'month', 'day'] } =&gt; ['DATE'],
           ] );

           if ( $result-&gt;has_error ) {
               my $tt = Template-&gt;new({ INCLUDE_PATH =&gt; './tmpl' });
               $tt-&gt;process('template.html', { result =&gt; $result });
           }

       template example

           [% IF result.has_error %]
           &lt;p&gt;Found Input Error&lt;/p&gt;
           &lt;ul&gt;

               [% IF result.missing('param1') %]
               &lt;li&gt;param1 is blank.&lt;/li&gt;
               [% END %]

               [% IF result.invalid('param1') %]
               &lt;li&gt;param1 is invalid.&lt;/li&gt;
               [% END %]

               [% IF result.invalid('param1', 'ASCII') %]
               &lt;li&gt;param1 needs ascii code.&lt;/li&gt;
               [% END %]

               [% IF result.invalid('param1', 'LENGTH') %]
               &lt;li&gt;input into param1 with characters that's length should be between two and five. &lt;/li&gt;
               [% END %]

           &lt;/ul&gt;
           [% END %]

       example2

           [% IF result.has_error %]
           &lt;ul&gt;
               [% FOREACH key IN result.error %]
                   [% FOREACH type IN result.error(key) %]
                   &lt;li&gt;invalid: [% key %] - [% type %]&lt;/li&gt;
                   [% END %]
               [% END %]
           &lt;/ul&gt;
           [% END %]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides you a sweet way of form data validation with simple constraints chains.  You can
       write constraints on single line for each input data.

       This idea is based on Sledge::Plugin::Validator, and most of validation code is borrowed from this
       plugin.

       (Sledge is a MVC web application framework: <a href="http://sl.edge.jp">http://sl.edge.jp</a> [Japanese] )

       The result object this module returns behaves like Data::FormValidator::Results.

</pre><h4><b>HOW</b> <b>TO</b> <b>SET</b> <b>PROFILE</b></h4><pre>
           FormValidator::Simple-&gt;check( $q =&gt; [
               #profile
           ] );

       Use 'check' method.

       A hash reference includes input data, or an object of some class that has a method named 'param', for
       example CGI, is needed as first argument.

       And set profile as array reference into second argument. Profile consists of some pairs of input data and
       constraints.

           my $q = CGI-&gt;new;
           $q-&gt;param( param1 =&gt; 'hoge' );

           FormValidator::Simple-&gt;check( $q =&gt; [
               param1 =&gt; [ ['NOT_BLANK'], ['LENGTH', 4, 10] ],
           ] );

       In this case, param1 is the name of a form element. and the array ref "[ ['NOT_BLANK']... ]" is a
       constraints chain.

       Write constraints chain as arrayref, and you can set some constraints into it. In the last example, two
       constraints 'NOT_BLANK', and 'LENGTH' are set. Each constraints is should be set as arrayref, but in case
       the constraint has no argument, it can be written as scalar text.

           FormValidator::Simple-&gt;check( $q =&gt; [
               param1 =&gt; [ 'NOT_BLANK', ['LENGTH', 4, 10] ],
           ] );

       Now, in this sample 'NOT_BLANK' constraint is not an arrayref, but 'LENGTH' isn't. Because 'LENGTH' has
       two arguments, 4 and 10.

   <b>MULTIPLE</b> <b>DATA</b> <b>VALIDATION</b>
       When you want to check about multiple input data, do like this.

           my $q = CGI-&gt;new;
           $q-&gt;param( mail1 =&gt; '<a href="mailto:lyo.kato@gmail.com">lyo.kato@gmail.com</a>' );
           $q-&gt;param( mail2 =&gt; '<a href="mailto:lyo.kato@gmail.com">lyo.kato@gmail.com</a>' );

           my $result = FormValidator::Simple-&gt;check( $q =&gt; [
               { mails =&gt; ['mail1', 'mail2'] } =&gt; [ 'DUPLICATION' ],
           ] )

           [% IF result.invalid('mails') %]
           &lt;p&gt;mail1 and mail2 aren't same.&lt;/p&gt;
           [% END %]

       and here's an another example.

           my $q = CGI-&gt;new;
           $q-&gt;param( year  =&gt; 2005 );
           $q-&gt;param( month =&gt;   12 );
           $q-&gt;param(   day =&gt;   27 );

           my $result = FormValidator::Simple-&gt;check( $q =&gt; [
               { date =&gt; ['year', 'month', 'day'] } =&gt; [ 'DATE' ],
           ] );

           [% IF result.invalid('date') %]
           &lt;p&gt;Set correct date.&lt;/p&gt;
           [% END %]

   <b>FLEXIBLE</b> <b>VALIDATION</b>
           my $valid = FormValidator::Simple-&gt;new();

           $valid-&gt;check( $q =&gt; [
               param1 =&gt; [qw/NOT_BLANK ASCII/, [qw/LENGTH 4 10/] ],
           ] );

           $valid-&gt;check( $q =&gt; [
               param2 =&gt; [qw/NOT_BLANK/],
           ] );

           my $results = $valid-&gt;results;

           if ( found some error... ) {
               $results-&gt;set_invalid('param3' =&gt; 'MY_ERROR');
           }

       template example

           [% IF results.invalid('param1') %]
           ...
           [% END %]
           [% IF results.invalid('param2') %]
           ...
           [% END %]
           [% IF results.invalid('param3', 'MY_ERROR') %]
           ...
           [% END %]

</pre><h4><b>HOW</b> <b>TO</b> <b>SET</b> <b>OPTIONS</b></h4><pre>
       Option setting is needed by some validation, especially in plugins.

       You can set them in two ways.

           FormValidator::Simple-&gt;set_option(
               dbic_base_class =&gt; 'MyProj::Model::DBIC',
               charset         =&gt; 'euc',
           );

       or

           $valid = FormValidator::Simple-&gt;new(
               dbic_base_class =&gt; 'MyProj::Model::DBIC',
               charset         =&gt; 'euc',
           );

           $valid-&gt;check(...)

</pre><h4><b>VALIDATION</b> <b>COMMANDS</b></h4><pre>
       You can use follow variety validations.  and each validations can be used as negative validation with
       'NOT_' prefix.

           FormValidator::Simple-&gt;check( $q =&gt; [
               param1 =&gt; [ 'INT', ['LENGTH', 4, 10] ],
               param2 =&gt; [ 'NOT_INT', ['NOT_LENGTH', 4, 10] ],
           ] );

       SP  check if the data has space or not.

       INT check if the data is integer or not.

       UINT
           unsigined integer check.  for example, if -1234 is input, the validation judges it invalid.

       DECIMAL
               $q-&gt;param( 'num1' =&gt; '123.45678' );

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   num1 =&gt; [ ['DECIMAL', 3, 5] ],
               ] );

           each numbers (3,5) mean maximum digits before/after '.'

       ASCII
           check is the data consists of only ascii code.

       LENGTH
           check the length of the data.

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   param1 =&gt; [ ['LENGTH', 4] ],
               ] );

           check if the length of the data is 4 or not.

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   param1 =&gt; [ ['LENGTH', 4, 10] ],
               ] );

           when you set two arguments, it checks if the length of data is in the range between 4 and 10.

       HTTP_URL
           verify it is a http(s)-url

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   param1 =&gt; [ 'HTTP_URL' ],
               ] );

       SELECTED_AT_LEAST
           verify the quantity of selected parameters is counted over allowed minimum.

               &lt;input type="checkbox" name="hobby" value="music" /&gt; Music
               &lt;input type="checkbox" name="hobby" value="movie" /&gt; Movie
               &lt;input type="checkbox" name="hobby" value="game"  /&gt; Game

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   hobby =&gt; ['NOT_BLANK', ['SELECTED_AT_LEAST', 2] ],
               ] );

       REGEX
           check with regular expression.

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   param1 =&gt; [ ['REGEX', qr/^hoge$/ ] ],
               ] );

       DUPLICATION
           check if the two data are same or not.

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   { duplication_check =&gt; ['param1', 'param2'] } =&gt; [ 'DUPLICATION' ],
               ] );

       EMAIL
           check with Email::Valid.

       EMAIL_MX
           check with Email::Valid, including  mx check.

       EMAIL_LOOSE
           check with Email::Valid::Loose.

       EMAIL_LOOSE_MX
           check with Email::Valid::Loose, including mx check.

       DATE
           check with Date::Calc

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   { date =&gt; [qw/year month day/] } =&gt; [ 'DATE' ]
               ] );

       TIME
           check with Date::Calc

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   { time =&gt; [qw/hour min sec/] } =&gt; ['TIME'],
               ] );

       DATETIME
           check with Date::Calc

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   { datetime =&gt; [qw/year month day hour min sec/] } =&gt; ['DATETIME']
               ] );

       DATETIME_STRPTIME
           check with DateTime::Format::Strptime.

               my $q = CGI-&gt;new;
               $q-&gt;param( datetime =&gt; '2006-04-26T19:09:21+0900' );

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                 datetime =&gt; [ [ 'DATETIME_STRPTIME', '%Y-%m-%dT%T%z' ] ],
               ] );

       DATETIME_FORMAT
           check   with  DateTime::Format::***.  for  example,  DateTime::Format::HTTP,  DateTime::Format::Mail,
           DateTime::Format::MySQL and etc.

               my $q = CGI-&gt;new;
               $q-&gt;param( datetime =&gt; '2004-04-26 19:09:21' );

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                 datetime =&gt; [ [qw/DATETIME_FORMAT MySQL/] ],
               ] );

       GREATER_THAN
           numeric comparison

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   age =&gt; [ ['GREATER_THAN', 25] ],
               ] );

       LESS_THAN
           numeric comparison

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   age =&gt; [ ['LESS_THAN', 25] ],
               ] );

       EQUAL_TO
           numeric comparison

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   age =&gt; [ ['EQUAL_TO', 25] ],
               ] );

       BETWEEN
           numeric comparison

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   age =&gt; [ ['BETWEEN', 20, 25] ],
               ] );

       ANY check if there is not blank data in multiple data.

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   { some_data =&gt; [qw/param1 param2 param3/] } =&gt; ['ANY']
               ] );

       IN_ARRAY
           check if the food ordered is in menu

               my $result = FormValidator::Simple-&gt;check( $q =&gt; [
                   food =&gt; [ ['IN_ARRAY', qw/noodle soba spaghetti/] ],
               ] };

</pre><h4><b>HOW</b> <b>TO</b> <b>LOAD</b> <b>PLUGINS</b></h4><pre>
           use FormValidator::Simple qw/Japanese CreditCard/;

       FormValidator::Simple::Plugin::Japanese, FormValidator::Simple::Plugin::CreditCard are loaded.

       or use 'load_plugin' method.

           use FormValidator::Simple;
           FormValidator::Simple-&gt;load_plugin('FormValidator::Simple::Plugin::CreditCard');

       If you want to load plugin which name isn't in FormValidator::Simple::Plugin namespace, use +.

           use FormValidator::Simple qw/+MyApp::ValidatorPlugin/;

</pre><h4><b>MESSAGE</b> <b>HANDLING</b></h4><pre>
       You can custom your own message with key and type.

           [% IF result.has_error %]
               [% FOREACH key IN result.error %]
                   [% FOREACH type IN result.error(key) %]
                   &lt;p&gt;error message:[% type %] - [% key %]&lt;/p&gt;
                   [% END %]
               [% END %]
           [% END %]

       And you can also set messages configuration before.  You can prepare configuration as hash reference.

           FormValidator::Simple-&gt;set_messages( {
               action1 =&gt; {
                   name =&gt; {
                       NOT_BLANK =&gt; 'input name!',
                       LENGTH    =&gt; 'input name (length should be between 0 and 10)!',
                   },
                   email =&gt; {
                       DEFAULT =&gt; 'input correct email address!',
                   },
               },
           } );

       or a YAML file.

           # messages.yml
           DEFAULT:
               name:
                   DEFAULT: name is invalid!
           action1:
               name:
                   NOT_BLANK: input name!
                   LENGTH: input name(length should be between 0 and 10)!
               email:
                   DEFAULT: input correct email address!
           action2:
               name:
                   DEFAULT: ...

           # in your perl-script, set the file's path.
           FormValidator::Simple-&gt;set_messages('messages.yml');

       DEFAULT is a special type.  If it can't find setting for indicated validation-type, it uses  message  set
       for DEFAULT.

       after setting, execute <b>check()</b>,

           my $result = FormValidator::Simple-&gt;check( $q =&gt; [
               name  =&gt; [qw/NOT_BLANK/, [qw/LENGTH 0 10/] ],
               email =&gt; [qw/NOT_BLANK EMAIL_LOOSE/, [qw/LENGTH 0 20/] ],
           ] );

           # matching result and messages for indicated action.
           my $messages = $result-&gt;messages('action1');

           foreach my $message ( @$messages ) {
               print $message, "\n";
           }

           # or you can get messages as hash style.
           # each fieldname is the key
           my $field_messages = $result-&gt;field_messages('action1');
           if ($field_messages-&gt;{name}) {
               foreach my $message ( @{ $field_messages-&gt;{name} } ) {
                   print $message, "\n";
               }
           }

       When  it can't find indicated action, name, and type, it searches proper message from DEFAULT action.  If
       in template file,

           [% IF result.has_error %]
               [% FOREACH msg IN result.messages('action1') %]
               &lt;p&gt;[% msg %]&lt;/p&gt;
               [% END %]
           [% END %]

       you can set each message format.

           FormValidator::Simple-&gt;set_message_format('&lt;p&gt;%s&lt;/p&gt;');
           my $result = FormValidator::Simple-&gt;check( $q =&gt; [
               ...profile
           ] );

           [% IF result.has_error %]
               [% result.messages('action1').join("\n") %]
           [% END %]

</pre><h4><b>RESULT</b> <b>HANDLING</b></h4><pre>
       See FormValidator::Simple::Results

</pre><h4><b>FLAGGED</b> <b>UTF-8</b></h4><pre>
       If you set encoding like follows, it automatically decode the result messages.

           FormValidtor::Simple-&gt;set_mesasges_decode_from('utf-8');

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Data::FormValidator

       <a href="http://sl.edge.jp/">http://sl.edge.jp/</a> (Japanese)

       <a href="http://sourceforge.jp/projects/sledge">http://sourceforge.jp/projects/sledge</a>

</pre><h4><b>AUTHOR</b></h4><pre>
       Lyo Kato &lt;<a href="mailto:lyo.kato@gmail.com">lyo.kato@gmail.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This library is free software.  You can redistribute it and/or modify it under the  same  terms  as  perl
       itself.

perl v5.34.0                                       2022-06-14                         <u>FormValidator::<a href="../man3pm/Simple.3pm.html">Simple</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>