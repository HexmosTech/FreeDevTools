<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type::Tiny::Manual::Params - advanced information on Type::Params</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtype-tiny-perl">libtype-tiny-perl_2.004000-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Type::Tiny::Manual::Params - advanced information on Type::Params

</pre><h4><b>MANUAL</b></h4><pre>
       To get started with Type::Params, please read Type::Tiny::Manual::UsingWithMoo which will cover a lot of
       the basics, even if you're not using Moo.

   <b>"multiple"</b>
       The "multiple" option allows you to specify multiple ways of calling a sub.

        sub repeat_string {
          state $check = signature(
            multiple =&gt; [
              { positional =&gt; [ Str, Int ] },
              { named =&gt; [ string =&gt; Str, count =&gt; Int ], named_to_list =&gt; 1 },
            ],
          );

          my ( $string, $count ) = $check-&gt;( @_ );
          return $string x $count;
        }

        repeat_string(            "Hello",          42  );    # works
        repeat_string(  string =&gt; "Hello", count =&gt; 42  );    # works
        repeat_string({ string =&gt; "Hello", count =&gt; 42 });    # works
        repeat_string( qr/hiya/ );                            # dies

       It combines multiple checks and tries each until one works.

   <b>"signature_for"</b>
       "signature_for" turns "signature" inside out.

       Instead of this:

        sub foobar {
          state $check = signature( positional =&gt; [ Int, Str ] );
          my ( $foo, $bar ) = $check-&gt;( @_ );
          ...;
        }

       You do this:

        signature_for foobar =&gt; (
          positional =&gt; [ Int, Str ],
        );

        sub foobar {
          my ( $foo, $bar ) = @_;
          ...;
        }

       Or in Perl 5.20+, you can even do this:

        signature_for foobar =&gt; (
          positional =&gt; [ Int, Str ],
        );

        sub foobar ( $foo, $bar ) {
          ...;
        }

   <b>Functions</b> <b>versus</b> <b>Methods</b>
       For subs which are intended to be called as functions:

        signature( method =&gt; 0, ... );
        signature( ... );                       # this is the default anyway

       For subs which are intended to be called as methods on a blessed object:

        signature( method =&gt; Object, ... );

       And for subs which are intended to be called as methods on a class:

        signature( method =&gt; ClassName, ... );
        signature( method =&gt; Str, ... );        # less readable, but faster check!

       The following is also allowed, which indicates that the sub is intended to be called as a method, but you
       don't want to do type checks on the invocant:

        signature( method =&gt; 1, ... );

   <b>Mixed</b> <b>Named</b> <b>and</b> <b>Positional</b> <b>Parameters</b>
       The "head" and "tail" options allow required positional parameters at the start or end of a named
       parameter list:

        state $check = signature(
          head  =&gt; [ Int ],
          named =&gt; [
            foo =&gt; Int,
            bar =&gt; Optional[Int],
            baz =&gt; Optional[Int],
          ],
        );

        $check-&gt;( 42, foo =&gt; 21 );                 # ok
        $check-&gt;( 42, foo =&gt; 21, bar  =&gt; 84 );     # ok
        $check-&gt;( 42, foo =&gt; 21, bar  =&gt; 10.5 );   # not ok
        $check-&gt;( 42, foo =&gt; 21, quux =&gt; 84 );     # not ok

   <b>Proper</b> <b>Signatures</b>
       Don't you wish your subs could look like this?

         sub set_name ( Object $self, Str $name ) {
           $self-&gt;{name} = $name;
         }

       Well; here are a few solutions for sub signatures that work with Type::Tiny...

       <u>Zydeco</u>

       Zydeco is a Perl OO syntax toolkit with Type::Tiny support baked in throughout.

         package MyApp {
           use Zydeco;

           class Person {
             has name ( type =&gt; Str );

             method rename ( Str $new_name ) {
               printf( "%s will now be called %s\n", $self-&gt;name, $new_name );
               $self-&gt;name( $new_name );
             }

             coerce from Str via {
               $class-&gt;new( name =&gt; $_ )
             }
           }

           class Company {
             has owner ( type =&gt; 'Person' );
           }
         }

         my $acme = MyApp-&gt;new_company( owner =&gt; "Robert" );
         $acme-&gt;owner-&gt;rename( "Bob" );

       <u>Kavorka</u>

       Kavorka is a sub signatures implementation written to natively use Type::Utils' "dwim_type" for type
       constraints, and take advantage of Type::Tiny's features such as inlining, and coercions.

         method set_name ( Str $name ) {
           $self-&gt;{name} = $name;
         }

       Kavorka's signatures provide a lot more flexibility, and slightly more speed than Type::Params. (The
       speed comes from inlining almost all type checks into the body of the sub being declared.)

       Kavorka also includes support for type checking of the returned value.

       Kavorka can also be used as part of Moops, a larger framework for object oriented programming in Perl.

       <u>Function::Parameters</u>

       Function::Parameters offers support for Type::Tiny and MooseX::Types.

         use Types::Standard qw( Str );
         use Function::Parameters;

         method set_name ( Str $name ) {
             $self-&gt;{name} = $name;
         }

       <u>Attribute::Contract</u>

       Both Kavorka and Function::Parameters require a relatively recent version of Perl. Attribute::Contract
       supports older versions by using a lot less magic.

       You want Attribute::Contract 0.03 or above.

         use Attribute::Contract -types =&gt; [qw/Object Str/];

         sub set_name :ContractRequires(Object, Str) {
             my ($self, $name) = @_;
             $self-&gt;{name} = $name;
         }

       Attribute::Contract also includes support for type checking of the returned value.

   <b>Type::Params</b> <b>versus</b> <b>X</b>
       <u>Params::Validate</u>

       Type::Params is not really a drop-in replacement for Params::Validate; the API differs far too much to
       claim that. Yet it performs a similar task, so it makes sense to compare them.

       •   Type::Params  will  tend  to  be  faster if you've got a sub which is called repeatedly, but may be a
           little slower than Params::Validate for subs that are only called a few times.  This  is  because  it
           does a bunch of work the first time your sub is called to make subsequent calls a lot faster.

       •   Params::Validate  doesn't appear to have a particularly natural way of validating a mix of positional
           and named parameters.

       •   Type::Utils allows you to coerce parameters. For example, if you  expect  a  Path::Tiny  object,  you
           could coerce it from a string.

       •   If  you  are  primarily  writing  object-oriented  code,  using  Moose  or similar, and you are using
           Type::Tiny type constraints for your attributes, then using Type::Params allows you to use  the  same
           constraints for method calls.

       •   Type::Params  comes  bundled  with  Types::Standard, which provides a much richer vocabulary of types
           than the type validation constants that come  with  Params::Validate.  For  example,  Types::Standard
           provides  constraints  like  "ArrayRef[Int]"  (an  arrayref  of  integers),  while  the  closest from
           Params::Validate is "ARRAYREF", which you'd need to  supplement  with  additional  callbacks  if  you
           wanted to check that the arrayref contained integers.

           Whatsmore,  Type::Params  doesn't  just work with Types::Standard, but also any other Type::Tiny type
           constraints.

       <u>Params::ValidationCompiler</u>

       Params::ValidationCompiler does basically the same thing as Type::Params.

       •   Params::ValidationCompiler and Type::Params are likely to perform fairly similarly.  In  most  cases,
           recent  versions of Type::Params seem to be <u>slightly</u> faster, but except in very trivial cases, you're
           unlikely to notice the speed difference. Speed probably shouldn't be a factor when  choosing  between
           them.

       •   Type::Params's syntax is more compact:

              state $check = signature(
                pos =&gt; [
                  Object,
                  Optional[Int],
                  Slurpy[ArrayRef],
                ],
              );

           Versus:

              state $check = validation_for(
                 params =&gt; [
                    { type =&gt; Object },
                    { type =&gt; Int,      optional =&gt; 1 },
                    { type =&gt; ArrayRef, slurpy =&gt; 1 },
                 ],
              );

       •   Params::ValidationCompiler probably has slightly better exceptions.

</pre><h4><b>NEXT</b> <b>STEPS</b></h4><pre>
       Here's your next step:

       •   Type::Tiny::Manual::NonOO

           Type::Tiny in non-object-oriented code.

</pre><h4><b>AUTHOR</b></h4><pre>
       Toby Inkster &lt;<a href="mailto:tobyink@cpan.org">tobyink@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2013-2014, 2017-2023 by Toby Inkster.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTIES</b></h4><pre>
       THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  WITHOUT
       LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

perl v5.40.1                                       2025-05-06                    <u>Type::Tiny::Manual::<a href="../man3pm/Params.3pm.html">Params</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>