<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spreadsheet::Read - Read the data from a spreadsheet</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libspreadsheet-read-perl">libspreadsheet-read-perl_0.93-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Spreadsheet::Read - Read the data from a spreadsheet

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Spreadsheet::Read;
        my $book  = ReadData ("test.csv", sep =&gt; ";");
        my $book  = ReadData ("test.sxc");
        my $book  = ReadData ("test.ods");
        my $book  = ReadData ("test.xls");
        my $book  = ReadData ("test.xlsx");
        my $book  = ReadData ("test.xlsm");
        my $book  = ReadData ("test.gnumeric");
        my $book  = ReadData ($fh, parser =&gt; "xls");

        Spreadsheet::Read::add ($book, "sheet.csv");

        my $sheet = $book-&gt;[1];             # first datasheet
        my $cell  = $book-&gt;[1]{A3};         # content of field A3 of sheet 1
        my $cell  = $book-&gt;[1]{cell}[1][3]; # same, unformatted

        # OO API
        my $book = Spreadsheet::Read-&gt;new ("file.csv");
        my $sheet = $book-&gt;sheet (1);
        my $cell  = $sheet-&gt;cell ("A3");
        my $cell  = $sheet-&gt;cell (1, 3);

        $book-&gt;add ("test.xls");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Spreadsheet::Read tries to transparently read *any* spreadsheet and return its content in a universal
       manner independent of the parsing module that does the actual spreadsheet scanning.

       The parser has to be available and is not provided by this module.

   <b>Supported</b> <b>spreadsheets</b>
       <u>OpenOffice</u> <u>and</u> <u>LibreOffice</u> <u>("ODS"</u> <u>and</u> <u>"SXC")</u>

       For OpenOffice and/or LibreOffice this module uses Spreadsheet::ParseODS
       &lt;https://metacpan.org/pod/Spreadsheet::ParseODS&gt; or Spreadsheet::ReadSXC
       &lt;https://metacpan.org/release/Spreadsheet-ReadSXC&gt;

       <u>Microsoft</u> <u>Excel</u> <u>("XLSX"</u> <u>and</u> <u>"XLS")</u>

       For Microsoft Excel this module uses Spreadsheet::ParseExcel &lt;https://metacpan.org/release/Spreadsheet-
       ParseExcel&gt;, Spreadsheet::ParseXLSX &lt;https://metacpan.org/release/Spreadsheet-ParseXLSX&gt;,
       Excel::ValueReader::XLSX &lt;https://metacpan.org/release/Excel-ValueReader-XLSX&gt;, or Spreadsheet::XLSX
       &lt;https://metacpan.org/release/Spreadsheet-XLSX&gt; (strongly discouraged).

       <u>CSV</u> <u>("CSV")</u>

       For CSV this module uses Text::CSV_XS &lt;https://metacpan.org/release/Text-CSV_XS&gt; or Text::CSV_PP
       &lt;https://metacpan.org/release/Text-CSV&gt;.

       <u>Gnumeric</u> <u>("gnumeric")</u>

       For Gnumeric this module uses Spreadsheet::ReadGnumeric &lt;https://metacpan.org/release/Spreadsheet-
       ReadGnumeric&gt;.

       <u>SquirrelCalc</u> <u>("sc")</u>

       For SquirrelCalc there is a very simplistic built-in parser

   <b>Data</b> <b>structure</b>
       The data is returned as an array reference:

         $book = [
             # Entry 0 is the overall control hash
             { sheets  =&gt; 2,
               sheet   =&gt; {
                 "Sheet 1" =&gt; 1,
                 "Sheet 2" =&gt; 2,
                 },
               parsers =&gt; [ {
                 type      =&gt; "xls",
                 parser    =&gt; "Spreadsheet::ParseExcel",
                 version   =&gt; 0.59,
                 }],
               error   =&gt; undef,
               },
             # Entry 1 is the first sheet
             { parser  =&gt; 0,
               label   =&gt; "Sheet 1",
               maxrow  =&gt; 2,
               maxcol  =&gt; 4,
               cell    =&gt; [ undef,
                 [ undef, 1 ],
                 [ undef, undef, undef, undef, undef, "Nugget" ],
                 ],
               attr    =&gt; [],
               merged  =&gt; [],
               active  =&gt; 1,
               hidden  =&gt; 0,
               A1      =&gt; 1,
               B5      =&gt; "Nugget",
               },
             # Entry 2 is the second sheet
             { parser  =&gt; 0,
               label   =&gt; "Sheet 2",
               :
               :

       To keep as close contact to spreadsheet users, row and column 1 have index 1 too in the "cell" element of
       the sheet hash, so cell "A1" is the same as "cell" [1, 1] (column first). To switch between the two,
       there are helper functions available: "cell2cr ()", "cr2cell ()", and "col2label ()".

       The "cell" hash entry contains unformatted data, while the hash entries with the traditional labels
       contain the formatted values (if applicable).

       The control hash (the first entry in the returned array ref), contains some spreadsheet meta-data. The
       entry "sheet" is there to be able to find the sheets when accessing them by name:

         my %sheet2 = %{$book-&gt;[$book-&gt;[0]{sheet}{"Sheet 2"}]};

   <b>Formatted</b> <b>vs</b> <b>Unformatted</b>
       The difference between formatted and unformatted cells is that the (optional) format is applied to the
       cell or not. This part is <b>completely</b> implemented on the parser side. Spreadsheet::Read just makes both
       available if these are supported. Options provide means to disable either. If the parser does not provide
       formatted cells - like CSV - both values are equal.

       To show what this implies:

        use Spreadsheet::Read;

        my $file     = "files/example.xlsx";
        my $workbook = Spreadsheet::Read-&gt;new ($file);

        my $info     = $workbook-&gt;[0];
        say "Parsed $file with $info-&gt;{parser}-$info-&gt;{version}";

        my $sheet    = $workbook-&gt;sheet (1);

        say join "\t" =&gt; "Formatted:",   $sheet-&gt;row     (1);
        say join "\t" =&gt; "Unformatted:", $sheet-&gt;cellrow (1);

       Might return very different results depending one the underlying parser (and its version):

        Parsed files/example.xlsx with Spreadsheet::ParseXLSX-0.27
        Formatted:      8-Aug   Foo &amp; Barr &lt; Quux
        Unformatted:    39668   Foo &amp; Barr &lt; Quux

        Parsed files/example.xlsx with Spreadsheet::XLSX-0.15
        Formatted:      39668   Foo &amp;amp; Barr &amp;lt; Quux
        Unformatted:    39668   Foo &amp;amp; Barr &amp;lt; Quux

   <b>Functions</b> <b>and</b> <b>methods</b>
       <u>new</u>

        my $book = Spreadsheet::Read-&gt;new (...) or die $@;

       All options accepted by ReadData are accepted by new.

       With no arguments at all, $book will be an object where sheets can be added using "add"

        my $book = Spreadsheet::Read-&gt;new ();
        $book-&gt;add ("file.csv");
        $book-&gt;add ("file.cslx");

       <u>ReadData</u>

        my $book = ReadData ($source [, option =&gt; value [, ... ]]);

        my $book = ReadData ("file.csv", sep =&gt; ',', quote =&gt; '"');

        my $book = ReadData ("file.xls", dtfmt =&gt; "yyyy-mm-dd");

        my $book = ReadData ("file.ods");

        my $book = ReadData ("file.sxc");

        my $book = ReadData ("content.xml");

        my $book = ReadData ($content);

        my $book = ReadData ($content,  parser =&gt; "xlsx");

        my $book = ReadData ($fh,       parser =&gt; "xlsx");

        my $book = ReadData (\$content, parser =&gt; "xlsx");

       Tries to convert the given file, string, or stream to the data structure described above.

       Processing Excel data from a stream or content is supported through a File::Temp
       &lt;https://metacpan.org/release/File-Temp&gt; temporary file or IO::Scalar &lt;https://metacpan.org/release/IO-
       stringy&gt; when available.

       Spreadsheet::ReadSXC &lt;https://metacpan.org/release/Spreadsheet-ReadSXC&gt; does preserve sheet order as of
       version 0.20.

       Choosing between $content and "\\$content" (with or without passing the desired "parser" option) may be
       depending on trial and terror.  "ReadData" does try to determine parser type on content if needed, but
       not all combinations are checked, and not all signatures are builtin.

       Currently supported options are:

       parser
         Force  the  data  to be parsed by a specific format. Possible values are "csv", "prl" (or "perl"), "sc"
         (or "squirrelcalc"), "sxc" (or "oo", "ods", "openoffice", "libreoffice") "xls" (or "excel"), and "xlsx"
         (or "excel2007").

         When parsing streams, instead of files, it is highly recommended to pass this option.

         Spreadsheet::Read supports several underlying parsers per spreadsheet type. It will try those from most
         favored to least favored. When you have a good reason to prefer a different parser, you can set that in
         environment variables. The other options then will not be tested for:

          env SPREADSHEET_READ_CSV=Text::CSV_PP ...

         You can also directly pass the required backend, forcing the matching type, but this  excludes  version
         checking.

          # Checks for minimal version
          BEGIN { $ENV{SPREADSHEET_READ_CSV} = "Text::CSV_PP" }
          my $book = ReadData ("test.csv", parser =&gt; "csv");

          vs

          # NO check for minimal version
          my $book = ReadData ("test.csv", parser =&gt; "Text::CSV_PP");

       cells
         Control the generation of named cells (""A1"" etc). Default is true.

       rc
         Control the generation of the {cell}[c][r] entries. Default is true.

       attr
         Control the generation of the {attr}[c][r] entries. Default is false.  See "Cell Attributes" below.

       clip
         If set, "ReadData" will remove all trailing rows and columns per sheet that have no data, where no data
         means  only  undefined  or  empty  cells (after optional stripping). If a sheet has no data at all, the
         sheet will be skipped entirely when this attribute is true.

       trim
       strip
         If set, "ReadData" will remove trailing- and/or leading-whitespace from every field.

           strip  leading  strailing
           -----  -------  ---------
             0      n/a      n/a
             1     strip     n/a
             2      n/a     strip
             3     strip    strip

         "trim" and "strip" are aliases. If passed both, "trim" is ignored because of backward compatibility.

       transpose
       pivot
         Swap all rows and columns.

         When a sheet contains data like

           A1  B1  C1      E1
           A2      C2  D2
           A3  B3  C3  D3  E3

         using "transpose" or "pivot" will return the sheet data as

           A1  A2  A3
           B1      B3
           C1  C2  C3
               D2  D3
           E1      E3

         "transpose" and "pivot" are aliases. If  passed  both,  "transpose"  is  ignored  because  of  backward
         compatibility.

       sep
         Set separator for CSV. Default is comma ",".

       quote
         Set quote character for CSV. Default is """.

       dtfmt
         Set the format for MS-Excel date fields that are set to use the default date format. The default format
         in  Excel  is  ""m-d-yy"",  which  is  both  not  year  2000  safe, nor very useful. The default is now
         ""yyyy-mm-dd"", which is more ISO-like.

         Note that date formatting in MS-Excel is not reliable at all, as it will store/replace/change the  date
         field  separator  in  already stored formats if you change your locale settings. So the above mentioned
         default can be either ""m-d-yy"" OR ""m/d/yy"" depending on what that specific character happened to be
         at the time the user saved the file.

       merge
         Copy content to all cells in merged areas.

         If supported, this will copy formatted and unformatted values from the top-left cell of a  merged  area
         to all other cells in the area.

       debug
         Enable some diagnostic messages to STDERR.

         The     value     determines     how     much     diagnostics     are    dumped    (using    Data::Peek
         &lt;https://metacpan.org/release/Data-Peek&gt;).  A value of 9 and higher will dump the entire structure from
         the back-end parser.

       passwd
         Use this password to decrypt password protected spreadsheet.

         Currently only supports Excel.

       All other attributes/options will be passed to the underlying parser if that parser supports attributes.

       <u>col2label</u>

        my $col_id = col2label (col);

        my $col_id = $book-&gt;col2label (col);  # OO

       "col2label ()" converts a "(column)" (1 based) to the letters used in the traditional cell notation:

         my $id = col2label ( 4); # $id now "D"
         my $id = col2label (28); # $id now "AB"

       <u>cr2cell</u>

        my $cell = cr2cell (col, row);

        my $cell = $book-&gt;cr2cell (col, row);  # OO

       "cr2cell ()" converts a "(column, row)" pair (1 based) to the traditional cell notation:

         my $cell = cr2cell ( 4, 14); # $cell now "D14"
         my $cell = cr2cell (28,  4); # $cell now "AB4"

       <u>cell2cr</u>

        my ($col, $row) = cell2cr ($cell);

        my ($col, $row) = $book-&gt;cell2cr ($cell);  # OO

       "cell2cr ()" converts traditional cell notation to a "(column, row)" pair (1 based):

         my ($col, $row) = cell2cr ("D14"); # returns ( 4, 14)
         my ($col, $row) = cell2cr ("AB4"); # returns (28,  4)

       <u>row</u>

        my @row = row ($sheet, $row)

        my @row = Spreadsheet::Read::row ($book-&gt;[1], 3);

        my @row = $book-&gt;row ($sheet, $row); # OO

       Get full row of formatted values (like "$sheet-&gt;{A3} .. $sheet-&gt;{G3}")

       Note that the indexes in the returned list are 0-based.

       "row ()" is not imported by default, so either specify it in the use argument  list,  or  call  it  fully
       qualified.

       See also the "row ()" method on sheets.

       <u>cellrow</u>

        my @row = cellrow ($sheet, $row);

        my @row = Spreadsheet::Read::cellrow ($book-&gt;[1], 3);

        my @row = $book-&gt;cellrow ($sheet, $row); # OO

       Get full row of unformatted values (like "$sheet-&gt;{cell}[1][3] .. $sheet-&gt;{cell}[7][3]")

       Note that the indexes in the returned list are 0-based.

       "cellrow  ()" is not imported by default, so either specify it in the use argument list, or call it fully
       qualified or as method call.

       See also the "cellrow ()" method on sheets.

       <u>rows</u>

        my @rows = rows ($sheet);

        my @rows = Spreadsheet::Read::rows ($book-&gt;[1]);

        my @rows = $book-&gt;rows (1); # OO

       Convert "{cell}"'s "[column][row]" to a "[row][column]" list.

       Note that the indexes in the returned list are 0-based, where the index in the "{cell}" entry is 1-based.

       "rows ()" is not imported by default, so either specify it in the use argument list,  or  call  it  fully
       qualified.

       <u>parses</u>

        parses ($format);

        Spreadsheet::Read::parses ("CSV");

        $book-&gt;parses ("CSV"); # OO

       "parses  ()"  returns  Spreadsheet::Read's  capability  to parse the required format or 0 if it does not.
       "ReadData" will pick its preferred parser for that format unless overruled.  See "parser".

       "parses ()" is not imported by default, so either specify it in the use argument list, or call  it  fully
       qualified.

       If $format is false ("undef", "", or 0), "parses ()" will return a sorted list of supported types.

        @my types = parses ("");   # e.g: csv, ods, sc, sxc, xls, xlsx

       <u>parsers</u>

        my @p = parsers ();

       "parsers ()" returns a list of hashrefs with information about supported parsers, each giving information
       about the parser, its versions and if it will be used as default parser for the given type, like:

        { ext =&gt; "csv",            # extension or type
          mod =&gt; "Text::CSV_XS",   # parser module
          min =&gt; "0.71",           # module required  version
          vsn =&gt; "1.45",           # module installed version
          def =&gt; "*",              # is default for ext
          }

       As the modules are actually loaded to get their version, do only use this to analyse prerequisites.

       <u>Version</u>

        my $v = Version ()

        my $v = Spreadsheet::Read::Version ()

        my $v = Spreadsheet::Read-&gt;VERSION;

        my $v = $book-&gt;Version (); # OO

       Returns the current version of Spreadsheet::Read.

       "Version  ()" is not imported by default, so either specify it in the use argument list, or call it fully
       qualified.

       This function returns exactly the same as "Spreadsheet::Read-&gt;VERSION"  returns  and  is  only  kept  for
       backward compatibility reasons.

       <u>sheets</u>

        my $sheets = $book-&gt;sheets; # OO
        my @sheets = $book-&gt;sheets; # OO

       In scalar context return the number of sheets in the book.

       In  list  context return the labels of the sheets in the book. This list only returns known unique labels
       in sorted order. Sheets could have no label or there can be more sheets with the same label  (depends  on
       the spreadsheet format and the parser used).

       <u>sheet</u>

        my $sheet = $book-&gt;sheet (1);     # OO
        my $sheet = $book-&gt;sheet ("Foo"); # OO

       Return  the  numbered  or named sheet out of the book. Will return "undef" if there is no match. Will not
       work for sheets <u>named</u> with a number between 1 and the number of sheets in the book.

       With named sheets will first try to use the list of sheet-labels as stored in the control  structure.  If
       no  match  is found, it will scan the actual labels of the sheets. In that case, it will return the first
       matching sheet.

       If defined, the returned sheet will be of class "Spreadsheet::Read::Sheet".

       <u>add</u>

        my $book = ReadData ("file.csv");
        Spreadsheet::Read::add ($book, "file.xlsx");

        my $book = Spreadsheet::Read-&gt;new ("file.csv");
        $book-&gt;add ("file.xlsx"); # OO

   <b>Methods</b> <b>on</b> <b>sheets</b>
       <u>maxcol</u>

        my $col = $sheet-&gt;maxcol;

       Return the index of the last in-use column in the sheet. This index is 1-based.

       <u>maxrow</u>

        my $row = $sheet-&gt;maxrow;

       Return the index of the last in-use row in the sheet. This index is 1-based.

       <u>cell</u>

        my $cell = $sheet-&gt;cell ("A3");
        my $cell = $sheet-&gt;cell (1, 3);

       Return the value for a cell. Using tags will return the formatted value, using column and row will return
       unformatted value.

       <u>attr</u>

        my $cell = $sheet-&gt;attr ("A3");
        my $cell = $sheet-&gt;attr (1, 3);

       Return the attributes of a cell. Only valid if attributes are enabled through option "attr".

       <u>col2label</u>

        my $col_id = $sheet-&gt;col2label (col);

       "col2label ()" converts a "(column)" (1 based) to the letters used in the traditional cell notation:

         my $id = $sheet-&gt;col2label ( 4); # $id now "D"
         my $id = $sheet-&gt;col2label (28); # $id now "AB"

       <u>cr2cell</u>

        my $cell = $sheet-&gt;cr2cell (col, row);

       "cr2cell ()" converts a "(column, row)" pair (1 based) to the traditional cell notation:

         my $cell = $sheet-&gt;cr2cell ( 4, 14); # $cell now "D14"
         my $cell = $sheet-&gt;cr2cell (28,  4); # $cell now "AB4"

       <u>cell2cr</u>

        my ($col, $row) = $sheet-&gt;cell2cr ($cell);

       "cell2cr ()" converts traditional cell notation to a "(column, row)" pair (1 based):

         my ($col, $row) = $sheet-&gt;cell2cr ("D14"); # returns ( 4, 14)
         my ($col, $row) = $sheet-&gt;cell2cr ("AB4"); # returns (28,  4)

       <u>col</u>

        my @col = $sheet-&gt;column ($col);

       Get full column of formatted values (like "$sheet-&gt;{C1} .. $sheet-&gt;{C9}")

       Note that the indexes in the returned list are 0-based.

       <u>cellcolumn</u>

        my @col = $sheet-&gt;cellcolumn ($col);

       Get full column of unformatted values (like "$sheet-&gt;{cell}[3][1] .. $sheet-&gt;{cell}[3][9]")

       Note that the indexes in the returned list are 0-based.

       <u>row</u>

        my @row = $sheet-&gt;row ($row);

       Get full row of formatted values (like "$sheet-&gt;{A3} .. $sheet-&gt;{G3}")

       Note that the indexes in the returned list are 0-based.

       <u>cellrow</u>

        my @row = $sheet-&gt;cellrow ($row);

       Get full row of unformatted values (like "$sheet-&gt;{cell}[1][3] .. $sheet-&gt;{cell}[7][3]")

       Note that the indexes in the returned list are 0-based.

       <u>cellrange</u>

        my $arrayref = $sheet-&gt;cellrange ("B3:D5");
        my $arrayref = $sheet-&gt;cellrange (2, 3, 4, 5);
        my $arrayref = $sheet-&gt;cellrange (-4, -5, -1, -1);

       Return an arrayref with the selected cells from "$sheet-&gt;{cell}".  When the range is given as  (top-left,
       bottom-right)  numeric  CR pairs, negative values are allowed (count from rigth/bottom) and automatically
       clipped to be inside the existing data set.

       <u>range</u>

        my $hashref = $sheet-&gt;range ("B3:D5");
        my $hashref = $sheet-&gt;range (2, 3, 4, 5);
        my $hashref = $sheet-&gt;range (-4, -5, -1, -1);

       Return a hashref with all the fields in the given range. When the range is given  as  (top-left,  bottom-
       right)  numeric CR pairs, negative values are allowed (count from rigth/bottom) and automatically clipped
       to be inside the existing data set.

       <u>rows</u>

        my @rows = $sheet-&gt;rows ();

       Convert "{cell}"'s "[column][row]" to a "[row][column]" list.

       Note that the indexes in the returned list are 0-based, where the index in the "{cell}" entry is 1-based.

       <u>merged_from</u>

        my $top_left = $sheet-&gt;merged_from ("C2");
        my $top_left = $sheet-&gt;merged_from (3, 2);

       If the parser supports merged areas, this method will return the label of the top-left cell in the merged
       area the requested cell is part of.

       If the requested ID is valid and withing the sheet cell range, but not part of a  merged  area,  it  will
       return "".

       If the ID is not valid or out of range, it returns "undef".

       See Merged cells for more details.

       <u>label</u>

        my $label = $sheet-&gt;label;
        $sheet-&gt;label ("New sheet label");

       Set a new label to a sheet. Note that the index in the control structure will <u>NOT</u> be updated.

       <u>active</u>

        my $sheet_is_active = $sheet-&gt;active;

       Returns 1 if the selected sheet is active, otherwise returns 0.

       Currently only works on XLS (as of Spreadsheed::ParseExcel-0.61).  CSV is always active.

       <u>hidden</u>

        my $sheet_is_hidden = $sheet-&gt;hidden;

       Returns 1 if the selected sheet is hidden, otherwise returns 0.

       Fully depends on the backend supporting this.  CSV and SC are never hidden.

   <b>Using</b> <b>CSV</b>
       In  case  of  CSV  parsing,  "ReadData" will use the first line of the file to auto-detect the separation
       character if the first argument is a file and both "sep"  and  "quote"  are  not  passed  as  attributes.
       Text::CSV_XS            &lt;https://metacpan.org/release/Text-CSV_XS&gt;            (or            Text::CSV_PP
       &lt;https://metacpan.org/release/Text-CSV&gt;) is able to automatically detect and use "\r" line endings.

       CSV can parse streams too, but be sure to pass "sep" and/or "quote" if these do not match the default ","
       and """.

       When an error is found in the CSV, it is automatically reported (to STDERR).  The  structure  will  store
       the    error    in    "$ss-&gt;[0]{error}"    as    anonymous    list    returned    by   "$csv-&gt;error_diag"
       &lt;https://metacpan.org/pod/Text::CSV_XS#error_diag&gt;.                    See                   Text::CSV_XS
       &lt;https://metacpan.org/pod/Text::CSV_XS&gt; for documentation.

        my $ss = ReadData ("bad.csv");
        $ss-&gt;[0]{error} and say $ss-&gt;[0]{error}[1];

       As  CSV  has  no  sheet  labels, the default label for a CSV sheet is its filename.  For CSV, this can be
       overruled using the <u>label</u> attribute:

        my $ss = Spreadsheet::Read-&gt;new ("/some/place/test.csv", label =&gt; "Test");

   <b>Cell</b> <b>Attributes</b>
       If the constructor was called with "attr" having a true value,

        my $book = ReadData ("book.xls", attr =&gt; 1);
        my $book = Spreadsheet::Read-&gt;new ("book.xlsx", attr =&gt; 1);

       effort is made to analyze and store field attributes like this:

           { label  =&gt; "Sheet 1",
             maxrow =&gt; 5,
             maxcol =&gt; 2,
             cell   =&gt; [ undef,
               [ undef, 1 ],
               [ undef, undef, undef, undef, undef, "Nugget" ],
               ],
             attr   =&gt; [ undef,
               [ undef, {
                 type    =&gt; "numeric",
                 fgcolor =&gt; "#ff0000",
                 bgcolor =&gt; undef,
                 font    =&gt; "Arial",
                 size    =&gt; undef,
                 format  =&gt; "## ##0.00",
                 halign  =&gt; "right",
                 valign  =&gt; "top",
                 uline   =&gt; 0,
                 bold    =&gt; 0,
                 italic  =&gt; 0,
                 wrap    =&gt; 0,
                 merged  =&gt; 0,
                 hidden  =&gt; 0,
                 locked  =&gt; 0,
                 enc     =&gt; "utf-8",
                 }, ],
               [ undef, undef, undef, undef, undef, {
                 type    =&gt; "text",
                 fgcolor =&gt; "#e2e2e2",
                 bgcolor =&gt; undef,
                 font    =&gt; "Letter Gothic",
                 size    =&gt; 15,
                 format  =&gt; undef,
                 halign  =&gt; "left",
                 valign  =&gt; "top",
                 uline   =&gt; 0,
                 bold    =&gt; 0,
                 italic  =&gt; 0,
                 wrap    =&gt; 0,
                 merged  =&gt; 0,
                 hidden  =&gt; 0,
                 locked  =&gt; 0,
                 enc     =&gt; "iso8859-1",
                 }, ],
               ],
             merged =&gt; [],
             A1     =&gt; 1,
             B5     =&gt; "Nugget",
             },

       The entries "maxrow" and "maxcol" are 1-based.

       This has now been partially implemented, mainly for Excel, as the other parsers do not (yet) support  all
       of that. YMMV.

       If  a  cell  itself is not hidden, but the parser holds the information that either the row or the column
       (or both) the field is in is hidden, the flag is inherited into the cell attributes.

       You can get the attributes of a cell (as a hash-ref) like this:

        my $attr = $book[1]{attr}[1][3];          # Direct structure
        my $attr = $book-&gt;sheet (1)-&gt;attr (1, 3); # Same using OO
        my $attr = $book-&gt;sheet (1)-&gt;attr ("A3"); # Same using OO

       To get to the "font" attribute, use any of these:

        my $font = $book[1]{attr}[1][3]{font};
        my $font = $book-&gt;sheet (1)-&gt;attr (1, 3)-&gt;{font};
        my $font = $book-&gt;sheet (1)-&gt;attr ("A3")-&gt;font;

       <u>Merged</u> <u>cells</u>

       Note that only Spreadsheet::ReadSXC &lt;https://metacpan.org/release/Spreadsheet-ReadSXC&gt; documents the  use
       of merged cells, and not in a way useful for the spreadsheet consumer.

       CSV does not support merged cells (though future implementations of CSV for the web might).

       The  documentation  of merged areas in Spreadsheet::ParseExcel &lt;https://metacpan.org/release/Spreadsheet-
       ParseExcel&gt; and Spreadsheet::ParseXLSX &lt;https://metacpan.org/release/Spreadsheet-ParseXLSX&gt; can be  found
       in  Spreadsheet::ParseExcel::Worksheet  &lt;https://metacpan.org/pod/Spreadsheet::ParseExcel::Worksheet&gt; and
       Spreadsheet::ParseExcel::Cell &lt;https://metacpan.org/pod/Spreadsheet::ParseExcel::Cell&gt;.

       None of basic Spreadsheet::XLSX &lt;https://metacpan.org/release/Spreadsheet-XLSX&gt;,  Spreadsheet::ParseExcel
       &lt;https://metacpan.org/release/Spreadsheet-ParseExcel&gt;,             and             Spreadsheet::ParseXLSX
       &lt;https://metacpan.org/release/Spreadsheet-ParseXLSX&gt; manual pages mention merged cells at all.

       This module just tries to return the information in a generic way.

       Given this spreadsheet as an example

        merged.xlsx:

            A     B     C
         +-----+-----------+
        1|     | foo       |
         +-----+           +
        2| bar |           |
         |     +-----+-----+
        3|     | urg | orc |
         +-----+-----+-----+

       the information extracted from that undocumented information is returned in the  "merged"  entry  of  the
       sheet's hash as a list of top-left, bottom-right coordinate pars (col, row, col, row). For given example,
       that would be:

        $ss-&gt;{merged} = [
           [ 1, 2, 1, 3 ], # A2-A3
           [ 2, 1, 3, 2 ], # B1-C2
           ];

       To find the label of the top-left cell in a merged area, use the "merged_from" method.

        $ss-&gt;merged_from ("C2"); # will return "B1"

       When  the  attributes  are  also  enabled,  there is some merge information copied directly from the cell
       information, but again, that stems from code analysis and not from documentation:

        my $ss = ReadData ("merged.xlsx", attr =&gt; 1)-&gt;[1];
        foreach my $row (1 .. $ss-&gt;{maxrow}) {
            foreach my $col (1 .. $ss-&gt;{maxcol}) {
                my $cell = cr2cell ($col, $row);
                printf "%s %-3s %s  ", $cell, $ss-&gt;{$cell},
                    $ss-&gt;{attr}[$col][$row]{merged};
                }
            print "\n";
            }

        A1     0  B1 foo 1  C1     1
        A2 bar 1  B2     1  C2     1
        A3     1  B3 urg 0  C3 orc 0

       In this example, there is no way to see if "B2" is merged to  "A2"  or  to  "B1"  without  analyzing  all
       surrounding  cells.  This  could as well mean "A2:A3", "B1:C1", "B2:C2", as "A2:A3", "B1:B2", "C1:C2", as
       "A2:A3", "B1:C2".

       Use the "merged" entry described above to find out what fields are merged to what  other  fields  or  use
       "merge":

        my $ss = ReadData ("merged.xlsx", attr =&gt; 1, merge =&gt; 1)-&gt;[1];
        foreach my $row (1 .. $ss-&gt;{maxrow}) {
            foreach my $col (1 .. $ss-&gt;{maxcol}) {
                my $cell = cr2cell ($col, $row);
                printf "%s %-3s %s  ", $cell, $ss-&gt;{$cell},
                    $ss-&gt;{attr}[$col][$row]{merged};
                }
            print "\n";
            }

        A1     0   B1 foo B1  C1 foo B1
        A2 bar A2  B2 foo B1  C2 foo B1
        A3 bar A2  B3 urg 0   C3 orc 0

   <b>Streams</b> <b>from</b> <b>web-resources</b>
       If  you  want  to  stream  a  web-resource, and the underlying parser supports it, you could use a helper
       function like this (thanks Corion):

        use HTTP::Tiny;
        use Spreadsheet::Read;

        # Fetch data and return a filehandle to that data
        sub fh_from_url {
            my $url = shift;
            my $ua  = HTTP::Tiny-&gt;new;
            my $res = $ua-&gt;get ($url);
            open my $fh, "&lt;", \$res-&gt;{content};
            return $fh
            } # fh_from_url

        my $fh = fh_from_url ("<a href="http://example.com/example.csv">http://example.com/example.csv</a>");
        my $sheet = Spreadsheet::Read-&gt;new ($fh, parser =&gt; "csv");

</pre><h4><b>TOOLS</b></h4><pre>
       This modules comes with a few tools that perform tasks from the FAQ, like "How do I select only column  D
       through F from sheet 2 into a CSV file?"

       If the module was installed without the tools, you can find them here:
         https://github.com/Tux/Spreadsheet-Read/tree/master/scripts

   <b>"xlscat"</b>
       Show (parts of) a spreadsheet in plain text, CSV, or HTML

        usage: xlscat   [-s &lt;sep&gt;] [-L] [-n] [-A] [-u] [Selection] file.xls
                        [-c | -m]                 [-u] [Selection] file.xls
                         -i                            [-S sheets] file.xls
            Generic options:
               -v[#]       Set verbose level (xlscat/xlsgrep)
               -d[#]       Set debug   level (Spreadsheet::Read)
               --list      Show supported spreadsheet formats and exit
               -u          Use unformatted values
               --strip[=#] Strip leading and/or traing spaces of all cells
                           # &amp; 01 = leading, # &amp; 02 = trailing, 3 = default
               --clip=#    Clip cells to max length #
               --noclip    Do not strip empty sheets and
                           trailing empty rows and columns
               --no-empty  Skip empty rows
                --no-nl[=R] Replace all newlines in cells with R (default space)
               -e &lt;enc&gt;    Set encoding for input and output
               -b &lt;enc&gt;    Set encoding for input
               -a &lt;enc&gt;    Set encoding for output
               -U          Set encoding for output to utf-8 (short for -a utf-8)
            Input CSV:
               --in-sep=c  Set input sep_char for CSV (c can be 'TAB')
            Input XLS:
               --dtfmt=fmt Specify the default date format to replace 'm-d-yy'
                           the default replacement is 'yyyy-mm-dd'
               --passwd=pw Specify the password for workbook
                           if pw = -, read password from keyboard
               --formulas  Show the formula instead of the value
            Output Text (default):
               -s &lt;sep&gt;    Use separator &lt;sep&gt;. Default '|', \n allowed
                           Overrules ',' when used with --csv
               -L          Line up the columns
               -B  --box   Like -L but also add outer frame
               -n [skip]   Number lines (prefix with column number)
                           optionally skip &lt;skip&gt; (header) lines
               -A          Show field attributes in ANSI escapes
               -h[#]       Show # header lines
               -D          Dump each record with Data::Peek or Data::Dumper
                --hash     Like -D but as hash with first row as keys
            Output CSV:
               -c          Output CSV, separator = ','
               -m          Output CSV, separator = ';'
            Output Index only:
               -i          Show sheet names and size only
            Output HTML:
               -H          Output HTML
            Selection:
               -S &lt;sheets&gt; Only print sheets &lt;sheets&gt;. 'all' is a valid set
                           Default only prints the first sheet
               -R &lt;rows&gt;   Only print rows    &lt;rows&gt;. Default is 'all'
                           Ranges and lists supported as 2,4-7,8-
                           Trailing - is to end of data
                           Negative rows count from tail -8--2 is allowed
                --head[=n] Alias for -R1..n   where n defaults to 10
                --tail[=n] Alias for -R-n-    where n defaults to 10
               -C &lt;cols&gt;   Only print columns &lt;cols&gt;. Default is 'all'
               -F &lt;flds&gt;   Only fields &lt;flds&gt; e.g. -FA3,B16
            Ordering (column numbers in result set *after* selection):
               --sort=spec Sort output (e.g. --sort=3,2r,5n,1rn+2)
                           +#   - first # lines do not sort (header)
                           #    - order on column # lexical ascending
                           #n   - order on column # numeric ascending
                           #r   - order on column # lexical descending
                           #rn  - order on column # numeric descending

        Examples:
            xlscat   -i foo.xls
            xlscat   --in-sep=: --sort=3n -L <a href="file:/etc/passwd">/etc/passwd</a>
            xlsgrep  pattern file.ods

   <b>"xlsgrep"</b>
       Show (parts of) a spreadsheet that match a pattern in plain text, CSV, or HTML

        usage: xlsgrep  [-s &lt;sep&gt;] [-L] [-n] [-A] [-u] [Selection] pattern file.xls
                        [-c | -m]                 [-u] [Selection] pattern file.xls
                         -i                            [-S sheets] pattern file.xls
            Generic options:
               -v[#]       Set verbose level (xlscat/xlsgrep)
               -d[#]       Set debug   level (Spreadsheet::Read)
               --list      Show supported spreadsheet formats and exit
               -u          Use unformatted values
               --strip[=#] Strip leading and/or traing spaces of all cells
                           # &amp; 01 = leading, # &amp; 02 = trailing, 3 = default
               --clip=#    Clip cells to max length #
               --noclip    Do not strip empty sheets and
                           trailing empty rows and columns
               --no-empty  Skip empty rows
                --no-nl[=R] Replace all newlines in cells with R (default space)
               -e &lt;enc&gt;    Set encoding for input and output
               -b &lt;enc&gt;    Set encoding for input
               -a &lt;enc&gt;    Set encoding for output
               -U          Set encoding for output to utf-8 (short for -a utf-8)
            Input CSV:
               --in-sep=c  Set input sep_char for CSV (c can be 'TAB')
            Input XLS:
               --dtfmt=fmt Specify the default date format to replace 'm-d-yy'
                           the default replacement is 'yyyy-mm-dd'
               --passwd=pw Specify the password for workbook
                           if pw = -, read password from keyboard
               --formulas  Show the formula instead of the value
            Output Text (default):
               -s &lt;sep&gt;    Use separator &lt;sep&gt;. Default '|', \n allowed
                           Overrules ',' when used with --csv
               -L          Line up the columns
               -B  --box   Like -L but also add outer frame
               -n [skip]   Number lines (prefix with column number)
                           optionally skip &lt;skip&gt; (header) lines
               -A          Show field attributes in ANSI escapes
               -h[#]       Show # header lines
               -D          Dump each record with Data::Peek or Data::Dumper
                --hash     Like -D but as hash with first row as keys
            Output CSV:
               -c          Output CSV, separator = ','
               -m          Output CSV, separator = ';'
            Grep options:
               -i          Ignore case
               -w          Match whole words only
            Output HTML:
               -H          Output HTML
            Selection:
               -S &lt;sheets&gt; Only print sheets &lt;sheets&gt;. 'all' is a valid set
                           Default only prints the first sheet
               -R &lt;rows&gt;   Only print rows    &lt;rows&gt;. Default is 'all'
                           Ranges and lists supported as 2,4-7,8-
                           Trailing - is to end of data
                           Negative rows count from tail -8--2 is allowed
                --head[=n] Alias for -R1..n   where n defaults to 10
                --tail[=n] Alias for -R-n-    where n defaults to 10
               -C &lt;cols&gt;   Only print columns &lt;cols&gt;. Default is 'all'
               -F &lt;flds&gt;   Only fields &lt;flds&gt; e.g. -FA3,B16
            Ordering (column numbers in result set *after* selection):
               --sort=spec Sort output (e.g. --sort=3,2r,5n,1rn+2)
                           +#   - first # lines do not sort (header)
                           #    - order on column # lexical ascending
                           #n   - order on column # numeric ascending
                           #r   - order on column # lexical descending
                           #rn  - order on column # numeric descending

        Examples:
            xlscat   -i foo.xls
            xlscat   --in-sep=: --sort=3n -L <a href="file:/etc/passwd">/etc/passwd</a>
            xlsgrep  pattern file.ods

   <b>"xlsx2csv"</b>
       Convert a spreadsheet to CSV. This is just a small wrapper over "xlscat".

        usage: xlsx2csv [-A [-N | -J c] | -o file.csv] [-s sep] [-f] [-i] file.xls
               xlsx2csv --help | --man | --info
                  --list    List supported spreadsheet formats and exit
            -A    --all     Export all sheets      (filename-sheetname.csv)
            -N    --no-pfx  No filene prefix on -A (sheetname.csv)
            -Z    --zip     Convert sheets to CSV's in ZIP
            -J s  --join=s  Use s to join filename-sheetname (-)
            -o f  --out=f   Set output filename
            -i f  --in=f    Set input  filename
            -f    --force   Force overwrite output if exists
            -s s  --sep=s   Set CSV separator character
        Unless -A is used, all other options are passed on to xlscat

   <b>"xls2csv"</b>
       Convert a spreadsheet to CSV. This is identical to "xlsx2csv"

   <b>"ss2tk"</b>
       Show a spreadsheet in a perl/Tk spreadsheet widget

        usage: ss2tk [options] [X11 options] file.xls [&lt;pattern&gt;]
               -w &lt;width&gt; use &lt;width&gt; as column width
               -L         Add spreadsheet tags to top (A, B, ..Z, AB, ...)
                          and left (1, 2, ...)
               --fs[=7]   Set font size (default 7 if no value)
               --fn=name  Set font Face name (default is DejaVu Sans Mono
                          if font size is given

   <b>"ssdiff"</b>
       Show the differences between two spreadsheets.

        usage: ssdiff [--verbose[=1]] file.xls file.xlsx

</pre><h4><b>Vulnerabilities</b></h4><pre>
       As  this is just a wrapper over the actual parsers, it cannot vouch for vulnerabilities in these parsers.
       We try to keep up with the CVE's as published, and check for weaknesses. For a more thorough  report  see
       this      security-posting      &lt;https://security.metacpan.org/2024/02/10/vulnerable-spreadsheet-parsing-
       modules.html&gt;.

       For vulnerabilities in this module, please read <u>SECURITY.md</u>.

</pre><h4><b>TODO</b></h4><pre>
       Options
           Module Options
             New Spreadsheet::Read options are bound to happen. I'm thinking of  an  option  that  disables  the
             reading  of  the  data  entirely to speed up an index request (how many sheets/fields/columns). See
             "xlscat -i".

           Parser options
             Try to transparently support  as  many  options  as  the  encapsulated  modules  support  regarding
             (un)formatted values, (date) formats, hidden columns rows or fields etc. These could be implemented
             like "attr" above but names "meta", or just be new values in the "attr" hashes.

       Other parsers
           Add support for new(er) parsers for already supported formats, like

           Data::XLSX::Parser
             Data::XLSX::Parser  provides  faster way to parse Microsoft Excel's .xlsx files. The implementation
             of this module is highly inspired from Python's FastXLSX library.

             This is SAX based parser, so you can parse very large XLSX file with lower memory usage.

             Last commit 2021-02-16, so I will take PR's but won't do it myself as there seems to be little gain
             in supporting this.

       Other spreadsheet formats
           I consider adding any spreadsheet interface that offers a usable API.

           Under investigation:

           Kspread (.ksp)
             Now knows as Calligra Sheets.

             I have seen no existing CPAN module yet.

             It is XML in ZIP

       Alternative parsers for existing formats
           As long as the alternative has a good reason for its existence, and the API of that parser reasonable
           fits in my approach, I will consider to implement the glue layer, or apply patches to do so  as  long
           as these match what <u>CONTRIBUTING.md</u> describes.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Text::CSV_XS, Text::CSV_PP
         See         Text::CSV_XS        &lt;https://metacpan.org/release/Text-CSV_XS&gt;        ,        Text::CSV_PP
         &lt;https://metacpan.org/release/Text-CSV&gt;   ,   and   Text::CSV   &lt;https://metacpan.org/release/Text-CSV&gt;
         documentation.

         Text::CSV  &lt;https://metacpan.org/release/Text-CSV&gt; is a wrapper over Text::CSV_XS (the fast XS version)
         and/or Text::CSV_PP &lt;https://metacpan.org/release/Text-CSV&gt; (the pure perl version).

       Spreadsheet::ParseExcel
         Spreadsheet::ParseExcel &lt;https://metacpan.org/release/Spreadsheet-ParseExcel&gt; is the  best  parser  for
         old-style  Microsoft  Excel  (.xls) files.  Most recent commit was Dec 2023. Please use version 0.66 or
         higher to prevent possible memory bombs.

       Spreadsheet::ParseXLSX
         Spreadsheet::ParseXLSX       &lt;https://metacpan.org/release/Spreadsheet-ParseXLSX&gt;        is        like
         Spreadsheet::ParseExcel  &lt;https://metacpan.org/release/Spreadsheet-ParseExcel&gt;,  but  for new Microsoft
         Excel 2007+ files (.xlsx). They have the same API.

         This module uses XML::Twig &lt;https://metacpan.org/release/XML-Twig&gt; to  parse  the  internal  XML.  Most
         recent commit was in Dec 2023. Please use version 0.29 or higher to prevent possible memory bombs.

       Spreadsheet::XLSX
         See Spreadsheet::XLSX &lt;https://metacpan.org/release/Spreadsheet-XLSX&gt; documentation.

         This  module  is  dead  and deprecated. It is <b>buggy</b> <b>and</b> <b>unmaintained</b> (Most recent commit was Oct 2014).
         <u>Please</u> use Spreadsheet::ParseXLSX &lt;https://metacpan.org/release/Spreadsheet-ParseXLSX&gt; instead.

       Excel::ValueReader::XLSX
         See Excel::ValueReader::XLSX &lt;https://metacpan.org/release/Excel-ValueReader-XLSX&gt; documentation.

         This module aims at speed-reading ignoring all attributes and formatting.

         Using this backend does not, and will  not,  support  parsing  strings,  string-refs,  or  globs.  Only
         filenames and file handles are supported.

       Spreadsheet::ParseODS
         Spreadsheet::ParseODS     &lt;https://metacpan.org/pod/Spreadsheet::ParseODS&gt;     is    a    parser    for
         OpenOffice/LibreOffice (.sxc and .ods) spreadsheet files. It is the successor of   Spreadsheet::ReadSXC
         &lt;https://metacpan.org/release/Spreadsheet-ReadSXC&gt;.

       Spreadsheet::ReadSXC
         Spreadsheet::ReadSXC     &lt;https://metacpan.org/release/Spreadsheet-ReadSXC&gt;    is    a    parser    for
         OpenOffice/LibreOffice (.sxc and .ods) spreadsheet files.

       Spreadsheet::ReadGnumeric
         Spreadsheet::ReadGnumeric  &lt;https://metacpan.org/release/Spreadsheet-ReadGnumeric&gt;  is  a  parser   for
         Gnumeric &lt;<a href="http://www.gnumeric.org/">http://www.gnumeric.org/</a>&gt; (.gnumeric) spreadsheet files.

       Spreadsheet::BasicRead
         See   Spreadsheet::BasicRead   &lt;https://metacpan.org/release/Spreadsheet-BasicRead&gt;   for   xlscat-like
         functionality (Excel only)

       Spreadsheet::ConvertAA
         See Spreadsheet::ConvertAA &lt;https://metacpan.org/release/Spreadsheet-ConvertAA&gt; for an alternative  set
         of "cell2cr"/"cr2cell" pair.

       Spreadsheet::Perl
         Spreadsheet::Perl  &lt;https://metacpan.org/release/Spreadsheet-Perl&gt; offers a Pure Perl implementation of
         a spreadsheet engine.  Users that want this format to be  supported  in  Spreadsheet::Read  are  hereby
         motivated to offer patches. It is not high on my TODO-list.

       Spreadsheet::CSV
         Spreadsheet::CSV  &lt;https://metacpan.org/release/Spreadsheet-CSV&gt;  offers  the  interesting  approach of
         seeing  all  supported  spreadsheet  formats  as  if  it   were   CSV,   mimicking   the   Text::CSV_XS
         &lt;https://metacpan.org/release/Text-CSV_XS&gt; interface.

       xls2csv
         xls2csv &lt;https://github.com/Tux/Spreadsheet-Read/blob/master/scripts/xls2csv&gt; offers an alternative for
         my  "xlscat  -c",  in  the  xls2csv tool, but this tool focuses on character encoding transparency, and
         requires some other modules.

</pre><h4><b>AUTHOR</b></h4><pre>
       H.Merijn Brand &lt;<a href="mailto:perl5@tux.freedom.nl">perl5@tux.freedom.nl</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2005-2025 H.Merijn Brand

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.40.1                                       2025-03-29                                          <u><a href="../man3pm/Read.3pm.html">Read</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>