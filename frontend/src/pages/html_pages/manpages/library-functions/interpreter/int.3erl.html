<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>int - Interpreter Interface.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       int - Interpreter Interface.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  Erlang  interpreter  provides  mechanisms  for  breakpoints  and  stepwise  execution of code. It is
       primarily intended to be used by Debugger, see the User's Guide and <u><a href="../man3erl/debugger.3erl.html">debugger</a>(3erl)</u>.

       The following can be done from the shell:

         * Specify the modules to be interpreted.

         * Specify breakpoints.

         * Monitor the current status of all processes executing code in interpreted modules, also processes  at
           other Erlang nodes.

       By  <u>attaching</u>  <u>to</u>  a  process executing interpreted code, it is possible to examine variable bindings and
       order stepwise execution. This is done by sending and receiving information to/from the process through a
       third process, called the meta process. You can implement your own  attached  process.  See  <u>int.erl</u>  for
       available functions and <u>dbg_wx_trace.erl</u> for possible messages.

       The  interpreter depends on the Kernel, STDLIB, and GS applications. This means that modules belonging to
       any of these applications are not allowed to be interpreted, as it could lead to a deadlock  or  emulator
       crash. This also applies to modules belonging to the Debugger application.

</pre><h4><b>BREAKPOINTS</b></h4><pre>
       Breakpoints are specified on a line basis. When a process executing code in an interpreted module reaches
       a  breakpoint,  it stops. This means that a breakpoint must be set at an executable line, that is, a code
       line containing an executable expression.

       A breakpoint has the following:

         * A status, which is <u>active</u> or <u>inactive</u>. An inactive breakpoint is ignored.

         * A trigger action. When a breakpoint is reached, the trigger action specifies if the breakpoint is  to
           continue as active (<u>enable</u>), or to become inactive (<u>disable</u>), or to be removed (<u>delete</u>).

         * Optionally  an  associated  condition.  A  condition is a tuple <u>{Module,Name}</u>. When the breakpoint is
           reached, <u>Module:Name(Bindings)</u> is called. If it evaluates to <u>true</u>, execution stops. If  it  evaluates
           to <u>false</u>, the breakpoint is ignored. <u>Bindings</u> contains the current variable bindings. To retrieve the
           value for a specified variable, use <u>get_binding</u>.

       By  default,  a  breakpoint  is  active,  has trigger action <u>enable</u>, and has no associated condition. For
       details about breakpoints, see the User's Guide.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>i(AbsModule)</b> <b>-&gt;</b> <b>{module,Module}</b> <b>|</b> <b>error</b>
       <b>i(AbsModules)</b> <b>-&gt;</b> <b>ok</b>
       <b>ni(AbsModule)</b> <b>-&gt;</b> <b>{module,Module}</b> <b>|</b> <b>error</b>
       <b>ni(AbsModules)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 AbsModules = [AbsModule]
                 AbsModule = Module | File | [Module | File]
                  Module = atom()
                  File = string()

              Interprets the specified module(s). <u>i/1</u> interprets the module  only  at  the  current  node.  <u>ni/1</u>
              interprets the module at all known nodes.

              A module can be specified by its module name (atom) or filename.

              If  specified by its module name, the object code <u>Module.beam</u> is searched for in the current path.
              The source code <u>Module.erl</u> is searched for first in the same directory as the object code, then in
              an <u>src</u> directory next to it.

              If specified by its filename, the filename can include a  path  and  the  <u>.erl</u>  extension  can  be
              omitted.  The  object  code  <u>Module.beam</u> is searched for first in the same directory as the source
              code, then in an <u>ebin</u> directory next to it, and then in the current path.

          <b>Note:</b>
              The interpreter requires both the source code and the object code. The object  code  <u>must</u>  include
              debug information, that is, only modules compiled with option <u>debug_info</u> set can be interpreted.

              The functions returns <u>{module,Module}</u> if the module was interpreted, otherwise <u>error</u> is returned.

              The  argument  can  also  be  a  list of modules or filenames, in which case the function tries to
              interpret each module as specified earlier. The function then always returns <u>ok</u>, but  prints  some
              information to <u>stdout</u> if a module cannot be interpreted.

       <b>n(AbsModule)</b> <b>-&gt;</b> <b>ok</b>
       <b>nn(AbsModule)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 AbsModule = Module | File | [Module | File]
                  Module = atom()
                  File = string()

              Stops  interpreting  the  specified  module. <u>n/1</u> stops interpreting the module only at the current
              node. <u>nn/1</u> stops interpreting the module at all known nodes.

              As for <u>i/1</u> and <u>ni/1</u>, a module can be specified by its module name or filename.

       <b>interpreted()</b> <b>-&gt;</b> <b>[Module]</b>

              Types:

                 Module = atom()

              Returns a list with all interpreted modules.

       <b>file(Module)</b> <b>-&gt;</b> <b>File</b> <b>|</b> <b>{error,not_loaded}</b>

              Types:

                 Module = atom()
                 File = string()

              Returns the source code filename <u>File</u> for an interpreted module <u>Module</u>.

       <b>interpretable(AbsModule)</b> <b>-&gt;</b> <b>true</b> <b>|</b> <b>{error,Reason}</b>

              Types:

                 AbsModule = Module | File
                  Module = atom()
                  File = string()
                 Reason = no_src | no_beam | no_debug_info | badarg | {app,App}
                  App = atom()

              Checks if a module can be interpreted. The module can be specified by its module  name  <u>Module</u>  or
              its  source  filename  <u>File</u>. If specified by a module name, the module is searched for in the code
              path.

              The function returns <u>true</u> if all of the following apply:

                * Both source code and object code for the module is found.

                * The module has been compiled with option <u>debug_info</u> set.

                * The module does not belong to any of the applications Kernel, STDLIB, GS, or Debugger.

              The function returns <u>{error,Reason}</u> if the module cannot  be  interpreted.  <u>Reason</u>  can  have  the
              following values:

                <u>no_src</u>:
                  No source code is found. It is assumed that the source code and object code are located either
                  in the same directory, or in <u>src</u> and <u>ebin</u> directories next to each other.

                <u>no_beam</u>:
                  No object code is found. It is assumed that the source code and object code are located either
                  in the same directory, or in <u>src</u> and <u>ebin</u> directories next to each other.

                <u>no_debug_info</u>:
                  The module has not been compiled with option <u>debug_info</u> set.

                <u>badarg</u>:
                  <u>AbsModule</u>  is  not  found. This could be because the specified file does not exist, or because
                  <u>code:which/1</u> does not return a BEAM filename, which is the  case  not  only  for  non-existing
                  modules but also for modules that are preloaded or cover-compiled.

                <u>{app,App}</u>:
                  <u>App</u> is <u>kernel</u>, <u>stdlib</u>, <u>gs</u>, or <u>debugger</u> if <u>AbsModule</u> belongs to one of these applications.

              Notice  that  the  function  can return <u>true</u> for a module that in fact is not interpretable in the
              case where the module is marked as sticky or resides in a directory marked as sticky.  The  reason
              is that this is not discovered until the interpreter tries to load the module.

       <b>auto_attach()</b> <b>-&gt;</b> <b>false</b> <b>|</b> <b>{Flags,Function}</b>
       <b>auto_attach(false)</b>
       <b>auto_attach(Flags,</b> <b>Function)</b>

              Types:

                 Flags = [init | break | exit]
                 Function = {Module,Name,Args}
                  Module = Name = atom()
                  Args = [term()]

              Gets  and  sets  when  and  how to attach automatically to a process executing code in interpreted
              modules. <u>false</u> means never attach automatically, this is the default. Otherwise  automatic  attach
              is defined by a list of flags and a function. The following flags can be specified:

                * <u>init</u> - Attach when a process for the first time calls an interpreted function.

                * <u>break</u> - Attach whenever a process reaches a breakpoint.

                * <u>exit</u> - Attach when a process terminates.

              When the specified event occurs, the function <u>Function</u> is called as:

              spawn(Module, Name, [Pid | Args])

              <u>Pid</u> is the pid of the process executing interpreted code.

       <b>stack_trace()</b> <b>-&gt;</b> <b>Flag</b>
       <b>stack_trace(Flag)</b>

              Types:

                 Flag = all | no_tail | false

              Gets  and  sets  how  to  save  call  frames in the stack. Saving call frames makes it possible to
              inspect the call chain of a process, and is also used to emulate the stack trace if an  error  (an
              exception of class error) occurs. The following flags can be specified:

                <u>all</u>:
                  Save information about all current calls, that is, function calls that have not yet returned a
                  value.

                <u>no_tail</u>:
                  Save  information  about current calls, but discard previous information when a tail recursive
                  call is made. This option consumes less memory and can be necessary to use for processes  with
                  long lifetimes and many tail recursive calls. This is the default.

                <u>false</u>:
                  Save no information about current calls.

       <b>break(Module,</b> <b>Line)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,break_exists}</b>

              Types:

                 Module = atom()
                 Line = int()

              Creates a breakpoint at <u>Line</u> in <u>Module</u>.

       <b>delete_break(Module,</b> <b>Line)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()
                 Line = int()

              Deletes the breakpoint at <u>Line</u> in <u>Module</u>.

       <b>break_in(Module,</b> <b>Name,</b> <b>Arity)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,function_not_found}</b>

              Types:

                 Module = Name = atom()
                 Arity = int()

              Creates a breakpoint at the first line of every clause of function <u>Module:Name/Arity</u>.

       <b>del_break_in(Module,</b> <b>Name,</b> <b>Arity)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,function_not_found}</b>

              Types:

                 Module = Name = atom()
                 Arity = int()

              Deletes the breakpoints at the first line of every clause of function <u>Module:Name/Arity</u>.

       <b>no_break()</b> <b>-&gt;</b> <b>ok</b>
       <b>no_break(Module)</b> <b>-&gt;</b> <b>ok</b>

              Deletes all breakpoints, or all breakpoints in <u>Module</u>.

       <b>disable_break(Module,</b> <b>Line)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()
                 Line = int()

              Makes the breakpoint at <u>Line</u> in <u>Module</u> inactive.

       <b>enable_break(Module,</b> <b>Line)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()
                 Line = int()

              Makes the breakpoint at <u>Line</u> in <u>Module</u> active.

       <b>action_at_break(Module,</b> <b>Line,</b> <b>Action)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()
                 Line = int()
                 Action = enable | disable | delete

              Sets the trigger action of the breakpoint at <u>Line</u> in <u>Module</u> to <u>Action</u>.

       <b>test_at_break(Module,</b> <b>Line,</b> <b>Function)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()
                 Line = int()
                 Function = {Module,Name}
                  Name = atom()

              Sets  the  conditional  test  of  the  breakpoint at <u>Line</u> in <u>Module</u> to <u>Function</u>. The function must
              fulfill the requirements specified in section Breakpoints.

       <b>get_binding(Var,</b> <b>Bindings)</b> <b>-&gt;</b> <b>{value,Value}</b> <b>|</b> <b>unbound</b>

              Types:

                 Var = atom()
                 Bindings = term()
                 Value = term()

              Retrieves the binding of <u>Var</u>. This function is intended to be used by the conditional function  of
              a breakpoint.

       <b>all_breaks()</b> <b>-&gt;</b> <b>[Break]</b>
       <b>all_breaks(Module)</b> <b>-&gt;</b> <b>[Break]</b>

              Types:

                 Break = {Point,Options}
                  Point = {Module,Line}
                  Module = atom()
                  Line = int()
                  Options = [Status,Trigger,null,Cond|]
                  Status = active | inactive
                  Trigger = enable | disable | delete
                  Cond = null | Function
                  Function = {Module,Name}
                  Name = atom()

              Gets all breakpoints, or all breakpoints in <u>Module</u>.

       <b>snapshot()</b> <b>-&gt;</b> <b>[Snapshot]</b>

              Types:

                 Snapshot = {Pid, Function, Status, Info}
                  Pid = pid()
                  Function = {Module,Name,Args}
                  Module = Name = atom()
                  Args = [term()]
                  Status = idle | running | waiting | break | exit | no_conn
                  Info = {} | {Module,Line} | ExitReason
                  Line = int()
                  ExitReason = term()

              Gets information about all processes executing interpreted code.

                * <u>Pid</u> - Process identifier.

                * <u>Function</u> - First interpreted function called by the process.

                * <u>Status</u> - Current status of the process.

                * <u>Info</u> - More information.

              <u>Status</u> is one of the following:

                * <u>idle</u> - The process is no longer executing interpreted code. <u>Info={}</u>.

                * <u>running</u> - The process is running. <u>Info={}</u>.

                * <u>waiting</u> - The process is waiting at a <u>receive</u>. <u>Info={}</u>.

                * <u>break</u> - Process execution is stopped, normally at a breakpoint. <u>Info={Module,Line}</u>.

                * <u>exit</u> - The process is terminated. <u>Info=ExitReason</u>.

                * <u>no_conn</u> - The connection is down to the node where the process is running. <u>Info={}</u>.

       <b>clear()</b> <b>-&gt;</b> <b>ok</b>

              Clears  information  about  processes executing interpreted code by removing all information about
              terminated processes.

       <b>continue(Pid)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,not_interpreted}</b>
       <b>continue(X,Y,Z)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,not_interpreted}</b>

              Types:

                 Pid = pid()
                 X = Y = Z = int()

              Resumes process execution for <u>Pid</u> or <u>c:pid(X,Y,Z)</u>.

Ericsson AB                                       debugger 5.2                                         <u><a href="../man3erl/int.3erl.html">int</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>