<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>interp - Create and manipulate Tcl interpreters</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       interp - Create and manipulate Tcl interpreters

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>interp</b> <u>subcommand</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This command makes it possible to create one or more new Tcl interpreters that co-exist with the creating
       interpreter  in  the  same  application.   The  creating  interpreter  is  called  the <u>parent</u> and the new
       interpreter is called a <u>child</u>.  A parent can create any number of children, and  each  child  can  itself
       create additional children for which it is parent, resulting in a hierarchy of interpreters.

       Each  interpreter is independent from the others: it has its own name space for commands, procedures, and
       global variables.  A parent interpreter may create connections between its children and  itself  using  a
       mechanism  called  an  <u>alias</u>.  An <u>alias</u> is a command in a child interpreter which, when invoked, causes a
       command to be invoked in its parent  interpreter  or  in  another  child  interpreter.   The  only  other
       connections between interpreters are through environment variables (the <b>env</b> variable), which are normally
       shared among all interpreters in the application, and by resource limit exceeded callbacks. Note that the
       name  space  for  files  (such  as  the  names  returned by the <b>open</b> command) is no longer shared between
       interpreters. Explicit commands are provided to share files and to transfer references to open files from
       one interpreter to another.

       The <b>interp</b> command also provides support for <u>safe</u> interpreters.  A safe  interpreter  is  a  child  whose
       functions  have  been greatly restricted, so that it is safe to execute untrusted scripts without fear of
       them damaging other interpreters or the application's environment. For example, all IO  channel  creation
       commands  and  subprocess  creation  commands  are  made  inaccessible  to  safe  interpreters.  See <b>SAFE</b>
       <b>INTERPRETERS</b> below for more information on  what  features  are  present  in  a  safe  interpreter.   The
       dangerous  functionality  is  not  removed from the safe interpreter; instead, it is <u>hidden</u>, so that only
       trusted interpreters can obtain access to it. For a detailed explanation of hidden commands,  see  <b>HIDDEN</b>
       <b>COMMANDS</b>,  below.   The  alias  mechanism  can be used for protected communication (analogous to a kernel
       call) between a child interpreter and its parent.  See <b>ALIAS</b> <b>INVOCATION</b>, below, for more details  on  how
       the alias mechanism works.

       A qualified interpreter name is a proper Tcl list containing a subset of its ancestors in the interpreter
       hierarchy, terminated by the string naming the interpreter in its immediate parent. Interpreter names are
       relative  to  the  interpreter  in  which  they  are  used. For example, if “<b>a</b>” is a child of the current
       interpreter and it has a child “<b>a1</b>”, which in turn has a child “<b>a11</b>”, the qualified name of “<b>a11</b>” in  “<b>a</b>”
       is the list “<b>a1</b> <b>a11</b>”.

       The <b>interp</b> command, described below, accepts qualified interpreter names as arguments; the interpreter in
       which  the  command  is  being evaluated can always be referred to as <b>{}</b> (the empty list or string). Note
       that it is impossible to refer to a parent (ancestor) interpreter by name in a child  interpreter  except
       through aliases. Also, there is no global name by which one can refer to the first interpreter created in
       an application.  Both restrictions are motivated by safety concerns.

</pre><h4><b>THE</b> <b>INTERP</b> <b>COMMAND</b></h4><pre>
       The <b>interp</b> command is used to create, delete, and manipulate child interpreters, and to share or transfer
       channels between interpreters.  It can have any of several forms, depending on the <u>subcommand</u> argument:

       <b>interp</b> <b>alias</b> <u>srcPath</u> <u>srcToken</u>
              Returns a Tcl list whose elements are the <u>targetCmd</u> and <u>arg</u>s associated with the alias represented
              by  <u>srcToken</u>  (this is the value returned when the alias was created; it is possible that the name
              of the source command in the child is different from <u>srcToken</u>).

       <b>interp</b> <b>alias</b> <u>srcPath</u> <u>srcToken</u> <b>{}</b>
              Deletes the alias for <u>srcToken</u> in the child interpreter identified by <u>srcPath</u>.  <u>srcToken</u> refers to
              the value returned when the alias was created;  if  the  source  command  has  been  renamed,  the
              renamed command will be deleted.

       <b>interp</b> <b>alias</b> <u>srcPath</u> <u>srcCmd</u> <u>targetPath</u> <u>targetCmd</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
              This command creates an alias between one child and another (see the <b>alias</b> child command below for
              creating  aliases  between  a  child  and  its  parent).   In  this  command,  either of the child
              interpreters may be anywhere in the hierarchy of interpreters under the interpreter  invoking  the
              command.   <u>SrcPath</u>  and  <u>srcCmd</u>  identify  the  source  of the alias.  <u>SrcPath</u> is a Tcl list whose
              elements select a particular interpreter.  For example, “<b>a</b> <b>b</b>” identifies an interpreter “<b>b</b>”, which
              is a child of interpreter “<b>a</b>”, which is a child  of  the  invoking  interpreter.   An  empty  list
              specifies  the  interpreter  invoking  the command.  <u>srcCmd</u> gives the name of a new command, which
              will be created in the source interpreter.  <u>TargetPath</u> and <u>targetCmd</u> specify a target  interpreter
              and  command,  and  the <u>arg</u> arguments, if any, specify additional arguments to <u>targetCmd</u> which are
              prepended to any arguments specified in the invocation of <u>srcCmd</u>.  <u>TargetCmd</u> may be  undefined  at
              the  time  of  this  call,  or it may already exist; it is not created by this command.  The alias
              arranges for the given target command to be invoked in the target interpreter whenever  the  given
              source command is invoked in the source interpreter.  See <b>ALIAS</b> <b>INVOCATION</b> below for more details.
              The  command  returns  a  token  that  uniquely identifies the command created <u>srcCmd</u>, even if the
              command is renamed afterwards. The token may but does not have to be equal to <u>srcCmd</u>.

       <b>interp</b> <b>aliases</b> ?<u>path</u>?
              This command returns a Tcl list of the tokens of all the source commands for  aliases  defined  in
              the  interpreter identified by <u>path</u>. The tokens correspond to the values returned when the aliases
              were created (which may not be the same as the current names of the commands).

       <b>interp</b> <b>bgerror</b> <u>path</u> ?<u>cmdPrefix</u>?
              This command either gets or sets the current background  exception  handler  for  the  interpreter
              identified  by <u>path</u>. If <u>cmdPrefix</u> is absent, the current background exception handler is returned,
              and if it is present, it is a list of words (of minimum length one) that describes what to set the
              interpreter's background exception handler to. See the <b>BACKGROUND</b> <b>EXCEPTION</b> <b>HANDLING</b>  section  for
              more details.

       <b>interp</b> <b>cancel</b> ?<b>-unwind</b>? ?<b>--</b>? ?<u>path</u>? ?<u>result</u>?
              Cancels  the  script  being  evaluated  in the interpreter identified by <u>path</u>. Without the <b>-unwind</b>
              switch the evaluation stack for the interpreter is unwound until an  enclosing  catch  command  is
              found  or  there  are  no  further invocations of the interpreter left on the call stack. With the
              <b>-unwind</b> switch the evaluation  stack  for  the  interpreter  is  unwound  without  regard  to  any
              intervening  catch  command  until there are no further invocations of the interpreter left on the
              call stack. The <b>--</b> switch can be used to mark the end of switches; it may be needed if <u>path</u> is  an
              unusual  value  such  as <b>-safe</b>. If <u>result</u> is present, it will be used as the error message string;
              otherwise, a default error message string will be used.

       <b>interp</b> <b>children</b> ?<u>path</u>?
              Returns a Tcl list of the names of all the child  interpreters  associated  with  the  interpreter
              identified by <u>path</u>. If <u>path</u> is omitted, the invoking interpreter is used.

       <b>interp</b> <b>create</b> ?<b>-safe</b>? ?<b>--</b>? ?<u>path</u>?
              Creates a child interpreter identified by <u>path</u> and a new command, called a <u>child</u> <u>command</u>. The name
              of  the  child  command  is  the  last  component of <u>path</u>. The new child interpreter and the child
              command are created in the interpreter identified by  the  path  obtained  by  removing  the  last
              component  from <u>path</u>. For example, if <u>path</u> is <b>a</b> <b>b</b> <b>c</b> then a new child interpreter and child command
              named <b>c</b> are created in the interpreter identified by the path <b>a</b> <b>b</b>.  The child command may be  used
              to  manipulate  the  new  interpreter as described below. If <u>path</u> is omitted, Tcl creates a unique
              name of the form <b>interp</b><u>x</u>, where <u>x</u> is an integer, and uses it for the  interpreter  and  the  child
              command.  If  the  <b>-safe</b> switch is specified (or if the parent interpreter is a safe interpreter),
              the new child interpreter will be created  as  a  safe  interpreter  with  limited  functionality;
              otherwise  the  child  will  include  the  full set of Tcl built-in commands and variables. The <b>--</b>
              switch can be used to mark the end of switches;  it may be needed if <u>path</u> is an unusual value such
              as <b>-safe</b>. The result of the command is the name of the  new  interpreter.  The  name  of  a  child
              interpreter  must  be  unique  among  all the children for its parent;  an error occurs if a child
              interpreter by the given name already exists in this parent.  The initial recursion limit  of  the
              child interpreter is set to the current recursion limit of its parent interpreter.

       <b>interp</b> <b>debug</b> <u>path</u> ?<b>-frame</b> ?<u>bool</u>??
              Controls  whether frame-level stack information is captured in the child interpreter identified by
              <u>path</u>.  If no arguments are given, option and current setting are returned.  If  <b>-frame</b>  is  given,
              the  debug  setting  is  set to the given boolean if provided and the current setting is returned.
              This only affects the output of <b>info</b> <b>frame</b>, in that  exact  frame-level  information  for  command
              invocation at the bytecode level is only captured with this setting on.

              For example, with code like

                     <b>proc</b> mycontrol {... script} {
                       ...
                       <b>uplevel</b> 1 $script
                       ...
                     }

                     <b>proc</b> dosomething {...} {
                       ...
                       mycontrol {
                         somecode
                       }
                     }

              the standard setting will provide a relative line number for the command <b>somecode</b> and the relevant
              frame  will be of type <b>eval</b>. With frame-debug active on the other hand the tracking extends so far
              that the system will be able to determine the file and absolute line number of this  command,  and
              return  a  frame  of type <b>source</b>. This more exact information is paid for with slower execution of
              all commands.

              Note that once it is on, this flag cannot  be  switched  back  off:  such  attempts  are  silently
              ignored. This is needed to maintain the consistency of the underlying interpreter's state.

       <b>interp</b> <b>delete</b> ?<u>path</u> <u>...</u>?
              Deletes  zero or more interpreters given by the optional <u>path</u> arguments, and for each interpreter,
              it also deletes its children. The command also deletes the  child  command  for  each  interpreter
              deleted.   For  each  <u>path</u>  argument, if no interpreter by that name exists, the command raises an
              error.

       <b>interp</b> <b>eval</b> <u>path</u> <u>arg</u> ?<u>arg</u> <u>...</u>?
              This command concatenates all of the <u>arg</u> arguments in the same fashion as the <b>concat</b> command, then
              evaluates the resulting string as a Tcl script in the child interpreter identified  by  <u>path</u>.  The
              result  of  this  evaluation  (including  all  <b>return</b>  options,  such as <b>-errorinfo</b> and <b>-errorcode</b>
              information, if an error occurs) is returned to the invoking interpreter.

              Note that the script will be executed in the current context stack frame of the <u>path</u>  interpreter;
              this  is  so  that the implementations (in a parent interpreter) of aliases in a child interpreter
              can execute scripts in the child that find out information about the  child's  current  state  and
              stack frame.

       <b>interp</b> <b>exists</b> <u>path</u>
              Returns <b>1</b> if a child interpreter by the specified <u>path</u> exists in this parent, <b>0</b> otherwise. If <u>path</u>
              is omitted, the invoking interpreter is used.

       <b>interp</b> <b>expose</b> <u>path</u> <u>hiddenName</u> ?<u>exposedCmdName</u>?
              Makes   the   hidden  command  <u>hiddenName</u>  exposed,  eventually  bringing  it  back  under  a  new
              <u>exposedCmdName</u> name (this name is currently accepted only if it is a valid global name space  name
              without any ::), in the interpreter denoted by <u>path</u>.  If an exposed command with the targeted name
              already  exists,  this  command  fails.   Hidden  commands  are explained in more detail in <b>HIDDEN</b>
              <b>COMMANDS</b>, below.

       <b>interp</b> <b>hide</b> <u>path</u> <u>exposedCmdName</u> ?<u>hiddenCmdName</u>?
              Makes the exposed command <u>exposedCmdName</u> hidden, renaming it to the hidden command  <u>hiddenCmdName</u>,
              or  keeping the same name if <u>hiddenCmdName</u> is not given, in the interpreter denoted by <u>path</u>.  If a
              hidden command with the  targeted  name  already  exists,  this  command  fails.   Currently  both
              <u>exposedCmdName</u>  and  <u>hiddenCmdName</u>  can  not  contain namespace qualifiers, or an error is raised.
              Commands to be hidden by <b>interp</b> <b>hide</b> are looked up in the global namespace  even  if  the  current
              namespace  is  not  the  global one. This prevents children from fooling a parent interpreter into
              hiding the wrong command, by making the current  namespace  be  different  from  the  global  one.
              Hidden commands are explained in more detail in <b>HIDDEN</b> <b>COMMANDS</b>, below.

       <b>interp</b> <b>hidden</b> <u>path</u>
              Returns a list of the names of all hidden commands in the interpreter identified by <u>path</u>.

       <b>interp</b> <b>invokehidden</b> <u>path</u> ?<u>-option</u> <u>...</u>? <u>hiddenCmdName</u> ?<u>arg</u> <u>...</u>?
              Invokes the hidden command <u>hiddenCmdName</u> with the arguments supplied in the interpreter denoted by
              <u>path</u>.  No  substitutions or evaluation are applied to the arguments. Three <u>-option</u>s are supported,
              all of which start with <b>-</b>: <b>-namespace</b> (which takes a single argument afterwards, <u>nsName</u>), <b>-global</b>,
              and <b>--</b>.  If the <b>-namespace</b> flag is present, the hidden command is invoked in the namespace  called
              <u>nsName</u>  in  the target interpreter.  If the <b>-global</b> flag is present, the hidden command is invoked
              at the global level in the target interpreter; otherwise it is invoked at the current  call  frame
              and  can  access  local  variables  in  that  and  outer  call  frames.   The  <b>--</b>  flag allows the
              <u>hiddenCmdName</u> argument to start with a “-” character, and is otherwise unnecessary.  If  both  the
              <b>-namespace</b> and <b>-global</b> flags are present, the <b>-namespace</b> flag is ignored.

              Note  that  the hidden command will be executed (by default) in the current context stack frame of
              the <u>path</u> interpreter.

              Hidden commands are explained in more detail in <b>HIDDEN</b> <b>COMMANDS</b>, below.

       <b>interp</b> <b>issafe</b> ?<u>path</u>?
              Returns <b>1</b> if the interpreter identified by the specified <u>path</u> is safe, <b>0</b> otherwise.

       <b>interp</b> <b>limit</b> <u>path</u> <u>limitType</u> ?<u>-option</u>? ?<u>value</u> <u>...</u>?
              Sets up, manipulates and queries the  configuration  of  the  resource  limit  <u>limitType</u>  for  the
              interpreter  denoted by <u>path</u>.  If no <u>-option</u> is specified, return the current configuration of the
              limit.  If <u>-option</u> is the sole argument, return the value of that option.  Otherwise,  a  list  of
              <u>-option</u>/<u>value</u>  argument  pairs  must  supplied.  See  <b>RESOURCE</b>  <b>LIMITS</b>  below  for a more detailed
              explanation of what limits and options are supported.

       <b>interp</b> <b>marktrusted</b> <u>path</u>
              Marks the interpreter identified by <u>path</u> as trusted. Does not expose  the  hidden  commands.  This
              command  can  only  be  invoked  from  a  trusted  interpreter.   The command has no effect if the
              interpreter identified by <u>path</u> is already trusted.

       <b>interp</b> <b>recursionlimit</b> <u>path</u> ?<u>newlimit</u>?
              Returns the maximum allowable nesting depth for the interpreter specified by <u>path</u>.  If <u>newlimit</u> is
              specified, the interpreter recursion limit will be set so that nesting of more than <u>newlimit</u> calls
              to <b>Tcl_Eval</b> and related procedures in that interpreter will return an error.  The  <u>newlimit</u>  value
              is  also  returned.  The <u>newlimit</u> value must be a positive integer between 1 and the maximum value
              of a non-long integer on the platform.

              The command sets the maximum size of the Tcl call stack only. It cannot by  itself  prevent  stack
              overflows on the C stack being used by the application. If your machine has a limit on the size of
              the  C  stack,  you  may get stack overflows before reaching the limit set by the command. If this
              happens, see if there is a mechanism in your system for increasing  the  maximum  size  of  the  C
              stack.

       <b>interp</b> <b>share</b> <u>srcPath</u> <u>channel</u> <u>destPath</u>
              Causes the IO channel identified by <u>channel</u> to become shared between the interpreter identified by
              <u>srcPath</u> and the interpreter identified by <u>destPath</u>. Both interpreters have the same permissions on
              the  IO  channel.  Both interpreters must close it to close the underlying IO channel; IO channels
              accessible in an interpreter are automatically closed when an interpreter is destroyed.

       <b>interp</b> <b>target</b> <u>path</u> <u>alias</u>
              Returns a Tcl list describing the target interpreter for an alias. The alias is specified with  an
              interpreter  path  and  source command name, just as in <b>interp</b> <b>alias</b> above. The name of the target
              interpreter is returned as an interpreter path, relative to  the  invoking  interpreter.   If  the
              target  interpreter  for  the alias is the invoking interpreter then an empty list is returned. If
              the target interpreter for the alias is not the invoking interpreter or  one  of  its  descendants
              then  an  error  is generated.  The target command does not have to be defined at the time of this
              invocation.

       <b>interp</b> <b>transfer</b> <u>srcPath</u> <u>channel</u> <u>destPath</u>
              Causes the IO channel identified by <u>channel</u> to become available in the interpreter  identified  by
              <u>destPath</u> and unavailable in the interpreter identified by <u>srcPath</u>.

</pre><h4><b>CHILD</b> <b>COMMAND</b></h4><pre>
       For  each  child  interpreter created with the <b>interp</b> command, a new Tcl command is created in the parent
       interpreter with the same name as the new interpreter.  This  command  may  be  used  to  invoke  various
       operations on the interpreter.  It has the following general form:

              <u>child</u> <u>command</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <u>Child</u>  is  the  name  of  the  interpreter,  and <u>command</u> and the <u>arg</u>s determine the exact behavior of the
       command.  The valid forms of this command are:

       <u>child</u> <b>aliases</b>
              Returns a Tcl list whose elements are the  tokens  of  all  the  aliases  in  <u>child</u>.   The  tokens
              correspond  to the values returned when the aliases were created (which may not be the same as the
              current names of the commands).

       <u>child</u> <b>alias</b> <u>srcToken</u>
              Returns a Tcl list whose elements are the <u>targetCmd</u> and <u>arg</u>s associated with the alias represented
              by <u>srcToken</u> (this is the value returned when the alias was created; it is possible that the actual
              source command in the child is different from <u>srcToken</u>).

       <u>child</u> <b>alias</b> <u>srcToken</u> <b>{}</b>
              Deletes the alias for <u>srcToken</u> in the child interpreter.  <u>srcToken</u> refers to  the  value  returned
              when  the  alias was created;  if the source command has been renamed, the renamed command will be
              deleted.

       <u>child</u> <b>alias</b> <u>srcCmd</u> <u>targetCmd</u> ?<u>arg</u> <u>..</u>?
              Creates an alias such that whenever <u>srcCmd</u> is invoked  in  <u>child</u>,  <u>targetCmd</u>  is  invoked  in  the
              parent.   The  <u>arg</u> arguments will be passed to <u>targetCmd</u> as additional arguments, prepended before
              any arguments passed in the invocation of <u>srcCmd</u>.  See <b>ALIAS</b> <b>INVOCATION</b> below  for  details.   The
              command  returns  a token that uniquely identifies the command created <u>srcCmd</u>, even if the command
              is renamed afterwards. The token may but does not have to be equal to <u>srcCmd</u>.

       <u>child</u> <b>bgerror</b> ?<u>cmdPrefix</u>?
              This command either  gets  or  sets  the  current  background  exception  handler  for  the  <u>child</u>
              interpreter.  If <u>cmdPrefix</u> is absent, the current background exception handler is returned, and if
              it is present, it is a list of words (of minimum length  one)  that  describes  what  to  set  the
              interpreter's  background  exception handler to. See the <b>BACKGROUND</b> <b>EXCEPTION</b> <b>HANDLING</b> section for
              more details.

       <u>child</u> <b>eval</b> <u>arg</u> ?<u>arg</u> <u>..</u>?
              This command concatenates all of the <u>arg</u> arguments in the same fashion as the <b>concat</b> command, then
              evaluates the resulting string as a Tcl script in <u>child</u>.  The result of this evaluation (including
              all <b>return</b> options, such as <b>-errorinfo</b> and <b>-errorcode</b> information, if an error occurs) is returned
              to the invoking interpreter.

              Note that the script will be executed in the current context stack frame of <u>child</u>; this is so that
              the implementations (in a parent interpreter) of  aliases  in  a  child  interpreter  can  execute
              scripts in the child that find out information about the child's current state and stack frame.

       <u>child</u> <b>expose</b> <u>hiddenName</u> ?<u>exposedCmdName</u>?
              This  command  exposes  the  hidden  command  <u>hiddenName</u>,  eventually bringing it back under a new
              <u>exposedCmdName</u> name (this name is currently accepted only if it is a valid global name space  name
              without  any  ::),  in  <u>child</u>.   If an exposed command with the targeted name already exists, this
              command fails.  For more details on hidden commands, see <b>HIDDEN</b> <b>COMMANDS</b>, below.

       <u>child</u> <b>hide</b> <u>exposedCmdName</u> ?<u>hiddenCmdName</u>?
              This command hides  the  exposed  command  <u>exposedCmdName</u>,  renaming  it  to  the  hidden  command
              <u>hiddenCmdName</u>,  or  keeping  the same name if the argument is not given, in the <u>child</u> interpreter.
              If a hidden command with the targeted name already exists, this  command  fails.   Currently  both
              <u>exposedCmdName</u>  and  <u>hiddenCmdName</u>  can  not  contain namespace qualifiers, or an error is raised.
              Commands to be hidden are looked up in the global namespace even if the current namespace  is  not
              the  global  one.  This  prevents children from fooling a parent interpreter into hiding the wrong
              command, by making the current namespace be different from the global one.  For  more  details  on
              hidden commands, see <b>HIDDEN</b> <b>COMMANDS</b>, below.

       <u>child</u> <b>hidden</b>
              Returns a list of the names of all hidden commands in <u>child</u>.

       <u>child</u> <b>invokehidden</b> ?<u>-option</u> <u>...</u>? <u>hiddenName</u> ?<u>arg</u> <u>..</u>?
              This  command  invokes  the  hidden  command  <u>hiddenName</u> with the supplied arguments, in <u>child</u>. No
              substitutions or evaluations are applied to the arguments. Three <u>-option</u>s are  supported,  all  of
              which  start  with  <b>-</b>: <b>-namespace</b> (which takes a single argument afterwards, <u>nsName</u>), <b>-global</b>, and
              <b>--</b>.  If the <b>-namespace</b> flag is given, the hidden command is invoked in the specified namespace  in
              the child.  If the <b>-global</b> flag is given, the command is invoked at the global level in the child;
              otherwise  it is invoked at the current call frame and can access local variables in that or outer
              call frames.  The <b>--</b> flag allows the <u>hiddenCmdName</u> argument to start with a “-” character, and  is
              otherwise unnecessary.  If both the <b>-namespace</b> and <b>-global</b> flags are given, the <b>-namespace</b> flag is
              ignored.

              Note  that  the hidden command will be executed (by default) in the current context stack frame of
              <u>child</u>.

              For more details on hidden commands, see <b>HIDDEN</b> <b>COMMANDS</b>, below.

       <u>child</u> <b>issafe</b>
              Returns <b>1</b> if the child interpreter is safe, <b>0</b> otherwise.

       <u>child</u> <b>limit</b> <u>limitType</u> ?<u>-option</u>? ?<u>value</u> <u>...</u>?
              Sets up, manipulates and queries the configuration of the resource limit <u>limitType</u> for  the  child
              interpreter.   If  no  <u>-option</u>  is  specified,  return the current configuration of the limit.  If
              <u>-option</u> is the sole argument, return the value of that option.  Otherwise, a list of <u>-option</u>/<u>value</u>
              argument pairs must supplied. See <b>RESOURCE</b> <b>LIMITS</b> below for a more detailed  explanation  of  what
              limits and options are supported.

       <u>child</u> <b>marktrusted</b>
              Marks the child interpreter as trusted. Can only be invoked by a trusted interpreter. This command
              does  not  expose  any  hidden commands in the child interpreter. The command has no effect if the
              child is already trusted.

       <u>child</u> <b>recursionlimit</b> ?<u>newlimit</u>?
              Returns the maximum allowable nesting depth for the <u>child</u> interpreter.  If <u>newlimit</u> is  specified,
              the recursion limit in <u>child</u> will be set so that nesting of more than <u>newlimit</u> calls to <b>Tcl_Eval()</b>
              and  related  procedures in <u>child</u> will return an error.  The <u>newlimit</u> value is also returned.  The
              <u>newlimit</u> value must be a positive integer between 1 and the maximum value of a non-long integer on
              the platform.

              The command sets the maximum size of the Tcl call stack only. It cannot by  itself  prevent  stack
              overflows on the C stack being used by the application. If your machine has a limit on the size of
              the  C  stack,  you  may get stack overflows before reaching the limit set by the command. If this
              happens, see if there is a mechanism in your system for increasing  the  maximum  size  of  the  C
              stack.

</pre><h4><b>SAFE</b> <b>INTERPRETERS</b></h4><pre>
       A  safe  interpreter is one with restricted functionality, so that is safe to execute an arbitrary script
       from your worst enemy without fear of that script damaging the enclosing application or the rest of  your
       computing  environment.  In order to make an interpreter safe, certain commands and variables are removed
       from the interpreter.  For example, commands to create files on disk are removed, and the <b>exec</b> command is
       removed, since it could be used to cause damage through subprocesses.  Limited access to these facilities
       can be provided, by creating aliases to the parent interpreter which check their arguments carefully  and
       provide restricted access to a safe subset of facilities.  For example, file creation might be allowed in
       a  particular  subdirectory and subprocess invocation might be allowed for a carefully selected and fixed
       set of programs.

       A safe interpreter is created by specifying the <b>-safe</b> switch to the <b>interp</b> <b>create</b> command.   Furthermore,
       any child created by a safe interpreter will also be safe.

       A safe interpreter is created with exactly the following set of built-in commands:

              <b>after</b>       <b>append</b>      <b>apply</b>       <b>array</b>
              <b>binary</b>      <b>break</b>       <b>catch</b>       <b>chan</b>
              <b>clock</b>       <b>close</b>       <b>concat</b>      <b>continue</b>
              <b>dict</b>        <b>eof</b>         <b>error</b>       <b>eval</b>
              <b>expr</b>        <b>fblocked</b>    <b>fcopy</b>       <b>fileevent</b>
              <b>flush</b>       <b>for</b>         <b>foreach</b>     <b>format</b>
              <b>gets</b>        <b>global</b>      <b>if</b>          <b>incr</b>
              <b>info</b>        <b>interp</b>      <b>join</b>        <b>lappend</b>
              <b>lassign</b>     <b>ledit</b>       <b>lindex</b>      <b>linsert</b>
              <b>list</b>        <b>llength</b>     <b>lrange</b>      <b>lrepeat</b>
              <b>lreplace</b>    <b>lsearch</b>     <b>lseq</b>      <b>lset</b>
              <b>lsort</b>     <b>namespace</b>     <b>package</b>     <b>pid</b>
              <b>proc</b>      <b>puts</b>          <b>read</b>        <b>regexp</b>
              <b>regsub</b>      <b>rename</b>      <b>return</b>      <b>scan</b>
              <b>seek</b>        <b>set</b>         <b>split</b>       <b>string</b>
              <b>subst</b>       <b>switch</b>      <b>tell</b>        <b>time</b>
              <b>trace</b>       <b>unset</b>       <b>update</b>      <b>uplevel</b>
              <b>upvar</b>       <b>variable</b>    <b>vwait</b>       <b>while</b>
              <b>zlib</b>

       The following commands are hidden by <b>interp</b> <b>create</b> when it creates a safe interpreter:

              <b>cd</b>          <b>encoding</b>    <b>exec</b>        <b>exit</b>
              <b>fconfigure</b>  <b>file</b>        <b>glob</b>        <b>load</b>
              <b>open</b>        <b>pwd</b>         <b>socket</b>      <b>source</b>
              <b>unload</b>      <b>zipfs</b>

       These commands can be recreated later as Tcl procedures or aliases, or re-exposed by <b>interp</b> <b>expose</b>.

       The following commands from Tcl's library of support procedures are not present in a safe interpreter:

              <b>auto_exec_ok</b>    <b>auto_import</b>     <b>auto_load</b>
              <b>auto_load_index</b> <b>auto_qualify</b>    <b>unknown</b>

       Note  in  particular that safe interpreters have no default <b>unknown</b> command, so Tcl's default autoloading
       facilities are not available.  Autoload access to Tcl's commands that are normally autoloaded:

              <b>auto_mkindex</b>         <b>auto_mkindex_old</b>
              <b>auto_reset</b>           <b>history</b>
              <b>parray</b>               <b>pkg_mkIndex</b>
              <b>::pkg::create</b>        <b>::safe::interpAddToAccessPath</b>
              <b>::safe::interpCreate</b> <b>::safe::interpConfigure</b>
              <b>::safe::interpDelete</b> <b>::safe::interpFindInAccessPath</b>
              <b>::safe::interpInit</b>   <b>::safe::setLogCmd</b>
              <b>tcl_endOfWord</b>        <b>tcl_findLibrary</b>
              <b>tcl_startOfNextWord</b>  <b>tcl_startOfPreviousWord</b>
              <b>tcl_wordBreakAfter</b>   <b>tcl_wordBreakBefore</b>

       can only be provided by explicit definition of an <b>unknown</b> command in the  safe  interpreter.   This  will
       involve  exposing  the <b>source</b> command.  This is most easily accomplished by creating the safe interpreter
       with Tcl's <b>Safe-Tcl</b> mechanism.  <b>Safe-Tcl</b> provides safe versions of <b>source</b>, <b>load</b>, and other  Tcl  commands
       needed to support autoloading of commands and the loading of packages.

       In  addition,  the  <b>env</b>  variable  is  not  present in a safe interpreter, so it cannot share environment
       variables with other interpreters. The <b>env</b> variable poses  a  security  risk,  because  users  can  store
       sensitive  information in an environment variable. For example, the PGP manual recommends storing the PGP
       private key protection password in the environment variable <u>PGPPASS</u>. Making this  variable  available  to
       untrusted code executing in a safe interpreter would incur a security risk.

       If  extensions  are  loaded  into  a  safe interpreter, they may also restrict their own functionality to
       eliminate unsafe commands. For a discussion of management of extensions for safety see the manual entries
       for <b>Safe-Tcl</b> and the <b>load</b> Tcl command.

       A safe interpreter may not alter the recursion limit of any interpreter, including itself.

</pre><h4><b>ALIAS</b> <b>INVOCATION</b></h4><pre>
       The alias mechanism has been carefully designed so that it can be used  safely  in  an  untrusted  script
       which  is being executed in a safe interpreter even if the target of the alias is not a safe interpreter.
       The most important thing in guaranteeing safety is to ensure that information passed from  the  child  to
       the  parent  is  never evaluated or substituted in the parent;  if this were to occur, it would enable an
       evil script in the child to invoke arbitrary functions in the parent, which would compromise security.

       When the source for an alias is invoked in  the  child  interpreter,  the  usual  Tcl  substitutions  are
       performed  when parsing that command.  These substitutions are carried out in the source interpreter just
       as they would be for any other command invoked in that interpreter.  The command procedure for the source
       command takes its arguments and merges them with the <u>targetCmd</u> and <u>arg</u>s for the alias  to  create  a  new
       array  of  arguments.  If the words of <u>srcCmd</u> were “<u>srcCmd</u> <u>arg1</u> <u>arg2</u> <u>...</u> <u>argN</u>”, the new set of words will
       be “<u>targetCmd</u> <u>arg</u> <u>arg</u> <u>...</u> <u>arg</u> <u>arg1</u> <u>arg2</u> <u>...</u> <u>argN</u>”, where <u>targetCmd</u> and <u>arg</u>s are the values supplied  when
       the  alias  was created.  <u>TargetCmd</u> is then used to locate a command procedure in the target interpreter,
       and that command procedure is invoked with the new set of arguments.  An error  occurs  if  there  is  no
       command  named  <u>targetCmd</u>  in  the  target interpreter.  No additional substitutions are performed on the
       words:  the target command procedure is invoked directly, without going through the normal Tcl evaluation
       mechanism.  Substitutions are thus  performed  on  each  word  exactly  once:  <u>targetCmd</u>  and  <u>args</u>  were
       substituted  when  parsing  the  command that created the alias, and <u>arg1</u> <u>-</u> <u>argN</u> are substituted when the
       alias's source command is parsed in the source interpreter.

       When writing the <u>targetCmd</u>s for aliases in safe interpreters, it is very important that the arguments  to
       that  command never be evaluated or substituted, since this would provide an escape mechanism whereby the
       child interpreter could execute arbitrary code in the parent.  This in turn would compromise the security
       of the system.

</pre><h4><b>HIDDEN</b> <b>COMMANDS</b></h4><pre>
       Safe interpreters greatly restrict the functionality available to Tcl  programs  executing  within  them.
       Allowing  the untrusted Tcl program to have direct access to this functionality is unsafe, because it can
       be used for a variety of attacks on the environment.  However, there are times when there is a legitimate
       need to use the dangerous functionality in the context of the safe interpreter. For example, sometimes  a
       program  must  be  <b>source</b>d  into  the interpreter.  Another example is Tk, where windows are bound to the
       hierarchy of windows for a specific interpreter;  some  potentially  dangerous  functions,  e.g.   window
       management, must be performed on these windows within the interpreter context.

       The  <b>interp</b>  command  provides  a  solution  to  this  problem in the form of <u>hidden</u> <u>commands</u>. Instead of
       removing the dangerous commands entirely from a safe interpreter,  these  commands  are  hidden  so  they
       become  unavailable  to  Tcl  scripts  executing in the interpreter. However, such hidden commands can be
       invoked by any trusted ancestor of the safe interpreter, in the context of the  safe  interpreter,  using
       <b>interp</b>  <b>invoke</b>.  Hidden  commands  and exposed commands reside in separate name spaces. It is possible to
       define a hidden command and an exposed command by the same name within one interpreter.

       Hidden commands in a child interpreter can be invoked in the body of  procedures  called  in  the  parent
       during  alias  invocation. For example, an alias for <b>source</b> could be created in a child interpreter. When
       it is invoked in the child interpreter, a procedure is called in the parent interpreter to check that the
       operation is allowable (e.g. it asks to source a file that the child interpreter is allowed  to  access).
       The  procedure  then  it invokes the hidden <b>source</b> command in the child interpreter to actually source in
       the contents of the file. Note that two commands named <b>source</b> exist in the child interpreter: the  alias,
       and the hidden command.

       Because  a  parent interpreter may invoke a hidden command as part of handling an alias invocation, great
       care must be taken to avoid evaluating any arguments passed in through the alias invocation.   Otherwise,
       malicious  child  interpreters  could cause a trusted parent interpreter to execute dangerous commands on
       their behalf. See the section on <b>ALIAS</b> <b>INVOCATION</b> for a more complete discussion of this topic.  To  help
       avoid this problem, no substitutions or evaluations are applied to arguments of <b>interp</b> <b>invokehidden</b>.

       Safe  interpreters  are not allowed to invoke hidden commands in themselves or in their descendants. This
       prevents them from gaining access to hidden functionality in themselves or their descendants.

       The set of hidden commands in an interpreter can be manipulated by a  trusted  interpreter  using  <b>interp</b>
       <b>expose</b>  and  <b>interp</b> <b>hide</b>. The <b>interp</b> <b>expose</b> command moves a hidden command to the set of exposed commands
       in the interpreter identified by <u>path</u>, potentially renaming the command in the  process.  If  an  exposed
       command by the targeted name already exists, the operation fails. Similarly, <b>interp</b> <b>hide</b> moves an exposed
       command  to  the  set  of  hidden commands in that interpreter. Safe interpreters are not allowed to move
       commands between the set of hidden and exposed commands, in either themselves or their descendants.

       Currently, the names of hidden commands cannot contain namespace qualifiers, and you must first rename  a
       command  in  a namespace to the global namespace before you can hide it.  Commands to be hidden by <b>interp</b>
       <b>hide</b> are looked up in the global namespace even if the current namespace is  not  the  global  one.  This
       prevents  children from fooling a parent interpreter into hiding the wrong command, by making the current
       namespace be different from the global one.

</pre><h4><b>RESOURCE</b> <b>LIMITS</b></h4><pre>
       Every interpreter has two kinds of resource limits that may be imposed by any parent interpreter upon its
       children. Command limits (of type <b>command</b>) restrict the total number of Tcl commands that may be executed
       by an interpreter (as can be inspected via the <b>info</b> <b>cmdcount</b> command), and time  limits  (of  type  <b>time</b>)
       place  a  limit  by  which  execution  within  the  interpreter  must complete. Note that time limits are
       expressed as <u>absolute</u> times (as in <b>clock</b> <b>seconds</b>) and not relative times (as in <b>after</b>) because  they  may
       be modified after creation.

       When  a  limit is exceeded for an interpreter, first any handler callbacks defined by parent interpreters
       are called. If those callbacks increase or remove the limit, execution within  the  (previously)  limited
       interpreter  continues.  If  the  limit is still in force, an error is generated at that point and normal
       processing of errors within the interpreter (by the <b>catch</b> command) is disabled, so the  error  propagates
       outwards (building a stack-trace as it goes) to the point where the limited interpreter was invoked (e.g.
       by <b>interp</b> <b>eval</b>) where it becomes the responsibility of the calling code to catch and handle.

   <b>LIMIT</b> <b>OPTIONS</b>
       Every  limit  has  a  number  of options associated with it, some of which are common across all kinds of
       limits, and others of which are particular to the kind of limit.

       <b>-command</b>
              This option (common for all limit types) specifies (if non-empty) a Tcl script to be  executed  in
              the  global  namespace of the interpreter reading and writing the option when the particular limit
              in the limited interpreter is exceeded.  The callback may modify the limit on the  interpreter  if
              it  wishes  the limited interpreter to continue executing. If the callback generates an exception,
              it is reported through the background exception mechanism (see <b>BACKGROUND</b> <b>EXCEPTION</b> <b>HANDLING</b>).

              Note that the callbacks defined by one interpreter are  completely  isolated  from  the  callbacks
              defined by another, and that the order in which those callbacks are called is undefined.

       <b>-granularity</b>
              This  option (common for all limit types) specifies how frequently (out of the points when the Tcl
              interpreter is in a consistent state where limit checking is possible) that the limit is  actually
              checked.  This  allows  the  tuning  of how frequently a limit is checked, and hence how often the
              limit-checking overhead (which may be substantial in the case of time limits) is incurred.

       <b>-milliseconds</b>
              This option specifies the number of milliseconds after the moment defined in the  <b>-seconds</b>  option
              that  the  time limit will fire. It should only ever be specified in conjunction with the <b>-seconds</b>
              option (whether it was set previously or is being set this invocation.)

       <b>-seconds</b>
              This option specifies the number of seconds after the epoch (see  <b>clock</b>  <b>seconds</b>)  that  the  time
              limit  for  the  interpreter  will  be  triggered. The limit will be triggered at the start of the
              second unless specified at a sub-second level using the <b>-milliseconds</b> option. This option  may  be
              the empty string, which indicates that a time limit is not set for the interpreter.

       <b>-value</b> This  option  specifies  the number of commands that the interpreter may execute before triggering
              the command limit. This option may be the empty string, which indicates that a  command  limit  is
              not set for the interpreter.

       Where  an interpreter with a resource limit set on it creates a child interpreter, that child interpreter
       will have resource limits imposed on it that are at least as restrictive as the limits  on  the  creating
       parent  interpreter. If the parent interpreter of the limited parent wishes to relax these conditions, it
       should hide the <b>interp</b> command in the child and then use aliases and the <b>interp</b>  <b>invokehidden</b>  subcommand
       to provide such access as it chooses to the <b>interp</b> command to the limited parent as necessary.

</pre><h4><b>BACKGROUND</b> <b>EXCEPTION</b> <b>HANDLING</b></h4><pre>
       When  an  exception  happens  in a situation where it cannot be reported directly up the stack (e.g. when
       processing events in an <b>update</b> or <b>vwait</b> call) the exception is instead reported  through  the  background
       exception  handling  mechanism.  Every  interpreter  has  a  background exception handler registered; the
       default exception handler arranges for the <b>bgerror</b> command in the interpreter's global  namespace  to  be
       called,  but other exception handlers may be installed and process background exceptions in substantially
       different ways.

       A background exception handler consists of a non-empty list of  words  to  which  will  be  appended  two
       further words at invocation time. The first word will be the interpreter result at time of the exception,
       typically  an  error  message, and the second will be the dictionary of return options at the time of the
       exception.  These are the same values that <b>catch</b> can capture when it controls script evaluation in a non-
       background situation.  The resulting list will then be executed in  the  interpreter's  global  namespace
       without further substitutions being performed.

</pre><h4><b>CREDITS</b></h4><pre>
       The safe interpreter mechanism is based on the Safe-Tcl prototype implemented by Nathaniel Borenstein and
       Marshall Rose.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Creating and using an alias for a command in the current interpreter:

              <b>interp</b> <b>alias</b> {} getIndex {} lsearch {alpha beta gamma delta}
              set idx [getIndex delta]

       Executing an arbitrary command in a safe interpreter where every invocation of <b>lappend</b> is logged:

              set i [<b>interp</b> <b>create</b> -safe]
              <b>interp</b> <b>hide</b> $i lappend
              <b>interp</b> <b>alias</b> $i lappend {} loggedLappend $i
              proc loggedLappend {i args} {
                  puts "logged invocation of lappend $args"
                  <b>interp</b> <b>invokehidden</b> $i lappend {*}$args
              }
              <b>interp</b> <b>eval</b> $i $someUntrustedScript

       Setting a resource limit on an interpreter so that an infinite loop terminates.

              set i [<b>interp</b> <b>create</b>]
              <b>interp</b> <b>limit</b> $i command -value 1000
              <b>interp</b> <b>eval</b> $i {
                  set x 0
                  while {1} {
                      puts "Counting up... [incr x]"
                  }
              }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/bgerror.3tcl.html">bgerror</a>(3tcl),        <a href="../man3tcl/load.3tcl.html">load</a>(3tcl),        <a href="../man3tcl/safe.3tcl.html">safe</a>(3tcl),        <a href="../man3tcl/Tcl_CreateChild.3tcl.html">Tcl_CreateChild</a>(3tcl),        <a href="../man3tcl/Tcl_Eval.3tcl.html">Tcl_Eval</a>(3tcl),
       <a href="../man3tcl/Tcl_BackgroundException.3tcl.html">Tcl_BackgroundException</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       alias, parent interpreter, safe interpreter, child interpreter

Tcl                                                    8.6                                          <u><a href="../man3tcl/interp.3tcl.html">interp</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>