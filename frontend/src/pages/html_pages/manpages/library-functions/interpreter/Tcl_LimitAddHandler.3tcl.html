<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_LimitAddHandler,  Tcl_LimitCheck,  Tcl_LimitExceeded,  Tcl_LimitGetCommands, Tcl_LimitGetGranularity,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_LimitAddHandler,  Tcl_LimitCheck,  Tcl_LimitExceeded,  Tcl_LimitGetCommands, Tcl_LimitGetGranularity,
       Tcl_LimitGetTime, Tcl_LimitReady, Tcl_LimitRemoveHandler, Tcl_LimitSetCommands,  Tcl_LimitSetGranularity,
       Tcl_LimitSetTime,  Tcl_LimitTypeEnabled,  Tcl_LimitTypeExceeded,  Tcl_LimitTypeReset,  Tcl_LimitTypeSet -
       manage and check resource limits on interpreters

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       int
       <b>Tcl_LimitCheck</b>(<u>interp</u>)

       int
       <b>Tcl_LimitReady</b>(<u>interp</u>)

       int
       <b>Tcl_LimitExceeded</b>(<u>interp</u>)

       int
       <b>Tcl_LimitTypeExceeded</b>(<u>interp,</u> <u>type</u>)

       int
       <b>Tcl_LimitTypeEnabled</b>(<u>interp,</u> <u>type</u>)

       <b>Tcl_LimitTypeSet</b>(<u>interp,</u> <u>type</u>)

       <b>Tcl_LimitTypeReset</b>(<u>interp,</u> <u>type</u>)

       int
       <b>Tcl_LimitGetCommands</b>(<u>interp</u>)

       <b>Tcl_LimitSetCommands</b>(<u>interp,</u> <u>commandLimit</u>)

       <b>Tcl_LimitGetTime</b>(<u>interp,</u> <u>timeLimitPtr</u>)

       <b>Tcl_LimitSetTime</b>(<u>interp,</u> <u>timeLimitPtr</u>)

       int
       <b>Tcl_LimitGetGranularity</b>(<u>interp,</u> <u>type</u>)

       <b>Tcl_LimitSetGranularity</b>(<u>interp,</u> <u>type,</u> <u>granularity</u>)

       <b>Tcl_LimitAddHandler</b>(<u>interp,</u> <u>type,</u> <u>handlerProc,</u> <u>clientData,</u> <u>deleteProc</u>)

       <b>Tcl_LimitRemoveHandler</b>(<u>interp,</u> <u>type,</u> <u>handlerProc,</u> <u>clientData</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       Tcl_Interp <u>*interp</u> (in)                               Interpreter that the limit being managed applies to
                                                             or that will have its limits checked.

       int <u>type</u> (in)                                         The type of limit that  the  operation  refers  to.
                                                             This   must   be   either   <b>TCL_LIMIT_COMMANDS</b>   or
                                                             <b>TCL_LIMIT_TIME</b>.

       Tcl_Size <u>commandLimit</u> (in)                            The maximum number of commands (as reported by <b>info</b>
                                                             <b>cmdcount</b>) that may be executed in the interpreter.

       Tcl_Time <u>*timeLimitPtr</u> (in/out)                       A pointer to a structure that will either have  the
                                                             new  time limit read from (<b>Tcl_LimitSetTime</b>) or the
                                                             current time limit written to (<b>Tcl_LimitGetTime</b>).

       int <u>granularity</u> (in)                                  Divisor that indicates how often a particular limit
                                                             should really be checked.  Must be at least 1.

       Tcl_LimitHandlerProc <u>*handlerProc</u> (in)                Function  to  call  when  a  particular  limit   is
                                                             exceeded.  If the <u>handlerProc</u> removes or raises the
                                                             limit    during   its   processing,   the   limited
                                                             interpreter  will  be  permitted  to  continue   to
                                                             process  after  the handler returns.  Many handlers
                                                             may be attached  to  the  same  interpreter  limit;
                                                             their  order  of execution is not defined, and they
                                                             must be identified by  <u>handlerProc</u>  and  <u>clientData</u>
                                                             when they are deleted.

       void <u>*clientData</u> (in)                                 Arbitrary  pointer-sized  word  used  to  pass some
                                                             context to the <u>handlerProc</u> function.

       Tcl_LimitHandlerDeleteProc <u>*deleteProc</u> (in)           Function to call whenever  a  handler  is  deleted.
                                                             May be NULL if the <u>clientData</u> requires no deletion.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Tcl's  interpreter  resource  limit  subsystem  allows for close control over how much computation time a
       script may use, and is useful for cases where a program is divided into multiple pieces where some  parts
       are more trusted than others (e.g. web application servers).

       Every  interpreter may have a limit on the wall-time for execution, and a limit on the number of commands
       that the interpreter may execute.  Since checking of these limits is  potentially  expensive  (especially
       the  time limit), each limit also has a checking granularity, which is a divisor for an internal count of
       the number of points in the core where a check may be performed (which is immediately before executing  a
       command  and at an unspecified frequency between running commands, which can happen in empty-bodied <b>while</b>
       loops).

       The final component of the limit engine is a callback scheme which allows for  notifications  of  when  a
       limit has been exceeded.  These callbacks can just provide logging, or may allocate more resources to the
       interpreter to permit it to continue processing longer.

       When  a  limit  is  exceeded  (and  the  callbacks  have  run; the order of execution of the callbacks is
       unspecified) execution in the limited interpreter is stopped by raising an error and setting a flag  that
       prevents  the  <b>catch</b>  command in that interpreter from trapping that error.  It is up to the context that
       started execution in that interpreter (typically the main interpreter) to handle the error.

</pre><h4><b>LIMIT</b> <b>CHECKING</b> <b>API</b></h4><pre>
       To check the resource limits for an interpreter, call <b>Tcl_LimitCheck</b>, which returns <b>TCL_OK</b> if  the  limit
       was  not  exceeded (after processing callbacks) and <b>TCL_ERROR</b> if the limit was exceeded (in which case an
       error message is also placed in the interpreter result).   That  function  should  only  be  called  when
       <b>Tcl_LimitReady</b>  returns  non-zero  so  that  granularity  policy is enforced.  This API is designed to be
       similar in usage to <b>Tcl_AsyncReady</b> and <b>Tcl_AsyncInvoke</b>.

       When writing code that may behave like <b>catch</b> in respect of errors, you  should  only  trap  an  error  if
       <b>Tcl_LimitExceeded</b> returns zero.  If it returns non-zero, the interpreter is in a limit-exceeded state and
       errors  should  be  allowed to propagate to the calling context.  You can also check whether a particular
       type of limit has been exceeded using <b>Tcl_LimitTypeExceeded</b>.

</pre><h4><b>LIMIT</b> <b>CONFIGURATION</b></h4><pre>
       To check whether a limit has been set (but not whether it has actually been exceeded) on an  interpreter,
       call  <b>Tcl_LimitTypeEnabled</b>  with  the type of limit you want to check.  To enable a particular limit call
       <b>Tcl_LimitTypeSet</b>, and to disable a limit call <b>Tcl_LimitTypeReset</b>.

       The  level  of  a  command  limit  may  be  set   using   <b>Tcl_LimitSetCommands</b>,   and   retrieved   using
       <b>Tcl_LimitGetCommands</b>.    Similarly   for   a   time  limit  with  <b>Tcl_LimitSetTime</b>  and  <b>Tcl_LimitGetTime</b>
       respectively, but with that API the time limit is copied from and to  the  Tcl_Time  structure  that  the
       <u>timeLimitPtr</u> argument points to.

       The  checking  granularity  for a particular limit may be set using <b>Tcl_LimitSetGranularity</b> and retrieved
       using <b>Tcl_LimitGetGranularity</b>.  Note that granularities must always be positive.

   <b>LIMIT</b> <b>CALLBACKS</b>
       To add a handler callback to be  invoked  when  a  limit  is  exceeded,  call  <b>Tcl_LimitAddHandler</b>.   The
       <u>handlerProc</u>  argument  describes  the function that will actually be called; it should have the following
       prototype:

              typedef void <b>Tcl_LimitHandlerProc</b>(
                      void *<u>clientData</u>,
                      Tcl_Interp *<u>interp</u>);

       The <u>clientData</u> argument to the handler  will  be  whatever  is  passed  to  the  <u>clientData</u>  argument  to
       <b>Tcl_LimitAddHandler</b>, and the <u>interp</u> is the interpreter that had its limit exceeded.

       The  <u>deleteProc</u> argument to <b>Tcl_LimitAddHandler</b> is a function to call to delete the <u>clientData</u> value.  It
       may be <b>TCL_STATIC</b> or NULL if no deletion action is necessary, or <b>TCL_DYNAMIC</b> if all that is necessary  is
       to  free  the  structure  with  <b>Tcl_Free</b>.   Otherwise,  it  should refer to a function with the following
       prototype:

              typedef void <b>Tcl_LimitHandlerDeleteProc</b>(
                      void *<u>clientData</u>);

       A limit handler may be deleted using <b>Tcl_LimitRemoveHandler</b>; the handler removed will be  the  first  one
       found  (out  of  the handlers added with <b>Tcl_LimitAddHandler</b>) with exactly matching <u>type</u>, <u>handlerProc</u> and
       <u>clientData</u> arguments.  This function  always  invokes  the  <u>deleteProc</u>  on  the  <u>clientData</u>  (unless  the
       <u>deleteProc</u> was NULL or <b>TCL_STATIC</b>).

</pre><h4><b>KEYWORDS</b></h4><pre>
       interpreter, resource, limit, commands, time, callback

Tcl                                                    8.5                                  <u><a href="../man3tcl/Tcl_LimitCheck.3tcl.html">Tcl_LimitCheck</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>