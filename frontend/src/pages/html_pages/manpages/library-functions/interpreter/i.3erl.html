<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>i - Debugger/Interpreter Interface.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       i - Debugger/Interpreter Interface.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>i</u>  module  provides short forms for some of the functions used by the graphical Debugger and some of
       the functions in module <u>int</u>, the Erlang interpreter.

       This module also provides facilities for displaying status information about  interpreted  processes  and
       break points.

       It  is  possible to attach to interpreted processes by giving the corresponding process identity only. By
       default, an attachment window is displayed. Processes at other Erlang nodes can be attached  manually  or
       automatically.

       By  preference, these functions can be included in module <u>shell_default</u>. By default, they are included in
       that module.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>im()</b> <b>-&gt;</b> <b>pid()</b>

              Starts a new graphical monitor. This is the Monitor window, the main window of Debugger.  All  the
              Debugger  and  interpreter functionality is accessed from the Monitor window. This window displays
              the status of all processes that have been or are executing interpreted modules.

       <b>ii(AbsModules)</b> <b>-&gt;</b> <b>ok</b>
       <b>ii(AbsModule)</b> <b>-&gt;</b> <b>{module,</b> <b>Module}</b> <b>|</b> <b>error</b>
       <b>ini(AbsModules)</b> <b>-&gt;</b> <b>ok</b>
       <b>ini(AbsModule)</b> <b>-&gt;</b> <b>{module,</b> <b>Module}</b> <b>|</b> <b>error</b>

              Types:

                 AbsModules = [AbsModule]
                 AbsModule = Module | File
                  Module = atom()
                  File = string()

              Interprets the specified module(s). <u>ii/1</u> interprets the module(s) only at the  current  node,  see
              int:i/1. <u>ini/1</u> interprets the module(s) at all known nodes, see int:ni/1.

       <b>iq(AbsModule)</b> <b>-&gt;</b> <b>ok</b>
       <b>inq(AbsModule)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 AbsModule = Module | File
                  Module = atom()
                  File = string()

              Stops  interpreting  the  specified module. <u>iq/1</u> stops interpreting the module only at the current
              node. <u>inq/1</u> stops interpreting the module at all known nodes.

       <b>il()</b> <b>-&gt;</b> <b>ok</b>

              Makes a printout of all interpreted modules. Modules are printed together with the full path  name
              of the corresponding source code file.

       <b>ip()</b> <b>-&gt;</b> <b>ok</b>

              Prints the current status of all interpreted processes.

       <b>ic()</b> <b>-&gt;</b> <b>ok</b>

              Clears  information  about  processes executing interpreted code by removing all information about
              terminated processes.

       <b>iaa(Flags)</b> <b>-&gt;</b> <b>true</b>
       <b>iaa(Flags,</b> <b>Function)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Flags = [init | break | exit]
                 Function = {Module,Name,Args}
                  Module = Name = atom()
                  Args = [term()]

              Sets when and how to attach to a debugged process automatically, see  int:auto_attach/2.  <u>Function</u>
              defaults to the standard function used by Debugger.

       <b>ist(Flag)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Flag = all | no_tail | false

              Sets how to save call frames in the stack, see int:stack_trace/1.

       <b>ia(Pid)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>no_proc</b>

              Types:

                 Pid = pid()

              Attaches to the debugged process <u>Pid</u>. An Attach Process window is opened for the process.

       <b>ia(X,Y,Z)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>no_proc</b>

              Types:

                 X = Y = Z = int()

              Same as <u>ia(Pid)</u>, where <u>Pid</u> is the result of calling the shell function <u>pid(X,Y,Z)</u>.

       <b>ia(Pid,</b> <b>Function)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>no_proc</b>

              Types:

                 Pid = pid()
                 Function = {Module,Name}
                  Module = Name = atom()

              Attaches  to  the  debugged  process  <u>Pid</u>.  The  interpreter calls <u>spawn(Module,</u> <u>Name,</u> <u>[Pid])</u> (and
              ignores the result).

       <b>ia(X,Y,Z,</b> <b>Function)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>no_proc</b>

              Types:

                 X = Y = Z = int()
                 Function = {Module,Name}
                  Module = Name = atom()

              Same as <u>ia(Pid,</u> <u>Function)</u>, where <u>Pid</u> is the result of calling the shell  function  <u>pid(X,Y,Z)</u>.  An
              attached  process  is expected to call the unofficial function <u>int:attached(Pid)</u> and to be able to
              handle messages from the interpreter. For an example, see <u>dbg_wx_trace.erl</u>.

       <b>ib(Module,</b> <b>Line)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>break_exists}</b>

              Types:

                 Module = atom()
                 Line = int()

              Creates a breakpoint at <u>Line</u> in <u>Module</u>.

       <b>ib(Module,</b> <b>Name,</b> <b>Arity)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>function_not_found}</b>

              Types:

                 Module = Name = atom()
                 Arity = int()

              Creates breakpoints at the first line of every clause of function <u>Module:Name/Arity</u>.

       <b>ir()</b> <b>-&gt;</b> <b>ok</b>

              Deletes all breakpoints.

       <b>ir(Module)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()

              Deletes all breakpoints in <u>Module</u>.

       <b>ir(Module,</b> <b>Line)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()
                 Line = int()

              Deletes the breakpoint at <u>Line</u> in <u>Module</u>.

       <b>ir(Module,</b> <b>Name,</b> <b>Arity)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>function_not_found}</b>

              Types:

                 Module = Name = atom()
                 Arity = int()

              Deletes the breakpoints at the first line of every clause of function <u>Module:Name/Arity</u>.

       <b>ibd(Module,</b> <b>Line)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()
                 Line = int()

              Makes the breakpoint at <u>Line</u> in <u>Module</u> inactive.

       <b>ibe(Module,</b> <b>Line)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()
                 Line = int()

              Makes the breakpoint at <u>Line</u> in <u>Module</u> active.

       <b>iba(Module,</b> <b>Line,</b> <b>Action)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()
                 Line = int()
                 Action = enable | disable | delete

              Sets the trigger action of the breakpoint at <u>Line</u> in <u>Module</u> to <u>Action</u>.

       <b>ibc(Module,</b> <b>Line,</b> <b>Function)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()
                 Line = int()
                 Function = {Module,Name}
                  Name = atom()

              Sets the conditional test of the breakpoint at <u>Line</u> in <u>Module</u> to <u>Function</u>.

              The conditional test is performed by calling <u>Module:Name(Bindings)</u>, where <u>Bindings</u> is the  current
              variable  bindings. The function must return <u>true</u> (break) or <u>false</u> (do not break). To retrieve the
              value of a variable <u>Var</u>, use int:get_binding(Var, Bindings).

       <b>ipb()</b> <b>-&gt;</b> <b>ok</b>

              Prints all existing breakpoints.

       <b>ipb(Module)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Module = atom()

              Prints all existing breakpoints in <u>Module</u>.

       <b>iv()</b> <b>-&gt;</b> <b>atom()</b>

              Returns the current version number of the interpreter. Same as the version number of the  Debugger
              application.

       <b>help()</b> <b>-&gt;</b> <b>ok</b>

              Prints help text.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/int.3erl.html">int</a>(3erl)</u>

Ericsson AB                                       debugger 5.2                                           <u><a href="../man3erl/i.3erl.html">i</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>