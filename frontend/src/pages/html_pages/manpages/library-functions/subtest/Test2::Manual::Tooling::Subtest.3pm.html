<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test2::Manual::Tooling::Subtest - How to implement a tool that makes use of subtests.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest2-suite-perl">libtest2-suite-perl_0.000163-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test2::Manual::Tooling::Subtest - How to implement a tool that makes use of subtests.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Subtests are a nice way of making related events visually, and architecturally distinct.

</pre><h4><b>WHICH</b> <b>TYPE</b> <b>OF</b> <b>SUBTEST</b> <b>DO</b> <b>I</b> <b>NEED?</b></h4><pre>
       There are 2 types of subtest. The first type is subtests with user-supplied coderefs, such as the
       subtest() function itself. The second type is subtest that do not have any user supplied coderefs.

       So which type do you need? The answer to that is simple, if you are going to let the user define the
       subtest with their own codeblock, you have the first type, otherwise you have the second.

       In either case, you will still need use the same API function: "Test2::API::run_subtest".

   <b>SUBTEST</b> <b>WITH</b> <b>USER</b> <b>SUPPLIED</b> <b>CODEREF</b>
       This example will emulate the "subtest" function.

           use Test2::API qw/context run_subtest/;

           sub my_subtest {
               my ($name, $code) = @_;

               # Like any other tool, you need to acquire a context, if you do not then
               # things will not report the correct file and line number.
               my $ctx = context();

               my $bool = run_subtest($name, $code);

               $ctx-&gt;release;

               return $bool;
           }

       This looks incredibly simple... and it is. run_subtest() does all the hard work for you. This will issue
       an Test2::Event::Subtest event with the results of the subtest. The subtest event itself will report to
       the proper file and line number due to the context you acquired (even though it does not <u>look</u> like you
       used the context.

       run_subtest() can take additional arguments:

           run_subtest($name, $code, \%params, @args);

       @args
           This allows you to pass arguments into the codeblock that gets run.

       \%params
           This is a hashref of parameters. Currently there are 3 possible parameters:

           buffered =&gt; $bool
               This  will  turn  the  subtest  into  the  new  style  buffered  subtest. This type of subtest is
               recommended, but not default.

           inherit_trace =&gt; $bool
               This is used for tool-side coderefs.

           no_fork =&gt; $bool
               react to forking/threading inside the subtest itself. In general you are  unlikely  to  need/want
               this parameter.

   <b>SUBTEST</b> <b>WITH</b> <b>TOOL-SIDE</b> <b>CODEREF</b>
       This is particularly useful if you want to turn a tool that wraps other tools into a subtest. For this we
       will be using the tool we created in Test2::Manual::Tooling::Nesting.

           use Test2::API qw/context run_subtest/;

           sub check_class {
               my $class = shift;

               my $ctx = context();

               my $code = sub {
                   my $obj = $class-&gt;new;
                   is($obj-&gt;foo, 'foo', "got foo");
                   is($obj-&gt;bar, 'bar', "got bar");
               };

               my $bool = run_subtest($class, $code, {buffered =&gt; 1, inherit_trace =&gt; 1});

               $ctx-&gt;release;

               return $bool;
           }

       The  run_subtest()  function  does all the heavy lifting for us. All we need to do is give the function a
       name, a coderef to run, and the "inherit_trace  =&gt;  1"  parameter.  The  "buffered  =&gt;  1"  parameter  is
       optional, but recommended.

       The  "inherit_trace"  parameter tells the subtest tool that the contexts acquired inside the nested tools
       should use the  same  trace  as  the  subtest  itself.  For  user-supplied  codeblocks  you  do  not  use
       inherit_trace because you want errors to report to the user-supplied file+line.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Test2::Manual - Primary index of the manual.

</pre><h4><b>SOURCE</b></h4><pre>
       The source code repository for Test2-Manual can be found at <u>https://github.com/Test-More/Test2-Suite/</u>.

</pre><h4><b>MAINTAINERS</b></h4><pre>
       Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;

</pre><h4><b>AUTHORS</b></h4><pre>
       Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2018 Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

       See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.38.2                                       2024-06-07               <u>Test2::Manual::Tooling::<a href="../man3pm/Subtest.3pm.html">Subtest</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>