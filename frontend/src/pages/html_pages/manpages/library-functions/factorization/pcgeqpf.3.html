<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCGEQPF  -  compute  a  QR  factorization  with column pivoting of a M-by-N distributed matrix sub( A ) =</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/scalapack-doc">scalapack-doc_1.5-11_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PCGEQPF  -  compute  a  QR  factorization  with column pivoting of a M-by-N distributed matrix sub( A ) =
       A(IA:IA+M-1,JA:JA+N-1)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       SUBROUTINE PCGEQPF( M, N, A, IA, JA, DESCA, IPIV, TAU, WORK, LWORK, RWORK, LRWORK, INFO )

           INTEGER         IA, JA, INFO, LRWORK, LWORK, M, N

           INTEGER         DESCA( * ), IPIV( * )

           REAL            RWORK( * )

           COMPLEX         A( * ), TAU( * ), WORK( * )

</pre><h4><b>PURPOSE</b></h4><pre>
       PCGEQPF computes a QR factorization with column pivoting of a  M-by-N  distributed  matrix  sub(  A  )  =
       A(IA:IA+M-1,JA:JA+N-1):

                              sub( A ) * P = Q * R.

       Notes
       =====

       Each  global  data  object  is  described  by  an  associated description vector.  This vector stores the
       information required to establish the mapping between an object element and its corresponding process and
       memory location.

       Let A be a generic term for any 2D block  cyclicly  distributed  array.   Such  a  global  array  has  an
       associated  description  vector  DESCA.  In the following comments, the character _ should be read as "of
       the global array".

       NOTATION        STORED IN      EXPLANATION
       --------------- -------------- -------------------------------------- DTYPE_A(global) DESCA( DTYPE_  )The
       descriptor type.  In this case,
                                      DTYPE_A = 1.
       CTXT_A (global) DESCA( CTXT_ ) The BLACS context handle, indicating
                                      the BLACS process grid A is distribu-
                                      ted over. The context itself is glo-
                                      bal, but the handle (the integer
                                      value) may vary.
       M_A    (global) DESCA( M_ )    The number of rows in the global
                                      array A.
       N_A    (global) DESCA( N_ )    The number of columns in the global
                                      array A.
       MB_A   (global) DESCA( MB_ )   The blocking factor used to distribute
                                      the rows of the array.
       NB_A   (global) DESCA( NB_ )   The blocking factor used to distribute
                                      the columns of the array.
       RSRC_A (global) DESCA( RSRC_ ) The process row over which the first
                                      row  of  the  array  A is distributed.  CSRC_A (global) DESCA( CSRC_ ) The
       process column over which the
                                      first column of the array A is
                                      distributed.
       LLD_A  (local)  DESCA( LLD_ )  The leading dimension of the local
                                      array.  LLD_A &gt;= MAX(1,LOCr(M_A)).

       Let K be the number of rows or columns of a distributed matrix, and assume  that  its  process  grid  has
       dimension p x q.
       LOCr( K ) denotes the number of elements of K that a process would receive if K were distributed over the
       p processes of its process column.
       Similarly,  LOCc(  K  )  denotes  the  number  of  elements  of  K that a process would receive if K were
       distributed over the q processes of its process row.
       The values of LOCr() and LOCc() may be determined via a call to the ScaLAPACK tool function, NUMROC:
               LOCr( M ) = NUMROC( M, MB_A, MYROW, RSRC_A, NPROW ),
               LOCc( N ) = NUMROC( N, NB_A, MYCOL, CSRC_A, NPCOL ).  An upper bound for these quantities may  be
       computed by:
               LOCr( M ) &lt;= ceil( ceil(M/MB_A)/NPROW )*MB_A
               LOCc( N ) &lt;= ceil( ceil(N/NB_A)/NPCOL )*NB_A

</pre><h4><b>ARGUMENTS</b></h4><pre>
       M       (global input) INTEGER
               The number of rows to be operated on, i.e. the number of rows of the distributed submatrix sub( A
               ). M &gt;= 0.

       N       (global input) INTEGER
               The  number of columns to be operated on, i.e. the number of columns of the distributed submatrix
               sub( A ). N &gt;= 0.

       A       (local input/local output) COMPLEX pointer into the
               local memory to an array of dimension (LLD_A, LOCc(JA+N-1)).  On entry, the local pieces  of  the
               M-by-N  distributed  matrix  sub( A ) which is to be factored. On exit, the elements on and above
               the diagonal of sub( A ) contain the min(M,N) by  N  upper  trapezoidal  matrix  R  (R  is  upper
               triangular  if  M  &gt;=  N);  the  elements below the diagonal, with the array TAU, repre- sent the
               unitary matrix Q as a product of elementary reflectors (see Further  Details).   IA       (global
               input) INTEGER The row index in the global array A indicating the first row of sub( A ).

       JA      (global input) INTEGER
               The column index in the global array A indicating the first column of sub( A ).

       DESCA   (global and local input) INTEGER array of dimension DLEN_.
               The array descriptor for the distributed matrix A.

       IPIV    (local output) INTEGER array, dimension LOCc(JA+N-1).
               On exit, if IPIV(I) = K, the local i-th column of sub( A )*P was the global K-th column of sub( A
               ). IPIV is tied to the distributed matrix A.

       TAU     (local output) COMPLEX, array, dimension
               LOCc(JA+MIN(M,N)-1). This array contains the scalar factors TAU of the elementary reflectors. TAU
               is tied to the distributed matrix A.

       WORK    (local workspace/local output) COMPLEX array,
               dimension (LWORK) On exit, <a href="../man1/WORK.1.html">WORK</a>(1) returns the minimal and optimal LWORK.

       LWORK   (local or global input) INTEGER
               The  dimension of the array WORK.  LWORK is local input and must be at least LWORK &gt;= MAX(3,Mp0 +
               Nq0).

               If LWORK = -1, then LWORK is global input and a workspace query  is  assumed;  the  routine  only
               calculates  the minimum and optimal size for all work arrays. Each of these values is returned in
               the first entry of the corresponding work array, and no error message is issued by PXERBLA.

       RWORK   (local workspace/local output) REAL array,
               dimension (LRWORK) On exit, <a href="../man1/RWORK.1.html">RWORK</a>(1) returns the minimal and optimal LRWORK.

       LRWORK  (local or global input) INTEGER
               The dimension of the array RWORK.  LRWORK  is  local  input  and  must  be  at  least  LRWORK  &gt;=
               LOCc(JA+N-1)+Nq0.

               IROFF  =  MOD( IA-1, MB_A ), ICOFF = MOD( JA-1, NB_A ), IAROW = INDXG2P( IA, MB_A, MYROW, RSRC_A,
               NPROW ), IACOL = INDXG2P( JA, NB_A, MYCOL, CSRC_A, NPCOL ), Mp0   = NUMROC( M+IROFF, MB_A, MYROW,
               IAROW, NPROW ), Nq0   = NUMROC( N+ICOFF, NB_A, MYCOL, IACOL,  NPCOL  ),  LOCc(JA+N-1)  =  NUMROC(
               JA+N-1, NB_A, MYCOL, CSRC_A, NPCOL )

               and NUMROC, INDXG2P are ScaLAPACK tool functions; MYROW, MYCOL, NPROW and NPCOL can be determined
               by calling the subroutine BLACS_GRIDINFO.

               If  LRWORK  =  -1, then LRWORK is global input and a workspace query is assumed; the routine only
               calculates the minimum and optimal size for all work arrays. Each of these values is returned  in
               the first entry of the corresponding work array, and no error message is issued by PXERBLA.

       INFO    (global output) INTEGER
               = 0:  successful exit
               &lt;  0:   If  the  i-th  argument  is  an  array  and the j-entry had an illegal value, then INFO =
               -(i*100+j), if the i-th argument is a scalar and had an illegal value, then INFO = -i.

</pre><h4><b>FURTHER</b> <b>DETAILS</b></h4><pre>
       The matrix Q is represented as a product of elementary reflectors

          Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(n)

       Each H(i) has the form

          H = I - tau * v * v'

       where tau is a complex scalar, and v is a complex vector with v(1:i-1) = 0 and  v(i)  =  1;  v(i+1:m)  is
       stored on exit in
       A(ia+i-1:ia+m-1,ja+i-1).

       The matrix P is represented in jpvt as follows: If
          jpvt(j) = i
       then the jth column of P is the ith canonical unit vector.

LAPACK version 1.5                                 12 May 1997                                        <u>PCGEQPF</u>(l)
</pre>
 </div>
</div></section>
</div>
</body>
</html>