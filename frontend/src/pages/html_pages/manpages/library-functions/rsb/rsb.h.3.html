<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>librsb - rsb.h - The librsb library interface (rsb.h, optional ones rsb.hpp and rsb.F90)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librsb-dev">librsb-dev_1.3.0.2+dfsg-7_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       librsb - rsb.h - The librsb library interface (rsb.h, optional ones rsb.hpp and rsb.F90)

</pre><h4><b>DESCRIPTION</b></h4><pre>
        -
        The reference documentation of the librsb library comes in both HTML and Unix man pages formats.
        The following sections/man pages are available: <b>The</b> <b>librsb</b> <b>library</b> <b>interface</b> <b>(rsb.h,</b> <b>optional</b> <b>ones</b>
       <b>rsb.hpp</b> <b>and</b> <b>rsb.F90)</b> ; <b>The</b> <b>Sparse</b> <b>BLAS</b> <b>interface</b> <b>to</b> <b>librsb</b> <b>(blas_sparse.h,</b> <b>rsb_blas_sparse.F90)</b> ; <b>Example</b>
       <b>programs</b> <b>and</b> <b>code</b>.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Macros</b>
       #<b>define</b> <b>RSB_SIZEOF</b>(<b>TYPE</b>)   <b>RSB_NUMERICAL_TYPE_SIZE</b>(<b>TYPE</b>)

   <b>Enumerations</b>
       enum <b>rsb_opt_t</b> { <b>RSB_IO_WANT_VERBOSE_INIT</b> =0x000001, <b>RSB_IO_WANT_VERBOSE_EXIT</b> =0x000002,
           <b>RSB_IO_WANT_OUTPUT_STREAM</b> =0x000003, <b>RSB_IO_WANT_SORT_METHOD</b> =0x000004,
           <b>RSB_IO_WANT_CACHE_BLOCKING_METHOD</b> =0x000005, <b>RSB_IO_WANT_SUBDIVISION_MULTIPLIER</b> =0x000006,
           <b>RSB_IO_WANT_VERBOSE_ERRORS</b> =0x000007, <b>RSB_IO_WANT_BOUNDED_BOX_COMPUTATION</b> =0x000008,
           <b>RSB_IO_WANT_EXECUTING_THREADS</b> =0x000009, <b>RSB_IO_WANT_EXTRA_VERBOSE_INTERFACE</b> =0x000010,
           <b>RSB_IO_WANT_MEMORY_HIERARCHY_INFO_STRING</b> =0x000011, <b>RSB_IO_WANT_IS_INITIALIZED_MARKER</b> =0x000012,
           <b>RSB_IO_WANT_MEM_ALLOC_CNT</b> =0x000013, <b>RSB_IO_WANT_MEM_ALLOC_TOT</b> =0x000014,
           <b>RSB_IO_WANT_LEAF_LEVEL_MULTIVEC</b> =0x000015, <b>RSB_IO_WANT_MAX_MEMORY_ALLOCATIONS</b> =0x000016,
           <b>RSB_IO_WANT_MAX_MEMORY_ALLOCATED</b> =0x000017, <b>RSB_IO_WANT_LIBRSB_ETIME</b> =0x000018,
           <b>RSB_IO_WANT_VERBOSE_TUNING</b> =0x000019 }
           library option values for <b>rsb_lib_init</b>, <b>rsb_lib_set_opt_str</b>, <b>rsb_lib_reinit</b>, <b>rsb_lib_exit</b>,
           <b>rsb_lib_get_opt</b>, <b>rsb_lib_set_opt</b>, or (deprecated) macros <b>RSB_REINIT_SINGLE_VALUE_GET</b>,
           <b>RSB_REINIT_SINGLE_VALUE_SET</b>, <b>RSB_REINIT_SINGLE_VALUE</b>, <b>RSB_REINIT_SINGLE_VALUE_C_IOP</b>..
       enum <b>rsb_extff_t</b> { <b>RSB_EXTF_NORM_ONE</b> =0x00001001, <b>RSB_EXTF_NORM_TWO</b> =0x00001002, <b>RSB_EXTF_NORM_INF</b>
           =0x00001003, <b>RSB_EXTF_SUMS_ROW</b> =0x00001004, <b>RSB_EXTF_SUMS_COL</b> =0x00001005, <b>RSB_EXTF_ASUMS_ROW</b>
           =0x00001006, <b>RSB_EXTF_ASUMS_COL</b> =0x00001007, <b>RSB_EXTF_DIAG</b> =0x00000004 }
           Extraction filter flags, to be used with <b>rsb_mtx_get_nrm()</b>/<b>rsb_mtx_get_vec()</b>.
       enum <b>rsb_mif_t</b> { <b>RSB_MIF_INDEX_STORAGE_IN_BYTES__TO__SIZE_T</b> =0x00000001,
           <b>RSB_MIF_INDEX_STORAGE_IN_BYTES_PER_NNZ__TO__RSB_REAL_T</b> =0x00000002,
           <b>RSB_MIF_MATRIX_ROWS__TO__RSB_COO_INDEX_T</b> =0x00000004, <b>RSB_MIF_MATRIX_COLS__TO__RSB_COO_INDEX_T</b>
           =0x00000008, <b>RSB_MIF_MATRIX_NNZ__TO__RSB_NNZ_INDEX_T</b> =0x00000010, <b>RSB_MIF_TOTAL_SIZE__TO__SIZE_T</b>
           =0x00000020, <b>RSB_MIF_MATRIX_FLAGS__TO__RSB_FLAGS_T</b> =0x00000040,
           <b>RSB_MIF_MATRIX_TYPECODE__TO__RSB_TYPE_T</b> =0x00000080, <b>RSB_MIF_MATRIX_INFO__TO__CHAR_P</b> =0x00000100,
           <b>RSB_MIF_LEAVES_COUNT__TO__RSB_BLK_INDEX_T</b> =0x00000200 }
           Flags for getting matrix information via <b>rsb_mtx_get_info()</b>/<b>rsb_mtx_get_info_str()</b>.
       enum <b>rsb_elopf_t</b> { <b>RSB_ELOPF_MUL</b> =0x00000001, <b>RSB_ELOPF_DIV</b> =0x00000002, <b>RSB_ELOPF_POW</b> =0x00000004,
           <b>RSB_ELOPF_NEG</b> =0x00000008, <b>RSB_ELOPF_SCALE_ROWS</b> =0x00000010, <b>RSB_ELOPF_SCALE_COLS</b> =0x00000020,
           <b>RSB_ELOPF_SCALE_ROWS_REAL</b> =0x00000040, <b>RSB_ELOPF_SCALE_COLS_REAL</b> =0x00000080 }
           Flags for specifying a particular elemental/row-wise operation with <b>rsb_mtx_upd_vals()</b>.

   <b>Functions</b>
       <b>rsb_err_t</b> <b>rsb_lib_init</b> (<b>struct</b> <b>rsb_initopts</b> *<b>iop</b>)
       <b>rsb_err_t</b> <b>rsb_lib_set_opt</b> (<b>enum</b> <b>rsb_opt_t</b> <b>iof</b>, <b>const</b> <b>void</b> *<b>iop</b>)
       <b>rsb_err_t</b> <b>rsb_lib_get_opt</b> (<b>enum</b> <b>rsb_opt_t</b> <b>iof</b>, <b>void</b> *<b>iop</b>)
       <b>rsb_err_t</b> <b>rsb_lib_set_opt_str</b> (<b>const</b> <b>rsb_char_t</b> *<b>opnp</b>, <b>const</b> <b>rsb_char_t</b> *<b>opvp</b>)
       <b>rsb_err_t</b> <b>rsb_lib_reinit</b> (<b>struct</b> <b>rsb_initopts</b> *<b>iop</b>)
       <b>rsb_err_t</b> <b>rsb_lib_exit</b> (<b>struct</b> <b>rsb_initopts</b> *<b>iop</b>)
       <b>struct</b> <b>rsb_mtx_t</b> * <b>rsb_mtx_alloc_from_coo_const</b> (<b>const</b> <b>void</b> *<b>VA</b>, <b>const</b> <b>rsb_coo_idx_t</b> *<b>IA</b>, <b>const</b>
           <b>rsb_coo_idx_t</b> *<b>JA</b>, <b>rsb_nnz_idx_t</b> <b>nnzA</b>, <b>rsb_type_t</b> <b>typecode</b>, <b>rsb_coo_idx_t</b> <b>nrA</b>, <b>rsb_coo_idx_t</b> <b>ncA</b>,
           <b>rsb_blk_idx_t</b> <b>brA</b>, <b>rsb_blk_idx_t</b> <b>bcA</b>, <b>rsb_flags_t</b> <b>flagsA</b>, <b>rsb_err_t</b> *<b>errvalp</b>)
       <b>struct</b> <b>rsb_mtx_t</b> * <b>rsb_mtx_alloc_from_coo_inplace</b> (<b>void</b> *<b>VA</b>, <b>rsb_coo_idx_t</b> *<b>IA</b>, <b>rsb_coo_idx_t</b> *<b>JA</b>,
           <b>rsb_nnz_idx_t</b> <b>nnzA</b>, <b>rsb_type_t</b> <b>typecode</b>, <b>rsb_coo_idx_t</b> <b>nrA</b>, <b>rsb_coo_idx_t</b> <b>ncA</b>, <b>rsb_blk_idx_t</b> <b>brA</b>,
           <b>rsb_blk_idx_t</b> <b>bcA</b>, <b>rsb_flags_t</b> <b>flagsA</b>, <b>rsb_err_t</b> *<b>errvalp</b>)
       <b>struct</b> <b>rsb_mtx_t</b> * <b>rsb_mtx_free</b> (<b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_clone</b> (<b>struct</b> <b>rsb_mtx_t</b> **<b>mtxBpp</b>, <b>rsb_type_t</b> <b>typecode</b>, <b>rsb_trans_t</b> <b>transA</b>, <b>const</b> <b>void</b>
           *<b>alphap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>rsb_flags_t</b> <b>flags</b>)
       <b>rsb_err_t</b> <b>rsb_spmv</b> (<b>rsb_trans_t</b> <b>transA</b>, <b>const</b> <b>void</b> *<b>alphap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>const</b> <b>void</b>
           *<b>Xp</b>, <b>rsb_coo_idx_t</b> <b>incX</b>, <b>const</b> <b>void</b> *<b>betap</b>, <b>void</b> *<b>Yp</b>, <b>rsb_coo_idx_t</b> <b>incY</b>)
       <b>rsb_err_t</b> <b>rsb_spsv</b> (<b>rsb_trans_t</b> <b>transT</b>, <b>const</b> <b>void</b> *<b>alphap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxTp</b>, <b>const</b> <b>void</b>
           *<b>Xp</b>, <b>rsb_coo_idx_t</b> <b>incX</b>, <b>void</b> *<b>Yp</b>, <b>rsb_coo_idx_t</b> <b>incY</b>)
       <b>rsb_err_t</b> <b>rsb_spsm</b> (<b>rsb_trans_t</b> <b>transT</b>, <b>const</b> <b>void</b> *<b>alphap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxTp</b>, <b>rsb_coo_idx_t</b>
           <b>nrhs</b>, <b>rsb_flags_t</b> <b>order</b>, <b>const</b> <b>void</b> *<b>betap</b>, <b>const</b> <b>void</b> *<b>Bp</b>, <b>rsb_nnz_idx_t</b> <b>ldB</b>, <b>void</b> *<b>Cp</b>,
           <b>rsb_nnz_idx_t</b> <b>ldC</b>)
       <b>rsb_err_t</b> <b>rsb_coo_sort</b> (<b>void</b> *<b>VA</b>, <b>rsb_coo_idx_t</b> *<b>IA</b>, <b>rsb_coo_idx_t</b> *<b>JA</b>, <b>rsb_nnz_idx_t</b> <b>nnzA</b>, <b>rsb_coo_idx_t</b>
           <b>nrA</b>, <b>rsb_coo_idx_t</b> <b>ncA</b>, <b>rsb_type_t</b> <b>typecode</b>, <b>rsb_flags_t</b> <b>flagsA</b>)
       <b>rsb_err_t</b> <b>rsb_coo_cleanup</b> (<b>rsb_coo_idx_t</b> *<b>nnzp</b>, <b>void</b> *<b>VA</b>, <b>rsb_coo_idx_t</b> *<b>IA</b>, <b>rsb_coo_idx_t</b> *<b>JA</b>,
           <b>rsb_nnz_idx_t</b> <b>nnzA</b>, <b>rsb_coo_idx_t</b> <b>nrA</b>, <b>rsb_coo_idx_t</b> <b>ncA</b>, <b>rsb_type_t</b> <b>typecode</b>, <b>rsb_flags_t</b> <b>flagsA</b>)
       <b>rsb_err_t</b> <b>rsb_file_mtx_get_dims</b> (<b>const</b> <b>char</b> *<b>filename</b>, <b>rsb_coo_idx_t</b> *<b>nrp</b>, <b>rsb_coo_idx_t</b> *<b>ncp</b>,
           <b>rsb_coo_idx_t</b> *<b>nzp</b>, <b>rsb_flags_t</b> *<b>flagsp</b>)
       <b>rsb_err_t</b> <b>rsb_perror</b> (<b>void</b> *<b>stream</b>, <b>rsb_err_t</b> <b>errval</b>)
       <b>rsb_err_t</b> <b>rsb_strerror_r</b> (<b>rsb_err_t</b> <b>errval</b>, <b>rsb_char_t</b> *<b>buf</b>, <b>size_t</b> <b>buflen</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_upd_vals</b> (<b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>enum</b> <b>rsb_elopf_t</b> <b>elop_flags</b>, <b>const</b> <b>void</b> *<b>omegap</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_set_vals</b> (<b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>const</b> <b>void</b> *<b>VA</b>, <b>const</b> <b>rsb_coo_idx_t</b> *<b>IA</b>, <b>const</b>
           <b>rsb_coo_idx_t</b> *<b>JA</b>, <b>rsb_nnz_idx_t</b> nnz, <b>rsb_flags_t</b> <b>flags</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_get_vals</b> (<b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>void</b> *<b>VA</b>, <b>const</b> <b>rsb_coo_idx_t</b> *<b>IA</b>, <b>const</b>
           <b>rsb_coo_idx_t</b> *<b>JA</b>, <b>rsb_nnz_idx_t</b> nnz, <b>rsb_flags_t</b> <b>flags</b>)
       <b>rsb_err_t</b> <b>rsb_file_mtx_save</b> (<b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>const</b> <b>rsb_char_t</b> *<b>filename</b>)
       <b>rsb_err_t</b> <b>rsb_file_vec_save</b> (<b>const</b> <b>rsb_char_t</b> *<b>filename</b>, <b>rsb_type_t</b> <b>typecode</b>, <b>const</b> <b>void</b> *<b>Yp</b>,
           <b>rsb_coo_idx_t</b> <b>yvl</b>)
       <b>rsb_err_t</b> <b>rsb_file_vec_load</b> (<b>const</b> <b>rsb_char_t</b> *<b>filename</b>, <b>rsb_type_t</b> <b>typecode</b>, <b>void</b> *<b>Yp</b>, <b>rsb_coo_idx_t</b>
           *<b>yvlp</b>)
       <b>struct</b> <b>rsb_mtx_t</b> * <b>rsb_file_mtx_load</b> (<b>const</b> <b>rsb_char_t</b> *<b>filename</b>, <b>rsb_flags_t</b> <b>flagsA</b>, <b>rsb_type_t</b>
           <b>typecode</b>, <b>rsb_err_t</b> *<b>errvalp</b>)
       <b>struct</b> <b>rsb_mtx_t</b> * <b>rsb_sppsp</b> (<b>rsb_type_t</b> <b>typecode</b>, <b>rsb_trans_t</b> <b>transA</b>, <b>const</b> <b>void</b> *<b>alphap</b>, <b>const</b> <b>struct</b>
           <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>rsb_trans_t</b> <b>transB</b>, <b>const</b> <b>void</b> *<b>betap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxBp</b>, <b>rsb_err_t</b>
           *<b>errvalp</b>)
       <b>struct</b> <b>rsb_mtx_t</b> * <b>rsb_spmsp</b> (<b>rsb_type_t</b> <b>typecode</b>, <b>rsb_trans_t</b> <b>transA</b>, <b>const</b> <b>void</b> *<b>alphap</b>, <b>const</b> <b>struct</b>
           <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>rsb_trans_t</b> <b>transB</b>, <b>const</b> <b>void</b> *<b>betap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxBp</b>, <b>rsb_err_t</b>
           *<b>errvalp</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_add_to_dense</b> (<b>const</b> <b>void</b> *<b>alphap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>rsb_nnz_idx_t</b> <b>ldB</b>,
           <b>rsb_nnz_idx_t</b> <b>nrB</b>, <b>rsb_nnz_idx_t</b> <b>ncB</b>, <b>rsb_bool_t</b> <b>rowmajorB</b>, <b>void</b> *<b>Bp</b>)
       <b>rsb_trans_t</b> <b>rsb_psblas_trans_to_rsb_trans</b> (<b>const</b> <b>char</b> <b>psbtrans</b>)
       <b>struct</b> <b>rsb_mtx_t</b> * <b>rsb_mtx_alloc_from_csr_const</b> (<b>const</b> <b>void</b> *<b>VA</b>, <b>const</b> <b>rsb_coo_idx_t</b> *<b>RP</b>, <b>const</b>
           <b>rsb_coo_idx_t</b> *<b>JA</b>, <b>rsb_nnz_idx_t</b> <b>nnzA</b>, <b>rsb_type_t</b> <b>typecode</b>, <b>rsb_coo_idx_t</b> <b>nrA</b>, <b>rsb_coo_idx_t</b> <b>ncA</b>,
           <b>rsb_blk_idx_t</b> <b>brA</b>, <b>rsb_blk_idx_t</b> <b>bcA</b>, <b>rsb_flags_t</b> <b>flagsA</b>, <b>rsb_err_t</b> *<b>errvalp</b>)
       <b>struct</b> <b>rsb_mtx_t</b> * <b>rsb_mtx_alloc_from_csc_const</b> (<b>const</b> <b>void</b> *<b>VA</b>, <b>const</b> <b>rsb_coo_idx_t</b> *<b>IA</b>, <b>const</b>
           <b>rsb_coo_idx_t</b> *<b>CP</b>, <b>rsb_nnz_idx_t</b> <b>nnzA</b>, <b>rsb_type_t</b> <b>typecode</b>, <b>rsb_coo_idx_t</b> <b>nrA</b>, <b>rsb_coo_idx_t</b> <b>ncA</b>,
           <b>rsb_blk_idx_t</b> <b>brA</b>, <b>rsb_blk_idx_t</b> <b>bcA</b>, <b>rsb_flags_t</b> <b>flagsA</b>, <b>rsb_err_t</b> *<b>errvalp</b>)
       <b>struct</b> <b>rsb_mtx_t</b> * <b>rsb_mtx_alloc_from_csr_inplace</b> (<b>void</b> *<b>VA</b>, <b>rsb_nnz_idx_t</b> *<b>RP</b>, <b>rsb_coo_idx_t</b> *<b>JA</b>,
           <b>rsb_nnz_idx_t</b> <b>nnzA</b>, <b>rsb_type_t</b> <b>typecode</b>, <b>rsb_coo_idx_t</b> <b>nrA</b>, <b>rsb_coo_idx_t</b> <b>ncA</b>, <b>rsb_blk_idx_t</b> <b>brA</b>,
           <b>rsb_blk_idx_t</b> <b>bcA</b>, <b>rsb_flags_t</b> <b>flagsA</b>, <b>rsb_err_t</b> *<b>errvalp</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_switch_to_csr</b> (<b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>void</b> **<b>VAp</b>, <b>rsb_coo_idx_t</b> **<b>IAp</b>, <b>rsb_coo_idx_t</b>
           **<b>JAp</b>, <b>rsb_flags_t</b> <b>flags</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_get_coo</b> (<b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>void</b> *<b>VA</b>, <b>rsb_coo_idx_t</b> *<b>IA</b>, <b>rsb_coo_idx_t</b> *<b>JA</b>,
           <b>rsb_flags_t</b> <b>flags</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_get_csr</b> (<b>rsb_type_t</b> <b>typecode</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>void</b> *<b>VA</b>, <b>rsb_nnz_idx_t</b>
           *<b>RP</b>, <b>rsb_coo_idx_t</b> *<b>JA</b>, <b>rsb_flags_t</b> <b>flags</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_get_rows_sparse</b> (<b>rsb_trans_t</b> <b>transA</b>, <b>const</b> <b>void</b> *<b>alphap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>,
           <b>void</b> *<b>VA</b>, <b>rsb_coo_idx_t</b> *<b>IA</b>, <b>rsb_coo_idx_t</b> *<b>JA</b>, <b>rsb_coo_idx_t</b> <b>frA</b>, <b>rsb_coo_idx_t</b> <b>lrA</b>, <b>rsb_nnz_idx_t</b>
           *<b>rnzp</b>, <b>rsb_flags_t</b> <b>flags</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_get_coo_block</b> (<b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>void</b> *<b>VA</b>, <b>rsb_coo_idx_t</b> *<b>IA</b>,
           <b>rsb_coo_idx_t</b> *<b>JA</b>, <b>rsb_coo_idx_t</b> <b>frA</b>, <b>rsb_coo_idx_t</b> <b>lrA</b>, <b>rsb_coo_idx_t</b> <b>fcA</b>, <b>rsb_coo_idx_t</b> <b>lcA</b>, <b>const</b>
           <b>rsb_coo_idx_t</b> *<b>IREN</b>, <b>const</b> <b>rsb_coo_idx_t</b> *<b>JREN</b>, <b>rsb_nnz_idx_t</b> *<b>rnzp</b>, <b>rsb_flags_t</b> <b>flags</b>)
       <b>rsb_err_t</b> <b>rsb_spmm</b> (<b>rsb_trans_t</b> <b>transA</b>, <b>const</b> <b>void</b> *<b>alphap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>rsb_coo_idx_t</b>
           <b>nrhs</b>, <b>rsb_flags_t</b> <b>order</b>, <b>const</b> <b>void</b> *<b>Bp</b>, <b>rsb_nnz_idx_t</b> <b>ldB</b>, <b>const</b> <b>void</b> *<b>betap</b>, <b>void</b> *<b>Cp</b>,
           <b>rsb_nnz_idx_t</b> <b>ldC</b>)
       <b>rsb_err_t</b> <b>rsb_spmsp_to_dense</b> (<b>rsb_type_t</b> <b>typecode</b>, <b>rsb_trans_t</b> <b>transA</b>, <b>const</b> <b>void</b> *<b>alphap</b>, <b>const</b> <b>struct</b>
           <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>rsb_trans_t</b> <b>transB</b>, <b>const</b> <b>void</b> *<b>betap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxBp</b>, <b>rsb_nnz_idx_t</b>
           <b>ldC</b>, <b>rsb_nnz_idx_t</b> <b>nrC</b>, <b>rsb_nnz_idx_t</b> <b>ncC</b>, <b>rsb_bool_t</b> <b>rowmajorC</b>, <b>void</b> *<b>Cp</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_rndr</b> (<b>const</b> <b>char</b> *<b>filename</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>rsb_coo_idx_t</b> <b>pmWidth</b>,
           <b>rsb_coo_idx_t</b> <b>pmHeight</b>, <b>rsb_marf_t</b> <b>rflags</b>)
       <b>rsb_err_t</b> <b>rsb_file_mtx_rndr</b> (<b>void</b> *<b>pmp</b>, <b>const</b> <b>char</b> *<b>filename</b>, <b>rsb_coo_idx_t</b> <b>pmlWidth</b>, <b>rsb_coo_idx_t</b>
           <b>pmWidth</b>, <b>rsb_coo_idx_t</b> <b>pmHeight</b>, <b>rsb_marf_t</b> <b>rflags</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_switch_to_coo</b> (<b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>void</b> **<b>VAp</b>, <b>rsb_coo_idx_t</b> **<b>IAp</b>, <b>rsb_coo_idx_t</b>
           **<b>JAp</b>, <b>rsb_flags_t</b> <b>flags</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_get_prec</b> (<b>void</b> *<b>opdp</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>rsb_precf_t</b> <b>prec_flags</b>, <b>const</b> <b>void</b>
           *<b>ipdp</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_get_info</b> (<b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>enum</b> <b>rsb_mif_t</b> <b>miflags</b>, <b>void</b> *<b>minfop</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_get_info_str</b> (<b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>const</b> <b>rsb_char_t</b> *<b>mis</b>, <b>void</b> *<b>minfop</b>,
           <b>size_t</b> <b>buflen</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_get_nrm</b> (<b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>void</b> *<b>Np</b>, <b>enum</b> <b>rsb_extff_t</b> <b>flags</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_get_vec</b> (<b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>void</b> *<b>Dp</b>, <b>enum</b> <b>rsb_extff_t</b> <b>flags</b>)
       <b>rsb_time_t</b> <b>rsb_time</b> (<b>void</b>)
       <b>struct</b> <b>rsb_mtx_t</b> * <b>rsb_mtx_alloc_from_coo_begin</b> (<b>rsb_nnz_idx_t</b> <b>nnzA</b>, <b>rsb_type_t</b> <b>typecode</b>, <b>rsb_coo_idx_t</b>
           <b>nrA</b>, <b>rsb_coo_idx_t</b> <b>ncA</b>, <b>rsb_flags_t</b> <b>flagsA</b>, <b>rsb_err_t</b> *<b>errvalp</b>)
       <b>rsb_err_t</b> <b>rsb_mtx_alloc_from_coo_end</b> (<b>struct</b> <b>rsb_mtx_t</b> **<b>mtxApp</b>)
       <b>rsb_err_t</b> <b>rsb_tune_spmm</b> (<b>struct</b> <b>rsb_mtx_t</b> **<b>mtxOpp</b>, <b>rsb_real_t</b> *<b>sfp</b>, <b>rsb_int_t</b> *<b>tnp</b>, <b>rsb_int_t</b> <b>maxr</b>,
           <b>rsb_time_t</b> <b>maxt</b>, <b>rsb_trans_t</b> <b>transA</b>, <b>const</b> <b>void</b> *<b>alphap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>rsb_coo_idx_t</b>
           <b>nrhs</b>, <b>rsb_flags_t</b> <b>order</b>, <b>const</b> <b>void</b> *<b>Bp</b>, <b>rsb_nnz_idx_t</b> <b>ldB</b>, <b>const</b> <b>void</b> *<b>betap</b>, <b>void</b> *<b>Cp</b>,
           <b>rsb_nnz_idx_t</b> <b>ldC</b>)
       <b>rsb_err_t</b> <b>rsb_tune_spsm</b> (<b>struct</b> <b>rsb_mtx_t</b> **<b>mtxOpp</b>, <b>rsb_real_t</b> *<b>sfp</b>, <b>rsb_int_t</b> *<b>tnp</b>, <b>rsb_int_t</b> <b>maxr</b>,
           <b>rsb_time_t</b> <b>maxt</b>, <b>rsb_trans_t</b> <b>transA</b>, <b>const</b> <b>void</b> *<b>alphap</b>, <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> *<b>mtxAp</b>, <b>rsb_coo_idx_t</b>
           <b>nrhs</b>, <b>rsb_flags_t</b> <b>order</b>, <b>const</b> <b>void</b> *<b>Bp</b>, <b>rsb_nnz_idx_t</b> <b>ldB</b>, <b>const</b> <b>void</b> *<b>betap</b>, <b>void</b> *<b>Cp</b>,
           <b>rsb_nnz_idx_t</b> <b>ldC</b>)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
        The reference documentation of the librsb library comes in both HTML and Unix man pages formats.
        The following sections/man pages are available: <b>The</b> <b>librsb</b> <b>library</b> <b>interface</b> <b>(rsb.h,</b> <b>optional</b> <b>ones</b>
       <b>rsb.hpp</b> <b>and</b> <b>rsb.F90)</b> ; <b>The</b> <b>Sparse</b> <b>BLAS</b> <b>interface</b> <b>to</b> <b>librsb</b> <b>(blas_sparse.h,</b> <b>rsb_blas_sparse.F90)</b> ; <b>Example</b>
       <b>programs</b> <b>and</b> <b>code</b>.

       In general, users of this library are interested in high performance sparse matrix computations on cache
       based shared memory parallel computers.
        For this, librsb offers a native C interface (here documented) and a Fortran one (in <b>rsb.F90</b>, equivalent
       to the C declaration headers from <b>rsb.h</b>), in addition to the Sparse BLAS one (both C and Fortran,
       documented).
        Please refer to optional &lt;<b>rsb.hpp</b>&gt; for the C++ API.

       Configuration, build, and installation instructions are contained in the README file distributed in the
       sources archive.

        <b>Typical</b> <b>C</b> <b>program</b> <b>structure</b>

       •
        initialize librsb with <b>rsb_lib_init()</b>
       •
        (in  any  order)  allocate  matrices  (e.g.:  with  <b>rsb_mtx_alloc_from_coo_inplace()</b>  or others); do any
        computation  with  them   (e.g.:   <b>rsb_spmv()</b>,   <b>rsb_spsv()</b>   );   converting   matrices   (e.g.:   with
        <b>rsb_mtx_switch_to_coo()</b> ); freeing matrices (<b>rsb_mtx_free()</b> )
       •
        finalize librsb with <b>rsb_lib_exit()</b>
        <b>Important</b> <b>usage</b> <b>notes</b>
        <b>General</b>  <b>C</b>  <b>program</b>  <b>structure</b>   Before calling any librsb function, a program is required to initialize
       librsb's internal status. This is done by calling <b>rsb_lib_init()</b> . Afterwards, any librsb function can be
       safely used. When  librsb  functions  are  not  intended  to  be  called  anymore,  a  program  may  call
       <b>rsb_lib_exit()</b> to free any resource. Then, <b>rsb_lib_init()</b> should be called for further usage of librsb.
        <b>Manipulating</b>  <b>matrices</b>  <b>and</b>  <b>vectors</b>  In order to use librsb, the user is not required to use explicitly
       any of librsb's data structures: their manipulation is to be performed by  librsb  functions.  Therefore,
       knowledge  of  librsb's matrix type (rsb_mtx_t) is not necessary at all: this structure is intended to be
       used as an opaque container.
       On the contrary, arrays for numerical vectors (or more generally, dense  matrices)  are  expected  to  be
       managed  by  the  user:  librsb  does not furnish any specific vector type. Computational functions treat
       dense vectors/matrices are simple arrays of a specified type; see the <b>Example</b> <b>programs</b> <b>and</b> <b>code</b> .
        <b>Computational</b> <b>functions</b>  This library can be configured at build time to  support  a  custom  subset  of
       numerical  types.  To  keep  the  programming interface compact, it has been decided to not replicate the
       computational functions to each numerical type. Instead, the type is expected to be specified by the user
       via a type flag. For instance, matrix assembly functions (e.g.: <b>rsb_mtx_alloc_from_coo_const()</b> ) accept a
       type information and keep it stored in the matrix structure. Therefore,  computational  functions  (e.g.:
       <b>rsb_spmv()</b>  )  can  fetch  this information from their rsb_mtx_t operand, and treat accordingly the other
       parameters (e.g.: <u>alphap</u>, <u>Xp</u>, ...). Mixed type operations are currently not supported.
        <b>Memory</b> <b>management</b>
       Matrix structures (rsb_mtx_t) allocated by librsb shall be freed only via <b>rsb_mtx_free()</b> .
        <b>Benchmarking</b>
       If you want to benchmark this library, there are different possibilities:
       #!<a href="file:/bin/bash">/bin/bash</a>

       set -e
       set -x

       # the benchmark command assumes A.mtx is a file in Matrix Market format
       rsbench -oa -Ob --bench --nmb -f pd.mtx

       # it has many (librsb development-oriented) options
       rsbench -oa -Ob --help

       # this is mostly a development tool so don't rely on much more than the above.

        <b>Tuning</b> <b>and</b> <b>Customization</b>
       There are different ./configure options you may look at for tuning or customizing the library.
</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RSB_SIZEOF(TYPE)</b>   <b>RSB_NUMERICAL_TYPE_SIZE(TYPE)</b>
       Use <b>RSB_SIZEOF</b> macro to get the size (in bytes) of a type supported by the library (e.g.: when allocating
       numerical vectors).
</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>rsb_elopf_t</b>
       Flags for specifying a particular elemental/row-wise operation with <b>rsb_mtx_upd_vals()</b>.
       <b>Enumerator</b>
       <u>RSB_ELOPF_MUL</u>
              Elemental multiplication of the matrix by a  specified  scalar  (usable  with  <b>rsb_mtx_upd_vals()</b>,
              binary operation).
       <u>RSB_ELOPF_DIV</u>
              Elemental division by a specified scalar (usable with <b>rsb_mtx_upd_vals()</b>, binary operation).
       <u>RSB_ELOPF_POW</u>
              Elemental power to a specified scalar (usable with <b>rsb_mtx_upd_vals()</b>, binary operation).
       <u>RSB_ELOPF_NEG</u>
              Elemental negation (usable with <b>rsb_mtx_upd_vals()</b>, unary operation).
       <u>RSB_ELOPF_SCALE_ROWS</u>
              Row wise scaling by a specified scaling vector (usable with <b>rsb_mtx_upd_vals()</b>, binary operation).
       <u>RSB_ELOPF_SCALE_COLS</u>
              Column  wise  scaling  by  a  specified  scaling  vector  (usable  with <b>rsb_mtx_upd_vals()</b>, binary
              operation).
       <u>RSB_ELOPF_SCALE_ROWS_REAL</u>
              Row wise scaling by a specified scaling vector. If matrix is of a complex type,  the  argument  is
              expected  to  be of the corresponding real type (assumed that that type has been enabled). (usable
              with <b>rsb_mtx_upd_vals()</b>, binary operation).
       <u>RSB_ELOPF_SCALE_COLS_REAL</u>
              Column wise scaling by a specified scaling vector. If matrix is of a complex type, the argument is
              expected to be of the corresponding real type (assumed that that type has been  enabled).  (usable
              with <b>rsb_mtx_upd_vals()</b>, binary operation).
   <b>enum</b> <b>rsb_extff_t</b>
       Extraction filter flags, to be used with <b>rsb_mtx_get_nrm()</b>/<b>rsb_mtx_get_vec()</b>.
       <b>Enumerator</b>
       <u>RSB_EXTF_NORM_ONE</u>
              <b>rsb_mtx_get_nrm()</b> flag value for computing the one-norm.
       <u>RSB_EXTF_NORM_TWO</u>
              <b>rsb_mtx_get_nrm()</b> flag value for computing the two-norm (Frobenius norm).
       <u>RSB_EXTF_NORM_INF</u>
              <b>rsb_mtx_get_nrm()</b> flag value for computing the infinity-norm.
       <u>RSB_EXTF_SUMS_ROW</u>
              <b>rsb_mtx_get_vec()</b> flag value for computing the sum along each row.
       <u>RSB_EXTF_SUMS_COL</u>
              <b>rsb_mtx_get_vec()</b> flag value for computing the sum along each column.
       <u>RSB_EXTF_ASUMS_ROW</u>
              <b>rsb_mtx_get_vec()</b> flag value for computing the absolute values sum, along each row.
       <u>RSB_EXTF_ASUMS_COL</u>
              <b>rsb_mtx_get_vec()</b> flag value for computing the absolute values sum, along each column.
       <u>RSB_EXTF_DIAG</u>
              <b>rsb_mtx_get_vec()</b> flag value for extracting the diagonal submatrix.
   <b>enum</b> <b>rsb_mif_t</b>
       Flags for getting matrix information via <b>rsb_mtx_get_info()</b>/<b>rsb_mtx_get_info_str()</b>.
       <b>Enumerator</b>
       <u>RSB_MIF_INDEX_STORAGE_IN_BYTES</u><b>__</b><u>TO</u><b>__</b><u>SIZE_T</u>
              Index storage occupation, in bytes. (size_t)
       <u>RSB_MIF_INDEX_STORAGE_IN_BYTES_PER_NNZ</u><b>__</b><u>TO</u><b>__</b><u>RSB_REAL_T</u>
              Index storage occupation per nnz, in bytes. (<b>rsb_real_t</b>)
       <u>RSB_MIF_MATRIX_ROWS</u><b>__</b><u>TO</u><b>__</b><u>RSB_COO_INDEX_T</u>
              Rows count(<b>rsb_coo_idx_t</b>)
       <u>RSB_MIF_MATRIX_COLS</u><b>__</b><u>TO</u><b>__</b><u>RSB_COO_INDEX_T</u>
              Columns count (<b>rsb_coo_idx_t</b>)
       <u>RSB_MIF_MATRIX_NNZ</u><b>__</b><u>TO</u><b>__</b><u>RSB_NNZ_INDEX_T</u>
              Nonzeroes count (<b>rsb_nnz_idx_t</b>)
       <u>RSB_MIF_TOTAL_SIZE</u><b>__</b><u>TO</u><b>__</b><u>SIZE_T</u>
              Total size, in bytes (size_t)
       <u>RSB_MIF_MATRIX_FLAGS</u><b>__</b><u>TO</u><b>__</b><u>RSB_FLAGS_T</u>
              Matrix flags (<b>rsb_flags_t</b>)
       <u>RSB_MIF_MATRIX_TYPECODE</u><b>__</b><u>TO</u><b>__</b><u>RSB_TYPE_T</u>
              Matrix type code (<b>rsb_type_t</b>)
       <u>RSB_MIF_MATRIX_INFO</u><b>__</b><u>TO</u><b>__</b><u>CHAR_P</u>
              Matrix info string, only for <b>rsb_mtx_get_info_str()</b> (<b>rsb_char_t</b>*)
       <u>RSB_MIF_LEAVES_COUNT</u><b>__</b><u>TO</u><b>__</b><u>RSB_BLK_INDEX_T</u>
              Leaf submatrices count (<b>rsb_blk_idx_t</b>)
   <b>enum</b> <b>rsb_opt_t</b>
       library    option   values   for   <b>rsb_lib_init</b>,   <b>rsb_lib_set_opt_str</b>,   <b>rsb_lib_reinit</b>,   <b>rsb_lib_exit</b>,
       <b>rsb_lib_get_opt</b>,     <b>rsb_lib_set_opt</b>,     or     (deprecated)     macros     <b>RSB_REINIT_SINGLE_VALUE_GET</b>,
       <b>RSB_REINIT_SINGLE_VALUE_SET</b>, <b>RSB_REINIT_SINGLE_VALUE</b>, <b>RSB_REINIT_SINGLE_VALUE_C_IOP</b>..
       <b>Enumerator</b>
       <u>RSB_IO_WANT_VERBOSE_INIT</u>
              <b>RSB_IO_WANT_VERBOSE_INIT</b>  prompts  for  a  verbose initialization of the library: messages will be
              written to the file descriptor (FILE*) pointed by the value pointer when calling  <b>rsb_lib_init</b>  or
              <b>rsb_lib_reinit</b>.
       <u>RSB_IO_WANT_VERBOSE_EXIT</u>
              <b>RSB_IO_WANT_VERBOSE_EXIT</b>  prompts  for  a  verbose  finalization  of the library: messages will be
              written to the file descriptor (FILE*) pointed by the value pointer when calling <b>rsb_lib_exit</b>.
       <u>RSB_IO_WANT_OUTPUT_STREAM</u>
              Specifies the default output stream. Output (debug info) info will be written
               to the file descriptor (FILE*) pointed by the value pointer.
       <u>RSB_IO_WANT_SORT_METHOD</u>
              Specifies the default sorting method. Specified  as  a  pointed  integer  (<b>rsb_int_t</b>)  number,  in
              {[0],1}. (internal)
       <u>RSB_IO_WANT_CACHE_BLOCKING_METHOD</u>
              Specifies the default cache blocking method. Specified as a pointed integer (<b>rsb_int_t</b>) number, in
              {-1,[0],1}. (internal)
       <u>RSB_IO_WANT_SUBDIVISION_MULTIPLIER</u>
              Specifies  a  multiplier  for  finer  (if  &gt;1.0) or coarser (if &lt;1.0) subdivisions. Specified as a
              pointed (<b>rsb_real_t</b>) number, in {..,[1.0],..}. (internal)
       <u>RSB_IO_WANT_VERBOSE_ERRORS</u>
              Prompts for a verbose error reporting: messages will be written to  the  file  descriptor  (FILE*)
              pointed  by  the value pointer. Only meaningful if an interface error verbosity greater than 0 was
              set at configure time.
       <u>RSB_IO_WANT_BOUNDED_BOX_COMPUTATION</u>
              Prompts for bounded box computation, for a smoother  submatrices  locking;  pointed  <b>rsb_int_t</b>  in
              {0,[1]}. (internal).
       <u>RSB_IO_WANT_EXECUTING_THREADS</u>
              Specifies the number of desired executing threads; pointed <b>rsb_int_t</b> in {[0],1,..}.
       <u>RSB_IO_WANT_EXTRA_VERBOSE_INTERFACE</u>
              Specifies  the  level  of  interface  verbosity; if setting, pointed <b>rsb_int_t</b> values should be in
              {[0],1,..}. Support may be enabled or disabled at build  time  via  the  --enable-internals-error-
              verbosity  configure  option. If disabled, only getting is supported and yields -1, but setting is
              not supported and the <b>RSB_ERR_NO_STREAM_OUTPUT_CONFIGURED_OUT</b> error will be returned.
       <u>RSB_IO_WANT_MEMORY_HIERARCHY_INFO_STRING</u>
              Specifies a custom memory hierarchy info string; pointed const <b>rsb_char_t</b>*; (may point to  a  NULL
              string pointer).
       <u>RSB_IO_WANT_IS_INITIALIZED_MARKER</u>
              Used  for getting whether the library has been initialized (<b>RSB_BOOL_TRUE</b>) or not (<b>RSB_BOOL_FALSE</b>)
              ; pointed const <b>rsb_bool_t</b>*; (this is NOT for general users).
       <u>RSB_IO_WANT_MEM_ALLOC_CNT</u>
              Used for getting the count of memory allocations performed by  librsb  employing  librsb's  memory
              allocation  wrapper (if disabled, will return zero); pointed const size_t*; (this is for debugging
              purposes).
       <u>RSB_IO_WANT_MEM_ALLOC_TOT</u>
              Used for getting the total  amount  of  memory  allocated  by  librsb  employing  librsb's  memory
              allocation  wrapper (if disabled, will return zero); pointed const size_t*; (this is for debugging
              purposes).
       <u>RSB_IO_WANT_LEAF_LEVEL_MULTIVEC</u>
              Specifies whether the default multi-vector ops shall act at a leaf level (default value  of  0  is
              yes). Specified as a pointed integer (<b>rsb_int_t</b>) number, in {-1,[0]}. (internal)
       <u>RSB_IO_WANT_MAX_MEMORY_ALLOCATIONS</u>
              Specifies  an  upper  limit  to  the  count of allocated memory areas (default value of 0 means no
              limit). Specified as a pointed size_t. Only  works  if  the  memory  wrapper  (--enable-allocator-
              wrapper) has been specified at configure time.
       <u>RSB_IO_WANT_MAX_MEMORY_ALLOCATED</u>
              Specifies  an  upper  limit to the amount of allocated memory (default value of 0 means no limit).
              Specified as a pointed size_t. Only works if the memory wrapper  (--enable-allocator-wrapper)  has
              been specified at configure time.
       <u>RSB_IO_WANT_LIBRSB_ETIME</u>
              Represents  time  spent  in  librsb.  Specified  as a pointed <b>rsb_time_t</b>. Only works if statistics
              collection (--enable-librsb-stats) was specified at configure time.
       <u>RSB_IO_WANT_VERBOSE_TUNING</u>
              Auto tuning verbosity level for rsb_tune_spmm/rsb_tune_spsm. If 0, no verbosity; if 1, verbose; if
              2, verbose with trace files being dumped.
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>rsb_err_t</b> <b>rsb_coo_cleanup</b> <b>(rsb_coo_idx_t</b> <b>*</b>  <b>nnzp,</b>  <b>void</b>  <b>*</b>  <b>VA,</b>  <b>rsb_coo_idx_t</b>  <b>*</b>  <b>IA,</b>  <b>rsb_coo_idx_t</b>  <b>*</b>  <b>JA,</b>
       <b>rsb_nnz_idx_t</b> <b>nnzA,</b> <b>rsb_coo_idx_t</b> <b>nrA,</b> <b>rsb_coo_idx_t</b> <b>ncA,</b> <b>rsb_type_t</b> <b>typecode,</b> <b>rsb_flags_t</b> <b>flagsA)</b>
       Compacts the given COO input arrays representing a sparse matrix $A$. Will either sum together duplicates
       or  use  the  last  one, depending on whether <b>RSB_FLAG_DUPLICATES_KEEP_LAST</b> or <b>RSB_FLAG_DUPLICATES_SUM</b> is
       present in flagsA.
       It is important that the input is sorted and flagsA shall contain  RSB_FLAG_SORTED_INPUT,  otherwise  the
       algorithm's complexity will be quadratic.
       <b>Parameters</b>
           <u>nnzp</u> Pointer to the number of nonzeroes after the cleanup.
           <u>VA,IA,JA</u> Output numerical values (VA) array; output row (IA) and column (JA) indices arrays.
           <u>nnzA</u> The number of nonzeroes in the input arrays representing matrix $A$.
           <u>nrA,ncA</u> The number of rows and columns of the sparse matrix $A$.
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>flagsA</u> A valid combination of matrix storage flags. If unsure, use <b>RSB_FLAG_NOFLAGS</b>.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       <b>See</b> <b>also</b>
           <b>rsb_time</b>, <b>rsb_coo_sort</b>
           <b>rsb_coo_sort</b>
       <b>Warning</b>
           This is an experimental librsb-1.3 function.
       <b>Note</b>
           By  invoking  with  swapped  IA and JA (and swapping nrA and ncA as well) one can obtain column major
           order.
       Examples:
               rsb_err_t errval = RSB_ERR_NO_ERROR;
               rsb_nnz_idx_t nnzA = 4;
               const rsb_coo_idx_t  nrA = 4;
               const rsb_coo_idx_t  ncA = 4;
               rsb_coo_idx_t    IA[] = { 1, 1, 1, 2 };
               rsb_coo_idx_t    JA[] = { 1, 1, 3, 2 };
               RSB_DEFAULT_TYPE VA[] = { 1, 10, 13, 22 };
               const rsb_type_t typecode = RSB_NUMERICAL_TYPE_DEFAULT;
               rsb_flags_t flagsA = RSB_FLAG_DUPLICATES_SUM | RSB_FLAG_SORTED_INPUT;
               // IA={1,1,1,2} JA={1,1,3,2} VA={1,10,13,22} nnzA=4 nrA=4 nca=4

               if((errval = rsb_lib_init(RSB_NULL_INIT_OPTIONS))
                               != RSB_ERR_NO_ERROR) goto err;

               errval = rsb_coo_cleanup(&amp;nnzA, VA, IA, JA,
                        nnzA, nrA, ncA, typecode, flagsA );
               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_coo_cleanup!\n");
                       goto err;
               }
               // IA={1,1,2} JA={1,3,2} VA={11,13,22} nnzA=3 nrA=4 nca=4
               rsb_err_t errval = RSB_ERR_NO_ERROR;
               rsb_nnz_idx_t nnzA = 3;
               const rsb_coo_idx_t  nrA = 2;
               const rsb_coo_idx_t  ncA = 2;
               rsb_coo_idx_t    IA[] = { 1, 1, 1 };
               rsb_coo_idx_t    JA[] = { 2, 1, 1 };
               RSB_DEFAULT_TYPE VA[] = { 1, 2, 3 };
               const rsb_type_t typecode = RSB_NUMERICAL_TYPE_DEFAULT;
               const rsb_flags_t flagsA = RSB_FLAG_DUPLICATES_SUM
                               | RSB_FLAG_SORTED_INPUT
                               | RSB_FLAG_FORTRAN_INDICES_INTERFACE;

               // IA={1,1,1} JA={2,1,1} VA={1,2,3} nnzA=3 nrA=2 nca=2
               errval =rsb_coo_sort(VA, IA, JA, nnzA, nrA, ncA,  typecode, flagsA);
               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_coo_cleanup!\n");
                       goto err;
               }
               // IA={1,1,1} JA={1,1,2} VA={2,3,1} nnzA=3 nrA=2 nca=2

               errval = rsb_coo_cleanup(&amp;nnzA, VA, IA, JA, nnzA,
                        nrA, ncA, typecode, flagsA );
               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_coo_cleanup!\n");
                       goto err;
               }
               // IA={1,1} JA={1,2} VA={5,1} nnzA=2 nrA=2 nca=2
   <b>rsb_err_t</b> <b>rsb_coo_sort</b> <b>(void</b> <b>*</b> <b>VA,</b> <b>rsb_coo_idx_t</b> <b>*</b> <b>IA,</b> <b>rsb_coo_idx_t</b> <b>*</b> <b>JA,</b> <b>rsb_nnz_idx_t</b> <b>nnzA,</b>  <b>rsb_coo_idx_t</b>
       <b>nrA,</b> <b>rsb_coo_idx_t</b> <b>ncA,</b> <b>rsb_type_t</b> <b>typecode,</b> <b>rsb_flags_t</b> <b>flagsA)</b>
       Sorts row-major the given COO input arrays representing a sparse matrix $A$.
       <b>Parameters</b>
           <u>VA,IA,JA</u> Output numerical values (VA) array; output row (IA) and column (JA) indices arrays.
           <u>nnzA</u> The number of nonzeroes in the input arrays representing matrix $A$.
           <u>nrA,ncA</u>  The  number  of  rows and columns of the sparse matrix $A$. If any of nrA or ncA is zero, no
           sort occurs.
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>flagsA</u> A valid combination of matrix storage flags. If unsure, use <b>RSB_FLAG_NOFLAGS</b>.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       <b>See</b> <b>also</b>
           <b>rsb_time</b>, <b>rsb_coo_sort</b>
       <b>Note</b>
           By invoking with swapped IA and JA (and swapping nrA and ncA as well) one  can  obtain  column  major
           order.
   <b>rsb_err_t</b>   <b>rsb_file_mtx_get_dims</b>  <b>(const</b>  <b>char</b>  <b>*</b>  <b>filename,</b>  <b>rsb_coo_idx_t</b>  <b>*</b>  <b>nrp,</b>  <b>rsb_coo_idx_t</b>  <b>*</b>  <b>ncp,</b>
       <b>rsb_coo_idx_t</b> <b>*</b> <b>nzp,</b> <b>rsb_flags_t</b> <b>*</b> <b>flagsp)</b>
       Reads structural information (dimensions, structural flags) for a matrix file into  user  specified  (and
       optionally NULL) variables.
       <b>Parameters</b>
           <u>filename</u> The specified matrix file name (cannot be NULL).
           <u>nrp,ncp</u> Output pointers to rows and columns count variables (can be NULL).
           <u>nzp</u> Output pointer to the nonzeroes count variable (can be NULL).
           <u>flagsp</u>  Output  pointer  to  the  detected  structural  flags  variable.  Will  be  a  combination of
           <b>RSB_FLAG_LOWER</b>, <b>RSB_FLAG_UPPER</b>, <b>RSB_FLAG_SYMMETRIC</b>, <b>RSB_FLAG_HERMITIAN</b>.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b>  to  get  more  information  about  the  error.  If  read  dimensions  are  illegal (see
           <b>rsb_coo_idx_t</b>,<b>rsb_nnz_idx_t</b>), <b>RSB_ERR_LIMITS</b> will be returned.
       Example getting dimensions of a sparse matrix stored in a Matrix Market file:
               if(RSB_ERR_NO_ERROR!=(errval =
                       rsb_file_mtx_get_dims("pd.mtx",&amp;nrA,&amp;ncA,&amp;nnzA,NULL)))
               {
                       if(errval != RSB_ERR_UNSUPPORTED_FEATURE)
                               goto err; /* may have not configured what needed */
               }

       <b>Note</b>
           The only sparse matrix file format currently supported is Matrix Market. E.g.:
           %%MatrixMarket matrix coordinate real symmetric
           %
           % A Hilbert Matrix of order 3, so with 3 rows, 3 columns, and 6 nonzeroes.
           %
           3 3 6
           1 1 1.0
           2 1 0.5
           2 2 0.33
           3 1 0.33
           3 2 0.25
           3 3 0.2

            In the above example header on the first line, you can specify either real or complex or pattern for
           the numerical type. Either general, symmetric, hermitian can be specified for the structure. In  case
           of  pattern  matrices,  only  coordinate  indices  will be loaded (saving pattern matrices is not yet
           supported); in case of real matrices, also one coefficient value will be saved/loaded; in the case of
           complex matrices, both the real and imaginary parts will be saved/loaded in addition to the indices.
           Upper/lower flags will not be reported; hermitiannes do.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_coo</b>, <b>rsb_mtx_get_csr</b>, <b>rsb_mtx_get_rows_sparse</b>,  <b>rsb_mtx_get_coo_block</b>,  <b>rsb_mtx_get_prec</b>,
           <b>rsb_mtx_get_nrm</b>, <b>rsb_mtx_get_vec</b>, <b>rsb_file_mtx_get_dims</b>, <b>rsb_mtx_get_vals</b>
   <b>struct</b>  <b>rsb_mtx_t</b>  <b>*</b> <b>rsb_file_mtx_load</b> <b>(const</b> <b>rsb_char_t</b> <b>*</b> <b>filename,</b> <b>rsb_flags_t</b> <b>flagsA,</b> <b>rsb_type_t</b> <b>typecode,</b>
       <b>rsb_err_t</b> <b>*</b> <b>errvalp)</b>
       Loads a sparse matrix from the specified matrix file, assembling it in the  format  specified  by  flags,
       using  the  numerical  type  representation  as  specified  by  the  user. Extra input errors or warnings
       verbosity can be enabled via the ./configure --enable-internals-error-verbosity option.
       <b>Parameters</b>
           <u>filename</u> The specified matrix file name (cannot be NULL).
           <u>flagsA</u> A valid combination of matrix storage flags.
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>errvalp</u> An optional (can be NULL) pointer to <b>rsb_err_t</b> where the error status will be written to.
       <b>Returns</b>
           On  success,  a  valid pointer (struct rsb_mtx_t*) to the newly allocated matrix structure; on error,
           NULL.
       <b>Note</b>
           The only sparse matrix file format currently supported is Matrix Market. E.g.:
           %%MatrixMarket matrix coordinate real symmetric
           %
           % A Hilbert Matrix of order 3, so with 3 rows, 3 columns, and 6 nonzeroes.
           %
           3 3 6
           1 1 1.0
           2 1 0.5
           2 2 0.33
           3 1 0.33
           3 2 0.25
           3 3 0.2

            In the above example header on the first line, you can specify either real or complex or pattern for
           the numerical type. Either general, symmetric, hermitian can be specified for the structure. In  case
           of  pattern  matrices,  only  coordinate  indices  will be loaded (saving pattern matrices is not yet
           supported); in case of real matrices, also one coefficient value will be saved/loaded; in the case of
           complex matrices, both the real and imaginary parts will be saved/loaded in addition to the indices.
       Example loading a matrix from a Matrix Market file:
               mtxAp = rsb_file_mtx_load("pd.mtx",
                       RSB_FLAG_NOFLAGS,typecode,NULL);
               if(!mtxAp)
               {
                       return EXIT_FAILURE;
               }

       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_info</b>, <b>rsb_mtx_get_info_str</b>, <b>rsb_file_mtx_save</b>, <b>rsb_file_vec_load</b>, <b>rsb_file_mtx_load</b>
   <b>rsb_err_t</b> <b>rsb_file_mtx_rndr</b> <b>(void</b> <b>*</b>  <b>pmp,</b>  <b>const</b>  <b>char</b>  <b>*</b>  <b>filename,</b>  <b>rsb_coo_idx_t</b>  <b>pmlWidth,</b>  <b>rsb_coo_idx_t</b>
       <b>pmWidth,</b> <b>rsb_coo_idx_t</b> <b>pmHeight,</b> <b>rsb_marf_t</b> <b>rflags)</b>
       Renders as pixel map the matrix contained in a matrix file.
       <b>Parameters</b>
           <u>pmp</u> Pixel map array pointer.
           <u>filename</u> The specified matrix file name (cannot be NULL).
           <u>pmlWidth</u> stride between lines (in pixels; no less than pmWidth).
           <u>pmWidth</u> Pixel map width (in pixels or points).
           <u>pmHeight</u> Pixel map height (in pixels or points).
           <u>rflags</u>  The  color  mode;  only <b>RSB_MARF_RGB</b> is supported for now (1 byte per channel, 3 channels ---
           red, green, blue): this requires array pmp to be at least (3*pmlWidth*pmHeight) bytes large.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       <b>Note</b>
           At the time being, pmlWidth is required to be equal to pmWidth.
       Example rendering a matrix from a Matrix Market file to a pixelmap in memory:
               /* matrices can be rendered from file to a pixelmap as well */
               {
                       unsigned char pixmap[3*2*2];

                       if(RSB_ERR_NO_ERROR!=(errval =
                       rsb_file_mtx_rndr(pixmap,"pd.mtx",2,2,2,RSB_MARF_RGB)))
                               goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_mtx_rndr</b>, <b>rsb_file_mtx_rndr</b>
   <b>rsb_err_t</b> <b>rsb_file_mtx_save</b> <b>(const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>const</b> <b>rsb_char_t</b> <b>*</b> <b>filename)</b>
       Saves the given matrix to the specified matrix file.
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>filename</u>  The  specified  output  file name (if NULL or '' (the empty string), will write to standard
           output).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       <b>Warning</b>
           Some structural info contained in the matrix structural flags may be lost in the output data.
       <b>Note</b>
           The only sparse matrix file format currently supported is Matrix Market. E.g.:
           %%MatrixMarket matrix coordinate real symmetric
           %
           % A Hilbert Matrix of order 3, so with 3 rows, 3 columns, and 6 nonzeroes.
           %
           3 3 6
           1 1 1.0
           2 1 0.5
           2 2 0.33
           3 1 0.33
           3 2 0.25
           3 3 0.2

            In the above example header on the first line, you can specify either real or complex or pattern for
           the  numerical type. Either general, symmetric, hermitian can be specified for the structure. In case
           of pattern matrices, only coordinate indices will be loaded  (saving  pattern  matrices  is  not  yet
           supported); in case of real matrices, also one coefficient value will be saved/loaded; in the case of
           complex matrices, both the real and imaginary parts will be saved/loaded in addition to the indices.
       Example, printing a matrix to standard output:
               if(RSB_ERR_NO_ERROR!=(errval = rsb_file_mtx_save(mtxAp,NULL)))
               {
                       if(errval != RSB_ERR_UNSUPPORTED_FEATURE)
                               goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_info</b>, <b>rsb_mtx_get_info_str</b>, <b>rsb_file_mtx_save</b>, <b>rsb_file_vec_load</b>, <b>rsb_file_mtx_load</b>
   <b>rsb_err_t</b>  <b>rsb_file_vec_load</b>  <b>(const</b>  <b>rsb_char_t</b>  <b>*</b> <b>filename,</b> <b>rsb_type_t</b> <b>typecode,</b> <b>void</b> <b>*</b> <b>Yp,</b> <b>rsb_coo_idx_t</b> <b>*</b>
       <b>yvlp)</b>
       Loads a dense vector from the specified file, using the numerical type representation as specified by the
       user. This function is intended to be called in two steps: first with Yp=NULL,  in  order  to  write  the
       vector length to *yvlp ; then, with yvlp=NULL, to get Yp written.
       <b>Parameters</b>
           <u>filename</u> The specified vector file name (cannot be NULL).
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>Yp</u> The input array vector.
           <u>yvlp</u> An optional pointer (can be NULL). If supplied, vector length  will  be  written  here,  and  no
           vector will be read.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       Example loading vector matrix from file
               /* also vectors can be loaded */
               if(RSB_ERR_NO_ERROR!=(errval =
                       rsb_file_vec_load("vf.mtx",typecode,NULL,&amp;vl )))
                       goto err;
               /* we expect vf.mtx to be 6 rows long */
               if( vl != 6 )
               {
                       goto err;
               }

               if(RSB_ERR_NO_ERROR!=(errval =
                       rsb_file_vec_load("vf.mtx",typecode,XV, NULL )))
                       goto err;

       <b>Note</b>
           The only dense vector file format currently supported is Matrix Market. E.g.:
           %%MatrixMarket matrix array complex general
           % Test MatrixMarket file with a complex vector.
           % Note: a blank line like the following is OK.

           6           1
           11.000000000000000E+000 12.000000000000000E+000
           21.000000000000000E+000 22.000000000000000E+000
           31.000000000000000E+000 32.000000000000000E+000
           41.000000000000000E+000 42.000000000000000E+000
           51.000000000000000E+000 52.000000000000000E+000
           61.000000000000000E+000 62.000000000000000E+000

            In the above example header on the first line, you can specify either real or complex or pattern for
           the numerical type.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_info</b>, <b>rsb_mtx_get_info_str</b>, <b>rsb_file_mtx_save</b>, <b>rsb_file_vec_load</b>, <b>rsb_file_mtx_load</b>
   <b>rsb_err_t</b> <b>rsb_file_vec_save</b> <b>(const</b> <b>rsb_char_t</b> <b>*</b> <b>filename,</b> <b>rsb_type_t</b> <b>typecode,</b> <b>const</b> <b>void</b> <b>*</b> <b>Yp,</b> <b>rsb_coo_idx_t</b>
       <b>yvl)</b>
       Saves a dense vector to the specified file, using the numerical type representation as specified  by  the
       user. This function assumes Yp!=NULL and yvl&gt;0.
       <b>Parameters</b>
           <u>filename</u> The specified vector file name (cannot be NULL).
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>Yp</u> The output array vector.
           <u>yvl</u> Output vector length.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       <b>Note</b>
           The only dense vector file format currently supported is Matrix Market. E.g.:
           %%MatrixMarket matrix array complex general
           % Test MatrixMarket file with a complex vector.
           % Note: a blank line like the following is OK.

           6           1
           11.000000000000000E+000 12.000000000000000E+000
           21.000000000000000E+000 22.000000000000000E+000
           31.000000000000000E+000 32.000000000000000E+000
           41.000000000000000E+000 42.000000000000000E+000
           51.000000000000000E+000 52.000000000000000E+000
           61.000000000000000E+000 62.000000000000000E+000

            In the above example header on the first line, you can specify either real or complex or pattern for
           the numerical type.
       Example printing to standard output:
               errval = rsb_file_vec_save(NULL, typecode, X, nrA);
               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error printing vector!\n");
                       goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_info</b>, <b>rsb_mtx_get_info_str</b>, <b>rsb_file_mtx_save</b>, <b>rsb_file_vec_load</b>, <b>rsb_file_mtx_load</b>
   <b>rsb_err_t</b> <b>rsb_lib_exit</b> <b>(struct</b> <b>rsb_initopts</b> <b>*</b> <b>iop)</b>
       Finalize librsb.
       <b>rsb_lib_exit</b> should be called after having freed all matrices.
       If  not  all  of  the  data  structures were properly deallocated before, this function may still attempt
       finalizing the library and return the <b>RSB_ERR_MEMORY_LEAK</b> error  code  (this  depends  on  the  --enable-
       allocator-wrapper  configure  time option). Any allocated memory will be lost (librsb does not keep track
       of allocated matrices).
       Internal library state will be cleared. After this call, it is legal to initialize the library again,  by
       calling <b>rsb_lib_init()</b>.
       On  an  error,  the  library  state  may  be inconsistent, so it is advisable to either terminate program
       execution (rather than forcing a new initialization with <b>rsb_lib_init()</b>).
       Parameter iop is reserved for future use; for now it is safe to pass <b>RSB_NULL_EXIT_OPTIONS</b>.
       It should be safe to call <b>rsb_lib_exit()</b> more than once.

       <b>Parameters</b>
           <u>iop</u> A pointer to a  <b>rsb_initopts</b>  structure  with  library  options.  It  may  be  NULL  (or  better,
           <b>RSB_NULL_INIT_OPTIONS</b>/<b>RSB_NULL_EXIT_OPTIONS</b>) for specifying default options.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       An example snippet declaring an error variable accumulator at program's beginning:
               rsb_err_t errval = RSB_ERR_NO_ERROR;

        and finalizing the library at program's end:
               if((errval = rsb_lib_exit(RSB_NULL_EXIT_OPTIONS))
                               != RSB_ERR_NO_ERROR)
               {
                       printf("Error finalizing the library!\n");
                       goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_lib_init</b>, <b>rsb_lib_set_opt_str</b>, <b>rsb_lib_reinit</b>, <b>rsb_lib_exit</b>, <b>rsb_lib_get_opt</b>, <b>rsb_lib_set_opt</b>, <b>or</b>
           (deprecated)         <b>macros</b>         <b>RSB_REINIT_SINGLE_VALUE_GET</b>,         <b>RSB_REINIT_SINGLE_VALUE_SET</b>,
           <b>RSB_REINIT_SINGLE_VALUE</b>, <b>RSB_REINIT_SINGLE_VALUE_C_IOP</b>..
   <b>rsb_err_t</b> <b>rsb_lib_get_opt</b> <b>(enum</b> <b>rsb_opt_t</b> <b>iof,</b> <b>void</b> <b>*</b> <b>iop)</b>
       Gets value of a library option.
       A  value  specified by the request flag iof will be fetched from the library internal state and *iop will
       be updated accordingly.
       <b>Parameters</b>
           <u>iof</u> library options flags. See <b>rsb_opt_t</b> for a list of valid options.
           <u>iop</u> library options value output pointer (pointed location will be updated).
       <b>See</b> <b>also</b>
           <b>RSB_REINIT_SINGLE_VALUE_GET</b>,          <b>RSB_REINIT_SINGLE_VALUE_SET</b>,           <b>RSB_REINIT_SINGLE_VALUE</b>,
           <b>RSB_REINIT_SINGLE_VALUE_C_IOP</b>
           <b>rsb_lib_init</b>, <b>rsb_lib_set_opt_str</b>, <b>rsb_lib_reinit</b>, <b>rsb_lib_exit</b>, <b>rsb_lib_get_opt</b>, <b>rsb_lib_set_opt</b>, <b>or</b>
           (deprecated)         <b>macros</b>         <b>RSB_REINIT_SINGLE_VALUE_GET</b>,         <b>RSB_REINIT_SINGLE_VALUE_SET</b>,
           <b>RSB_REINIT_SINGLE_VALUE</b>, <b>RSB_REINIT_SINGLE_VALUE_C_IOP</b>..
   <b>rsb_err_t</b> <b>rsb_lib_init</b> <b>(struct</b> <b>rsb_initopts</b> <b>*</b> <b>iop)</b>
       This is the library initialization function.
       It must be called only once before using any other library function.
       It is allowed to call it again after <b>rsb_lib_exit()</b>.
       To fine-tune the library behaviour, one may specify a number of options via the iop parameter.
       Options may be specified also after <b>rsb_lib_init()</b> by calling <b>rsb_lib_reinit()</b>.
       One may call <b>RSB_REINIT_SINGLE_VALUE_GET</b> with flag <b>RSB_IO_WANT_IS_INITIALIZED_MARKER</b>  to  verify  whether
       the library has been initialized or not.
       If  the RSB_NUM_THREADS environment variable is set, <b>rsb_lib_init()</b> uses it and sets the number of active
       threads, thus overriding what detected by the OpenMP runtime (e.g. OMP_NUM_THREADS).
       <b>Parameters</b>
           <u>iop</u> A pointer to a  <b>rsb_initopts</b>  structure  with  library  options.  It  may  be  NULL  (or  better,
           <b>RSB_NULL_INIT_OPTIONS</b>/<b>RSB_NULL_EXIT_OPTIONS</b>) for specifying default options.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       An example snippet declaring an error variable accumulator at program's beginning:
               rsb_err_t errval = RSB_ERR_NO_ERROR;

        and initializing the library soon thereafter:
               if((errval = rsb_lib_init(RSB_NULL_INIT_OPTIONS)) !=
                               RSB_ERR_NO_ERROR)
               {
                       printf("Error initializing the library!\n");
                       goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_lib_init</b>, <b>rsb_lib_set_opt_str</b>, <b>rsb_lib_reinit</b>, <b>rsb_lib_exit</b>, <b>rsb_lib_get_opt</b>, <b>rsb_lib_set_opt</b>, <b>or</b>
           (deprecated)         <b>macros</b>         <b>RSB_REINIT_SINGLE_VALUE_GET</b>,         <b>RSB_REINIT_SINGLE_VALUE_SET</b>,
           <b>RSB_REINIT_SINGLE_VALUE</b>, <b>RSB_REINIT_SINGLE_VALUE_C_IOP</b>..
   <b>rsb_err_t</b> <b>rsb_lib_reinit</b> <b>(struct</b> <b>rsb_initopts</b> <b>*</b> <b>iop)</b>
       Changes  the  library  operation  options  which  were  set at initialization time either by a user or as
       defaults.
       Not all options may be supported, depending on build time library settings.
       If an unsupported option was specified, an appropriate error (e.g.:  <b>RSB_ERR_UNSUPPORTED_OPERATION</b>)  will
       be returned.

       On  the  first  error,  option  processing  is  interrupted  and  the  remaining options (if any) are not
       processed.
       Program execution may continue safely even if an error code is returned (that is, library  status  should
       be consistent).

       <b>Parameters</b>
           <u>iop</u>  A  pointer  to  a  <b>rsb_initopts</b>  structure  with  library  options.  It  may be NULL (or better,
           <b>RSB_NULL_INIT_OPTIONS</b>/<b>RSB_NULL_EXIT_OPTIONS</b>) for specifying default options.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
               rsb_err_t errval = RSB_ERR_NO_ERROR;
               struct rsb_initopts io;

               rsb_int_t ione={1};
               enum rsb_opt_t keys[]={RSB_IO_WANT_EXTRA_VERBOSE_INTERFACE};
               void*values[]={&amp;ione};
               io.action=RSB_IO_SPECIFIER_SET;
               io.keys=keys;
               io.values=values;
               io.n_pairs=1;

               if((errval = rsb_lib_init(RSB_NULL_INIT_OPTIONS))
                               != RSB_ERR_NO_ERROR) goto err;

               // won't print anything
               if((errval = rsb_lib_reinit(&amp;io))
                               != RSB_ERR_NO_ERROR) goto err;

               // may print verbose message (depends on configure)
               if((errval = rsb_lib_reinit(NULL))
                               != RSB_ERR_NO_ERROR) goto err;

               // may print verbose message (depends on configure)
               if((errval = rsb_lib_set_opt_str(
                       "RSB_IO_WANT_EXTRA_VERBOSE_INTERFACE","0"))
                               != RSB_ERR_NO_ERROR) goto err;

               // won't print anything anymore
               if((errval = rsb_lib_exit(&amp;io))
                               != RSB_ERR_NO_ERROR) goto err;
       <b>See</b> <b>also</b>
           <b>rsb_lib_init</b>, <b>rsb_lib_set_opt_str</b>, <b>rsb_lib_reinit</b>, <b>rsb_lib_exit</b>, <b>rsb_lib_get_opt</b>, <b>rsb_lib_set_opt</b>, <b>or</b>
           (deprecated)         <b>macros</b>         <b>RSB_REINIT_SINGLE_VALUE_GET</b>,         <b>RSB_REINIT_SINGLE_VALUE_SET</b>,
           <b>RSB_REINIT_SINGLE_VALUE</b>, <b>RSB_REINIT_SINGLE_VALUE_C_IOP</b>..
   <b>rsb_err_t</b> <b>rsb_lib_set_opt</b> <b>(enum</b> <b>rsb_opt_t</b> <b>iof,</b> <b>const</b> <b>void</b> <b>*</b> <b>iop)</b>
       Sets value of a library option.
       A value specified by the request flag iof will be fetched from *iop  and  will  be  used  to  update  the
       selected option in the library internal state.
       <b>Parameters</b>
           <u>iof</u> library options flags. See <b>rsb_opt_t</b> for a list of valid options.
           <u>iop</u> library options value output pointer (pointed location will be updated).
       Example snip:
                       rsb_int_t evi=1;

                       /* Setting a single optional library parameter. */
                       errval = rsb_lib_set_opt(
                               RSB_IO_WANT_EXTRA_VERBOSE_INTERFACE, &amp;evi);
                       if(errval != RSB_ERR_NO_ERROR)
                       {
                              /*! [Copy error message to string] */
                               char errbuf[256];
                               rsb_strerror_r(errval,&amp;errbuf[0],sizeof(errbuf));
                               printf("Failed setting the"
                               " RSB_IO_WANT_EXTRA_VERBOSE_INTERFACE"
                               " library option (reason string:\n%s).\n",errbuf);
                              /*! [Copy error message to string] */
                               if(errval&amp;RSB_ERRS_UNSUPPORTED_FEATURES)
                               {
                                 printf("This error may be safely ignored.\n");
                               }
                               else
                               {
                                 printf("Some unexpected error occurred!\n");
                                 goto err;
                               }
                       }
                       else
                       {
                               printf("Setting back the "
                                       "RSB_IO_WANT_EXTRA_VERBOSE_INTERFACE"
                                       " library option.\n");
                               evi = 0;
                               errval = rsb_lib_set_opt(RSB_IO_WANT_EXTRA_VERBOSE_INTERFACE,
                                               &amp;evi);
                               errval = RSB_ERR_NO_ERROR;
                       }

       <b>See</b> <b>also</b>
           <b>RSB_REINIT_SINGLE_VALUE_GET</b>,           <b>RSB_REINIT_SINGLE_VALUE_SET</b>,          <b>RSB_REINIT_SINGLE_VALUE</b>,
           <b>RSB_REINIT_SINGLE_VALUE_C_IOP</b>
           <b>rsb_lib_init</b>, <b>rsb_lib_set_opt_str</b>, <b>rsb_lib_reinit</b>, <b>rsb_lib_exit</b>, <b>rsb_lib_get_opt</b>, <b>rsb_lib_set_opt</b>, <b>or</b>
           (deprecated)         <b>macros</b>         <b>RSB_REINIT_SINGLE_VALUE_GET</b>,         <b>RSB_REINIT_SINGLE_VALUE_SET</b>,
           <b>RSB_REINIT_SINGLE_VALUE</b>, <b>RSB_REINIT_SINGLE_VALUE_C_IOP</b>..
   <b>rsb_err_t</b> <b>rsb_lib_set_opt_str</b> <b>(const</b> <b>rsb_char_t</b> <b>*</b> <b>opnp,</b> <b>const</b> <b>rsb_char_t</b> <b>*</b> <b>opvp)</b>
       Specifies individual library options in order to fine-tune the library behaviour.
       Both  the  option  name  and  the  value  shall  be expressed as strings, identical to their preprocessor
       identifiers (see <b>rsb_opt_t</b> ). The opnp string will be translated internally to the corresponding  request
       flag values, and the passed value will be parsed out of the opvp string.

       <b>Parameters</b>
           <u>opnp</u> A pointer to a library option input name string (may not be NULL).
           <u>opvp</u> A pointer to a library option input value string (may not be NULL).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
               rsb_err_t errval = RSB_ERR_NO_ERROR;
               struct rsb_initopts io;

               rsb_int_t ione={1};
               enum rsb_opt_t keys[]={RSB_IO_WANT_EXTRA_VERBOSE_INTERFACE};
               void*values[]={&amp;ione};
               io.action=RSB_IO_SPECIFIER_SET;
               io.keys=keys;
               io.values=values;
               io.n_pairs=1;

               if((errval = rsb_lib_init(RSB_NULL_INIT_OPTIONS))
                               != RSB_ERR_NO_ERROR) goto err;

               // won't print anything
               if((errval = rsb_lib_reinit(&amp;io))
                               != RSB_ERR_NO_ERROR) goto err;

               // may print verbose message (depends on configure)
               if((errval = rsb_lib_reinit(NULL))
                               != RSB_ERR_NO_ERROR) goto err;

               // may print verbose message (depends on configure)
               if((errval = rsb_lib_set_opt_str(
                       "RSB_IO_WANT_EXTRA_VERBOSE_INTERFACE","0"))
                               != RSB_ERR_NO_ERROR) goto err;

               // won't print anything anymore
               if((errval = rsb_lib_exit(&amp;io))
                               != RSB_ERR_NO_ERROR) goto err;
       <b>See</b> <b>also</b>
           <b>rsb_lib_init</b>, <b>rsb_lib_set_opt_str</b>, <b>rsb_lib_reinit</b>, <b>rsb_lib_exit</b>, <b>rsb_lib_get_opt</b>, <b>rsb_lib_set_opt</b>, <b>or</b>
           (deprecated)         <b>macros</b>         <b>RSB_REINIT_SINGLE_VALUE_GET</b>,         <b>RSB_REINIT_SINGLE_VALUE_SET</b>,
           <b>RSB_REINIT_SINGLE_VALUE</b>, <b>RSB_REINIT_SINGLE_VALUE_C_IOP</b>..
   <b>rsb_err_t</b>  <b>rsb_mtx_add_to_dense</b>  <b>(const</b>  <b>void</b>  <b>*</b>  <b>alphap,</b>  <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>rsb_nnz_idx_t</b> <b>ldB,</b>
       <b>rsb_nnz_idx_t</b> <b>nrB,</b> <b>rsb_nnz_idx_t</b> <b>ncB,</b> <b>rsb_bool_t</b> <b>rowmajorB,</b> <b>void</b> <b>*</b> <b>Bp)</b>
       Dense matrix B is updated by adding scaled sparse matrix ${A}$ to it: $B &lt;- B + alpha {A} $
       <b>Parameters</b>
           <u>alphap</u> Optional pointer (if NULL, will default to 1) to a  numerical  value  (of  the  same  type  as
           matrix).
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>ldB</u> Leading dimension of Bp array.
           <u>nrB,ncB</u> The number of rows and columns for the dense matrix $B$.
           <u>rowmajorB</u>  <b>RSB_BOOL_TRUE</b> if the dense matrix $B$ is considered stored as row major, or <b>RSB_BOOL_FALSE</b>
           if as column major.
           <u>Bp</u> Array representing the dense matrix $B$.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       Example snip:
               const rsb_nnz_idx_t ldB = 4, nrB = 3, ncB = 3;
               const rsb_bool_t rowmajorB = RSB_BOOL_TRUE;
               RSB_DEFAULT_TYPE Bp[ /*ldB*nrB*/ ] = {
                       -1, -1, -1, -1,
                       -1, -1, -1, -1,
                       -1, -1, -1, -1
               };
               RSB_DEFAULT_TYPE *alphap = NULL;

               errval = rsb_mtx_add_to_dense(alphap, mtxAp, ldB,
                        nrB, ncB, rowmajorB, Bp);
               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_mtx_add_to_dense!\n");
                       goto err;
               }

       <b>Note</b>
           Please  note that it suffices to 'transpose' Bp's description parameters to get $A$ transposed summed
           in.
           Symmetry is currently not expanded.
           Threaded, for large enough matrices.
       <b>See</b> <b>also</b>
           <b>rsb_spmsp_to_dense</b>, <b>rsb_sppsp</b>, <b>rsb_spmsp</b>, <b>rsb_mtx_add_to_dense</b>
   <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>rsb_mtx_alloc_from_coo_begin</b> <b>(rsb_nnz_idx_t</b> <b>nnzA,</b> <b>rsb_type_t</b> <b>typecode,</b> <b>rsb_coo_idx_t</b>  <b>nrA,</b>
       <b>rsb_coo_idx_t</b> <b>ncA,</b> <b>rsb_flags_t</b> <b>flagsA,</b> <b>rsb_err_t</b> <b>*</b> <b>errvalp)</b>
       Creates  an empty matrix structure in assembly state. The user then populates it using <b>rsb_mtx_set_vals()</b>
       repeatedly; then assembles it with <b>rsb_mtx_alloc_from_coo_end()</b>.
       <b>Parameters</b>
           <u>nnzA</u> A rough estimate of the number of nonzeroes matrix $A$ will host  (used  for  optimizing  arrays
           allocation). If you do not know yet, you can specify zero.
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>nrA,ncA</u> The number of rows and columns of the sparse matrix $A$.
           <u>flagsA</u> A valid combination of index conversion and matrix storage flags and other meaningful flags.
            The encouraged base choice here is <b>RSB_FLAG_DEFAULT_RSB_MATRIX_FLAGS</b>. If Fortran (1  based)  indices
           are  being  used  for  the  IA, JA arrays, then the <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b> flag should be
           added. If symmetric storage is desired, then <b>RSB_FLAG_SYMMETRIC</b> (or <b>RSB_FLAG_HERMITIAN</b>, for Hermitian
           matrices) is necessary, in combination with either <b>RSB_FLAG_LOWER</b> or <b>RSB_FLAG_UPPER</b>. If you intend to
           use this matrix for triangular solution (e.g.: <b>rsb_spsv()</b>/<b>rsb_spsm()</b>), it needs to be triangular  and
           specified   with   either   <b>RSB_FLAG_LOWER_TRIANGULAR</b>  or  <b>RSB_FLAG_UPPER_TRIANGULAR</b>,  and  not  have
           <b>RSB_FLAG_LOWER_SYMMETRIC</b> or <b>RSB_FLAG_LOWER_HERMITIAN</b>. Nonzeroes  non  complying  with  the  specified
           flags will be ignored. If a matrix is both <b>RSB_FLAG_LOWER_TRIANGULAR</b> and <b>RSB_FLAG_UPPER_TRIANGULAR</b> at
           the  same  time,  then  it's  diagonal,  for  which  shorthand:  <b>RSB_FLAG_DIAGONAL</b>  can  be  used. If
           <b>RSB_FLAG_UNIT_DIAG_IMPLICIT</b> is present, diagonal entries will be not represented but  assumed  to  be
           unitary.  If  <b>RSB_FLAG_DUPLICATES_SUM</b>  is  present,  duplicate  entries  will  be summed together. If
           <b>RSB_FLAG_DISCARD_ZEROS</b> is present, zeroes will be discarded.
           <u>errvalp</u> An optional (can be NULL) pointer to <b>rsb_err_t</b> where the error status will be written to.
       <b>Returns</b>
           Pointer to a rsb_mtx_t matrix structure in assembly state, or NULL (on error).
       <b>Warning</b>
           This function has not been thoroughly tested.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_alloc_from_coo_const</b>,    <b>rsb_mtx_alloc_from_coo_inplace</b>,     <b>rsb_mtx_free</b>,     <b>rsb_mtx_clone</b>,
           <b>rsb_mtx_alloc_from_csr_const</b>,      <b>rsb_mtx_alloc_from_csc_const</b>,      <b>rsb_mtx_alloc_from_csr_inplace</b>,
           <b>rsb_mtx_switch_to_csr</b>, <b>rsb_mtx_alloc_from_coo_begin</b>, <b>rsb_mtx_alloc_from_coo_end</b>
   <b>struct</b>  <b>rsb_mtx_t</b>  <b>*</b>  <b>rsb_mtx_alloc_from_coo_const</b>  <b>(const</b>  <b>void</b>  <b>*</b>  <b>VA,</b>  <b>const</b>  <b>rsb_coo_idx_t</b>  <b>*</b>  <b>IA,</b>  <b>const</b>
       <b>rsb_coo_idx_t</b>  <b>*</b>  <b>JA,</b>  <b>rsb_nnz_idx_t</b>  <b>nnzA,</b>  <b>rsb_type_t</b>  <b>typecode,</b>  <b>rsb_coo_idx_t</b> <b>nrA,</b> <b>rsb_coo_idx_t</b> <b>ncA,</b>
       <b>rsb_blk_idx_t</b> <b>brA,</b> <b>rsb_blk_idx_t</b> <b>bcA,</b> <b>rsb_flags_t</b> <b>flagsA,</b> <b>rsb_err_t</b> <b>*</b> <b>errvalp)</b>
       Given as input COO arrays VA,IA,JA, allocates and assembles an RSB matrix using separate arrays.
       <b>Parameters</b>
           <u>VA,IA,JA</u> Input numerical values (VA) array; row (IA) and column (JA) input indices arrays.
           <u>nnzA</u> The number of nonzeroes in the input arrays representing matrix $A$.
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>nrA,ncA</u>  The  number  of  rows and columns of the sparse matrix $A$. If any of nrA or ncA is zero, it
           will be detected on the basis of the IA and JA arrays and flagsA.
           <u>brA,bcA</u> Blocking parameters: brA should be set to 1 or  <b>RSB_DEFAULT_ROW_BLOCKING</b>  (currently  unused,
           reserved  for  future  use);  bcA  should  be set to 1 or <b>RSB_DEFAULT_ROW_BLOCKING</b> (currently unused,
           reserved for future use).
           <u>flagsA</u> A valid combination of index conversion and matrix storage flags and other meaningful flags.
            The encouraged base choice here is <b>RSB_FLAG_DEFAULT_RSB_MATRIX_FLAGS</b>. If Fortran (1  based)  indices
           are  being  used  for  the  IA, JA arrays, then the <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b> flag should be
           added. If symmetric storage is desired, then <b>RSB_FLAG_SYMMETRIC</b> (or <b>RSB_FLAG_HERMITIAN</b>, for Hermitian
           matrices) is necessary, in combination with either <b>RSB_FLAG_LOWER</b> or <b>RSB_FLAG_UPPER</b>. If you intend to
           use this matrix for triangular solution (e.g.: <b>rsb_spsv()</b>/<b>rsb_spsm()</b>), it needs to be triangular  and
           specified   with   either   <b>RSB_FLAG_LOWER_TRIANGULAR</b>  or  <b>RSB_FLAG_UPPER_TRIANGULAR</b>,  and  not  have
           <b>RSB_FLAG_LOWER_SYMMETRIC</b> or <b>RSB_FLAG_LOWER_HERMITIAN</b>. Nonzeroes  non  complying  with  the  specified
           flags will be ignored. If a matrix is both <b>RSB_FLAG_LOWER_TRIANGULAR</b> and <b>RSB_FLAG_UPPER_TRIANGULAR</b> at
           the  same  time,  then  it's  diagonal,  for  which  shorthand:  <b>RSB_FLAG_DIAGONAL</b>  can  be  used. If
           <b>RSB_FLAG_UNIT_DIAG_IMPLICIT</b> is present, diagonal entries will be not represented but  assumed  to  be
           unitary.  If  <b>RSB_FLAG_DUPLICATES_SUM</b>  is  present,  duplicate  entries  will  be summed together. If
           <b>RSB_FLAG_DISCARD_ZEROS</b> is present, zeroes will be discarded.
           <u>errvalp</u> An optional (can be NULL) pointer to <b>rsb_err_t</b> where the error status will be written to.
       <b>Returns</b>
           On success, a valid pointer (struct rsb_mtx_t*) to the newly allocated matrix  structure;  on  error,
           NULL.
       Example snip:
               mtxAp = rsb_mtx_alloc_from_coo_const(
                               VA,IA,JA,nnzA,typecode,nrA,ncA,
                               brA,bcA,RSB_FLAG_NOFLAGS,NULL);
               if(!mtxAp)
               {
                       return EXIT_FAILURE;
               }

        And another, with duplicate sum flags:
               mtxAp = rsb_mtx_alloc_from_coo_const(
                       VA,IA,JA,nnzA,typecode,nrA,ncA,brA,bcA,
                       RSB_FLAG_NOFLAGS    /* default format will be chosen */
                       |RSB_FLAG_DUPLICATES_SUM/* duplicates will be summed */
                               ,&amp;errval);
               if((!mtxAp) || (errval != RSB_ERR_NO_ERROR))
               {
                       printf("Error while allocating the matrix!\n");
                       goto err;
               }

        And yet another, allocating a triangular matrix:
               mtxAp = rsb_mtx_alloc_from_coo_const(
                       VA,IA,JA,nnzA,typecode,nrA,ncA,brA,bcA,
                       RSB_FLAG_DEFAULT_RSB_MATRIX_FLAGS /* force rsb */
                       | RSB_FLAG_DUPLICATES_SUM/* sum dups */
                       | RSB_FLAG_UNIT_DIAG_IMPLICIT/* ask diagonal implicit */
                       | RSB_FLAG_TRIANGULAR /* need triangle for spsv */
                       , &amp;errval);
               if((!mtxAp) || (errval != RSB_ERR_NO_ERROR))
               {
                       printf("Error while allocating the matrix!\n");
                       goto err;
               }
               printf("Correctly allocated a matrix with %ld nonzeroes.\n",
                       (long int)nnzA);

       <b>See</b> <b>also</b>
           <b>rsb_mtx_alloc_from_coo_const</b>,     <b>rsb_mtx_alloc_from_coo_inplace</b>,     <b>rsb_mtx_free</b>,    <b>rsb_mtx_clone</b>,
           <b>rsb_mtx_alloc_from_csr_const</b>,      <b>rsb_mtx_alloc_from_csc_const</b>,      <b>rsb_mtx_alloc_from_csr_inplace</b>,
           <b>rsb_mtx_switch_to_csr</b>, <b>rsb_mtx_alloc_from_coo_begin</b>, <b>rsb_mtx_alloc_from_coo_end</b>
   <b>rsb_err_t</b> <b>rsb_mtx_alloc_from_coo_end</b> <b>(struct</b> <b>rsb_mtx_t</b> <b>**</b> <b>mtxApp)</b>
       Assembles  RSB  arrays  for  a  matrix  in  build  state  created with <b>rsb_mtx_alloc_from_coo_begin()</b> and
       populated with <b>rsb_mtx_set_vals()</b>.
       After assembly, any operation on the matrix is allowed.
       <b>Parameters</b>
           <u>mtxApp</u> rsb_mtx_t pointer to an unassembled matrix address.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       <b>Warning</b>
           This function has not been thoroughly tested.
       <b>Note</b>
           Note  that  the  memory  location  of  the matrix will be changed by this call, and the (old) *mtxApp
           address value will be not valid anymore.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_alloc_from_coo_const</b>,    <b>rsb_mtx_alloc_from_coo_inplace</b>,     <b>rsb_mtx_free</b>,     <b>rsb_mtx_clone</b>,
           <b>rsb_mtx_alloc_from_csr_const</b>,      <b>rsb_mtx_alloc_from_csc_const</b>,      <b>rsb_mtx_alloc_from_csr_inplace</b>,
           <b>rsb_mtx_switch_to_csr</b>, <b>rsb_mtx_alloc_from_coo_begin</b>, <b>rsb_mtx_alloc_from_coo_end</b>
   <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>rsb_mtx_alloc_from_coo_inplace</b> <b>(void</b>  <b>*</b>  <b>VA,</b>  <b>rsb_coo_idx_t</b>  <b>*</b>  <b>IA,</b>  <b>rsb_coo_idx_t</b>  <b>*</b>  <b>JA,</b>
       <b>rsb_nnz_idx_t</b>  <b>nnzA,</b>  <b>rsb_type_t</b>  <b>typecode,</b>  <b>rsb_coo_idx_t</b>  <b>nrA,</b>  <b>rsb_coo_idx_t</b>  <b>ncA,</b>  <b>rsb_blk_idx_t</b> <b>brA,</b>
       <b>rsb_blk_idx_t</b> <b>bcA,</b> <b>rsb_flags_t</b> <b>flagsA,</b> <b>rsb_err_t</b> <b>*</b> <b>errvalp)</b>
       Given as input COO arrays VA,IA,JA, allocates and assembles an RSB matrix reusing input arrays.
       Assumes all three VA,IA,JA arrays are at least max(nnzA,nrA+1,ncA+1) sized. The user is expected  NOT  to
       use  these  arrays  until  the matrix has been destroyed with <b>rsb_mtx_free()</b>. Then, it is possible to use
       these arrays again.
       <b>Parameters</b>
           <u>VA,IA,JA</u> Input/output numerical values array (VA); row (IA) and column (JA) indices arrays.
           <u>nnzA</u> The number of nonzeroes in the input arrays representing matrix $A$.
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>nrA,ncA</u> The number of rows and columns of the sparse matrix $A$.
           <u>brA,bcA</u>  Blocking  parameters:  brA should be set to 1 or <b>RSB_DEFAULT_ROW_BLOCKING</b> (currently unused,
           reserved for future use); bcA should be set  to  1  or  <b>RSB_DEFAULT_ROW_BLOCKING</b>  (currently  unused,
           reserved for future use).
           <u>flagsA</u> A valid combination of index conversion and matrix storage flags and other meaningful flags.
            The  encouraged  base choice here is <b>RSB_FLAG_DEFAULT_RSB_MATRIX_FLAGS</b>. If Fortran (1 based) indices
           are being used for the IA, JA arrays, then  the  <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b>  flag  should  be
           added. If symmetric storage is desired, then <b>RSB_FLAG_SYMMETRIC</b> (or <b>RSB_FLAG_HERMITIAN</b>, for Hermitian
           matrices) is necessary, in combination with either <b>RSB_FLAG_LOWER</b> or <b>RSB_FLAG_UPPER</b>. If you intend to
           use  this matrix for triangular solution (e.g.: <b>rsb_spsv()</b>/<b>rsb_spsm()</b>), it needs to be triangular and
           specified  with  either  <b>RSB_FLAG_LOWER_TRIANGULAR</b>  or  <b>RSB_FLAG_UPPER_TRIANGULAR</b>,   and   not   have
           <b>RSB_FLAG_LOWER_SYMMETRIC</b>  or  <b>RSB_FLAG_LOWER_HERMITIAN</b>.  Nonzeroes  non  complying with the specified
           flags will be ignored. If a matrix is both <b>RSB_FLAG_LOWER_TRIANGULAR</b> and <b>RSB_FLAG_UPPER_TRIANGULAR</b> at
           the same  time,  then  it's  diagonal,  for  which  shorthand:  <b>RSB_FLAG_DIAGONAL</b>  can  be  used.  If
           <b>RSB_FLAG_UNIT_DIAG_IMPLICIT</b>  is  present,  diagonal entries will be not represented but assumed to be
           unitary. If <b>RSB_FLAG_DUPLICATES_SUM</b> is  present,  duplicate  entries  will  be  summed  together.  If
           <b>RSB_FLAG_DISCARD_ZEROS</b> is present, zeroes will be discarded.
           <u>errvalp</u> An optional (can be NULL) pointer to <b>rsb_err_t</b> where the error status will be written to.
       <b>Returns</b>
           On  success,  a  valid pointer (struct rsb_mtx_t*) to the newly allocated matrix structure; on error,
           NULL.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_alloc_from_coo_const</b>,    <b>rsb_mtx_alloc_from_coo_inplace</b>,     <b>rsb_mtx_free</b>,     <b>rsb_mtx_clone</b>,
           <b>rsb_mtx_alloc_from_csr_const</b>,      <b>rsb_mtx_alloc_from_csc_const</b>,      <b>rsb_mtx_alloc_from_csr_inplace</b>,
           <b>rsb_mtx_switch_to_csr</b>, <b>rsb_mtx_alloc_from_coo_begin</b>, <b>rsb_mtx_alloc_from_coo_end</b>
   <b>struct</b>  <b>rsb_mtx_t</b>  <b>*</b>  <b>rsb_mtx_alloc_from_csc_const</b>  <b>(const</b>  <b>void</b>  <b>*</b>  <b>VA,</b>  <b>const</b>  <b>rsb_coo_idx_t</b>  <b>*</b>  <b>IA,</b>  <b>const</b>
       <b>rsb_coo_idx_t</b>  <b>*</b>  <b>CP,</b>  <b>rsb_nnz_idx_t</b>  <b>nnzA,</b>  <b>rsb_type_t</b>  <b>typecode,</b>  <b>rsb_coo_idx_t</b> <b>nrA,</b> <b>rsb_coo_idx_t</b> <b>ncA,</b>
       <b>rsb_blk_idx_t</b> <b>brA,</b> <b>rsb_blk_idx_t</b> <b>bcA,</b> <b>rsb_flags_t</b> <b>flagsA,</b> <b>rsb_err_t</b> <b>*</b> <b>errvalp)</b>
       Given input read only CSC format arrays, allocates and  assembles  an  RSB  matrix  (stored  in  separate
       arrays).
       <b>Parameters</b>
           <u>VA,IA,CP</u> Input numerical values (VA) array, input row indices (IA) and compressed column (CP) indices
           arrays.
           <u>nnzA</u> The number of nonzeroes in the input arrays representing matrix $A$.
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>nrA,ncA</u> The number of rows and columns of the sparse matrix $A$.
           <u>brA,bcA</u> Blocking parameters: brA should be set to 1 or  <b>RSB_DEFAULT_ROW_BLOCKING</b>  (currently  unused,
           reserved  for  future  use);  bcA  should  be set to 1 or <b>RSB_DEFAULT_ROW_BLOCKING</b> (currently unused,
           reserved for future use).
           <u>flagsA</u> A valid combination of index conversion and matrix storage flags and other meaningful flags.
            The encouraged base choice here is <b>RSB_FLAG_DEFAULT_RSB_MATRIX_FLAGS</b>. If Fortran (1  based)  indices
           are  being  used  for  the  IA, JA arrays, then the <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b> flag should be
           added. If symmetric storage is desired, then <b>RSB_FLAG_SYMMETRIC</b> (or <b>RSB_FLAG_HERMITIAN</b>, for Hermitian
           matrices) is necessary, in combination with either <b>RSB_FLAG_LOWER</b> or <b>RSB_FLAG_UPPER</b>. If you intend to
           use this matrix for triangular solution (e.g.: <b>rsb_spsv()</b>/<b>rsb_spsm()</b>), it needs to be triangular  and
           specified   with   either   <b>RSB_FLAG_LOWER_TRIANGULAR</b>  or  <b>RSB_FLAG_UPPER_TRIANGULAR</b>,  and  not  have
           <b>RSB_FLAG_LOWER_SYMMETRIC</b> or <b>RSB_FLAG_LOWER_HERMITIAN</b>. Nonzeroes  non  complying  with  the  specified
           flags will be ignored. If a matrix is both <b>RSB_FLAG_LOWER_TRIANGULAR</b> and <b>RSB_FLAG_UPPER_TRIANGULAR</b> at
           the  same  time,  then  it's  diagonal,  for  which  shorthand:  <b>RSB_FLAG_DIAGONAL</b>  can  be  used. If
           <b>RSB_FLAG_UNIT_DIAG_IMPLICIT</b> is present, diagonal entries will be not represented but  assumed  to  be
           unitary.  If  <b>RSB_FLAG_DUPLICATES_SUM</b>  is  present,  duplicate  entries  will  be summed together. If
           <b>RSB_FLAG_DISCARD_ZEROS</b> is present, zeroes will be discarded.
           <u>errvalp</u> An optional (can be NULL) pointer to <b>rsb_err_t</b> where the error status will be written to.
       <b>Returns</b>
           On success, a valid pointer (struct rsb_mtx_t*) to the newly allocated matrix  structure;  on  error,
           NULL.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_alloc_from_coo_const</b>,     <b>rsb_mtx_alloc_from_coo_inplace</b>,     <b>rsb_mtx_free</b>,    <b>rsb_mtx_clone</b>,
           <b>rsb_mtx_alloc_from_csr_const</b>,      <b>rsb_mtx_alloc_from_csc_const</b>,      <b>rsb_mtx_alloc_from_csr_inplace</b>,
           <b>rsb_mtx_switch_to_csr</b>, <b>rsb_mtx_alloc_from_coo_begin</b>, <b>rsb_mtx_alloc_from_coo_end</b>
       Example:
               rsb_err_t errval = RSB_ERR_NO_ERROR;
               struct rsb_mtx_t *mtxAp = NULL;
               const rsb_blk_idx_t brA = RSB_DEFAULT_BLOCKING,
                                   bcA = RSB_DEFAULT_BLOCKING;
               const rsb_nnz_idx_t nnzA = 4;
               const rsb_coo_idx_t  nrA = 3;
               const rsb_coo_idx_t  ncA = 3;
               const rsb_coo_idx_t    IA[] = { 0, 2, 1, 2 };
               const rsb_coo_idx_t    CP[] = { 0, 2, 3, 4 };
               const RSB_DEFAULT_TYPE VA[] = { 11, 31, 22, 33 };
               const rsb_type_t typecode = RSB_NUMERICAL_TYPE_DEFAULT;

               if(rsb_lib_init(RSB_NULL_INIT_OPTIONS)!=RSB_ERR_NO_ERROR)
               {
                       return EXIT_FAILURE;
               }

               mtxAp = rsb_mtx_alloc_from_csc_const(
                               VA,IA,CP,nnzA,typecode,nrA,ncA,
                               brA,bcA,RSB_FLAG_NOFLAGS,NULL);
               if(!mtxAp)
               {
                       return EXIT_FAILURE;
               }

               rsb_file_mtx_save(mtxAp, NULL);

   <b>struct</b>  <b>rsb_mtx_t</b>  <b>*</b>  <b>rsb_mtx_alloc_from_csr_const</b>  <b>(const</b>  <b>void</b>  <b>*</b>  <b>VA,</b>  <b>const</b>  <b>rsb_coo_idx_t</b>  <b>*</b>  <b>RP,</b>  <b>const</b>
       <b>rsb_coo_idx_t</b> <b>*</b> <b>JA,</b> <b>rsb_nnz_idx_t</b>  <b>nnzA,</b>  <b>rsb_type_t</b>  <b>typecode,</b>  <b>rsb_coo_idx_t</b>  <b>nrA,</b>  <b>rsb_coo_idx_t</b>  <b>ncA,</b>
       <b>rsb_blk_idx_t</b> <b>brA,</b> <b>rsb_blk_idx_t</b> <b>bcA,</b> <b>rsb_flags_t</b> <b>flagsA,</b> <b>rsb_err_t</b> <b>*</b> <b>errvalp)</b>
       Given  input  read  only  CSR  format  arrays,  allocates and assembles an RSB matrix (stored in separate
       arrays).
       <b>Parameters</b>
           <u>VA,RP,JA</u> Input numerical values (VA) array; compressed  rows  (RP)  and  column  (JA)  input  indices
           arrays.
           <u>nnzA</u> The number of nonzeroes in the input arrays representing matrix $A$.
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>nrA,ncA</u> The number of rows and columns of the sparse matrix $A$.
           <u>brA,bcA</u> Blocking parameters: brA should be set to 1 or  <b>RSB_DEFAULT_ROW_BLOCKING</b>  (currently  unused,
           reserved  for  future  use);  bcA  should  be set to 1 or <b>RSB_DEFAULT_ROW_BLOCKING</b> (currently unused,
           reserved for future use).
           <u>flagsA</u> A valid combination of index conversion and matrix storage flags and other meaningful flags.
            The encouraged base choice here is <b>RSB_FLAG_DEFAULT_RSB_MATRIX_FLAGS</b>. If Fortran (1  based)  indices
           are  being  used  for  the  IA, JA arrays, then the <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b> flag should be
           added. If symmetric storage is desired, then <b>RSB_FLAG_SYMMETRIC</b> (or <b>RSB_FLAG_HERMITIAN</b>, for Hermitian
           matrices) is necessary, in combination with either <b>RSB_FLAG_LOWER</b> or <b>RSB_FLAG_UPPER</b>. If you intend to
           use this matrix for triangular solution (e.g.: <b>rsb_spsv()</b>/<b>rsb_spsm()</b>), it needs to be triangular  and
           specified   with   either   <b>RSB_FLAG_LOWER_TRIANGULAR</b>  or  <b>RSB_FLAG_UPPER_TRIANGULAR</b>,  and  not  have
           <b>RSB_FLAG_LOWER_SYMMETRIC</b> or <b>RSB_FLAG_LOWER_HERMITIAN</b>. Nonzeroes  non  complying  with  the  specified
           flags will be ignored. If a matrix is both <b>RSB_FLAG_LOWER_TRIANGULAR</b> and <b>RSB_FLAG_UPPER_TRIANGULAR</b> at
           the  same  time,  then  it's  diagonal,  for  which  shorthand:  <b>RSB_FLAG_DIAGONAL</b>  can  be  used. If
           <b>RSB_FLAG_UNIT_DIAG_IMPLICIT</b> is present, diagonal entries will be not represented but  assumed  to  be
           unitary.  If  <b>RSB_FLAG_DUPLICATES_SUM</b>  is  present,  duplicate  entries  will  be summed together. If
           <b>RSB_FLAG_DISCARD_ZEROS</b> is present, zeroes will be discarded.
           <u>errvalp</u> An optional (can be NULL) pointer to <b>rsb_err_t</b> where the error status will be written to.
       <b>Returns</b>
           On success, a valid pointer (struct rsb_mtx_t*) to the newly allocated matrix  structure;  on  error,
           NULL.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_alloc_from_coo_const</b>,     <b>rsb_mtx_alloc_from_coo_inplace</b>,     <b>rsb_mtx_free</b>,    <b>rsb_mtx_clone</b>,
           <b>rsb_mtx_alloc_from_csr_const</b>,      <b>rsb_mtx_alloc_from_csc_const</b>,      <b>rsb_mtx_alloc_from_csr_inplace</b>,
           <b>rsb_mtx_switch_to_csr</b>, <b>rsb_mtx_alloc_from_coo_begin</b>, <b>rsb_mtx_alloc_from_coo_end</b>
   <b>struct</b>  <b>rsb_mtx_t</b>  <b>*</b>  <b>rsb_mtx_alloc_from_csr_inplace</b>  <b>(void</b>  <b>*</b>  <b>VA,</b>  <b>rsb_nnz_idx_t</b>  <b>*</b> <b>RP,</b> <b>rsb_coo_idx_t</b> <b>*</b> <b>JA,</b>
       <b>rsb_nnz_idx_t</b> <b>nnzA,</b>  <b>rsb_type_t</b>  <b>typecode,</b>  <b>rsb_coo_idx_t</b>  <b>nrA,</b>  <b>rsb_coo_idx_t</b>  <b>ncA,</b>  <b>rsb_blk_idx_t</b>  <b>brA,</b>
       <b>rsb_blk_idx_t</b> <b>bcA,</b> <b>rsb_flags_t</b> <b>flagsA,</b> <b>rsb_err_t</b> <b>*</b> <b>errvalp)</b>
       Given as input CSR arrays VA,RP,JA , allocates and assembles an RSB matrix reusing input arrays.
       Assumes  all  three VA,IA,JA arrays are at least max(nnzA,nrA+1,ncA+1) sized. The user is expected NOT to
       use these arrays until the matrix has been destroyed with <b>rsb_mtx_free()</b>. Then, it  is  possible  to  use
       these arrays again.
       <b>Parameters</b>
           <u>VA,RP,JA</u>  Input  numerical  values  (VA)  array;  compressed  rows (RP) and column (JA) input indices
           arrays. Will not be freed by <b>rsb_mtx_free()</b>.
           <u>nnzA</u> The number of nonzeroes in the input arrays representing matrix $A$.
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>nrA,ncA</u> The number of rows and columns of the sparse matrix $A$.
           <u>brA,bcA</u>  Blocking  parameters:  brA should be set to 1 or <b>RSB_DEFAULT_ROW_BLOCKING</b> (currently unused,
           reserved for future use); bcA should be set  to  1  or  <b>RSB_DEFAULT_ROW_BLOCKING</b>  (currently  unused,
           reserved for future use).
           <u>flagsA</u> A valid combination of index conversion and matrix storage flags and other meaningful flags.
            The  encouraged  base choice here is <b>RSB_FLAG_DEFAULT_RSB_MATRIX_FLAGS</b>. If Fortran (1 based) indices
           are being used for the IA, JA arrays, then  the  <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b>  flag  should  be
           added. If symmetric storage is desired, then <b>RSB_FLAG_SYMMETRIC</b> (or <b>RSB_FLAG_HERMITIAN</b>, for Hermitian
           matrices) is necessary, in combination with either <b>RSB_FLAG_LOWER</b> or <b>RSB_FLAG_UPPER</b>. If you intend to
           use  this matrix for triangular solution (e.g.: <b>rsb_spsv()</b>/<b>rsb_spsm()</b>), it needs to be triangular and
           specified  with  either  <b>RSB_FLAG_LOWER_TRIANGULAR</b>  or  <b>RSB_FLAG_UPPER_TRIANGULAR</b>,   and   not   have
           <b>RSB_FLAG_LOWER_SYMMETRIC</b>  or  <b>RSB_FLAG_LOWER_HERMITIAN</b>.  Nonzeroes  non  complying with the specified
           flags will be ignored. If a matrix is both <b>RSB_FLAG_LOWER_TRIANGULAR</b> and <b>RSB_FLAG_UPPER_TRIANGULAR</b> at
           the same  time,  then  it's  diagonal,  for  which  shorthand:  <b>RSB_FLAG_DIAGONAL</b>  can  be  used.  If
           <b>RSB_FLAG_UNIT_DIAG_IMPLICIT</b>  is  present,  diagonal entries will be not represented but assumed to be
           unitary. If <b>RSB_FLAG_DUPLICATES_SUM</b> is  present,  duplicate  entries  will  be  summed  together.  If
           <b>RSB_FLAG_DISCARD_ZEROS</b> is present, zeroes will be discarded.
           <u>errvalp</u> An optional (can be NULL) pointer to <b>rsb_err_t</b> where the error status will be written to.
       <b>Returns</b>
           On  success,  a  valid pointer (struct rsb_mtx_t*) to the newly allocated matrix structure; on error,
           NULL.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_alloc_from_coo_const</b>,    <b>rsb_mtx_alloc_from_coo_inplace</b>,     <b>rsb_mtx_free</b>,     <b>rsb_mtx_clone</b>,
           <b>rsb_mtx_alloc_from_csr_const</b>,      <b>rsb_mtx_alloc_from_csc_const</b>,      <b>rsb_mtx_alloc_from_csr_inplace</b>,
           <b>rsb_mtx_switch_to_csr</b>, <b>rsb_mtx_alloc_from_coo_begin</b>, <b>rsb_mtx_alloc_from_coo_end</b>
   <b>rsb_err_t</b> <b>rsb_mtx_clone</b> <b>(struct</b> <b>rsb_mtx_t</b> <b>**</b> <b>mtxBpp,</b> <b>rsb_type_t</b> <b>typecode,</b> <b>rsb_trans_t</b> <b>transA,</b>  <b>const</b>  <b>void</b>  <b>*</b>
       <b>alphap,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>rsb_flags_t</b> <b>flags)</b>
       This function clones a given matrix, allocating a fresh data structure or overwriting an existing one.
       Target  type (specified by typecode) can be different from that in the matrix. If alphap=NULL, the cloned
       matrix will not be scaled.
       This new structure will be completely separated and independent from the original one.
       Examples:
       // will clone the matrix exactly
       errval = rsb_mtx_clone(&amp;mtxBp,RSB_NUMERICAL_TYPE_SAME_TYPE,RSB_TRANSPOSITION_N,NULL,mtxAp,RSB_FLAG_IDENTICAL_FLAGS);
       // will clone the transpose of the matrix
       errval = rsb_mtx_clone(&amp;mtxBp,RSB_NUMERICAL_TYPE_SAME_TYPE,RSB_TRANSPOSITION_T,NULL,mtxAp,RSB_FLAG_IDENTICAL_FLAGS);
       // will clone the lower triangle of the matrix
       errval = rsb_mtx_clone(&amp;mtxBp,RSB_NUMERICAL_TYPE_SAME_TYPE,RSB_TRANSPOSITION_N,NULL,mtxAp,RSB_FLAG_TRIANGULAR|RSB_FLAG_LOWER);
       <b>Parameters</b>
           <u>mtxBpp</u> Valid rsb_mtx_t pointer to an address for matrix $B$. If *mtxBpp==NULL, a fresh clone will  be
           assigned  there;  if  not,  the existing matrix structure will be freed and allocated to host the new
           one. The case *mtxBpp==mtxAp is supported.
           <u>typecode</u> A valid type code for the desired output matrix (see <b>matrix_type_symbols_section</b>).
           <u>transA</u> Transposition parameter for $A$ (see <b>matrix_transposition_flags_section</b>).
           <u>alphap</u> Optional pointer (if NULL, will default to 1) to a numerical value for scaling the output.  Of
           the type code of mtxAp.
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>flags</u>    Either    <b>RSB_FLAG_IDENTICAL_FLAGS</b>    or    a    combination    of    other   flags,   e.g.:
           <b>RSB_FLAG_C_INDICES_INTERFACE</b>,    <b>RSB_FLAG_SYMMETRIC</b>,     <b>RSB_FLAG_HERMITIAN</b>,     <b>RSB_FLAG_TRIANGULAR</b>,
           <b>RSB_FLAG_UPPER</b>,    <b>RSB_FLAG_LOWER</b>,    <b>RSB_FLAG_UNIT_DIAG_IMPLICIT</b>,    <b>RSB_FLAG_DISCARD_ZEROS</b>.    Flag
           <b>RSB_FLAG_EXTERNALLY_ALLOCATED_ARRAYS</b>  is  forbidden.   Flag   <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b>   is
           ignored.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       Example snip:
               if( RSB_ERR_NO_ERROR != (errval =
                       rsb_mtx_clone(&amp;mtxAp,RSB_NUMERICAL_TYPE_SAME_TYPE,
                       RSB_TRANSPOSITION_T,NULL,mtxAp,RSB_FLAG_IDENTICAL_FLAGS)))
               {
                       goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_mtx_alloc_from_coo_const</b>,    <b>rsb_mtx_alloc_from_coo_inplace</b>,     <b>rsb_mtx_free</b>,     <b>rsb_mtx_clone</b>,
           <b>rsb_mtx_alloc_from_csr_const</b>,      <b>rsb_mtx_alloc_from_csc_const</b>,      <b>rsb_mtx_alloc_from_csr_inplace</b>,
           <b>rsb_mtx_switch_to_csr</b>, <b>rsb_mtx_alloc_from_coo_begin</b>, <b>rsb_mtx_alloc_from_coo_end</b>
   <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>rsb_mtx_free</b> <b>(struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp)</b>
       Frees a previously allocated sparse matrix structure.
       In the case the matrix has the <b>RSB_FLAG_EXTERNALLY_ALLOCATED_ARRAYS</b> flag,  the  main  three  data  arrays
       VA,IA,JA          will          not         be         freed         by         <b>rsb_mtx_free</b>         (see
       <b>rsb_mtx_alloc_from_coo_inplace</b>,<b>rsb_mtx_alloc_from_csr_inplace</b>).
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
       <b>Returns</b>
           Always NULL.
       Example freeing a sparse matrix:
               <a href="../manmtxAp/rsb_mtx_free.mtxAp.html">rsb_mtx_free</a>(mtxAp);

       <b>See</b> <b>also</b>
           <b>rsb_mtx_alloc_from_coo_const</b>,    <b>rsb_mtx_alloc_from_coo_inplace</b>,     <b>rsb_mtx_free</b>,     <b>rsb_mtx_clone</b>,
           <b>rsb_mtx_alloc_from_csr_const</b>,      <b>rsb_mtx_alloc_from_csc_const</b>,      <b>rsb_mtx_alloc_from_csr_inplace</b>,
           <b>rsb_mtx_switch_to_csr</b>, <b>rsb_mtx_alloc_from_coo_begin</b>, <b>rsb_mtx_alloc_from_coo_end</b>
   <b>rsb_err_t</b> <b>rsb_mtx_get_coo</b> <b>(const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>void</b> <b>*</b> <b>VA,</b> <b>rsb_coo_idx_t</b> <b>*</b> <b>IA,</b> <b>rsb_coo_idx_t</b> <b>*</b> <b>JA,</b>
       <b>rsb_flags_t</b> <b>flags)</b>
       Returns the matrix converted in a coordinate storage format.
       Elements will be stored in no particular order.
       If there are structural or fill-in zero elements, these will be skipped.
       Writes       as        many        entries        as        there        are        nonzeroes        (use
       <b>rsb_mtx_get_info</b>(mtxAp,<b>RSB_MIF_MATRIX_NNZ__TO__RSB_NNZ_INDEX_T</b>,&amp;nnz))  to  find  out how many in order to
       allocate the arrays correctly.
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>VA,IA,JA</u> Output numerical values (VA) array; output row (IA) and column (JA) indices arrays.
           <u>flags</u> Either <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b> or  <b>RSB_FLAG_C_INDICES_INTERFACE</b>  (see  <b>flags_section</b>
           flags section).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_coo</b>, <b>rsb_mtx_get_csr</b>, <b>rsb_mtx_get_rows_sparse</b>,  <b>rsb_mtx_get_coo_block</b>,  <b>rsb_mtx_get_prec</b>,
           <b>rsb_mtx_get_nrm</b>, <b>rsb_mtx_get_vec</b>, <b>rsb_file_mtx_get_dims</b>, <b>rsb_mtx_get_vals</b>
   <b>rsb_err_t</b> <b>rsb_mtx_get_coo_block</b> <b>(const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>void</b> <b>*</b> <b>VA,</b> <b>rsb_coo_idx_t</b> <b>*</b> <b>IA,</b> <b>rsb_coo_idx_t</b>
       <b>*</b>  <b>JA,</b>  <b>rsb_coo_idx_t</b> <b>frA,</b> <b>rsb_coo_idx_t</b> <b>lrA,</b> <b>rsb_coo_idx_t</b> <b>fcA,</b> <b>rsb_coo_idx_t</b> <b>lcA,</b> <b>const</b> <b>rsb_coo_idx_t</b> <b>*</b>
       <b>IREN,</b> <b>const</b> <b>rsb_coo_idx_t</b> <b>*</b> <b>JREN,</b> <b>rsb_nnz_idx_t</b> <b>*</b> <b>rnzp,</b> <b>rsb_flags_t</b> <b>flags)</b>
       Writes in COO format the specified submatrix.
       Works in two stages: first the user invokes it with VA,IA,JA set to NULL to get *rnzp. Then the  VA,IA,JA
       arrays  can be allocated, and the function called again, this time with rnzp=NULL but the VA,IA,JA arrays
       pointers non NULL (or at least, one of them).
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>VA,IA,JA</u> Output numerical values (VA) array; output row (IA) and column (JA) indices arrays.
           <u>frA,lrA</u> First and last row indices.
           <u>fcA,lcA</u> First and last column indices.
           <u>IREN,JREN</u> Renumbering arrays for IA and JA (respectively rows count  and  columns  count  sized).  If
           NULL, no renumbering will be used.
           <u>rnzp</u> A pointer where the number of relevant nonzero elements will be written to.
           <u>flags</u>  Either  <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b>  or <b>RSB_FLAG_C_INDICES_INTERFACE</b> (see <b>flags_section</b>
           flags section).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       Examples:
               rsb_coo_idx_t nzi;
               rsb_coo_idx_t *IA = NULL;
               rsb_coo_idx_t *JA = NULL;
               const rsb_coo_idx_t IREN[]={0,1,2,3};
               const rsb_coo_idx_t JREN[]={3,2,1,0};
               RSB_DEFAULT_TYPE *VA = NULL;
               const size_t so = sizeof(RSB_DEFAULT_TYPE);
               const size_t si = sizeof(rsb_coo_idx_t);
               rsb_err_t errval;
               rsb_flags_t flagsA = RSB_FLAG_NOFLAGS;
               rsb_nnz_idx_t rnz = 0;
               rsb_coo_idx_t frA=0,lrA=1; // first two rows
               rsb_coo_idx_t fcA=0,lcA=4; // 5 (all) columns

               // get the nnz count only
               errval=rsb_mtx_get_coo_block
                       (mtxAp,NULL,NULL,NULL,frA,lrA,fcA,lcA,NULL,NULL,&amp;rnz,flagsA);
               if(errval != RSB_ERR_NO_ERROR )
                       goto err;

               // allocate VA, IA, JA to rnz elements
               IA = calloc(rnz, si);
               JA = calloc(rnz, si);
               VA = calloc(rnz, so);

               // get the  rnz  values then
               errval=rsb_mtx_get_coo_block
                       (mtxAp,  VA,  IA,  JA,frA,lrA,fcA,lcA,NULL,NULL,NULL,flagsA);
               if(errval != RSB_ERR_NO_ERROR )
                       goto err;

               for(nzi=0;nzi&lt;rnz;++nzi)
                       printf("%d/%d  %d %d -&gt; %d\n",(int)nzi,(int)rnz,
                               (int)IA[nzi],(int)JA[nzi],(int)VA[nzi]);

               // get the  rnz  values again, renumbered
               errval=rsb_mtx_get_coo_block
                       (mtxAp,  VA,  IA,  JA,frA,lrA,fcA,lcA,IREN,JREN,NULL,flagsA);
               if(errval != RSB_ERR_NO_ERROR )
                       goto err;

               for(nzi=0;nzi&lt;rnz;++nzi)
                       printf("%d/%d  %d %d -&gt; %d\n",(int)nzi,(int)rnz,
                               (int)IA[nzi],(int)JA[nzi],(int)VA[nzi]);

               free(VA);
               free(IA);
               free(JA);

              And other examples:
       // get nnz count first
       errval=rsb_mtx_get_coo_block(mtxAp,NULL,NULL,NULL,frA,lrA,fcA,lcA,NULL,NULL,&amp;rnz,flags )
       // allocate VA, IA, JA to rnz elements
       ...
       // get the  rnz  values then
       errval=rsb_mtx_get_coo_block(mtxAp,  VA,  IA,  JA,frA,lrA,fcA,lcA,NULL,NULL,NULL,flags )

       <b>Warning</b>
           Expect  this function to change soon (e.g.: have scaling parameters, etc.). Contact the author if you
           intend to use it.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_coo</b>, <b>rsb_mtx_get_csr</b>, <b>rsb_mtx_get_rows_sparse</b>,  <b>rsb_mtx_get_coo_block</b>,  <b>rsb_mtx_get_prec</b>,
           <b>rsb_mtx_get_nrm</b>, <b>rsb_mtx_get_vec</b>, <b>rsb_file_mtx_get_dims</b>, <b>rsb_mtx_get_vals</b>
   <b>rsb_err_t</b>  <b>rsb_mtx_get_csr</b>  <b>(rsb_type_t</b>  <b>typecode,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>void</b> <b>*</b> <b>VA,</b> <b>rsb_nnz_idx_t</b> <b>*</b>
       <b>RP,</b> <b>rsb_coo_idx_t</b> <b>*</b> <b>JA,</b> <b>rsb_flags_t</b> <b>flags)</b>
       Fills the given arrays with the matrix expressed in the CSR format.
       <b>Parameters</b>
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>VA,RP,JA</u>  Output  numerical  values  (VA)  array, compressed row indices (RP) and column indices (JA)
           arrays.
           <u>flags</u> Either <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b> or  <b>RSB_FLAG_C_INDICES_INTERFACE</b>  (see  <b>flags_section</b>
           flags section).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_coo</b>, <b>rsb_mtx_get_csr</b>, <b>rsb_mtx_get_rows_sparse</b>,  <b>rsb_mtx_get_coo_block</b>,  <b>rsb_mtx_get_prec</b>,
           <b>rsb_mtx_get_nrm</b>, <b>rsb_mtx_get_vec</b>, <b>rsb_file_mtx_get_dims</b>, <b>rsb_mtx_get_vals</b>
   <b>rsb_err_t</b> <b>rsb_mtx_get_info</b> <b>(const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>enum</b> <b>rsb_mif_t</b> <b>miflags,</b> <b>void</b> <b>*</b> <b>minfop)</b>
       Returns a specified matrix (numerical) property.
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>miflags</u> A valid value of matrix info flags (see <b>rsb_mif_t</b> for valid values).
           <u>minfop</u>  Pointer to a variable of the right type, according to the matrix info flag specification (see
           <b>rsb_mif_t</b>).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       Example snip:
               rsb_real_t isopnnz;
               const enum rsb_mif_t miflags =
                       RSB_MIF_INDEX_STORAGE_IN_BYTES_PER_NNZ__TO__RSB_REAL_T;
               errval = rsb_mtx_get_info(mtxAp, miflags, &amp;isopnnz);

               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_mtx_get_info!\n");
                       goto err;
               }
               printf("RSB matrix uses %lf bytes per nnz.\n",(double)isopnnz);

       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_info</b>, <b>rsb_mtx_get_info_str</b>, <b>rsb_file_mtx_save</b>, <b>rsb_file_vec_load</b>, <b>rsb_file_mtx_load</b>
   <b>rsb_err_t</b> <b>rsb_mtx_get_info_str</b> <b>(const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>const</b> <b>rsb_char_t</b> <b>*</b> <b>mis,</b> <b>void</b> <b>*</b> <b>minfop,</b> <b>size_t</b>
       <b>buflen)</b>
       Returns a specified matrix (numerical) property, via a string form query.
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>mis</u>  A string specifying any identifier among the matrix info ones. See <b>rsb_mif_t</b> for a list of valid
           identifiers that can be supplied in string form.
           <u>minfop</u> Pointer to a variable of the right type, according to the matrix info flag specification  (see
           <b>rsb_mif_t</b>).
           <u>buflen</u>  If  greater  than  0, minfop will be treated as a string of length buflen and filled with the
           desired value via the standard <b>snprintf()</b> <b>function.</b>
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       Example snip:
               rsb_mtx_get_info_str(mtxAp,"RSB_MIF_MATRIX_INFO__TO__CHAR_P",
                               ib,sizeof(ib));
               printf("%s",ib);

       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_info</b>, <b>rsb_mtx_get_info_str</b>, <b>rsb_file_mtx_save</b>, <b>rsb_file_vec_load</b>, <b>rsb_file_mtx_load</b>
   <b>rsb_err_t</b> <b>rsb_mtx_get_nrm</b> <b>(const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>void</b> <b>*</b> <b>Np,</b> <b>enum</b> <b>rsb_extff_t</b> <b>flags)</b>
       Computes a matrix norm (either infinite-norm or or 2-norm or 1-norm).
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>Np</u> Points to a scalar value which will be overwritten with the selected norm.
           <u>flags</u> Either <b>RSB_EXTF_NORM_ONE</b> or <b>RSB_EXTF_NORM_TWO</b> or <b>RSB_EXTF_NORM_INF</b>.
       In case of a complex type, only the real part will be written to Np.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_coo</b>, <b>rsb_mtx_get_csr</b>, <b>rsb_mtx_get_rows_sparse</b>,  <b>rsb_mtx_get_coo_block</b>,  <b>rsb_mtx_get_prec</b>,
           <b>rsb_mtx_get_nrm</b>, <b>rsb_mtx_get_vec</b>, <b>rsb_file_mtx_get_dims</b>, <b>rsb_mtx_get_vals</b>
   <b>rsb_err_t</b> <b>rsb_mtx_get_prec</b> <b>(void</b> <b>*</b> <b>opdp,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>rsb_precf_t</b> <b>prec_flags,</b> <b>const</b> <b>void</b> <b>*</b>
       <b>ipdp)</b>
       A function computing a simple preconditioner out of mtxAp.
       <b>Parameters</b>
           <u>opdp</u> Preconditioner data pointer (output).
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>prec_flags</u>  Valid  preconditioner request flags (currently, only <b>RSB_PRECF_ILU0</b> is supported; for it,
           *opdp will be overwritten with two rsb_mtx_t pointers, respectively a lower and an upper matrix.).
           <u>ipdp</u> Preconditioner data pointer (input) (ignored at the moment).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       Example:
               struct rsb_mtx_t *mtxAp = NULL; /* matrix structure pointer */
               struct rsb_mtx_t *mtxLUp [2];   /* matrix structure pointer */
               rsb_precf_t prec_flags = RSB_PRECF_ILU0;

               if((errval = rsb_lib_init(RSB_NULL_INIT_OPTIONS)) !=
                               RSB_ERR_NO_ERROR)
               {
                       printf("Error initializing the library!\n");
                       goto err;
               }

               mtxAp = rsb_mtx_alloc_from_coo_const(
                       VA,IA,JA,nnzA,typecode,nrA,ncA,brA,bcA,
                       RSB_FLAG_DEFAULT_RSB_MATRIX_FLAGS /* force rsb */
                       | RSB_FLAG_DUPLICATES_SUM /* sum dups */
                       | RSB_FLAG_TRIANGULAR /* need triangle for spsv */
                       , &amp;errval);

               if((!mtxAp) || (errval != RSB_ERR_NO_ERROR))
               {
                       printf("Error while allocating the matrix!\n");
                       goto err;
               }

               errval = rsb_mtx_get_prec(mtxLUp,mtxAp, prec_flags, NULL);
               if( errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error while calling rsb_mtx_get_prec!\n");
                       goto err;
               }
               // ...

               rsb_mtx_free(mtxLUp[0]);
               rsb_mtx_free(mtxLUp[1]);
               rsb_mtx_free(mtxAp );

       <b>Note</b>
           Matrix should be square, have at least two rows, and have at least one nonzero.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_coo</b>,  <b>rsb_mtx_get_csr</b>,  <b>rsb_mtx_get_rows_sparse</b>, <b>rsb_mtx_get_coo_block</b>, <b>rsb_mtx_get_prec</b>,
           <b>rsb_mtx_get_nrm</b>, <b>rsb_mtx_get_vec</b>, <b>rsb_file_mtx_get_dims</b>, <b>rsb_mtx_get_vals</b>
   <b>rsb_err_t</b> <b>rsb_mtx_get_rows_sparse</b> <b>(rsb_trans_t</b> <b>transA,</b> <b>const</b> <b>void</b> <b>*</b> <b>alphap,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b>  <b>*</b>  <b>mtxAp,</b>
       <b>void</b>  <b>*</b> <b>VA,</b> <b>rsb_coo_idx_t</b> <b>*</b> <b>IA,</b> <b>rsb_coo_idx_t</b> <b>*</b> <b>JA,</b> <b>rsb_coo_idx_t</b> <b>frA,</b> <b>rsb_coo_idx_t</b> <b>lrA,</b> <b>rsb_nnz_idx_t</b> <b>*</b>
       <b>rnzp,</b> <b>rsb_flags_t</b> <b>flags)</b>
       Writes to the given COO arrays the specified submatrix.
       Invoke with VA,IA,JA set to NULL in order to get the nonzeroes count written to *rnzp, and know how large
       the arrays should be.
       IA can be NULL (in this case it will be ignored). The written rows are ordered.
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>VA,IA,JA</u> Output numerical values (VA) array; input row (IA) and column (JA) indices arrays.
           <u>frA,lrA</u> First and last row indices.
           <u>rnzp</u> A pointer where the number of relevant nonzero elements will be written to.
           <u>alphap</u> Optional pointer (if NULL, will default to 1) to a  numerical  value  (of  the  same  type  as
           matrix).
           <u>transA</u> Transposition parameter for $A$ (see <b>matrix_transposition_flags_section</b>).
           <u>flags</u>  Either  <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b>  or <b>RSB_FLAG_C_INDICES_INTERFACE</b> (see <b>flags_section</b>
           flags section).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       Example snip:
               rsb_coo_idx_t    IA[] = { 0, 0, 0, 0 };
               rsb_coo_idx_t    JA[] = { 0, 0, 0, 0 };
               RSB_DEFAULT_TYPE VA[] = { -1, -1, -1, -1 };
               rsb_trans_t transA = RSB_TRANSPOSITION_N;
               const rsb_coo_idx_t frA = 2, lrA = 2;
               rsb_nnz_idx_t rnz;
               RSB_DEFAULT_TYPE *alphap = NULL;

               errval = rsb_mtx_get_rows_sparse(transA, NULL, mtxAp, NULL,
                        NULL, NULL, frA, lrA, &amp;rnz, RSB_FLAG_NOFLAGS);
               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_mtx_get_rows_sparse!\n");
                       goto err;
               }

               printf("Rows between %d and %d have %d nnz\n",
                       (int)frA,(int)lrA,(int)rnz);

               errval = rsb_mtx_get_rows_sparse(transA, alphap, mtxAp,
                        VA, IA, JA, frA, lrA, &amp;rnz, RSB_FLAG_NOFLAGS);
               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_mtx_get_vals!\n");
                       goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_coo</b>,  <b>rsb_mtx_get_csr</b>,  <b>rsb_mtx_get_rows_sparse</b>, <b>rsb_mtx_get_coo_block</b>, <b>rsb_mtx_get_prec</b>,
           <b>rsb_mtx_get_nrm</b>, <b>rsb_mtx_get_vec</b>, <b>rsb_file_mtx_get_dims</b>, <b>rsb_mtx_get_vals</b>
   <b>rsb_err_t</b> <b>rsb_mtx_get_vals</b> <b>(const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>void</b>  <b>*</b>  <b>VA,</b>  <b>const</b>  <b>rsb_coo_idx_t</b>  <b>*</b>  <b>IA,</b>  <b>const</b>
       <b>rsb_coo_idx_t</b> <b>*</b> <b>JA,</b> <b>rsb_nnz_idx_t</b> <b>nnz,</b> <b>rsb_flags_t</b> <b>flags)</b>
       Gets the specified matrix elements, if found. Please note that unlike <b>rsb_mtx_set_vals</b>, the matrix has to
       be fully assembled here.
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>VA,IA,JA</u> Output numerical values (VA) array; input row (IA) and column (JA) indices arrays.
           <u>nnz</u> The number of nonzeroes in the input arrays.
           <u>flags</u>  Either  <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b>  or <b>RSB_FLAG_C_INDICES_INTERFACE</b> (see <b>flags_section</b>
           flags section).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       Example snip:
               const rsb_coo_idx_t    IA[] = { 2, 0, 2, 0 };
               const rsb_coo_idx_t    JA[] = { 2, 0, 0, 0 };
               RSB_DEFAULT_TYPE VA[] = { -1, -1, -1, -1 };

               errval = rsb_mtx_get_vals(mtxAp, VA, IA, JA, nnzA, RSB_FLAG_NOFLAGS);
               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_mtx_get_vals!\n");
                       goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_coo</b>,  <b>rsb_mtx_get_csr</b>,  <b>rsb_mtx_get_rows_sparse</b>, <b>rsb_mtx_get_coo_block</b>, <b>rsb_mtx_get_prec</b>,
           <b>rsb_mtx_get_nrm</b>, <b>rsb_mtx_get_vec</b>, <b>rsb_file_mtx_get_dims</b>, <b>rsb_mtx_get_vals</b>
   <b>rsb_err_t</b> <b>rsb_mtx_get_vec</b> <b>(const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>void</b> <b>*</b> <b>Dp,</b> <b>enum</b> <b>rsb_extff_t</b> <b>flags)</b>
       Will overwrite a supplied array with a specific vector quantity.
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>Dp</u> A valid pointer to a numerical vector array $D$.
           <u>flags</u> Either one of the different extraction filter flags  (e.g.:  <b>RSB_EXTF_DIAG</b>,  <b>RSB_EXTF_SUMS_ROW</b>,
           ...) .
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_get_coo</b>, <b>rsb_mtx_get_csr</b>, <b>rsb_mtx_get_rows_sparse</b>,  <b>rsb_mtx_get_coo_block</b>,  <b>rsb_mtx_get_prec</b>,
           <b>rsb_mtx_get_nrm</b>, <b>rsb_mtx_get_vec</b>, <b>rsb_file_mtx_get_dims</b>, <b>rsb_mtx_get_vals</b>
   <b>rsb_err_t</b>  <b>rsb_mtx_rndr</b>  <b>(const</b>  <b>char</b>  <b>*</b>  <b>filename,</b>  <b>const</b>  <b>struct</b>  <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>rsb_coo_idx_t</b> <b>pmWidth,</b>
       <b>rsb_coo_idx_t</b> <b>pmHeight,</b> <b>rsb_marf_t</b> <b>rflags)</b>
       Renders a matrix to a file. Currently, only Encapsulated Postscript (EPS) is supported.
       <b>Parameters</b>
           <u>filename</u> The specified output file name (if NULL or '' (the empty string),  will  write  to  standard
           output).
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>pmWidth</u> Pixel map width (in pixels or points).
           <u>pmHeight</u> Pixel map height (in pixels or points).
           <u>rflags</u>  The  color  mode;  only <b>RSB_MARF_RGB</b> is supported for now (1 byte per channel, 3 channels ---
           red, green, blue): this requires array pmp to be at least (3*pmlWidth*pmHeight) bytes large.
       Example rendering a sparse matrix to Postscript:
                       if(RSB_ERR_NO_ERROR!=(errval =
                       rsb_mtx_rndr("pd.eps",mtxAp,512,512,RSB_MARF_EPS_B)))
                               goto err;

       Setting environment variable  RSB_USE_HOSTNAME=0  prevents  hostname  being  in  the  EPS  plot  internal
       comments.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_rndr</b>, <b>rsb_file_mtx_rndr</b>
   <b>rsb_err_t</b>  <b>rsb_mtx_set_vals</b>  <b>(struct</b>  <b>rsb_mtx_t</b>  <b>*</b>  <b>mtxAp,</b>  <b>const</b>  <b>void</b> <b>*</b> <b>VA,</b> <b>const</b> <b>rsb_coo_idx_t</b> <b>*</b> <b>IA,</b> <b>const</b>
       <b>rsb_coo_idx_t</b> <b>*</b> <b>JA,</b> <b>rsb_nnz_idx_t</b> <b>nnz,</b> <b>rsb_flags_t</b> <b>flags)</b>
       Updates the specified matrix elements, if found in the nonzero pattern.
       In the special case of a matrix in assembly state (that is, one that  has  been  created  as  empty  with
       <b>rsb_mtx_alloc_from_coo_begin()</b> and not yet assembled with <b>rsb_mtx_alloc_from_coo_end()</b> ) all the supplied
       matrix elements will be accepted: whether already present or not.
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>VA,IA,JA</u> Input numerical values (VA) array; row (IA) and column (JA) input indices arrays.
           <u>nnz</u> The number of nonzeroes in the input arrays.
           <u>flags</u>   Either   <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b>   or   <b>RSB_FLAG_C_INDICES_INTERFACE</b>  plus  either
           <b>RSB_FLAG_DUPLICATES_SUM</b> (to sum into) or <b>RSB_FLAG_DUPLICATES_KEEP_LAST</b> (to  overwrite  entries)  (see
           <b>flags_section</b> flags section).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       <b>See</b> <b>also</b>
           <b>rsb_mtx_upd_vals</b>, <b>rsb_mtx_set_vals</b>
   <b>rsb_err_t</b> <b>rsb_mtx_switch_to_coo</b> <b>(struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>void</b> <b>**</b> <b>VAp,</b> <b>rsb_coo_idx_t</b> <b>**</b>  <b>IAp,</b>  <b>rsb_coo_idx_t</b>
       <b>**</b> <b>JAp,</b> <b>rsb_flags_t</b> <b>flags)</b>
       Switches a matrix to COO arrays in place.
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>VAp,IAp,JAp</u>  Output  numerical  values (VAp) array pointer; output row (IAp) and column (JAp) indices
           arrays pointers.
           <u>flags</u>   A   combination    of    <b>RSB_FLAG_C_INDICES_INTERFACE</b>,    <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b>,
           <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b>. (see <b>flags_section</b> flags section).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       <b>Note</b>
           This function is only valid if mtxAp has been assembled in place (that is, in  the  arrays  that  are
           being  reclaimed),  so  with e.g.: <b>rsb_mtx_alloc_from_coo_inplace()</b>. Please also note that the matrix
           will get freed internally and so mtxAp will not be usable in any way afterwards.
       <b>Warning</b>
           This function has not been thoroughly tested.
       Example:
               rsb_coo_idx_t  *RP = NULL;
               rsb_coo_idx_t  *JA = NULL;
               RSB_DEFAULT_TYPE *VA = NULL;

               errval = rsb_mtx_switch_to_coo(mtxAp, (void**)&amp;VA,
                       &amp;RP, &amp;JA, RSB_FLAG_NOFLAGS);

               // NOTE: no rsb_mtx_free() necessary now..

       <b>See</b> <b>also</b>
           <b>rsb_mtx_switch_to_coo</b>,<b>rsb_mtx_switch_to_coo</b>
   <b>rsb_err_t</b> <b>rsb_mtx_switch_to_csr</b> <b>(struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>void</b> <b>**</b> <b>VAp,</b> <b>rsb_coo_idx_t</b> <b>**</b>  <b>IAp,</b>  <b>rsb_coo_idx_t</b>
       <b>**</b> <b>JAp,</b> <b>rsb_flags_t</b> <b>flags)</b>
       Switches the matrix to the CSR format, in-place.
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>VAp,IAp,JAp</u>  Output  numerical  values (VAp) array pointer; output row (IAp) and column (JAp) indices
           arrays pointers.
           <u>flags</u> A valid combination of  index  conversion  flags  (that  is,  <b>RSB_FLAG_C_INDICES_INTERFACE</b>  and
           <b>RSB_FLAG_FORTRAN_INDICES_INTERFACE</b>)  and  other meaningful flags. Symmetry flags shall be the same as
           in   the   matrix   in   use,   because   symmetry   expansion   may    happen    otherwise.    Flags
           <b>RSB_FLAG_EXTERNALLY_ALLOCATED_ARRAYS</b> are forbidden.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       <b>Note</b>
           This function is only valid if mtxAp has been assembled in place (that is, in  the  arrays  that  are
           being  reclaimed),  so  with e.g.: <b>rsb_mtx_alloc_from_coo_inplace()</b>. Please also note that the matrix
           will get freed internally and so mtxAp will not be usable in any way afterwards.
       <b>Warning</b>
           This function has not been thoroughly tested.
       Example:
               rsb_coo_idx_t  *IA = NULL;
               rsb_coo_idx_t  *JA = NULL;
               RSB_DEFAULT_TYPE *VA = NULL;

               errval = rsb_mtx_switch_to_csr(mtxAp, (void**)&amp;VA,
                       &amp;IA, &amp;JA, RSB_FLAG_NOFLAGS);

               // NOTE: no rsb_mtx_free() necessary now..

       <b>See</b> <b>also</b>
           <b>rsb_mtx_switch_to_coo</b>,<b>rsb_mtx_switch_to_coo</b>
   <b>rsb_err_t</b> <b>rsb_mtx_upd_vals</b> <b>(struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>enum</b> <b>rsb_elopf_t</b> <b>elop_flags,</b> <b>const</b> <b>void</b> <b>*</b> <b>omegap)</b>
       $ A &lt;- op (A,Omega) $ Updates the matrix $A$ by applying either a  row-wise  or  an  elemental  operation
       $op$, which is determined by elop_flags. If an unary operation is selected, omegap can be NULL.
       <b>Parameters</b>
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>elop_flags</u> Elemental operation specification flags (see <b>rsb_elopf_t</b> for valid choices).
           <u>omegap</u> Pointer to a numerical location(s) (of the same type as matrix).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       Example snip:
               enum rsb_elopf_t elop_flags = RSB_ELOPF_NEG;
               const RSB_DEFAULT_TYPE omegap[] = {10};

               errval = rsb_mtx_upd_vals(mtxAp, elop_flags, NULL);
               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_mtx_upd_vals!\n");
                       goto err;
               }

               elop_flags = RSB_ELOPF_MUL;
               errval = rsb_mtx_upd_vals(mtxAp, elop_flags, omegap);
               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_mtx_upd_vals!\n");
                       goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_mtx_upd_vals</b>, <b>rsb_mtx_set_vals</b>
   <b>rsb_err_t</b> <b>rsb_perror</b> <b>(void</b> <b>*</b> <b>stream,</b> <b>rsb_err_t</b> <b>errval)</b>
       Prints out to the specified stream a string corresponding to the error code (using &lt;stdio.h&gt;'s  fprintf).
       If stream==NULL, will print out to the default output stream; see <b>RSB_IO_WANT_OUTPUT_STREAM</b> .
       <b>Parameters</b>
           <u>stream</u> A (FILE*) pointer, as declared in &lt;stdio.h&gt;; can be NULL.
           <u>errval</u> A valid error flag value (see <b>rsb_err_t</b>).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       <b>See</b> <b>also</b>
           <b>rsb_perror</b>, <b>rsb_strerror_r</b>
   <b>rsb_trans_t</b> <b>rsb_psblas_trans_to_rsb_trans</b> <b>(const</b> <b>char</b> <b>psbtrans)</b>
       Translate a PSBLAS transposition value character to a librsb one.
        See the PSBLAS library website/documentation for valid input values.
       <b>Parameters</b>
           <u>psbtrans</u> Transposition parameter value valid in the PSBLAS library.
       <b>Returns</b>
           A valid transposition code;  that  is  <b>RSB_TRANSPOSITION_N</b>  for  'N',  <b>RSB_TRANSPOSITION_T</b>  for  'T',
           RSB_TRANSPOSITION_C for 'C', (See <b>matrix_transposition_flags_section</b>).
       Example snip:
       <b>See</b> <b>also</b>
           <b>rsb_psblas_trans_to_rsb_trans</b>
   <b>rsb_err_t</b>  <b>rsb_spmm</b>  <b>(rsb_trans_t</b>  <b>transA,</b> <b>const</b> <b>void</b> <b>*</b> <b>alphap,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>rsb_coo_idx_t</b>
       <b>nrhs,</b> <b>rsb_flags_t</b> <b>order,</b> <b>const</b> <b>void</b> <b>*</b> <b>Bp,</b> <b>rsb_nnz_idx_t</b> <b>ldB,</b> <b>const</b> <b>void</b> <b>*</b> <b>betap,</b> <b>void</b> <b>*</b> <b>Cp,</b> <b>rsb_nnz_idx_t</b>
       <b>ldC)</b>
       Updates a dense matrix with the product of sparse matrix by dense matrix; that is, computes $ C &lt;-  beta*
       C + alpha* opa(A) * B $.
       $opa( A )=A$ if transA=<b>RSB_TRANSPOSITION_N;</b>
        <b>$opa(</b>  <b>A</b>  <b>)=</b>  <b>A</b>  <b>^T$</b>  <b>if</b>  <b>transA=RSB_TRANSPOSITION_T;</b> <b>$opa(</b> <b>A</b> <b>)=</b> <b>A</b> <b>^H$</b> <b>if</b> <b>transA=RSB_TRANSPOSITION_C;</b> <b>If</b>
       <b>--enable-rsb-num-threads</b> <b>has</b> <b>been</b> <b>specified</b> <b>at</b> <b>configure</b> <b>time,</b> <b>the</b> <b>RSB_NUM_THREADS</b>  <b>environment</b>  <b>variable</b>
       <b>will</b>   <b>override</b>   <b>the</b>   <b>number</b>   <b>of</b>   <b>executing</b>   <b>threads</b>   <b>specified</b>   <b>by</b>   <b>OMP_NUM_THREADS.</b>  <b>(See</b>  <b>also</b>
       <b>RSB_IO_WANT_EXECUTING_THREADS).</b>  <b>Setting</b>  <b>order=RSB_FLAG_WANT_COLUMN_MAJOR_ORDER</b>  <b>with</b>  <b>ldC=0</b>  <b>and</b>  <b>ldB=0</b>
       <b>implies</b> <b>'compact'</b> <b>defaults,</b> <b>that</b> <b>is</b> <b>no</b> <b>extra</b> <b>stride</b> <b>between</b> <b>the</b> <b>columns.</b>
       <b>Parameters</b>
           <u>transA</u> Transposition parameter for $A$ (see <b>matrix_transposition_flags_section</b>).
           <u>alphap</u>  Optional  pointer  (if  NULL,  will  default  to 1) to a numerical value (of the same type as
           matrix).
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>nrhs</u> The number of right hand side vectors (cannot be &lt;1).
           <u>order</u> A flag among <b>RSB_FLAG_WANT_COLUMN_MAJOR_ORDER</b> and <b>RSB_FLAG_WANT_ROW_MAJOR_ORDER</b>. For contiguous
           vector arrays, you probably want <b>RSB_FLAG_WANT_COLUMN_MAJOR_ORDER</b>.
           <u>Bp</u> The input vector array.
           <u>ldB</u> Leading dimension of Bp array.
           <u>betap</u> Optional pointer (if NULL, will default to 1) to a numerical value.
           <u>Cp</u> The output vector array.
           <u>ldC</u> Leading dimension of Cp array.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       <b>Note</b>
           Starting  from  version  1.3,  librsb uses C++ kernels for <b>rsb_spmv</b>/<b>rsb_spmm</b>. Assuming you configured
           --enable-debug-getenvs, you may set environment variable RSB_WANT_RSBPP=0  to  turn  use  the  old  C
           kernels.
       <b>See</b> <b>also</b>
           <b>rsb_spmv</b>, <b>rsb_spmm</b>, <b>rsb_spata</b>, <b>rsb_tune_spmm</b>
   <b>struct</b>  <b>rsb_mtx_t</b>  <b>*</b>  <b>rsb_spmsp</b>  <b>(rsb_type_t</b>  <b>typecode,</b> <b>rsb_trans_t</b> <b>transA,</b> <b>const</b> <b>void</b> <b>*</b> <b>alphap,</b> <b>const</b> <b>struct</b>
       <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>rsb_trans_t</b> <b>transB,</b> <b>const</b> <b>void</b> <b>*</b> <b>betap,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b>  <b>mtxBp,</b>  <b>rsb_err_t</b>  <b>*</b>
       <b>errvalp)</b>
       Computes  the  weighted  product  of  two  sparse  matrices  in a new sparse matrix (also known as SpGEMM
       operation): $C &lt;- alpha * opa(A) *  beta  *  opb(B)  $  Symmetry/Hermitian  flags  are  ignored  by  this
       operation.
       $opa( A )=A$ if transA=<b>RSB_TRANSPOSITION_N;</b>
        <b>$opa(</b>  <b>A</b> <b>)=</b> <b>A</b> <b>^T$</b> <b>if</b> <b>transA=RSB_TRANSPOSITION_T;</b> <b>$opa(</b> <b>A</b> <b>)=</b> <b>A</b> <b>^H$</b> <b>if</b> <b>transA=RSB_TRANSPOSITION_C;</b> <b>$opb(</b> <b>B</b>
       <b>)=B$</b> <b>if</b> <b>transB=RSB_TRANSPOSITION_N;</b>
        <b>$opb(</b> <b>B</b> <b>)=</b> <b>B</b> <b>^T$</b> <b>if</b> <b>transB=RSB_TRANSPOSITION_T;</b> <b>$opb(</b> <b>B</b> <b>)=</b> <b>B</b> <b>^H$</b> <b>if</b> <b>transB=RSB_TRANSPOSITION_C;</b>
       <b>Parameters</b>
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>transA</u> Transposition parameter for $A$ (see <b>matrix_transposition_flags_section</b>).
           <u>alphap</u>  Optional  pointer  (if  NULL,  will  default  to 1) to a numerical value (of the same type as
           matrix).
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>transB</u> Transposition parameter for $B$ (see <b>matrix_transposition_flags_section</b>).
           <u>betap</u> Optional pointer (if NULL, will default to 1) to a numerical value.
           <u>mtxBp</u> Valid rsb_mtx_t pointer to matrix $B$ representation.
           <u>errvalp</u> An optional (can be NULL) pointer to <b>rsb_err_t</b> where the error status will be written to.
       <b>Returns</b>
           On success, a valid pointer (struct rsb_mtx_t*) to the newly allocated matrix  structure;  on  error,
           NULL.
       Example snip:
               const rsb_trans_t transA = RSB_TRANSPOSITION_N;
               const rsb_trans_t transB = RSB_TRANSPOSITION_N;
               RSB_DEFAULT_TYPE *alphap = NULL;
               RSB_DEFAULT_TYPE *betap = NULL;
               struct rsb_mtx_t * mtxCp = NULL;

               mtxCp = rsb_spmsp(typecode, transA, alphap, mtxAp,
                        transB, betap, mtxAp, &amp;errval);
               if( !mtxCp )
               {
                       printf("Error calling rsb_spmsp!\n");
                       goto err;
               }

               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_spmsp!\n");
                       goto err;
               }

       <b>Warning</b>
           Parameters  alphap,betap,transA,transB are not yet taken in consideration. The following defaults are
           valid: $alpha=1.0$ and $beta=1.0$, and transA=transB=<b>RSB_TRANSPOSITION_N.</b>
       <b>See</b> <b>also</b>
           <b>rsb_spmsp_to_dense</b>, <b>rsb_sppsp</b>, <b>rsb_spmsp</b>, <b>rsb_mtx_add_to_dense</b>
   <b>rsb_err_t</b> <b>rsb_spmsp_to_dense</b> <b>(rsb_type_t</b> <b>typecode,</b> <b>rsb_trans_t</b> <b>transA,</b> <b>const</b>  <b>void</b>  <b>*</b>  <b>alphap,</b>  <b>const</b>  <b>struct</b>
       <b>rsb_mtx_t</b>  <b>*</b> <b>mtxAp,</b> <b>rsb_trans_t</b> <b>transB,</b> <b>const</b> <b>void</b> <b>*</b> <b>betap,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxBp,</b> <b>rsb_nnz_idx_t</b>
       <b>ldC,</b> <b>rsb_nnz_idx_t</b> <b>nrC,</b> <b>rsb_nnz_idx_t</b> <b>ncC,</b> <b>rsb_bool_t</b> <b>rowmajorC,</b> <b>void</b> <b>*</b> <b>Cp)</b>
       Computes the product of sparse matrices and adds it to a dense matrix: $C &lt;- alpha opa(A) * beta * opb(B)
       $.
       $opa( A )=A$ if transA=<b>RSB_TRANSPOSITION_N;</b>
        <b>$opa(</b> <b>A</b> <b>)=</b> <b>A</b> <b>^T$</b> <b>if</b> <b>transA=RSB_TRANSPOSITION_T;</b> <b>$opa(</b> <b>A</b> <b>)=</b> <b>A</b> <b>^H$</b> <b>if</b> <b>transA=RSB_TRANSPOSITION_C;</b> <b>$opb(</b>  <b>B</b>
       <b>)=B$</b> <b>if</b> <b>transB=RSB_TRANSPOSITION_N;</b>
        <b>$opb(</b> <b>B</b> <b>)=</b> <b>B</b> <b>^T$</b> <b>if</b> <b>transB=RSB_TRANSPOSITION_T;</b> <b>$opb(</b> <b>B</b> <b>)=</b> <b>B</b> <b>^H$</b> <b>if</b> <b>transB=RSB_TRANSPOSITION_C;</b>
       <b>Parameters</b>
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>transA</u> Transposition parameter for $A$ (see <b>matrix_transposition_flags_section</b>).
           <u>alphap</u> Optional pointer (if NULL, will default to 1) to a  numerical  value  (of  the  same  type  as
           matrix).
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>transB</u> Transposition parameter for $B$ (see <b>matrix_transposition_flags_section</b>).
           <u>betap</u> Optional pointer (if NULL, will default to 1) to a numerical value.
           <u>mtxBp</u> Valid rsb_mtx_t pointer to matrix $B$ representation.
           <u>ldC</u> Leading dimension of Cp array.
           <u>nrC,ncC</u> The number of rows and columns for the dense matrix $C$.
           <u>rowmajorC</u>  <b>RSB_BOOL_TRUE</b> if the dense matrix $C$ is considered stored as row major, or <b>RSB_BOOL_FALSE</b>
           if as column major.
           <u>Cp</u> Array representing the dense matrix $C$.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       <b>Warning</b>
           Parameters  alphap,betap,transA,transB are not yet taken in consideration. The following defaults are
           valid: $alpha=1.0$ and $beta=1.0$, and transA=transB=<b>RSB_TRANSPOSITION_N.</b>
       Example snip:
               const rsb_nnz_idx_t ldC = 4, nrC = 3, ncC = 3;
               const rsb_bool_t rowmajorC = RSB_BOOL_TRUE;
               RSB_DEFAULT_TYPE Cp[ /*ldC*nrC*/ ] = {
                       0, 0, 0, -99,
                       0, 0, 0, -99,
                       0, 0, 0, -99
               };
               const rsb_trans_t transA = RSB_TRANSPOSITION_N;
               const rsb_trans_t transB = RSB_TRANSPOSITION_N;
               RSB_DEFAULT_TYPE *alphap = NULL;
               RSB_DEFAULT_TYPE *betap = NULL;

               errval = rsb_spmsp_to_dense(typecode, transA, alphap, mtxAp,
                        transB, betap, mtxAp , ldC, nrC, ncC, rowmajorC, Cp);
               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_spmsp_to_dense!\n");
                       goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_spmsp_to_dense</b>, <b>rsb_sppsp</b>, <b>rsb_spmsp</b>, <b>rsb_mtx_add_to_dense</b>
   <b>rsb_err_t</b> <b>rsb_spmv</b> <b>(rsb_trans_t</b> <b>transA,</b> <b>const</b> <b>void</b> <b>*</b> <b>alphap,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>const</b> <b>void</b> <b>*</b> <b>Xp,</b>
       <b>rsb_coo_idx_t</b> <b>incX,</b> <b>const</b> <b>void</b> <b>*</b> <b>betap,</b> <b>void</b> <b>*</b> <b>Yp,</b> <b>rsb_coo_idx_t</b> <b>incY)</b>
       Multiplies a sparse matrix $opa(A)$ by a vector $X$, updating vector $Y$.
       Computes $Y &lt;- beta Y + alpha * opa(A) * X $.
       It is not allowed to supply same Xp and Yp (that is, Xp==Yp).
        $opa( A )=A$ if transA=<b>RSB_TRANSPOSITION_N;</b>
        <b>$opa(</b> <b>A</b> <b>)=</b> <b>A</b> <b>^T$</b> <b>if</b> <b>transA=RSB_TRANSPOSITION_T;</b> <b>$opa(</b> <b>A</b>  <b>)=</b>  <b>A</b>  <b>^H$</b>  <b>if</b>  <b>transA=RSB_TRANSPOSITION_C;</b>  <b>If</b>
       <b>--enable-rsb-num-threads</b>  <b>has</b>  <b>been</b> <b>specified</b> <b>at</b> <b>configure</b> <b>time,</b> <b>the</b> <b>RSB_NUM_THREADS</b> <b>environment</b> <b>variable</b>
       <b>will</b>  <b>override</b>  <b>the</b>   <b>number</b>   <b>of</b>   <b>executing</b>   <b>threads</b>   <b>specified</b>   <b>by</b>   <b>OMP_NUM_THREADS.</b>   <b>(See</b>   <b>also</b>
       <b>RSB_IO_WANT_EXECUTING_THREADS).</b>
       <b>Parameters</b>
           <u>transA</u> Transposition parameter for $A$ (see <b>matrix_transposition_flags_section</b>).
           <u>alphap</u>  Optional  pointer  (if  NULL,  will  default  to 1) to a numerical value (of the same type as
           matrix).
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>Xp</u> The input vector array.
           <u>incX</u> Spacing of vector elements in each input vector array (&gt;=1).
           <u>betap</u> Optional pointer (if NULL, will default to 1) to a numerical value.
           <u>Yp</u> The output array vector.
           <u>incY</u> Spacing of vector elements in each output vector array (&gt;=1).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       Example snip:
               if((errval =
                       rsb_spmv(RSB_TRANSPOSITION_N,&amp;one,mtxAp,B,1,&amp;one,X,1))
                               != RSB_ERR_NO_ERROR )
               {
                       printf("Error performing a multiplication!\n");
                       goto err;
               }

       <b>Note</b>
           Starting  from  version  1.3,  librsb uses C++ kernels for <b>rsb_spmv</b>/<b>rsb_spmm</b>. Assuming you configured
           --enable-debug-getenvs, you may set environment variable RSB_WANT_RSBPP=0  to  turn  use  the  old  C
           kernels.
       <b>See</b> <b>also</b>
           <b>rsb_spmv</b>, <b>rsb_spmm</b>, <b>rsb_spata</b>, <b>rsb_tune_spmm</b>
   <b>struct</b>  <b>rsb_mtx_t</b>  <b>*</b>  <b>rsb_sppsp</b>  <b>(rsb_type_t</b>  <b>typecode,</b> <b>rsb_trans_t</b> <b>transA,</b> <b>const</b> <b>void</b> <b>*</b> <b>alphap,</b> <b>const</b> <b>struct</b>
       <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>rsb_trans_t</b> <b>transB,</b> <b>const</b> <b>void</b> <b>*</b> <b>betap,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b>  <b>mtxBp,</b>  <b>rsb_err_t</b>  <b>*</b>
       <b>errvalp)</b>
       Computes  the weighted sum of two sparse matrices, returning a new matrix: $C &lt;- alpha* transA(A) + beta*
       transB{B} $ Symmetry flags are ignored in this operation.
       $opa( A )=A$ if transA=<b>RSB_TRANSPOSITION_N;</b>
        <b>$opa(</b> <b>A</b> <b>)=</b> <b>A</b> <b>^T$</b> <b>if</b> <b>transA=RSB_TRANSPOSITION_T;</b> <b>$opa(</b> <b>A</b> <b>)=</b> <b>A</b> <b>^H$</b> <b>if</b> <b>transA=RSB_TRANSPOSITION_C;</b> <b>$opb(</b>  <b>B</b>
       <b>)=B$</b> <b>if</b> <b>transB=RSB_TRANSPOSITION_N;</b>
        <b>$opb(</b> <b>B</b> <b>)=</b> <b>B</b> <b>^T$</b> <b>if</b> <b>transB=RSB_TRANSPOSITION_T;</b> <b>$opb(</b> <b>B</b> <b>)=</b> <b>B</b> <b>^H$</b> <b>if</b> <b>transB=RSB_TRANSPOSITION_C;</b>
       <b>Parameters</b>
           <u>typecode</u>   A   valid   type   code   for   the   given   (numerical   array)   input   pointer   (see
           <b>matrix_type_symbols_section</b>).
           <u>transA</u> Transposition parameter for $A$ (see <b>matrix_transposition_flags_section</b>).
           <u>alphap</u> Optional pointer (if NULL, will default to 1) to a  numerical  value  (of  the  same  type  as
           matrix).
           <u>mtxAp</u> Valid rsb_mtx_t pointer to matrix $A$ representation.
           <u>transB</u> Transposition parameter for $B$ (see <b>matrix_transposition_flags_section</b>).
           <u>betap</u> Optional pointer (if NULL, will default to 1) to a numerical value.
           <u>mtxBp</u> Valid rsb_mtx_t pointer to matrix $B$ representation.
           <u>errvalp</u> An optional (can be NULL) pointer to <b>rsb_err_t</b> where the error status will be written to.
       <b>Returns</b>
           On  success,  a  valid pointer (struct rsb_mtx_t*) to the newly allocated matrix structure; on error,
           NULL.
       Example snip:
               const rsb_trans_t transA = RSB_TRANSPOSITION_N;
               const rsb_trans_t transB = RSB_TRANSPOSITION_N;
               RSB_DEFAULT_TYPE *alphap = NULL;
               RSB_DEFAULT_TYPE *betap = NULL;
               struct rsb_mtx_t * mtxCp = NULL;

               mtxCp = rsb_sppsp(typecode, transA, alphap, mtxAp,
                        transB, betap, mtxAp, &amp;errval);
               if( !mtxCp )
               {
                       printf("Error calling rsb_sppsp!\n");
                       goto err;
               }

               if(errval != RSB_ERR_NO_ERROR )
               {
                       printf("Error calling rsb_sppsp!\n");
                       goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_spmsp_to_dense</b>, <b>rsb_sppsp</b>, <b>rsb_spmsp</b>, <b>rsb_mtx_add_to_dense</b>
       <b>Warning</b>
           This function has not been thoroughly tested.
           This function is not optimized.
   <b>rsb_err_t</b> <b>rsb_spsm</b> <b>(rsb_trans_t</b> <b>transT,</b> <b>const</b> <b>void</b> <b>*</b> <b>alphap,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b>  <b>*</b>  <b>mtxTp,</b>  <b>rsb_coo_idx_t</b>
       <b>nrhs,</b> <b>rsb_flags_t</b> <b>order,</b> <b>const</b> <b>void</b> <b>*</b> <b>betap,</b> <b>const</b> <b>void</b> <b>*</b> <b>Bp,</b> <b>rsb_nnz_idx_t</b> <b>ldB,</b> <b>void</b> <b>*</b> <b>Cp,</b> <b>rsb_nnz_idx_t</b>
       <b>ldC)</b>
       Computes $Y &lt;- alpha * opt( T )^{-1} * B $, with upper or lower triangular $T$.
       $opt( T )=T$ if transT=<b>RSB_TRANSPOSITION_N;</b>
        <b>$opt(</b> <b>T</b> <b>)=</b> <b>T</b> <b>^T$</b> <b>if</b> <b>transT=RSB_TRANSPOSITION_T;</b> <b>$opt(</b> <b>T</b> <b>)=</b> <b>T</b> <b>^H$</b> <b>if</b> <b>transT=RSB_TRANSPOSITION_C;</b>
       <b>Parameters</b>
           <u>transT</u> Transposition parameter for $T$ (see <b>matrix_transposition_flags_section</b>).
           <u>alphap</u>  Optional  pointer  (if  NULL,  will  default  to 1) to a numerical value (of the same type as
           matrix).
           <u>mtxTp</u> Valid rsb_mtx_t pointer to matrix $T$ representation. The matrix must be triangular;  that  is,
           it must have been allocated with either <b>RSB_FLAG_LOWER_TRIANGULAR</b> or <b>RSB_FLAG_UPPER_TRIANGULAR</b> flags.
           <u>nrhs</u> The number of right hand side vectors (cannot be &lt;1).
           <u>order</u> A flag among <b>RSB_FLAG_WANT_COLUMN_MAJOR_ORDER</b> and <b>RSB_FLAG_WANT_ROW_MAJOR_ORDER</b>. For contiguous
           vector arrays, you probably want <b>RSB_FLAG_WANT_COLUMN_MAJOR_ORDER</b>.
           <u>betap</u> Optional pointer (if NULL, will default to 1) to a numerical value.
           <u>Bp</u> The input vector array.
           <u>ldB</u> Leading dimension of Bp array.
           <u>Cp</u> The output vector array.
           <u>ldC</u> Leading dimension of Cp array.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       <b>See</b> <b>also</b>
           <b>rsb_spsm</b>, <b>rsb_spsv</b>, <b>rsb_tune_spsm</b>
   <b>rsb_err_t</b> <b>rsb_spsv</b> <b>(rsb_trans_t</b> <b>transT,</b> <b>const</b> <b>void</b> <b>*</b> <b>alphap,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxTp,</b> <b>const</b> <b>void</b> <b>*</b> <b>Xp,</b>
       <b>rsb_coo_idx_t</b> <b>incX,</b> <b>void</b> <b>*</b> <b>Yp,</b> <b>rsb_coo_idx_t</b> <b>incY)</b>
       Computes $Y &lt;- alpha * opt( T )^{-1} * X $, with upper or lower triangular $T$. It is allowed  to  supply
       same Xp and Yp (that is, Xp==Yp).
       $opt( T )=T$ if transT=<b>RSB_TRANSPOSITION_N;</b>
        <b>$opt(</b> <b>T</b> <b>)=</b> <b>T</b> <b>^T$</b> <b>if</b> <b>transT=RSB_TRANSPOSITION_T;</b> <b>$opt(</b> <b>T</b> <b>)=</b> <b>T</b> <b>^H$</b> <b>if</b> <b>transT=RSB_TRANSPOSITION_C;</b>
       <b>Parameters</b>
           <u>transT</u> Transposition parameter for $T$ (see <b>matrix_transposition_flags_section</b>).
           <u>alphap</u>  Optional  pointer  (if  NULL,  will  default  to 1) to a numerical value (of the same type as
           matrix).
           <u>mtxTp</u> Valid rsb_mtx_t pointer to matrix $T$ representation. The matrix must be triangular;  that  is,
           it must have been allocated with either <b>RSB_FLAG_LOWER_TRIANGULAR</b> or <b>RSB_FLAG_UPPER_TRIANGULAR</b> flags.
           <u>Xp</u> The input vector array.
           <u>incX</u> Spacing of vector elements in each input vector array (&gt;=1).
           <u>Yp</u> The output array vector.
           <u>incY</u> Spacing of vector elements in each output vector array (&gt;=1).
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error. If  --enable-zero-division-checks-on-solve  was
           specified  at  configure  time,  attempts to solve a triangular matrix with zeroes on a diagonal will
           fail.
       Example backsolving a triangular system:
               if((errval = rsb_spsv(RSB_TRANSPOSITION_N,&amp;one,mtxAp,X,1,X,1))
                               != RSB_ERR_NO_ERROR )
               {
                       printf("Error performing triangular solve!\n");
                       goto err;
               }

       <b>See</b> <b>also</b>
           <b>rsb_spsm</b>, <b>rsb_spsv</b>, <b>rsb_tune_spsm</b>
   <b>rsb_err_t</b> <b>rsb_strerror_r</b> <b>(rsb_err_t</b> <b>errval,</b> <b>rsb_char_t</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>buflen)</b>
       Writes a textual description of an error code in  the  specified  string  buffer.  No  more  than  buflen
       characters  will be written (comprehensive of the terminating NUL character). No action will be performed
       on <b>RSB_ERR_NO_ERROR.</b>  <b>Notice</b>  <b>too</b>  <b>that</b>  <b>error</b>  <b>flags</b>  <b>cannot</b>  <b>be</b>  <b>added</b>  <b>in</b>  <b>the</b>  <b>way</b>  <b>flags</b>  <b>are</b>  <b>(e.g.</b>
       <b>(RSB_ERR_GENERIC_ERROR|RSB_ERR_BADARGS)</b> <b>evaluates</b> <b>to</b> <b>RSB_ERR_GENERIC_ERROR).</b>
       <b>Parameters</b>
           <u>errval</u> A valid error flag value (see <b>rsb_err_t</b>).
           <u>buf</u> A valid string buffer pointer where to write to.
           <u>buflen</u> The string buffer length.
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b>  on  correct  operation,  an  error  code otherwise. You can use <b>rsb_strerror_r()</b> or
           <b>rsb_perror()</b> to get more information about the error.
       Examples:
                               char errbuf[256];
                               rsb_strerror_r(errval,&amp;errbuf[0],sizeof(errbuf));
                               printf("Failed setting the"
                               " RSB_IO_WANT_EXTRA_VERBOSE_INTERFACE"
                               " library option (reason string:\n%s).\n",errbuf);

        or
               rsb_err_t errval = RSB_ERR_INTERNAL_ERROR;

               // ...

               if(errval != RSB_ERR_NO_ERROR)
               {
                       char errbuf[256];

                       rsb_strerror_r(errval,&amp;errbuf[0],sizeof(errbuf));

                       // error handling ...

       <b>See</b> <b>also</b>
           <b>rsb_perror</b>, <b>rsb_strerror_r</b>
   <b>rsb_time_t</b> <b>rsb_time</b> <b>(void)</b>
       Returns the current time in seconds. This function is meant to be used  for  computing  wall  clock  time
       intervals  (e.g.: for benchmarking purposes). The user should not rely on this function for absolute time
       computations.
       <b>Returns</b>
           A value for the current time, in seconds.
       <b>See</b> <b>also</b>
           <b>rsb_time</b>, <b>rsb_coo_sort</b>
   <b>rsb_err_t</b> <b>rsb_tune_spmm</b> <b>(struct</b> <b>rsb_mtx_t</b> <b>**</b> <b>mtxOpp,</b> <b>rsb_real_t</b> <b>*</b>  <b>sfp,</b>  <b>rsb_int_t</b>  <b>*</b>  <b>tnp,</b>  <b>rsb_int_t</b>  <b>maxr,</b>
       <b>rsb_time_t</b>  <b>maxt,</b>  <b>rsb_trans_t</b> <b>transA,</b> <b>const</b> <b>void</b> <b>*</b> <b>alphap,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>rsb_coo_idx_t</b>
       <b>nrhs,</b> <b>rsb_flags_t</b> <b>order,</b> <b>const</b> <b>void</b> <b>*</b> <b>Bp,</b> <b>rsb_nnz_idx_t</b> <b>ldB,</b> <b>const</b> <b>void</b> <b>*</b> <b>betap,</b> <b>void</b> <b>*</b> <b>Cp,</b> <b>rsb_nnz_idx_t</b>
       <b>ldC)</b>
       An auto-tuner: optimizes either the matrix instance, the thread count or both for the <b>rsb_spmm</b> operation.
       The tuner works by evaluating different instances and working threads variants. The instance  leading  to
       faster  operation  time  will  be  retained  and  given  back  to  the  user  in  *mtxOpp. If nrhs==1 and
       order==<b>RSB_FLAG_WANT_COLUMN_MAJOR_ORDER,</b> <b>unitary</b> <b>stride</b> <b>vectors</b>  <b>are</b>  <b>assumed.</b>  <b>In</b>  <b>case</b>  <b>of</b>  <b>error,</b>  <b>the</b>
       <b>original</b>  <b>input</b>  <b>matrix</b>  <b>shall</b>  <b>be</b>  <b>unaffected.</b> <b>It</b> <b>is</b> <b>possible</b> <b>to</b> <b>specify</b> <b>the</b> <b>leading</b> <b>dimensions</b> <b>of</b> <b>Bp,Cp</b>
       <b>implicitly,</b> <b>with</b> <b>ldB=0</b> <b>and</b> <b>ldC=0:</b> <b>in</b>  <b>this</b>  <b>case,</b>  <b>their</b>  <b>values</b>  <b>will</b>  <b>be</b>  <b>computed</b>  <b>internally</b>  <b>and</b>  <b>if</b>
       <b>Bp!=NULL,Cp!=NULL,</b>  <b>they</b> <b>will</b> <b>be</b> <b>assumed</b> <b>of</b> <b>being</b> <b>sufficiently</b> <b>sized.</b> <b>Values</b> <b>of</b> <b>nrhs&lt;1</b> <b>will</b> <b>be</b> <b>treated</b> <b>as</b>
       <b>1.</b> <b>Bp,</b> <b>Cp</b> <b>can</b> <b>be</b> <b>NULL:</b> <b>temporary</b> <b>vectors</b> <b>will</b> <b>be</b> <b>allocated,</b> <b>used,</b> <b>and</b> <b>deallocated</b> <b>within</b>  <b>the</b>  <b>tuner.</b>  <b>If</b>
       <b>mtxOpp=NULL</b>  <b>and</b>  <b>*tnp!=NULL</b>  <b>the</b>  <b>best</b> <b>thread</b> <b>count</b> <b>will</b> <b>be</b> <b>probed</b> <b>for</b> <b>the</b> <b>matrix</b> <b>given</b> <b>in</b> <b>mtxAp.</b> <b>Please</b>
       <b>note</b>  <b>that</b>   <b>if</b>   <b>threads-only</b>   <b>tuning</b>   <b>is</b>   <b>requested</b>   <b>and</b>   <b>matrix</b>   <b>has</b>   <b>too</b>   <b>few</b>   <b>leaves</b>   <b>(see</b>
       <b>RSB_MIF_LEAVES_COUNT__TO__RSB_BLK_INDEX_T),</b>  <b>tuning</b>  <b>will</b>  <b>not</b>  <b>work.</b>  <b>If</b>  <b>mtxAp==NULL,</b>  <b>then</b> <b>the</b> <b>*mtxOpp</b>
       <b>instance</b> <b>will</b> <b>be</b> <b>used;</b> <b>however</b> <b>in</b> <b>this</b> <b>case,</b> <b>if</b>  <b>a</b>  <b>better</b>  <b>instance</b>  <b>is</b>  <b>found,</b>  <b>the</b>  <b>original</b>  <b>will</b>  <b>be</b>
       <b>destroyed</b>  <b>as</b>  <b>with</b>  <b>rsb_mtx_free().</b>  <b>The</b> <b>case</b> <b>mtxAp!=NULL&amp;&amp;*mtxOpp!=NULL</b> <b>is</b> <b>illegal</b> <b>and</b> <b>will</b> <b>cause</b> <b>error</b>
       <b>code</b> <b>RSB_ERR_BADARGS</b> <b>to</b> <b>be</b> <b>returned.</b>
       <b>Parameters</b>
           <u>mtxOpp</u> Optimal matrix structure pointer will be assigned to *mtxOpp (it may occur that *mtxOpp==mtxAp
           on output). If mtxOpp is NULL then no data structure optimization will  be  attempted;  rather,  only
           optimal threads search will occur (tnp must be not NULL then).
           <u>sfp</u> Achieved speedup factor will be written to *sfp (unless sfp==NULL).
           <u>tnp</u> If tnp==NULL on input, the current thread count will be utilized. Otherwise, if *tnp&gt;0, then *tnp
           will be used as first suggestion in optimal thread count searching. If tnp!=NULL ,on output *tnp will
           be  set  to  contain  the optimal number of threads. Then, the user is expected to set this number of
           threads  using  e.g.:  <b>RSB_REINIT_SINGLE_VALUE_SET(RSB_IO_WANT_EXECUTING_THREADS,tnp,errval).</b>  <b>Please</b>
           <b>note</b> <b>that</b> <b>this</b> <b>will</b> <b>affect</b> <b>the</b> <b>whole</b> <b>library</b> <b>operation,</b> <b>not</b> <b>only</b> <b>this</b> <b>matrix.</b>
           <u>maxr</u> <b>Optimizer</b> <b>rounds</b> <b>max</b> <b>count.</b> <b>If</b> <b>&lt;1,</b> <b>will</b> <b>be</b> <b>treated</b> <b>as</b> <b>1;</b> <b>if</b> <b>0</b> <b>will</b> <b>be</b> <b>decided</b> <b>automatically.</b> <b>Max</b>
           <b>is</b> <b>RSB_CONST_MAX_TUNING_ROUNDS.</b>
           <u>maxt</u>  <b>Maximum</b> <b>time</b> <b>(in</b> <b>seconds)</b> <b>per</b> <b>optimization</b> <b>round</b> <b>(does</b> <b>not</b> <b>take</b> <b>in</b> <b>account</b> <b>conversion</b> <b>time).</b> <b>If</b>
           <b>maxt&lt;0.0</b> <b>is</b> <b>provided,</b> <b>-<a href="../manmaxt/ceil.maxt.html">ceil</a>(maxt)</b> <b>will</b> <b>be</b> <b>interpreted</b> <b>as</b> <b>number</b>  <b>of</b>  <b>iterations</b>  <b>to</b>  <b>check</b>  <b>for</b>  <b>each</b>
           <b>operation</b> <b>time</b> <b>sample.</b> <b>If</b> <b>maxt==0.0</b> <b>is</b> <b>provided,</b> <b>a</b> <b>default</b> <b>choice</b> <b>will</b> <b>be</b> <b>made</b> <b>instead.</b>
           <u>transA</u> <b>Transposition</b> <b>parameter</b> <b>for</b> <b>$A$</b> <b>(see</b> <b>matrix_transposition_flags_section).</b>
           <u>alphap</u>  <b>Optional</b>  <b>pointer</b>  <b>(if</b>  <b>NULL,</b>  <b>will</b>  <b>default</b>  <b>to</b> <b>1)</b> <b>to</b> <b>a</b> <b>numerical</b> <b>value</b> <b>(of</b> <b>the</b> <b>same</b> <b>type</b> <b>as</b>
           <b>matrix).</b>
           <u>mtxAp</u> <b>Valid</b> <b>rsb_mtx_t</b> <b>pointer</b> <b>to</b> <b>matrix</b> <b>$A$</b> <b>representation.</b>
           <u>nrhs</u> <b>The</b> <b>number</b> <b>of</b> <b>right</b> <b>hand</b> <b>side</b> <b>vectors</b> <b>(cannot</b> <b>be</b> <b>&lt;1).</b>
           <u>order</u> <b>A</b> <b>flag</b> <b>among</b> <b>RSB_FLAG_WANT_COLUMN_MAJOR_ORDER</b> <b>and</b> <b>RSB_FLAG_WANT_ROW_MAJOR_ORDER.</b> <b>For</b> <b>contiguous</b>
           <b>vector</b> <b>arrays,</b> <b>you</b> <b>probably</b> <b>want</b> <b>RSB_FLAG_WANT_COLUMN_MAJOR_ORDER.</b>
           <u>Bp</u> <b>The</b> <b>input</b> <b>vector</b> <b>array.</b> <b>If</b> <b>NULL,</b> <b>a</b> <b>temporary,</b> <b>internally</b> <b>allocated</b> <b>copy</b> <b>will</b> <b>be</b> <b>used.</b>
           <u>ldB</u> <b>Leading</b> <b>dimension</b> <b>of</b> <b>Bp</b> <b>array.</b>
           <u>betap</u> <b>Optional</b> <b>pointer</b> <b>(if</b> <b>NULL,</b> <b>will</b> <b>default</b> <b>to</b> <b>1)</b> <b>to</b> <b>a</b> <b>numerical</b> <b>value.</b>
           <u>Cp</u> <b>The</b> <b>output</b> <b>vector</b> <b>array.</b> <b>If</b> <b>NULL,</b> <b>a</b> <b>temporary,</b> <b>internally</b> <b>allocated</b> <b>copy</b> <b>will</b> <b>be</b> <b>used.</b>
           <u>ldC</u> <b>Leading</b> <b>dimension</b> <b>of</b> <b>Cp</b> <b>array.</b>
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
              Examples:
       // obtain best thread count for mtxAp:
       errval = rsb_tune_spmm(NULL  ,&amp;sf,&amp;tn ,maxr,maxt,transA,&amp;alpha,mtxAp,nrhs,order,Bp,ldB,&amp;beta,Cp,ldC);

       // obtain best thread count for mtxAp; Bp and Cp will be allocated by the tuner:
       errval = rsb_tune_spmm(NULL  ,&amp;sf,&amp;tn ,maxr,maxt,transA,&amp;alpha,mtxAp,nrhs,order,NULL,0,&amp;beta,NULL,0);

       // obtain best clone of mtxAp (for current thread count):
       assert(mtxOp == NULL &amp;&amp; mtxAp != NULL);
       errval = rsb_tune_spmm(&amp;mtxOp,&amp;sf,NULL,maxr,maxt,transA,&amp;alpha,mtxAp,nrhs,order,Bp,ldB,&amp;beta,Cp,ldC);

       // obtain best clone of mtxAp and best thread count:
       assert(mtxOp == NULL &amp;&amp; mtxAp != NULL);
       errval = rsb_tune_spmm(&amp;mtxOp,&amp;sf,&amp;tn ,maxr,maxt,transA,&amp;alpha,mtxAp,nrhs,order,Bp,ldB,&amp;beta,Cp,ldC);

       // replace mtxAp with best clone (if any):
       errval = rsb_tune_spmm(&amp;mtxAp,&amp;sf,NULL,maxr,maxt,transA,&amp;alpha,NULL ,nrhs,order,Bp,ldB,&amp;beta,Cp,ldC);

       // replace mtxAp with best clone (if any) and obtain best thread count:
       errval = rsb_tune_spmm(&amp;mtxAp,&amp;sf,&amp;tn ,maxr,maxt,transA,&amp;alpha,NULL ,nrhs,order,Bp,ldB,&amp;beta,Cp,ldC);

       // illegal call:
       assert(mtxOp != NULL &amp;&amp; mtxAp != NULL);
       errval = rsb_tune_spmm(&amp;mtxOp,&amp;sf,&amp;tn ,maxr,maxt,transA,&amp;alpha,mtxAp,nrhs,order,Bp,ldB,&amp;beta,Cp,ldC);

       <b>Warning</b>
           This  function  is still experimental. In case of error, although the matrix shall be unaffected, the
           library status may be affected (e.g.: execution thread count, default matrix subdivision).
       <b>Todo</b>
           Autotuning functionality is still object of much research. Need support for lightweight, threads-only
           optimization.
       Sample matrix sparse block structure before tuning
        Sample matrix sparse block structure after tuning
       <b>See</b> <b>also</b>
           <b>rsb_spmv</b>, <b>rsb_spmm</b>, <b>rsb_spata</b>, <b>rsb_tune_spmm</b>
   <b>rsb_err_t</b> <b>rsb_tune_spsm</b> <b>(struct</b> <b>rsb_mtx_t</b> <b>**</b> <b>mtxOpp,</b> <b>rsb_real_t</b> <b>*</b>  <b>sfp,</b>  <b>rsb_int_t</b>  <b>*</b>  <b>tnp,</b>  <b>rsb_int_t</b>  <b>maxr,</b>
       <b>rsb_time_t</b>  <b>maxt,</b>  <b>rsb_trans_t</b> <b>transA,</b> <b>const</b> <b>void</b> <b>*</b> <b>alphap,</b> <b>const</b> <b>struct</b> <b>rsb_mtx_t</b> <b>*</b> <b>mtxAp,</b> <b>rsb_coo_idx_t</b>
       <b>nrhs,</b> <b>rsb_flags_t</b> <b>order,</b> <b>const</b> <b>void</b> <b>*</b> <b>Bp,</b> <b>rsb_nnz_idx_t</b> <b>ldB,</b> <b>const</b> <b>void</b> <b>*</b> <b>betap,</b> <b>void</b> <b>*</b> <b>Cp,</b> <b>rsb_nnz_idx_t</b>
       <b>ldC)</b>
       An auto-tuner: optimizes either the matrix instance, the thread count or both for the <b>rsb_spsm</b> operation.
       The tuner works by evaluating different instances and working threads variants. The instance  leading  to
       faster  operation  time  will  be  retained  and  given  back  to  the  user  in  *mtxOpp. If nrhs==1 and
       order==<b>RSB_FLAG_WANT_COLUMN_MAJOR_ORDER,</b> <b>unitary</b> <b>stride</b> <b>vectors</b>  <b>are</b>  <b>assumed.</b>  <b>In</b>  <b>case</b>  <b>of</b>  <b>error,</b>  <b>the</b>
       <b>original</b>  <b>input</b>  <b>matrix</b>  <b>shall</b>  <b>be</b>  <b>unaffected.</b> <b>It</b> <b>is</b> <b>possible</b> <b>to</b> <b>specify</b> <b>the</b> <b>leading</b> <b>dimensions</b> <b>of</b> <b>Bp,Cp</b>
       <b>implicitly,</b> <b>with</b> <b>ldB=0</b> <b>and</b> <b>ldC=0:</b> <b>in</b>  <b>this</b>  <b>case,</b>  <b>their</b>  <b>values</b>  <b>will</b>  <b>be</b>  <b>computed</b>  <b>internally</b>  <b>and</b>  <b>if</b>
       <b>Bp!=NULL,Cp!=NULL,</b>  <b>they</b> <b>will</b> <b>be</b> <b>assumed</b> <b>of</b> <b>being</b> <b>sufficiently</b> <b>sized.</b> <b>Values</b> <b>of</b> <b>nrhs&lt;1</b> <b>will</b> <b>be</b> <b>treated</b> <b>as</b>
       <b>1.</b> <b>Bp,</b> <b>Cp</b> <b>can</b> <b>be</b> <b>NULL:</b> <b>temporary</b> <b>vectors</b> <b>will</b> <b>be</b> <b>allocated,</b> <b>used,</b> <b>and</b> <b>deallocated</b> <b>within</b>  <b>the</b>  <b>tuner.</b>  <b>If</b>
       <b>mtxOpp=NULL</b>  <b>and</b>  <b>*tnp!=NULL</b>  <b>the</b>  <b>best</b> <b>thread</b> <b>count</b> <b>will</b> <b>be</b> <b>probed</b> <b>for</b> <b>the</b> <b>matrix</b> <b>given</b> <b>in</b> <b>mtxAp.</b> <b>Please</b>
       <b>note</b>  <b>that</b>   <b>if</b>   <b>threads-only</b>   <b>tuning</b>   <b>is</b>   <b>requested</b>   <b>and</b>   <b>matrix</b>   <b>has</b>   <b>too</b>   <b>few</b>   <b>leaves</b>   <b>(see</b>
       <b>RSB_MIF_LEAVES_COUNT__TO__RSB_BLK_INDEX_T),</b>  <b>tuning</b>  <b>will</b>  <b>not</b>  <b>work.</b>  <b>If</b>  <b>mtxAp==NULL,</b>  <b>then</b> <b>the</b> <b>*mtxOpp</b>
       <b>instance</b> <b>will</b> <b>be</b> <b>used;</b> <b>however</b> <b>in</b> <b>this</b> <b>case,</b> <b>if</b>  <b>a</b>  <b>better</b>  <b>instance</b>  <b>is</b>  <b>found,</b>  <b>the</b>  <b>original</b>  <b>will</b>  <b>be</b>
       <b>destroyed</b>  <b>as</b>  <b>with</b>  <b>rsb_mtx_free().</b>  <b>The</b> <b>case</b> <b>mtxAp!=NULL&amp;&amp;*mtxOpp!=NULL</b> <b>is</b> <b>illegal</b> <b>and</b> <b>will</b> <b>cause</b> <b>error</b>
       <b>code</b> <b>RSB_ERR_BADARGS</b> <b>to</b> <b>be</b> <b>returned.</b>
       <b>Parameters</b>
           <u>mtxOpp</u> Optimal matrix structure pointer will be assigned to *mtxOpp (it may occur that *mtxOpp==mtxAp
           on output). If mtxOpp is NULL then no data structure optimization will  be  attempted;  rather,  only
           optimal threads search will occur (tnp must be not NULL then).
           <u>sfp</u> Achieved speedup factor will be written to *sfp (unless sfp==NULL).
           <u>tnp</u> If tnp==NULL on input, the current thread count will be utilized. Otherwise, if *tnp&gt;0, then *tnp
           will be used as first suggestion in optimal thread count searching. If tnp!=NULL ,on output *tnp will
           be  set  to  contain  the optimal number of threads. Then, the user is expected to set this number of
           threads  using  e.g.:  <b>RSB_REINIT_SINGLE_VALUE_SET(RSB_IO_WANT_EXECUTING_THREADS,tnp,errval).</b>  <b>Please</b>
           <b>note</b> <b>that</b> <b>this</b> <b>will</b> <b>affect</b> <b>the</b> <b>whole</b> <b>library</b> <b>operation,</b> <b>not</b> <b>only</b> <b>this</b> <b>matrix.</b>
           <u>maxr</u> <b>Optimizer</b> <b>rounds</b> <b>max</b> <b>count.</b> <b>If</b> <b>&lt;1,</b> <b>will</b> <b>be</b> <b>treated</b> <b>as</b> <b>1;</b> <b>if</b> <b>0</b> <b>will</b> <b>be</b> <b>decided</b> <b>automatically.</b> <b>Max</b>
           <b>is</b> <b>RSB_CONST_MAX_TUNING_ROUNDS.</b>
           <u>maxt</u>  <b>Maximum</b> <b>time</b> <b>(in</b> <b>seconds)</b> <b>per</b> <b>optimization</b> <b>round</b> <b>(does</b> <b>not</b> <b>take</b> <b>in</b> <b>account</b> <b>conversion</b> <b>time).</b> <b>If</b>
           <b>maxt&lt;0.0</b> <b>is</b> <b>provided,</b> <b>-<a href="../manmaxt/ceil.maxt.html">ceil</a>(maxt)</b> <b>will</b> <b>be</b> <b>interpreted</b> <b>as</b> <b>number</b>  <b>of</b>  <b>iterations</b>  <b>to</b>  <b>check</b>  <b>for</b>  <b>each</b>
           <b>operation</b> <b>time</b> <b>sample.</b> <b>If</b> <b>maxt==0.0</b> <b>is</b> <b>provided,</b> <b>a</b> <b>default</b> <b>choice</b> <b>will</b> <b>be</b> <b>made</b> <b>instead.</b>
           <u>transA</u> <b>Transposition</b> <b>parameter</b> <b>for</b> <b>$A$</b> <b>(see</b> <b>matrix_transposition_flags_section).</b>
           <u>alphap</u>  <b>Optional</b>  <b>pointer</b>  <b>(if</b>  <b>NULL,</b>  <b>will</b>  <b>default</b>  <b>to</b> <b>1)</b> <b>to</b> <b>a</b> <b>numerical</b> <b>value</b> <b>(of</b> <b>the</b> <b>same</b> <b>type</b> <b>as</b>
           <b>matrix).</b>
           <u>mtxAp</u> <b>Valid</b> <b>rsb_mtx_t</b> <b>pointer</b> <b>to</b> <b>matrix</b> <b>$A$</b> <b>representation.</b>
           <u>nrhs</u> <b>The</b> <b>number</b> <b>of</b> <b>right</b> <b>hand</b> <b>side</b> <b>vectors</b> <b>(cannot</b> <b>be</b> <b>&lt;1).</b>
           <u>order</u> <b>A</b> <b>flag</b> <b>among</b> <b>RSB_FLAG_WANT_COLUMN_MAJOR_ORDER</b> <b>and</b> <b>RSB_FLAG_WANT_ROW_MAJOR_ORDER.</b> <b>For</b> <b>contiguous</b>
           <b>vector</b> <b>arrays,</b> <b>you</b> <b>probably</b> <b>want</b> <b>RSB_FLAG_WANT_COLUMN_MAJOR_ORDER.</b>
           <u>Bp</u> <b>The</b> <b>input</b> <b>vector</b> <b>array.</b> <b>If</b> <b>NULL,</b> <b>a</b> <b>temporary,</b> <b>internally</b> <b>allocated</b> <b>copy</b> <b>will</b> <b>be</b> <b>used.</b>
           <u>ldB</u> <b>Leading</b> <b>dimension</b> <b>of</b> <b>Bp</b> <b>array.</b>
           <u>betap</u> <b>Optional</b> <b>pointer</b> <b>(if</b> <b>NULL,</b> <b>will</b> <b>default</b> <b>to</b> <b>1)</b> <b>to</b> <b>a</b> <b>numerical</b> <b>value.</b>
           <u>Cp</u> <b>The</b> <b>output</b> <b>vector</b> <b>array.</b> <b>If</b> <b>NULL,</b> <b>a</b> <b>temporary,</b> <b>internally</b> <b>allocated</b> <b>copy</b> <b>will</b> <b>be</b> <b>used.</b>
           <u>ldC</u> <b>Leading</b> <b>dimension</b> <b>of</b> <b>Cp</b> <b>array.</b>
       <b>Returns</b>
           <b>RSB_ERR_NO_ERROR</b> on correct operation, an error code  otherwise.  You  can  use  <b>rsb_strerror_r()</b>  or
           <b>rsb_perror()</b> to get more information about the error.
       If --enable-zero-division-checks-on-solve was specified at configure time, attempts to solve a triangular
       matrix with zeroes on a diagonal will fail.
       <b>Warning</b>
           This  function  is still experimental. In case of error, although the matrix shall be unaffected, the
           library status may be affected (e.g.: execution thread count, default matrix subdivision).
       <b>Todo</b>
           Autotuning functionality is still object of much research. Need support for lightweight, threads-only
           optimization.
       Sample matrix sparse block structure before tuning
        Sample matrix sparse block structure after tuning
       <b>See</b> <b>also</b>
           <b>rsb_spsm</b>, <b>rsb_spsv</b>, <b>rsb_tune_spsm</b>
           <b>rsb_tune_spmm</b>
</pre><h4><b>Author</b></h4><pre>
       librsb was written by Michele Martone; this documentation has been generated by Doxygen.
</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>rsb-examples</b> <b>rsb-spblas.h</b> <b>rsb.h</b> <b>rsb.hpp</b>

librsb                                           Version 1.3.0.2                                        <u><a href="../man3/rsb.h.3.html">rsb.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>