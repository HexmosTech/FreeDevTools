<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cerl - Core Erlang abstract syntax trees.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cerl - Core Erlang abstract syntax trees.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Core Erlang abstract syntax trees.

       This module defines an abstract data type for representing Core Erlang source code as syntax trees.

       A recommended starting point for the first-time user is the documentation of the function type/1.

       <u>NOTES:</u>

       This  module  deals  with the composition and decomposition of <u>syntactic</u> entities (as opposed to semantic
       ones); its purpose is to hide all direct references to  the  data  structures  used  to  represent  these
       entities.  With  few exceptions, the functions in this module perform no semantic interpretation of their
       inputs, and in general, the user is assumed to pass type-correct arguments - if this  is  not  done,  the
       effects are not defined.

       Currently,  the  internal  data  structure  used  is  the  same  as the record-based data structures used
       traditionally in the Beam compiler.

       The internal representations of abstract syntax trees are subject to change without  notice,  and  should
       not  be  documented  outside  this  module. Furthermore, we do not give any guarantees on how an abstract
       syntax tree may or may not be represented, <u>with</u> <u>the</u> <u>following</u> <u>exceptions</u>: no syntax tree  is  represented
       by  a  single  atom,  such  as  <u>none</u>, by a list constructor <u>[X</u> <u>|</u> <u>Y]</u>, or by the empty list <u>[]</u>. This can be
       relied on when writing functions that operate on syntax trees.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <b>c_alias()</b> <b>=</b> <b>#c_alias{}:</b>

         <b>c_apply()</b> <b>=</b> <b>#c_apply{}:</b>

         <b>c_binary()</b> <b>=</b> <b>#c_binary{}:</b>

         <b>c_bitstr()</b> <b>=</b> <b>#c_bitstr{}:</b>

         <b>c_call()</b> <b>=</b> <b>#c_call{}:</b>

         <b>c_case()</b> <b>=</b> <b>#c_case{}:</b>

         <b>c_catch()</b> <b>=</b> <b>#c_catch{}:</b>

         <b>c_clause()</b> <b>=</b> <b>#c_clause{}:</b>

         <b>c_cons()</b> <b>=</b> <b>#c_cons{}:</b>

         <b>c_fun()</b> <b>=</b> <b>#c_fun{}:</b>

         <b>c_lct()</b> <b>=</b> <b>c_literal()</b> <b>|</b> <b>c_cons()</b> <b>|</b> <b>c_tuple():</b>

         <b>c_let()</b> <b>=</b> <b>#c_let{}:</b>

         <b>c_letrec()</b> <b>=</b> <b>#c_letrec{}:</b>

         <b>c_literal()</b> <b>=</b> <b>#c_literal{}:</b>

         <b>c_map()</b> <b>=</b> <b>#c_map{}:</b>

         <b>c_map_pair()</b> <b>=</b> <b>#c_map_pair{}:</b>

         <b>c_module()</b> <b>=</b> <b>#c_module{}:</b>

         <b>c_primop()</b> <b>=</b> <b>#c_primop{}:</b>

         <b>c_receive()</b> <b>=</b> <b>#c_receive{}:</b>

         <b>c_seq()</b> <b>=</b> <b>#c_seq{}:</b>

         <b>c_try()</b> <b>=</b> <b>#c_try{}:</b>

         <b>c_tuple()</b> <b>=</b> <b>#c_tuple{}:</b>

         <b>c_values()</b> <b>=</b> <b>#c_values{}:</b>

         <b>c_var()</b> <b>=</b> <b>#c_var{}:</b>

         <b>cerl()</b> <b>=</b> <b>c_alias()</b> <b>|</b> <b>c_apply()</b> <b>|</b> <b>c_binary()</b> <b>|</b> <b>c_bitstr()</b> <b>|</b> <b>c_call()</b> <b>|</b> <b>c_case()</b> <b>|</b> <b>c_catch()</b> <b>|</b> <b>c_clause()</b>
         <b>|</b> <b>c_cons()</b> <b>|</b> <b>c_fun()</b> <b>|</b> <b>c_let()</b> <b>|</b> <b>c_letrec()</b> <b>|</b> <b>c_literal()</b> <b>|</b> <b>c_map()</b> <b>|</b> <b>c_map_pair()</b> <b>|</b> <b>c_module()</b> <b>|</b>
         <b>c_primop()</b> <b>|</b> <b>c_receive()</b> <b>|</b> <b>c_seq()</b> <b>|</b> <b>c_try()</b> <b>|</b> <b>c_tuple()</b> <b>|</b> <b>c_values()</b> <b>|</b> <b>c_var():</b>

         <b>ctype()</b> <b>=</b> <b>alias</b> <b>|</b> <b>apply</b> <b>|</b> <b>binary</b> <b>|</b> <b>bitstr</b> <b>|</b> <b>call</b> <b>|</b> <b>case</b> <b>|</b> <b>catch</b> <b>|</b> <b>clause</b> <b>|</b> <b>cons</b> <b>|</b> <b>fun</b> <b>|</b> <b>let</b> <b>|</b> <b>letrec</b> <b>|</b>
         <b>literal</b> <b>|</b> <b>map</b> <b>|</b> <b>map_pair</b> <b>|</b> <b>module</b> <b>|</b> <b>primop</b> <b>|</b> <b>receive</b> <b>|</b> <b>seq</b> <b>|</b> <b>try</b> <b>|</b> <b>tuple</b> <b>|</b> <b>values</b> <b>|</b> <b>var:</b>

         <b>dtype()</b> <b>=</b> <b>cons</b> <b>|</b> <b>tuple</b> <b>|</b> <b>{atomic,</b> <b>value()}:</b>

         <b>map_op()</b> <b>=</b> <b>#c_literal{val=assoc}</b> <b>|</b> <b>#c_literal{val=exact}:</b>

         <b>value()</b> <b>=</b> <b>integer()</b> <b>|</b> <b>float()</b> <b>|</b> <b>atom()</b> <b>|</b> <b>[]:</b>

         <b>var_name()</b> <b>=</b> <b>integer()</b> <b>|</b> <b>atom()</b> <b>|</b> <b>{atom(),</b> <b>integer()}:</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>abstract(T::term())</b> <b>-&gt;</b> <b>c_literal()</b>

              Creates a syntax tree corresponding to an Erlang term. <u>Term</u> must be a literal term, i.e., one that
              can be represented as a source code literal. Thus, it may not contain a process identifier,  port,
              reference, binary or function value as a subterm.

              Note: This is a constant time operation.

              <u>See</u> <u>also:</u> ann_abstract/2, concrete/1, is_literal/1, is_literal_term/1.

       <b>add_ann(Terms::[term()],</b> <b>Node::cerl())</b> <b>-&gt;</b> <b>cerl()</b>

              Appends <u>Annotations</u> to the list of user annotations of <u>Node</u>.

              Note:  this  is  equivalent  to  <u>set_ann(Node,</u> <u>Annotations</u> <u>++</u> <u>get_ann(Node))</u>, but potentially more
              efficient.

              <u>See</u> <u>also:</u> get_ann/1, set_ann/2.

       <b>alias_pat(Node::c_alias())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the pattern subtree of an abstract pattern alias.

              <u>See</u> <u>also:</u> c_alias/2.

       <b>alias_var(Node::c_alias())</b> <b>-&gt;</b> <b>c_var()</b>

              Returns the variable subtree of an abstract pattern alias.

              <u>See</u> <u>also:</u> c_alias/2.

       <b>ann_abstract(As::[term()],</b> <b>T::term())</b> <b>-&gt;</b> <b>c_literal()</b>

              <u>See</u> <u>also:</u> abstract/1.

       <b>ann_c_alias(As::[term()],</b> <b>Var::c_var(),</b> <b>Pattern::cerl())</b> <b>-&gt;</b> <b>c_alias()</b>

              <u>See</u> <u>also:</u> c_alias/2.

       <b>ann_c_apply(As::[term()],</b> <b>Operator::cerl(),</b> <b>Arguments::[cerl()])</b> <b>-&gt;</b> <b>c_apply()</b>

              <u>See</u> <u>also:</u> c_apply/2.

       <b>ann_c_atom(As::[term()],</b> <b>Name::atom()</b> <b>|</b> <b>string())</b> <b>-&gt;</b> <b>c_literal()</b>

              <u>See</u> <u>also:</u> c_atom/1.

       <b>ann_c_binary(As::[term()],</b> <b>Segments::[cerl()])</b> <b>-&gt;</b> <b>c_binary()</b>

              <u>See</u> <u>also:</u> c_binary/1.

       <b>ann_c_bitstr(As::[term()],</b> <b>Value::cerl(),</b> <b>Size::cerl(),</b> <b>Type::cerl(),</b> <b>Flags::cerl())</b> <b>-&gt;</b> <b>c_bitstr()</b>

              Equivalent to ann_c_bitstr(As, Value, Size, <a href="../man1/abstract.1.html">abstract</a>(1), Type, Flags).

       <b>ann_c_bitstr(As::[term()],</b>  <b>Val::cerl(),</b>  <b>Size::cerl(),</b>  <b>Unit::cerl(),</b>  <b>Type::cerl(),</b>  <b>Flags::cerl())</b>  <b>-&gt;</b>
       <b>c_bitstr()</b>

              <u>See</u> <u>also:</u> ann_c_bitstr/5, c_bitstr/5.

       <b>ann_c_call(As::[term()],</b> <b>Module::cerl(),</b> <b>Name::cerl(),</b> <b>Arguments::[cerl()])</b> <b>-&gt;</b> <b>c_call()</b>

              <u>See</u> <u>also:</u> c_call/3.

       <b>ann_c_case(As::[term()],</b> <b>Expr::cerl(),</b> <b>Clauses::[cerl()])</b> <b>-&gt;</b> <b>c_case()</b>

              <u>See</u> <u>also:</u> c_case/2.

       <b>ann_c_catch(As::[term()],</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_catch()</b>

              <u>See</u> <u>also:</u> c_catch/1.

       <b>ann_c_char(As::[term()],</b> <b>Value::char())</b> <b>-&gt;</b> <b>c_literal()</b>

              <u>See</u> <u>also:</u> c_char/1.

       <b>ann_c_clause(As::[term()],</b> <b>Patterns::[cerl()],</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_clause()</b>

              Equivalent to ann_c_clause(As, Patterns, c_atom(true), Body).

              <u>See</u> <u>also:</u> c_clause/3.

       <b>ann_c_clause(As::[term()],</b> <b>Patterns::[cerl()],</b> <b>Guard::cerl(),</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_clause()</b>

              <u>See</u> <u>also:</u> ann_c_clause/3, c_clause/3.

       <b>ann_c_cons(As::[term()],</b> <b>C_literal::cerl(),</b> <b>Tail::cerl())</b> <b>-&gt;</b> <b>c_literal()</b> <b>|</b> <b>c_cons()</b>

              <u>See</u> <u>also:</u> c_cons/2.

       <b>ann_c_cons_skel(As::[term()],</b> <b>Head::cerl(),</b> <b>Tail::cerl())</b> <b>-&gt;</b> <b>c_cons()</b>

              <u>See</u> <u>also:</u> c_cons_skel/2.

       <b>ann_c_float(As::[term()],</b> <b>Value::float())</b> <b>-&gt;</b> <b>c_literal()</b>

              <u>See</u> <u>also:</u> c_float/1.

       <b>ann_c_fname(As::[term()],</b> <b>Atom::atom(),</b> <b>Arity::arity())</b> <b>-&gt;</b> <b>c_var()</b>

              Equivalent to ann_c_var(As, {Atom, Arity}).

              <u>See</u> <u>also:</u> c_fname/2.

       <b>ann_c_fun(As::[term()],</b> <b>Variables::[cerl()],</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_fun()</b>

              <u>See</u> <u>also:</u> c_fun/2.

       <b>ann_c_int(As::[term()],</b> <b>Value::integer())</b> <b>-&gt;</b> <b>c_literal()</b>

              <u>See</u> <u>also:</u> c_int/1.

       <b>ann_c_let(As::[term()],</b> <b>Variables::[cerl()],</b> <b>Argument::cerl(),</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_let()</b>

              <u>See</u> <u>also:</u> c_let/3.

       <b>ann_c_letrec(As::[term()],</b> <b>Defs::[{cerl(),</b> <b>cerl()}],</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_letrec()</b>

              <u>See</u> <u>also:</u> c_letrec/2.

       <b>ann_c_map(As::[term()],</b> <b>Es::[c_map_pair()])</b> <b>-&gt;</b> <b>c_map()</b> <b>|</b> <b>c_literal()</b>

       <b>ann_c_map(As::[term()],</b> <b>C_literal::c_map()</b> <b>|</b> <b>c_literal(),</b> <b>Es::[c_map_pair()])</b> <b>-&gt;</b> <b>c_map()</b> <b>|</b> <b>c_literal()</b>

       <b>ann_c_map_pair(As::[term()],</b> <b>Op::cerl(),</b> <b>K::cerl(),</b> <b>V::cerl())</b> <b>-&gt;</b> <b>c_map_pair()</b>

       <b>ann_c_map_pattern(As::[term()],</b> <b>Pairs::[c_map_pair()])</b> <b>-&gt;</b> <b>c_map()</b>

       <b>ann_c_module(As::[term()],</b> <b>Name::cerl(),</b> <b>Exports::[cerl()],</b> <b>Es::[{cerl(),</b> <b>cerl()}])</b> <b>-&gt;</b> <b>c_module()</b>

              <u>See</u> <u>also:</u> ann_c_module/5, c_module/3.

       <b>ann_c_module(As::[term()],</b>  <b>Name::cerl(),</b>  <b>Exports::[cerl()],</b>  <b>Attrs::[{cerl(),</b>  <b>cerl()}],</b>  <b>Es::[{cerl(),</b>
       <b>cerl()}])</b> <b>-&gt;</b> <b>c_module()</b>

              <u>See</u> <u>also:</u> ann_c_module/4, c_module/4.

       <b>ann_c_nil(As::[term()])</b> <b>-&gt;</b> <b>c_literal()</b>

              <u>See</u> <u>also:</u> c_nil/0.

       <b>ann_c_primop(As::[term()],</b> <b>Name::cerl(),</b> <b>Arguments::[cerl()])</b> <b>-&gt;</b> <b>c_primop()</b>

              <u>See</u> <u>also:</u> c_primop/2.

       <b>ann_c_receive(As::[term()],</b> <b>Clauses::[cerl()])</b> <b>-&gt;</b> <b>c_receive()</b>

              Equivalent to ann_c_receive(As, Clauses, c_atom(infinity), c_atom(true)).

              <u>See</u> <u>also:</u> c_atom/1, c_receive/3.

       <b>ann_c_receive(As::[term()],</b> <b>Clauses::[cerl()],</b> <b>Timeout::cerl(),</b> <b>Action::cerl())</b> <b>-&gt;</b> <b>c_receive()</b>

              <u>See</u> <u>also:</u> ann_c_receive/2, c_receive/3.

       <b>ann_c_seq(As::[term()],</b> <b>Argument::cerl(),</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_seq()</b>

              <u>See</u> <u>also:</u> c_seq/2.

       <b>ann_c_string(As::[term()],</b> <b>Value::string())</b> <b>-&gt;</b> <b>c_literal()</b>

              <u>See</u> <u>also:</u> c_string/1.

       <b>ann_c_try(As::[term()],</b> <b>Expr::cerl(),</b>  <b>Vs::[cerl()],</b>  <b>Body::cerl(),</b>  <b>Evs::[cerl()],</b>  <b>Handler::cerl())</b>  <b>-&gt;</b>
       <b>c_try()</b>

              <u>See</u> <u>also:</u> c_try/5.

       <b>ann_c_tuple(As::[term()],</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_tuple()</b> <b>|</b> <b>c_literal()</b>

              <u>See</u> <u>also:</u> c_tuple/1.

       <b>ann_c_tuple_skel(As::[term()],</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_tuple()</b>

              <u>See</u> <u>also:</u> c_tuple_skel/1.

       <b>ann_c_values(As::[term()],</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_values()</b>

              <u>See</u> <u>also:</u> c_values/1.

       <b>ann_c_var(As::[term()],</b> <b>Name::var_name())</b> <b>-&gt;</b> <b>c_var()</b>

              <u>See</u> <u>also:</u> c_var/1.

       <b>ann_make_data(As::[term()],</b> <b>X2::dtype(),</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_lct()</b>

              <u>See</u> <u>also:</u> make_data/2.

       <b>ann_make_data_skel(As::[term()],</b> <b>X2::dtype(),</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_lct()</b>

              <u>See</u> <u>also:</u> make_data_skel/2.

       <b>ann_make_list(As::[term()],</b> <b>List::[cerl()])</b> <b>-&gt;</b> <b>cerl()</b>

              Equivalent to ann_make_list(As, List, none).

       <b>ann_make_list(As::[term()],</b> <b>T::[cerl()],</b> <b>Tail::cerl()</b> <b>|</b> <b>none)</b> <b>-&gt;</b> <b>cerl()</b>

              <u>See</u> <u>also:</u> ann_make_list/2, make_list/2.

       <b>ann_make_tree(As::[term()],</b> <b>X2::ctype(),</b> <b>X3::[[cerl()],</b> <b>...])</b> <b>-&gt;</b> <b>cerl()</b>

              Creates a syntax tree with the given annotations, type and subtrees. See <u>make_tree/2</u> for details.

              <u>See</u> <u>also:</u> make_tree/2.

       <b>apply_args(Node::c_apply())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of argument subtrees of an abstract function application.

              <u>See</u> <u>also:</u> apply_arity/1, c_apply/2.

       <b>apply_arity(Node::c_apply())</b> <b>-&gt;</b> <b>arity()</b>

              Returns the number of argument subtrees of an abstract function application.

              Note: this is equivalent to <u>length(apply_args(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> apply_args/1, c_apply/2.

       <b>apply_op(Node::c_apply())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the operator subtree of an abstract function application.

              <u>See</u> <u>also:</u> c_apply/2.

       <b>atom_lit(Node::cerl())</b> <b>-&gt;</b> <b>nonempty_string()</b>

              Returns  the  literal  string  represented  by  an abstract atom. This always includes surrounding
              single-quote characters.

              Note that an abstract atom may have several literal representations, and that  the  representation
              yielded  by  this  function  is not fixed; e.g., <u>atom_lit(c_atom("a\012b"))</u> could yield the string
              <u>"\'a\\nb\'"</u>.

              <u>See</u> <u>also:</u> c_atom/1.

       <b>atom_name(Node::c_literal())</b> <b>-&gt;</b> <b>string()</b>

              Returns the printname of an abstract atom.

              <u>See</u> <u>also:</u> c_atom/1.

       <b>atom_val(Node::c_literal())</b> <b>-&gt;</b> <b>atom()</b>

              Returns the value represented by an abstract atom.

              <u>See</u> <u>also:</u> c_atom/1.

       <b>binary_segments(Node::c_binary())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of segment subtrees of an abstract binary-template.

              <u>See</u> <u>also:</u> c_binary/1, c_bitstr/5.

       <b>bitstr_bitsize(Node::c_bitstr())</b> <b>-&gt;</b> <b>all</b> <b>|</b> <b>any</b> <b>|</b> <b>utf</b> <b>|</b> <b>non_neg_integer()</b>

              Returns the total size in bits of an abstract bit-string template. If the size field is an integer
              literal, the result is the product of the size and unit values; if the  size  field  is  the  atom
              literal <u>all</u>, the atom <u>all</u> is returned. If the size is not a literal, the atom <u>any</u> is returned.

              <u>See</u> <u>also:</u> c_bitstr/5.

       <b>bitstr_flags(Node::c_bitstr())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the flags subtree of an abstract bit-string template.

              <u>See</u> <u>also:</u> c_bitstr/5.

       <b>bitstr_size(Node::c_bitstr())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the size subtree of an abstract bit-string template.

              <u>See</u> <u>also:</u> c_bitstr/5.

       <b>bitstr_type(Node::c_bitstr())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the type subtree of an abstract bit-string template.

              <u>See</u> <u>also:</u> c_bitstr/5.

       <b>bitstr_unit(Node::c_bitstr())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the unit subtree of an abstract bit-string template.

              <u>See</u> <u>also:</u> c_bitstr/5.

       <b>bitstr_val(Node::c_bitstr())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the value subtree of an abstract bit-string template.

              <u>See</u> <u>also:</u> c_bitstr/5.

       <b>c_alias(Var::c_var(),</b> <b>Pattern::cerl())</b> <b>-&gt;</b> <b>c_alias()</b>

              Creates an abstract pattern alias. The result represents "<u>Variable</u> <u>=</u> <u>Pattern</u>".

              <u>See</u> <u>also:</u> alias_pat/1, alias_var/1, ann_c_alias/3, c_clause/3, is_c_alias/1, update_c_alias/3.

       <b>c_apply(Operator::cerl(),</b> <b>Arguments::[cerl()])</b> <b>-&gt;</b> <b>c_apply()</b>

              Creates  an  abstract  function  application. If <u>Arguments</u> is <u>[A1,</u> <u>...,</u> <u>An]</u>, the result represents
              "<u>apply</u> <u>Operator(A1,</u> <u>...,</u> <u>An)</u>".

              <u>See</u>  <u>also:</u>  ann_c_apply/3,  apply_args/1,   apply_arity/1,   apply_op/1,   c_call/3,   c_primop/2,
              is_c_apply/1, update_c_apply/3.

       <b>c_atom(Name::atom()</b> <b>|</b> <b>string())</b> <b>-&gt;</b> <b>c_literal()</b>

              Creates an abstract atom literal. The print name of the atom is the character sequence represented
              by <u>Name</u>.

              Note:  passing a string as argument to this function causes a corresponding atom to be created for
              the internal representation.

              <u>See</u> <u>also:</u> ann_c_atom/2, atom_lit/1, atom_name/1, atom_val/1, is_c_atom/1.

       <b>c_binary(Segments::[cerl()])</b> <b>-&gt;</b> <b>c_binary()</b>

              Creates an abstract binary-template. A binary object is in this context a sequence of an arbitrary
              number of bits. (The number of bits used to be evenly divisible by 8, but after  the  introduction
              of  bit strings in the Erlang language, the choice was made to use the binary template for all bit
              strings.) It is specified by zero or more bit-string template <u>segments</u> of  arbitrary  lengths  (in
              number of bits). If <u>Segments</u> is <u>[S1,</u> <u>...,</u> <u>Sn]</u>, the result represents "<u>#{S1,</u> <u>...,</u> <u>Sn}#</u>". All the <u>Si</u>
              must have type <u>bitstr</u>.

              <u>See</u> <u>also:</u> ann_c_binary/2, binary_segments/1, c_bitstr/5, is_c_binary/1, update_c_binary/2.

       <b>c_bitstr(Val::cerl(),</b> <b>Type::cerl(),</b> <b>Flags::cerl())</b> <b>-&gt;</b> <b>c_bitstr()</b>

              Equivalent to c_bitstr(Value, abstract(all), <a href="../man1/abstract.1.html">abstract</a>(1), Type, Flags).

       <b>c_bitstr(Val::cerl(),</b> <b>Size::cerl(),</b> <b>Type::cerl(),</b> <b>Flags::cerl())</b> <b>-&gt;</b> <b>c_bitstr()</b>

              Equivalent to c_bitstr(Value, Size, <a href="../man1/abstract.1.html">abstract</a>(1), Type, Flags).

       <b>c_bitstr(Val::cerl(),</b> <b>Size::cerl(),</b> <b>Unit::cerl(),</b> <b>Type::cerl(),</b> <b>Flags::cerl())</b> <b>-&gt;</b> <b>c_bitstr()</b>

              Creates an abstract bit-string template. These can only occur as components of an abstract binary-
              template  (see  c_binary/1). The result represents "<u>#&lt;Value&gt;(Size,</u> <u>Unit,</u> <u>Type,</u> <u>Flags)</u>", where <u>Unit</u>
              must represent a positive integer constant, <u>Type</u> must represent a constant atom (one of <u>'integer'</u>,
              <u>'float'</u>, or <u>'binary'</u>), and <u>Flags</u> must represent a constant list <u>"[F1,</u> <u>...,</u> <u>Fn]"</u> where all  the  <u>Fi</u>
              are atoms.

              <u>See</u>   <u>also:</u>   ann_c_bitstr/6,   bitstr_flags/1,   bitstr_size/1,   bitstr_type/1,   bitstr_unit/1,
              bitstr_val/1, c_binary/1, is_c_bitstr/1, update_c_bitstr/6.

       <b>c_call(Module::cerl(),</b> <b>Name::cerl(),</b> <b>Arguments::[cerl()])</b> <b>-&gt;</b> <b>c_call()</b>

              Creates an abstract inter-module call. If <u>Arguments</u> is <u>[A1,</u> <u>...,</u> <u>An]</u>, the result represents  "<u>call</u>
              <u>Module:Name(A1,</u> <u>...,</u> <u>An)</u>".

              <u>See</u>   <u>also:</u>   ann_c_call/4,   c_apply/2,  c_primop/2,  call_args/1,  call_arity/1,  call_module/1,
              call_name/1, is_c_call/1, update_c_call/4.

       <b>c_case(Expr::cerl(),</b> <b>Clauses::[cerl()])</b> <b>-&gt;</b> <b>c_case()</b>

              Creates an abstract case-expression. If <u>Clauses</u> is <u>[C1,</u> <u>...,</u>  <u>Cn]</u>,  the  result  represents  "<u>case</u>
              <u>Argument</u> <u>of</u> <u>C1</u> <u>...</u> <u>Cn</u> <u>end</u>". <u>Clauses</u> must not be empty.

              <u>See</u>   <u>also:</u>  ann_c_case/3,  c_clause/3,  case_arg/1,  case_arity/1,  case_clauses/1,  is_c_case/1,
              update_c_case/3.

       <b>c_catch(Body::cerl())</b> <b>-&gt;</b> <b>c_catch()</b>

              Creates an abstract catch-expression. The result represents "<u>catch</u> <u>Body</u>".

              Note: catch-expressions can be rewritten as try-expressions, and will eventually be  removed  from
              Core Erlang.

              <u>See</u> <u>also:</u> ann_c_catch/2, c_try/5, catch_body/1, is_c_catch/1, update_c_catch/2.

       <b>c_char(Value::non_neg_integer())</b> <b>-&gt;</b> <b>c_literal()</b>

              Creates  an  abstract character literal. If the local implementation of Erlang defines <u>char()</u> as a
              subset of <u>integer()</u>, this function is equivalent to <u>c_int/1</u>. Otherwise, if the given value  is  an
              integer,  it  will  be  converted  to  the  character  with  the  corresponding  code. The lexical
              representation of a character is "<u>$Char</u>", where <u>Char</u> is a single printing character or  an  escape
              sequence.

              <u>See</u> <u>also:</u> ann_c_char/2, c_int/1, c_string/1, char_lit/1, char_val/1, is_c_char/1, is_print_char/1.

       <b>c_clause(Patterns::[cerl()],</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_clause()</b>

              Equivalent to c_clause(Patterns, c_atom(true), Body).

              <u>See</u> <u>also:</u> c_atom/1.

       <b>c_clause(Patterns::[cerl()],</b> <b>Guard::cerl(),</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_clause()</b>

              Creates  an an abstract clause. If <u>Patterns</u> is <u>[P1,</u> <u>...,</u> <u>Pn]</u>, the result represents "<u>&lt;P1,</u> <u>...,</u> <u>Pn&gt;</u>
              <u>when</u> <u>Guard</u> <u>-&gt;</u> <u>Body</u>".

              <u>See</u>  <u>also:</u>  ann_c_clause/4,  c_case/2,  c_clause/2,  c_receive/3,  clause_arity/1,  clause_body/1,
              clause_guard/1, clause_pats/1, clause_vars/1, is_c_clause/1, update_c_clause/4.

       <b>c_cons(C_literal::cerl(),</b> <b>Tail::cerl())</b> <b>-&gt;</b> <b>c_literal()</b> <b>|</b> <b>c_cons()</b>

              Creates  an  abstract  list  constructor. The result represents "<u>[Head</u> <u>|</u> <u>Tail]</u>". Note that if both
              <u>Head</u> and <u>Tail</u> have type <u>literal</u>, then the result will also have type <u>literal</u>, and  annotations  on
              <u>Head</u> and <u>Tail</u> are lost.

              Recall that in Erlang, the tail element of a list constructor is not necessarily a list.

              <u>See</u>  <u>also:</u>  ann_c_cons/3,  c_cons_skel/2, c_nil/0, cons_hd/1, cons_tl/1, is_c_cons/1, is_c_list/1,
              list_elements/1, list_length/1, make_list/2, update_c_cons/3.

       <b>c_cons_skel(Head::cerl(),</b> <b>Tail::cerl())</b> <b>-&gt;</b> <b>c_cons()</b>

              Creates an abstract list constructor skeleton. Does not fold constant literals, i.e.,  the  result
              always has type <u>cons</u>, representing "<u>[Head</u> <u>|</u> <u>Tail]</u>".

              This function is occasionally useful when it is necessary to have annotations on the subnodes of a
              list  constructor  node,  even  when  the  subnodes  are  constant  literals.  Note  however  that
              <u>is_literal/1</u> will yield <u>false</u> and <u>concrete/1</u> will fail if passed the result from this function.

              <u>fold_literal/1</u> can be used to revert a node to the normal-form representation.

              <u>See</u>  <u>also:</u>  ann_c_cons_skel/3,  c_cons/2,  c_nil/0,   concrete/1,   fold_literal/1,   is_c_cons/1,
              is_c_list/1, is_literal/1, update_c_cons_skel/3.

       <b>c_float(Value::float())</b> <b>-&gt;</b> <b>c_literal()</b>

              Creates  an  abstract  floating-point literal. The lexical representation is the decimal floating-
              point numeral of <u>Value</u>.

              <u>See</u> <u>also:</u> ann_c_float/2, float_lit/1, float_val/1, is_c_float/1.

       <b>c_fname(Atom::atom(),</b> <b>Arity::arity())</b> <b>-&gt;</b> <b>c_var()</b>

              Equivalent to c_var({Name, Arity}).

              <u>See</u> <u>also:</u> ann_c_fname/3, fname_arity/1, fname_id/1, is_c_fname/1, update_c_fname/3.

       <b>c_fun(Variables::[cerl()],</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_fun()</b>

              Creates an abstract fun-expression. If <u>Variables</u> is <u>[V1,</u> <u>...,</u> <u>Vn]</u>, the result represents "<u>fun</u> <u>(V1,</u>
              <u>...,</u> <u>Vn)</u> <u>-&gt;</u> <u>Body</u>". All the <u>Vi</u> must have type <u>var</u>.

              <u>See</u> <u>also:</u> ann_c_fun/3, fun_arity/1, fun_body/1, fun_vars/1, is_c_fun/1, update_c_fun/3.

       <b>c_int(Value::integer())</b> <b>-&gt;</b> <b>c_literal()</b>

              Creates an abstract integer literal. The lexical representation is the canonical  decimal  numeral
              of <u>Value</u>.

              <u>See</u> <u>also:</u> ann_c_int/2, c_char/1, int_lit/1, int_val/1, is_c_int/1.

       <b>c_let(Variables::[cerl()],</b> <b>Argument::cerl(),</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_let()</b>

              Creates an abstract let-expression. If <u>Variables</u> is <u>[V1,</u> <u>...,</u> <u>Vn]</u>, the result represents "<u>let</u> <u>&lt;V1,</u>
              <u>...,</u> <u>Vn&gt;</u> <u>=</u> <u>Argument</u> <u>in</u> <u>Body</u>". All the <u>Vi</u> must have type <u>var</u>.

              <u>See</u> <u>also:</u> ann_c_let/4, is_c_let/1, let_arg/1, let_arity/1, let_body/1, let_vars/1, update_c_let/4.

       <b>c_letrec(Defs::[{cerl(),</b> <b>cerl()}],</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_letrec()</b>

              Creates  an  abstract  letrec-expression.  If <u>Definitions</u> is <u>[{V1,</u> <u>F1},</u> <u>...,</u> <u>{Vn,</u> <u>Fn}]</u>, the result
              represents "<u>letrec</u> <u>V1</u> <u>=</u> <u>F1</u> <u>...</u> <u>Vn</u> <u>=</u> <u>Fn</u> <u>in</u> <u>Body</u>. All the  <u>Vi</u>  must  have  type  <u>var</u>  and  represent
              function names. All the <u>Fi</u> must have type <u>'fun'</u>.

              <u>See</u>    <u>also:</u>   ann_c_letrec/3,   is_c_letrec/1,   letrec_body/1,   letrec_defs/1,   letrec_vars/1,
              update_c_letrec/3.

       <b>c_map(Pairs::[c_map_pair()])</b> <b>-&gt;</b> <b>c_map()</b>

       <b>c_map_pair(Key::cerl(),</b> <b>Val::cerl())</b> <b>-&gt;</b> <b>c_map_pair()</b>

       <b>c_map_pair_exact(Key::cerl(),</b> <b>Val::cerl())</b> <b>-&gt;</b> <b>c_map_pair()</b>

       <b>c_map_pattern(Pairs::[c_map_pair()])</b> <b>-&gt;</b> <b>c_map()</b>

       <b>c_module(Name::cerl(),</b> <b>Exports::[cerl()],</b> <b>Es::[{cerl(),</b> <b>cerl()}])</b> <b>-&gt;</b> <b>c_module()</b>

              Equivalent to c_module(Name, Exports, [], Definitions).

       <b>c_module(Name::cerl(),</b>  <b>Exports::[cerl()],</b>  <b>Attrs::[{cerl(),</b>   <b>cerl()}],</b>   <b>Es::[{cerl(),</b>   <b>cerl()}])</b>   <b>-&gt;</b>
       <b>c_module()</b>

              Creates an abstract module definition. The result represents

                  module Name [E1, ..., Ek]
                    attributes [K1 = T1, ...,
                                Km = Tm]
                    V1 = F1
                    ...
                    Vn = Fn
                  end

              if  <u>Exports</u>  = <u>[E1,</u> <u>...,</u> <u>Ek]</u>, <u>Attributes</u> = <u>[{K1,</u> <u>T1},</u> <u>...,</u> <u>{Km,</u> <u>Tm}]</u>, and <u>Definitions</u> = <u>[{V1,</u> <u>F1},</u>
              <u>...,</u> <u>{Vn,</u> <u>Fn}]</u>.

              <u>Name</u> and all the <u>Ki</u> must be atom literals, and all the <u>Ti</u> must be constant literals.  All  the  <u>Vi</u>
              and <u>Ei</u> must have type <u>var</u> and represent function names. All the <u>Fi</u> must have type <u>'fun'</u>.

              <u>See</u>  <u>also:</u>  ann_c_module/4,  ann_c_module/5, c_atom/1, c_fun/2, c_module/3, c_var/1, is_literal/1,
              module_attrs/1, module_defs/1, module_exports/1, module_name/1, module_vars/1, update_c_module/5.

       <b>c_nil()</b> <b>-&gt;</b> <b>c_literal()</b>

              Creates an abstract empty list. The result represents "<u>[]</u>". The empty list is traditionally called
              "nil".

              <u>See</u> <u>also:</u> ann_c_nil/1, c_cons/2, is_c_list/1.

       <b>c_primop(Name::cerl(),</b> <b>Arguments::[cerl()])</b> <b>-&gt;</b> <b>c_primop()</b>

              Creates an abstract primitive operation call. If <u>Arguments</u> is <u>[A1,</u> <u>...,</u> <u>An]</u>, the result represents
              "<u>primop</u> <u>Name(A1,</u> <u>...,</u> <u>An)</u>". <u>Name</u> must be an atom literal.

              <u>See</u> <u>also:</u>  ann_c_primop/3,  c_apply/2,  c_call/3,  is_c_primop/1,  primop_args/1,  primop_arity/1,
              primop_name/1, update_c_primop/3.

       <b>c_receive(Clauses::[cerl()])</b> <b>-&gt;</b> <b>c_receive()</b>

              Equivalent to c_receive(Clauses, c_atom(infinity), c_atom(true)).

              <u>See</u> <u>also:</u> c_atom/1.

       <b>c_receive(Clauses::[cerl()],</b> <b>Timeout::cerl(),</b> <b>Action::cerl())</b> <b>-&gt;</b> <b>c_receive()</b>

              Creates  an  abstract  receive-expression.  If  <u>Clauses</u>  is  <u>[C1,</u>  <u>...,</u> <u>Cn]</u>, the result represents
              "<u>receive</u> <u>C1</u> <u>...</u> <u>Cn</u> <u>after</u> <u>Timeout</u> <u>-&gt;</u> <u>Action</u> <u>end</u>".

              <u>See</u>  <u>also:</u>  ann_c_receive/4,  c_receive/1,  is_c_receive/1,  receive_action/1,  receive_clauses/1,
              receive_timeout/1, update_c_receive/4.

       <b>c_seq(Argument::cerl(),</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_seq()</b>

              Creates an abstract sequencing expression. The result represents "<u>do</u> <u>Argument</u> <u>Body</u>".

              <u>See</u> <u>also:</u> ann_c_seq/3, is_c_seq/1, seq_arg/1, seq_body/1, update_c_seq/3.

       <b>c_string(Value::string())</b> <b>-&gt;</b> <b>c_literal()</b>

              Creates  an  abstract string literal. Equivalent to creating an abstract list of the corresponding
              character  literals  (cf.  <u>is_c_string/1</u>),  but  is  typically   more   efficient.   The   lexical
              representation  of  a  string  is  "<u>"Chars"</u>",  where <u>Chars</u> is a sequence of printing characters or
              spaces.

              <u>See</u> <u>also:</u> ann_c_string/2, c_char/1, is_c_string/1, is_print_string/1, string_lit/1, string_val/1.

       <b>c_try(Expr::cerl(),</b> <b>Vs::[cerl()],</b> <b>Body::cerl(),</b> <b>Evs::[cerl()],</b> <b>Handler::cerl())</b> <b>-&gt;</b> <b>c_try()</b>

              Creates an abstract try-expression. If <u>Variables</u> is <u>[V1,</u> <u>...,</u> <u>Vn]</u> and <u>ExceptionVars</u> is  <u>[X1,</u>  <u>...,</u>
              <u>Xm]</u>, the result represents "<u>try</u> <u>Argument</u> <u>of</u> <u>&lt;V1,</u> <u>...,</u> <u>Vn&gt;</u> <u>-&gt;</u> <u>Body</u> <u>catch</u> <u>&lt;X1,</u> <u>...,</u> <u>Xm&gt;</u> <u>-&gt;</u> <u>Handler</u>".
              All the <u>Vi</u> and <u>Xi</u> must have type <u>var</u>.

              <u>See</u> <u>also:</u> ann_c_try/6, c_catch/1, is_c_try/1, try_arg/1, try_body/1, try_vars/1, update_c_try/6.

       <b>c_tuple(Es::[cerl()])</b> <b>-&gt;</b> <b>c_tuple()</b> <b>|</b> <b>c_literal()</b>

              Creates  an  abstract  tuple. If <u>Elements</u> is <u>[E1,</u> <u>...,</u> <u>En]</u>, the result represents "<u>{E1,</u> <u>...,</u> <u>En}</u>".
              Note that if all nodes in <u>Elements</u> have type <u>literal</u>, or if <u>Elements</u> is  empty,  then  the  result
              will also have type <u>literal</u> and annotations on nodes in <u>Elements</u> are lost.

              Recall that Erlang has distinct 1-tuples, i.e., <u>{X}</u> is always distinct from <u>X</u> itself.

              <u>See</u>    <u>also:</u>    ann_c_tuple/2,    c_tuple_skel/1,    is_c_tuple/1,    tuple_arity/1,   tuple_es/1,
              update_c_tuple/2.

       <b>c_tuple_skel(Es::[cerl()])</b> <b>-&gt;</b> <b>c_tuple()</b>

              Creates an abstract tuple skeleton. Does not fold constant literals, i.e., the result  always  has
              type <u>tuple</u>, representing "<u>{E1,</u> <u>...,</u> <u>En}</u>", if <u>Elements</u> is <u>[E1,</u> <u>...,</u> <u>En]</u>.

              This function is occasionally useful when it is necessary to have annotations on the subnodes of a
              tuple  node, even when all the subnodes are constant literals. Note however that <u>is_literal/1</u> will
              yield <u>false</u> and <u>concrete/1</u> will fail if passed the result from this function.

              <u>fold_literal/1</u> can be used to revert a node to the normal-form representation.

              <u>See</u> <u>also:</u> ann_c_tuple_skel/2, c_tuple/1, concrete/1, fold_literal/1,  is_c_tuple/1,  is_literal/1,
              tuple_es/1, update_c_tuple_skel/2.

       <b>c_values(Es::[cerl()])</b> <b>-&gt;</b> <b>c_values()</b>

              Creates  an  abstract  value  list. If <u>Elements</u> is <u>[E1,</u> <u>...,</u> <u>En]</u>, the result represents "<u>&lt;E1,</u> <u>...,</u>
              <u>En&gt;</u>".

              <u>See</u> <u>also:</u> ann_c_values/2, is_c_values/1, update_c_values/2, values_arity/1, values_es/1.

       <b>c_var(Name::var_name())</b> <b>-&gt;</b> <b>c_var()</b>

              Creates an abstract variable. A variable is identified by its name, given by the <u>Name</u> parameter.

              If a name is given by a single atom, it should either be a "simple" atom which does not need to be
              single-quoted in Erlang, or otherwise  its  print  name  should  correspond  to  a  proper  Erlang
              variable,  i.e.,  begin  with  an  uppercase  character or an underscore. Names on the form <u>{A,</u> <u>N}</u>
              represent function name variables "<u>A/N</u>"; these are special variables which may be  bound  only  in
              the  function  definitions  of  a module or a <u>letrec</u>. They may not be bound in <u>let</u> expressions and
              cannot occur in clause patterns. The atom <u>A</u> in a function name may be any atom; the integer <u>N</u> must
              be nonnegative. The functions <u>c_fname/2</u> etc. are utilities for handling function name variables.

              When printing variable names, they must have the form of proper Core Erlang variables and function
              names. E.g., a name represented by an integer such as <u>42</u> could be  formatted  as  "<b>_</b><u>42</u>",  an  atom
              <u>'Xxx'</u>  simply  as  "<u>Xxx</u>",  and  an atom <u>foo</u> as "<b>_</b><u>foo</u>". However, one must assure that any two valid
              distinct names are never mapped to the same strings. Tuples such as <u>{foo,</u> <u>2}</u> representing function
              names can simply by formatted as "<u>'foo'/2</u>", with no risk of conflicts.

              <u>See</u> <u>also:</u> ann_c_var/2, c_fname/2, c_letrec/2, c_module/4, is_c_var/1, update_c_var/2, var_name/1.

       <b>call_args(Node::c_call())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of argument subtrees of an abstract inter-module call.

              <u>See</u> <u>also:</u> c_call/3, call_arity/1.

       <b>call_arity(Node::c_call())</b> <b>-&gt;</b> <b>arity()</b>

              Returns the number of argument subtrees of an abstract inter-module call.

              Note: this is equivalent to <u>length(call_args(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> c_call/3, call_args/1.

       <b>call_module(Node::c_call())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the module subtree of an abstract inter-module call.

              <u>See</u> <u>also:</u> c_call/3.

       <b>call_name(Node::c_call())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the name subtree of an abstract inter-module call.

              <u>See</u> <u>also:</u> c_call/3.

       <b>case_arg(Node::c_case())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the argument subtree of an abstract case-expression.

              <u>See</u> <u>also:</u> c_case/2.

       <b>case_arity(Node::c_case())</b> <b>-&gt;</b> <b>non_neg_integer()</b>

              Equivalent to <u>clause_arity(hd(case_clauses(Node)))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> c_case/2, case_clauses/1, clause_arity/1.

       <b>case_clauses(Node::c_case())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of clause subtrees of an abstract case-expression.

              <u>See</u> <u>also:</u> c_case/2, case_arity/1.

       <b>catch_body(Node::c_catch())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the body subtree of an abstract catch-expression.

              <u>See</u> <u>also:</u> c_catch/1.

       <b>char_lit(Node::c_literal())</b> <b>-&gt;</b> <b>nonempty_string()</b>

              Returns the literal string represented by  an  abstract  character.  This  includes  a  leading  <u>$</u>
              character.  Currently,  all  characters that are not in the set of ISO 8859-1 (Latin-1) "printing"
              characters will be escaped.

              <u>See</u> <u>also:</u> c_char/1.

       <b>char_val(Node::c_literal())</b> <b>-&gt;</b> <b>char()</b>

              Returns the value represented by an abstract character literal.

              <u>See</u> <u>also:</u> c_char/1.

       <b>clause_arity(Node::c_clause())</b> <b>-&gt;</b> <b>non_neg_integer()</b>

              Returns the number of pattern subtrees of an abstract clause.

              Note: this is equivalent to <u>length(clause_pats(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> c_clause/3, clause_pats/1.

       <b>clause_body(Node::c_clause())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the body subtree of an abstract clause.

              <u>See</u> <u>also:</u> c_clause/3.

       <b>clause_guard(Node::c_clause())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the guard subtree of an abstract clause.

              <u>See</u> <u>also:</u> c_clause/3.

       <b>clause_pats(Node::c_clause())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of pattern subtrees of an abstract clause.

              <u>See</u> <u>also:</u> c_clause/3, clause_arity/1.

       <b>clause_vars(Clause::c_clause())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of all abstract variables in the patterns of an abstract  clause.  The  order  of
              listing is not defined.

              <u>See</u> <u>also:</u> c_clause/3, pat_list_vars/1.

       <b>concrete(C_literal::c_literal())</b> <b>-&gt;</b> <b>term()</b>

              Returns  the  Erlang  term  represented  by a syntax tree. An exception is thrown if <u>Node</u> does not
              represent a literal term.

              Note: This is a constant time operation.

              <u>See</u> <u>also:</u> abstract/1, is_literal/1.

       <b>cons_hd(C_cons::c_cons()</b> <b>|</b> <b>c_literal())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the head subtree of an abstract list constructor.

              <u>See</u> <u>also:</u> c_cons/2.

       <b>cons_tl(C_cons::c_cons()</b> <b>|</b> <b>c_literal())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the tail subtree of an abstract list constructor.

              Recall that the tail does not necessarily represent a proper list.

              <u>See</u> <u>also:</u> c_cons/2.

       <b>copy_ann(Source::cerl(),</b> <b>Target::cerl())</b> <b>-&gt;</b> <b>cerl()</b>

              Copies the list of user annotations from <u>Source</u> to <u>Target</u>.

              Note: this is equivalent to <u>set_ann(Target,</u> <u>get_ann(Source))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> get_ann/1, set_ann/2.

       <b>data_arity(C_literal::c_lct())</b> <b>-&gt;</b> <b>non_neg_integer()</b>

              Returns  the  number  of  subtrees  of  a  data  constructor   node.   This   is   equivalent   to
              <u>length(data_es(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> data_es/1, is_data/1.

       <b>data_es(C_literal::c_lct())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns  the list of subtrees of a data constructor node. If the arity of the constructor is zero,
              the result is the empty list.

              Note: if <u>data_type(Node)</u> is <u>cons</u>, the number of subtrees is exactly  two.  If  <u>data_type(Node)</u>  is
              <u>{atomic,</u> <u>Value}</u>, the number of subtrees is zero.

              <u>See</u> <u>also:</u> data_arity/1, data_type/1, is_data/1, make_data/2.

       <b>data_type(C_literal::c_lct())</b> <b>-&gt;</b> <b>dtype()</b>

              Returns  a type descriptor for a data constructor node. (Cf. <u>is_data/1</u>.) This is mainly useful for
              comparing types and for constructing new nodes  of  the  same  type  (cf.  <u>make_data/2</u>).  If  <u>Node</u>
              represents  an  integer, floating-point number, atom or empty list, the result is <u>{atomic,</u> <u>Value}</u>,
              where <u>Value</u> is the value of <u>concrete(Node)</u>, otherwise the result is either <u>cons</u> or <u>tuple</u>.

              Type descriptors can be compared for equality or order (in the Erlang term  order),  but  remember
              that floating-point values should in general never be tested for equality.

              <u>See</u> <u>also:</u> concrete/1, is_data/1, make_data/2, type/1.

       <b>float_lit(Node::c_literal())</b> <b>-&gt;</b> <b>string()</b>

              Returns the numeral string represented by a floating-point literal node.

              <u>See</u> <u>also:</u> c_float/1.

       <b>float_val(Node::c_literal())</b> <b>-&gt;</b> <b>float()</b>

              Returns the value represented by a floating-point literal node.

              <u>See</u> <u>also:</u> c_float/1.

       <b>fname_arity(C_var::c_var())</b> <b>-&gt;</b> <b>arity()</b>

              Returns the arity part of an abstract function name variable.

              <u>See</u> <u>also:</u> c_fname/2, fname_id/1.

       <b>fname_id(C_var::c_var())</b> <b>-&gt;</b> <b>atom()</b>

              Returns the identifier part of an abstract function name variable.

              <u>See</u> <u>also:</u> c_fname/2, fname_arity/1.

       <b>fold_literal(Node::cerl())</b> <b>-&gt;</b> <b>cerl()</b>

              Assures that literals have a compact representation. This is occasionally useful if <u>c_cons_skel/2</u>,
              <u>c_tuple_skel/1</u>  or  <u>unfold_literal/1</u> were used in the construction of <u>Node</u>, and you want to revert
              to the normal "folded" representation of literals. If <u>Node</u> represents a tuple or list constructor,
              its elements are rewritten recursively, and the node is reconstructed using <u>c_cons/2</u> or <u>c_tuple/1</u>,
              respectively; otherwise, <u>Node</u> is not changed.

              <u>See</u> <u>also:</u> c_cons/2, c_cons_skel/2, c_tuple/1, c_tuple_skel/1, is_literal/1, unfold_literal/1.

       <b>from_records(Node::cerl())</b> <b>-&gt;</b> <b>cerl()</b>

              Translates an explicit record representation to a corresponding abstract syntax tree. The  records
              are defined in the file "<u>core_parse.hrl</u>".

              <u>See</u> <u>also:</u> to_records/1, type/1.

       <b>fun_arity(Node::c_fun())</b> <b>-&gt;</b> <b>arity()</b>

              Returns the number of parameter subtrees of an abstract fun-expression.

              Note: this is equivalent to <u>length(fun_vars(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> c_fun/2, fun_vars/1.

       <b>fun_body(Node::c_fun())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the body subtree of an abstract fun-expression.

              <u>See</u> <u>also:</u> c_fun/2.

       <b>fun_vars(Node::c_fun())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of parameter subtrees of an abstract fun-expression.

              <u>See</u> <u>also:</u> c_fun/2, fun_arity/1.

       <b>get_ann(Node::cerl())</b> <b>-&gt;</b> <b>[term()]</b>

              Returns the list of user annotations associated with a syntax tree node. For a newly created node,
              this is the empty list. The annotations may be any terms.

              <u>See</u> <u>also:</u> set_ann/2.

       <b>int_lit(Node::c_literal())</b> <b>-&gt;</b> <b>string()</b>

              Returns the numeral string represented by an integer literal node.

              <u>See</u> <u>also:</u> c_int/1.

       <b>int_val(Node::c_literal())</b> <b>-&gt;</b> <b>integer()</b>

              Returns the value represented by an integer literal node.

              <u>See</u> <u>also:</u> c_int/1.

       <b>is_c_alias(C_alias::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract pattern alias, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_alias/2.

       <b>is_c_apply(C_apply::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract function application, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_apply/2.

       <b>is_c_atom(C_literal::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> represents an atom literal, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_atom/1.

       <b>is_c_binary(C_binary::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract binary-template; otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_binary/1.

       <b>is_c_bitstr(C_bitstr::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract bit-string template; otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_bitstr/5.

       <b>is_c_call(C_call::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract inter-module call expression; otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_call/3.

       <b>is_c_case(C_case::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract case-expression; otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_case/2.

       <b>is_c_catch(C_catch::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract catch-expression, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_catch/1.

       <b>is_c_char(C_literal::c_literal())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> may represent a character literal, otherwise <u>false</u>.

              If the local implementation of Erlang defines <u>char()</u> as a subset of <u>integer()</u>, then <u>is_c_int(Node)</u>
              will also yield <u>true</u>.

              <u>See</u> <u>also:</u> c_char/1, is_print_char/1.

       <b>is_c_clause(C_clause::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract clause, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_clause/3.

       <b>is_c_cons(C_cons::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract list constructor, otherwise <u>false</u>.

       <b>is_c_float(C_literal::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> represents a floating-point literal, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_float/1.

       <b>is_c_fname(C_var::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract function name variable, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_fname/2, c_var/1, var_name/1.

       <b>is_c_fun(C_fun::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract fun-expression, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_fun/2.

       <b>is_c_int(C_literal::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> represents an integer literal, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_int/1.

       <b>is_c_let(C_let::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract let-expression, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_let/3.

       <b>is_c_letrec(C_letrec::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract letrec-expression, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_letrec/2.

       <b>is_c_list(C_cons::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns  <u>true</u> if <u>Node</u> represents a proper list, otherwise <u>false</u>. A proper list is either the empty
              list <u>[]</u>, or a cons cell <u>[Head</u> <u>|</u> <u>Tail]</u>, where recursively <u>Tail</u> is a proper list.

              Note: Because <u>Node</u> is a syntax tree, the actual run-time values corresponding to its subtrees  may
              often  be partially or completely unknown. Thus, if <u>Node</u> represents e.g. "<u>[...</u> <u>|</u> <u>Ns]</u>" (where <u>Ns</u> is
              a variable), then the function will return <u>false</u>, because it is not known whether <u>Ns</u> will be bound
              to a list at run-time. If <u>Node</u> instead represents e.g. "<u>[1,</u>  <u>2,</u>  <u>3]</u>"  or  "<u>[A</u>  <u>|</u>  <u>[]]</u>",  then  the
              function will return <u>true</u>.

              <u>See</u> <u>also:</u> c_cons/2, c_nil/0, list_elements/1, list_length/1.

       <b>is_c_map(C_map::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract map constructor, otherwise <u>false</u>.

       <b>is_c_map_empty(C_map::c_map()</b> <b>|</b> <b>c_literal())</b> <b>-&gt;</b> <b>boolean()</b>

       <b>is_c_map_pattern(C_map::c_map())</b> <b>-&gt;</b> <b>boolean()</b>

       <b>is_c_module(C_module::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract module definition, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> type/1.

       <b>is_c_nil(C_literal::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract empty list, otherwise <u>false</u>.

       <b>is_c_primop(C_primop::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract primitive operation call, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_primop/2.

       <b>is_c_receive(C_receive::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract receive-expression, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_receive/3.

       <b>is_c_seq(C_seq::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract sequencing expression, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_seq/2.

       <b>is_c_string(C_literal::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> may represent a string literal, otherwise <u>false</u>. Strings are defined as lists
              of characters; see <u>is_c_char/1</u> for details.

              <u>See</u> <u>also:</u> c_string/1, is_c_char/1, is_print_string/1.

       <b>is_c_try(C_try::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract try-expression, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_try/5.

       <b>is_c_tuple(C_tuple::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract tuple, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_tuple/1.

       <b>is_c_values(C_values::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract value list; otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_values/1.

       <b>is_c_var(C_var::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is an abstract variable, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> c_var/1.

       <b>is_data(C_literal::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns  <u>true</u>  if  <u>Node</u> represents a data constructor, otherwise <u>false</u>. Data constructors are cons
              cells, tuples, and atomic literals.

              <u>See</u> <u>also:</u> data_arity/1, data_es/1, data_type/1.

       <b>is_leaf(Node::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is a leaf node, otherwise <u>false</u>. The current leaf node types are <u>literal</u>  and
              <u>var</u>.

              Note: all literals (cf. <u>is_literal/1</u>) are leaf nodes, even if they represent structured (constant)
              values such as <u>{foo,</u> <u>[bar,</u> <u>baz]}</u>. Also note that variables are leaf nodes but not literals.

              <u>See</u> <u>also:</u> is_literal/1, type/1.

       <b>is_literal(C_literal::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> represents a literal term, otherwise <u>false</u>. This function returns <u>true</u> if and
              only if the value of <u>concrete(Node)</u> is defined.

              Note: This is a constant time operation.

              <u>See</u> <u>also:</u> abstract/1, concrete/1, fold_literal/1.

       <b>is_literal_term(T::term())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns  <u>true</u>  if  <u>Term</u> can be represented as a literal, otherwise <u>false</u>. This function takes time
              proportional to the size of <u>Term</u>.

              <u>See</u> <u>also:</u> abstract/1.

       <b>is_print_char(C_literal::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> may represent a "printing" character, otherwise <u>false</u>. (Cf.  <u>is_c_char/1</u>.)  A
              "printing"  character  has  either  a given graphical representation, or a "named" escape sequence
              such as "<u>\n</u>". Currently, only ISO 8859-1 (Latin-1) character values are recognized.

              <u>See</u> <u>also:</u> c_char/1, is_c_char/1.

       <b>is_print_string(C_literal::cerl())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> may  represent  a  string  literal  containing  only  "printing"  characters,
              otherwise  <u>false</u>.  See  <u>is_c_string/1</u>  and <u>is_print_char/1</u> for details. Currently, only ISO 8859-1
              (Latin-1) character values are recognized.

              <u>See</u> <u>also:</u> c_string/1, is_c_string/1, is_print_char/1.

       <b>let_arg(Node::c_let())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the argument subtree of an abstract let-expression.

              <u>See</u> <u>also:</u> c_let/3.

       <b>let_arity(Node::c_let())</b> <b>-&gt;</b> <b>non_neg_integer()</b>

              Returns the number of left-hand side variables of an abstract let-expression.

              Note: this is equivalent to <u>length(let_vars(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> c_let/3, let_vars/1.

       <b>let_body(Node::c_let())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the body subtree of an abstract let-expression.

              <u>See</u> <u>also:</u> c_let/3.

       <b>let_vars(Node::c_let())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of left-hand side variables of an abstract let-expression.

              <u>See</u> <u>also:</u> c_let/3, let_arity/1.

       <b>letrec_body(Node::c_letrec())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the body subtree of an abstract letrec-expression.

              <u>See</u> <u>also:</u> c_letrec/2.

       <b>letrec_defs(Node::c_letrec())</b> <b>-&gt;</b> <b>[{cerl(),</b> <b>cerl()}]</b>

              Returns the list of definitions of an abstract letrec-expression. If <u>Node</u> represents "<u>letrec</u> <u>V1</u>  <u>=</u>
              <u>F1</u> <u>...</u> <u>Vn</u> <u>=</u> <u>Fn</u> <u>in</u> <u>Body</u>", the returned value is <u>[{V1,</u> <u>F1},</u> <u>...,</u> <u>{Vn,</u> <u>Fn}]</u>.

              <u>See</u> <u>also:</u> c_letrec/2.

       <b>letrec_vars(Node::c_letrec())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns  the  list  of  left-hand  side function variable subtrees of a letrec-expression. If <u>Node</u>
              represents "<u>letrec</u> <u>V1</u> <u>=</u> <u>F1</u> <u>...</u> <u>Vn</u> <u>=</u> <u>Fn</u> <u>in</u> <u>Body</u>", the returned value is <u>[V1,</u> <u>...,</u> <u>Vn]</u>.

              <u>See</u> <u>also:</u> c_letrec/2.

       <b>list_elements(C_cons::c_cons()</b> <b>|</b> <b>c_literal())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of element subtrees of an abstract list. <u>Node</u> must represent a proper list. E.g.,
              if <u>Node</u> represents "<u>[X1,</u> <u>X2</u> <u>|</u> <u>[X3,</u> <u>X4</u> <u>|</u> <u>[]]</u>", then <u>list_elements(Node)</u> yields the  list  <u>[X1,</u>  <u>X2,</u>
              <u>X3,</u> <u>X4]</u>.

              <u>See</u> <u>also:</u> c_cons/2, c_nil/0, is_c_list/1, list_length/1, make_list/2.

       <b>list_length(L::c_cons()</b> <b>|</b> <b>c_literal())</b> <b>-&gt;</b> <b>non_neg_integer()</b>

              Returns  the  number  of  element subtrees of an abstract list. <u>Node</u> must represent a proper list.
              E.g., if <u>Node</u> represents "<u>[X1</u> <u>|</u> <u>[X2,</u> <u>X3</u> <u>|</u> <u>[X4,</u> <u>X5,</u>  <u>X6]]]</u>",  then  <u>list_length(Node)</u>  returns  the
              integer 6.

              Note: this is equivalent to <u>length(list_elements(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> c_cons/2, c_nil/0, is_c_list/1, list_elements/1.

       <b>make_data(CType::dtype(),</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_lct()</b>

              Creates  a  data  constructor  node  with  the  specified type and subtrees. (Cf. <u>data_type/1</u>.) An
              exception is thrown if the length of <u>Elements</u> is invalid for the given  <u>Type</u>;  see  <u>data_es/1</u>  for
              arity constraints on constructor types.

              <u>See</u> <u>also:</u> ann_make_data/3, data_es/1, data_type/1, make_data_skel/2, update_data/3.

       <b>make_data_skel(CType::dtype(),</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_lct()</b>

              Like <u>make_data/2</u>, but analogous to <u>c_tuple_skel/1</u> and <u>c_cons_skel/2</u>.

              <u>See</u> <u>also:</u> ann_make_data_skel/3, c_cons_skel/2, c_tuple_skel/1, make_data/2, update_data_skel/3.

       <b>make_list(List::[cerl()])</b> <b>-&gt;</b> <b>cerl()</b>

              Equivalent to make_list(List, none).

       <b>make_list(List::[cerl()],</b> <b>Tail::cerl()</b> <b>|</b> <b>none)</b> <b>-&gt;</b> <b>cerl()</b>

              Creates  an  abstract  list  from the elements in <u>List</u> and the optional <u>Tail</u>. If <u>Tail</u> is <u>none</u>, the
              result will represent a nil-terminated list, otherwise it represents "<u>[...</u> <u>|</u> <u>Tail]</u>".

              <u>See</u> <u>also:</u> ann_make_list/3, c_cons/2, c_nil/0, list_elements/1, update_list/3.

       <b>make_tree(Type::ctype(),</b> <b>Gs::[[cerl()],</b> <b>...])</b> <b>-&gt;</b> <b>cerl()</b>

              Creates a syntax tree with the given type and subtrees. <u>Type</u> must be a node type name (cf. <u>type/1</u>)
              that does not denote a leaf node type (cf. <u>is_leaf/1</u>). <u>Groups</u> must be a <u>nonempty</u> list of groups of
              syntax trees, representing the subtrees of a node of the given type,  in  left-to-right  order  as
              they would occur in the printed program text, grouped by category as done by <u>subtrees/1</u>.

              The   result  of  <u>ann_make_tree(get_ann(Node),</u>  <u>type(Node),</u>  <u>subtrees(Node))</u>  (cf.  <u>update_tree/2</u>)
              represents the same source code text as the original <u>Node</u>, assuming that <u>subtrees(Node)</u>  yields  a
              nonempty list. However, it does not necessarily have the exact same data representation as <u>Node</u>.

              <u>See</u> <u>also:</u> ann_make_tree/3, is_leaf/1, subtrees/1, type/1, update_tree/2.

       <b>map_arg(C_literal::c_map()</b> <b>|</b> <b>c_literal())</b> <b>-&gt;</b> <b>c_map()</b> <b>|</b> <b>c_literal()</b>

       <b>map_es(C_literal::c_map()</b> <b>|</b> <b>c_literal())</b> <b>-&gt;</b> <b>[c_map_pair()]</b>

       <b>map_pair_key(C_map_pair::c_map_pair())</b> <b>-&gt;</b> <b>cerl()</b>

       <b>map_pair_op(C_map_pair::c_map_pair())</b> <b>-&gt;</b> <b>map_op()</b>

       <b>map_pair_val(C_map_pair::c_map_pair())</b> <b>-&gt;</b> <b>cerl()</b>

       <b>meta(Node::cerl())</b> <b>-&gt;</b> <b>cerl()</b>

              Creates  a  meta-representation  of  a  syntax  tree.  The  result represents an Erlang expression
              "<u>MetaTree</u>" which, if evaluated, will yield a new syntax tree representing  the  same  source  code
              text  as  <u>Tree</u>  (although  the  actual  data  representation  may  be  different).  The expression
              represented by <u>MetaTree</u> is <u>implementation</u> <u>independent</u> with regard to the data structures  used  by
              the abstract syntax tree implementation.

              Any  node  in  <u>Tree</u>  whose  node  type  is  <u>var</u>  (cf.  <u>type/1</u>), and whose list of annotations (cf.
              <u>get_ann/1</u>) contains the atom <u>meta_var</u>, will remain unchanged in the resulting  tree,  except  that
              exactly one occurrence of <u>meta_var</u> is removed from its annotation list.

              The  main  use  of  the  function <u>meta/1</u> is to transform a data structure <u>Tree</u>, which represents a
              piece of program code, into a form that is <u>representation</u> <u>independent</u> <u>when</u> <u>printed</u>. E.g.,  suppose
              <u>Tree</u>  represents  a  variable  named  "V".  Then  (assuming a function <u>print/1</u> for printing syntax
              trees), evaluating <u>print(abstract(Tree))</u>  -  simply  using  <u>abstract/1</u>  to  map  the  actual  data
              structure onto a syntax tree representation - would output a string that might look something like
              "<u>{var,</u>  <u>...,</u>  <u>'V'}</u>",  which  is  obviously  dependent on the implementation of the abstract syntax
              trees. This could e.g. be useful for caching a syntax tree in a file. However, in some  situations
              like  in  a  program  generator  generator  (with  two "generator"), it may be unacceptable. Using
              <u>print(meta(Tree))</u> instead  would  output  a  <u>representation</u>  <u>independent</u>  syntax  tree  generating
              expression; in the above case, something like "<u>cerl:c_var('V')</u>".

              The implementation tries to generate compact code with respect to literals and lists.

              <u>See</u> <u>also:</u> abstract/1, get_ann/1, type/1.

       <b>module_attrs(Node::c_module())</b> <b>-&gt;</b> <b>[{cerl(),</b> <b>cerl()}]</b>

              Returns the list of pairs of attribute key/value subtrees of an abstract module definition.

              <u>See</u> <u>also:</u> c_module/4.

       <b>module_defs(Node::c_module())</b> <b>-&gt;</b> <b>[{cerl(),</b> <b>cerl()}]</b>

              Returns the list of function definitions of an abstract module definition.

              <u>See</u> <u>also:</u> c_module/4.

       <b>module_exports(Node::c_module())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of exports subtrees of an abstract module definition.

              <u>See</u> <u>also:</u> c_module/4.

       <b>module_name(Node::c_module())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the name subtree of an abstract module definition.

              <u>See</u> <u>also:</u> c_module/4.

       <b>module_vars(Node::c_module())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of left-hand side function variable subtrees of an abstract module definition.

              <u>See</u> <u>also:</u> c_module/4.

       <b>pat_list_vars(Ps::[cerl()])</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns  the  list of all abstract variables in the given patterns. An exception is thrown if some
              element in <u>Patterns</u> does not represent a well-formed Core Erlang  clause  pattern.  The  order  of
              listing is not defined.

              <u>See</u> <u>also:</u> clause_vars/1, pat_vars/1.

       <b>pat_vars(Node::cerl())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns  the  list of all abstract variables in a pattern. An exception is thrown if <u>Node</u> does not
              represent a well-formed Core Erlang clause pattern. The order of listing is not defined.

              <u>See</u> <u>also:</u> clause_vars/1, pat_list_vars/1.

       <b>primop_args(Node::c_primop())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of argument subtrees of an abstract primitive operation call.

              <u>See</u> <u>also:</u> c_primop/2, primop_arity/1.

       <b>primop_arity(Node::c_primop())</b> <b>-&gt;</b> <b>arity()</b>

              Returns the number of argument subtrees of an abstract primitive operation call.

              Note: this is equivalent to <u>length(primop_args(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> c_primop/2, primop_args/1.

       <b>primop_name(Node::c_primop())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the name subtree of an abstract primitive operation call.

              <u>See</u> <u>also:</u> c_primop/2.

       <b>receive_action(Node::c_receive())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the action subtree of an abstract receive-expression.

              <u>See</u> <u>also:</u> c_receive/3.

       <b>receive_clauses(Node::c_receive())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of clause subtrees of an abstract receive-expression.

              <u>See</u> <u>also:</u> c_receive/3.

       <b>receive_timeout(Node::c_receive())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the timeout subtree of an abstract receive-expression.

              <u>See</u> <u>also:</u> c_receive/3.

       <b>seq_arg(Node::c_seq())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the argument subtree of an abstract sequencing expression.

              <u>See</u> <u>also:</u> c_seq/2.

       <b>seq_body(Node::c_seq())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the body subtree of an abstract sequencing expression.

              <u>See</u> <u>also:</u> c_seq/2.

       <b>set_ann(Node::cerl(),</b> <b>List::[term()])</b> <b>-&gt;</b> <b>cerl()</b>

              Sets the list of user annotations of <u>Node</u> to <u>Annotations</u>.

              <u>See</u> <u>also:</u> add_ann/2, copy_ann/2, get_ann/1.

       <b>string_lit(Node::c_literal())</b> <b>-&gt;</b> <b>nonempty_string()</b>

              Returns the literal string represented by an abstract string. This  includes  surrounding  double-
              quote  characters  <u>"..."</u>.  Currently,  characters  that are not in the set of ISO 8859-1 (Latin-1)
              "printing" characters will be escaped, except for spaces.

              <u>See</u> <u>also:</u> c_string/1.

       <b>string_val(Node::c_literal())</b> <b>-&gt;</b> <b>string()</b>

              Returns the value represented by an abstract string literal.

              <u>See</u> <u>also:</u> c_string/1.

       <b>subtrees(T::cerl())</b> <b>-&gt;</b> <b>[[cerl()]]</b>

              Returns the grouped list of all subtrees of a node. If <u>Node</u> is a leaf node (cf.  <u>is_leaf/1</u>),  this
              is  the  empty  list,  otherwise  the  result  is  always a nonempty list, containing the lists of
              subtrees of <u>Node</u>, in left-to-right order as they occur in the printed program text, and grouped by
              category. Often, each group contains only a single subtree.

              Depending on the type of <u>Node</u>, the size of some groups may be variable (e.g., the group consisting
              of all the elements of a tuple), while others always contain the same number of elements - usually
              exactly one (e.g., the group containing the  argument  expression  of  a  case-expression).  Note,
              however,  that  the exact structure of the returned list (for a given node type) should in general
              not be depended upon, since it might be subject to change without notice.

              The function <u>subtrees/1</u> and the constructor functions <u>make_tree/2</u> and <u>update_tree/2</u> can be a great
              help if one wants to traverse a syntax tree, visiting all its subtrees, but  treat  nodes  of  the
              tree  in  a  uniform  way  in most or all cases. Using these functions makes this simple, and also
              assures that your code is not overly sensitive to extensions of the syntax tree data type, because
              any node types not explicitly handled by your code can be left to a default case.

              For example:

                  postorder(F, Tree) -&gt;
                      F(case subtrees(Tree) of
                          [] -&gt; Tree;
                          List -&gt; update_tree(Tree,
                                              [[postorder(F, Subtree)
                                                || Subtree &lt;- Group]
                                               || Group &lt;- List])
                        end).

              maps the function <u>F</u> on <u>Tree</u> and all its subtrees, doing a post-order traversal of the syntax tree.
              (Note the use of <u>update_tree/2</u> to preserve annotations.) For a simple function like:

                  f(Node) -&gt;
                      case type(Node) of
                          atom -&gt; atom("a_" ++ atom_name(Node));
                          _ -&gt; Node
                      end.

              the call <u>postorder(fun</u> <u>f/1,</u> <u>Tree)</u> will yield a new representation of <u>Tree</u> in which all atom  names
              have  been  extended  with  the  prefix  "a_",  but  nothing else (including annotations) has been
              changed.

              <u>See</u> <u>also:</u> is_leaf/1, make_tree/2, update_tree/2.

       <b>to_records(Node::cerl())</b> <b>-&gt;</b> <b>cerl()</b>

              Translates an abstract syntax tree to a corresponding explicit record representation. The  records
              are defined in the file "<u>cerl.hrl</u>".

              <u>See</u> <u>also:</u> from_records/1, type/1.

       <b>try_arg(Node::c_try())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the expression subtree of an abstract try-expression.

              <u>See</u> <u>also:</u> c_try/5.

       <b>try_body(Node::c_try())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the success body subtree of an abstract try-expression.

              <u>See</u> <u>also:</u> c_try/5.

       <b>try_evars(Node::c_try())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of exception variable subtrees of an abstract try-expression.

              <u>See</u> <u>also:</u> c_try/5.

       <b>try_handler(Node::c_try())</b> <b>-&gt;</b> <b>cerl()</b>

              Returns the exception body subtree of an abstract try-expression.

              <u>See</u> <u>also:</u> c_try/5.

       <b>try_vars(Node::c_try())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of success variable subtrees of an abstract try-expression.

              <u>See</u> <u>also:</u> c_try/5.

       <b>tuple_arity(C_tuple::c_tuple()</b> <b>|</b> <b>c_literal())</b> <b>-&gt;</b> <b>non_neg_integer()</b>

              Returns the number of element subtrees of an abstract tuple.

              Note: this is equivalent to <u>length(tuple_es(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> c_tuple/1, tuple_es/1.

       <b>tuple_es(C_tuple::c_tuple()</b> <b>|</b> <b>c_literal())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of element subtrees of an abstract tuple.

              <u>See</u> <u>also:</u> c_tuple/1.

       <b>type(C_alias::cerl())</b> <b>-&gt;</b> <b>ctype()</b>

              Returns the type tag of <u>Node</u>. Current node types are:

              alias apply binary bitstr call case catch clause
              cons fun let letrec literal map map_pair module
              primop receive seq try tuple values var

              Note:  The name of the primary constructor function for a node type is always the name of the type
              itself,  prefixed  by  "<u>c</u><b>_</b>";  recognizer  predicates  are  correspondingly  prefixed  by  "<u>is_c</u><b>_</b>".
              Furthermore,  to  simplify  preservation  of  annotations  (cf.  <u>get_ann/1</u>),  there  are analogous
              constructor functions prefixed by "<u>ann_c</u><b>_</b>" and "<u>update_c</u><b>_</b>", for setting the annotation list of the
              new node to either a specific value or to the annotations of an existing node, respectively.

              <u>See</u> <u>also:</u> abstract/1, c_alias/2, c_apply/2, c_binary/1, c_bitstr/5, c_call/3, c_case/2, c_catch/1,
              c_clause/3, c_cons/2, c_fun/2, c_let/3, c_letrec/2, c_module/3, c_primop/2, c_receive/1,  c_seq/2,
              c_try/5,   c_tuple/1,   c_values/1,   c_var/1,  data_type/1,  from_records/1,  get_ann/1,  meta/1,
              subtrees/1, to_records/1.

       <b>unfold_literal(Node::cerl())</b> <b>-&gt;</b> <b>cerl()</b>

              Assures that literals have a fully expanded representation. If <u>Node</u> represents a literal tuple  or
              list  constructor,  its  elements  are  rewritten recursively, and the node is reconstructed using
              <u>c_cons_skel/2</u> or <u>c_tuple_skel/1</u>, respectively; otherwise, <u>Node</u> is not changed. The  fold_literal/1
              can be used to revert to the normal compact representation.

              <u>See</u> <u>also:</u> c_cons/2, c_cons_skel/2, c_tuple/1, c_tuple_skel/1, fold_literal/1, is_literal/1.

       <b>update_c_alias(Node::c_alias(),</b> <b>Var::cerl(),</b> <b>Pattern::cerl())</b> <b>-&gt;</b> <b>c_alias()</b>

              <u>See</u> <u>also:</u> c_alias/2.

       <b>update_c_apply(Node::c_apply(),</b> <b>Operator::cerl(),</b> <b>Arguments::[cerl()])</b> <b>-&gt;</b> <b>c_apply()</b>

              <u>See</u> <u>also:</u> c_apply/2.

       <b>update_c_binary(Node::c_binary(),</b> <b>Segments::[cerl()])</b> <b>-&gt;</b> <b>c_binary()</b>

              <u>See</u> <u>also:</u> c_binary/1.

       <b>update_c_bitstr(Node::c_bitstr(),</b> <b>Value::cerl(),</b> <b>Size::cerl(),</b> <b>Type::cerl(),</b> <b>Flags::cerl())</b> <b>-&gt;</b> <b>c_bitstr()</b>

              Equivalent to update_c_bitstr(Node, Value, Size, <a href="../man1/abstract.1.html">abstract</a>(1), Type, Flags).

       <b>update_c_bitstr(Node::c_bitstr(),</b>  <b>Val::cerl(),</b>  <b>Size::cerl(),</b> <b>Unit::cerl(),</b> <b>Type::cerl(),</b> <b>Flags::cerl())</b>
       <b>-&gt;</b> <b>c_bitstr()</b>

              <u>See</u> <u>also:</u> c_bitstr/5, update_c_bitstr/5.

       <b>update_c_call(Node::cerl(),</b> <b>Module::cerl(),</b> <b>Name::cerl(),</b> <b>Arguments::[cerl()])</b> <b>-&gt;</b> <b>c_call()</b>

              <u>See</u> <u>also:</u> c_call/3.

       <b>update_c_case(Node::c_case(),</b> <b>Expr::cerl(),</b> <b>Clauses::[cerl()])</b> <b>-&gt;</b> <b>c_case()</b>

              <u>See</u> <u>also:</u> c_case/2.

       <b>update_c_catch(Node::c_catch(),</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_catch()</b>

              <u>See</u> <u>also:</u> c_catch/1.

       <b>update_c_clause(Node::c_clause(),</b> <b>Patterns::[cerl()],</b> <b>Guard::cerl(),</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_clause()</b>

              <u>See</u> <u>also:</u> c_clause/3.

       <b>update_c_cons(Node::c_literal()</b> <b>|</b> <b>c_cons(),</b> <b>C_literal::cerl(),</b> <b>Tail::cerl())</b> <b>-&gt;</b> <b>c_literal()</b> <b>|</b> <b>c_cons()</b>

              <u>See</u> <u>also:</u> c_cons/2.

       <b>update_c_cons_skel(Node::c_cons()</b> <b>|</b> <b>c_literal(),</b> <b>Head::cerl(),</b> <b>Tail::cerl())</b> <b>-&gt;</b> <b>c_cons()</b>

              <u>See</u> <u>also:</u> c_cons_skel/2.

       <b>update_c_fname(C_var::c_var(),</b> <b>Atom::atom())</b> <b>-&gt;</b> <b>c_var()</b>

              Like <u>update_c_fname/3</u>, but takes the arity from <u>Node</u>.

              <u>See</u> <u>also:</u> c_fname/2, update_c_fname/3.

       <b>update_c_fname(Node::c_var(),</b> <b>Atom::atom(),</b> <b>Arity::arity())</b> <b>-&gt;</b> <b>c_var()</b>

              Equivalent to update_c_var(Old, {Atom, Arity}).

              <u>See</u> <u>also:</u> c_fname/2, update_c_fname/2.

       <b>update_c_fun(Node::c_fun(),</b> <b>Variables::[cerl()],</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_fun()</b>

              <u>See</u> <u>also:</u> c_fun/2.

       <b>update_c_let(Node::c_let(),</b> <b>Variables::[cerl()],</b> <b>Argument::cerl(),</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_let()</b>

              <u>See</u> <u>also:</u> c_let/3.

       <b>update_c_letrec(Node::c_letrec(),</b> <b>Defs::[{cerl(),</b> <b>cerl()}],</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_letrec()</b>

              <u>See</u> <u>also:</u> c_letrec/2.

       <b>update_c_map(C_map::c_map(),</b> <b>M::cerl(),</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_map()</b> <b>|</b> <b>c_literal()</b>

       <b>update_c_map_pair(Old::c_map_pair(),</b> <b>Op::map_op(),</b> <b>K::cerl(),</b> <b>V::cerl())</b> <b>-&gt;</b> <b>c_map_pair()</b>

       <b>update_c_module(Node::c_module(),</b>    <b>Name::cerl(),</b>    <b>Exports::[cerl()],</b>    <b>Attrs::[{cerl(),</b>    <b>cerl()}],</b>
       <b>Es::[{cerl(),</b> <b>cerl()}])</b> <b>-&gt;</b> <b>c_module()</b>

              <u>See</u> <u>also:</u> c_module/4.

       <b>update_c_primop(Node::cerl(),</b> <b>Name::cerl(),</b> <b>Arguments::[cerl()])</b> <b>-&gt;</b> <b>c_primop()</b>

              <u>See</u> <u>also:</u> c_primop/2.

       <b>update_c_receive(Node::c_receive(),</b> <b>Clauses::[cerl()],</b> <b>Timeout::cerl(),</b> <b>Action::cerl())</b> <b>-&gt;</b> <b>c_receive()</b>

              <u>See</u> <u>also:</u> c_receive/3.

       <b>update_c_seq(Node::c_seq(),</b> <b>Argument::cerl(),</b> <b>Body::cerl())</b> <b>-&gt;</b> <b>c_seq()</b>

              <u>See</u> <u>also:</u> c_seq/2.

       <b>update_c_try(Node::c_try(),</b>  <b>Expr::cerl(),</b> <b>Vs::[cerl()],</b> <b>Body::cerl(),</b> <b>Evs::[cerl()],</b> <b>Handler::cerl())</b> <b>-&gt;</b>
       <b>c_try()</b>

              <u>See</u> <u>also:</u> c_try/5.

       <b>update_c_tuple(Node::c_tuple()</b> <b>|</b> <b>c_literal(),</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_tuple()</b> <b>|</b> <b>c_literal()</b>

              <u>See</u> <u>also:</u> c_tuple/1.

       <b>update_c_tuple_skel(Old::c_tuple(),</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_tuple()</b>

              <u>See</u> <u>also:</u> c_tuple_skel/1.

       <b>update_c_values(Node::c_values(),</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_values()</b>

              <u>See</u> <u>also:</u> c_values/1.

       <b>update_c_var(Node::c_var(),</b> <b>Name::var_name())</b> <b>-&gt;</b> <b>c_var()</b>

              <u>See</u> <u>also:</u> c_var/1.

       <b>update_data(Node::cerl(),</b> <b>CType::dtype(),</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_lct()</b>

              <u>See</u> <u>also:</u> make_data/2.

       <b>update_data_skel(Node::cerl(),</b> <b>CType::dtype(),</b> <b>Es::[cerl()])</b> <b>-&gt;</b> <b>c_lct()</b>

              <u>See</u> <u>also:</u> make_data_skel/2.

       <b>update_list(Node::cerl(),</b> <b>List::[cerl()])</b> <b>-&gt;</b> <b>cerl()</b>

              Equivalent to update_list(Old, List, none).

       <b>update_list(Node::cerl(),</b> <b>List::[cerl()],</b> <b>Tail::cerl()</b> <b>|</b> <b>none)</b> <b>-&gt;</b> <b>cerl()</b>

              <u>See</u> <u>also:</u> make_list/2, update_list/2.

       <b>update_tree(Node::cerl(),</b> <b>Gs::[[cerl()],</b> <b>...])</b> <b>-&gt;</b> <b>cerl()</b>

              Creates a syntax tree with the given subtrees, and the same type and annotations as the <u>Old</u>  node.
              This  is  equivalent  to  <u>ann_make_tree(get_ann(Node),</u>  <u>type(Node),</u>  <u>Groups)</u>, but potentially more
              efficient.

              <u>See</u> <u>also:</u> ann_make_tree/3, get_ann/1, type/1, update_tree/3.

       <b>update_tree(Node::cerl(),</b> <b>Type::ctype(),</b> <b>Gs::[[cerl()],</b> <b>...])</b> <b>-&gt;</b> <b>cerl()</b>

              Creates a syntax tree with the given type and subtrees, and the same annotations as the <u>Old</u>  node.
              This is equivalent to <u>ann_make_tree(get_ann(Node),</u> <u>Type,</u> <u>Groups)</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> ann_make_tree/3, get_ann/1, update_tree/2.

       <b>values_arity(Node::c_values())</b> <b>-&gt;</b> <b>non_neg_integer()</b>

              Returns the number of element subtrees of an abstract value list.

              Note: This is equivalent to <u>length(values_es(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> c_values/1, values_es/1.

       <b>values_es(Node::c_values())</b> <b>-&gt;</b> <b>[cerl()]</b>

              Returns the list of element subtrees of an abstract value list.

              <u>See</u> <u>also:</u> c_values/1, values_arity/1.

       <b>var_name(Node::c_var())</b> <b>-&gt;</b> <b>var_name()</b>

              Returns the name of an abstract variable.

              <u>See</u> <u>also:</u> c_var/1.

</pre><h4><b>AUTHORS</b></h4><pre>
       Richard Carlsson <u>&lt;<a href="mailto:carlsson.richard@gmail.com">carlsson.richard@gmail.com</a>&gt;</u>

                                                 compiler 8.0.4                                       <u><a href="../man3erl/cerl.3erl.html">cerl</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>