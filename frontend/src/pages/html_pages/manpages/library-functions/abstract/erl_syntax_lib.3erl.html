<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>erl_syntax_lib - Support library for abstract Erlang syntax trees.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       erl_syntax_lib - Support library for abstract Erlang syntax trees.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Support library for abstract Erlang syntax trees.

       This  module  contains  utility  functions  for working with the abstract data type defined in the module
       erl_syntax.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <b>appFunName()</b> <b>=</b> <b>{atom(),</b> <b>arity()}</b> <b>|</b> <b>{atom(),</b> <b>{atom(),</b> <b>arity()}}:</b>

         <b>field()</b> <b>=</b> <b>{atom(),</b> <b>{field_default(),</b> <b>field_type()}}:</b>

         <b>field_default()</b> <b>=</b> <b>none</b> <b>|</b> <b>erl_syntax:syntaxTree():</b>

         <b>field_type()</b> <b>=</b> <b>none</b> <b>|</b> <b>erl_syntax:syntaxTree():</b>

         <b>fields()</b> <b>=</b> <b>[field()]:</b>

         <b>functionN()</b> <b>=</b> <b>atom()</b> <b>|</b> <b>{atom(),</b> <b>arity()}:</b>

         <b>functionName()</b> <b>=</b> <b>functionN()</b> <b>|</b> <b>{atom(),</b> <b>functionN()}:</b>

         <b>info()</b> <b>=</b> <b>{atom(),</b> <b>[{atom(),</b> <b>erl_syntax:syntaxTree()}]}</b> <b>|</b> <b>{atom(),</b> <b>atom()}</b> <b>|</b> <b>atom():</b>

         <b>info_pair()</b> <b>=</b> <b>{key(),</b> <b>term()}:</b>

         <b>key()</b> <b>=</b> <b>attributes</b> <b>|</b> <b>errors</b> <b>|</b> <b>exports</b> <b>|</b> <b>functions</b> <b>|</b> <b>imports</b> <b>|</b> <b>module</b> <b>|</b> <b>records</b> <b>|</b> <b>warnings:</b>

         <b>name()</b> <b>=</b> <b>shortname()</b> <b>|</b> <b>{atom(),</b> <b>shortname()}:</b>

         <b>ordset(T)</b> <b>=</b> <b>ordsets:ordset(T):</b>

         <b>set(T)</b> <b>=</b> <b>sets:set(T):</b>

         <b>shortname()</b> <b>=</b> <b>atom()</b> <b>|</b> <b>{atom(),</b> <b>arity()}:</b>

         <b>syntaxTree()</b> <b>=</b> <b>erl_syntax:syntaxTree():</b>

           An abstract syntax tree. See the erl_syntax module for details.

         <b>typeName()</b> <b>=</b> <b>atom()</b> <b>|</b> <b>{module(),</b> <b>{atom(),</b> <b>arity()}}</b> <b>|</b> <b>{atom(),</b> <b>arity()}:</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>analyze_application(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>appFunName()</b> <b>|</b> <b>arity()</b>

              Returns the name of a called function. The result is a representation of the name of  the  applied
              function   <u>F/A</u>,   if   <u>Node</u>  represents  a  function  application  "<u>&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;X_1&lt;/em&gt;,</u>  <u>...,</u>
              <u>&lt;em&gt;X_A&lt;/em&gt;)</u>". If the function is not explicitly named (i.e., <u>F</u> is  given  by  some  expression),
              only the arity <u>A</u> is returned.

              The  evaluation  throws  <u>syntax_error</u>  if  <u>Node</u>  does  not  represent  a  well-formed  application
              expression.

              <u>See</u> <u>also:</u> analyze_function_name/1.

       <b>analyze_attribute(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>preprocessor</b> <b>|</b> <b>{atom(),</b> <b>term()}</b>

              Analyzes an attribute node. If <u>Node</u> represents a preprocessor directive, the atom <u>preprocessor</u>  is
              returned.  Otherwise,  if  <u>Node</u>  represents a module attribute "<u>-&lt;em&gt;Name&lt;/em&gt;...</u>", a tuple <u>{Name,</u>
              <u>Info}</u> is returned, where <u>Info</u> depends on <u>Name</u>, as follows:

                <u>{module,</u> <u>Info}</u>:
                  where <u>Info</u> <u>=</u> <u>analyze_module_attribute(Node)</u>.

                <u>{export,</u> <u>Info}</u>:
                  where <u>Info</u> <u>=</u> <u>analyze_export_attribute(Node)</u>.

                <u>{import,</u> <u>Info}</u>:
                  where <u>Info</u> <u>=</u> <u>analyze_import_attribute(Node)</u>.

                <u>{file,</u> <u>Info}</u>:
                  where <u>Info</u> <u>=</u> <u>analyze_file_attribute(Node)</u>.

                <u>{record,</u> <u>Info}</u>:
                  where <u>Info</u> <u>=</u> <u>analyze_record_attribute(Node)</u>.

                <u>{Name,</u> <u>Info}</u>:
                  where <u>{Name,</u> <u>Info}</u> <u>=</u> <u>analyze_wild_attribute(Node)</u>.

              The evaluation throws <u>syntax_error</u> if <u>Node</u> does not represent a well-formed module attribute.

              <u>See</u>  <u>also:</u>   analyze_export_attribute/1,   analyze_file_attribute/1,   analyze_import_attribute/1,
              analyze_module_attribute/1, analyze_record_attribute/1, analyze_wild_attribute/1.

       <b>analyze_export_attribute(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>[functionName()]</b>

              Returns  the list of function names declared by an export attribute. We do not guarantee that each
              name occurs at most once in the list. The order of listing is not defined.

              The evaluation throws <u>syntax_error</u> if <u>Node</u> does not represent a well-formed export attribute.

              <u>See</u> <u>also:</u> analyze_attribute/1.

       <b>analyze_file_attribute(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>{string(),</b> <b>integer()}</b>

              Returns the file name and line number of a <u>file</u> attribute. The result is the pair <u>{File,</u> <u>Line}</u>  if
              <u>Node</u> represents "<u>-file(File,</u> <u>Line).</u>".

              The evaluation throws <u>syntax_error</u> if <u>Node</u> does not represent a well-formed <u>file</u> attribute.

              <u>See</u> <u>also:</u> analyze_attribute/1.

       <b>analyze_form(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>{atom(),</b> <b>term()}</b> <b>|</b> <b>atom()</b>

              Analyzes  a  "source  code  form"  node.  If <u>Node</u> is a "form" type (cf. <u>erl_syntax:is_form/1</u>), the
              returned value is a tuple <u>{Type,</u> <u>Info}</u> where <u>Type</u> is the node type and <u>Info</u> depends  on  <u>Type</u>,  as
              follows:

                <u>{attribute,</u> <u>Info}</u>:
                  where <u>Info</u> <u>=</u> <u>analyze_attribute(Node)</u>.

                <u>{error_marker,</u> <u>Info}</u>:
                  where <u>Info</u> <u>=</u> <u>erl_syntax:error_marker_info(Node)</u>.

                <u>{function,</u> <u>Info}</u>:
                  where <u>Info</u> <u>=</u> <u>analyze_function(Node)</u>.

                <u>{warning_marker,</u> <u>Info}</u>:
                  where <u>Info</u> <u>=</u> <u>erl_syntax:warning_marker_info(Node)</u>.

              For other types of forms, only the node type is returned.

              The evaluation throws <u>syntax_error</u> if <u>Node</u> is not well-formed.

              <u>See</u>     <u>also:</u>     analyze_attribute/1,     analyze_function/1,     erl_syntax:error_marker_info/1,
              erl_syntax:is_form/1, erl_syntax:warning_marker_info/1.

       <b>analyze_forms(Forms::erl_syntax:forms())</b> <b>-&gt;</b> <b>[info_pair()]</b>

              Analyzes a sequence of "program forms". The given <u>Forms</u> may  be  a  single  syntax  tree  of  type
              <u>form_list</u>,  or  a list of "program form" syntax trees. The returned value is a list of pairs <u>{Key,</u>
              <u>Info}</u>, where each value of <u>Key</u> occurs at most once in the list; the absence of  a  particular  key
              indicates that there is no well-defined value for that key.

              Each  entry  in  the  resulting  list  contains  the following corresponding information about the
              program forms:

                <u>{attributes,</u> <u>Attributes}</u>:

                  * <u>Attributes</u> <u>=</u> <u>[{atom(),</u> <u>term()}]</u>

                  <u>Attributes</u> is a list of pairs representing the names and corresponding values of all so-called
                  "wild" attributes (as e.g. "<u>-compile(...)</u>") occurring in <u>Forms</u> (cf. <u>analyze_wild_attribute/1</u>).
                  We do not guarantee that each name occurs at most once in the list. The order  of  listing  is
                  not defined.

                <u>{errors,</u> <u>Errors}</u>:

                  * <u>Errors</u> <u>=</u> <u>[term()]</u>

                  <u>Errors</u>  is  the  list  of error descriptors of all <u>error_marker</u> nodes that occur in <u>Forms</u>. The
                  order of listing is not defined.

                <u>{exports,</u> <u>Exports}</u>:

                  * <u>Exports</u> <u>=</u> <u>[FunctionName]</u>

                  * <u>FunctionName</u> <u>=</u> <u>atom()</u> <u>|</u> <u>{atom(),</u> <u>integer()}</u> <u>|</u> <u>{ModuleName,</u> <u>FunctionName}</u>

                  * <u>ModuleName</u> <u>=</u> <u>atom()</u>

                  <u>Exports</u> is a list of representations of  those  function  names  that  are  listed  by  export
                  declaration  attributes  in  <u>Forms</u>  (cf. <u>analyze_export_attribute/1</u>). We do not guarantee that
                  each name occurs at most once in the list. The order of listing is not defined.

                <u>{functions,</u> <u>Functions}</u>:

                  * <u>Functions</u> <u>=</u> <u>[{atom(),</u> <u>integer()}]</u>

                  <u>Functions</u> is  a  list  of  the  names  of  the  functions  that  are  defined  in  <u>Forms</u>  (cf.
                  <u>analyze_function/1</u>).  We  do not guarantee that each name occurs at most once in the list. The
                  order of listing is not defined.

                <u>{imports,</u> <u>Imports}</u>:

                  * <u>Imports</u> <u>=</u> <u>[{Module,</u> <u>Names}]</u>

                  * <u>Module</u> <u>=</u> <u>atom()</u>

                  * <u>Names</u> <u>=</u> <u>[FunctionName]</u>

                  * <u>FunctionName</u> <u>=</u> <u>atom()</u> <u>|</u> <u>{atom(),</u> <u>integer()}</u> <u>|</u> <u>{ModuleName,</u> <u>FunctionName}</u>

                  * <u>ModuleName</u> <u>=</u> <u>atom()</u>

                  <u>Imports</u> is a list of pairs representing those module names and  corresponding  function  names
                  that  are  listed  by import declaration attributes in <u>Forms</u> (cf. <u>analyze_import_attribute/1</u>),
                  where each <u>Module</u> occurs at most once in <u>Imports</u>. We do not guarantee that each name occurs at
                  most once in the lists of function names. The order of listing is not defined.

                <u>{module,</u> <u>ModuleName}</u>:

                  * <u>ModuleName</u> <u>=</u> <u>atom()</u>

                  <u>ModuleName</u> is the name declared by a module attribute in <u>Forms</u>. If no module name  is  defined
                  in  <u>Forms</u>,  the  result  will  contain  no  entry  for the <u>module</u> key. If multiple module name
                  declarations should occur, all but the first will be ignored.

                <u>{records,</u> <u>Records}</u>:

                  * <u>Records</u> <u>=</u> <u>[{atom(),</u> <u>Fields}]</u>

                  * <u>Fields</u> <u>=</u> <u>[{atom(),</u> <u>{Default,</u> <u>Type}}]</u>

                  * <u>Default</u> <u>=</u> <u>none</u> <u>|</u> <u>syntaxTree()</u>

                  * <u>Type</u> <u>=</u> <u>none</u> <u>|</u> <u>syntaxTree()</u>

                  <u>Records</u> is a list of pairs representing the names and corresponding field declarations of  all
                  record declaration attributes occurring in <u>Forms</u>. For fields declared without a default value,
                  the corresponding value for <u>Default</u> is the atom <u>none</u>. Similarly, for fields declared without a
                  type,  the  corresponding value for <u>Type</u> is the atom <u>none</u> (cf. <u>analyze_record_attribute/1</u>). We
                  do not guarantee that each record name occurs at most once in the list. The order  of  listing
                  is not defined.

                <u>{warnings,</u> <u>Warnings}</u>:

                  * <u>Warnings</u> <u>=</u> <u>[term()]</u>

                  <u>Warnings</u> is the list of error descriptors of all <u>warning_marker</u> nodes that occur in <u>Forms</u>. The
                  order of listing is not defined.

              The evaluation throws <u>syntax_error</u> if an ill-formed Erlang construct is encountered.

              <u>See</u>     <u>also:</u>    analyze_export_attribute/1,    analyze_function/1,    analyze_import_attribute/1,
              analyze_record_attribute/1,       analyze_wild_attribute/1,        erl_syntax:error_marker_info/1,
              erl_syntax:warning_marker_info/1.

       <b>analyze_function(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>{atom(),</b> <b>arity()}</b>

              Returns  the  name  and  arity  of  a  function definition. The result is a pair <u>{Name,</u> <u>A}</u> if <u>Node</u>
              represents a function definition "<u>Name(&lt;em&gt;P_1&lt;/em&gt;,</u> <u>...,</u> <u>&lt;em&gt;P_A&lt;/em&gt;)</u> <u>-&gt;</u> <u>...</u>".

              The evaluation throws <u>syntax_error</u> if <u>Node</u> does not represent a well-formed function definition.

       <b>analyze_function_name(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>functionName()</b>

              Returns the function name represented by a syntax tree. If <u>Node</u> represents a function  name,  such
              as  "<u>foo/1</u>"  or  "<u>bloggs:fred/2</u>",  a  uniform  representation  of that name is returned. Different
              nestings of arity and module name qualifiers in the syntax tree does not affect the result.

              The evaluation throws <u>syntax_error</u> if <u>Node</u> does not represent a well-formed function name.

       <b>analyze_implicit_fun(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>functionName()</b>

              Returns the name of an implicit fun expression "<u>fun</u> <u>&lt;em&gt;F&lt;/em&gt;</u>". The result is a representation of
              the function name <u>F</u>. (Cf. <u>analyze_function_name/1</u>.)

              The evaluation throws <u>syntax_error</u> if <u>Node</u> does not represent a well-formed implicit fun.

              <u>See</u> <u>also:</u> analyze_function_name/1.

       <b>analyze_import_attribute(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>{atom(),</b> <b>[functionName()]}</b> <b>|</b> <b>atom()</b>

              Returns the module name and (if present) list of function names declared by an  import  attribute.
              The  returned value is an atom <u>Module</u> or a pair <u>{Module,</u> <u>Names}</u>, where <u>Names</u> is a list of function
              names declared as imported from the module named by <u>Module</u>. We do not  guarantee  that  each  name
              occurs at most once in <u>Names</u>. The order of listing is not defined.

              The evaluation throws <u>syntax_error</u> if <u>Node</u> does not represent a well-formed import attribute.

              <u>See</u> <u>also:</u> analyze_attribute/1.

       <b>analyze_module_attribute(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>atom()</b> <b>|</b> <b>{atom(),</b> <b>[atom()]}</b>

              Returns  the  module name and possible parameters declared by a module attribute. If the attribute
              is a plain module declaration such as <u>-module(name)</u>,  the  result  is  the  module  name.  If  the
              attribute  is a parameterized module declaration, the result is a tuple containing the module name
              and a list of the parameter variable names.

              The evaluation throws <u>syntax_error</u> if <u>Node</u> does not represent a well-formed module attribute.

              <u>See</u> <u>also:</u> analyze_attribute/1.

       <b>analyze_record_attribute(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>{atom(),</b> <b>fields()}</b>

              Returns the name and the list of fields of a record declaration attribute. The result  is  a  pair
              <u>{Name,</u>  <u>Fields}</u>,  if  <u>Node</u>  represents  "<u>-record(Name,</u>  <u>{...}).</u>",  where <u>Fields</u> is a list of pairs
              <u>{Label,</u>  <u>{Default,</u>  <u>Type}}</u>  for  each  field  "<u>Label</u>",  "<u>Label</u>  <u>=</u>  <u>&lt;em&gt;Default&lt;/em&gt;</u>",  "<u>Label</u>   <u>::</u>
              <u>&lt;em&gt;Type&lt;/em&gt;</u>", or "<u>Label</u> <u>=</u> <u>&lt;em&gt;Default&lt;/em&gt;</u> <u>::</u> <u>&lt;em&gt;Type&lt;/em&gt;</u>" in the declaration, listed in left-
              to-right  order.  If the field has no default-value declaration, the value for <u>Default</u> will be the
              atom <u>none</u>. If the field has no type declaration, the value for <u>Type</u> will be the atom <u>none</u>.  We  do
              not guarantee that each label occurs at most once in the list.

              The  evaluation  throws  <u>syntax_error</u>  if <u>Node</u> does not represent a well-formed record declaration
              attribute.

              <u>See</u> <u>also:</u> analyze_attribute/1, analyze_record_field/1.

       <b>analyze_record_expr(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>{atom(),</b> <b>info()}</b> <b>|</b> <b>atom()</b>

              Returns the record name and field name/names of a record expression. If <u>Node</u> has type <u>record_expr</u>,
              <u>record_index_expr</u> or <u>record_access</u>, a pair <u>{Type,</u> <u>Info}</u> is returned, otherwise  an  atom  <u>Type</u>  is
              returned. <u>Type</u> is the node type of <u>Node</u>, and <u>Info</u> depends on <u>Type</u>, as follows:

                <u>record_expr</u>::
                  <u>{atom(),</u> <u>[{atom(),</u> <u>Value}]}</u>

                <u>record_access</u>::
                  <u>{atom(),</u> <u>atom()}</u>

                <u>record_index_expr</u>::
                  <u>{atom(),</u> <u>atom()}</u>

              For  a  <u>record_expr</u>  node,  <u>Info</u>  represents  the  record name and the list of descriptors for the
              involved fields, listed in the order they appear. A field descriptor is a pair <u>{Label,</u> <u>Value}</u>,  if
              <u>Node</u>  represents  "<u>Label</u>  <u>=</u>  <u>&lt;em&gt;Value&lt;/em&gt;</u>". For a <u>record_access</u> node, <u>Info</u> represents the record
              name and the field name. For a <u>record_index_expr</u> node, <u>Info</u> represents the  record  name  and  the
              name field name.

              The evaluation throws <u>syntax_error</u> if <u>Node</u> represents a record expression that is not well-formed.

              <u>See</u> <u>also:</u> analyze_record_attribute/1, analyze_record_field/1.

       <b>analyze_record_field(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>field()</b>

              Returns  the  label,  value-expression, and type of a record field specifier. The result is a pair
              <u>{Label,</u> <u>{Default,</u> <u>Type}}</u>, if <u>Node</u>  represents  "<u>Label</u>",  "<u>Label</u>  <u>=</u>  <u>&lt;em&gt;Default&lt;/em&gt;</u>",  "<u>Label</u>  <u>::</u>
              <u>&lt;em&gt;Type&lt;/em&gt;</u>",  or  "<u>Label</u>  <u>=</u>  <u>&lt;em&gt;Default&lt;/em&gt;</u>  <u>::</u>  <u>&lt;em&gt;Type&lt;/em&gt;</u>".  If  the field has no value-
              expression, the value for <u>Default</u> will be the atom <u>none</u>. If the field has no type, the  value  for
              <u>Type</u> will be the atom <u>none</u>.

              The  evaluation  throws  <u>syntax_error</u>  if  <u>Node</u>  does  not  represent  a  well-formed record field
              specifier.

              <u>See</u> <u>also:</u> analyze_record_attribute/1, analyze_record_expr/1.

       <b>analyze_type_application(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>typeName()</b>

              Returns the name of a used type. The result is a representation of  the  name  of  the  used  pre-
              defined   or   local   type   <u>N/A</u>,   if   <u>Node</u>   represents   a   local  (user)  type  application
              "<u>&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T_1&lt;/em&gt;,</u> <u>...,</u> <u>&lt;em&gt;T_A&lt;/em&gt;)</u>", or a representation of the name of the used  remote
              type  <u>M:N/A</u> if <u>Node</u> represents a remote user type application "<u>&lt;em&gt;M&lt;/em&gt;:&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T_1&lt;/em&gt;,</u>
              <u>...,</u> <u>&lt;em&gt;T_A&lt;/em&gt;)</u>".

              The evaluation  throws  <u>syntax_error</u>  if  <u>Node</u>  does  not  represent  a  well-formed  (user)  type
              application expression.

              <u>See</u> <u>also:</u> analyze_type_name/1.

       <b>analyze_type_name(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>typeName()</b>

              Returns  the  type  name  represented  by  a  syntax tree. If <u>Node</u> represents a type name, such as
              "<u>foo/1</u>" or "<u>bloggs:fred/2</u>", a uniform representation of that name is returned.

              The evaluation throws <u>syntax_error</u> if <u>Node</u> does not represent a well-formed type name.

       <b>analyze_wild_attribute(Node::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>{atom(),</b> <b>term()}</b>

              Returns the name and value of a "wild" attribute. The result is the pair <u>{Name,</u>  <u>Value}</u>,  if  <u>Node</u>
              represents "<u>-Name(Value)</u>".

              Note  that no checking is done whether <u>Name</u> is a reserved attribute name such as <u>module</u> or <u>export</u>:
              it is assumed that the attribute is "wild".

              The evaluation throws <u>syntax_error</u> if <u>Node</u> does not represent a well-formed wild attribute.

              <u>See</u> <u>also:</u> analyze_attribute/1.

       <b>annotate_bindings(Tree::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>erl_syntax:syntaxTree()</b>

              Adds or updates annotations on nodes in  a  syntax  tree.  Equivalent  to  <u>annotate_bindings(Tree,</u>
              <u>Bindings)</u> where the top-level environment <u>Bindings</u> is taken from the annotation <u>{env,</u> <u>Bindings}</u> on
              the root node of <u>Tree</u>. An exception is thrown if no such annotation should exist.

              <u>See</u> <u>also:</u> annotate_bindings/2.

       <b>annotate_bindings(Tree::erl_syntax:syntaxTree(),</b> <b>Env::ordsets:ordset(atom()))</b> <b>-&gt;</b> <b>erl_syntax:syntaxTree()</b>

              Adds  or  updates  annotations  on  nodes  in  a  syntax tree. <u>Bindings</u> specifies the set of bound
              variables in the environment of the top level node. The following annotations are affected:

                * <u>{env,</u> <u>Vars}</u>, representing the input environment of the subtree.

                * <u>{bound,</u> <u>Vars}</u>, representing the variables that are bound in the subtree.

                * <u>{free,</u> <u>Vars}</u>, representing the free variables in the subtree.

              <u>Bindings</u> and <u>Vars</u> are ordered-set lists (cf. module <u>ordsets</u>) of atoms representing variable names.

              <u>See</u> <u>also:</u> <a href="../man3erl/ordsets.3erl.html">ordsets</a>(3erl), annotate_bindings/1.

       <b>fold(F::(erl_syntax:syntaxTree(),</b> <b>term())</b> <b>-&gt;</b> <b>term(),</b> <b>S::term(),</b> <b>Tree::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>term()</b>

              Folds a function over all nodes of a  syntax  tree.  The  result  is  the  value  of  <u>Function(X1,</u>
              <u>Function(X2,</u>  <u>...</u>  <u>Function(Xn,</u>  <u>Start)</u> <u>...</u> <u>))</u>, where <u>[X1,</u> <u>X2,</u> <u>...,</u> <u>Xn]</u> are the nodes of <u>Tree</u> in a
              post-order traversal.

              <u>See</u> <u>also:</u> fold_subtrees/3, foldl_listlist/3.

       <b>fold_subtrees(F::(erl_syntax:syntaxTree(),</b> <b>term())</b> <b>-&gt;</b> <b>term(),</b>  <b>S::term(),</b>  <b>Tree::erl_syntax:syntaxTree())</b>
       <b>-&gt;</b> <b>term()</b>

              Folds a function over the immediate subtrees of a syntax tree. This is similar to <u>fold/3</u>, but only
              on  the  immediate  subtrees of <u>Tree</u>, in left-to-right order; it does not include the root node of
              <u>Tree</u>.

              <u>See</u> <u>also:</u> fold/3.

       <b>foldl_listlist(F::(term(),</b> <b>term())</b> <b>-&gt;</b> <b>term(),</b> <b>S::term(),</b> <b>Ls::[[term()]])</b> <b>-&gt;</b> <b>term()</b>

              Like <u>lists:foldl/3</u>, but over a list of lists.

              <u>See</u> <u>also:</u> lists:foldl/3, fold/3.

       <b>function_name_expansions(Fs::[name()])</b> <b>-&gt;</b> <b>[{shortname(),</b> <b>name()}]</b>

              Creates a mapping from corresponding short names to full function names. Names are represented  by
              nested tuples of atoms and integers (cf. <u>analyze_function_name/1</u>). The result is a list containing
              a  pair  <u>{ShortName,</u>  <u>Name}</u>  for  each  element  <u>Name</u>  in  the given list, where the corresponding
              <u>ShortName</u> is the rightmost-innermost part of <u>Name</u>. The list thus represents a finite mapping  from
              unqualified names to the corresponding qualified names.

              Note: the resulting list can contain more than one tuple <u>{ShortName,</u> <u>Name}</u> for the same <u>ShortName</u>,
              possibly with different values for <u>Name</u>, depending on the given list.

              <u>See</u> <u>also:</u> analyze_function_name/1.

       <b>is_fail_expr(E::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns  <u>true</u>  if  <u>Tree</u>  represents  an  expression which never terminates normally. Note that the
              reverse does not apply. Currently, the detected cases are calls to <u>exit/1</u>, <u>throw/1</u>, <u>erlang:error/1</u>
              and <u>erlang:error/2</u>.

              <u>See</u> <u>also:</u> erlang:error/1, erlang:error/2, erlang:exit/1, erlang:throw/1.

       <b>limit(Tree::erl_syntax:syntaxTree(),</b> <b>Depth::integer())</b> <b>-&gt;</b> <b>erl_syntax:syntaxTree()</b>

              Equivalent to <u>limit(Tree,</u> <u>Depth,</u> <u>Text)</u> using the text <u>"..."</u> as default replacement.

              <u>See</u> <u>also:</u> limit/3, erl_syntax:text/1.

       <b>limit(Tree::erl_syntax:syntaxTree(),</b>      <b>Depth::integer(),</b>       <b>Node::erl_syntax:syntaxTree())</b>       <b>-&gt;</b>
       <b>erl_syntax:syntaxTree()</b>

              Limits  a  syntax  tree  to a specified depth. Replaces all non-leaf subtrees in <u>Tree</u> at the given
              <u>Depth</u> by <u>Node</u>. If <u>Depth</u> is negative, the result is always <u>Node</u>, even if <u>Tree</u> has no subtrees.

              When a group of subtrees (as e.g., the argument list of an <u>application</u> node) is at  the  specified
              depth,  and  there  are  two or more subtrees in the group, these will be collectively replaced by
              <u>Node</u> even if they are leaf nodes. Groups of subtrees that are above the specified  depth  will  be
              limited  in size, as if each subsequent tree in the group were one level deeper than the previous.
              E.g., if <u>Tree</u> represents a list of integers "<u>[1,</u> <u>2,</u> <u>3,</u> <u>4,</u> <u>5,</u> <u>6,</u> <u>7,</u>  <u>8,</u>  <u>9,</u>  <u>10]</u>",  the  result  of
              <u>limit(Tree,</u> <u>5)</u> will represent <u>[1,</u> <u>2,</u> <u>3,</u> <u>4,</u> <u>...]</u>.

              The  resulting  syntax  tree  is  typically  only  useful  for  pretty-printing  or similar visual
              formatting.

              <u>See</u> <u>also:</u> limit/2.

       <b>map(F::(erl_syntax:syntaxTree())</b>   <b>-&gt;</b>    <b>erl_syntax:syntaxTree(),</b>    <b>Tree::erl_syntax:syntaxTree())</b>    <b>-&gt;</b>
       <b>erl_syntax:syntaxTree()</b>

              Applies  a  function  to  each  node of a syntax tree. The result of each application replaces the
              corresponding original node. The order of traversal is bottom-up.

              <u>See</u> <u>also:</u> map_subtrees/2.

       <b>map_subtrees(F::(erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>erl_syntax:syntaxTree(),</b>  <b>Tree::erl_syntax:syntaxTree())</b>  <b>-&gt;</b>
       <b>erl_syntax:syntaxTree()</b>

              Applies  a  function  to  each  immediate subtree of a syntax tree. The result of each application
              replaces the corresponding original node.

              <u>See</u> <u>also:</u> map/2.

       <b>mapfold(F::(erl_syntax:syntaxTree(),</b>   <b>term())</b>   <b>-&gt;</b>   <b>{erl_syntax:syntaxTree(),</b>    <b>term()},</b>    <b>S::term(),</b>
       <b>Tree::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>{erl_syntax:syntaxTree(),</b> <b>term()}</b>

              Combines  map  and  fold  in  a single operation. This is similar to <u>map/2</u>, but also propagates an
              extra value from each application of the <u>Function</u> to the next, while doing a post-order  traversal
              of  the  tree  like  <u>fold/3</u>.  The value <u>Start</u> is passed to the first function application, and the
              final result is the result of the last application.

              <u>See</u> <u>also:</u> fold/3, map/2.

       <b>mapfold_subtrees(F::(erl_syntax:syntaxTree(),</b> <b>term())</b> <b>-&gt;</b>  <b>{erl_syntax:syntaxTree(),</b>  <b>term()},</b>  <b>S::term(),</b>
       <b>Tree::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>{erl_syntax:syntaxTree(),</b> <b>term()}</b>

              Does  a  mapfold  operation  over  the  immediate  subtrees  of  a syntax tree. This is similar to
              <u>mapfold/3</u>, but only on the immediate subtrees of <u>Tree</u>, in left-to-right order; it does not include
              the root node of <u>Tree</u>.

              <u>See</u> <u>also:</u> mapfold/3.

       <b>mapfoldl_listlist(F::(term(),</b> <b>term())</b> <b>-&gt;</b> <b>{term(),</b> <b>term()},</b>  <b>S::term(),</b>  <b>Ls::[[term()]])</b>  <b>-&gt;</b>  <b>{[[term()]],</b>
       <b>term()}</b>

              Like  <u>lists:mapfoldl/3</u>,  but  over  a  list of lists. The list of lists in the result has the same
              structure as the given list of lists.

       <b>new_variable_name(S::sets:set(atom()))</b> <b>-&gt;</b> <b>atom()</b>

              Returns  an  atom  which  is  not   already   in   the   set   <u>Used</u>.   This   is   equivalent   to
              <u>new_variable_name(Function,</u>  <u>Used)</u>,  where  <u>Function</u> maps a given integer <u>N</u> to the atom whose name
              consists of "<u>V</u>" followed by the numeral for <u>N</u>.

              <u>See</u> <u>also:</u> new_variable_name/2.

       <b>new_variable_name(F::(integer())</b> <b>-&gt;</b> <b>atom(),</b> <b>S::sets:set(atom()))</b> <b>-&gt;</b> <b>atom()</b>

              Returns a user-named atom which is not already in the set <u>Used</u>. The atom is generated by  applying
              the  given  <u>Function</u> to a generated integer. Integers are generated using an algorithm which tries
              to keep the names randomly distributed within a reasonably small range relative to the  number  of
              elements in the set.

              This  function  uses  the module <u>rand</u> to generate new keys. The seed it uses may be initialized by
              calling <u>rand:seed/1</u> or <u>rand:seed/2</u> before this function is first called.

              <u>See</u> <u>also:</u> <a href="../man3erl/random.3erl.html">random</a>(3erl), <a href="../man3erl/sets.3erl.html">sets</a>(3erl), new_variable_name/1.

       <b>new_variable_names(N::integer(),</b> <b>S::sets:set(atom()))</b> <b>-&gt;</b> <b>[atom()]</b>

              Like <u>new_variable_name/1</u>, but generates a list of <u>N</u> new names.

              <u>See</u> <u>also:</u> new_variable_name/1.

       <b>new_variable_names(N::integer(),</b> <b>F::(integer())</b> <b>-&gt;</b> <b>atom(),</b> <b>S::sets:set(atom()))</b> <b>-&gt;</b> <b>[atom()]</b>

              Like <u>new_variable_name/2</u>, but generates a list of <u>N</u> new names.

              <u>See</u> <u>also:</u> new_variable_name/2.

       <b>strip_comments(Tree::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>erl_syntax:syntaxTree()</b>

              Removes all comments from all nodes of a syntax tree.  All  other  attributes  (such  as  position
              information) remain unchanged. Standalone comments in form lists are removed; any other standalone
              comments are changed into null-comments (no text, no indentation).

       <b>to_comment(Tree::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>erl_syntax:syntaxTree()</b>

              Equivalent to to_comment(Tree, "% ").

       <b>to_comment(Tree::erl_syntax:syntaxTree(),</b> <b>Prefix::string())</b> <b>-&gt;</b> <b>erl_syntax:syntaxTree()</b>

              Equivalent  to  <u>to_comment(Tree,</u>  <u>Prefix,</u>  <u>F)</u>  for  a default formatting function <u>F</u>. The default <u>F</u>
              simply calls <u>erl_prettypr:format/1</u>.

              <u>See</u> <u>also:</u> to_comment/3, erl_prettypr:format/1.

       <b>to_comment(Tree::erl_syntax:syntaxTree(),</b> <b>Prefix::string(),</b> <b>F::(erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>string())</b>  <b>-&gt;</b>
       <b>erl_syntax:syntaxTree()</b>

              Transforms  a  syntax tree into an abstract comment. The lines of the comment contain the text for
              <u>Node</u>, as produced by the given <u>Printer</u> function. Each line of  the  comment  is  prefixed  by  the
              string <u>Prefix</u> (this does not include the initial "<u>%</u>" character of the comment line).

              For example, the result of <u>to_comment(erl_syntax:abstract([a,b,c]))</u> represents

                        %% [a,b,c]

              (cf. <u>to_comment/1</u>).

              Note:  the  text  returned  by  the  formatting function will be split automatically into separate
              comment lines at each line break. No extra work is needed.

              <u>See</u> <u>also:</u> to_comment/1, to_comment/2.

       <b>variables(Tree::erl_syntax:syntaxTree())</b> <b>-&gt;</b> <b>sets:set(atom())</b>

              Returns the names of variables occurring in a syntax tree, The result is a set of  variable  names
              represented by atoms. Macro names are not included.

              <u>See</u> <u>also:</u> <a href="../man3erl/sets.3erl.html">sets</a>(3erl).

</pre><h4><b>AUTHORS</b></h4><pre>
       Richard Carlsson <u>&lt;<a href="mailto:carlsson.richard@gmail.com">carlsson.richard@gmail.com</a>&gt;</u>

                                                syntax_tools 2.6                            <u><a href="../man3erl/erl_syntax_lib.3erl.html">erl_syntax_lib</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>