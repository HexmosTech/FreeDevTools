<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL::Abstract::Pg - PostgreSQL features for SQL::Abstract</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsql-abstract-pg-perl">libsql-abstract-pg-perl_1.0-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SQL::Abstract::Pg - PostgreSQL features for SQL::Abstract

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use SQL::Abstract::Pg;

         my $abstract = SQL::Abstract::Pg-&gt;new;
         say $abstract-&gt;select('some_table');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       SQL::Abstract::Pg extends SQL::Abstract with a few PostgreSQL features used by Mojo::Pg.

   <b>JSON</b>
       In many places (as supported by SQL::Abstract) you can use the "-json" unary op to encode JSON from Perl
       data structures.

         # "UPDATE some_table SET foo = '[1,2,3]' WHERE bar = 23"
         $abstract-&gt;update('some_table', {foo =&gt; {-json =&gt; [1, 2, 3]}}, {bar =&gt; 23});

         # "SELECT * FROM some_table WHERE foo = '[1,2,3]'"
         $abstract-&gt;select('some_table', '*', {foo =&gt; {'=' =&gt; {-json =&gt; [1, 2, 3]}}});

</pre><h4><b>INSERT</b></h4><pre>
         $abstract-&gt;insert($table, \@values || \%fieldvals, \%options);

   <b>ON</b> <b>CONFLICT</b>
       The "on_conflict" option can be used to generate "INSERT" queries with "ON CONFLICT" clauses. So far,
       "undef" to pass "DO NOTHING", array references to pass "DO UPDATE" with conflict targets and a "SET"
       expression, scalar references to pass literal SQL and array reference references to pass literal SQL with
       bind values are supported.

         # "INSERT INTO t (a) VALUES ('b') ON CONFLICT DO NOTHING"
         $abstract-&gt;insert('t', {a =&gt; 'b'}, {on_conflict =&gt; undef});

         # "INSERT INTO t (a) VALUES ('b') ON CONFLICT DO NOTHING"
         $abstract-&gt;insert('t', {a =&gt; 'b'}, {on_conflict =&gt; \'do nothing'});

       This includes operations commonly referred to as "upsert".

         # "INSERT INTO t (a) VALUES ('b') ON CONFLICT (a) DO UPDATE SET a = 'c'"
         $abstract-&gt;insert('t', {a =&gt; 'b'}, {on_conflict =&gt; [a =&gt; {a =&gt; 'c'}]});

         # "INSERT INTO t (a, b) VALUES ('c', 'd') ON CONFLICT (a, b) DO UPDATE SET a = 'e'"
         $abstract-&gt;insert('t', {a =&gt; 'c', b =&gt; 'd'}, {on_conflict =&gt; [['a', 'b'] =&gt; {a =&gt; 'e'}]});

         # "INSERT INTO t (a) VALUES ('b') ON CONFLICT (a) DO UPDATE SET a = 'c'"
         $abstract-&gt;insert('t', {a =&gt; 'b'}, {on_conflict =&gt; \['(a) do update set a = ?', 'c']});

</pre><h4><b>SELECT</b></h4><pre>
         $abstract-&gt;select($source, $fields, $where, $order);
         $abstract-&gt;select($source, $fields, $where, \%options);

   <b>AS</b>
       The $fields argument now also accepts array references containing array references with field names and
       aliases, as well as array references containing scalar references to pass literal SQL and array reference
       references to pass literal SQL with bind values.

         # "SELECT foo AS bar FROM some_table"
         $abstract-&gt;select('some_table', [[foo =&gt; 'bar']]);

         # "SELECT foo, bar AS baz, yada FROM some_table"
         $abstract-&gt;select('some_table', ['foo', [bar =&gt; 'baz'], 'yada']);

         # "SELECT EXTRACT(EPOCH FROM foo) AS foo, bar FROM some_table"
         $abstract-&gt;select('some_table', [\'extract(epoch from foo) AS foo', 'bar']);

         # "SELECT 'test' AS foo, bar FROM some_table"
         $abstract-&gt;select('some_table', [\['? AS foo', 'test'], 'bar']);

   <b>JOIN</b>
       The $source argument now also accepts array references containing not only table names, but also array
       references with tables to generate "JOIN" clauses for.

         # "SELECT * FROM foo JOIN bar ON (bar.foo_id = foo.id)"
         $abstract-&gt;select(['foo', ['bar', foo_id =&gt; 'id']]);

         # "SELECT * FROM foo JOIN bar ON (foo.id = bar.foo_id)"
         $abstract-&gt;select(['foo', ['bar', 'foo.id' =&gt; 'bar.foo_id']]);

         # "SELECT * FROM a JOIN b ON (b.a_id = a.id) JOIN c ON (c.a_id = a.id)"
         $abstract-&gt;select(['a', ['b', a_id =&gt; 'id'], ['c', a_id =&gt; 'id']]);

         # "SELECT * FROM foo LEFT JOIN bar ON (bar.foo_id = foo.id)"
         $abstract-&gt;select(['foo', [-left =&gt; 'bar', foo_id =&gt; 'id']]);

         # "SELECT * FROM a LEFT JOIN b ON (b.a_id = a.id AND b.a_id2 = a.id2)"
         $abstract-&gt;select(['a', [-left =&gt; 'b', a_id =&gt; 'id', a_id2 =&gt; 'id2']]);

   <b>ORDER</b> <b>BY</b>
       Alternatively to the $order argument accepted by SQL::Abstract you can now also pass a hash reference
       with various options. This includes "order_by", which takes the same values as the $order argument.

         # "SELECT * FROM some_table ORDER BY foo DESC"
         $abstract-&gt;select('some_table', '*', undef, {order_by =&gt; {-desc =&gt; 'foo'}});

   <b>LIMIT/OFFSET</b>
       The "limit" and "offset" options can be used to generate "SELECT" queries with "LIMIT" and "OFFSET"
       clauses.

         # "SELECT * FROM some_table LIMIT 10"
         $abstract-&gt;select('some_table', '*', undef, {limit =&gt; 10});

         # "SELECT * FROM some_table OFFSET 5"
         $abstract-&gt;select('some_table', '*', undef, {offset =&gt; 5});

         # "SELECT * FROM some_table LIMIT 10 OFFSET 5"
         $abstract-&gt;select('some_table', '*', undef, {limit =&gt; 10, offset =&gt; 5});

   <b>GROUP</b> <b>BY</b>
       The "group_by" option can be used to generate "SELECT" queries with "GROUP BY" clauses. So far, array
       references to pass a list of fields and scalar references to pass literal SQL are supported.

         # "SELECT * FROM some_table GROUP BY foo, bar"
         $abstract-&gt;select('some_table', '*', undef, {group_by =&gt; ['foo', 'bar']});

         # "SELECT * FROM some_table GROUP BY foo, bar"
         $abstract-&gt;select('some_table', '*', undef, {group_by =&gt; \'foo, bar'});

   <b>HAVING</b>
       The "having" option can be used to generate "SELECT" queries with "HAVING" clauses, which takes the same
       values as the $where argument.

         # "SELECT * FROM t GROUP BY a HAVING b = 'c'"
         $abstract-&gt;select('t', '*', undef, {group_by =&gt; ['a'], having =&gt; {b =&gt; 'c'}});

   <b>FOR</b>
       The "for" option can be used to generate "SELECT" queries with "FOR" clauses. So far, the scalar value
       "update" to pass "UPDATE" and scalar references to pass literal SQL are supported.

         # "SELECT * FROM some_table FOR UPDATE"
         $abstract-&gt;select('some_table', '*', undef, {for =&gt; 'update'});

         # "SELECT * FROM some_table FOR UPDATE SKIP LOCKED"
         $abstract-&gt;select('some_table', '*', undef, {for =&gt; \'update skip locked'});

</pre><h4><b>METHODS</b></h4><pre>
       SQL::Abstract::Pg inherits all methods from SQL::Abstract.

</pre><h4><b>AUTHOR</b></h4><pre>
       Sebastian Riedel, "<a href="mailto:sri@cpan.org">sri@cpan.org</a>".

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2014-2021, Sebastian Riedel and others.

       This program is free software, you can redistribute it and/or modify it under the terms of the Artistic
       License version 2.0.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       &lt;https://github.com/mojolicious/sql-abstract-pg&gt;, Mojolicious::Guides, &lt;https://mojolicious.org&gt;.

perl v5.32.1                                       2021-09-29                             <u>SQL::Abstract::<a href="../man3pm/Pg.3pm.html">Pg</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>