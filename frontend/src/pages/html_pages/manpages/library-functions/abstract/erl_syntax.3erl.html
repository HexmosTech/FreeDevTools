<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>erl_syntax - Abstract Erlang syntax trees.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       erl_syntax - Abstract Erlang syntax trees.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Abstract Erlang syntax trees.

       This  module  defines an abstract data type for representing Erlang source code as syntax trees, in a way
       that is backwards compatible with the data structures created  by  the  Erlang  standard  library  parser
       module  <u>erl_parse</u> (often referred to as "parse trees", which is a bit of a misnomer). This means that all
       <u>erl_parse</u> trees are valid abstract syntax trees, but the reverse is not true: abstract syntax  trees  can
       in general not be used as input to functions expecting an <u>erl_parse</u> tree. However, as long as an abstract
       syntax  tree represents a correct Erlang program, the function revert/1 should be able to transform it to
       the corresponding <u>erl_parse</u> representation.

       A recommended starting point for the first-time user is the documentation of the syntaxTree() data  type,
       and the function type/1.

       <u>NOTES:</u>

       This  module  deals  with the composition and decomposition of <u>syntactic</u> entities (as opposed to semantic
       ones); its purpose is to hide all direct references to  the  data  structures  used  to  represent  these
       entities.  With  few exceptions, the functions in this module perform no semantic interpretation of their
       inputs, and in general, the user is assumed to pass type-correct arguments - if this  is  not  done,  the
       effects are not defined.

       With  the  exception  of the erl_parse() data structures, the internal representations of abstract syntax
       trees are subject  to  change  without  notice,  and  should  not  be  documented  outside  this  module.
       Furthermore,  we do not give any guarantees on how an abstract syntax tree may or may not be represented,
       <u>with</u> <u>the</u> <u>following</u> <u>exceptions</u>: no syntax tree is represented by a single atom, such as <u>none</u>,  by  a  list
       constructor  <u>[X</u>  <u>|</u> <u>Y]</u>, or by the empty list <u>[]</u>. This can be relied on when writing functions that operate
       on syntax trees.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <b>annotation_or_location()</b> <b>=</b> <b>erl_anno:anno()</b> <b>|</b> <b>erl_anno:location():</b>

         <b>encoding()</b> <b>=</b> <b>utf8</b> <b>|</b> <b>unicode</b> <b>|</b> <b>latin1:</b>

         <b>erl_parse()</b> <b>=</b> <b>erl_parse:abstract_clause()</b> <b>|</b> <b>erl_parse:abstract_expr()</b> <b>|</b> <b>erl_parse:abstract_form()</b> <b>|</b>
         <b>erl_parse:abstract_type()</b> <b>|</b> <b>erl_parse:form_info()</b> <b>|</b> <b>erl_parse:af_binelement(term())</b> <b>|</b>
         <b>erl_parse:af_generator()</b> <b>|</b> <b>erl_parse:af_remote_function():</b>

         <b>forms()</b> <b>=</b> <b>syntaxTree()</b> <b>|</b> <b>[syntaxTree()]:</b>

         <b>guard()</b> <b>=</b> <b>none</b> <b>|</b> <b>syntaxTree()</b> <b>|</b> <b>[syntaxTree()]</b> <b>|</b> <b>[[syntaxTree()]]:</b>

         <b>padding()</b> <b>=</b> <b>none</b> <b>|</b> <b>integer():</b>

         <b>syntaxTree()</b> <b>=</b> <b>tree()</b> <b>|</b> <b>wrapper()</b> <b>|</b> <b>erl_parse():</b>

         <b>syntaxTreeAttributes()</b> <b>=</b> <b>#attr{pos=term(),</b> <b>ann=[term()],</b> <b>com=none</b> <b>|</b> <b>#com{pre=[syntaxTree()],</b>
         <b>post=[syntaxTree()]}}:</b>

         <b>tree()</b> <b>=</b> <b>#tree{type=atom(),</b> <b>attr=#attr{pos=term(),</b> <b>ann=[term()],</b> <b>com=none</b> <b>|</b> <b>#com{pre=[syntaxTree()],</b>
         <b>post=[syntaxTree()]}},</b> <b>data=term()}:</b>

         <b>wrapper()</b> <b>=</b> <b>#wrapper{type=atom(),</b> <b>attr=#attr{pos=term(),</b> <b>ann=[term()],</b> <b>com=none</b> <b>|</b>
         <b>#com{pre=[syntaxTree()],</b> <b>post=[syntaxTree()]}},</b> <b>tree=erl_parse()}:</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>abstract(T::term())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the syntax tree corresponding to an Erlang term. <u>Term</u> must be a literal  term,  i.e.,  one
              that  can  be represented as a source code literal. Thus, it may not contain a process identifier,
              port, reference or function value as a subterm. The  function  recognises  printable  strings,  in
              order to get a compact and readable representation. Evaluation fails with reason <u>badarg</u> if <u>Term</u> is
              not a literal term.

              <u>See</u> <u>also:</u> concrete/1, is_literal/1.

       <b>add_ann(A::term(),</b> <b>Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Appends the term <u>Annotation</u> to the list of user annotations of <u>Node</u>.

              Note:  this  is  equivalent  to  <u>set_ann(Node,</u> <u>[Annotation</u> <u>|</u> <u>get_ann(Node)])</u>, but potentially more
              efficient.

              <u>See</u> <u>also:</u> get_ann/1, set_ann/2.

       <b>add_postcomments(Cs::[syntaxTree()],</b> <b>Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Appends <u>Comments</u> to the post-comments of <u>Node</u>.

              Note: This is  equivalent  to  <u>set_postcomments(Node,</u>  <u>get_postcomments(Node)</u>  <u>++</u>  <u>Comments)</u>,  but
              potentially more efficient.

              <u>See</u> <u>also:</u> add_precomments/2, comment/2, get_postcomments/1, join_comments/2, set_postcomments/2.

       <b>add_precomments(Cs::[syntaxTree()],</b> <b>Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Appends <u>Comments</u> to the pre-comments of <u>Node</u>.

              Note:  This  is  equivalent  to  <u>set_precomments(Node,</u>  <u>get_precomments(Node)</u>  <u>++</u>  <u>Comments)</u>,  but
              potentially more efficient.

              <u>See</u> <u>also:</u> add_postcomments/2, comment/2, get_precomments/1, join_comments/2, set_precomments/2.

       <b>annotated_type(Name::syntaxTree(),</b> <b>Type::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract annotated type expression. The result represents "<u>Name</u> <u>::</u> <u>Type</u>".

              <u>See</u> <u>also:</u> annotated_type_body/1, annotated_type_name/1.

       <b>annotated_type_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the type subtrees of an <u>annotated_type</u> node.

              <u>See</u> <u>also:</u> annotated_type/2.

       <b>annotated_type_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of an <u>annotated_type</u> node.

              <u>See</u> <u>also:</u> annotated_type/2.

       <b>application(Operator::syntaxTree(),</b> <b>Arguments::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract function application expression. If <u>Arguments</u> is <u>[A1,</u>  <u>...,</u>  <u>An]</u>,  the  result
              represents "<u>Operator(A1,</u> <u>...,</u> <u>An)</u>".

              <u>See</u> <u>also:</u> application/3, application_arguments/1, application_operator/1.

       <b>application(Module::none</b> <b>|</b> <b>syntaxTree(),</b> <b>Name::syntaxTree(),</b> <b>Arguments::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract function application expression. If <u>Module</u> is <u>none</u>, this is call is equivalent
              to      <u>application(Function,</u>      <u>Arguments)</u>,      otherwise      it     is     equivalent     to
              <u>application(module_qualifier(Module,</u> <u>Function),</u> <u>Arguments)</u>.

              (This is a utility function.)

              <u>See</u> <u>also:</u> application/2, module_qualifier/2.

       <b>application_arguments(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of argument subtrees of an <u>application</u> node.

              <u>See</u> <u>also:</u> application/2.

       <b>application_operator(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the operator subtree of an <u>application</u> node.

              Note: if <u>Node</u> represents "<u>M:F(...)</u>", then the result is the subtree representing "<u>M:F</u>".

              <u>See</u> <u>also:</u> application/2, module_qualifier/2.

       <b>arity_qualifier(Body::syntaxTree(),</b> <b>Arity::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract arity qualifier. The result represents "<u>Body/Arity</u>".

              <u>See</u> <u>also:</u> arity_qualifier_argument/1, arity_qualifier_body/1.

       <b>arity_qualifier_argument(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the argument (the arity) subtree of an <u>arity_qualifier</u> node.

              <u>See</u> <u>also:</u> arity_qualifier/2.

       <b>arity_qualifier_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the body subtree of an <u>arity_qualifier</u> node.

              <u>See</u> <u>also:</u> arity_qualifier/2.

       <b>atom(Name::atom()</b> <b>|</b> <b>string())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract atom literal. The print name of the atom is the character sequence represented
              by <u>Name</u>.

              <u>See</u> <u>also:</u> atom_literal/1, atom_literal/2, atom_name/1, atom_value/1, is_atom/2.

       <b>atom_literal(Node::syntaxTree())</b> <b>-&gt;</b> <b>string()</b>

              Returns the literal string represented by an <u>atom</u> node.  This  includes  surrounding  single-quote
              characters if necessary. Characters beyond 255 will be escaped.

              Note  that  e.g. the result of <u>atom("x\ny")</u> represents any and all of `x\ny'', `x\12y'', `x\012y''
              and `x\^Jy\''; see string/1.

              <u>See</u> <u>also:</u> atom/1, string/1.

       <b>atom_literal(Node,</b> <b>X2)</b> <b>-&gt;</b> <b>term()</b>

              Returns the literal string represented by an <u>atom</u> node.  This  includes  surrounding  single-quote
              characters if necessary. Depending on the encoding a character beyond 255 will be escaped (<u>latin1</u>)
              or copied as is (<u>utf8</u>).

              <u>See</u> <u>also:</u> atom/1, atom_literal/1, string/1.

       <b>atom_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>string()</b>

              Returns the printname of an <u>atom</u> node.

              <u>See</u> <u>also:</u> atom/1.

       <b>atom_value(Node::syntaxTree())</b> <b>-&gt;</b> <b>atom()</b>

              Returns the value represented by an <u>atom</u> node.

              <u>See</u> <u>also:</u> atom/1.

       <b>attribute(Name::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to attribute(Name, none).

       <b>attribute(Name::syntaxTree(),</b> <b>Args::none</b> <b>|</b> <b>[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  program  attribute.  If  <u>Arguments</u>  is <u>[A1,</u> <u>...,</u> <u>An]</u>, the result represents
              "<u>-Name(A1,</u> <u>...,</u> <u>An).</u>". Otherwise, if <u>Arguments</u> is <u>none</u>, the result represents "<u>-Name.</u>". The latter
              form makes it possible to represent preprocessor directives  such  as  "<u>-endif.</u>".  Attributes  are
              source code forms.

              Note:  The  preprocessor  macro  definition  directive  "<u>-define(Name,</u>  <u>Body).</u>" has relatively few
              requirements on the syntactical form of <u>Body</u> (viewed as a sequence of tokens). The <u>text</u> node  type
              can be used for a <u>Body</u> that is not a normal Erlang construct.

              <u>See</u> <u>also:</u> attribute/1, attribute_arguments/1, attribute_name/1, is_form/1, text/1.

       <b>attribute_arguments(Node::syntaxTree())</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>[syntaxTree()]</b>

              Returns  the  list of argument subtrees of an <u>attribute</u> node, if any. If <u>Node</u> represents "<u>-Name.</u>",
              the result is <u>none</u>. Otherwise, if  <u>Node</u>  represents  "<u>-Name(E1,</u>  <u>...,</u>  <u>En).</u>",  <u>[E1,</u>  <u>...,</u>  <u>E1]</u>  is
              returned.

              <u>See</u> <u>also:</u> attribute/1.

       <b>attribute_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of an <u>attribute</u> node.

              <u>See</u> <u>also:</u> attribute/1.

       <b>binary(List::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  binary-object  template.  If <u>Fields</u> is <u>[F1,</u> <u>...,</u> <u>Fn]</u>, the result represents
              "<u>&lt;&lt;F1,</u> <u>...,</u> <u>Fn&gt;&gt;</u>".

              <u>See</u> <u>also:</u> binary_field/2, binary_fields/1.

       <b>binary_comp(Template::syntaxTree(),</b> <b>Body::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract binary comprehension.  If  <u>Body</u>  is  <u>[E1,</u>  <u>...,</u>  <u>En]</u>,  the  result  represents
              "<u>&lt;&lt;Template</u> <u>||</u> <u>E1,</u> <u>...,</u> <u>En&gt;&gt;</u>".

              <u>See</u> <u>also:</u> binary_comp_body/1, binary_comp_template/1, generator/2.

       <b>binary_comp_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of body subtrees of a <u>binary_comp</u> node.

              <u>See</u> <u>also:</u> binary_comp/2.

       <b>binary_comp_template(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the template subtree of a <u>binary_comp</u> node.

              <u>See</u> <u>also:</u> binary_comp/2.

       <b>binary_field(Body::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to binary_field(Body, []).

       <b>binary_field(Body::syntaxTree(),</b> <b>Types::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  binary  template  field.  If  <u>Types</u>  is  the  empty list, the result simply
              represents "<u>Body</u>", otherwise, if <u>Types</u> is <u>[T1,</u> <u>...,</u> <u>Tn]</u>, the result represents "<u>Body/T1-...-Tn</u>".

              <u>See</u> <u>also:</u>  binary/1,  binary_field/1,  binary_field/3,  binary_field_body/1,  binary_field_size/1,
              binary_field_types/1.

       <b>binary_field(Body::syntaxTree(),</b> <b>Size::none</b> <b>|</b> <b>syntaxTree(),</b> <b>Types::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates   an   abstract   binary   template  field.  If  <u>Size</u>  is  <u>none</u>,  this  is  equivalent  to
              "<u>binary_field(Body,</u> <u>Types)</u>", otherwise  it  is  equivalent  to  "<u>binary_field(size_qualifier(Body,</u>
              <u>Size),</u> <u>Types)</u>".

              (This is a utility function.)

              <u>See</u> <u>also:</u> binary/1, binary_field/2, size_qualifier/2.

       <b>binary_field_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the body subtree of a <u>binary_field</u>.

              <u>See</u> <u>also:</u> binary_field/2.

       <b>binary_field_size(Node::syntaxTree())</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>syntaxTree()</b>

              Returns  the size specifier subtree of a <u>binary_field</u> node, if any. If <u>Node</u> represents "<u>Body:Size</u>"
              or "<u>Body:Size/T1,</u> <u>...,</u> <u>Tn</u>", the result is <u>Size</u>, otherwise <u>none</u> is returned.

              (This is a utility function.)

              <u>See</u> <u>also:</u> binary_field/2, binary_field/3.

       <b>binary_field_types(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of type-specifier subtrees of a <u>binary_field</u> node. If  <u>Node</u>  represents  "<u>.../T1,</u>
              <u>...,</u> <u>Tn</u>", the result is <u>[T1,</u> <u>...,</u> <u>Tn]</u>, otherwise the result is the empty list.

              <u>See</u> <u>also:</u> binary_field/2.

       <b>binary_fields(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of field subtrees of a <u>binary</u> node.

              <u>See</u> <u>also:</u> binary/1, binary_field/2.

       <b>binary_generator(Pattern::syntaxTree(),</b> <b>Body::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract binary_generator. The result represents "<u>Pattern</u> <u>&lt;-</u> <u>Body</u>".

              <u>See</u> <u>also:</u> binary_comp/2, binary_generator_body/1, binary_generator_pattern/1, list_comp/2.

       <b>binary_generator_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the body subtree of a <u>generator</u> node.

              <u>See</u> <u>also:</u> binary_generator/2.

       <b>binary_generator_pattern(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the pattern subtree of a <u>generator</u> node.

              <u>See</u> <u>also:</u> binary_generator/2.

       <b>bitstring_type(M::syntaxTree(),</b> <b>N::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract bitstring type. The result represents "<u>&lt;&lt;_:M,</u> <b>_</b><u>:_*N&gt;&gt;</u>".

              <u>See</u> <u>also:</u> bitstring_type_m/1, bitstring_type_n/1.

       <b>bitstring_type_m(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the number of start bits, <u>M</u>, of a <u>bitstring_type</u> node.

              <u>See</u> <u>also:</u> bitstring_type/2.

       <b>bitstring_type_n(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the segment size, <u>N</u>, of a <u>bitstring_type</u> node.

              <u>See</u> <u>also:</u> bitstring_type/2.

       <b>block_expr(Body::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract block expression. If <u>Body</u> is <u>[B1,</u> <u>...,</u> <u>Bn]</u>, the result represents "<u>begin</u> <u>B1,</u>
              <u>...,</u> <u>Bn</u> <u>end</u>".

              <u>See</u> <u>also:</u> block_expr_body/1.

       <b>block_expr_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of body subtrees of a <u>block_expr</u> node.

              <u>See</u> <u>also:</u> block_expr/1.

       <b>case_expr(Argument::syntaxTree(),</b> <b>Clauses::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract case-expression. If <u>Clauses</u> is <u>[C1,</u> <u>...,</u>  <u>Cn]</u>,  the  result  represents  "<u>case</u>
              <u>Argument</u> <u>of</u> <u>C1;</u> <u>...;</u> <u>Cn</u> <u>end</u>". More exactly, if each <u>Ci</u> represents "<u>(Pi)</u> <u>Gi</u> <u>-&gt;</u> <u>Bi</u>", then the result
              represents "<u>case</u> <u>Argument</u> <u>of</u> <u>P1</u> <u>G1</u> <u>-&gt;</u> <u>B1;</u> <u>...;</u> <u>Pn</u> <u>Gn</u> <u>-&gt;</u> <u>Bn</u> <u>end</u>".

              <u>See</u> <u>also:</u> case_expr_argument/1, case_expr_clauses/1, clause/3, if_expr/1.

       <b>case_expr_argument(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the argument subtree of a <u>case_expr</u> node.

              <u>See</u> <u>also:</u> case_expr/2.

       <b>case_expr_clauses(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of clause subtrees of a <u>case_expr</u> node.

              <u>See</u> <u>also:</u> case_expr/2.

       <b>catch_expr(Expr::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract catch-expression. The result represents "<u>catch</u> <u>Expr</u>".

              <u>See</u> <u>also:</u> catch_expr_body/1.

       <b>catch_expr_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the body subtree of a <u>catch_expr</u> node.

              <u>See</u> <u>also:</u> catch_expr/1.

       <b>char(Char::char())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  character literal. The result represents "<u>$Name</u>", where <u>Name</u> corresponds to
              <u>Value</u>.

              Note: the literal corresponding to a particular character value is not uniquely defined. E.g., the
              character "<u>a</u>" can be written both as "<u>$a</u>" and "<u>$\141</u>", and a  Tab  character  can  be  written  as
              "<u>$\11</u>", "<u>$\011</u>" or "<u>$\t</u>".

              <u>See</u> <u>also:</u> char_literal/1, char_literal/2, char_value/1, is_char/2.

       <b>char_literal(Node::syntaxTree())</b> <b>-&gt;</b> <b>nonempty_string()</b>

              Returns  the  literal  string represented by a <u>char</u> node. This includes the leading "<u>$</u>" character.
              Characters beyond 255 will be escaped.

              <u>See</u> <u>also:</u> char/1.

       <b>char_literal(Node::syntaxTree(),</b> <b>X2::encoding())</b> <b>-&gt;</b> <b>nonempty_string()</b>

              Returns the literal string represented by a <u>char</u> node. This includes the  leading  "<u>$</u>"  character.
              Depending on the encoding a character beyond 255 will be escaped (<u>latin1</u>) or copied as is (<u>utf8</u>).

              <u>See</u> <u>also:</u> char/1.

       <b>char_value(Node::syntaxTree())</b> <b>-&gt;</b> <b>char()</b>

              Returns the value represented by a <u>char</u> node.

              <u>See</u> <u>also:</u> char/1.

       <b>class_qualifier(Class::syntaxTree(),</b> <b>Body::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract class qualifier. The result represents "<u>Class:Body</u>".

              <u>See</u>   <u>also:</u>   class_qualifier_argument/1,   class_qualifier_body/1,  class_qualifier_stacktrace/1,
              try_expr/4.

       <b>class_qualifier(Class::syntaxTree(),</b> <b>Body::syntaxTree(),</b> <b>Stacktrace::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract class qualifier. The result represents "<u>Class:Body:Stacktrace</u>".

              <u>See</u> <u>also:</u> class_qualifier_argument/1, class_qualifier_body/1, try_expr/4.

       <b>class_qualifier_argument(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the argument (the class) subtree of a <u>class_qualifier</u> node.

              <u>See</u> <u>also:</u> class_qualifier/2.

       <b>class_qualifier_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the body subtree of a <u>class_qualifier</u> node.

              <u>See</u> <u>also:</u> class_qualifier/2.

       <b>class_qualifier_stacktrace(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the stacktrace subtree of a <u>class_qualifier</u> node.

              <u>See</u> <u>also:</u> class_qualifier/2.

       <b>clause(Guard::guard(),</b> <b>Body::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to clause([], Guard, Body).

       <b>clause(Patterns::[syntaxTree()],</b> <b>Guard::guard(),</b> <b>Body::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract clause. If <u>Patterns</u> is <u>[P1,</u> <u>...,</u> <u>Pn]</u> and <u>Body</u> is <u>[B1,</u> <u>...,</u> <u>Bm]</u>, then if  <u>Guard</u>
              is  <u>none</u>, the result represents "<u>(P1,</u> <u>...,</u> <u>Pn)</u> <u>-&gt;</u> <u>B1,</u> <u>...,</u> <u>Bm</u>", otherwise, unless <u>Guard</u> is a list,
              the result represents "<u>(P1,</u> <u>...,</u> <u>Pn)</u> <u>when</u> <u>Guard</u> <u>-&gt;</u> <u>B1,</u> <u>...,</u> <u>Bm</u>".

              For simplicity, the <u>Guard</u> argument may also be any of the following:

                * An empty list <u>[]</u>. This is equivalent to passing <u>none</u>.

                * A nonempty list <u>[E1,</u> <u>...,</u> <u>Ej]</u> of syntax trees. This is equivalent to passing  <u>conjunction([E1,</u>
                  <u>...,</u> <u>Ej])</u>.

                * A  nonempty list of lists of syntax trees <u>[[E1_1,</u> <u>...,</u> <u>E1_k1],</u> <u>...,</u> <u>[Ej_1,</u> <u>...,</u> <u>Ej_kj]]</u>, which
                  is equivalent to passing <u>disjunction([conjunction([E1_1,</u> <u>...,</u> <u>E1_k1]),</u> <u>...,</u> <u>conjunction([Ej_1,</u>
                  <u>...,</u> <u>Ej_kj])])</u>.

              <u>See</u> <u>also:</u> clause/2, clause_body/1, clause_guard/1, clause_patterns/1.

       <b>clause_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Return the list of body subtrees of a <u>clause</u> node.

              <u>See</u> <u>also:</u> clause/3.

       <b>clause_guard(Node::syntaxTree())</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>syntaxTree()</b>

              Returns the guard subtree of a <u>clause</u> node, if any. If <u>Node</u> represents "<u>(P1,</u> <u>...,</u> <u>Pn)</u>  <u>when</u>  <u>Guard</u>
              <u>-&gt;</u> <u>B1,</u> <u>...,</u> <u>Bm</u>", <u>Guard</u> is returned. Otherwise, the result is <u>none</u>.

              <u>See</u> <u>also:</u> clause/3.

       <b>clause_patterns(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of pattern subtrees of a <u>clause</u> node.

              <u>See</u> <u>also:</u> clause/3.

       <b>comment(Strings::[string()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to comment(none, Strings).

       <b>comment(Pad::padding(),</b> <b>Strings::[string()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract comment with the given padding and text. If <u>Strings</u> is a (possibly empty) list
              <u>["Txt1",</u> <u>...,</u> <u>"TxtN"]</u>, the result represents the source code text

                   %Txt1
                   ...
                   %TxtN

              <u>Padding</u>  states  the  number of empty character positions to the left of the comment separating it
              horizontally from source code on the same line (if any). If <u>Padding</u> is <u>none</u>,  a  default  positive
              number  is  used.  If  <u>Padding</u>  is  an  integer  less than 1, there should be no separating space.
              Comments are in themselves regarded as source program forms.

              <u>See</u> <u>also:</u> comment/1, is_form/1.

       <b>comment_padding(Node::syntaxTree())</b> <b>-&gt;</b> <b>padding()</b>

              Returns the amount of padding before the comment, or <u>none</u>. The latter means that a default padding
              may be used.

              <u>See</u> <u>also:</u> comment/2.

       <b>comment_text(Node::syntaxTree())</b> <b>-&gt;</b> <b>[string()]</b>

              Returns the lines of text of the abstract comment.

              <u>See</u> <u>also:</u> comment/2.

       <b>compact_list(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Yields the most compact form for an abstract list skeleton. The  result  either  represents  "<u>[E1,</u>
              <u>...,</u>  <u>En</u>  <u>|</u>  <u>Tail]</u>",  where  <u>Tail</u>  is  not  a  list skeleton, or otherwise simply "<u>[E1,</u> <u>...,</u> <u>En]</u>".
              Annotations on subtrees of <u>Node</u> that represent list skeletons may be lost, but  comments  will  be
              propagated to the result. Returns <u>Node</u> itself if <u>Node</u> does not represent a list skeleton.

              <u>See</u> <u>also:</u> list/2, normalize_list/1.

       <b>concrete(Node::syntaxTree())</b> <b>-&gt;</b> <b>term()</b>

              Returns  the Erlang term represented by a syntax tree. Evaluation fails with reason <u>badarg</u> if <u>Node</u>
              does not represent a literal term.

              Note: Currently, the set of syntax trees which have a concrete representation is larger  than  the
              set  of  trees  which  can  be  built using the function abstract/1. An abstract character will be
              concretised as an integer, while abstract/1 does not at present yield an  abstract  character  for
              any input. (Use the char/1 function to explicitly create an abstract character.)

              Note:  <u>arity_qualifier</u>  nodes are recognized. This is to follow The Erlang Parser when it comes to
              wild attributes: both {F, A} and F/A  are  recognized,  which  makes  it  possible  to  turn  wild
              attributes  into  recognized  attributes  without at the same time making it impossible to compile
              files using the new syntax with the old version of the Erlang Compiler.

              <u>See</u> <u>also:</u> abstract/1, char/1, is_literal/1.

       <b>conjunction(Tests::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract conjunction. If <u>List</u> is <u>[E1,</u> <u>...,</u> <u>En]</u>, the result represents "<u>E1,</u> <u>...,</u> <u>En</u>".

              <u>See</u> <u>also:</u> conjunction_body/1, disjunction/1.

       <b>conjunction_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of body subtrees of a <u>conjunction</u> node.

              <u>See</u> <u>also:</u> conjunction/1.

       <b>cons(Head::syntaxTree(),</b> <b>Tail::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              "Optimising" list skeleton cons operation. Creates an abstract list skeleton whose  first  element
              is  <u>Head</u>  and  whose  tail corresponds to <u>Tail</u>. This is similar to <u>list([Head],</u> <u>Tail)</u>, except that
              <u>Tail</u> may not be <u>none</u>, and that the result does not necessarily represent exactly "<u>[Head</u> <u>|</u>  <u>Tail]</u>",
              but  may  depend  on  the  <u>Tail</u> subtree. E.g., if <u>Tail</u> represents <u>[X,</u> <u>Y]</u>, the result may represent
              "<u>[Head,</u> <u>X,</u> <u>Y]</u>", rather than "<u>[Head</u> <u>|</u> <u>[X,</u> <u>Y]]</u>". Annotations on <u>Tail</u> itself  may  be  lost  if  <u>Tail</u>
              represents a list skeleton, but comments on <u>Tail</u> are propagated to the result.

              <u>See</u> <u>also:</u> list/2, list_head/1, list_tail/1.

       <b>constrained_function_type(FunctionType::syntaxTree(),</b> <b>FunctionConstraint::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an abstract constrained function type. If <u>FunctionConstraint</u> is <u>[C1,</u> <u>...,</u> <u>Cn]</u>, the result
              represents "<u>FunctionType</u> <u>when</u> <u>C1,</u> <u>...Cn</u>".

              <u>See</u> <u>also:</u> constrained_function_type_argument/1, constrained_function_type_body/1.

       <b>constrained_function_type_argument(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the function constraint subtree of a <u>constrained_function_type</u> node.

              <u>See</u> <u>also:</u> constrained_function_type/2.

       <b>constrained_function_type_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the function type subtree of a <u>constrained_function_type</u> node.

              <u>See</u> <u>also:</u> constrained_function_type/2.

       <b>constraint(Name::syntaxTree(),</b> <b>Types::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract (subtype) constraint. The result represents "<u>Name</u> <u>::</u> <u>Type</u>".

              <u>See</u> <u>also:</u> constraint_argument/1, constraint_body/1.

       <b>constraint_argument(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of a <u>constraint</u> node.

              <u>See</u> <u>also:</u> constraint/2.

       <b>constraint_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the type subtree of a <u>constraint</u> node.

              <u>See</u> <u>also:</u> constraint/2.

       <b>copy_ann(Source::syntaxTree(),</b> <b>Target::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Copies the list of user annotations from <u>Source</u> to <u>Target</u>.

              Note: this is equivalent to <u>set_ann(Target,</u> <u>get_ann(Source))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> get_ann/1, set_ann/2.

       <b>copy_attrs(S::syntaxTree(),</b> <b>T::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Copies the attributes from <u>Source</u> to <u>Target</u>.

              Note: this is equivalent to <u>set_attrs(Target,</u> <u>get_attrs(Source))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> get_attrs/1, set_attrs/2.

       <b>copy_comments(Source::syntaxTree(),</b> <b>Target::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Copies the pre- and postcomments from <u>Source</u> to <u>Target</u>.

              Note: This is  equivalent  to  <u>set_postcomments(set_precomments(Target,</u>  <u>get_precomments(Source)),</u>
              <u>get_postcomments(Source))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> comment/2, get_postcomments/1, get_precomments/1, set_postcomments/2, set_precomments/2.

       <b>copy_pos(Source::syntaxTree(),</b> <b>Target::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Copies the annotation from <u>Source</u> to <u>Target</u>.

              This is equivalent to <u>set_pos(Target,</u> <u>get_pos(Source))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> get_pos/1, set_pos/2.

       <b>data(Tree::syntaxTree())</b> <b>-&gt;</b> <b>term()</b>

              <u>For</u>  <u>special</u>  <u>purposes</u>  <u>only</u>.  Returns the associated data of a syntax tree node. Evaluation fails
              with reason <u>badarg</u> if <u>is_tree(Node)</u> does not yield <u>true</u>.

              <u>See</u> <u>also:</u> tree/2.

       <b>disjunction(Tests::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract disjunction. If <u>List</u> is <u>[E1,</u> <u>...,</u> <u>En]</u>, the result represents "<u>E1;</u> <u>...;</u> <u>En</u>".

              <u>See</u> <u>also:</u> conjunction/1, disjunction_body/1.

       <b>disjunction_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of body subtrees of a <u>disjunction</u> node.

              <u>See</u> <u>also:</u> disjunction/1.

       <b>eof_marker()</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract end-of-file marker. This represents the end of input when reading  a  sequence
              of  source code forms. An end-of-file marker is itself regarded as a source code form (namely, the
              last in any sequence in which it occurs). It has no defined lexical form.

              Note: this is retained only for backwards compatibility with existing parsers and tools.

              <u>See</u> <u>also:</u> error_marker/1, is_form/1, warning_marker/1.

       <b>error_marker(Error::term())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract error marker. The result represents an occurrence of an error  in  the  source
              code,  with  an  associated Erlang I/O ErrorInfo structure given by <u>Error</u> (see module <a href="../man3erl/io.3erl.html">io</a>(3erl) for
              details). Error markers are regarded as source code forms, but have no defined lexical form.

              Note: this is supported only for backwards compatibility with existing parsers and tools.

              <u>See</u> <u>also:</u> eof_marker/0, error_marker_info/1, is_form/1, warning_marker/1.

       <b>error_marker_info(Node::syntaxTree())</b> <b>-&gt;</b> <b>term()</b>

              Returns the ErrorInfo structure of an <u>error_marker</u> node.

              <u>See</u> <u>also:</u> error_marker/1.

       <b>flatten_form_list(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Flattens sublists of  a  <u>form_list</u>  node.  Returns  <u>Node</u>  with  all  subtrees  of  type  <u>form_list</u>
              recursively expanded, yielding a single "flat" abstract form sequence.

              <u>See</u> <u>also:</u> form_list/1.

       <b>float(Value::float())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  floating-point literal. The lexical representation is the decimal floating-
              point numeral of <u>Value</u>.

              <u>See</u> <u>also:</u> float_literal/1, float_value/1.

       <b>float_literal(Node::syntaxTree())</b> <b>-&gt;</b> <b>string()</b>

              Returns the numeral string represented by a <u>float</u> node.

              <u>See</u> <u>also:</u> float/1.

       <b>float_value(Node::syntaxTree())</b> <b>-&gt;</b> <b>float()</b>

              Returns the value represented by a <u>float</u> node. Note that floating-point values should usually  not
              be compared for equality.

              <u>See</u> <u>also:</u> float/1.

       <b>form_list(Forms::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract sequence of "source code forms". If <u>Forms</u> is <u>[F1,</u> <u>...,</u> <u>Fn]</u>, where each <u>Fi</u> is a
              form (see is_form/1, the result represents

                   F1
                   ...
                   Fn

              where the <u>Fi</u> are separated by one or more line breaks. A node of type <u>form_list</u> is itself regarded
              as a source code form; see flatten_form_list/1.

              Note: this is simply a way of grouping source code forms as a single syntax tree, usually in order
              to form an Erlang module definition.

              <u>See</u> <u>also:</u> flatten_form_list/1, form_list_elements/1, is_form/1.

       <b>form_list_elements(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of subnodes of a <u>form_list</u> node.

              <u>See</u> <u>also:</u> form_list/1.

       <b>fun_expr(Clauses::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  fun-expression. If <u>Clauses</u> is <u>[C1,</u> <u>...,</u> <u>Cn]</u>, the result represents "<u>fun</u> <u>C1;</u>
              <u>...;</u> <u>Cn</u> <u>end</u>". More exactly, if each <u>Ci</u> represents "<u>(Pi1,</u> <u>...,</u> <u>Pim)</u> <u>Gi</u>  <u>-&gt;</u>  <u>Bi</u>",  then  the  result
              represents "<u>fun</u> <u>(P11,</u> <u>...,</u> <u>P1m)</u> <u>G1</u> <u>-&gt;</u> <u>B1;</u> <u>...;</u> <u>(Pn1,</u> <u>...,</u> <u>Pnm)</u> <u>Gn</u> <u>-&gt;</u> <u>Bn</u> <u>end</u>".

              <u>See</u> <u>also:</u> fun_expr_arity/1, fun_expr_clauses/1.

       <b>fun_expr_arity(Node::syntaxTree())</b> <b>-&gt;</b> <b>arity()</b>

              Returns  the arity of a <u>fun_expr</u> node. The result is the number of parameter patterns in the first
              clause of the fun-expression; subsequent clauses are ignored.

              An exception is thrown if <u>fun_expr_clauses(Node)</u> returns an empty list, or if the first element of
              that list is not a syntax tree <u>C</u> of type <u>clause</u> such that <u>clause_patterns(C)</u> is a nonempty list.

              <u>See</u> <u>also:</u> clause/3, clause_patterns/1, fun_expr/1, fun_expr_clauses/1.

       <b>fun_expr_clauses(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of clause subtrees of a <u>fun_expr</u> node.

              <u>See</u> <u>also:</u> fun_expr/1.

       <b>fun_type()</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract fun of any type. The result represents "<u>fun()</u>".

       <b>function(Name::syntaxTree(),</b> <b>Clauses::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract function definition. If <u>Clauses</u> is <u>[C1,</u> <u>...,</u> <u>Cn]</u>, the result represents  "<u>Name</u>
              <u>C1;</u>  <u>...;</u>  <u>Name</u>  <u>Cn.</u>".  More  exactly,  if each <u>Ci</u> represents "<u>(Pi1,</u> <u>...,</u> <u>Pim)</u> <u>Gi</u> <u>-&gt;</u> <u>Bi</u>", then the
              result represents "<u>Name(P11,</u> <u>...,</u> <u>P1m)</u> <u>G1</u> <u>-&gt;</u> <u>B1;</u> <u>...;</u> <u>Name(Pn1,</u> <u>...,</u> <u>Pnm)</u>  <u>Gn</u>  <u>-&gt;</u>  <u>Bn.</u>".  Function
              definitions are source code forms.

              <u>See</u> <u>also:</u> function_arity/1, function_clauses/1, function_name/1, is_form/1.

       <b>function_arity(Node::syntaxTree())</b> <b>-&gt;</b> <b>arity()</b>

              Returns  the arity of a <u>function</u> node. The result is the number of parameter patterns in the first
              clause of the function; subsequent clauses are ignored.

              An exception is thrown if <u>function_clauses(Node)</u> returns an empty list, or if the first element of
              that list is not a syntax tree <u>C</u> of type <u>clause</u> such that <u>clause_patterns(C)</u> is a nonempty list.

              <u>See</u> <u>also:</u> clause/3, clause_patterns/1, function/2, function_clauses/1.

       <b>function_clauses(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of clause subtrees of a <u>function</u> node.

              <u>See</u> <u>also:</u> function/2.

       <b>function_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of a <u>function</u> node.

              <u>See</u> <u>also:</u> function/2.

       <b>function_type(Type)</b> <b>-&gt;</b> <b>term()</b>

              Equivalent to function_type(any_arity, Type).

       <b>function_type(Arguments::any_arity</b> <b>|</b> <b>[syntaxTree()],</b> <b>Return::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract function type. If <u>Arguments</u> is <u>[T1,</u> <u>...,</u> <u>Tn]</u>,  then  if  it  occurs  within  a
              function  specification,  the  result  represents "<u>(T1,</u> <u>...Tn)</u> <u>-&gt;</u> <u>Return</u>"; otherwise it represents
              "<u>fun((T1,</u> <u>...Tn)</u> <u>-&gt;</u> <u>Return)</u>". If <u>Arguments</u> is <u>any_arity</u>, it represents "<u>fun((...)</u> <u>-&gt;</u> <u>Return)</u>".

              Note that the <u>erl_parse</u> representation is identical for "<u>FunctionType</u>" and "<u>fun(FunctionType)</u>".

              <u>See</u> <u>also:</u> function_type_arguments/1, function_type_return/1.

       <b>function_type_arguments(Node::syntaxTree())</b> <b>-&gt;</b> <b>any_arity</b> <b>|</b> <b>[syntaxTree()]</b>

              Returns the argument types subtrees of a <u>function_type</u> node.  If  <u>Node</u>  represents  "<u>fun((...)</u>  <u>-&gt;</u>
              <u>Return)</u>",  <u>any_arity</u>  is  returned;  otherwise,  if  <u>Node</u>  represents  "<u>(T1,</u>  <u>...Tn)</u> <u>-&gt;</u> <u>Return</u>" or
              "<u>fun((T1,</u> <u>...Tn)</u> <u>-&gt;</u> <u>Return)</u>", <u>[T1,</u> <u>...,</u> <u>Tn]</u> is returned.

              <u>See</u> <u>also:</u> function_type/1, function_type/2.

       <b>function_type_return(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the return type subtrees of a <u>function_type</u> node.

              <u>See</u> <u>also:</u> function_type/1, function_type/2.

       <b>generator(Pattern::syntaxTree(),</b> <b>Body::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract generator. The result represents "<u>Pattern</u> <u>&lt;-</u> <u>Body</u>".

              <u>See</u> <u>also:</u> binary_comp/2, generator_body/1, generator_pattern/1, list_comp/2.

       <b>generator_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the body subtree of a <u>generator</u> node.

              <u>See</u> <u>also:</u> generator/2.

       <b>generator_pattern(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the pattern subtree of a <u>generator</u> node.

              <u>See</u> <u>also:</u> generator/2.

       <b>get_ann(Tree::syntaxTree())</b> <b>-&gt;</b> <b>[term()]</b>

              Returns the list of user annotations associated with a syntax tree node. For a newly created node,
              this is the empty list. The annotations may be any terms.

              <u>See</u> <u>also:</u> get_attrs/1, set_ann/2.

       <b>get_attrs(Tree::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTreeAttributes()</b>

              Returns a representation of the attributes associated with a syntax tree node. The attributes  are
              all  the  extra  information  that  can  be  attached to a node. Currently, this includes position
              information, source code comments, and user annotations. The result of  this  function  cannot  be
              inspected directly; only attached to another node (see set_attrs/2).

              For   accessing   individual   attributes,   see   get_pos/1,   get_ann/1,  get_precomments/1  and
              get_postcomments/1.

              <u>See</u> <u>also:</u> get_ann/1, get_pos/1, get_postcomments/1, get_precomments/1, set_attrs/2.

       <b>get_pos(Tree::syntaxTree())</b> <b>-&gt;</b> <b>annotation_or_location()</b>

              Returns the annotation (see <a href="../man3erl/erl_anno.3erl.html">erl_anno</a>(3erl)) associated with <u>Node</u>. By default, all new  tree  nodes
              have  their  associated  position  information set to the integer zero. Use erl_anno:location/1 or
              erl_anno:line/1 to get the position information.

              <u>See</u> <u>also:</u> get_attrs/1, set_pos/2.

       <b>get_postcomments(Tree::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the associated post-comments of a  node.  This  is  a  possibly  empty  list  of  abstract
              comments,  in  top-down  textual  order.  When  the code is formatted, post-comments are typically
              displayed to the right of and/or below the node. For example:

                   {foo, X, Y}     % Post-comment of tuple

              If possible, the comment should be moved past any following separator characters on the same line,
              rather than placing the separators on the following line. E.g.:

                   foo([X | Xs], Y) -&gt;
                       foo(Xs, bar(X));     % Post-comment of 'bar(X)' node
                    ...

              (where the comment is moved past the rightmost "<u>)</u>" and the "<u>;</u>").

              <u>See</u> <u>also:</u> comment/2, get_attrs/1, get_precomments/1, set_postcomments/2.

       <b>get_precomments(Tree::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the associated pre-comments of a node. This is a possibly empty list of abstract comments,
              in top-down textual order. When the  code  is  formatted,  pre-comments  are  typically  displayed
              directly above the node. For example:

                   % Pre-comment of function
                   foo(X) -&gt; {bar, X}.

              If  possible,  the  comment  should be moved before any preceding separator characters on the same
              line. E.g.:

                   foo([X | Xs]) -&gt;
                       % Pre-comment of 'bar(X)' node
                       [bar(X) | foo(Xs)];
                   ...

              (where the comment is moved before the "<u>[</u>").

              <u>See</u> <u>also:</u> comment/2, get_attrs/1, get_postcomments/1, set_precomments/2.

       <b>has_comments(Tree::syntaxTree())</b> <b>-&gt;</b> <b>boolean()</b>

              Yields <u>false</u> if the node has no associated comments, and <u>true</u> otherwise.

              Note: This is equivalent to <u>(get_precomments(Node)</u> <u>==</u> <u>[])</u> <u>and</u> <u>(get_postcomments(Node)</u> <u>==</u> <u>[])</u>,  but
              potentially more efficient.

              <u>See</u> <u>also:</u> get_postcomments/1, get_precomments/1, remove_comments/1.

       <b>if_expr(Clauses::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract if-expression. If <u>Clauses</u> is <u>[C1,</u> <u>...,</u> <u>Cn]</u>, the result represents "<u>if</u> <u>C1;</u> <u>...;</u>
              <u>Cn</u>  <u>end</u>".  More exactly, if each <u>Ci</u> represents "<u>()</u> <u>Gi</u> <u>-&gt;</u> <u>Bi</u>", then the result represents "<u>if</u> <u>G1</u> <u>-&gt;</u>
              <u>B1;</u> <u>...;</u> <u>Gn</u> <u>-&gt;</u> <u>Bn</u> <u>end</u>".

              <u>See</u> <u>also:</u> case_expr/2, clause/3, if_expr_clauses/1.

       <b>if_expr_clauses(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of clause subtrees of an <u>if_expr</u> node.

              <u>See</u> <u>also:</u> if_expr/1.

       <b>implicit_fun(Name::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract "implicit fun" expression. The  result  represents  "<u>fun</u>  <u>Name</u>".  <u>Name</u>  should
              represent either <u>F/A</u> or <u>M:F/A</u>

              <u>See</u>     <u>also:</u>     arity_qualifier/2,    implicit_fun/2,    implicit_fun/3,    implicit_fun_name/1,
              module_qualifier/2.

       <b>implicit_fun(Name::syntaxTree(),</b> <b>Arity::none</b> <b>|</b> <b>syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an  abstract  "implicit  fun"  expression.  If  <u>Arity</u>  is  <u>none</u>,  this  is  equivalent  to
              <u>implicit_fun(Name)</u>, otherwise it is equivalent to <u>implicit_fun(arity_qualifier(Name,</u> <u>Arity))</u>.

              (This is a utility function.)

              <u>See</u> <u>also:</u> implicit_fun/1, implicit_fun/3.

       <b>implicit_fun(Module::none</b> <b>|</b> <b>syntaxTree(),</b> <b>Name::syntaxTree(),</b> <b>Arity::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  module-qualified  "implicit  fun"  expression.  If  <u>Module</u> is <u>none</u>, this is
              equivalent    to    <u>implicit_fun(Name,</u>    <u>Arity)</u>,    otherwise     it     is     equivalent     to
              <u>implicit_fun(module_qualifier(Module,</u> <u>arity_qualifier(Name,</u> <u>Arity))</u>.

              (This is a utility function.)

              <u>See</u> <u>also:</u> implicit_fun/1, implicit_fun/2.

       <b>implicit_fun_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of an <u>implicit_fun</u> node.

              Note:  if  <u>Node</u>  represents  "<u>fun</u> <u>N/A</u>" or "<u>fun</u> <u>M:N/A</u>", then the result is the subtree representing
              "<u>N/A</u>" or "<u>M:N/A</u>", respectively.

              <u>See</u> <u>also:</u> arity_qualifier/2, implicit_fun/1, module_qualifier/2.

       <b>infix_expr(Left::syntaxTree(),</b> <b>Operator::syntaxTree(),</b> <b>Right::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract infix operator expression. The result represents "<u>Left</u> <u>Operator</u> <u>Right</u>".

              <u>See</u> <u>also:</u> infix_expr_left/1, infix_expr_operator/1, infix_expr_right/1, prefix_expr/2.

       <b>infix_expr_left(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the left argument subtree of an <u>infix_expr</u> node.

              <u>See</u> <u>also:</u> infix_expr/3.

       <b>infix_expr_operator(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the operator subtree of an <u>infix_expr</u> node.

              <u>See</u> <u>also:</u> infix_expr/3.

       <b>infix_expr_right(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the right argument subtree of an <u>infix_expr</u> node.

              <u>See</u> <u>also:</u> infix_expr/3.

       <b>integer(Value::integer())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract integer literal. The lexical representation is the canonical  decimal  numeral
              of <u>Value</u>.

              <u>See</u> <u>also:</u> integer_literal/1, integer_value/1, is_integer/2.

       <b>integer_literal(Node::syntaxTree())</b> <b>-&gt;</b> <b>string()</b>

              Returns the numeral string represented by an <u>integer</u> node.

              <u>See</u> <u>also:</u> integer/1.

       <b>integer_range_type(Low::syntaxTree(),</b> <b>High::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract range type. The result represents "<u>Low</u> <u>..</u> <u>High</u>".

              <u>See</u> <u>also:</u> integer_range_type_high/1, integer_range_type_low/1.

       <b>integer_range_type_high(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the high limit of an <u>integer_range_type</u> node.

              <u>See</u> <u>also:</u> integer_range_type/2.

       <b>integer_range_type_low(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the low limit of an <u>integer_range_type</u> node.

              <u>See</u> <u>also:</u> integer_range_type/2.

       <b>integer_value(Node::syntaxTree())</b> <b>-&gt;</b> <b>integer()</b>

              Returns the value represented by an <u>integer</u> node.

              <u>See</u> <u>also:</u> integer/1.

       <b>is_atom(Node::syntaxTree(),</b> <b>Value::atom())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> has type <u>atom</u> and represents <u>Value</u>, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> atom/1.

       <b>is_char(Node::syntaxTree(),</b> <b>Value::char())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> has type <u>char</u> and represents <u>Value</u>, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> char/1.

       <b>is_form(Node::syntaxTree())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns  <u>true</u>  if  <u>Node</u>  is  a  syntax tree representing a so-called "source code form", otherwise
              <u>false</u>. Forms are the Erlang source code units which, placed  in  sequence,  constitute  an  Erlang
              program. Current form types are:

              <u>attribute</u> <u>comment</u> <u>error_marker</u> <u>eof_marker</u>
              <u>form_list</u> <u>function</u> <u>warning_marker</u> <u>text</u>

              <u>See</u>  <u>also:</u>  attribute/2, comment/2, eof_marker/0, error_marker/1, form_list/1, function/2, type/1,
              warning_marker/1.

       <b>is_integer(Node::syntaxTree(),</b> <b>Value::integer())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> has type <u>integer</u> and represents <u>Value</u>, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> integer/1.

       <b>is_leaf(Node::syntaxTree())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> is a leaf node, otherwise <u>false</u>. The currently  recognised  leaf  node  types
              are:

              <u>atom</u> <u>char</u> <u>comment</u> <u>eof_marker</u> <u>error_marker</u>
              <u>float</u> <u>fun_type</u> <u>integer</u> <u>nil</u> <u>operator</u> <u>string</u>
              <u>text</u> <u>underscore</u> <u>variable</u> <u>warning_marker</u>

              A  node of type <u>map_expr</u> is a leaf node if and only if it has no argument and no fields. A node of
              type <u>map_type</u> is a leaf node if and only if it has no fields (<u>any_size</u>). A node of type <u>tuple</u> is a
              leaf node if and only if its arity is zero. A node of type <u>tuple_type</u> is a leaf node if  and  only
              if it has no elements (<u>any_size</u>).

              Note:  not  all  literals  are  leaf  nodes,  and  vice versa. E.g., tuples with nonzero arity and
              nonempty lists may be literals, but are not leaf nodes. Variables, on the  other  hand,  are  leaf
              nodes but not literals.

              <u>See</u> <u>also:</u> is_literal/1, type/1.

       <b>is_list_skeleton(Node::syntaxTree())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> has type <u>list</u> or <u>nil</u>, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> list/2, nil/0.

       <b>is_literal(T::syntaxTree())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> represents a literal term, otherwise <u>false</u>. This function returns <u>true</u> if and
              only if the value of <u>concrete(Node)</u> is defined.

              <u>See</u> <u>also:</u> abstract/1, concrete/1.

       <b>is_proper_list(Node::syntaxTree())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns  <u>true</u>  if  <u>Node</u>  represents  a  proper  list, and <u>false</u> otherwise. A proper list is a list
              skeleton either on the form "<u>[]</u>" or "<u>[E1,</u> <u>...,</u> <u>En]</u>", or "<u>[...</u> <u>|</u> <u>Tail]</u>" where recursively <u>Tail</u> also
              represents a proper list.

              Note: Since <u>Node</u> is a syntax tree, the actual run-time values corresponding to  its  subtrees  may
              often  be partially or completely unknown. Thus, if <u>Node</u> represents e.g. "<u>[...</u> <u>|</u> <u>Ns]</u>" (where <u>Ns</u> is
              a variable), then the function will return <u>false</u>, because it is not known whether <u>Ns</u> will be bound
              to a list at run-time. If <u>Node</u> instead represents e.g. "<u>[1,</u>  <u>2,</u>  <u>3]</u>"  or  "<u>[A</u>  <u>|</u>  <u>[]]</u>",  then  the
              function will return <u>true</u>.

              <u>See</u> <u>also:</u> list/2.

       <b>is_string(Node::syntaxTree(),</b> <b>Value::string())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Node</u> has type <u>string</u> and represents <u>Value</u>, otherwise <u>false</u>.

              <u>See</u> <u>also:</u> string/1.

       <b>is_tree(Tree::syntaxTree())</b> <b>-&gt;</b> <b>boolean()</b>

              <u>For</u> <u>special</u> <u>purposes</u> <u>only</u>. Returns <u>true</u> if <u>Tree</u> is an abstract syntax tree and <u>false</u> otherwise.

              <u>Note</u>: this function yields <u>false</u> for all "old-style" <u>erl_parse</u>-compatible "parse trees".

              <u>See</u> <u>also:</u> tree/2.

       <b>join_comments(Source::syntaxTree(),</b> <b>Target::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Appends the comments of <u>Source</u> to the current comments of <u>Target</u>.

              Note:       This       is       equivalent      to      <u>add_postcomments(get_postcomments(Source),</u>
              <u>add_precomments(get_precomments(Source),</u> <u>Target))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> add_postcomments/2, add_precomments/2, comment/2, get_postcomments/1, get_precomments/1.

       <b>list(List::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to list(List, none).

       <b>list(Elements::[syntaxTree()],</b> <b>Tail::none</b> <b>|</b> <b>syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Constructs an abstract list skeleton. The result has type <u>list</u> or <u>nil</u>. If <u>List</u> is a nonempty  list
              <u>[E1,</u> <u>...,</u> <u>En]</u>, the result has type <u>list</u> and represents either "<u>[E1,</u> <u>...,</u> <u>En]</u>", if <u>Tail</u> is <u>none</u>, or
              otherwise  "<u>[E1,</u>  <u>...,</u> <u>En</u> <u>|</u> <u>Tail]</u>". If <u>List</u> is the empty list, <u>Tail</u> <u>must</u> be <u>none</u>, and in that case
              the result has type <u>nil</u> and represents "<u>[]</u>" (see nil/0).

              The difference between lists as semantic objects (built up of individual "cons" and  "nil"  terms)
              and  the  various  syntactic  forms  for  denoting  lists may be bewildering at first. This module
              provides functions both for exact control of the syntactic  representation  as  well  as  for  the
              simple composition and deconstruction in terms of cons and head/tail operations.

              Note:  in  <u>list(Elements,</u>  <u>none)</u>,  the  "nil"  list  terminator  is implicit and has no associated
              information (see get_attrs/1), while in the seemingly equivalent <u>list(Elements,</u>  <u>Tail)</u>  when  <u>Tail</u>
              has  type  <u>nil</u>,  the  list  terminator subtree <u>Tail</u> may have attached attributes such as position,
              comments, and annotations, which will be preserved in the result.

              <u>See</u> <u>also:</u>  compact_list/1,  cons/2,  get_attrs/1,  is_list_skeleton/1,  is_proper_list/1,  list/1,
              list_elements/1,  list_head/1,  list_length/1,  list_prefix/1,  list_suffix/1, list_tail/1, nil/0,
              normalize_list/1.

       <b>list_comp(Template::syntaxTree(),</b> <b>Body::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract list comprehension. If <u>Body</u> is <u>[E1,</u> <u>...,</u> <u>En]</u>, the result represents "<u>[Template</u>
              <u>||</u> <u>E1,</u> <u>...,</u> <u>En]</u>".

              <u>See</u> <u>also:</u> generator/2, list_comp_body/1, list_comp_template/1.

       <b>list_comp_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of body subtrees of a <u>list_comp</u> node.

              <u>See</u> <u>also:</u> list_comp/2.

       <b>list_comp_template(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the template subtree of a <u>list_comp</u> node.

              <u>See</u> <u>also:</u> list_comp/2.

       <b>list_elements(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of element subtrees of a list skeleton. <u>Node</u> must represent a proper list.  E.g.,
              if  <u>Node</u>  represents  "<u>[X1,</u> <u>X2</u> <u>|</u> <u>[X3,</u> <u>X4</u> <u>|</u> <u>[]]</u>", then <u>list_elements(Node)</u> yields the list <u>[X1,</u> <u>X2,</u>
              <u>X3,</u> <u>X4]</u>.

              <u>See</u> <u>also:</u> is_proper_list/1, list/2.

       <b>list_head(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the head element subtree of a <u>list</u> node. If <u>Node</u> represents "<u>[Head</u> <u>...]</u>", the result  will
              represent "<u>Head</u>".

              <u>See</u> <u>also:</u> cons/2, list/2, list_tail/1.

       <b>list_length(Node::syntaxTree())</b> <b>-&gt;</b> <b>non_neg_integer()</b>

              Returns  the  number  of  element  subtrees of a list skeleton. <u>Node</u> must represent a proper list.
              E.g., if <u>Node</u> represents "<u>[X1</u> <u>|</u> <u>[X2,</u> <u>X3</u> <u>|</u> <u>[X4,</u> <u>X5,</u>  <u>X6]]]</u>",  then  <u>list_length(Node)</u>  returns  the
              integer 6.

              Note: this is equivalent to <u>length(list_elements(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> is_proper_list/1, list/2, list_elements/1.

       <b>list_prefix(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns  the  prefix  element subtrees of a <u>list</u> node. If <u>Node</u> represents "<u>[E1,</u> <u>...,</u> <u>En]</u>" or "<u>[E1,</u>
              <u>...,</u> <u>En</u> <u>|</u> <u>Tail]</u>", the returned value is <u>[E1,</u> <u>...,</u> <u>En]</u>.

              <u>See</u> <u>also:</u> list/2.

       <b>list_suffix(Node::syntaxTree())</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>syntaxTree()</b>

              Returns the suffix subtree of a <u>list</u> node, if one exists. If  <u>Node</u>  represents  "<u>[E1,</u>  <u>...,</u>  <u>En</u>  <u>|</u>
              <u>Tail]</u>",  the  returned value is <u>Tail</u>, otherwise, i.e., if <u>Node</u> represents "<u>[E1,</u> <u>...,</u> <u>En]</u>", <u>none</u> is
              returned.

              Note that even if this function returns some <u>Tail</u> that is not <u>none</u>, the type of <u>Tail</u> can  be  <u>nil</u>,
              if  the  tail  has  been  given  explicitly,  and  the  list  skeleton has not been compacted (see
              compact_list/1).

              <u>See</u> <u>also:</u> compact_list/1, list/2, nil/0.

       <b>list_tail(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the tail of a <u>list</u> node. If <u>Node</u> represents a single-element list "<u>[E]</u>", then  the  result
              has type <u>nil</u>, representing "<u>[]</u>". If <u>Node</u> represents "<u>[E1,</u> <u>E2</u> <u>...]</u>", the result will represent "<u>[E2</u>
              <u>...]</u>", and if <u>Node</u> represents "<u>[Head</u> <u>|</u> <u>Tail]</u>", the result will represent "<u>Tail</u>".

              <u>See</u> <u>also:</u> cons/2, list/2, list_head/1.

       <b>macro(Name::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to macro(Name, none).

       <b>macro(Name::syntaxTree(),</b> <b>Arguments::none</b> <b>|</b> <b>[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  macro  application.  If  <u>Arguments</u>  is <u>none</u>, the result represents "<u>?Name</u>",
              otherwise, if <u>Arguments</u> is <u>[A1,</u> <u>...,</u> <u>An]</u>, the result represents "<u>?Name(A1,</u> <u>...,</u> <u>An)</u>".

              Notes: if <u>Arguments</u> is the empty list, the result will thus represent "<u>?Name()</u>", including a  pair
              of matching parentheses.

              The  only  syntactical  limitation  imposed  by  the  preprocessor  on  the  arguments  to a macro
              application (viewed as sequences of tokens)  is  that  they  must  be  balanced  with  respect  to
              parentheses,  brackets,  <u>begin</u>  <u>...</u>  <u>end</u>,  <u>case</u>  <u>...</u>  <u>end</u>,  etc. The <u>text</u> node type can be used to
              represent arguments which are not regular Erlang constructs.

              <u>See</u> <u>also:</u> macro/1, macro_arguments/1, macro_name/1, text/1.

       <b>macro_arguments(Node::syntaxTree())</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>[syntaxTree()]</b>

              Returns the list of argument subtrees of a <u>macro</u> node, if any. If <u>Node</u> represents "<u>?Name</u>", <u>none</u> is
              returned. Otherwise, if <u>Node</u> represents "<u>?Name(A1,</u> <u>...,</u> <u>An)</u>", <u>[A1,</u> <u>...,</u> <u>An]</u> is returned.

              <u>See</u> <u>also:</u> macro/2.

       <b>macro_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of a <u>macro</u> node.

              <u>See</u> <u>also:</u> macro/2.

       <b>make_tree(X1::atom(),</b> <b>X2::[[syntaxTree()]])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates a syntax tree with the given type and subtrees. <u>Type</u> must be a node type name (see type/1)
              that does not denote a leaf node type (see is_leaf/1). <u>Groups</u> must be a <u>nonempty</u> list of groups of
              syntax trees, representing the subtrees of a node of the given type,  in  left-to-right  order  as
              they would occur in the printed program text, grouped by category as done by subtrees/1.

              The   result   of  <u>copy_attrs(Node,</u>  <u>make_tree(type(Node),</u>  <u>subtrees(Node)))</u>  (see  update_tree/2)
              represents the same source code text as the original <u>Node</u>, assuming that <u>subtrees(Node)</u>  yields  a
              nonempty list. However, it does not necessarily have the same data representation as <u>Node</u>.

              <u>See</u> <u>also:</u> copy_attrs/2, is_leaf/1, subtrees/1, type/1, update_tree/2.

       <b>map_expr(Fields::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to map_expr(none, Fields).

       <b>map_expr(Argument::none</b> <b>|</b> <b>syntaxTree(),</b> <b>Fields::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  map  expression.  If <u>Fields</u> is <u>[F1,</u> <u>...,</u> <u>Fn]</u>, then if <u>Argument</u> is <u>none</u>, the
              result represents "<u>#{F1,</u> <u>...,</u> <u>Fn}</u>", otherwise it represents "<u>Argument#{F1,</u> <u>...,</u> <u>Fn}</u>".

              <u>See</u>    <u>also:</u>    map_expr/1,     map_expr_argument/1,     map_expr_fields/1,     map_field_assoc/2,
              map_field_exact/2.

       <b>map_expr_argument(Node::syntaxTree())</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>syntaxTree()</b>

              Returns  the  argument  subtree  of  a <u>map_expr</u> node, if any. If <u>Node</u> represents "<u>#{...}</u>", <u>none</u> is
              returned. Otherwise, if <u>Node</u> represents "<u>Argument#{...}</u>", <u>Argument</u> is returned.

              <u>See</u> <u>also:</u> map_expr/2.

       <b>map_expr_fields(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of field subtrees of a <u>map_expr</u> node.

              <u>See</u> <u>also:</u> map_expr/2.

       <b>map_field_assoc(Name::syntaxTree(),</b> <b>Value::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract map assoc field. The result represents "<u>Name</u> <u>=&gt;</u> <u>Value</u>".

              <u>See</u> <u>also:</u> map_expr/2, map_field_assoc_name/1, map_field_assoc_value/1.

       <b>map_field_assoc_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of a <u>map_field_assoc</u> node.

              <u>See</u> <u>also:</u> map_field_assoc/2.

       <b>map_field_assoc_value(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the value subtree of a <u>map_field_assoc</u> node.

              <u>See</u> <u>also:</u> map_field_assoc/2.

       <b>map_field_exact(Name::syntaxTree(),</b> <b>Value::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract map exact field. The result represents "<u>Name</u> <u>:=</u> <u>Value</u>".

              <u>See</u> <u>also:</u> map_expr/2, map_field_exact_name/1, map_field_exact_value/1.

       <b>map_field_exact_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of a <u>map_field_exact</u> node.

              <u>See</u> <u>also:</u> map_field_exact/2.

       <b>map_field_exact_value(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the value subtree of a <u>map_field_exact</u> node.

              <u>See</u> <u>also:</u> map_field_exact/2.

       <b>map_type()</b> <b>-&gt;</b> <b>term()</b>

              Equivalent to map_type(any_size).

       <b>map_type(Fields::any_size</b> <b>|</b> <b>[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract type map. If <u>Fields</u> is <u>[F1,</u> <u>...,</u> <u>Fn]</u>, the result represents "<u>#{F1,</u> <u>...,</u>  <u>Fn}</u>";
              otherwise, if <u>Fields</u> is <u>any_size</u>, it represents "<u>map()</u>".

              <u>See</u> <u>also:</u> map_type_fields/1.

       <b>map_type_assoc(Name::syntaxTree(),</b> <b>Value::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract map type assoc field. The result represents "<u>Name</u> <u>=&gt;</u> <u>Value</u>".

              <u>See</u> <u>also:</u> map_type/1, map_type_assoc_name/1, map_type_assoc_value/1.

       <b>map_type_assoc_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of a <u>map_type_assoc</u> node.

              <u>See</u> <u>also:</u> map_type_assoc/2.

       <b>map_type_assoc_value(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the value subtree of a <u>map_type_assoc</u> node.

              <u>See</u> <u>also:</u> map_type_assoc/2.

       <b>map_type_exact(Name::syntaxTree(),</b> <b>Value::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract map type exact field. The result represents "<u>Name</u> <u>:=</u> <u>Value</u>".

              <u>See</u> <u>also:</u> map_type/1, map_type_exact_name/1, map_type_exact_value/1.

       <b>map_type_exact_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of a <u>map_type_exact</u> node.

              <u>See</u> <u>also:</u> map_type_exact/2.

       <b>map_type_exact_value(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the value subtree of a <u>map_type_exact</u> node.

              <u>See</u> <u>also:</u> map_type_exact/2.

       <b>map_type_fields(Node::syntaxTree())</b> <b>-&gt;</b> <b>any_size</b> <b>|</b> <b>[syntaxTree()]</b>

              Returns  the  list  of  field subtrees of a <u>map_type</u> node. If <u>Node</u> represents "<u>map()</u>", <u>any_size</u> is
              returned; otherwise, if <u>Node</u> represents "<u>#{F1,</u> <u>...,</u> <u>Fn}</u>", <u>[F1,</u> <u>...,</u> <u>Fn]</u> is returned.

              <u>See</u> <u>also:</u> map_type/0, map_type/1.

       <b>match_expr(Pattern::syntaxTree(),</b> <b>Body::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract match-expression. The result represents "<u>Pattern</u> <u>=</u> <u>Body</u>".

              <u>See</u> <u>also:</u> match_expr_body/1, match_expr_pattern/1.

       <b>match_expr_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the body subtree of a <u>match_expr</u> node.

              <u>See</u> <u>also:</u> match_expr/2.

       <b>match_expr_pattern(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the pattern subtree of a <u>match_expr</u> node.

              <u>See</u> <u>also:</u> match_expr/2.

       <b>meta(T::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates a meta-representation of a  syntax  tree.  The  result  represents  an  Erlang  expression
              "<u>MetaTree</u>"  which,  if  evaluated,  will yield a new syntax tree representing the same source code
              text as  <u>Tree</u>  (although  the  actual  data  representation  may  be  different).  The  expression
              represented  by  <u>MetaTree</u> is <u>implementation</u> <u>independent</u> with regard to the data structures used by
              the abstract syntax tree implementation. Comments attached to nodes of <u>Tree</u> will be preserved, but
              other attributes are lost.

              Any node in <u>Tree</u> whose node type is <u>variable</u> (see type/1), and  whose  list  of  annotations  (see
              get_ann/1)  contains  the  atom <u>meta_var</u>, will remain unchanged in the resulting tree, except that
              exactly one occurrence of <u>meta_var</u> is removed from its annotation list.

              The main use of the function <u>meta/1</u> is to transform a data  structure  <u>Tree</u>,  which  represents  a
              piece  of program code, into a form that is <u>representation</u> <u>independent</u> <u>when</u> <u>printed</u>. E.g., suppose
              <u>Tree</u> represents a variable named "V". Then  (assuming  a  function  <u>print/1</u>  for  printing  syntax
              trees),  evaluating  <u>print(abstract(Tree))</u>  -  simply  using  abstract/1  to  map  the actual data
              structure onto a syntax tree representation - would output a string that might look something like
              "<u>{tree,</u> <u>variable,</u> <u>...,</u> <u>"V",</u> <u>...}</u>", which is obviously  dependent  on  the  implementation  of  the
              abstract  syntax trees. This could e.g. be useful for caching a syntax tree in a file. However, in
              some situations like  in  a  program  generator  generator  (with  two  "generator"),  it  may  be
              unacceptable.  Using  <u>print(meta(Tree))</u>  instead  would output a <u>representation</u> <u>independent</u> syntax
              tree generating expression; in the above case, something like "<u>erl_syntax:variable("V")</u>".

              <u>See</u> <u>also:</u> abstract/1, get_ann/1, type/1.

       <b>module_qualifier(Module::syntaxTree(),</b> <b>Body::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract module qualifier. The result represents "<u>Module:Body</u>".

              <u>See</u> <u>also:</u> module_qualifier_argument/1, module_qualifier_body/1.

       <b>module_qualifier_argument(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the argument (the module) subtree of a <u>module_qualifier</u> node.

              <u>See</u> <u>also:</u> module_qualifier/2.

       <b>module_qualifier_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the body subtree of a <u>module_qualifier</u> node.

              <u>See</u> <u>also:</u> module_qualifier/2.

       <b>named_fun_expr(Name::syntaxTree(),</b> <b>Clauses::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract named fun-expression. If <u>Clauses</u> is <u>[C1,</u> <u>...,</u> <u>Cn]</u>, the result represents  "<u>fun</u>
              <u>Name</u>  <u>C1;</u>  <u>...;</u> <u>Name</u> <u>Cn</u> <u>end</u>". More exactly, if each <u>Ci</u> represents "<u>(Pi1,</u> <u>...,</u> <u>Pim)</u> <u>Gi</u> <u>-&gt;</u> <u>Bi</u>", then
              the result represents "<u>fun</u> <u>Name(P11,</u> <u>...,</u> <u>P1m)</u> <u>G1</u> <u>-&gt;</u> <u>B1;</u> <u>...;</u> <u>Name(Pn1,</u> <u>...,</u> <u>Pnm)</u> <u>Gn</u> <u>-&gt;</u> <u>Bn</u> <u>end</u>".

              <u>See</u> <u>also:</u> named_fun_expr_arity/1, named_fun_expr_clauses/1, named_fun_expr_name/1.

       <b>named_fun_expr_arity(Node::syntaxTree())</b> <b>-&gt;</b> <b>arity()</b>

              Returns the arity of a <u>named_fun_expr</u> node. The result is the number of parameter patterns in  the
              first clause of the named fun-expression; subsequent clauses are ignored.

              An  exception  is  thrown  if  <u>named_fun_expr_clauses(Node)</u> returns an empty list, or if the first
              element of that list is not a syntax tree <u>C</u> of type  <u>clause</u>  such  that  <u>clause_patterns(C)</u>  is  a
              nonempty list.

              <u>See</u> <u>also:</u> clause/3, clause_patterns/1, named_fun_expr/2, named_fun_expr_clauses/1.

       <b>named_fun_expr_clauses(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of clause subtrees of a <u>named_fun_expr</u> node.

              <u>See</u> <u>also:</u> named_fun_expr/2.

       <b>named_fun_expr_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of a <u>named_fun_expr</u> node.

              <u>See</u> <u>also:</u> named_fun_expr/2.

       <b>nil()</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract empty list. The result represents "<u>[]</u>". The empty list is traditionally called
              "nil".

              <u>See</u> <u>also:</u> is_list_skeleton/1, list/2.

       <b>normalize_list(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Expands  an  abstract  list skeleton to its most explicit form. If <u>Node</u> represents "<u>[E1,</u> <u>...,</u> <u>En</u> <u>|</u>
              <u>Tail]</u>", the result represents "<u>[E1</u> <u>|</u> <u>...</u> <u>[En</u> <u>|</u> <u>Tail1]</u>  <u>...</u>  <u>]</u>",  where  <u>Tail1</u>  is  the  result  of
              <u>normalize_list(Tail)</u>.  If <u>Node</u> represents "<u>[E1,</u> <u>...,</u> <u>En]</u>", the result simply represents "<u>[E1</u> <u>|</u> <u>...</u>
              <u>[En</u> <u>|</u> <u>[]]</u> <u>...</u> <u>]</u>". If <u>Node</u> does not represent a list skeleton, <u>Node</u> itself is returned.

              <u>See</u> <u>also:</u> compact_list/1, list/2.

       <b>operator(Name::atom()</b> <b>|</b> <b>string())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract operator. The name of the operator is the character  sequence  represented  by
              <u>Name</u>.  This  is  analogous  to  the print name of an atom, but an operator is never written within
              single-quotes; e.g., the result of <u>operator('++')</u> represents "<u>++</u>" rather than "<u>'++'</u>".

              <u>See</u> <u>also:</u> atom/1, operator_literal/1, operator_name/1.

       <b>operator_literal(Node::syntaxTree())</b> <b>-&gt;</b> <b>string()</b>

              Returns the literal string represented by an <u>operator</u> node. This is simply the operator name as  a
              string.

              <u>See</u> <u>also:</u> operator/1.

       <b>operator_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>atom()</b>

              Returns the name of an <u>operator</u> node. Note that the name is returned as an atom.

              <u>See</u> <u>also:</u> operator/1.

       <b>parentheses(Expr::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract parenthesised expression. The result represents "<u>(Body)</u>", independently of the
              context.

              <u>See</u> <u>also:</u> parentheses_body/1.

       <b>parentheses_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the body subtree of a <u>parentheses</u> node.

              <u>See</u> <u>also:</u> parentheses/1.

       <b>prefix_expr(Operator::syntaxTree(),</b> <b>Argument::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract prefix operator expression. The result represents "<u>Operator</u> <u>Argument</u>".

              <u>See</u> <u>also:</u> infix_expr/3, prefix_expr_argument/1, prefix_expr_operator/1.

       <b>prefix_expr_argument(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the argument subtree of a <u>prefix_expr</u> node.

              <u>See</u> <u>also:</u> prefix_expr/2.

       <b>prefix_expr_operator(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the operator subtree of a <u>prefix_expr</u> node.

              <u>See</u> <u>also:</u> prefix_expr/2.

       <b>receive_expr(Clauses::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to receive_expr(Clauses, none, []).

       <b>receive_expr(Clauses::[syntaxTree()],</b>    <b>Timeout::none</b>   <b>|</b>   <b>syntaxTree(),</b>   <b>Action::[syntaxTree()])</b>   <b>-&gt;</b>
       <b>syntaxTree()</b>

              Creates an abstract receive-expression. If <u>Timeout</u> is <u>none</u>, the  result  represents  "<u>receive</u>  <u>C1;</u>
              <u>...;</u>  <u>Cn</u>  <u>end</u>" (the <u>Action</u> argument is ignored). Otherwise, if <u>Clauses</u> is <u>[C1,</u> <u>...,</u> <u>Cn]</u> and <u>Action</u>
              is <u>[A1,</u> <u>...,</u> <u>Am]</u>, the result represents "<u>receive</u> <u>C1;</u> <u>...;</u> <u>Cn</u> <u>after</u> <u>Timeout</u> <u>-&gt;</u> <u>A1,</u>  <u>...,</u>  <u>Am</u>  <u>end</u>".
              More  exactly, if each <u>Ci</u> represents "<u>(Pi)</u> <u>Gi</u> <u>-&gt;</u> <u>Bi</u>", then the result represents "<u>receive</u> <u>P1</u> <u>G1</u> <u>-&gt;</u>
              <u>B1;</u> <u>...;</u> <u>Pn</u> <u>Gn</u> <u>-&gt;</u> <u>Bn</u> <u>...</u> <u>end</u>".

              Note that in Erlang, a receive-expression must have at least one clause  if  no  timeout  part  is
              specified.

              <u>See</u>  <u>also:</u>  case_expr/2,  clause/3, receive_expr/1, receive_expr_action/1, receive_expr_clauses/1,
              receive_expr_timeout/1.

       <b>receive_expr_action(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of action body subtrees of a <u>receive_expr</u> node. If <u>Node</u> represents  "<u>receive</u>  <u>C1;</u>
              <u>...;</u> <u>Cn</u> <u>end</u>", this is the empty list.

              <u>See</u> <u>also:</u> receive_expr/3.

       <b>receive_expr_clauses(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of clause subtrees of a <u>receive_expr</u> node.

              <u>See</u> <u>also:</u> receive_expr/3.

       <b>receive_expr_timeout(Node::syntaxTree())</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>syntaxTree()</b>

              Returns  the  timeout subtree of a <u>receive_expr</u> node, if any. If <u>Node</u> represents "<u>receive</u> <u>C1;</u> <u>...;</u>
              <u>Cn</u> <u>end</u>", <u>none</u> is returned. Otherwise, if <u>Node</u> represents "<u>receive</u> <u>C1;</u> <u>...;</u> <u>Cn</u> <u>after</u> <u>Timeout</u> <u>-&gt;</u> <u>...</u>
              <u>end</u>", <u>Timeout</u> is returned.

              <u>See</u> <u>also:</u> receive_expr/3.

       <b>record_access(Argument::syntaxTree(),</b> <b>Type::syntaxTree(),</b> <b>Field::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract record field access expression. The result represents "<u>Argument#Type.Field</u>".

              <u>See</u> <u>also:</u> record_access_argument/1, record_access_field/1, record_access_type/1, record_expr/3.

       <b>record_access_argument(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the argument subtree of a <u>record_access</u> node.

              <u>See</u> <u>also:</u> record_access/3.

       <b>record_access_field(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the field subtree of a <u>record_access</u> node.

              <u>See</u> <u>also:</u> record_access/3.

       <b>record_access_type(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the type subtree of a <u>record_access</u> node.

              <u>See</u> <u>also:</u> record_access/3.

       <b>record_expr(Type::syntaxTree(),</b> <b>Fields::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to record_expr(none, Type, Fields).

       <b>record_expr(Argument::none</b> <b>|</b> <b>syntaxTree(),</b> <b>Type::syntaxTree(),</b> <b>Fields::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract record expression. If <u>Fields</u> is <u>[F1,</u> <u>...,</u> <u>Fn]</u>, then if <u>Argument</u> is  <u>none</u>,  the
              result represents "<u>#Type{F1,</u> <u>...,</u> <u>Fn}</u>", otherwise it represents "<u>Argument#Type{F1,</u> <u>...,</u> <u>Fn}</u>".

              <u>See</u>    <u>also:</u>   record_access/3,   record_expr/2,   record_expr_argument/1,   record_expr_fields/1,
              record_expr_type/1, record_field/2, record_index_expr/2.

       <b>record_expr_argument(Node::syntaxTree())</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>syntaxTree()</b>

              Returns the argument subtree of a <u>record_expr</u> node, if any. If <u>Node</u> represents "<u>#Type{...}</u>",  <u>none</u>
              is returned. Otherwise, if <u>Node</u> represents "<u>Argument#Type{...}</u>", <u>Argument</u> is returned.

              <u>See</u> <u>also:</u> record_expr/3.

       <b>record_expr_fields(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of field subtrees of a <u>record_expr</u> node.

              <u>See</u> <u>also:</u> record_expr/3.

       <b>record_expr_type(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the type subtree of a <u>record_expr</u> node.

              <u>See</u> <u>also:</u> record_expr/3.

       <b>record_field(Name::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to record_field(Name, none).

       <b>record_field(Name::syntaxTree(),</b> <b>Value::none</b> <b>|</b> <b>syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  record  field specification. If <u>Value</u> is <u>none</u>, the result represents simply
              "<u>Name</u>", otherwise it represents "<u>Name</u> <u>=</u> <u>Value</u>".

              <u>See</u> <u>also:</u> record_expr/3, record_field_name/1, record_field_value/1.

       <b>record_field_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of a <u>record_field</u> node.

              <u>See</u> <u>also:</u> record_field/2.

       <b>record_field_value(Node::syntaxTree())</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>syntaxTree()</b>

              Returns the value subtree of a <u>record_field</u> node, if any.  If  <u>Node</u>  represents  "<u>Name</u>",  <u>none</u>  is
              returned. Otherwise, if <u>Node</u> represents "<u>Name</u> <u>=</u> <u>Value</u>", <u>Value</u> is returned.

              <u>See</u> <u>also:</u> record_field/2.

       <b>record_index_expr(Type::syntaxTree(),</b> <b>Field::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract record field index expression. The result represents "<u>#Type.Field</u>".

              (Note: the function name <u>record_index/2</u> is reserved by the Erlang compiler, which is why that name
              could not be used for this constructor.)

              <u>See</u> <u>also:</u> record_expr/3, record_index_expr_field/1, record_index_expr_type/1.

       <b>record_index_expr_field(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the field subtree of a <u>record_index_expr</u> node.

              <u>See</u> <u>also:</u> record_index_expr/2.

       <b>record_index_expr_type(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the type subtree of a <u>record_index_expr</u> node.

              <u>See</u> <u>also:</u> record_index_expr/2.

       <b>record_type(Name::syntaxTree(),</b> <b>Fields::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract record type. If <u>Fields</u> is <u>[F1,</u> <u>...,</u> <u>Fn]</u>, the result represents "<u>#Name{F1,</u> <u>...,</u>
              <u>Fn}</u>".

              <u>See</u> <u>also:</u> record_type_fields/1, record_type_name/1.

       <b>record_type_field(Name::syntaxTree(),</b> <b>Type::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract record type field. The result represents "<u>Name</u> <u>::</u> <u>Type</u>".

              <u>See</u> <u>also:</u> record_type_field_name/1, record_type_field_type/1.

       <b>record_type_field_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of a <u>record_type_field</u> node.

              <u>See</u> <u>also:</u> record_type_field/2.

       <b>record_type_field_type(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the type subtree of a <u>record_type_field</u> node.

              <u>See</u> <u>also:</u> record_type_field/2.

       <b>record_type_fields(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the fields subtree of a <u>record_type</u> node.

              <u>See</u> <u>also:</u> record_type/2.

       <b>record_type_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the name subtree of a <u>record_type</u> node.

              <u>See</u> <u>also:</u> record_type/2.

       <b>remove_comments(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Clears the associated comments of <u>Node</u>.

              Note:  This is equivalent to <u>set_precomments(set_postcomments(Node,</u> <u>[]),</u> <u>[])</u>, but potentially more
              efficient.

              <u>See</u> <u>also:</u> set_postcomments/2, set_precomments/2.

       <b>revert(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns an <u>erl_parse</u>-compatible representation of a syntax tree, if possible. If <u>Tree</u> represents a
              well-formed Erlang program or expression, the conversion should work without problems.  Typically,
              is_tree/1  yields  <u>true</u>  if conversion failed (i.e., the result is still an abstract syntax tree),
              and <u>false</u> otherwise.

              The  is_tree/1  test  is  not  completely  foolproof.  For  a  few  special   node   types   (e.g.
              <u>arity_qualifier</u>),  if  such  a  node occurs in a context where it is not expected, it will be left
              unchanged as a non-reverted subtree of the result. This can only happen if <u>Tree</u> does not  actually
              represent legal Erlang code.

              <u>See</u> <u>also:</u> <a href="../man3erl/erl_parse.3erl.html">erl_parse</a>(3erl), revert_forms/1.

       <b>revert_forms(Forms::forms())</b> <b>-&gt;</b> <b>[erl_parse()]</b>

              Reverts  a  sequence  of Erlang source code forms. The sequence can be given either as a <u>form_list</u>
              syntax tree (possibly nested), or as a list of "program form" syntax  trees.  If  successful,  the
              corresponding  flat  list of <u>erl_parse</u>-compatible syntax trees is returned (see revert/1). If some
              program form could not be reverted, <u>{error,</u> <u>Form}</u> is  thrown.  Standalone  comments  in  the  form
              sequence are discarded.

              <u>See</u> <u>also:</u> form_list/1, is_form/1, revert/1.

       <b>set_ann(Node::syntaxTree(),</b> <b>As::[term()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Sets the list of user annotations of <u>Node</u> to <u>Annotations</u>.

              <u>See</u> <u>also:</u> add_ann/2, copy_ann/2, get_ann/1.

       <b>set_attrs(Node::syntaxTree(),</b> <b>Attr::syntaxTreeAttributes())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Sets the attributes of <u>Node</u> to <u>Attributes</u>.

              <u>See</u> <u>also:</u> copy_attrs/2, get_attrs/1.

       <b>set_pos(Node::syntaxTree(),</b> <b>Pos::annotation_or_location())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Sets the position information of <u>Node</u> to <u>Pos</u>.

              <u>See</u> <u>also:</u> copy_pos/2, get_pos/1.

       <b>set_postcomments(Node::syntaxTree(),</b> <b>Cs::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Sets  the  post-comments of <u>Node</u> to <u>Comments</u>. <u>Comments</u> should be a possibly empty list of abstract
              comments, in top-down textual order

              <u>See</u> <u>also:</u> add_postcomments/2,  comment/2,  copy_comments/2,  get_postcomments/1,  join_comments/2,
              remove_comments/1, set_precomments/2.

       <b>set_precomments(Node::syntaxTree(),</b> <b>Cs::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Sets  the  pre-comments  of <u>Node</u> to <u>Comments</u>. <u>Comments</u> should be a possibly empty list of abstract
              comments, in top-down textual order.

              <u>See</u>  <u>also:</u>  add_precomments/2,  comment/2,  copy_comments/2,  get_precomments/1,  join_comments/2,
              remove_comments/1, set_postcomments/2.

       <b>size_qualifier(Body::syntaxTree(),</b> <b>Size::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract size qualifier. The result represents "<u>Body:Size</u>".

              <u>See</u> <u>also:</u> size_qualifier_argument/1, size_qualifier_body/1.

       <b>size_qualifier_argument(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the argument subtree (the size) of a <u>size_qualifier</u> node.

              <u>See</u> <u>also:</u> size_qualifier/2.

       <b>size_qualifier_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the body subtree of a <u>size_qualifier</u> node.

              <u>See</u> <u>also:</u> size_qualifier/2.

       <b>string(String::string())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  string  literal.  The  result  represents <u>"Text"</u> (including the surrounding
              double-quotes),  where  <u>Text</u>  corresponds  to  the  sequence  of  characters  in  <u>Value</u>,  but  not
              representing a <u>specific</u> string literal.

              For  example, the result of <u>string("x\ny")</u> represents any and all of <u>"x\ny"</u>, <u>"x\12y"</u>, <u>"x\012y"</u> and
              <u>"x\^Jy"</u>; see char/1.

              <u>See</u> <u>also:</u> char/1, is_string/2, string_literal/1, string_literal/2, string_value/1.

       <b>string_literal(Node::syntaxTree())</b> <b>-&gt;</b> <b>nonempty_string()</b>

              Returns the literal string represented by a <u>string</u> node. This  includes  surrounding  double-quote
              characters. Characters beyond 255 will be escaped.

              <u>See</u> <u>also:</u> string/1.

       <b>string_literal(Node::syntaxTree(),</b> <b>X2::encoding())</b> <b>-&gt;</b> <b>nonempty_string()</b>

              Returns  the  literal  string represented by a <u>string</u> node. This includes surrounding double-quote
              characters. Depending on the encoding characters beyond 255 will be escaped (<u>latin1</u>) or copied  as
              is (<u>utf8</u>).

              <u>See</u> <u>also:</u> string/1.

       <b>string_value(Node::syntaxTree())</b> <b>-&gt;</b> <b>string()</b>

              Returns the value represented by a <u>string</u> node.

              <u>See</u> <u>also:</u> string/1.

       <b>subtrees(T::syntaxTree())</b> <b>-&gt;</b> <b>[[syntaxTree()]]</b>

              Returns the grouped list of all subtrees of a syntax tree. If <u>Node</u> is a leaf node (see is_leaf/1),
              this  is  the  empty list, otherwise the result is always a nonempty list, containing the lists of
              subtrees of <u>Node</u>, in left-to-right order as they occur in the printed program text, and grouped by
              category. Often, each group contains only a single subtree.

              Depending on the type of <u>Node</u>, the size of some groups may be variable (e.g., the group consisting
              of all the elements of a tuple), while others always contain the same number of elements - usually
              exactly one (e.g., the group containing the  argument  expression  of  a  case-expression).  Note,
              however,  that  the exact structure of the returned list (for a given node type) should in general
              not be depended upon, since it might be subject to change without notice.

              The function subtrees/1 and the constructor functions make_tree/2 and update_tree/2 can be a great
              help if one wants to traverse a syntax tree, visiting all its subtrees, but  treat  nodes  of  the
              tree  in  a  uniform  way  in most or all cases. Using these functions makes this simple, and also
              assures that your code is not overly sensitive to extensions of the syntax tree data type, because
              any node types not explicitly handled by your code can be left to a default case.

              For example:

                   postorder(F, Tree) -&gt;
                      F(case subtrees(Tree) of
                          [] -&gt; Tree;
                          List -&gt; update_tree(Tree,
                                              [[postorder(F, Subtree)
                                                || Subtree &amp;lt;- Group]
                                               || Group &amp;lt;- List])
                        end).

              maps the function <u>F</u> on <u>Tree</u> and all its subtrees, doing a post-order traversal of the syntax tree.
              (Note the use of update_tree/2 to preserve node attributes.) For a simple function like:

                   f(Node) -&gt;
                      case type(Node) of
                          atom -&gt; atom("a_" ++ atom_name(Node));
                          _ -&gt; Node
                      end.

              the call <u>postorder(fun</u> <u>f/1,</u> <u>Tree)</u> will yield a new representation of <u>Tree</u> in which all atom  names
              have  been  extended  with  the prefix "a_", but nothing else (including comments, annotations and
              line numbers) has been changed.

              <u>See</u> <u>also:</u> copy_attrs/2, is_leaf/1, make_tree/2, type/1.

       <b>text(String::string())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract piece of source code text. The  result  represents  exactly  the  sequence  of
              characters in <u>String</u>. This is useful in cases when one wants full control of the resulting output,
              e.g., for the appearance of floating-point numbers or macro definitions.

              <u>See</u> <u>also:</u> text_string/1.

       <b>text_string(Node::syntaxTree())</b> <b>-&gt;</b> <b>string()</b>

              Returns the character sequence represented by a <u>text</u> node.

              <u>See</u> <u>also:</u> text/1.

       <b>tree(Type::atom())</b> <b>-&gt;</b> <b>tree()</b>

              Equivalent to tree(Type, []).

       <b>tree(Type::atom(),</b> <b>Data::term())</b> <b>-&gt;</b> <b>tree()</b>

              <u>For</u>  <u>special</u> <u>purposes</u> <u>only</u>. Creates an abstract syntax tree node with type tag <u>Type</u> and associated
              data <u>Data</u>.

              This function and the related is_tree/1 and data/1 provide a uniform way  to  extend  the  set  of
              <u>erl_parse</u> node types. The associated data is any term, whose format may depend on the type tag.

              <u>Notes:</u>

                * Any  nodes  created  outside  of this module must have type tags distinct from those currently
                  defined by this module; see type/1 for a complete list.

                * The type tag of a syntax tree node may also  be  used  as  a  primary  tag  by  the  <u>erl_parse</u>
                  representation;  in  that case, the selector functions for that node type <u>must</u> handle both the
                  abstract syntax tree and the <u>erl_parse</u> form. The function <u>type(T)</u> should  return  the  correct
                  type  tag  regardless  of the representation of <u>T</u>, so that the user sees no difference between
                  <u>erl_syntax</u> and <u>erl_parse</u> nodes.

              <u>See</u> <u>also:</u> data/1, is_tree/1, type/1.

       <b>try_after_expr(Body::[syntaxTree()],</b> <b>After::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to try_expr(Body, [], [], After).

       <b>try_expr(Body::[syntaxTree()],</b> <b>Handlers::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to try_expr(Body, [], Handlers).

       <b>try_expr(Body::[syntaxTree()],</b> <b>Clauses::[syntaxTree()],</b> <b>Handlers::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Equivalent to try_expr(Body, Clauses, Handlers, []).

       <b>try_expr(Body::[syntaxTree()],</b> <b>Clauses::[syntaxTree()],</b> <b>Handlers::[syntaxTree()],</b>  <b>After::[syntaxTree()])</b>
       <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract try-expression. If <u>Body</u> is <u>[B1,</u> <u>...,</u> <u>Bn]</u>, <u>Clauses</u> is <u>[C1,</u> <u>...,</u> <u>Cj]</u>, <u>Handlers</u>
              is <u>[H1,</u> <u>...,</u> <u>Hk]</u>, and <u>After</u> is <u>[A1,</u> <u>...,</u> <u>Am]</u>, the result represents "<u>try</u> <u>B1,</u> <u>...,</u> <u>Bn</u> <u>of</u>  <u>C1;</u>  <u>...;</u>
              <u>Cj</u>  <u>catch</u>  <u>H1;</u>  <u>...;</u>  <u>Hk</u> <u>after</u> <u>A1,</u> <u>...,</u> <u>Am</u> <u>end</u>". More exactly, if each <u>Ci</u> represents "<u>(CPi)</u> <u>CGi</u> <u>-&gt;</u>
              <u>CBi</u>", and each <u>Hi</u> represents "<u>(HPi)</u> <u>HGi</u> <u>-&gt;</u> <u>HBi</u>", then the result represents "<u>try</u> <u>B1,</u>  <u>...,</u>  <u>Bn</u>  <u>of</u>
              <u>CP1</u>  <u>CG1</u>  <u>-&gt;</u>  <u>CB1;</u> <u>...;</u> <u>CPj</u> <u>CGj</u> <u>-&gt;</u> <u>CBj</u> <u>catch</u> <u>HP1</u> <u>HG1</u> <u>-&gt;</u> <u>HB1;</u> <u>...;</u> <u>HPk</u> <u>HGk</u> <u>-&gt;</u> <u>HBk</u> <u>after</u> <u>A1,</u> <u>...,</u> <u>Am</u>
              <u>end</u>"; see case_expr/2. If <u>Clauses</u> is the empty list, the <u>of</u> <u>...</u> section is left out. If  <u>After</u>  is
              the  empty  list,  the  <u>after</u> <u>...</u> section is left out. If <u>Handlers</u> is the empty list, and <u>After</u> is
              nonempty, the <u>catch</u> <u>...</u> section is left out.

              <u>See</u> <u>also:</u> case_expr/2,  class_qualifier/2,  clause/3,  try_after_expr/2,  try_expr/2,  try_expr/3,
              try_expr_after/1, try_expr_body/1, try_expr_clauses/1, try_expr_handlers/1.

       <b>try_expr_after(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of "after" subtrees of a <u>try_expr</u> node.

              <u>See</u> <u>also:</u> try_expr/4.

       <b>try_expr_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of body subtrees of a <u>try_expr</u> node.

              <u>See</u> <u>also:</u> try_expr/4.

       <b>try_expr_clauses(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns  the  list  of case-clause subtrees of a <u>try_expr</u> node. If <u>Node</u> represents "<u>try</u> <u>Body</u> <u>catch</u>
              <u>H1;</u> <u>...;</u> <u>Hn</u> <u>end</u>", the result is the empty list.

              <u>See</u> <u>also:</u> try_expr/4.

       <b>try_expr_handlers(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of handler-clause subtrees of a <u>try_expr</u> node.

              <u>See</u> <u>also:</u> try_expr/4.

       <b>tuple(List::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract tuple. If <u>Elements</u> is <u>[X1,</u> <u>...,</u> <u>Xn]</u>, the result represents "<u>{X1,</u> <u>...,</u> <u>Xn}</u>".

              Note: The Erlang language has distinct 1-tuples, i.e., <u>{X}</u> is always distinct from <u>X</u> itself.

              <u>See</u> <u>also:</u> tuple_elements/1, tuple_size/1.

       <b>tuple_elements(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of element subtrees of a <u>tuple</u> node.

              <u>See</u> <u>also:</u> tuple/1.

       <b>tuple_size(Node::syntaxTree())</b> <b>-&gt;</b> <b>non_neg_integer()</b>

              Returns the number of elements of a <u>tuple</u> node.

              Note: this is equivalent to <u>length(tuple_elements(Node))</u>, but potentially more efficient.

              <u>See</u> <u>also:</u> tuple/1, tuple_elements/1.

       <b>tuple_type()</b> <b>-&gt;</b> <b>term()</b>

              Equivalent to tuple_type(any_size).

       <b>tuple_type(Elements::any_size</b> <b>|</b> <b>[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract type tuple. If <u>Elements</u> is <u>[T1,</u> <u>...,</u> <u>Tn]</u>, the  result  represents  "<u>{T1,</u>  <u>...,</u>
              <u>Tn}</u>"; otherwise, if <u>Elements</u> is <u>any_size</u>, it represents "<u>tuple()</u>".

              <u>See</u> <u>also:</u> tuple_type_elements/1.

       <b>tuple_type_elements(Node::syntaxTree())</b> <b>-&gt;</b> <b>any_size</b> <b>|</b> <b>[syntaxTree()]</b>

              Returns  the  list  of  type  element subtrees of a <u>tuple_type</u> node. If <u>Node</u> represents "<u>tuple()</u>",
              <u>any_size</u> is returned; otherwise, if <u>Node</u> represents "<u>{T1,</u> <u>...,</u> <u>Tn}</u>", <u>[T1,</u> <u>...,</u> <u>Tn]</u> is returned.

              <u>See</u> <u>also:</u> tuple_type/0, tuple_type/1.

       <b>type(Tree::syntaxTree())</b> <b>-&gt;</b> <b>atom()</b>

              Returns the type tag of <u>Node</u>. If <u>Node</u> does not represent a  syntax  tree,  evaluation  fails  with
              reason <u>badarg</u>. Node types currently defined by this module are:

              application annotated_type arity_qualifier atom
              attribute binary binary_field bitstring_type
              block_expr case_expr catch_expr char
              class_qualifier clause comment conjunction
              constrained_function_type constraint disjunction eof_marker
              error_marker float form_list fun_expr
              fun_type function function_type generator
              if_expr implicit_fun infix_expr integer
              integer_range_type list list_comp macro
              map_expr map_field_assoc map_field_exact map_type
              map_type_assoc map_type_exact match_expr module_qualifier
              named_fun_expr nil operator parentheses
              prefix_expr receive_expr record_access record_expr
              record_field record_index_expr record_type record_type_field
              size_qualifier string text try_expr
              tuple tuple_type typed_record_field type_application
              type_union underscore user_type_application variable
              warning_marker

              The user may (for special purposes) create additional nodes with other type tags, using the tree/2
              function.

              Note:  The  primary  constructor functions for a node type should always have the same name as the
              node type itself.

              <u>See</u> <u>also:</u>  annotated_type/2,  application/3,  arity_qualifier/2,  atom/1,  attribute/2,  binary/1,
              binary_field/2,     bitstring_type/2,    block_expr/1,    case_expr/2,    catch_expr/1,    char/1,
              class_qualifier/2, clause/3, comment/2, conjunction/1, constrained_function_type/2,  constraint/2,
              disjunction/1,   eof_marker/0,   error_marker/1,  float/1,  form_list/1,  fun_expr/1,  fun_type/0,
              function/2,   function_type/1,   function_type/2,    generator/2,    if_expr/1,    implicit_fun/2,
              infix_expr/3,   integer/1,   integer_range_type/2,   list/2,   list_comp/2,  macro/2,  map_expr/2,
              map_field_assoc/2, map_field_exact/2, map_type/0, map_type/1, map_type_assoc/2,  map_type_exact/2,
              match_expr/2,    module_qualifier/2,    named_fun_expr/2,    nil/0,   operator/1,   parentheses/1,
              prefix_expr/2,      receive_expr/3,      record_access/3,      record_expr/2,      record_field/2,
              record_index_expr/2,   record_type/2,  record_type_field/2,  size_qualifier/2,  string/1,  text/1,
              tree/2,  try_expr/3,  tuple/1,  tuple_type/0,  tuple_type/1,   type_application/2,   type_union/1,
              typed_record_field/2, underscore/0, user_type_application/2, variable/1, warning_marker/1.

       <b>type_application(TypeName::syntaxTree(),</b> <b>Arguments::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract  type  application  expression.  If  <u>Arguments</u>  is <u>[T1,</u> <u>...,</u> <u>Tn]</u>, the result
              represents "<u>TypeName(T1,</u> <u>...Tn)</u>".

              <u>See</u>    <u>also:</u>    type_application/3,     type_application_arguments/1,     type_application_name/1,
              user_type_application/2.

       <b>type_application(Module::none</b>   <b>|</b>  <b>syntaxTree(),</b>  <b>TypeName::syntaxTree(),</b>  <b>Arguments::[syntaxTree()])</b>  <b>-&gt;</b>
       <b>syntaxTree()</b>

              Creates an abstract type application expression. If <u>Module</u> is <u>none</u>, this is call is equivalent  to
              <u>type_application(TypeName,</u>      <u>Arguments)</u>,      otherwise      it      is      equivalent      to
              <u>type_application(module_qualifier(Module,</u> <u>TypeName),</u> <u>Arguments)</u>.

              (This is a utility function.)

              <u>See</u> <u>also:</u> module_qualifier/2, type_application/2.

       <b>type_application_arguments(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the arguments subtrees of a <u>type_application</u> node.

              <u>See</u> <u>also:</u> type_application/2.

       <b>type_application_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the type name subtree of a <u>type_application</u> node.

              <u>See</u> <u>also:</u> type_application/2.

       <b>type_union(Types::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract type union. If <u>Types</u> is <u>[T1,</u> <u>...,</u> <u>Tn]</u>, the result represents "<u>T1</u> <u>|</u> <u>...</u> <u>|</u> <u>Tn</u>".

              <u>See</u> <u>also:</u> type_union_types/1.

       <b>type_union_types(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the list of type subtrees of a <u>type_union</u> node.

              <u>See</u> <u>also:</u> type_union/1.

       <b>typed_record_field(Field::syntaxTree(),</b> <b>Type::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract typed record field specification. The result represents "<u>Field</u> <u>::</u> <u>Type</u>".

              <u>See</u> <u>also:</u> typed_record_field_body/1, typed_record_field_type/1.

       <b>typed_record_field_body(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the field subtree of a <u>typed_record_field</u> node.

              <u>See</u> <u>also:</u> typed_record_field/2.

       <b>typed_record_field_type(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the type subtree of a <u>typed_record_field</u> node.

              <u>See</u> <u>also:</u> typed_record_field/2.

       <b>underscore()</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract universal pattern ("<b>_</b>"). The lexical representation  is  a  single  underscore
              character. Note that this is <u>not</u> a variable, lexically speaking.

              <u>See</u> <u>also:</u> variable/1.

       <b>update_tree(Node::syntaxTree(),</b> <b>Groups::[[syntaxTree()]])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  a  syntax tree with the same type and attributes as the given tree. This is equivalent to
              <u>copy_attrs(Node,</u> <u>make_tree(type(Node),</u> <u>Groups))</u>.

              <u>See</u> <u>also:</u> copy_attrs/2, make_tree/2, type/1.

       <b>user_type_application(TypeName::syntaxTree(),</b> <b>Arguments::[syntaxTree()])</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract user type. If <u>Arguments</u> is <u>[T1,</u> <u>...,</u> <u>Tn]</u>, the result represents  "<u>TypeName(T1,</u>
              <u>...Tn)</u>".

              <u>See</u> <u>also:</u> type_application/2, user_type_application_arguments/1, user_type_application_name/1.

       <b>user_type_application_arguments(Node::syntaxTree())</b> <b>-&gt;</b> <b>[syntaxTree()]</b>

              Returns the arguments subtrees of a <u>user_type_application</u> node.

              <u>See</u> <u>also:</u> user_type_application/2.

       <b>user_type_application_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Returns the type name subtree of a <u>user_type_application</u> node.

              <u>See</u> <u>also:</u> user_type_application/2.

       <b>variable(Name::atom()</b> <b>|</b> <b>string())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates an abstract variable with the given name. <u>Name</u> may be any atom or string that represents a
              lexically valid variable name, but <u>not</u> a single underscore character; see underscore/0.

              Note:  no checking is done whether the character sequence represents a proper variable name, i.e.,
              whether or not its first character is an uppercase  Erlang  character,  or  whether  it  does  not
              contain control characters, whitespace, etc.

              <u>See</u> <u>also:</u> underscore/0, variable_literal/1, variable_name/1.

       <b>variable_literal(Node::syntaxTree())</b> <b>-&gt;</b> <b>string()</b>

              Returns the name of a <u>variable</u> node as a string.

              <u>See</u> <u>also:</u> variable/1.

       <b>variable_name(Node::syntaxTree())</b> <b>-&gt;</b> <b>atom()</b>

              Returns the name of a <u>variable</u> node as an atom.

              <u>See</u> <u>also:</u> variable/1.

       <b>warning_marker(Warning::term())</b> <b>-&gt;</b> <b>syntaxTree()</b>

              Creates  an  abstract warning marker. The result represents an occurrence of a possible problem in
              the source code, with an associated Erlang I/O ErrorInfo structure  given  by  <u>Error</u>  (see  module
              <a href="../man3erl/io.3erl.html">io</a>(3erl)  for  details).  Warning  markers  are regarded as source code forms, but have no defined
              lexical form.

              Note: this is supported only for backwards compatibility with existing parsers and tools.

              <u>See</u> <u>also:</u> eof_marker/0, error_marker/1, is_form/1, warning_marker_info/1.

       <b>warning_marker_info(Node::syntaxTree())</b> <b>-&gt;</b> <b>term()</b>

              Returns the ErrorInfo structure of a <u>warning_marker</u> node.

              <u>See</u> <u>also:</u> warning_marker/1.

</pre><h4><b>AUTHORS</b></h4><pre>
       Richard Carlsson <u>&lt;<a href="mailto:carlsson.richard@gmail.com">carlsson.richard@gmail.com</a>&gt;</u>

                                                syntax_tools 2.6                                <u><a href="../man3erl/erl_syntax.3erl.html">erl_syntax</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>