<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::HTML::Content - Perl extension for testing HTML output</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-html-content-perl">libtest-html-content-perl_0.13-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::HTML::Content - Perl extension for testing HTML output

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Test::HTML::Content( tests =&gt; 13 );

         $HTML = "&lt;html&gt;&lt;title&gt;A test page&lt;/title&gt;&lt;body&gt;&lt;p&gt;Home page&lt;/p&gt;
                  &lt;img src='<a href="http://www.perl.com/camel.png">http://www.perl.com/camel.png</a>' alt='camel'&gt;
                  &lt;a href='<a href="http://www.perl.com">http://www.perl.com</a>'&gt;Perl&lt;/a&gt;
                  &lt;img src='<a href="http://www.perl.com/camel.png">http://www.perl.com/camel.png</a>' alt='more camel'&gt;
                  &lt;!--Hidden message--&gt;&lt;/body&gt;&lt;/html&gt;";

         link_ok($HTML,"<a href="http://www.perl.com">http://www.perl.com</a>","We link to Perl");
         no_link($HTML,"<a href="http://www.pearl.com">http://www.pearl.com</a>","We have no embarassing typos");
         link_ok($HTML,qr"http://[a-z]+\.perl.com","We have a link to perl.com");

         title_count($HTML,1,"We have one title tag");
         title_ok($HTML,qr/test/);

         tag_ok($HTML,"img", {src =&gt; "<a href="http://www.perl.com/camel.png">http://www.perl.com/camel.png</a>"},
                               "We have an image of a camel on the page");
         tag_count($HTML,"img", {src =&gt; "<a href="http://www.perl.com/camel.png">http://www.perl.com/camel.png</a>"}, 2,
                               "In fact, we have exactly two camel images on the page");
         no_tag($HTML,"blink",{}, "No annoying blink tags ..." );

         # We can check the textual contents
         text_ok($HTML,"Perl");

         # We can also check the contents of comments
         comment_ok($HTML,"Hidden message");

         # Advanced stuff

         # Using a regular expression to match against
         # tag attributes - here checking there are no ugly styles
         no_tag($HTML,"p",{ style =&gt; qr'ugly$' }, "No ugly styles" );

         # REs also can be used for substrings in comments
         comment_ok($HTML,qr"[hH]idden\s+mess");

         # and if you have XML::LibXML or XML::XPath, you can
         # even do XPath queries yourself:
         xpath_ok($HTML,'/html/body/p','HTML is somewhat wellformed');
         no_xpath($HTML,'/html/head/p','HTML is somewhat wellformed');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a module to test the HTML output of your programs in simple test scripts. It can test a scalar
       (presumably containing HTML) for the presence (or absence, or a specific number) of tags having (or
       lacking) specific attributes. Unspecified attributes are ignored, and the attribute values can be
       specified as either scalars (meaning a match succeeds if the strings are identical) or regular
       expressions (meaning that a match succeeds if the actual attribute value is matched by the given RE) or
       undef (meaning that the attribute must not be present).

       If you want to specify or test the deeper structure of the HTML (for example, META tags within the BODY)
       or the (textual) content of tags, you will have to resort to "xpath_ok","xpath_count" and "no_xpath",
       which take an XPath expression. If you find yourself crafting very complex XPath expression to verify the
       structure of your output, it is time to rethink your testing process and maybe use a template based
       solution or simply compare against prefabricated files as a whole.

       The used HTML parser is HTML::TokeParser, the used XPath module is XML::XPath or XML::LibXML. XML::XPath
       needs valid xHTML, XML::LibXML will try its best to force your code into xHTML, but it is best to supply
       valid xHTML (snippets) to the test functions.

       If no XPath parsers/interpreters are available, the tests will automatically skip, so your users won't
       need to install XML::XPath or XML::LibXML. The module then falls back onto a crude implementation of the
       core functions for tags, links, comments and text, and the diagnostic output of the tests varies a bit.

       The test functionality is derived from Test::Builder, and the export behaviour is the same. When you use
       Test::HTML::Content, a set of HTML testing functions is exported into the namespace of the caller.

   <b>EXPORT</b>
       Exports the bunch of test functions :

         link_ok() no_link() link_count()
         tag_ok() no_tag() tag_count()
         text_ok no_text() text_count()
         comment_ok() no_comment() comment_count()
         xpath_ok() no_xpath() xpath_count()
         has_declaration() no_declaration()

   <b>CONSIDERATIONS</b>
       The module reparses the HTML string every time a test function is called.  This will make running many
       tests over the same, large HTML stream relatively slow. A possible speedup could be simple minded caching
       mechanism that keeps the most recent HTML stream in a cache.

   <b>CAVEATS</b>
       The test output differs between XPath and HTML parsing, because XML::XPath delivers the complete node
       including the content, where my HTML parser only delivers the start tag. So don't make your tests depend
       on the _exact_ output of my tests. It was a pain to do so in my test scripts for this module and if you
       really want to, take a look at the included test scripts.

       The title functions "title_ok" and "no_title" rely on the XPath functionality and will thus skip if XPath
       functionality is unavailable.

   <b>BUGS</b>
       Currently, if there is text split up by comments, the text will be seen as two separate entities, so the
       following dosen't work :

         is_text( "Hello&lt;!-- brave new--&gt; World", "Hello World" );

       Whether this is a real bug or not, I don't know at the moment - most likely, I'll modify <b>text_ok()</b> and
       siblings to ignore embedded comments.

   <b>TODO</b>
       My things on the todo list for this module. Patches are welcome !

       •   Refactor the code to fold some of the internal routines

       •   Implement a cache for the last parsed tree / token sequence

       •   Possibly <b>diag()</b> the row/line number for failing tests

       •   Allow  RE  instead  of  plain strings in the functions (for tags themselves). This one is most likely
           useless.

</pre><h4><b>LICENSE</b></h4><pre>
       This code may be distributed under the same terms as Perl itself.

</pre><h4><b>AUTHOR</b></h4><pre>
       Max Maischein &lt;<a href="mailto:corion@cpan.org">corion@cpan.org</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), Test::Builder,Test::Simple,Test::HTML::Lint.

perl v5.40.0                                       2024-08-17                           <u>Test::HTML::<a href="../man3pm/Content.3pm.html">Content</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>