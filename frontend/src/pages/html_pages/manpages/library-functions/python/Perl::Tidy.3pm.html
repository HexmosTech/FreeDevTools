<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perl::Tidy - Parses and beautifies perl source</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perltidy">perltidy_20250105-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Perl::Tidy - Parses and beautifies perl source

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Perl::Tidy;

           my $error_flag = Perl::Tidy::perltidy(
               source            =&gt; $source,
               destination       =&gt; $destination,
               stderr            =&gt; $stderr,
               argv              =&gt; $argv,
               perltidyrc        =&gt; $perltidyrc,
               logfile           =&gt; $logfile,
               errorfile         =&gt; $errorfile,
               teefile           =&gt; $teefile,
               debugfile         =&gt; $debugfile,
               formatter         =&gt; $formatter,    # callback object (see below)
               dump_options      =&gt; $dump_options,
               dump_options_type =&gt; $dump_options_type,
               prefilter         =&gt; $prefilter_coderef,
               postfilter        =&gt; $postfilter_coderef,
           );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module makes the functionality of the perltidy utility available to perl scripts.  Any or all of the
       input parameters may be omitted, in which case the @ARGV array will be used to provide input parameters
       as described in the <b><a href="../man1/perltidy.1.html">perltidy</a></b>(1) man page.

       For example, the perltidy script is basically just this:

           use Perl::Tidy;
           Perl::Tidy::perltidy();

       The call to <b>perltidy</b> returns a scalar <b>$error_flag</b> which is TRUE if an error caused premature termination,
       and FALSE if the process ran to normal completion.  Additional discuss of errors is contained below in
       the ERROR HANDLING section.

       The module accepts input and output streams by a variety of methods.  The following list of parameters
       may be any of the following: a filename, an ARRAY reference, a SCALAR reference, or an object with either
       a <b>getline</b> or <b>print</b> method, as appropriate.

           source            - the source of the script to be formatted
           destination       - the destination of the formatted output
           stderr            - standard error output
           perltidyrc        - the .perltidyrc file
           logfile           - the .LOG file stream, if any
           errorfile         - the .ERR file stream, if any
           dump_options      - ref to a hash to receive parameters (see below),
           dump_options_type - controls contents of dump_options
           dump_getopt_flags - ref to a hash to receive Getopt flags
           dump_options_category - ref to a hash giving category of options
           dump_abbreviations    - ref to a hash giving all abbreviations

       The following chart illustrates the logic used to decide how to treat a parameter.

          ref($param)  $param is assumed to be:
          -----------  ---------------------
          undef        a filename
          SCALAR       ref to string
          ARRAY        ref to array
          (other)      object with getline (if source) or print method

       If the parameter is an object, and the object has a <b>close</b> method, that close method will be called at the
       end of the stream.

       <b>source</b>
           If  the  <b>source</b> parameter is given, it defines the source of the input stream.  If an input stream is
           defined with the <b>source</b> parameter then no other source filenames may be specified in the @ARGV  array
           or <b>argv</b> parameter.

       <b>destination</b>
           If  the  <b>destination</b>  parameter  is  given,  it will be used to define the file or memory location to
           receive output of perltidy.

           <b>Important</b> <b>note</b> <b>if</b> <b>destination</b> <b>is</b> <b>a</b> <b>string</b> <b>or</b> <b>array</b> <b>reference</b>.  Perl strings of characters  which  are
           decoded  as  utf8 by Perl::Tidy can be returned in either of two possible states, decoded or encoded,
           and it is important that the calling program and Perl::Tidy are in agreement regarding the  state  to
           be  returned.   A  flag  <b>--encode-output-strings</b>,  or  simply  <b>-eos</b>,  was added in Perl::Tidy version
           20220217 for this purpose.

           •   Use <b>-eos</b> if Perl::Tidy should encode any string which it decodes.  This is  the  current  default
               because  it makes perltidy behave well as a filter, and is the correct setting for most programs.
               But do not use this setting if the calling program will  encode  the  data  too,  because  double
               encoding will corrupt data.

           •   Use  <b>-neos</b>  if  a  string  should  remain  decoded if it was decoded by Perl::Tidy.  This is only
               appropriate if the calling program will handle any needed encoding before outputting the  string.
               If needed, this flag can be added to the end of the <b>argv</b> parameter passed to Perl::Tidy.

           For                  some                  background                 information                 see
           &lt;https://github.com/perltidy/perltidy/blob/master/docs/eos_flag.md&gt;.

           This change in default behavior was made over a period of time as follows:

           •   For versions before 20220217 the <b>-eos</b> flag was not available and the behavior was  equivalent  to
               <b>-neos</b>.

           •   In version 20220217 the <b>-eos</b> flag was added but the default remained <b>-neos</b>.

           •   For versions after 20220217 the default was set to <b>-eos</b>.

       <b>stderr</b>
           The <b>stderr</b> parameter allows the calling program to redirect the stream that would otherwise go to the
           standard error output device to any of the stream types listed above.  This stream contains important
           warnings and errors related to the parameters passed to perltidy.

       <b>perltidyrc</b>
           If  the  <b>perltidyrc</b> file is given, it will be used instead of any <u>.perltidyrc</u> configuration file that
           would otherwise be used.

       <b>errorfile</b>
           The <b>errorfile</b> parameter allows the calling program to capture the stream that would otherwise  go  to
           either  a  .ERR  file.  This stream contains warnings or errors related to the contents of one source
           file or stream.

           The reason that this is different from the stderr stream is that when perltidy is called  to  process
           multiple files there will be up to one .ERR file created for each file and it would be very confusing
           if they were combined.

           However  if perltidy is called to process just a single perl script then it may be more convenient to
           combine the <b>errorfile</b> stream with the <b>stderr</b> stream.  This can be done by setting the <b>-se</b>  parameter,
           in which case this parameter is ignored.

       <b>logfile</b>
           The  <b>logfile</b>  parameter  allows  the  calling program to capture the log stream.  This stream is only
           created if requested with a <b>-g</b> parameter.  It contains detailed diagnostic information about a script
           which may be useful for debugging.

       <b>teefile</b>
           The <b>teefile</b> parameter allows the calling program to capture the tee  stream.   This  stream  is  only
           created  if  requested  with  one  of  the  'tee'  parameters,  a  <b>--tee-pod</b>  , <b>--tee-block-comments</b>,
           <b>--tee-side-commnts</b>, or <b>--tee-all-comments</b>.

       <b>debugfile</b>
           The <b>debugfile</b> parameter allows the calling program to capture the  stream  produced  by  the  <b>--DEBUG</b>
           parameter.  This parameter is mainly used for debugging perltidy itself.

       <b>argv</b>
           If  the  <b>argv</b> parameter is given, it will be used instead of the <b>@ARGV</b> array.  The <b>argv</b> parameter may
           be a string, a reference to a string, or a reference to an array.  If it is a string or reference  to
           a string, it will be parsed into an array of items just as if it were a command line string.

       <b>dump_options</b>
           If  the  <b>dump_options</b>  parameter  is  given,  it  must be the reference to a hash.  In this case, the
           parameters contained in any perltidyrc configuration file will be placed in this  hash  and  perltidy
           will return immediately.  This is equivalent to running perltidy with --dump-options, except that the
           parameters  are  returned in a hash rather than dumped to standard output.  Also, by default only the
           parameters in the perltidyrc file are returned, but this can be changed  (see  the  next  parameter).
           This  parameter  provides  a  convenient  method for external programs to read a perltidyrc file.  An
           example program using this feature, <u>perltidyrc_dump.pl</u>, is included in the distribution.

           Any combination of the <b>dump_</b> parameters may be used together.

       <b>dump_options_type</b>
           This parameter is a string which can be used to control the parameters placed in the  hash  reference
           supplied  by  <b>dump_options</b>.   The  possible values are 'perltidyrc' (default) and 'full'.  The 'full'
           parameter causes both the default options plus any options found in a perltidyrc file to be returned.

       <b>dump_getopt_flags</b>
           If the <b>dump_getopt_flags</b> parameter is given, it must be the reference to  a  hash.   This  hash  will
           receive  all  of  the parameters that perltidy understands and flags that are passed to Getopt::Long.
           This parameter may be used alone or with the <b>dump_options</b> flag.  Perltidy will exit immediately after
           filling this hash.  See the demo program <u>perltidyrc_dump.pl</u> for example usage.

       <b>dump_options_category</b>
           If the <b>dump_options_category</b> parameter is given, it must be the reference to a hash.  This hash  will
           receive  a  hash  with  keys  equal  to all long parameter names and values equal to the title of the
           corresponding section of the perltidy manual.  See the demo program  <u>perltidyrc_dump.pl</u>  for  example
           usage.

       <b>dump_abbreviations</b>
           If  the  <b>dump_abbreviations</b>  parameter  is given, it must be the reference to a hash.  This hash will
           receive all abbreviations used by Perl::Tidy.  See the demo program  <u>perltidyrc_dump.pl</u>  for  example
           usage.

       <b>prefilter</b>
           A  code  reference that will be applied to the source before tidying. It is expected to take the full
           content as a string in its input, and output the transformed content.

       <b>postfilter</b>
           A code reference that will be applied to the tidied result before outputting.  It is expected to take
           the full content as a string in its input, and output the transformed content.

           Note: A convenient way to check the function of your custom prefilter and postfilter code is  to  use
           the  --notidy  option, first with just the prefilter and then with both the prefilter and postfilter.
           See also the file <b>filter_example.pl</b> in the perltidy distribution.

</pre><h4><b>ERROR</b> <b>HANDLING</b></h4><pre>
       An exit value of 0, 1, or 2 is returned by perltidy to indicate the status of the result.

       A exit value of 0 indicates that perltidy ran to completion with no error messages.

       An exit value of 1 indicates that the process had to be terminated early  due  to  errors  in  the  input
       parameters.   This  can  happen  for example if a parameter is misspelled or given an invalid value.  The
       calling program should check for this flag because if it is set the destination stream will be  empty  or
       incomplete  and  should  be  ignored.  Error messages in the <b>stderr</b> stream will indicate the cause of any
       problem.

       An exit value of 2 indicates that perltidy ran to completion but there are warning messages in the <b>stderr</b>
       stream related to parameter errors or conflicts and/or warning messages in the <b>errorfile</b> stream  relating
       to possible syntax errors in the source code being tidied.

       In  the  event  of  a catastrophic error for which recovery is not possible <b>perltidy</b> terminates by making
       calls to <b>croak</b> or <b>confess</b> to help the programmer localize the problem.  These should normally only  occur
       during program development.

</pre><h4><b>NOTES</b> <b>ON</b> <b>FORMATTING</b> <b>PARAMETERS</b></h4><pre>
       Parameters  which  control formatting may be passed in several ways: in a <u>.perltidyrc</u> configuration file,
       in the <b>perltidyrc</b> parameter, and in the <b>argv</b> parameter.

       If the <b>-pbp</b> style is used it will typically be necessary to also specify a <b>-nst</b> flag.  This is  necessary
       to  turn  off  the  <b>-st</b>  flag contained in the <b>-pbp</b> parameter set which otherwise would direct the output
       stream to the standard output.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following example uses string references to hold the input and output code  and  error  streams,  and
       illustrates checking for errors.

         use Perl::Tidy;

         my $source_string = &lt;&lt;'EOT';
         my$error=Perl::Tidy::perltidy(argv=&gt;$argv,source=&gt;\$source_string,
           destination=&gt;\$dest_string,stderr=&gt;\$stderr_string,
         errorfile=&gt;\$errorfile_string,);
         EOT

         my $dest_string;
         my $stderr_string;
         my $errorfile_string;
         my $argv = "-npro";   # Ignore any .perltidyrc at this site
         $argv .= " -pbp";     # Format according to perl best practices
         $argv .= " -nst";     # Must turn off -st in case -pbp is specified
         $argv .= " -se";      # -se appends the errorfile to stderr
         ## $argv .= " --spell-check";  # uncomment to trigger an error

         print "&lt;&lt;RAW SOURCE&gt;&gt;\n$source_string\n";

         my $error = Perl::Tidy::perltidy(
             argv        =&gt; $argv,
             source      =&gt; \$source_string,
             destination =&gt; \$dest_string,
             stderr      =&gt; \$stderr_string,
             errorfile   =&gt; \$errorfile_string,  # ignored when -se flag is set
             ##phasers   =&gt; 'stun',              # uncomment to trigger an error
         );

         if ($error) {

             # serious error in input parameters, no tidied output
             print "&lt;&lt;STDERR&gt;&gt;\n$stderr_string\n";
             die "Exiting because of serious errors\n";
         }

         if ($dest_string)      { print "&lt;&lt;TIDIED SOURCE&gt;&gt;\n$dest_string\n" }
         if ($stderr_string)    { print "&lt;&lt;STDERR&gt;&gt;\n$stderr_string\n" }
         if ($errorfile_string) { print "&lt;&lt;.ERR file&gt;&gt;\n$errorfile_string\n" }

       Additional examples are given in examples section of the perltidy distribution.

</pre><h4><b>Using</b> <b>the</b> <b>formatter</b> <b>Callback</b> <b>Object</b></h4><pre>
       The  <b>formatter</b>  parameter  is  an  optional  callback  object which allows the calling program to receive
       tokenized lines directly from perltidy for further specialized processing.  When this parameter is  used,
       the  two  formatting  options  which  are  built into perltidy (beautification or html) are ignored.  The
       following diagram illustrates the logical flow:

                           |-- (normal route)   -&gt; code beautification
         caller-&gt;perltidy-&gt;|-- (-html flag )    -&gt; create html
                           |-- (formatter given)-&gt; callback to write_line

       This can be useful for processing perl scripts in some way.  The parameter  $formatter  in  the  perltidy
       call,

               formatter   =&gt; $formatter,

       is  an  object  created  by the caller with a "write_line" method which will accept and process tokenized
       lines, one line per call.  Here is a simple example of  a  "write_line"  which  merely  prints  the  line
       number, the line type (as determined by perltidy), and the text of the line:

        sub write_line {

            # This is called from perltidy line-by-line
            my $self              = shift;
            my $line_of_tokens    = shift;
            my $line_type         = $line_of_tokens-&gt;{_line_type};
            my $input_line_number = $line_of_tokens-&gt;{_line_number};
            my $input_line        = $line_of_tokens-&gt;{_line_text};
            print "$input_line_number:$line_type:$input_line";
        }

       The  complete program, <b>perllinetype</b>, is contained in the examples section of the source distribution.  As
       this example shows, the callback method receives a parameter <b>$line_of_tokens</b>, which is a reference  to  a
       hash of other useful information.  This example uses these hash entries:

        $line_of_tokens-&gt;{_line_number} - the line number (1,2,...)
        $line_of_tokens-&gt;{_line_text}   - the text of the line
        $line_of_tokens-&gt;{_line_type}   - the type of the line, one of:

           SYSTEM         - system-specific code before hash-bang line
           CODE           - line of perl code (including comments)
           POD_START      - line starting pod, such as '=head'
           POD            - pod documentation text
           POD_END        - last line of pod section, '=cut'
           HERE           - text of here-document
           HERE_END       - last line of here-doc (target word)
           FORMAT         - format section
           FORMAT_END     - last line of format section, '.'
           DATA_START     - __DATA__ line
           DATA           - unidentified text following __DATA__
           END_START      - __END__ line
           END            - unidentified text following __END__
           ERROR          - we are in big trouble, probably not a perl script

       Most  applications  will  be  only  interested in lines of type <b>CODE</b>.  For another example, let's write a
       program which checks for one of the so-called <u>naughty</u> <u>matching</u> <u>variables</u> "&amp;`", $&amp;, and  "$'",  which  can
       slow down processing.  Here is a <b>write_line</b>, from the example program <b>find_naughty.pl</b>, which does that:

        sub write_line {

            # This is called back from perltidy line-by-line
            # We're looking for $`, $&amp;, and $'
            my ( $self, $line_of_tokens ) = @_;

            # pull out some stuff we might need
            my $line_type         = $line_of_tokens-&gt;{_line_type};
            my $input_line_number = $line_of_tokens-&gt;{_line_number};
            my $input_line        = $line_of_tokens-&gt;{_line_text};
            my $rtoken_type       = $line_of_tokens-&gt;{_rtoken_type};
            my $rtokens           = $line_of_tokens-&gt;{_rtokens};
            chomp $input_line;

            # skip comments, pod, etc
            return if ( $line_type ne 'CODE' );

            # loop over tokens looking for $`, $&amp;, and $'
            for ( my $j = 0 ; $j &lt; @$rtoken_type ; $j++ ) {

                # we only want to examine token types 'i' (identifier)
                next unless $$rtoken_type[$j] eq 'i';

                # pull out the actual token text
                my $token = $$rtokens[$j];

                # and check it
                if ( $token =~ /^\$[\`\&amp;\']$/ ) {
                    print STDERR
                      "$input_line_number: $token\n";
                }
            }
        }

       This example pulls out these tokenization variables from the $line_of_tokens hash reference:

            $rtoken_type = $line_of_tokens-&gt;{_rtoken_type};
            $rtokens     = $line_of_tokens-&gt;{_rtokens};

       The  variable $rtoken_type is a reference to an array of token type codes, and $rtokens is a reference to
       a corresponding array of token text.  These are obviously only defined for lines of type <b>CODE</b>.   Perltidy
       classifies  tokens  into  types,  and has a brief code for each type.  You can get a complete list at any
       time by running perltidy from the command line with

            perltidy --dump-token-types

       In the present example, we are only looking for tokens of type <b>i</b> (identifiers), so  the  for  loop  skips
       past  all other types.  When an identifier is found, its actual text is checked to see if it is one being
       sought.  If so, the above write_line prints the token and its line number.

       The <b>examples</b> section of the source distribution has some examples of programs  which  use  the  <b>formatter</b>
       option.

       For  help  with  perltidy's  peculiar  way of breaking lines into tokens, you might run, from the command
       line,

        perltidy -D filename

       where <u>filename</u> is a short script of interest.  This will produce <u>filename.DEBUG</u> with interleaved lines of
       text and their token types.  The <b>-D</b> flag has been in perltidy from the beginning for  this  purpose.   If
       you want to see the code which creates this file, it is "sub Perl::Tidy::Debugger::write_debug_entry"

</pre><h4><b>EXPORT</b></h4><pre>
         &amp;perltidy

</pre><h4><b>INSTALLATION</b></h4><pre>
       The  module  'Perl::Tidy' comes with a binary 'perltidy' which is installed when the module is installed.
       The module name is case-sensitive.  For example, the basic command for installing with  cpanm  is  'cpanm
       Perl::Tidy'.

</pre><h4><b>VERSION</b></h4><pre>
       This man page documents Perl::Tidy version 20250105

</pre><h4><b>LICENSE</b></h4><pre>
       This  package  is  free  software;  you  can redistribute it and/or modify it under the terms of the "GNU
       General Public License".

       Please refer to the file "COPYING" for details.

</pre><h4><b>BUG</b> <b>REPORTS</b></h4><pre>
       The source code repository is at &lt;https://github.com/perltidy/perltidy&gt;.

       To report a new bug or problem, use the "issues" link on this page.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The  <b><a href="../man1/perltidy.1.html">perltidy</a></b>(1)  man  page  describes  all  of  the  features  of  perltidy.   It  can   be   found   at
       <a href="http://perltidy.sourceforge.net">http://perltidy.sourceforge.net</a>.

perl v5.40.0                                       2025-01-05                                    <u>Perl::<a href="../man3pm/Tidy.3pm.html">Tidy</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>