<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Printer - colored & full-featured pretty print of Perl data structures and objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-printer-perl">libdata-printer-perl_1.002001-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Printer - colored &amp; full-featured pretty print of Perl data structures and objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Want to see what's inside a variable in a complete, colored and human-friendly way?

           use DDP;  # same as 'use Data::Printer'

           p $some_var;
           p $some_var, as =&gt; "This label will be printed too!";

           # no need to use '\' before arrays or hashes!
           p @array;
           p %hash;

           # printing anonymous array references:
           p [ $one, $two, $three ]-&gt;@*;    # perl 5.24 or later!
           p @{[ $one, $two, $three ]};     # same, older perls
           &amp;p( [ $one, $two, $three ] );    # same, older perls

           # printing anonymous hash references:
           p { foo =&gt; $foo, bar =&gt; $bar }-&gt;%*;   # perl 5.24 or later!
           p %{{ foo =&gt; $foo, bar =&gt; $bar }};    # same, older perls
           &amp;p( { foo =&gt; $foo, bar =&gt; $bar } );   # same, older perls

       The snippets above will print the contents of the chosen variables to STDERR on your terminal, with
       colors and a few extra features to help you debug your code.

       If you wish to grab the output and handle it yourself, call np():

           my $dump = np $var;

           die "this is what happened: " . np %data;

       The np() function is the same as p() but will return the string containing the dump. By default it has no
       colors, but you can change that easily too.

       That's pretty much it :)

       Data::Printer is fully customizable, even on a per-module basis! Once you figure out your own
       preferences, create a .dataprinter configuration file for yourself (or one for each project) and
       Data::Printer will automatically use it!

</pre><h4><b>FEATURES</b></h4><pre>
       Here's what Data::Printer offers Perl developers, out of the box:

       •   Variable dumps designed for <b>easy</b> <b>parsing</b> <b>by</b> <b>the</b> <b>human</b> <b>brain</b>, not a machine.

       •   <b>Highly</b>  <b>customizable</b>,  from  indentation  size  to depth level.  You can even rename the exported p()
           function!

       •   <b>Beautiful</b> <b>(and</b> <b>customizable)</b> <b>colors</b> to highlight variable dumps and make issues stand-out quickly  on
           your  console. Comes bundled with several themes for you to pick that work on light and dark terminal
           backgrounds, and you can create your own as well.

       •   <b>Filters</b> <b>for</b> <b>specific</b> <b>data</b> <b>structures</b> <b>and</b> <b>objects</b>  to  make  debugging  much,  much  easier.  Includes
           filters  for  many  popular  classes  from  CPAN  like JSON::*, URI, HTTP::*, LWP, Digest::*, DBI and
           DBIx::Class.  printing what really matters to developers debugging code. It also lets you create your
           own custom filters easily.

       •   Lets you <b>inspect</b> <b>information</b> <b>that's</b> <b>otherwise</b> <b>difficult</b>  <b>to</b>  <b>find/debug</b>  in  Perl  5,  like  circular
           references,  reference counting (refcount), weak/read-only information, overloaded operators, tainted
           data, ties, dual vars, even estimated data size - all to help you spot issues  with  your  data  like
           leaks  without  having  to  know  a lot about internal data structures or install hardcore tools like
           Devel::Peek and Devel::Gladiator.

       •   <b>Full</b> <b>support</b> <b>for</b> <b>dumping</b> <b>perl</b> <b>5.38</b> <b>native</b> <b>classes</b>.

       •   keep your custom settings on a .dataprinter file that  allows  <b>different</b>  <b>options</b>  <b>per</b>  <b>module</b>  being
           analyzed! You can have <b>one</b> <b>".dataprinter"</b> <b>file</b> <b>per</b> <b>project</b>, or default to one in your home directory.
           You may also create a custom profile class with your preferences and filters and upload it to CPAN.

       •   <b>output</b>  <b>to</b> <b>many</b> <b>different</b> <b>targets</b> like files, variables or open handles (defaults to STDERR). You can
           send your dumps to the screen or anywhere else, and customize this setting on a per-project  or  even
           per-module  basis,  like  print everything from Some::Module to a debug.log file with extra info, and
           everything else to STDERR.

       •   <b>Easy</b> <b>to</b> <b>learn,</b> <b>easy</b> <b>to</b> <b>master</b>. Seriously, the synopsis above  and  the  customization  section  below
           cover about 90% of all use cases.

       •   Works  on  <b>Perl</b>  <b>5.8</b>  <b>and</b>  <b>later</b>.  Because  you  can't control where you debug, we try our best to be
           compatible with all versions of Perl 5, from the oldest available to the bleeding edge.

       •   Best of all? All that with <b>No</b> <b>non-core</b> <b>dependencies</b>, Zero. Nada. So don't worry  about  adding  extra
           weight to your project, as Data::Printer can be easily added/removed.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  ever-popular  Data::Dumper is a fantastic tool, meant to stringify data structures in a way they are
       suitable for being "eval"'ed back in.  The thing is, a lot of people keep using  it  (and  similar  ones,
       like  Data::Dump)  to print data structures and objects on screen for inspection and debugging, and while
       you <u>can</u> use those modules for that, it doesn't mean you <u>should</u>.

       This is where Data::Printer comes in. It is meant to do one thing and one thing only:

       <u>format</u> <u>Perl</u> <u>variables</u> <u>and</u> <u>objects</u> <u>to</u> <u>be</u> <u>inspected</u> <u>by</u> <u>a</u> <u>human</u>

       If you want to serialize/store/restore Perl data structures, this module will NOT help you. Try Storable,
       Data::Dumper, JSON, or whatever. CPAN is full of such solutions!

       Whenever you type "use Data::Printer" or "use DDP", we export two functions to your namespace:

   <b>p()</b>
       This function pretty-prints the contents of whatever variable to STDERR (by default), and will use colors
       by default if your terminal supports it.

           p @some_array;
           p %some_hash;
           p $scalar_or_ref;

       Note that anonymous structures will only work if you postderef them:

           p [$foo, $bar, $baz]-&gt;@*;

       you may also deref it manually:

           p %{{ foo =&gt; $foo }};

       or prefix p() with "&amp;":

           &amp;p( [$foo, $bar, $baz] );    # &amp; (note mandatory parenthesis)

       You can pass custom options that will work only on that particular call:

           p @var, as =&gt; "some label", colored =&gt; 0;
           p %var, show_memsize =&gt; 1;

       By default, p() prints to STDERR and returns the same variable being dumped. This lets you  quickly  wrap
       variables with p() without worrying about changing return values. It means that if you change this:

           sub foo { my $x = shift + 13; $x }

       to this:

           sub foo { my $x = shift + 13; p($x) }

       The  function  will  still  return $x after printing the contents. This form of handling data even allows
       method chaining, so if you want to inspect what's going on in the middle of this:

           $object-&gt;foo-&gt;bar-&gt;baz;

       You can just add "DDP::p" anywhere:

           $object-&gt;foo-&gt;DDP::p-&gt;bar-&gt;baz; # what happens to $object after -&gt;foo?

       Check out the customization quick reference section below for all available options,  including  changing
       the return type, output target and a lot more.

   <b>np()</b>
       The  np() function behaves exactly like p() except it always returns the string containing the dump (thus
       ignoring any setting regarding dump mode or destination), and contains no colors by default. In fact, the
       only way to force a colored np() is to pass "colored =&gt; 1" as an argument to each call. It  is  meant  to
       provide  an  easy way to fetch the dump and send it to some unsupported target, or appended to some other
       text (like part of a log message).

</pre><h4><b>CUSTOMIZATION</b></h4><pre>
       There are 3 possible ways to customize Data::Printer:

       1. <b>[RECOMMENDED]</b> Creating a ".dataprinter" file either on your home  directory  or  your  project's  base
       directory, or both,  or wherever you set the "DATAPRINTERRC" environment variable to.

       2.  Setting custom properties on module load. This will override any setting from your config file on the
       namespace (package/module) it was called:

           use DDP max_depth =&gt; 2, deparse =&gt; 1;

       3. Setting custom properties on the actual call to p() or np(). This overrides all other settings:

           p $var, show_tainted =&gt; 1, indent =&gt; 2;

   <b>The</b> <b>.dataprinter</b> <b>configuration</b> <b>file</b>
       The most powerful way to customize Data::Printer is to have a ".dataprinter" file in your home  directory
       or your project's root directory. The format is super simple and can be understood in the example below:

           # global settings (note that only full line comments are accepted)
           max_depth       = 1
           theme           = Monokai
           class.stringify = 0

           # use quotes if you want spaces to be significant:
           hash_separator  = " =&gt; "

           # You can set rules that apply only to a specific
           # caller module (in this case, MyApp::Some::Module):
           [MyApp::Some::Module]
           max_depth    = 2
           class.expand = 0
           escape_chars = nonlatin1

           [MyApp::Other::Module]
           multiline = 0
           output    = /var/log/myapp/debug.data

           # use 'quiet' to silence all output from p() and np()
           # called from the specified package.
           [MyApp::Yet::Another]
           quiet = 1

       Note  that  if  you  set  custom properties as arguments to p() or np(), you should group suboptions as a
       hashref. So while the ".dataprinter" file has ""class.expand = 0"" and ""class.inherited  =  none"",  the
       equivalent code is ""class =&gt; { expand =&gt; 0, inherited =&gt; 'none' }"".

       <u>live</u> <u>updating</u> <u>your</u> <u>.dataprinter</u> <u>without</u> <u>restarts</u>

       Data::Printer  1.1  introduces  a  new 'live_update' flag that can be set to a positive integer to enable
       live updates. When this mode is on, Data::Printer will check if the ".dataprinter" file has been  updated
       and,  if  so, it will reload it. This way you can toggle features on and off and control output verbosity
       directly from your ".dataprinter" file without needing to change or restart running code.

   <b>Properties</b> <b>Quick</b> <b>Reference</b>
       Below  are  (almost)  all  available  properties  and  their  (hopefully  sane)   default   values.   See
       Data::Printer::Object for further information on each of them:

           # scalar options
           show_tainted      = 1
           show_unicode      = 1
           show_lvalue       = 1
           print_escapes     = 0
           scalar_quotes     = "
           escape_chars      = none
           string_max        = 4096
           string_preserve   = begin
           string_overflow   = '(...skipping __SKIPPED__ chars...)'
           unicode_charnames = 0

           # array options
           array_max      = 100
           array_preserve = begin
           array_overflow = '(...skipping __SKIPPED__ items...)'
           index          = 1

           # hash options
           hash_max       = 100
           hash_preserve  = begin
           hash_overflow  = '(...skipping __SKIPPED__ keys...)'
           hash_separator = '   '
           align_hash     = 1
           sort_keys      = 1
           quote_keys     = auto

           # general options
           name           = var
           return_value   = pass
           output         = stderr
           use_prototypes = 1
           indent         = 4
           show_readonly  = 1
           show_tied      = 1
           show_dualvar   = lax
           show_weak      = 1
           show_refcount  = 0
           show_memsize   = 0
           memsize_unit   = auto
           separator      = ,
           end_separator  = 0
           caller_info    = 0
           caller_message = 'Printing in line __LINE__ of __FILENAME__'
           max_depth      = 0
           deparse        = 0
           alias          = p
           warnings       = 1

           # colorization (see Colors &amp; Themes below)
           colored = auto
           theme   = Material

           # object output
           class_method             = _data_printer
           class.parents            = 1
           class.linear_isa         = auto
           class.universal          = 1
           class.expand             = 1
           class.stringify          = 1
           class.show_reftype       = 0
           class.show_overloads     = 1
           class.show_methods       = all
           class.sort_methods       = 1
           class.inherited          = none
           class.format_inheritance = string
           class.parent_filters     = 1
           class.internals          = 1

       <u>Settings'</u> <u>shortcuts</u>

       •   <b>as</b> - prints a string before the dump. So:

               p $some_var, as =&gt; 'here!';

           is a shortcut to:

               p $some_var, caller_info =&gt; 1, caller_message =&gt; 'here!';

       •   <b>multiline</b> - lets you create shorter dumps. By setting it to 0, we use a single space as linebreak and
           disable  the  array  index.  Setting  it  to 1 (the default) goes back to using "\n" as linebreak and
           restore whatever array index you had originally.

       •   <b>fulldump</b> - when set to 1, disables all max string/hash/array values. Use this  to  generate  complete
           (full) dumps of all your content, which is trimmed by default.

       •   <b>quiet</b>  -  when  set  to  1, disables all data parsing and returns as quickly as possible. Use this to
           disable all output from p() and np() inside a particular package, either from the 'use' call or  from
           .dataprinter.  (introduced in version 1.1)

   <b>Colors</b> <b>&amp;</b> <b>Themes</b>
       Data::Printer  lets  you  set  custom colors for pretty much every part of the content being printed. For
       example, if you want numbers to be shown in bright green, just put  "colors.number  =  #00ff00"  on  your
       configuration file.

       See  Data::Printer::Theme  for  the full list of labels, ways to represent and customize colors, and even
       how to group them in your own custom theme.

       The colorization is set by the "colored" property. It can  be  set  to  0  (never  colorize),  1  (always
       colorize)  or  'auto' (the default), which will colorize p() only when there is no "ANSI_COLORS_DISABLED"
       environment variable, the output is going to the terminal (STDOUT or STDERR) and your  terminal  actually
       supports colors.

   <b>Profiles</b>
       You  may  bundle your settings and filters into a profile module.  It works like a configuration file but
       gives you the power and flexibility to use Perl code to find out what to print and how to print. It  also
       lets  you  use  CPAN  to  store  your  preferred settings and install them into your projects just like a
       regular dependency.

           use DDP profile =&gt; 'ProfileName';

       See Data::Printer::Profile for all the ways to load a profile, a list of available profiles  and  how  to
       make one yourself.

   <b>Filters</b>
       Data::Printer  works  by passing your variable to a different set of filters, depending on whether it's a
       scalar, a hash, an array, an object, etc. It comes bundled with filters for all native data types (always
       enabled, but overwritable), including a generic object filter  that  pretty-prints  regular  and  Moo(se)
       objects and is even aware of Role::Tiny.

       Data::Printer  also  comes  with  filter bundles that can be quickly activated to make it easier to debug
       binary data and many popular CPAN modules that handle date and time, databases (yes,  even  DBIx::Class),
       message digests like MD5 and SHA1, and JSON and Web content like HTTP requests and responses.

       So  much  so  we recommend everyone to activate all bundled filters by putting the following line on your
       ".dataprinter" file:

           filters = ContentType, DateTime, DB, Digest, Web

       Creating your custom filters is very easy, and you're encouraged to upload them to CPAN. There  are  many
       options  available  under  the "Data::Printer::Filter::*" namespace. Check Data::Printer::Filter for more
       information!

   <b>Making</b> <b>your</b> <b>classes</b> <b>DDP-aware</b> <b>(without</b> <b>adding</b> <b>any</b> <b>dependencies!)</b>
       The default object filter will first check if the class implements a  sub  called  '_data_printer()'  (or
       whatever  you set the "class_method" option to in your settings). If so, Data::Printer will use it to get
       the string to print instead of making a regular class dump.

       This means you could have the following in one of your classes:

         sub _data_printer {
             my ($self, $ddp) = @_;
             return 'Hey, no peeking! But foo contains ' . $self-&gt;foo;
         }

       Notice that <b>you</b> <b>can</b> <b>do</b> <b>this</b> <b>without</b> <b>adding</b> <b>Data::Printer</b> <b>as</b> <b>a</b> <b>dependency</b> to your project! Just write your
       sub and it will be called with  the  object  to  be  printed  and  a  $ddp  object  ready  for  you.  See
       Data::Printer::Object for how to use it to pretty-print your data.

       Finally,  if  your object implements string overload or provides a method called "to_string", "as_string"
       or "stringify", Data::Printer will use it. To disable this behaviour, set "class.stringify = 0"  on  your
       ".dataprinter" file, or call p() with "class =&gt; { stringify =&gt; 0 }".

       Loading a filter for that particular class will of course override these settings.

</pre><h4><b>CAVEATS</b></h4><pre>
       You can't pass more than one variable at a time.

          p $foo, $bar;       # wrong
          p $foo; p $bar;     # right

       You can't use it in variable declarations (it will most likely not do what you want):

           p my @array = qw(a b c d);          # wrong
           my @array = qw(a b c d); p @array;  # right

       If you pass a nonexistent key/index to DDP using prototypes, they will trigger autovivification:

           use DDP;
           my %foo;
           p $foo{bar}; # undef, but will create the 'bar' key (with undef)

           my @x;
           p $x[5]; # undef, but will initialize the array with 5 elements (all undef)

       Slices  (both array and hash) must be coerced into actual arrays (or hashes) to properly shown. So if you
       want to print a slice, instead of doing something like this:

           p @somevar[1..10]; # WRONG! DON'T DO THIS!

       try one of those:

           my @x = @somevar[1..10]; p @x;   # works!
           p [ @somevar[1..0] ]-&gt;@*;        # also works!
           p @{[@somevar[1..0]]};           # this works too!!

       Finally, as mentioned before, you cannot pass anonymous references on the default mode of "use_prototypes
       = 1":

           p { foo =&gt; 1 };       # wrong!
           p %{{ foo =&gt; 1 }};    # right
           p { foo =&gt; 1 }-&gt;%*;   # right on perl 5.24+
           &amp;p( { foo =&gt; 1 } );   # right, but requires the parenthesis
           sub pp { p @_ };      # wrapping it also lets you use anonymous data.

           use DDP use_prototypes =&gt; 0;
           p { foo =&gt; 1 };   # works, but now p(@foo) will fail, you must always pass a ref,
                             # e.g. p(\@foo)

</pre><h4><b>BACKWARDS</b> <b>INCOMPATIBLE</b> <b>CHANGES</b></h4><pre>
       While we make a genuine effort not to break anything on new releases, sometimes we  do.  To  make  things
       easier  for people migrating their code, we have aggregated here a list of all incompatible changes since
       ever:

       •   1.00 - some defaults changed!  Because we added a bunch of new features (including color themes), you
           may notice some difference on the default output of Data::Printer. Hopefully it's for the best.

       •   1.00 - new ".dataprinter" file format.  <u>This</u> <u>should</u> <u>only</u> <u>affect</u> <u>you</u>  <u>if</u>  <u>you</u>  <u>have</u>  <u>a</u>  <u>".dataprinter"</u>
           <u>file.</u>   The  change was required to avoid calling "eval" on potentially tainted/unknown code. It also
           provided a much cleaner interface.

       •   1.00 - new way of creating external filters.  <u>This</u> <u>only</u> <u>affects</u> <u>you</u> <u>if</u>  <u>you</u>  <u>write</u>  <u>or</u>  <u>use</u>  <u>external</u>
           <u>filters.</u>   Previously,  the  sub  in  your  "filters" call would get the reference to be parsed and a
           properties hash. The properties  hash  has  been  replaced  with  a  Data::Printer::Object  instance,
           providing much more power and flexibility.  Because of that, the filter call does not export p()/np()
           anymore, replaced by methods in Data::Printer::Object.

       •   1.00  -  new  way to call filters.  <u>This</u> <u>affects</u> <u>you</u> <u>if</u> <u>you</u> <u>load</u> <u>your</u> <u>own</u> <u>inline</u> <u>filters</u>.  The fix is
           quick and Data::Printer will generate a warning explaining how to do it. Basically, "filters =&gt; { ...
           }" became "filters =&gt; [{ ... }]" and you must replace "-external =&gt; [1,2]" with "filters =&gt; [1,  2]",
           or  "filters  =&gt;  [1, 2, {...}]" if you also have inline filters. This allowed us much more power and
           flexibility with filters, and hopefully also makes things clearer.

       •   0.36 - p()'s default return value changed from 'dump' to 'pass'.  This was a very important change to
           ensure chained calls and to prevent weird side-effects when p() is the last statement in a sub.  Read
           the full discussion &lt;https://github.com/garu/Data-Printer/issues/16&gt;.

       Any undocumented change was probably unintended. If you bump into one, please file an issue on Github!

</pre><h4><b>TIPS</b> <b>&amp;</b> <b>TRICKS</b></h4><pre>
   <b>Using</b> <b>p()</b> <b>in</b> <b>some/all</b> <b>of</b> <b>your</b> <b>loaded</b> <b>modules</b>
       <u>(contributed</u> <u>by</u> <u>Matt</u> <u>S.</u> <u>Trout</u> <u>(mst))</u>

       While debugging your software, you may want to use Data::Printer in some or all loaded  modules  and  not
       bother  having  to load it in each and every one of them. To do this, in any module loaded by "myapp.pl",
       simply write:

         ::p @myvar;  # note the '::' in front of p()

       Then call your program like:

         perl -MDDP myapp.pl

       This also has the advantage that if you leave one p() call in by accident, it will trigger a compile-time
       failure without the -M, making it easier to spot :)

       If you really want to have p() imported into your loaded modules, use the next tip instead.

   <b>Adding</b> <b>p()</b> <b>to</b> <b>all</b> <b>your</b> <b>loaded</b> <b>modules</b>
       <u>(contributed</u> <u>by</u> <u>Árpád</u> <u>Szász)</u>

       If you wish to automatically add Data::Printer's p() function to every loaded module in you app, you  can
       do something like this to your main program:

           BEGIN {
               {
                   no strict 'refs';
                   require Data::Printer;
                   my $alias = 'p';
                   foreach my $package ( keys %main:: ) {
                       if ( $package =~ m/::$/ ) {
                           *{ $package . $alias } = \&amp;Data::Printer::p;
                       }
                   }
               }
           }

       <b>WARNING</b>  This will override all locally defined subroutines/methods that are named "p", if they exist, in
       every loaded module. If you already have a subroutine named 'p()', be sure to change $alias to  something
       custom.

       If you rather avoid namespace manipulation altogether, use the previous tip instead.

   <b>Using</b> <b>Data::Printer</b> <b>from</b> <b>the</b> <b>Perl</b> <b>debugger</b>
       <u>(contributed</u> <u>by</u> <u>Árpád</u> <u>Szász</u> <u>and</u> <u>Marcel</u> <u>Grünauer</u> <u>(hanekomu))</u>

       With  DB::Pluggable,  you  can  easily  set  the  perl  debugger  to  use Data::Printer to print variable
       information, replacing the debugger's standard p() function. All you have to do is  add  these  lines  to
       your ".perldb" file:

         use DB::Pluggable;
         DB::Pluggable-&gt;run_with_config( \'[DataPrinter]' );  # note the '\'

       Then call the perl debugger as you normally would:

         perl -d myapp.pl

       Now Data::Printer's p() command will be used instead of the debugger's!

       See  perldebug  for  more  information  on  how  to  use  the  perl debugger, and DB::Pluggable for extra
       functionality and other plugins.

       If you can't or don't want to use DB::Pluggable, or simply want to keep the debugger's p()  function  and
       add an extended version using Data::Printer (let's call it px() for instance), you can add these lines to
       your ".perldb" file instead:

           $DB::alias{px} = 's/px/DB::px/';
           sub px {
               my $expr = shift;
               require Data::Printer;
               print Data::Printer::p($expr);
           }

       Now,  inside  the  Perl  debugger,  you  can  pass  as  reference  to "px" expressions to be dumped using
       Data::Printer.

   <b>Using</b> <b>Data::Printer</b> <b>in</b> <b>a</b> <b>perl</b> <b>shell</b> <b>(REPL)</b>
       Some people really enjoy using a REPL shell to quickly try Perl code. One of the most  popular  ones  out
       there are Reply and Devel::REPL. If you use them, now you can also see its output with Data::Printer!

       •   <b>Reply</b>

       Just  install  Reply::Plugin::DataPrinter  and  add  a line with "[DataPrinter]" to your ".replyrc" file.
       That's it! Next time you run the 'reply' REPL, Data::Printer will be used to dump variables!

       •   <b>Devel::REPL</b>

       Just install Devel::REPL::Plugin::DataPrinter and add the following line to your re.pl configuration file
       (usually ".re.pl/repl.rc" in your home dir):

         load_plugin('DataPrinter');

       The next time you run "re.pl", it should dump all your REPL using Data::Printer!

   <b>Easily</b> <b>rendering</b> <b>Data::Printer's</b> <b>output</b> <b>as</b> <b>HTML</b>
       To turn Data::Printer's output into HTML, you can do something like:

         use HTML::FromANSI;
         use Data::Printer;

         my $html_output = ansi2html( np($object, colored =&gt; 1) );

       In the example above, the $html_output variable contains the HTML escaped output of  p($object),  so  you
       can print it for later inspection or render it (if it's a web app).

   <b>Using</b> <b>Data::Printer</b> <b>with</b> <b>Template</b> <b>Toolkit</b>
       <u>(contributed</u> <u>by</u> <u>Stephen</u> <u>Thirlwall</u> <u>(sdt))</u>

       If  you  use  Template  Toolkit  and  want  to  dump  your  variables  using  Data::Printer,  install the
       Template::Plugin::DataPrinter module and load it in your template:

          [% USE DataPrinter %]

       The provided methods match those of "Template::Plugin::Dumper":

          ansi-colored dump of the data structure in "myvar":
          [% DataPrinter.dump( myvar ) %]

          html-formatted, colored dump of the same data structure:
          [% DataPrinter.dump_html( myvar ) %]

       The module allows several customization  options,  even  letting  you  load  it  as  a  complete  drop-in
       replacement for Template::Plugin::Dumper so you don't even have to change your previous templates!

   <b>Migrating</b> <b>from</b> <b>Data::Dumper</b> <b>to</b> <b>Data::Printer</b>
       If you are porting your code to use Data::Printer instead of Data::Dumper, you could replace:

         use Data::Dumper;

       with something like:

         use Data::Printer;
         sub Dumper { np @_, colored =&gt; 1 }

       this sub will accept multiple variables just like Data::Dumper.

   <b>Unified</b> <b>interface</b> <b>for</b> <b>Data::Printer</b> <b>and</b> <b>other</b> <b>debug</b> <b>formatters</b>
       <u>(contributed</u> <u>by</u> <u>Kevin</u> <u>McGrath</u> <u>(catlgrep))</u>

       If you want a really unified approach to easily flip between debugging outputs, use Any::Renderer and its
       plugins, like Any::Renderer::Data::Printer.

   <b>Printing</b> <b>stack</b> <b>traces</b> <b>with</b> <b>arguments</b> <b>expanded</b> <b>using</b> <b>Data::Printer</b>
       <u>(contributed</u> <u>by</u> <u>Sergey</u> <u>Aleynikov</u> <u>(randir))</u>

       There  are  times where viewing the current state of a variable is not enough, and you want/need to see a
       full stack trace of a function call.

       The Devel::PrettyTrace module uses Data::Printer to provide you just that. It  exports  a  bt()  function
       that  pretty-prints  detailed  information  on  each function in your stack, making it easier to spot any
       issues!

   <b>Troubleshooting</b> <b>apps</b> <b>in</b> <b>real</b> <b>time</b> <b>without</b> <b>changing</b> <b>a</b> <b>single</b> <b>line</b> <b>of</b> <b>your</b> <b>code</b>
       <u>(contributed</u> <u>by</u> <u>Marcel</u> <u>Grünauer</u> <u>(hanekomu))</u>

       dip is a  dynamic  instrumentation  framework  for  troubleshooting  Perl  programs,  similar  to  DTrace
       &lt;<a href="http://opensolaris.org/os/community/dtrace/">http://opensolaris.org/os/community/dtrace/</a>&gt;.   In  a nutshell, "dip" lets you create probes for certain
       conditions in your application that, once met, will perform a specific  action.  Since  it  uses  Aspect-
       oriented programming, it's very lightweight and you only pay for what you use.

       "dip"  can  be  very  useful since it allows you to debug your software without changing a single line of
       your original code. And Data::Printer comes bundled with it, so you can use the p() function to view your
       data structures too!

          # Print a stack trace every time the name is changed,
          # except when reading from the database.
          dip -e 'before { print longmess(np $_-&gt;{args}[1], colored =&gt; 1)
          if $_-&gt;{args}[1] } call "MyObj::name" &amp; !cflow("MyObj::read")' myapp.pl

       You can check dip's own documentation for more information and options.

   <b>Sample</b> <b>output</b> <b>for</b> <b>color</b> <b>fine-tuning</b>
       <u>(contributed</u> <u>by</u> <u>Yanick</u> <u>Champoux</u> <u>(yanick))</u>

       The "examples/try_me.pl" file included in this distribution  has  a  sample  dump  with  a  complex  data
       structure to let you quickly test color schemes.

</pre><h4><b>VERSIONING</b> <b>AND</b> <b>UPDATES</b></h4><pre>
       As  of  1.0.0  this  module  complies  with  "Major.Minor.Revision"  versioning  scheme (SemVer), meaning
       backwards incompatible changes will trigger a new major number, new features without any breaking changes
       trigger a new minor number, and simple patches trigger a revision number.

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Many thanks to everyone who helped design and develop this module with patches, bug  reports,  wishlists,
       comments and tests. They are (alphabetically):

       Adam  Rosenstein,  Alexandr  Ciornii  (chorny),  Alexander  Hartmaier (abraxxa), Allan Whiteford, Anatoly
       (Snelius30), Andre Klärner, Andreas König (andk), Andy Bach, Anthony DeRobertis, Árpád Szász,  Athanasios
       Douitsis  (aduitsis), Baldur Kristinsson, Benct Philip Jonsson (bpj), brian d foy, Chad Granum (exodist),
       Chris Prather (perigrin), Curtis Poe (Ovid), David D Lowe (Flimm), David E. Condon (hhg7),  David  Golden
       (xdg),  David  Precious  (bigpresh), David Raab, David E. Wheeler (theory), Damien Krotkine (dams), Denis
       Howe, dirk, Dotan Dimet, Eden Cardim (edenc),  Elliot  Shank  (elliotjs),  Elvin  Aslanov,  Eugen  Konkov
       (KES777),  Fernando  Corrêa  (SmokeMachine),  Fitz  Elliott, Florian Schlichting (fschlich), Frew Schmidt
       (frew), GianniGi, Graham Knop (haarg), Graham Todd, Gregory J. Oschwald, grr, Håkon Hægland, Iaroslav  O.
       Kosmina  (darviarush),  Ivan  Bessarabov  (bessarabv),  J Mash, James E. Keenan (jkeenan), Jarrod Funnell
       (Timbus), Jay Allen (jayallen), Jay Hannah (jhannah), jcop, Jesse Luehrs (doy),  Joel  Berger  (jberger),
       John  S.  Anderson (genehack), Karen Etheridge (ether), Kartik Thakore (kthakore), Kevin Dawson (bowtie),
       Kevin McGrath  (catlgrep),  Kip  Hampton  (ubu),  Londran,  Marcel  Grünauer  (hanekomu),  Marco  Masetti
       (grubert65),  Mark  Fowler  (Trelane),  Martin J. Evans, Matthias Muth, Matt S. Trout (mst), Maxim Vuets,
       Michael  Conrad,  Mike  Doherty  (doherty),  Nicolas  R  (atoomic),  Nigel  Metheringham  (nigelm),  Nuba
       Princigalli  (nuba),  Olaf  Alders  (oalders),  Paul  Evans (LeoNerd), Pedro Melo (melo), Philippe Bruhat
       (BooK), Przemysław Wesołek (jest), Rebecca Turner  (iarna),  Renato  Cron  (renatoCRON),  Ricardo  Signes
       (rjbs),  Rob  Hoelz (hoelzro), Salve J. Nilsen (sjn), sawyer, Sebastian Willing (Sewi), Sébastien Feugère
       (smonff), Sergey Aleynikov (randir), Slaven  Rezić,  Stanislaw  Pusep  (syp),  Stephen  Thirlwall  (sdt),
       sugyan,  Tai  Paul,  Tatsuhiko  Miyagawa (miyagawa), Thomas Sibley (tsibley), Tim Heaney (oylenshpeegul),
       Toby Inkster (tobyink), Torsten Raudssus (Getty), Tokuhiro Matsuno  (tokuhirom),  trapd00r,  Tsai  Chung-
       Kuan, Veesh Goldman (rabbiveesh), vividsnow, Wesley Dal`Col (blabos), y, Yanick Champoux (yanick).

       If I missed your name, please drop me a line!

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2011-2024 Breno G. de Oliveira

       This  program  is  free software; you can redistribute it and/or modify it under the terms of either: the
       GNU General Public License as published by the Free Software Foundation; or the Artistic License.

       See &lt;<a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a>&gt; for more information.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE,  TO  THE  EXTENT
       PERMITTED  BY  APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
       PARTIES PROVIDE THE SOFTWARE "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND,  EITHER  EXPRESSED  OR  IMPLIED,
       INCLUDING,  BUT  NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
       PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE  SOFTWARE  IS  WITH  YOU.   SHOULD  THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN  NO  EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY
       OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE  LIABLE
       TO  YOU  FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF
       THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING BUT NOT  LIMITED  TO  LOSS  OF  DATA  OR  DATA  BEING
       RENDERED  INACCURATE  OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO OPERATE
       WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF  SUCH
       DAMAGES.

perl v5.38.2                                       2024-04-27                                 <u>Data::<a href="../man3pm/Printer.3pm.html">Printer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>