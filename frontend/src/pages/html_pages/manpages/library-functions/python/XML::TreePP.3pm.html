<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::TreePP -- Pure Perl implementation for parsing/writing XML documents</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-treepp-perl">libxml-treepp-perl_0.43-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::TreePP -- Pure Perl implementation for parsing/writing XML documents

</pre><h4><b>SYNOPSIS</b></h4><pre>
       parse an XML document from file into hash tree:

           use XML::TreePP;
           my $tpp = XML::TreePP-&gt;new();
           my $tree = $tpp-&gt;parsefile( "index.rdf" );
           print "Title: ", $tree-&gt;{"rdf:RDF"}-&gt;{item}-&gt;[0]-&gt;{title}, "\n";
           print "URL:   ", $tree-&gt;{"rdf:RDF"}-&gt;{item}-&gt;[0]-&gt;{link}, "\n";

       write an XML document as string from hash tree:

           use XML::TreePP;
           my $tpp = XML::TreePP-&gt;new();
           my $tree = { rss =&gt; { channel =&gt; { item =&gt; [ {
               title   =&gt; "The Perl Directory",
               link    =&gt; "<a href="http://www.perl.org/">http://www.perl.org/</a>",
           }, {
               title   =&gt; "The Comprehensive Perl Archive Network",
               link    =&gt; "<a href="http://cpan.perl.org/">http://cpan.perl.org/</a>",
           } ] } } };
           my $xml = $tpp-&gt;write( $tree );
           print $xml;

       get a remote XML document by HTTP-GET and parse it into hash tree:

           use XML::TreePP;
           my $tpp = XML::TreePP-&gt;new();
           my $tree = $tpp-&gt;parsehttp( GET =&gt; "<a href="http://use.perl.org/index.rss">http://use.perl.org/index.rss</a>" );
           print "Title: ", $tree-&gt;{"rdf:RDF"}-&gt;{channel}-&gt;{title}, "\n";
           print "URL:   ", $tree-&gt;{"rdf:RDF"}-&gt;{channel}-&gt;{link}, "\n";

       get a remote XML document by HTTP-POST and parse it into hash tree:

           use XML::TreePP;
           my $tpp = XML::TreePP-&gt;new( force_array =&gt; [qw( item )] );
           my $cgiurl = "<a href="http://search.hatena.ne.jp/keyword">http://search.hatena.ne.jp/keyword</a>";
           my $keyword = "ajax";
           my $cgiquery = "mode=rss2&amp;word=".$keyword;
           my $tree = $tpp-&gt;parsehttp( POST =&gt; $cgiurl, $cgiquery );
           print "Link: ", $tree-&gt;{rss}-&gt;{channel}-&gt;{item}-&gt;[0]-&gt;{link}, "\n";
           print "Desc: ", $tree-&gt;{rss}-&gt;{channel}-&gt;{item}-&gt;[0]-&gt;{description}, "\n";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       XML::TreePP module parses an XML document and expands it for a hash tree.  This generates an XML document
       from a hash tree as the opposite way around.  This is a pure Perl implementation and requires no modules
       depended.  This can also fetch and parse an XML document from remote web server like the XMLHttpRequest
       object does at JavaScript language.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Parse</b> <b>XML</b> <b>file</b>
       Sample XML document:

           &lt;?xml version="1.0" encoding="UTF-8"?&gt;
           &lt;family name="Kawasaki"&gt;
               &lt;father&gt;Yasuhisa&lt;/father&gt;
               &lt;mother&gt;Chizuko&lt;/mother&gt;
               &lt;children&gt;
                   &lt;girl&gt;Shiori&lt;/girl&gt;
                   &lt;boy&gt;Yusuke&lt;/boy&gt;
                   &lt;boy&gt;Kairi&lt;/boy&gt;
               &lt;/children&gt;
           &lt;/family&gt;

       Sample program to read a xml file and dump it:

           use XML::TreePP;
           use Data::Dumper;
           my $tpp = XML::TreePP-&gt;new();
           my $tree = $tpp-&gt;parsefile( "family.xml" );
           my $text = Dumper( $tree );
           print $text;

       Result dumped:

           $VAR1 = {
               'family' =&gt; {
                   '-name' =&gt; 'Kawasaki',
                   'father' =&gt; 'Yasuhisa',
                   'mother' =&gt; 'Chizuko',
                   'children' =&gt; {
                       'girl' =&gt; 'Shiori'
                       'boy' =&gt; [
                           'Yusuke',
                           'Kairi'
                       ],
                   }
               }
           };

       Details:

           print $tree-&gt;{family}-&gt;{father};        # the father's given name.

       The prefix '-' is added on every attribute's name.

           print $tree-&gt;{family}-&gt;{"-name"};       # the family name of the family

       The array is used because the family has two boys.

           print $tree-&gt;{family}-&gt;{children}-&gt;{boy}-&gt;[1];  # The second boy's name
           print $tree-&gt;{family}-&gt;{children}-&gt;{girl};      # The girl's name

   <b>Text</b> <b>node</b> <b>and</b> <b>attributes:</b>
       If a element has both of a text node and attributes or both of a text node and other child nodes, value
       of a text node is moved to "#text" like child nodes.

           use XML::TreePP;
           use Data::Dumper;
           my $tpp = XML::TreePP-&gt;new();
           my $source = '&lt;span class="author"&gt;Kawasaki Yusuke&lt;/span&gt;';
           my $tree = $tpp-&gt;parse( $source );
           my $text = Dumper( $tree );
           print $text;

       The result dumped is following:

           $VAR1 = {
               'span' =&gt; {
                   '-class' =&gt; 'author',
                   '#text'  =&gt; 'Kawasaki Yusuke'
               }
           };

       The special node name of "#text" is used because this elements has attribute(s) in addition to the text
       node.  See also "text_node_key" option.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       This constructor method returns a new XML::TreePP object with %options.

           $tpp = XML::TreePP-&gt;new( %options );

   <b>set</b>
       This method sets a option value for "option_name".  If $option_value is not defined, its option is
       deleted.

           $tpp-&gt;set( option_name =&gt; $option_value );

       See OPTIONS section below for details.

   <b>get</b>
       This method returns a current option value for "option_name".

           $tpp-&gt;get( 'option_name' );

   <b>parse</b>
       This method reads an XML document by string and returns a hash tree converted.  The first argument is a
       scalar or a reference to a scalar.

               $tree = $tpp-&gt;parse( $source );

   <b>parsefile</b>
       This method reads an XML document by file and returns a hash tree converted.  The first argument is a
       filename.

           $tree = $tpp-&gt;parsefile( $file );

   <b>parsehttp</b>
       This method receives an XML document from a remote server via HTTP and returns a hash tree converted.

           $tree = $tpp-&gt;parsehttp( $method, $url, $body, $head );

       $method is a method of HTTP connection: GET/POST/PUT/DELETE $url is an URI of an XML file.  $body is a
       request body when you use POST method.  $head is a request headers as a hash ref.  LWP::UserAgent module
       or HTTP::Lite module is required to fetch a file.

           ( $tree, $xml, $code ) = $tpp-&gt;parsehttp( $method, $url, $body, $head );

       In array context, This method returns also raw XML document received and HTTP response's status code.

   <b>write</b>
       This method parses a hash tree and returns an XML document as a string.

           $source = $tpp-&gt;write( $tree, $encode );

       $tree is a reference to a hash tree.

   <b>writefile</b>
       This method parses a hash tree and writes an XML document into a file.

           $tpp-&gt;writefile( $file, $tree, $encode );

       $file is a filename to create.  $tree is a reference to a hash tree.

</pre><h4><b>OPTIONS</b> <b>FOR</b> <b>PARSING</b> <b>XML</b></h4><pre>
       This module accepts option parameters following:

   <b>force_array</b>
       This option allows you to specify a list of element names which should always be forced into an array
       representation.

           $tpp-&gt;set( force_array =&gt; [ 'rdf:li', 'item', '-xmlns' ] );

       The default value is null, it means that context of the elements will determine to make array or to keep
       it scalar or hash.  Note that the special wildcard name '*' means all elements.

   <b>force_hash</b>
       This option allows you to specify a list of element names which should always be forced into an hash
       representation.

           $tpp-&gt;set( force_hash =&gt; [ 'item', 'image' ] );

       The default value is null, it means that context of the elements will determine to make hash or to keep
       it scalar as a text node.  See also "text_node_key" option below.  Note that the special wildcard name
       '*' means all elements.

   <b>cdata_scalar_ref</b>
       This option allows you to convert a cdata section into a reference for scalar on parsing an XML document.

           $tpp-&gt;set( cdata_scalar_ref =&gt; 1 );

       The default value is false, it means that each cdata section is converted into a scalar.

   <b>user_agent</b>
       This option allows you to specify a HTTP_USER_AGENT string which is used by <b>parsehttp()</b> method.

           $tpp-&gt;set( user_agent =&gt; 'Mozilla/4.0 (compatible; ...)' );

       The default string is 'XML-TreePP/#.##', where '#.##' is substituted with the version number of this
       library.

   <b>http_lite</b>
       This option forces <b>pasrsehttp()</b> method to use a HTTP::Lite instance.

           my $http = HTTP::Lite-&gt;new();
           $tpp-&gt;set( http_lite =&gt; $http );

   <b>lwp_useragent</b>
       This option forces <b>parsehttp()</b> method to use a LWP::UserAgent instance.

           my $ua = LWP::UserAgent-&gt;new();
           $ua-&gt;timeout( 60 );
           $ua-&gt;env_proxy;
           $tpp-&gt;set( lwp_useragent =&gt; $ua );

       You may use this with LWP::UserAgent::WithCache.

   <b>base_class</b>
       This blesses class name for each element's hashref.  Each class is named straight as a child class of it
       parent class.

           $tpp-&gt;set( base_class =&gt; 'MyElement' );
           my $xml  = '&lt;root&gt;&lt;parent&gt;&lt;child key="val"&gt;text&lt;/child&gt;&lt;/parent&gt;&lt;<a href="file:/root">/root</a>&gt;';
           my $tree = $tpp-&gt;parse( $xml );
           print ref $tree-&gt;{root}-&gt;{parent}-&gt;{child}, "\n";

       A hash for &lt;child&gt; element above is blessed to "MyElement::root::parent::child" class. You may use this
       with Class::Accessor.

   <b>elem_class</b>
       This blesses class name for each element's hashref.  Each class is named horizontally under the direct
       child of "MyElement".

           $tpp-&gt;set( base_class =&gt; 'MyElement' );
           my $xml  = '&lt;root&gt;&lt;parent&gt;&lt;child key="val"&gt;text&lt;/child&gt;&lt;/parent&gt;&lt;<a href="file:/root">/root</a>&gt;';
           my $tree = $tpp-&gt;parse( $xml );
           print ref $tree-&gt;{root}-&gt;{parent}-&gt;{child}, "\n";

       A hash for &lt;child&gt; element above is blessed to "MyElement::child" class.

   <b>xml_deref</b>
       This option dereferences the numeric character references, like &amp;#xEB;, &amp;#28450;, etc., in an XML
       document when this value is true.

           $tpp-&gt;set( xml_deref =&gt; 1 );

       Note that, for security reasons and your convenient, this module dereferences the predefined character
       entity references, &amp;amp;, &amp;lt;, &amp;gt;, &amp;apos; and &amp;quot;, and the numeric character references up to
       U+007F without xml_deref per default.

   <b>require_xml_decl</b>
       This option requires XML declaration at the top of XML document to parse.

           $tpp-&gt;set( require_xml_decl =&gt; 1 );

       This will die when &lt;?xml .../?&gt; declration not found.

</pre><h4><b>OPTIONS</b> <b>FOR</b> <b>WRITING</b> <b>XML</b></h4><pre>
   <b>first_out</b>
       This option allows you to specify a list of element/attribute names which should always appears at first
       on output XML document.

           $tpp-&gt;set( first_out =&gt; [ 'link', 'title', '-type' ] );

       The default value is null, it means alphabetical order is used.

   <b>last_out</b>
       This option allows you to specify a list of element/attribute names which should always appears at last
       on output XML document.

           $tpp-&gt;set( last_out =&gt; [ 'items', 'item', 'entry' ] );

   <b>indent</b>
       This makes the output more human readable by indenting appropriately.

           $tpp-&gt;set( indent =&gt; 2 );

       This doesn't strictly follow the XML specification but does looks nice.

   <b>xml_decl</b>
       This module inserts an XML declaration on top of the XML document generated per default. This option
       forces to change it to another or just remove it.

           $tpp-&gt;set( xml_decl =&gt; '' );

   <b>output_encoding</b>
       This option allows you to specify a encoding of the XML document generated by write/writefile methods.

           $tpp-&gt;set( output_encoding =&gt; 'UTF-8' );

       On Perl 5.8.0 and later, you can select it from every encodings supported by Encode.pm. On Perl 5.6.x and
       before with Jcode.pm, you can use "Shift_JIS", "EUC-JP", "ISO-2022-JP" and "UTF-8". The default value is
       "UTF-8" which is recommended encoding.

   <b>empty_element_tag_end</b>
           $tpp-&gt;set( empty_element_tag_end =&gt; '&gt;' );

       Set characters which close empty tag. The default value is ' /&gt;'.

</pre><h4><b>OPTIONS</b> <b>FOR</b> <b>BOTH</b></h4><pre>
   <b>utf8_flag</b>
       This makes utf8 flag on for every element's value parsed and makes it on for the XML document generated
       as well.

           $tpp-&gt;set( utf8_flag =&gt; 1 );

       Perl 5.8.1 or later is required to use this.

   <b>attr_prefix</b>
       This option allows you to specify a prefix character(s) which is inserted before each attribute names.

           $tpp-&gt;set( attr_prefix =&gt; '@' );

       The default character is '-'.  Or set '@' to access attribute values like E4X, ECMAScript for XML.  Zero-
       length prefix '' is available as well, it means no prefix is added.

   <b>text_node_key</b>
       This option allows you to specify a hash key for text nodes.

           $tpp-&gt;set( text_node_key =&gt; '#text' );

       The default key is "#text".

   <b>ignore_error</b>
       This module calls Carp::croak function on an error per default.  This option makes all errors ignored and
       just returns.

           $tpp-&gt;set( ignore_error =&gt; 1 );

   <b>use_ixhash</b>
       This option keeps the order for each element appeared in XML.  Tie::IxHash module is required.

           $tpp-&gt;set( use_ixhash =&gt; 1 );

       This makes parsing performance slow.  (about 100% slower than default)

</pre><h4><b>AUTHOR</b></h4><pre>
       Yusuke Kawasaki, <a href="http://www.kawa.net/">http://www.kawa.net/</a>

</pre><h4><b>REPOSITORY</b></h4><pre>
       https://github.com/kawanet/XML-TreePP

</pre><h4><b>COPYRIGHT</b></h4><pre>
       The following copyright notice applies to all the files provided in this distribution, including binary
       files, unless explicitly noted otherwise.

       Copyright 2006-2010 Yusuke Kawasaki

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-10-13                                   <u>XML::<a href="../man3pm/TreePP.3pm.html">TreePP</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>