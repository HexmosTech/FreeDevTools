<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YAML::XS - Perl YAML Serialization using XS and libyaml</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libyaml-libyaml-perl">libyaml-libyaml-perl_0.903.0+ds-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       YAML::XS - Perl YAML Serialization using XS and libyaml

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use YAML::XS;

           my $yaml = Dump [ 1..4 ];
           my $array = Load $yaml;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Kirill Simonov's "libyaml" is arguably the best YAML implementation. The C library is written precisely
       to the YAML 1.1 specification. It was originally bound to Python and was later bound to Ruby.

       This module is a Perl XS binding to libyaml which offers Perl the best YAML support to date.

       This module exports the functions "Dump", "Load", "DumpFile" and "LoadFile". These functions are intended
       to work exactly like "YAML.pm"'s corresponding functions. Only "Load" and "Dump" are exported by default.

</pre><h4><b>CONFIGURATION</b></h4><pre>
       •   $YAML::XS::LoadBlessed (since v0.69)

           Default: false.

           The default was changed in version 0.81.

           When set to false, it will not bless data into objects, which can be a security problem, when loading
           YAML from an untrusted source. It will silently ignore the tag and just load the data unblessed.

           In PyYAML, this is called SafeLoad.

           If set to true, it will load the following YAML as objects:

               ---
               local: !Foo::Bar [a]
               perl: !!perl/hash:Foo::Bar { a: 1 }
               regex: !!perl/regexp:Foo::Bar pattern

           You  can  create  any  kind of object with YAML. The creation itself is not the critical part. If the
           class has a "DESTROY" method, it will  be  called  once  the  object  is  deleted.  An  example  with
           File::Temp removing files can be found at &lt;https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=862373&gt;.

       •   $YAML::XS::ForbidDuplicateKeys (since 0.84)

           Default: false

           When set to true, "Load" will die when encountering a duplicate key in a hash, e.g.

               key: value
               key: another value

           This  can  be useful for bigger YAML documents where it is not that obvious, and it is recommended to
           set it to true. That's also  what  a  YAML  loader  should  do  by  default  according  to  the  YAML
           specification.

       •   $YAML::XS::UseCode

       •   $YAML::XS::DumpCode

       •   $YAML::XS::LoadCode

           If enabled supports deparsing and evaling of code blocks.

           Note  that  support  for  loading  code  was added in version 0.75, although $LoadCode was documented
           already in earlier versions.

       •   $YAML::XS::QuoteNumericStrings

           When true (the default) strings that look like numbers but have not been numified will be quoted when
           dumping.

           This ensures leading that things like leading zeros and other formatting are preserved.

       •   $YAML::XS::Boolean (since v0.67)

           Default: undef

           Since YAML::XS 0.89: When used with perl 5.36 or later, builtin booleans will work out  of  the  box.
           They will be created by "Load" and recognized by "Dump" automatically (since YAML::XS 0.89).

               say Dump({ truth =&gt; builtin::true });
               # truth: true

           Since YAML::XS v0.902: loaded booleans are not set to readonly anymore.

           For older perl versions you can use the following configuration to serialize data as YAML booleans:

           When  set  to "JSON::PP" or "boolean", the plain (unquoted) strings "true" and "false" will be loaded
           as "JSON::PP::Boolean" or "boolean.pm" objects. Those objects will be dumped again as plain "true" or
           "false".

           It will try to load [JSON::PP] or [boolean] and die if it can't be loaded.

           With that it's possible to add new "real" booleans to a data structure:

               local $YAML::XS::Boolean = "JSON::PP"; # or "boolean"
               my $data = Load("booltrue: true");
               $data-&gt;{boolfalse} = JSON::PP::false;
               my $yaml = Dump($data);
               # boolfalse: false
               # booltrue: true

           It also lets booleans survive when loading YAML via YAML::XS and encode it in JSON  via  one  of  the
           various JSON encoders, which mostly support JSON::PP booleans.

           Please  note  that JSON::PP::Boolean and boolean.pm behave a bit differently. Ideally you should only
           use them in boolean context.

           If not set, booleans are loaded as special perl variables "PL_sv_yes" and "PL_sv_no", which have  the
           disadvantage  that they are readonly, and you can't add those to an existing data structure with pure
           perl.

           If you simply need to load "perl booleans" that are true or false in boolean  context,  you  will  be
           fine with the default setting.

       •   $YAML::XS::Indent (since v0.76)

           Default is 2.

           Sets the number of spaces for indentation for "Dump".

</pre><h4><b>USING</b> <b>YAML::XS</b> <b>WITH</b> <b>UNICODE</b></h4><pre>
       Handling  unicode  properly  in Perl can be a pain. YAML::XS only deals with streams of utf8 octets. Just
       remember this:

           $perl = Load($utf8_octets);
           $utf8_octets = Dump($perl);

       There are many, many places where things can go wrong with unicode.  If  you  are  having  problems,  use
       Devel::Peek on all the possible data points.

</pre><h4><b>LIBYAML</b></h4><pre>
       You can find out (since v.079) which libyaml version this module was built with:

           my $libyaml_version = YAML::XS::LibYAML::libyaml_version();

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   YAML.pm

       •   YAML::Syck

       •   YAML::Tiny

       •   YAML::PP

       •   YAML::PP::LibYAML

</pre><h4><b>AUTHOR</b></h4><pre>
       Ingy döt Net <a href="mailto:ingy@ingy.net">ingy@ingy.net</a> &lt;<a href="mailto:ingy@ingy.net">mailto:ingy@ingy.net</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2007-2024 - Ingy döt Net

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

       See &lt;<a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>&gt;

perl v5.40.0                                       2025-02-07                                      <u>YAML::<a href="../man3pm/XS.3pm.html">XS</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>