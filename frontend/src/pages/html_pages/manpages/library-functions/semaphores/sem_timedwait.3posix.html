<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       sem_timedwait — lock a semaphore

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/semaphore.h">semaphore.h</a>&gt;
       #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;

       int sem_timedwait(sem_t *restrict <u>sem</u>,
           const struct timespec *restrict <u>abstime</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>sem_timedwait</u>()  function  shall lock the semaphore referenced by <u>sem</u> as in the <u>sem_wait</u>() function.
       However, if the semaphore cannot be locked without waiting for another process or thread  to  unlock  the
       semaphore  by  performing a <u>sem_post</u>() function, this wait shall be terminated when the specified timeout
       expires.

       The timeout shall expire when the absolute time specified by <u>abstime</u> passes, as measured by the clock  on
       which  timeouts  are  based  (that is, when the value of that clock equals or exceeds <u>abstime</u>), or if the
       absolute time specified by <u>abstime</u> has already been passed at the time of the call.

       The timeout shall be based on the CLOCK_REALTIME clock.  The resolution  of  the  timeout  shall  be  the
       resolution  of  the  clock  on which it is based. The <b>timespec</b> data type is defined as a structure in the
       <u>&lt;time.h&gt;</u> header.

       Under no circumstance shall the function fail with a timeout if the semaphore can be locked  immediately.
       The validity of the <u>abstime</u> need not be checked if the semaphore can be locked immediately.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The  <u>sem_timedwait</u>()  function  shall  return  zero  if  the  calling  process successfully performed the
       semaphore lock operation on the semaphore designated by <u>sem</u>.  If the call was unsuccessful, the state  of
       the  semaphore  shall be unchanged, and the function shall return a value of -1 and set <u>errno</u> to indicate
       the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>sem_timedwait</u>() function shall fail if:

       <b>EINVAL</b> The process or thread would have blocked, and the <u>abstime</u> parameter specified a nanoseconds  field
              value less than zero or greater than or equal to 1000 million.

       <b>ETIMEDOUT</b>
              The semaphore could not be locked before the specified timeout expired.

       The <u>sem_timedwait</u>() function may fail if:

       <b>EDEADLK</b>
              A deadlock condition was detected.

       <b>EINTR</b>  A signal interrupted this function.

       <b>EINVAL</b> The <u>sem</u> argument does not refer to a valid semaphore.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       The program shown below operates on an unnamed semaphore. The program expects two command-line arguments.
       The  first  argument  specifies  a seconds value that is used to set an alarm timer to generate a SIGALRM
       signal. This handler performs a <u><a href="../man3/sem_post.3.html">sem_post</a></u>(3) to increment the semaphore that is being waited on in  <u>main</u>()
       using <u>sem_timedwait</u>().  The second command-line argument specifies the length of the timeout, in seconds,
       for <u>sem_timedwait</u>().

           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/semaphore.h">semaphore.h</a>&gt;
           #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;
           #include &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;
           #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
           #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;

           sem_t sem;

           static void
           handler(int sig)
           {
               int sav_errno = errno;
               static const char info_msg[] = "sem_post() from handler\n";
               write(STDOUT_FILENO, info_msg, sizeof info_msg - 1);
               if (sem_post(&amp;sem) == -1) {
                   static const char err_msg[] = "sem_post() failed\n";
                   write(STDERR_FILENO, err_msg, sizeof err_msg - 1);
                   _exit(EXIT_FAILURE);
               }
               errno = sav_errno;
           }

           int
           main(int argc, char *argv[])
           {
               struct sigaction sa;
               struct timespec ts;
               int s;

               if (argc != 3) {
                   fprintf(stderr, "Usage: %s &lt;alarm-secs&gt; &lt;wait-secs&gt;\n",
                       argv[0]);
                   exit(EXIT_FAILURE);
               }

               if (sem_init(&amp;sem, 0, 0) == -1) {
                   perror("sem_init");
                   exit(EXIT_FAILURE);
               }

               /* Establish SIGALRM handler; set alarm timer using argv[1] */

               sa.sa_handler = handler;
               sigemptyset(&amp;sa.sa_mask);
               sa.sa_flags = 0;
               if (sigaction(SIGALRM, &amp;sa, NULL) == -1) {
                   perror("sigaction");
                   exit(EXIT_FAILURE);
               }

               alarm(atoi(argv[1]));

               /* Calculate relative interval as current time plus
                  number of seconds given argv[2] */

               if (clock_gettime(CLOCK_REALTIME, &amp;ts) == -1) {
                   perror("clock_gettime");
                   exit(EXIT_FAILURE);
               }
               ts.tv_sec += atoi(argv[2]);

               printf("main() about to call sem_timedwait()\n");
               while ((s = sem_timedwait(&amp;sem, &amp;ts)) == -1 &amp;&amp; errno == EINTR)
                   continue;       /* Restart if interrupted by handler */

               /* Check what happened */

               if (s == -1) {
                   if (errno == ETIMEDOUT)
                       printf("sem_timedwait() timed out\n");
                   else
                       perror("sem_timedwait");
               } else
                   printf("sem_timedwait() succeeded\n");

               exit((s == 0) ? EXIT_SUCCESS : EXIT_FAILURE);
           }

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       Applications  using  these  functions  may  be  subject  to  priority inversion, as discussed in the Base
       Definitions volume of POSIX.1‐2017, <u>Section</u> <u>3.291</u>, <u>Priority</u> <u>Inversion</u>.

</pre><h4><b>RATIONALE</b></h4><pre>
       None.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>sem_post</u>(), <u>sem_trywait</u>(), <u>semctl</u>(), <u>semget</u>(), <u>semop</u>(), <u>time</u>()

       The Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>3.291</u>, <u>Priority</u> <u>Inversion</u>, <b>&lt;semaphore.h&gt;</b>, <b>&lt;time.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                 <u><a href="../man3POSIX/SEM_TIMEDWAIT.3POSIX.html">SEM_TIMEDWAIT</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>