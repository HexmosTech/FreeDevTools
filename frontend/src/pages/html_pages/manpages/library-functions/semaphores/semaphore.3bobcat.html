<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::Semaphore - Implements the Semaphore type designed by Dijkstra</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::Semaphore - Implements the Semaphore type designed by Dijkstra

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/semaphore&gt;</b>

       Linking option: <u>-lpthread</u> <u>-lbobcat</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       According  to  <u><a href="http://en.wikipedia.org/wiki/Semaphore_">http://en.wikipedia.org/wiki/Semaphore_</a>(programming)</u> a semaphore is a variable or abstract
       data type that is used for controlling access, by multiple processes, to a common resource in a  parallel
       programming  or a multi user environment. The <u>Semaphore</u> as a data type was designed around 1962 by Edsger
       Dijkstra.

       A useful way to think of a semaphore is as a record of how  many  units  of  a  particular  resource  are
       available,  coupled with operations to safely (i.e., without race conditions) adjust that record as units
       are required or become free, and, if necessary, wait until a unit of the resource becomes available.

       Semaphores are a useful tool in the prevention of race  conditions.   Semaphores  allowing  an  arbitrary
       resource  count are called counting semaphores, while semaphores which are restricted to the values 0 and
       1 (or locked/unlocked, unavailable/available) are called binary semaphores. Both types are  supported  by
       Bobcat’s implementation.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All  constructors,  members,  operators  and manipulators, mentioned in this man-page, are defined in the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       -

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       o      <b>Semaphore(size_t</b> <b>nAvailable)</b>:
              The constructor defines the semaphore’s  initial  state.  With  a  counting  semaphore  <u>nAvailable</u>
              defines,  e.g., the number of available locations in a storage area. Locking/unlocking, supporting
              facilities to notify other waiting  threads  is  implemented  via  binary  semaphores,  which  are
              initialized  to  1  or  0.  A semaphore containing the value 0 blocks. I.e., its <u>wait</u> member waits
              until its value is incremented by another thread, calling one of the semaphore’s <u>notify</u> members.

       Copy and move constructors (and assignment operators) are not available.

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       o      <b>void</b> <b>notify()</b>:
              The internally maintained <u>available</u> value is incremented and one  waiting  thread  (cf.  the  <u>wait</u>
              members below) is notified, reactivating that thread.

       o      <b>void</b> <b>notify_all()</b>:
              The  internally  maintained  <u>available</u>  value is incremented and all waiting threads (cf. the <u>wait</u>
              members below) are notified. Only one waiting thread will be able to obtain the  semaphore’s  lock
              and to reduce <u>available</u>, and that particular thread is thereupon reactivated.

       o      <b>void</b> <b>set(size_t</b> <b>available)</b>:
              This member blocks until it has obtained the lock of the <u>std::mutex</u> which is maintained internally
              by  the  <u>Semaphore</u> object. Next the <u>Semaphore’s</u> <u>available</u> value receives the value of the member’s
              argument, and the lock is released.

       o      <b>size_t</b> <b>size()</b> <b>const</b>:
              Without trying to lock the <u>Semaphore</u> object’s <u>mutex</u> the current value of the <u>Semaphore’s</u> <u>available</u>
              value is returned.

       o      <b>void</b> <b>wait()</b>:
              This member blocks for as long as the  internally  stored  value  (<u>available</u>)  equals  zero.  When
              returning  from  <u>wait</u>  the  current  thread  holds  the lock of the <u>std::mutex</u> which is maintained
              internally by the <u>Semaphore</u> object. <u>Notify</u> members are used to increment <u>available</u> and  to  inform
              <u>wait</u>  that  it  may  return.  When multiple threads are waiting only one thread will stop waiting,
              while the remaining threads will continue to wait for another notification.

       o      <b>bool</b> <b>wait(Fun</b> <b>fun,</b> <b>Params</b> <b>&amp;&amp;...args)</b>:
              This is a member template, where <u>Fun</u> is a function (object) receiving the argument passed to <u>wait</u>,
              and returning a <u>bool</u>. This member blocks until it has obtained the <u>Semaphore’s</u> mutex  lock,  then,
              while  its  <u>available</u>  value equals 0, waits until being notified. Once it has reacquired the lock
              after being notified <u>fun</u> is called, receiving <u>wait’s</u> perfectly forwarded remaining arguments. This
              member returns <u>false</u> if <u>fun</u> returns <u>false</u>. It returns <u>true</u> if <u>fun</u> returns <u>true</u> and  <u>available</u>  was
              unequal zero following <u>fun</u> returning <u>true</u>. The function may therefore perform tasks outside of the
              <u>Semaphore</u> local environment, which might even involve updating the <u>Semaphore’s</u> <u>available</u> value.

       o      <b>std::cv_status</b> <b>wait_for(std::chrono::duration&lt;Rep,</b> <b>Period&gt;</b> <b>const</b> <b>&amp;relTime)</b>:
              This  member  blocks  for  as  long as the internally stored value (<u>available</u>) equals zero and the
              amount of time specified by <u>relTime</u> hasn’t passed. If the latter happens,  <u>std::cv_status::timeout</u>
              is  returned,  otherwise  <u>std::cv_status::no_timeout</u> is returned, in which case the current thread
              holds the lock of the <u>std::mutex</u> which is maintained internally by the  <u>Semaphore</u>  object.  <u>Notify</u>
              members  are  used  to  increment  <u>available</u>  and to inform <u>wait</u> that it may return. When multiple
              threads are waiting only one thread will stop waiting, while the remaining threads  will  continue
              to wait for another notification.

       o      <b>std::cv_status</b> <b>wait_until(std::chrono::time_point&lt;Clock,</b> <b>Duration&gt;</b> <b>const</b> <b>&amp;absTime)</b>:
              This member blocks for as long as the internally stored value (<u>available</u>) equals zero and the time
              specified  by  <u>absTime</u> hasn’t been reached. If the latter happens (or if <u>absTime</u> lies in the past)
              <u>std::cv_status::timeout</u> is returned, otherwise <u>std::cv_status::no_timeout</u> is  returned,  in  which
              case  the  current  thread  holds the lock of the <u>std::mutex</u> which is maintained internally by the
              <u>Semaphore</u> object. <u>Notify</u> members are used to increment <u>available</u> and to inform <u>wait</u>  that  it  may
              return.  When  multiple threads are waiting only one thread will stop waiting, while the remaining
              threads will continue to wait for another notification.

</pre><h4><b>EXAMPLE</b></h4><pre>
           #include &lt;bobcat/semaphore&gt;

           using namespace FBB;

           Semaphore <a href="../man10/produce.10.html">produce</a>(10);          // storage area size
           Semaphore <a href="../man0/consume.0.html">consume</a>(0);           // # items in store
           std::queue itemQueue;           // storage queue

           void consumer()
           {
               while (true)
               {
                   consume.wait();          // wait until there’s an item in store

                       // mutex lock the queue with multiple consumers
                   size_t item = itemQueue.front();
                   itemQueue.pop();

                   produce.notify();   // notify the producer

                   process(item);      // not implemented
               }
           }

           void producer()
           {
               size_t item = 0;
               while (true)
               {
                   ++item;
                   produce.wait();     // wait for room in the storage

                       // mutex lock the queue with multiple consumers
                   itemQueue.push(item);

                   consume.notify();   // notify the consumer
               }
           }
           int main()
           {
               thread cons(consumer);
               thread prod(producer);

               cons.join();            // ending the threads not implemented
               prod.join();
           }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/semaphore</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7)

</pre><h4><b>BUGS</b></h4><pre>
       None Reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>: debian package containing the static library, headers, manual pages, and  developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                            <u>FBB::<a href="../man3bobcat/Semaphore.3bobcat.html">Semaphore</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>