<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       pthread_mutex_destroy, pthread_mutex_init — destroy and initialize a mutex

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;

       int pthread_mutex_destroy(pthread_mutex_t *<u>mutex</u>);
       int pthread_mutex_init(pthread_mutex_t *restrict <u>mutex</u>,
           const pthread_mutexattr_t *restrict <u>attr</u>);
       pthread_mutex_t <u>mutex</u> = PTHREAD_MUTEX_INITIALIZER;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>pthread_mutex_destroy</u>() function shall destroy the mutex object referenced by <u>mutex</u>; the mutex object
       becomes,  in effect, uninitialized. An implementation may cause <u>pthread_mutex_destroy</u>() to set the object
       referenced by <u>mutex</u> to an invalid value.

       A destroyed mutex object can be  reinitialized  using  <u>pthread_mutex_init</u>();  the  results  of  otherwise
       referencing the object after it has been destroyed are undefined.

       It shall be safe to destroy an initialized mutex that is unlocked.  Attempting to destroy a locked mutex,
       or  a  mutex  that  another  thread  is  attempting  to  lock,  or  a  mutex  that  is  being  used  in a
       <u>pthread_cond_timedwait</u>() or <u>pthread_cond_wait</u>() call by another thread, results in undefined behavior.

       The <u>pthread_mutex_init</u>() function  shall  initialize  the  mutex  referenced  by  <u>mutex</u>  with  attributes
       specified  by <u>attr</u>.  If <u>attr</u> is NULL, the default mutex attributes are used; the effect shall be the same
       as passing the address of a default mutex attributes object. Upon successful initialization, the state of
       the mutex becomes initialized and unlocked.

       See <u>Section</u> <u>2.9.9</u>, <u>Synchronization</u> <u>Object</u> <u>Copies</u> <u>and</u> <u>Alternative</u> <u>Mappings</u> for further requirements.

       Attempting to initialize an already initialized mutex results in undefined behavior.

       In cases where default mutex attributes are appropriate, the macro PTHREAD_MUTEX_INITIALIZER can be  used
       to  initialize  mutexes.  The  effect  shall  be  equivalent  to  dynamic  initialization  by  a  call to
       <u>pthread_mutex_init</u>() with parameter <u>attr</u> specified as NULL, except that no error checks are performed.

       The behavior is undefined if the value specified by the <u>mutex</u> argument  to  <u>pthread_mutex_destroy</u>()  does
       not refer to an initialized mutex.

       The  behavior  is  undefined if the value specified by the <u>attr</u> argument to <u>pthread_mutex_init</u>() does not
       refer to an initialized mutex attributes object.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       If  successful,  the  <u>pthread_mutex_destroy</u>()  and  <u>pthread_mutex_init</u>()  functions  shall  return  zero;
       otherwise, an error number shall be returned to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>pthread_mutex_init</u>() function shall fail if:

       <b>EAGAIN</b> The system lacked the necessary resources (other than memory) to initialize another mutex.

       <b>ENOMEM</b> Insufficient memory exists to initialize the mutex.

       <b>EPERM</b>  The caller does not have the privilege to perform the operation.

       The <u>pthread_mutex_init</u>() function may fail if:

       <b>EINVAL</b> The  attributes  object referenced by <u>attr</u> has the robust mutex attribute set without the process-
              shared attribute being set.

       These functions shall not return an error code of <b>[EINTR]</b>.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       None.

</pre><h4><b>RATIONALE</b></h4><pre>
       If an implementation detects that the value specified by the <u>mutex</u>  argument  to  <u>pthread_mutex_destroy</u>()
       does  not  refer  to  an initialized mutex, it is recommended that the function should fail and report an
       <b>[EINVAL]</b> error.

       If an implementation detects that the value specified by the <u>mutex</u> argument to <u>pthread_mutex_destroy</u>() or
       <u>pthread_mutex_init</u>() refers to a locked mutex or a mutex that is referenced  (for  example,  while  being
       used  in  a <u>pthread_cond_timedwait</u>() or <u>pthread_cond_wait</u>()) by another thread, or detects that the value
       specified by the <u>mutex</u> argument to <u>pthread_mutex_init</u>() refers to an already  initialized  mutex,  it  is
       recommended that the function should fail and report an <b>[EBUSY]</b> error.

       If  an  implementation detects that the value specified by the <u>attr</u> argument to <u>pthread_mutex_init</u>() does
       not refer to an initialized mutex attributes object, it is recommended that the function should fail  and
       report an <b>[EINVAL]</b> error.

   <b>Alternate</b> <b>Implementations</b> <b>Possible</b>
       This  volume  of POSIX.1‐2017 supports several alternative implementations of mutexes.  An implementation
       may store the lock directly in the object of type <b>pthread_mutex_t</b>.  Alternatively, an implementation  may
       store  the lock in the heap and merely store a pointer, handle, or unique ID in the mutex object.  Either
       implementation has advantages or may be required on certain hardware  configurations.  So  that  portable
       code  can  be  written  that  is  invariant  to  this choice, this volume of POSIX.1‐2017 does not define
       assignment or equality for this type, and  it  uses  the  term  ``initialize''  to  reinforce  the  (more
       restrictive) notion that the lock may actually reside in the mutex object itself.

       Note  that  this  precludes  an  over-specification  of  the  type of the mutex or condition variable and
       motivates the opaqueness of the type.

       An implementation is permitted, but not required, to have <u>pthread_mutex_destroy</u>() store an illegal  value
       into the mutex. This may help detect erroneous programs that try to lock (or otherwise reference) a mutex
       that has already been destroyed.

   <b>Tradeoff</b> <b>Between</b> <b>Error</b> <b>Checks</b> <b>and</b> <b>Performance</b> <b>Supported</b>
       Many  error  conditions  that can occur are not required to be detected by the implementation in order to
       let implementations trade off performance <u>versus</u> degree of error checking according to the needs of their
       specific applications and execution environment. As a general rule, conditions caused by the system (such
       as insufficient memory) are required to be detected,  but  conditions  caused  by  an  erroneously  coded
       application  (such  as  failing to provide adequate synchronization to prevent a mutex from being deleted
       while in use) are specified to result in undefined behavior.

       A wide range of implementations is thus made  possible.  For  example,  an  implementation  intended  for
       application  debugging  may  implement  all  of the error checks, but an implementation running a single,
       provably correct application under very tight performance  constraints  in  an  embedded  computer  might
       implement  minimal  checks.  An  implementation  might  even  be provided in two versions, similar to the
       options that compilers provide: a full-checking, but slower version; and a limited-checking,  but  faster
       version. To forbid this optionality would be a disservice to users.

       By  carefully  limiting  the use of ``undefined behavior'' only to things that an erroneous (badly coded)
       application might do, and by defining that resource-not-available errors are mandatory,  this  volume  of
       POSIX.1‐2017  ensures  that  a  fully-conforming  application  is  portable  across  the  full  range  of
       implementations, while not forcing all implementations to add overhead to check for numerous things  that
       a correct program never does. When the behavior is undefined, no error number is specified to be returned
       on  implementations  that  do detect the condition. This is because undefined behavior means <u>anything</u> can
       happen, which includes returning with any value (which might happen to be a valid, but  different,  error
       number).  However,  since  the  error  number  might  be useful to application developers when diagnosing
       problems during application development, a recommendation is made in rationale that  implementors  should
       return a particular error number if their implementation does detect the condition.

   <b>Why</b> <b>No</b> <b>Limits</b> <b>are</b> <b>Defined</b>
       Defining  symbols  for  the maximum number of mutexes and condition variables was considered but rejected
       because the number of these objects may change dynamically. Furthermore, many implementations place these
       objects into application memory; thus, there is no explicit maximum.

   <b>Static</b> <b>Initializers</b> <b>for</b> <b>Mutexes</b> <b>and</b> <b>Condition</b> <b>Variables</b>
       Providing for static initialization of statically allocated synchronization objects allows  modules  with
       private static synchronization variables to avoid runtime initialization tests and overhead. Furthermore,
       it  simplifies the coding of self-initializing modules. Such modules are common in C libraries, where for
       various reasons the design  calls  for  self-initialization  instead  of  requiring  an  explicit  module
       initialization function to be called. An example use of static initialization follows.

       Without static initialization, a self-initializing routine <u>foo</u>() might look as follows:

           static pthread_once_t foo_once = PTHREAD_ONCE_INIT;
           static pthread_mutex_t foo_mutex;

           void foo_init()
           {
               pthread_mutex_init(&amp;foo_mutex, NULL);
           }

           void foo()
           {
               pthread_once(&amp;foo_once, foo_init);
               pthread_mutex_lock(&amp;foo_mutex);
              /* Do work. */
               pthread_mutex_unlock(&amp;foo_mutex);
           }

       With static initialization, the same routine could be coded as follows:

           static pthread_mutex_t foo_mutex = PTHREAD_MUTEX_INITIALIZER;

           void foo()
           {
               pthread_mutex_lock(&amp;foo_mutex);
              /* Do work. */
               pthread_mutex_unlock(&amp;foo_mutex);
           }

       Note  that  the  static  initialization  both  eliminates  the  need  for  the initialization test inside
       <u>pthread_once</u>() and the fetch of &amp;<u>foo_mutex</u> to learn the address to be passed to  <u>pthread_mutex_lock</u>()  or
       <u>pthread_mutex_unlock</u>().

       Thus,  the  C code written to initialize static objects is simpler on all systems and is also faster on a
       large class of systems; those where the (entire) synchronization object  can  be  stored  in  application
       memory.

       Yet  the  locking  performance  question  is  likely to be raised for machines that require mutexes to be
       allocated out of special memory.  Such machines actually have to  have  mutexes  and  possibly  condition
       variables  contain  pointers  to  the  actual  hardware  locks. For static initialization to work on such
       machines, <u>pthread_mutex_lock</u>() also has to test whether or not the pointer to the actual  lock  has  been
       allocated.  If  it has not, <u>pthread_mutex_lock</u>() has to initialize it before use. The reservation of such
       resources can be made when the program is loaded, and hence return codes have not  been  added  to  mutex
       locking and condition variable waiting to indicate failure to complete initialization.

       This runtime test in <u>pthread_mutex_lock</u>() would at first seem to be extra work; an extra test is required
       to see whether the pointer has been initialized. On most machines this would actually be implemented as a
       fetch of the pointer, testing the pointer against zero, and then using the pointer if it has already been
       initialized.  While  the  test  might  seem  to add extra work, the extra effort of testing a register is
       usually negligible since no extra memory references are actually done. As more and more machines  provide
       caches, the real expenses are memory references, not instructions executed.

       Alternatively,  depending  on the machine architecture, there are often ways to eliminate <u>all</u> overhead in
       the most important case: on the lock operations that occur <u>after</u> the lock has been initialized. This  can
       be done by shifting more overhead to the less frequent operation: initialization. Since out-of-line mutex
       allocation  also means that an address has to be dereferenced to find the actual lock, one technique that
       is widely applicable is to  have  static  initialization  store  a  bogus  value  for  that  address;  in
       particular,  an  address  that  causes  a machine fault to occur. When such a fault occurs upon the first
       attempt to lock such a mutex, validity checks can be done, and then the correct address  for  the  actual
       lock  can  be  filled in. Subsequent lock operations incur no extra overhead since they do not ``fault''.
       This is merely one technique that can be used to  support  static  initialization,  while  not  adversely
       affecting  the  performance  of  lock  acquisition.  No  doubt there are other techniques that are highly
       machine-dependent.

       The locking overhead for machines doing out-of-line mutex allocation is thus similar  for  modules  being
       implicitly initialized, where it is improved for those doing mutex allocation entirely inline. The inline
       case is thus made much faster, and the out-of-line case is not significantly worse.

       Besides  the issue of locking performance for such machines, a concern is raised that it is possible that
       threads would serialize contending for  initialization  locks  when  attempting  to  finish  initializing
       statically allocated mutexes. (Such finishing would typically involve taking an internal lock, allocating
       a  structure,  storing  a pointer to the structure in the mutex, and releasing the internal lock.) First,
       many implementations would reduce such serialization by  hashing  on  the  mutex  address.  Second,  such
       serialization  can  only  occur  a  bounded number of times. In particular, it can happen at most as many
       times as there are statically allocated synchronization  objects.  Dynamically  allocated  objects  would
       still be initialized via <u>pthread_mutex_init</u>() or <u>pthread_cond_init</u>().

       Finally,  if  none  of  the  above  optimization  techniques for out-of-line allocation yields sufficient
       performance for an application on some implementation, the application can  avoid  static  initialization
       altogether by explicitly initializing all synchronization objects with the corresponding <u>pthread_*_init</u>()
       functions,  which are supported by all implementations. An implementation can also document the tradeoffs
       and advise which initialization technique is more efficient for that particular implementation.

   <b>Destroying</b> <b>Mutexes</b>
       A mutex can be destroyed immediately after it is unlocked. However, since attempting to destroy a  locked
       mutex,  or  a  mutex  that  another  thread  is  attempting  to  lock, or a mutex that is being used in a
       <u>pthread_cond_timedwait</u>() or <u>pthread_cond_wait</u>() call by another thread, results  in  undefined  behavior,
       care must be taken to ensure that no other thread may be referencing the mutex.

   <b>Robust</b> <b>Mutexes</b>
       Implementations  are required to provide robust mutexes for mutexes with the process-shared attribute set
       to PTHREAD_PROCESS_SHARED. Implementations are allowed, but not required, to provide robust mutexes  when
       the process-shared attribute is set to PTHREAD_PROCESS_PRIVATE.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>pthread_mutex_getprioceiling</u>(), <u>pthread_mutexattr_getrobust</u>(), <u>pthread_mutex_lock</u>(),
       <u>pthread_mutex_timedlock</u>(), <u>pthread_mutexattr_getpshared</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;pthread.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                         <u><a href="../man3POSIX/PTHREAD_MUTEX_DESTROY.3POSIX.html">PTHREAD_MUTEX_DESTROY</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>