<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock — lock and unlock a mutex

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;

       int pthread_mutex_lock(pthread_mutex_t *<u>mutex</u>);
       int pthread_mutex_trylock(pthread_mutex_t *<u>mutex</u>);
       int pthread_mutex_unlock(pthread_mutex_t *<u>mutex</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  mutex object referenced by <u>mutex</u> shall be locked by a call to <u>pthread_mutex_lock</u>() that returns zero
       or <b>[EOWNERDEAD]</b>.  If the mutex is already locked by another thread, the calling thread shall block  until
       the mutex becomes available. This operation shall return with the mutex object referenced by <u>mutex</u> in the
       locked  state  with  the  calling thread as its owner. If a thread attempts to relock a mutex that it has
       already locked, <u>pthread_mutex_lock</u>() shall behave as described in the  <b>Relock</b>  column  of  the  following
       table.  If  a  thread  attempts  to  unlock  a mutex that it has not locked or a mutex which is unlocked,
       <u>pthread_mutex_unlock</u>() shall behave as described in the <b>Unlock</b> <b>When</b> <b>Not</b> <b>Owner</b>  column  of  the  following
       table.
                         ┌────────────┬────────────┬────────────────┬───────────────────────┐
                         │ <b>Mutex</b> <b>Type</b> │ <b>Robustness</b> │     <b>Relock</b>     │ <b>Unlock</b> <b>When</b> <b>Not</b> <b>Owner</b> │
                         ├────────────┼────────────┼────────────────┼───────────────────────┤
                         │ NORMAL     │ non-robust │ deadlock       │ undefined behavior    │
                         ├────────────┼────────────┼────────────────┼───────────────────────┤
                         │ NORMAL     │ robust     │ deadlock       │ error returned        │
                         ├────────────┼────────────┼────────────────┼───────────────────────┤
                         │ ERRORCHECK │ either     │ error returned │ error returned        │
                         ├────────────┼────────────┼────────────────┼───────────────────────┤
                         │ RECURSIVE  │ either     │ recursive      │ error returned        │
                         │            │            │ (see below)    │                       │
                         ├────────────┼────────────┼────────────────┼───────────────────────┤
                         │ DEFAULT    │ non-robust │ undefined      │ undefined behavior†   │
                         │            │            │ behavior†      │                       │
                         ├────────────┼────────────┼────────────────┼───────────────────────┤
                         │ DEFAULT    │ robust     │ undefined      │ error returned        │
                         │            │            │ behavior†      │                       │
                         └────────────┴────────────┴────────────────┴───────────────────────┘

       †     If  the mutex type is PTHREAD_MUTEX_DEFAULT, the behavior of <u>pthread_mutex_lock</u>() may correspond to
             one of the three other standard mutex types as described  in  the  table  above.  If  it  does  not
             correspond to one of those three, the behavior is undefined for the cases marked †.

       Where  the table indicates recursive behavior, the mutex shall maintain the concept of a lock count. When
       a thread successfully acquires a mutex for the first time, the lock count shall be set to one. Every time
       a thread relocks this mutex, the lock count shall be incremented by one. Each time the thread unlocks the
       mutex, the lock count shall be decremented by one. When the lock count  reaches  zero,  the  mutex  shall
       become available for other threads to acquire.

       The  <u>pthread_mutex_trylock</u>()  function  shall  be  equivalent to <u>pthread_mutex_lock</u>(), except that if the
       mutex object referenced by <u>mutex</u> is currently locked (by any thread, including the current  thread),  the
       call  shall  return  immediately. If the mutex type is PTHREAD_MUTEX_RECURSIVE and the mutex is currently
       owned  by  the  calling  thread,  the  mutex  lock  count  shall  be   incremented   by   one   and   the
       <u>pthread_mutex_trylock</u>() function shall immediately return success.

       The  <u>pthread_mutex_unlock</u>()  function  shall release the mutex object referenced by <u>mutex</u>.  The manner in
       which a mutex is released is dependent upon the mutex's type attribute. If there are threads  blocked  on
       the  mutex  object  referenced  by  <u>mutex</u>  when  <u>pthread_mutex_unlock</u>() is called, resulting in the mutex
       becoming available, the scheduling policy shall determine which thread shall acquire the mutex.

       (In the case of PTHREAD_MUTEX_RECURSIVE mutexes, the mutex shall become available when the count  reaches
       zero and the calling thread no longer has any locks on this mutex.)

       If  a signal is delivered to a thread waiting for a mutex, upon return from the signal handler the thread
       shall resume waiting for the mutex as if it was not interrupted.

       If <u>mutex</u> is a robust mutex and the process containing the owning  thread  terminated  while  holding  the
       mutex  lock,  a  call  to  <u>pthread_mutex_lock</u>() shall return the error value <b>[EOWNERDEAD]</b>.  If <u>mutex</u> is a
       robust  mutex  and  the  owning  thread  terminated  while  holding   the   mutex   lock,   a   call   to
       <u>pthread_mutex_lock</u>()  may  return  the  error  value <b>[EOWNERDEAD]</b> even if the process in which the owning
       thread resides has not terminated. In these cases, the mutex is locked by the thread  but  the  state  it
       protects  is  marked as inconsistent. The application should ensure that the state is made consistent for
       reuse and when that is complete call <u>pthread_mutex_consistent</u>().  If the application is unable to recover
       the state, it should unlock the mutex without a prior call to <u>pthread_mutex_consistent</u>(), after which the
       mutex is marked permanently unusable.

       If <u>mutex</u>  does  not  refer  to  an  initialized  mutex  object,  the  behavior  of  <u>pthread_mutex_lock</u>(),
       <u>pthread_mutex_trylock</u>(), and <u>pthread_mutex_unlock</u>() is undefined.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       If  successful,  the  <u>pthread_mutex_lock</u>(), <u>pthread_mutex_trylock</u>(), and <u>pthread_mutex_unlock</u>() functions
       shall return zero; otherwise, an error number shall be returned to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>pthread_mutex_lock</u>() and <u>pthread_mutex_trylock</u>() functions shall fail if:

       <b>EAGAIN</b> The mutex could not be acquired because the maximum number of recursive locks for <u>mutex</u>  has  been
              exceeded.

       <b>EINVAL</b> The  <u>mutex</u>  was  created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the
              calling thread's priority is higher than the mutex's current priority ceiling.

       <b>ENOTRECOVERABLE</b>
              The state protected by the mutex is not recoverable.

       <b>EOWNERDEAD</b>
              The mutex is a robust mutex and the process containing the previous owning thread terminated while
              holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the
              new owner to make the state consistent.

       The <u>pthread_mutex_lock</u>() function shall fail if:

       <b>EDEADLK</b>
              The mutex type is PTHREAD_MUTEX_ERRORCHECK and the current thread already owns the mutex.

       The <u>pthread_mutex_trylock</u>() function shall fail if:

       <b>EBUSY</b>  The <u>mutex</u> could not be acquired because it was already locked.

       The <u>pthread_mutex_unlock</u>() function shall fail if:

       <b>EPERM</b>  The mutex type is PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE, or the mutex  is  a  robust
              mutex, and the current thread does not own the mutex.

       The <u>pthread_mutex_lock</u>() and <u>pthread_mutex_trylock</u>() functions may fail if:

       <b>EOWNERDEAD</b>
              The  mutex  is  a  robust  mutex and the previous owning thread terminated while holding the mutex
              lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make
              the state consistent.

       The <u>pthread_mutex_lock</u>() function may fail if:

       <b>EDEADLK</b>
              A deadlock condition was detected.

       These functions shall not return an error code of <b>[EINTR]</b>.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       Applications that have assumed that non-zero return values are errors will need  updating  for  use  with
       robust  mutexes,  since  a  valid  return  for a thread acquiring a mutex which is protecting a currently
       inconsistent state is <b>[EOWNERDEAD]</b>.  Applications that do not check the error returns, due to ruling  out
       the  possibility  of such errors arising, should not use robust mutexes. If an application is supposed to
       work with normal and robust mutexes it should check  all  return  values  for  error  conditions  and  if
       necessary take appropriate action.

</pre><h4><b>RATIONALE</b></h4><pre>
       Mutex  objects  are  intended  to  serve as a low-level primitive from which other thread synchronization
       functions can be built. As such, the implementation of mutexes should be as efficient  as  possible,  and
       this has ramifications on the features available at the interface.

       The  mutex  functions  and the particular default settings of the mutex attributes have been motivated by
       the desire to not preclude fast, inlined implementations of mutex locking and unlocking.

       Since most attributes only need to be checked when a thread is going to be blocked, the use of attributes
       does not slow the (common) mutex-locking case.

       Likewise, while being able to extract the thread ID of the owner of a mutex might be desirable, it  would
       require storing the current thread ID when each mutex is locked, and this could incur unacceptable levels
       of overhead. Similar arguments apply to a <u>mutex_tryunlock</u> operation.

       For  further  rationale  on  the  extended  mutex  types,  see  the  Rationale  (Informative)  volume  of
       POSIX.1‐2017, <u>Threads</u> <u>Extensions</u>.

       If an implementation detects that the value specified  by  the  <u>mutex</u>  argument  does  not  refer  to  an
       initialized mutex object, it is recommended that the function should fail and report an <b>[EINVAL]</b> error.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>pthread_mutex_consistent</u>(), <u>pthread_mutex_destroy</u>(), <u>pthread_mutex_timedlock</u>(),
       <u>pthread_mutexattr_getrobust</u>()

       The Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>4.12</u>, <u>Memory</u> <u>Synchronization</u>, <b>&lt;pthread.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                            <u><a href="../man3POSIX/PTHREAD_MUTEX_LOCK.3POSIX.html">PTHREAD_MUTEX_LOCK</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>