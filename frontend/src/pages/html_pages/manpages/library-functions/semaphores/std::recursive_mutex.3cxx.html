<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::recursive_mutex</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::recursive_mutex

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;mutex&gt;

       Inherits __recursive_mutex_base.

   <b>Public</b> <b>Types</b>
       <b>typedef</b> <b>__native_type</b> * <b>native_handle_type</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>recursive_mutex</b> (const <b>recursive_mutex</b> &amp;)=<b>delete</b>
       <b>void</b> <b>lock</b> ()
       <b>native_handle_type</b> <b>native_handle</b> () noexcept
       <b>recursive_mutex</b> &amp; <b>operator=</b> (const <b>recursive_mutex</b> &amp;)=<b>delete</b>
       bool <b>try_lock</b> () noexcept
       <b>void</b> <b>unlock</b> ()

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       The standard recursive mutex type.

       A recursive mutex can be locked more than once by the same thread. Other threads cannot lock the mutex
       until the owning thread unlocks it as many times as it was locked.

       <b>Since</b>
           C++11

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                         <u>std::<a href="../man3cxx/recursive_mutex.3cxx.html">recursive_mutex</a></u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>