<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       semop — XSI semaphore operations

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;sys/sem.h&gt;

       int semop(int <u>semid</u>, struct sembuf *<u>sops</u>, size_t <u>nsops</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>semop</u>() function operates on XSI semaphores (see the Base Definitions volume of POSIX.1‐2017, <u>Section</u>
       <u>4.17</u>,  <u>Semaphore</u>).   It is unspecified whether this function interoperates with the realtime interprocess
       communication facilities defined in <u>Section</u> <u>2.8</u>, <u>Realtime</u>.

       The <u>semop</u>() function shall perform atomically a user-defined array of semaphore operations in array order
       on the set of semaphores associated with the semaphore identifier specified by the argument <u>semid</u>.

       The argument <u>sops</u>  is  a  pointer  to  a  user-defined  array  of  semaphore  operation  structures.  The
       implementation shall not modify elements of this array unless the application uses implementation-defined
       extensions.

       The argument <u>nsops</u> is the number of such structures in the array.

       Each structure, <b>sembuf</b>, includes the following members:
                            ┌────────────────┬───────────────┬──────────────────────────┐
                            │  <b>Member</b> <b>Type</b>   │ <b>Member</b> <b>Name</b>   │       <b>Description</b>        │
                            ├────────────────┼───────────────┼──────────────────────────┤
                            │ <b>unsigned</b> <b>short</b> │ <u>sem_num</u>       │Semaphore number.         │
                            │ <b>short</b>          │ <u>sem_op</u>        │Semaphore operation.      │
                            │ <b>short</b>          │ <u>sem_flg</u>       │Operation flags.          │
                            └────────────────┴───────────────┴──────────────────────────┘

       Each  semaphore  operation  specified  by <u>sem_op</u> is performed on the corresponding semaphore specified by
       <u>semid</u> and <u>sem_num</u>.

       The variable <u>sem_op</u> specifies one of three semaphore operations:

        1. If <u>sem_op</u> is a negative integer and the calling process has alter permission, one  of  the  following
           shall occur:

            *  If <u>semval</u>(see <u>&lt;sys/sem.h&gt;</u>) is greater than or equal to the absolute value of <u>sem_op</u>, the absolute
               value  of  <u>sem_op</u>  is  subtracted  from  <u>semval</u>.   Also,  if (<u>sem_flg</u> &amp;SEM_UNDO) is non-zero, the
               absolute value of <u>sem_op</u> shall be added to the <u>semadj</u>  value  of  the  calling  process  for  the
               specified semaphore.

            *  If  <u>semval</u>  is  less  than  the  absolute  value of <u>sem_op</u> and (<u>sem_flg</u> &amp;IPC_NOWAIT) is non-zero,
               <u>semop</u>() shall return immediately.

            *  If <u>semval</u> is less than the absolute value of <u>sem_op</u> and (<u>sem_flg</u> &amp;IPC_NOWAIT) is 0, <u>semop</u>() shall
               increment the <u>semncnt</u> associated with the  specified  semaphore  and  suspend  execution  of  the
               calling thread until one of the following conditions occurs:

               --  The value of <u>semval</u> becomes greater than or equal to the absolute value of <u>sem_op</u>.  When this
                   occurs,  the  value  of <u>semncnt</u> associated with the specified semaphore shall be decremented,
                   the absolute value of <u>sem_op</u> shall be subtracted from <u>semval</u> and, if (<u>sem_flg</u>  &amp;SEM_UNDO)  is
                   non-zero,  the  absolute  value  of  <u>sem_op</u> shall be added to the <u>semadj</u> value of the calling
                   process for the specified semaphore.

               --  The <u>semid</u> for which the calling thread is awaiting action is removed from  the  system.  When
                   this occurs, <u>errno</u> shall be set to <b>[EIDRM]</b> and -1 shall be returned.

               --  The  calling  thread  receives  a signal that is to be caught. When this occurs, the value of
                   <u>semncnt</u> associated with the specified semaphore shall be decremented, and the calling  thread
                   shall resume execution in the manner prescribed in <u>sigaction</u>().

        2. If  <u>sem_op</u>  is  a  positive integer and the calling process has alter permission, the value of <u>sem_op</u>
           shall be added to <u>semval</u> and, if (<u>sem_flg</u> &amp;SEM_UNDO) is  non-zero,  the  value  of  <u>sem_op</u>  shall  be
           subtracted from the <u>semadj</u> value of the calling process for the specified semaphore.

        3. If <u>sem_op</u> is 0 and the calling process has read permission, one of the following shall occur:

            *  If <u>semval</u> is 0, <u>semop</u>() shall return immediately.

            *  If <u>semval</u> is non-zero and (<u>sem_flg</u> &amp;IPC_NOWAIT) is non-zero, <u>semop</u>() shall return immediately.

            *  If  <u>semval</u>  is  non-zero  and  (<u>sem_flg</u>  &amp;IPC_NOWAIT)  is  0, <u>semop</u>() shall increment the <u>semzcnt</u>
               associated with the specified semaphore and suspend execution of the calling thread until one  of
               the following occurs:

               --  The  value  of  <u>semval</u>  becomes  0,  at  which  time the value of <u>semzcnt</u> associated with the
                   specified semaphore shall be decremented.

               --  The <u>semid</u> for which the calling thread is awaiting action is removed from  the  system.  When
                   this occurs, <u>errno</u> shall be set to <b>[EIDRM]</b> and -1 shall be returned.

               --  The  calling  thread  receives  a signal that is to be caught. When this occurs, the value of
                   <u>semzcnt</u> associated with the specified semaphore shall be decremented, and the calling  thread
                   shall resume execution in the manner prescribed in <u>sigaction</u>().

       Upon  successful  completion, the value of <u>sempid</u> for each semaphore specified in the array pointed to by
       <u>sops</u> shall be set to the process ID of the calling process. Also, the <u>sem_otime</u> timestamp shall be set to
       the current time, as described in <u>Section</u> <u>2.7.1</u>, <u>IPC</u> <u>General</u> <u>Description</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, <u>semop</u>() shall return 0; otherwise, it  shall  return  -1  and  set  <u>errno</u>  to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>semop</u>() function shall fail if:

       <b>E2BIG</b>  The value of <u>nsops</u> is greater than the system-imposed maximum.

       <b>EACCES</b> Operation  permission  is  denied  to  the  calling  process;  see  <u>Section</u>  <u>2.7</u>, <u>XSI</u> <u>Interprocess</u>
              <u>Communication</u>.

       <b>EAGAIN</b> The operation would result in suspension of the calling process but (<u>sem_flg</u> &amp;IPC_NOWAIT) is  non-
              zero.

       <b>EFBIG</b>  The  value  of  <u>sem_num</u> is greater than or equal to the number of semaphores in the set associated
              with <u>semid</u>.

       <b>EIDRM</b>  The semaphore identifier <u>semid</u> is removed from the system.

       <b>EINTR</b>  The <u>semop</u>() function was interrupted by a signal.

       <b>EINVAL</b> The value of <u>semid</u> is not a valid semaphore identifier, or the number of individual semaphores for
              which the calling process requests a SEM_UNDO would exceed the system-imposed limit.

       <b>ENOSPC</b> The limit on the number of individual processes requesting a SEM_UNDO would be exceeded.

       <b>ERANGE</b> An operation would cause a <u>semval</u> to overflow the system-imposed  limit,  or  an  operation  would
              cause a <u>semadj</u> value to overflow the system-imposed limit.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Setting</b> <b>Values</b> <b>in</b> <b>Semaphores</b>
       The  following  example sets the values of the two semaphores associated with the <u>semid</u> identifier to the
       values contained in the <u>sb</u> array.

           #include &lt;sys/sem.h&gt;
           ...
           int semid;
           struct sembuf sb[2];
           int nsops = 2;
           int result;

           /* Code to initialize semid. */
           ...

           /* Adjust value of semaphore in the semaphore array semid. */
           sb[0].sem_num = 0;
           sb[0].sem_op = -1;
           sb[0].sem_flg = SEM_UNDO | IPC_NOWAIT;
           sb[1].sem_num = 1;
           sb[1].sem_op = 1;
           sb[1].sem_flg = 0;

           result = semop(semid, sb, nsops);

   <b>Creating</b> <b>a</b> <b>Semaphore</b> <b>Identifier</b>
       The following example gets a unique semaphore key using the <u>ftok</u>() function, then  gets  a  semaphore  ID
       associated  with  that  key  using  the  <u>semget</u>()  function  (the  first call also tests to make sure the
       semaphore exists).  If the semaphore does not exist, the program creates it, as shown by the second  call
       to  <u>semget</u>().   In  creating  the  semaphore  for the queuing process, the program attempts to create one
       semaphore with read/write permission for all. It also uses the IPC_EXCL flag, which  forces  <u>semget</u>()  to
       fail if the semaphore already exists.

       After  creating  the  semaphore,  the  program uses calls to <u>semctl</u>() and <u>semop</u>() to initialize it to the
       values in the <u>sbuf</u> array. The number of processes  that  can  execute  concurrently  without  queuing  is
       initially  set  to 2. The final call to <u>semget</u>() creates a semaphore identifier that can be used later in
       the program.

       Processes that obtain <u>semid</u> without creating it check that <u>sem_otime</u> is  non-zero,  to  ensure  that  the
       creating process has completed the <u>semop</u>() initialization.

       The final call to <u>semop</u>() acquires the semaphore and waits until it is free; the SEM_UNDO option releases
       the  semaphore  when  the  process  exits,  waiting  until  there  are  less  than  two processes running
       concurrently.

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;sys/sem.h&gt;
           #include &lt;sys/stat.h&gt;
           #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           ...
           key_t semkey;
           int semid;
           struct sembuf sbuf;
           union semun {
               int val;
               struct semid_ds *buf;
               unsigned short *array;
           } arg;
           struct semid_ds ds;
           ...
           /* Get unique key for semaphore. */
           if ((semkey = ftok("<a href="file:/tmp">/tmp</a>", 'a')) == (key_t) -1) {
               perror("IPC error: ftok"); <a href="../man1/exit.1.html">exit</a>(1);
           }

           /* Get semaphore ID associated with this key. */
           if ((semid = semget(semkey, 0, 0)) == -1) {

               /* Semaphore does not exist - Create. */
               if ((semid = semget(semkey, 1, IPC_CREAT | IPC_EXCL | S_IRUSR |
                   S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) != -1)
               {
                   /* Initialize the semaphore. */
                   arg.val = 0;
                   sbuf.sem_num = 0;
                   sbuf.sem_op = 2;  /* This is the number of runs without queuing. */
                   sbuf.sem_flg = 0;
                   if (semctl(semid, 0, SETVAL, arg) == -1
                       || semop(semid, &amp;sbuf, 1) == -1) {
                       perror("IPC error: semop"); <a href="../man1/exit.1.html">exit</a>(1);
                   }
               }
               else if (errno == EEXIST) {
                   if ((semid = semget(semkey, 0, 0)) == -1) {
                       perror("IPC error 1: semget"); <a href="../man1/exit.1.html">exit</a>(1);
                   }
                   goto check_init;
               }
               else {
                   perror("IPC error 2: semget"); <a href="../man1/exit.1.html">exit</a>(1);
               }
           }
           else
           {
               /* Check that semid has completed initialization. */
               /* An application can use a retry loop at this point rather than
                  exiting. */
               check_init:
               arg.buf = &amp;ds;
               if (semctl(semid, 0, IPC_STAT, arg) &lt; 0) {
                   perror("IPC error 3: semctl"); <a href="../man1/exit.1.html">exit</a>(1);
               }
               if (ds.sem_otime == 0) {
                   perror("IPC error 4: semctl"); <a href="../man1/exit.1.html">exit</a>(1);
               }
           }
           ...
           sbuf.sem_num = 0;
           sbuf.sem_op = -1;
           sbuf.sem_flg = SEM_UNDO;
           if (semop(semid, &amp;sbuf, 1) == -1) {
               perror("IPC Error: semop"); <a href="../man1/exit.1.html">exit</a>(1);
           }

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       The POSIX Realtime Extension defines alternative interfaces for interprocess  communication.  Application
       developers  who  need  to use IPC should design their applications so that modules using the IPC routines
       described in <u>Section</u> <u>2.7</u>, <u>XSI</u> <u>Interprocess</u> <u>Communication</u> can be easily modified to  use  the  alternative
       interfaces.

</pre><h4><b>RATIONALE</b></h4><pre>
       None.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u>  <u>2.7</u>,  <u>XSI</u>  <u>Interprocess</u>  <u>Communication</u>,  <u>Section</u>  <u>2.8</u>, <u>Realtime</u>, <u>exec</u>, <u>exit</u>(), <u>fork</u>(), <u>semctl</u>(),
       <u>semget</u>(), <u>sem_close</u>(), <u>sem_destroy</u>(), <u>sem_getvalue</u>(), <u>sem_init</u>(), <u>sem_open</u>(), <u>sem_post</u>(),  <u>sem_trywait</u>(),
       <u>sem_unlink</u>()

       The  Base  Definitions  volume  of  POSIX.1‐2017,  <u>Section</u>  <u>4.17</u>,  <u>Semaphore</u>,  <b>&lt;sys_ipc.h&gt;</b>,  <b>&lt;sys_sem.h&gt;</b>,
       <b>&lt;sys_types.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                         <u><a href="../man3POSIX/SEMOP.3POSIX.html">SEMOP</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>