<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sem_wait, sem_timedwait, sem_trywait - lock a semaphore</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sem_wait, sem_timedwait, sem_trywait - lock a semaphore

</pre><h4><b>LIBRARY</b></h4><pre>
       POSIX threads library (<u>libpthread</u>, <u>-lpthread</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/semaphore.h">semaphore.h</a>&gt;</b>

       <b>int</b> <b>sem_wait(sem_t</b> <b>*</b><u>sem</u><b>);</b>
       <b>int</b> <b>sem_trywait(sem_t</b> <b>*</b><u>sem</u><b>);</b>
       <b>int</b> <b>sem_timedwait(sem_t</b> <b>*restrict</b> <u>sem</u><b>,</b>
                         <b>const</b> <b>struct</b> <b>timespec</b> <b>*restrict</b> <u>abs_timeout</u><b>);</b>

   Feature Test Macro Requirements for glibc (see <b><a href="../man7/feature_test_macros.7.html">feature_test_macros</a></b>(7)):

       <b>sem_timedwait</b>():
           _POSIX_C_SOURCE &gt;= 200112L

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sem_wait</b>()  decrements (locks) the semaphore pointed to by <u>sem</u>.  If the semaphore's value is greater than
       zero, then the decrement proceeds, and the function returns, immediately.  If the semaphore currently has
       the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the
       semaphore value rises above zero), or a signal handler interrupts the call.

       <b>sem_trywait</b>() is the same as <b>sem_wait</b>(), except that if the decrement cannot  be  immediately  performed,
       then call returns an error (<u>errno</u> set to <b>EAGAIN</b>) instead of blocking.

       <b>sem_timedwait</b>()  is  the  same  as <b>sem_wait</b>(), except that <u>abs_timeout</u> specifies a limit on the amount of
       time that the call should block if the  decrement  cannot  be  immediately  performed.   The  <u>abs_timeout</u>
       argument  points to a <b><a href="../man3/timespec.3.html">timespec</a></b>(3) structure that specifies an absolute timeout in seconds and nanoseconds
       since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).

       If the timeout has already expired by the time of the  call,  and  the  semaphore  could  not  be  locked
       immediately, then <b>sem_timedwait</b>() fails with a timeout error (<u>errno</u> set to <b>ETIMEDOUT</b>).

       If  the  operation  can  be performed immediately, then <b>sem_timedwait</b>() never fails with a timeout error,
       regardless of the value of <u>abs_timeout</u>.  Furthermore, the validity of <u>abs_timeout</u> is not checked in  this
       case.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       All of these functions return 0 on success; on error, the value of the semaphore is left unchanged, -1 is
       returned, and <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EAGAIN</b> (<b>sem_trywait</b>())  The  operation  could  not  be  performed  without  blocking (i.e., the semaphore
              currently has the value zero).

       <b>EINTR</b>  The call was interrupted by a signal handler; see <b><a href="../man7/signal.7.html">signal</a></b>(7).

       <b>EINVAL</b> <u>sem</u> is not a valid semaphore.

       <b>EINVAL</b> (<b>sem_timedwait</b>()) The value of <u>abs_timeout.tv_nsecs</u> is less than 0, or greater than  or  equal  to
              1000 million.

       <b>ETIMEDOUT</b>
              (<b>sem_timedwait</b>()) The call timed out before the semaphore could be locked.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────┐
       │ <b>Interface</b>                                                                   │ <b>Attribute</b>     │ <b>Value</b>   │
       ├─────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────┤
       │ <b>sem_wait</b>(), <b>sem_trywait</b>(), <b>sem_timedwait</b>()                                  │ Thread safety │ MT-Safe │
       └─────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────┘

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  (somewhat  trivial)  program  shown below operates on an unnamed semaphore.  The program expects two
       command-line arguments.  The first argument specifies a seconds value that is used to set an alarm  timer
       to  generate  a  <b>SIGALRM</b>  signal.  This handler performs a <b><a href="../man3/sem_post.3.html">sem_post</a></b>(3) to increment the semaphore that is
       being waited on in <u>main()</u> using <b>sem_timedwait</b>().  The second command-line argument specifies  the  length
       of  the timeout, in seconds, for <b>sem_timedwait</b>().  The following shows what happens on two different runs
       of the program:

           $ <b>./a.out</b> <b>2</b> <b>3</b>
           About to call sem_timedwait()
           sem_post() from handler
           sem_timedwait() succeeded
           $ <b>./a.out</b> <b>2</b> <b>1</b>
           About to call sem_timedwait()
           sem_timedwait() timed out

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
       #include &lt;<a href="file:/usr/include/semaphore.h">semaphore.h</a>&gt;
       #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       #include &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;

       sem_t sem;

       #define <a href="../manmsg/handle_error.msg.html">handle_error</a>(msg) \
           do { <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); } while (0)

       static void
       handler(int sig)
       {
           write(STDOUT_FILENO, "sem_post() from handler\n", 24);
           if (sem_post(&amp;sem) == -1) {
               write(STDERR_FILENO, "sem_post() failed\n", 18);
               _exit(EXIT_FAILURE);
           }
       }

       int
       main(int argc, char *argv[])
       {
           struct sigaction sa;
           struct timespec ts;
           int s;

           if (argc != 3) {
               fprintf(stderr, "Usage: %s &lt;alarm-secs&gt; &lt;wait-secs&gt;\n",
                       argv[0]);
               exit(EXIT_FAILURE);
           }

           if (sem_init(&amp;sem, 0, 0) == -1)
               handle_error("sem_init");

           /* Establish SIGALRM handler; set alarm timer using argv[1]. */

           sa.sa_handler = handler;
           sigemptyset(&amp;sa.sa_mask);
           sa.sa_flags = 0;
           if (sigaction(SIGALRM, &amp;sa, NULL) == -1)
               handle_error("sigaction");

           alarm(atoi(argv[1]));

           /* Calculate relative interval as current time plus
              number of seconds given argv[2]. */

           if (clock_gettime(CLOCK_REALTIME, &amp;ts) == -1)
               handle_error("clock_gettime");

           ts.tv_sec += atoi(argv[2]);

           printf("%s() about to call sem_timedwait()\n", __func__);
           while ((s = sem_timedwait(&amp;sem, &amp;ts)) == -1 &amp;&amp; errno == EINTR)
               continue;       /* Restart if interrupted by handler. */

           /* Check what happened. */

           if (s == -1) {
               if (errno == ETIMEDOUT)
                   printf("sem_timedwait() timed out\n");
               else
                   perror("sem_timedwait");
           } else
               printf("sem_timedwait() succeeded\n");

           exit((s == 0) ? EXIT_SUCCESS : EXIT_FAILURE);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/clock_gettime.2.html">clock_gettime</a></b>(2), <b><a href="../man3/sem_getvalue.3.html">sem_getvalue</a></b>(3), <b><a href="../man3/sem_post.3.html">sem_post</a></b>(3), <b><a href="../man3/timespec.3.html">timespec</a></b>(3), <b><a href="../man7/sem_overview.7.html">sem_overview</a></b>(7), <b><a href="../man7/time.7.html">time</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                        <u><a href="../man3/sem_wait.3.html">sem_wait</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>