<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>epp - An Erlang code preprocessor.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       epp - An Erlang code preprocessor.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  Erlang code preprocessor includes functions that are used by the <u>compile</u> module to preprocess macros
       and include files before the parsing takes place.

       The Erlang source file <u>encoding</u> is selected by a comment in one of the first  two  lines  of  the  source
       file.  The  first  string  matching  the  regular  expression <u>coding\s*[:=]\s*([-a-zA-Z0-9])+</u> selects the
       encoding. If the matching string is not a valid encoding, it is ignored. The valid encodings are  <u>Latin-1</u>
       and <u>UTF-8</u>, where the case of the characters can be chosen freely.

       <u>Examples:</u>

       %% coding: utf-8

       %% For this file we have chosen encoding = Latin-1

       %% -*- coding: latin-1 -*-

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>macros()</b> =
           [atom() | {atom(), term()} | {atom(), term(), redefine}]

       <b>epp_handle()</b> = pid()

              Handle to the <u>epp</u> server.

       <b>source_encoding()</b> = latin1 | utf8

       <b>warning_info()</b> = {erl_anno:location(), module(), term()}

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>close(Epp)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Epp = epp_handle()

              Closes the preprocessing of a file.

       <b>default_encoding()</b> <b>-&gt;</b> <b>source_encoding()</b>

              Returns the default encoding of Erlang source files.

       <b>encoding_to_string(Encoding)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Encoding = source_encoding()

              Returns  a  string  representation  of an encoding. The string is recognized by <u>read_encoding/1,2</u>,
              <u>read_encoding_from_binary/1,2</u>, and <u>set_encoding/1,2</u> as a valid encoding.

       <b>format_error(ErrorDescriptor)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

              Types:

                 ErrorDescriptor = term()

              Takes an <u>ErrorDescriptor</u> and returns a string that describes the error or warning.  This  function
              is   usually  called  implicitly  when  processing  an  <u>ErrorInfo</u>  structure  (see  section  Error
              Information).

       <b>open(Options)</b> <b>-&gt;</b>
               {ok, Epp} | {ok, Epp, Extra} | {error, ErrorDescriptor}

              Types:

                 Options =
                     [{default_encoding, DefEncoding :: source_encoding()} |
                      {includes, IncludePath :: [DirectoryName :: file:name()]} |
                      {source_name, SourceName :: file:name()} |
                      {macros, PredefMacros :: macros()} |
                      {name, FileName :: file:name()} |
                      {location, StartLocation :: erl_anno:location()} |
                      {fd, FileDescriptor :: file:io_device()} |
                      extra]
                 Epp = epp_handle()
                 Extra = [{encoding, source_encoding() | none}]
                 ErrorDescriptor = term()

              Opens a file for preprocessing.

              If you want  to  change  the  file  name  of  the  implicit  -file()  attributes  inserted  during
              preprocessing,  you can do with <u>{source_name,</u> <u>SourceName}</u>. If unset it will default to the name of
              the opened file.

              If <u>extra</u> is specified in <u>Options</u>, the return value is <u>{ok,</u> <u>Epp,</u> <u>Extra}</u> instead of <u>{ok,</u> <u>Epp}</u>.

              The option <u>location</u> is forwarded to the Erlang token scanner, see <u>erl_scan:tokens/3,4</u>.

       <b>open(FileName,</b> <b>IncludePath)</b> <b>-&gt;</b>
               {ok, Epp} | {error, ErrorDescriptor}

              Types:

                 FileName = file:name()
                 IncludePath = [DirectoryName :: file:name()]
                 Epp = epp_handle()
                 ErrorDescriptor = term()

              Equivalent to <u>epp:open([{name,</u> <u>FileName},</u> <u>{includes,</u> <u>IncludePath}])</u>.

       <b>open(FileName,</b> <b>IncludePath,</b> <b>PredefMacros)</b> <b>-&gt;</b>
               {ok, Epp} | {error, ErrorDescriptor}

              Types:

                 FileName = file:name()
                 IncludePath = [DirectoryName :: file:name()]
                 PredefMacros = macros()
                 Epp = epp_handle()
                 ErrorDescriptor = term()

              Equivalent to <u>epp:open([{name,</u> <u>FileName},</u> <u>{includes,</u> <u>IncludePath},</u> <u>{macros,</u> <u>PredefMacros}])</u>.

       <b>parse_erl_form(Epp)</b> <b>-&gt;</b>
                         {ok, AbsForm} |
                         {error, ErrorInfo} |
                         {warning, WarningInfo} |
                         {eof, Location}

              Types:

                 Epp = epp_handle()
                 AbsForm = erl_parse:abstract_form()
                 Location = erl_anno:location()
                 ErrorInfo = erl_scan:error_info() | erl_parse:error_info()
                 WarningInfo = warning_info()

              Returns the next Erlang form from the opened Erlang source file. Tuple <u>{eof,</u> <u>Location}</u> is returned
              at the end of the file. The first form corresponds to an implicit attribute <u>-file(File,1).</u>,  where
              <u>File</u> is the file name.

       <b>parse_file(FileName,</b> <b>Options)</b> <b>-&gt;</b>
                     {ok, [Form]} |
                     {ok, [Form], Extra} |
                     {error, OpenError}

              Types:

                 FileName = file:name()
                 Options =
                     [{includes, IncludePath :: [DirectoryName :: file:name()]} |
                      {source_name, SourceName :: file:name()} |
                      {macros, PredefMacros :: macros()} |
                      {default_encoding, DefEncoding :: source_encoding()} |
                      {location, StartLocation :: erl_anno:location()} |
                      extra]
                 Form =
                     erl_parse:abstract_form() |
                     {error, ErrorInfo} |
                     {eof, Location}
                 Location = erl_anno:location()
                 ErrorInfo = erl_scan:error_info() | erl_parse:error_info()
                 Extra = [{encoding, source_encoding() | none}]
                 OpenError = file:posix() | badarg | system_limit

              Preprocesses  and  parses an Erlang source file. Notice that tuple <u>{eof,</u> <u>Location}</u> returned at the
              end of the file is included as a "form".

              If you want  to  change  the  file  name  of  the  implicit  -file()  attributes  inserted  during
              preprocessing,  you can do with <u>{source_name,</u> <u>SourceName}</u>. If unset it will default to the name of
              the opened file.

              If <u>extra</u> is specified in <u>Options</u>, the return value is <u>{ok,</u> <u>[Form],</u> <u>Extra}</u> instead of <u>{ok,</u> <u>[Form]}</u>.

              The option <u>location</u> is forwarded to the Erlang token scanner, see <u>erl_scan:tokens/3,4</u>.

       <b>parse_file(FileName,</b> <b>IncludePath,</b> <b>PredefMacros)</b> <b>-&gt;</b>
                     {ok, [Form]} | {error, OpenError}

              Types:

                 FileName = file:name()
                 IncludePath = [DirectoryName :: file:name()]
                 Form =
                     erl_parse:abstract_form() |
                     {error, ErrorInfo} |
                     {eof, Location}
                 PredefMacros = macros()
                 Location = erl_anno:location()
                 ErrorInfo = erl_scan:error_info() | erl_parse:error_info()
                 OpenError = file:posix() | badarg | system_limit

              Equivalent to <u>epp:parse_file(FileName,</u> <u>[{includes,</u> <u>IncludePath},</u> <u>{macros,</u> <u>PredefMacros}])</u>.

       <b>read_encoding(FileName)</b> <b>-&gt;</b> <b>source_encoding()</b> <b>|</b> <b>none</b>

       <b>read_encoding(FileName,</b> <b>Options)</b> <b>-&gt;</b> <b>source_encoding()</b> <b>|</b> <b>none</b>

              Types:

                 FileName = file:name()
                 Options = [Option]
                 Option = {in_comment_only, boolean()}

              Read the encoding from a file. Returns the read encoding, or <u>none</u> if no valid encoding is found.

              Option <u>in_comment_only</u> is <u>true</u> by default, which is correct for Erlang source  files.  If  set  to
              <u>false</u>, the encoding string does not necessarily have to occur in a comment.

       <b>read_encoding_from_binary(Binary)</b> <b>-&gt;</b> <b>source_encoding()</b> <b>|</b> <b>none</b>

       <b>read_encoding_from_binary(Binary,</b> <b>Options)</b> <b>-&gt;</b>
                                    source_encoding() | none

              Types:

                 Binary = binary()
                 Options = [Option]
                 Option = {in_comment_only, boolean()}

              Read the encoding from a binary. Returns the read encoding, or <u>none</u> if no valid encoding is found.

              Option  <u>in_comment_only</u>  is  <u>true</u>  by default, which is correct for Erlang source files. If set to
              <u>false</u>, the encoding string does not necessarily have to occur in a comment.

       <b>scan_erl_form(Epp)</b> <b>-&gt;</b>
                        {ok, Tokens} |
                        {error, ErrorInfo} |
                        {warning, WarningInfo} |
                        {eof, Line}

              Types:

                 Epp = epp_handle()
                 Tokens = erl_scan:tokens()
                 Line = erl_anno:line()
                 ErrorInfo = erl_scan:error_info() | erl_parse:error_info()
                 WarningInfo = warning_info()

              Returns the raw tokens of the next Erlang form from the opened Erlang source file. A  tuple  <u>{eof,</u>
              <u>Line}</u>  is  returned  at  the  end of the file. The first form corresponds to an implicit attribute
              <u>-file(File,1).</u>, where <u>File</u> is the file name.

       <b>scan_file(FileName,</b> <b>Options)</b> <b>-&gt;</b>
                    {ok, [Form], Extra} | {error, OpenError}

              Types:

                 FileName = file:name()
                 Options =
                     [{includes, IncludePath :: [DirectoryName :: file:name()]} |
                      {source_name, SourceName :: file:name()} |
                      {macros, PredefMacros :: macros()} |
                      {default_encoding, DefEncoding :: source_encoding()}]
                 Form = erl_scan:tokens() | {error, ErrorInfo} | {eof, Loc}
                 Loc = erl_anno:location()
                 ErrorInfo = erl_scan:error_info()
                 Extra = [{encoding, source_encoding() | none}]
                 OpenError = file:posix() | badarg | system_limit

              Preprocesses an Erlang source file returning a list of the lists  of  raw  tokens  of  each  form.
              Notice that the tuple <u>{eof,</u> <u>Line}</u> returned at the end of the file is included as a "form", and any
              failures to scan a form are included in the list as tuples <u>{error,</u> <u>ErrorInfo}</u>.

       <b>set_encoding(File)</b> <b>-&gt;</b> <b>source_encoding()</b> <b>|</b> <b>none</b>

              Types:

                 File = io:device()

              Reads  the  encoding  from  an  I/O  device  and  sets the encoding of the device accordingly. The
              position of the I/O device referenced by <u>File</u> is not affected. If no valid encoding  can  be  read
              from the I/O device, the encoding of the I/O device is set to the default encoding.

              Returns the read encoding, or <u>none</u> if no valid encoding is found.

       <b>set_encoding(File,</b> <b>Default)</b> <b>-&gt;</b> <b>source_encoding()</b> <b>|</b> <b>none</b>

              Types:

                 Default = source_encoding()
                 File = io:device()

              Reads  the  encoding  from  an  I/O  device  and  sets the encoding of the device accordingly. The
              position of the I/O device referenced by <u>File</u> is not affected. If no valid encoding  can  be  read
              from the I/O device, the encoding of the I/O device is set to the encoding specified by <u>Default</u>.

              Returns the read encoding, or <u>none</u> if no valid encoding is found.

</pre><h4><b>ERROR</b> <b>INFORMATION</b></h4><pre>
       <u>ErrorInfo</u>  is  the  standard  <u>ErrorInfo</u> structure that is returned from all I/O modules. The format is as
       follows:

       {ErrorLine, Module, ErrorDescriptor}

       A string describing the error is obtained with the following call:

       Module:format_error(ErrorDescriptor)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/erl_parse.3erl.html">erl_parse</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                                         <u><a href="../man3erl/epp.3erl.html">epp</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>