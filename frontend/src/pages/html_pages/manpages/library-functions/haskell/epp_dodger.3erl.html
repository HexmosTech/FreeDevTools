<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>epp_dodger - epp_dodger - bypasses the Erlang preprocessor.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       epp_dodger - epp_dodger - bypasses the Erlang preprocessor.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>epp_dodger</u> - bypasses the Erlang preprocessor.

       This  module  tokenises  and parses most Erlang source code without expanding preprocessor directives and
       macro applications, as long as these are syntactically "well-behaved". Because the normal parse trees  of
       the  <u>erl_parse</u>  module  cannot  represent  these  things  (normally,  they  are  expanded  by  the Erlang
       preprocessor <a href="../man3erl/epp.3erl.html">epp</a>(3erl) before the parser sees them), an  extended  syntax  tree  is  created,  using  the
       erl_syntax module.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <b>errorinfo()</b> <b>=</b> <b>erl_scan:error_info():</b>

         <b>option()</b> <b>=</b> <b>atom()</b> <b>|</b> <b>{atom(),</b> <b>term()}:</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>parse(Dev::file:io_device())</b> <b>-&gt;</b> <b>{ok,</b> <b>erl_syntax:forms()}</b>

              Equivalent to parse(IODevice, 1).

       <b>parse(Dev::file:io_device(),</b> <b>L::erl_anno:location())</b> <b>-&gt;</b> <b>{ok,</b> <b>erl_syntax:forms()}</b>

              Equivalent to parse(IODevice, StartLocation, []).

              <u>See</u> <u>also:</u> parse/1.

       <b>parse(Dev::file:io_device(),</b> <b>L0::erl_anno:location(),</b> <b>Options::[option()])</b> <b>-&gt;</b> <b>{ok,</b> <b>erl_syntax:forms()}</b>

              Reads  and parses program text from an I/O stream. Characters are read from <u>IODevice</u> until end-of-
              file; apart from this, the behaviour is the same as for parse_file/2. <u>StartLocation</u> is the initial
              location.

              <u>See</u> <u>also:</u> parse/2, parse_file/2, parse_form/2, quick_parse/3.

       <b>parse_file(File::file:filename())</b> <b>-&gt;</b> <b>{ok,</b> <b>erl_syntax:forms()}</b> <b>|</b> <b>{error,</b> <b>errorinfo()}</b>

              Equivalent to parse_file(File, []).

       <b>parse_file(File::file:filename(),</b> <b>Options::[option()])</b> <b>-&gt;</b> <b>{ok,</b> <b>erl_syntax:forms()}</b> <b>|</b> <b>{error,</b> <b>errorinfo()}</b>

              Reads and parses a file. If successful, <u>{ok,</u> <u>Forms}</u> is returned, where <u>Forms</u> is a list of abstract
              syntax trees representing the "program forms" of the file (cf.  <u>erl_syntax:is_form/1</u>).  Otherwise,
              <u>{error,</u>  <u>errorinfo()}</u>  is  returned,  typically  if  the file could not be opened. Note that parse
              errors show up as error markers in the returned list of forms; they do not cause this function  to
              fail or return <u>{error,</u> <u>errorinfo()}</u>.

              Options:

                <u>{no_fail,</u> <u>boolean()}</u>:
                  If  <u>true</u>,  this makes <u>epp_dodger</u> replace any program forms that could not be parsed with nodes
                  of type <u>text</u> (see erl_syntax:text/1), representing the raw token sequence of the form, instead
                  of reporting a parse error. The default value is <u>false</u>.

                <u>{clever,</u> <u>boolean()}</u>:
                  If set to <u>true</u>, this makes <u>epp_dodger</u> try to repair the  source  code  as  it  seems  fit,  in
                  certain  cases  where parsing would otherwise fail. Currently, it inserts <u>++</u>-operators between
                  string literals and macros where it looks like concatenation was intended. The  default  value
                  is <u>false</u>.

              <u>See</u> <u>also:</u> parse/2, quick_parse_file/1, erl_syntax:is_form/1.

       <b>parse_form(Dev::file:io_device(),</b>      <b>L0::erl_anno:location())</b>      <b>-&gt;</b>      <b>{ok,</b>     <b>erl_syntax:forms(),</b>
       <b>erl_anno:location()}</b> <b>|</b> <b>{eof,</b> <b>erl_anno:location()}</b> <b>|</b> <b>{error,</b> <b>errorinfo(),</b> <b>erl_anno:location()}</b>

              Equivalent to parse_form(IODevice, StartLocation, []).

              <u>See</u> <u>also:</u> quick_parse_form/2.

       <b>parse_form(Dev::file:io_device(),</b>     <b>L0::erl_anno:location(),</b>     <b>Options::[option()])</b>      <b>-&gt;</b>      <b>{ok,</b>
       <b>erl_syntax:forms(),</b>   <b>erl_anno:location()}</b>   <b>|</b>   <b>{eof,</b>   <b>erl_anno:location()}</b>   <b>|</b>   <b>{error,</b>  <b>errorinfo(),</b>
       <b>erl_anno:location()}</b>

              Reads and parses a single program form from an I/O stream. Characters are read from <u>IODevice</u> until
              an end-of-form marker is found (a period character followed by whitespace), or until  end-of-file;
              apart  from  this, the behaviour is similar to that of <u>parse/3</u>, except that the return values also
              contain the final location given that <u>StartLocation</u>  is  the  initial  location,  and  that  <u>{eof,</u>
              <u>Location}</u> may be returned.

              <u>See</u> <u>also:</u> parse/3, parse_form/2, quick_parse_form/3.

       <b>quick_parse(Dev::file:io_device())</b> <b>-&gt;</b> <b>{ok,</b> <b>erl_syntax:forms()}</b>

              Equivalent to quick_parse(IODevice, 1).

       <b>quick_parse(Dev::file:io_device(),</b> <b>L::erl_anno:location())</b> <b>-&gt;</b> <b>{ok,</b> <b>erl_syntax:forms()}</b>

              Equivalent to quick_parse(IODevice, StartLocation, []).

              <u>See</u> <u>also:</u> quick_parse/1.

       <b>quick_parse(Dev::file:io_device(),</b>      <b>L0::erl_anno:location(),</b>     <b>Options::[option()])</b>     <b>-&gt;</b>     <b>{ok,</b>
       <b>erl_syntax:forms()}</b>

              Similar to parse/3, but does a more quick-and-dirty processing of the code. See quick_parse_file/2
              for details.

              <u>See</u> <u>also:</u> parse/3, quick_parse/2, quick_parse_file/2, quick_parse_form/2.

       <b>quick_parse_file(File::file:filename())</b> <b>-&gt;</b> <b>{ok,</b> <b>erl_syntax:forms()}</b> <b>|</b> <b>{error,</b> <b>errorinfo()}</b>

              Equivalent to quick_parse_file(File, []).

       <b>quick_parse_file(File::file:filename(),</b>  <b>Options::[option()])</b>  <b>-&gt;</b>  <b>{ok,</b>  <b>erl_syntax:forms()}</b>  <b>|</b>   <b>{error,</b>
       <b>errorinfo()}</b>

              Similar to parse_file/2, but does a more quick-and-dirty processing of the code. Macro definitions
              and other preprocessor directives are discarded, and all macro calls are replaced with atoms. This
              is  useful  when  only  the  main  structure  of  the  code  is  of interest, and not the details.
              Furthermore, the quick-parse method can usually handle more strange cases than  the  normal,  more
              exact parsing.

              Options: see parse_file/2. Note however that for <u>quick_parse_file/2</u>, the option <u>no_fail</u> is <u>true</u> by
              default.

              <u>See</u> <u>also:</u> parse_file/2, quick_parse/2.

       <b>quick_parse_form(Dev::file:io_device(),</b>     <b>L0::erl_anno:location())</b>    <b>-&gt;</b>    <b>{ok,</b>    <b>erl_syntax:forms(),</b>
       <b>erl_anno:location()}</b> <b>|</b> <b>{eof,</b> <b>erl_anno:location()}</b> <b>|</b> <b>{error,</b> <b>errorinfo(),</b> <b>erl_anno:location()}</b>

              Equivalent to quick_parse_form(IODevice, StartLocation, []).

              <u>See</u> <u>also:</u> parse_form/2.

       <b>quick_parse_form(Dev::file:io_device(),</b>    <b>L0::erl_anno:location(),</b>    <b>Options::[option()])</b>    <b>-&gt;</b>    <b>{ok,</b>
       <b>erl_syntax:forms(),</b>   <b>erl_anno:location()}</b>   <b>|</b>   <b>{eof,</b>   <b>erl_anno:location()}</b>   <b>|</b>   <b>{error,</b>  <b>errorinfo(),</b>
       <b>erl_anno:location()}</b>

              Similar  to  parse_form/3,  but  does  a  more  quick-and-dirty  processing  of  the   code.   See
              quick_parse_file/2 for details.

              <u>See</u> <u>also:</u> parse/3, parse_form/3, quick_parse_form/2.

       <b>tokens_to_string(Ts::[term()])</b> <b>-&gt;</b> <b>string()</b>

              Generates  a  string  corresponding to the given token sequence. The string can be re-tokenized to
              yield the same token list again.

</pre><h4><b>AUTHORS</b></h4><pre>
       Richard Carlsson <u>&lt;<a href="mailto:carlsson.richard@gmail.com">carlsson.richard@gmail.com</a>&gt;</u>

                                                syntax_tools 2.6                                <u><a href="../man3erl/epp_dodger.3erl.html">epp_dodger</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>