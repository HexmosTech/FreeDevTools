<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ct_rpc - Common Test specific layer on Erlang/OTP rpc.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ct_rpc - Common Test specific layer on Erlang/OTP rpc.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Common</u> <u>Test</u> specific layer on Erlang/OTP <u>rpc</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>app_node(App,</b> <b>Candidates)</b> <b>-&gt;</b> <b>NodeName</b>

              Types:

                 App = atom()
                 Candidates = [NodeName]
                 NodeName = atom()

              From  a set of candidate nodes determines which of them is running the application <u>App</u>. If none of
              the candidate nodes is running <u>App</u>, the function makes the test  case  calling  this  function  to
              fail. This function is the same as calling <u>app_node(App,</u> <u>Candidates,</u> <u>true)</u>.

       <b>app_node(App,</b> <b>Candidates,</b> <b>FailOnBadRPC)</b> <b>-&gt;</b> <b>NodeName</b>

              Types:

                 App = atom()
                 Candidates = [NodeName]
                 NodeName = atom()
                 FailOnBadRPC = true | false

              Same  as  <u>ct_rpc:app_node/2</u>,  except  that  argument  <u>FailOnBadRPC</u>  determines if the search for a
              candidate node is to stop if <u>badrpc</u> is received at some point.

       <b>app_node(App,</b> <b>Candidates,</b> <b>FailOnBadRPC,</b> <b>Cookie)</b> <b>-&gt;</b> <b>NodeName</b>

              Types:

                 App = atom()
                 Candidates = [NodeName]
                 NodeName = atom()
                 FailOnBadRPC = true | false
                 Cookie = atom()

              Same as <u>ct_rpc:app_node/2</u>, except that argument  <u>FailOnBadRPC</u>  determines  if  the  search  for  a
              candidate node is to stop if <u>badrpc</u> is received at some point.

              The  cookie  on  the client node is set to <u>Cookie</u> for this <u>rpc</u> operation (used to match the server
              node cookie).

       <b>call(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>term()</b> <b>|</b> <b>{badrpc,</b> <b>Reason}</b>

              Same as <u>call(Node,</u> <u>Module,</u> <u>Function,</u> <u>Args,</u> <u>infinity)</u>.

       <b>call(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>TimeOut)</b> <b>-&gt;</b> <b>term()</b> <b>|</b> <b>{badrpc,</b> <b>Reason}</b>

              Types:

                 Node = NodeName | {Fun, FunArgs}
                 Fun = function()
                 FunArgs = term()
                 NodeName = atom()
                 Module = atom()
                 Function = atom()
                 Args = [term()]
                 Reason = timeout | term()

              Evaluates <u>apply(Module,</u> <u>Function,</u> <u>Args)</u>  on  the  node  <u>Node</u>.  Returns  either  whatever  <u>Function</u>
              returns,  or  <u>{badrpc,</u>  <u>Reason}</u>  if  the  remote  procedure call fails. If <u>Node</u> is <u>{Fun,</u> <u>FunArgs}</u>,
              applying <u>Fun</u> to <u>FunArgs</u> is to return a node name.

       <b>call(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>TimeOut,</b> <b>Cookie)</b> <b>-&gt;</b> <b>term()</b> <b>|</b> <b>{badrpc,</b> <b>Reason}</b>

              Types:

                 Node = NodeName | {Fun, FunArgs}
                 Fun = function()
                 FunArgs = term()
                 NodeName = atom()
                 Module = atom()
                 Function = atom()
                 Args = [term()]
                 Reason = timeout | term()
                 Cookie = atom()

              Evaluates <u>apply(Module,</u> <u>Function,</u> <u>Args)</u>  on  the  node  <u>Node</u>.  Returns  either  whatever  <u>Function</u>
              returns,  or  <u>{badrpc,</u>  <u>Reason}</u>  if  the  remote  procedure call fails. If <u>Node</u> is <u>{Fun,</u> <u>FunArgs}</u>,
              applying <u>Fun</u> to <u>FunArgs</u> is to return a node name.

              The cookie on the client node is set to <u>Cookie</u> for this <u>rpc</u> operation (used to  match  the  server
              node cookie).

       <b>cast(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Node = NodeName | {Fun, FunArgs}
                 Fun = function()
                 FunArgs = term()
                 NodeName = atom()
                 Module = atom()
                 Function = atom()
                 Args = [term()]
                 Reason = timeout | term()

              Evaluates <u>apply(Module,</u> <u>Function,</u> <u>Args)</u> on the node <u>Node</u>. No response is delivered and the process
              that makes the call is not suspended until the evaluation is completed as in the case of <u>call/3,4</u>.
              If <u>Node</u> is <u>{Fun,</u> <u>FunArgs}</u>, applying <u>Fun</u> to <u>FunArgs</u> is to return a node name.

       <b>cast(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>Cookie)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Node = NodeName | {Fun, FunArgs}
                 Fun = function()
                 FunArgs = term()
                 NodeName = atom()
                 Module = atom()
                 Function = atom()
                 Args = [term()]
                 Reason = timeout | term()
                 Cookie = atom()

              Evaluates <u>apply(Module,</u> <u>Function,</u> <u>Args)</u> on the node <u>Node</u>. No response is delivered and the process
              that makes the call is not suspended until the evaluation is completed as in the case of <u>call/3,4</u>.
              If <u>Node</u> is <u>{Fun,</u> <u>FunArgs}</u>, applying <u>Fun</u> to <u>FunArgs</u> is to return a node name.

              The  cookie  on  the client node is set to <u>Cookie</u> for this <u>rpc</u> operation (used to match the server
              node cookie).

Ericsson AB                                     common_test 1.22                                    <u><a href="../man3erl/ct_rpc.3erl.html">ct_rpc</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>