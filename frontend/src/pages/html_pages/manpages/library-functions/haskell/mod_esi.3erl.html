<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mod_esi - Erlang Server Interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mod_esi - Erlang Server Interface

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  defines the Erlang Server Interface (ESI) API. It is a more efficient way of writing Erlang
       scripts for your <u>Inets</u> web server than writing them as common CGI scripts.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       The following data types are used in the functions for mod_esi:

         <u>env()</u> <u>=</u> :
           <u>{EnvKey()::atom(),</u> <u>Value::term()}</u>

           Currently supported key value pairs

           <u>{server_software,</u> <u>string()}</u>:
             Indicates the inets version.

           <u>{server_name,</u> <u>string()}</u>:
             The local hostname.

           <u>{gateway_interface,</u> <u>string()}</u>:
             Legacy string used in CGI, just ignore.

           <u>{server_protocol,</u> <u>string()}</u>:
             HTTP version, currently "HTTP/1.1"

           <u>{server_port,</u> <u>integer()}</u>:
             Servers port number.

           <u>{request_method,</u> <u>"GET</u> <u>|</u> <u>"PUT"</u> <u>|</u> <u>"DELETE"</u> <u>|</u> <u>"POST"</u> <u>|</u> <u>"PATCH"}</u>:
             HTTP request method.

           <u>{remote_adress,</u> <u>inet:ip_address()}</u> :
             The clients ip address.

           <u>{peer_cert,</u> <u>undefined</u> <u>|</u> <u>no_peercert</u> <u>|</u> <u>DER:binary()}</u>:
             For TLS connections  where  client  certificates  are  used  this  will  be  an  ASN.1  DER-encoded
             X509-certificate  as  an  Erlang  binary.  If  client  certificates  are not used the value will be
             <u>no_peercert</u>, and if TLS is not used (HTTP or connection is lost due to network failure)  the  value
             will be <u>undefined</u>.

           <u>{script_name,</u> <u>string()}</u>:
             Request URI

           <u>{http_LowerCaseHTTPHeaderName,</u> <u>string()}</u>:
             example: {http_content_type, "text/html"}

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>deliver(SessionID,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SessionID = term()
                 Data = string() | io_list() | binary()
                 Reason = term()

              This  function  is  <u>only</u>  intended to be used from functions called by the Erl Scheme interface to
              deliver parts of the content to the user.

              Sends data from an Erl Scheme script back to the client.

          <b>Note:</b>
              If any HTTP header fields are added by the script, they must be in the first  call  to  <u>deliver/2</u>,
              and the data in the call must be a string. Calls after the headers are complete can contain binary
              data  to  reduce  copying  overhead.  Do  not  assume  anything  about the data type of <u>SessionID</u>.
              <u>SessionID</u> must be the value given as input to the ESI callback function that you implemented.

</pre><h4><b>ESI</b> <b>CALLBACK</b> <b>FUNCTIONS</b></h4><pre>
</pre><h4><b>EXPORTS</b></h4><pre>
       <b>Module:Function(SessionID,</b> <b>Env,</b> <b>Input)-&gt;</b> <b>{continue,</b> <b>State}</b> <b>|</b> <b>_</b>

              Types:

                 SessionID = term()
                 Env = env()
                 Input = string() | chunked_data()
                 chunked_data() = {first, Data::binary()} | {continue, Data::binary(), State::term()}  |  {last,
                 Data::binary(), State::term()}
                 State = term()

              <u>Module</u>  must  be  found  in  the  code  path  and  export  <u>Function</u>  with  an  arity  of three. An
              <u>erlScriptAlias</u> must also be set up in the configuration file for the web server.

              <u>mod_esi:deliver/2</u> shall be used to generate the  response  to  the  client  and  <u>SessionID</u>  is  an
              identifier  that  shall  by  used  when  calling  this  function, do not assume anything about the
              datatype. This function may be called several times to chunk the response data.  Notice  that  the
              first  chunk  of  data  sent  to  the client must at least contain all HTTP header fields that the
              response will generate. If the first chunk does not contain the  <u>end</u>  <u>of</u>  <u>HTTP</u>  <u>header</u>,  that  is,
              <u>"\r\n\r\n",</u> the server assumes that no HTTP header fields will be generated.

              <u>Env</u> environment data of the request see description above.

              <u>Input</u>  is  query  data of a GET request or the body of a PUT or POST request. The default behavior
              (legacy reasons) for delivering the body, is that the whole body is gathered and  converted  to  a
              string. But if the httpd config parameter max_client_body_chunk is set, the body will be delivered
              as binary chunks instead. The maximum size of the chunks is either max_client_body_chunk or decide
              by the client if it uses HTTP chunked encoding to send the body. When using the chunking mechanism
              this  callback  must  return  {continue,  State::term()}  for  all  calls  where  <u>Input</u> is <u>{first,</u>
              <u>Data::binary()}</u> or <u>{continue,</u> <u>Data::binary(),</u> <u>State::term()}</u>. When <u>Input</u> is <u>{last,</u> <u>Data::binary(),</u>
              <u>State::term()}</u> the return value will be ignored.

          <b>Note:</b>
              Note that if the body is small all data may be delivered in only one chunk and then  the  callback
              will  be  called  with  {last,  Data::binary(),  undefined}  without  getting  called with <u>{first,</u>
              <u>Data::binary()}</u>.

              The input <u>State</u> is the last returned <u>State</u>, in it the callback can include any data that it  needs
              to keep track of when handling the chunks.

       <b>Module:Function(Env,</b> <b>Input)-&gt;</b> <b>Response</b>

              Types:

                 Env = env()
                 Input = string()
                 Response = string()

              This  callback  format  consumes much memory, as the whole response must be generated before it is
              sent to the user. This callback format is deprecated. For new development, use <u>Module:Function/3</u>.

Ericsson AB                                         inets 7.5                                      <u><a href="../man3erl/mod_esi.3erl.html">mod_esi</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>