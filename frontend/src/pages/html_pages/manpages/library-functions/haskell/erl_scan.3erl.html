<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>erl_scan - The Erlang token scanner.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       erl_scan - The Erlang token scanner.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module contains functions for tokenizing (scanning) characters into Erlang tokens.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>category()</b> = atom()

       <b>error_description()</b> = term()

       <b>error_info()</b> =
           {erl_anno:location(), module(), error_description()}

       <b>option()</b> =
           return | return_white_spaces | return_comments | text |
           {reserved_word_fun, resword_fun()}

       <b>options()</b> = option() | [option()]

       <b>symbol()</b> = atom() | float() | integer() | string()

       <b>resword_fun()</b> = fun((atom()) -&gt; boolean())

       <b>token()</b> =
           {category(), Anno :: erl_anno:anno(), symbol()} |
           {category(), Anno :: erl_anno:anno()}

       <b>tokens()</b> = [token()]

       <b>tokens_result()</b> =
           {ok, Tokens :: tokens(), EndLocation :: erl_anno:location()} |
           {eof, EndLocation :: erl_anno:location()} |
           {error,
            ErrorInfo :: error_info(),
            EndLocation :: erl_anno:location()}

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>category(Token)</b> <b>-&gt;</b> <b>category()</b>

              Types:

                 Token = token()

              Returns the category of <u>Token</u>.

       <b>column(Token)</b> <b>-&gt;</b> <b>erl_anno:column()</b> <b>|</b> <b>undefined</b>

              Types:

                 Token = token()

              Returns the column of <u>Token</u>'s collection of annotations.

       <b>end_location(Token)</b> <b>-&gt;</b> <b>erl_anno:location()</b> <b>|</b> <b>undefined</b>

              Types:

                 Token = token()

              Returns  the  end  location of the text of <u>Token</u>'s collection of annotations. If there is no text,
              <u>undefined</u> is returned.

       <b>format_error(ErrorDescriptor)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 ErrorDescriptor = error_description()

              Uses an <u>ErrorDescriptor</u> and returns a string that describes the error or warning. This function is
              usually  called  implicitly  when  an  <u>ErrorInfo</u>  structure  is  processed  (see   section   Error
              Information).

       <b>line(Token)</b> <b>-&gt;</b> <b>erl_anno:line()</b>

              Types:

                 Token = token()

              Returns the line of <u>Token</u>'s collection of annotations.

       <b>location(Token)</b> <b>-&gt;</b> <b>erl_anno:location()</b>

              Types:

                 Token = token()

              Returns the location of <u>Token</u>'s collection of annotations.

       <b>reserved_word(Atom</b> <b>::</b> <b>atom())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if <u>Atom</u> is an Erlang reserved word, otherwise <u>false</u>.

       <b>string(String)</b> <b>-&gt;</b> <b>Return</b>

       <b>string(String,</b> <b>StartLocation)</b> <b>-&gt;</b> <b>Return</b>

       <b>string(String,</b> <b>StartLocation,</b> <b>Options)</b> <b>-&gt;</b> <b>Return</b>

              Types:

                 String = string()
                 Options = options()
                 Return =
                     {ok, Tokens :: tokens(), EndLocation} |
                     {error, ErrorInfo :: error_info(), ErrorLocation}
                 StartLocation = EndLocation = ErrorLocation = erl_anno:location()

              Takes  the  list  of  characters  <u>String</u>  and  tries  to  scan (tokenize) them. Returns one of the
              following:

                <u>{ok,</u> <u>Tokens,</u> <u>EndLocation}</u>:
                  <u>Tokens</u> are the Erlang tokens from <u>String</u>. <u>EndLocation</u> is the first  location  after  the  last
                  token.

                <u>{error,</u> <u>ErrorInfo,</u> <u>ErrorLocation}</u>:
                  An error occurred. <u>ErrorLocation</u> is the first location after the erroneous token.

              <u>string(String)</u> is equivalent to <u>string(String,</u> <u>1)</u>, and <u>string(String,</u> <u>StartLocation)</u> is equivalent
              to <u>string(String,</u> <u>StartLocation,</u> <u>[])</u>.

              <u>StartLocation</u>  indicates  the  initial  location when scanning starts. If <u>StartLocation</u> is a line,
              <u>Anno</u>, <u>EndLocation</u>, and <u>ErrorLocation</u> are lines. If <u>StartLocation</u> is a pair of a line and a column,
              <u>Anno</u> takes the form of an opaque compound data type, and <u>EndLocation</u> and <u>ErrorLocation</u>  are  pairs
              of  a  line  and a column. The <u>token</u> <u>annotations</u> contain information about the column and the line
              where the token begins, as well as the text of the token (if option <u>text</u>  is  specified),  all  of
              which can be accessed by calling <u>column/1</u>, <u>line/1</u>, <u>location/1</u>, and <u>text/1</u>.

              A <u>token</u> is a tuple containing information about syntactic category, the token annotations, and the
              terminal symbol. For punctuation characters (such as <u>;</u> and <u>|</u>) and reserved words, the category and
              the  symbol  coincide,  and  the token is represented by a two-tuple. Three-tuples have one of the
              following forms:

                * <u>{atom,</u> <u>Anno,</u> <u>atom()}</u>

                * <u>{char,</u> <u>Anno,</u> <u>char()}</u>

                * <u>{comment,</u> <u>Anno,</u> <u>string()}</u>

                * <u>{float,</u> <u>Anno,</u> <u>float()}</u>

                * <u>{integer,</u> <u>Anno,</u> <u>integer()}</u>

                * <u>{var,</u> <u>Anno,</u> <u>atom()}</u>

                * <u>{white_space,</u> <u>Anno,</u> <u>string()}</u>

              Valid options:

                <u>{reserved_word_fun,</u> <u>reserved_word_fun()}</u>:
                  A callback function that is called when the  scanner  has  found  an  unquoted  atom.  If  the
                  function  returns  <u>true</u>,  the  unquoted  atom itself becomes the category of the token. If the
                  function returns <u>false</u>, <u>atom</u> becomes the category of the unquoted atom.

                <u>return_comments</u>:
                  Return comment tokens.

                <u>return_white_spaces</u>:
                  Return white space tokens. By convention, a newline character, if present, is always the first
                  character of the text (there cannot be more than one newline in a white space token).

                <u>return</u>:
                  Short for <u>[return_comments,</u> <u>return_white_spaces]</u>.

                <u>text</u>:
                  Include the token  text  in  the  token  annotation.  The  text  is  the  part  of  the  input
                  corresponding to the token.

       <b>symbol(Token)</b> <b>-&gt;</b> <b>symbol()</b>

              Types:

                 Token = token()

              Returns the symbol of <u>Token</u>.

       <b>text(Token)</b> <b>-&gt;</b> <b>erl_anno:text()</b> <b>|</b> <b>undefined</b>

              Types:

                 Token = token()

              Returns the text of <u>Token</u>'s collection of annotations. If there is no text, <u>undefined</u> is returned.

       <b>tokens(Continuation,</b> <b>CharSpec,</b> <b>StartLocation)</b> <b>-&gt;</b> <b>Return</b>

       <b>tokens(Continuation,</b> <b>CharSpec,</b> <b>StartLocation,</b> <b>Options)</b> <b>-&gt;</b> <b>Return</b>

              Types:

                 Continuation = return_cont() | []
                 CharSpec = char_spec()
                 StartLocation = erl_anno:location()
                 Options = options()
                 Return =
                     {done,
                      Result :: tokens_result(),
                      LeftOverChars :: char_spec()} |
                     {more, Continuation1 :: return_cont()}
                 <b>char_spec()</b> = string() | eof
                 <b>return_cont()</b>
                   An opaque continuation.

              This is the re-entrant scanner, which scans characters until either a <u>dot</u> ('.' followed by a white
              space) or <u>eof</u> is reached. It returns:

                <u>{done,</u> <u>Result,</u> <u>LeftOverChars}</u>:
                  Indicates that there is sufficient input data to get a result. <u>Result</u> is:

                  <u>{ok,</u> <u>Tokens,</u> <u>EndLocation}</u>:
                    The scanning was successful. <u>Tokens</u> is the list of tokens including <u>dot</u>.

                  <u>{eof,</u> <u>EndLocation}</u>:
                    End of file was encountered before any more tokens.

                  <u>{error,</u> <u>ErrorInfo,</u> <u>EndLocation}</u>:
                    An  error  occurred.  <u>LeftOverChars</u>  is the remaining characters of the input data, starting
                    from <u>EndLocation</u>.

                <u>{more,</u> <u>Continuation1}</u>:
                  More data is required for building a term. <u>Continuation1</u> must be  passed  in  a  new  call  to
                  <u>tokens/3,4</u> when more data is available.

              The <u>CharSpec</u> <u>eof</u> signals end of file. <u>LeftOverChars</u> then takes the value <u>eof</u> as well.

              <u>tokens(Continuation,</u>  <u>CharSpec,</u>  <u>StartLocation)</u>  is  equivalent  to <u>tokens(Continuation,</u> <u>CharSpec,</u>
              <u>StartLocation,</u> <u>[])</u>.

              For a description of the options, see <u>string/3</u>.

</pre><h4><b>ERROR</b> <b>INFORMATION</b></h4><pre>
       <u>ErrorInfo</u> is the standard <u>ErrorInfo</u> structure that is returned from all I/O modules.  The  format  is  as
       follows:

       {ErrorLocation, Module, ErrorDescriptor}

       A string describing the error is obtained with the following call:

       Module:format_error(ErrorDescriptor)

</pre><h4><b>NOTES</b></h4><pre>
       The  continuation  of  the  first  call  to  the  re-entrant  input  functions must be <u>[]</u>. For a complete
       description of how the re-entrant input scheme works, see Armstrong, Virding  and  Williams:  'Concurrent
       Programming in Erlang', Chapter 13.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/erl_anno.3erl.html">erl_anno</a>(3erl)</u>, <u><a href="../man3erl/erl_parse.3erl.html">erl_parse</a>(3erl)</u>, <u><a href="../man3erl/io.3erl.html">io</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                                    <u><a href="../man3erl/erl_scan.3erl.html">erl_scan</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>