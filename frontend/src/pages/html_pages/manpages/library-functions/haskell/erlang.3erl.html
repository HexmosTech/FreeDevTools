<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>erlang - The Erlang BIFs and predefined types.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       erlang - The Erlang BIFs and predefined types.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       By  convention, most Built-In Functions (BIFs) and all predefined types are included in this module. Some
       of the BIFs and all of the predefined types are viewed more or less as part  of  the  Erlang  programming
       language  and  are  <u>auto-imported</u>. Thus, it is not necessary to specify the module name. For example, the
       calls <u>atom_to_list(erlang)</u> and <u>erlang:atom_to_list(erlang)</u> are identical.

       Auto-imported BIFs are listed without module prefix.  BIFs  listed  with  module  prefix  are  not  auto-
       imported.

       Predefined types are listed in the Predefined datatypes section of this reference manual and in the Types
       and Function Specifications section of the Erlang Reference Manual.

       BIFs  can fail for various reasons. All BIFs fail with reason <u>badarg</u> if they are called with arguments of
       an incorrect type. The other reasons are described in the description of each individual BIF.

       Some BIFs can be used in guard tests and are marked with "Allowed in guard tests".

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
   <b>Predefined</b> <b>datatypes</b>
       <b>any()</b> = any()

              All possible Erlang terms. Synonym for <u>term()</u>.

       <b>arity()</b> = arity()

              The arity of a function or type.

       <b>atom()</b> = atom()

              An Erlang atom.

       <b>binary()</b> = &lt;&lt;_:_*8&gt;&gt;

              An Erlang binary, that is, a bitstring with a size divisible by 8.

       <b>bitstring()</b> = &lt;&lt;_:_*1&gt;&gt;

              An Erlang bitstring.

       <b>boolean()</b> = true | false

              A boolean value.

       <b>byte()</b> = 0..255

              A byte of data represented by an integer.

       <b>char()</b> = 0..1114111

              An ASCII character or a unicode codepoint presented by an integer.

       <b>float()</b> = float()

              An Erlang float.

       <b>function()</b> = function()

              An Erlang fun.

       <b>identifier()</b> = pid() | port() | reference()

              An unique identifier for some entity, for example a process, port or monitor.

       <b>integer()</b> = integer()

              An Erlang integer.

       <b>iodata()</b> = iolist() | binary()

              A binary or list containing bytes and/or iodata. This datatype is used to represent data  that  is
              meant to be output using any I/O module. For example: file:write/2 or gen_tcp:send/2.

              To  convert  an iodata() term to binary() you can use  iolist_to_binary/2. To transcode a string()
              or unicode:chardata() to iodata() you can use unicode:characters_to_binary/1.

       <b>iolist()</b> =
           maybe_improper_list(byte() | binary() | iolist(),
                               binary() | [])

              A list containing bytes and/or iodata. This datatype is used to represent data that is meant to be
              output using any I/O module. For example: file:write/2 or gen_tcp:send/2.

              In most use cases you want to use iodata() instead of this type.

       <b>list()</b> = list()

              An Erlang list containing terms of any type.

       <b>list(ContentType)</b> = [ContentType]

              An Erlang list containing terms of the type <u>ContentType</u>.

       <b>map()</b> = #{any() =&gt; any()}

              An Erlang map containing any number of key and value associations.

       <b>maybe_improper_list()</b> = maybe_improper_list(any(), any())

              An Erlang list that is not guaranteed to end with a [], and where the list elements can be of  any
              type.

       <b>maybe_improper_list(ContentType,</b> <b>TerminationType)</b> =
           maybe_improper_list(ContentType, TerminationType)

              An  Erlang  list,  that is not guaranteed to end with a [], and where the list elements are of the
              type <u>ContentType</u>.

       <b>mfa()</b> = {module(), atom(), arity()}

              A three-tuple representing a <u>Module:Function/Arity</u> function signature.

       <b>module()</b> = atom()

              An Erlang module represented by an atom.

       <b>neg_integer()</b> = integer() =&lt; -1

              A negative integer.

       <b>nil()</b> = []

              The empty list().

       <b>no_return()</b> = none()

              The type used to show that a function will <u>never</u> return a value, that is it will <u>always</u>  throw  an
              exception.

       <b>node()</b> = atom()

              An Erlang node represented by an atom.

       <b>non_neg_integer()</b> = integer() &gt;= 0

              A non-negative integer, that is any positive integer or 0.

       <b>none()</b> = none()

              This  type is used to show that a function will <u>never</u> return a value; that is it will <u>always</u> throw
              an exception. In a spec, use <u>no_return()</u> for the sake of clarity.

       <b>nonempty_binary()</b> = &lt;&lt;_:8, _:_*8&gt;&gt;

              A binary() that contains some data.

       <b>nonempty_bitstring()</b> = &lt;&lt;_:1, _:_*1&gt;&gt;

              A bitstring() that contains some data.

       <b>nonempty_improper_list(ContentType,</b> <b>TerminationType)</b> =
           nonempty_improper_list(ContentType, TerminationType)

              A maybe_improper_list/2 that contains some items.

       <b>nonempty_list()</b> = [any(), ...]

              A list() that contains some items.

       <b>nonempty_list(ContentType)</b> = [ContentType, ...]

              A list(ContentType) that contains some items.

       <b>nonempty_maybe_improper_list()</b> =
           nonempty_maybe_improper_list(any(), any())

              A maybe_improper_list() that contains some items.

       <b>nonempty_maybe_improper_list(ContentType,</b> <b>TerminationType)</b> =
           nonempty_maybe_improper_list(ContentType, TerminationType)

              A maybe_improper_list(ContentType, TerminationType) that contains some items.

       <b>nonempty_string()</b> = [char(), ...]

              A string() that contains some characters.

       <b>number()</b> = integer() | float()

              An Erlang number.

       <b>pid()</b> = pid()

              An Erlang process identifier.

       <b>port()</b> = port()

              An Erlang port identifier.

       <b>pos_integer()</b> = integer() &gt;= 1

              An integer greater than zero.

       <b>reference()</b> = reference()

              An Erlang reference.

       <b>string()</b> = [char()]

              A character string represented by a list of ASCII characters or unicode codepoints.

       <b>term()</b> = any()

              All possible Erlang terms. Synonym for <u>any()</u>.

       <b>timeout()</b> = infinity | integer() &gt;= 0

              A timeout value that can be passed to a receive expression.

       <b>tuple()</b> = tuple()

              An Erlang tuple.

   <b>Other</b> <b>Datatypes</b>
       <b>ext_binary()</b> = binary()

              A binary data object, structured according to the Erlang external term format.

       <b>ext_iovec()</b> = iovec()

              A term of type <u>iovec()</u>, structured according to the Erlang external term format.

       <b>iovec()</b> = [binary()]

              A list of binaries. This datatype is useful to use together with <u>enif_inspect_iovec</u>.

       <b>message_queue_data()</b> = off_heap | on_heap

              See <u>process_flag(message_queue_data,</u> <u>MQD)</u>.

       <b>monitor_option()</b> =
           {alias, explicit_unalias | demonitor | reply_demonitor} |
           {tag, term()}

              See <u>monitor/3</u>.

       <b>timestamp()</b> =
           {MegaSecs :: integer() &gt;= 0,
            Secs :: integer() &gt;= 0,
            MicroSecs :: integer() &gt;= 0}

              See <u>erlang:timestamp/0</u>.

       <b>time_unit()</b> =
           integer() &gt;= 1 |
           second | millisecond | microsecond | nanosecond | native |
           perf_counter |
           deprecated_time_unit()

              Supported time unit representations:

                <u>PartsPerSecond</u> <u>::</u> <u>integer()</u> <u>&gt;=</u> <u>1</u>:
                  Time unit expressed in parts per second.  That  is,  the  time  unit  equals  <u>1/PartsPerSecond</u>
                  second.

                <u>second</u>:
                  Symbolic representation of the time unit represented by the integer <u>1</u>.

                <u>millisecond</u>:
                  Symbolic representation of the time unit represented by the integer <u>1000</u>.

                <u>microsecond</u>:
                  Symbolic representation of the time unit represented by the integer <u>1000_000</u>.

                <u>nanosecond</u>:
                  Symbolic representation of the time unit represented by the integer <u>1000_000_000</u>.

                <u>native</u>:
                  Symbolic representation of the native time unit used by the Erlang runtime system.

                  The  <u>native</u>  time  unit  is determined at runtime system start, and remains the same until the
                  runtime system terminates. If a runtime system is stopped and then started again (even on  the
                  same  machine),  the  <u>native</u>  time unit of the new runtime system instance can differ from the
                  <u>native</u> time unit of the old runtime system instance.

                  One can get an approximation of the <u>native</u> time unit  by  calling  <u>erlang:convert_time_unit(1,</u>
                  <u>second,</u>  <u>native)</u>.  The  result equals the number of whole <u>native</u> time units per second. If the
                  number of <u>native</u> time units per second does not add up  to  a  whole  number,  the  result  is
                  rounded downwards.

            <b>Note:</b>
                The  value  of  the  <u>native</u> time unit gives you more or less no information about the quality of
                time values. It sets a limit for the  resolution and for the  precision of time values,  but  it
                gives  no information about the  accuracy of time values. The resolution of the <u>native</u> time unit
                and the resolution of time values can differ significantly.

                <u>perf_counter</u>:
                  Symbolic representation of the performance counter  time  unit  used  by  the  Erlang  runtime
                  system.

                  The  <u>perf_counter</u>  time unit behaves much in the same way as the <u>native</u> time unit. That is, it
                  can differ between runtime restarts. To get values of this type, call <u>os:perf_counter/0</u>.

                <u>deprecated_time_unit()</u>:
                  Deprecated symbolic representations kept for backwards-compatibility.

              The  <u>time_unit/0</u>  type  can  be  extended.  To  convert  time  values  between  time  units,   use
              <u>erlang:convert_time_unit/3</u>.

       <b>deprecated_time_unit()</b> =
           seconds | milli_seconds | micro_seconds | nano_seconds

              The <u>time_unit()</u> type also consist of the following <u>deprecated</u> symbolic time units:

                <u>seconds</u>:
                  Same as <u>second</u>.

                <u>milli_seconds</u>:
                  Same as <u>millisecond</u>.

                <u>micro_seconds</u>:
                  Same as <u>microsecond</u>.

                <u>nano_seconds</u>:
                  Same as <u>nanosecond</u>.

       <b>dist_handle()</b>

              An opaque handle identifing a distribution channel.

       <b>nif_resource()</b>

              An opaque handle identifing a NIF resource object .

       <b>spawn_opt_option()</b> =
           link | monitor |
           {monitor, MonitorOpts :: [monitor_option()]} |
           {priority, Level :: priority_level()} |
           {fullsweep_after, Number :: integer() &gt;= 0} |
           {min_heap_size, Size :: integer() &gt;= 0} |
           {min_bin_vheap_size, VSize :: integer() &gt;= 0} |
           {max_heap_size, Size :: max_heap_size()} |
           {message_queue_data, MQD :: message_queue_data()}

              Options for <u>spawn_opt()</u>.

       <b>priority_level()</b> = low | normal | high | max

              Process priority level. For more info see <u>process_flag(priority,</u> <u>Level)</u>

       <b>max_heap_size()</b> =
           integer() &gt;= 0 |
           #{size =&gt; integer() &gt;= 0,
             kill =&gt; boolean(),
             error_logger =&gt; boolean()}

              Process max heap size configuration. For more info see <u>process_flag(max_heap_size,</u> <u>MaxHeapSize)</u>

       <b>message_queue_data()</b> = off_heap | on_heap

              Process     message     queue     data     configuration.     For     more     information,    see
              <u>process_flag(message_queue_data,</u> <u>MQD)</u>

       <b>stacktrace()</b> =
           [{module(),
             atom(),
             arity() | [term()],
             [stacktrace_extrainfo()]} |
            {function(), arity() | [term()], [stacktrace_extrainfo()]}]

       <b>stacktrace_extrainfo()</b> =
           {line, integer() &gt;= 1} |
           {file, unicode:chardata()} |
           {error_info,
            #{module =&gt; module(), function =&gt; atom(), cause =&gt; term()}} |
           {atom(), term()}

              An Erlang stacktrace as described by Errors and Error Handling section  in  the  Erlang  Reference
              Manual.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>abs(Float)</b> <b>-&gt;</b> <b>float()</b>

       <b>abs(Int)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Int = integer()

              Returns an integer or float that is the arithmetical absolute value of <u>Float</u> or <u>Int</u>, for example:

              &gt; abs(-3.33).
              3.33
              &gt; abs(-3).
              3

              Allowed in guard tests.

       <b>erlang:adler32(Data)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Data = iodata()

              Computes and returns the adler32 checksum for <u>Data</u>.

       <b>erlang:adler32(OldAdler,</b> <b>Data)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 OldAdler = integer() &gt;= 0
                 Data = iodata()

              Continues  computing  the  adler32 checksum by combining the previous checksum, <u>OldAdler</u>, with the
              checksum of <u>Data</u>.

              The following code:

              X = erlang:adler32(Data1),
              Y = erlang:adler32(X,Data2).

              assigns the same value to <u>Y</u> as this:

              Y = erlang:adler32([Data1,Data2]).

       <b>erlang:adler32_combine(FirstAdler,</b> <b>SecondAdler,</b> <b>SecondSize)</b> <b>-&gt;</b>
                                 integer() &gt;= 0

              Types:

                 FirstAdler = SecondAdler = SecondSize = integer() &gt;= 0

              Combines two previously computed adler32 checksums. This computation requires the size of the data
              object for the second checksum to be known.

              The following code:

              Y = erlang:adler32(Data1),
              Z = erlang:adler32(Y,Data2).

              assigns the same value to <u>Z</u> as this:

              X = erlang:adler32(Data1),
              Y = erlang:adler32(Data2),
              Z = erlang:adler32_combine(X,Y,iolist_size(Data2)).

       <b>alias()</b> <b>-&gt;</b> <b>Alias</b>

       <b>alias(Opts)</b> <b>-&gt;</b> <b>Alias</b>

              Types:

                 Alias = reference()
                 Opts = [explicit_unalias | reply]

              Create an alias which can be used when sending messages to the process  that  created  the  alias.
              When  the  alias has been deactivated, messages sent using the alias will be dropped. An alias can
              be deactivated using <u>unalias/1</u>. Currently available options for <u>alias/1</u>:

                <u>explicit_unalias</u>:
                  The alias can only be deactivated via a call to <u>unalias/1</u>. This is also the default  behaviour
                  if no options are passed or if <u>alias/0</u> is called.

                <u>reply</u>:
                  The  alias  will  be  automatically  deactivated  when  a  reply message sent via the alias is
                  received. The alias can also still be deactivated via a call to <u>unalias/1</u>.

              Example:

              server() -&gt;
                  receive
                      {request, AliasReqId, Request} -&gt;
                          Result = perform_request(Request),
                          AliasReqId ! {reply, AliasReqId, Result}
                  end,
                  server().

              client(ServerPid, Request) -&gt;
                  AliasReqId = alias([reply]),
                  ServerPid ! {request, AliasReqId, Request},
                  %% Alias will be automatically deactivated if we receive a reply
                  %% since we used the 'reply' option...
                  receive
                      {reply, AliasReqId, Result} -&gt; Result
                  after 5000 -&gt;
                          unalias(AliasReqId),
                          %% Flush message queue in case the reply arrived
                          %% just before the alias was deactivated...
                          receive {reply, AliasReqId, Result} -&gt; Result
                          after 0 -&gt; exit(timeout)
                          end
                  end.

              Note that both the server and the client in this example must be executing  on  at  least  OTP  24
              systems in order for this to work.

              For  more  information on process aliases see the <u>Process</u> <u>Aliases</u>  section of the <u>Erlang</u> <u>Reference</u>
              <u>Manual</u> .

       <b>erlang:append_element(Tuple1,</b> <b>Term)</b> <b>-&gt;</b> <b>Tuple2</b>

              Types:

                 Tuple1 = Tuple2 = tuple()
                 Term = term()

              Returns a new tuple that has one element more than <u>Tuple1</u>, and contains  the  elements  in  <u>Tuple1</u>
              followed     by     <u>Term</u>     as     the     last     element.     Semantically    equivalent    to
              <u>list_to_tuple(tuple_to_list(Tuple1)</u> <u>++</u> <u>[Term])</u>, but much faster. Example:

              &gt; erlang:append_element({one, two}, three).
              {one,two,three}

       <b>apply(Fun,</b> <b>Args)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Fun = function()
                 Args = [term()]

              Calls a fun, passing the elements in <u>Args</u> as arguments.

              If the number of elements in the arguments are known at compile time, the call is  better  written
              as <u>Fun(Arg1,</u> <u>Arg2,</u> <u>...</u> <u>ArgN)</u>.

          <b>Warning:</b>
              Earlier,  <u>Fun</u> could also be specified as <u>{Module,</u> <u>Function}</u>, equivalent to <u>apply(Module,</u> <u>Function,</u>
              <u>Args)</u>. <u>This</u> <u>use</u> <u>is</u> <u>deprecated</u> <u>and</u> <u>will</u> <u>stop</u> <u>working</u> <u>in</u> <u>a</u> <u>future</u> <u>release.</u>

       <b>apply(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]

              Returns the result of applying <u>Function</u> in <u>Module</u> to <u>Args</u>. The applied function must  be  exported
              from <u>Module</u>. The arity of the function is the length of <u>Args</u>. Example:

              &gt; apply(lists, reverse, [[a, b, c]]).
              [c,b,a]
              &gt; apply(erlang, atom_to_list, ['Erlang']).
              "Erlang"

              If  the  number  of  arguments  are  known  at  compile  time,  the  call  is  better  written  as
              <u>Module:Function(Arg1,</u> <u>Arg2,</u> <u>...,</u> <u>ArgN)</u>.

              Failure: <u>error_handler:undefined_function/3</u> is called if the applied function is not exported. The
              error handler can be redefined (see <u>process_flag/2</u>). If <u>error_handler</u> is undefined, or if the user
              has redefined the default <u>error_handler</u> so the replacement module  is  undefined,  an  error  with
              reason <u>undef</u> is generated.

       <b>atom_to_binary(Atom)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Atom = atom()

              The same as <u>atom_to_binary(Atom,</u> <u>utf8)</u>.

       <b>atom_to_binary(Atom,</b> <b>Encoding)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Atom = atom()
                 Encoding = latin1 | unicode | utf8

              Returns a binary corresponding to the text representation of <u>Atom</u>. If <u>Encoding</u> is <u>latin1</u>, one byte
              exists  for  each  character  in  the  text  representation.  If  <u>Encoding</u> is <u>utf8</u> or <u>unicode</u>, the
              characters are encoded using UTF-8 where characters may require multiple bytes.

          <b>Note:</b>
              As from Erlang/OTP 20, atoms can contain any Unicode character  and  <u>atom_to_binary(Atom,</u>  <u>latin1)</u>
              may fail if the text representation for <u>Atom</u> contains a Unicode character &gt; 255.

              Example:

              &gt; atom_to_binary('Erlang', latin1).
              &lt;&lt;"Erlang"&gt;&gt;

       <b>atom_to_list(Atom)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Atom = atom()

              Returns  a  list  of  unicode  code  points  corresponding to the text representation of <u>Atom</u>, for
              example:

              &gt; atom_to_list('Erlang').
              "Erlang"

              &gt; atom_to_list('你好').
              [20320,22909]

              See <u><a href="../man3erl/unicode.3erl.html">unicode</a>(3erl)</u> for how to convert the resulting list to different formats.

       <b>binary_part(Subject,</b> <b>PosLen)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Subject = binary()
                 PosLen = {Start :: integer() &gt;= 0, Length :: integer()}

              Extracts the part of the binary described by <u>PosLen</u>.

              Negative length can be used to extract bytes at the end of a binary, for example:

              1&gt; Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;.
              2&gt; binary_part(Bin,{byte_size(Bin), -5}).
              &lt;&lt;6,7,8,9,10&gt;&gt;

              Failure: <u>badarg</u> if <u>PosLen</u> in any way references outside the binary.

              <u>Start</u> is zero-based, that is:

              1&gt; Bin = &lt;&lt;1,2,3&gt;&gt;
              2&gt; binary_part(Bin,{0,2}).
              &lt;&lt;1,2&gt;&gt;

              For details about the <u>PosLen</u> semantics, see <u><a href="../man3erl/binary.3erl.html">binary</a>(3erl)</u>.

              Allowed in guard tests.

       <b>binary_part(Subject,</b> <b>Start,</b> <b>Length)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Subject = binary()
                 Start = integer() &gt;= 0
                 Length = integer()

              The same as <u>binary_part(Subject,</u> <u>{Start,</u> <u>Length})</u>.

              Allowed in guard tests.

       <b>binary_to_atom(Binary)</b> <b>-&gt;</b> <b>atom()</b>

              Types:

                 Binary = binary()

              The same as <u>binary_to_atom(Binary,</u> <u>utf8)</u>.

       <b>binary_to_atom(Binary,</b> <b>Encoding)</b> <b>-&gt;</b> <b>atom()</b>

              Types:

                 Binary = binary()
                 Encoding = latin1 | unicode | utf8

              Returns the atom whose text representation is <u>Binary</u>. If <u>Encoding</u> is <u>utf8</u> or <u>unicode</u>,  the  binary
              must contain valid UTF-8 sequences.

          <b>Note:</b>
              As  from Erlang/OTP 20, <u>binary_to_atom(Binary,</u> <u>utf8)</u> is capable of decoding any Unicode character.
              Earlier versions would fail if the binary contained Unicode characters &gt; 255.

          <b>Note:</b>
              The number of characters that are permitted in an atom name is limited. The default limits can  be
              found in the  efficiency guide (section Advanced).

          <b>Note:</b>
              There  is configurable limit on how many atoms that can exist and atoms are not garbage collected.
              Therefore, it is recommended to consider whether <u>binary_to_existing_atom/2</u> is a better option than
              <u>binary_to_atom/2</u>. The default limits can be found in efficiency guide (section Advanced).

              Examples:

              &gt; binary_to_atom(&lt;&lt;"Erlang"&gt;&gt;, latin1).
              'Erlang'

              &gt; binary_to_atom(&lt;&lt;1024/utf8&gt;&gt;, utf8).

       <b>binary_to_existing_atom(Binary)</b> <b>-&gt;</b> <b>atom()</b>

              Types:

                 Binary = binary()

              The same as <u>binary_to_existing_atom</u> <u>(Binary,</u> <u>utf8)</u>.

       <b>binary_to_existing_atom(Binary,</b> <b>Encoding)</b> <b>-&gt;</b> <b>atom()</b>

              Types:

                 Binary = binary()
                 Encoding = latin1 | unicode | utf8

              As <u>binary_to_atom/2</u>, but the atom must exist.

              The Erlang system has a  configurable limit for the total number of  atoms  that  can  exist,  and
              atoms are not garbage collected. Therefore, it is not safe to create many atoms from binaries that
              come  from an untrusted source (for example, a file fetched from the Internet), for example, using
              <u>binary_to_atom/2</u>. This function is thus the appropriate option when the input binary comes from an
              untrusted source.

              An atom exists in an Erlang system when included  in  a  loaded  Erlang  module  or  when  created
              programmatically  (for  example, by <u>binary_to_atom/2</u>). See the next note for an example of when an
              atom exists in the source code for an Erlang module but not in the compiled version  of  the  same
              module.

              Failure: <u>badarg</u> if the atom does not exist.

          <b>Note:</b>
              Note  that  the  compiler  may  optimize  away  atoms.  For  example,  the  compiler  will rewrite
              <u>atom_to_list(some_atom)</u> to <u>"some_atom"</u>. If that  expression  is  the  only  mention  of  the  atom
              <u>some_atom</u>  in the containing module, the atom will not be created when the module is loaded, and a
              subsequent call to <u>binary_to_existing_atom(&lt;&lt;"some_atom"&gt;&gt;,</u> <u>utf8)</u> will fail.

          <b>Note:</b>
              The number of characters that are permitted in an atom name is limited. The default limits can  be
              found in the  efficiency guide (section Advanced).

       <b>binary_to_float(Binary)</b> <b>-&gt;</b> <b>float()</b>

              Types:

                 Binary = binary()

              Returns the float whose text representation is <u>Binary</u>, for example:

              &gt; binary_to_float(&lt;&lt;"2.2017764e+0"&gt;&gt;).
              2.2017764

              The  float  string  format  is  the  same  as the format for Erlang float literals except for that
              underscores are not permitted.

              Failure: <u>badarg</u> if <u>Binary</u> contains a bad representation of a float.

       <b>binary_to_integer(Binary)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 Binary = binary()

              Returns an integer whose text representation is <u>Binary</u>, for example:

              &gt; binary_to_integer(&lt;&lt;"123"&gt;&gt;).
              123

              <u>binary_to_integer/1</u> accepts the same string formats as <u>list_to_integer/1</u>.

              Failure: <u>badarg</u> if <u>Binary</u> contains a bad representation of an integer.

       <b>binary_to_integer(Binary,</b> <b>Base)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 Binary = binary()
                 Base = 2..36

              Returns an integer whose text representation in base <u>Base</u> is <u>Binary</u>, for example:

              &gt; binary_to_integer(&lt;&lt;"3FF"&gt;&gt;, 16).
              1023

              <u>binary_to_integer/2</u> accepts the same string formats as <u>list_to_integer/2</u>.

              Failure: <u>badarg</u> if <u>Binary</u> contains a bad representation of an integer.

       <b>binary_to_list(Binary)</b> <b>-&gt;</b> <b>[byte()]</b>

              Types:

                 Binary = binary()

              Returns a list of integers corresponding to the bytes of <u>Binary</u>.

       <b>binary_to_list(Binary,</b> <b>Start,</b> <b>Stop)</b> <b>-&gt;</b> <b>[byte()]</b>

              Types:

                 Binary = binary()
                 Start = Stop = integer() &gt;= 1
                   1..byte_size(<u>Binary</u>)

              As <u>binary_to_list/1</u>, but returns a list of integers corresponding to the bytes from position <u>Start</u>
              to position <u>Stop</u> in <u>Binary</u>. The positions in the binary are numbered starting from 1.

          <b>Note:</b>
              <u>The</u> <u>one-based</u> <u>indexing</u> <u>for</u> <u>binaries</u> <u>used</u> <u>by</u> <u>this</u> <u>function</u>  <u>is</u>  <u>deprecated.</u>  New  code  is  to  use
              <u>binary:bin_to_list/3</u> in STDLIB instead. All functions in module <u>binary</u> consistently use zero-based
              indexing.

       <b>binary_to_term(Binary)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Binary = ext_binary()

              Returns  an Erlang term that is the result of decoding binary object <u>Binary</u>, which must be encoded
              according to the  Erlang external term format.

              &gt; Bin = term_to_binary(hello).
              &lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;
              &gt; hello = binary_to_term(Bin).
              hello

          <b>Warning:</b>
              When decoding binaries from untrusted sources, the untrusted source may submit data in  a  way  to
              create  resources,  such as atoms and remote references, that cannot be garbage collected and lead
              to Denial of Service attack. In such cases, consider using <u>binary_to_term/2</u> with the <u>safe</u> option.

              See also <u>term_to_binary/1</u> and <u>binary_to_term/2</u>.

       <b>binary_to_term(Binary,</b> <b>Opts)</b> <b>-&gt;</b> <b>term()</b> <b>|</b> <b>{term(),</b> <b>Used}</b>

              Types:

                 Binary = ext_binary()
                 Opt = safe | used
                 Opts = [Opt]
                 Used = integer() &gt;= 1

              As <u>binary_to_term/1</u>, but takes these options:

                <u>safe</u>:
                  Use this option when receiving binaries from an untrusted source.

                  When enabled, it prevents decoding data that can be used to attack the Erlang runtime. In  the
                  event of receiving unsafe data, decoding fails with a <u>badarg</u> error.

                  This  prevents  creation  of new atoms directly, creation of new atoms indirectly (as they are
                  embedded in certain structures, such as process identifiers, refs, and funs), and creation  of
                  new  external function references. None of those resources are garbage collected, so unchecked
                  creation of them can exhaust available memory.

                &gt; binary_to_term(&lt;&lt;131,100,0,5,"hello"&gt;&gt;, [safe]).
                ** exception error: bad argument
                &gt; hello.
                hello
                &gt; binary_to_term(&lt;&lt;131,100,0,5,"hello"&gt;&gt;, [safe]).
                hello

            <b>Warning:</b>
                The <u>safe</u> option ensures the data is safely processed by the  Erlang  runtime  but  it  does  not
                guarantee  the  data  is  safe to your application. You must always validate data from untrusted
                sources. If the binary is stored or transits through untrusted sources, you should also consider
                cryptographically signing it.

                <u>used</u>:
                  Changes the return value to <u>{Term,</u> <u>Used}</u> where <u>Used</u> is the number of bytes actually read  from
                  <u>Binary</u>.

                &gt; Input = &lt;&lt;131,100,0,5,"hello","world"&gt;&gt;.
                &lt;&lt;131,100,0,5,104,101,108,108,111,119,111,114,108,100&gt;&gt;
                &gt; {Term, Used} = binary_to_term(Input, [used]).
                {hello, 9}
                &gt; split_binary(Input, Used).
                {&lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;, &lt;&lt;"world"&gt;&gt;}

              Failure: <u>badarg</u> if <u>safe</u> is specified and unsafe data is decoded.

              See also <u>term_to_binary/1</u>, <u>binary_to_term/1</u>, and <u>list_to_existing_atom/1</u>.

       <b>bit_size(Bitstring)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Bitstring = bitstring()

              Returns an integer that is the size in bits of <u>Bitstring</u>, for example:

              &gt; bit_size(&lt;&lt;433:16,3:3&gt;&gt;).
              19
              &gt; bit_size(&lt;&lt;1,2,3&gt;&gt;).
              24

              Allowed in guard tests.

       <b>bitstring_to_list(Bitstring)</b> <b>-&gt;</b> <b>[byte()</b> <b>|</b> <b>bitstring()]</b>

              Types:

                 Bitstring = bitstring()

              Returns  a  list of integers corresponding to the bytes of <u>Bitstring</u>. If the number of bits in the
              binary is not divisible by 8, the last element of the list is a bitstring containing the remaining
              1-7 bits. Examples:

              &gt; bitstring_to_list(&lt;&lt;433:16&gt;&gt;).
              [1,177]

              &gt; bitstring_to_list(&lt;&lt;433:16,3:3&gt;&gt;).
              [1,177,&lt;&lt;3:3&gt;&gt;]

       <b>erlang:bump_reductions(Reductions)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Reductions = integer() &gt;= 1

              This implementation-dependent function increments the reduction counter for the  calling  process.
              In  the  Beam emulator, the reduction counter is normally incremented by one for each function and
              BIF call. A context switch is forced when the counter reaches the maximum number of reductions for
              a process (4000 reductions in Erlang/OTP 19.2 and later).

          <b>Warning:</b>
              This BIF can be removed in a future version of the Beam  machine  without  prior  warning.  It  is
              unlikely to be implemented in other Erlang implementations.

       <b>byte_size(Bitstring)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Bitstring = bitstring()

              Returns an integer that is the number of bytes needed to contain <u>Bitstring</u>. That is, if the number
              of bits in <u>Bitstring</u> is not divisible by 8, the resulting number of bytes is rounded <u>up</u>. Examples:

              &gt; byte_size(&lt;&lt;433:16,3:3&gt;&gt;).
              3
              &gt; byte_size(&lt;&lt;1,2,3&gt;&gt;).
              3

              Allowed in guard tests.

       <b>erlang:cancel_timer(TimerRef)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TimerRef = reference()
                 Time = integer() &gt;= 0
                 Result = Time | false

              Cancels a timer. The same as calling <u>erlang:cancel_timer(TimerRef,</u> <u>[])</u>.

       <b>erlang:cancel_timer(TimerRef,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b> <b>|</b> <b>ok</b>

              Types:

                 TimerRef = reference()
                 Async = Info = boolean()
                 Option = {async, Async} | {info, Info}
                 Options = [Option]
                 Time = integer() &gt;= 0
                 Result = Time | false

              Cancels  a  timer  that  has  been  created  by  <u>erlang:start_timer</u> or <u>erlang:send_after</u>. <u>TimerRef</u>
              identifies the timer, and was returned by the BIF that created the timer.

              <u>Option</u>s:

                <u>{async,</u> <u>Async}</u>:
                  Asynchronous request for cancellation. <u>Async</u> defaults to <u>false</u>, which causes the  cancellation
                  to  be  performed  synchronously. When <u>Async</u> is set to <u>true</u>, the cancel operation is performed
                  asynchronously. That is, <u>cancel_timer()</u> sends an asynchronous request for cancellation to  the
                  timer service that manages the timer, and then returns <u>ok</u>.

                <u>{info,</u> <u>Info}</u>:
                  Requests  information about the <u>Result</u> of the cancellation. <u>Info</u> defaults to <u>true</u>, which means
                  the <u>Result</u> is given. When <u>Info</u> is set to  <u>false</u>,  no  information  about  the  result  of  the
                  cancellation is given.

                  * When  <u>Async</u>  is  <u>false</u>:  if  <u>Info</u>  is <u>true</u>, the <u>Result</u> is returned by <u>erlang:cancel_timer()</u>.
                    otherwise <u>ok</u> is returned.

                  * When <u>Async</u> is <u>true</u>: if <u>Info</u> is <u>true</u>, a message on the form <u>{cancel_timer,</u> <u>TimerRef,</u>  <u>Result}</u>
                    is  sent  to  the  caller  of <u>erlang:cancel_timer()</u> when the cancellation operation has been
                    performed, otherwise no message is sent.

              More <u>Option</u>s may be added in the future.

              If <u>Result</u> is an integer, it represents the time in milliseconds  left  until  the  canceled  timer
              would have expired.

              If  <u>Result</u>  is  <u>false</u>,  a  timer  corresponding to <u>TimerRef</u> could not be found. This can be either
              because the timer had expired, already had been canceled, or because <u>TimerRef</u>  never  corresponded
              to  a  timer.  Even  if  the  timer  had expired, it does not tell you if the time-out message has
              arrived at its destination yet.

          <b>Note:</b>
              The timer service that manages the timer  can  be  co-located  with  another  scheduler  than  the
              scheduler  that  the  calling process is executing on. If so, communication with the timer service
              takes much longer time than if it is located locally. If the calling process is in critical  path,
              and  can  do  other things while waiting for the result of this operation, or is not interested in
              the result of the operation, you want to use option <u>{async,</u> <u>true}</u>. If using option <u>{async,</u> <u>false}</u>,
              the calling process blocks until the operation has been performed.

              See also <u>erlang:send_after/4</u>, <u>erlang:start_timer/4</u>, and <u>erlang:read_timer/2</u>.

       <b>ceil(Number)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 Number = number()

              Returns the smallest integer not less than <u>Number</u>. For example:

              &gt; ceil(5.5).
              6

              Allowed in guard tests.

       <b>check_old_code(Module)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Module = module()

              Returns <u>true</u> if <u>Module</u> has old code, otherwise <u>false</u>.

              See also <u><a href="../man3erl/code.3erl.html">code</a>(3erl)</u>.

       <b>check_process_code(Pid,</b> <b>Module)</b> <b>-&gt;</b> <b>CheckResult</b>

              Types:

                 Pid = pid()
                 Module = module()
                 CheckResult = boolean()

              The same as <u>check_process_code(Pid,</u> <u>Module,</u> <u>[])</u>.

       <b>check_process_code(Pid,</b> <b>Module,</b> <b>OptionList)</b> <b>-&gt;</b> <b>CheckResult</b> <b>|</b> <b>async</b>

              Types:

                 Pid = pid()
                 Module = module()
                 RequestId = term()
                 Option = {async, RequestId} | {allow_gc, boolean()}
                 OptionList = [Option]
                 CheckResult = boolean() | aborted

              Checks if the node local process identified by <u>Pid</u> executes old code for <u>Module</u>.

              <u>Option</u>s:

                <u>{allow_gc,</u> <u>boolean()}</u>:
                  Determines if garbage collection is allowed  when  performing  the  operation.  If  <u>{allow_gc,</u>
                  <u>false}</u> is passed, and a garbage collection is needed to determine the result of the operation,
                  the  operation  is  aborted  (see  information  on <u>CheckResult</u> below). The default is to allow
                  garbage collection, that is, <u>{allow_gc,</u> <u>true}</u>.

                <u>{async,</u> <u>RequestId}</u>:
                  The function <u>check_process_code/3</u> returns the value <u>async</u> immediately after  the  request  has
                  been  sent.  When  the  request  has  been processed, the process that called this function is
                  passed a message on the form <u>{check_process_code,</u> <u>RequestId,</u> <u>CheckResult}</u>.

              If <u>Pid</u> equals <u>self()</u>, and no <u>async</u> option has been passed, the operation  is  performed  at  once.
              Otherwise  a  request  for  the operation is sent to the process identified by <u>Pid</u>, and is handled
              when appropriate. If no <u>async</u> option has been passed,  the  caller  blocks  until  <u>CheckResult</u>  is
              available and can be returned.

              <u>CheckResult</u> informs about the result of the request as follows:

                <u>true</u>:
                  The  process  identified by <u>Pid</u> executes old code for <u>Module</u>. That is, the current call of the
                  process executes old code for this module, or the process has references to old code for  this
                  module, or the process contains funs that references old code for this module.

                <u>false</u>:
                  The process identified by <u>Pid</u> does not execute old code for <u>Module</u>.

                <u>aborted</u>:
                  The  operation  was  aborted,  as  the process needed to be garbage collected to determine the
                  operation result, and the operation was requested by passing option <u>{allow_gc,</u> <u>false}</u>.

          <b>Note:</b>
              Up until ERTS version 8.*, the check process code operation checks for all types of references  to
              the  old  code.  That is, direct references (e.g. return addresses on the process stack), indirect
              references (<u>fun</u>s in process context), and references to literals in the code.

              As of ERTS version 9.0, the check process code operation only checks for direct references to  the
              code.  Indirect references via <u>fun</u>s will be ignored. If such <u>fun</u>s exist and are used after a purge
              of the old code, an exception will be raised upon usage (same as the case when the <u>fun</u> is received
              by the process after the purge). Literals will be taken care of (copied) at a  later  stage.  This
              behavior  can  as  of  ERTS  version  8.1  be enabled when building OTP, and will automatically be
              enabled if dirty scheduler support is enabled.

              See also <u><a href="../man3erl/code.3erl.html">code</a>(3erl)</u>.

              Failures:

                <u>badarg</u>:
                  If <u>Pid</u> is not a node local process identifier.

                <u>badarg</u>:
                  If <u>Module</u> is not an atom.

                <u>badarg</u>:
                  If <u>OptionList</u> is an invalid list of options.

       <b>erlang:convert_time_unit(Time,</b> <b>FromUnit,</b> <b>ToUnit)</b> <b>-&gt;</b> <b>ConvertedTime</b>

              Types:

                 Time = ConvertedTime = integer()
                 FromUnit = ToUnit = time_unit()

              Converts the <u>Time</u> value of time unit <u>FromUnit</u> to the corresponding  <u>ConvertedTime</u>  value  of  time
              unit <u>ToUnit</u>. The result is rounded using the floor function.

          <b>Warning:</b>
              You  can  lose  accuracy  and precision when converting between time units. To minimize such loss,
              collect all data at <u>native</u> time unit and do the conversion on the end result.

       <b>erlang:crc32(Data)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Data = iodata()

              Computes and returns the crc32 (IEEE 802.3 style) checksum for <u>Data</u>.

       <b>erlang:crc32(OldCrc,</b> <b>Data)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 OldCrc = integer() &gt;= 0
                 Data = iodata()

              Continues computing the crc32 checksum by  combining  the  previous  checksum,  <u>OldCrc</u>,  with  the
              checksum of <u>Data</u>.

              The following code:

              X = erlang:crc32(Data1),
              Y = erlang:crc32(X,Data2).

              assigns the same value to <u>Y</u> as this:

              Y = erlang:crc32([Data1,Data2]).

       <b>erlang:crc32_combine(FirstCrc,</b> <b>SecondCrc,</b> <b>SecondSize)</b> <b>-&gt;</b>
                               integer() &gt;= 0

              Types:

                 FirstCrc = SecondCrc = SecondSize = integer() &gt;= 0

              Combines  two  previously computed crc32 checksums. This computation requires the size of the data
              object for the second checksum to be known.

              The following code:

              Y = erlang:crc32(Data1),
              Z = erlang:crc32(Y,Data2).

              assigns the same value to <u>Z</u> as this:

              X = erlang:crc32(Data1),
              Y = erlang:crc32(Data2),
              Z = erlang:crc32_combine(X,Y,iolist_size(Data2)).

       <b>date()</b> <b>-&gt;</b> <b>Date</b>

              Types:

                 Date = calendar:date()

              Returns the current date as <u>{Year,</u> <u>Month,</u> <u>Day}</u>.

              The time zone and Daylight Saving Time correction depend on the underlying OS. The return value is
              based on the OS System Time. Example:

              &gt; date().
              {1995,2,19}

       <b>erlang:decode_packet(Type,</b> <b>Bin,</b> <b>Options)</b> <b>-&gt;</b>
                               {ok, Packet, Rest} |
                               {more, Length} |
                               {error, Reason}

              Types:

                 Type =
                     raw | 0 | 1 | 2 | 4 | asn1 | cdr | sunrm | fcgi | tpkt |
                     line | http | http_bin | httph | httph_bin
                 Bin = binary()
                 Options = [Opt]
                 Opt =
                     {packet_size, integer() &gt;= 0} |
                     {line_length, integer() &gt;= 0}
                 Packet = binary() | HttpPacket
                 Rest = binary()
                 Length = integer() &gt;= 0 | undefined
                 Reason = term()
                 HttpPacket =
                     HttpRequest | HttpResponse | HttpHeader | http_eoh | HttpError
                 HttpRequest = {http_request, HttpMethod, HttpUri, HttpVersion}
                 HttpResponse =
                     {http_response, HttpVersion, integer(), HttpString}
                 HttpHeader =
                     {http_header,
                      integer(),
                      HttpField,
                      UnmodifiedField :: HttpString,
                      Value :: HttpString}
                 HttpError = {http_error, HttpString}
                 HttpMethod =
                     'OPTIONS' | 'GET' | 'HEAD' | 'POST' | 'PUT' | 'DELETE' |
                     'TRACE' | HttpString
                 HttpUri =
                     '*' |
                     {absoluteURI,
                      http | https,
                      Host :: HttpString,
                      Port :: inet:port_number() | undefined,
                      Path :: HttpString} |
                     {scheme, Scheme :: HttpString, HttpString} |
                     {abs_path, HttpString} |
                     HttpString
                 HttpVersion =
                     {Major :: integer() &gt;= 0, Minor :: integer() &gt;= 0}
                 HttpField =
                     'Cache-Control' | 'Connection' | 'Date' | 'Pragma' |
                     'Transfer-Encoding' | 'Upgrade' | 'Via' | 'Accept' |
                     'Accept-Charset' | 'Accept-Encoding' | 'Accept-Language' |
                     'Authorization' | 'From' | 'Host' | 'If-Modified-Since' |
                     'If-Match' | 'If-None-Match' | 'If-Range' |
                     'If-Unmodified-Since' | 'Max-Forwards' |
                     'Proxy-Authorization' | 'Range' | 'Referer' | 'User-Agent' |
                     'Age' | 'Location' | 'Proxy-Authenticate' | 'Public' |
                     'Retry-After' | 'Server' | 'Vary' | 'Warning' |
                     'Www-Authenticate' | 'Allow' | 'Content-Base' |
                     'Content-Encoding' | 'Content-Language' | 'Content-Length' |
                     'Content-Location' | 'Content-Md5' | 'Content-Range' |
                     'Content-Type' | 'Etag' | 'Expires' | 'Last-Modified' |
                     'Accept-Ranges' | 'Set-Cookie' | 'Set-Cookie2' |
                     'X-Forwarded-For' | 'Cookie' | 'Keep-Alive' |
                     'Proxy-Connection' | HttpString
                 HttpString = string() | binary()

              Decodes the binary <u>Bin</u> according to the packet protocol specified by <u>Type</u>. Similar to  the  packet
              handling done by sockets with option <u>{packet,Type}.</u>

              If  an entire packet is contained in <u>Bin</u>, it is returned together with the remainder of the binary
              as <u>{ok,Packet,Rest}</u>.

              If <u>Bin</u> does not contain the entire  packet,  <u>{more,Length}</u>  is  returned.  <u>Length</u>  is  either  the
              expected  <u>total</u>  <u>size</u>  of  the  packet,  or  <u>undefined</u>  if  the  expected  packet size is unknown.
              <u>decode_packet</u> can then be called again with more data added.

              If the packet does not conform to the protocol format, <u>{error,Reason}</u> is returned.

              <u>Type</u>s:

                <u>raw</u> <u>|</u> <u>0</u>:
                  No packet handling is done. The entire binary is returned unless it is empty.

                <u>1</u> <u>|</u> <u>2</u> <u>|</u> <u>4</u>:
                  Packets consist of a header specifying the number of bytes in the  packet,  followed  by  that
                  number  of  bytes.  The  length of the header can be one, two, or four bytes; the order of the
                  bytes is big-endian. The header is stripped off when the packet is returned.

                <u>line</u>:
                  A packet is a line-terminated by a delimiter byte, default is the latin-1  newline  character.
                  The  delimiter byte is included in the returned packet unless the line was truncated according
                  to option <u>line_length</u>.

                <u>asn1</u> <u>|</u> <u>cdr</u> <u>|</u> <u>sunrm</u> <u>|</u> <u>fcgi</u> <u>|</u> <u>tpkt</u>:
                  The header is <u>not</u> stripped off.

                  The meanings of the packet types are as follows:

                  <u>asn1</u> - ASN.1 BER:

                  <u>sunrm</u> - Sun's RPC encoding:

                  <u>cdr</u> - CORBA (GIOP 1.1):

                  <u>fcgi</u> - Fast CGI:

                  <u>tpkt</u> - TPKT format [RFC1006]:

                <u>http</u> <u>|</u> <u>httph</u> <u>|</u> <u>http_bin</u> <u>|</u> <u>httph_bin</u>:
                  The Hypertext Transfer Protocol. The  packets  are  returned  with  the  format  according  to
                  <u>HttpPacket</u> described earlier. A packet is either a request, a response, a header, or an end of
                  header mark. Invalid lines are returned as <u>HttpError</u>.

                  Recognized  request  methods  and  header fields are returned as atoms. Others are returned as
                  strings. Strings of unrecognized header fields are formatted with only capital  letters  first
                  and  after  hyphen  characters,  for example, <u>"Sec-Websocket-Key"</u>. Header field names are also
                  returned in <u>UnmodifiedField</u> as strings, without any conversion or formatting.

                  The protocol type <u>http</u> is only to be used for  the  first  line  when  an  <u>HttpRequest</u>  or  an
                  <u>HttpResponse</u>  is  expected.  The  following  calls  are  to use <u>httph</u> to get <u>HttpHeader</u>s until
                  <u>http_eoh</u> is returned, which marks the end of the headers and the beginning  of  any  following
                  message body.

                  The variants <u>http_bin</u> and <u>httph_bin</u> return strings (<u>HttpString</u>) as binaries instead of lists.

              Options:

                <u>{packet_size,</u> <u>integer()</u> <u>&gt;=</u> <u>0}</u>:
                  Sets  the  maximum  allowed  size  of the packet body. If the packet header indicates that the
                  length of the packet is longer than the maximum  allowed  length,  the  packet  is  considered
                  invalid. Defaults to 0, which means no size limit.

                <u>{line_length,</u> <u>integer()</u> <u>&gt;=</u> <u>0}</u>:
                  For packet type <u>line</u>, lines longer than the indicated length are truncated.

                  Option  <u>line_length</u>  also  applies to <u>http*</u> packet types as an alias for option <u>packet_size</u> if
                  <u>packet_size</u> itself is not set. This use is only intended for backward compatibility.

                <u>{line_delimiter,</u> <u>0</u> <u>=&lt;</u> <u>byte()</u> <u>=&lt;</u> <u>255}</u>:
                  For packet type <u>line</u>, sets the delimiting byte. Default is the latin-1 character <u>$\n</u>.

              Examples:

              &gt; erlang:decode_packet(1,&lt;&lt;3,"abcd"&gt;&gt;,[]).
              {ok,&lt;&lt;"abc"&gt;&gt;,&lt;&lt;"d"&gt;&gt;}
              &gt; erlang:decode_packet(1,&lt;&lt;5,"abcd"&gt;&gt;,[]).
              {more,6}

       <b>erlang:delete_element(Index,</b> <b>Tuple1)</b> <b>-&gt;</b> <b>Tuple2</b>

              Types:

                 Index = integer() &gt;= 1
                   1..tuple_size(Tuple1)
                 Tuple1 = Tuple2 = tuple()

              Returns a new tuple with element at <u>Index</u> removed from tuple <u>Tuple1</u>, for example:

              &gt; erlang:delete_element(2, {one, two, three}).
              {one,three}

       <b>delete_module(Module)</b> <b>-&gt;</b> <b>true</b> <b>|</b> <b>undefined</b>

              Types:

                 Module = module()

              Makes the current code for <u>Module</u> become old code and deletes all references for this module  from
              the export table. Returns <u>undefined</u> if the module does not exist, otherwise <u>true</u>.

          <b>Warning:</b>
              This BIF is intended for the code server (see <u><a href="../man3erl/code.3erl.html">code</a>(3erl)</u>) and is not to be used elsewhere.

              Failure: <u>badarg</u> if there already is an old version of <u>Module</u>.

       <b>demonitor(MonitorRef)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 MonitorRef = reference()

              If  <u>MonitorRef</u>  is  a  reference  that  the  calling  process  obtained by calling <u>monitor/2</u>, this
              monitoring is turned off. If the monitoring is already turned off, nothing happens.

              Once <u>demonitor(MonitorRef)</u> has returned, it is guaranteed that no <u>{'DOWN',</u> <u>MonitorRef,</u>  <b>_</b><u>,</u>  <b>_</b><u>,</u>  <b>_</b><u>}</u>
              message,  because  of  the  monitor,  will  be  placed  in the caller message queue in the future.
              However, a <u>{'DOWN',</u> <u>MonitorRef,</u> <b>_</b><u>,</u> <b>_</b><u>,</u> <b>_</b><u>}</u> message can have been placed in the caller message  queue
              before  the  call.  It  is  therefore  usually  advisable to remove such a <u>'DOWN'</u> message from the
              message queue after monitoring has  been  stopped.  <u>demonitor(MonitorRef,</u>  <u>[flush])</u>  can  be  used
              instead of <u>demonitor(MonitorRef)</u> if this cleanup is wanted.

          <b>Note:</b>
              Before  Erlang/OTP  R11B  (ERTS  5.5)  <u>demonitor/1</u> behaved completely asynchronously, that is, the
              monitor was active until the "demonitor  signal"  reached  the  monitored  entity.  This  had  one
              undesirable  effect.  You  could never know when you were guaranteed <u>not</u> to receive a <u>DOWN</u> message
              because of the monitor.

              The current behavior can be viewed as two combined operations: asynchronously  send  a  "demonitor
              signal" to the monitored entity and ignore any future results of the monitor.

              Failure:  It  is an error if <u>MonitorRef</u> refers to a monitoring started by another process. Not all
              such cases are cheap to check. If checking is cheap, the call fails with <u>badarg</u>,  for  example  if
              <u>MonitorRef</u> is a remote reference.

       <b>demonitor(MonitorRef,</b> <b>OptionList)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 MonitorRef = reference()
                 OptionList = [Option]
                 Option = flush | info

              The returned value is <u>true</u> unless <u>info</u> is part of <u>OptionList</u>.

              <u>demonitor(MonitorRef,</u> <u>[])</u> is equivalent to <u>demonitor(MonitorRef)</u>.

              <u>Option</u>s:

                <u>flush</u>:
                  Removes (one) <u>{_,</u> <u>MonitorRef,</u> <b>_</b><u>,</u> <b>_</b><u>,</u> <b>_</b><u>}</u> message, if there is one, from the caller message queue
                  after monitoring has been stopped.

                  Calling <u>demonitor(MonitorRef,</u> <u>[flush])</u> is equivalent to the following, but more efficient:

                demonitor(MonitorRef),
                receive
                    {_, MonitorRef, _, _, _} -&gt;
                        true
                after 0 -&gt;
                        true
                end

                <u>info</u>:
                  The returned value is one of the following:

                  <u>true</u>:
                    The  monitor  was  found  and removed. In this case, no <u>'DOWN'</u> message corresponding to this
                    monitor has been delivered and will not be delivered.

                  <u>false</u>:
                    The monitor was not found and could not be removed. This probably  because  someone  already
                    has placed a <u>'DOWN'</u> message corresponding to this monitor in the caller message queue.

                  If  option  <u>info</u>  is  combined  with  option  <u>flush</u>,  <u>false</u> is returned if a flush was needed,
                  otherwise <u>true</u>.

          <b>Note:</b>
              More options can be added in a future release.

              Failures:

                <u>badarg</u>:
                  If <u>OptionList</u> is not a list.

                <u>badarg</u>:
                  If <u>Option</u> is an invalid option.

                <u>badarg</u>:
                  The same failure as for <u>demonitor/1</u>.

       <b>disconnect_node(Node)</b> <b>-&gt;</b> <b>boolean()</b> <b>|</b> <b>ignored</b>

              Types:

                 Node = node()

              Forces the disconnection of a node. This appears to the  node  <u>Node</u>  as  if  the  local  node  has
              crashed. This BIF is mainly used in the Erlang network authentication protocols.

              Returns  <u>true</u>  if disconnection succeeds, otherwise <u>false</u>. If the local node is not alive, <u>ignored</u>
              is returned.

          <b>Note:</b>
              This function may return before <u>nodedown</u> messages have been delivered.

       <b>erlang:display(Term)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Term = term()

              Prints a text representation of <u>Term</u> on the standard output.

          <b>Warning:</b>
              This BIF is intended for debugging only.

       <b>erlang:dist_ctrl_get_data(DHandle)</b> <b>-&gt;</b> <b>{Size,</b> <b>Data}</b> <b>|</b> <b>Data</b> <b>|</b> <b>none</b>

              Types:

                 Size = integer() &gt;= 0
                 DHandle = dist_handle()
                 Data = iovec()

              Get distribution channel data from the local node that is to be passed to  the  remote  node.  The
              distribution channel is identified by <u>DHandle</u>. If no data is available, the atom <u>none</u> is returned.
              One   can  request  to  be  informed  by  a  message  when  more  data  is  available  by  calling
              <u>erlang:dist_ctrl_get_data_notification(DHandle)</u>.

              The returned value when there are data available depends on  the  value  of  the  <u>get_size</u>  option
              configured  on  the  distribution  channel  identified  by  <u>DHandle</u>.  For more information see the
              documentation of the <u>get_size</u> option for the <u>erlang:dist_ctrl_set_opt/3</u> function.

          <b>Note:</b>
              Only the process registered as distribution controller for the distribution channel identified  by
              <u>DHandle</u> is allowed to call this function.

              This  function  is  used  when implementing an alternative distribution carrier using processes as
              distribution  controllers.  <u>DHandle</u>  is  retrived  via  the  callback  <u>f_handshake_complete</u>.  More
              information  can  be  found  in  the  documentation  of  ERTS  User's  Guide ➜ How to implement an
              Alternative Carrier for the Erlang Distribution ➜ Distribution Module.

       <b>erlang:dist_ctrl_get_opt(DHandle,</b> <b>Opt</b> <b>::</b> <b>get_size)</b> <b>-&gt;</b> <b>Value</b>

              Types:

                 DHandle = dist_handle()
                 Value = boolean()

              Returns the value of the <u>get_size</u> option on the distribution channel identified  by  <u>DHandle</u>.  For
              more  information  see the documentation of the <u>get_size</u> option for the <u>erlang:dist_ctrl_set_opt/3</u>
              function.

          <b>Note:</b>
              Only the process registered as distribution controller for the distribution channel identified  by
              <u>DHandle</u> is allowed to call this function.

              This  function  is  used  when implementing an alternative distribution carrier using processes as
              distribution  controllers.  <u>DHandle</u>  is  retrived  via  the  callback  <u>f_handshake_complete</u>.  More
              information  can  be  found  in  the  documentation  of  ERTS  User's  Guide ➜ How to implement an
              Alternative Carrier for the Erlang Distribution ➜ Distribution Module.

       <b>erlang:dist_ctrl_get_data_notification(DHandle)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 DHandle = dist_handle()

              Request notification when more data is available to fetch using <u>erlang:dist_ctrl_get_data(DHandle)</u>
              for the distribution channel identified by <u>DHandle</u>. When more data is present, the caller will  be
              sent  the  message  <u>dist_data</u>. Once a <u>dist_data</u> messages has been sent, no more <u>dist_data</u> messages
              will be sent until the <u>dist_ctrl_get_data_notification/1</u> function has been called again.

          <b>Note:</b>
              Only the process registered as distribution controller for the distribution channel identified  by
              <u>DHandle</u> is allowed to call this function.

              This  function  is  used  when implementing an alternative distribution carrier using processes as
              distribution  controllers.  <u>DHandle</u>  is  retrived  via  the  callback  <u>f_handshake_complete</u>.  More
              information  can  be  found  in  the  documentation  of  ERTS  User's  Guide ➜ How to implement an
              Alternative Carrier for the Erlang Distribution ➜ Distribution Module.

       <b>erlang:dist_ctrl_input_handler(DHandle,</b> <b>InputHandler)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 DHandle = dist_handle()
                 InputHandler = pid()

              Register an alternate input handler process for the distribution channel  identified  by  <u>DHandle</u>.
              Once   this  function  has  been  called,  <u>InputHandler</u>  is  the  only  process  allowed  to  call
              <u>erlang:dist_ctrl_put_data(DHandle,</u> <u>Data)</u> with the <u>DHandle</u> identifing this distribution channel.

          <b>Note:</b>
              Only the process registered as distribution controller for the distribution channel identified  by
              <u>DHandle</u> is allowed to call this function.

              This  function  is  used  when implementing an alternative distribution carrier using processes as
              distribution  controllers.  <u>DHandle</u>  is  retrived  via  the  callback  <u>f_handshake_complete</u>.  More
              information  can  be  found  in  the  documentation  of  ERTS  User's  Guide ➜ How to implement an
              Alternative Carrier for the Erlang Distribution ➜ Distribution Module.

       <b>erlang:dist_ctrl_put_data(DHandle,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 DHandle = dist_handle()
                 Data = iodata()

              Deliver distribution channel data from a remote node to the local node.

          <b>Note:</b>
              Only the process registered as distribution controller for the distribution channel identified  by
              <u>DHandle</u>  is  allowed  to  call  this  function  unless an alternate input handler process has been
              registered using <u>erlang:dist_ctrl_input_handler(DHandle,</u>  <u>InputHandler)</u>.  If  an  alternate  input
              handler  has  been  registered,  only the registered input handler process is allowed to call this
              function.

              This function is used when implementing an alternative distribution  carrier  using  processes  as
              distribution  controllers.  <u>DHandle</u>  is  retrived  via  the  callback  <u>f_handshake_complete</u>.  More
              information can be found in the  documentation  of  ERTS  User's  Guide  ➜  How  to  implement  an
              Alternative Carrier for the Erlang Distribution ➜ Distribution Module.

       <b>erlang:dist_ctrl_set_opt(DHandle,</b> <b>Opt</b> <b>::</b> <b>get_size,</b> <b>Value)</b> <b>-&gt;</b>
                                   OldValue

              Types:

                 DHandle = dist_handle()
                 Value = OldValue = boolean()

              Sets  the  value  of  the  <u>get_size</u> option on the distribution channel identified by <u>DHandle</u>. This
              option controls the return value of  calls  to  erlang:dist_ctrl_get_data(DHandle)  where  <u>DHandle</u>
              equals <u>DHandle</u> used when setting this option. When the <u>get_size</u> option is:

                <u>false</u>:
                   and  there are distribution data available, a call to <u>erlang:dist_ctrl_get_data(DHandle)</u> will
                  just return <u>Data</u> to pass over the channel. This is the default value of the <u>get_size</u> option.

                <u>true</u>:
                   and there are distribution data available, a call to <u>erlang:dist_ctrl_get_data(DHandle)</u>  will
                  return <u>Data</u> to pass over the channel as well as the <u>Size</u> of <u>Data</u> in bytes. This is returned as
                  a tuple on the form <u>{Size,</u> <u>Data}</u>.

              All options are set to default when a channel is closed.

          <b>Note:</b>
              Only  the process registered as distribution controller for the distribution channel identified by
              <u>DHandle</u> is allowed to call this function.

              This function is used when implementing an alternative distribution  carrier  using  processes  as
              distribution  controllers.  <u>DHandle</u>  is  retrived  via  the  callback  <u>f_handshake_complete</u>.  More
              information can be found in the  documentation  of  ERTS  User's  Guide  ➜  How  to  implement  an
              Alternative Carrier for the Erlang Distribution ➜ Distribution Module.

       <b>element(N,</b> <b>Tuple)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 N = integer() &gt;= 1
                   1..tuple_size(Tuple)
                 Tuple = tuple()

              Returns the <u>N</u>th element (numbering from 1) of <u>Tuple</u>, for example:

              &gt; element(2, {a, b, c}).
              b

              Allowed in guard tests.

       <b>erase()</b> <b>-&gt;</b> <b>[{Key,</b> <b>Val}]</b>

              Types:

                 Key = Val = term()

              Returns the process dictionary and deletes it, for example:

              &gt; put(key1, {1, 2, 3}),
              put(key2, [a, b, c]),
              erase().
              [{key1,{1,2,3}},{key2,[a,b,c]}]

       <b>erase(Key)</b> <b>-&gt;</b> <b>Val</b> <b>|</b> <b>undefined</b>

              Types:

                 Key = Val = term()

              Returns  the  value  <u>Val</u>  associated  with <u>Key</u> and deletes it from the process dictionary. Returns
              <u>undefined</u> if no value is associated  with  <u>Key</u>.  The  average  time  complexity  for  the  current
              implementation of this function is O(<u>1</u>) and the worst case time complexity is O(<u>N</u>), where <u>N</u> is the
              number of items in the process dictionary. Example:

              &gt; put(key1, {merry, lambs, are, playing}),
              X = erase(key1),
              {X, erase(key1)}.
              {{merry,lambs,are,playing},undefined}

       <b>error(Reason)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Reason = term()

              Raises  an  exception of class <u>error</u> with the reason <u>Reason</u>. As evaluating this function causes an
              exception to be thrown, it has no return value.

              The intent of the exception class <u>error</u> is to signal that an unexpected error  has  happened  (for
              example,  a  function  is called with a parameter that has an incorrect type). See the guide about
              errors and error handling for additional information. Example:

              &gt; catch error(foobar).
              {'EXIT',{foobar,[{shell,apply_fun,3,
                                      [{file,"shell.erl"},{line,906}]},
                               {erl_eval,do_apply,6,[{file,"erl_eval.erl"},{line,677}]},
                               {erl_eval,expr,5,[{file,"erl_eval.erl"},{line,430}]},
                               {shell,exprs,7,[{file,"shell.erl"},{line,687}]},
                               {shell,eval_exprs,7,[{file,"shell.erl"},{line,642}]},
                               {shell,eval_loop,3,[{file,"shell.erl"},{line,627}]}]}}

       <b>error(Reason,</b> <b>Args)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Reason = term()
                 Args = [term()] | none

              Raises an exception of class <u>error</u> with the reason <u>Reason</u>. <u>Args</u> is expected  to  be  the  list  of
              arguments  for  the  current function or the atom <u>none</u>. If it is a list, it is used to provide the
              arguments for the current function in the stack back-trace. If  it  is  <u>none</u>,  the  arity  of  the
              calling  function is used in the stacktrace. As evaluating this function causes an exception to be
              raised, it has no return value.

              The intent of the exception class <u>error</u> is to signal that an unexpected error  has  happened  (for
              example,  a  function  is called with a parameter that has an incorrect type). See the guide about
              errors and error handling for additional information. Example:

              <u>test.erl</u>:

              -module(test).
              -export([example_fun/2]).

              example_fun(A1, A2) -&gt;
                  erlang:error(my_error, [A1, A2]).

              Erlang shell:

              6&gt; c(test).
              {ok,test}
              7&gt; test:example_fun(arg1,"this is the second argument").
              ** exception error: my_error
                   in function  test:example_fun/2
                       called as test:example_fun(arg1,"this is the second argument")

       <b>error(Reason,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Reason = term()
                 Args = [term()] | none
                 Options = [Option]
                 Option = {error_info, ErrorInfoMap}
                 ErrorInfoMap =
                     #{cause =&gt; term(), module =&gt; module(), function =&gt; atom()}

              Raises an exception of class <u>error</u> with the reason <u>Reason</u>. <u>Args</u> is expected  to  be  the  list  of
              arguments  for  the  current function or the atom <u>none</u>. If it is a list, it is used to provide the
              arguments for the current function in the stack back-trace. If  it  is  <u>none</u>,  the  arity  of  the
              calling  function is used in the stacktrace. As evaluating this function causes an exception to be
              raised, it has no return value.

              If the <u>error_info</u> option is given, the <u>ErrorInfoMap</u> will be  inserted  into  the  stacktrace.  The
              information  given  in  the  <u>ErrorInfoMap</u>  is  to be used by error formatters such as <u>erl_error</u> to
              provide more context around an error.

              The default <u>module</u> of the <u>ErrorInfoMap</u> is the module that the call to <u>error/3</u> is made. The default
              <u>function</u> is <u>format_error</u>. See <u>format_error/2</u> for more details on how this Module:Function/2 is  to
              be used

              The  intent  of  the exception class <u>error</u> is to signal that an unexpected error has happened (for
              example, a function is called with a parameter that has an incorrect type). See  the  guide  about
              errors and error handling for additional information.

       <b>exit(Reason)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Reason = term()

              Raises  an  exception of class <u>exit</u> with exit reason <u>Reason</u>. As evaluating this function causes an
              exception to be raised, it has no return value.

              The intent of the exception class <u>exit</u> is that the current process should be stopped (for  example
              when a message telling a process to stop is received).

              This function differ from <u>error/1,2,3</u> by causing an exception of a different class and by having a
              reason that does not include the list of functions from the call stack.

              See the guide about errors and error handling for additional information.

              Example:

              &gt; exit(foobar).
              ** exception exit: foobar
              &gt; catch exit(foobar).
              {'EXIT',foobar}

          <b>Note:</b>
              If a process calls <u>exit(kill)</u> and does not catch the exception, it will terminate with exit reason
              <u>kill</u>  and  also emit exit signals with exit reason <u>kill</u> (not <u>killed</u>) to all linked processes. Such
              exit signals with exit reason <u>kill</u> can be trapped by the linked processes. Note  that  this  means
              that  signals  with exit reason <u>kill</u> behave differently depending on how they are sent because the
              signal will be untrappable if a process sends such a signal to another process with <u>erlang:exit/2</u>.

       <b>exit(Pid,</b> <b>Reason)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Pid = pid() | port()
                 Reason = term()

              Sends an exit signal with exit reason <u>Reason</u> to the process or port identified by <u>Pid</u>.

              The following behavior applies if <u>Reason</u> is any term, except <u>normal</u> or <u>kill</u>, and <u>P</u> is the  process
              or port identified by <u>Pid</u>:

                * If <u>P</u> is not trapping exits, <u>P</u> exits with exit reason <u>Reason</u>.

                * If  <u>P</u> is trapping exits, the exit signal is transformed into a message <u>{'EXIT',</u> <u>From,</u> <u>Reason}</u>,
                  where <u>From</u> is the process identifier of the process that sent the exit signal,  and  delivered
                  to the message queue of <u>P</u>.

              The following behavior applies if <u>Reason</u> is the term <u>normal</u> and <u>Pid</u> is the identifier of a process
              <u>P</u>  which is not the same as the process that invoked <u>erlang:exit(Pid,</u> <u>normal)</u> (the behavior when a
              process sends a signal with the <u>normal</u> reason to itself is described in the warning):

                * If <u>P</u> is trapping exits, the exit signal is transformed into a message <u>{'EXIT',</u> <u>From,</u>  <u>normal}</u>,
                  where  <u>From</u>  is the process identifier of the process that sent the exit signal, and delivered
                  to <u>P</u>'s message queue.

                * The signal has no effect if <u>P</u> is not trapping exits.

              If <u>Reason</u> is the atom <u>kill</u>, that is, if <u>exit(Pid,</u> <u>kill)</u> is called, an untrappable exit  signal  is
              sent  to  the  process  that  is  identified  by <u>Pid</u>, which unconditionally exits with exit reason
              <u>killed</u>. The exit reason is changed from <u>kill</u> to <u>killed</u> to hint to linked processes that the killed
              process got killed by a call to <u>exit(Pid,</u> <u>kill)</u>.

          <b>Note:</b>
              The functions <u>erlang:exit/1</u> and <u>erlang:exit/2</u> are  named  similarly  but  provide  very  different
              functionalities.  The <u>erlang:exit/1</u> function should be used when the intent is to stop the current
              process while <u>erlang:exit/2</u> should be used when the intent is to send an exit  signal  to  another
              process.  Note  also that <u>erlang:exit/1</u> raises an exception that can be caught while <u>erlang:exit/2</u>
              does not cause any exception to be raised.

          <b>Warning:</b>
              The only scenario that has not been covered by the description above is when a process <u>P</u> sends  an
              exit  signal  with  reason  <u>normal</u> to itself, that is <u>erlang:exit(self(),</u> <u>normal)</u>. The behavior in
              this scenario is as follows:

                * If <u>P</u> is trapping exits, the exit signal is transformed into a message <u>{'EXIT',</u> <u>From,</u>  <u>normal}</u>,
                  where <u>From</u> is <u>P</u>'s process identifier, and delivered to <u>P</u>'s message queue.

                * <u>P</u> exits with reason <u>normal</u> if <u>P</u> is not trapping exits.

              Note  that the behavior described above is different from when a process sends an exit signal with
              reason <u>normal</u> to another process. This is arguably strange but this behavior is kept for  backward
              compatibility reasons.

       <b>erlang:external_size(Term)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Term = term()

              Calculates,  without  doing  the  encoding, the maximum byte size for a term encoded in the Erlang
              external term format. The following condition applies always:

              &gt; Size1 = byte_size(term_to_binary(Term)),
              &gt; Size2 = erlang:external_size(Term),
              &gt; true = Size1 =&lt; Size2.
              true

              This is equivalent to a call to:

              erlang:external_size(Term, [])

       <b>erlang:external_size(Term,</b> <b>Options)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Term = term()
                 Options = [{minor_version, Version :: integer() &gt;= 0}]

              Calculates, without doing the encoding, the maximum byte size for a term  encoded  in  the  Erlang
              external term format. The following condition applies always:

              &gt; Size1 = byte_size(term_to_binary(Term, Options)),
              &gt; Size2 = erlang:external_size(Term, Options),
              &gt; true = Size1 =&lt; Size2.
              true

              Option  <u>{minor_version,</u> <u>Version}</u> specifies how floats are encoded. For a detailed description, see
              <u>term_to_binary/2</u>.

       <b>float(Number)</b> <b>-&gt;</b> <b>float()</b>

              Types:

                 Number = number()

              Returns a float by converting <u>Number</u> to a float, for example:

              &gt; <a href="../man55/float.55.html">float</a>(55).
              55.0

              Allowed in guard tests.

          <b>Note:</b>
              If used on the top level in a guard, it tests whether the argument is a floating point number; for
              clarity, use <u>is_float/1</u> instead.

              When <u>float/1</u> is used in an expression in a guard, such as '<u>float(A)</u> <u>==</u> <u>4.0</u>', it converts a  number
              as described earlier.

       <b>float_to_binary(Float)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Float = float()

              The same as <u>float_to_binary(Float,[{scientific,20}])</u>.

       <b>float_to_binary(Float,</b> <b>Options)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Float = float()
                 Options = [Option]
                 Option =
                     {decimals, Decimals :: 0..253} |
                     {scientific, Decimals :: 0..249} |
                     compact

              Returns  a  binary  corresponding  to  the  text representation of <u>Float</u> using fixed decimal point
              formatting. <u>Options</u> behaves in the same way as <u>float_to_list/2</u>. Examples:

              &gt; float_to_binary(7.12, [{decimals, 4}]).
              &lt;&lt;"7.1200"&gt;&gt;
              &gt; float_to_binary(7.12, [{decimals, 4}, compact]).
              &lt;&lt;"7.12"&gt;&gt;
              &gt; float_to_binary(7.12, [{scientific, 3}]).
              &lt;&lt;"7.120e+00"&gt;&gt;

       <b>float_to_list(Float)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Float = float()

              The same as <u>float_to_list(Float,[{scientific,20}])</u>.

       <b>float_to_list(Float,</b> <b>Options)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Float = float()
                 Options = [Option]
                 Option =
                     {decimals, Decimals :: 0..253} |
                     {scientific, Decimals :: 0..249} |
                     compact

              Returns a string corresponding to the text representation  of  <u>Float</u>  using  fixed  decimal  point
              formatting.

              Available options:

                * If option <u>decimals</u> is specified, the returned value contains at most <u>Decimals</u> number of digits
                  past the decimal point. If the number does not fit in the internal static buffer of 256 bytes,
                  the function throws <u>badarg</u>.

                * If  option <u>compact</u> is specified, the trailing zeros at the end of the list are truncated. This
                  option is only meaningful together with option <u>decimals</u>.

                * If option <u>scientific</u> is specified, the float  is  formatted  using  scientific  notation  with
                  <u>Decimals</u> digits of precision.

                * If <u>Options</u> is <u>[]</u>, the function behaves as <u>float_to_list/1</u>.

              Examples:

              &gt; float_to_list(7.12, [{decimals, 4}]).
              "7.1200"
              &gt; float_to_list(7.12, [{decimals, 4}, compact]).
              "7.12"
              &gt; float_to_list(7.12, [{scientific, 3}]).
              "7.120e+00"
              &gt; float_to_list(0.1+0.2)
              "3.00000000000000044409e-01"

              In  the last example, <u>float_to_list(0.1+0.2)</u> evaluates to <u>"3.00000000000000044409e-01"</u>. The reason
              for this is explained in Representation of Floating Point Numbers.

       <b>floor(Number)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 Number = number()

              Returns the largest integer not greater than <u>Number</u>. For example:

              &gt; floor(-10.5).
              -11

              Allowed in guard tests.

       <b>erlang:fun_info(Fun)</b> <b>-&gt;</b> <b>[{Item,</b> <b>Info}]</b>

              Types:

                 Fun = function()
                 Item =
                     arity | env | index | name | module | new_index | new_uniq |
                     pid | type | uniq
                 Info = term()

              Returns a list with information about the fun <u>Fun</u>. Each list element is a tuple. The order of  the
              tuples is undefined, and more tuples can be added in a future release.

          <b>Warning:</b>
              This  BIF  is  mainly  intended for debugging, but it can sometimes be useful in library functions
              that need to verify, for example, the arity of a fun.

              Two types of funs have slightly different semantics:

                * A fun created by <u>fun</u> <u>M:F/A</u> is called an <u>external</u> fun. Calling it will always call the function
                  <u>F</u> with arity <u>A</u> in the latest code for module <u>M</u>. Notice that module <u>M</u> does not even need to  be
                  loaded when the fun <u>fun</u> <u>M:F/A</u> is created.

                * All other funs are called <u>local</u>. When a local fun is called, the same version of the code that
                  created the fun is called (even if a newer version of the module has been loaded).

              The following elements are always present in the list for both local and external funs:

                <u>{type,</u> <u>Type}</u>:
                  <u>Type</u> is <u>local</u> or <u>external</u>.

                <u>{module,</u> <u>Module}</u>:
                  <u>Module</u> (an atom) is the module name.

                  If <u>Fun</u> is a local fun, <u>Module</u> is the module in which the fun is defined.

                  If <u>Fun</u> is an external fun, <u>Module</u> is the module that the fun refers to.

                <u>{name,</u> <u>Name}</u>:
                  <u>Name</u> (an atom) is a function name.

                  If  <u>Fun</u>  is a local fun, <u>Name</u> is the name of the local function that implements the fun. (This
                  name was generated by the compiler, and is only  of  informational  use.  As  it  is  a  local
                  function,  it  cannot  be  called directly.) If no code is currently loaded for the fun, <u>[]</u> is
                  returned instead of an atom.

                  If <u>Fun</u> is an external fun, <u>Name</u> is the name of the exported function that the fun refers to.

                <u>{arity,</u> <u>Arity}</u>:
                  <u>Arity</u> is the number of arguments that the fun is to be called with.

                <u>{env,</u> <u>Env}</u>:
                  <u>Env</u> (a list) is the environment or free variables for the fun. For external funs, the returned
                  list is always empty.

              The following elements are only present in the list if <u>Fun</u> is local:

                <u>{pid,</u> <u>Pid}</u>:
                  <u>Pid</u> is the process identifier of the process that originally created the fun.

                  It might point to the <u>init</u> process if the <u>Fun</u> was statically allocated when module was  loaded
                  (this optimisation is performed for local functions that do not capture the environment).

                <u>{index,</u> <u>Index}</u>:
                  <u>Index</u> (an integer) is an index into the module fun table.

                <u>{new_index,</u> <u>Index}</u>:
                  <u>Index</u> (an integer) is an index into the module fun table.

                <u>{new_uniq,</u> <u>Uniq}</u>:
                  <u>Uniq</u>  (a  binary)  is a unique value for this fun. It is calculated from the compiled code for
                  the entire module.

                <u>{uniq,</u> <u>Uniq}</u>:
                  <u>Uniq</u> (an integer) is a unique value for this fun. As from  Erlang/OTP  R15,  this  integer  is
                  calculated  from  the compiled code for the entire module. Before Erlang/OTP R15, this integer
                  was based on only the body of the fun.

       <b>erlang:fun_info(Fun,</b> <b>Item)</b> <b>-&gt;</b> <b>{Item,</b> <b>Info}</b>

              Types:

                 Fun = function()
                 Item = fun_info_item()
                 Info = term()
                 <b>fun_info_item()</b> =
                     arity | env | index | name | module | new_index | new_uniq |
                     pid | type | uniq

              Returns information about <u>Fun</u> as specified by <u>Item</u>, in the form <u>{Item,Info}</u>.

              For any fun, <u>Item</u> can be any of the atoms <u>module</u>, <u>name</u>, <u>arity</u>, <u>env</u>, or <u>type</u>.

              For a local fun, <u>Item</u> can also be any of the atoms <u>index</u>, <u>new_index</u>, <u>new_uniq</u>, <u>uniq</u>, and <u>pid</u>.  For
              an external fun, the value of any of these items is always the atom <u>undefined</u>.

              See <u>erlang:fun_info/1</u>.

       <b>erlang:fun_to_list(Fun)</b> <b>-&gt;</b> <b>String</b> <b>::</b> <b>string()</b>

              Types:

                 Fun = function()

              Returns <u>String</u> that represents the code that created <u>Fun</u>.

              <u>String</u>  has  the  following  form,  if  <u>Fun</u>  was  created  by  a  fun  expression  of the form <u>fun</u>
              <u>ModuleName:FuncName/Arity</u>:

              <u>"fun</u> <u>ModuleName:FuncName/Arity"</u>

              The form of <u>String</u> when <u>Fun</u> is created from other types of fun expressions differs depending on if
              the fun expression was executed while executing  compiled  code  or  if  the  fun  expression  was
              executed  while  executing  uncompiled code (uncompiled escripts, the Erlang shell, and other code
              executed by the erl_eval module):

                <b>compiled</b> <b>code:</b>
                  <u>"#Fun&lt;M.I.U&gt;"</u>, where M, I and U correspond to the values named <u>module</u>, <u>index</u> and <u>uniq</u>  in  the
                  result of <u>erlang:fun_info(Fun)</u>.

                <b>uncompiled</b> <b>code:</b>
                  All funs created from fun expressions in uncompiled code with the same arity are mapped to the
                  same list by <u>fun_to_list/1</u>.

          <b>Note:</b>
              Generally,  one can not use <u>fun_to_list/1</u> to check if two funs are equal as <u>fun_to_list/1</u> does not
              take the fun's environment into account. See <u>erlang:fun_info/1</u> for how to get the environment of a
              fun.

          <b>Note:</b>
              The output of <u>fun_to_list/1</u> can differ between Erlang implementations and  may  change  in  future
              versions.

              Examples:

              -module(test).
              -export([add/1, add2/0, fun_tuple/0]).
              add(A) -&gt; fun(B) -&gt; A + B end.
              add2() -&gt; fun add/1.
              fun_tuple() -&gt; {fun() -&gt; 1 end, fun() -&gt; 1 end}.

              &gt; {fun test:add/1, test:add2()}.
              {fun test:add/1,#Fun&lt;test.1.107738983&gt;}

              Explanation: <u>fun</u> <u>test:add/1</u> is upgradable but <u>test:add2()</u> is not upgradable.

              &gt; {test:<a href="../man1/add.1.html">add</a>(1), test:<a href="../man42/add.42.html">add</a>(42)}.
              {#Fun&lt;test.0.107738983&gt;,#Fun&lt;test.0.107738983&gt;}

              Explanation: <u>test:<a href="../man1/add.1.html">add</a>(1)</u> and <u>test:<a href="../man42/add.42.html">add</a>(42)</u> has the same string representation as the environment is
              not taken into account.

              &gt;test:fun_tuple().
              {#Fun&lt;test.2.107738983&gt;,#Fun&lt;test.3.107738983&gt;}

              Explanation:  The  string  representations  differ  because  the  funs  come  from  different  fun
              experssions.

              &gt; {fun() -&gt; 1 end, fun() -&gt; 1 end}. &gt;
              {#Fun&lt;erl_eval.45.97283095&gt;,#Fun&lt;erl_eval.45.97283095&gt;}

              Explanation: All funs created from fun expressions of this form in uncompiled code with  the  same
              arity are mapped to the same list by <u>fun_to_list/1</u>.

       <b>erlang:function_exported(Module,</b> <b>Function,</b> <b>Arity)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Module = module()
                 Function = atom()
                 Arity = arity()

              Returns  <u>true</u> if the module <u>Module</u> is current and contains an exported function <u>Function/Arity</u>, or
              if there is a BIF (a built-in function implemented  in  C)  with  the  specified  name,  otherwise
              returns <u>false</u>.

       <b>garbage_collect()</b> <b>-&gt;</b> <b>true</b>

              Forces  an  immediate  garbage collection of the executing process. The function is not to be used
              unless it has been noticed (or there are good reasons to suspect)  that  the  spontaneous  garbage
              collection will occur too late or not at all.

          <b>Warning:</b>
              Improper use can seriously degrade system performance.

       <b>garbage_collect(Pid)</b> <b>-&gt;</b> <b>GCResult</b>

              Types:

                 Pid = pid()
                 GCResult = boolean()

              The same as <u>garbage_collect(Pid,</u> <u>[])</u>.

       <b>garbage_collect(Pid,</b> <b>OptionList)</b> <b>-&gt;</b> <b>GCResult</b> <b>|</b> <b>async</b>

              Types:

                 Pid = pid()
                 RequestId = term()
                 Option = {async, RequestId} | {type, major | minor}
                 OptionList = [Option]
                 GCResult = boolean()

              Garbage collects the node local process identified by <u>Pid</u>.

              <u>Option</u>:

                <u>{async,</u> <u>RequestId}</u>:
                  The  function <u>garbage_collect/2</u> returns the value <u>async</u> immediately after the request has been
                  sent. When the request has been processed, the process that called this function is  passed  a
                  message on the form <u>{garbage_collect,</u> <u>RequestId,</u> <u>GCResult}</u>.

                <u>{type,</u> <u>'major'</u> <u>|</u> <u>'minor'}</u>:
                  Triggers garbage collection of requested type. Default value is <u>'major'</u>, which would trigger a
                  fullsweep GC. The option <u>'minor'</u> is considered a hint and may lead to either minor or major GC
                  run.

              If  <u>Pid</u> equals <u>self()</u>, and no <u>async</u> option has been passed, the garbage collection is performed at
              once, that is, the same as calling <u>garbage_collect/0</u>. Otherwise a request for  garbage  collection
              is sent to the process identified by <u>Pid</u>, and will be handled when appropriate. If no <u>async</u> option
              has been passed, the caller blocks until <u>GCResult</u> is available and can be returned.

              <u>GCResult</u> informs about the result of the garbage collection request as follows:

                <u>true</u>:
                   The process identified by <u>Pid</u> has been garbage collected.

                <u>false</u>:
                   No  garbage  collection was performed, as the process identified by <u>Pid</u> terminated before the
                  request could be satisfied.

              Notice that the same caveats apply as for <u>garbage_collect/0</u>.

              Failures:

                <u>badarg</u>:
                   If <u>Pid</u> is not a node local process identifier.

                <u>badarg</u>:
                   If <u>OptionList</u> is an invalid list of options.

       <b>get()</b> <b>-&gt;</b> <b>[{Key,</b> <b>Val}]</b>

              Types:

                 Key = Val = term()

              Returns the process dictionary as a list of <u>{Key,</u> <u>Val}</u> tuples. The items in the returned list  can
              be in any order. Example:

              &gt; put(key1, merry),
              put(key2, lambs),
              put(key3, {are, playing}),
              get().
              [{key1,merry},{key2,lambs},{key3,{are,playing}}]

       <b>get(Key)</b> <b>-&gt;</b> <b>Val</b> <b>|</b> <b>undefined</b>

              Types:

                 Key = Val = term()

              Returns  the value <u>Val</u> associated with <u>Key</u> in the process dictionary, or <u>undefined</u> if <u>Key</u> does not
              exist. The expected time complexity for the current implementation of this function  is  O(<u>1</u>)  and
              the  worst case time complexity is O(<u>N</u>), where <u>N</u> is the number of items in the process dictionary.
              Example:

              &gt; put(key1, merry),
              put(key2, lambs),
              put({any, [valid, term]}, {are, playing}),
              get({any, [valid, term]}).
              {are,playing}

       <b>erlang:get_cookie()</b> <b>-&gt;</b> <b>Cookie</b> <b>|</b> <b>nocookie</b>

              Types:

                 Cookie = atom()

              Returns the magic cookie of the local node if the node is alive, otherwise the atom <u>nocookie</u>.

       <b>erlang:get_cookie(Node)</b> <b>-&gt;</b> <b>Cookie</b> <b>|</b> <b>nocookie</b>

              Types:

                 Node = node()
                 Cookie = atom()

              Returns the magic cookie for node <u>Node</u> if the local node is alive, otherwise the atom <u>nocookie</u>.

       <b>get_keys()</b> <b>-&gt;</b> <b>[Key]</b>

              Types:

                 Key = term()

              Returns a list of all keys present in the process dictionary. The items in the returned  list  can
              be in any order. Example:

              &gt; put(dog, {animal,1}),
              put(cow, {animal,2}),
              put(lamb, {animal,3}),
              get_keys().
              [dog,cow,lamb]

       <b>get_keys(Val)</b> <b>-&gt;</b> <b>[Key]</b>

              Types:

                 Val = Key = term()

              Returns a list of keys that are associated with the value <u>Val</u> in the process dictionary. The items
              in the returned list can be in any order. Example:

              &gt; put(mary, {1, 2}),
              put(had, {1, 2}),
              put(a, {1, 2}),
              put(little, {1, 2}),
              put(dog, {1, 3}),
              put(lamb, {1, 2}),
              get_keys({1, 2}).
              [mary,had,a,little,lamb]

       <b>group_leader()</b> <b>-&gt;</b> <b>pid()</b>

              Returns the process identifier of the group leader for the process evaluating the function.

              Every  process  is a member of some process group and all groups have a <u>group</u> <u>leader</u>. All I/O from
              the group is channeled to the group leader. When a new process is spawned, it gets the same  group
              leader  as  the  spawning process. Initially, at system startup, <u>init</u> is both its own group leader
              and the group leader of all processes.

       <b>group_leader(GroupLeader,</b> <b>Pid)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 GroupLeader = Pid = pid()

              Sets the group leader of <u>Pid</u> to <u>GroupLeader</u>. Typically, this is used when a process started from a
              certain shell is to have another group leader than <u>init</u>.

              The group leader should be rarely changed in applications with a  supervision  tree,  because  OTP
              assumes the group leader of their processes is their application master.

              Setting  the  group  leader  follows  the  signal  ordering guarentees described in the  Processes
              Chapter in the <u>Erlang</u> <u>Reference</u> <u>Manual</u> .

              See also <u>group_leader/0</u> and OTP design principles related to starting and stopping applications.

       <b>halt()</b> <b>-&gt;</b> <b>no_return()</b>

              The same as <u>halt(0,</u> <u>[])</u>. Example:

              &gt; halt().
              os_prompt%

       <b>halt(Status)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Status = integer() &gt;= 0 | abort | string()

              The same as <u>halt(Status,</u> <u>[])</u>. Example:

              &gt; <a href="../man17/halt.17.html">halt</a>(17).
              os_prompt% echo $?
              17
              os_prompt%

       <b>halt(Status,</b> <b>Options)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Status = integer() &gt;= 0 | abort | string()
                 Options = [Option]
                 Option = {flush, boolean()}

              <u>Status</u> must be a non-negative integer, a string, or the  atom  <u>abort</u>.  Halts  the  Erlang  runtime
              system. Has no return value. Depending on <u>Status</u>, the following occurs:

                <b>integer():</b>
                  The  runtime  system exits with integer value <u>Status</u> as status code to the calling environment
                  (OS).

            <b>Note:</b>
                On many platforms, the OS supports only status codes 0-255. A too large status code is truncated
                by clearing the high bits.

                <b>string():</b>
                  An Erlang crash dump is produced with <u>Status</u> as slogan. Then the  runtime  system  exits  with
                  status code <u>1</u>. The string will be truncated if longer than 200 characters.

            <b>Note:</b>
                Before  ERTS  9.1 (OTP-20.1) only code points in the range 0-255 was accepted in the string. Now
                any unicode string is valid.

                <u>abort</u>:
                  The runtime system aborts producing a core dump, if that is enabled in the OS.

              For integer <u>Status</u>, the Erlang runtime system closes all ports and allows async threads to  finish
              their operations before exiting. To exit without such flushing, use <u>Option</u> as <u>{flush,false}</u>.

              For statuses <u>string()</u> and <u>abort</u>, option <u>flush</u> is ignored and flushing is <u>not</u> done.

       <b>hd(List)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 List = [term(), ...]

              Returns the head of <u>List</u>, that is, the first element, for example:

              &gt; hd([1,2,3,4,5]).
              1

              Allowed in guard tests.

              Failure: <u>badarg</u> if <u>List</u> is the empty list <u>[]</u>.

       <b>erlang:hibernate(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]

              Puts the calling process into a wait state where its memory allocation has been reduced as much as
              possible. This is useful if the process does not expect to receive any messages soon.

              The  process  is  awaken when a message is sent to it, and control resumes in <u>Module:Function</u> with
              the arguments specified by <u>Args</u> with the call stack emptied, meaning that the  process  terminates
              when  that  function  returns.  Thus  <u>erlang:hibernate/3</u>  never  returns to its caller. The resume
              function <u>Module:Function/Arity</u> must be exported (<u>Arity</u> =:= <u>length(Args)</u>).

              If the process has any message in its message queue, the process is awakened  immediately  in  the
              same way as described earlier.

              In  more  technical  terms,  <u>erlang:hibernate/3</u>  discards the call stack for the process, and then
              garbage collects the process. After this, all live data is in one continuous  heap.  The  heap  is
              then  shrunken  to  the  exact same size as the live data that it holds (even if that size is less
              than the minimum heap size for the process).

              If the size of the live data in the process is less than the minimum heap size, the first  garbage
              collection occurring after the process is awakened ensures that the heap size is changed to a size
              not smaller than the minimum heap size.

              Notice  that  emptying  the call stack means that any surrounding <u>catch</u> is removed and must be re-
              inserted after hibernation. One effect of this is that  processes  started  using  <u>proc_lib</u>  (also
              indirectly, such as <u>gen_server</u> processes), are to use <u>proc_lib:hibernate/3</u> instead, to ensure that
              the exception handler continues to work when the process wakes up.

       <b>erlang:insert_element(Index,</b> <b>Tuple1,</b> <b>Term)</b> <b>-&gt;</b> <b>Tuple2</b>

              Types:

                 Index = integer() &gt;= 1
                   1..tuple_size(Tuple1) + 1
                 Tuple1 = Tuple2 = tuple()
                 Term = term()

              Returns  a  new  tuple  with element <u>Term</u> inserted at position <u>Index</u> in tuple <u>Tuple1</u>. All elements
              from position <u>Index</u> and upwards are pushed one step higher in the new tuple <u>Tuple2</u>. Example:

              &gt; erlang:insert_element(2, {one, two, three}, new).
              {one,new,two,three}

       <b>integer_to_binary(Integer)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Integer = integer()

              Returns a binary corresponding to the text representation of <u>Integer</u>, for example:

              &gt; <a href="../man77/integer_to_binary.77.html">integer_to_binary</a>(77).
              &lt;&lt;"77"&gt;&gt;

       <b>integer_to_binary(Integer,</b> <b>Base)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Integer = integer()
                 Base = 2..36

              Returns a binary corresponding to the text representation of <u>Integer</u> in base <u>Base</u>, for example:

              &gt; integer_to_binary(1023, 16).
              &lt;&lt;"3FF"&gt;&gt;

       <b>integer_to_list(Integer)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Integer = integer()

              Returns a string corresponding to the text representation of <u>Integer</u>, for example:

              &gt; <a href="../man77/integer_to_list.77.html">integer_to_list</a>(77).
              "77"

       <b>integer_to_list(Integer,</b> <b>Base)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Integer = integer()
                 Base = 2..36

              Returns a string corresponding to the text representation of <u>Integer</u> in base <u>Base</u>, for example:

              &gt; integer_to_list(1023, 16).
              "3FF"

       <b>iolist_size(Item)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Item = iolist() | binary()

              Returns an integer, that is the size in  bytes,  of  the  binary  that  would  be  the  result  of
              <u>iolist_to_binary(Item)</u>, for example:

              &gt; iolist_size([1,2|&lt;&lt;3,4&gt;&gt;]).
              4

       <b>iolist_to_binary(IoListOrBinary)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 IoListOrBinary = iolist() | binary()

              Returns a binary that is made from the integers and binaries in <u>IoListOrBinary</u>, for example:

              &gt; Bin1 = &lt;&lt;1,2,3&gt;&gt;.
              &lt;&lt;1,2,3&gt;&gt;
              &gt; Bin2 = &lt;&lt;4,5&gt;&gt;.
              &lt;&lt;4,5&gt;&gt;
              &gt; Bin3 = &lt;&lt;6&gt;&gt;.
              &lt;&lt;6&gt;&gt;
              &gt; iolist_to_binary([Bin1,1,[2,3,Bin2],4|Bin3]).
              &lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;

       <b>erlang:iolist_to_iovec(IoListOrBinary)</b> <b>-&gt;</b> <b>iovec()</b>

              Types:

                 IoListOrBinary = iolist() | binary()

              Returns  an  iovec that is made from the integers and binaries in <u>IoListOrBinary</u>. This function is
              useful when you want to flatten an iolist but you do not need a single binary. This can be  useful
              for  passing  the  data  to  nif functions such as <u>enif_inspect_iovec</u> or do more efficient message
              passing. The advantage of using this function over <u>iolist_to_binary/1</u> is that it does not have  to
              copy  off-heap binaries. Example:

              &gt; Bin1 = &lt;&lt;1,2,3&gt;&gt;.
              &lt;&lt;1,2,3&gt;&gt;
              &gt; Bin2 = &lt;&lt;4,5&gt;&gt;.
              &lt;&lt;4,5&gt;&gt;
              &gt; Bin3 = &lt;&lt;6&gt;&gt;.
              &lt;&lt;6&gt;&gt;
              %% If you pass small binaries and integers it works as iolist_to_binary
              &gt; erlang:iolist_to_iovec([Bin1,1,[2,3,Bin2],4|Bin3]).
              [&lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;]
              %% If you pass larger binaries, they are split and returned in a form
              %% optimized for calling the C function writev.
              &gt; erlang:iolist_to_iovec([&lt;&lt;1&gt;&gt;,&lt;&lt;2:8096&gt;&gt;,&lt;&lt;3:8096&gt;&gt;]).
              [&lt;&lt;1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                 0,...&gt;&gt;,
               &lt;&lt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                 ...&gt;&gt;,
               &lt;&lt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...&gt;&gt;]

       <b>is_alive()</b> <b>-&gt;</b> <b>boolean()</b>

              Returns  <u>true</u>  if  the  local  node  is  alive  (that is, if the node can be part of a distributed
              system), otherwise <u>false</u>. A node is alive if it is started with:

                * <u>"erl</u> <u>-name</u> <u>LONGNAME"</u> or,

                * <u>"erl</u> <u>-sname</u> <u>SHORTNAME"</u>.

              A node can also be alive if it has got a name from a call to <u>net_kernel:start/1</u> and has  not  been
              stopped by a call to <u>net_kernel:stop/0</u>.

       <b>is_atom(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is an atom, otherwise <u>false</u>.

              Allowed in guard tests.

       <b>is_binary(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a binary, otherwise <u>false</u>.

              A binary always contains a complete number of bytes.

              Allowed in guard tests.

       <b>is_bitstring(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a bitstring (including a binary), otherwise <u>false</u>.

              Allowed in guard tests.

       <b>is_boolean(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns  <u>true</u>  if  <u>Term</u> is the atom <u>true</u> or the atom <u>false</u> (that is, a boolean). Otherwise returns
              <u>false</u>.

              Allowed in guard tests.

       <b>erlang:is_builtin(Module,</b> <b>Function,</b> <b>Arity)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Module = module()
                 Function = atom()
                 Arity = arity()

              This BIF is useful for builders of cross-reference tools.

              Returns <u>true</u> if <u>Module:Function/Arity</u> is a BIF implemented in C, otherwise <u>false</u>.

       <b>is_float(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a floating point number, otherwise <u>false</u>.

              Allowed in guard tests.

       <b>is_function(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a fun, otherwise <u>false</u>.

              Allowed in guard tests.

       <b>is_function(Term,</b> <b>Arity)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()
                 Arity = arity()

              Returns <u>true</u> if <u>Term</u> is a fun that can be applied with <u>Arity</u> number of arguments, otherwise <u>false</u>.

              Allowed in guard tests.

       <b>is_integer(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is an integer, otherwise <u>false</u>.

              Allowed in guard tests.

       <b>is_list(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a list with zero or more elements, otherwise <u>false</u>.

              Allowed in guard tests.

       <b>is_map(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a map, otherwise <u>false</u>.

              Allowed in guard tests.

       <b>is_map_key(Key,</b> <b>Map)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Key = term()
                 Map = map()

              Returns <u>true</u> if map <u>Map</u> contains <u>Key</u> and returns <u>false</u> if it does not contain the <u>Key</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map</u> is not a map.

              <u>Example:</u>

              &gt; Map = #{"42" =&gt; value}.
              #{"42" =&gt; value}
              &gt; is_map_key("42",Map).
              true
              &gt; is_map_key(value,Map).
              false

              Allowed in guard tests.

       <b>is_number(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is an integer or a floating point number. Otherwise returns <u>false</u>.

              Allowed in guard tests.

       <b>is_pid(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a process identifier, otherwise <u>false</u>.

              Allowed in guard tests.

       <b>is_port(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a port identifier, otherwise <u>false</u>.

              Allowed in guard tests.

       <b>is_process_alive(Pid)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Pid = pid()

              <u>Pid</u> must refer to a process at the local node.

              Returns <u>true</u> if the process exists and is alive, that is, is  not  exiting  and  has  not  exited.
              Otherwise returns <u>false</u>.

              If  process <u>P1</u> calls <u>is_process_alive(P2Pid)</u> it is guaranteed that all signals, sent from <u>P1</u> to <u>P2</u>
              (<u>P2</u> is the process with identifier <u>P2Pid</u>) before the call, will be  delivered  to  <u>P2</u>  before  the
              aliveness  of  <u>P2</u>  is  checked.  This guarantee means that one can use <u>is_process_alive/1</u> to let a
              process <u>P1</u> wait until a process <u>P2</u>, which has got an exit signal with  reason  <u>kill</u>  from  P1,  is
              killed. Example:

              exit(P2Pid, kill),
              % P2 might not be killed
              is_process_alive(P2Pid),
              % P2 is not alive (the call above always return false)

              See  the documentation about signals and erlang:exit/2 for more information about signals and exit
              singnals.

       <b>is_record(Term,</b> <b>RecordTag)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()
                 RecordTag = atom()

              Returns <u>true</u> if <u>Term</u> is a tuple and its first element is <u>RecordTag</u>. Otherwise returns <u>false</u>.

          <b>Note:</b>
              Normally the compiler treats calls to <u>is_record/2</u> especially. It emits code to verify that <u>Term</u> is
              a tuple, that its first element is <u>RecordTag</u>, and that the size is correct. However, if  <u>RecordTag</u>
              is  not  a  literal  atom,  the BIF <u>is_record/2</u> is called instead and the size of the tuple is not
              verified.

              Allowed in guard tests, if <u>RecordTag</u> is a literal atom.

       <b>is_record(Term,</b> <b>RecordTag,</b> <b>Size)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()
                 RecordTag = atom()
                 Size = integer() &gt;= 0

              <u>RecordTag</u> must be an atom.

              Returns <u>true</u> if <u>Term</u> is a tuple, its first element is <u>RecordTag</u>, and its size is  <u>Size</u>.  Otherwise
              returns <u>false</u>.

              Allowed in guard tests if <u>RecordTag</u> is a literal atom and <u>Size</u> is a literal integer.

          <b>Note:</b>
              This BIF is documented for completeness. Usually <u>is_record/2</u> is to be used.

       <b>is_reference(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a reference, otherwise <u>false</u>.

              Allowed in guard tests.

       <b>is_tuple(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a tuple, otherwise <u>false</u>.

              Allowed in guard tests.

       <b>length(List)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 List = [term()]

              Returns the length of <u>List</u>, for example:

              &gt; length([1,2,3,4,5,6,7,8,9]).
              9

              Allowed in guard tests.

       <b>link(PidOrPort)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 PidOrPort = pid() | port()

              Sets  up and activates a link between the calling process and another process or a port identified
              by <u>PidOrPort</u>. We will from here on call the identified process or port linkee. If the linkee is  a
              port, it must reside on the same node as the caller.

              If  one  of  the  participants  of  a  link  terminates,  it will send an exit signal to the other
              participant. The exit signal will contain the exit reason of  the  terminated  participant.  Other
              cases  when exit signals are triggered due to a link are when no linkee exist (<u>noproc</u> exit reason)
              and when the connection between  linked  processes  on  different  nodes  is  lost  or  cannot  be
              established (<u>noconnection</u> exit reason).

              An  existing  link  can  be  removed  by  calling <u>unlink/1</u>. For more information on links and exit
              signals due to links, see the <u>Processes</u>  chapter in the <u>Erlang</u> <u>Reference</u> <u>Manual</u> :

                * Links

                * Sending Exit Signals

                * Receiving Exit Signals

              For historical reasons, <u>link/1</u> has a strange semi-synchronous behavior when it is "cheap" to check
              if the linkee exists or not, and the caller does not trap exits. If the  above  is  true  and  the
              linkee  does  not  exist,  <u>link/1</u> will raise a <u>noproc</u> error <u>exception</u>. The expected behavior would
              instead have been that <u>link/1</u> returned <u>true</u>, and the caller later was sent  an  exit  signal  with
              <u>noproc</u>  exit  reason,  but  this is unfortunately not the case. The <u>noproc</u>  exception is not to be
              confused with an exit signal with exit reason <u>noproc</u>. Currently it is  "cheap"  to  check  if  the
              linkee exists when it is supposed to reside on the same node as the calling process.

              The  link  setup and activation is performed asynchronously. If the link already exists, or if the
              caller attempts to create a link to itself, nothing is done. A detailed description  of  the  link
              protocol can be found in the <u>Distribution</u> <u>Protocol</u>  chapter of the <u>ERTS</u> <u>User's</u> <u>Guide</u> .

              Failure:

                * <u>badarg</u> if <u>PidOrPort</u> does not identify a process or a node local port.

                * <u>noproc</u> linkee does not exist and it is "cheap" to check if it exists as described above.

       <b>list_to_atom(String)</b> <b>-&gt;</b> <b>atom()</b>

              Types:

                 String = string()

              Returns the atom whose text representation is <u>String</u>.

              As  from  Erlang/OTP  20,  <u>String</u> may contain any Unicode character. Earlier versions allowed only
              ISO-latin-1 characters as the implementation did not allow Unicode characters above 255.

          <b>Note:</b>
              The number of characters that are permitted in an atom name is limited. The default limits can  be
              found in the  efficiency guide (section Advanced).

          <b>Note:</b>
              There  is configurable limit on how many atoms that can exist and atoms are not garbage collected.
              Therefore, it is recommended to consider  if  <u>list_to_existing_atom/1</u>  is  a  better  option  than
              <u>list_to_atom/1</u>. The default limits can be found in the efficiency guide (section Advanced).

              Example:

              &gt; list_to_atom("Erlang").
              'Erlang'

       <b>list_to_binary(IoList)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 IoList = iolist()

              Returns a binary that is made from the integers and binaries in <u>IoList</u>, for example:

              &gt; Bin1 = &lt;&lt;1,2,3&gt;&gt;.
              &lt;&lt;1,2,3&gt;&gt;
              &gt; Bin2 = &lt;&lt;4,5&gt;&gt;.
              &lt;&lt;4,5&gt;&gt;
              &gt; Bin3 = &lt;&lt;6&gt;&gt;.
              &lt;&lt;6&gt;&gt;
              &gt; list_to_binary([Bin1,1,[2,3,Bin2],4|Bin3]).
              &lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;

       <b>list_to_bitstring(BitstringList)</b> <b>-&gt;</b> <b>bitstring()</b>

              Types:

                 BitstringList = bitstring_list()
                 <b>bitstring_list()</b> =
                     maybe_improper_list(byte() | bitstring() | bitstring_list(),
                                         bitstring() | [])

              Returns a bitstring that is made from the integers and bitstrings in <u>BitstringList</u>. (The last tail
              in <u>BitstringList</u> is allowed to be a bitstring.) Example:

              &gt; Bin1 = &lt;&lt;1,2,3&gt;&gt;.
              &lt;&lt;1,2,3&gt;&gt;
              &gt; Bin2 = &lt;&lt;4,5&gt;&gt;.
              &lt;&lt;4,5&gt;&gt;
              &gt; Bin3 = &lt;&lt;6,7:4&gt;&gt;.
              &lt;&lt;6,7:4&gt;&gt;
              &gt; list_to_bitstring([Bin1,1,[2,3,Bin2],4|Bin3]).
              &lt;&lt;1,2,3,1,2,3,4,5,4,6,7:4&gt;&gt;

       <b>list_to_existing_atom(String)</b> <b>-&gt;</b> <b>atom()</b>

              Types:

                 String = string()

              Returns  the atom whose text representation is <u>String</u>, but only if there already exists such atom.
              An atom exists if it has been created by the run-time system by either loading code or creating  a
              term in which the atom is part.

              Failure: <u>badarg</u> if there does not already exist an atom whose text representation is <u>String</u>.

          <b>Note:</b>
              Note  that  the  compiler  may  optimize  away  atoms.  For  example,  the  compiler  will rewrite
              <u>atom_to_list(some_atom)</u> to <u>"some_atom"</u>. If that  expression  is  the  only  mention  of  the  atom
              <u>some_atom</u>  in the containing module, the atom will not be created when the module is loaded, and a
              subsequent call to <u>list_to_existing_atom("some_atom")</u> will fail.

       <b>list_to_float(String)</b> <b>-&gt;</b> <b>float()</b>

              Types:

                 String = string()

              Returns the float whose text representation is <u>String</u>, for example:

              &gt; list_to_float("2.2017764e+0").
              2.2017764

              The float string format is the same as the format  for  Erlang  float  literals  except  for  that
              underscores are not permitted.

              Failure: <u>badarg</u> if <u>String</u> contains a bad representation of a float.

       <b>list_to_integer(String)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 String = string()

              Returns an integer whose text representation is <u>String</u>, for example:

              &gt; list_to_integer("123").
              123

              &gt; list_to_integer("-123").
              -123

              &gt; list_to_integer("+123234982304982309482093833234234").
              123234982304982309482093833234234

              <u>String</u>  must  contain at least one digit character and can have an optional prefix consisting of a
              single "<u>+</u>" or "<u>-</u>" character (that is, <u>String</u> must match the regular expression <u>"^[+-]?[0-9]+$"</u>).

              Failure: <u>badarg</u> if <u>String</u> contains a bad representation of an integer.

       <b>list_to_integer(String,</b> <b>Base)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 String = string()
                 Base = 2..36

              Returns an integer whose text representation in base <u>Base</u> is <u>String</u>, for example:

              &gt; list_to_integer("3FF", 16).
              1023

              &gt; list_to_integer("+3FF", 16).
              1023

              &gt; list_to_integer("3ff", 16).
              1023

              &gt; list_to_integer("3fF", 16).
              1023

              &gt; list_to_integer("-3FF", 16).
              -1023

              For example, when <u>Base</u> is 16, <u>String</u> must match  the  regular  expression  <u>"^[+-]?([0-9]|[A-F]|[a-</u>
              <u>f])+$"</u>.

              Failure: <u>badarg</u> if <u>String</u> contains a bad representation of an integer.

       <b>list_to_pid(String)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 String = string()

              Returns a process identifier whose text representation is a <u>String</u>, for example:

              &gt; list_to_pid("&lt;0.4.1&gt;").
              &lt;0.4.1&gt;

              Failure: <u>badarg</u> if <u>String</u> contains a bad representation of a process identifier.

          <b>Warning:</b>
              This BIF is intended for debugging and is not to be used in application programs.

       <b>list_to_port(String)</b> <b>-&gt;</b> <b>port()</b>

              Types:

                 String = string()

              Returns a port identifier whose text representation is a <u>String</u>, for example:

              &gt; list_to_port("#Port&lt;0.4&gt;").
              #Port&lt;0.4&gt;

              Failure: <u>badarg</u> if <u>String</u> contains a bad representation of a port identifier.

          <b>Warning:</b>
              This BIF is intended for debugging and is not to be used in application programs.

       <b>list_to_ref(String)</b> <b>-&gt;</b> <b>reference()</b>

              Types:

                 String = string()

              Returns a reference whose text representation is a <u>String</u>, for example:

              &gt; list_to_ref("#Ref&lt;0.4192537678.4073193475.71181&gt;").
              #Ref&lt;0.4192537678.4073193475.71181&gt;

              Failure: <u>badarg</u> if <u>String</u> contains a bad representation of a reference.

          <b>Warning:</b>
              This BIF is intended for debugging and is not to be used in application programs.

       <b>list_to_tuple(List)</b> <b>-&gt;</b> <b>tuple()</b>

              Types:

                 List = [term()]

              Returns a tuple corresponding to <u>List</u>, for example

              &gt; list_to_tuple([share, ['Ericsson_B', 163]]).
              {share, ['Ericsson_B', 163]}

              <u>List</u> can contain any Erlang terms.

       <b>load_module(Module,</b> <b>Binary)</b> <b>-&gt;</b> <b>{module,</b> <b>Module}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Module = module()
                 Binary = binary()
                 Reason = badfile | not_purged | on_load

              If <u>Binary</u> contains the object code for module <u>Module</u>, this BIF loads that object code. If the code
              for  module  <u>Module</u>  already exists, all export references are replaced so they point to the newly
              loaded code. The previously loaded code is kept in the system as old code, as there can  still  be
              processes executing that code.

              Returns  either  <u>{module,</u>  <u>Module}</u>,  or  <u>{error,</u>  <u>Reason}</u>  if  loading fails. <u>Reason</u> is one of the
              following:

                <u>badfile</u>:
                  The object code in <u>Binary</u> has an incorrect format <u>or</u> the object code contains code for another
                  module than <u>Module</u>.

                <u>not_purged</u>:
                  <u>Binary</u> contains a module that cannot be loaded  because  old  code  for  this  module  already
                  exists.

                <u>on_load</u>:
                  The  code  in  <u>Binary</u>  contains an <u>on_load</u> declaration that must be executed before <u>Binary</u> can
                  become the current code. Any previous current code for <u>Module</u> will remain  until  the  <u>on_load</u>
                  call has finished.

          <b>Warning:</b>
              This BIF is intended for the code server (see <u><a href="../man3erl/code.3erl.html">code</a>(3erl)</u>) and is not to be used elsewhere.

       <b>erlang:load_nif(Path,</b> <b>LoadInfo)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 Path = string()
                 LoadInfo = term()
                 Error = {error, {Reason, Text :: string()}}
                 Reason =
                     load_failed | bad_lib | load | reload | upgrade | old_code

              Loads  and  links  a  dynamic library containing native implemented functions (NIFs) for a module.
              <u>Path</u> is a file path to the shareable object/dynamic  library  file  minus  the  OS-dependent  file
              extension  (<u>.so</u>  for Unix and <u>.dll</u> for Windows). Notice that on most OSs the library has to have a
              different name on disc when an upgrade of the nif is done. If  the  name  is  the  same,  but  the
              contents  differ, the old library may be loaded instead. For information on how to implement a NIF
              library, see <u><a href="../man3erl/erl_nif.3erl.html">erl_nif</a>(3erl)</u>.

              <u>LoadInfo</u> can be any term. It is passed on to the library as part of  the  initialization.  A  good
              practice is to include a module version number to support future code upgrade scenarios.

              The  call  to  <u>load_nif/2</u>  must  be  made <u>directly</u> from the Erlang code of the module that the NIF
              library belongs to. It returns either <u>ok</u>, or <u>{error,{Reason,Text}}</u> if loading fails. <u>Reason</u> is one
              of the following atoms while <u>Text</u> is a human readable string that can give more information  about
              the failure:

                <u>load_failed</u>:
                  The OS failed to load the NIF library.

                <u>bad_lib</u>:
                  The library did not fulfill the requirements as a NIF library of the calling module.

                <u>load</u> <u>|</u> <u>upgrade</u>:
                  The corresponding library callback was unsuccessful.

                <u>reload</u>:
                  A  NIF  library  is  already loaded for this module instance. The previously deprecated <u>reload</u>
                  feature was removed in OTP 20.

                <u>old_code</u>:
                  The call to <u>load_nif/2</u> was made from the old code of a module that has been upgraded; this  is
                  not allowed.

       <b>erlang:loaded()</b> <b>-&gt;</b> <b>[Module]</b>

              Types:

                 Module = module()

              Returns a list of all loaded Erlang modules (current and old code), including preloaded modules.

              See also <u><a href="../man3erl/code.3erl.html">code</a>(3erl)</u>.

       <b>erlang:localtime()</b> <b>-&gt;</b> <b>DateTime</b>

              Types:

                 DateTime = calendar:datetime()

              Returns  the  current  local  date  and  time,  <u>{{Year,</u>  <u>Month,</u> <u>Day},</u> <u>{Hour,</u> <u>Minute,</u> <u>Second}}</u>, for
              example:

              &gt; erlang:localtime().
              {{1996,11,6},{14,45,17}}

              The time zone and Daylight Saving Time correction depend on the underlying OS. The return value is
              based on the OS System Time.

       <b>erlang:localtime_to_universaltime(Localtime)</b> <b>-&gt;</b> <b>Universaltime</b>

              Types:

                 Localtime = Universaltime = calendar:datetime()

              Converts local date and time to Universal Time Coordinated (UTC), if supported by  the  underlying
              OS. Otherwise no conversion is done and <u>Localtime</u> is returned. Example:

              &gt; erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}).
              {{1996,11,6},{13,45,17}}

              Failure: <u>badarg</u> if <u>Localtime</u> denotes an invalid date and time.

       <b>erlang:localtime_to_universaltime(Localtime,</b> <b>IsDst)</b> <b>-&gt;</b>
                                            Universaltime

              Types:

                 Localtime = Universaltime = calendar:datetime()
                 IsDst = true | false | undefined

              Converts     local    date    and    time    to    Universal    Time    Coordinated    (UTC)    as
              <u>erlang:localtime_to_universaltime/1</u>, but the caller decides if Daylight Saving Time is active.

              If <u>IsDst</u> <u>==</u> <u>true</u>, <u>Localtime</u> is during Daylight Saving Time, if <u>IsDst</u> <u>==</u> <u>false</u> it is not. If  <u>IsDst</u>
              <u>==</u>    <u>undefined</u>,    the    underlying   OS   can   guess,   which   is   the   same   as   calling
              <u>erlang:localtime_to_universaltime(Localtime)</u>.

              Examples:

              &gt; erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, true).
              {{1996,11,6},{12,45,17}}
              &gt; erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, false).
              {{1996,11,6},{13,45,17}}
              &gt; erlang:localtime_to_universaltime({{1996,11,6},{14,45,17}}, undefined).
              {{1996,11,6},{13,45,17}}

              Failure: <u>badarg</u> if <u>Localtime</u> denotes an invalid date and time.

       <b>make_ref()</b> <b>-&gt;</b> <b>reference()</b>

              Returns a  unique reference. The reference is unique among connected nodes.

          <b>Warning:</b>
              Before OTP-23 when a node is restarted multiple times with the same node name, references  created
              on a newer node can be mistaken for a reference created on an older node with the same node name.

       <b>erlang:make_tuple(Arity,</b> <b>InitialValue)</b> <b>-&gt;</b> <b>tuple()</b>

              Types:

                 Arity = arity()
                 InitialValue = term()

              Creates a new tuple of the specified <u>Arity</u>, where all elements are <u>InitialValue</u>, for example:

              &gt; erlang:make_tuple(4, []).
              {[],[],[],[]}

       <b>erlang:make_tuple(Arity,</b> <b>DefaultValue,</b> <b>InitList)</b> <b>-&gt;</b> <b>tuple()</b>

              Types:

                 Arity = arity()
                 DefaultValue = term()
                 InitList = [{Position :: integer() &gt;= 1, term()}]

              Creates a tuple of size <u>Arity</u>, where each element has value <u>DefaultValue</u>, and then fills in values
              from  <u>InitList</u>.  Each  list  element in <u>InitList</u> must be a two-tuple, where the first element is a
              position in the newly created tuple and the second element is any term. If a position occurs  more
              than once in the list, the term corresponding to the last occurrence is used. Example:

              &gt; erlang:make_tuple(5, [], [{2,ignored},{5,zz},{2,aa}]).
              {[],aa,[],[],zz}

       <b>map_get(Key,</b> <b>Map)</b> <b>-&gt;</b> <b>Value</b>

              Types:

                 Map = map()
                 Key = Value = any()

              Returns value <u>Value</u> associated with <u>Key</u> if <u>Map</u> contains <u>Key</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map</u> is not a map, or with a <u>{badkey,Key}</u> exception
              if no value is associated with <u>Key</u>.

              <u>Example:</u>

              &gt; Key = 1337,
                Map = #{42 =&gt; value_two,1337 =&gt; "value one","a" =&gt; 1},
                map_get(Key,Map).
              "value one"

              Allowed in guard tests.

       <b>map_size(Map)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Map = map()

              Returns an integer, which is the number of key-value pairs in <u>Map</u>, for example:

              &gt; map_size(#{a=&gt;1, b=&gt;2, c=&gt;3}).
              3

              Allowed in guard tests.

       <b>erlang:match_spec_test(MatchAgainst,</b> <b>MatchSpec,</b> <b>Type)</b> <b>-&gt;</b>
                                 TestResult

              Types:

                 MatchAgainst = [term()] | tuple()
                 MatchSpec = term()
                 Type = table | trace
                 TestResult =
                     {ok, term(), [return_trace], [{error | warning, string()}]} |
                     {error, [{error | warning, string()}]}

              Tests a match specification used in calls to <u>ets:select/2</u> and <u>erlang:trace_pattern/3</u>. The function
              tests  both  a  match  specification  for "syntactic" correctness and runs the match specification
              against the object. If the match specification contains  errors,  the  tuple  <u>{error,</u>  <u>Errors}</u>  is
              returned, where <u>Errors</u> is a list of natural language descriptions of what was wrong with the match
              specification.

              If  <u>Type</u>  is  <u>table</u>,  the  object  to  match  against  is to be a tuple. The function then returns
              <u>{ok,Result,[],Warnings}</u>, where <u>Result</u> is what would have been the result in  a  real  <u>ets:select/2</u>
              call, or <u>false</u> if the match specification does not match the object tuple.

              If  <u>Type</u>  is <u>trace</u>, the object to match against is to be a list. The function returns <u>{ok,</u> <u>Result,</u>
              <u>Flags,</u> <u>Warnings}</u>, where <u>Result</u> is one of the following:

                * <u>true</u> if a trace message is to be emitted

                * <u>false</u> if a trace message is not to be emitted

                * The message term to be appended to the trace message

              <u>Flags</u> is a list containing all the trace flags to be enabled, currently this is only <u>return_trace</u>.

              This  is  a  useful  debugging  and  test  tool,  especially  when   writing   complicated   match
              specifications.

              See also <u>ets:test_ms/2</u>.

       <b>max(Term1,</b> <b>Term2)</b> <b>-&gt;</b> <b>Maximum</b>

              Types:

                 Term1 = Term2 = Maximum = term()

              Returns  the largest of <u>Term1</u> and <u>Term2</u>. If the terms compare equal with the <u>==</u> operator, <u>Term1</u> is
              returned.

              The  Expressions section contains descriptions of the <u>==</u> operator and how terms are ordered.

              Examples:

              &gt; max(1, 2).
              2

              &gt; max(1.0, 1).
              1.0

              &gt; max(1, 1.0).
              1

              &gt; max("abc", "b").
              "b"

       <b>erlang:md5(Data)</b> <b>-&gt;</b> <b>Digest</b>

              Types:

                 Data = iodata()
                 Digest = binary()

              Computes an MD5 message digest from <u>Data</u>, where the length of the digest is 128 bits  (16  bytes).
              <u>Data</u> is a binary or a list of small integers and binaries.

              For more information about MD5, see  RFC 1321 - The MD5 Message-Digest Algorithm.

          <b>Warning:</b>
              The  MD5  Message-Digest  Algorithm  is <u>not</u> considered safe for code-signing or software-integrity
              purposes.

       <b>erlang:md5_final(Context)</b> <b>-&gt;</b> <b>Digest</b>

              Types:

                 Context = Digest = binary()

              Finishes the update of an MD5 <u>Context</u> and returns the computed <u>MD5</u> message digest.

       <b>erlang:md5_init()</b> <b>-&gt;</b> <b>Context</b>

              Types:

                 Context = binary()

              Creates an MD5 context, to be used in the following calls to <u>md5_update/2</u>.

       <b>erlang:md5_update(Context,</b> <b>Data)</b> <b>-&gt;</b> <b>NewContext</b>

              Types:

                 Context = binary()
                 Data = iodata()
                 NewContext = binary()

              Update an MD5 <u>Context</u> with <u>Data</u> and returns a <u>NewContext</u>.

       <b>erlang:memory()</b> <b>-&gt;</b> <b>[{Type,</b> <b>Size}]</b>

              Types:

                 Type = memory_type()
                 Size = integer() &gt;= 0
                 <b>memory_type()</b> =
                     total | processes | processes_used | system | atom |
                     atom_used | binary | code | ets

              Returns a list with information about memory dynamically allocated by the  Erlang  emulator.  Each
              list  element  is  a tuple <u>{Type,</u> <u>Size}</u>. The first element <u>Type</u> is an atom describing memory type.
              The second element <u>Size</u> is the memory size in bytes.

              Memory types:

                <u>total</u>:
                  The total amount of memory currently allocated. This is the same as the sum of the memory size
                  for <u>processes</u> and <u>system</u>.

                <u>processes</u>:
                  The total amount of memory currently allocated for the Erlang processes.

                <u>processes_used</u>:
                  The total amount of memory currently used by the Erlang processes. This is part of the  memory
                  presented as <u>processes</u> memory.

                <u>system</u>:
                  The  total  amount of memory currently allocated for the emulator that is not directly related
                  to any Erlang process.  Memory  presented  as  <u>processes</u>  is  not  included  in  this  memory.
                  <u><a href="../man3erl/instrument.3erl.html">instrument</a>(3erl)</u>  can  be used to get a more detailed breakdown of what memory is part of this
                  type.

                <u>atom</u>:
                  The total amount of memory currently allocated for atoms. This memory is part  of  the  memory
                  presented as <u>system</u> memory.

                <u>atom_used</u>:
                  The  total  amount  of  memory  currently  used  for  atoms. This memory is part of the memory
                  presented as <u>atom</u> memory.

                <u>binary</u>:
                  The total amount of memory currently allocated for binaries. This memory is part of the memory
                  presented as <u>system</u> memory.

                <u>code</u>:
                  The total amount of memory currently allocated for Erlang code. This memory  is  part  of  the
                  memory presented as <u>system</u> memory.

                <u>ets</u>:
                  The  total  amount  of  memory  currently allocated for ETS tables. This memory is part of the
                  memory presented as <u>system</u> memory.

                <u>maximum</u>:
                  The maximum total amount of memory allocated since the emulator was  started.  This  tuple  is
                  only present when the emulator is run with instrumentation.

                  For  information  on how to run the emulator with instrumentation, see <u><a href="../man3erl/instrument.3erl.html">instrument</a>(3erl)</u> and/or
                  <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

          <b>Note:</b>
              The <u>system</u> value is not complete. Some allocated memory that is to be part of this value is not.

              When the emulator is run with instrumentation, the <u>system</u>  value  is  more  accurate,  but  memory
              directly allocated for <u>malloc</u> (and friends) is still not part of the <u>system</u> value. Direct calls to
              <u>malloc</u>  are  only done from OS-specific runtime libraries and perhaps from user-implemented Erlang
              drivers that do not use the memory allocation functions in the driver interface.

              As the <u>total</u> value is the sum of <u>processes</u> and <u>system</u>, the error in <u>system</u> propagates to the <u>total</u>
              value.

              The different amounts of memory that are summed are <u>not</u> gathered atomically, which  introduces  an
              error in the result.

              The different values have the following relation to each other. Values beginning with an uppercase
              letter is not part of the result.

              total      = processes + system
              processes  = processes_used + ProcessesNotUsed
              system     = atom + binary + code + ets + OtherSystem
              atom       = atom_used + AtomNotUsed
              RealTotal  = processes + RealSystem
              RealSystem = system + MissedSystem

              More tuples in the returned list can be added in a future release.

          <b>Note:</b>
              The  <u>total</u>  value  is  supposed  to  be  the  total  amount of memory dynamically allocated by the
              emulator. Shared libraries, the code of the emulator itself,  and  the  emulator  stacks  are  not
              supposed to be included. That is, the <u>total</u> value is <u>not</u> supposed to be equal to the total size of
              all pages mapped to the emulator.

              Also, because of fragmentation and prereservation of memory areas, the size of the memory segments
              containing  the  dynamically allocated memory blocks can be much larger than the total size of the
              dynamically allocated memory blocks.

          <b>Note:</b>
              As from ERTS 5.6.4, <u>erlang:memory/0</u> requires that  all  <u><a href="../man3erl/erts_alloc.3erl.html">erts_alloc</a>(3erl)</u>  allocators  are  enabled
              (default behavior).

              Failure: <u>notsup</u> if an <u><a href="../man3erl/erts_alloc.3erl.html">erts_alloc</a>(3erl)</u> allocator has been disabled.

       <b>erlang:memory(Type</b> <b>::</b> <b>memory_type())</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>erlang:memory(TypeList</b> <b>::</b> <b>[memory_type()])</b> <b>-&gt;</b>
                        [{memory_type(), integer() &gt;= 0}]

              Types:

                 <b>memory_type()</b> =
                     total | processes | processes_used | system | atom |
                     atom_used | binary | code | ets

              Returns  the  memory  size  in  bytes  allocated for memory of type <u>Type</u>. The argument can also be
              specified as a list of <u>memory_type()</u> atoms, in which case a corresponding list of  <u>{memory_type(),</u>
              <u>Size</u> <u>::</u> <u>integer</u> <u>&gt;=</u> <u>0}</u> tuples is returned.

          <b>Note:</b>
              As  from  ERTS  5.6.4,  <u>erlang:memory/1</u>  requires that all <u><a href="../man3erl/erts_alloc.3erl.html">erts_alloc</a>(3erl)</u> allocators are enabled
              (default behavior).

              Failures:

                <u>badarg</u>:
                   If <u>Type</u> is not one of the memory types listed in the description of <u>erlang:memory/0</u>.

                <u>badarg</u>:
                   If <u>maximum</u> is passed as <u>Type</u> and the emulator is not run in instrumented mode.

                <u>notsup</u>:
                   If an <u><a href="../man3erl/erts_alloc.3erl.html">erts_alloc</a>(3erl)</u> allocator has been disabled.

              See also <u>erlang:memory/0</u>.

       <b>min(Term1,</b> <b>Term2)</b> <b>-&gt;</b> <b>Minimum</b>

              Types:

                 Term1 = Term2 = Minimum = term()

              Returns the smallest of <u>Term1</u> and <u>Term2</u>. If the terms compare equal with the <u>==</u> operator, <u>Term1</u> is
              returned.

              The  Expressions section contains descriptions of the <u>==</u> operator and how terms are ordered.

              Examples:

              &gt; min(1, 2).
              1

              &gt; min(1.0, 1).
              1.0

              &gt; min(1, 1.0).
              1

              &gt; min("abc", "b").
              "abc"

       <b>module_loaded(Module)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Module = module()

              Returns <u>true</u> if the module <u>Module</u> is loaded, otherwise <u>false</u>. It does  not  attempt  to  load  the
              module.

          <b>Warning:</b>
              This BIF is intended for the code server (see <u><a href="../man3erl/code.3erl.html">code</a>(3erl)</u>) and is not to be used elsewhere.

       <b>monitor(Type</b> <b>::</b> <b>process,</b> <b>Item</b> <b>::</b> <b>monitor_process_identifier())</b> <b>-&gt;</b>
                  MonitorRef

       <b>monitor(Type</b> <b>::</b> <b>port,</b> <b>Item</b> <b>::</b> <b>monitor_port_identifier())</b> <b>-&gt;</b>
                  MonitorRef

       <b>monitor(Type</b> <b>::</b> <b>time_offset,</b> <b>Item</b> <b>::</b> <b>clock_service)</b> <b>-&gt;</b> <b>MonitorRef</b>

              Types:

                 MonitorRef = reference()
                 <b>registered_name()</b> = atom()
                 <b>registered_process_identifier()</b> =
                     registered_name() | {registered_name(), node()}
                 <b>monitor_process_identifier()</b> =
                     pid() | registered_process_identifier()
                 <b>monitor_port_identifier()</b> = port() | registered_name()

              Sends  a  monitor  request  of type <u>Type</u> to the entity identified by <u>Item</u>. If the monitored entity
              does not exist or it changes monitored state, the caller of <u>monitor/2</u> is notified by a message  on
              the following format:

              {Tag, MonitorRef, Type, Object, Info}

          <b>Note:</b>
              The  monitor  request  is an asynchronous signal. That is, it takes time before the signal reaches
              its destination.

              <u>Type</u> can be one of the following atoms: <u>process</u>, <u>port</u> or <u>time_offset</u>.

              A <u>process</u> or <u>port</u> monitor is triggered only once, after that it is removed  from  both  monitoring
              process  and  the  monitored  entity.  Monitors  are  fired  when  the  monitored  process or port
              terminates, does not exist at the moment of creation, or if the connection to it is lost.  If  the
              connection  to  it  is  lost, we do not know if it still exists. The monitoring is also turned off
              when demonitor/1 is called.

              A <u>process</u> or <u>port</u> monitor by name resolves the <u>RegisteredName</u> to <u>pid()</u> or <u>port()</u> only once at  the
              moment  of  monitor  instantiation,  later  changes  to  the name registration will not affect the
              existing monitor.

              When a <u>process</u> or <u>port</u> monitor is triggered, a <u>'DOWN'</u> message  is  sent  that  has  the  following
              pattern:

              {'DOWN', MonitorRef, Type, Object, Info}

              In the monitor message <u>MonitorRef</u> and <u>Type</u> are the same as described earlier, and:

                <u>Object</u>:
                  The  monitored  entity,  which triggered the event. When monitoring a process or a local port,
                  <u>Object</u> will be equal to the <u>pid()</u> or <u>port()</u> that was being monitored. When monitoring  process
                  or  port  by  name, <u>Object</u> will have format <u>{RegisteredName,</u> <u>Node}</u> where <u>RegisteredName</u> is the
                  name which has been used with <u>monitor/2</u> call and <u>Node</u> is local or remote node name (for  ports
                  monitored by name, <u>Node</u> is always local node name).

                <u>Info</u>:
                  Either  the  exit  reason of the process, <u>noproc</u> (process or port did not exist at the time of
                  monitor creation), or <u>noconnection</u> (no connection to the  node  where  the  monitored  process
                  resides).

                <b>Monitoring</b> <b>a</b> <u>process</u>:
                  Creates  monitor between the current process and another process identified by <u>Item</u>, which can
                  be a <u>pid()</u> (local or remote), an atom <u>RegisteredName</u> or a tuple <u>{RegisteredName,</u> <u>Node}</u>  for  a
                  registered process, located elsewhere.

            <b>Note:</b>
                Before  ERTS  10.0  (OTP  21.0),  monitoring  a  process could fail with <u>badarg</u> if the monitored
                process resided on a primitive node (such as erl_interface or jinterface), where remote  process
                monitoring is not implemented.

                Now,  such a call to <u>monitor</u> will instead succeed and a monitor is created. But the monitor will
                only supervise the connection. That is, a <u>{'DOWN',</u> <b>_</b><u>,</u> <u>process,</u>  <b>_</b><u>,</u>  <u>noconnection}</u>  is  the  only
                message  that  may be received, as the primitive node have no way of reporting the status of the
                monitored process.

                <b>Monitoring</b> <b>a</b> <u>port</u>:
                  Creates monitor between the current process and a port identified by  <u>Item</u>,  which  can  be  a
                  <u>port()</u> (only local), an atom <u>RegisteredName</u> or a tuple <u>{RegisteredName,</u> <u>Node}</u> for a registered
                  port, located on this node. Note, that attempt to monitor a remote port will result in <u>badarg</u>.

                <b>Monitoring</b> <b>a</b> <u>time_offset</u>:
                  Monitors  changes  in  <u>time</u>  <u>offset</u>  between Erlang monotonic time and Erlang system time. One
                  valid <u>Item</u> exists in combination with the <u>time_offset</u> <u>Type</u>,  namely  the  atom  <u>clock_service</u>.
                  Notice  that  the  atom <u>clock_service</u> is <u>not</u> the registered name of a process. In this case it
                  serves as an identifier of the runtime system internal clock service at current runtime system
                  instance.

                  The monitor is triggered when the time offset is changed. This either if the time offset value
                  is changed, or if the offset is changed from preliminary to final during finalization  of  the
                  time  offset  when  the single time warp mode is used. When a change from preliminary to final
                  time offset is made, the monitor is triggered once regardless of whether the time offset value
                  was changed or not.

                  If the runtime system is in multi time warp mode, the time offset is changed when the  runtime
                  system  detects  that  the  OS  system time has changed. The runtime system does, however, not
                  detect this immediately when it occurs. A task  checking  the  time  offset  is  scheduled  to
                  execute  at  least  once  a  minute, so under normal operation this is to be detected within a
                  minute, but during heavy load it can take longer time.

                  The monitor is <u>not</u> automatically removed after  it  has  been  triggered.  That  is,  repeated
                  changes of the time offset trigger the monitor repeatedly.

                  When the monitor is triggered a <u>'CHANGE'</u> message is sent to the monitoring process. A <u>'CHANGE'</u>
                  message has the following pattern:

                {'CHANGE', MonitorRef, Type, Item, NewTimeOffset}

                  where <u>MonitorRef</u>, <u>Type</u>, and <u>Item</u> are the same as described above, and <u>NewTimeOffset</u> is the new
                  time offset.

                  When  the  <u>'CHANGE'</u>  message has been received you are guaranteed not to retrieve the old time
                  offset when calling <u>erlang:time_offset()</u>. Notice that you can observe the change of  the  time
                  offset when calling <u>erlang:time_offset()</u> before you get the <u>'CHANGE'</u> message.

              Making  several calls to <u>monitor/2</u> for the same <u>Item</u> and/or <u>Type</u> is not an error; it results in as
              many independent monitoring instances.

              The monitor functionality is expected to be extended. That is, other <u>Type</u>s and <u>Item</u>s are  expected
              to be supported in a future release.

          <b>Note:</b>
              If  or  when <u>monitor/2</u> is extended, other possible values for <u>Tag</u>, <u>Object</u>, and <u>Info</u> in the monitor
              message will be introduced.

       <b>monitor(Type</b> <b>::</b> <b>process,</b>
               Item :: monitor_process_identifier(),
               Opts :: [monitor_option()]) -&gt;
                  MonitorRef

       <b>monitor(Type</b> <b>::</b> <b>port,</b>
               Item :: monitor_port_identifier(),
               Opts :: [monitor_option()]) -&gt;
                  MonitorRef

       <b>monitor(Type</b> <b>::</b> <b>time_offset,</b>
               Item :: clock_service,
               Opts :: [monitor_option()]) -&gt;
                  MonitorRef

              Types:

                 MonitorRef = reference()
                 <b>registered_name()</b> = atom()
                 <b>registered_process_identifier()</b> =
                     registered_name() | {registered_name(), node()}
                 <b>monitor_process_identifier()</b> =
                     pid() | registered_process_identifier()
                 <b>monitor_port_identifier()</b> = port() | registered_name()

              Provides an option list for modification of monitoring functionality provided  by  <u>monitor/2</u>.  The
              <u>Type</u>  and  <u>Item</u>  arguments  have the same meaning as when passed to <u>monitor/2</u>. Currently available
              options:

                <u>{alias,</u> <u>UnaliasOpt}</u>:
                  The returned monitor reference will also become an alias for the calling process. That is, the
                  returned reference can be used for sending messages to the calling process. See also  <u>alias/0</u>.
                  The <u>UnaliasOpt</u> determines how the alias should be deactivated.

                  <u>explicit_unalias</u>:
                    Only an explicit call to <u>unalias/1</u> will deactivate the alias.

                  <u>demonitor</u>:
                    The  alias will be automatically deactivated when the monitor is removed. This either via an
                    explicit call to <u>demonitor/1</u> or when it is automatically removed  at  the  same  time  as  a
                    <u>'DOWN'</u>  message is delivered due to the monitor. The alias can also still be deactivated via
                    a call to <u>unalias/1</u>.

                  <u>reply_demonitor</u>:
                    The alias will be automatically deactivated when  the  monitor  is  removed  (see  <u>demonitor</u>
                    option  above)  or  a  reply message sent via the alias is received. When a reply message is
                    received via the alias the monitor will also be automatically removed.  This  is  useful  in
                    client/server  scenarios  when  a  client monitors the server and will get the reply via the
                    alias. Once the response is received both the alias and the monitor  will  be  automatically
                    removed  regardless  of  whether  the response is a reply or a <u>'DOWN'</u> message. The alias can
                    also still be deactivated via a call to <u>unalias/1</u>. Note that if the alias is  removed  using
                    the <u>unalias/1</u> BIF, the monitor will still be left active.

                  Example:

                server() -&gt;
                    receive
                        {request, AliasReqId, Request} -&gt;
                            Result = perform_request(Request),
                            AliasReqId ! {reply, AliasReqId, Result}
                    end,
                    server().

                client(ServerPid, Request) -&gt;
                    AliasMonReqId = monitor(process, ServerPid, [{alias, reply_demonitor}]),
                    ServerPid ! {request, AliasMonReqId, Request},
                    %% Alias as well as monitor will be automatically deactivated if we
                    %% receive a reply or a 'DOWN' message since we used 'reply_demonitor'
                    %% as unalias option...
                    receive
                        {reply, AliasMonReqId, Result} -&gt;
                            Result;
                        {'DOWN', AliasMonReqId, process, ServerPid, ExitReason} -&gt;
                            error(ExitReason)
                    end.

                  Note  that both the server and the client in this example must be executing on at least OTP 24
                  systems in order for this to work.

                  For more information on process aliases  see  the  <u>Process</u>  <u>Aliases</u>   section  of  the  <u>Erlang</u>
                  <u>Reference</u> <u>Manual</u> .

                <u>{tag,</u> <u>UserDefinedTag}</u>:
                  Replace  the default <u>Tag</u> with <u>UserDefinedTag</u> in the monitor message delivered when the monitor
                  is triggered. For example, when monitoring a process, the <u>'DOWN'</u> tag in the down message  will
                  be replaced by <u>UserDefinedTag</u>.

                  An  example  of  how  the  <u>{tag,</u> <u>UserDefinedTag}</u> option can be used in order to enable the new
                  selective receive optimization, introduced  in  OTP  24,  when  making  multiple  requests  to
                  different servers:

                server() -&gt;
                    receive
                        {request, From, ReqId, Request} -&gt;
                            Result = perform_request(Request),
                            From ! {reply, self(), ReqId, Result}
                    end,
                    server().

                client(ServerPids, Request) when is_list(ServerPids) -&gt;
                    ReqId = make_ref(),
                    lists:foreach(fun (ServerPid) -&gt;
                                          _ = monitor(process, ServerPid,
                                                      [{tag, {'DOWN', ReqId}}]),
                                          ServerPid ! {request, self(), ReqId, Request}
                                  end,
                                  ServerPids),
                    receive_replies(ReqId, length(ServerPids), []).

                receive_replies(_ReqId, 0, Acc) -&gt;
                    Acc;
                receive_replies(ReqId, N, Acc) -&gt;
                    %% The compiler will detect that we match on the 'ReqId'
                    %% reference in all clauses, and will enable the selective
                    %% receive optimization which makes the receive able to
                    %% skip past all messages present in the message queue at
                    %% the time when the 'ReqId' reference was created...
                    Res = receive
                              {reply, ServerPid, ReqId, Result} -&gt;
                                  %% Here we typically would have deactivated the
                                  %% monitor by a call to demonitor(Mon, [flush]) but
                                  %% we ignore this in this example for simplicity...
                                  {ok, ServerPid, Result};
                              {{'DOWN', ReqId}, _Mon, process, ServerPid, ExitReason} -&gt;
                                  {error, ServerPid, ExitReason}
                          end,
                    receive_replies(ReqId, N-1, [Res | Acc]).

                  In order for this example to work as intended, the client must be executing on at least an OTP
                  24 system, but the servers may execute on older systems.

       <b>monitor_node(Node,</b> <b>Flag)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Node = node()
                 Flag = boolean()

              Monitor  the  status of the node <u>Node</u>. If <u>Flag</u> is <u>true</u>, monitoring is turned on. If <u>Flag</u> is <u>false</u>,
              monitoring is turned off.

              Making several calls to <u>monitor_node(Node,</u> <u>true)</u> for the same <u>Node</u> is not an error; it results  in
              as many independent monitoring instances.

              If  <u>Node</u>  fails  or does not exist, the message <u>{nodedown,</u> <u>Node}</u> is delivered to the process. If a
              process has made two calls to <u>monitor_node(Node,</u> <u>true)</u> and <u>Node</u> terminates, two <u>nodedown</u>  messages
              are delivered to the process. If there is no connection to <u>Node</u>, an attempt is made to create one.
              If this fails, a <u>nodedown</u> message is delivered.

              The  delivery  of the <u>nodedown</u> signal is not ordered with respect to other link or monitor signals
              from the node that goes down. If you need a guarantee that all signals from the  remote  node  has
              been delivered before the <u>nodedown</u> signal is sent, you should use <u>net_kernel:monitor_nodes/1</u>.

              Nodes connected through hidden connections can be monitored as any other nodes.

              Failure: <u>notalive</u> if the local node is not alive.

       <b>erlang:monitor_node(Node,</b> <b>Flag,</b> <b>Options)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Node = node()
                 Flag = boolean()
                 Options = [Option]
                 Option = allow_passive_connect

              Behaves  as  <u>monitor_node/2</u>  except  that  it  allows  an  extra  option  to  be specified, namely
              <u>allow_passive_connect</u>. This option allows the BIF to wait the normal network  connection  time-out
              for  the  <u>monitored</u> <u>node</u> to connect itself, even if it cannot be actively connected from this node
              (that is, it is blocked). The state where this can be useful can only be  achieved  by  using  the
              Kernel option <u>dist_auto_connect</u> <u>once</u>. If that option is not used, option <u>allow_passive_connect</u> has
              no effect.

          <b>Note:</b>
              Option  <u>allow_passive_connect</u>  is  used  internally and is seldom needed in applications where the
              network topology and the Kernel options in effect are known in advance.

              Failure: <u>badarg</u> if the local node is not alive or the option list is malformed.

       <b>erlang:monotonic_time()</b> <b>-&gt;</b> <b>integer()</b>

              Returns the current Erlang monotonic time in <u>native</u> time unit. This is a monotonically  increasing
              time since some unspecified point in time.

          <b>Note:</b>
              This  is a  monotonically increasing time, but <u>not</u> a  strictly monotonically increasing time. That
              is, consecutive calls to <u>erlang:monotonic_time/0</u> can produce the same result.

              Different runtime system instances will use different unspecified points in time as base for their
              Erlang monotonic clocks. That is, it is <u>pointless</u> comparing monotonic times from different runtime
              system instances. Different runtime system instances can also place this unspecified point in time
              different relative runtime system start. It can be placed in  the  future  (time  at  start  is  a
              negative  value),  the past (time at start is a positive value), or the runtime system start (time
              at start is zero). The monotonic time  at  runtime  system  start  can  be  retrieved  by  calling
              <u>erlang:system_info(start_time)</u>.

       <b>erlang:monotonic_time(Unit)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 Unit = time_unit()

              Returns the current Erlang monotonic time converted into the <u>Unit</u> passed as argument.

              Same as calling <u>erlang:convert_time_unit(erlang:monotonic_time(),</u> <u>native,</u> <u>Unit)</u>, however optimized
              for commonly used <u>Unit</u>s.

       <b>erlang:nif_error(Reason)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Reason = term()

              Works  exactly like <u>error/1</u>, but Dialyzer thinks that this BIF will return an arbitrary term. When
              used in a stub function for a NIF to generate an exception when the NIF  library  is  not  loaded,
              Dialyzer does not generate false warnings.

       <b>erlang:nif_error(Reason,</b> <b>Args)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Reason = term()
                 Args = [term()]

              Works  exactly like <u>error/2</u>, but Dialyzer thinks that this BIF will return an arbitrary term. When
              used in a stub function for a NIF to generate an exception when the NIF  library  is  not  loaded,
              Dialyzer does not generate false warnings.

       <b>node()</b> <b>-&gt;</b> <b>Node</b>

              Types:

                 Node = node()

              Returns the name of the local node. If the node is not alive, <u>nonode@nohost</u> is returned instead.

              Allowed in guard tests.

       <b>node(Arg)</b> <b>-&gt;</b> <b>Node</b>

              Types:

                 Arg = pid() | port() | reference()
                 Node = node()

              Returns the node where <u>Arg</u> originates. <u>Arg</u> can be a process identifier, a reference, or a port. If
              <u>Arg</u> originates from the local node and the local node is not alive, <u>nonode@nohost</u> is returned.

              Allowed in guard tests.

       <b>nodes()</b> <b>-&gt;</b> <b>Nodes</b>

              Types:

                 Nodes = [node()]

              Returns  a  list  of  all nodes connected to this node through normal connections (that is, hidden
              nodes are not listed). Same as nodes(visible).

       <b>nodes(Arg)</b> <b>-&gt;</b> <b>Nodes</b>

              Types:

                 Arg = NodeType | [NodeType]
                 NodeType = visible | hidden | connected | this | known
                 Nodes = [node()]

              Returns a list of nodes according to  the  argument  specified.  The  returned  result,  when  the
              argument is a list, is the list of nodes satisfying the disjunction(s) of the list elements.

              <u>NodeType</u>s:

                <u>visible</u>:
                  Nodes connected to this node through normal connections.

                <u>hidden</u>:
                  Nodes connected to this node through hidden connections.

                <u>connected</u>:
                  All nodes connected to this node.

                <u>this</u>:
                  This node.

                <u>known</u>:
                  Nodes  that  are known to this node. That is, connected nodes and nodes referred to by process
                  identifiers, port identifiers, and references located on this node. The set of known nodes  is
                  garbage  collected.  Notice that this garbage collection can be delayed. For more information,
                  see <u>erlang:system_info(delayed_node_table_gc)</u>.

              Some equalities: <u>[node()]</u> <u>=</u> <u>nodes(this)</u>, <u>nodes(connected)</u> <u>=</u> <u>nodes([visible,</u> <u>hidden])</u>, and  <u>nodes()</u>
              <u>=</u> <u>nodes(visible)</u>.

       <b>now()</b> <b>-&gt;</b> <b>Timestamp</b>

              Types:

                 Timestamp = timestamp()
                 <b>timestamp()</b> =
                     {MegaSecs :: integer() &gt;= 0,
                      Secs :: integer() &gt;= 0,
                      MicroSecs :: integer() &gt;= 0}

          <b>Warning:</b>
              <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u> <u>Do</u> <u>not</u> <u>use</u> <u>it.</u>

              For  more  information,  see  section  Time and Time Correction in the User's Guide. Specifically,
              section  Dos and Dont's describes what to use instead of <u>erlang:now/0</u>.

              Returns the tuple <u>{MegaSecs,</u> <u>Secs,</u> <u>MicroSecs}</u>, which is the elapsed time since 00:00 GMT,  January
              1,  1970  (zero  hour),  if  provided  by the underlying OS. Otherwise some other point in time is
              chosen. It is also guaranteed that the following calls to this BIF return continuously  increasing
              values.  Hence,  the return value from <u>erlang:now/0</u> can be used to generate unique time stamps. If
              it is called in a tight loop on a fast machine, the time of the node can become skewed.

              Can only be used to check the local time of day if the time-zone information of the underlying  OS
              is properly configured.

       <b>open_port(PortName,</b> <b>PortSettings)</b> <b>-&gt;</b> <b>port()</b>

              Types:

                 PortName =
                     {spawn, Command :: string() | binary()} |
                     {spawn_driver, Command :: string() | binary()} |
                     {spawn_executable, FileName :: file:name_all()} |
                     {fd, In :: integer() &gt;= 0, Out :: integer() &gt;= 0}
                 PortSettings = [Opt]
                 Opt =
                     {packet, N :: 1 | 2 | 4} |
                     stream |
                     {line, L :: integer() &gt;= 0} |
                     {cd, Dir :: string() | binary()} |
                     {env,
                      Env ::
                          [{Name :: os:env_var_name(),
                            Val :: os:env_var_value() | false}]} |
                     {args, [string() | binary()]} |
                     {arg0, string() | binary()} |
                     exit_status | use_stdio | nouse_stdio | stderr_to_stdout |
                     in | out | binary | eof |
                     {parallelism, Boolean :: boolean()} |
                     hide |
                     {busy_limits_port,
                      {integer() &gt;= 0, integer() &gt;= 0} | disabled} |
                     {busy_limits_msgq,
                      {integer() &gt;= 0, integer() &gt;= 0} | disabled}

              Returns  a  port  identifier  as the result of opening a new Erlang port. A port can be seen as an
              external Erlang process.

              The name of the executable as well as the arguments specifed  in  <u>cd</u>,  <u>env</u>,  <u>args</u>,  and  <u>arg0</u>  are
              subject  to  Unicode  filename  translation  if the system is running in Unicode filename mode. To
              avoid translation or to force, for example UTF-8, supply the  executable  and/or  arguments  as  a
              binary   in   the  correct  encoding.  For  details,  see  the  module  <u><a href="../man3erl/file.3erl.html">file</a>(3erl)</u>,  the  function
              <u>file:native_name_encoding/0</u> in Kernel, and the <u>Using</u> <u>Unicode</u> <u>in</u> <u>Erlang</u> User's Guide.

          <b>Note:</b>
              The characters in the name (if specified as a list) can only  be  &gt;  255  if  the  Erlang  virtual
              machine  is  started in Unicode filename translation mode. Otherwise the name of the executable is
              limited to the ISO Latin-1 character set.

              <u>PortName</u>s:

                <u>{spawn,</u> <u>Command}</u>:
                  Starts an external program. <u>Command</u> is the name of the external program  to  be  run.  <u>Command</u>
                  runs  outside the Erlang work space unless an Erlang driver with the name <u>Command</u> is found. If
                  found, that driver is started. A driver runs in the Erlang work space, which means that it  is
                  linked with the Erlang runtime system.

                  For  external  programs,  <u>PATH</u>  is searched (or an equivalent method is used to find programs,
                  depending on the OS). This is done by invoking the  shell  on  certain  platforms.  The  first
                  space-separated  token of the command is considered as the name of the executable (or driver).
                  This (among other things) makes this option unsuitable for running  programs  with  spaces  in
                  filenames   or   directory   names.  If  spaces  in  executable  filenames  are  desired,  use
                  <u>{spawn_executable,</u> <u>Command}</u> instead.

                <u>{spawn_driver,</u> <u>Command}</u>:
                  Works like <u>{spawn,</u> <u>Command}</u>, but demands the first (space-separated) token of the  command  to
                  be  the  name  of  a  loaded  driver. If no driver with that name is loaded, a <u>badarg</u> error is
                  raised.

                <u>{spawn_executable,</u> <u>FileName}</u>:
                  Works like <u>{spawn,</u> <u>FileName}</u>, but only runs external executables. <u>FileName</u>  in  its  whole  is
                  used  as  the name of the executable, including any spaces. If arguments are to be passed, the
                  <u>PortSettings</u> <u>args</u> and <u>arg0</u> can be used.

                  The shell is usually not invoked to start the program,  it  is  executed  directly.  <u>PATH</u>  (or
                  equivalent) is not searched. To find a program in <u>PATH</u> to execute, use <u>os:find_executable/1</u>.

                  Only  if  a  shell  script  or  <u>.bat</u>  file is executed, the appropriate command interpreter is
                  invoked implicitly, but there is still no command-argument expansion or implicit <u>PATH</u> search.

                  If <u>FileName</u> cannot be run, an error exception is raised, with the  POSIX  error  code  as  the
                  reason.  The error reason can differ between OSs. Typically the error <u>enoent</u> is raised when an
                  attempt is made to run a program that is not found and <u>eacces</u> is  raised  when  the  specified
                  file is not executable.

                <u>{fd,</u> <u>In,</u> <u>Out}</u>:
                  Allows  an  Erlang process to access any currently opened file descriptors used by Erlang. The
                  file descriptor <u>In</u> can be used for standard input, and the file descriptor  <u>Out</u>  for  standard
                  output.  It is only used for various servers in the Erlang OS (<u>shell</u> and <u>user</u>). Hence, its use
                  is limited.

              <u>PortSettings</u> is a list of settings for the port. The valid settings are as follows:

                <u>{packet,</u> <u>N}</u>:
                  Messages are preceded by their length, sent in <u>N</u> bytes, with the most significant byte  first.
                  The valid values for <u>N</u> are 1, 2, and 4.

                <u>stream</u>:
                  Output  messages are sent without packet lengths. A user-defined protocol must be used between
                  the Erlang process and the external object.

                <u>{line,</u> <u>L}</u>:
                  Messages are delivered on a per line basis. Each line (delimited by the  OS-dependent  newline
                  sequence)  is  delivered  in  a single message. The message data format is <u>{Flag,</u> <u>Line}</u>, where
                  <u>Flag</u> is <u>eol</u> or <u>noeol</u>, and <u>Line</u> is the data delivered (without the newline sequence).

                  <u>L</u> specifies the maximum line length in bytes. Lines longer than this  are  delivered  in  more
                  than  one  message,  with  <u>Flag</u>  set  to <u>noeol</u> for all but the last message. If end of file is
                  encountered anywhere else than immediately following a newline sequence, the last line is also
                  delivered with <u>Flag</u> set to <u>noeol</u>. Otherwise lines are delivered with <u>Flag</u> set to <u>eol</u>.

                  The <u>{packet,</u> <u>N}</u> and <u>{line,</u> <u>L}</u> settings are mutually exclusive.

                <u>{cd,</u> <u>Dir}</u>:
                  Only valid for <u>{spawn,</u> <u>Command}</u> and <u>{spawn_executable,</u> <u>FileName}</u>. The external program  starts
                  using <u>Dir</u> as its working directory. <u>Dir</u> must be a string.

                <u>{env,</u> <u>Env}</u>:
                  Types:
                  <u>Name</u> <u>=</u> <u>os:env_var_name()</u>
                  <u>Val</u> <u>=</u> <u>os:env_var_value()</u> <u>|</u> <u>false</u>
                  <u>Env</u> <u>=</u> <u>[{Name,</u> <u>Val}]</u>

                  Only  valid  for  <u>{spawn,</u>  <u>Command}</u>,  and <u>{spawn_executable,</u> <u>FileName}</u>. The environment of the
                  started process is extended using the environment specifications in <u>Env</u>.

                  <u>Env</u> is to be a list of tuples <u>{Name,</u> <u>Val}</u>, where <u>Name</u> is the name of an environment  variable,
                  and  <u>Val</u>  is  the  value  it is to have in the spawned port process. Both <u>Name</u> and <u>Val</u> must be
                  strings. The one exception is <u>Val</u> being the atom <u>false</u> (in  analogy  with  <u>os:getenv/1</u>,  which
                  removes the environment variable.

                  For information about encoding requirements, see documentation of the types for <u>Name</u> and <u>Val</u>.

                <u>{args,</u> <u>[</u> <u>string()</u> <u>|</u> <u>binary()</u> <u>]}</u>:
                  Only  valid  for  <u>{spawn_executable,</u> <u>FileName}</u> and specifies arguments to the executable. Each
                  argument is specified as a separate string and (on Unix) eventually ends  up  as  one  element
                  each in the argument vector. On other platforms, a similar behavior is mimicked.

                  The  arguments  are not expanded by the shell before they are supplied to the executable. Most
                  notably this means that file wildcard expansion does not occur. To expand  wildcards  for  the
                  arguments,  use  <u>filelib:wildcard/1</u>.  Notice  that even if the program is a Unix shell script,
                  meaning that the shell ultimately is invoked, wildcard  expansion  does  not  occur,  and  the
                  script  is  provided with the untouched arguments. On Windows, wildcard expansion is always up
                  to the program itself, therefore this is not an issue.

                  The executable name (also known as <u>argv[0]</u>) is not to be specified in this  list.  The  proper
                  executable name is automatically used as <u>argv[0]</u>, where applicable.

                  If  you  explicitly  want  to  set the program name in the argument vector, option <u>arg0</u> can be
                  used.

                <u>{arg0,</u> <u>string()</u> <u>|</u> <u>binary()}</u>:
                  Only valid for <u>{spawn_executable,</u> <u>FileName}</u> and explicitly specifies the program name argument
                  when running an executable. This can in some circumstances, on some OSs, be desirable. How the
                  program responds to this is highly system-dependent and no specific effect is guaranteed.

                <u>exit_status</u>:
                  Only valid for <u>{spawn,</u> <u>Command}</u>,  where  <u>Command</u>  refers  to  an  external  program,  and  for
                  <u>{spawn_executable,</u> <u>FileName}</u>.

                  When   the   external   process   connected   to  the  port  exits,  a  message  of  the  form
                  <u>{Port,{exit_status,Status}}</u> is sent to the connected process, where <u>Status</u> is the exit  status
                  of  the  external  process.  If the program aborts on Unix, the same convention is used as the
                  shells do (that is, 128+signal).

                  If option <u>eof</u> is specified also, the messages <u>eof</u> and <u>exit_status</u>  appear  in  an  unspecified
                  order.

                  If the port program closes its <u>stdout</u> without exiting, option <u>exit_status</u> does not work.

                <u>use_stdio</u>:
                  Only valid for <u>{spawn,</u> <u>Command}</u> and <u>{spawn_executable,</u> <u>FileName}</u>. It allows the standard input
                  and  output  (file  descriptors  0 and 1) of the spawned (Unix) process for communication with
                  Erlang.

                <u>nouse_stdio</u>:
                  The opposite of <u>use_stdio</u>. It uses file descriptors 3 and 4 for communication with Erlang.

                <u>stderr_to_stdout</u>:
                  Affects ports to external  programs.  The  executed  program  gets  its  standard  error  file
                  redirected  to  its  standard  output  file.  <u>stderr_to_stdout</u>  and  <u>nouse_stdio</u>  are mutually
                  exclusive.

                <u>overlapped_io</u>:
                  Affects ports to external programs on Windows only. The standard  input  and  standard  output
                  handles   of   the   port   program  are,  if  this  option  is  supplied,  opened  with  flag
                  <u>FILE_FLAG_OVERLAPPED</u>, so that the port program  can  (and  must)  do  overlapped  I/O  on  its
                  standard  handles.  This  is  not normally the case for simple port programs, but an option of
                  value for the experienced Windows programmer. <u>On</u> <u>all</u> <u>other</u> <u>platforms,</u> <u>this</u> <u>option</u> <u>is</u>  <u>silently</u>
                  <u>discarded.</u>

                <u>in</u>:
                  The port can only be used for input.

                <u>out</u>:
                  The port can only be used for output.

                <u>binary</u>:
                  All I/O from the port is binary data objects as opposed to lists of bytes.

                <u>eof</u>:
                  The port is not closed at the end of the file and does not produce an exit signal. Instead, it
                  remains open and a <u>{Port,</u> <u>eof}</u> message is sent to the process holding the port.

                <u>hide</u>:
                  When  running  on  Windows, suppresses creation of a new console window when spawning the port
                  program. (This option has no effect on other platforms.)

                <u>{parallelism,</u> <u>Boolean}</u>:

                  Sets scheduler hint for port parallelism. If set to <u>true</u>, the virtual machine  schedules  port
                  tasks;  when  doing  so,  it  improves parallelism in the system. If set to <u>false</u>, the virtual
                  machine tries to  perform  port  tasks  immediately,  improving  latency  at  the  expense  of
                  parallelism. The default can be set at system startup by passing command-line argument <u>+spp</u> to
                  <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>{busy_limits_port,</u> <u>{Low,</u> <u>High}</u> <u>|</u> <u>disabled}</u>:
                  Sets limits that will be used for controlling the busy state of the port.

                  When  the  ports  internal  output  queue  size becomes larger than or equal to <u>High</u> bytes, it
                  enters the busy state. When it becomes less than <u>Low</u> bytes it leaves the busy state. When  the
                  port  is  in the busy state, processes sending commands to it will be suspended until the port
                  leaves the busy state. Commands are in this context either <u>Port</u> <u>!</u> <u>{Owner,</u> <u>{command,</u> <u>Data}}</u>  or
                  <u>port_command/[2,3]</u>.

                  The  <u>Low</u>  limit  is  automatically adjusted to the same as <u>High</u> if it is set larger then <u>High</u>.
                  Valid range of values for <u>Low</u> and <u>High</u> is <u>[1,</u> <u>(1</u> <u>bsl</u> <u>(8*erlang:system_info(wordsize)))-2]</u>.  If
                  the atom <u>disabled</u> is passed, the port will never enter the busy state.

                  The defaults are <u>Low</u> <u>=</u> <u>4096</u> and <u>High</u> <u>=</u> <u>8192</u>.

                  <u>Note</u>  that this option is only valid when spawning an executable (port program) by opening the
                  spawn driver and when opening the <u>fd</u> driver. This option will cause a failure  with  a  <u>badarg</u>
                  exception when opening other drivers.

                <u>{busy_limits_msgq,</u> <u>{Low,</u> <u>High}</u> <u>|</u> <u>disabled}</u>:
                  Sets limits that will be used for controlling the busy state of the port message queue.

                  When  the  ports  message  queue size becomes larger than or equal to <u>High</u> bytes it enters the
                  busy state. When it becomes less than <u>Low</u> bytes it  leaves  the  busy  state.  When  the  port
                  message  queue  is in the busy state, processes sending commands to it will be suspended until
                  the port message queue leaves the busy state. Commands are  in  this  context  either  <u>Port</u>  <u>!</u>
                  <u>{Owner,</u> <u>{command,</u> <u>Data}}</u> or <u>port_command/[2,3]</u>.

                  The  <u>Low</u>  limit  is  automatically adjusted to the same as <u>High</u> if it is set larger then <u>High</u>.
                  Valid range of values for <u>Low</u> and <u>High</u> is <u>[1,</u> <u>(1</u> <u>bsl</u> <u>(8*erlang:system_info(wordsize)))-2]</u>.  If
                  the atom <u>disabled</u> is passed, the port message queue will never enter the busy state.

                  <u>Note</u>  that  if  the  driver  statically has disabled the use of this feature, a failure with a
                  <u>badarg</u> exception will be raised unless this option also is set to <u>disable</u>  or  not  passed  at
                  all.

                  The  defaults  are  <u>Low</u>  <u>=</u> <u>4096</u> and <u>High</u> <u>=</u> <u>8192</u> unless the driver itself does modifications of
                  these values.

                  <u>Note</u> that the driver might fail if it also adjust these limits by itself and you have disabled
                  this feature.

                  The spawn driver (used when spawning an executable) and the <u>fd</u>  driver  do  not  disable  this
                  feature and do not adjust these limits by themselves.

                  For more information see the documentation <u>erl_drv_busy_msgq_limits()</u>.

              Default is <u>stream</u> for all port types and <u>use_stdio</u> for spawned ports.

              Failure: if the port cannot be opened, the exit reason is <u>badarg</u>, <u>system_limit</u>, or the POSIX error
              code that most closely describes the error, or <u>einval</u> if no POSIX code is appropriate:

                <u>badarg</u>:
                  Bad input arguments to <u>open_port</u>.

                <u>system_limit</u>:
                  All available ports in the Erlang emulator are in use.

                <u>enomem</u>:
                  Not enough memory to create the port.

                <u>eagain</u>:
                  No more available OS processes.

                <u>enametoolong</u>:
                  Too long external command.

                <u>emfile</u>:
                  No more available file descriptors (for the OS process that the Erlang emulator runs in).

                <u>enfile</u>:
                  Full file table (for the entire OS).

                <u>eacces</u>:
                  <u>Command</u> specified in <u>{spawn_executable,</u> <u>Command}</u> does not point out an executable file.

                <u>enoent</u>:
                  <u>FileName</u> specified in <u>{spawn_executable,</u> <u>FileName}</u> does not point out an existing file.

              During  use  of  a  port  opened  using <u>{spawn,</u> <u>Name}</u>, <u>{spawn_driver,</u> <u>Name}</u>, or <u>{spawn_executable,</u>
              <u>Name}</u>, errors arising when sending messages to it are reported to the owning process using signals
              of the form <u>{'EXIT',</u> <u>Port,</u> <u>PosixCode}</u>. For the possible values of <u>PosixCode</u>, see <u><a href="../man3erl/file.3erl.html">file</a>(3erl)</u>.

              The maximum number of ports that can be open at  the  same  time  can  be  configured  by  passing
              command-line flag <u>+Q</u> to <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

       <b>erlang:phash(Term,</b> <b>Range)</b> <b>-&gt;</b> <b>Hash</b>

              Types:

                 Term = term()
                 Range = Hash = integer() &gt;= 1
                   Range = 1..2^32, Hash = 1..Range

          <b>Warning:</b>
              This  function  is  deprecated  as  <u>erlang:phash2/2</u>  should  be  used  for  new  code.  Note  that
              <u>erlang:phash(X,N)</u> is not necessary equal to <u>erlang:phash2(X,N)</u>

              Portable hash function that gives the same hash for the same Erlang  term  regardless  of  machine
              architecture  and  ERTS  version  (the BIF was introduced in ERTS 4.9.1.1). The function returns a
              hash value for <u>Term</u> within the range <u>1..Range</u>. The maximum value for <u>Range</u> is 2^32.

       <b>erlang:phash2(Term)</b> <b>-&gt;</b> <b>Hash</b>

       <b>erlang:phash2(Term,</b> <b>Range)</b> <b>-&gt;</b> <b>Hash</b>

              Types:

                 Term = term()
                 Range = integer() &gt;= 1
                   1..2^32
                 Hash = integer() &gt;= 0
                   0..Range-1

              Portable hash function that gives the same hash for the same Erlang  term  regardless  of  machine
              architecture  and  ERTS  version (the BIF was introduced in ERTS 5.2). The function returns a hash
              value for <u>Term</u> within the range <u>0..Range-1</u>. The maximum value for  <u>Range</u>  is  2^32.  When  without
              argument <u>Range</u>, a value in the range 0..2^27-1 is returned.

              This  BIF  is  always  to  be  used  for  hashing terms. It distributes small integers better than
              <u>phash/2</u>, and it is faster for bignums and binaries.

              Notice that the range <u>0..Range-1</u> is different from the range of <u>phash/2</u>, which is <u>1..Range</u>.

       <b>pid_to_list(Pid)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Pid = pid()

              Returns a string corresponding to the text representation of <u>Pid</u>. Example:

              &gt; erlang:pid_to_list(self()).
              "&lt;0.85.0&gt;"

          <b>Note:</b>
              The creation for the node is not included in the list  representation  of  <u>Pid</u>.  This  means  that
              processes  in  different  incarnations  of  a  node  with  a  specific  name can get the same list
              representation.

       <b>erlang:port_call(Port,</b> <b>Operation,</b> <b>Data)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Port = port() | atom()
                 Operation = integer()
                 Data = term()

              Performs a synchronous call to a port. The meaning of <u>Operation</u> and <u>Data</u> depends on the port, that
              is, on the port driver. Not all port drivers support this feature.

              <u>Port</u> is a port identifier, referring to a driver.

              <u>Operation</u> is an integer, which is passed on to the driver.

              <u>Data</u> is any Erlang term. This data is converted to binary term format and sent to the port.

              Returns a term from the driver. The meaning of the returned data also depends on the port driver.

              Failures:

                <u>badarg</u>:
                   If <u>Port</u> is not an identifier of an open port, or the registered name of an open port. If  the
                  calling  process was previously linked to the closed port, identified by <u>Port</u>, the exit signal
                  from the port is guaranteed to be delivered before this <u>badarg</u> exception occurs.

                <u>badarg</u>:
                   If <u>Operation</u> does not fit in a 32-bit integer.

                <u>badarg</u>:
                   If the port driver does not support synchronous control operations.

                <u>badarg</u>:
                  If the port driver so decides for any reason  (probably  something  wrong  with  <u>Operation</u>  or
                  <u>Data</u>).

            <b>Warning:</b>
                Do not call <u>port_call</u> with an unknown <u>Port</u> identifier and expect <u>badarg</u> exception. Any undefined
                behavior  is  possible  (including  node  crash) depending on how the port driver interprets the
                supplied arguments.

       <b>port_close(Port)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Port = port() | atom()

              Closes an open port. Roughly the same as <u>Port</u> <u>!</u> <u>{self(),</u> <u>close}</u> except for the error behavior (see
              below), being synchronous, and that the port does <u>not</u> reply with <u>{Port,</u> <u>closed}</u>. Any  process  can
              close  a  port  with <u>port_close/1</u>, not only the port owner (the connected process). If the calling
              process is linked to the port identified by <u>Port</u>, the exit signal from the port is  guaranteed  to
              be delivered before <u>port_close/1</u> returns.

              For  comparison: <u>Port</u> <u>!</u> <u>{self(),</u> <u>close}</u> only fails with <u>badarg</u> if <u>Port</u> does not refer to a port or
              a process. If <u>Port</u> is a closed port, nothing happens. If <u>Port</u> is an  open  port  and  the  calling
              process is the port owner, the port replies with <u>{Port,</u> <u>closed}</u> when all buffers have been flushed
              and  the  port  really  closes. If the calling process is not the port owner, the <u>port</u> <u>owner</u> fails
              with <u>badsig</u>.

              Notice that any process can close a port using <u>Port</u> <u>!</u> <u>{PortOwner,</u> <u>close}</u> as if it itself  was  the
              port owner, but the reply always goes to the port owner.

              As  from  Erlang/OTP  R16,  <u>Port</u>  <u>!</u>  <u>{PortOwner,</u>  <u>close}</u>  is  truly asynchronous. Notice that this
              operation  has  always  been  documented  as  an  asynchronous  operation,  while  the  underlying
              implementation  has  been  synchronous. <u>port_close/1</u> is however still fully synchronous because of
              its error behavior.

              Failure: <u>badarg</u> if <u>Port</u> is not an identifier of an open port, or the registered name  of  an  open
              port.  If  the  calling  process was previously linked to the closed port, identified by <u>Port</u>, the
              exit signal from the port is guaranteed to be delivered before this <u>badarg</u> exception occurs.

       <b>port_command(Port,</b> <b>Data)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Port = port() | atom()
                 Data = iodata()

              Sends data to a port. Same as <u>Port</u> <u>!</u> <u>{PortOwner,</u> <u>{command,</u> <u>Data}}</u> except for  the  error  behavior
              and  being  synchronous  (see below). Any process can send data to a port with <u>port_command/2</u>, not
              only the port owner (the connected process).

              For comparison: <u>Port</u> <u>!</u> <u>{PortOwner,</u> <u>{command,</u> <u>Data}}</u> only fails with <u>badarg</u> if <u>Port</u> does not  refer
              to  a port or a process. If <u>Port</u> is a closed port, the data message disappears without a sound. If
              <u>Port</u> is open and the calling process is not the port owner, the <u>port</u> <u>owner</u> fails with <u>badsig</u>.  The
              port owner fails with <u>badsig</u> also if <u>Data</u> is an invalid I/O list.

              Notice  that  any  process  can  send to a port using <u>Port</u> <u>!</u> <u>{PortOwner,</u> <u>{command,</u> <u>Data}}</u> as if it
              itself was the port owner.

              If the port is busy, the calling process is suspended until the port is not busy any more.

              As from Erlang/OTP R16, <u>Port</u> <u>!</u> <u>{PortOwner,</u> <u>{command,</u> <u>Data}}</u> is  truly  asynchronous.  Notice  that
              this  operation  has  always  been  documented  as an asynchronous operation, while the underlying
              implementation has been synchronous. <u>port_command/2</u> is however still fully synchronous because  of
              its error behavior.

              Failures:

                <u>badarg</u>:
                  If  <u>Port</u>  is not an identifier of an open port, or the registered name of an open port. If the
                  calling process was previously linked to the closed port, identified by <u>Port</u>, the exit  signal
                  from the port is guaranteed to be delivered before this <u>badarg</u> exception occurs.

                <u>badarg</u>:
                  If <u>Data</u> is an invalid I/O list.

          <b>Warning:</b>
              Do  not  send  data  to an unknown port. Any undefined behavior is possible (including node crash)
              depending on how the port driver interprets the data.

       <b>port_command(Port,</b> <b>Data,</b> <b>OptionList)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Port = port() | atom()
                 Data = iodata()
                 Option = force | nosuspend
                 OptionList = [Option]

              Sends data to a port. <u>port_command(Port,</u> <u>Data,</u> <u>[])</u> equals <u>port_command(Port,</u> <u>Data)</u>.

              If the port command is aborted, <u>false</u> is returned, otherwise <u>true</u>.

              If the port is busy, the calling process is suspended until the port is not busy anymore.

              <u>Option</u>s:

                <u>force</u>:
                  The calling process is not suspended if the port is busy, instead the port command  is  forced
                  through.  The  call  fails  with a <u>notsup</u> exception if the driver of the port does not support
                  this. For more information, see driver flag <u>ERL_DRV_FLAG_SOFT_BUSY</u>.

                <u>nosuspend</u>:
                  The calling process is not suspended if the port is busy, instead the port command is  aborted
                  and <u>false</u> is returned.

          <b>Note:</b>
              More options can be added in a future release.

              Failures:

                <u>badarg</u>:
                   If  <u>Port</u> is not an identifier of an open port, or the registered name of an open port. If the
                  calling process was previously linked to the closed port, identified by <u>Port</u>, the exit  signal
                  from the port is guaranteed to be delivered before this <u>badarg</u> exception occurs.

                <u>badarg</u>:
                   If <u>Data</u> is an invalid I/O list.

                <u>badarg</u>:
                   If <u>OptionList</u> is an invalid option list.

                <u>notsup</u>:
                   If  option <u>force</u> has been passed, but the driver of the port does not allow forcing through a
                  busy port.

          <b>Warning:</b>
              Do not send data to an unknown port. Any undefined behavior is  possible  (including  node  crash)
              depending on how the port driver interprets the data.

       <b>port_connect(Port,</b> <b>Pid)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Port = port() | atom()
                 Pid = pid()

              Sets  the  port  owner  (the  connected port) to <u>Pid</u>. Roughly the same as <u>Port</u> <u>!</u> <u>{Owner,</u> <u>{connect,</u>
              <u>Pid}}</u> except for the following:

                * The error behavior differs, see below.

                * The port does <u>not</u> reply with <u>{Port,connected}</u>.

                * <u>port_connect/1</u> is synchronous, see below.

                * The new port owner gets linked to the port.

              The old port owner stays linked to the port and must call <u>unlink(Port)</u> if this is not desired. Any
              process can set the port owner to be any process with <u>port_connect/2</u>.

              For comparison: <u>Port</u> <u>!</u> <u>{self(),</u> <u>{connect,</u> <u>Pid}}</u> only fails with <u>badarg</u> if <u>Port</u> does not refer to a
              port or a process. If <u>Port</u> is a closed port, nothing happens. If <u>Port</u> is  an  open  port  and  the
              calling  process is the port owner, the port replies with <u>{Port,</u> <u>connected}</u> to the old port owner.
              Notice that the old port owner is still linked to the port, while the new is not. If  <u>Port</u>  is  an
              open  port  and  the  calling process is not the port owner, the <u>port</u> <u>owner</u> fails with <u>badsig</u>. The
              port owner fails with <u>badsig</u> also if <u>Pid</u> is not an existing local process identifier.

              Notice that any process can set the port owner using <u>Port</u> <u>!</u> <u>{PortOwner,</u> <u>{connect,</u> <u>Pid}}</u> as  if  it
              itself was the port owner, but the reply always goes to the port owner.

              As from Erlang/OTP R16, <u>Port</u> <u>!</u> <u>{PortOwner,</u> <u>{connect,</u> <u>Pid}}</u> is truly asynchronous. Notice that this
              operation  has  always  been  documented  as  an  asynchronous  operation,  while  the  underlying
              implementation has been synchronous. <u>port_connect/2</u> is however still fully synchronous because  of
              its error behavior.

              Failures:

                <u>badarg</u>:
                   If  <u>Port</u> is not an identifier of an open port, or the registered name of an open port. If the
                  calling process was previously linked to the closed port, identified by <u>Port</u>, the exit  signal
                  from the port is guaranteed to be delivered before this <u>badarg</u> exception occurs.

                <u>badarg</u>:
                  If the process identified by <u>Pid</u> is not an existing local process.

       <b>port_control(Port,</b> <b>Operation,</b> <b>Data)</b> <b>-&gt;</b> <b>iodata()</b> <b>|</b> <b>binary()</b>

              Types:

                 Port = port() | atom()
                 Operation = integer()
                 Data = iodata()

              Performs  a  synchronous control operation on a port. The meaning of <u>Operation</u> and <u>Data</u> depends on
              the port, that is, on the port driver. Not all port drivers support this control feature.

              Returns a list of integers in the range 0..255, or a binary, depending on  the  port  driver.  The
              meaning of the returned data also depends on the port driver.

              Failures:

                <u>badarg</u>:
                   If <u>Port</u> is not an open port or the registered name of an open port.

                <u>badarg</u>:
                   If <u>Operation</u> cannot fit in a 32-bit integer.

                <u>badarg</u>:
                   If the port driver does not support synchronous control operations.

                <u>badarg</u>:
                   If  the  port  driver  so  decides for any reason (probably something wrong with <u>Operation</u> or
                  <u>Data</u>).

            <b>Warning:</b>
                Do not call <u>port_control/3</u> with an unknown <u>Port</u> identifier  and  expect  <u>badarg</u>  exception.  Any
                undefined  behavior  is  possible  (including  node  crash)  depending  on  how  the port driver
                interprets the supplied arguments.

       <b>erlang:port_info(Port)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Port = port() | atom()
                 ResultItem =
                     {registered_name, RegisteredName :: atom()} |
                     {id, Index :: integer() &gt;= 0} |
                     {connected, Pid :: pid()} |
                     {links, Pids :: [pid()]} |
                     {name, String :: string()} |
                     {input, Bytes :: integer() &gt;= 0} |
                     {output, Bytes :: integer() &gt;= 0} |
                     {os_pid, OsPid :: integer() &gt;= 0 | undefined}
                 Result = [ResultItem] | undefined

              Returns a list containing tuples with information about <u>Port</u>, or <u>undefined</u>  if  the  port  is  not
              open.  The  order of the tuples is undefined, and all the tuples are not mandatory. If the port is
              closed and the calling process was previously linked to the port, the exit signal from the port is
              guaranteed to be delivered before <u>port_info/1</u> returns <u>undefined</u>.

              The result contains information about the following <u>Item</u>s:

                * <u>registered_name</u> (if the port has a registered name)

                * <u>id</u>

                * <u>connected</u>

                * <u>links</u>

                * <u>name</u>

                * <u>input</u>

                * <u>output</u>

              For more information about the different <u>Item</u>s, see <u>port_info/2</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>connected)</b> <b>-&gt;</b>
                           {connected, Pid} | undefined

              Types:

                 Port = port() | atom()
                 Pid = pid()

              <u>Pid</u> is the process identifier of the process connected to the port.

              If the port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed  and  the
              calling  process was previously linked to the port, the exit signal from the port is guaranteed to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>id)</b> <b>-&gt;</b> <b>{id,</b> <b>Index}</b> <b>|</b> <b>undefined</b>

              Types:

                 Port = port() | atom()
                 Index = integer() &gt;= 0

              <u>Index</u> is the internal index of the port. This index can be used to separate ports.

              If the port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed  and  the
              calling  process was previously linked to the port, the exit signal from the port is guaranteed to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>input)</b> <b>-&gt;</b>
                           {input, Bytes} | undefined

              Types:

                 Port = port() | atom()
                 Bytes = integer() &gt;= 0

              <u>Bytes</u> is the total number of bytes read from the port.

              If the port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed  and  the
              calling  process was previously linked to the port, the exit signal from the port is guaranteed to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>links)</b> <b>-&gt;</b> <b>{links,</b> <b>Pids}</b> <b>|</b> <b>undefined</b>

              Types:

                 Port = port() | atom()
                 Pids = [pid()]

              <u>Pids</u> is a list of the process identifiers of the processes that the port is linked to.

              If the port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed  and  the
              calling  process was previously linked to the port, the exit signal from the port is guaranteed to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>locking)</b> <b>-&gt;</b>
                           {locking, Locking} | undefined

              Types:

                 Port = port() | atom()
                 Locking = false | port_level | driver_level

              <u>Locking</u> is one of the following:

                * <u>port_level</u> (port-specific locking)

                * <u>driver_level</u> (driver-specific locking)

              Notice that these results are highly implementation-specific and can change in a future release.

              If the port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed  and  the
              calling  process was previously linked to the port, the exit signal from the port is guaranteed to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>memory)</b> <b>-&gt;</b>
                           {memory, Bytes} | undefined

              Types:

                 Port = port() | atom()
                 Bytes = integer() &gt;= 0

              <u>Bytes</u> is the total number of bytes allocated for this port by the runtime system. The port  itself
              can have allocated memory that is not included in <u>Bytes</u>.

              If  the  port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed and the
              calling process was previously linked to the port, the exit signal from the port is guaranteed  to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>monitors)</b> <b>-&gt;</b>
                           {monitors, Monitors} | undefined

              Types:

                 Port = port() | atom()
                 Monitors = [{process, pid()}]

              <u>Monitors</u> represent processes monitored by this port.

              If  the  port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed and the
              calling process was previously linked to the port, the exit signal from the port is guaranteed  to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>monitored_by)</b> <b>-&gt;</b>
                           {monitored_by, MonitoredBy} | undefined

              Types:

                 Port = port() | atom()
                 MonitoredBy = [pid()]

              Returns list of pids that are monitoring given port at the moment.

              If  the  port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed and the
              calling process was previously linked to the port, the exit signal from the port is guaranteed  to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>name)</b> <b>-&gt;</b> <b>{name,</b> <b>Name}</b> <b>|</b> <b>undefined</b>

              Types:

                 Port = port() | atom()
                 Name = string()

              <u>Name</u> is the command name set by <u>open_port/2</u>.

              If  the  port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed and the
              calling process was previously linked to the port, the exit signal from the port is guaranteed  to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>os_pid)</b> <b>-&gt;</b>
                           {os_pid, OsPid} | undefined

              Types:

                 Port = port() | atom()
                 OsPid = integer() &gt;= 0 | undefined

              <u>OsPid</u>  is  the process identifier (or equivalent) of an OS process created with <u>open_port({spawn</u> <u>|</u>
              <u>spawn_executable,</u> <u>Command},</u> <u>Options)</u>. If the port is not the result of spawning an OS process, the
              value is <u>undefined</u>.

              If the port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed  and  the
              calling  process was previously linked to the port, the exit signal from the port is guaranteed to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>output)</b> <b>-&gt;</b>
                           {output, Bytes} | undefined

              Types:

                 Port = port() | atom()
                 Bytes = integer() &gt;= 0

              <u>Bytes</u> is the total number of bytes written to the port from Erlang processes using <u>port_command/2</u>,
              <u>port_command/3</u>, or <u>Port</u> <u>!</u> <u>{Owner,</u> <u>{command,</u> <u>Data}</u>.

              If the port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed  and  the
              calling  process was previously linked to the port, the exit signal from the port is guaranteed to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>parallelism)</b> <b>-&gt;</b>
                           {parallelism, Boolean} | undefined

              Types:

                 Port = port() | atom()
                 Boolean = boolean()

              <u>Boolean</u> corresponds to the port parallelism hint used by this  port.  For  more  information,  see
              option <u>parallelism</u> of <u>open_port/2</u>.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>queue_size)</b> <b>-&gt;</b>
                           {queue_size, Bytes} | undefined

              Types:

                 Port = port() | atom()
                 Bytes = integer() &gt;= 0

              <u>Bytes</u> is the total number of bytes queued by the port using the ERTS driver queue implementation.

              If  the  port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed and the
              calling process was previously linked to the port, the exit signal from the port is guaranteed  to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>erlang:port_info(Port,</b> <b>Item</b> <b>::</b> <b>registered_name)</b> <b>-&gt;</b>
                           {registered_name, RegisteredName} |
                           [] | undefined

              Types:

                 Port = port() | atom()
                 RegisteredName = atom()

              <u>RegisteredName</u>  is  the  registered  name  of  the port. If the port has no registered name, <u>[]</u> is
              returned.

              If the port identified by <u>Port</u> is not open, <u>undefined</u> is returned. If the port is closed  and  the
              calling  process was previously linked to the port, the exit signal from the port is guaranteed to
              be delivered before <u>port_info/2</u> returns <u>undefined</u>.

              Failure: <u>badarg</u> if <u>Port</u> is not a local port identifier, or an atom.

       <b>port_to_list(Port)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Port = port()

              Returns a string corresponding to the text representation of the port identifier <u>Port</u>.

       <b>erlang:ports()</b> <b>-&gt;</b> <b>[port()]</b>

              Returns a list of port identifiers corresponding to all the ports existing on the local node.

              Notice that an exiting port exists, but is not open.

       <b>pre_loaded()</b> <b>-&gt;</b> <b>[module()]</b>

              Returns a list of Erlang modules that are preloaded in the run-time system. Pre-loaded modules are
              Erlang modules that are needed to bootstrap the system to  load  the  first  Erlang  modules  from
              either disk or by using <u>erl_boot_server</u>.

       <b>erlang:process_display(Pid,</b> <b>Type)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Pid = pid()
                 Type = backtrace

              Writes  information  about the local process <u>Pid</u> on standard error. The only allowed value for the
              atom <u>Type</u> is <u>backtrace</u>, which shows the contents of the call stack,  including  information  about
              the  call  chain, with the current function printed first. The format of the output is not further
              defined.

       <b>process_flag(Flag</b> <b>::</b> <b>trap_exit,</b> <b>Boolean)</b> <b>-&gt;</b> <b>OldBoolean</b>

              Types:

                 Boolean = OldBoolean = boolean()

              When <u>trap_exit</u> is set to <u>true</u>, exit signals arriving to a process are converted to <u>{'EXIT',</u>  <u>From,</u>
              <u>Reason}</u>  messages,  which  can be received as ordinary messages. If <u>trap_exit</u> is set to <u>false</u>, the
              process exits if it receives an exit signal other than <u>normal</u> and the exit signal is propagated to
              its linked processes. Application processes are normally not to trap exits.

              Returns the old value of the flag.

              See also <u>exit/2</u>.

       <b>process_flag(Flag</b> <b>::</b> <b>error_handler,</b> <b>Module)</b> <b>-&gt;</b> <b>OldModule</b>

              Types:

                 Module = OldModule = atom()

              Used by a process to redefine the  error  handler  for  undefined  function  calls  and  undefined
              registered  processes.  Inexperienced users are not to use this flag, as code auto-loading depends
              on the correct operation of the error handling module.

              Returns the old value of the flag.

       <b>process_flag(Flag</b> <b>::</b> <b>fullsweep_after,</b> <b>FullsweepAfter)</b> <b>-&gt;</b>
                       OldFullsweepAfter

              Types:

                 FullsweepAfter = OldFullsweepAfter = integer() &gt;= 0

              Changes the maximum number of generational collections before forcing a fullsweep for the  calling
              process.

              Returns the old value of the flag.

       <b>process_flag(Flag</b> <b>::</b> <b>min_heap_size,</b> <b>MinHeapSize)</b> <b>-&gt;</b> <b>OldMinHeapSize</b>

              Types:

                 MinHeapSize = OldMinHeapSize = integer() &gt;= 0

              Changes the minimum heap size for the calling process.

              Returns the old value of the flag.

       <b>process_flag(Flag</b> <b>::</b> <b>min_bin_vheap_size,</b> <b>MinBinVHeapSize)</b> <b>-&gt;</b>
                       OldMinBinVHeapSize

              Types:

                 MinBinVHeapSize = OldMinBinVHeapSize = integer() &gt;= 0

              Changes the minimum binary virtual heap size for the calling process.

              Returns the old value of the flag.

       <b>process_flag(Flag</b> <b>::</b> <b>max_heap_size,</b> <b>MaxHeapSize)</b> <b>-&gt;</b> <b>OldMaxHeapSize</b>

              Types:

                 MaxHeapSize = OldMaxHeapSize = max_heap_size()
                 <b>max_heap_size()</b> =
                     integer() &gt;= 0 |
                     #{size =&gt; integer() &gt;= 0,
                       kill =&gt; boolean(),
                       error_logger =&gt; boolean()}

              This  flag  sets  the maximum heap size for the calling process. If <u>MaxHeapSize</u> is an integer, the
              system default values for <u>kill</u> and <u>error_logger</u> are used.

                <u>size</u>:
                  The maximum size in words of the process. If set to zero, the heap  size  limit  is  disabled.
                  <u>badarg</u>  is  be  thrown if the value is smaller than <u>min_heap_size</u>. The size check is only done
                  when a garbage collection is triggered.

                  <u>size</u> is the entire heap of the process when garbage collection is triggered. This includes all
                  generational heaps, the process stack, any  messages that are considered to  be  part  of  the
                  heap, and any extra memory that the garbage collector needs during collection.

                  <u>size</u>  is  the  same as can be retrieved using <u>erlang:process_info(Pid,</u> <u>total_heap_size)</u>, or by
                  adding  <u>heap_block_size</u>,  <u>old_heap_block_size</u>  and  <u>mbuf_size</u>  from   <u>erlang:process_info(Pid,</u>
                  <u>garbage_collection_info)</u>.

                <u>kill</u>:
                  When  set to <u>true</u>, the runtime system sends an untrappable exit signal with reason <u>kill</u> to the
                  process if the maximum heap size is reached. The garbage collection that triggered the <u>kill</u> is
                  not completed, instead the process exits as soon as possible.  When  set  to  <u>false</u>,  no  exit
                  signal is sent to the process, instead it continues executing.

                  If <u>kill</u> is not defined in the map, the system default will be used. The default system default
                  is    <u>true</u>.    It    can    be    changed    by   either   option   +hmaxk   in   <u><a href="../man1/erl.1.html">erl</a>(1)</u>,   or
                  <u>erlang:system_flag(max_heap_size,</u> <u>MaxHeapSize)</u>.

                <u>error_logger</u>:
                  When set to <u>true</u>, the runtime system logs an error event via <u>logger</u>, containing details  about
                  the  process  when the maximum heap size is reached. One log event is sent each time the limit
                  is reached.

                  If <u>error_logger</u> is not defined in the map, the system default  is  used.  The  default  system
                  default   is   <u>true</u>.  It  can  be  changed  by  either  the  option  +hmaxel  int  <u><a href="../man1/erl.1.html">erl</a>(1)</u>,  or
                  <u>erlang:system_flag(max_heap_size,</u> <u>MaxHeapSize)</u>.

              The heap size of a process is quite hard to predict, especially the amount of memory that is  used
              during  the  garbage  collection. When contemplating using this option, it is recommended to first
              run it in production with <u>kill</u> set to <u>false</u> and inspect the log events to see what the normal peak
              sizes of the processes in the system is and then tune the value accordingly.

       <b>process_flag(Flag</b> <b>::</b> <b>message_queue_data,</b> <b>MQD)</b> <b>-&gt;</b> <b>OldMQD</b>

              Types:

                 MQD = OldMQD = message_queue_data()
                 <b>message_queue_data()</b> = off_heap | on_heap

              Determines how messages in the message queue are stored, as follows:

                <u>off_heap</u>:
                  <u>All</u> messages in the message queue will be stored outside the process heap. This  implies  that
                  <u>no</u> messages in the message queue will be part of a garbage collection of the process.

                <u>on_heap</u>:
                  All  messages  in  the  message queue will eventually be placed on the process heap. They can,
                  however, be temporarily stored off the heap. This is how messages have always been  stored  up
                  until ERTS 8.0.

              The  default  value  of  the  <u>message_queue_data</u>  process  flag  is determined by the command-line
              argument <u>+hmqd</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

              If the process may potentially  accumulate  a  large  number  of  messages  in  its  queue  it  is
              recommended to set the flag value to <u>off_heap</u>. This is due to the fact that the garbage collection
              of a process that has a large number of messages stored on the heap can become extremely expensive
              and the process can consume large amounts of memory. The performance of the actual message passing
              is, however, generally better when the flag value is <u>on_heap</u>.

              Changing the flag value causes any existing messages to be moved. The move operation is initiated,
              but not necessarily completed, by the time the function returns.

              Returns the old value of the flag.

       <b>process_flag(Flag</b> <b>::</b> <b>priority,</b> <b>Level)</b> <b>-&gt;</b> <b>OldLevel</b>

              Types:

                 Level = OldLevel = priority_level()
                 <b>priority_level()</b> = low | normal | high | max

              Sets  the  process  priority. <u>Level</u> is an atom. Four priority levels exist: <u>low</u>, <u>normal</u>, <u>high</u>, and
              <u>max</u>. Default is <u>normal</u>.

          <b>Note:</b>
              Priority level <u>max</u> is reserved for internal use in the Erlang runtime system, and  is  <u>not</u>  to  be
              used by others.

              Internally in each priority level, processes are scheduled in a round robin fashion.

              Execution  of  processes on priority <u>normal</u> and <u>low</u> are interleaved. Processes on priority <u>low</u> are
              selected for execution less frequently than processes on priority <u>normal</u>.

              When runnable processes on priority <u>high</u> exist,  no  processes  on  priority  <u>low</u>  or  <u>normal</u>  are
              selected  for  execution. Notice however that this does <u>not</u> mean that no processes on priority <u>low</u>
              or <u>normal</u> can run when processes are running on priority <u>high</u>.  When  using  multiple  schedulers,
              more  processes  can  be running in parallel than processes on priority <u>high</u>. That is, a <u>low</u> and a
              <u>high</u> priority process can execute at the same time.

              When runnable processes on priority <u>max</u> exist, no processes on priority <u>low</u>, <u>normal</u>, or  <u>high</u>  are
              selected  for  execution.  As  with  priority  <u>high</u>,  processes on lower priorities can execute in
              parallel with processes on priority <u>max</u>.

              Scheduling is pre-emptive. Regardless of priority, a process is pre-empted when  it  has  consumed
              more than a certain number of reductions since the last time it was selected for execution.

          <b>Note:</b>
              Do  not  depend  on  the  scheduling  to remain exactly as it is today. Scheduling is likely to be
              changed in a future release to use available processor cores better.

              There is <u>no</u> automatic mechanism for avoiding priority inversion, such as priority  inheritance  or
              priority  ceilings.  When  using  priorities,  take this into account and handle such scenarios by
              yourself.

              Making calls from a <u>high</u> priority process into code that you has no control  over  can  cause  the
              <u>high</u>  priority  process to wait for a process with lower priority. That is, effectively decreasing
              the priority of the <u>high</u> priority process during the call. Even if this is not the case  with  one
              version  of  the code that you have no control over, it can be the case in a future version of it.
              This can, for example, occur if a <u>high</u> priority process triggers code loading, as the code  server
              runs on priority <u>normal</u>.

              Other  priorities  than  <u>normal</u>  are normally not needed. When other priorities are used, use them
              with care, <u>especially</u> priority <u>high</u>. A process on priority <u>high</u> is only to perform work for  short
              periods.  Busy looping for long periods in a <u>high</u> priority process causes most likely problems, as
              important OTP servers run on priority <u>normal</u>.

              Returns the old value of the flag.

       <b>process_flag(Flag</b> <b>::</b> <b>save_calls,</b> <b>N)</b> <b>-&gt;</b> <b>OldN</b>

              Types:

                 N = OldN = 0..10000

              <u>N</u> must be an integer in the interval 0..10000. If <u>N</u> &gt; 0,  call  saving  is  made  active  for  the
              process.  This  means  that  information about the <u>N</u> most recent global function calls, BIF calls,
              sends, and receives made by the process  are  saved  in  a  list,  which  can  be  retrieved  with
              <u>process_info(Pid,</u>  <u>last_calls)</u>.  A global function call is one in which the module of the function
              is explicitly mentioned. Only a fixed amount of information is saved, as follows:

                * A tuple <u>{Module,</u> <u>Function,</u> <u>Arity}</u> for function calls

                * The atoms <u>send</u>, <u>'receive'</u>, and <u>timeout</u> for sends and receives (<u>'receive'</u>  when  a  message  is
                  received and <u>timeout</u> when a receive times out)

              If  <u>N</u> = 0, call saving is disabled for the process, which is the default. Whenever the size of the
              call saving list is set, its contents are reset.

              Returns the old value of the flag.

       <b>process_flag(Flag</b> <b>::</b> <b>sensitive,</b> <b>Boolean)</b> <b>-&gt;</b> <b>OldBoolean</b>

              Types:

                 Boolean = OldBoolean = boolean()

              Sets or clears flag <u>sensitive</u> for the current process. When a process has been marked as sensitive
              by calling <u>process_flag(sensitive,</u> <u>true)</u>, features in the runtime system  that  can  be  used  for
              examining the data or inner working of the process are silently disabled.

              Features that are disabled include (but are not limited to) the following:

                * Tracing.  Trace  flags can still be set for the process, but no trace messages of any kind are
                  generated. (If flag <u>sensitive</u> is turned off, trace messages are again generated if  any  trace
                  flags are set.)

                * Sequential tracing. The sequential trace token is propagated as usual, but no sequential trace
                  messages are generated.

              <u>process_info/1,2</u>  cannot be used to read out the message queue or the process dictionary (both are
              returned as empty lists).

              Stack back-traces cannot be displayed for the process.

              In crash dumps, the stack, messages, and the process dictionary are omitted.

              If <u>{save_calls,N}</u> has been set for the process, no function calls are saved  to  the  call  saving
              list.  (The  call  saving  list is not cleared. Also, send, receive, and time-out events are still
              added to the list.)

              Returns the old value of the flag.

       <b>process_flag(Pid,</b> <b>Flag,</b> <b>Value)</b> <b>-&gt;</b> <b>OldValue</b>

              Types:

                 Pid = pid()
                 Flag = save_calls
                 Value = OldValue = integer() &gt;= 0

              Sets certain flags for the process <u>Pid</u>, in the same manner  as  <u>process_flag/2</u>.  Returns  the  old
              value of the flag. The valid values for <u>Flag</u> are only a subset of those allowed in <u>process_flag/2</u>,
              namely <u>save_calls</u>.

              Failure: <u>badarg</u> if <u>Pid</u> is not a local process.

       <b>process_info(Pid)</b> <b>-&gt;</b> <b>Info</b>

              Types:

                 Pid = pid()
                 Info = [InfoTuple] | undefined
                 InfoTuple = process_info_result_item()
                 <b>process_info_result_item()</b> =
                     {backtrace, Bin :: binary()} |
                     {binary,
                      BinInfo ::
                          [{integer() &gt;= 0,
                            integer() &gt;= 0,
                            integer() &gt;= 0}]} |
                     {catchlevel, CatchLevel :: integer() &gt;= 0} |
                     {current_function,
                      {Module :: module(), Function :: atom(), Arity :: arity()} |
                      undefined} |
                     {current_location,
                      {Module :: module(),
                       Function :: atom(),
                       Arity :: arity(),
                       Location ::
                           [{file, Filename :: string()} |
                            {line, Line :: integer() &gt;= 1}]}} |
                     {current_stacktrace, Stack :: [stack_item()]} |
                     {dictionary, Dictionary :: [{Key :: term(), Value :: term()}]} |
                     {error_handler, Module :: module()} |
                     {garbage_collection, GCInfo :: [{atom(), integer() &gt;= 0}]} |
                     {garbage_collection_info,
                      GCInfo :: [{atom(), integer() &gt;= 0}]} |
                     {group_leader, GroupLeader :: pid()} |
                     {heap_size, Size :: integer() &gt;= 0} |
                     {initial_call, mfa()} |
                     {links, PidsAndPorts :: [pid() | port()]} |
                     {last_calls, false | (Calls :: [mfa()])} |
                     {memory, Size :: integer() &gt;= 0} |
                     {message_queue_len, MessageQueueLen :: integer() &gt;= 0} |
                     {messages, MessageQueue :: [term()]} |
                     {min_heap_size, MinHeapSize :: integer() &gt;= 0} |
                     {min_bin_vheap_size, MinBinVHeapSize :: integer() &gt;= 0} |
                     {max_heap_size, MaxHeapSize :: max_heap_size()} |
                     {monitored_by,
                      MonitoredBy :: [pid() | port() | nif_resource()]} |
                     {monitors,
                      Monitors ::
                          [{process | port,
                            Pid ::
                                pid() |
                                port() |
                                {RegName :: atom(), Node :: node()}}]} |
                     {message_queue_data, MQD :: message_queue_data()} |
                     {priority, Level :: priority_level()} |
                     {reductions, Number :: integer() &gt;= 0} |
                     {registered_name, [] | (Atom :: atom())} |
                     {sequential_trace_token,
                      [] | (SequentialTraceToken :: term())} |
                     {stack_size, Size :: integer() &gt;= 0} |
                     {status,
                      Status ::
                          exiting | garbage_collecting | waiting | running |
                          runnable | suspended} |
                     {suspending,
                      SuspendeeList ::
                          [{Suspendee :: pid(),
                            ActiveSuspendCount :: integer() &gt;= 0,
                            OutstandingSuspendCount :: integer() &gt;= 0}]} |
                     {total_heap_size, Size :: integer() &gt;= 0} |
                     {trace, InternalTraceFlags :: integer() &gt;= 0} |
                     {trap_exit, Boolean :: boolean()}
                 <b>priority_level()</b> = low | normal | high | max
                 <b>stack_item()</b> =
                     {Module :: module(),
                      Function :: atom(),
                      Arity :: arity() | (Args :: [term()]),
                      Location ::
                          [{file, Filename :: string()} |
                           {line, Line :: integer() &gt;= 1}]}
                 <b>max_heap_size()</b> =
                     integer() &gt;= 0 |
                     #{size =&gt; integer() &gt;= 0,
                       kill =&gt; boolean(),
                       error_logger =&gt; boolean()}
                 <b>message_queue_data()</b> = off_heap | on_heap

              Returns  a  list containing <u>InfoTuple</u>s with miscellaneous information about the process identified
              by <u>Pid</u>, or <u>undefined</u> if the process is not alive.

              The order of the <u>InfoTuple</u>s is undefined and all <u>InfoTuple</u>s are not mandatory. The <u>InfoTuple</u>s part
              of the result can be changed without prior notice.

              The <u>InfoTuple</u>s with the following items are part of the result:

                * <u>current_function</u>

                * <u>initial_call</u>

                * <u>status</u>

                * <u>message_queue_len</u>

                * <u>links</u>

                * <u>dictionary</u>

                * <u>trap_exit</u>

                * <u>error_handler</u>

                * <u>priority</u>

                * <u>group_leader</u>

                * <u>total_heap_size</u>

                * <u>heap_size</u>

                * <u>stack_size</u>

                * <u>reductions</u>

                * <u>garbage_collection</u>

              If  the  process  identified  by  <u>Pid</u>  has  a  registered  name,  also  an  <u>InfoTuple</u>  with   item
              <u>registered_name</u> is included.

              For information about specific <u>InfoTuple</u>s, see <u>process_info/2</u>.

          <b>Warning:</b>
              This BIF is intended for <u>debugging</u> <u>only</u>. For all other purposes, use <u>process_info/2</u>.

              Failure: <u>badarg</u> if <u>Pid</u> is not a local process.

       <b>process_info(Pid,</b> <b>Item)</b> <b>-&gt;</b> <b>InfoTuple</b> <b>|</b> <b>[]</b> <b>|</b> <b>undefined</b>

       <b>process_info(Pid,</b> <b>ItemList)</b> <b>-&gt;</b> <b>InfoTupleList</b> <b>|</b> <b>[]</b> <b>|</b> <b>undefined</b>

              Types:

                 Pid = pid()
                 ItemList = [Item]
                 Item = process_info_item()
                 InfoTupleList = [InfoTuple]
                 InfoTuple = process_info_result_item()
                 <b>process_info_item()</b> =
                     backtrace | binary | catchlevel | current_function |
                     current_location | current_stacktrace | dictionary |
                     error_handler | garbage_collection | garbage_collection_info |
                     group_leader | heap_size | initial_call | links | last_calls |
                     memory | message_queue_len | messages | min_heap_size |
                     min_bin_vheap_size | monitored_by | monitors |
                     message_queue_data | priority | reductions | registered_name |
                     sequential_trace_token | stack_size | status | suspending |
                     total_heap_size | trace | trap_exit
                 <b>process_info_result_item()</b> =
                     {backtrace, Bin :: binary()} |
                     {binary,
                      BinInfo ::
                          [{integer() &gt;= 0,
                            integer() &gt;= 0,
                            integer() &gt;= 0}]} |
                     {catchlevel, CatchLevel :: integer() &gt;= 0} |
                     {current_function,
                      {Module :: module(), Function :: atom(), Arity :: arity()} |
                      undefined} |
                     {current_location,
                      {Module :: module(),
                       Function :: atom(),
                       Arity :: arity(),
                       Location ::
                           [{file, Filename :: string()} |
                            {line, Line :: integer() &gt;= 1}]}} |
                     {current_stacktrace, Stack :: [stack_item()]} |
                     {dictionary, Dictionary :: [{Key :: term(), Value :: term()}]} |
                     {error_handler, Module :: module()} |
                     {garbage_collection, GCInfo :: [{atom(), integer() &gt;= 0}]} |
                     {garbage_collection_info,
                      GCInfo :: [{atom(), integer() &gt;= 0}]} |
                     {group_leader, GroupLeader :: pid()} |
                     {heap_size, Size :: integer() &gt;= 0} |
                     {initial_call, mfa()} |
                     {links, PidsAndPorts :: [pid() | port()]} |
                     {last_calls, false | (Calls :: [mfa()])} |
                     {memory, Size :: integer() &gt;= 0} |
                     {message_queue_len, MessageQueueLen :: integer() &gt;= 0} |
                     {messages, MessageQueue :: [term()]} |
                     {min_heap_size, MinHeapSize :: integer() &gt;= 0} |
                     {min_bin_vheap_size, MinBinVHeapSize :: integer() &gt;= 0} |
                     {max_heap_size, MaxHeapSize :: max_heap_size()} |
                     {monitored_by,
                      MonitoredBy :: [pid() | port() | nif_resource()]} |
                     {monitors,
                      Monitors ::
                          [{process | port,
                            Pid ::
                                pid() |
                                port() |
                                {RegName :: atom(), Node :: node()}}]} |
                     {message_queue_data, MQD :: message_queue_data()} |
                     {priority, Level :: priority_level()} |
                     {reductions, Number :: integer() &gt;= 0} |
                     {registered_name, [] | (Atom :: atom())} |
                     {sequential_trace_token,
                      [] | (SequentialTraceToken :: term())} |
                     {stack_size, Size :: integer() &gt;= 0} |
                     {status,
                      Status ::
                          exiting | garbage_collecting | waiting | running |
                          runnable | suspended} |
                     {suspending,
                      SuspendeeList ::
                          [{Suspendee :: pid(),
                            ActiveSuspendCount :: integer() &gt;= 0,
                            OutstandingSuspendCount :: integer() &gt;= 0}]} |
                     {total_heap_size, Size :: integer() &gt;= 0} |
                     {trace, InternalTraceFlags :: integer() &gt;= 0} |
                     {trap_exit, Boolean :: boolean()}
                 <b>stack_item()</b> =
                     {Module :: module(),
                      Function :: atom(),
                      Arity :: arity() | (Args :: [term()]),
                      Location ::
                          [{file, Filename :: string()} |
                           {line, Line :: integer() &gt;= 1}]}
                 <b>priority_level()</b> = low | normal | high | max
                 <b>max_heap_size()</b> =
                     integer() &gt;= 0 |
                     #{size =&gt; integer() &gt;= 0,
                       kill =&gt; boolean(),
                       error_logger =&gt; boolean()}
                 <b>message_queue_data()</b> = off_heap | on_heap

              Returns information about the process identified by <u>Pid</u>, as specified by <u>Item</u> or <u>ItemList</u>. Returns
              <u>undefined</u> if the process is not alive.

              If  the  process  is alive and a single <u>Item</u> is specified, the returned value is the corresponding
              <u>InfoTuple</u>, unless <u>Item</u> <u>=:=</u> <u>registered_name</u> and the process has no registered name. In  this  case,
              <u>[]</u>  is  returned. This strange behavior is because of historical reasons, and is kept for backward
              compatibility.

              If <u>ItemList</u> is specified, the  result  is  <u>InfoTupleList</u>.  The  <u>InfoTuple</u>s  in  <u>InfoTupleList</u>  are
              included  with  the  corresponding <u>Item</u>s in the same order as the <u>Item</u>s were included in <u>ItemList</u>.
              Valid <u>Item</u>s can be included multiple times in <u>ItemList</u>.

              Getting process informations follows the signal ordering guarantees described  in  the   Processes
              Chapter in the <u>Erlang</u> <u>Reference</u> <u>Manual</u> .

          <b>Note:</b>
              If <u>registered_name</u> is part of <u>ItemList</u> and the process has no name registered, a <u>{registered_name,</u>
              <u>[]}</u>,  <u>InfoTuple</u> <u>will</u> be included in the resulting <u>InfoTupleList</u>. This behavior is different when a
              single <u>Item</u> <u>=:=</u> <u>registered_name</u> is specified, and when <u>process_info/1</u> is used.

              Valid <u>InfoTuple</u>s with corresponding <u>Item</u>s:

                <u>{backtrace,</u> <u>Bin}</u>:
                  Binary <u>Bin</u> contains the  same  information  as  the  output  from  <u>erlang:process_display(Pid,</u>
                  <u>backtrace)</u>. Use <u>binary_to_list/1</u> to obtain the string of characters from the binary.

                <u>{binary,</u> <u>BinInfo}</u>:
                  <u>BinInfo</u>  is  a  list  containing  miscellaneous information about binaries on the heap of this
                  process. This <u>InfoTuple</u> can be changed  or  removed  without  prior  notice.  In  the  current
                  implementation  <u>BinInfo</u>  is  a  list  of  tuples.  The  tuples  contain; <u>BinaryId</u>, <u>BinarySize</u>,
                  <u>BinaryRefcCount</u>.

                  Depending on the value of the <u>message_queue_data</u> process flag the message queue may be  stored
                  on the heap.

                <u>{catchlevel,</u> <u>CatchLevel}</u>:
                  <u>CatchLevel</u>  is  the  number of currently active catches in this process. This <u>InfoTuple</u> can be
                  changed or removed without prior notice.

                <u>{current_function,</u> <u>{Module,</u> <u>Function,</u> <u>Arity}</u> <u>|</u> <u>undefined}</u>:
                  <u>Module</u>, <u>Function</u>, <u>Arity</u> is the current function call of the process. The value  <u>undefined</u>  can
                  be returned if the process is currently executing native compiled code.

                <u>{current_location,</u> <u>{Module,</u> <u>Function,</u> <u>Arity,</u> <u>Location}}</u>:
                  <u>Module</u>,  <u>Function</u>,  <u>Arity</u>  is  the current function call of the process. <u>Location</u> is a list of
                  two-tuples describing the location in the source code.

                <u>{current_stacktrace,</u> <u>Stack}</u>:
                  Returns the current call stack back-trace (<u>stacktrace</u>) of the process. The stack has the  same
                  format as in the <u>catch</u> part of a <u>try</u>. See The call-stack back trace (stacktrace). The depth of
                  the stacktrace is truncated according to the <u>backtrace_depth</u> system flag setting.

                <u>{dictionary,</u> <u>Dictionary}</u>:
                  <u>Dictionary</u> is the process dictionary.

                <u>{error_handler,</u> <u>Module}</u>:
                  <u>Module</u>  is  the  error  handler  module used by the process (for undefined function calls, for
                  example).

                <u>{garbage_collection,</u> <u>GCInfo}</u>:
                  <u>GCInfo</u> is a list containing  miscellaneous  information  about  garbage  collection  for  this
                  process. The content of <u>GCInfo</u> can be changed without prior notice.

                <u>{garbage_collection_info,</u> <u>GCInfo}</u>:
                  <u>GCInfo</u>  is  a  list containing miscellaneous detailed information about garbage collection for
                  this process. The content of <u>GCInfo</u> can be changed without prior notice. For details about the
                  meaning of each item, see <u>gc_minor_start</u> in <u>erlang:trace/3</u>.

                <u>{group_leader,</u> <u>GroupLeader}</u>:
                  <u>GroupLeader</u> is the group leader for the I/O of the process.

                <u>{heap_size,</u> <u>Size}</u>:
                  <u>Size</u> is the size in words of the youngest heap generation  of  the  process.  This  generation
                  includes  the  process  stack.  This  information  is highly implementation-dependent, and can
                  change if the implementation changes.

                <u>{initial_call,</u> <u>{Module,</u> <u>Function,</u> <u>Arity}}</u>:
                  <u>Module</u>, <u>Function</u>, <u>Arity</u> is the initial function call with which the process was spawned.

                <u>{links,</u> <u>PidsAndPorts}</u>:
                  <u>PidsAndPorts</u> is a list of process identifiers and port identifiers, with processes or ports to
                  which the process has a link.

                <u>{last_calls,</u> <u>false|Calls}</u>:
                  The value is <u>false</u> if call saving is not active for the process (see <u>process_flag/3</u>). If  call
                  saving is active, a list is returned, in which the last element is the most recent called.

                <u>{memory,</u> <u>Size}</u>:

                  <u>Size</u>  is  the  size  in  bytes  of  the  process. This includes call stack, heap, and internal
                  structures.

                <u>{message_queue_len,</u> <u>MessageQueueLen}</u>:
                  <u>MessageQueueLen</u> is the number of messages currently in the message queue of the process.  This
                  is the length of the list <u>MessageQueue</u> returned as the information item <u>messages</u> (see below).

                <u>{messages,</u> <u>MessageQueue}</u>:
                  <u>MessageQueue</u> is a list of the messages to the process, which have not yet been processed.

                <u>{min_heap_size,</u> <u>MinHeapSize}</u>:
                  <u>MinHeapSize</u> is the minimum heap size for the process.

                <u>{min_bin_vheap_size,</u> <u>MinBinVHeapSize}</u>:
                  <u>MinBinVHeapSize</u> is the minimum binary virtual heap size for the process.

                <u>{monitored_by,</u> <u>MonitoredBy}</u>:
                  A  list of identifiers for all the processes, ports and NIF resources, that are monitoring the
                  process.

                <u>{monitors,</u> <u>Monitors}</u>:
                  A list of monitors (started by <u>monitor/2</u>) that are active for the process. For a local process
                  monitor or a remote process monitor by a process identifier, the list consists of:

                  <u>{process,</u> <u>Pid}</u>:
                    Process is monitored by pid.

                  <u>{process,</u> <u>{RegName,</u> <u>Node}}</u>:
                    Local or remote process is monitored by name.

                  <u>{port,</u> <u>PortId}</u>:
                    Local port is monitored by port id.

                  <u>{port,</u> <u>{RegName,</u> <u>Node}}</u>:
                    Local port is monitored by name. Please note, that remote port monitors are  not  supported,
                    so <u>Node</u> will always be the local node name.

                <u>{message_queue_data,</u> <u>MQD}</u>:
                  <u>MQD</u>  is the current value of the <u>message_queue_data</u> process flag, which can be either <u>off_heap</u>
                  or <u>on_heap</u>. For more information, see the  documentation  of  <u>process_flag(message_queue_data,</u>
                  <u>MQD)</u>.

                <u>{priority,</u> <u>Level}</u>:
                  <u>Level</u>  is  the current priority level for the process. For more information on priorities, see
                  <u>process_flag(priority,</u> <u>Level)</u>.

                <u>{reductions,</u> <u>Number}</u>:
                  <u>Number</u> is the number of reductions executed by the process.

                <u>{registered_name,</u> <u>Atom}</u>:
                  <u>Atom</u> is the registered process name. If the process has no registered name, this tuple is  not
                  present in the list.

                <u>{sequential_trace_token,</u> <u>[]</u> <u>|</u> <u>SequentialTraceToken}</u>:
                  <u>SequentialTraceToken</u>  is  the  sequential  trace  token for the process. This <u>InfoTuple</u> can be
                  changed or removed without prior notice.

                <u>{stack_size,</u> <u>Size}</u>:
                  <u>Size</u> is the stack size, in words, of the process.

                <u>{status,</u> <u>Status}</u>:
                  <u>Status</u> is the status of the process and is one of the following:

                  * <u>exiting</u>

                  * <u>garbage_collecting</u>

                  * <u>waiting</u> (for a message)

                  * <u>running</u>

                  * <u>runnable</u> (ready to run, but another process is running)

                  * <u>suspended</u> (suspended on a "busy" port or by the BIF <u>erlang:suspend_process/1,2</u>)

                <u>{suspending,</u> <u>SuspendeeList}</u>:
                  <u>SuspendeeList</u> is a list of <u>{Suspendee,</u>  <u>ActiveSuspendCount,</u>  <u>OutstandingSuspendCount}</u>  tuples.
                  <u>Suspendee</u>  is the process identifier of a process that has been, or is to be, suspended by the
                  process    identified    by    <u>Pid</u>    through    the    BIF    <u>erlang:suspend_process/2</u>     or
                  <u>erlang:suspend_process/1</u>.

                  <u>ActiveSuspendCount</u>   is   the   number   of   times  <u>Suspendee</u>  has  been  suspended  by  <u>Pid</u>.
                  <u>OutstandingSuspendCount</u> is the number of not yet completed suspend requests sent by <u>Pid</u>,  that
                  is:

                  * If <u>ActiveSuspendCount</u> <u>=/=</u> <u>0</u>, <u>Suspendee</u> is currently in the suspended state.

                  * If  <u>OutstandingSuspendCount</u>  <u>=/=</u> <u>0</u>, option <u>asynchronous</u> of <u>erlang:suspend_process/2</u> has been
                    used and the suspendee has not yet been suspended by <u>Pid</u>.

                  Notice that <u>ActiveSuspendCount</u> and <u>OutstandingSuspendCount</u> are not the total suspend count  on
                  <u>Suspendee</u>, only the parts contributed by <u>Pid</u>.

                <u>{total_heap_size,</u> <u>Size}</u>:
                  <u>Size</u>  is  the  total  size,  in words, of all heap fragments of the process. This includes the
                  process stack and any unreceived messages that are considered to be part of the heap.

                <u>{trace,</u> <u>InternalTraceFlags}</u>:
                  <u>InternalTraceFlags</u> is an integer representing the internal trace flag for this  process.  This
                  <u>InfoTuple</u> can be changed or removed without prior notice.

                <u>{trap_exit,</u> <u>Boolean}</u>:
                  <u>Boolean</u> is <u>true</u> if the process is trapping exits, otherwise <u>false</u>.

              Notice that not all implementations support all these <u>Item</u>s.

              Failures:

                <u>badarg</u>:
                  If <u>Pid</u> is not a local process.

                <u>badarg</u>:
                  If <u>Item</u> is an invalid item.

       <b>processes()</b> <b>-&gt;</b> <b>[pid()]</b>

              Returns a list of process identifiers corresponding to all the processes currently existing on the
              local node.

              Notice that an exiting process exists, but is not alive. That is, <u>is_process_alive/1</u> returns <u>false</u>
              for  an  exiting  process,  but  its  process  identifier  is  part  of  the  result returned from
              <u>processes/0</u>.

              Example:

              &gt; processes().
              [&lt;0.0.0&gt;,&lt;0.2.0&gt;,&lt;0.4.0&gt;,&lt;0.5.0&gt;,&lt;0.7.0&gt;,&lt;0.8.0&gt;]

       <b>purge_module(Module)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Module = atom()

              Removes old code for <u>Module</u>. Before this BIF is used, <u>check_process_code/2</u>  is  to  be  called  to
              check that no processes execute old code in the module.

          <b>Warning:</b>
              This BIF is intended for the code server (see <u><a href="../man3erl/code.3erl.html">code</a>(3erl)</u>) and is not to be used elsewhere.

          <b>Note:</b>
              As  from  ERTS  8.0  (Erlang/OTP  19),  any lingering processes that still execute the old code is
              killed by this function. In earlier versions, such incorrect  use  could  cause  much  more  fatal
              failures, like emulator crash.

              Failure: <u>badarg</u> if there is no old code for <u>Module</u>.

       <b>put(Key,</b> <b>Val)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Key = Val = term()

              Adds a new <u>Key</u> to the process dictionary, associated with the value <u>Val</u>, and returns <u>undefined</u>. If
              <u>Key</u>  exists, the old value is deleted and replaced by <u>Val</u>, and the function returns the old value.
              The average time complexity for the current implementation of this function is O(<u>1</u>) and the  worst
              case time complexity is O(<u>N</u>), where <u>N</u> is the number of items in the process dictionary. Example:

              &gt; X = put(name, walrus), Y = put(name, carpenter),
              Z = get(name),
              {X, Y, Z}.
              {undefined,walrus,carpenter}

          <b>Note:</b>
              The  values  stored when <u>put</u> is evaluated within the scope of a <u>catch</u> are not retracted if a <u>throw</u>
              is evaluated, or if an error occurs.

       <b>erlang:raise(Class,</b> <b>Reason,</b> <b>Stacktrace)</b> <b>-&gt;</b> <b>badarg</b>

              Types:

                 Class = error | exit | throw
                 Reason = term()
                 Stacktrace = raise_stacktrace() | stacktrace()
                 <b>raise_stacktrace()</b> =
                     [{module(), atom(), arity() | [term()]} |
                      {function(), arity() | [term()]}]

              Raises an exception of the specified class, reason, and call stack backtrace (<u>stacktrace</u>).

              <u>Class</u> is <u>error</u>, <u>exit</u>, or <u>throw</u>. So, if it were not for the stacktrace, <u>erlang:raise(Class,</u> <u>Reason,</u>
              <u>Stacktrace)</u> is equivalent to <u>erlang:Class(Reason)</u> (given that <u>Class</u> is a valid class).

              <u>Reason</u> can be any term.

              <u>Stacktrace</u> is a list as provided in a try-catch clause.

              try
                  ...
              catch Class:Reason:Stacktrace -&gt;
                  ...
              end

              That is, a list of four-tuples <u>{Module,</u> <u>Function,</u> <u>Arity</u>  <u>|</u>  <u>Args,</u>  <u>ExtraInfo}</u>,  where  <u>Module</u>  and
              <u>Function</u>  are atoms, and the third element is an integer arity or an argument list. The stacktrace
              can also contain <u>{Fun,</u> <u>Args,</u> <u>ExtraInfo}</u> tuples, where <u>Fun</u> is a local fun and <u>Args</u> is  an  argument
              list.

              Element <u>ExtraInfo</u> at the end is optional. Omitting it is equivalent to specifying an empty list.

              The stacktrace is used as the exception stacktrace for the calling process; it is truncated to the
              current maximum stacktrace depth.

              As  evaluating  this  function  causes the process to terminate, it has no return value unless the
              arguments are invalid, in which case the function <u>returns</u> <u>the</u> <u>error</u> <u>reason</u> <u>badarg</u>. If you want  to
              be  sure  not  to  return, you can call <u>error(erlang:raise(Class,</u> <u>Reason,</u> <u>Stacktrace))</u> and hope to
              distinguish exceptions later.

              See the reference manual about errors and error handling  for  more  information  about  exception
              classes and how to catch exceptions.

       <b>erlang:read_timer(TimerRef)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TimerRef = reference()
                 Time = integer() &gt;= 0
                 Result = Time | false

              Reads the state of a timer. The same as calling <u>erlang:read_timer(TimerRef,</u> <u>[])</u>.

       <b>erlang:read_timer(TimerRef,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b> <b>|</b> <b>ok</b>

              Types:

                 TimerRef = reference()
                 Async = boolean()
                 Option = {async, Async}
                 Options = [Option]
                 Time = integer() &gt;= 0
                 Result = Time | false

              Reads   the   state   of   a   timer  that  has  been  created  by  either  <u>erlang:start_timer</u>  or
              <u>erlang:send_after</u>. <u>TimerRef</u> identifies the timer, and was returned by the  BIF  that  created  the
              timer.

              <u>Options</u>:

                <u>{async,</u> <u>Async}</u>:
                  Asynchronous  request  for  state  information.  <u>Async</u>  defaults  to  <u>false</u>,  which causes the
                  operation  to  be  performed  synchronously.  In  this  case,  the  <u>Result</u>  is   returned   by
                  <u>erlang:read_timer</u>. When <u>Async</u> is <u>true</u>, <u>erlang:read_timer</u> sends an asynchronous request for the
                  state  information to the timer service that manages the timer, and then returns <u>ok</u>. A message
                  on the format <u>{read_timer,</u> <u>TimerRef,</u> <u>Result}</u> is sent to the caller of  <u>erlang:read_timer</u>  when
                  the operation has been processed.

              More <u>Option</u>s can be added in the future.

              If <u>Result</u> is an integer, it represents the time in milliseconds left until the timer expires.

              If  <u>Result</u>  is <u>false</u>, a timer corresponding to <u>TimerRef</u> could not be found. This because the timer
              had expired, or been canceled, or because <u>TimerRef</u> never has corresponded to a timer. Even if  the
              timer  has  expired,  it  does not tell you whether or not the time-out message has arrived at its
              destination yet.

          <b>Note:</b>
              The timer service that manages the timer  can  be  co-located  with  another  scheduler  than  the
              scheduler  that  the  calling process is executing on. If so, communication with the timer service
              takes much longer time than if it is located locally. If the calling  process  is  in  a  critical
              path,  and  can  do  other  things while waiting for the result of this operation, you want to use
              option <u>{async,</u> <u>true}</u>. If using option <u>{async,</u> <u>false}</u>, the calling process  is  blocked  until  the
              operation has been performed.

              See also <u>erlang:send_after/4</u>, <u>erlang:start_timer/4</u>, and <u>erlang:cancel_timer/2</u>.

       <b>ref_to_list(Ref)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Ref = reference()

              Returns a string corresponding to the text representation of <u>Ref</u>.

          <b>Warning:</b>
              This BIF is intended for debugging and is not to be used in application programs.

       <b>register(RegName,</b> <b>PidOrPort)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 RegName = atom()
                 PidOrPort = port() | pid()

              Registers  the  name  <u>RegName</u>  with  a  process  identifier (pid) or a port identifier in the <u>name</u>
              <u>registry</u>. <u>RegName</u>, which must be an atom, can be used instead of the pid  or  port  identifier  in
              send  operator  (<u>RegName</u>  <u>!</u>  <u>Message</u>) and most other BIFs that take a pid or port identifies as an
              argument. Example:

              &gt; register(db, Pid).
              true

              The registered name is considered  a   Directly  Visible  Erlang  Resource  and  is  automatically
              unregistered when the process terminates.

              Failures:

                <u>badarg</u>:
                  If <u>PidOrPort</u> is not an existing local process or port.

                <u>badarg</u>:
                  If <u>RegName</u> is already in use.

                <u>badarg</u>:
                  If the process or port is already registered (already has a name).

                <u>badarg</u>:
                  If <u>RegName</u> is the atom <u>undefined</u>.

       <b>registered()</b> <b>-&gt;</b> <b>[RegName]</b>

              Types:

                 RegName = atom()

              Returns a list of names that have been registered using <u>register/2</u>, for example:

              &gt; registered().
              [code_server, file_server, init, user, my_db]

       <b>erlang:resume_process(Suspendee)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Suspendee = pid()

              Decreases  the  suspend  count  on the process identified by <u>Suspendee</u>. <u>Suspendee</u> is previously to
              have been suspended through <u>erlang:suspend_process/2</u> or <u>erlang:suspend_process/1</u>  by  the  process
              calling  <u>erlang:resume_process(Suspendee)</u>.  When  the  suspend  count  on  <u>Suspendee</u> reaches zero,
              <u>Suspendee</u> is resumed, that is, its state is changed from suspended into the state it had before it
              was suspended.

          <b>Warning:</b>
              This BIF is intended for debugging only.

              Failures:

                <u>badarg</u>:
                   If <u>Suspendee</u> is not a process identifier.

                <u>badarg</u>:
                   If the process calling <u>erlang:resume_process/1</u> had not previously increased the suspend count
                  on the process identified by <u>Suspendee</u>.

                <u>badarg</u>:
                   If the process identified by <u>Suspendee</u> is not alive.

       <b>round(Number)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 Number = number()

              Returns an integer by rounding <u>Number</u>, for example:

              round(42.1).
              42

              round(5.5).
              6

              round(-5.5).
              -6

              round(36028797018963969.0).
              36028797018963968

              In the last example, <u>round(36028797018963969.0)</u> evaluates to  <u>36028797018963968</u>.  The  reason  for
              this  is  that  the  number  <u>36028797018963969.0</u>  cannot  be represented exactly as a float value.
              Instead, the float literal is represented as <u>36028797018963968.0</u>, which is the closest number that
              can be represented exactly as a float value. See Representation  of  Floating  Point  Numbers  for
              additional information.

              Allowed in guard tests.

       <b>self()</b> <b>-&gt;</b> <b>pid()</b>

              Returns the process identifier of the calling process, for example:

              &gt; self().
              &lt;0.26.0&gt;

              Allowed in guard tests.

       <b>erlang:send(Dest,</b> <b>Msg)</b> <b>-&gt;</b> <b>Msg</b>

              Types:

                 Dest = dst()
                 Msg = term()
                 <b>dst()</b> =
                     pid() |
                     reference() |
                     port() |
                     (RegName :: atom()) |
                     {RegName :: atom(), Node :: node()}

              Sends a message and returns <u>Msg</u>. This is the same as using the  send operator: <u>Dest</u> <u>!</u> <u>Msg</u>.

              <u>Dest</u>  can  be a remote or local process identifier, an alias, a (local) port, a locally registered
              name, or a tuple <u>{RegName,</u> <u>Node}</u> for a registered name at another node.

              The function fails with a <u>badarg</u> run-time error if <u>Dest</u> is an atom name,  but  this  name  is  not
              registered.  This is the only case when <u>send</u> fails for an unreachable destination <u>Dest</u> (of correct
              type).

       <b>erlang:send(Dest,</b> <b>Msg,</b> <b>Options)</b> <b>-&gt;</b> <b>Res</b>

              Types:

                 Dest = dst()
                 Msg = term()
                 Options = [nosuspend | noconnect]
                 Res = ok | nosuspend | noconnect
                 <b>dst()</b> =
                     pid() |
                     reference() |
                     port() |
                     (RegName :: atom()) |
                     {RegName :: atom(), Node :: node()}

              Either sends a message and returns <u>ok</u>, or does not send the message  but  returns  something  else
              (see  below). Otherwise the same as <u>erlang:send/2</u>. For more detailed explanation and warnings, see
              <u>erlang:send_nosuspend/2,3</u>.

              Options:

                <u>nosuspend</u>:
                  If the sender would have to be suspended to do the send, <u>nosuspend</u> is returned instead.

                <u>noconnect</u>:
                   If the destination node would have to be auto-connected to do the send, <u>noconnect</u> is returned
                  instead.

          <b>Warning:</b>
              As with <u>erlang:send_nosuspend/2,3</u>: use with extreme care.

       <b>erlang:send_after(Time,</b> <b>Dest,</b> <b>Msg)</b> <b>-&gt;</b> <b>TimerRef</b>

              Types:

                 Time = integer() &gt;= 0
                 Dest = pid() | atom()
                 Msg = term()
                 TimerRef = reference()

              Starts a timer. The same as calling <u>erlang:send_after(Time,</u> <u>Dest,</u> <u>Msg,</u> <u>[])</u>.

       <b>erlang:send_after(Time,</b> <b>Dest,</b> <b>Msg,</b> <b>Options)</b> <b>-&gt;</b> <b>TimerRef</b>

              Types:

                 Time = integer()
                 Dest = pid() | atom()
                 Msg = term()
                 Options = [Option]
                 Abs = boolean()
                 Option = {abs, Abs}
                 TimerRef = reference()

              Starts a timer. When the timer expires, the message <u>Msg</u> is sent to the process identified by <u>Dest</u>.
              Apart  from  the  format   of   the   time-out   message,   this   function   works   exactly   as
              <u>erlang:start_timer/4</u>.

       <b>erlang:send_nosuspend(Dest,</b> <b>Msg)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Dest = dst()
                 Msg = term()
                 <b>dst()</b> =
                     pid() |
                     reference() |
                     port() |
                     (RegName :: atom()) |
                     {RegName :: atom(), Node :: node()}

              The  same  as  <u>erlang:send(Dest,</u>  <u>Msg,</u>  <u>[nosuspend])</u>, but returns <u>true</u> if the message was sent and
              <u>false</u> if the message was not sent because the sender would have had to be suspended.

              This function is intended for send operations to an unreliable remote node without  ever  blocking
              the  sending  (Erlang)  process.  If  the connection to the remote node (usually not a real Erlang
              node, but a node written in C or Java) is overloaded, this function <u>does</u> <u>not</u> <u>send</u> <u>the</u> <u>message</u>  and
              returns <u>false</u>.

              The  same  occurs if <u>Dest</u> refers to a local port that is busy. For all other destinations (allowed
              for the ordinary send operator <u>'!'</u>), this function sends the message and returns <u>true</u>.

              This function is only to be used in rare circumstances where a process  communicates  with  Erlang
              nodes  that  can  disappear without any trace, causing the TCP buffers and the drivers queue to be
              over-full before the node is shut down (because of  tick  time-outs)  by  <u>net_kernel</u>.  The  normal
              reaction to take when this occurs is some kind of premature shutdown of the other node.

              Notice  that  ignoring  the  return value from this function would result in an <u>unreliable</u> message
              passing, which is contradictory to the Erlang programming model. The message is <u>not</u> sent  if  this
              function returns <u>false</u>.

              In  many systems, transient states of overloaded queues are normal. Although this function returns
              <u>false</u> does not mean that the other node  is  guaranteed  to  be  non-responsive,  it  could  be  a
              temporary  overload.  Also,  a return value of <u>true</u> does only mean that the message can be sent on
              the (TCP) channel without blocking; the message is not guaranteed to arrive at  the  remote  node.
              For  a disconnected non-responsive node, the return value is <u>true</u> (mimics the behavior of operator
              <u>!</u>). The expected behavior and the actions to take when the function returns <u>false</u> are application-
              and hardware-specific.

          <b>Warning:</b>
              Use with extreme care.

       <b>erlang:send_nosuspend(Dest,</b> <b>Msg,</b> <b>Options)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Dest = dst()
                 Msg = term()
                 Options = [noconnect]
                 <b>dst()</b> =
                     pid() |
                     reference() |
                     port() |
                     (RegName :: atom()) |
                     {RegName :: atom(), Node :: node()}

              The same as <u>erlang:send(Dest,</u> <u>Msg,</u> <u>[nosuspend</u> <u>|</u> <u>Options])</u>, but with a Boolean return value.

              This function behaves like <u>erlang:send_nosuspend/2</u>,  but  takes  a  third  parameter,  a  list  of
              options. The only option is <u>noconnect</u>, which makes the function return <u>false</u> if the remote node is
              not  currently  reachable by the local node. The normal behavior is to try to connect to the node,
              which can stall the process during a short period. The use of option <u>noconnect</u> makes  it  possible
              to  be  sure  not  to get the slightest delay when sending to a remote process. This is especially
              useful when communicating with nodes that expect to always be the connecting part (that is,  nodes
              written in C or Java).

              Whenever  the  function  returns  <u>false</u>  (either  when a suspend would occur or when <u>noconnect</u> was
              specified and the node was not already connected), the message is  guaranteed  <u>not</u>  to  have  been
              sent.

          <b>Warning:</b>
              Use with extreme care.

       <b>erlang:set_cookie(Cookie)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Cookie = atom()

              Sets the magic cookie of the local node to the atom <u>Cookie</u>, which is also the cookie for all nodes
              that  have no explicit cookie set with <u>set_cookie/2</u> <u>Cookie</u> (see section  Distributed Erlang in the
              Erlang Reference Manual in System Documentation).

              Failure: <u>function_clause</u> if the local node is not alive.

       <b>erlang:set_cookie(Node,</b> <b>Cookie)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Node = node()
                 Cookie = atom()

              Sets the magic cookie for <u>Node</u> to the atom <u>Cookie</u>. If <u>Node</u> is the local node,  the  function  sets
              the cookie of all other nodes (that have no explicit cookie set with this function) to <u>Cookie</u> (see
              section  Distributed Erlang in the Erlang Reference Manual in System Documentation).

              Failure: <u>function_clause</u> if the local node is not alive.

       <b>setelement(Index,</b> <b>Tuple1,</b> <b>Value)</b> <b>-&gt;</b> <b>Tuple2</b>

              Types:

                 Index = integer() &gt;= 1
                   1..tuple_size(Tuple1
                 Tuple1 = Tuple2 = tuple()
                 Value = term()

              Returns  a  tuple that is a copy of argument <u>Tuple1</u> with the element specified by integer argument
              <u>Index</u> (the first element is the element with index 1) replaced by argument <u>Value</u>, for example:

              &gt; setelement(2, {10, green, bottles}, red).
              {10,red,bottles}

       <b>size(Item)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Item = tuple() | binary()

              Returns the number of elements in a tuple or the number of bytes in a  binary  or  bitstring,  for
              example:

              &gt; size({morni, mulle, bwange}).
              3
              &gt; size(&lt;&lt;11, 22, 33&gt;&gt;).
              3

              For  bitstrings,  the  number  of  whole  bytes is returned. That is, if the number of bits in the
              bitstring is not divisible by 8, the resulting number of bytes is rounded <u>down</u>.

              Allowed in guard tests.

              See also <u>tuple_size/1</u>, <u>byte_size/1</u>, and <u>bit_size/1</u>.

       <b>spawn(Fun)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Fun = function()

              Returns the process identifier of a new process started by the application of  <u>Fun</u>  to  the  empty
              list <u>[]</u>. Otherwise works like <u>spawn/3</u>.

       <b>spawn(Node,</b> <b>Fun)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Node = node()
                 Fun = function()

              Returns  the  process  identifier  of a new process started by the application of <u>Fun</u> to the empty
              list <u>[]</u> on <u>Node</u>. If <u>Node</u> does not exist, a useless pid is returned. Otherwise works like <u>spawn/3</u>.

       <b>spawn(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]

              Returns the process identifier of a new process started by the application of  <u>Module:Function</u>  to
              <u>Args</u>.

              <u>error_handler:undefined_function(Module,</u>  <u>Function,</u>  <u>Args)</u>  is  evaluated  by  the  new process if
              <u>Module:Function/Arity</u> does not exist (where <u>Arity</u> is the length of <u>Args</u>). The error handler can be
              redefined (see <u>process_flag/2</u>). If <u>error_handler</u> is undefined,  or  the  user  has  redefined  the
              default <u>error_handler</u> and its replacement is undefined, a failure with reason <u>undef</u> occurs.

              Example:

              &gt; spawn(speed, regulator, [high_speed, thin_cut]).
              &lt;0.13.1&gt;

       <b>spawn(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]

              Returns   the   process  identifier  (pid)  of  a  new  process  started  by  the  application  of
              <u>Module:Function</u> to <u>Args</u> on <u>Node</u>. If <u>Node</u> does not exist, a  useless  pid  is  returned.  Otherwise
              works like <u>spawn/3</u>.

       <b>spawn_link(Fun)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Fun = function()

              Returns  the  process  identifier  of a new process started by the application of <u>Fun</u> to the empty
              list <u>[]</u>. A link is created between the calling process and the new process, atomically.  Otherwise
              works like <u>spawn/3</u>.

       <b>spawn_link(Node,</b> <b>Fun)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Node = node()
                 Fun = function()

              Returns  the  process  identifier  (pid) of a new process started by the application of <u>Fun</u> to the
              empty list <u>[]</u> on <u>Node</u>. A link is  created  between  the  calling  process  and  the  new  process,
              atomically.  If  <u>Node</u>  does  not  exist,  a useless pid is returned and an exit signal with reason
              <u>noconnection</u> is sent to the calling process. Otherwise works like <u>spawn/3</u>.

       <b>spawn_link(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]

              Returns the process identifier of a new process started by the application of  <u>Module:Function</u>  to
              <u>Args</u>.  A  link  is  created between the calling process and the new process, atomically. Otherwise
              works like <u>spawn/3</u>.

       <b>spawn_link(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]

              Returns  the  process  identifier  (pid)  of  a  new  process  started  by  the   application   of
              <u>Module:Function</u>  to  <u>Args</u>  on  <u>Node</u>.  A  link  is  created between the calling process and the new
              process, atomically. If <u>Node</u> does not exist, a useless pid is returned and  an  exit  signal  with
              reason <u>noconnection</u> is sent to the calling process. Otherwise works like <u>spawn/3</u>.

       <b>spawn_monitor(Fun)</b> <b>-&gt;</b> <b>{pid(),</b> <b>reference()}</b>

              Types:

                 Fun = function()

              Returns  the  process  identifier of a new process, started by the application of <u>Fun</u> to the empty
              list <u>[]</u>, and a reference for a monitor created to the new process. Otherwise works like <u>spawn/3</u>.

       <b>spawn_monitor(Node,</b> <b>Fun)</b> <b>-&gt;</b> <b>{pid(),</b> <b>reference()}</b>

              Types:

                 Node = node()
                 Fun = function()

              Returns the process identifier of a new process, started by the application of <u>Fun</u>  to  the  empty
              list  <u>[]</u>  on  the  node  <u>Node</u>, and a reference for a monitor created to the new process. Otherwise
              works like <u>spawn/3</u>.

              If the node identified by <u>Node</u> does not support distributed <u>spawn_monitor()</u>, the  call  will  fail
              with a <u>notsup</u> exception.

       <b>spawn_monitor(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>{pid(),</b> <b>reference()}</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]

              A  new  process is started by the application of <u>Module:Function</u> to <u>Args</u>. The process is monitored
              at the same time. Returns the process identifier and a reference for the monitor. Otherwise  works
              like <u>spawn/3</u>.

       <b>spawn_monitor(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b>
                        {pid(), reference()}

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]

              A  new  process  is  started  by  the application of <u>Module:Function</u> to <u>Args</u> on the node <u>Node</u>. The
              process is monitored at the same time. Returns the process identifier  and  a  reference  for  the
              monitor. Otherwise works like <u>spawn/3</u>.

              If  the  node  identified by <u>Node</u> does not support distributed <u>spawn_monitor()</u>, the call will fail
              with a <u>notsup</u> exception.

       <b>spawn_opt(Fun,</b> <b>Options)</b> <b>-&gt;</b> <b>pid()</b> <b>|</b> <b>{pid(),</b> <b>reference()}</b>

              Types:

                 Fun = function()
                 Options = [spawn_opt_option()]
                 <b>priority_level()</b> = low | normal | high | max
                 <b>max_heap_size()</b> =
                     integer() &gt;= 0 |
                     #{size =&gt; integer() &gt;= 0,
                       kill =&gt; boolean(),
                       error_logger =&gt; boolean()}
                 <b>message_queue_data()</b> = off_heap | on_heap
                 <b>spawn_opt_option()</b> =
                     link | monitor |
                     {monitor, MonitorOpts :: [monitor_option()]} |
                     {priority, Level :: priority_level()} |
                     {fullsweep_after, Number :: integer() &gt;= 0} |
                     {min_heap_size, Size :: integer() &gt;= 0} |
                     {min_bin_vheap_size, VSize :: integer() &gt;= 0} |
                     {max_heap_size, Size :: max_heap_size()} |
                     {message_queue_data, MQD :: message_queue_data()}

              Returns the process identifier (pid) of a new process started by the application  of  <u>Fun</u>  to  the
              empty list <u>[]</u>. Otherwise works like <u>spawn_opt/4</u>.

              If  option  <u>monitor</u>  is  specified,  the  newly created process is monitored, and both the pid and
              reference for the monitor are returned.

       <b>spawn_opt(Node,</b> <b>Fun,</b> <b>Options)</b> <b>-&gt;</b> <b>pid()</b> <b>|</b> <b>{pid(),</b> <b>reference()}</b>

              Types:

                 Node = node()
                 Fun = function()
                 Options =
                     [monitor | {monitor, [monitor_option()]} | link | OtherOption]
                 OtherOption = term()

              Returns the process identifier (pid) of a new process started by the application  of  <u>Fun</u>  to  the
              empty  list  <u>[]</u>  on  <u>Node</u>. If <u>Node</u> does not exist, a useless pid is returned. Otherwise works like
              <u>spawn_opt/4</u>.

              Valid options depends on what options are supported by the node identified by <u>Node</u>. A  description
              of  valid  <u>Option</u>s  for the local node of current OTP version can be found in the documentation of
              <u>spawn_opt/4</u>.

       <b>spawn_opt(Module,</b> <b>Function,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b>
                    Pid | {Pid, MonitorRef}

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Options = [spawn_opt_option()]
                 Pid = pid()
                 MonitorRef = reference()
                 <b>priority_level()</b> = low | normal | high | max
                 <b>max_heap_size()</b> =
                     integer() &gt;= 0 |
                     #{size =&gt; integer() &gt;= 0,
                       kill =&gt; boolean(),
                       error_logger =&gt; boolean()}
                 <b>message_queue_data()</b> = off_heap | on_heap
                 <b>spawn_opt_option()</b> =
                     link | monitor |
                     {monitor, MonitorOpts :: [monitor_option()]} |
                     {priority, Level :: priority_level()} |
                     {fullsweep_after, Number :: integer() &gt;= 0} |
                     {min_heap_size, Size :: integer() &gt;= 0} |
                     {min_bin_vheap_size, VSize :: integer() &gt;= 0} |
                     {max_heap_size, Size :: max_heap_size()} |
                     {message_queue_data, MQD :: message_queue_data()}

              Works as <u>spawn/3</u>, except that an extra option list is specified when creating the process.

              If option <u>monitor</u> is specified, the newly created process is  monitored,  and  both  the  pid  and
              reference for the monitor are returned.

              Options:

                <u>link</u>:
                  Sets a link to the parent process (like <u>spawn_link/3</u> does).

                <u>monitor</u>:
                  Monitors  the new process (like <u>monitor(process,</u> <u>Pid)</u> does). A <u>{Pid,</u> <u>MonitorRef}</u> tuple will be
                  returned instead of just a <u>Pid</u>.

                <u>{monitor,</u> <u>MonitorOpts}</u>:
                  Monitors the new process with options (like <u>monitor(process,</u> <u>Pid,</u> <u>MonitorOpts)</u> does). A  <u>{Pid,</u>
                  <u>MonitorRef}</u> tuple will be returned instead of just a <u>Pid</u>.

                <u>{priority,</u> <u>Level}</u>:
                  Sets the priority of the new process. Equivalent to executing <u>process_flag(priority,</u> <u>Level)</u> in
                  the  start  function of the new process, except that the priority is set before the process is
                  selected  for  execution  for  the  first  time.  For  more  information  on  priorities,  see
                  <u>process_flag(priority,</u> <u>Level)</u>.

                <u>{fullsweep_after,</u> <u>Number}</u>:
                  Useful  only  for  performance  tuning.  Do  not use this option unless you know that there is
                  problem with execution times or memory  consumption,  and  ensure  that  the  option  improves
                  matters.

                  The  Erlang  runtime system uses a generational garbage collection scheme, using an "old heap"
                  for data that has survived at least one garbage collection. When there is no more room on  the
                  old heap, a fullsweep garbage collection is done.

                  Option  <u>fullsweep_after</u>  makes  it  possible  to  specify  the  maximum number of generational
                  collections before forcing a fullsweep, even if there is room on the  old  heap.  Setting  the
                  number  to zero disables the general collection algorithm, that is, all live data is copied at
                  every garbage collection.

                  A few cases when it can be useful to change <u>fullsweep_after</u>:

                  * If binaries that are no longer used are to be thrown away as soon as possible.  (Set  <u>Number</u>
                    to zero.)

                  * A process that mostly have short-lived data is fullsweeped seldom or never, that is, the old
                    heap  contains  mostly garbage. To ensure a fullsweep occasionally, set <u>Number</u> to a suitable
                    value, such as 10 or 20.

                  * In embedded systems with a limited amount of RAM and no virtual memory, you  might  want  to
                    preserve   memory  by  setting  <u>Number</u>  to  zero.  (The  value  can  be  set  globally,  see
                    <u>erlang:system_flag/2</u>.)

                <u>{min_heap_size,</u> <u>Size}</u>:
                  Useful only for performance tuning. Do not use this option  unless  you  know  that  there  is
                  problem  with  execution  times  or  memory  consumption,  and ensure that the option improves
                  matters.

                  Gives a minimum heap size, in words. Setting this value higher than  the  system  default  can
                  speed  up  some processes because less garbage collection is done. However, setting a too high
                  value can waste memory and slow down the system because of worse data locality. Therefore, use
                  this option only for fine-tuning an application and to measure the execution time with various
                  <u>Size</u> values.

                <u>{min_bin_vheap_size,</u> <u>VSize}</u>:
                  Useful only for performance tuning. Do not use this option  unless  you  know  that  there  is
                  problem  with  execution  times  or  memory  consumption,  and ensure that the option improves
                  matters.

                  Gives a minimum binary virtual heap size, in words. Setting this value higher than the  system
                  default  can speed up some processes because less garbage collection is done. However, setting
                  a too high value can waste  memory.  Therefore,  use  this  option  only  for  fine-tuning  an
                  application and to measure the execution time with various <u>VSize</u> values.

                <u>{max_heap_size,</u> <u>Size}</u>:
                  Sets  the  <u>max_heap_size</u> process flag. The default <u>max_heap_size</u> is determined by command-line
                  argument   <u>+hmax</u>   in   <u><a href="../man1/erl.1.html">erl</a>(1)</u>.   For   more   information,   see   the    documentation    of
                  <u>process_flag(max_heap_size,</u> <u>Size)</u>.

                <u>{message_queue_data,</u> <u>MQD}</u>:
                  Sets  the value of the <u>message_queue_data</u> process flag. <u>MQD</u> can be either <u>off_heap</u> or <u>on_heap</u>.
                  The default value of the <u>message_queue_data</u> process flag is  determined  by  the  command-line
                  argument    <u>+hmqd</u>    in   <u><a href="../man1/erl.1.html">erl</a>(1)</u>.   For   more   information,   see   the   documentation   of
                  <u>process_flag(message_queue_data,</u> <u>MQD)</u>.

       <b>spawn_opt(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b>
                    pid() | {pid(), reference()}

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Options =
                     [monitor | {monitor, [monitor_option()]} | link | OtherOption]
                 OtherOption = term()

              Returns  the  process  identifier  (pid)  of  a  new  process  started  by  the   application   of
              <u>Module:Function</u>  to  <u>Args</u>  on  <u>Node</u>.  If <u>Node</u> does not exist, a useless pid is returned. Otherwise
              works like <u>spawn_opt/4</u>.

              Valid options depends on what options are supported by the node identified by <u>Node</u>. A  description
              of  valid  <u>Option</u>s  for the local node of current OTP version can be found in the documentation of
              <u>spawn_opt/4</u>.

       <b>spawn_request(Fun)</b> <b>-&gt;</b> <b>ReqId</b>

              Types:

                 Fun = function()
                 ReqId = reference()

              The same as the call <u>spawn_request(node(),Fun,[])</u>. That is, a spawn request on the local node with
              no options.

       <b>spawn_request(Fun,</b> <b>Options)</b> <b>-&gt;</b> <b>ReqId</b>

              Types:

                 Fun = function()
                 Option =
                     {reply_tag, ReplyTag} | {reply, Reply} | spawn_opt_option()
                 ReplyTag = term()
                 Reply = yes | no | error_only | success_only
                 Options = [Option]
                 ReqId = reference()

              The same as the call <u>spawn_request(node(),Fun,Options)</u>. That is, a  spawn  request  on  the  local
              node.

       <b>spawn_request(Node,</b> <b>Fun)</b> <b>-&gt;</b> <b>ReqId</b>

              Types:

                 Node = node()
                 Fun = function()
                 ReqId = reference()

              The same as the call <u>spawn_request(Node,Fun,[])</u>. That is, a spawn request with no options.

       <b>spawn_request(Node,</b> <b>Fun,</b> <b>Options)</b> <b>-&gt;</b> <b>ReqId</b>

              Types:

                 Node = node()
                 Fun = function()
                 Options = [Option]
                 Option =
                     monitor |
                     {monitor, [monitor_option()]} |
                     link |
                     {reply_tag, ReplyTag} |
                     {reply, Reply} |
                     OtherOption
                 ReplyTag = term()
                 Reply = yes | no | error_only | success_only
                 OtherOption = term()
                 ReqId = reference()

              The  same as <u>spawn_request(Node,erlang,apply,[Fun,[]],Options)</u>. That is, a spawn request using the
              fun <u>Fun</u> of arity zero as entry point.

              This function will fail with a <u>badarg</u> exception if:

                * <u>Node</u> is not an atom.

                * <u>Fun</u> is not a fun of arity zero.

                * <u>Options</u> is not a proper list of terms.

       <b>spawn_request(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>ReqId</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]
                 ReqId = reference()

              The same as the call <u>spawn_request(node(),Module,Function,Args,[])</u>. That is, a  spawn  request  on
              the local node with no options.

       <b>spawn_request(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>ReqId</b>

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 ReqId = reference()

              The same as the call <u>spawn_request(Node,Module,Function,Args,[])</u>. That is, a spawn request with no
              options.

       <b>spawn_request(Module,</b> <b>Function,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>ReqId</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Option =
                     {reply_tag, ReplyTag} | {reply, Reply} | spawn_opt_option()
                 ReplyTag = term()
                 Reply = yes | no | error_only | success_only
                 Options = [Option]
                 ReqId = reference()

              The  same as the call <u>spawn_request(node(),Module,Function,Args,Options)</u>. That is, a spawn request
              on the local node.

       <b>spawn_request(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>ReqId</b>

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Options = [Option]
                 Option =
                     monitor |
                     {monitor, [monitor_option()]} |
                     link |
                     {reply_tag, ReplyTag} |
                     {reply, Reply} |
                     OtherOption
                 ReplyTag = term()
                 Reply = yes | no | error_only | success_only
                 OtherOption = term()
                 ReqId = reference()

              Asynchronously send a spawn request. Returns a request identifier <u>ReqId</u>.

              If the spawn operation succeeds, a new process is created on the node identified by <u>Node</u>.  When  a
              spawn  operation  succeeds,  the  caller  will by default be sent a message on the form <u>{ReplyTag,</u>
              <u>ReqId,</u> <u>ok,</u> <u>Pid}</u> where <u>Pid</u> is the process identifier of the newly created process. Such  a  message
              is  referred  to  as  a  <u>success</u>  <u>message</u>   below  in  the  text.  <u>ReplyTag</u> is by default the atom
              <u>spawn_reply</u> unless modified by the <u>{reply_tag,</u> <u>ReplyTag}</u> option. The new process is started by the
              application of <u>Module:Function</u> to <u>Args</u>.

              The spawn operation fails either if creation of a new process failed or if the spawn operation was
              interrupted by a connection failure. When a spawn operation fails, the caller will by  default  be
              sent a message on the form <u>{ReplyTag,</u> <u>ReqId,</u> <u>error,</u> <u>Reason}</u> where <u>Reason</u> is the error reason. Such
              a  message  is  referred  to as an <u>error</u> <u>message</u>  below in the text. Currently the following spawn
              error <u>Reason</u>s are defined, but other reasons can appear at any time without prior notice:

                <u>badopt</u>:
                  An invalid <u>Option</u> was passed as argument. Note that  different  runtime  systems  may  support
                  different options.

                <u>notsup</u>:
                  The node identified by <u>Node</u> does not support spawn operations issued by <u>spawn_request()</u>.

                <u>noconnection</u>:
                  Failure  to  set up a connection to the node identified by <u>Node</u> or the connection to that node
                  was lost during the spawn operation. In the case the connection was lost, a process may or may
                  not have been created.

                <u>system_limit</u>:
                  Could not create a new process due to that  some  system  limit  was  reached.  Typically  the
                  process table was full.

              Valid <u>Option</u>s:

                <u>monitor</u>:
                  In  the absence of spawn operation failures, atomically sets up a monitor to the newly created
                  process. That is, as if the calling process had called <u>monitor(process,</u> <u>Pid)</u> where <u>Pid</u> is  the
                  process identifier of the newly created process. The <u>ReqId</u> returned by <u>spawn_request()</u> is also
                  used as monitor reference as if it was returned from <u>monitor(process,</u> <u>Pid)</u>.

                  The  monitor  will  not  be  activated  for  the calling process until the spawn operation has
                  succeeded. The monitor can not be demonitored before the operation  has  succeeded.  A  <u>'DOWN'</u>
                  message  for  the  corresponding  monitor  is  guaranteed not to be delivered before a <u>success</u>
                  <u>message</u>  that corresponds to the spawn operation. If the  spawn  operation  fails,  no  <u>'DOWN'</u>
                  message will be delivered.

                  If  the  connection between the nodes involved in the spawn operation is lost during the spawn
                  operation, the spawn operation will fail with an error reason of <u>noconnection</u>. A  new  process
                  may or may not have been created.

                <u>{monitor,</u> <u>MonitorOpts}</u>:
                  In  the absence of spawn operation failures, atomically sets up a monitor to the newly created
                  process. That is, as if the calling process  had  called  <u>monitor(process,</u>  <u>Pid,</u>  <u>MonitorOpts)</u>
                  where <u>Pid</u> is the process identifier of the newly created process. See the <u>monitor</u> option above
                  for more information.

                  Note  that the monitor will not be activated for the calling process until the spawn operation
                  has succeeded. For example, in the case that an alias is created using the monitor option, the
                  alias will not be active until the monitor is activated.

                <u>link</u>:
                  In absence of spawn operation failures, atomically sets up a link between the calling  process
                  and  the  newly created process. That is, as if the calling process had called <u>link(Pid)</u> where
                  <u>Pid</u> is the process identifier of the newly created process.

                  The link will not be  activated  for  the  calling  process  until  the  spawn  operation  has
                  succeeded.  The link can not be removed before the operation has succeeded. An exit signal due
                  to the link is guaranteed not to be delivered before a <u>success</u> <u>message</u>   that  corresponds  to
                  the  spawn  operation.  If  the  spawn operation fails, no exit signal due to the link will be
                  delivered to the caller of <u>spawn_request()</u>.

                  If the connection between the nodes involved in the spawn operation is lost during  the  spawn
                  operation,  the  spawn operation will fail with an error reason of <u>noconnection</u>. A new process
                  may or may not have been created. If it has been created, it will be delivered an exit  signal
                  with an exit reason of <u>noconnection</u>.

                <u>{reply,</u> <u>Reply}</u>:
                  Valid <u>Reply</u> values:

                  <u>yes</u>:
                    A  spawn  reply  message  will  be  sent  to  the caller regardless of whether the operation
                    succeeds or not. If the call to <u>spawn_request()</u> returns without raising an exception and the
                    <u>reply</u> option is set to <u>yes</u>, the caller is  guaranteed  to  be  delivered  either  a  <u>success</u>
                    <u>message</u>  or an <u>error</u> <u>message</u> . The <u>reply</u> option is by default set to <u>yes</u>.

                  <u>no</u>:
                    No  spawn  reply message will be sent to the caller when the spawn operation completes. This
                    regardless of whether the operation succeeds or not.

                  <u>error_only</u>:
                    No spawn reply message will be sent to the caller if the spawn operation  succeeds,  but  an
                    <u>error</u> <u>message</u>  will be sent to the caller if the operation fails.

                  <u>success_only</u>:
                    No  spawn  reply  message  will  be  sent  to the caller if the spawn operation fails, but a
                    <u>success</u> <u>message</u>  will be sent to the caller if the operation succeeds.

                <u>{reply_tag,</u> <u>ReplyTag}</u>:
                  Sets the reply tag to <u>ReplyTag</u> in the reply  message.  That  is,  in  the  <u>success</u>   or  <u>error</u>
                  message  that  is  sent to the caller due to the spawn operation. The default reply tag is the
                  atom <u>spawn_reply</u>.

                <u>OtherOption</u>:
                  Other valid options depends on what options are supported by the node identified  by  <u>Node</u>.  A
                  description  of  other valid <u>Option</u>s for the local node of current OTP version can be found in
                  the documentation of <u>spawn_opt/4</u>.

              This function will fail with a <u>badarg</u> exception if:

                * <u>Node</u> is not an atom.

                * <u>Module</u> is not an atom.

                * <u>Function</u> is not an atom.

                * <u>Args</u> is not a proper list of terms.

                * <u>Options</u> is not a proper list of terms.

              Note that not all individual <u>Option</u>s are checked when the spawn request is sent. Some <u>Option</u>s  can
              only  be  checked on reception of the request. Therefore an invalid option does <u>not</u> cause a <u>badarg</u>
              exception, but will cause the spawn operation to fail with an error reason of <u>badopt</u>.

              A spawn request can be abandoned by calling <u>spawn_request_abandon/1</u>.

       <b>spawn_request_abandon(ReqId</b> <b>::</b> <b>reference())</b> <b>-&gt;</b> <b>boolean()</b>

              Abandon a previously issued spawn request. <u>ReqId</u> corresponds to a  request  identifier  previously
              returned  by  <u>spawn_request()</u>  in  a call from current process. That is, only the process that has
              made the request can abandon the request.

              A spawn request can only be successfully abandoned until the spawn request has completed.  When  a
              spawn  request  has  been successfully abandoned, the caller will not be effected by future direct
              effects of the spawn request itself. For example, it will not receive a spawn reply  message.  The
              request  is  however not withdrawn, so a new process may or may not be created due to the request.
              If a new process is created after the spawn request was abandoned, no monitors nor links  will  be
              set  up  to  the  caller of <u>spawn_request_abandon/1</u> due to the spawn request. If the spawn request
              included the <u>link</u> option, the process created due to this request will be sent an exit signal from
              its parent with the exit reason <u>abandoned</u> when  it  is  detected  that  the  spawn  operation  has
              succeeded.

          <b>Note:</b>
              A  process  created due to a spawn request that has been abandoned may communicate with its parent
              as any other process. It is <u>only</u> the direct effects on the parent of  the  actual  spawn  request,
              that will be canceled by abandoning a spawn request.

              Return values:

                <u>true</u>:
                  The spawn request was successfully abandoned.

                <u>false</u>:
                  No  spawn  request  was  abandoned.  The  <u>ReqId</u>  request  identifier  did not correspond to an
                  outstanding spawn request issued by the calling process. The reason for this is either:

                  * <u>ReqId</u> corresponds to a spawn request previoulsy made  by  the  calling  process.  The  spawn
                    operation  has completed and a spawn reply has already been delivered to the calling process
                    unless the spawn reply was disabled in the request.

                  * <u>ReqId</u> does not correspond to a spawn request that has been made by the calling process.

              This function fail with a <u>badarg</u> exception if <u>ReqId</u> is not a reference.

       <b>split_binary(Bin,</b> <b>Pos)</b> <b>-&gt;</b> <b>{binary(),</b> <b>binary()}</b>

              Types:

                 Bin = binary()
                 Pos = integer() &gt;= 0
                   0..byte_size(Bin)

              Returns a tuple containing the binaries that are the result of splitting <u>Bin</u>  into  two  parts  at
              position  <u>Pos</u>.  This is not a destructive operation. After the operation, there are three binaries
              altogether. Example:

              &gt; B = list_to_binary("0123456789").
              &lt;&lt;"0123456789"&gt;&gt;
              &gt; byte_size(B).
              10
              &gt; {B1, B2} = split_binary(B,3).
              {&lt;&lt;"012"&gt;&gt;,&lt;&lt;"3456789"&gt;&gt;}
              &gt; byte_size(B1).
              3
              &gt; byte_size(B2).
              7

       <b>erlang:start_timer(Time,</b> <b>Dest,</b> <b>Msg)</b> <b>-&gt;</b> <b>TimerRef</b>

              Types:

                 Time = integer() &gt;= 0
                 Dest = pid() | atom()
                 Msg = term()
                 TimerRef = reference()

              Starts a timer. The same as calling <u>erlang:start_timer(Time,</u> <u>Dest,</u> <u>Msg,</u> <u>[])</u>.

       <b>erlang:start_timer(Time,</b> <b>Dest,</b> <b>Msg,</b> <b>Options)</b> <b>-&gt;</b> <b>TimerRef</b>

              Types:

                 Time = integer()
                 Dest = pid() | atom()
                 Msg = term()
                 Options = [Option]
                 Abs = boolean()
                 Option = {abs, Abs}
                 TimerRef = reference()

              Starts a timer. When the timer expires, the message  <u>{timeout,</u>  <u>TimerRef,</u>  <u>Msg}</u>  is  sent  to  the
              process identified by <u>Dest</u>.

              <u>Option</u>s:

                <u>{abs,</u> <u>false}</u>:
                  This is the default. It means the <u>Time</u> value is interpreted as a time in milliseconds <u>relative</u>
                  current Erlang monotonic time.

                <u>{abs,</u> <u>true}</u>:
                  Absolute  <u>Time</u>  value.  The  <u>Time</u> value is interpreted as an absolute Erlang monotonic time in
                  milliseconds.

              More <u>Option</u>s can be added in the future.

              The absolute point in  time,  the  timer  is  set  to  expire  on,  must  be  in  the  interval  <u>[</u>
              erlang:convert_time_unit<u>(</u>erlang:system_info<u>(start_time),</u>           <u>native,</u>           <u>millisecond),</u>
              erlang:convert_time_unit<u>(</u>erlang:system_info<u>(end_time),</u> <u>native,</u> <u>millisecond)</u> <u>]</u>. If a relative  time
              is specified, the <u>Time</u> value is not allowed to be negative.

              If  <u>Dest</u>  is  a  <u>pid()</u>,  it  must  be  a  <u>pid()</u> of a process created on the current runtime system
              instance. This process has either terminated or not. If <u>Dest</u> is an <u>atom()</u>, it  is  interpreted  as
              the  name of a locally registered process. The process referred to by the name is looked up at the
              time of timer expiration. No error is returned if the name does not refer to a process.

              If <u>Dest</u> is a <u>pid()</u>, the timer is automatically canceled if the process referred to by the <u>pid()</u> is
              not alive, or if the process exits. This feature was introduced in ERTS 5.4.11. Notice that timers
              are not automatically canceled when <u>Dest</u> is an <u>atom()</u>.

              See also <u>erlang:send_after/4</u>, <u>erlang:cancel_timer/2</u>, and <u>erlang:read_timer/2</u>.

              Failure: <u>badarg</u> if the arguments do not satisfy the requirements specified here.

       <b>statistics(Item</b> <b>::</b> <b>active_tasks)</b> <b>-&gt;</b> <b>[ActiveTasks]</b>

              Types:

                 ActiveTasks = integer() &gt;= 0

              Returns the same as <u>statistics(active_tasks_all)</u> with the exception that no information about  the
              dirty  IO  run queue and its associated schedulers is part of the result. That is, only tasks that
              are expected to be CPU bound are part of the result.

       <b>statistics(Item</b> <b>::</b> <b>active_tasks_all)</b> <b>-&gt;</b> <b>[ActiveTasks]</b>

              Types:

                 ActiveTasks = integer() &gt;= 0

              Returns a list where each element represents the amount of active processes and ports on each  run
              queue  and its associated schedulers. That is, the number of processes and ports that are ready to
              run, or are currently running. Values for normal run queues and their  associated  schedulers  are
              located  first  in  the resulting list. The first element corresponds to scheduler number 1 and so
              on. If support for dirty schedulers exist, an element with the value for the dirty CPU  run  queue
              and  its  associated  dirty  CPU  schedulers follow and then as last element the value for the the
              dirty IO run queue and its associated dirty IO schedulers follow. The information is <u>not</u>  gathered
              atomically. That is, the result is not necessarily a consistent snapshot of the state, but instead
              quite efficiently gathered.

          <b>Note:</b>
              Each  normal  scheduler  has  one  run  queue  that it manages. If dirty schedulers schedulers are
              supported, all dirty CPU schedulers share one run queue, and all dirty IO schedulers share one run
              queue. That is, we have multiple normal run queues, one dirty CPU run queue and one dirty  IO  run
              queue.  Work  can  <u>not</u>  migrate between the different types of run queues. Only work in normal run
              queues can migrate to other normal run queues. This has to be taken into account  when  evaluating
              the result.

              See          also          <u>statistics(total_active_tasks)</u>,          <u>statistics(run_queue_lengths)</u>,
              <u>statistics(run_queue_lengths_all)</u>,            <u>statistics(total_run_queue_lengths)</u>,             and
              <u>statistics(total_run_queue_lengths_all)</u>.

       <b>statistics(Item</b> <b>::</b> <b>context_switches)</b> <b>-&gt;</b> <b>{ContextSwitches,</b> <b>0}</b>

              Types:

                 ContextSwitches = integer() &gt;= 0

              Returns the total number of context switches since the system started.

       <b>statistics(Item</b> <b>::</b> <b>exact_reductions)</b> <b>-&gt;</b>
                     {Total_Exact_Reductions,
                      Exact_Reductions_Since_Last_Call}

              Types:

                 Total_Exact_Reductions = Exact_Reductions_Since_Last_Call = integer() &gt;= 0

              Returns the number of exact reductions.

          <b>Note:</b>
              <u>statistics(exact_reductions)</u> is a more expensive operation than  statistics(reductions).

       <b>statistics(Item</b> <b>::</b> <b>garbage_collection)</b> <b>-&gt;</b>
                     {Number_of_GCs, Words_Reclaimed, 0}

              Types:

                 Number_of_GCs = Words_Reclaimed = integer() &gt;= 0

              Returns information about garbage collection, for example:

              &gt; statistics(garbage_collection).
              {85,23961,0}

              This information can be invalid for some implementations.

       <b>statistics(Item</b> <b>::</b> <b>io)</b> <b>-&gt;</b> <b>{{input,</b> <b>Input},</b> <b>{output,</b> <b>Output}}</b>

              Types:

                 Input = Output = integer() &gt;= 0

              Returns <u>Input</u>, which is the total number of bytes received through ports, and <u>Output</u>, which is the
              total number of bytes output to ports.

       <b>statistics(Item</b> <b>::</b> <b>microstate_accounting)</b> <b>-&gt;</b>
                     [MSAcc_Thread] | undefined

              Types:

                 MSAcc_Thread =
                     #{type := MSAcc_Thread_Type,
                       id := MSAcc_Thread_Id,
                       counters := MSAcc_Counters}
                 MSAcc_Thread_Type =
                     async | aux | dirty_io_scheduler | dirty_cpu_scheduler |
                     poll | scheduler
                 MSAcc_Thread_Id = integer() &gt;= 0
                 MSAcc_Counters = #{MSAcc_Thread_State =&gt; integer() &gt;= 0}
                 MSAcc_Thread_State =
                     alloc | aux | bif | busy_wait | check_io | emulator | ets |
                     gc | gc_fullsweep | nif | other | port | send | sleep | timers

              Microstate  accounting can be used to measure how much time the Erlang runtime system spends doing
              various tasks. It is designed to be as lightweight as possible, but some overhead exists when this
              is enabled. Microstate accounting is meant to be a profiling  tool  to  help  finding  performance
              bottlenecks. To <u>start</u>/<u>stop</u>/<u>reset</u> microstate accounting, use system flag <u>microstate_accounting</u>.

              <u><a href="../manmicrostate_accounting/statistics.microstate_accounting.html">statistics</a>(microstate_accounting)</u>  returns  a  list  of  maps  representing some of the OS threads
              within ERTS. Each map contains <u>type</u> and <u>id</u> fields that can be used to identify what thread it  is,
              and  also  a  counters  field that contains data about how much time has been spent in the various
              states.

              Example:

              &gt; erlang:<a href="../manmicrostate_accounting/statistics.microstate_accounting.html">statistics</a>(microstate_accounting).
              [#{counters =&gt; #{aux =&gt; 1899182914,
                               check_io =&gt; 2605863602,
                               emulator =&gt; 45731880463,
                               gc =&gt; 1512206910,
                               other =&gt; 5421338456,
                               port =&gt; 221631,
                               sleep =&gt; 5150294100},
                 id =&gt; 1,
                 type =&gt; scheduler}|...]

              The time unit is the same as returned by <u>os:perf_counter/0</u>. So, to convert it to milliseconds, you
              can do something like this:

              lists:map(
                fun(#{ counters := Cnt } = M) -&gt;
                        MsCnt = maps:map(fun(_K, PerfCount) -&gt;
                                                 erlang:convert_time_unit(PerfCount, perf_counter, 1000)
                                         end, Cnt),
                       M#{ counters := MsCnt }
                end, erlang:<a href="../manmicrostate_accounting/statistics.microstate_accounting.html">statistics</a>(microstate_accounting)).

              Notice that these values are not guaranteed to be the exact time spent  in  each  state.  This  is
              because of various optimisation done to keep the overhead as small as possible.

              <u>MSAcc_Thread_Type</u>s:

                <u>scheduler</u>:
                  The main execution threads that do most of the work. See erl +S for more details.

                <u>dirty_cpu_scheduler</u>:
                  The threads for long running cpu intensive work. See erl +SDcpu for more details.

                <u>dirty_io_scheduler</u>:
                  The threads for long running I/O work. See erl +SDio for more details.

                <u>async</u>:
                  Async  threads are used by various linked-in drivers (mainly the file drivers) do offload non-
                  CPU intensive work. See erl +A for more details.

                <u>aux</u>:
                  Takes care of any work that is not specifically assigned to a scheduler.

                <u>poll</u>:
                  Does the IO polling for the emulator. See erl +IOt for more details.

              The following <u>MSAcc_Thread_State</u>s are available. All states are exclusive, meaning that  a  thread
              cannot  be  in two states at once. So, if you add the numbers of all counters in a thread, you get
              the total runtime for that thread.

                <u>aux</u>:
                  Time spent handling auxiliary jobs.

                <u>check_io</u>:
                  Time spent checking for new I/O events.

                <u>emulator</u>:
                  Time spent executing Erlang processes.

                <u>gc</u>:
                  Time spent doing garbage collection. When extra states are enabled  this  is  the  time  spent
                  doing non-fullsweep garbage collections.

                <u>other</u>:
                  Time spent doing unaccounted things.

                <u>port</u>:
                  Time spent executing ports.

                <u>sleep</u>:
                  Time spent sleeping.

              More  fine-grained <u>MSAcc_Thread_State</u>s can be added through configure (such as <u>./configure</u> <u>--with-</u>
              <u>microstate-accounting=extra</u>). Enabling these states causes performance degradation when microstate
              accounting is turned off and increases the overhead when it is turned on.

                <u>alloc</u>:
                  Time spent managing memory. Without extra states this  time  is  spread  out  over  all  other
                  states.

                <u>bif</u>:
                  Time spent in BIFs. Without extra states this time is part of the <u>emulator</u> state.

                <u>busy_wait</u>:
                  Time spent busy waiting. This is also the state where a scheduler no longer reports that it is
                  active  when  using  <u>statistics(scheduler_wall_time)</u>. So, if you add all other states but this
                  and sleep, and then divide that by all time in the  thread,  you  should  get  something  very
                  similar  to  the  <u>scheduler_wall_time</u>  fraction. Without extra states this time is part of the
                  <u>other</u> state.

                <u>ets</u>:
                  Time spent executing ETS BIFs. Without extra states this time is part of the <u>emulator</u> state.

                <u>gc_full</u>:
                  Time spent doing fullsweep garbage collection. Without extra states this time is part  of  the
                  <u>gc</u> state.

                <u>nif</u>:
                  Time spent in NIFs. Without extra states this time is part of the <u>emulator</u> state.

                <u>send</u>:
                  Time  spent  sending  messages (processes only). Without extra states this time is part of the
                  <u>emulator</u> state.

                <u>timers</u>:
                  Time spent managing timers. Without extra states this time is part of the <u>other</u> state.

              The utility module <u><a href="../man3erl/msacc.3erl.html">msacc</a>(3erl)</u> can be used to more easily analyse these statistics.

              Returns <u>undefined</u> if system flag <u>microstate_accounting</u> is turned off.

              The list of thread information is unsorted and can appear in different order between calls.

          <b>Note:</b>
              The threads and states are subject to change without any prior notice.

       <b>statistics(Item</b> <b>::</b> <b>reductions)</b> <b>-&gt;</b>
                     {Total_Reductions, Reductions_Since_Last_Call}

              Types:

                 Total_Reductions = Reductions_Since_Last_Call = integer() &gt;= 0

              Returns information about reductions, for example:

              &gt; statistics(reductions).
              {2046,11}

          <b>Note:</b>
              As from ERTS 5.5 (Erlang/OTP R11B), this value does not include reductions  performed  in  current
              time   slices   of   currently   scheduled   processes.   If   an   exact  value  is  wanted,  use
              <u>statistics(exact_reductions)</u>.

       <b>statistics(Item</b> <b>::</b> <b>run_queue)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Returns the total length of all normal and dirty CPU run queues. That  is,  queued  work  that  is
              expected  to  be  CPU  bound.  The  information  is  gathered atomically. That is, the result is a
              consistent snapshot of  the  state,  but  this  operation  is  much  more  expensive  compared  to
              <u>statistics(total_run_queue_lengths)</u>, especially when a large amount of schedulers is used.

       <b>statistics(Item</b> <b>::</b> <b>run_queue_lengths)</b> <b>-&gt;</b> <b>[RunQueueLength]</b>

              Types:

                 RunQueueLength = integer() &gt;= 0

              Returns the same as <u>statistics(run_queue_lengths_all)</u> with the exception that no information about
              the  dirty IO run queue is part of the result. That is, only run queues with work that is expected
              to be CPU bound is part of the result.

       <b>statistics(Item</b> <b>::</b> <b>run_queue_lengths_all)</b> <b>-&gt;</b> <b>[RunQueueLength]</b>

              Types:

                 RunQueueLength = integer() &gt;= 0

              Returns a list where each element represents the amount of processes and ports ready  to  run  for
              each  run  queue.  Values for normal run queues are located first in the resulting list. The first
              element corresponds to the normal run queue of scheduler number 1 and so on. If support for  dirty
              schedulers  exist,  values  for the dirty CPU run queue and the dirty IO run queue follow (in that
              order) at the end. The information is  <u>not</u>  gathered  atomically.  That  is,  the  result  is  not
              necessarily a consistent snapshot of the state, but instead quite efficiently gathered.

          <b>Note:</b>
              Each  normal  scheduler  has  one  run  queue  that it manages. If dirty schedulers schedulers are
              supported, all dirty CPU schedulers share one run queue, and all dirty IO schedulers share one run
              queue. That is, we have multiple normal run queues, one dirty CPU run queue and one dirty  IO  run
              queue.  Work  can  <u>not</u>  migrate between the different types of run queues. Only work in normal run
              queues can migrate to other normal run queues. This has to be taken into account  when  evaluating
              the result.

              See       also       <u>statistics(run_queue_lengths)</u>,       <u>statistics(total_run_queue_lengths_all)</u>,
              <u>statistics(total_run_queue_lengths)</u>, <u>statistics(active_tasks)</u>,  <u>statistics(active_tasks_all)</u>,  and
              <u>statistics(total_active_tasks)</u>, <u>statistics(total_active_tasks_all)</u>.

       <b>statistics(Item</b> <b>::</b> <b>runtime)</b> <b>-&gt;</b>
                     {Total_Run_Time, Time_Since_Last_Call}

              Types:

                 Total_Run_Time = Time_Since_Last_Call = integer() &gt;= 0

              Returns information about runtime, in milliseconds.

              This  is  the sum of the runtime for all threads in the Erlang runtime system and can therefore be
              greater than the wall clock time.

          <b>Warning:</b>
              This value might wrap due to limitations in the underlying functionality provided by the operating
              system that is used.

              Example:

              &gt; statistics(runtime).
              {1690,1620}

       <b>statistics(Item</b> <b>::</b> <b>scheduler_wall_time)</b> <b>-&gt;</b>
                     [{SchedulerId, ActiveTime, TotalTime}] | undefined

              Types:

                 SchedulerId = integer() &gt;= 1
                 ActiveTime = TotalTime = integer() &gt;= 0

              Returns information describing how much time normal and dirty CPU schedulers in  the  system  have
              been  busy.  This  value  is  normally a better indicator of how much load an Erlang node is under
              instead of looking at the CPU utilization privided by tools  such  as  <u>top</u>  or  <u>sysstat</u>.  This  is
              because  <u>scheduler_wall_time</u>  also  includes  time  where  the scheduler is waiting for some other
              reasource (such as an internal mutex) to be available but does not use the CPU. In order to better
              understand what a scheduler is busy doing you can use microstate accounting.

              The definition of a busy scheduler is when it is not idle and not busy waiting for new work,  that
              is:

                * Executing process code

                * Executing linked-in driver or NIF code

                * Executing BIFs, or any other runtime handling

                * Garbage collecting

                * Handling any other memory management

              Notice that a scheduler can also be busy even if the OS has scheduled out the scheduler thread.

          <b>Note:</b>
              It  is recommended to use the module <u>scheduler</u> instead of this function directly as it provides an
              easier way to get the information that you usually want.

              If enabled this function returns a list of tuples with <u>{SchedulerId,</u> <u>ActiveTime,</u> <u>TotalTime}</u>, where
              <u>SchedulerId</u> is an integer ID of the scheduler, <u>ActiveTime</u> is the duration the scheduler  has  been
              busy,  and  <u>TotalTime</u>  is  the  total  time  duration since <u>scheduler_wall_time</u> activation for the
              specific scheduler. The time unit returned is undefined and  can  be  subject  to  change  between
              releases,  OSs,  and system restarts. <u>scheduler_wall_time</u> is only to be used to calculate relative
              values for scheduler utilization. The <u>ActiveTime</u> can never exceed <u>TotalTime</u>. The list of scheduler
              information is unsorted and can appear in different order between calls.

              The disabled this function returns <u>undefined</u>.

              The activation time can differ significantly between schedulers. Currently  dirty  schedulers  are
              activated   at   system   start  while  normal  schedulers  are  activated  some  time  after  the
              <u>scheduler_wall_time</u> functionality is enabled.

              Only information about schedulers that are expected to handle CPU bound work is  included  in  the
              return  values  from  this  function. If you also want information about dirty I/O schedulers, use
              <u>statistics(scheduler_wall_time_all)</u> instead.

              Normal  schedulers  will  have  scheduler  identifiers  in  the  range   <u>1</u>   <u>=&lt;</u>   <u>SchedulerId</u>   <u>=&lt;</u>
              <u>erlang:system_info(schedulers)</u>.  Dirty CPU schedulers will have scheduler identifiers in the range
              <u>erlang:system_info(schedulers)</u>    <u>&lt;</u>    <u>SchedulerId</u>     <u>=&lt;</u>     <u>erlang:system_info(schedulers)</u>     <u>+</u>
              <u>erlang:system_info(dirty_cpu_schedulers)</u>.

          <b>Note:</b>
              The  different  types  of  schedulers  handle  specific  types of jobs. Every job is assigned to a
              specific scheduler type. Jobs can migrate between different schedulers of the same type, but never
              between schedulers of different types.  This  fact  has  to  be  taken  under  consideration  when
              evaluating the result returned.

              You can use <u>scheduler_wall_time</u> to calculate scheduler utilization. First you take a sample of the
              values returned by <u>erlang:statistics(scheduler_wall_time)</u>.

              &gt; erlang:system_flag(scheduler_wall_time, true).
              false
              &gt; Ts0 = lists:sort(erlang:statistics(scheduler_wall_time)), ok.
              ok

              Some  time  later  the  user  takes  another  snapshot  and  calculates  scheduler utilization per
              scheduler, for example:

              &gt; Ts1 = lists:sort(erlang:statistics(scheduler_wall_time)), ok.
              ok
              &gt; lists:map(fun({{I, A0, T0}, {I, A1, T1}}) -&gt; {I, (A1 - A0)/(T1 - T0)} end, lists:zip(Ts0,Ts1)).
              [{1,0.9743474730177548},
               {2,0.9744843782751444},
               {3,0.9995902361669045},
               {4,0.9738012596572161},
               {5,0.9717956667018103},
               {6,0.9739235846420741},
               {7,0.973237033077876},
               {8,0.9741297293248656}]

              Using the same snapshots to calculate a total scheduler utilization:

              &gt; {A, T} = lists:foldl(fun({{_, A0, T0}, {_, A1, T1}}, {Ai,Ti}) -&gt; {Ai + (A1 - A0), Ti + (T1 - T0)} end, {0, 0}, lists:zip(Ts0,Ts1)), TotalSchedulerUtilization = A/T.
              0.9769136803764825

              Total scheduler utilization will equal <u>1.0</u> when all schedulers  have  been  active  all  the  time
              between the two measurements.

              Another  (probably more) useful value is to calculate total scheduler utilization weighted against
              maximum amount of available CPU time:

              &gt; WeightedSchedulerUtilization = (TotalSchedulerUtilization * (erlang:system_info(schedulers) + erlang:system_info(dirty_cpu_schedulers))) / erlang:system_info(logical_processors_available).
              0.9769136803764825

              This weighted scheduler utilization will reach <u>1.0</u> when schedulers are active the same  amount  of
              time  as  maximum  available CPU time. If more schedulers exist than available logical processors,
              this value may be greater than <u>1.0</u>.

              As of ERTS version 9.0, the Erlang runtime system  will  as  default  have  more  schedulers  than
              logical processors. This due to the dirty schedulers.

          <b>Note:</b>
              <u>scheduler_wall_time</u>      is      by      default      disabled.      To     enable     it,     use
              <u>erlang:system_flag(scheduler_wall_time,</u> <u>true)</u>.

       <b>statistics(Item</b> <b>::</b> <b>scheduler_wall_time_all)</b> <b>-&gt;</b>
                     [{SchedulerId, ActiveTime, TotalTime}] | undefined

              Types:

                 SchedulerId = integer() &gt;= 1
                 ActiveTime = TotalTime = integer() &gt;= 0

              The same as <u>statistics(scheduler_wall_time)</u>, except that it also  include  information  about  all
              dirty I/O schedulers.

              Dirty  IO schedulers will have scheduler identifiers in the range <u>erlang:system_info(schedulers)</u> <u>+</u>
              <u>erlang:system_info(dirty_cpu_schedulers)</u>  <u>&lt;</u>  <u>SchedulerId</u>   <u>=&lt;</u>   <u>erlang:system_info(schedulers)</u>   <u>+</u>
              <u>erlang:system_info(dirty_cpu_schedulers)</u> <u>+</u> <u>erlang:system_info(dirty_io_schedulers)</u>.

          <b>Note:</b>
              Note  that  work  executing  on dirty I/O schedulers are expected to mainly wait for I/O. That is,
              when you get high scheduler utilization on dirty I/O schedulers, CPU utilization is  <u>not</u>  expected
              to be high due to this work.

       <b>statistics(Item</b> <b>::</b> <b>total_active_tasks)</b> <b>-&gt;</b> <b>ActiveTasks</b>

              Types:

                 ActiveTasks = integer() &gt;= 0

              The same as calling <u>lists:sum(statistics(active_tasks))</u>, but more efficient.

       <b>statistics(Item</b> <b>::</b> <b>total_active_tasks_all)</b> <b>-&gt;</b> <b>ActiveTasks</b>

              Types:

                 ActiveTasks = integer() &gt;= 0

              The same as calling <u>lists:sum(statistics(active_tasks_all))</u>, but more efficient.

       <b>statistics(Item</b> <b>::</b> <b>total_run_queue_lengths)</b> <b>-&gt;</b>
                     TotalRunQueueLengths

              Types:

                 TotalRunQueueLengths = integer() &gt;= 0

              The same as calling <u>lists:sum(statistics(run_queue_lengths))</u>, but more efficient.

       <b>statistics(Item</b> <b>::</b> <b>total_run_queue_lengths_all)</b> <b>-&gt;</b>
                     TotalRunQueueLengths

              Types:

                 TotalRunQueueLengths = integer() &gt;= 0

              The same as calling <u>lists:sum(statistics(run_queue_lengths_all))</u>, but more efficient.

       <b>statistics(Item</b> <b>::</b> <b>wall_clock)</b> <b>-&gt;</b>
                     {Total_Wallclock_Time,
                      Wallclock_Time_Since_Last_Call}

              Types:

                 Total_Wallclock_Time = Wallclock_Time_Since_Last_Call = integer() &gt;= 0

              Returns information about wall clock. <u>wall_clock</u> can be used in the same manner as <u>runtime</u>, except
              that real time is measured as opposed to runtime or CPU time.

       <b>erlang:suspend_process(Suspendee)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Suspendee = pid()

              Suspends     the     process     identified     by     <u>Suspendee</u>.     The    same    as    calling
              <u>erlang:suspend_process(Suspendee,</u> <u>[])</u>.

          <b>Warning:</b>
              This BIF is intended for debugging only.

       <b>erlang:suspend_process(Suspendee,</b> <b>OptList)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Suspendee = pid()
                 OptList = [Opt]
                 Opt = unless_suspending | asynchronous | {asynchronous, term()}

              Increases the suspend count on the process identified by <u>Suspendee</u> and puts it  in  the  suspended
              state if it is not already in that state. A suspended process is not scheduled for execution until
              the process has been resumed.

              A  process  can be suspended by multiple processes and can be suspended multiple times by a single
              process. A suspended process does not leave the suspended state until its  suspend  count  reaches
              zero.  The suspend count of <u>Suspendee</u> is decreased when <u>erlang:resume_process(Suspendee)</u> is called
              by the same process that called <u>erlang:suspend_process(Suspendee)</u>. All increased suspend counts on
              other processes acquired by a process are automatically decreased when the process terminates.

              Options (<u>Opt</u>s):

                <u>asynchronous</u>:
                  A suspend request is sent  to  the  process  identified  by  <u>Suspendee</u>.  <u>Suspendee</u>  eventually
                  suspends  unless it is resumed before it could suspend. The caller of <u>erlang:suspend_process/2</u>
                  returns immediately, regardless of whether <u>Suspendee</u> has suspended yet or not.  The  point  in
                  time  when  <u>Suspendee</u>  suspends  cannot be deduced from other events in the system. It is only
                  guaranteed that <u>Suspendee</u> <u>eventually</u> suspends (unless  it  is  resumed).  If  no  <u>asynchronous</u>
                  options has been passed, the caller of <u>erlang:suspend_process/2</u> is blocked until <u>Suspendee</u> has
                  suspended.

                <u>{asynchronous,</u> <u>ReplyTag}</u>:
                  A suspend request is sent to the process identified by <u>Suspendee</u>. When the suspend request has
                  been  processed,  a  reply message is sent to the caller of this function. The reply is on the
                  form <u>{ReplyTag,</u> <u>State}</u> where <u>State</u> is either:

                  <u>exited</u>:
                    <u>Suspendee</u> has exited.

                  <u>suspended</u>:
                    <u>Suspendee</u> is now suspended.

                  <u>not_suspended</u>:
                    <u>Suspendee</u> is not suspended. This can only happen when the process that issued this  request,
                    have called <u>resume_process(Suspendee)</u> before getting the reply.

                  Appart from the reply message, the <u>{asynchronous,</u> <u>ReplyTag}</u> option behaves exactly the same as
                  the <u>asynchronous</u> option without reply tag.

                <u>unless_suspending</u>:
                  The  process  identified  by  <u>Suspendee</u>  is  suspended  unless  the calling process already is
                  suspending <u>Suspendee</u>. If <u>unless_suspending</u> is combined with  option  <u>asynchronous</u>,  a  suspend
                  request  is  sent  unless  the calling process already is suspending <u>Suspendee</u> or if a suspend
                  request already has been sent and is in transit. If the calling process already is  suspending
                  <u>Suspendee</u>,  or  if combined with option <u>asynchronous</u> and a send request already is in transit,
                  <u>false</u> is returned and the suspend count on <u>Suspendee</u> remains unchanged.

              If the suspend count on the process identified  by  <u>Suspendee</u>  is  increased,  <u>true</u>  is  returned,
              otherwise <u>false</u>.

          <b>Warning:</b>
              This BIF is intended for debugging only.

          <b>Warning:</b>
              You can easily create deadlocks if processes suspends each other (directly or in circles). In ERTS
              versions  prior  to  ERTS  version  10.0,  the  runtime  system prevented such deadlocks, but this
              prevention has now been removed due to performance reasons.

              Failures:

                <u>badarg</u>:
                   If <u>Suspendee</u> is not a process identifier.

                <u>badarg</u>:
                   If the  process  identified  by  <u>Suspendee</u>  is  the  same  process  as  the  process  calling
                  <u>erlang:suspend_process/2</u>.

                <u>badarg</u>:
                   If the process identified by <u>Suspendee</u> is not alive.

                <u>badarg</u>:
                   If the process identified by <u>Suspendee</u> resides on another node.

                <u>badarg</u>:
                   If <u>OptList</u> is not a proper list of valid <u>Opt</u>s.

                <u>system_limit</u>:
                   If  the  process identified by <u>Suspendee</u> has been suspended more times by the calling process
                  than can be represented by the currently used internal data structures. The  system  limit  is
                  greater than 2,000,000,000 suspends and will never be lower.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>backtrace_depth,</b> <b>Depth)</b> <b>-&gt;</b> <b>OldDepth</b>

              Types:

                 Depth = OldDepth = integer() &gt;= 0

              Sets  the maximum depth of call stack back-traces in the exit reason element of <u>'EXIT'</u> tuples. The
              flag also limits the stacktrace depth returned by <u>process_info</u> item <u>current_stacktrace.</u>

              Returns the old value of the flag.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>cpu_topology,</b> <b>CpuTopology)</b> <b>-&gt;</b>
                             OldCpuTopology

              Types:

                 CpuTopology = OldCpuTopology = cpu_topology()
                 <b>cpu_topology()</b> = [LevelEntry :: level_entry()] | undefined
                 <b>level_entry()</b> =
                     {LevelTag :: level_tag(), SubLevel :: sub_level()} |
                     {LevelTag :: level_tag(),
                      InfoList :: info_list(),
                      SubLevel :: sub_level()}
                 <b>level_tag()</b> = core | node | processor | thread
                 <b>sub_level()</b> =
                     [LevelEntry :: level_entry()] |
                     (LogicalCpuId :: {logical, integer() &gt;= 0})
                 <b>info_list()</b> = []

          <b>Warning:</b>
              <u>This</u> <u>argument</u> <u>is</u> <u>deprecated.</u> Instead of using this argument, use  command-line  argument  <u>+sct</u>  in
              <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

              When this argument is removed, a final CPU topology to use is determined at emulator boot time.

              Sets  the  user-defined  <u>CpuTopology</u>.  The  user-defined  CPU topology overrides any automatically
              detected CPU topology. By passing <u>undefined</u> as <u>CpuTopology</u>, the system reverts to the CPU topology
              automatically   detected.   The    returned    value    equals    the    value    returned    from
              <u>erlang:system_info(cpu_topology)</u> before the change was made.

              Returns the old value of the flag.

              The  CPU topology is used when binding schedulers to logical processors. If schedulers are already
              bound when the CPU topology is changed, the schedulers are sent a request to rebind  according  to
              the new CPU topology.

              The user-defined CPU topology can also be set by passing command-line argument <u>+sct</u> to <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

              For  information  on  type  <u>CpuTopology</u>  and more, see <u>erlang:system_info(cpu_topology)</u> as well as
              command-line flags <u>+sct</u> and <u>+sbt</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>dirty_cpu_schedulers_online,</b>
                          DirtyCPUSchedulersOnline) -&gt;
                             OldDirtyCPUSchedulersOnline

              Types:

                 DirtyCPUSchedulersOnline = OldDirtyCPUSchedulersOnline = integer() &gt;= 1

              Sets the number of dirty CPU schedulers online. Range is <u>1</u> <u>&lt;=</u> <u>DirtyCPUSchedulersOnline</u> <u>&lt;=</u> <u>N</u>, where
              <u>N</u>  is  the  smallest  of  the  return  values  of   <u>erlang:system_info(dirty_cpu_schedulers)</u>   and
              <u>erlang:system_info(schedulers_online)</u>.

              Returns the old value of the flag.

              The  number  of dirty CPU schedulers online can change if the number of schedulers online changes.
              For example, if 12 schedulers and 6 dirty CPU schedulers are online, and <u>system_flag/2</u> is used  to
              set  the  number  of  schedulers  online  to  6, then the number of dirty CPU schedulers online is
              automatically decreased by half as well, down to 3. Similarly, the number of dirty CPU  schedulers
              online increases proportionally to increases in the number of schedulers online.

              For       more       information,       see      <u>erlang:system_info(dirty_cpu_schedulers)</u>      and
              <u>erlang:system_info(dirty_cpu_schedulers_online)</u>.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>erts_alloc,</b> <b>Value</b> <b>::</b> <b>{Alloc,</b> <b>F,</b> <b>V})</b> <b>-&gt;</b>
                             ok | notsup

              Types:

                 Alloc = F = atom()
                 V = integer()

              Sets  system  flags  for  <u><a href="../man3erl/erts_alloc.3erl.html">erts_alloc</a>(3erl)</u>.  <u>Alloc</u>  is  the  allocator  to  affect,  for   example
              <u>binary_alloc</u>. <u>F</u> is the flag to change and <u>V</u> is the new value.

              Only  a  subset  of all <u>erts_alloc</u> flags can be changed at run time. This subset is currently only
              the flag <u>sbct</u>.

              Returns <u>ok</u> if the flag was set or <u>notsup</u> if not supported by <u>erts_alloc</u>.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>fullsweep_after,</b> <b>Number)</b> <b>-&gt;</b> <b>OldNumber</b>

              Types:

                 Number = OldNumber = integer() &gt;= 0

              Sets system flag <u>fullsweep_after</u>. <u>Number</u> is a  non-negative  integer  indicating  how  many  times
              generational  garbage  collections  can  be done without forcing a fullsweep collection. The value
              applies to new processes, while processes already running are not affected.

              Returns the old value of the flag.

              In low-memory systems (especially without virtual memory), setting the value  to  <u>0</u>  can  help  to
              conserve memory.

              This value can also be set through (OS) environment variable <u>ERL_FULLSWEEP_AFTER</u>.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>microstate_accounting,</b> <b>Action)</b> <b>-&gt;</b>
                             OldState

              Types:

                 Action = true | false | reset
                 OldState = true | false

              Turns on/off microstate accounting measurements. When passing reset, all counters are reset to 0.

              For more information see <u><a href="../manmicrostate_accounting/statistics.microstate_accounting.html">statistics</a>(microstate_accounting)</u>.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>min_heap_size,</b> <b>MinHeapSize)</b> <b>-&gt;</b>
                             OldMinHeapSize

              Types:

                 MinHeapSize = OldMinHeapSize = integer() &gt;= 0

              Sets  the  default  minimum  heap  size  for  processes.  The  size is specified in words. The new
              <u>min_heap_size</u> effects only processes spawned after the change  of  <u>min_heap_size</u>  has  been  made.
              <u>min_heap_size</u> can be set for individual processes by using <u>spawn_opt/4</u> or <u>process_flag/2</u>.

              Returns the old value of the flag.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>min_bin_vheap_size,</b> <b>MinBinVHeapSize)</b> <b>-&gt;</b>
                             OldMinBinVHeapSize

              Types:

                 MinBinVHeapSize = OldMinBinVHeapSize = integer() &gt;= 0

              Sets  the  default minimum binary virtual heap size for processes. The size is specified in words.
              The new <u>min_bin_vhheap_size</u> effects only processes spawned after the change of  <u>min_bin_vheap_size</u>
              has  been made. <u>min_bin_vheap_size</u> can be set for individual processes by using <u>spawn_opt/2,3,4</u> or
              <u>process_flag/2</u>.

              Returns the old value of the flag.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>max_heap_size,</b> <b>MaxHeapSize)</b> <b>-&gt;</b>
                             OldMaxHeapSize

              Types:

                 MaxHeapSize = OldMaxHeapSize = max_heap_size()
                 <b>max_heap_size()</b> =
                     integer() &gt;= 0 |
                     #{size =&gt; integer() &gt;= 0,
                       kill =&gt; boolean(),
                       error_logger =&gt; boolean()}

              Sets the default maximum heap size settings for processes. The size is specified in words. The new
              <u>max_heap_size</u> effects only processes spawned efter the change has been made. <u>max_heap_size</u> can  be
              set for individual processes using <u>spawn_opt/2,3,4</u> or <u>process_flag/2</u>.

              Returns the old value of the flag.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>multi_scheduling,</b> <b>BlockState)</b> <b>-&gt;</b>
                             OldBlockState

              Types:

                 BlockState = block | unblock | block_normal | unblock_normal
                 OldBlockState = blocked | disabled | enabled

              If  multi-scheduling  is  enabled,  more than one scheduler thread is used by the emulator. Multi-
              scheduling can be blocked in two different ways. Either all schedulers but one is blocked, or  all
              <u>normal</u>  schedulers  but  one is blocked. When only normal schedulers are blocked, dirty schedulers
              are free to continue to schedule processes.

              If <u>BlockState</u> <u>=:=</u> <u>block</u>, multi-scheduling is blocked. That is, one and only one  scheduler  thread
              will  execute. If <u>BlockState</u> <u>=:=</u> <u>unblock</u> and no one else blocks multi-scheduling, and this process
              has blocked only once, multi-scheduling is unblocked.

              If <u>BlockState</u> <u>=:=</u> <u>block_normal</u>, normal multi-scheduling is  blocked.  That  is,  only  one  normal
              scheduler  thread  will  execute,  but  multiple  dirty  schedulers can execute. If <u>BlockState</u> <u>=:=</u>
              <u>unblock_normal</u> and no one else blocks normal multi-scheduling, and this process has  blocked  only
              once, normal multi-scheduling is unblocked.

              One  process  can  block multi-scheduling and normal multi-scheduling multiple times. If a process
              has blocked multiple times, it must unblock exactly as many times as it has blocked before it  has
              released  its  multi-scheduling  block.  If  a process that has blocked multi-scheduling or normal
              multi-scheduling exits, it automatically releases its  blocking  of  multi-scheduling  and  normal
              multi-scheduling.

              The  return values are <u>disabled</u>, <u>blocked</u>, <u>blocked_normal</u>, or <u>enabled</u>. The returned value describes
              the state just after the call to <u>erlang:system_flag(multi_scheduling,</u> <u>BlockState)</u> has  been  made.
              For information about the return values, see <u>erlang:<a href="../manmulti_scheduling/system_info.multi_scheduling.html">system_info</a>(multi_scheduling)</u>.

          <b>Note:</b>
              Blocking  of multi-scheduling and normal multi-scheduling is normally not needed. If you feel that
              you need to use these features, consider it a few more times again. Blocking  multi-scheduling  is
              only  to  be  used  as  a  last  resort,  as it is most likely a <u>very</u> <u>inefficient</u> way to solve the
              problem.

              See                           also                           <u>erlang:<a href="../manmulti_scheduling/system_info.multi_scheduling.html">system_info</a>(multi_scheduling)</u>,
              <u>erlang:system_info(normal_multi_scheduling_blockers)</u>,
              <u>erlang:<a href="../manmulti_scheduling_blockers/system_info.multi_scheduling_blockers.html">system_info</a>(multi_scheduling_blockers)</u>, and <u>erlang:system_info(schedulers)</u>.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>outstanding_system_requests_limit,</b>
                          NewLimit) -&gt;
                             OldLimit

              Types:

                 NewLimit = OldLimit = 1..134217727

              Sets  a  limit on the amount of outstanding requests made by a system process orchestrating system
              wide changes. Currently there are two such processes:

                <b>The</b> <b>Code</b> <b>Purger:</b>
                  The code purger orchestrates checking of references to old code before  old  code  is  removed
                  from the system.

                <b>The</b> <b>Literal</b> <b>Area</b> <b>Collector:</b>
                  The  literal  area  collector orchestrates copying of references from old literal areas before
                  removal of such areas from the system.

              Each of these processes are allowed to have as many outstanding requests as this limit is set  to.
              By  default  this  limit  is set to twice the amount of schedulers on the system. This will ensure
              that schedulers will have enough work scheduled to perform these operations as quickly as possible
              at the same time as other work will be interleaved with this work. Currently  used  limit  can  be
              checked by calling <u>erlang:system_info(outstanding_system_requests_limit)</u>.

              This limit can also be set by passing the command line argument <u>+zosrl</u> <u>&lt;Limit&gt;</u> to <u>erl</u>.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>scheduler_bind_type,</b> <b>How)</b> <b>-&gt;</b>
                             OldBindType

              Types:

                 How = scheduler_bind_type() | default_bind
                 OldBindType = scheduler_bind_type()
                 <b>scheduler_bind_type()</b> =
                     no_node_processor_spread | no_node_thread_spread | no_spread |
                     processor_spread | spread | thread_spread |
                     thread_no_node_processor_spread | unbound

          <b>Warning:</b>
              <u>This</u>  <u>argument</u>  <u>is</u>  <u>deprecated.</u>  Instead of using this argument, use command-line argument <u>+sbt</u> in
              <u><a href="../man1/erl.1.html">erl</a>(1)</u>. When this argument is removed, a final  scheduler  bind  type  to  use  is  determined  at
              emulator boot time.

              Controls if and how schedulers are bound to logical processors.

              When <u>erlang:system_flag(scheduler_bind_type,</u> <u>How)</u> is called, an asynchronous signal is sent to all
              schedulers online, causing them to try to bind or unbind as requested.

          <b>Note:</b>
              If  a  scheduler  fails  to  bind, this is often silently ignored, as it is not always possible to
              verify valid logical processor identifiers. If an error is reported, an error event is logged.  To
              verify that the schedulers have bound as requested, call <u>erlang:system_info(scheduler_bindings)</u>.

              Schedulers  can  be  bound on newer Linux, Solaris, FreeBSD, and Windows systems, but more systems
              will be supported in future releases.

              In order for the runtime system to be able to bind schedulers, the CPU topology must be known.  If
              the  runtime  system  fails  to detect the CPU topology automatically, it can be defined. For more
              information on how to define the CPU topology, see command-line flag <u>+sct</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

              The runtime system does by default <u>not</u> bind schedulers to logical processors.

          <b>Note:</b>
              If the Erlang runtime system is the only OS process binding threads to  logical  processors,  this
              improves  the  performance  of  the  runtime  system. However, if other OS processes (for example,
              another Erlang runtime system) also bind threads to logical processors, there can be a performance
              penalty instead. Sometimes this performance penalty can be severe. If so, it is recommended to not
              bind the schedulers.

              Schedulers can be bound in different ways. Argument <u>How</u> determines how schedulers  are  bound  and
              can be any of the following:

                <u>unbound</u>:
                  Same as command-line argument <u>+sbt</u> <u>u</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>no_spread</u>:
                  Same as command-line argument <u>+sbt</u> <u>ns</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>thread_spread</u>:
                  Same as command-line argument <u>+sbt</u> <u>ts</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>processor_spread</u>:
                  Same as command-line argument <u>+sbt</u> <u>ps</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>spread</u>:
                  Same as command-line argument <u>+sbt</u> <u>s</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>no_node_thread_spread</u>:
                  Same as command-line argument <u>+sbt</u> <u>nnts</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>no_node_processor_spread</u>:
                  Same as command-line argument <u>+sbt</u> <u>nnps</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>thread_no_node_processor_spread</u>:
                  Same as command-line argument <u>+sbt</u> <u>tnnps</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>default_bind</u>:
                  Same as command-line argument <u>+sbt</u> <u>db</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

              The returned value equals <u>How</u> before flag <u>scheduler_bind_type</u> was changed.

              Failures:

                <u>notsup</u>:
                  If binding of schedulers is not supported.

                <u>badarg</u>:
                  If <u>How</u> is not one of the documented alternatives.

                <u>badarg</u>:
                  If CPU topology information is unavailable.

              The scheduler bind type can also be set by passing command-line argument <u>+sbt</u> to <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

              For         more         information,         see         <u>erlang:system_info(scheduler_bind_type)</u>,
              <u>erlang:system_info(scheduler_bindings)</u>, as well as command-line flags <u>+sbt</u> and <u>+sct</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>scheduler_wall_time,</b> <b>Boolean)</b> <b>-&gt;</b>
                             OldBoolean

              Types:

                 Boolean = OldBoolean = boolean()

              Turns on or off scheduler wall time measurements.

              For more information, see <u>statistics(scheduler_wall_time)</u>.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>schedulers_online,</b> <b>SchedulersOnline)</b> <b>-&gt;</b>
                             OldSchedulersOnline

              Types:

                 SchedulersOnline = OldSchedulersOnline = integer() &gt;= 1

              Sets   the   number   of   schedulers   online.   Range    is    <u>1</u>    <u>&lt;=</u>    <u>SchedulersOnline</u>    <u>&lt;=</u>
              <u>erlang:system_info(schedulers)</u>.

              Returns the old value of the flag.

              If  the  emulator  was built with support for  dirty schedulers, changing the number of schedulers
              online can also change the number of dirty CPU schedulers online. For example,  if  12  schedulers
              and  6  dirty CPU schedulers are online, and <u>system_flag/2</u> is used to set the number of schedulers
              online to 6, then the number of dirty CPU schedulers online is automatically decreased by half  as
              well,  down to 3. Similarly, the number of dirty CPU schedulers online increases proportionally to
              increases in the number of schedulers online.

              For        more        information,         see         <u>erlang:system_info(schedulers)</u>         and
              <u>erlang:system_info(schedulers_online)</u>.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>system_logger,</b> <b>Logger)</b> <b>-&gt;</b> <b>PrevLogger</b>

              Types:

                 Logger = PrevLogger = logger | undefined | pid()

              Sets  the  process  that will receive the logging messages generated by ERTS. If set to <u>undefined</u>,
              all logging messages generated by ERTS will be dropped. The messages will be in the format:

              {log,Level,Format,ArgList,Metadata} where

              Level = atom(),
              Format = string(),
              ArgList = list(term()),
              Metadata = #{ pid =&gt; pid(),
                 group_leader =&gt; pid(),
                 time := logger:timestamp(),
                 error_logger := #{ emulator := true, tag := atom() }

              If the <u>system_logger</u> process dies, this flag will be reset to <u>logger</u>.

              The default is the process named <u>logger</u>.

              Returns the old value of the flag.

          <b>Note:</b>
              This function is designed to be used by the  KERNEL  <u>logger</u>.  Be  careful  if  you  change  it  to
              something  else as log messages may be lost. If you want to intercept emulator log messages, do it
              by adding a specialized handler to the KERNEL logger.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>trace_control_word,</b> <b>TCW)</b> <b>-&gt;</b> <b>OldTCW</b>

              Types:

                 TCW = OldTCW = integer() &gt;= 0

              Sets the value of the node trace control word to <u>TCW</u>, which is to be an unsigned integer. For more
              information, see function <u>set_tcw</u> in section "Match Specifications in Erlang" in the User's Guide.

              Returns the old value of the flag.

       <b>erlang:system_flag(Flag</b> <b>::</b> <b>time_offset,</b> <b>Value</b> <b>::</b> <b>finalize)</b> <b>-&gt;</b>
                             OldState

              Types:

                 OldState = preliminary | final | volatile

              Finalizes the time offset when single time warp mode is used. If another time warp mode  is  used,
              the time offset state is left unchanged.

              Returns the old state identifier, that is:

                * If <u>preliminary</u> is returned, finalization was performed and the time offset is now final.

                * If  <u>final</u>  is  returned,  the  time offset was already in the final state. This either because
                  another <u>erlang:system_flag(time_offset,</u> <u>finalize)</u> call or because no time warp mode is used.

                * If <u>volatile</u> is returned, the time offset cannot be finalized because multi-time warp  mode  is
                  used.

       <b>erlang:system_info(Item</b> <b>::</b> <b>update_cpu_info)</b> <b>-&gt;</b> <b>changed</b> <b>|</b> <b>unchanged</b>

              Returns  information  about  the current system. The documentation of this function is broken into
              the following sections in order to make it easier to navigate.

                <u>Memory</u> <u>Allocation</u>:
                  <u>allocated_areas</u>, <u>allocator</u>, <u>alloc_util_allocators</u>, <u>allocator_sizes</u>

                <u>CPU</u> <u>Topology</u>:
                  <u>cpu_topology</u>, <u>logical_processors</u>, <u>update_cpu_info</u>

                <u>Process</u> <u>Information</u>:
                  <u>fullsweep_after</u>, <u>garbage_collection</u>, <u>heap_sizes</u>, <u>heap_type</u>, <u>max_heap_size</u>, <u>message_queue_data</u>,
                  <u>min_heap_size</u>, <u>min_bin_vheap_size</u>, <u>procs</u>

                <u>System</u> <u>Limits</u>:
                  <u>atom_count</u>,  <u>atom_limit</u>,  <u>ets_count</u>,   <u>ets_limit</u>,   <u>port_count</u>,   <u>port_limit</u>,   <u>process_count</u>,
                  <u>process_limit</u>

                <u>System</u> <u>Time</u>:
                  <u>end_time</u>,   <u>os_monotonic_time_source</u>,   <u>os_system_time_source</u>,   <u>start_time</u>,  <u>time_correction</u>,
                  <u>time_offset</u>, <u>time_warp_mode</u>, <u>tolerant_timeofday</u>

                <u>Scheduler</u> <u>Information</u>:
                  <u>dirty_cpu_schedulers</u>,  <u>dirty_cpu_schedulers_online</u>,   <u>dirty_io_schedulers</u>,   <u>multi_scheduling</u>,
                  <u>multi_scheduling_blockers</u>,        <u>normal_multi_scheduling_blockers</u>,       <u>scheduler_bind_type</u>,
                  <u>scheduler_bindings</u>, <u>scheduler_id</u>, <u>schedulers</u>, <u>smp_support</u>, <u>threads</u>, <u>thread_pool_size</u>

                <u>Distribution</u> <u>Information</u>:
                  <u>creation</u>, <u>delayed_node_table_gc</u>, <u>dist</u>, <u>dist_buf_busy_limit</u>, <u>dist_ctrl</u>

                <u>System</u> <u>Information</u>:
                  <u>c_compiler_used</u>,  <u>check_io</u>,   <u>compat_rel</u>,   <u>debug_compiled</u>,   <u>driver_version</u>,   <u>dynamic_trace</u>,
                  <u>dynamic_trace_probes</u>,    <u>emu_flavor</u>,    <u>emu_type</u>,    <u>info</u>,   <u>kernel_poll</u>,   <u>loaded</u>,   <u>machine</u>,
                  <u>modified_timing_level</u>,    <u>nif_version</u>,     <u>otp_release</u>,     <u>outstanding_system_requests_limit</u>,
                  <u>port_parallelism</u>,   <u>system_architecture</u>,  <u>system_logger</u>,  <u>system_version</u>,  <u>trace_control_word</u>,
                  <u>version</u>, <u>wordsize</u>

       <b>erlang:system_info(Item</b> <b>::</b> <b>allocated_areas)</b> <b>-&gt;</b> <b>[tuple()]</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>allocator)</b> <b>-&gt;</b>
                             {Allocator, Version, Features, Settings}

       <b>erlang:system_info(Item</b> <b>::</b> <b>{allocator,</b> <b>Alloc})</b> <b>-&gt;</b> <b>[term()]</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>alloc_util_allocators)</b> <b>-&gt;</b> <b>[Alloc]</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>{allocator_sizes,</b> <b>Alloc})</b> <b>-&gt;</b> <b>[term()]</b>

              Types:

                 Allocator = undefined | glibc
                 Version = [integer() &gt;= 0]
                 Features = [atom()]
                 Settings =
                     [{Subsystem :: atom(),
                       [{Parameter :: atom(), Value :: term()}]}]
                 Alloc = atom()

              Returns various information about the memory  allocators  of  the  current  system  (emulator)  as
              specified by <u>Item</u>:

                <u>allocated_areas</u>:
                  Returns a list of tuples with information about miscellaneous allocated memory areas.

                  Each  tuple  contains an atom describing the type of memory as first element and the amount of
                  allocated memory in bytes as second element. When information about allocated and used  memory
                  is present, also a third element is present, containing the amount of used memory in bytes.

                  <u>erlang:system_info(allocated_areas)</u>  is  intended  for  debugging,  and  the content is highly
                  implementation-dependent. The content of the results therefore  changes  when  needed  without
                  prior notice.

                  Notice  that  the  sum  of  these  values  is  <u>not</u> the total amount of memory allocated by the
                  emulator. Some values are part of other values, and some memory areas  are  not  part  of  the
                  result.  For  information  about  the  total  amount  of memory allocated by the emulator, see
                  <u>erlang:memory/0,1</u>.

                <u>allocator</u>:
                  Returns <u>{Allocator,</u> <u>Version,</u> <u>Features,</u> <u>Settings</u>, where:

                  * <u>Allocator</u> corresponds to the <u>malloc()</u> implementation used. If  <u>Allocator</u>  equals  <u>undefined</u>,
                    the <u>malloc()</u> implementation used cannot be identified. <u>glibc</u> can be identified.

                  * <u>Version</u>  is  a  list of integers (but not a string) representing the version of the <u>malloc()</u>
                    implementation used.

                  * <u>Features</u> is a list of atoms representing the allocation features used.

                  * <u>Settings</u> is a list of subsystems, their configurable parameters, and used  values.  Settings
                    can differ between different combinations of platforms, allocators, and allocation features.
                    Memory sizes are given in bytes.

                  See also "System Flags Effecting erts_alloc" in <u><a href="../man3erl/erts_alloc.3erl.html">erts_alloc</a>(3erl)</u>.

                <u>{allocator,</u> <u>Alloc}</u>:
                  Returns  information  about the specified allocator. As from ERTS 5.6.1, the return value is a
                  list of <u>{instance,</u> <u>InstanceNo,</u> <u>InstanceInfo}</u> tuples, where <u>InstanceInfo</u>  contains  information
                  about  a specific instance of the allocator. If <u>Alloc</u> is not a recognized allocator, <u>undefined</u>
                  is returned. If <u>Alloc</u> is disabled, <u>false</u> is returned.

                  Notice that the information returned is highly implementation-dependent and can be changed  or
                  removed  at any time without prior notice. It was initially intended as a tool when developing
                  new allocators, but as it can be of interest for others it has been briefly documented.

                  The recognized allocators are listed in <u><a href="../man3erl/erts_alloc.3erl.html">erts_alloc</a>(3erl)</u>. Information about super carriers can
                  be obtained from ERTS 8.0 with <u>{allocator,</u> <u>erts_mmap}</u> or from ERTS 5.10.4; the  returned  list
                  when calling with <u>{allocator,</u> <u>mseg_alloc}</u> also includes an <u>{erts_mmap,</u> <b>_</b><u>}</u> tuple as one element
                  in the list.

                  After reading the <u><a href="../man3erl/erts_alloc.3erl.html">erts_alloc</a>(3erl)</u> documentation, the returned information more or less speaks
                  for  itself,  but  it  can  be  worth explaining some things. Call counts are presented by two
                  values, the first value is giga calls, and the second value is calls.  <u>mbcs</u>  and  <u>sbcs</u>  denote
                  multi-block  carriers,  and single-block carriers, respectively. Sizes are presented in bytes.
                  When a size is not presented, it is the amount of  something.  Sizes  and  amounts  are  often
                  presented by three values:

                  * The first is the current value.

                  * The  second  is  the  maximum  value  since  the last call to <u>erlang:system_info({allocator,</u>
                    <u>Alloc})</u>.

                  * The third is the maximum value since the emulator was started.

                  If only one value is present, it is the  current  value.  <u>fix_alloc</u>  memory  block  types  are
                  presented  by  two values. The first value is the memory pool size and the second value is the
                  used memory size.

                <u>alloc_util_allocators</u>:
                  Returns a list of the names of all allocators using the ERTS internal <u>alloc_util</u> framework  as
                  atoms. For more information, see section The alloc_util framework in <u><a href="../man3erl/erts_alloc.3erl.html">erts_alloc</a>(3erl)</u>.

                <u>{allocator_sizes,</u> <u>Alloc}</u>:
                  Returns  various  size  information for the specified allocator. The information returned is a
                  subset of the information returned by <u>erlang:system_info({allocator,</u> <u>Alloc})</u>.

       <b>erlang:system_info(Item</b> <b>::</b> <b>cpu_topology)</b> <b>-&gt;</b> <b>CpuTopology</b>

       <b>erlang:system_info(Item</b> <b>::</b>
                              {cpu_topology, defined | detected | used}) -&gt;
                             CpuTopology

       <b>erlang:system_info(Item</b> <b>::</b>
                              logical_processors |
                              logical_processors_available |
                              logical_processors_online) -&gt;
                             unknown | integer() &gt;= 1

       <b>erlang:system_info(Item</b> <b>::</b> <b>trace_control_word)</b> <b>-&gt;</b>
                             integer() &gt;= 0

              Types:

                 <b>cpu_topology()</b> = [LevelEntry :: level_entry()] | undefined
                    All <u>LevelEntry</u>s of a list must contain the same <u>LevelTag</u>, except on the top level where both
                   <u>node</u> and <u>processorLevelTag</u>s can coexist.
                 <b>level_entry()</b> =
                     {LevelTag :: level_tag(), SubLevel :: sub_level()} |
                     {LevelTag :: level_tag(),
                      InfoList :: info_list(),
                      SubLevel :: sub_level()}
                   <u>{LevelTag,</u> <u>SubLevel}</u> <u>==</u> <u>{LevelTag,</u> <u>[],</u> <u>SubLevel}</u>
                 <b>level_tag()</b> = core | node | processor | thread
                    More <u>LevelTag</u>s can be introduced in a future release.
                 <b>sub_level()</b> =
                     [LevelEntry :: level_entry()] |
                     (LogicalCpuId :: {logical, integer() &gt;= 0})
                 <b>info_list()</b> = []
                    The <u>info_list()</u> can be extended in a future release.

              Returns various information about the CPU topology of the current system (emulator)  as  specified
              by <u>Item</u>:

                <u>cpu_topology</u>:
                  Returns  the <u>CpuTopology</u> currently used by the emulator. The CPU topology is used when binding
                  schedulers to logical processors. The CPU topology used is the  user-defined CPU topology,  if
                  such  exists,  otherwise  the   automatically detected CPU topology, if such exists. If no CPU
                  topology exists, <u>undefined</u> is returned.

                  <u>node</u> refers to Non-Uniform Memory Access (NUMA) nodes. <u>thread</u> refers to hardware threads  (for
                  example, Intel hyper-threads).

                  A level in term <u>CpuTopology</u> can be omitted if only one entry exists and <u>InfoList</u> is empty.

                  <u>thread</u>  can only be a sublevel to <u>core</u>. <u>core</u> can be a sublevel to <u>processor</u> or <u>node</u>. <u>processor</u>
                  can be on the top level or a sublevel to <u>node</u>. <u>node</u> can be on the top level or a  sublevel  to
                  <u>processor</u>. That is, NUMA nodes can be processor internal or processor external. A CPU topology
                  can  consist  of  a mix of processor internal and external NUMA nodes, as long as each logical
                  CPU belongs to <u>one</u> NUMA node. Cache hierarchy is not part of the <u>CpuTopology</u> type, but will be
                  in a future release. Other things can also make it into the CPU topology in a future  release.
                  So, expect the <u>CpuTopology</u> type to change.

                <u>{cpu_topology,</u> <u>defined}</u>:

                  Returns  the  user-defined  <u>CpuTopology</u>.  For  more information, see command-line flag <u>+sct</u> in
                  <u><a href="../man1/erl.1.html">erl</a>(1)</u> and argument <u>cpu_topology</u>.

                <u>{cpu_topology,</u> <u>detected}</u>:

                  Returns the automatically detected <u>CpuTopologyy</u>. The emulator detects the CPU topology on some
                  newer Linux, Solaris, FreeBSD, and Windows systems.  On  Windows  system  with  more  than  32
                  logical processors, the CPU topology is not detected.

                  For more information, see argument <u>cpu_topology</u>.

                <u>{cpu_topology,</u> <u>used}</u>:
                  Returns <u>CpuTopology</u> used by the emulator. For more information, see argument <u>cpu_topology</u>.

                <u>logical_processors</u>:
                  Returns  the  detected number of logical processors configured in the system. The return value
                  is either an integer, or the atom <u>unknown</u> if the emulator cannot detect the configured logical
                  processors.

                <u>logical_processors_available</u>:
                  Returns the detected number of logical processors available to the Erlang runtime system.  The
                  return  value  is  either  an  integer,  or the atom <u>unknown</u> if the emulator cannot detect the
                  available logical processors. The number of available logical processors is less than or equal
                  to the number of  logical processors online.

                <u>logical_processors_online</u>:
                  Returns the detected number of logical processors online on the system. The  return  value  is
                  either  an  integer,  or  the  atom  <u>unknown</u>  if the emulator cannot detect logical processors
                  online. The number of logical processors online is less than or equal to the number of logical
                  processors configured.

                <u>cpu_quota</u>:
                  Returns the detected CPU quota the emulator is limited by. The  return  value  is  an  integer
                  saying  how  many  processors'  worth  of  runtime we get (between 1 and the number of logical
                  processors), or the atom <u>unknown</u> if the emulator cannot detect a quota.

                <u>update_cpu_info</u>:
                  The runtime system rereads the CPU information available and  updates  its  internally  stored
                  information  about  the detected CPU topology and the number of logical processors configured,
                  online, available, and cpu quota.

                  If the CPU information has changed since the last time  it  was  read,  the  atom  <u>changed</u>  is
                  returned,  otherwise the atom <u>unchanged</u>. If the CPU information has changed, you probably want
                  to adjust the number of schedulers online. You typically  want  to  have  as  many  schedulers
                  online as logical processors available.

       <b>erlang:system_info(Item</b> <b>::</b> <b>fullsweep_after)</b> <b>-&gt;</b>
                             {fullsweep_after, integer() &gt;= 0}

       <b>erlang:system_info(Item</b> <b>::</b> <b>garbage_collection)</b> <b>-&gt;</b>
                             [{atom(), integer()}]

       <b>erlang:system_info(Item</b> <b>::</b> <b>heap_sizes)</b> <b>-&gt;</b> <b>[integer()</b> <b>&gt;=</b> <b>0]</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>heap_type)</b> <b>-&gt;</b> <b>private</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>max_heap_size)</b> <b>-&gt;</b>
                             {max_heap_size,
                              MaxHeapSize :: max_heap_size()}

       <b>erlang:system_info(Item</b> <b>::</b> <b>message_queue_data)</b> <b>-&gt;</b>
                             message_queue_data()

       <b>erlang:system_info(Item</b> <b>::</b> <b>min_heap_size)</b> <b>-&gt;</b>
                             {min_heap_size,
                              MinHeapSize :: integer() &gt;= 1}

       <b>erlang:system_info(Item</b> <b>::</b> <b>min_bin_vheap_size)</b> <b>-&gt;</b>
                             {min_bin_vheap_size,
                              MinBinVHeapSize :: integer() &gt;= 1}

       <b>erlang:system_info(Item</b> <b>::</b> <b>process_limit)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>1</b>

              Types:

                 <b>message_queue_data()</b> = off_heap | on_heap
                 <b>max_heap_size()</b> =
                     integer() &gt;= 0 |
                     #{size =&gt; integer() &gt;= 0,
                       kill =&gt; boolean(),
                       error_logger =&gt; boolean()}

              Returns information about the default process heap settings:

                <u>fullsweep_after</u>:
                  Returns  <u>{fullsweep_after,</u>  <u>integer()</u>  <u>&gt;=</u>  <u>0}</u>, which is the <u>fullsweep_after</u> garbage collection
                  setting used by default. For more information, see <u>garbage_collection</u> described below.

                <u>garbage_collection</u>:
                  Returns a list describing the default garbage collection settings. A process  spawned  on  the
                  local  node  by  a  <u>spawn</u>  or  <u>spawn_link</u>  uses these garbage collection settings. The default
                  settings can be changed by using <u>erlang:system_flag/2</u>. <u>spawn_opt/2,3,4</u>  can  spawn  a  process
                  that does not use the default settings.

                <u>heap_sizes</u>:
                  Returns  a list of integers representing valid heap sizes in words. All Erlang heaps are sized
                  from sizes in this list.

                <u>heap_type</u>:
                  Returns the heap type used by the current emulator. One heap type exists:

                  <u>private</u>:
                     Each process has a heap reserved for its use and no references between heaps  of  different
                    processes are allowed. Messages passed between processes are copied between heaps.

                <u>max_heap_size</u>:
                  Returns  <u>{max_heap_size,</u>  <u>MaxHeapSize}</u>,  where  <u>MaxHeapSize</u> is the current system-wide maximum
                  heap size settings for spawned processes. This setting can be set using the command-line flags
                  <u>+hmax</u>,  <u>+hmaxk</u>  and  <u>+hmaxel</u>  in  <u><a href="../man1/erl.1.html">erl</a>(1)</u>.  It  can  also   be   changed   at   runtime   using
                  <u>erlang:system_flag(max_heap_size,</u>  <u>MaxHeapSize)</u>.  For  more  details  about  the <u>max_heap_size</u>
                  process flag, see <u>process_flag(max_heap_size,</u> <u>MaxHeapSize)</u>.

                <u>message_queue_data</u>:
                  Returns the default value of the <u>message_queue_data</u> process flag, which can be either <u>off_heap</u>
                  or <u>on_heap</u>. The default value is set by the command-line argument <u>+hmqd</u> in  <u><a href="../man1/erl.1.html">erl</a>(1)</u>.  For  more
                  information, see the documentation of <u>process_flag(message_queue_data,</u> <u>MQD)</u>.

                <u>min_heap_size</u>:
                  Returns  <u>{min_heap_size,</u>  <u>MinHeapSize}</u>,  where  <u>MinHeapSize</u> is the current system-wide minimum
                  heap size for spawned processes.

                <u>min_bin_vheap_size</u>:
                  Returns <u>{min_bin_vheap_size,</u> <u>MinBinVHeapSize}</u>, where <u>MinBinVHeapSize</u> is  the  current  system-
                  wide minimum binary virtual heap size for spawned processes.

                <u>procs</u>:
                  Returns  a  binary  containing a string of process and port information formatted as in Erlang
                  crash dumps. For more information, see section  How to interpret the Erlang crash dumps in the
                  User's Guide.

       <b>erlang:system_info(Item</b> <b>::</b> <b>atom_count)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>1</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>atom_limit)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>1</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>ets_count)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>1</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>ets_limit)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>1</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>port_parallelism)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>port_count)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>port_limit)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>1</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>process_count)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>1</b>

              Returns information about the current system (emulator) limits as specified by <u>Item</u>:

                <u>atom_count</u>:
                  Returns the number of atoms currently existing at the local node. The value  is  given  as  an
                  integer.

                <u>atom_limit</u>:
                  Returns the maximum number of atoms allowed. This limit can be increased at startup by passing
                  command-line flag <u>+t</u> to <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>ets_count</u>:
                  Returns the number of ETS tables currently existing at the local node.

                <u>ets_limit</u>:
                  Returns  the  limit  for  number of ETS tables. This limit is partially obsolete and number of
                  tables are only limited by available memory.

                <u>port_count</u>:
                  Returns the number of ports currently existing at the local node. The value  is  given  as  an
                  integer. This is the same value as returned by <u>length(erlang:ports())</u>, but more efficient.

                <u>port_limit</u>:
                  Returns  the  maximum number of simultaneously existing ports at the local node as an integer.
                  This limit can be configured at startup by using command-line flag <u>+Q</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>process_count</u>:
                  Returns the number of processes currently existing at the local node. The value is given as an
                  integer. This is the same value as returned by <u>length(processes())</u>, but more efficient.

                <u>process_limit</u>:
                  Returns the maximum number of simultaneously existing processes at the local node.  The  value
                  is  given as an integer. This limit can be configured at startup by using command-line flag <u>+P</u>
                  in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

       <b>erlang:system_info(Item</b> <b>::</b> <b>end_time)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>os_monotonic_time_source)</b> <b>-&gt;</b>
                             [{atom(), term()}]

       <b>erlang:system_info(Item</b> <b>::</b> <b>os_system_time_source)</b> <b>-&gt;</b>
                             [{atom(), term()}]

       <b>erlang:system_info(Item</b> <b>::</b> <b>smp_support)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>thread_pool_size)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>time_correction)</b> <b>-&gt;</b> <b>true</b> <b>|</b> <b>false</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>time_offset)</b> <b>-&gt;</b>
                             preliminary | final | volatile

       <b>erlang:system_info(Item</b> <b>::</b> <b>time_warp_mode)</b> <b>-&gt;</b>
                             no_time_warp | single_time_warp |
                             multi_time_warp

              Returns information about the current system (emulator) time as specified by <u>Item</u>:

                <u>end_time</u>:
                  The last Erlang monotonic time in <u>native</u> time unit that can be represented internally  in  the
                  current Erlang runtime system instance. The time between the start time and the end time is at
                  least a quarter of a millennium.

                <u>os_monotonic_time_source</u>:
                  Returns  a  list  containing information about the source of OS monotonic time that is used by
                  the runtime system.

                  If <u>[]</u> is returned, no OS monotonic time is available. The list contains two-tuples  with  <u>Key</u>s
                  as  first  element,  and <u>Value</u>s as second element. The order of these tuples is undefined. The
                  following tuples can be part of the list, but more tuples can be introduced in the future:

                  <u>{function,</u> <u>Function}</u>:
                    <u>Function</u> is the name of the function used. This tuple always exists if OS monotonic time  is
                    available to the runtime system.

                  <u>{clock_id,</u> <u>ClockId}</u>:
                    This tuple only exists if <u>Function</u> can be used with different clocks. <u>ClockId</u> corresponds to
                    the clock identifier used when calling <u>Function</u>.

                  <u>{resolution,</u> <u>OsMonotonicTimeResolution}</u>:
                    Highest  possible  resolution of current OS monotonic time source as parts per second. If no
                    resolution information can be retrieved from the OS, <u>OsMonotonicTimeResolution</u> is set to the
                    resolution of the time unit of <u>Function</u>s return value. That is, the actual resolution can be
                    lower than <u>OsMonotonicTimeResolution</u>. Notice that the resolution does not say anything about
                    the  accuracy or whether the  precision aligns with the resolution. You  do,  however,  know
                    that the precision is not better than <u>OsMonotonicTimeResolution</u>.

                  <u>{extended,</u> <u>Extended}</u>:
                    <u>Extended</u> equals <u>yes</u> if the range of time values has been extended; otherwise <u>Extended</u> equals
                    <u>no</u>.  The range must be extended if <u>Function</u> returns values that wrap fast. This typically is
                    the case when the return value is a 32-bit value.

                  <u>{parallel,</u> <u>Parallel}</u>:
                    <u>Parallel</u> equals <u>yes</u> if <u>Function</u> is called in parallel from multiple threads. If  it  is  not
                    called in parallel, because calls must be serialized, <u>Parallel</u> equals <u>no</u>.

                  <u>{time,</u> <u>OsMonotonicTime}</u>:
                    <u>OsMonotonicTime</u> equals current OS monotonic time in <u>native</u> time unit.

                <u>os_system_time_source</u>:
                  Returns  a  list containing information about the source of OS system time that is used by the
                  runtime system.

                  The list contains two-tuples with <u>Key</u>s as first element, and <u>Value</u>s  as  second  element.  The
                  order  of  these  tuples  is undefined. The following tuples can be part of the list, but more
                  tuples can be introduced in the future:

                  <u>{function,</u> <u>Function}</u>:
                    <u>Function</u> is the name of the funcion used.

                  <u>{clock_id,</u> <u>ClockId}</u>:
                    Exists only if <u>Function</u> can be used with different clocks. <u>ClockId</u> corresponds to the  clock
                    identifier used when calling <u>Function</u>.

                  <u>{resolution,</u> <u>OsSystemTimeResolution}</u>:
                    Highest  possible   resolution  of  current OS system time source as parts per second. If no
                    resolution information can be retrieved from the OS, <u>OsSystemTimeResolution</u> is  set  to  the
                    resolution of the time unit of <u>Function</u>s return value. That is, the actual resolution can be
                    lower  than  <u>OsSystemTimeResolution</u>.  Notice that the resolution does not say anything about
                    the  accuracy or whether the  precision do align with the resolution. You do, however,  know
                    that the precision is not better than <u>OsSystemTimeResolution</u>.

                  <u>{parallel,</u> <u>Parallel}</u>:
                    <u>Parallel</u>  equals  <u>yes</u>  if <u>Function</u> is called in parallel from multiple threads. If it is not
                    called in parallel, because calls needs to be serialized, <u>Parallel</u> equals <u>no</u>.

                  <u>{time,</u> <u>OsSystemTime}</u>:
                    <u>OsSystemTime</u> equals current OS system time in <u>native</u> time unit.

                <u>start_time</u>:
                  The Erlang monotonic time in <u>native</u> time unit at the time when current Erlang  runtime  system
                  instance started.

                  See also <u>erlang:system_info(end_time)</u>.

                <u>time_correction</u>:
                  Returns a boolean value indicating whether  time correction is enabled or not.

                <u>time_offset</u>:
                  Returns the state of the time offset:

                  <u>preliminary</u>:
                    The  time  offset  is  preliminary, and will be changed and finalized later. The preliminary
                    time offset is used during the preliminary phase of the  single time warp mode.

                  <u>final</u>:
                    The time offset is final. This either because  no time warp mode is  used,  or  because  the
                    time offset have been finalized when  single time warp mode is used.

                  <u>volatile</u>:
                    The time offset is volatile. That is, it can change at any time. This is because  multi-time
                    warp mode is used.

                <u>time_warp_mode</u>:
                  Returns a value identifying the  time warp mode that is used:

                  <u>no_time_warp</u>:
                    The  no time warp mode is used.

                  <u>single_time_warp</u>:
                    The  single time warp mode is used.

                  <u>multi_time_warp</u>:
                    The  multi-time warp mode is used.

                <u>tolerant_timeofday</u>:
                  Returns  whether a pre ERTS 7.0 backwards compatible compensation for sudden changes of system
                  time is <u>enabled</u> or <u>disabled</u>. Such compensation is <u>enabled</u> when the time offset is  <u>final</u>,  and
                  time correction is enabled.

       <b>erlang:system_info(Item</b> <b>::</b> <b>dirty_cpu_schedulers)</b> <b>-&gt;</b>
                             integer() &gt;= 0

       <b>erlang:system_info(Item</b> <b>::</b> <b>dirty_cpu_schedulers_online)</b> <b>-&gt;</b>
                             integer() &gt;= 0

       <b>erlang:system_info(Item</b> <b>::</b> <b>dirty_io_schedulers)</b> <b>-&gt;</b>
                             integer() &gt;= 0

       <b>erlang:system_info(Item</b> <b>::</b> <b>multi_scheduling)</b> <b>-&gt;</b>
                             disabled | blocked | blocked_normal |
                             enabled

       <b>erlang:system_info(Item</b> <b>::</b> <b>multi_scheduling_blockers)</b> <b>-&gt;</b>
                             [Pid :: pid()]

       <b>erlang:system_info(Item</b> <b>::</b> <b>normal_multi_scheduling_blockers)</b> <b>-&gt;</b>
                             [Pid :: pid()]

       <b>erlang:system_info(Item</b> <b>::</b> <b>procs)</b> <b>-&gt;</b> <b>binary()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>scheduler_bind_type)</b> <b>-&gt;</b>
                             spread | processor_spread | thread_spread |
                             thread_no_node_processor_spread |
                             no_node_processor_spread |
                             no_node_thread_spread | no_spread | unbound

       <b>erlang:system_info(Item</b> <b>::</b> <b>scheduler_bindings)</b> <b>-&gt;</b> <b>tuple()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>scheduler_id)</b> <b>-&gt;</b>
                             SchedulerId :: integer() &gt;= 1

       <b>erlang:system_info(Item</b> <b>::</b> <b>schedulers</b> <b>|</b> <b>schedulers_online)</b> <b>-&gt;</b>
                             integer() &gt;= 1

       <b>erlang:system_info(Item</b> <b>::</b> <b>system_version)</b> <b>-&gt;</b> <b>string()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>threads)</b> <b>-&gt;</b> <b>boolean()</b>

              Returns information about schedulers, scheduling and threads in the current system as specified by
              <u>Item</u>:

                <u>dirty_cpu_schedulers</u>:
                  Returns  the  number of dirty CPU scheduler threads used by the emulator. Dirty CPU schedulers
                  execute CPU-bound native functions, such as NIFs, linked-in driver code, and BIFs that  cannot
                  be managed cleanly by the normal emulator schedulers.

                  The  number  of  dirty CPU scheduler threads is determined at emulator boot time and cannot be
                  changed after that. However, the number of dirty CPU scheduler threads online can  be  changed
                  at  any time. The number of dirty CPU schedulers can be set at startup by passing command-line
                  flag <u>+SDcpu</u> or <u>+SDPcpu</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                  See    also     <u>erlang:system_flag(dirty_cpu_schedulers_online,</u>     <u>DirtyCPUSchedulersOnline)</u>,
                  <u>erlang:system_info(dirty_cpu_schedulers_online)</u>,      <u>erlang:system_info(dirty_io_schedulers)</u>,
                  <u>erlang:system_info(schedulers)</u>,           <u>erlang:system_info(schedulers_online)</u>,           and
                  <u>erlang:system_flag(schedulers_online,</u> <u>SchedulersOnline)</u>.

                <u>dirty_cpu_schedulers_online</u>:
                  Returns  the  number  of  dirty  CPU  schedulers  online.  The  return  value  satisfies  <u>1</u> <u>&lt;=</u>
                  <u>DirtyCPUSchedulersOnline</u>  <u>&lt;=</u>  <u>N</u>,  where  <u>N</u>  is  the  smallest  of   the   return   values   of
                  <u>erlang:system_info(dirty_cpu_schedulers)</u> and <u>erlang:system_info(schedulers_online)</u>.

                  The  number  of dirty CPU schedulers online can be set at startup by passing command-line flag
                  <u>+SDcpu</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                  For       more        information,        see        <u>erlang:system_info(dirty_cpu_schedulers)</u>,
                  <u>erlang:system_info(dirty_io_schedulers)</u>,       <u>erlang:system_info(schedulers_online)</u>,      and
                  <u>erlang:system_flag(dirty_cpu_schedulers_online,</u> <u>DirtyCPUSchedulersOnline)</u>.

                <u>dirty_io_schedulers</u>:
                  Returns the number of dirty I/O schedulers as an integer. Dirty I/O  schedulers  execute  I/O-
                  bound  native  functions,  such  as  NIFs  and  linked-in driver code, which cannot be managed
                  cleanly by the normal emulator schedulers.

                  This value can be set at startup by passing command-line argument <u>+SDio</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                  For       more        information,        see        <u>erlang:system_info(dirty_cpu_schedulers)</u>,
                  <u>erlang:system_info(dirty_cpu_schedulers_online)</u>,                                           and
                  <u>erlang:system_flag(dirty_cpu_schedulers_online,</u> <u>DirtyCPUSchedulersOnline)</u>.

                <u>multi_scheduling</u>:
                  Returns one of the following:

                  <u>disabled</u>:
                    The emulator has been started with only one scheduler thread.

                  <u>blocked</u>:
                    The emulator has more than one scheduler thread, but all scheduler threads  except  one  are
                    blocked.  That  is, only one scheduler thread schedules Erlang processes and executes Erlang
                    code.

                  <u>blocked_normal</u>:
                    The emulator has more than one scheduler thread, but all normal scheduler threads except one
                    are blocked. Notice that dirty schedulers are not blocked, and can schedule Erlang processes
                    and execute native code.

                  <u>enabled</u>:
                    The emulator has more than one scheduler thread, and no scheduler threads are blocked.  That
                    is, all available scheduler threads schedule Erlang processes and execute Erlang code.

                  See             also             <u>erlang:system_flag(multi_scheduling,</u>             <u>BlockState)</u>,
                  <u>erlang:<a href="../manmulti_scheduling_blockers/system_info.multi_scheduling_blockers.html">system_info</a>(multi_scheduling_blockers)</u>,
                  <u>erlang:system_info(normal_multi_scheduling_blockers)</u>, and <u>erlang:system_info(schedulers)</u>.

                <u>multi_scheduling_blockers</u>:
                  Returns a list of <u>Pid</u>s when multi-scheduling is blocked, otherwise the empty list is returned.
                  The <u>Pid</u>s in the list represent all the processes currently blocking  multi-scheduling.  A  <u>Pid</u>
                  occurs only once in the list, even if the corresponding process has blocked multiple times.

                  See             also             <u>erlang:system_flag(multi_scheduling,</u>             <u>BlockState)</u>,
                  <u>erlang:<a href="../manmulti_scheduling/system_info.multi_scheduling.html">system_info</a>(multi_scheduling)</u>,    <u>erlang:system_info(normal_multi_scheduling_blockers)</u>,
                  and <u>erlang:system_info(schedulers)</u>.

                <u>normal_multi_scheduling_blockers</u>:
                  Returns a list of <u>Pid</u>s when normal multi-scheduling is blocked (that is, all normal schedulers
                  but  one is blocked), otherwise the empty list is returned. The <u>Pid</u>s in the list represent all
                  the processes currently blocking normal multi-scheduling. A <u>Pid</u> occurs only once in the  list,
                  even if the corresponding process has blocked multiple times.

                  See             also             <u>erlang:system_flag(multi_scheduling,</u>             <u>BlockState)</u>,
                  <u>erlang:<a href="../manmulti_scheduling/system_info.multi_scheduling.html">system_info</a>(multi_scheduling)</u>,    <u>erlang:<a href="../manmulti_scheduling_blockers/system_info.multi_scheduling_blockers.html">system_info</a>(multi_scheduling_blockers)</u>,    and
                  <u>erlang:system_info(schedulers)</u>.

                <u>scheduler_bind_type</u>:
                  Returns information about how the user has requested schedulers to be bound or not bound.

                  Notice  that  although  a  user  has  requested schedulers to be bound, they can silently have
                  failed     to      bind.      To      inspect      the      scheduler      bindings,      call
                  <u>erlang:system_info(scheduler_bindings)</u>.

                  For     more    information,    see    command-line    argument    <u>+sbt</u>    in    <u><a href="../man1/erl.1.html">erl</a>(1)</u>    and
                  <u>erlang:system_info(scheduler_bindings)</u>.

                <u>scheduler_bindings</u>:
                  Returns information about the currently used scheduler bindings.

                  A tuple of a size equal to <u>erlang:system_info(schedulers)</u> is returned. The tuple elements  are
                  integers  or  the atom <u>unbound</u>. Logical processor identifiers are represented as integers. The
                  <u>N</u>th element of the tuple equals the current binding  for  the  scheduler  with  the  scheduler
                  identifier    equal    to    <u>N</u>.    For    example,    if    the    schedulers    are    bound,
                  <u>element(erlang:system_info(scheduler_id),</u> <u>erlang:system_info(scheduler_bindings))</u> returns  the
                  identifier of the logical processor that the calling process is executing on.

                  Notice that only schedulers online can be bound to logical processors.

                  For     more    information,    see    command-line    argument    <u>+sbt</u>    in    <u><a href="../man1/erl.1.html">erl</a>(1)</u>    and
                  <u>erlang:system_info(schedulers_online)</u>.

                <u>scheduler_id</u>:
                  Returns the scheduler ID (<u>SchedulerId</u>) of the scheduler thread that  the  calling  process  is
                  executing   on.   <u>SchedulerId</u>   is   a   positive   integer,   where   <u>1</u>   <u>&lt;=</u>  <u>SchedulerId</u>  <u>&lt;=</u>
                  <u>erlang:system_info(schedulers)</u>.

                  See also <u>erlang:system_info(schedulers)</u>.

                <u>schedulers</u>:
                  Returns the number of scheduler  threads  used  by  the  emulator.  Scheduler  threads  online
                  schedules  Erlang  processes  and  Erlang  ports, and execute Erlang code and Erlang linked-in
                  driver code.

                  The number of scheduler threads is determined at emulator boot  time  and  cannot  be  changed
                  later. However, the number of schedulers online can be changed at any time.

                  See           also           <u>erlang:system_flag(schedulers_online,</u>          <u>SchedulersOnline)</u>,
                  <u>erlang:system_info(schedulers_online)</u>,                       <u>erlang:system_info(scheduler_id)</u>,
                  <u>erlang:system_flag(multi_scheduling,</u>     <u>BlockState)</u>,    <u>erlang:<a href="../manmulti_scheduling/system_info.multi_scheduling.html">system_info</a>(multi_scheduling)</u>,
                  <u>erlang:system_info(normal_multi_scheduling_blockers)</u>                                       and
                  <u>erlang:<a href="../manmulti_scheduling_blockers/system_info.multi_scheduling_blockers.html">system_info</a>(multi_scheduling_blockers)</u>.

                <u>schedulers_online</u>:
                  Returns  the  number  of  schedulers  online.  The  scheduler identifiers of schedulers online
                  satisfy the relationship <u>1</u> <u>&lt;=</u> <u>SchedulerId</u> <u>&lt;=</u> <u>erlang:system_info(schedulers_online)</u>.

                  For       more        information,        see        <u>erlang:system_info(schedulers)</u>        and
                  <u>erlang:system_flag(schedulers_online,</u> <u>SchedulersOnline)</u>.

                <u>smp_support</u>:
                  Returns <u>true</u>.

                <u>threads</u>:
                  Returns <u>true</u>.

                <u>thread_pool_size</u>:

                  Returns  the  number  of  async  threads in the async thread pool used for asynchronous driver
                  calls (<u>erl_driver:driver_async()</u>). The value is given as an integer.

       <b>erlang:system_info(Item</b> <b>::</b> <b>creation)</b> <b>-&gt;</b> <b>integer()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>delayed_node_table_gc)</b> <b>-&gt;</b>
                             infinity | integer() &gt;= 0

       <b>erlang:system_info(Item</b> <b>::</b> <b>dist)</b> <b>-&gt;</b> <b>binary()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>dist_buf_busy_limit)</b> <b>-&gt;</b>
                             integer() &gt;= 0

       <b>erlang:system_info(Item</b> <b>::</b> <b>dist_ctrl)</b> <b>-&gt;</b>
                             {Node :: node(),
                              ControllingEntity :: port() | pid()}

              Returns information about Erlang Distribution in the current system as specified by <u>Item</u>:

                <u>creation</u>:
                  Returns the creation of the local node as an integer. The creation is changed when a  node  is
                  restarted.  The  creation  of  a  node is stored in process identifiers, port identifiers, and
                  references. This makes it (to some extent) possible to distinguish  between  identifiers  from
                  different incarnations of a node. The valid creations are integers in the range 1..3, but this
                  will probably change in a future release. If the node is not alive, <u>0</u> is returned.

                <u>delayed_node_table_gc</u>:
                  Returns  the  amount  of  time  in  seconds  garbage collection of an entry in a node table is
                  delayed. This limit can be set on startup by passing command-line flag <u>+zdntgc</u> to <u><a href="../man1/erl.1.html">erl</a>(1)</u>.  For
                  more information, see the documentation of the command-line flag.

                <u>dist</u>:
                  Returns  a binary containing a string of distribution information formatted as in Erlang crash
                  dumps. For more information, see section  How to interpret  the  Erlang  crash  dumps  in  the
                  User's Guide.

                <u>dist_buf_busy_limit</u>:
                  Returns  the  value  of  the distribution buffer busy limit in bytes. This limit can be set at
                  startup by passing command-line flag <u>+zdbbl</u> to <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>dist_ctrl</u>:
                  Returns a list of tuples <u>{Node,</u> <u>ControllingEntity}</u>, one entry for each connected remote  node.
                  <u>Node</u>  is the node name and <u>ControllingEntity</u> is the port or process identifier responsible for
                  the communication to that node.  More  specifically,  <u>ControllingEntity</u>  for  nodes  connected
                  through TCP/IP (the normal case) is the socket used in communication with the specific node.

       <b>erlang:system_info(Item</b> <b>::</b> <b>c_compiler_used)</b> <b>-&gt;</b> <b>{atom(),</b> <b>term()}</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>check_io)</b> <b>-&gt;</b> <b>[term()]</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>compat_rel)</b> <b>-&gt;</b> <b>integer()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>debug_compiled)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>driver_version)</b> <b>-&gt;</b> <b>string()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>dynamic_trace)</b> <b>-&gt;</b>
                             none | dtrace | systemtap

       <b>erlang:system_info(Item</b> <b>::</b> <b>dynamic_trace_probes)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>emu_flavor)</b> <b>-&gt;</b> <b>emu</b> <b>|</b> <b>jit</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>emu_type)</b> <b>-&gt;</b>
                             opt | debug | gcov | valgrind | gprof |
                             lcnt | frmptr

       <b>erlang:system_info(Item</b> <b>::</b> <b>info)</b> <b>-&gt;</b> <b>binary()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>kernel_poll)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>loaded)</b> <b>-&gt;</b> <b>binary()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>machine)</b> <b>-&gt;</b> <b>string()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>modified_timing_level)</b> <b>-&gt;</b>
                             integer() | undefined

       <b>erlang:system_info(Item</b> <b>::</b> <b>nif_version)</b> <b>-&gt;</b> <b>string()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>otp_release)</b> <b>-&gt;</b> <b>string()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>outstanding_system_requests_limit)</b> <b>-&gt;</b>
                             1..134217727

       <b>erlang:system_info(Item</b> <b>::</b> <b>port_parallelism)</b> <b>-&gt;</b> <b>boolean()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>system_architecture)</b> <b>-&gt;</b> <b>string()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>system_logger)</b> <b>-&gt;</b>
                             logger | undefined | pid()

       <b>erlang:system_info(Item</b> <b>::</b> <b>system_version)</b> <b>-&gt;</b> <b>string()</b>

       <b>erlang:system_info(Item</b> <b>::</b> <b>trace_control_word)</b> <b>-&gt;</b>
                             integer() &gt;= 0

       <b>erlang:system_info(Item</b> <b>::</b> <b>version)</b> <b>-&gt;</b> <b>string()</b>

       <b>erlang:system_info(Item</b> <b>::</b>
                              wordsize |
                              {wordsize, internal} |
                              {wordsize, external}) -&gt;
                             4 | 8

              Returns various information about the current system (emulator) as specified by <u>Item</u>:

                <u>build_type</u>:
                  Deprecated, use emu_type instead

                <u>c_compiler_used</u>:
                  Returns  a  two-tuple  describing  the  C compiler used when compiling the runtime system. The
                  first element is an atom describing the name of the compiler, or  <u>undefined</u>  if  unknown.  The
                  second element is a term describing the version of the compiler, or <u>undefined</u> if unknown.

                <u>check_io</u>:
                  Returns a list containing miscellaneous information about the emulators internal I/O checking.
                  Notice  that  the content of the returned list can vary between platforms and over time. It is
                  only guaranteed that a list is returned.

                <u>compat_rel</u>:
                  Returns the compatibility mode  of  the  local  node  as  an  integer.  The  integer  returned
                  represents  the  Erlang/OTP  release  that  the  current  emulator has been set to be backward
                  compatible with. The compatibility mode can be configured at  startup  by  using  command-line
                  flag <u>+R</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>debug_compiled</u>:
                  Returns <u>true</u> if the emulator has been debug-compiled, otherwise <u>false</u>.

                <u>driver_version</u>:
                  Returns  a  string containing the Erlang driver version used by the runtime system. It has the
                  form  "&lt;major ver&gt;.&lt;minor ver&gt;".

                <u>dynamic_trace</u>:
                  Returns an atom describing the dynamic trace framework compiled into the virtual  machine.  It
                  can  be <u>dtrace</u>, <u>systemtap</u>, or <u>none</u>. For a commercial or standard build, it is always <u>none</u>. The
                  other return values indicate a custom configuration (for example, <u>./configure</u>  <u>--with-dynamic-</u>
                  <u>trace=dtrace</u>).  For more information about dynamic tracing, see <u><a href="../man3erl/dyntrace.3erl.html">dyntrace</a>(3erl)</u> manual page and
                  the <u>README.dtrace</u>/<u>README.systemtap</u> files in the Erlang source code top directory.

                <u>dynamic_trace_probes</u>:
                  Returns a <u>boolean()</u> indicating if dynamic trace probes (<u>dtrace</u> or <u>systemtap</u>)  are  built  into
                  the emulator. This can only be <u>true</u> if the virtual machine was built for dynamic tracing (that
                  is, <u>system_info(dynamic_trace)</u> returns <u>dtrace</u> or <u>systemtap</u>).

                <u>emu_flavor</u>:
                  Returns  an  atom describing the flavor of the runtime system. This will be either <u>emu</u> or <u>jit</u>.
                  Possible return values can be added or removed at any time without prior notice.

                <u>emu_type</u>:
                  Returns an atom describing the build type of the runtime system. This is normally the atom <u>opt</u>
                  for optimized. Other possible return values  are  <u>debug</u>,  <u>gcov</u>,  <u>valgrind</u>,  <u>gprof</u>,  and  <u>lcnt</u>.
                  Possible return values can be added or removed at any time without prior notice.

                <u>info</u>:
                  Returns  a  binary  containing  a  string  of miscellaneous system information formatted as in
                  Erlang crash dumps. For more information, see section  How to interpret the Erlang crash dumps
                  in the User's Guide.

                <u>kernel_poll</u>:
                  Returns <u>true</u> if the emulator uses some kind of kernel-poll implementation, otherwise <u>false</u>.

                <u>loaded</u>:
                  Returns a binary containing a string of loaded module information formatted as in Erlang crash
                  dumps. For more information, see section How to interpret the Erlang crash dumps in the User's
                  Guide.

                <u>machine</u>:
                  Returns a string containing the Erlang machine name.

                <u>modified_timing_level</u>:
                  Returns the modified timing-level (an  integer)  if  modified  timing  is  enabled,  otherwise
                  <u>undefined</u>. For more information about modified timing, see command-line flag <u>+T</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>

                <u>nif_version</u>:
                  Returns  a  string  containing  the  version  of  the Erlang NIF interface used by the runtime
                  system. It is on the form "&lt;major ver&gt;.&lt;minor ver&gt;".

                <u>otp_release</u>:

                  Returns a string containing the OTP release number of  the  OTP  release  that  the  currently
                  executing ERTS application is part of.

                  As  from Erlang/OTP 17, the OTP release number corresponds to the major OTP version number. No
                  <u>erlang:system_info()</u> argument gives the exact OTP version.  This  is  because  the  exact  OTP
                  version  in  the  general  case  is  difficult  to  determine.  For  more information, see the
                  description of versions in  System principles in System Documentation.

                <u>outstanding_system_requests_limit</u>:
                  Returns the limit on the amount of outstanding requests made by a system process orchestrating
                  system wide changes. See <u>erlang:system_flag(outstanding_system_requests_limit,</u> <u>Limit)</u> for more
                  information.

                <u>port_parallelism</u>:
                  Returns the default port parallelism scheduling hint used. For more information, see  command-
                  line argument <u>+spp</u> in <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

                <u>system_architecture</u>:
                  Returns a string containing the processor and OS architecture the emulator is built for.

                <u>system_logger</u>:
                  Returns the current <u>system_logger</u> as set by <u>erlang:system_flag(system_logger,</u> <b>_</b><u>)</u>.

                <u>system_version</u>:
                  Returns  a  string containing version number and some important properties, such as the number
                  of schedulers.

                <u>trace_control_word</u>:
                  Returns the value of the node trace control word. For more information, see  function  <u>get_tcw</u>
                  in section  Match Specifications in Erlang in the User's Guide.

                <u>version</u>:
                  Returns a string containing the version number of the emulator.

                <u>wordsize</u>:
                  Same as <u>{wordsize,</u> <u>internal}</u>.

                <u>{wordsize,</u> <u>internal}</u>:
                  Returns  the  size  of  Erlang  term words in bytes as an integer, that is, 4 is returned on a
                  32-bit architecture, and 8 is returned on a 64-bit architecture.

                <u>{wordsize,</u> <u>external}</u>:
                  Returns the true word size of the emulator, that is, the size of a pointer. The value is given
                  in bytes as  an  integer.  On  a  pure  32-bit  architecture,  4  is  returned.  On  a  64-bit
                  architecture, 8 is returned.

       <b>erlang:system_monitor()</b> <b>-&gt;</b> <b>MonSettings</b>

              Types:

                 MonSettings = undefined | {MonitorPid, Options}
                 MonitorPid = pid()
                 Options = [system_monitor_option()]
                 <b>system_monitor_option()</b> =
                     busy_port | busy_dist_port |
                     {long_gc, integer() &gt;= 0} |
                     {long_schedule, integer() &gt;= 0} |
                     {large_heap, integer() &gt;= 0}

              Returns  the  current  system  monitoring  settings set by <u>erlang:system_monitor/2</u> as <u>{MonitorPid,</u>
              <u>Options}</u>, or <u>undefined</u> if no settings exist. The order of the options can be  different  from  the
              one that was set.

       <b>erlang:system_monitor(Arg)</b> <b>-&gt;</b> <b>MonSettings</b>

              Types:

                 Arg = MonSettings = undefined | {MonitorPid, Options}
                 MonitorPid = pid()
                 Options = [system_monitor_option()]
                 <b>system_monitor_option()</b> =
                     busy_port | busy_dist_port |
                     {long_gc, integer() &gt;= 0} |
                     {long_schedule, integer() &gt;= 0} |
                     {large_heap, integer() &gt;= 0}

              When called with argument <u>undefined</u>, all system performance monitoring settings are cleared.

              Calling   the   function   with   <u>{MonitorPid,</u>  <u>Options}</u>  as  argument  is  the  same  as  calling
              <u>erlang:system_monitor(MonitorPid,</u> <u>Options)</u>.

              Returns the previous system monitor settings just like <u>erlang:system_monitor/0</u>.

       <b>erlang:system_monitor(MonitorPid,</b> <b>Options)</b> <b>-&gt;</b> <b>MonSettings</b>

              Types:

                 MonitorPid = pid()
                 Options = [system_monitor_option()]
                 MonSettings = undefined | {OldMonitorPid, OldOptions}
                 OldMonitorPid = pid()
                 OldOptions = [system_monitor_option()]
                 <b>system_monitor_option()</b> =
                     busy_port | busy_dist_port |
                     {long_gc, integer() &gt;= 0} |
                     {long_schedule, integer() &gt;= 0} |
                     {large_heap, integer() &gt;= 0}

              Sets the system performance monitoring options. <u>MonitorPid</u> is a  local  process  identifier  (pid)
              receiving system monitor messages. The second argument is a list of monitoring options:

                <u>{long_gc,</u> <u>Time}</u>:
                  If  a  garbage collection in the system takes at least <u>Time</u> wall clock milliseconds, a message
                  <u>{monitor,</u> <u>GcPid,</u> <u>long_gc,</u> <u>Info}</u> is sent to <u>MonitorPid</u>. <u>GcPid</u>  is  the  pid  that  was  garbage
                  collected.  <u>Info</u>  is  a  list  of  two-element  tuples  describing  the  result of the garbage
                  collection.

                  One of the tuples is <u>{timeout,</u> <u>GcTime}</u>, where <u>GcTime</u> is the time for the garbage collection in
                  milliseconds. The  other  tuples  are  tagged  with  <u>heap_size</u>,  <u>heap_block_size</u>,  <u>stack_size</u>,
                  <u>mbuf_size</u>,   <u>old_heap_size</u>,  and  <u>old_heap_block_size</u>.  These  tuples  are  explained  in  the
                  description of trace message <u>gc_minor_start</u> (see <u>erlang:trace/3</u>). New tuples can be added, and
                  the order of the tuples in the <u>Info</u> list can be changed at any time without prior notice.

                <u>{long_schedule,</u> <u>Time}</u>:
                  If a process or  port  in  the  system  runs  uninterrupted  for  at  least  <u>Time</u>  wall  clock
                  milliseconds,  a  message  <u>{monitor,</u>  <u>PidOrPort,</u>  <u>long_schedule,</u>  <u>Info}</u> is sent to <u>MonitorPid</u>.
                  <u>PidOrPort</u> is the process or port that was running.  <u>Info</u>  is  a  list  of  two-element  tuples
                  describing the event.

                  If  a  <u>pid()</u>,  the  tuples <u>{timeout,</u> <u>Millis}</u>, <u>{in,</u> <u>Location}</u>, and <u>{out,</u> <u>Location}</u> are present,
                  where <u>Location</u> is either an MFA (<u>{Module,</u> <u>Function,</u> <u>Arity}</u>) describing the function where  the
                  process was scheduled in/out, or the atom <u>undefined</u>.

                  If a <u>port()</u>, the tuples <u>{timeout,</u> <u>Millis}</u> and <u>{port_op,Op}</u> are present. <u>Op</u> is one of <u>proc_sig</u>,
                  <u>timeout</u>, <u>input</u>, <u>output</u>, <u>event</u>, or <u>dist_cmd</u>, depending on which driver callback was executing.

                  <u>proc_sig</u>  is  an  internal  operation  and  is never to appear, while the others represent the
                  corresponding driver callbacks <u>timeout</u>, <u>ready_input</u>, <u>ready_output</u>, <u>event</u>,  and  <u>outputv</u>  (when
                  the  port  is  used  by  distribution).  Value  <u>Millis</u>  in  tuple  <u>timeout</u>  informs  about the
                  uninterrupted execution time of the process or port, which always is equal to or  higher  than
                  the <u>Time</u> value supplied when starting the trace. New tuples can be added to the <u>Info</u> list in a
                  future  release.  The order of the tuples in the list can be changed at any time without prior
                  notice.

                  This can be used to detect problems with NIFs or drivers that take too long to execute.  1  ms
                  is  considered  a  good  maximum  time for a driver callback or a NIF. However, a time-sharing
                  system is usually to consider everything &lt; 100 ms as "possible" and fairly "normal".  However,
                  longer  schedule times can indicate swapping or a misbehaving NIF/driver. Misbehaving NIFs and
                  drivers can cause bad resource utilization and bad overall system performance.

                <u>{large_heap,</u> <u>Size}</u>:
                  If a garbage collection in the system results in the allocated size of a heap being  at  least
                  <u>Size</u> words, a message <u>{monitor,</u> <u>GcPid,</u> <u>large_heap,</u> <u>Info}</u> is sent to <u>MonitorPid</u>. <u>GcPid</u> and <u>Info</u>
                  are the same as for <u>long_gc</u> earlier, except that the tuple tagged with <u>timeout</u> is not present.

                  The  monitor  message  is  sent if the sum of the sizes of all memory blocks allocated for all
                  heap generations after a garbage collection is equal to or higher than <u>Size</u>.

                  When a process is killed by <u>max_heap_size</u>, it is  killed  before  the  garbage  collection  is
                  complete and thus no large heap message is sent.

                <u>busy_port</u>:
                  If a process in the system gets suspended because it sends to a busy port, a message <u>{monitor,</u>
                  <u>SusPid,</u>  <u>busy_port,</u>  <u>Port}</u>  is  sent  to <u>MonitorPid</u>. <u>SusPid</u> is the pid that got suspended when
                  sending to <u>Port</u>.

                <u>busy_dist_port</u>:
                  If a process in the system gets suspended because it sends to a process on a remote node whose
                  inter-node  communication  was  handled  by  a  busy  port,  a   message   <u>{monitor,</u>   <u>SusPid,</u>
                  <u>busy_dist_port,</u> <u>Port}</u> is sent to <u>MonitorPid</u>. <u>SusPid</u> is the pid that got suspended when sending
                  through the inter-node communication port <u>Port</u>.

              Returns the previous system monitor settings just like <u>erlang:system_monitor/0</u>.

              The  arguments to <u>system_monitor/2</u> specifies how all system monitoring on the node should be done,
              not how it should be changed. This means only one process  at  a  time  (<u>MonitorPid</u>)  can  be  the
              receiver  of  system  monitor messages. Also, the way to clear a specific monitor option is to not
              include it in the list <u>Options</u>. All system monitoring will, however, be  cleared  if  the  process
              identified by <u>MonitorPid</u> terminates.

              There  are  no  special  option  values (like zero) to clear an option. Some of the options have a
              unspecified minimum value. Lower values will be adjusted to the minimum value. For example, it  is
              currently not possible to monitor all garbage collections with <u>{long_gc,</u> <u>0}</u>.

          <b>Note:</b>
              If  a monitoring process gets so large that it itself starts to cause system monitor messages when
              garbage collecting, the messages enlarge the process message queue and probably make  the  problem
              worse.

              Keep the monitoring process neat and do not set the system monitor limits too tight.

              Failures:

                <u>badarg</u>:
                  If <u>MonitorPid</u> does not exist.

                <u>badarg</u>:
                  If <u>MonitorPid</u> is not a local process.

       <b>erlang:system_profile()</b> <b>-&gt;</b> <b>ProfilerSettings</b>

              Types:

                 ProfilerSettings = undefined | {ProfilerPid, Options}
                 ProfilerPid = pid() | port()
                 Options = [system_profile_option()]
                 <b>system_profile_option()</b> =
                     exclusive | runnable_ports | runnable_procs | scheduler |
                     timestamp | monotonic_timestamp | strict_monotonic_timestamp

              Returns  the  current  system  profiling  settings set by <u>erlang:system_profile/2</u> as <u>{ProfilerPid,</u>
              <u>Options}</u>, or <u>undefined</u> if there are no settings. The order of the options can  be  different  from
              the one that was set.

       <b>erlang:system_profile(ProfilerPid,</b> <b>Options)</b> <b>-&gt;</b> <b>ProfilerSettings</b>

              Types:

                 ProfilerPid = pid() | port() | undefined
                 Options = [system_profile_option()]
                 ProfilerSettings =
                     undefined | {pid() | port(), [system_profile_option()]}
                 <b>system_profile_option()</b> =
                     exclusive | runnable_ports | runnable_procs | scheduler |
                     timestamp | monotonic_timestamp | strict_monotonic_timestamp

              Sets  system  profiler  options. <u>ProfilerPid</u> is a local process identifier (pid) or port receiving
              profiling messages. The receiver is excluded from all profiling. The second argument is a list  of
              profiling options:

                <u>exclusive</u>:
                  If  a synchronous call to a port from a process is done, the calling process is considered not
                  runnable during the call runtime to the port. The calling process is notified as <u>inactive</u>, and
                  later <u>active</u> when the port callback returns.

                <u>monotonic_timestamp</u>:
                  Time stamps in profile messages use Erlang monotonic time. The time stamp (Ts)  has  the  same
                  format and value as produced by <u>erlang:monotonic_time(nanosecond)</u>.

                <u>runnable_procs</u>:
                  If  a process is put into or removed from the run queue, a message, <u>{profile,</u> <u>Pid,</u> <u>State,</u> <u>Mfa,</u>
                  <u>Ts}</u>, is sent to <u>ProfilerPid</u>. Running processes that are reinserted into the  run  queue  after
                  having been pre-empted do not trigger this message.

                <u>runnable_ports</u>:
                  If a port is put into or removed from the run queue, a message, <u>{profile,</u> <u>Port,</u> <u>State,</u> <u>0,</u> <u>Ts}</u>,
                  is sent to <u>ProfilerPid</u>.

                <u>scheduler</u>:
                  If a scheduler is put to sleep or awoken, a message, <u>{profile,</u> <u>scheduler,</u> <u>Id,</u> <u>State,</u> <u>NoScheds,</u>
                  <u>Ts}</u>, is sent to <u>ProfilerPid</u>.

                <u>strict_monotonic_timestamp</u>:
                  Time  stamps  in  profile  messages  consist  of  Erlang  monotonic  time  and a monotonically
                  increasing integer. The time stamp  (Ts)  has  the  same  format  and  value  as  produced  by
                  <u>{erlang:monotonic_time(nanosecond),</u> <u>erlang:unique_integer([monotonic])}</u>.

                <u>timestamp</u>:
                  Time  stamps  in profile messages include a time stamp (Ts) that has the same form as returned
                  by <u>erlang:now()</u>. This is also the default if no time stamp flag is specified. If <u>cpu_timestamp</u>
                  has been enabled through  <u>erlang:trace/3</u>,  this  also  effects  the  time  stamp  produced  in
                  profiling messages when flag <u>timestamp</u> is enabled.

          <b>Note:</b>
              <u>erlang:system_profile</u> behavior can change in a future release.

       <b>erlang:system_time()</b> <b>-&gt;</b> <b>integer()</b>

              Returns current  Erlang system time in <u>native</u> time unit.

              Calling <u>erlang:system_time()</u> is equivalent to <u>erlang:monotonic_time()</u> <u>+</u> <u>erlang:time_offset()</u>.

          <b>Note:</b>
              This  time  is  <u>not</u> a monotonically increasing time in the general case. For more information, see
              the documentation of  time warp modes in the User's Guide.

       <b>erlang:system_time(Unit)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 Unit = time_unit()

              Returns current  Erlang system time converted into the <u>Unit</u> passed as argument.

              Calling <u>erlang:system_time(Unit)</u> is equivalent  to  <u>erlang:convert_time_unit(erlang:system_time(),</u>
              <u>native,</u> <u>Unit)</u>.

          <b>Note:</b>
              This  time  is  <u>not</u> a monotonically increasing time in the general case. For more information, see
              the documentation of  time warp modes in the User's Guide.

       <b>term_to_binary(Term)</b> <b>-&gt;</b> <b>ext_binary()</b>

              Types:

                 Term = term()

              Returns a binary data object that is the result of encoding <u>Term</u> according to the Erlang  external
              term format.

              This  can be used for various purposes, for example, writing a term to a file in an efficient way,
              or sending an Erlang term to some type of communications  channel  not  supported  by  distributed
              Erlang.

              &gt; Bin = term_to_binary(hello).
              &lt;&lt;131,100,0,5,104,101,108,108,111&gt;&gt;
              &gt; hello = binary_to_term(Bin).
              hello

              See also <u>binary_to_term/1</u>.

          <b>Note:</b>
              There  is no guarantee that this function will return the same encoded representation for the same
              term.

       <b>term_to_binary(Term,</b> <b>Options)</b> <b>-&gt;</b> <b>ext_binary()</b>

              Types:

                 Term = term()
                 Options =
                     [compressed |
                      {compressed, Level :: 0..9} |
                      deterministic |
                      {minor_version, Version :: 0..2}]

              Returns a binary data object that is the result of encoding <u>Term</u> according to the Erlang  external
              term format.

              If option <u>compressed</u> is provided, the external term format is compressed. The compressed format is
              automatically recognized by <u>binary_to_term/1</u> as from Erlang/OTP R7B.

              A  compression  level  can  be specified by giving option <u>{compressed,</u> <u>Level}</u>. <u>Level</u> is an integer
              with range 0..9, where:

                * <u>0</u> - No compression is done (it is the same as giving no <u>compressed</u> option).

                * <u>1</u> - Takes least time but may not compress as well as the higher levels.

                * <u>6</u> - Default level when option <u>compressed</u> is provided.

                * <u>9</u> - Takes most time and tries to produce a smaller result. Notice  "tries"  in  the  preceding
                  sentence;  depending  on the input term, level 9 compression either does or does not produce a
                  smaller result than level 1 compression.

              Option <u>{minor_version,</u> <u>Version}</u> can be used to control some  encoding  details.  This  option  was
              introduced in Erlang/OTP R11B-4. The valid values for <u>Version</u> are:

                <u>0</u>:
                  Floats  are  encoded  using  a  textual  representation.  This option is useful to ensure that
                  releases before Erlang/OTP R11B-4 can decode resulting binary.

                  This version encode atoms that can be represented by a latin1  string  using  latin1  encoding
                  while only atoms that cannot be represented by latin1 are encoded using utf8.

                <u>1</u>:
                  This is as of Erlang/OTP 17.0 the <u>default</u>. It forces any floats in the term to be encoded in a
                  more space-efficient and exact way (namely in the 64-bit IEEE format, rather than converted to
                  a  textual  representation).  As  from  Erlang/OTP  R11B-4,  <u>binary_to_term/1</u>  can decode this
                  representation.

                  This version encode atoms that can be represented by a latin1  string  using  latin1  encoding
                  while only atoms that cannot be represented by latin1 are encoded using utf8.

                <u>2</u>:
                  Drops  usage  of the latin1 atom encoding and unconditionally use utf8 encoding for all atoms.
                  Erlang/OTP systems as of R16B can decode this representation.

            <b>Note:</b>
                In Erlang/OTP 26, the default <u>minor_version</u> is planned to change from  1  to  2.  See   Upcoming
                Potential Incompatibilities .

              Option  <u>deterministic</u>  (introduced  in  OTP 24.1) can be used to ensure that within the same major
              release of Erlang/OTP, the same encoded representation is returned for the  same  term.  There  is
              still  no  guarantee  that  the  encoded representation remains the same between major releases of
              Erlang/OTP.

              See also <u>binary_to_term/1</u>.

       <b>term_to_iovec(Term)</b> <b>-&gt;</b> <b>ext_iovec()</b>

              Types:

                 Term = term()

              Returns the encoding of <u>Term</u> according to the Erlang external term format as <u>ext_iovec()</u>.

              This function produce the same encoding as <u>term_to_binary/1</u>, but with  another  return  type.  The
              call  <u>iolist_to_binary(term_to_iovec(Term))</u>  will  produce  exactly  the  same  result as the call
              <u>term_to_binary(Term)</u>.

              <u>term_to_iovec()</u>  is  a  pure  optimization  of   the   functionality   <u>term_to_binary()</u>   provide.
              <u>term_to_iovec()</u>  can for example refer directly to off heap binaries instead of copying the binary
              data into the result.

              See also <u>term_to_binary/1</u>.

       <b>term_to_iovec(Term,</b> <b>Options)</b> <b>-&gt;</b> <b>ext_iovec()</b>

              Types:

                 Term = term()
                 Options =
                     [compressed |
                      {compressed, Level :: 0..9} |
                      deterministic |
                      {minor_version, Version :: 0..2}]

              Returns the encoding of <u>Term</u> according to the Erlang external term format as <u>ext_iovec()</u>.

              This function produce the same encoding as <u>term_to_binary/2</u>, but with  another  return  type.  The
              call   <u>iolist_to_binary(term_to_iovec(Term,</u>  <u>Opts))</u>  will  produce  exactly  the  same  result  as
              <u>term_to_binary(Term,</u> <u>Opts)</u>.

              Currently recognised options are all options recognised by <u>term_to_binary/2</u>.

              <u>term_to_iovec()</u>  is  a  pure  optimization  of   the   functionality   <u>term_to_binary()</u>   provide.
              <u>term_to_iovec()</u>  can for example refer directly to off heap binaries instead of copying the binary
              data into the result.

              See also <u>term_to_binary/2</u>.

       <b>throw(Any)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Any = term()

              Raises an exception of class <u>throw</u>. Intended to be used to do non-local returns from functions.

              If evaluated within a  catch expression, the catch expression returns value <u>Any</u>. Example:

              &gt; catch throw({hello, there}).
                      {hello,there}

              If evaluated within a <u>try</u>-block of a try expression, the value <u>Any</u> can be caught within the  catch
              block. Example:

              try
                  throw({my_exception, "Something happened"})
              catch
                  throw:{my_exception, Desc} -&gt;
                      io:format(standard_error, "Error: ~s~n", [Desc])
              end

              Failure: <u>nocatch</u> if not caught by an exception handler.

              See the guide about errors and error handling for additional information.

       <b>time()</b> <b>-&gt;</b> <b>Time</b>

              Types:

                 Time = calendar:time()

              Returns the current time as <u>{Hour,</u> <u>Minute,</u> <u>Second}</u>.

              The time zone and Daylight Saving Time correction depend on the underlying OS. The return value is
              based on the OS System Time. Example:

              &gt; time().
              {9,42,44}

       <b>erlang:time_offset()</b> <b>-&gt;</b> <b>integer()</b>

              Returns  the  current time offset between  Erlang monotonic time and  Erlang system time in <u>native</u>
              time unit. Current time offset added to an Erlang monotonic time gives corresponding Erlang system
              time.

              The time offset may or may not change during operation depending on the time warp mode used.

          <b>Note:</b>
              A change in time offset can be  observed  at  slightly  different  points  in  time  by  different
              processes.

              If  the  runtime  system  is  in multi-time warp mode, the time offset is changed when the runtime
              system detects that the OS system time has changed. The runtime system will, however,  not  detect
              this  immediately when it occurs. A task checking the time offset is scheduled to execute at least
              once a minute; so, under normal operation this is to be detected within a minute, but during heavy
              load it can take longer time.

       <b>erlang:time_offset(Unit)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 Unit = time_unit()

              Returns the current time offset between  Erlang monotonic time and  Erlang system  time  converted
              into the <u>Unit</u> passed as argument.

              Same as calling <u>erlang:convert_time_unit(erlang:time_offset(),</u> <u>native,</u> <u>Unit)</u> however optimized for
              commonly used <u>Unit</u>s.

       <b>erlang:timestamp()</b> <b>-&gt;</b> <b>Timestamp</b>

              Types:

                 Timestamp = timestamp()
                 <b>timestamp()</b> =
                     {MegaSecs :: integer() &gt;= 0,
                      Secs :: integer() &gt;= 0,
                      MicroSecs :: integer() &gt;= 0}

              Returns  current  Erlang system time on the format <u>{MegaSecs,</u> <u>Secs,</u> <u>MicroSecs}</u>. This format is the
              same as <u>os:timestamp/0</u> and the deprecated <u>erlang:now/0</u>  use.  The  reason  for  the  existence  of
              <u>erlang:timestamp()</u>  is  purely  to  simplify  use  for  existing code that assumes this time stamp
              format. Current Erlang system time can more efficiently be retrieved in  the  time  unit  of  your
              choice using <u>erlang:system_time/1</u>.

              The <u>erlang:timestamp()</u> BIF is equivalent to:

              timestamp() -&gt;
                  ErlangSystemTime = erlang:<a href="../manmicrosecond/system_time.microsecond.html">system_time</a>(microsecond),
                  MegaSecs = ErlangSystemTime div 1000_000_000_000,
                  Secs = ErlangSystemTime div 1000_000 - MegaSecs*1000_000,
                  MicroSecs = ErlangSystemTime rem 1000_000,
                  {MegaSecs, Secs, MicroSecs}.

              It,  however,  uses  a  native  implementation  that  does  not build garbage on the heap and with
              slightly better performance.

          <b>Note:</b>
              This time is <u>not</u> a monotonically increasing time in the general case. For  more  information,  see
              the documentation of  time warp modes in the User's Guide.

       <b>tl(List)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 List = nonempty_maybe_improper_list()

              Returns the tail of <u>List</u>, that is, the list minus the first element, for example:

              &gt; tl([geesties, guilies, beasties]).
              [guilies, beasties]

              &gt; tl([geesties]).
              []

              &gt; tl([geesties, guilies, beasties | improper_end]).
              [guilies, beasties | improper_end]

              &gt; tl([geesties | improper_end]).
              improper_end

              Allowed in guard tests.

              Failure: <u>badarg</u> if <u>List</u> is the empty list <u>[]</u>.

       <b>erlang:trace(PidPortSpec,</b> <b>How,</b> <b>FlagList)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 PidPortSpec =
                     pid() |
                     port() |
                     all | processes | ports | existing | existing_processes |
                     existing_ports | new | new_processes | new_ports
                 How = boolean()
                 FlagList = [trace_flag()]
                 <b>trace_flag()</b> =
                     all | send | 'receive' | procs | ports | call | arity |
                     return_to | silent | running | exiting | running_procs |
                     running_ports | garbage_collection | timestamp |
                     cpu_timestamp | monotonic_timestamp |
                     strict_monotonic_timestamp | set_on_spawn |
                     set_on_first_spawn | set_on_link | set_on_first_link |
                     {tracer, pid() | port()} |
                     {tracer, module(), term()}

              Turns  on (if <u>How</u> <u>==</u> <u>true</u>) or off (if <u>How</u> <u>==</u> <u>false</u>) the trace flags in <u>FlagList</u> for the process or
              processes represented by <u>PidPortSpec</u>.

              <u>PidPortSpec</u> is either a process identifier (pid) for a local process, a port identifier, or one of
              the following atoms:

                <u>all</u>:
                  All currently existing processes and ports and all that will be created in the future.

                <u>processes</u>:
                  All currently existing processes and all that will be created in the future.

                <u>ports</u>:
                  All currently existing ports and all that will be created in the future.

                <u>existing</u>:
                  All currently existing processes and ports.

                <u>existing_processes</u>:
                  All currently existing processes.

                <u>existing_ports</u>:
                  All currently existing ports.

                <u>new</u>:
                  All processes and ports that will be created in the future.

                <u>new_processes</u>:
                  All processes that will be created in the future.

                <u>new_ports</u>:
                  All ports that will be created in the future.

              <u>FlagList</u> can contain any number of the following flags (the "message tags" refers to the  list  of
              <u>trace</u> <u>messages</u>):

                <u>all</u>:
                  Sets all trace flags except <u>tracer</u> and <u>cpu_timestamp</u>, which are in their nature different than
                  the others.

                <u>send</u>:
                  Traces sending of messages.

                  Message tags: <u>send</u> and <u>send_to_non_existing_process</u>.

                <u>'receive'</u>:
                  Traces receiving of messages.

                  Message tags: <u>'receive'</u>.

                <u>call</u>:
                  Traces   certain   function   calls.   Specify  which  function  calls  to  trace  by  calling
                  <u>erlang:trace_pattern/3</u>.

                  Message tags: <u>call</u> and <u>return_from</u>.

                <u>silent</u>:
                  Used with the <u>call</u> trace flag.  The  <u>call</u>,  <u>return_from</u>,  and  <u>return_to</u>  trace  messages  are
                  inhibited  if  this  flag  is  set,  but  they  are  executed  as  normal  if  there are match
                  specifications.

                  Silent mode is inhibited by executing  <u>erlang:trace(_,</u>  <u>false,</u>  <u>[silent|_])</u>,  or  by  a  match
                  specification executing the function <u>{silent,</u> <u>false}</u>.

                  The  <u>silent</u>  trace  flag  facilitates  setting up a trace on many or even all processes in the
                  system. The trace can then be activated and deactivated using the match specification function
                  <u>{silent,Bool}</u>, giving a high degree of control of which functions with  which  arguments  that
                  trigger the trace.

                  Message tags: <u>call</u>, <u>return_from</u>, and <u>return_to</u>. Or rather, the absence of.

                <u>return_to</u>:
                  Used  with  the  <u>call</u> trace flag. Traces the return from a traced function back to its caller.
                  Only works for functions traced with option <u>local</u> to <u>erlang:trace_pattern/3</u>.

                  The semantics is that a trace message is sent when a call traced function  returns,  that  is,
                  when  a  chain  of tail recursive calls ends. Only one trace message is sent per chain of tail
                  recursive calls, so the properties of tail recursiveness for function  calls  are  kept  while
                  tracing  with  this  flag.  Using  <u>call</u> and <u>return_to</u> trace together makes it possible to know
                  exactly in which function a process executes at any time.

                  To get trace messages containing return values from functions, use  the  <u>{return_trace}</u>  match
                  specification action instead.

                  Message tags: <u>return_to</u>.

                <u>procs</u>:
                  Traces process-related events.

                  Message  tags:  <u>spawn</u>,  <u>spawned</u>, <u>exit</u>, <u>register</u>, <u>unregister</u>, <u>link</u>, <u>unlink</u>, <u>getting_linked</u>, and
                  <u>getting_unlinked</u>.

                <u>ports</u>:
                  Traces port-related events.

                  Message tags: <u>open</u>, <u>closed</u>, <u>register</u>, <u>unregister</u>, <u>getting_linked</u>, and <u>getting_unlinked</u>.

                <u>running</u>:
                  Traces scheduling of processes.

                  Message tags: <u>in</u> and <u>out</u>.

                <u>exiting</u>:
                  Traces scheduling of exiting processes.

                  Message tags: <u>in_exiting</u>, <u>out_exiting</u>, and <u>out_exited</u>.

                <u>running_procs</u>:
                  Traces scheduling of processes just like <u>running</u>. However, this option also includes  schedule
                  events  when  the  process  executes  within the context of a port without being scheduled out
                  itself.

                  Message tags: <u>in</u> and <u>out</u>.

                <u>running_ports</u>:
                  Traces scheduling of ports.

                  Message tags: <u>in</u> and <u>out</u>.

                <u>garbage_collection</u>:
                  Traces garbage collections of processes.

                  Message tags: <u>gc_minor_start</u>, <u>gc_max_heap_size</u>, and <u>gc_minor_end</u>.

                <u>timestamp</u>:
                  Includes a time stamp in all trace messages. The time stamp (Ts) has the same form as returned
                  by <u>erlang:now()</u>.

                <u>cpu_timestamp</u>:
                  A global trace flag for the Erlang node that makes all trace time stamps using flag  <u>timestamp</u>
                  to  be  in  CPU  time,  not  wall  clock  time.  That  is,  <u>cpu_timestamp</u>  is  not  be used if
                  <u>monotonic_timestamp</u>   or   <u>strict_monotonic_timestamp</u>   is   enabled.   Only   allowed    with
                  <u>PidPortSpec==all</u>.   If  the  host  machine  OS  does  not  support  high-resolution  CPU  time
                  measurements, <u>trace/3</u> exits with <u>badarg</u>. Notice that most OS do  not  synchronize  this  value
                  across cores, so be prepared that time can seem to go backwards when using this option.

                <u>monotonic_timestamp</u>:
                  Includes  an  Erlang  monotonic time time stamp in all trace messages. The time stamp (Ts) has
                  the same  format  and  value  as  produced  by  <u>erlang:monotonic_time(nanosecond)</u>.  This  flag
                  overrides flag <u>cpu_timestamp</u>.

                <u>strict_monotonic_timestamp</u>:
                  Includes  an  time  stamp  consisting  of Erlang monotonic time and a monotonically increasing
                  integer in all trace messages. The time stamp (Ts) has the same format and value  as  produced
                  by   <u>{</u>   <u>erlang:monotonic_time(nanosecond),</u>   <u>erlang:unique_integer([monotonic])}</u>.  This  flag
                  overrides flag <u>cpu_timestamp</u>.

                <u>arity</u>:
                  Used with the <u>call</u> trace flag. <u>{M,</u> <u>F,</u> <u>Arity}</u> is specified instead of  <u>{M,</u>  <u>F,</u>  <u>Args}</u>  in  call
                  trace messages.

                <u>set_on_spawn</u>:
                  Makes  any  process  created  by  a  traced  process  inherit  its trace flags, including flag
                  <u>set_on_spawn</u>.

                <u>set_on_first_spawn</u>:
                  Makes the first process created by a traced process inherit its trace  flags,  excluding  flag
                  <u>set_on_first_spawn</u>.

                <u>set_on_link</u>:
                  Makes  any  process  linked  by  a  traced  process  inherit  its  trace flags, including flag
                  <u>set_on_link</u>.

                <u>set_on_first_link</u>:
                  Makes the first process linked to by a traced process inherit its trace flags, excluding  flag
                  <u>set_on_first_link</u>.

                <u>{tracer,</u> <u>Tracer}</u>:
                  Specifies  where  to send the trace messages. <u>Tracer</u> must be the process identifier of a local
                  process or the port identifier of a local port.

                <u>{tracer,</u> <u>TracerModule,</u> <u>TracerState}</u>:
                  Specifies that a tracer module is to be called instead of sending a trace message. The  tracer
                  module  can then ignore or change the trace message. For more details on how to write a tracer
                  module, see <u><a href="../man3erl/erl_tracer.3erl.html">erl_tracer</a>(3erl)</u>.

              If no <u>tracer</u> is specified, the calling process receives all the trace messages.

              The effect of combining <u>set_on_first_link</u> with <u>set_on_link</u> is the same as <u>set_on_first_link</u> alone.
              Likewise for <u>set_on_spawn</u> and <u>set_on_first_spawn</u>.

              The tracing process receives the <u>trace</u> <u>messages</u> described  in  the  following  list.  <u>Pid</u>  is  the
              process  identifier  of the traced process in which the traced event has occurred. The third tuple
              element is the message tag.

              If flag <u>timestamp</u>, <u>strict_monotonic_timestamp</u>, or  <u>monotonic_timestamp</u>  is  specified,  the  first
              tuple  element  is  <u>trace_ts</u>  instead, and the time stamp is added as an extra element last in the
              message  tuple.  If  multiple  time  stamp  flags  are  passed,  <u>timestamp</u>  has  precedence   over
              <u>strict_monotonic_timestamp</u>,  which in turn has precedence over <u>monotonic_timestamp</u>. All time stamp
              flags are remembered, so if two are passed and the one with highest precedence later is  disabled,
              the other one becomes active.

              If  a  match  specification  (applicable  only  for  <u>call</u>,  <u>send</u> and <u>'receive'</u> tracing) contains a
              <u>{message}</u> action function with a non-boolean value, that value is added as an extra element to the
              message tuple either in the last position or before the timestamp (if it is present).

              Trace messages:

                <u>{trace,</u> <u>PidPort,</u> <u>send,</u> <u>Msg,</u> <u>To}</u>:
                  When <u>PidPort</u> sends message <u>Msg</u> to process <u>To</u>.

                <u>{trace,</u> <u>PidPort,</u> <u>send_to_non_existing_process,</u> <u>Msg,</u> <u>To}</u>:
                  When <u>PidPort</u> sends message <u>Msg</u> to the non-existing process <u>To</u>.

                <u>{trace,</u> <u>PidPort,</u> <u>'receive',</u> <u>Msg}</u>:
                  When <u>PidPort</u> receives message <u>Msg</u>. If <u>Msg</u> is set to time-out, a  receive  statement  can  have
                  timed out, or the process received a message with the payload <u>timeout</u>.

                <u>{trace,</u> <u>Pid,</u> <u>call,</u> <u>{M,</u> <u>F,</u> <u>Args}}</u>:
                  When <u>Pid</u> calls a traced function. The return values of calls are never supplied, only the call
                  and its arguments.

                  Trace  flag  <u>arity</u>  can  be  used  to  change  the  contents of this message, so that <u>Arity</u> is
                  specified instead of <u>Args</u>.

                <u>{trace,</u> <u>Pid,</u> <u>return_to,</u> <u>{M,</u> <u>F,</u> <u>Arity}}</u>:
                  When <u>Pid</u> returns <u>to</u> the specified function. This trace message is sent if both the flags  <u>call</u>
                  and  <u>return_to</u>  are  set,  and  the  function is set to be traced on <u>local</u> function calls. The
                  message is only sent when returning from a chain of tail recursive function  calls,  where  at
                  least  one  call  generated  a  <u>call</u> trace message (that is, the functions match specification
                  matched, and <u>{message,</u> <u>false}</u> was not an action).

                <u>{trace,</u> <u>Pid,</u> <u>return_from,</u> <u>{M,</u> <u>F,</u> <u>Arity},</u> <u>ReturnValue}</u>:
                  When <u>Pid</u> returns <u>from</u> the specified function. This trace message is sent if flag <u>call</u> is  set,
                  and the function has a match specification with a <u>return_trace</u> or <u>exception_trace</u> action.

                <u>{trace,</u> <u>Pid,</u> <u>exception_from,</u> <u>{M,</u> <u>F,</u> <u>Arity},</u> <u>{Class,</u> <u>Value}}</u>:
                  When <u>Pid</u> exits <u>from</u> the specified function because of an exception. This trace message is sent
                  if  flag  <u>call</u>  is  set,  and  the  function has a match specification with an <u>exception_trace</u>
                  action.

                <u>{trace,</u> <u>Pid,</u> <u>spawn,</u> <u>Pid2,</u> <u>{M,</u> <u>F,</u> <u>Args}}</u>:
                  When <u>Pid</u> spawns a new process <u>Pid2</u> with the specified function call as entry point.

                  <u>Args</u> is supposed to be the argument list, but can be any term if the spawn is erroneous.

                <u>{trace,</u> <u>Pid,</u> <u>spawned,</u> <u>Pid2,</u> <u>{M,</u> <u>F,</u> <u>Args}}</u>:
                  When <u>Pid</u> is spawned by process <u>Pid2</u> with the specified function call as entry point.

                  <u>Args</u> is supposed to be the argument list, but can be any term if the spawn is erroneous.

                <u>{trace,</u> <u>Pid,</u> <u>exit,</u> <u>Reason}</u>:
                  When <u>Pid</u> exits with reason <u>Reason</u>.

                <u>{trace,</u> <u>PidPort,</u> <u>register,</u> <u>RegName}</u>:
                  When <u>PidPort</u> gets the name <u>RegName</u> registered.

                <u>{trace,</u> <u>PidPort,</u> <u>unregister,</u> <u>RegName}</u>:
                  When <u>PidPort</u> gets the name <u>RegName</u> unregistered. This is done automatically when a  registered
                  process or port exits.

                <u>{trace,</u> <u>Pid,</u> <u>link,</u> <u>Pid2}</u>:
                  When <u>Pid</u> links to a process <u>Pid2</u>.

                <u>{trace,</u> <u>Pid,</u> <u>unlink,</u> <u>Pid2}</u>:
                  When <u>Pid</u> removes the link from a process <u>Pid2</u>.

                <u>{trace,</u> <u>PidPort,</u> <u>getting_linked,</u> <u>Pid2}</u>:
                  When <u>PidPort</u> gets linked to a process <u>Pid2</u>.

                <u>{trace,</u> <u>PidPort,</u> <u>getting_unlinked,</u> <u>Pid2}</u>:
                  When <u>PidPort</u> gets unlinked from a process <u>Pid2</u>.

                <u>{trace,</u> <u>Port,</u> <u>open,</u> <u>Pid,</u> <u>Driver}</u>:
                  When <u>Pid</u> opens a new port <u>Port</u> with the running <u>Driver</u>.

                  <u>Driver</u> is the name of the driver as an atom.

                <u>{trace,</u> <u>Port,</u> <u>closed,</u> <u>Reason}</u>:
                  When <u>Port</u> closes with <u>Reason</u>.

                <u>{trace,</u> <u>Pid,</u> <u>in</u> <u>|</u> <u>in_exiting,</u> <u>{M,</u> <u>F,</u> <u>Arity}</u> <u>|</u> <u>0}</u>:
                  When  <u>Pid</u>  is  scheduled  to  run.  The  process  runs in function <u>{M,</u> <u>F,</u> <u>Arity}</u>. On some rare
                  occasions, the current function cannot be determined, then the last element is <u>0</u>.

                <u>{trace,</u> <u>Pid,</u> <u>out</u> <u>|</u> <u>out_exiting</u> <u>|</u> <u>out_exited,</u> <u>{M,</u> <u>F,</u> <u>Arity}</u> <u>|</u> <u>0}</u>:
                  When <u>Pid</u> is scheduled out. The process was running in function {M, F,  Arity}.  On  some  rare
                  occasions, the current function cannot be determined, then the last element is <u>0</u>.

                <u>{trace,</u> <u>Port,</u> <u>in,</u> <u>Command</u> <u>|</u> <u>0}</u>:
                  When  <u>Port</u>  is  scheduled  to  run.  <u>Command</u>  is the first thing the port will execute, it can
                  however run several commands before being scheduled out. On some rare occasions,  the  current
                  function cannot be determined, then the last element is <u>0</u>.

                  The possible commands are <u>call</u>, <u>close</u>, <u>command</u>, <u>connect</u>, <u>control</u>, <u>flush</u>, <u>info</u>, <u>link</u>, <u>open</u>, and
                  <u>unlink</u>.

                <u>{trace,</u> <u>Port,</u> <u>out,</u> <u>Command</u> <u>|</u> <u>0}</u>:
                  When  <u>Port</u>  is  scheduled  out.  The last command run was <u>Command</u>. On some rare occasions, the
                  current function cannot be determined, then the last element is <u>0</u>.  <u>Command</u>  can  contain  the
                  same commands as <u>in</u>

                <u>{trace,</u> <u>Pid,</u> <u>gc_minor_start,</u> <u>Info}</u>:

                  Sent  when  a  young  garbage collection is about to be started. <u>Info</u> is a list of two-element
                  tuples, where the first element is a key, and the second is the value. Do not  depend  on  any
                  order of the tuples. The following keys are defined:

                  <u>heap_size</u>:
                    The size of the used part of the heap.

                  <u>heap_block_size</u>:
                    The size of the memory block used for storing the heap and the stack.

                  <u>old_heap_size</u>:
                    The size of the used part of the old heap.

                  <u>old_heap_block_size</u>:
                    The size of the memory block used for storing the old heap.

                  <u>stack_size</u>:
                    The size of the stack.

                  <u>recent_size</u>:
                    The size of the data that survived the previous garbage collection.

                  <u>mbuf_size</u>:
                    The combined size of message buffers associated with the process.

                  <u>bin_vheap_size</u>:
                    The total size of unique off-heap binaries referenced from the process heap.

                  <u>bin_vheap_block_size</u>:
                    The total size of binaries allowed in the virtual heap in the process before doing a garbage
                    collection.

                  <u>bin_old_vheap_size</u>:
                    The total size of unique off-heap binaries referenced from the process old heap.

                  <u>bin_old_vheap_block_size</u>:
                    The  total  size  of  binaries allowed in the virtual old heap in the process before doing a
                    garbage collection.

                  <u>wordsize</u>:
                    For the <u>gc_minor_start</u> event it is the size of the need  that  triggered  the  GC.  For  the
                    corresponding  <u>gc_minor_end</u> event it is the size of reclaimed memory = start <u>heap_size</u> - end
                    <u>heap_size</u>.

                  All sizes are in words.

                <u>{trace,</u> <u>Pid,</u> <u>gc_max_heap_size,</u> <u>Info}</u>:
                  Sent when the <u>max_heap_size</u> is reached during garbage collection. <u>Info</u> contains the same  kind
                  of  list  as in message <u>gc_start</u>, but the sizes reflect the sizes that triggered <u>max_heap_size</u>
                  to be reached.

                <u>{trace,</u> <u>Pid,</u> <u>gc_minor_end,</u> <u>Info}</u>:
                  Sent when young garbage collection is finished. <u>Info</u> contains the same  kind  of  list  as  in
                  message <u>gc_minor_start</u>, but the sizes reflect the new sizes after garbage collection.

                <u>{trace,</u> <u>Pid,</u> <u>gc_major_start,</u> <u>Info}</u>:
                  Sent  when fullsweep garbage collection is about to be started. <u>Info</u> contains the same kind of
                  list as in message <u>gc_minor_start</u>.

                <u>{trace,</u> <u>Pid,</u> <u>gc_major_end,</u> <u>Info}</u>:
                  Sent when fullsweep garbage collection is finished. <u>Info</u> contains the same kind of list as  in
                  message  <u>gc_minor_start</u>,  but  the  sizes  reflect  the  new  sizes  after a fullsweep garbage
                  collection.

              If the tracing process/port dies or the tracer module  returns  <u>remove</u>,  the  flags  are  silently
              removed.

              Each  process  can  only  be  traced by one tracer. Therefore, attempts to trace an already traced
              process fail.

              Returns a number indicating the number of processes that matched <u>PidPortSpec</u>. If <u>PidPortSpec</u> is  a
              process  identifier, the return value is <u>1</u>. If <u>PidPortSpec</u> is <u>all</u> or <u>existing</u>, the return value is
              the number of processes running. If <u>PidPortSpec</u> is <u>new</u>, the return value is <u>0</u>.

              Failure: <u>badarg</u> if the specified arguments are not supported. For example,  <u>cpu_timestamp</u>  is  not
              supported on all platforms.

       <b>erlang:trace_delivered(Tracee)</b> <b>-&gt;</b> <b>Ref</b>

              Types:

                 Tracee = pid() | all
                 Ref = reference()

              The   delivery   of   trace   messages   (generated   by   <u>erlang:trace/3</u>,   <u><a href="../man3erl/seq_trace.3erl.html">seq_trace</a>(3erl)</u>,   or
              <u>erlang:system_profile/2</u>) is dislocated on the time-line compared to other events in the system. If
              you know that <u>Tracee</u> has passed some specific point in its execution, and you want to know when at
              least all trace messages corresponding to events up to this point have  reached  the  tracer,  use
              <u>erlang:trace_delivered(Tracee)</u>.

              When  it  is  guaranteed  that all trace messages are delivered to the tracer up to the point that
              <u>Tracee</u> reached at the time of the call to <u>erlang:trace_delivered(Tracee)</u>, then a <u>{trace_delivered,</u>
              <u>Tracee,</u> <u>Ref}</u> message is sent to the caller of <u>erlang:trace_delivered(Tracee)</u> .

              Notice that message <u>trace_delivered</u> does <u>not</u>  imply  that  trace  messages  have  been  delivered.
              Instead it implies that all trace messages that <u>are</u> <u>to</u> <u>be</u> <u>delivered</u> have been delivered. It is not
              an  error  if <u>Tracee</u> is not, and has not been traced by someone, but if this is the case, <u>no</u> trace
              messages have been delivered when the <u>trace_delivered</u> message arrives.

              Notice that <u>Tracee</u> must refer to a process currently or previously existing on the  same  node  as
              the  caller  of <u>erlang:trace_delivered(Tracee)</u> resides on. The special <u>Tracee</u> atom <u>all</u> denotes all
              processes that currently are traced in the node.

              When used together with a  Tracer Module, any message sent in the trace callback is guaranteed  to
              have reached its recipient before the <u>trace_delivered</u> message is sent.

              Example:  Process  <u>A</u> is <u>Tracee</u>, port <u>B</u> is tracer, and process <u>C</u> is the port owner of <u>B</u>. <u>C</u> wants to
              close  <u>B</u>  when  <u>A</u>  exits.  To  ensure  that   the   trace   is   not   truncated,   <u>C</u>   can   call
              <u>erlang:trace_delivered(A)</u>  when  <u>A</u>  exits,  and  wait for message <u>{trace_delivered,</u> <u>A,</u> <u>Ref}</u> before
              closing <u>B</u>.

              Failure: <u>badarg</u> if <u>Tracee</u> does not refer to a process (dead or alive) on  the  same  node  as  the
              caller of <u>erlang:trace_delivered(Tracee)</u> resides on.

       <b>erlang:trace_info(PidPortFuncEvent,</b> <b>Item)</b> <b>-&gt;</b> <b>Res</b>

              Types:

                 PidPortFuncEvent =
                     pid() |
                     port() |
                     new | new_processes | new_ports |
                     {Module, Function, Arity} |
                     on_load | send | 'receive'
                 Module = module()
                 Function = atom()
                 Arity = arity()
                 Item =
                     flags | tracer | traced | match_spec | meta |
                     meta_match_spec | call_count | call_time | all
                 Res = trace_info_return()
                 <b>trace_info_return()</b> =
                     undefined |
                     {flags, [trace_info_flag()]} |
                     {tracer, pid() | port() | []} |
                     {tracer, module(), term()} |
                     trace_info_item_result() |
                     {all, [trace_info_item_result()] | false | undefined}
                 <b>trace_info_item_result()</b> =
                     {traced, global | local | false | undefined} |
                     {match_spec, trace_match_spec() | false | undefined} |
                     {meta, pid() | port() | false | undefined | []} |
                     {meta, module(), term()} |
                     {meta_match_spec, trace_match_spec() | false | undefined} |
                     {call_count, integer() &gt;= 0 | boolean() | undefined} |
                     {call_time,
                      [{pid(),
                        integer() &gt;= 0,
                        integer() &gt;= 0,
                        integer() &gt;= 0}] |
                      boolean() |
                      undefined}
                 <b>trace_info_flag()</b> =
                     send | 'receive' | set_on_spawn | call | return_to | procs |
                     set_on_first_spawn | set_on_link | running |
                     garbage_collection | timestamp | monotonic_timestamp |
                     strict_monotonic_timestamp | arity
                 <b>trace_match_spec()</b> =
                     [{[term()] | '_' | match_variable(), [term()], [term()]}]
                 <b>match_variable()</b> = atom()
                    Approximation of '$1' | '$2' | '$3' | ...

              Returns trace information about a port, process, function, or event.

              <u>To</u>  <u>get</u> <u>information</u> <u>about</u> <u>a</u> <u>port</u> <u>or</u> <u>process</u>, <u>PidPortFuncEvent</u> is to be a process identifier (pid),
              port identifier, or  one  of  the  atoms  <u>new</u>,  <u>new_processes</u>,  or  <u>new_ports</u>.  The  atom  <u>new</u>  or
              <u>new_processes</u> means that the default trace state for processes to be created is returned. The atom
              <u>new_ports</u> means that the default trace state for ports to be created is returned.

              Valid <u>Item</u>s for ports and processes:

                <u>flags</u>:
                  Returns a list of atoms indicating what kind of traces is enabled for the process. The list is
                  empty if no traces are enabled, and one or more of the followings atoms if traces are enabled:
                  <u>send</u>, <u>'receive'</u>, <u>set_on_spawn</u>, <u>call</u>, <u>return_to</u>, <u>procs</u>, <u>ports</u>, <u>set_on_first_spawn</u>, <u>set_on_link</u>,
                  <u>running</u>,     <u>running_procs</u>,     <u>running_ports</u>,     <u>silent</u>,    <u>exiting</u>,    <u>monotonic_timestamp</u>,
                  <u>strict_monotonic_timestamp</u>, <u>garbage_collection</u>, <u>timestamp</u>, and <u>arity</u>. The order is arbitrary.

                <u>tracer</u>:
                  Returns the identifier for process, port, or a tuple containing the tracer module  and  tracer
                  state tracing this process. If this process is not traced, the return value is <u>[]</u>.

              <u>To</u>  <u>get</u>  <u>information</u>  <u>about</u> <u>a</u> <u>function</u>, <u>PidPortFuncEvent</u> is to be the three-element tuple <u>{Module,</u>
              <u>Function,</u> <u>Arity}</u> or the atom <u>on_load</u>. No wildcards are allowed. Returns <u>undefined</u> if the  function
              does  not  exist,  or  <u>false</u>  if  the  function is not traced. If <u>PidPortFuncEvent</u> is <u>on_load</u>, the
              information returned refers to the default value for code that will be loaded.

              Valid <u>Item</u>s for functions:

                <u>traced</u>:
                  Returns <u>global</u> if this function is traced on global function calls, <u>local</u> if this function  is
                  traced  on local function calls (that is, local and global function calls), and <u>false</u> if local
                  or global function calls are not traced.

                <u>match_spec</u>:
                  Returns the match specification for this function, if it has one. If the function  is  locally
                  or globally traced but has no match specification defined, the returned value is <u>[]</u>.

                <u>meta</u>:
                  Returns the meta-trace tracer process, port, or trace module for this function, if it has one.
                  If  the  function  is  not  meta-traced, the returned value is <u>false</u>. If the function is meta-
                  traced but has once detected that the tracer process is invalid, the returned value is <u>[]</u>.

                <u>meta_match_spec</u>:
                  Returns the meta-trace match specification for this function, if it has one. If  the  function
                  is meta-traced but has no match specification defined, the returned value is <u>[]</u>.

                <u>call_count</u>:
                  Returns the call count value for this function or <u>true</u> for the pseudo function <u>on_load</u> if call
                  count tracing is active. Otherwise <u>false</u> is returned.

                  See also <u>erlang:trace_pattern/3</u>.

                <u>call_time</u>:
                  Returns the call time values for this function or <u>true</u> for the pseudo function <u>on_load</u> if call
                  time  tracing  is  active.  Otherwise <u>false</u> is returned. The call time values returned, <u>[{Pid,</u>
                  <u>Count,</u> <u>S,</u> <u>Us}]</u>, is a list of  each  process  that  executed  the  function  and  its  specific
                  counters.

                  See also <u>erlang:trace_pattern/3</u>.

                <u>all</u>:
                  Returns a list containing the <u>{Item,</u> <u>Value}</u> tuples for all other items, or returns <u>false</u> if no
                  tracing is active for this function.

              <u>To</u> <u>get</u> <u>information</u> <u>about</u> <u>an</u> <u>event</u>, <u>PidPortFuncEvent</u> is to be one of the atoms <u>send</u> or <u>'receive'</u>.

              One valid <u>Item</u> for events exists:

                <u>match_spec</u>:
                  Returns  the  match  specification  for  this  event,  if  it  has  one,  or  <u>true</u> if no match
                  specification has been set.

              The return value is <u>{Item,</u> <u>Value}</u>, where <u>Value</u> is the requested information as described  earlier.
              If  a  pid  for  a  dead  process  was specified, or the name of a non-existing function, <u>Value</u> is
              <u>undefined</u>.

       <b>erlang:trace_pattern(MFA,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 MFA = trace_pattern_mfa() | send | 'receive'
                 MatchSpec =
                     (MatchSpecList :: trace_match_spec()) |
                     boolean() |
                     restart | pause
                 <b>trace_pattern_mfa()</b> = {atom(), atom(), arity() | '_'} | on_load
                 <b>trace_match_spec()</b> =
                     [{[term()] | '_' | match_variable(), [term()], [term()]}]
                 <b>match_variable()</b> = atom()
                    Approximation of '$1' | '$2' | '$3' | ...

              The same as <u>erlang:trace_pattern(Event,</u> <u>MatchSpec,</u> <u>[])</u>, retained for backward compatibility.

       <b>erlang:trace_pattern(MFA</b> <b>::</b> <b>send,</b> <b>MatchSpec,</b> <b>FlagList</b> <b>::</b> <b>[])</b> <b>-&gt;</b>
                               integer() &gt;= 0

              Types:

                 MatchSpec = (MatchSpecList :: trace_match_spec()) | boolean()
                 <b>trace_match_spec()</b> =
                     [{[term()] | '_' | match_variable(), [term()], [term()]}]
                 <b>match_variable()</b> = atom()
                    Approximation of '$1' | '$2' | '$3' | ...

              Sets trace pattern for <u>message</u> <u>sending</u>. Must be combined with <u>erlang:trace/3</u> to set the <u>send</u> trace
              flag for one or more processes. By default all  messages  sent  from  <u>send</u>  traced  processes  are
              traced.  To limit traced send events based on the message content, the sender and/or the receiver,
              use <u>erlang:trace_pattern/3</u>.

              Argument <u>MatchSpec</u> can take the following forms:

                <u>MatchSpecList</u>:
                  A list of match specifications. The matching is done on the list <u>[Receiver,</u> <u>Msg]</u>. <u>Receiver</u>  is
                  the  process  or  port  identity  of  the receiver and <u>Msg</u> is the message term. The pid of the
                  sending process can be accessed with the guard function <u>self/0</u>. An empty list is the  same  as
                  <u>true</u>. For more information, see section  Match Specifications in Erlang in the User's Guide.

                <u>true</u>:
                  Enables tracing for all sent messages (from <u>send</u> traced processes). Any match specification is
                  removed. <u>This</u> <u>is</u> <u>the</u> <u>default</u>.

                <u>false</u>:
                  Disables tracing for all sent messages. Any match specification is removed.

              Argument <u>FlagList</u> must be <u>[]</u> for send tracing.

              The return value is always <u>1</u>.

              Examples:

              Only trace messages to a specific process <u>Pid</u>:

              &gt; erlang:trace_pattern(send, [{[Pid, '_'],[],[]}], []).
              1

              Only trace messages matching <u>{reply,</u> <b>_</b><u>}</u>:

              &gt; erlang:trace_pattern(send, [{['_', {reply,'_'}],[],[]}], []).
              1

              Only trace messages sent to the sender itself:

              &gt; erlang:trace_pattern(send, [{['$1', '_'],[{'=:=','$1',{self}}],[]}], []).
              1

              Only trace messages sent to other nodes:

              &gt; erlang:trace_pattern(send, [{['$1', '_'],[{'=/=',{node,'$1'},{node}}],[]}], []).
              1

          <b>Note:</b>
              A match specification for <u>send</u> trace can use all guard and body functions except <u>caller</u>.

              Fails by raising an error exception with an error reason of:

                <u>badarg</u>:
                  If an argument is invalid.

                <u>system_limit</u>:
                  If a match specification passed as argument has excessive nesting which causes scheduler stack
                  exhaustion  for  the  scheduler that the calling process is executing on. Scheduler stack size
                  can be configured when starting the runtime system.

       <b>erlang:trace_pattern(MFA</b> <b>::</b> <b>'receive',</b> <b>MatchSpec,</b> <b>FlagList</b> <b>::</b> <b>[])</b> <b>-&gt;</b>
                               integer() &gt;= 0

              Types:

                 MatchSpec = (MatchSpecList :: trace_match_spec()) | boolean()
                 <b>trace_match_spec()</b> =
                     [{[term()] | '_' | match_variable(), [term()], [term()]}]
                 <b>match_variable()</b> = atom()
                    Approximation of '$1' | '$2' | '$3' | ...

              Sets trace pattern for <u>message</u>  <u>receiving</u>.  Must  be  combined  with  <u>erlang:trace/3</u>  to  set  the
              <u>'receive'</u>  trace  flag  for  one  or more processes. By default all messages received by <u>'receive'</u>
              traced processes are traced. To limit traced receive events based  on  the  message  content,  the
              sender and/or the receiver, use <u>erlang:trace_pattern/3</u>.

              Argument <u>MatchSpec</u> can take the following forms:

                <u>MatchSpecList</u>:
                  A  list of match specifications. The matching is done on the list <u>[Node,</u> <u>Sender,</u> <u>Msg]</u>. <u>Node</u> is
                  the node name of the sender. <u>Sender</u> is the process or port identity of the sender, or the atom
                  <u>undefined</u> if the sender is not known (which can be the case for remote senders).  <u>Msg</u>  is  the
                  message term. The pid of the receiving process can be accessed with the guard function <u>self/0</u>.
                  An  empty list is the same as <u>true</u>. For more information, see section  Match Specifications in
                  Erlang in the User's Guide.

                <u>true</u>:
                  Enables tracing  for  all  received  messages  (to  <u>'receive'</u>  traced  processes).  Any  match
                  specification is removed. <u>This</u> <u>is</u> <u>the</u> <u>default</u>.

                <u>false</u>:
                  Disables tracing for all received messages. Any match specification is removed.

              Argument <u>FlagList</u> must be <u>[]</u> for receive tracing.

              The return value is always <u>1</u>.

              Examples:

              Only trace messages from a specific process <u>Pid</u>:

              &gt; erlang:trace_pattern('receive', [{['_',Pid, '_'],[],[]}], []).
              1

              Only trace messages matching <u>{reply,</u> <b>_</b><u>}</u>:

              &gt; erlang:trace_pattern('receive', [{['_','_', {reply,'_'}],[],[]}], []).
              1

              Only trace messages from other nodes:

              &gt; erlang:trace_pattern('receive', [{['$1', '_', '_'],[{'=/=','$1',{node}}],[]}], []).
              1

          <b>Note:</b>
              A  match  specification  for  <u>'receive'</u>  trace can use all guard and body functions except <u>caller</u>,
              <u>is_seq_trace</u>,  <u>get_seq_token</u>,  <u>set_seq_token</u>,  <u>enable_trace</u>,  <u>disable_trace</u>,  <u>trace</u>,  <u>silent</u>,  and
              <u>process_dump</u>.

              Fails by raising an error exception with an error reason of:

                <u>badarg</u>:
                  If an argument is invalid.

                <u>system_limit</u>:
                  If a match specification passed as argument has excessive nesting which causes scheduler stack
                  exhaustion  for  the  scheduler that the calling process is executing on. Scheduler stack size
                  can be configured when starting the runtime system.

       <b>erlang:trace_pattern(MFA,</b> <b>MatchSpec,</b> <b>FlagList)</b> <b>-&gt;</b>
                               integer() &gt;= 0

              Types:

                 MFA = trace_pattern_mfa()
                 MatchSpec =
                     (MatchSpecList :: trace_match_spec()) |
                     boolean() |
                     restart | pause
                 FlagList = [trace_pattern_flag()]
                 <b>trace_pattern_mfa()</b> = {atom(), atom(), arity() | '_'} | on_load
                 <b>trace_match_spec()</b> =
                     [{[term()] | '_' | match_variable(), [term()], [term()]}]
                 <b>trace_pattern_flag()</b> =
                     global | local | meta |
                     {meta, Pid :: pid()} |
                     {meta, TracerModule :: module(), TracerState :: term()} |
                     call_count | call_time
                 <b>match_variable()</b> = atom()
                    Approximation of '$1' | '$2' | '$3' | ...

              Enables or disables <u>call</u> <u>tracing</u> for one or more functions. Must be combined  with  <u>erlang:trace/3</u>
              to set the <u>call</u> trace flag for one or more processes.

              Conceptually, call tracing works as follows. Inside the Erlang virtual machine, a set of processes
              and  a  set  of functions are to be traced. If a traced process calls a traced function, the trace
              action is taken. Otherwise, nothing happens.

              To add or remove one or more processes to the set of traced processes, use <u>erlang:trace/3</u>.

              To add or remove functions to the set of traced functions, use <u>erlang:trace_pattern/3</u>.

              The BIF  <u>erlang:trace_pattern/3</u>  can  also  add  match  specifications  to  a  function.  A  match
              specification  comprises a pattern that the function arguments must match, a guard expression that
              must evaluate to <u>true</u>, and an action to be performed. The  default  action  is  to  send  a  trace
              message. If the pattern does not match or the guard fails, the action is not executed.

              Argument  <u>MFA</u>  is to be a tuple, such as <u>{Module,</u> <u>Function,</u> <u>Arity}</u>, or the atom <u>on_load</u> (described
              below). It can be the module, function, and arity for a function (or a BIF  in  any  module).  The
              atom <u>'_'</u> can be used as a wildcard in any of the following ways:

                <u>{Module,Function,'_'}</u>:
                  All functions of any arity named <u>Function</u> in module <u>Module</u>.

                <u>{Module,'_','_'}</u>:
                  All functions in module <u>Module</u>.

                <u>{'_','_','_'}</u>:
                  All functions in all loaded modules.

              Other  combinations,  such as <u>{Module,'_',Arity}</u>, are not allowed. Local functions match wildcards
              only if option <u>local</u> is in <u>FlagList</u>.

              If argument <u>MFA</u> is the atom <u>on_load</u>, the match specification and flag list are used on all modules
              that are newly loaded.

              Argument <u>MatchSpec</u> can take the following forms:

                <u>false</u>:
                  Disables tracing for the matching functions. Any match specification is removed.

                <u>true</u>:
                  Enables tracing for the matching functions. Any match specification is removed.

                <u>MatchSpecList</u>:
                  A list of match specifications. An empty list is equivalent to  <u>true</u>.  For  a  description  of
                  match specifications, see section  Match Specifications in Erlang in the User's Guide.

                <u>restart</u>:
                  For  the  <u>FlagList</u>  options  <u>call_count</u>  and  <u>call_time</u>:  restarts  the existing counters. The
                  behavior is undefined for other <u>FlagList</u> options.

                <u>pause</u>:
                  For the <u>FlagList</u> options <u>call_count</u> and <u>call_time</u>: pauses the existing counters. The  behavior
                  is undefined for other <u>FlagList</u> options.

              Parameter <u>FlagList</u> is a list of options. The following are the valid options:

                <u>global</u>:
                  Turns  on  or off call tracing for global function calls (that is, calls specifying the module
                  explicitly). Only exported functions match and only global calls generate trace messages. <u>This</u>
                  <u>is</u> <u>the</u> <u>default</u>.

                <u>local</u>:
                  Turns on or off call tracing for all types of function calls. Trace messages are sent whenever
                  any of the specified functions are  called,  regardless  of  how  they  are  called.  If  flag
                  <u>return_to</u>  is set for the process, a <u>return_to</u> message is also sent when this function returns
                  to its caller.

                <u>meta</u> <u>|</u> <u>{meta,</u> <u>Pid}</u> <u>|</u> <u>{meta,</u> <u>TracerModule,</u> <u>TracerState}</u>:
                  Turns on or off meta-tracing for all types of function calls. Trace messages are sent  to  the
                  tracer  whenever  any of the specified functions are called. If no tracer is specified, <u>self()</u>
                  is used as a default tracer process.

                  Meta-tracing traces all processes and does not care about  the  process  trace  flags  set  by
                  <u>erlang:trace/3</u>, the trace flags are instead fixed to <u>[call,</u> <u>timestamp]</u>.

                  The  match  specification  function  <u>{return_trace}</u>  works with meta-trace and sends its trace
                  message to the same tracer.

                <u>call_count</u>:
                  Starts (<u>MatchSpec</u> <u>==</u> <u>true</u>) or stops (<u>MatchSpec</u> <u>==</u> <u>false</u>) call count tracing for all  types  of
                  function  calls.  For every function, a counter is incremented when the function is called, in
                  any process. No process trace flags need to be activated.

                  If call count tracing is started while already running, the count is restarted from  zero.  To
                  pause  running  counters, use <u>MatchSpec</u> <u>==</u> <u>pause</u>. Paused and running counters can be restarted
                  from zero with <u>MatchSpec</u> <u>==</u> <u>restart</u>.

                  To read the counter value, use <u>erlang:trace_info/2</u>.

                <u>call_time</u>:
                  Starts (<u>MatchSpec</u> <u>==</u> <u>true</u>) or stops (<u>MatchSpec</u> <u>==</u> <u>false</u>) call time tracing for  all  types  of
                  function calls. For every function, a counter is incremented when the function is called. Time
                  spent  in  the  function  is  accumulated in two other counters, seconds and microseconds. The
                  counters are stored for each call traced process.

                  If call time tracing is started while already running, the count and time restart  from  zero.
                  To  pause  running  counters,  use  <u>MatchSpec</u>  <u>==</u>  <u>pause</u>.  Paused  and running counters can be
                  restarted from zero with <u>MatchSpec</u> <u>==</u> <u>restart</u>.

                  To read the counter value, use <u>erlang:trace_info/2</u>.

              The options <u>global</u> and <u>local</u> are mutually exclusive, and <u>global</u> is the default (if no options  are
              specified).  The  options  <u>call_count</u>  and  <u>meta</u>  perform  a  kind of local tracing, and cannot be
              combined with <u>global</u>. A function can be globally or locally traced. If global tracing is specified
              for a set of functions, then local, meta, call time, and call count tracing for the  matching  set
              of local functions is disabled, and conversely.

              When  disabling trace, the option must match the type of trace set on the function. That is, local
              tracing must be disabled with option <u>local</u> and global tracing with option <u>global</u> (or  no  option),
              and so on.

              Part  of  a  match  specification  list  cannot  be  changed  directly.  If a function has a match
              specification, it can be replaced with a new one. To change an existing match  specification,  use
              the BIF <u>erlang:trace_info/2</u> to retrieve the existing match specification.

              Returns the number of functions matching argument <u>MFA</u>. This is zero if none matched.

              Fails by raising an error exception with an error reason of:

                <u>badarg</u>:
                  If an argument is invalid.

                <u>system_limit</u>:
                  If a match specification passed as argument has excessive nesting which causes scheduler stack
                  exhaustion  for  the  scheduler that the calling process is executing on. Scheduler stack size
                  can be configured when starting the runtime system.

       <b>trunc(Number)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 Number = number()

              Truncates the decimals of <u>Number</u>, for example:

              &gt; trunc(5.7).
              5

              &gt; trunc(-5.7).
              -5

              &gt; <a href="../man5/trunc.5.html">trunc</a>(5).
              5

              &gt; trunc(36028797018963969.0).
              36028797018963968

              In the last example, <u>trunc(36028797018963969.0)</u> evaluates to  <u>36028797018963968</u>.  The  reason  for
              this  is  that  the  number  <u>36028797018963969.0</u>  cannot  be represented exactly as a float value.
              Instead, the float literal is represented as <u>36028797018963968.0</u>, which is the closest number that
              can be represented exactly as a float value. See Representation  of  Floating  Point  Numbers  for
              additional information.

              Allowed in guard tests.

       <b>tuple_size(Tuple)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Tuple = tuple()

              Returns an integer that is the number of elements in <u>Tuple</u>, for example:

              &gt; tuple_size({morni, mulle, bwange}).
              3

              Allowed in guard tests.

       <b>tuple_to_list(Tuple)</b> <b>-&gt;</b> <b>[term()]</b>

              Types:

                 Tuple = tuple()

              Returns a list corresponding to <u>Tuple</u>. <u>Tuple</u> can contain any Erlang terms. Example:

              &gt; tuple_to_list({share, {'Ericsson_B', 163}}).
              [share,{'Ericsson_B',163}]

       <b>unalias(Alias)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Alias = reference()

              Deactivate  the alias <u>Alias</u> previously created by the calling process. An alias can for example be
              created via <u>alias/0</u>, or <u>monitor/3</u>. <u>unalias/1</u>  will  always  deactivate  the  alias  regardless  of
              options used when creating the alias.

              Returns true if <u>Alias</u> was a currently active alias for current processes; otherwise, false.

              For  more  information on process aliases see the <u>Process</u> <u>Aliases</u>  section of the <u>Erlang</u> <u>Reference</u>
              <u>Manual</u> .

       <b>erlang:unique_integer()</b> <b>-&gt;</b> <b>integer()</b>

              Generates and returns an  integer unique on current runtime system instance. The same  as  calling
              <u>erlang:unique_integer([])</u>.

       <b>erlang:unique_integer(ModifierList)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 ModifierList = [Modifier]
                 Modifier = positive | monotonic

              Generates and returns an  integer unique on current runtime system instance. The integer is unique
              in the sense that this BIF, using the same set of modifiers, does not return the same integer more
              than  once on the current runtime system instance. Each integer value can of course be constructed
              by other means.

              By default, when <u>[]</u> is passed  as  <u>ModifierList</u>,  both  negative  and  positive  integers  can  be
              returned.  This  to  use  the range of integers that do not need heap memory allocation as much as
              possible. By default the returned integers are also only guaranteed to be  unique,  that  is,  any
              returned integer can be smaller or larger than previously returned integers.

              <u>Modifier</u>s:

                <b>positive:</b>
                  Returns only positive integers.

                  Notice  that  by  passing the <u>positive</u> modifier you will get heap allocated integers (bignums)
                  quicker.

                <b>monotonic:</b>
                  Returns  strictly monotonically increasing integers corresponding to creation time.  That  is,
                  the integer returned is always larger than previously returned integers on the current runtime
                  system instance.

                  These  values  can  be  used to determine order between events on the runtime system instance.
                  That    is,    if    both    <u>X</u>    <u>=</u>     <u>erlang:unique_integer([monotonic])</u>     and     <u>Y</u>     <u>=</u>
                  <u>erlang:unique_integer([monotonic])</u>  are  executed by different processes (or the same process)
                  on the same runtime system instance and <u>X</u> <u>&lt;</u> <u>Y</u>, we know that <u>X</u> was created before <u>Y</u>.

            <b>Warning:</b>
                Strictly monotonically increasing values are inherently quite expensive to generate  and  scales
                poorly.  This  is  because the values need to be synchronized between CPU cores. That is, do not
                pass the <u>monotonic</u> modifier unless you really need strictly monotonically increasing values.

              All valid <u>Modifier</u>s can be combined. Repeated (valid) <u>Modifier</u>s in the <u>ModifierList</u> are ignored.

          <b>Note:</b>
              The set of integers returned by <u>erlang:unique_integer/1</u> using different  sets  of  <u>Modifier</u>s  <u>will</u>
              <u>overlap</u>.  For  example,  by  calling  <u>unique_integer([monotonic])</u>,  and  <u>unique_integer([positive,</u>
              <u>monotonic])</u> repeatedly, you will eventually see some integers that are returned by both calls.

              Failures:

                <u>badarg</u>:
                  if <u>ModifierList</u> is not a proper list.

                <u>badarg</u>:
                  if <u>Modifier</u> is not a valid modifier.

       <b>erlang:universaltime()</b> <b>-&gt;</b> <b>DateTime</b>

              Types:

                 DateTime = calendar:datetime()

              Returns the current date and time according to  Universal  Time  Coordinated  (UTC)  in  the  form
              <u>{{Year,</u>  <u>Month,</u>  <u>Day},</u>  <u>{Hour,</u>  <u>Minute,</u>  <u>Second}}</u>  if  supported  by  the underlying OS. Otherwise
              <u>erlang:universaltime()</u> is equivalent to <u>erlang:localtime()</u>. The return value is based  on  the  OS
              System Time. Example:

              &gt; erlang:universaltime().
              {{1996,11,6},{14,18,43}}

       <b>erlang:universaltime_to_localtime(Universaltime)</b> <b>-&gt;</b> <b>Localtime</b>

              Types:

                 Localtime = Universaltime = calendar:datetime()

              Converts Universal Time Coordinated (UTC) date and time to local date and time in the form <u>{{Year,</u>
              <u>Month,</u> <u>Day},</u> <u>{Hour,</u> <u>Minute,</u> <u>Second}}</u> if supported by the underlying OS. Otherwise no conversion is
              done, and <u>Universaltime</u> is returned. Example:

              &gt; erlang:universaltime_to_localtime({{1996,11,6},{14,18,43}}).
              {{1996,11,7},{15,18,43}}

              Failure: <u>badarg</u> if <u>Universaltime</u> denotes an invalid date and time.

       <b>unlink(Id)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Id = pid() | port()

              Removes a link between the calling process and another process or a port identified by <u>Id</u>. We will
              from here on call the identified process or port unlinkee.

              A  link  can be set up using the <u>link/1</u> BIF. For more information on links and exit signals due to
              links, see the <u>Processes</u>  chapter in the <u>Erlang</u> <u>Reference</u> <u>Manual</u> :

                * Links

                * Sending Exit Signals

                * Receiving Exit Signals

              Once <u>unlink(Id)</u> has returned, it is guaranteed that the link between the caller and  the  unlinkee
              has  no  effect  on  the  caller  in the future (unless the link is setup again). Note that if the
              caller is trapping exits, an <u>{'EXIT',</u> <u>Id,</u> <u>ExitReason}</u> message due to the link may have been placed
              in the message queue of the caller before the  <u>unlink(Id)</u>  call  completed.  Also  note  that  the
              <u>{'EXIT',</u>  <u>Id,</u> <u>ExitReason}</u> message may be the result of the link, but may also be the result of the
              unlikee sending the caller an exit signal by calling the <u>exit/2</u> BIF. Therefore, it may or may  not
              be  appropriate to clean up the message queue after a call to <u>unlink(Id)</u> as follows, when trapping
              exits:

              unlink(Id),
              receive
                  {'EXIT', Id, _} -&gt;
                      true
              after 0 -&gt;
                      true
              end

              The link removal is performed asynchronously. If such a link does not exist, nothing  is  done.  A
              detailed  description  of  the link protocol can be found in the <u>Distribution</u> <u>Protocol</u>  chapter of
              the <u>ERTS</u> <u>User's</u> <u>Guide</u> .

              Failure: <u>badarg</u> if <u>Id</u> does not identify a process or a node local port.

       <b>unregister(RegName)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 RegName = atom()

              Removes the <u>registered</u> <u>name</u> <u>RegName</u> associated with a process identifier or a port identifier from
              the <u>name</u> <u>registry</u>. For example:

              &gt; unregister(db).
              true

              Keep in mind that you can still receive signals associated with the registered name after  it  has
              been unregistered as the sender may have looked up the name before sending to it.

              Users are advised not to unregister system processes.

              Failure: <u>badarg</u> if <u>RegName</u> is not a registered name.

       <b>whereis(RegName)</b> <b>-&gt;</b> <b>pid()</b> <b>|</b> <b>port()</b> <b>|</b> <b>undefined</b>

              Types:

                 RegName = atom()

              Returns  the  process identifier or port identifier with the <u>registered</u> <u>name</u> <u>RegName</u> from the <u>name</u>
              <u>registry</u>. Returns <u>undefined</u> if the name is not registered. Example:

              &gt; whereis(db).
              &lt;0.43.0&gt;

       <b>erlang:yield()</b> <b>-&gt;</b> <b>true</b>

              Tries to give other processes with the same or higher priority (if any) a chance to execute before
              returning. There is no guarantee that any other process runs between the invocation and return  of
              <u>erlang:yield/0</u>.

              See  the documentation for <u>receive-after</u> expressions for how to make the current process sleep for
              a specific number of milliseconds.

          <b>Warning:</b>
              There is seldom or never any need to use this BIF. Using this BIF without a thorough grasp of  how
              the scheduler works can cause performance degradation. The current implementation of this function
              puts  the current process last in the current scheduler's queue for processes of the same priority
              as the current process.

Ericsson AB                                        erts 12.2.1                                      <u><a href="../man3erl/erlang.3erl.html">erlang</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>