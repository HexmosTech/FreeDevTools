<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>net_kernel - Erlang networking kernel.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       net_kernel - Erlang networking kernel.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  net  kernel is a system process, registered as <u>net_kernel</u>, which must be operational for distributed
       Erlang to work. The purpose of this process is to implement parts of the BIFs <u>spawn/4</u>  and  <u>spawn_link/4</u>,
       and to provide monitoring of the network.

       An Erlang node is started using command-line flag <u>-name</u> or <u>-sname</u>:

       $ erl -sname foobar

       It is also possible to call <u>net_kernel:start([foobar])</u> directly from the normal Erlang shell prompt:

       1&gt; net_kernel:start([foobar, shortnames]).
       {ok,&lt;0.64.0&gt;}
       (foobar@gringotts)2&gt;

       If  the  node  is  started with command-line flag <u>-sname</u>, the node name is <u>foobar@Host</u>, where <u>Host</u> is the
       short name of the host (not the fully qualified domain name). If started with flag <u>-name</u>, the  node  name
       is <u>foobar@Host</u>, where <u>Host</u> is the fully qualified domain name. For more information, see <u>erl</u>.

       Normally,  connections  are established automatically when another node is referenced. This functionality
       can be disabled by setting Kernel configuration parameter <u>dist_auto_connect</u> to <u>never</u>, see  <u><a href="../man7/kernel.7.html">kernel</a>(7)</u>.  In
       this case, connections must be established explicitly by calling <u>connect_node/1</u>.

       Which  nodes  that  are allowed to communicate with each other is handled by the magic cookie system, see
       section Distributed Erlang in the Erlang Reference Manual.

   <b>Warning:</b>
       Starting a distributed node without also specifying <u>-proto_dist</u> <u>inet_tls</u> will expose the node to  attacks
       that may give the attacker complete access to the node and in extension the cluster. When using un-secure
       distributed  nodes,  make  sure  that  the network is configured to keep potential attackers out. See the
       Using SSL for Erlang Distribution User's Guide for details on how to setup a secure distributed node.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>allow(Nodes)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>error</b>

              Types:

                 Nodes = [node()]

              Permits access to the specified set of nodes.

              Before the first call to <u>allow/1</u>, any node with the correct cookie can be connected. When  <u>allow/1</u>
              is called, a list of allowed nodes is established. Any access attempts made from (or to) nodes not
              in that list will be rejected.

              Subsequent  calls  to <u>allow/1</u> will add the specified nodes to the list of allowed nodes. It is not
              possible to remove nodes from the list.

              Returns <u>error</u> if any element in <u>Nodes</u> is not an atom.

       <b>connect_node(Node)</b> <b>-&gt;</b> <b>boolean()</b> <b>|</b> <b>ignored</b>

              Types:

                 Node = node()

              Establishes a connection to <u>Node</u>. Returns <u>true</u> if a connection  was  established  or  was  already
              established  or  if <u>Node</u> is the local node itself. Returns <u>false</u> if the connection attempt failed,
              and <u>ignored</u> if the local node is not alive.

       <b>get_net_ticktime()</b> <b>-&gt;</b> <b>Res</b>

              Types:

                 Res = NetTicktime | {ongoing_change_to, NetTicktime} | ignored
                 NetTicktime = integer() &gt;= 1

              Gets <u>net_ticktime</u> (see <u><a href="../man7/kernel.7.html">kernel</a>(7)</u>).

              Defined return values (<u>Res</u>):

                <u>NetTicktime</u>:
                  <u>net_ticktime</u> is <u>NetTicktime</u> seconds.

                <u>{ongoing_change_to,</u> <u>NetTicktime}</u>:
                  <u>net_kernel</u> is currently changing <u>net_ticktime</u> to <u>NetTicktime</u> seconds.

                <u>ignored</u>:
                  The local node is not alive.

       <b>getopts(Node,</b> <b>Options)</b> <b>-&gt;</b>
                  {ok, OptionValues} | {error, Reason} | ignored

              Types:

                 Node = node()
                 Options = [inet:socket_getopt()]
                 OptionValues = [inet:socket_setopt()]
                 Reason = inet:posix() | noconnection

              Get one or more options for the distribution socket connected to <u>Node</u>.

              If <u>Node</u> is a connected node the return value is the same as from <u>inet:getopts(Sock,</u> <u>Options)</u> where
              <u>Sock</u> is the distribution socket for <u>Node</u>.

              Returns <u>ignored</u> if the local node is not alive or <u>{error,</u> <u>noconnection}</u> if <u>Node</u> is not connected.

       <b>monitor_nodes(Flag)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

       <b>monitor_nodes(Flag,</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 Flag = boolean()
                 Options = [Option]
                 Option = {node_type, NodeType} | nodedown_reason
                 NodeType = visible | hidden | all
                 Error = error | {error, term()}

              The calling process subscribes or unsubscribes to node status change messages. A <u>nodeup</u> message is
              delivered to all subscribing processes when a new node is connected, and  a  <u>nodedown</u>  message  is
              delivered when a node is disconnected.

              If  <u>Flag</u>  is  <u>true</u>,  a  new  subscription is started. If <u>Flag</u> is <u>false</u>, all previous subscriptions
              started with the same <u>Options</u> are stopped. Two option  lists  are  considered  the  same  if  they
              contain the same set of options.

              As from Kernel version 2.11.4, and ERTS version 5.5.4, the following is guaranteed:

                * <u>nodeup</u>  messages  are  delivered  before  delivery  of any message from the remote node passed
                  through the newly established connection.

                * <u>nodedown</u> messages are not delivered until all messages from the remote  node  that  have  been
                  passed through the connection have been delivered.

              Notice that this is <u>not</u> guaranteed for Kernel versions before 2.11.4.

              As  from  Kernel  version  2.11.4,  subscriptions can also be made before the <u>net_kernel</u> server is
              started, that is, <u>net_kernel:monitor_nodes/[1,2]</u> does not return <u>ignored</u>.

              As from Kernel version 2.13, and ERTS version 5.7, the following is guaranteed:

                * <u>nodeup</u>  messages  are  delivered  after  the  corresponding  node  appears  in  results   from
                  <u>erlang:nodes/X</u>.

                * <u>nodedown</u>  messages  are delivered after the corresponding node has disappeared in results from
                  <u>erlang:nodes/X</u>.

              Notice that this is <u>not</u> guaranteed for Kernel versions before 2.13.

              The format of the node status change messages depends on <u>Options</u>. If <u>Options</u> is <u>[]</u>, which  is  the
              default, the format is as follows:

              {nodeup, Node} | {nodedown, Node}
                Node = node()

              If <u>Options</u> is not <u>[]</u>, the format is as follows:

              {nodeup, Node, InfoList} | {nodedown, Node, InfoList}
                Node = node()
                InfoList = [{Tag, Val}]

              <u>InfoList</u> is a list of tuples. Its contents depends on <u>Options</u>, see below.

              Also,  when  <u>OptionList</u>  <u>==</u>  <u>[]</u>,  only  visible nodes, that is, nodes that appear in the result of
              <u>erlang:nodes/0</u>, are monitored.

              <u>Option</u> can be any of the following:

                <u>{node_type,</u> <u>NodeType}</u>:
                  Valid values for <u>NodeType</u>:

                  <u>visible</u>:
                    Subscribe to node status change messages for  visible  nodes  only.  The  tuple  <u>{node_type,</u>
                    <u>visible}</u> is included in <u>InfoList</u>.

                  <u>hidden</u>:
                    Subscribe  to  node  status  change  messages  for  hidden nodes only. The tuple <u>{node_type,</u>
                    <u>hidden}</u> is included in <u>InfoList</u>.

                  <u>all</u>:
                    Subscribe to node status change messages for  both  visible  and  hidden  nodes.  The  tuple
                    <u>{node_type,</u> <u>visible</u> <u>|</u> <u>hidden}</u> is included in <u>InfoList</u>.

                <u>nodedown_reason</u>:
                  The tuple <u>{nodedown_reason,</u> <u>Reason}</u> is included in <u>InfoList</u> in <u>nodedown</u> messages.

                  <u>Reason</u>  can,  depending  on which distribution module or process that is used be any term, but
                  for the standard TCP distribution module it is any of the following:

                  <u>connection_setup_failed</u>:
                    The connection setup failed (after <u>nodeup</u> messages were sent).

                  <u>no_network</u>:
                    No network is available.

                  <u>net_kernel_terminated</u>:
                    The <u>net_kernel</u> process terminated.

                  <u>shutdown</u>:
                    Unspecified connection shutdown.

                  <u>connection_closed</u>:
                    The connection was closed.

                  <u>disconnect</u>:
                    The connection was disconnected (forced from the current node).

                  <u>net_tick_timeout</u>:
                    Net tick time-out.

                  <u>send_net_tick_failed</u>:
                    Failed to send net tick over the connection.

                  <u>get_status_failed</u>:
                    Status information retrieval from the <u>Port</u> holding the connection failed.

       <b>set_net_ticktime(NetTicktime)</b> <b>-&gt;</b> <b>Res</b>

       <b>set_net_ticktime(NetTicktime,</b> <b>TransitionPeriod)</b> <b>-&gt;</b> <b>Res</b>

              Types:

                 NetTicktime = integer() &gt;= 1
                 TransitionPeriod = integer() &gt;= 0
                 Res =
                     unchanged | change_initiated |
                     {ongoing_change_to, NewNetTicktime}
                 NewNetTicktime = integer() &gt;= 1

              Sets <u>net_ticktime</u> (see <u><a href="../man7/kernel.7.html">kernel</a>(7)</u>) to <u>NetTicktime</u> seconds. <u>TransitionPeriod</u> defaults to <u>60</u>.

              Some definitions:

                <b>Minimum</b> <b>transition</b> <b>traffic</b> <b>interval</b> <b>(</b><u>MTTI</u>):
                  <u>minimum(NetTicktime,</u> <u>PreviousNetTicktime)*1000</u> <u>div</u> <u>4</u> milliseconds.

                <b>Transition</b> <b>period:</b>
                  The time of the least number of consecutive <u>MTTI</u>s to cover <u>TransitionPeriod</u> seconds  following
                  the  call  to  <u>set_net_ticktime/2</u>  (that  is,  ((<u>TransitionPeriod*1000</u> <u>-</u> <u>1)</u> <u>div</u> <u>MTTI</u> <u>+</u> <u>1)*MTTI</u>
                  milliseconds).

              If <u>NetTicktime</u> <u>&lt;</u> <u>PreviousNetTicktime</u>, the <u>net_ticktime</u> change is done at the end of the transition
              period; otherwise at the beginning. During the transition period, <u>net_kernel</u> ensures that there is
              outgoing traffic on all connections at least every <u>MTTI</u> millisecond.

          <b>Note:</b>
              The <u>net_ticktime</u> changes must be initiated on all nodes in the network (with the same <u>NetTicktime</u>)
              before the end of any transition period on any node;  otherwise  connections  can  erroneously  be
              disconnected.

              Returns one of the following:

                <u>unchanged</u>:
                  <u>net_ticktime</u> already has the value of <u>NetTicktime</u> and is left unchanged.

                <u>change_initiated</u>:
                  <u>net_kernel</u> initiated the change of <u>net_ticktime</u> to <u>NetTicktime</u> seconds.

                <u>{ongoing_change_to,</u> <u>NewNetTicktime}</u>:
                  The  request  is  <u>ignored</u>  because  <u>net_kernel</u> is busy changing <u>net_ticktime</u> to <u>NewNetTicktime</u>
                  seconds.

       <b>setopts(Node,</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b> <b>|</b> <b>ignored</b>

              Types:

                 Node = node() | new
                 Options = [inet:socket_setopt()]
                 Reason = inet:posix() | noconnection

              Set one or more options for distribution sockets. Argument <u>Node</u> can be either one node name or the
              atom <u>new</u> to affect the distribution sockets of all future connected nodes.

              The return value is the same as from <u>inet:setopts/2</u> or <u>{error,</u> <u>noconnection}</u>  if  <u>Node</u>  is  not  a
              connected node or <u>new</u>.

              If  <u>Node</u>  is  <u>new</u>  the  <u>Options</u>  will  then  also  be  added  to  kernel  configration  parameters
              inet_dist_listen_options and inet_dist_connect_options.

              Returns <u>ignored</u> if the local node is not alive.

       <b>start([Name])</b> <b>-&gt;</b> <b>{ok,</b> <b>pid()}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>start([Name,</b> <b>NameType])</b> <b>-&gt;</b> <b>{ok,</b> <b>pid()}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>start([Name,</b> <b>NameType,</b> <b>Ticktime])</b> <b>-&gt;</b> <b>{ok,</b> <b>pid()}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = atom()
                 NameType = shortnames | longnames
                 Reason = {already_started, pid()} | term()

              Turns a non-distributed node into a distributed node by starting <u>net_kernel</u>  and  other  necessary
              processes.

              Notice that the argument is a list with exactly one, two, or three arguments. <u>NameType</u> defaults to
              <u>longnames</u> and <u>Ticktime</u> to <u>15000</u>.

       <b>stop()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Reason = not_allowed | not_found

              Turns  a distributed node into a non-distributed node. For other nodes in the network, this is the
              same as the node going down. Only  possible  when  the  net  kernel  was  started  using  <u>start/1</u>,
              otherwise  <u>{error,</u>  <u>not_allowed}</u>  is returned. Returns <u>{error,</u> <u>not_found}</u> if the local node is not
              alive.

Ericsson AB                                        kernel 8.2                                   <u><a href="../man3erl/net_kernel.3erl.html">net_kernel</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>