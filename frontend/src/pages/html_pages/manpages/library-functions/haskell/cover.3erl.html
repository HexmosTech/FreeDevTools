<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cover - A Coverage Analysis Tool for Erlang</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cover - A Coverage Analysis Tool for Erlang

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  module <u>cover</u> provides a set of functions for coverage analysis of Erlang programs, counting how many
       times each <u>executable</u> <u>line</u> of code is executed when a program is run.
       An executable line contains an Erlang expression such as a matching or a function call. A blank line or a
       line containing a comment, function head or pattern in a <u>case</u>- or <u>receive</u> statement is not executable.

       Coverage analysis can be used to verify test cases, making sure all relevant code  is  covered,  and  may
       also be helpful when looking for bottlenecks in the code.

       Before  any  analysis  can  take place, the involved modules must be <u>Cover</u> <u>compiled</u>. This means that some
       extra information is added to the module before it is compiled into a binary which then  is  loaded.  The
       source file of the module is not affected and no <u>.beam</u> file is created.

       Each  time  a  function  in  a Cover compiled module is called, information about the call is added to an
       internal database of Cover. The coverage analysis is performed by examining the  contents  of  the  Cover
       database. The output <u>Answer</u> is determined by two parameters, <u>Level</u> and <u>Analysis</u>.

         * <u>Level</u> <u>=</u> <u>module</u>

           <u>Answer</u> <u>=</u> <u>{Module,Value}</u>, where <u>Module</u> is the module name.

         * <u>Level</u> <u>=</u> <u>function</u>

           <u>Answer</u>  <u>=</u>  <u>[{Function,Value}]</u>,  one tuple for each function in the module. A function is specified by
           its module name <u>M</u>, function name <u>F</u> and arity <u>A</u> as a tuple <u>{M,F,A}</u>.

         * <u>Level</u> <u>=</u> <u>clause</u>

           <u>Answer</u> <u>=</u> <u>[{Clause,Value}]</u>, one tuple for each clause in the module. A  clause  is  specified  by  its
           module  name  <u>M</u>,  function  name  <u>F</u>,  arity  <u>A</u>  and  position in the function definition <u>C</u> as a tuple
           <u>{M,F,A,C}</u>.

         * <u>Level</u> <u>=</u> <u>line</u>

           <u>Answer</u> <u>=</u> <u>[{Line,Value}]</u>, one tuple for each executable line in the module. A line is specified by its
           module name <u>M</u> and line number in the source file <u>N</u> as a tuple <u>{M,N}</u>.

         * <u>Analysis</u> <u>=</u> <u>coverage</u>

           <u>Value</u> <u>=</u> <u>{Cov,NotCov}</u> where <u>Cov</u> is the number of executable lines in the module, function,  clause  or
           line that have been executed at least once and <u>NotCov</u> is the number of executable lines that have not
           been executed.

         * <u>Analysis</u> <u>=</u> <u>calls</u>

           <u>Value</u>  <u>=</u>  <u>Calls</u>  which is the number of times the module, function, or clause has been called. In the
           case of line level analysis, <u>Calls</u> is the number of times the line has been executed.

       <u>Distribution</u>

       Cover can be used in a distributed Erlang system. One of the nodes in the system must then be selected as
       the <u>main</u> <u>node</u>, and all Cover commands must be executed from this node. The error reason <u>not_main_node</u>  is
       returned if an interface function is called on one of the remote nodes.

       Use <u>cover:start/1</u> and <u>cover:stop/1</u> to add or remove nodes. The same Cover compiled code will be loaded on
       each node, and analysis will collect and sum up coverage data results from all nodes.

       To only collect data from remote nodes without stopping <u>cover</u> on those nodes, use <u>cover:flush/1</u>

       If  the connection to a remote node goes down, the main node will mark it as lost. If the node comes back
       it will be added again. If the remote node was alive during the disconnected  periode,  cover  data  from
       before and during this periode will be included in the analysis.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>start()</b> <b>-&gt;</b> <b>{ok,</b> <b>pid()}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Reason = {already_started, pid()} | term()

              Starts  the  Cover  server  which  owns  the  Cover  internal  database.  This  function is called
              automatically by the other functions in the module.

       <b>local_only()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>too_late}</b>

              Only support running Cover on the local node. This function must be called before any modules have
              been compiled or any nodes added. When running in this mode, modules will be Cover compiled  in  a
              more efficient way, but the resulting code will only work on the same node they were compiled on.

       <b>start(Nodes)</b> <b>-&gt;</b>
                {ok, StartedNodes} |
                {error, not_main_node} |
                {error, local_only}

              Types:

                 Nodes = node() | [node()]
                 StartedNodes = [node()]

              Starts  a Cover server on the each of given nodes, and loads all cover compiled modules. This call
              will fail if <u>cover:local_only/0</u> has been called.

       <b>compile(ModFiles)</b> <b>-&gt;</b> <b>Result</b> <b>|</b> <b>[Result]</b>

       <b>compile(ModFiles,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b> <b>|</b> <b>[Result]</b>

       <b>compile_module(ModFiles)</b> <b>-&gt;</b> <b>Result</b> <b>|</b> <b>[Result]</b>

       <b>compile_module(ModFiles,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b> <b>|</b> <b>[Result]</b>

              Types:

                 ModFiles = mod_files()
                 Options = [option()]
                 Result = compile_result()
                 <b>mod_files()</b> = mod_file() | [mod_file()]
                 <b>mod_file()</b> = (Module :: module()) | (File :: file:filename())
                 <b>option()</b> =
                     {i, Dir :: file:filename()} |
                     {d, Macro :: atom()} |
                     {d, Macro :: atom(), Value :: term()} |
                     export_all
                   See <u>compile:file/2</u>.
                 <b>compile_result()</b> =
                     {ok, Module :: module()} |
                     {error, file:filename()} |
                     {error, not_main_node}

              Compiles a module for Cover analysis. The module is given by its module name <u>Module</u> or by its file
              name <u>File</u>. The <u>.erl</u> extension may be omitted. If the module is located in another  directory,  the
              path has to be specified.

              <u>Options</u>  is  a  list  of compiler options which defaults to <u>[]</u>. Only options defining include file
              directories and macros are passed to <u>compile:file/2</u>, everything else is ignored.

              If the module is successfully Cover compiled, the function returns  <u>{ok,</u>  <u>Module}</u>.  Otherwise  the
              function returns <u>{error,</u> <u>File}</u>. Errors and warnings are printed as they occur.

              If  a  list  of  <u>ModFiles</u>  is  given as input, a list of <u>Result</u> will be returned. The order of the
              returned list is undefined.

              Note that the internal database is (re-)initiated during the compilation, meaning  any  previously
              collected coverage data for the module will be lost.

       <b>compile_directory()</b> <b>-&gt;</b> <b>[Result]</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>compile_directory(Dir)</b> <b>-&gt;</b> <b>[Result]</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>compile_directory(Dir,</b> <b>Options)</b> <b>-&gt;</b> <b>[Result]</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Dir = file:filename()
                 Options = [option()]
                 Reason = file_error()
                 Result = compile_result()
                 <b>option()</b> =
                     {i, Dir :: file:filename()} |
                     {d, Macro :: atom()} |
                     {d, Macro :: atom(), Value :: term()} |
                     export_all
                   See <u>compile:file/2</u>.
                 <b>file_error()</b> = eacces | enoent
                 <b>compile_result()</b> =
                     {ok, Module :: module()} |
                     {error, file:filename()} |
                     {error, not_main_node}

              Compiles  all  modules  (<u>.erl</u>  files)  in  a  directory  <u>Dir</u>  for  Cover  analysis the same way as
              <u>compile_module/1,2</u> and returns a list with the return values.

              <u>Dir</u> defaults to the current working directory.

              The function returns <u>{error,</u> <u>eacces}</u> if the directory is not readable or <u>{error,</u>  <u>enoent}</u>  if  the
              directory does not exist.

       <b>compile_beam(ModFiles)</b> <b>-&gt;</b> <b>Result</b> <b>|</b> <b>[Result]</b>

              Types:

                 ModFiles = beam_mod_files()
                 Result = compile_beam_result()
                 <b>beam_mod_files()</b> = beam_mod_file() | [beam_mod_file()]
                 <b>beam_mod_file()</b> =
                     (Module :: module()) | (BeamFile :: file:filename())
                 <b>compile_beam_result()</b> =
                     {ok, module()} |
                     {error, BeamFile :: file:filename()} |
                     {error, Reason :: compile_beam_rsn()}
                 <b>compile_beam_rsn()</b> =
                     non_existing |
                     {no_abstract_code, BeamFile :: file:filename()} |
                     {encrypted_abstract_code, BeamFile :: file:filename()} |
                     {already_cover_compiled, no_beam_found, module()} |
                     {{missing_backend, module()}, BeamFile :: file:filename()} |
                     {no_file_attribute, BeamFile :: file:filename()} |
                     not_main_node

              Does  the same as <u>compile/1,2</u>, but uses an existing <u>.beam</u> file as base, that is, the module is not
              compiled from source. Thus <u>compile_beam/1</u> is faster than <u>compile/1,2</u>.

              Note that the existing <u>.beam</u> file must contain <u>abstract</u> <u>code</u>, that is, it must have been  compiled
              with  the <u>debug_info</u> option. If not, the error reason <u>{no_abstract_code,</u> <u>BeamFile}</u> is returned. If
              the abstract code is encrypted, and no key is  available  for  decrypting  it,  the  error  reason
              <u>{encrypted_abstract_code,</u> <u>BeamFile}</u> is returned.

              If  only the module name (that is, not the full name of the <u>.beam</u> file) is given to this function,
              the <u>.beam</u> file is found by calling <u>code:which(Module)</u>. If no <u>.beam</u> file is found, the error reason
              <u>non_existing</u> is returned. If the module is already cover compiled with <u>compile_beam/1</u>,  the  <u>.beam</u>
              file  will  be  picked  from the same location as the first time it was compiled. If the module is
              already cover compiled with <u>compile/1,2</u>, there is no way to find the correct <u>.beam</u>  file,  so  the
              error reason <u>{already_cover_compiled,</u> <u>no_beam_found,</u> <u>Module}</u> is returned.

              <u>{error,</u> <u>BeamFile}</u> is returned if the compiled code cannot be loaded on the node.

              If  a  list  of  <u>ModFiles</u>  is  given as input, a list of <u>Result</u> will be returned. The order of the
              returned list is undefined.

       <b>compile_beam_directory()</b> <b>-&gt;</b> <b>[Result]</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>compile_beam_directory(Dir)</b> <b>-&gt;</b> <b>[Result]</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Dir = file:filename()
                 Reason = file_error()
                 Result = compile_beam_result()
                 <b>compile_beam_result()</b> =
                     {ok, module()} |
                     {error, BeamFile :: file:filename()} |
                     {error, Reason :: compile_beam_rsn()}
                 <b>compile_beam_rsn()</b> =
                     non_existing |
                     {no_abstract_code, BeamFile :: file:filename()} |
                     {encrypted_abstract_code, BeamFile :: file:filename()} |
                     {already_cover_compiled, no_beam_found, module()} |
                     {{missing_backend, module()}, BeamFile :: file:filename()} |
                     {no_file_attribute, BeamFile :: file:filename()} |
                     not_main_node
                 <b>file_error()</b> = eacces | enoent

              Compiles all modules (<u>.beam</u> files) in  a  directory  <u>Dir</u>  for  Cover  analysis  the  same  way  as
              <u>compile_beam/1</u> and returns a list with the return values.

              <u>Dir</u> defaults to the current working directory.

              The  function  returns  <u>{error,</u> <u>eacces}</u> if the directory is not readable or <u>{error,</u> <u>enoent}</u> if the
              directory does not exist.

       <b>analyse()</b> <b>-&gt;</b>
                  {result, analyse_ok(), analyse_fail()} |
                  {error, not_main_node}

       <b>analyse(Analysis)</b> <b>-&gt;</b>
                  {result, analyse_ok(), analyse_fail()} |
                  {error, not_main_node}

       <b>analyse(Level)</b> <b>-&gt;</b>
                  {result, analyse_ok(), analyse_fail()} |
                  {error, not_main_node}

       <b>analyse(Modules)</b> <b>-&gt;</b>
                  OneResult |
                  {result, analyse_ok(), analyse_fail()} |
                  {error, not_main_node}

       <b>analyse(Analysis,</b> <b>Level)</b> <b>-&gt;</b>
                  {result, analyse_ok(), analyse_fail()} |
                  {error, not_main_node}

       <b>analyse(Modules,</b> <b>Analysis)</b> <b>-&gt;</b>
                  OneResult |
                  {result, analyse_ok(), analyse_fail()} |
                  {error, not_main_node}

       <b>analyse(Modules,</b> <b>Level)</b> <b>-&gt;</b>
                  OneResult |
                  {result, analyse_ok(), analyse_fail()} |
                  {error, not_main_node}

       <b>analyse(Modules,</b> <b>Analysis,</b> <b>Level)</b> <b>-&gt;</b>
                  OneResult |
                  {result, analyse_ok(), analyse_fail()} |
                  {error, not_main_node}

              Types:

                 Analysis = analysis()
                 Level = level()
                 Modules = modules()
                 OneResult = one_result()
                 <b>analysis()</b> = coverage | calls
                 <b>level()</b> = line | clause | function | module
                 <b>modules()</b> = module() | [module()]
                 <b>one_result()</b> =
                     {ok, {Module :: module(), Value :: analyse_value()}} |
                     {ok, [{Item :: analyse_item(), Value :: analyse_value()}]} |
                     {error, {not_cover_compiled, module()}}
                 <b>analyse_fail()</b> = [{not_cover_compiled, module()}]
                 <b>analyse_ok()</b> =
                     [{Module :: module(), Value :: analyse_value()}] |
                     [{Item :: analyse_item(), Value :: analyse_value()}]
                 <b>analyse_value()</b> =
                     {Cov :: integer() &gt;= 0, NotCov :: integer() &gt;= 0} |
                     (Calls :: integer() &gt;= 0)
                 <b>analyse_item()</b> =
                     (Line :: {M :: module(), N :: integer() &gt;= 0}) |
                     (Clause ::
                          {M :: module(),
                           F :: atom(),
                           A :: arity(),
                           C :: integer() &gt;= 0}) |
                     (Function :: {M :: module(), F :: atom(), A :: arity()})

              Performs analysis of one or more Cover compiled modules, as specified by <u>Analysis</u> and  <u>Level</u>  (see
              above), by examining the contents of the internal database.

              <u>Analysis</u> defaults to <u>coverage</u> and <u>Level</u> defaults to <u>function</u>.

              If <u>Modules</u> is an atom (one module), the return will be <u>OneResult</u>, else the return will be <u>{result,</u>
              <u>Ok,</u> <u>Fail}</u>.

              If  <u>Modules</u>  is  not given, all modules that have data in the cover data table, are analysed. Note
              that this includes both cover compiled modules and imported modules.

              If  a  given  module  is  not  Cover  compiled,  this   is   indicated   by   the   error   reason
              <u>{not_cover_compiled,</u> <u>Module}</u>.

       <b>analyse_to_file()</b> <b>-&gt;</b>
                          {result,
                           analyse_file_ok(),
                           analyse_file_fail()} |
                          {error, not_main_node}

       <b>analyse_to_file(Modules)</b> <b>-&gt;</b>
                          Answer |
                          {result,
                           analyse_file_ok(),
                           analyse_file_fail()} |
                          {error, not_main_node}

       <b>analyse_to_file(Options)</b> <b>-&gt;</b>
                          {result,
                           analyse_file_ok(),
                           analyse_file_fail()} |
                          {error, not_main_node}

       <b>analyse_to_file(Modules,</b> <b>Options)</b> <b>-&gt;</b>
                          Answer |
                          {result,
                           analyse_file_ok(),
                           analyse_file_fail()} |
                          {error, not_main_node}

              Types:

                 Modules = modules()
                 Options = [analyse_option()]
                 Answer = analyse_answer()
                 <b>modules()</b> = module() | [module()]
                 <b>analyse_option()</b> =
                     html |
                     {outfile, OutFile :: file:filename()} |
                     {outdir, OutDir :: file:filename()}
                 <b>analyse_answer()</b> =
                     {ok, OutFile :: file:filename()} | {error, analyse_rsn()}
                 <b>analyse_file_ok()</b> = [OutFile :: file:filename()]
                 <b>analyse_file_fail()</b> = [analyse_rsn()]
                 <b>analyse_rsn()</b> =
                     {not_cover_compiled, Module :: module()} |
                     {file, File :: file:filename(), Reason :: term()} |
                     {no_source_code_found, Module :: module()}

              Makes  copies  of  the  source  file  for  the given modules, where it for each executable line is
              specified how many times it has been executed.

              The output file <u>OutFile</u> defaults to <u>Module.COVER.out</u>, or <u>Module.COVER.html</u> if the option <u>html</u>  was
              used.

              If  <u>Modules</u>  is  an  atom (one module), the return will be <u>Answer</u>, else the return will be a list,
              <u>{result,</u> <u>Ok,</u> <u>Fail}</u>.

              If <u>Modules</u> is not given, all modules that have da ta in the cover data table, are  analysed.  Note
              that this includes both cover compiled modules and imported modules.

              If  a  module  is  not  Cover compiled, this is indicated by the error reason <u>{not_cover_compiled,</u>
              <u>Module}</u>.

              If the source file and/or the output file cannot be opened using <u>file:open/2</u>, the function returns
              <u>{error,</u> <u>{file,</u> <u>File,</u> <u>Reason}}</u> where <u>File</u> is the file name and <u>Reason</u> is the error reason.

              If  a  module  was  cover  compiled  from  the  <u>.beam</u>  file,  that  is,  using  <u>compile_beam/1</u>  or
              <u>compile_beam_directory/0,1</u>,it  is  assumed that the source code can be found in the same directory
              as the  <u>.beam</u>  file,  in  <u>../src</u>  relative  to  that  directory,  or  using  the  source  path  in
              <u>Module:module_info(compile)</u>.  When  using  the  latter,  two  paths  are  examined:  first the one
              constructed by joining <u>../src</u> and the tail of the compiled path below a  trailing  <u>src</u>  component,
              then  the  compiled path itself. If no source code is found, this is indicated by the error reason
              <u>{no_source_code_found,</u> <u>Module}</u>.

       <b>async_analyse_to_file(Module)</b> <b>-&gt;</b> <b>pid()</b>

       <b>async_analyse_to_file(Module,</b> <b>OutFile)</b> <b>-&gt;</b> <b>pid()</b>

       <b>async_analyse_to_file(Module,</b> <b>Options)</b> <b>-&gt;</b> <b>pid()</b>

       <b>async_analyse_to_file(Module,</b> <b>OutFile,</b> <b>Options)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Module = module()
                 OutFile = file:filename()
                 Options = [Option]
                 Option = html
                 <b>analyse_rsn()</b> =
                     {not_cover_compiled, Module :: module()} |
                     {file, File :: file:filename(), Reason :: term()} |
                     {no_source_code_found, Module :: module()}

              This function works exactly the same way as <u>analyse_to_file</u> except that it is asynchronous instead
              of synchronous. The spawned process will link with the caller when created. If an  error  of  type
              <u>analyse_rsn()</u>  occurs  while  doing  the cover analysis the process will crash with the same error
              reason as <u>analyse_to_file</u> would return.

       <b>modules()</b> <b>-&gt;</b> <b>[module()]</b> <b>|</b> <b>{error,</b> <b>not_main_node}</b>

              Returns a list with all modules that are currently Cover compiled.

       <b>imported_modules()</b> <b>-&gt;</b> <b>[module()]</b> <b>|</b> <b>{error,</b> <b>not_main_node}</b>

              Returns a list with all modules for which there are imported data.

       <b>imported()</b> <b>-&gt;</b> <b>[file:filename()]</b> <b>|</b> <b>{error,</b> <b>not_main_node}</b>

              Returns a list with all imported files.

       <b>which_nodes()</b> <b>-&gt;</b> <b>[node()]</b>

              Returns a list with all nodes that are part of the coverage analysis. Note that the  current  node
              is not returned. This node is always part of the analysis.

       <b>is_compiled(Module)</b> <b>-&gt;</b>
                      {file, File :: file:filename()} |
                      false |
                      {error, not_main_node}

              Types:

                 Module = module()

              Returns  <u>{file,</u> <u>File}</u> if the module <u>Module</u> is Cover compiled, or <u>false</u> otherwise. <u>File</u> is the <u>.erl</u>
              file used by <u>compile_module/1,2</u> or the <u>.beam</u> file used by <u>compile_beam/1</u>.

       <b>reset()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>not_main_node}</b>

       <b>reset(Module)</b> <b>-&gt;</b>
                ok |
                {error, not_main_node} |
                {error, {not_cover_compiled, Module}}

              Types:

                 Module = module()

              Resets all coverage data for a Cover compiled module <u>Module</u> in the Cover database on all nodes. If
              the argument is omitted, the coverage data will be reset for all modules known by Cover.

              If <u>Module</u> is not Cover compiled, the function returns <u>{error,</u> <u>{not_cover_compiled,</u> <u>Module}}</u>.

       <b>export(File)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>export(File,</b> <b>Module)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 File = file:filename()
                 Module = module()
                 Reason = export_reason()
                 <b>export_reason()</b> =
                     {not_cover_compiled, Module :: module()} |
                     {cant_open_file,
                      ExportFile :: file:filename(),
                      FileReason :: term()} |
                     not_main_node

              Exports the current coverage data for <u>Module</u> to the file <u>ExportFile</u>. It is recommended to name the
              <u>ExportFile</u> with the extension <u>.coverdata</u>, since other filenames cannot be read by  the  web  based
              interface to cover.

              If <u>Module</u> is not given, data for all Cover compiled or earlier imported modules is exported.

              This function is useful if coverage data from different systems is to be merged.

              See also <u>import/1</u>.

       <b>import(ExportFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 ExportFile = file:filename()
                 Reason =
                     {cant_open_file, ExportFile, FileReason :: term()} |
                     not_main_node

              Imports  coverage  data  from  the file <u>ExportFile</u> created with <u>export/1,2</u>. Any analysis performed
              after this will include the imported data.

              Note that when compiling a module <u>all</u> <u>existing</u> <u>coverage</u> <u>data</u> <u>is</u> <u>removed</u>, including imported  data.
              If  a module is already compiled when data is imported, the imported data is <u>added</u> to the existing
              coverage data.

              Coverage data from several export files can be imported into one system. The coverage data is then
              added up when analysing.

              Coverage data for a module cannot be imported from the same file twice unless the module is  first
              reset  or  compiled.  The  check  is  based  on the filename, so you can easily fool the system by
              renaming your export file.

              See also <u>export/1,2</u>.

       <b>stop()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>not_main_node}</b>

              Stops the Cover server and unloads all Cover compiled code.

       <b>stop(Nodes)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>not_main_node}</b>

              Types:

                 Nodes = node() | [node()]

              Stops the Cover server and unloads all Cover compiled code on the given nodes. Data stored in  the
              Cover database on the remote nodes is fetched and stored on the main node.

       <b>flush(Nodes)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>not_main_node}</b>

              Types:

                 Nodes = node() | [node()]

              Fetch data from the Cover database on the remote nodes and stored on the main node.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3erl/code.3erl.html">code</a>(3erl), <a href="../man3erl/compile.3erl.html">compile</a>(3erl)

Ericsson AB                                        tools 3.5.2                                       <u><a href="../man3erl/cover.3erl.html">cover</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>