<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>erl_parse - The Erlang parser.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       erl_parse - The Erlang parser.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module is the basic Erlang parser that converts tokens into the abstract form of either forms (that
       is, top-level constructs), expressions, or terms. The Abstract Format is described  in  the  ERTS  User's
       Guide.  Notice that a token list must end with the <u>dot</u> token to be acceptable to the parse functions (see
       the <u><a href="../man3erl/erl_scan.3erl.html">erl_scan</a>(3erl)</u>) module.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>abstract_clause()</b>

              Abstract form of an Erlang clause.

       <b>abstract_expr()</b>

              Abstract form of an Erlang expression.

       <b>abstract_form()</b>

              Abstract form of an Erlang form.

       <b>abstract_type()</b>

              Abstract form of an Erlang type.

       <b>erl_parse_tree()</b> =
           abstract_clause() |
           abstract_expr() |
           abstract_form() |
           abstract_type()

       <b>af_binelement(_)</b>

              Abstract representation of an element of a bitstring.

       <b>af_field_decl()</b>

              Abstract representation of a record field.

       <b>af_generator()</b>

              Abstract representation of a generator or a bitstring generator.

       <b>af_remote_function()&gt;</b>

              Abstract representation of a remote function call.

       <b>error_description()</b> = term()

       <b>error_info()</b> =
           {erl_anno:location(), module(), error_description()}

       <b>form_info()</b> =
           {eof, erl_anno:location()} |
           {error, erl_scan:error_info() | error_info()} |
           {warning, erl_scan:error_info() | error_info()}

              Tuples <u>{error,</u> <u>error_info()}</u> and <u>{warning,</u> <u>error_info()}</u>, denoting syntactically  incorrect  forms
              and  warnings, and <u>{eof,</u> <u>line()}</u>, denoting an end-of-stream encountered before a complete form had
              been parsed.

       <b>token()</b> = erl_scan:token()

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>abstract(Data)</b> <b>-&gt;</b> <b>AbsTerm</b>

              Types:

                 Data = term()
                 AbsTerm = abstract_expr()

              Converts the Erlang data structure <u>Data</u> into an abstract form of type <u>AbsTerm</u>.  This  function  is
              the inverse of <u>normalise/1</u>.

              <u>erl_parse:abstract(T)</u> is equivalent to <u>erl_parse:abstract(T,</u> <u>0)</u>.

       <b>abstract(Data,</b> <b>Options)</b> <b>-&gt;</b> <b>AbsTerm</b>

              Types:

                 Data = term()
                 Options = Location | [Option]
                 Option =
                     {encoding, Encoding} | {line, Line} | {location, Location}
                 Encoding = latin1 | unicode | utf8 | none | encoding_func()
                 Line = erl_anno:line()
                 Location = erl_anno:location()
                 AbsTerm = abstract_expr()
                 <b>encoding_func()</b> = fun((integer() &gt;= 0) -&gt; boolean())

              Converts the Erlang data structure <u>Data</u> into an abstract form of type <u>AbsTerm</u>.

              Each  node  of  <u>AbsTerm</u> is assigned an annotation, see <u><a href="../man3erl/erl_anno.3erl.html">erl_anno</a>(3erl)</u>. The annotation contains the
              location given by option <u>location</u> or by option <u>line</u>. Option <u>location</u>  overrides  option  <u>line</u>.  If
              neither option <u>location</u> nor option <u>line</u> is given, <u>0</u> is used as location.

              Option <u>Encoding</u> is used for selecting which integer lists to be considered as strings. The default
              is  to  use  the  encoding  returned  by function <u>epp:default_encoding/0</u>. Value <u>none</u> means that no
              integer lists are considered as strings. <u>encoding_func()</u> is called with one integer of a list at a
              time; if it returns <u>true</u> for every integer, the list is considered a string.

       <b>anno_from_term(Term)</b> <b>-&gt;</b> <b>erl_parse_tree()</b> <b>|</b> <b>form_info()</b>

              Types:

                 Term = term()

              Assumes that <u>Term</u> is a term with the same structure as a <u>erl_parse</u> tree, but with  terms,  say  <u>T</u>,
              where  a <u>erl_parse</u> tree has collections of annotations. Returns a <u>erl_parse</u> tree where each term <u>T</u>
              is replaced by the value returned by <u>erl_anno:from_term(T)</u>. The term <u>Term</u> is traversed in a depth-
              first, left-to-right fashion.

       <b>anno_to_term(Abstr)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 Abstr = erl_parse_tree() | form_info()

              Returns a term where each collection of annotations <u>Anno</u> of the nodes of the <u>erl_parse</u> tree  <u>Abstr</u>
              is  replaced  by the term returned by <u>erl_anno:to_term(Anno)</u>. The <u>erl_parse</u> tree is traversed in a
              depth-first, left-to-right fashion.

       <b>fold_anno(Fun,</b> <b>Acc0,</b> <b>Abstr)</b> <b>-&gt;</b> <b>Acc1</b>

              Types:

                 Fun = fun((Anno, AccIn) -&gt; AccOut)
                 Anno = erl_anno:anno()
                 Acc0 = Acc1 = AccIn = AccOut = term()
                 Abstr = erl_parse_tree() | form_info()

              Updates an accumulator by applying <u>Fun</u> on each collection of annotations  of  the  <u>erl_parse</u>  tree
              <u>Abstr</u>.  The  first call to <u>Fun</u> has <u>AccIn</u> as argument, the returned accumulator <u>AccOut</u> is passed to
              the next call, and so on. The final value of the accumulator is returned. The  <u>erl_parse</u>  tree  is
              traversed in a depth-first, left-to-right fashion.

       <b>format_error(ErrorDescriptor)</b> <b>-&gt;</b> <b>Chars</b>

              Types:

                 ErrorDescriptor = error_description()
                 Chars = [char() | Chars]

              Uses  an  <u>ErrorDescriptor</u>  and returns a string that describes the error. This function is usually
              called implicitly when an <u>ErrorInfo</u> structure is processed (see section  Error Information).

       <b>map_anno(Fun,</b> <b>Abstr)</b> <b>-&gt;</b> <b>NewAbstr</b>

              Types:

                 Fun = fun((Anno) -&gt; NewAnno)
                 Anno = NewAnno = erl_anno:anno()
                 Abstr = NewAbstr = erl_parse_tree() | form_info()

              Modifies the <u>erl_parse</u> tree <u>Abstr</u> by applying <u>Fun</u> on each collection of annotations of  the  nodes
              of the <u>erl_parse</u> tree. The <u>erl_parse</u> tree is traversed in a depth-first, left-to-right fashion.

       <b>mapfold_anno(Fun,</b> <b>Acc0,</b> <b>Abstr)</b> <b>-&gt;</b> <b>{NewAbstr,</b> <b>Acc1}</b>

              Types:

                 Fun = fun((Anno, AccIn) -&gt; {NewAnno, AccOut})
                 Anno = NewAnno = erl_anno:anno()
                 Acc0 = Acc1 = AccIn = AccOut = term()
                 Abstr = NewAbstr = erl_parse_tree() | form_info()

              Modifies  the  <u>erl_parse</u> tree <u>Abstr</u> by applying <u>Fun</u> on each collection of annotations of the nodes
              of the <u>erl_parse</u> tree, while at the same time updating an accumulator. The first call to  <u>Fun</u>  has
              <u>AccIn</u>  as  second argument, the returned accumulator <u>AccOut</u> is passed to the next call, and so on.
              The modified <u>erl_parse</u> tree and the final value of the accumulator  are  returned.  The  <u>erl_parse</u>
              tree is traversed in a depth-first, left-to-right fashion.

       <b>new_anno(Term)</b> <b>-&gt;</b> <b>Abstr</b>

              Types:

                 Term = term()
                 Abstr = erl_parse_tree() | form_info()

              Assumes  that <u>Term</u> is a term with the same structure as a <u>erl_parse</u> tree, but with locations where
              a <u>erl_parse</u> tree has collections of annotations. Returns a <u>erl_parse</u> tree where each location <u>L</u> is
              replaced by the value returned by <u>erl_anno:new(L)</u>. The term <u>Term</u> is traversed  in  a  depth-first,
              left-to-right fashion.

       <b>normalise(AbsTerm)</b> <b>-&gt;</b> <b>Data</b>

              Types:

                 AbsTerm = abstract_expr()
                 Data = term()

              Converts  the  abstract form <u>AbsTerm</u> of a term into a conventional Erlang data structure (that is,
              the term itself). This function is the inverse of <u>abstract/1</u>.

       <b>parse_exprs(Tokens)</b> <b>-&gt;</b> <b>{ok,</b> <b>ExprList}</b> <b>|</b> <b>{error,</b> <b>ErrorInfo}</b>

              Types:

                 Tokens = [token()]
                 ExprList = [abstract_expr()]
                 ErrorInfo = error_info()

              Parses <u>Tokens</u> as if it was a list of expressions. Returns one of the following:

                <u>{ok,</u> <u>ExprList}</u>:
                  The parsing was  successful.  <u>ExprList</u>  is  a  list  of  the  abstract  forms  of  the  parsed
                  expressions.

                <u>{error,</u> <u>ErrorInfo}</u>:
                  An error occurred.

       <b>parse_form(Tokens)</b> <b>-&gt;</b> <b>{ok,</b> <b>AbsForm}</b> <b>|</b> <b>{error,</b> <b>ErrorInfo}</b>

              Types:

                 Tokens = [token()]
                 AbsForm = abstract_form()
                 ErrorInfo = error_info()

              Parses <u>Tokens</u> as if it was a form. Returns one of the following:

                <u>{ok,</u> <u>AbsForm}</u>:
                  The parsing was successful. <u>AbsForm</u> is the abstract form of the parsed form.

                <u>{error,</u> <u>ErrorInfo}</u>:
                  An error occurred.

       <b>parse_term(Tokens)</b> <b>-&gt;</b> <b>{ok,</b> <b>Term}</b> <b>|</b> <b>{error,</b> <b>ErrorInfo}</b>

              Types:

                 Tokens = [token()]
                 Term = term()
                 ErrorInfo = error_info()

              Parses <u>Tokens</u> as if it was a term. Returns one of the following:

                <u>{ok,</u> <u>Term}</u>:
                  The parsing was successful. <u>Term</u> is the Erlang term corresponding to the token list.

                <u>{error,</u> <u>ErrorInfo}</u>:
                  An error occurred.

       <b>tokens(AbsTerm)</b> <b>-&gt;</b> <b>Tokens</b>

       <b>tokens(AbsTerm,</b> <b>MoreTokens)</b> <b>-&gt;</b> <b>Tokens</b>

              Types:

                 AbsTerm = abstract_expr()
                 MoreTokens = Tokens = [token()]

              Generates  a  list  of tokens representing the abstract form <u>AbsTerm</u> of an expression. Optionally,
              <u>MoreTokens</u> is appended.

</pre><h4><b>ERROR</b> <b>INFORMATION</b></h4><pre>
       <u>ErrorInfo</u> is the standard <u>ErrorInfo</u> structure that is returned from all I/O modules.  The  format  is  as
       follows:

       {ErrorLine, Module, ErrorDescriptor}

       A string describing the error is obtained with the following call:

       Module:format_error(ErrorDescriptor)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/erl_anno.3erl.html">erl_anno</a>(3erl)</u>, <u><a href="../man3erl/erl_scan.3erl.html">erl_scan</a>(3erl)</u>, <u><a href="../man3erl/io.3erl.html">io</a>(3erl)</u>, section The Abstract Format in the ERTS User's Guide

Ericsson AB                                        stdlib 3.17                                   <u><a href="../man3erl/erl_parse.3erl.html">erl_parse</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>