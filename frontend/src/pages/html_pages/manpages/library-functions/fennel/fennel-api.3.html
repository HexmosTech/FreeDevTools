<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fennel-api - Fennel's Lua API</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/fennel">fennel_1.5.3+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fennel-api - Fennel's Lua API

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>fennel</b>  module  provides the following functions for use when embedding Fennel in a Lua program.  If
       you're writing a pure Fennel program or working on a system that already has Fennel support, you probably
       don't need this.

       Only the <b>fennel</b> module is part of the public API.  The other modules are implementation  details  subject
       to change.  Most functions will <b>error</b> upon failure.

       Any time a function takes an <b>options</b> table argument, that table will usually accept these fields:

       • <b>allowedGlobals</b>:  a  sequential  table  of strings of the names of globals which the compiler will allow
         references to.  Set to false to disable checks.  Defaults to the contents of the <b>env</b> table, if  provid‐
         ed, or the current environment.

       • <b>correlate</b>:  when this is set, Fennel attempts to emit Lua where the line numbers match up with the Fen‐
         nel input code; useful for situation where code that isn't under your  control  will  print  the  stack
         traces.  This is meant as a debugging aid and cannot give exact numbers in all cases.

       • <b>useMetadata</b>:  enables or disables metadata, allowing use of the <b>,doc</b> repl command.  Intended for devel‐
         opment purposes (see performance note); defaults to true for REPL only.

       • <b>requireAsInclude</b>: Alias any static <b>require</b> calls to the <b>include</b> special, embedding the module code  in‐
         line  in  the compiled output.  If the module name isn't a string literal that is resolvable at compile
         time it falls back to <b>require</b> at runtime.  Can be used to embed both Fennel and Lua modules.

       • <b>assertAsRepl</b>: Replace calls to <b>assert</b> with <b>assert-repl</b> to allow for interactive debugging.

       • <b>env</b>: an environment table in which to run the code; see the Lua manual.

       • <b>compilerEnv</b>: an environment table in which to run compiler-scoped code for macro definitions and  <b>eval-</b>
         <b>compiler</b> calls.  Internal Fennel functions such as <b>list</b>, <b>sym</b>, etc.  will be exposed in addition to this
         table.  Defaults to a table containing limited known-safe globals.  Pass <b>_G</b> to disable sandboxing.

       • <b>unfriendly</b>: disable friendly compiler/parser error messages.

       • <b>plugins</b>: list of compiler plugins.

       • <b>error-pinpoint</b>: a list of two strings indicating what to wrap compile errors in

       • <b>keywords</b>: a table of the form <b>{:keyword1</b> <b>true</b> <b>:keyword2</b> <b>true}</b> containing symbols that should be treated
         as reserved Lua keywords.

       • <b>global-mangle</b>:  whether  to  mangle  globals in compiler output; set to <b>false</b> to turn global references
         that aren't valid Lua into <b>_G['hello-world']</b>.

       You can pass the string <b>"_COMPILER"</b> as the value for <b>env</b>; it will cause the code to be run/compiled in  a
       context which has all compiler-scoped values available.  This can be useful for macro modules or compiler
       plugins.

       Note that only the <b>fennel</b> module is part of the public API.  The other modules (<b>fennel.utils</b>, <b>fennel.com‐</b>
       <b>piler</b>, etc) should be considered compiler internals subject to change.

       If  you are embedding Fennel in a context where ANSI escape codes are not interpreted, you can set <b>error-</b>
       <b>pinpoint</b> to <b>false</b> to disable the highlighting of compiler and parse errors.

</pre><h4><b>START</b> <b>A</b> <b>CONFIGURABLE</b> <b>REPL</b></h4><pre>
              fennel.repl([options])

       Takes these additional options:

       • <b>readChunk(state)</b>: a function that when called, returns a line of code to run.  This can  be  an  incom‐
         plete expression, in which case it will be called again until a complete expression can be constructed.
         The state argument is a table with a <b>stack-size</b> field which will be zero unless it's reading a continu‐
         ation  of previous input.  Strings returned should end in newlines.  It should return nil when there is
         no more source, which will exit the repl.

       • <b>onValues(values)</b>: a function which is called for every evaluation  with  a  sequence  table  containing
         string representations of each of the values resulting from the input.

       • <b>onError(errType,</b>  <b>err,</b>  <b>luaSource)</b>:  a function that will be called on each error.  <b>errType</b> is a string
         with the type of error: 'parse', 'compile', 'runtime', or 'lua'.  <b>err</b> is the error  message,  and  <b>lua‐</b>
         <b>Source</b> is the source of the generated lua code.

       • <b>pp(x)</b>: a pretty-printer function to apply on values (default: <b>fennel.view</b>).

       • <b>view-opts</b>: an options table passed to <b>pp</b> (default: <b>{:depth</b> <b>4}</b>).

       • <b>rawValues(...)</b>:  a  function which is passed the raw values from evaluation; like <b>onValues</b> but receives
         the underlying data rather than the string representation.

       Note that overriding <b>readChunk</b>/<b>onValues</b> will only affect input and output initiated by the repl directly.
       If the repl runs code that calls <b>print</b>, <b>io.write</b>, <b>io.read</b>, etc, those will still use stdio  unless  over‐
       ridden in <b>env</b>.

       By  default,  metadata  will be enabled and you can view function signatures and docstrings with the <b>,doc</b>
       command in the REPL.

       In Fennel 1.4.1 <b>fennel.repl</b> was changed from a normal function to a callable table.  This mostly  behaves
       the same, but it can cause problems with certain functions that are very picky about functions.  Unfortu‐
       nately this includes <b>coroutine.create</b>.  You can pass <b>fennel.repl.repl</b> instead.

   <b>Customize</b> <b>REPL</b> <b>default</b> <b>options</b>
       Any fields set on <b>fennel.repl</b>, which is actually a table with a <b>__call</b> metamethod rather than a function,
       will used as a fallback for any options passed to <b>(fennel.repl)</b> before defaults are applied, allowing one
       to

       customize the default behavior of <b>(fennel.repl)</b>:

              fennel.repl.onError = custom_error_handler
              -- In rare cases this needs to be temporary, overrides
              -- can be cleared by simply clearing the entire table
              for k in pairs(fennel.repl) do
                fennel.repl[k] = nil
              end

</pre><h4><b>EVALUATE</b> <b>A</b> <b>STRING</b> <b>OF</b> <b>FENNEL</b></h4><pre>
              local result = fennel.eval(str[, options[, ...]])

       The <b>options</b> table may also contain:

       • <b>filename</b>: override the filename that Lua thinks the code came from.

       Additional arguments beyond <b>options</b> are passed to the code and available as <b>...</b>.

</pre><h4><b>EVALUATE</b> <b>A</b> <b>FILE</b> <b>OF</b> <b>FENNEL</b></h4><pre>
              local result = fennel.dofile(filename[, options[, ...]])

       Additional arguments beyond <b>options</b> are passed to the code and available as <b>...</b>.

</pre><h4><b>USE</b> <b>LUA'S</b> <b>BUILT-IN</b> <b>REQUIRE</b> <b>FUNCTION</b></h4><pre>
              require("fennel").install().dofile("main.fnl")

       This is the equivalent of this code:

              local fennel = require("fennel")
              table.insert(package.loaders or package.searchers, fennel.searcher)
              fennel.dofile("main.fnl") -- require calls in main.fnl can load fennel modules

       Normally  Lua's  <b>require</b>  function only loads modules written in Lua, but you can install <b>fennel.searcher</b>
       into <b>package.searchers</b> (or in Lua 5.1 <b>package.loaders</b>) to teach it how to load Fennel code.

       If you would rather change some of the options you can use <b>fennel.makeSearcher(options)</b> to get a searcher
       function that's equivalent to <b>fennel.searcher</b> but overrides the default <b>options</b> table.

       The <b>require</b> function is different from <b>fennel.dofile</b> in that it searches the directories  in  <b>fennel.path</b>
       for  <b>.fnl</b> files matching the module name, and also in that it caches the loaded value to return on subse‐
       quent calls, while <b>fennel.dofile</b> will reload each time.  The behavior  of  <b>fennel.path</b>  mirrors  that  of
       Lua's <b>package.path</b>.  There is also a <b>fennel.macro-path</b> which is used to look up macro modules.

       If  you  install  Fennel into <b>package.searchers</b> then you can use the repl's <b>,reload</b> <b>mod</b> command to reload
       modules that have been loaded with <b>require</b>.

</pre><h4><b>MACRO</b> <b>SEARCHERS</b></h4><pre>
       The compiler sandbox makes it so that the module system is also isolated from the rest of the system,  so
       the  above  <b>require</b>  calls  will not work from inside macros.  However, there is a separate <b>fennel.macro-</b>
       <b>searchers</b> table which can be used to allow different modules to be loaded inside macros.  By  default  it
       includes a searcher to load sandboxed Fennel modules and a searcher to load sandboxed Lua modules, but if
       you  disable  the  compiler sandbox you may want to replace these with searchers which can load arbitrary
       modules.

       The default <b>fennel.macro-searchers</b> functions also cannot load C modules.  Here's an example of some  code
       which would allow that to work:

              table.insert(fennel["macro-searchers"], <a href="../manmodule_name/function.module_name.html">function</a>(module_name)
                local filename = fennel["search-module"](module_name, package.cpath)
                if filename then
                  local func = "luaopen_" .. module_name
                  return function() return package.loadlib(filename, func) end, filename
                end
              end)

       Macro searchers store loaded macro modules in the <b>fennel.macro-loaded</b> table which works the same as <b>pack‐</b>
       <b>age.loaded</b> but for macro modules.

</pre><h4><b>GET</b> <b>FENNEL-AWARE</b> <b>STACK</b> <b>INFORMATION</b></h4><pre>
       The  <b>fennel.traceback</b>  function  works like Lua's <b>debug.traceback</b> function, except it tracks line numbers
       from Fennel code correctly.

       If you are working on an application written in Fennel, you can override the default  traceback  function
       to replace it with Fennel's:

              debug.traceback = fennel.traceback

       Note that some systems print stack traces from C, which will not be affected.

       The  <b>fennel.getinfo</b>  function works like Lua's <b>debug.getinfo</b> function, except it tracks line numbers from
       Fennel code correctly.  Functions defined from Fennel will have the <b>what</b> field set to <b>"Fennel"</b> instead of
       <b>"Lua"</b>.

              local mymodule = require("module")
              print(fennel.getinfo(mymodule.func1).linedefined)

</pre><h4><b>COMPILE</b> <b>FENNEL</b> <b>CODE</b> <b>TO</b> <b>LUA</b></h4><pre>
   <b>Compile</b> <b>a</b> <b>file,</b> <b>AST,</b> <b>or</b> <b>byte</b> <b>iterator</b>
              local lua = fennel.compile(fennelSource[, options])

       The first argument here can be a file name, an AST (usually produced by <b>fennel.parser</b>), or a stateful it‐
       erator function of bytes.

       Unlike the other functions, the <b>compile</b> functions default to performing no global checks, though you  can
       pass  in  an  <b>allowedGlobals</b> table in <b>options</b> to enable it.  Accepts <b>filename</b> in <b>options</b> like <b>fennel.eval</b>
       for error reporting purposes.

   <b>Compile</b> <b>a</b> <b>string</b> <b>of</b> <b>Fennel</b> <b>code</b>
              local lua = fennel.compileString(fennelcode[, options])

       Also aliased to <b>fennel.compile-string</b> for convenience calling from Fennel.

</pre><h4><b>PARSE</b> <b>TEXT</b> <b>INTO</b> <b>AST</b> <b>NODES</b></h4><pre>
       The <b>fennel.parser</b> function returns a function which you can call repeatedly to get successive  AST  nodes
       from  a  string.   This  happens to be an iterator function, so you can use it with Lua's <b>for</b> or Fennel's
       <b>each</b>.  If a form was successfully read, it returns true followed by the AST node.  Returns  nil  when  it
       reaches the end.  Raises an error if it can't parse the input.

              local parse = fennel.parser(text)
              local ok, ast = assert(parse()) -- just get the first form

              -- Or use in a for loop
              for ok, ast in parse do
                if ok then
                  print(fennel.view(ast))
                end
              end

       The  first  argument  can either be a string or a function that returns one byte at a time.  It takes two
       optional arguments; a filename and a table of options.  Supported options are both booleans that  default
       to false:

       • <b>unfriendly</b>: disable enhanced parse error reporting

       • <b>comments</b>: include comment nodes in AST

       • <b>plugins</b>: <u>(since</u> <u>1.2.0)</u> An optional list of compiler plugins.

       The list of common options at the top of this document do not apply here.

</pre><h4><b>AST</b> <b>NODE</b> <b>DEFINITION</b></h4><pre>
       The  AST  returned by the parser consists of data structures representing the code.  Passing AST nodes to
       the <b>fennel.view</b> function will give you a string which should round-trip thru the parser to give  you  the
       same data back.  The same is true with <b>tostring</b>, except it does not work with non-sequence tables.

       The  <b>fennel.ast-source</b>  function  takes an AST node and returns a table with source data around filename,
       line number, et in it, if possible.  Some AST nodes cannot  provide  this  data,  for  instance  numbers,
       strings, and booleans, or symbols constructed within macros using the <b>sym</b> function instead of backtick.

       AST nodes can be any of these types:

   <b>list</b>
       A list represents a call to function/macro, or destructuring multiple return values in a binding context.
       It's  represented  as  a  table which can be identified using the <b>fennel.list?</b> predicate function or con‐
       structed using <b>fennel.list</b> which takes any number of arguments for the contents of the list.

       Note that lists are compile-time constructs in Fennel.  They do not exist at runtime, except in such cas‐
       es as the compiler is in use at runtime.

       The list also contains these keys indicating where it was defined: <b>filename</b>, <b>line</b>,  <b>col</b>,  <b>endcol</b>,  <b>bytes‐</b>
       <b>tart</b>, and <b>byteend</b>.  This data is used for stack traces and for pinpointing compiler error messages.  Note
       that column numbers are based on character count, which does not always correspond to visual columns; for
       instance "วัด" is three characters but only two visual columns.

   <b>sequence/key-value</b> <b>table</b>
       These  are  table  literals in Fennel code produced by square brackets (sequences) or curly brackets (k/v
       tables).  Sequences can be identified using the <b>fennel.sequence?</b>  function  and  constructed  using  <b>fen‐</b>
       <b>nel.sequence</b>.   There  is  no  predicate or constructor for k/v tables; any table which is not one of the
       other types is assumed to be one of these.

       At runtime there is no difference between sequences and k/v tables which use monotonically increasing in‐
       teger keys, but the parser is able to distinguish between them to improve error reporting.

       Sequences and k/v tables have their source data in <b>filename</b>, <b>line</b>, etc  keys  of  their  metatable.   The
       metatable  for  k/v  tables  also  includes a <b>keys</b> sequence which tells you which order the keys appeared
       originally, since k/v tables are unordered and there would otherwise be no way to reconstruct this infor‐
       mation.

   <b>symbol</b>
       Symbols typically represent identifiers in Fennel code.  Symbols can be identified with  <b>fennel.sym?</b>  and
       constructed  with  <b>fennel.sym</b>  which takes a string name as its first argument and a source data table as
       the second.  Symbols are represented as tables which store their source data (<b>filename</b>, <b>line</b>,  <b>col</b>,  etc)
       in fields on themselves.  Unlike the other tables in the AST, they do not represent collections; they are
       used as scalar types.

       Symbols  can  refer not just directly to locals, but also to table references like <b>tbl.x</b> for field lookup
       or <b>access.channel:deny</b> for method invocation.  The <b>fennel.multi-sym?</b> function will return  a  table  con‐
       taining the segments if the symbol if it is one of these, or nil otherwise.

       <b>Note:</b>  <b>nil</b>  is  not a valid AST; code that references nil will have the symbol named <b>"nil"</b> which unfortu‐
       nately prints in a way that is visually indistinguishable from actual <b>nil</b>.

       The <b>fennel.sym-char?</b> function will tell you if a given character is allowed to be used in the name  of  a
       symbol.

   <b>vararg</b>
       This  is  a  special type of symbol-like construct (<b>...</b>)  indicating functions using a variable number of
       arguments.  Its meaning is the same as in Lua.  It's identified with <b>fennel.varg?</b>  and  constructed  with
       <b>fennel.varg</b>.

   <b>number/string/boolean</b>
       These are literal types defined by Lua.  They cannot carry source data.

   <b>comment</b>
       By default, ASTs will omit comments.  However, when the <b>:comment</b> field is set in the parser options, com‐
       ments  will  be included in the parsed values.  They are identified using <b>fennel.comment?</b> and constructed
       using the <b>fennel.comment</b> function.  They are represented as tables that have source data as fields inside
       them.

       In most data contexts, comments just get included inline in a list or sequence.  However, in a k/v table,
       this cannot be done, because k/v tables must have balanced key/value pairs, and including comments inline
       would imbalance these or cause keys to be considered as values and  vice  versa.   So  the  comments  are
       stored on the <b>comments</b> field of metatable instead, keyed by the key or value they were attached to.

</pre><h4><b>SEARCH</b> <b>THE</b> <b>PATH</b> <b>FOR</b> <b>A</b> <b>MODULE</b> <b>WITHOUT</b> <b>LOADING</b> <b>IT</b></h4><pre>
              print(fennel.searchModule("my.mod", package.path))

       If  you  just  want to find the file path that a module would resolve to without actually loading it, you
       can use <b>fennel.searchModule</b>.  The first argument is the module name, and the second argument is the  path
       string to search.  If none is provided, it defaults to Fennel's own path.

       Returns <b>nil</b> if the module is not found on the path.

</pre><h4><b>SERIALIZATION</b> <b>(VIEW)</b></h4><pre>
       The  <b>fennel.view</b>  function  takes any Fennel data and turns it into a representation suitable for feeding
       back to Fennel's parser.  In addition to tables, strings, numbers, and booleans, it can  produce  reason‐
       able  output from ASTs that come from the parser.  It will emit an unreadable placeholder for coroutines,
       compiled functions, and userdata, which cannot be understood by the parser.

              print(fennel.view({abc=123}[, options])
              {:abc 123}

       The list of common options at the top of this document do not apply here; instead these options  are  ac‐
       cepted:

       • <b>one-line?</b> (default: false) keep the output string as a one-liner

       • <b>depth</b> (number, default: 128) limit how many levels to go (default: 128)

       • <b>detect-cycles?</b> (default: true) don't try to traverse a looping table

       • <b>metamethod?</b> (default: true) use the __fennelview metamethod if found

       • <b>empty-as-sequence?</b> (default: false) render empty tables as []

       • <b>line-length</b> (number, default: 80) length of the line at which multi-line output for tables is forced

       • <b>byte-escape</b> (function) If present, overrides default behavior of escaping special characters in decimal
         format  (e.g.   <b>&lt;ESC&gt;</b>  -&gt; <b>\027</b>).  Called with the signature <b>(byte-escape</b> <b>byte</b> <b>view-opts)</b>, where byte is
         the char code for a special character

       • <b>escape-newlines?</b> (default: false) emit strings with \n instead of newline

       • <b>prefer-colon?</b> (default: false) emit strings in colon notation when possible

       • <b>utf8?</b> (default: true) whether to use utf8 module to compute string lengths

       • <b>max-sparse-gap</b> (number, default: 1) maximum gap to fill in with nils in sparse sequential tables before
         switching to curly brackets.

       • <b>preprocess</b> (function) if present, called on x (and recursively on each value in x), and the  result  is
         used for pretty printing; takes the same arguments as <b>fennel.view</b>

       All  options can be set to <b>{:once</b> <b>some-value}</b> to force their value to be <b>some-value</b> but only for the cur‐
       rent level.  After that, such option is reset to its default value.  Alternatively, <b>{:once</b>  <b>value</b>  <b>:after</b>
       <b>other-value}</b> can be used, with the difference that after first use, the options will be set to <b>other-val‐</b>
       <b>ue</b> instead of the default value.

       You  can set a <b>__fennelview</b> metamethod on a table to override its serialization behavior.  It should take
       the table being serialized as its first argument, a function as its second  argument,  options  table  as
       third argument, and current amount of indentation as its last argument:

              (fn [t view options indent] ...)

       <b>view</b>  function  contains  a pretty printer that can be used to serialize elements stored within the table
       being serialized.  If your metamethod produces indented representation, you should pass <b>indent</b>  parameter
       to  <b>view</b> increased by the amount of additional indentation you've introduced.  This function has the same
       interface as <b>__fennelview</b> metamethod, but in addition accepts <b>colon-string?</b> as last argument.  If  <b>colon?</b>
       is  <b>true</b>, strings will be printed as colon-strings when possible, and if its value is <b>false</b>, strings will
       be always printed in double quotes.  If omitted or <b>nil</b> will default to value of <b>:prefer-colon?</b> option.

       <b>options</b> table contains options described above, and also <b>visible-cycle?</b> function, that takes a table  be‐
       ing  serialized,  detects and saves information about possible reachable cycle.  Should be used in <b>__fen‐</b>
       <b>nelview</b> to implement cycle detection.

       <b>__fennelview</b> metamethod should always return a table of correctly indented lines  when  producing  multi-
       line  output,  or  a string when always returning single-line item.  <b>fennel.view</b> will transform your data
       structure to correct multi-line representation when needed.  There's no need to concatenate table manual‐
       ly ever - <b>fennel.view</b> will apply general rules for your data structure, depending on current options.  By
       default multiline output is produced only when inner data structures contains newlines, or when returning
       table of lines as single line results in width greater than <b>line-size</b> option.

       Multi-line representation can be forced by returning two values from <b>__fennelview</b> - a table  of  indented
       lines  as  first  value,  and  <b>true</b>  as second value, indicating that multi-line representation should be
       forced.

       There's no need to incorporate indentation beyond needed to correctly align elements within  the  printed
       representation of your data structure.  For example, if you want to print a multi-line table, like this:

              @my-table[1
                        2
                        3]

       <b>__fennelview</b> should return a sequence of lines:

              ["@my-table[1"
               "          2"
               "          3]"]

       Note,  since  we've  introduced  inner indent string of length 10, when calling <b>view</b> function from within
       <b>__fennelview</b> metamethod, in order to keep inner tables indented correctly, <b>indent</b> must  be  increased  by
       this amount of extra indentation.

       Here's an implementation of such pretty-printer for an arbitrary sequential table:

              (fn pp-doc-example [t view options indent]
                (let [lines (icollect [i v (ipairs t)]
                              (let [v (view v options (+ 10 indent))]
                                (if (= i 1) v
                                    (.. "          " v))))]
                  (doto lines
                    (tset 1 (.. "@my-table[" (or (. lines 1) "")))
                    (tset (length lines) (.. (. lines (length lines)) "]")))))

       Setting table's <b>__fennelview</b> metamethod to this function will provide correct results regardless of nest‐
       ing:

              &gt;&gt; {:my-table (setmetatable [[1 2 3 4 5]
                                           {:smalls [6 7 8 9 10 11 12]
                                            :bigs [500 1000 2000 3000 4000]}]
                                          {:__fennelview pp-doc-example})
                  :normal-table [{:c [1 2 3] :d :some-data} 4]}
              {:my-table @my-table[[1 2 3 4 5]
                                   {:bigs [500 1000 2000 3000 4000]
                                    :smalls [6 7 8 9 10 11 12]}]
               :normal-table [{:c [1 2 3] :d "some-data"} 4]}

       Note  that even though we've only indented inner elements of our table with 10 spaces, the result is cor‐
       rectly indented in terms of outer table, and inner tables also remain indented correctly.

       When using the <b>:preprocess</b> option or <b>__fennelview</b> method, avoid modifying  any  tables  in-place  in  the
       passed  function.   Since  Lua tables are mutable and passed in without copying, any modification done in
       these functions will be visible outside of <b>fennel.view</b>.

       Using <b>:byte-escape</b> to override the special character escape format is intended for use-cases  where  it's
       known  that the output will be consumed by something other than Lua/Fennel, and may result in output that
       Fennel can no longer parse.  For example, to force the use of hex escapes:

              (print (fennel.view {:clear-screen "\027[H\027[2J"}
                                  {:byte-escape #(: "\\x%2x" :format $)}))
              ;; &gt; {:clear-screen "\x1b[H\x1b[2J"}

       While Lua 5.2+ supports hex escapes, PUC Lua 5.1 does not, so compiling this with Fennel later would  re‐
       sult in an incorrect escape code in Lua 5.1.

</pre><h4><b>WORK</b> <b>WITH</b> <b>DOCSTRINGS</b> <b>AND</b> <b>METADATA</b></h4><pre>
       When  running  a  REPL  or  using  compile/eval  with metadata enabled, each function declared with <b>fn</b> or
       <b>λ/lambda</b> will use the created function as a key on <b>fennel.metadata</b> to store the  function's  arglist  and
       (if  provided)  docstring.   The  metadata table is weakly-referenced by key, so each function's metadata
       will be garbage collected along with the function itself.

       You can work with the API to view or modify this metadata yourself, or use the <b>,doc</b> repl command to  view
       function documentation.

       In addition to direct access to the metadata tables, you can use the following methods:

       • <b>fennel.metadata:get(func,</b> <b>key)</b>: get a value from a function's metadata

       • <b>fennel.metadata:set(func,</b> <b>key,</b> <b>val)</b>: set a metadata value

       • <b>fennel.metadata:setall(func,</b> <b>key1,</b> <b>val1,</b> <b>key2,</b> <b>val2,</b> <b>...)</b>: set pairs

       • <b>fennel.doc(func,</b>  <b>fnName)</b>: print formatted documentation for function using name.  Utilized by the <b>,doc</b>
         command, name is whatever symbol you operate on that's bound to the function.

         local greet = fennel.eval('(λ greet [name] "Say hello" (print "Hello," name))',
                                   {useMetadata = true})

         fennel.metadata[greet]
         -- &gt; {"fnl/docstring" = "Say hello", "fnl/arglist" = ["name"]}

         fennel.doc(greet, "greet")
         -- &gt; (greet name)
         -- &gt;   Say hello

         fennel.metadata:set(greet, "fnl/docstring", "Say hello!!!")
         fennel.doc(greet, "greet!")
         --&gt; (greet! name)
         --&gt;   Say hello!!!

   <b>Metadata</b> <b>performance</b> <b>note</b>
       Enabling metadata in the compiler/eval/REPL will cause every function to store a new table containing the
       function's arglist and docstring in the metadata table, weakly referenced by the  function  itself  as  a
       key.

       This  may have a performance impact in some applications due to the extra allocations and garbage collec‐
       tion associated with dynamic function creation.  The impact hasn't been benchmarked, but enabling metada‐
       ta is currently recommended for development purposes only.

</pre><h4><b>DESCRIBE</b> <b>FENNEL</b> <b>SYNTAX</b></h4><pre>
       If you're writing a tool which performs syntax highlighting or some other operations on Fennel code,  the
       <b>fennel.syntax</b> function can provide you with data about what forms and keywords to treat specially.

              local syntax = fennel.syntax()
              print(fennel.view(syntax["icollect"]))
              --&gt; {:binding-form? true :body-form? true :macro? true}

       The  table  has  string keys and table values.  Each entry will have one of <b>"macro?"</b>, <b>"global?"</b>, or <b>"spe‐</b>
       <b>cial?"</b> set to <b>true</b> indicating what type it is.  Globals can also have <b>"function?"</b> set  to  true.   Macros
       and  specials  can  have <b>"binding-form?"</b> set to true indicating it accepts a <b>[]</b> argument which introduces
       new locals, and/or a <b>"body-form?"</b> indicating whether it should be indented with two spaces instead of be‐
       ing indented like a function call.  They can also have a <b>"define?"</b> key indicating whether it introduces a
       new top-level identifier like <b>local</b> or <b>fn</b>.

</pre><h4><b>LOAD</b> <b>LUA</b> <b>CODE</b> <b>IN</b> <b>A</b> <b>PORTABLE</b> <b>WAY</b></h4><pre>
       This isn't Fennel-specific, but the <b>loadCode</b> function takes a string of Lua code along with  an  optional
       environment  table  and filename string, and returns a function for the loaded code which will run inside
       that environment, in a way that's portable across any Lua 5.1+ version.

              local f = fennel.loadCode(luaCode, { x = y }, "myfile.lua")

</pre><h4><b>DETECT</b> <b>LUA</b> <b>VM</b> <b>RUNTIME</b> <b>VERSION</b></h4><pre>
       This function does a best effort detection of the Lua VM environment hosting Fennel.  Useful for display‐
       ing an "About" dialog in your Fennel app that matches the REPL and <b>--version</b> CLI flag.

              (fennel.runtime-version)

              print(fennel.runtimeVersion())
              -- &gt; Fennel 1.0.0 on PUC Lua 5.4

       The <b>fennel.version</b> field will give you the version of just Fennel itself.

       <u>(since</u> <u>1.3.1)</u>

       If an optional argument is given, returns version information as a table:

              (fennel.runtime-version :as-table)
              ;; &gt; {:fennel "1.3.1" :lua "PUC Lua 5.4"}

</pre><h4><b>PLUGINS</b></h4><pre>
       Fennel's plugin system is extremely experimental and exposes internals of the compiler in  ways  that  no
       other  part  of  the  compiler does.  It should be considered unstable; changes to the compiler in future
       versions are likely to break plugins, and each plugin should only be assumed to work with  specific  ver‐
       sions of the compiler that they're tested against.  The backwards-compatibility guarantees of the rest of
       Fennel <b>do</b> <b>not</b> <b>apply</b> to plugins.

       Compiler  plugins  allow the functionality of the compiler to be extended in various ways.  A plugin is a
       module containing various functions in fields named after different compiler extension points.  When  the
       compiler  hits  an extension point, it will call each plugin's function for that extension point, if pro‐
       vided, with various arguments; usually the AST in question and the scope  table.   Each  plugin  function
       should  normally  do  side  effects  and return nil or error out.  If a function returns non-nil, it will
       cause the rest of the plugins for a given event to be skipped.

       • <b>symbol-to-expression</b>

       • <b>call</b>

       • <b>do</b>

       • <b>fn</b>

       • <b>destructure</b>

       • <b>parse-error</b>

       • <b>assert-compile</b>

       The <b>destructure</b> extension point is different because instead of just taking <b>ast</b> and <b>scope</b> it takes a <b>from</b>
       which is the AST for the value being destructured and a <b>to</b> AST which is the AST for the  form  being  de‐
       structured to.  This is most commonly a symbol but can be a list or a table.

       The  <b>parse-error</b>  and  <b>assert-compile</b> hooks can be used to override how fennel behaves down to the parser
       and compiler levels.  Possible use-cases include building atop <b>fennel.view</b> to  serialize  data  with  EDN
       (https://clojure.github.io/clojure/clojure.edn-api.html)-style  tagging,  or  manipulating external s-ex‐
       pression-based syntax,  such  as  tree-sitter  queries  (https://tree-sitter.github.io/tree-sitter/using-
       parsers#query-syntax).

       The <b>scope</b> argument is a table containing all the compiler's information about the current scope.  Most of
       the tables here look up values in their parent scopes if they do not contain a key.

       Plugins  can  also  contain  repl commands.  If your plugin module has a field with a name beginning with
       "repl-command-" then that function will be available as a comma command from within a repl  session.   It
       will  be called with a table for the repl session's environment, a function which will read the next form
       from stdin (ignoring newlines and other whitespace), a function which is used to print normal values, and
       one which is used to print errors.

              (local fennel (require :fennel)
              (fn locals [env read on-values on-error scope chars opts]
                "Print all locals in repl session scope."
                (on-values [(fennel.view env.___replLocals___)]))

              {:repl-command-locals locals}

              $ fennel --plugin locals-plugin.fnl
              Welcome to Fennel 0.8.0 on Lua 5.4!
              Use ,help to see available commands.
              &gt;&gt; (local x 4)
              nil
              &gt;&gt; (local abc :xyz)
              nil
              &gt;&gt; ,locals
              {
                :abc "xyz"
                :x 4
              }

       The docstring of the function will be used as its summary in the ",help" command listing.   Unlike  other
       plugin hook fields, only the first plugin to provide a repl command will be used.

   <b>Activation</b>
       Plugins  are  activated by passing the <b>--plugin</b> argument on the command line, which should be a path to a
       Fennel file containing a module that has some of the functions listed above.  If you're using the compil‐
       er programmatically, you can include a <b>:plugins</b> table in the <b>options</b> table to most compiler  entry  point
       functions.

       Your  plugin  should  contain  a <b>:versions</b> field which either contains a list of strings indicating every
       version of Fennel which you have tested it with, or a  string  containing  a  pattern  which  is  checked
       against  Fennel's version with <b>string.find</b>.  If your plugin is used with a version of Fennel that doesn't
       match <b>:versions</b> it will emit a warning.  You should also have a <b>:name</b> field with the plugin's name.

</pre><h4><b>AUTHORS</b></h4><pre>
       Fennel Maintainers.

fennel 1.5.3                                       2025-02-16                                      <u><a href="../man3/fennel-api.3.html">fennel-api</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>