<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::Core - fundamental PDL functionality and vectorization/broadcasting</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/pdl">pdl_2.100-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::Core - fundamental PDL functionality and vectorization/broadcasting

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Methods and functions for type conversions, PDL creation, type conversion, broadcasting etc.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PDL::Core;             # Normal routines
        use PDL::Core ':Internal'; # Hairy routines

</pre><h4><b>VECTORIZATION/BROADCASTING:</b> <b>METHOD</b> <b>AND</b> <b>NOMENCLATURE</b></h4><pre>
       PDL provides vectorized operations via a built-in engine.  Vectorization in PDL is called "broadcasting"
       (formerly, up to 2.074, "threading").  The broadcasting engine implements simple rules for each
       operation.

       Each PDL object has a "shape" that is a generalized N-dimensional rectangle defined by a "dim list" of
       sizes in an arbitrary set of dimensions.  A PDL with shape 2x3 has 6 elements and is said to be two-
       dimensional, or may be referred to as a 2x3-PDL.  The dimensions are indexed numerically starting at 0,
       so a 2x3-PDL has a dimension 0 (or "dim 0") with size 2 and a 1 dimension (or "dim 1") with size 3.

       PDL generalizes *all* mathematical operations with the notion of "active dims": each operator has zero or
       more active dims that are used in carrying out the operation.  Simple scalar operations like scalar
       multiplication ('*') have 0 active dims.  More complicated operators can have more active dims.  For
       example, matrix multiplication ('x') has 2 active dims.  Additional dims are automatically vectorized
       across -- e.g. multiplying a 2x5-PDL with a 2x5-PDL requires 10 simple multiplication operations, and
       yields a 2x5-PDL result.

   <b>Broadcasting</b> <b>rules</b>
       In any PDL expression, the active dims appropriate for each operator are used starting at the 0 dim and
       working forward through the dim list of each object.  All additional dims after the active dims are
       "broadcast dims".  The broadcast dims do not have to agree exactly: they are coerced to agree according
       to simple rules:

       •  Null PDLs match any dim list (see below).

       •  Dims with sizes other than 1 must all agree in size.

       •  Dims of size 1 are silently repeated as necessary except for "[phys]" PDLs.

       •  Missing dims are expanded appropriately.

       A size-1 dim for "[phys]" PDLs causes an exception if the dim is used in another parameter and has a size
       greater than 1.

       The  "size  1"  rule implements "generalized scalar" operation, by analogy to scalar multiplication.  The
       "missing dims" rule acknowledges the ambiguity between a missing dim and a dim of size 1.

   <b>Null</b> <b>PDLs</b>
       PDLs on the left-hand side of assignment can have the special value "Null".  A null PDL has no  dim  list
       and  no  set  size; its shape is determined by the computed shape of the expression being assigned to it.
       Null PDLs contain no values and can only be assigned to.  When assigned to (e.g. via the ".="  operator),
       they cease to be null PDLs.

       To create a null PDL, use "PDL-&gt;null()".

   <b>Empty</b> <b>PDLs</b>
       PDLs can represent the empty set using "structured Empty" variables.  An empty PDL is not a null PDL.

       Any dim of a PDL can be set explicitly to size 0.  If so, the PDL contains zero values (because the total
       number of values is the product of all the sizes in the PDL's shape or dimlist).

       Scalar  PDLs  are zero-dimensional and have no entries in the dim list, so they cannot be empty.  1-D and
       higher PDLs can be empty.  Empty PDLs are useful for set operations, and are most commonly encountered in
       the output from selection operators such as which  and  whichND.   Not  all  empty  PDLs  have  the  same
       broadcasting properties -- e.g. a 2x0-PDL represents a collection of 2-vectors that happens to contain no
       elements,  while a simple 0-PDL represents a collection of scalar values (that also happens to contain no
       elements).

       Note that 0 dims are not adjustable via the broadcasting rules -- a dim with size  0  can  only  match  a
       corresponding dim of size 0 or 1.

   <b>Broadcast</b> <b>rules</b> <b>and</b> <b>assignments</b>
       Versions  of  PDL through 2.4.10 have some irregularity with broadcasting and assignments.  Currently the
       broadcasting engine performs a full expansion of both sides of  the  computed  assignment  operator  ".="
       (which assigns values to a pre-existing PDL).  This leads to counter-intuitive behavior in some cases:

       •  Empty PDLs and generalized scalars

          Generalized scalars (PDLs with a dim of size 1) can match any size in the corresponding dim, including
          0.  Thus,

              $x = ones(2,0);
              $y = sequence(2,1);
              $c = $x * $y;
              print $c;

          prints "Empty[2,0]".

          This behavior is counterintuitive but desirable, and will be preserved in future versions of PDL.

</pre><h4><b>VARIABLES</b></h4><pre>
       These are important variables of <b>global</b> scope and are placed in the PDL namespace.

       <u>$PDL::debug</u>

           When true, PDL debugging information is printed.

       <u>$PDL::verbose</u>

           When true, PDL functions provide chatty information.

       <u>$PDL::use_commas</u>

           Whether to insert commas when printing pdls

       <u>$PDL::floatformat,</u> <u>$PDL::doubleformat,</u> <u>$PDL::indxformat</u>

           The  default  print  format  for floats, doubles, and indx values, respectively.  The default default
           values are:

             $PDL::floatformat  = "%7g";
             $PDL::doubleformat = "%10.8g";
             $PDL::indxformat   = "%12d";

       <u>$PDL::infoformat</u>

           The default format for "info".  The default value is:

             $PDL::infoformat = "%C: %T %D";

       <u>$PDL::undefval</u>

           The value to use instead of "undef" when creating pdls. If is "undef", 0 will be used.

       <u>$PDL::toolongtoprint</u>

           The maximal size pdls to print (defaults to 10000 elements)

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>barf</b>
       Standard error reporting routine for PDL.

       barf() is the routine PDL modules should call to report errors. This is because barf()  will  report  the
       error as coming from the correct line in the module user's script rather than in the PDL module.

       For now, barf just calls <b>Carp::confess()</b>

       Remember barf() is your friend. *Use* it!

       At the perl level:

        barf("User has too low an IQ!");

       In C or XS code:

        barf("You have made %d errors", count);

       Note: this is one of the few functions ALWAYS exported by PDL::Core

   <b>pdl</b>
       PDL constructor - creates new ndarray from perl scalars/arrays, ndarrays, and strings

        $double_pdl = pdl(SCALAR|ARRAY REFERENCE|ARRAY|STRING);  # default type
        $type_pdl   = pdl(PDL::Type,SCALAR|ARRAY REFERENCE|ARRAY|STRING);

        $x = pdl [1..10];                    # 1D array of doubles
        $x = pdl ([1..10]);                  # 1D array
        $x = pdl (1,2,3,4);                  # Ditto
        $y = pdl [[1,2,3],[4,5,6]];          # 2D 3x2 array
        $y = pdl "[[1,2,3],[4,5,6]]";        # Ditto (slower)
        $y = pdl "[1 2 3; 4 5 6]";           # Ditto
        $y = pdl q[1 2 3; 4 5 6];            # Ditto, using the q quote operator
        $y = pdl "1 2 3; 4 5 6";             # Ditto, less obvious, but still works
        $y = pdl 42                          # 0-dimensional scalar
        $c = pdl $x;                         # Make a new copy

        $u = pdl ushort(), 42                # 0-dimensional ushort scalar
        $y = pdl(byte(),[[1,2,3],[4,5,6]]);  # 2D byte ndarray

        $n = pdl indx(), [1..5];             # 1D array of indx values
        $n = pdl indx, [1..5];               # ... can leave off parens
        $n = indx( [1..5] );                 # ... still the same!

        $n = pdl cdouble, 2, 3;              # native complex numbers, zero imaginary
        use Math::Complex qw(cplx);
        $n = pdl cdouble, 2, cplx(2, 1));    # explicit type
        $n = pdl 2, cplx(2, 1);              # default cdouble if Math::Complex obj

        $x = pdl([[1,2,3],[4,5,6]]);         # 2D
        $x = pdl([1,2,3],[4,5,6]);           # 2D

       Note  the  last  two are equivalent - a list is automatically converted to a list reference for syntactic
       convenience. i.e. you can omit the outer "[]"

       You can mix and match arrays, array refs, and PDLs in your argument list, and "pdl" will sort  them  out.
       You  get  back  a PDL whose last (slowest running) dim runs across the top level of the list you hand in,
       and whose first (fastest running) dim runs across the deepest level that you supply.

       At the moment, you cannot mix and match those arguments with string arguments, though we can't imagine  a
       situation in which you would really want to do that.

       The  string version of pdl also allows you to use the strings "bad", "inf", and "nan", and it will insert
       the values that you mean (and set the bad flag if you use "bad"). You can mix and match case, though  you
       shouldn't. Here are some examples:

        $bad = pdl q[1 2 3 bad 5 6];  # Set fourth element to the bad value
        $bad = pdl q[1 2 3 BAD 5 6];  # ditto
        $bad = pdl q[1 2 inf bad 5];  # now third element is IEEE infinite value
        $bad = pdl q[nan 2 inf -inf]; # first value is IEEE nan value

       The  default  constructor uses IEEE double-precision floating point numbers. You can use other types, but
       you will get a warning if you try to use "nan" with integer types (it will be  replaced  with  the  "bad"
       value) and you will get a fatal error if you try to use "inf".

       Throwing a PDL into the mix has the same effect as throwing in a list ref:

         pdl(pdl(1,2),[3,4])

       is the same as

         pdl([1,2],[3,4]).

       All  of  the dimensions in the list are "padded-out" with undefval to meet the widest dim in the list, so
       (e.g.)

         $x = pdl([[1,2,3],[2]])

       gives you the same answer as

         $x = pdl([[1,2,3],[2,undef,undef]]);

       If your PDL module has bad values compiled into it (see PDL::Bad), you  can  pass  BAD  values  into  the
       constructor  within  pre-existing  PDLs.   The  BAD  values  are  automatically  kept  BAD and propagated
       correctly.

       pdl() is a functional synonym for the 'new' constructor, e.g.:

        $x = PDL-&gt;new([1..10]);

       In order to control how undefs are handled in converting from  perl  lists  to  PDLs,  one  can  set  the
       variable $PDL::undefval.  For example:

        $foo = [[1,2,undef],[undef,3,4]];
        $PDL::undefval = -999;
        $f = pdl $foo;
        print $f
        [
         [   1    2 -999]
         [-999    3    4]
        ]

       $PDL::undefval defaults to zero.

       As  a  final note, if you include an Empty PDL in the list of objects to construct into a PDL, it is kept
       as a placeholder pane -- so if you feed in (say) 7 objects, you get a size of 7 in the  0th  dim  of  the
       output  PDL.   The  placeholder  panes are completely padded out.  But if you feed in only a single Empty
       PDL, you get back the Empty PDL (no padding).

   <b>empty</b>
       Returns an empty ndarray, with a single zero-length dimension.  Only  available  as  a  function,  not  a
       method.

        $x = empty; # defaults to lowest type so it can always be promoted up
        $x = empty(float);

   <b>null</b>
       Returns a 'null' ndarray.  It is an error to pass one of these as an input to a function.

        $x = null;

       null()  has  a  special meaning to PDL::PP. It is used to flag a special kind of empty ndarray, which can
       grow to appropriate dimensions to store a result (as opposed to storing a result in an existing ndarray).

        pdl&gt; sumover sequence(10,10), $ans=null;p $ans
        [45 145 245 345 445 545 645 745 845 945]

   <b>nullcreate</b>
       Returns a 'null' ndarray.

        $x = PDL-&gt;nullcreate($arg)

       This is an routine used by many of the broadcasting primitives (i.e. sumover, minimum, etc.) to  generate
       a  null  ndarray  for  the  function's  output  that will behave properly for derived (or subclassed) PDL
       objects.

       For the above usage: If $arg is a PDL, or a derived PDL, then "$arg-&gt;null" is returned.   If  $arg  is  a
       scalar (i.e. a zero-dimensional PDL) then "PDL-&gt;null" is returned.

        PDL::Derived-&gt;<a href="../man10/nullcreate.10.html">nullcreate</a>(10)
          returns PDL::Derived-&gt;null.
        PDL-&gt;nullcreate($pdlderived)
          returns $pdlderived-&gt;null.

   <b>nelem</b>
       Return the number of elements in an ndarray

        $n = nelem($ndarray); $n = $ndarray-&gt;nelem;

        $mean = sum($data)/nelem($data);

   <b>dims</b>
       Return ndarray dimensions as a perl list

        @dims = $ndarray-&gt;dims;  @dims = dims($ndarray);

        pdl&gt; p @tmp = dims zeroes 10,3,22
        10 3 22

       See also "shape" which returns an ndarray instead.

   <b>shape</b>
       Return ndarray dimensions as an ndarray

        $shape = $ndarray-&gt;shape;  $shape = shape($ndarray);

        pdl&gt; p $shape = shape zeroes 10,3,22
        [10 3 22]

       See also "dims" which returns a perl list.

   <b>ndims</b>
       Returns the number of dimensions in an ndarray. Alias for getndims.

   <b>getndims</b>
       Returns the number of dimensions in an ndarray

        $ndims = $ndarray-&gt;getndims;

        pdl&gt; p zeroes(10,3,22)-&gt;getndims
        3

   <b>dim</b>
       Returns the size of the given dimension of an ndarray. Alias for getdim.

   <b>getdim</b>
       Returns the size of the given dimension.

        $dim0 = $ndarray-&gt;<a href="../man0/getdim.0.html">getdim</a>(0);

        pdl&gt; p zeroes(10,3,22)-&gt;<a href="../man1/getdim.1.html">getdim</a>(1)
        3

       Negative  indices  count from the end of the dims array.  Indices beyond the end will return a size of 1.
       This reflects the idea that any pdl is equivalent to an infinitely dimensional  array  in  which  only  a
       finite  number  of  dimensions have a size different from one. For example, in that sense a 3D ndarray of
       shape [3,5,2] is equivalent to a [3,5,2,1,1,1,1,1,....]  ndarray. Accordingly,

         print $x-&gt;<a href="../man10000/getdim.10000.html">getdim</a>(10000);

       will print 1 for most practically encountered ndarrays.

   <b>topdl</b>
       alternate ndarray constructor - ensures arg is an ndarray

        $x = topdl(SCALAR|ARRAY REFERENCE|ARRAY);

       The difference between <b>pdl()</b> and topdl() is that the latter will just 'fall through' if the  argument  is
       already an ndarray. It will return a reference and <u>NOT</u> a new copy.

       This is particularly useful if you are writing a function which is doing some fiddling with internals and
       assumes  an  ndarray argument (e.g. for method calls). Using topdl() will ensure nothing breaks if passed
       with '2'.

       Note that topdl() is not exported by default (see example below for usage).

        use PDL::Core ':Internal'; # use the internal routines of
                                   # the Core module

        $x = topdl 43;             # $x is ndarray with value '43'
        $y = topdl $ndarray;       # fall through
        $x = topdl (1,2,3,4);      # Convert 1D array

   <b>tocomplex</b>
       Return a complex-typed ndarray, either as a no-op or a conversion.

         $cplx = $pdl-&gt;tocomplex;

       Not exported. Added in 2.099.

   <b>set_datatype</b>
       Sets the ndarray's data type to the given value (the integer identifier  for  the  type,  see  "enum"  in
       PDL::Types). See "get_datatype". Internal function. Errors if ndarray has child transforms. Severs if has
       a parent.

   <b>get_datatype</b>
       Internal: Return the numeric value identifying the ndarray datatype

        $x = $ndarray-&gt;get_datatype;

       Mainly used for internal routines.

       NOTE: get_datatype returns 'just a number' not any special type object, unlike "type".

   <b>howbig</b>
       Returns the sizeof an ndarray datatype in bytes.

       Note that howbig() is not exported by default (see example below for usage).

        use PDL::Core ':Internal'; # use the internal routines of
                                   # the Core module

        $size = howbig($ndarray-&gt;get_datatype);

       Mainly used for internal routines.

       NOTE: NOT a method! This is because get_datatype returns 'just a number' not any special object.

        pdl&gt; p howbig(ushort([1..10])-&gt;get_datatype)
        2

   <b>update_data_from</b>
       Update an ndarray's internal data for from packed data.

         $data = read_from_datasource();
         $pdl-&gt;update_data_from($data);

       Throws an exception if the argument is the wrong size for that ndarray.

   <b>get_dataref</b>
       Return the internal data for an ndarray, as a perl SCALAR ref.

       If  you  are  using  this  in  order to manipulate the SV, then call "upd_data", then as of 2.099 you are
       recommended instead to just use "update_data_from" to streamline the process.

       Most ndarrays hold their internal data in a packed perl  string,  to  take  advantage  of  perl's  memory
       management.   This  gives you direct access to the string, which is handy when you need to manipulate the
       binary data directly (e.g. for file I/O).  If you modify the  string,  you'll  need  to  call  "upd_data"
       afterward, to make sure that the ndarray points to the new location of the underlying perl variable.

       Calling  "get_dataref"  automatically  physicalizes  your  ndarray (see "make_physical").  You definitely
       don't want to do anything to the SV to truncate or deallocate the string, unless you correspondingly call
       "reshape" to make the PDL match its new data dimension.

       You definitely don't want to use get_dataref unless you know what you are doing (or are  trying  to  find
       out):  you  can  end  up  scrozzling  memory  if you shrink or eliminate the string representation of the
       variable.  Here be dragons.

   <b>upd_data</b>
       Update the data pointer in an ndarray to match its perl SV.

       This is useful if you've been monkeying with the packed string  representation  of  the  PDL,  which  you
       probably shouldn't be doing anyway.  (see "get_dataref".)

       As of 2.099 you are recommended instead to just use "update_data_from" to streamline the process.

   <b>broadcastids</b>
       Returns the ndarray broadcast IDs as a perl list

       Note that broadcastids() is not exported by default (see example below for usage).

        use PDL::Core ':Internal'; # use the internal routines of
                                   # the Core module

        @ids = broadcastids $ndarray;

   <b>readonly</b>
       Make  an ndarray read-only, returning the ndarray argument.  This means any future transformation (a.k.a.
       PDL operation) applied to this ndarray <u>as</u> <u>an</u> <u>output</u> will cause an exception:

         $x = <a href="../man3/sequence.3.html">sequence</a>(3)-&gt;readonly; # also works: $x = <a href="../man3/sequence.3.html">sequence</a>(3); $x-&gt;readonly;
         $y = $x + 1; # fine
         $x .= 5; # error
         $x += 5; # also error

       Not exported.

        $x-&gt;readonly;

   <b>is_readonly</b>
       Test whether an ndarray is read-only.

         $bool = $x-&gt;is_readonly;

       Not exported.

        $x-&gt;is_readonly;

   <b>flowing</b>
       Turn on dataflow, forward only, only for  the  next  operation  (cf  "inplace"),  returning  the  ndarray
       argument.   This  means  the next transformation (a.k.a. PDL operation) applied to this ndarray will have
       forward dataflow:

         $x = sequence 3;
         $y = $x-&gt;flowing + 1; # could instead do $x-&gt;flowing; $y = $x + 1
         $x += 3; # this does not flow, but that would be an infinite loop anyway
         print "$y\n"; # [4 5 6]

       This replaced "doflow" as of 2.090. See PDL::Dataflow for more.

        $x-&gt;flowing; flowing($x);

   <b>fflows</b>
       Returns whether the ndarray's "PDL_DATAFLOW_F" flag is set.

   <b>new</b>
       new ndarray constructor method

        $x = PDL-&gt;new(SCALAR|ARRAY|ARRAY REF|STRING);

        $x = PDL-&gt;<a href="../man42/new.42.html">new</a>(42);             # new from a Perl scalar
        $y = PDL-&gt;new(@list_of_vals);  # new from Perl list
        $z = PDL-&gt;new(\@list_of_vals); # new from Perl list reference
        $w = PDL-&gt;new("[1 2 3]");      # new from Perl string, using
                                       # Matlab constructor syntax

       Constructs ndarray from perl numbers and lists and strings with Matlab/Octave style constructor syntax.

       The string input is fairly versatile though not performance optimized. The goal is to  make  it  easy  to
       copy and paste code from PDL output and to offer a familiar Matlab syntax for ndarray construction. As of
       May,  2010,  it is a new feature, so feel free to report bugs or suggest new features.  See documentation
       for pdl for more examples of usage.

   <b>copy</b>
       Make a physical copy of an ndarray

        $new = $old-&gt;copy;

       Since "$new = $old" just makes a new reference, the "copy" method is provided to allow  real  independent
       copies to be made.

   <b>hdr_copy</b>
       Return an explicit copy of the header of a PDL.

       hdr_copy  is just a wrapper for the internal routine _hdr_copy, which takes the hash ref itself.  That is
       the routine which is used to make copies of the header during normal operations if the <b>hdrcpy()</b> flag of a
       PDL is set.

       General-purpose deep copies are expensive in perl, so some simple optimization happens:

       If the header is a tied array or a blessed hash ref with an associated method called  "copy",  then  that
       -&gt;copy  method  is  called.   Otherwise,  all elements of the hash are explicitly copied.  References are
       recursively deep copied.

       This routine seems to leak memory.

   <b>unwind</b>
       Return an ndarray which is the same as the argument except that all broadcastids have been removed.

        $y = $x-&gt;unwind;

   <b>make_physical</b>
       Make sure the data portion of an ndarray can be accessed from XS code.

        $x-&gt;make_physical;
        $x-&gt;call_my_xs_method;

       Ensures that an ndarray gets its own allocated copy of  data.  This  obviously  implies  that  there  are
       certain ndarrays which do not have their own data.  These are so called <u>virtual</u> ndarrays that make use of
       the  <u>vaffine</u> optimisation (see PDL::Indexing).  They do not have their own copy of data but instead store
       only access information to some (or all) of another ndarray's data.

       Note: this function should not be used unless absolutely necessary since  otherwise  memory  requirements
       might  be  severely  increased. Instead of writing your own XS code with the need to call "make_physical"
       you might want to consider using the PDL preprocessor (see PDL::PP) which can be  used  to  transparently
       access virtual ndarrays without the need to physicalise them (though there are exceptions).

   <b>make_physvaffine</b>
       A more "careful" function than "make_physical". For ndarrays without a vaffine transformations as parent,
       it will just call "make_physical". Otherwise, it will update the vaffine transformation bookkeeping.

   <b>make_physdims</b>
       Ensures  the  ndarray's  dimensions  are up to date including changes in parent's dimensions, and calling
       "redodims".

   <b>trans_parent</b>
       Returns a PDL::Trans object representing the transformation (PDL operation) that is the "parent" of  this
       ndarray, or "undef" if none.

       Such objects have these methods:

       parents
           Returns a list of ndarrays that are inputs to this trans.

       children
           Returns  a  list  of ndarrays that are outputs to this trans (specified as "[o]", "[oca]", "[io]", or
           "[t]" in "Pars").

       address
           The memory address of the struct.

       flags
           List of strings of flags set for this trans.

       affine
           Whether the trans is affine.

       offs
           Affine-only: the offset into the parent's data.

       incs
           Affine-only: the dimincs for each of the child's dims.

       ind_sizes
           The size of each named dim.

       inc_sizes
           The size of the inc for each use of a named dim.

       vtable
           This trans's vtable.

       "$vtable-&gt;name"
           The function name from this vtable.

       "$vtable-&gt;flags"
           List of strings of flags set for this vtable.

       "$vtable-&gt;par_names"
           List of 2 array-refs of strings of names of input pars, then output pars, for this vtable.

   <b>trans_children</b>
       Returns a list of PDL::Trans objects (see "trans_parent") representing each transformation that has  this
       ndarray as an input.

   <b>address</b>
       Returns the memory address of the ndarray's "struct".

   <b>address_data</b>
       Returns the value of the ndarray "struct"'s "data" member.

   <b>set_donttouchdata</b>
       Sets  the  "PDL_DONTTOUCHDATA"  flag  and  the  "nbytes"  to  the  given  value. Useful in memory-mapping
       functionality.  The "nbytes" can be omitted, in which case only the flag is set.

   <b>nbytes</b>
       Returns the ndarray's "nbytes".

   <b>seed</b>
       Returns the random seed being used by PDL's RNG.

   <b>set_debugging</b>
       Sets whether PDL operations print lots of debugging info to standard output. Returns the old value.

         PDL::Core::<a href="../man1/set_debugging.1.html">set_debugging</a>(1);
         # ... these operations will have debugging info printed to stdout
         PDL::Core::<a href="../man0/set_debugging.0.html">set_debugging</a>(0); # turn it off again

   <b>dummy</b>
       Insert a 'dummy dimension' of given length (defaults to 1)

       No relation to the 'Dungeon Dimensions' in Discworld!

       Negative positions specify relative to last dimension, i.e.  dummy(-1)  appends  one  dimension  at  end,
       dummy(-2) inserts a dummy dimension in front of the last dim, etc.

       If  you  specify  a  dimension position larger than the existing dimension list of your PDL, the PDL gets
       automagically padded with extra dummy dimensions so that you get the dim you asked for, in the  slot  you
       asked  for.   This could cause you trouble if, for example, you ask for $x-&gt;dummy(5000,1) because $x will
       get 5,000 dimensions, each of rank 1.

       Because padding at the beginning of the dimension list moves existing dimensions from slot to slot,  it's
       considered  unsafe,  so  automagic  padding  doesn't  work  for  large negative indices -- only for large
       positive indices.

        $y = $x-&gt;dummy($position[,$dimsize]);

        pdl&gt; p <a href="../man3/sequence.3.html">sequence</a>(3)-&gt;dummy(0,3)
        [
         [0 0 0]
         [1 1 1]
         [2 2 2]
        ]

        pdl&gt; p <a href="../man3/sequence.3.html">sequence</a>(3)-&gt;dummy(3,2)
        [
         [
          [0 1 2]
         ]
         [
          [0 1 2]
         ]
        ]

        pdl&gt; p <a href="../man3/sequence.3.html">sequence</a>(3)-&gt;dummy(-3,2)
        Runtime error: PDL: For safety, &lt;pos&gt; &lt; -(dims+1) forbidden in dummy.  min=-2, pos=-3

   <b>dup</b>
       Duplicates an ndarray along a dimension

        $x = <a href="../man3/sequence.3.html">sequence</a>(3);
        $y = $x-&gt;dup(0, 2); # doubles along first dimension
        # $y now [0 1 2 0 1 2]

   <b>dupN</b>
       Duplicates an ndarray along several dimensions

        $x = sequence(3,2);
        $y = $x-&gt;dupN(2, 3); # doubles along first dimension, triples along second
        # [
        #  [0 1 2 0 1 2]
        #  [3 4 5 3 4 5]
        #  [0 1 2 0 1 2]
        #  [3 4 5 3 4 5]
        #  [0 1 2 0 1 2]
        #  [3 4 5 3 4 5]
        # ]

   <b>inflateN</b>
       Inflates an ndarray along several dimensions, useful for e.g. Kronecker products

       cf "dupN"

        $x = sequence(3,2);
        $y = $x-&gt;inflateN(2, 2); # doubles along first two dimensions
        # [
        #  [0 0 1 1 2 2]
        #  [0 0 1 1 2 2]
        #  [3 3 4 4 5 5]
        #  [3 3 4 4 5 5]
        # ]

   <b>clump</b>
       "clumps" several dimensions into one large dimension

       If called with one argument $n clumps the first $n dimensions into one. For example, if $x has dimensions
       "(5,3,4)" then after

        $y = $x-&gt;<a href="../man2/clump.2.html">clump</a>(2);   # Clump 2 first dimensions

       the variable $y will have dimensions "(15,4)"  and  the  element  "$y-&gt;at(7,3)"  refers  to  the  element
       "$x-&gt;at(1,2,3)".

       Use clump(-1) to flatten an ndarray. The method flat is provided as a convenient alias.

       Clumping with a negative dimension in general leaves that many dimensions behind -- e.g. clump(-2) clumps
       all of the first few dimensions into a single one, leaving a 2-D ndarray.

       If  "clump" is called with an index list with more than one element it is treated as a list of dimensions
       that should be clumped together into one. The resulting clumped dim is placed  at  the  position  of  the
       lowest  index  in  the  list.   This convention ensures that "clump" does the expected thing in the usual
       cases. The following example demonstrates typical usage:

         $x = sequence 2,3,3,3,5; # 5D ndarray
         $c = $x-&gt;clump(1..3);    # clump all the dims 1 to 3 into one
         print $c-&gt;info;          # resulting 3D ndarray has clumped dim at pos 1
         PDL: Double D [2,27,5]

       Data flows back and forth as usual with slicing routines.

   <b>broadcast_define</b>
       define functions that support broadcasting at the perl level

        broadcast_define 'tline(a(n);b(n))', over {
         line $_[0], $_[1]; # make line compliant with broadcasting
        };

       "broadcast_define" provides some support for broadcasting (see  PDL::Indexing)  at  the  perl  level.  It
       allows  you to do things for which you normally would have resorted to PDL::PP (see PDL::PP); however, it
       is most useful to wrap existing perl functions so that the new routine supports PDL broadcasting.

       "broadcast_define" is used to define new <u>broadcasting</u> <u>aware</u> functions. Its first argument is  a  symbolic
       repesentation  of  the new function to be defined. The string is composed of the name of the new function
       followed by its signature (see PDL::Indexing and PDL::PP)  in  parentheses.  The  second  argument  is  a
       subroutine  that  will  be  called  with  the  slices of the actual runtime arguments as specified by its
       signature. Correct dimension sizes and minimal number of dimensions for all  arguments  will  be  checked
       (assuming the rules of PDL broadcasting, see PDL::Indexing).

       The  actual  work  is  done  by  the  "signature"  class  which parses the signature string, does runtime
       dimension checks and the routine "broadcastover" that generates the loop over all appropriate  slices  of
       pdl arguments and creates pdls as needed.

       Similar  to  "pp_def"  and  its  "OtherPars"  option it is possible to define the new function so that it
       accepts normal perl args as well as ndarrays. You do this by using  the  "NOtherPars"  parameter  in  the
       signature. The number of "NOtherPars" specified will be passed unaltered into the subroutine given as the
       second argument of "broadcast_define". Let's illustrate this with an example:

        PDL::broadcast_define 'triangles(inda();indb();indc()), NOtherPars =&gt; 2',
         PDL::over {
           ${$_[3]} .= $_[4].join(',',map {$_-&gt;at} @_[0..2]).",-1,\n";
         };

       This defines a function "triangles" that takes 3 ndarrays as input plus 2 arguments which are passed into
       the routine unaltered. This routine is used to collect lists of indices into a perl scalar that is passed
       by reference. Each line is preceded by a prefix passed as $_[4]. Here is typical usage:

        $txt = '';
        triangles(pdl(1,2,3),<a href="../man1/pdl.1.html">pdl</a>(1),<a href="../man0/pdl.0.html">pdl</a>(0),\$txt," "x10);
        print $txt;

       resulting in the following output

        1,1,0,-1,
        2,1,0,-1,
        3,1,0,-1,

       which is used in PDL::Graphics::TriD::VRML to generate VRML output.

       Currently,  this  is  probably  not  much  more than a POP (proof of principle) but is hoped to be useful
       enough for some real life work.

       Check PDL::PP for the format of the signature. Currently, the "[t]" qualifier and all type qualifiers are
       ignored.

   <b>broadcast</b>
       Use explicit broadcasting over specified dimensions (see also PDL::Indexing)

        $y = $x-&gt;broadcast($dim,[$dim1,...])

        $x = zeroes 3,4,5;
        $y = $x-&gt;broadcast(2,0);
        print $y-&gt;info; # PDL: Double D [4] T1 [5,3]
        $pb = zeroes(3,3);
        print $pb-&gt;broadcast(0,1)-&gt;info; # PDL: Double D [] T1 [3,3]
        print $pb-&gt;<a href="../man0/broadcast.0.html">broadcast</a>(0)-&gt;info; #  'PDL: Double D [3] T1 [3]
        print zeroes(4,7,2,8)-&gt;<a href="../man2/broadcast.2.html">broadcast</a>(2)-&gt;info; # PDL: Double D [4,7,8] T1 [2]
        print zeroes(4,7,2,8)-&gt;broadcast(2,1)-&gt;info; # PDL: Double D [4,8] T1 [2,7]
        print zeroes(4,7,2,8,5,6)-&gt;broadcast(2,4)-&gt;info; # PDL: Double D [4,7,8,6] T1 [2,5]
        print zeroes(4,7,2,8,5,6)-&gt;<a href="../man2/broadcast1.2.html">broadcast1</a>(2)-&gt;<a href="../man3/broadcast2.3.html">broadcast2</a>(3)-&gt;info; # PDL: Double D [4,7,8,6] T1 [2] T2 [5]

       Same as "broadcast1", i.e. uses broadcast id 1.  To use broadcast id 2, use "broadcast2", or "broadcastI"
       in PDL::Slices directly.

   <b>broadcast1</b>
       Explicit broadcasting over specified dims using broadcast id 1.

        $xx = $x-&gt;broadcast1(3,1)

       Convenience function interfacing to PDL::Slices::broadcastI.

   <b>broadcast2</b>
       Explicit broadcasting over specified dims using broadcast id 2.

        $xx = $x-&gt;broadcast2(3,1)

       Convenience function interfacing to PDL::Slices::broadcastI.

   <b>broadcast3</b>
       Explicit broadcasting over specified dims using broadcast id 3.

        $xx = $x-&gt;broadcast3(3,1)

       Convenience function interfacing to PDL::Slices::broadcastI.

   <b>sever</b>
       sever any links of this ndarray to parent ndarrays

       In PDL it is possible for an ndarray to be just another view into another ndarray's data. In that case we
       call this ndarray a <u>virtual</u> <u>ndarray</u> and the original  ndarray  owning  the  data  its  parent.  In  other
       languages these alternate views sometimes run by names such as <u>alias</u> or <u>smart</u> <u>reference</u>.

       Typical  functions  that  return such ndarrays are "slice", "xchg", "index", etc. Sometimes, however, you
       would like to separate the <u>virtual</u> <u>ndarray</u> from its parent's data and just give it a life of its own  (so
       that  manipulation of its data doesn't change the parent).  This is simply achieved by using "sever". For
       example,

          $x = $pdl-&gt;index(pdl(0,3,7))-&gt;sever;
          $x++;       # important: $pdl is not modified!

       In many (but not all) circumstances it acts therefore similar to copy.  However, in  general  performance
       is  better  with  "sever" and secondly, "sever" doesn't lead to futile copying when used on ndarrays that
       already have their own data. On the other hand, if you really want to make sure to work on a copy  of  an
       ndarray use copy.

          $x = <a href="../man20/zeroes.20.html">zeroes</a>(20);
          $x-&gt;sever;   # NOOP since $x is already its own boss!

       Again note: "sever" <u>is</u> <u>not</u> the same as copy!  For example,

          $x = <a href="../man1/zeroes.1.html">zeroes</a>(1); # $x does not have a parent, i.e. it is not a slice etc
          $y = $x-&gt;sever; # $y is now pointing to the same ndarray as $x
          $y++;
          print $x;
        [1]

       but

          $x = <a href="../man1/zeroes.1.html">zeroes</a>(1);
          $y = $x-&gt;copy; # $y is now pointing to a new ndarray
          $y++;
          print $x;
        [0]

   <b>info</b>
       Return formatted information about an ndarray.

        $x-&gt;info($format_string);

        print $x-&gt;info("Type: %T Dim: %-15D State: %S");

       Returns  a  string  with  info  about  an  ndarray.  Takes  an optional argument to specify the format of
       information a la sprintf.  Format specifiers are in  the  form  "%&lt;width&gt;&lt;letter&gt;"  where  the  width  is
       optional and the letter is one of

       T      Type

       D      Formatted Dimensions

       F      Dataflow status

       S      Some internal flags (P=physical,V=Vaffine,C=changed,B=may contain bad data)

       C      Class of this ndarray, i.e. "ref $pdl"

       A      Address of the ndarray struct as a unique identifier

       M      Calculated memory consumption of this ndarray's data area

       The default format is "%C: %T %D".  This can be modified by assigning to $PDL::infoformat.

   <b>pdump</b>
       Returns  a  close  analogue  of the output of "$pdl-&gt;dump" as a string. Like that C function, it will not
       cause any physicalisation of the ndarray.

       Not exported, and not inserted into the "PDL" namespace.

         print PDL::Core::pdump($pdl);

   <b>pdump_trans</b>
       Returns a string representation of a "PDL::Trans" object, a close analogue  of  part  of  the  output  of
       "$pdl-&gt;dump".

       Not exported, and not inserted into the "PDL" namespace.

         print PDL::Core::pdump_trans($pdl_trans);

   <b>pdumphash</b>
       Returns  a  hash-ref  representing the information about a given object ("PDL::Trans" or ndarray) and all
       the objects of either type it is connected to. Includes similar information to that shown by "pdump"  and
       "pdump_trans".

       Not exported, and not inserted into the "PDL" namespace.

         $hashref = PDL::Core::pdumphash($pdl_trans); # or
         $hashref = PDL::Core::pdumphash($pdl);

   <b>pdumpgraph</b>
       Given a hash-ref returned by "pdumphash", returns a Graph object representing the same information.

       Not exported, and not inserted into the "PDL" namespace.

         $g = PDL::Core::pdumphash($hashref);

   <b>pdumpgraphvizify</b>
       Given  a  Graph  object  returned  by  "pdumpgraph",  modifies  it  suitable for input to "from_graph" in
       GraphViz2, then returns it. See example for how to use.

       Not exported, and not inserted into the "PDL" namespace.

         $g = PDL::Core::pdumpgraphvizify($g);

         # full example:
         $count = 1; $format = 'png'; sub output {
           $g = PDL::Core::pdumpgraph(PDL::Core::pdumphash($_[0]));
           require GraphViz2;
           $gv = GraphViz2-&gt;from_graph(PDL::Core::pdumpgraphvizify($g));
           $gv-&gt;run(format =&gt; $format, output_file =&gt; 'output'.$count++.".$format");
         }
         # keep changing ndarray, then calling this to show each state:
         output($pdl);

         # run the above script, then show the ndarray evolve over time, in a
         # left-to-right montage using ImageMagick tools:
         perl myscript.pl
         montage output* -tile "$(echo output*|wc -w)"x1 -geometry '1x1&lt;' final.png
         display final.png

   <b>approx</b>
       test for approximately equal values (relaxed "==")

         # ok if all corresponding values in
         # ndarrays are within 1e-8 of each other
         print "ok\n" if all approx $x, $y, 1e-8;

       "approx" is a relaxed form of the "==" operator and often  more  appropriate  for  floating  point  types
       ("float" "double" and "ldouble").

       Usage:

         $res = approx $x, $y [, $eps]

       The optional parameter $eps is remembered across invocations and initially set to 1e-6, e.g.

         approx $x, $y;         # last $eps used (1e-6 initially)
         approx $x, $y, 1e-10;  # 1e-10
         approx $x, $y;         # also 1e-10

   <b>mslice</b>
       Alias to "slice" in PDL::Slices.

   <b>nslice_if_pdl</b>
       If $self is a PDL, then calls "slice" with all but the last argument, otherwise $self-&gt;($_[-1]) is called
       where $_[-1] is the original argument string found during PDL::NiceSlice filtering.

       DEVELOPER'S NOTE: this routine is found in Core.pm but would be better placed in Slices/slices.pd.  It is
       likely to be moved there and/or changed to "slice_if_pdl" for PDL 3.0.

        $w = $x-&gt;nslice_if_pdl(...,'(args)');

   <b>donttouch</b>
       Returns whether the ndarray's "PDL_DONTTOUCHDATA" flag is set.

   <b>allocated</b>
       Returns whether the ndarray's "PDL_ALLOCATED" flag is set.

   <b>vaffine</b>
       Returns whether the ndarray's "PDL_OPT_VAFFTRANSOK" flag is set.

   <b>anychgd</b>
       Returns whether the ndarray's "PDL_ANYCHANGED" flag is set.

   <b>dimschgd</b>
       Returns whether the ndarray's "PDL_PARENTDIMSCHANGED" flag is set.

   <b>inplace</b>
       Flag an ndarray so that the next operation is done 'in place', returning the ndarray.

        somefunc($x-&gt;inplace); somefunc(inplace $x);

       In  most  cases  one  likes to use the syntax "$y = f($x)", however in many case the operation f() can be
       done correctly 'in place', i.e. without making a new copy of the data for output. To make it easy to  use
       this,  we  write  f()  in such a way that it operates in-place, and use "inplace" to hint that a new copy
       should be disabled. This also makes for clear syntax.

       Obviously this will not work for all functions, and if in doubt see the function's documentation. However
       one can assume this is true for all elemental functions (i.e. those which just operate array  element  by
       array element like "log10").

        pdl&gt; $x = xvals zeroes 10;
        pdl&gt; log10(inplace $x)
        pdl&gt; p $x
        [-inf 0    0.30103 0.47712125 0.60205999    0.69897 0.77815125 0.84509804 0.90308999 0.95424251]

   <b>is_inplace</b>
       Sets  whether  an  ndarray  will operate "in-place" for the next operation if a (Boolean) value is given.
       Returns the old value.

         $out = ($in-&gt;is_inplace) ? $in : zeroes($in);
         $in-&gt;<a href="../man0/set_inplace.0.html">set_inplace</a>(0)

       Provides access to the "inplace" hint flag, within the perl milieu.  That way functions you write can  be
       inplace aware... If given an argument the inplace flag will be set or unset depending on the value at the
       same time. Can be used for shortcut tests that delete the inplace flag while testing:

         $out = ($in-&gt;<a href="../man0/is_inplace.0.html">is_inplace</a>(0)) ? $in : zeroes($in); # test &amp; unset!

   <b>set_inplace</b>
       Set the in-place flag on an ndarray

         $out = ($in-&gt;is_inplace) ? $in : zeroes($in);
         $in-&gt;<a href="../man0/set_inplace.0.html">set_inplace</a>(0);

       Provides access to the "inplace" hint flag, within the perl milieu.  Useful mainly for turning it OFF, as
       "inplace" turns it ON more conveniently.

   <b>new_or_inplace</b>
           $w = new_or_inplace(shift());
           $w = new_or_inplace(shift(),$preferred_type);

       Return  back  either  the argument pdl or a copy of it depending on whether it be flagged in-place or no.
       Handy for building inplace-aware functions.

       If you specify a preferred type (must be one of the usual PDL type strings, a list ref containing several
       of them, or a comma-separated string containing several of them), then the copy is coerced into the first
       preferred type listed if it is not already one of the preferred types.

       Note that if the inplace flag is set, no coercion happens even if you specify a preferred type.

   <b>new_from_specification</b>
       Internal method: create ndarray by specification

       This is the argument processing method called by "zeroes"  and  some  other  functions  which  constructs
       ndarrays from argument lists of the form:

        [type], $nx, $ny, $nz,...

       For  $nx,  $ny,  etc.  0  and  1D  ndarrays  are  allowed.  Giving those has the same effect as if saying
       "$arg-&gt;list", e.g.

          1, pdl(5,2), 4

       is equivalent to

          1, 5, 2, 4

       Note, however, that in all functions using "new_from_specification" calling "func $ndarray" will probably
       not do what you want. So to play safe use (e.g. with zeroes)

         $pdl = zeroes $dimpdl-&gt;list;

       Calling

         $pdl = zeroes $dimpdl;

       will rather be equivalent to

         $pdl = zeroes $dimpdl-&gt;dims;

       However,

         $pdl = zeroes ushort, $dimpdl;

       will again do what you intended since it is interpreted as if you had said

         $pdl = zeroes ushort, $dimpdl-&gt;list;

       This is unfortunate and confusing but no good solution  seems  obvious  that  would  not  break  existing
       scripts.

   <b>isnull</b>
       Test whether an ndarray is null

        croak("Input ndarray mustn't be null!")
            if $input_ndarray-&gt;isnull;

       This  function  returns  1  if the ndarray is null, zero if it is not. The purpose of null ndarrays is to
       "tell" any PDL::PP methods to allocate new memory for an output  ndarray,  but  only  when  that  PDL::PP
       method is called in full-arg form. Of course, there's no reason you couldn't commandeer the special value
       for  your  own  purposes,  for  which  this  test function would prove most helpful.  But in general, you
       shouldn't need to test for an ndarray's nullness.

       See "Null PDLs" for more information.

   <b>isempty</b>
       Test whether an ndarray is empty

        print "The ndarray has zero dimension\n" if $pdl-&gt;isempty;

       This function returns 1 if the ndarray has zero elements. This is useful in  particular  when  using  the
       indexing  function which. In the case of no match to a specified criterion, the returned ndarray has zero
       dimension.

        pdl&gt; $w=<a href="../man10/sequence.10.html">sequence</a>(10)
        pdl&gt; $i=which($w &lt; -1)
        pdl&gt; print "I found no matches!\n" if ($i-&gt;isempty);
        I found no matches!

       Note that having zero elements is rather different from the concept of being  a  null  ndarray,  see  the
       PDL::FAQ and PDL::Indexing manpages for discussions of this.

   <b>zeroes</b>
       construct  a  zero  filled ndarray from dimension list or template ndarray.  If called with no arguments,
       returns a zero-dimension ndarray (a scalar).

       Various forms of usage,

       (i) by specification or (ii) by template ndarray:

        # usage type (i):
        $w = zeroes([type], $nx, $ny, $nz,...);
        $w = PDL-&gt;zeroes([type], $nx, $ny, $nz,...);
        $w = $pdl-&gt;zeroes([type], $nx, $ny, $nz,...); # all info about $pdl ignored
        # usage type (ii):
        $w = zeroes $y;
        $w = $y-&gt;zeroes
        zeroes inplace $w;     # Equivalent to   $w .= 0;
        $w-&gt;inplace-&gt;zeroes;   #  ""

        pdl&gt; $z = zeroes 4,3
        pdl&gt; p $z
        [
         [0 0 0 0]
         [0 0 0 0]
         [0 0 0 0]
        ]
        pdl&gt; $z = zeroes ushort, 3,2 # Create ushort array
        [ushort() etc. with no arg returns a PDL::Types token]

       See also "new_from_specification" for details on using ndarrays in the dimensions list.

   <b>zeros</b>
       construct a zero filled ndarray (see zeroes for usage)

   <b>ones</b>
       construct a one filled ndarray.  If called  with  no  arguments,  returns  a  zero-dimension  ndarray  (a
       scalar).

        $w = ones([type], $nx, $ny, $nz,...);
        etc. (see 'zeroes')

        see zeroes() and add one

       See also "new_from_specification" for details on using ndarrays in the dimensions list.

   <b>nan</b>
       construct  a  "NaN"  filled  ndarray.   If  called with no arguments, returns a zero-dimension ndarray (a
       scalar).

        $w = nan([type], $nx, $ny, $nz,...);
        etc. (see 'zeroes')

        see zeroes() and add NaN

       See also "new_from_specification" for details on using ndarrays in the dimensions list.

   <b>inf</b>
       construct an "Inf" filled ndarray.  If called with no arguments,  returns  a  zero-dimension  ndarray  (a
       scalar).

        $w = inf([type], $nx, $ny, $nz,...);
        etc. (see 'zeroes')

        see zeroes() and add Inf

       See also "new_from_specification" for details on using ndarrays in the dimensions list.

   <b>i</b>
       construct  an  ndarray  filled  with a native complex value equal to the imaginary number "i", the square
       root of -1.  If called with no arguments, returns a zero-dimension ndarray (a scalar).

        $w = i([type], $nx, $ny, $nz,...);
        etc. (see 'zeroes')

        see zeroes() and add "i"

       See also "new_from_specification" for details on using ndarrays in the dimensions list.

   <b>reshape</b>
       Change the shape (i.e. dimensions) of an ndarray, preserving contents.

        $x-&gt;reshape(NEWDIMS); reshape($x, NEWDIMS);

       The data elements are preserved, obviously they will wrap differently and get truncated if the new  array
       is shorter.  If the new array is longer it will be zero-padded.

       ***Potential incompatibility with earlier versions of PDL**** If the list of "NEWDIMS" is empty "reshape"
       will just drop all dimensions of size 1 (preserving the number of elements):

         $w = sequence(3,4,5);
         $y = $w(1,3);
         $y-&gt;reshape();
         print $y-&gt;info;
        PDL: Double D [5]

       Dimensions of size 1 will also be dropped if "reshape" is invoked with the argument -1:

         $y = $w-&gt;reshape(-1);

       As opposed to "reshape" without arguments, reshape(-1) preserves dataflow:

         $w = ones(2,1,2);
         $y = $<a href="../man0/w.0.html">w</a>(0)-&gt;reshape(-1);
         $y++;
         print $w;
        [
         [
          [2 1]
         ]
         [
          [2 1]
         ]
        ]

       Important: ndarrays are changed inplace!

       Note: If $x is connected to any other PDL (e.g. if it is a slice) then the connection is first severed.

        pdl&gt; $x = <a href="../man10/sequence.10.html">sequence</a>(10)
        pdl&gt; reshape $x,3,4; p $x
        [
         [0 1 2]
         [3 4 5]
         [6 7 8]
         [9 0 0]
        ]
        pdl&gt; reshape $x,5; p $x
        [0 1 2 3 4]

   <b>squeeze</b>
       eliminate all singleton dimensions (dims of size 1)

        $y = $w(0,0)-&gt;squeeze;

       Alias  for reshape(-1). Removes all singleton dimensions and preserves dataflow. A more concise interface
       is provided by PDL::NiceSlice via modifiers:

        use PDL::NiceSlice;
        $y = $w(0,0;-); # same as $w(0,0)-&gt;squeeze

   <b>flat</b>
       flatten an ndarray (alias for "$pdl-&gt;clump(-1)")

         $srt = $pdl-&gt;flat-&gt;qsort;

       Useful method to make a 1D ndarray from an arbitrarily sized input ndarray. Data flows back and forth  as
       usual with slicing routines.  Falls through if argument already == 1D.

   <b>convert</b>
       Generic datatype conversion function

        $y = convert($x, $newtype);
        $y = $x-&gt;convert($newtype);
        $x-&gt;inplace-&gt;convert($newtype);

       $newtype  is  a  type  number  or  PDL::Type object, for convenience they are returned by long() etc when
       called without arguments.  Can work in-place, though will "sever" if so.

        $y = convert $x, long;
        $y = $x-&gt;convert(ushort);
        $x-&gt;inplace-&gt;convert(double);

   <b>Datatype_conversions</b>
       sbyte|byte|short|ushort|long|ulong|indx|longlong|ulonglong|float|double|ldouble|cfloat|cdouble|cldouble
       (shorthands to convert datatypes)

        $y = double $x; $y = ushort [1..10];
        # all of the above listed shorthands behave similarly

       When called with an ndarray argument, they convert to the specific datatype.

       When called with a numeric, list, listref, or string argument they construct a new  ndarray.  This  is  a
       convenience to avoid having to be long-winded and say "$x = long(<a href="../man42/pdl.42.html">pdl</a>(42))"

       Thus one can say:

        $w = float(1,2,3,4);           # 1D
        $w = float q[1 2 3; 4 5 6];    # 2D
        $w = float([1,2,3],[4,5,6]);   # 2D
        $w = float([[1,2,3],[4,5,6]]); # 2D

       Note  the  last  three  give  identical  results,  and  the  last  two are exactly equivalent - a list is
       automatically converted to a list reference for syntactic convenience. i.e. you can omit the outer "[]"

       When called with no arguments, these functions return a special  type  token.   This  allows  syntactical
       sugar like:

        $x = ones byte, 1000,1000;

       This example creates a large ndarray directly as byte datatype in order to save memory.

       In  order  to  control  how  undefs  are  handled  in converting from perl lists to PDLs, one can set the
       variable $PDL::undefval; see the function <b>pdl()</b> for more details.

        pdl&gt; p $x=sqrt float [1..10]
        [1 1.41421 1.73205 2 2.23607 2.44949 2.64575 2.82843 3 3.16228]
        pdl&gt; p byte $x
        [1 1 1 2 2 2 2 2 3 3]

   <b>byte</b>
       Convert to byte datatype

   <b>short</b>
       Convert to short datatype

   <b>ushort</b>
       Convert to ushort datatype

   <b>long</b>
       Convert to long datatype

   <b>indx</b>
       Convert to indx datatype

   <b>longlong</b>
       Convert to longlong datatype

   <b>float</b>
       Convert to float datatype

   <b>double</b>
       Convert to double datatype

   <b>ldouble</b>
       Convert to long double datatype

   <b>cfloat</b>
       Convert to complex float datatype

   <b>cdouble</b>
       Convert to complex double datatype

   <b>cldouble</b>
       Convert to complex long double datatype

   <b>type</b>
       return the type of an ndarray as a blessed type object

       A convenience function for use with the ndarray constructors, e.g.

        $y = PDL-&gt;zeroes($x-&gt;type,$x-&gt;dims,3);
        die "must be float" unless $x-&gt;type == float;

       See also the discussion of the "PDL::Type" class in PDL::Types.  Note that the "PDL::Type"  objects  have
       overloaded comparison and stringify operators so that you can compare and print types:

        $x = $x-&gt;float if $x-&gt;type &lt; float;
        $t = $x-&gt;type; print "Type is $t\n";

   <b>string</b>
       Convert ndarray to string, optionally using a "sprintf" format. If such a format is provided, it is used.
       If  not,  then the formatting variables in "VARIABLES" provide a default, though heuristics are attempted
       to make a nice-looking output.

        print $x; # overloaded
        print $x-&gt;string; # explicit method call
        print $x-&gt;string("%5d"); # providing sprintf format

   <b>list</b>
       Convert ndarray to perl list

        @tmp = list $x;

       Obviously this is grossly inefficient for the large datasets PDL is designed to handle. This was provided
       as a get out while PDL matured. It should now be  mostly  superseded  by  superior  constructs,  such  as
       PP/broadcasting. However it is still occasionally useful and is provided for backwards compatibility.

        for (list $x) {
          # Do something on each value...
        }

       list converts any bad values into the string 'BAD'.

   <b>unpdl</b>
       Convert ndarray to nested Perl array references

        $arrayref = unpdl $x;

       This  function  returns  a  reference  to  a Perl list-of-lists structure equivalent to the input ndarray
       (within the limitation that while values of elements should be preserved, the detailed datatypes will not
       as perl itself basically has "number" data  rather  than  byte,  short,  int...   E.g.,  "sum($x  -  pdl(
       $x-&gt;unpdl ))" should equal 0.

       Obviously  this is grossly inefficient in memory and processing for the large datasets PDL is designed to
       handle. Sometimes,  however,  you  really  want  to  move  your  data  back  to  Perl,  and  with  proper
       dimensionality, unlike "list".

       If  you  want  to  round-trip  data  including the use of "PDL::undefval", "unpdl" does not support this.
       However, it is suggested you would generate an index-set with  "$pdl-&gt;whereND($pdl  ==  $PDL::undefval)",
       then loop over the Perl data, setting those locations to "undef".

       Another  round-trip  caveat:  a  zero-dimensional ndarray (a scalar) will be returned as a single-element
       array-ref. This is conceptually incorrect, but cannot now be changed due to backward compatibility.

        use JSON;
        my $json = encode_json unpdl $pdl;

       unpdl converts any bad values into the string 'BAD'.

   <b>listindices</b>
       Convert ndarray indices to perl list

        @tmp = listindices $x;

       @tmp now contains the values "0..nelem($x)-1".

       Obviously this is grossly inefficient for the large datasets PDL is designed to handle. This was provided
       as a get out while PDL matured. It  should now be mostly  superseded  by  superior  constructs,  such  as
       PP/broadcasting. However it is still occasionally useful and is provied for backwards compatibility.

        for $i (listindices $x) {
          # Do something on each value...
        }

   <b>set</b>
       Set a single value inside an ndarray

        set $ndarray, @position, $value

       @position  is  a  coordinate list, of size equal to the number of dimensions in the ndarray. Occasionally
       useful, mainly provided for backwards compatibility as superseded by use of slice and assignment operator
       ".=".

        pdl&gt; $x = sequence 3,4
        pdl&gt; set $x, 2,1,99
        pdl&gt; p $x
        [
         [ 0  1  2]
         [ 3  4 99]
         [ 6  7  8]
         [ 9 10 11]
        ]

   <b>at</b>
       Returns a single value inside an ndarray as perl scalar.  If  the  ndarray  is  a  native  complex  value
       (cdouble, cfloat), it will be a PDL::Complex::Overloads object.

        $z = at($ndarray, @position); $z=$ndarray-&gt;at(@position);

       @position  is  a  coordinate list, of size equal to the number of dimensions in the ndarray. Occasionally
       useful in a general context, quite useful too inside PDL internals.

        pdl&gt; $x = sequence 3,4
        pdl&gt; p $x-&gt;at(1,2)
        7

       at converts any bad values into the string 'BAD'.

   <b>sclr</b>
       return a single value from an ndarray as a scalar, ignoring whether it is bad.

         $val = $<a href="../man10/x.10.html">x</a>(10)-&gt;sclr;
         $val = sclr inner($x,$y);

       The "sclr" method is useful to turn a  single-element  ndarray  into  a  normal  Perl  scalar.  Its  main
       advantage  over  using  "at" for this purpose is the fact that you do not need to worry if the ndarray is
       0D, 1D or higher dimensional.  Using "at" you have to supply the correct number of zeroes, e.g.

         $x = <a href="../man10/sequence.10.html">sequence</a>(10);
         $y = $x-&gt;slice('4');
         print $y-&gt;sclr; # no problem
         print $y-&gt;at(); # error: needs at least one zero

       "sclr" is generally used when a Perl scalar is required instead of a one-element ndarray. As of 2.064, if
       the input is a multielement ndarray it will throw an exception.

   <b>cat</b>
       concatenate ndarrays to N+1 dimensional ndarray

       Takes a list of N ndarrays of same shape as argument, returns a single ndarray of dimension N+1.

        pdl&gt; $x = cat ones(3,3),zeroes(3,3),rvals(3,3); p $x
        [
         [
          [1 1 1]
          [1 1 1]
          [1 1 1]
         ]
         [
          [0 0 0]
          [0 0 0]
          [0 0 0]
         ]
         [
          [1 1 1]
          [1 0 1]
          [1 1 1]
         ]
        ]

       The output ndarray is set bad if any input ndarrays have their bad flag set.

       Similar functions include append, which appends only two ndarrays along their first dimension, and  glue,
       which can append more than two ndarrays along an arbitrary dimension.

       Also  consider  the  generic  constructor "pdl", which can handle ndarrays of different sizes (with zero-
       padding), and will return a ndarray of type 'double' by default, but may be considerably  faster  (up  to
       10x) than cat.

   <b>dog</b>
       Opposite of 'cat' :). Split N dim ndarray to list of N-1 dim ndarrays

       Takes  a  single N-dimensional ndarray and splits it into a list of N-1 dimensional ndarrays. The breakup
       is done along the last dimension.  Note the dataflowed connection is still preserved by default, e.g.:

        pdl&gt; $p = ones 3,3,3
        pdl&gt; ($x,$y,$c) = dog $p
        pdl&gt; $y++; p $p
        [
         [
          [1 1 1]
          [1 1 1]
          [1 1 1]
         ]
         [
          [2 2 2]
          [2 2 2]
          [2 2 2]
         ]
         [
          [1 1 1]
          [1 1 1]
          [1 1 1]
         ]
        ]

        Break =&gt; 1   Break dataflow connection (new copy)

       The output ndarrays are set bad if the original ndarray has its bad flag set.

   <b>gethdr</b>
       Retrieve header information from an ndarray

        $pdl=rfits('file.fits');
        $h=$pdl-&gt;gethdr;
        print "Number of pixels in the X-direction=$$h{NAXIS1}\n";

       The "gethdr" function retrieves whatever header information is contained within an  ndarray.  The  header
       can be set with "sethdr" and is always a hash reference or undef.

       "gethdr"  returns  undef  if the ndarray has not yet had a header defined; compare with "hdr" and "fhdr",
       which are guaranteed to return a defined value.

       Note that <b>gethdr()</b> works by <b>reference</b>: you can modify the header in-place once it has been retrieved:

         $x  = rfits($filename);
         $xh = $x-&gt;gethdr();
         $xh-&gt;{FILENAME} = $filename;

       It is also important to realise that in most cases the header is not automatically copied when  you  copy
       the ndarray.  See "hdrcpy" to enable automatic header copying.

       Here's  another example: a wrapper around rcols that allows your ndarray to remember the file it was read
       from and the columns could be easily written (here assuming that no regexp is needed, extensions are left
       as an exercise for the reader)

        sub ext_rcols {
           my ($file, @columns)=@_;
           my $header={};
           $$header{File}=$file;
           $$header{Columns}=\@columns;

           @ndarrays=rcols $file, @columns;
           foreach (@ndarrays) { $_-&gt;sethdr($header); }
           return @ndarrays;
        }

   <b>hdr</b>
       Retrieve or set header information from an ndarray

        $pdl-&gt;hdr-&gt;{CDELT1} = 1;

       The "hdr" function allows convenient access to the header of a ndarray.  Unlike "gethdr" it is guaranteed
       to return a defined value, so you can use it in a hash dereference as in the example.  If the header does
       not yet exist, it gets autogenerated as an empty hash.

       Note that this  is  usually  --  but  not  always  --  What  You  Want.   If  you  want  to  use  a  tied
       Astro::FITS::Header hash, for example, you should either construct it yourself and use "sethdr" to put it
       into  the  ndarray,  or  use  "fhdr"  instead.   (Note that you should be able to write out the FITS file
       successfully regardless of whether your PDL has a tied FITS header object or a vanilla hash).

   <b>fhdr</b>
       Retrieve or set FITS header information from an ndarray

        $pdl-&gt;fhdr-&gt;{CDELT1} = 1;

       The "fhdr" function allows convenient access  to  the  header  of  a  ndarray.   Unlike  "gethdr"  it  is
       guaranteed  to return a defined value, so you can use it in a hash dereference as in the example.  If the
       header does not yet exist, it gets autogenerated as a tied Astro::FITS::Header hash.

       Astro::FITS::Header tied hashes are better at matching the behavior of  FITS  headers  than  are  regular
       hashes.    In   particular,   the  hash  keys  are  CAsE  INsEnSItiVE,  unlike  normal  hash  keys.   See
       Astro::FITS::Header for details.

       If you do not have Astro::FITS::Header installed, you get back a normal hash instead of a tied object.

   <b>sethdr</b>
       Set header information of an ndarray

        $pdl = zeroes(100,100);
        $h = {NAXIS=&gt;2, NAXIS1=&gt;100, NAXIS=&gt;100, COMMENT=&gt;"Sample FITS-style header"};
        # add a FILENAME field to the header
        $$h{FILENAME} = 'file.fits';
        $pdl-&gt;sethdr( $h );

       The "sethdr" function sets the header information for an ndarray.  You must feed in a hash ref or  undef,
       and the header field of the PDL is set to be a new ref to the same hash (or undefined).

       The  hash  ref  requirement is a speed bump put in place since the normal use of headers is to store fits
       header information and the like.  Of course, if you want you can hang whatever ugly  old  data  structure
       you want off of the header, but that makes life more complex.

       Remember  that the hash is not copied -- the header is made into a ref that points to the same underlying
       data.  To get a real copy without making any assumptions about the underlying data structure, you can use
       one of the following:

         use PDL::IO::Dumper;
         $pdl-&gt;sethdr( deep_copy($h) );

       (which is slow but general), or

         $pdl-&gt;sethdr( PDL::_hdr_copy($h) )

       (which uses the built-in sleazy deep copier), or (if  you  know  that  all  the  elements  happen  to  be
       scalars):

         { my %a = %$h;
           $pdl-&gt;sethdr(\%a);
         }

       which is considerably faster but just copies the top level.

       The  "sethdr"  function  must be given a hash reference or undef.  For further information on the header,
       see "gethdr", "hdr", "fhdr" and "hdrcpy".

   <b>hdrcpy</b>
       switch on/off/examine automatic header copying

        print "hdrs will be copied" if $x-&gt;hdrcpy;
        $x-&gt;<a href="../man1/hdrcpy.1.html">hdrcpy</a>(1);       # switch on automatic header copying
        $y = $x-&gt;sumover;    # and $y will inherit $x's hdr
        $x-&gt;<a href="../man0/hdrcpy.0.html">hdrcpy</a>(0);       # and now make $x non-infectious again

       "hdrcpy" without an argument just returns the current setting of the flag.  See also "hcpy" which returns
       its PDL argument (and so is useful in method-call pipelines).

       Normally, the optional header of an ndarray is not copied automatically in pdl operations.  Switching  on
       the  hdrcpy  flag  using  the "hdrcpy" method will enable automatic hdr copying. Note that an actual deep
       copy gets made, which is rather processor-inefficient -- so avoid using header copying in tight loops!

       Most PDLs have the "hdrcpy" flag cleared by default; however, some routines (notably  rfits)  set  it  by
       default where that makes more sense.

       The  "hdrcpy" flag is viral: if you set it for a PDL, then derived PDLs will get copies of the header and
       will also have their "hdrcpy" flags set.  For example:

         $x = xvals(50,50);
         $x-&gt;<a href="../man1/hdrcpy.1.html">hdrcpy</a>(1);
         $x-&gt;hdr-&gt;{FOO} = "bar";
         $y = $x++;
         $c = $y++;
         print $y-&gt;hdr-&gt;{FOO}, " - ", $c-&gt;hdr-&gt;{FOO}, "\n";
         $y-&gt;hdr-&gt;{FOO} = "baz";
         print $x-&gt;hdr-&gt;{FOO}, " - ", $y-&gt;hdr-&gt;{FOO}, " - ", $c-&gt;hdr-&gt;{FOO}, "\n";

       will print:

         bar - bar
         bar - baz - bar

       Performing an operation in which more than one PDL has its hdrcpy flag causes the resulting PDL  to  take
       the header of the first PDL:

         ($x,$y) = sequence(5,2)-&gt;dog;
         $x-&gt;<a href="../man1/hdrcpy.1.html">hdrcpy</a>(1); $y-&gt;<a href="../man1/hdrcpy.1.html">hdrcpy</a>(1);
         $x-&gt;hdr-&gt;{foo} = 'a';
         $y-&gt;hdr-&gt;{foo} = 'b';
         print (($x+$y)-&gt;hdr-&gt;{foo} , ($y+$x)-&gt;hdr-&gt;{foo});

       will print:

         a b

   <b>hcpy</b>
       Switch on/off automatic header copying, with PDL pass-through

         $x = rfits('foo.fits')-&gt;<a href="../man0/hcpy.0.html">hcpy</a>(0);
         $x = rfits('foo.fits')-&gt;<a href="../man1/hcpy.1.html">hcpy</a>(1);

       "hcpy" sets or clears the hdrcpy flag of a PDL, and returns the PDL itself.  That makes it convenient for
       inline use in expressions.

   <b>online_cpus</b>
       Returns   the   number   of  available  processors  cores.  Used  to  set  the  number  of  threads  with
       "set_autopthread_targ" if $ENV{PDL_AUTOPTHREAD_TARG} is not set.

   <b>set_autopthread_targ</b>
       Set the target number of processor threads (pthreads) for multi-threaded processing.

        set_autopthread_targ($num_pthreads);

       $num_pthreads is the target number of pthreads the auto-pthread process will try to achieve.

       See PDL::ParallelCPU for an overview of the auto-pthread process.

         # Example turning on auto-pthreading for a target of 2 pthreads and for functions involving
         #   PDLs with greater than 1M elements
         <a href="../man2/set_autopthread_targ.2.html">set_autopthread_targ</a>(2);
         <a href="../man1/set_autopthread_size.1.html">set_autopthread_size</a>(1);

         # Execute a pdl function, processing will split into two pthreads
         $x = minimum($y);

         # Get the actual number of pthreads that were run.
         $actual_pthread = get_autopthread_actual();

   <b>get_autopthread_targ</b>
       Get the current target number of processor threads (pthreads) for multi-threaded processing.

        $num_pthreads = get_autopthread_targ();

       $num_pthreads is the target number of pthreads the auto-pthread process will try to achieve.

       See PDL::ParallelCPU for an overview of the auto-pthread process.

   <b>get_autopthread_actual</b>
       Get the actual number of pthreads executed for the last pdl processing function.

        $autopthread_actual = get_autopthread_actual();

       $autopthread_actual is the actual number of pthreads executed for the last pdl processing function.

       See PDL::ParallelCPU for an overview of the auto-pthread process.

   <b>get_autopthread_dim</b>
       Get the actual dimension on which pthreads were used for the last pdl processing function.

        $autopthread_dim = get_autopthread_dim();

       $autopthread_dim is the actual dimension on  which  pthreads  were  used  for  the  last  pdl  processing
       function.

       See PDL::ParallelCPU for an overview of the auto-pthread process.

   <b>set_autopthread_size</b>
       Set  the  minimum  size  (in M-elements or 2^20 elements) of the largest PDL involved in a function where
       auto-pthreading will be performed. For small PDLs, it probably isn't worth starting multiple pthreads, so
       this function is used to define a minimum threshold where auto-pthreading won't be attempted.

        set_autopthread_size($size);

       $size is the mimumum size, in M-elements or 2^20 elements (approx  1e6  elements)  for  the  largest  PDL
       involved in a function.

       See PDL::ParallelCPU for an overview of the auto-pthread process.

         # Example turning on auto-pthreading for a target of 2 pthreads and for functions involving
         #   PDLs with greater than 1M elements
         <a href="../man2/set_autopthread_targ.2.html">set_autopthread_targ</a>(2);
         <a href="../man1/set_autopthread_size.1.html">set_autopthread_size</a>(1);

         # Execute a pdl function, processing will split into two pthreads as long as
         #  one of the pdl-threaded dimensions is at least 2.
         $x = minimum($y);

         # Get the actual number of pthreads that were run.
         $actual_pthread = get_autopthread_actual();

   <b>get_autopthread_size</b>
       Get the current autopthread_size setting.

        $autopthread_size = get_autopthread_size();

       $autopthread_size  is the mimumum size limit for auto_pthreading to occur, in M-elements or 2^20 elements
       (approx 1e6 elements) for the largest PDL involved in a function

       See PDL::ParallelCPU for an overview of the auto-pthread process.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) Karl Glazebrook (<a href="mailto:kgb@aaoepp.aao.gov.au">kgb@aaoepp.aao.gov.au</a>),  Tuomas  J.  Lukka,  (<a href="mailto:lukka@husc.harvard.edu">lukka@husc.harvard.edu</a>)  and
       Christian  Soeller (<a href="mailto:c.soeller@auckland.ac.nz">c.soeller@auckland.ac.nz</a>) 1997.  Modified, Craig DeForest (<a href="mailto:deforest@boulder.swri.edu">deforest@boulder.swri.edu</a>)
       2002.  All rights reserved. There is no warranty.  You  are  allowed  to  redistribute  this  software  /
       documentation  under  certain  conditions.  For details, see the file COPYING in the PDL distribution. If
       this file is separated from the PDL distribution, the copyright notice should be included in the file.

perl v5.40.1                                       2025-03-27                                     <u>PDL::<a href="../man3pm/Core.3pm.html">Core</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>