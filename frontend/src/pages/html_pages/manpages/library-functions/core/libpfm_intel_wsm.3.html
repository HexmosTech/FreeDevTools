<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libpfm_intel_wsm - support for Intel Westmere core PMU</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpfm4-dev">libpfm4-dev_4.13.0+git99-gc5587f9-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libpfm_intel_wsm - support for Intel Westmere core PMU

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;perfmon/pfmlib.h&gt;</b>

       <b>PMU</b> <b>name:</b> <b>wsm</b>
       <b>PMU</b> <b>desc:</b> <b>Intel</b> <b>Westmere</b>
       <b>PMU</b> <b>name:</b> <b>wsm_dp</b>
       <b>PMU</b> <b>desc:</b> <b>Intel</b> <b>Westmere</b> <b>DP</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  library supports the Intel Westmere core PMU. It should be noted that this PMU model only covers the
       each core's PMU and not the socket level PMU. It is provided separately.  Support  is  provided  for  the
       Intel Core i7 and Core i5 processors (models 37, 44).

</pre><h4><b>MODIFIERS</b></h4><pre>
       The following modifiers are supported on Intel Westmere processors:

       <b>u</b>      Measure at user level which includes privilege levels 1, 2, 3. This corresponds to <b>PFM_PLM3</b>.  This
              is a boolean modifier.

       <b>k</b>      Measure at kernel level which includes privilege level 0. This corresponds to <b>PFM_PLM0</b>.  This is a
              boolean modifier.

       <b>i</b>      Invert  the  meaning  of  the  event.  The counter will now count cycles in which the event is <b>not</b>
              occurring. This is a boolean modifier

       <b>e</b>      Enable edge detection, i.e., count only when there is a state transition from no occurrence of the
              event to at least one occurrence. This modifier must be combined with a counter mask modifier  (m)
              with a value greater or equal to one.  This is a boolean modifier.

       <b>c</b>      Set  the  counter  mask  value. The mask acts as a threshold. The counter will count the number of
              cycles in which the number of occurrences of the event is greater or equal to the threshold.  This
              is an integer modifier with values in the range [0:255].

       <b>t</b>      Measure  on  both  threads at the same time assuming hyper-threading is enabled. This is a boolean
              modifier.

       <b>ldlat</b>  Pass a latency threshold  to  the  MEM_INST_RETIRED:LATENCY_ABOVE_THRESHOLD  event.   This  is  an
              integer  attribute  that must be in the range [1:65535]. It is required for this event.  Note that
              the event must be used with precise sampling (PEBS).

</pre><h4><b>OFFCORE_RESPONSE</b> <b>events</b></h4><pre>
       The library is able to encode the OFFCORE_RESPONSE_0 and OFFCORE_RESPONSE_1 events.   Those  are  special
       events  because  they,  each,  need  a second MSR (0x1a6 and 0x1a7 respectively) to be programmed for the
       event to count properly. Thus two values are necessary for each event.  The first value can be programmed
       on any of the generic counters. The second value goes into the dedicated MSR (0x1a6 or 0x1a7).

       The OFFCORE_RESPONSE events are exposed as normal events with several umasks which  are  divided  in  two
       groups:  request  and  response. The user must provide <b>at</b> <b>least</b> one umask from each group.  For instance,
       OFFCORE_RESPONSE_0:ANY_DATA:LOCAL_DRAM.

       When using <b>pfm_get_event_encoding()</b>, two 64-bit values are returned. The first value corresponds to  what
       needs  to  be  programmed  into any of the generic counters. The second value must be programmed into the
       corresponding dedicated MSR (0x1a6 or 0x1a7).

       When using an OS-specific encoding routine, the way the event is encoded is OS  specific.  Refer  to  the
       corresponding man page for more information.

</pre><h4><b>AUTHORS</b></h4><pre>
       Stephane Eranian &lt;<a href="mailto:eranian@gmail.com">eranian@gmail.com</a>&gt;

                                                 September, 2009                                       <u><a href="../man3/LIBPFM.3.html">LIBPFM</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>