<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_timer.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_timer.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;rte_common.h&gt;
       #include &lt;rte_spinlock.h&gt;

   <b>Data</b> <b>Structures</b>
       union <b>rte_timer_status</b>
       struct <b>rte_timer</b>

   <b>Macros</b>
       #define <b>RTE_TIMER_STOP</b>   0
       #define <b>RTE_TIMER_PENDING</b>   1
       #define <b>RTE_TIMER_RUNNING</b>   2
       #define <b>RTE_TIMER_CONFIG</b>   3
       #define <b>RTE_TIMER_NO_OWNER</b>   -2
       #define <b>RTE_TIMER_INITIALIZER</b>

   <b>Typedefs</b>
       <b>typedef</b> void(* <b>rte_timer_cb_t</b>) (struct <b>rte_timer</b> *, void *)
       <b>typedef</b> void(* <b>rte_timer_alt_manage_cb_t</b>) (struct <b>rte_timer</b> *tim)
       <b>typedef</b> void(* <b>rte_timer_stop_all_cb_t</b>) (struct <b>rte_timer</b> *tim, void *arg)

   <b>Enumerations</b>
       enum <b>rte_timer_type</b>

   <b>Functions</b>
       int <b>rte_timer_data_alloc</b> (uint32_t *id_ptr)
       int <b>rte_timer_data_dealloc</b> (uint32_t id)
       int <b>rte_timer_subsystem_init</b> (void)
       void <b>rte_timer_subsystem_finalize</b> (void)
       void <b>rte_timer_init</b> (struct <b>rte_timer</b> *tim)
       int <b>rte_timer_reset</b> (struct <b>rte_timer</b> *tim, uint64_t ticks, enum <b>rte_timer_type</b> type, unsigned tim_lcore,
           <b>rte_timer_cb_t</b> fct, void *arg)
       void <b>rte_timer_reset_sync</b> (struct <b>rte_timer</b> *tim, uint64_t ticks, enum <b>rte_timer_type</b> type, unsigned
           tim_lcore, <b>rte_timer_cb_t</b> fct, void *arg)
       int <b>rte_timer_stop</b> (struct <b>rte_timer</b> *tim)
       void <b>rte_timer_stop_sync</b> (struct <b>rte_timer</b> *tim)
       int <b>rte_timer_pending</b> (struct <b>rte_timer</b> *tim)
       int64_t <b>rte_timer_next_ticks</b> (void)
       int <b>rte_timer_manage</b> (void)
       int <b>rte_timer_dump_stats</b> (FILE *f)
       int <b>rte_timer_alt_reset</b> (uint32_t timer_data_id, struct <b>rte_timer</b> *tim, uint64_t ticks, enum
           <b>rte_timer_type</b> type, unsigned int tim_lcore, <b>rte_timer_cb_t</b> fct, void *arg)
       int <b>rte_timer_alt_stop</b> (uint32_t timer_data_id, struct <b>rte_timer</b> *tim)
       int <b>rte_timer_alt_manage</b> (uint32_t timer_data_id, unsigned int *poll_lcores, int n_poll_lcores,
           <b>rte_timer_alt_manage_cb_t</b> f)
       int <b>rte_timer_stop_all</b> (uint32_t timer_data_id, unsigned int *walk_lcores, int nb_walk_lcores,
           <b>rte_timer_stop_all_cb_t</b> f, void *f_arg)
       int <b>rte_timer_alt_dump_stats</b> (uint32_t timer_data_id, FILE *f)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       RTE Timer

       This library provides a timer service to RTE Data Plane execution units that allows the execution of
       callback functions asynchronously.

       • Timers can be periodic or single (one-shot).

       • The timers can be loaded from one core and executed on another. This has to be specified in the call to
         <b>rte_timer_reset()</b>.

       • High  precision  is possible. NOTE: this depends on the call frequency to <b>rte_timer_manage()</b> that check
         the timer expiration for the local core.

       • If not used in an application, for improved performance, it can be disabled at compilation time by  not
         calling the <b>rte_timer_manage()</b> to improve performance.

       The  timer library uses the rte_get_hpet_cycles() function that uses the HPET, when available, to provide
       a reliable time reference. [HPET routines are provided by EAL, which falls back to  using  the  chip  TSC
       (time- stamp counter) as fallback when HPET is not available]

       This  library  provides  an  interface  to  add,  delete and restart a timer. The API is based on the BSD
       <a href="../man9/callout.9.html">callout</a>(9) API with a few differences.

       See the RTE architecture documentation for more information about the design of this library.

       Definition in file <b>rte_timer.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_TIMER_STOP</b>   <b>0</b>
       State: timer is stopped.

       Definition at line <b>47</b> of file <b>rte_timer.h</b>.

   <b>#define</b> <b>RTE_TIMER_PENDING</b>   <b>1</b>
       State: timer is scheduled.

       Definition at line <b>48</b> of file <b>rte_timer.h</b>.

   <b>#define</b> <b>RTE_TIMER_RUNNING</b>   <b>2</b>
       State: timer function is running.

       Definition at line <b>49</b> of file <b>rte_timer.h</b>.

   <b>#define</b> <b>RTE_TIMER_CONFIG</b>   <b>3</b>
       State: timer is being configured.

       Definition at line <b>50</b> of file <b>rte_timer.h</b>.

   <b>#define</b> <b>RTE_TIMER_NO_OWNER</b>   <b>-2</b>
       Timer has no owner.

       Definition at line <b>52</b> of file <b>rte_timer.h</b>.

   <b>#define</b> <b>RTE_TIMER_INITIALIZER</b>
       <b>Value:</b>.PP
               {                      \
               .status = {{                         \
                   .state = RTE_TIMER_STOP,     \
                   .owner = RTE_TIMER_NO_OWNER, \
               }},                                  \
           }
       A static initializer for a timer structure.

       Definition at line <b>125</b> of file <b>rte_timer.h</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>void(*</b> <b>rte_timer_cb_t)</b> <b>(struct</b> <b>rte_timer</b> <b>*,</b> <b>void</b> <b>*)</b>
       Callback function type for timer expiry.

       Definition at line <b>91</b> of file <b>rte_timer.h</b>.

   <b>typedef</b> <b>void(*</b> <b>rte_timer_alt_manage_cb_t)</b> <b>(struct</b> <b>rte_timer</b> <b>*tim)</b>
       Callback function type for <b>rte_timer_alt_manage()</b>.

       Definition at line <b>436</b> of file <b>rte_timer.h</b>.

   <b>typedef</b> <b>void(*</b> <b>rte_timer_stop_all_cb_t)</b> <b>(struct</b> <b>rte_timer</b> <b>*tim,</b> <b>void</b> <b>*arg)</b>
       Callback function type for <b>rte_timer_stop_all()</b>.

       Definition at line <b>470</b> of file <b>rte_timer.h</b>.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>rte_timer_type</b>
       Timer type: Periodic or single (one-shot).

       Definition at line <b>57</b> of file <b>rte_timer.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>int</b> <b>rte_timer_data_alloc</b> <b>(uint32_t</b> <b>*</b> <b>id_ptr)</b>
       Allocate a timer data instance in shared memory to track a set of pending timer lists.

       <b>Parameters</b>
           <u>id_ptr</u> Pointer to variable into which to write the identifier of the allocated timer data instance.

       <b>Returns</b>

           • 0: Success

           • -ENOSPC: maximum number of timer data instances already allocated

   <b>int</b> <b>rte_timer_data_dealloc</b> <b>(uint32_t</b> <b>id)</b>
       Deallocate a timer data instance.

       <b>Parameters</b>
           <u>id</u> Identifier of the timer data instance to deallocate.

       <b>Returns</b>

           • 0: Success

           • -EINVAL: invalid timer data instance identifier

   <b>int</b> <b>rte_timer_subsystem_init</b> <b>(void)</b>
       Initialize the timer library.

       Initializes internal variables (list, locks and so on) for the RTE timer library.

       <b>Note</b>
           This function must be called in every process before using the library.

       <b>Returns</b>

           • 0: Success

           • -ENOMEM: Unable to allocate memory needed to initialize timer subsystem

           • -EALREADY: timer subsystem was already initialized. Not an error.

   <b>void</b> <b>rte_timer_subsystem_finalize</b> <b>(void)</b>
       Free timer subsystem resources.

   <b>void</b> <b>rte_timer_init</b> <b>(struct</b> <b>rte_timer</b> <b>*</b> <b>tim)</b>
       Initialize a timer handle.

       The <b>rte_timer_init()</b> function initializes the timer handle <u>tim</u> for use. No operations can be performed on
       a timer before it is initialized.

       <b>Parameters</b>
           <u>tim</u> The timer to initialize.

   <b>int</b> <b>rte_timer_reset</b> <b>(struct</b> <b>rte_timer</b> <b>*</b> <b>tim,</b> <b>uint64_t</b> <b>ticks,</b> <b>enum</b> <b>rte_timer_type</b>  <b>type,</b>  <b>unsigned</b>  <b>tim_lcore,</b>
       <b>rte_timer_cb_t</b> <b>fct,</b> <b>void</b> <b>*</b> <b>arg)</b>
       Reset and start the timer associated with the timer handle.

       The <b>rte_timer_reset()</b> function resets and starts the timer associated with the timer handle <u>tim</u>. When the
       timer expires after <u>ticks</u> HPET cycles, the function specified by <u>fct</u> will be called with the argument <u>arg</u>
       on core <u>tim_lcore</u>.

       If  the  timer  associated  with the timer handle is already running (in the RUNNING state), the function
       will fail. The user has to check the return value of the function to see if there is a  chance  that  the
       timer is in the RUNNING state.

       If the timer is being configured on another core (the CONFIG state), it will also fail.

       If the timer is pending or stopped, it will be rescheduled with the new parameters.

       <b>Parameters</b>
           <u>tim</u> The timer handle.
           <u>ticks</u> The number of cycles (see rte_get_hpet_hz()) before the callback function is called.
           <u>type</u> The type can be either:

           • PERIODICAL: The timer is automatically reloaded after execution (returns to the PENDING state)

           • SINGLE: The timer is one-shot, that is, the timer goes to a STOPPED state after execution.

           <u>tim_lcore</u>  The  ID of the lcore where the timer callback function has to be executed. If tim_lcore is
           LCORE_ID_ANY, the timer library will launch it on a different core for each call (round-robin).
           <u>fct</u> The callback function of the timer.
           <u>arg</u> The user argument of the callback function.

       <b>Returns</b>

           • 0: Success; the timer is scheduled.

           • (-1): Timer is in the RUNNING or CONFIG state.

   <b>void</b> <b>rte_timer_reset_sync</b> <b>(struct</b> <b>rte_timer</b>  <b>*</b>  <b>tim,</b>  <b>uint64_t</b>  <b>ticks,</b>  <b>enum</b>  <b>rte_timer_type</b>  <b>type,</b>  <b>unsigned</b>
       <b>tim_lcore,</b> <b>rte_timer_cb_t</b> <b>fct,</b> <b>void</b> <b>*</b> <b>arg)</b>
       Loop until <b>rte_timer_reset()</b> succeeds.

       Reset  and  start  the  timer associated with the timer handle. Always succeed. See <b>rte_timer_reset()</b> for
       details.

       <b>Parameters</b>
           <u>tim</u> The timer handle.
           <u>ticks</u> The number of cycles (see rte_get_hpet_hz()) before the callback function is called.
           <u>type</u> The type can be either:

           • PERIODICAL: The timer is automatically reloaded after execution (returns to the PENDING state)

           • SINGLE: The timer is one-shot, that is, the timer goes to a STOPPED state after execution.

           <u>tim_lcore</u> The ID of the lcore where the timer callback function has to be executed. If  tim_lcore  is
           LCORE_ID_ANY, the timer library will launch it on a different core for each call (round-robin).
           <u>fct</u> The callback function of the timer.
           <u>arg</u> The user argument of the callback function.

       <b>Note</b>
           This  API  should  not  be called inside a timer's callback function to reset another timer; doing so
           could hang in certain scenarios. Instead, the <b>rte_timer_reset()</b> API can be called  directly  and  its
           return code can be checked for success or failure.

   <b>int</b> <b>rte_timer_stop</b> <b>(struct</b> <b>rte_timer</b> <b>*</b> <b>tim)</b>
       Stop a timer.

       The  <b>rte_timer_stop()</b>  function  stops the timer associated with the timer handle <u>tim</u>. It may fail if the
       timer is currently running or being configured.

       If the timer is pending or stopped (for instance, already expired), the function will succeed. The  timer
       handle tim must have been initialized using <b>rte_timer_init()</b>, otherwise, undefined behavior will occur.

       This  function  can  be  called safely from a timer callback. If it succeeds, the timer is not referenced
       anymore by the timer library and the timer structure can be freed (even in the callback function).

       <b>Parameters</b>
           <u>tim</u> The timer handle.

       <b>Returns</b>

           • 0: Success; the timer is stopped.

           • (-1): The timer is in the RUNNING or CONFIG state.

   <b>void</b> <b>rte_timer_stop_sync</b> <b>(struct</b> <b>rte_timer</b> <b>*</b> <b>tim)</b>
       Loop until <b>rte_timer_stop()</b> succeeds.

       After a call to this function, the timer identified by <u>tim</u> is stopped. See <b>rte_timer_stop()</b> for details.

       <b>Parameters</b>
           <u>tim</u> The timer handle.

       <b>Note</b>
           This API should not be called inside a timer's callback function to  stop  another  timer;  doing  so
           could  hang  in  certain  scenarios. Instead, the <b>rte_timer_stop()</b> API can be called directly and its
           return code can be checked for success or failure.

   <b>int</b> <b>rte_timer_pending</b> <b>(struct</b> <b>rte_timer</b> <b>*</b> <b>tim)</b>
       Test if a timer is pending.

       The <b>rte_timer_pending()</b> function tests the PENDING status of the timer handle <u>tim</u>. A PENDING timer is one
       that has been scheduled and whose function has not yet been called.

       <b>Parameters</b>
           <u>tim</u> The timer handle.

       <b>Returns</b>

           • 0: The timer is not pending.

           • 1: The timer is pending.

   <b>int64_t</b> <b>rte_timer_next_ticks</b> <b>(void)</b>
       Time until the next timer on the current lcore This function gives the ticks until the next timer will be
       active.

       <b>Returns</b>

           • -EINVAL: invalid timer data instance identifier

           • -ENOENT: no timer pending

           • 0: a timer is pending and will run at next <b>rte_timer_manage()</b>

           • &gt;0: ticks until the next timer is ready

   <b>int</b> <b>rte_timer_manage</b> <b>(void)</b>
       Manage the timer list and execute callback functions.

       This function must be called periodically from EAL lcores main_loop(). It browses  the  list  of  pending
       timers and runs all timers that are expired.

       The  precision  of  the timer depends on the call frequency of this function. However, the more often the
       function is called, the more CPU resources it will use.

       <b>Returns</b>

           • 0: Success

           • -EINVAL: timer subsystem not yet initialized

   <b>int</b> <b>rte_timer_dump_stats</b> <b>(FILE</b> <b>*</b> <b>f)</b>
       Dump statistics about timers.

       <b>Parameters</b>
           <u>f</u> A pointer to a file for output

       <b>Returns</b>

           • 0: Success

           • -EINVAL: timer subsystem not yet initialized

   <b>int</b> <b>rte_timer_alt_reset</b> <b>(uint32_t</b> <b>timer_data_id,</b> <b>struct</b> <b>rte_timer</b> <b>*</b> <b>tim,</b> <b>uint64_t</b> <b>ticks,</b> <b>enum</b>  <b>rte_timer_type</b>
       <b>type,</b> <b>unsigned</b> <b>int</b> <b>tim_lcore,</b> <b>rte_timer_cb_t</b> <b>fct,</b> <b>void</b> <b>*</b> <b>arg)</b>
       This  function  is  the  same  as  <b>rte_timer_reset()</b>,  except  that  it  allows  a  caller to specify the
       rte_timer_data instance containing the list to which the timer should be added.

       <b>See</b> <b>also</b>
           <b>rte_timer_reset()</b>

       <b>Parameters</b>
           <u>timer_data_id</u> An identifier indicating  which  instance  of  timer  data  should  be  used  for  this
           operation.
           <u>tim</u> The timer handle.
           <u>ticks</u> The number of cycles (see rte_get_hpet_hz()) before the callback function is called.
           <u>type</u> The type can be either:

           • PERIODICAL: The timer is automatically reloaded after execution (returns to the PENDING state)

           • SINGLE: The timer is one-shot, that is, the timer goes to a STOPPED state after execution.

           <u>tim_lcore</u>  The  ID of the lcore where the timer callback function has to be executed. If tim_lcore is
           LCORE_ID_ANY, the timer library will launch it on a different core for each call (round-robin).
           <u>fct</u>  The  callback  function  of  the  timer.  This  parameter  can  be  NULL  if   (and   only   if)
           <b>rte_timer_alt_manage()</b> will be used to manage this timer.
           <u>arg</u> The user argument of the callback function.

       <b>Returns</b>

           • 0: Success; the timer is scheduled.

           • (-1): Timer is in the RUNNING or CONFIG state.

           • -EINVAL: invalid timer_data_id

   <b>int</b> <b>rte_timer_alt_stop</b> <b>(uint32_t</b> <b>timer_data_id,</b> <b>struct</b> <b>rte_timer</b> <b>*</b> <b>tim)</b>
       This  function  is  the  same  as  <b>rte_timer_stop()</b>,  except  that  it  allows  a  caller  to specify the
       rte_timer_data instance containing the list from which this timer should be removed.

       <b>See</b> <b>also</b>
           <b>rte_timer_stop()</b>

       <b>Parameters</b>
           <u>timer_data_id</u> An identifier indicating  which  instance  of  timer  data  should  be  used  for  this
           operation.
           <u>tim</u> The timer handle.

       <b>Returns</b>

           • 0: Success; the timer is stopped.

           • (-1): The timer is in the RUNNING or CONFIG state.

           • -EINVAL: invalid timer_data_id

   <b>int</b>   <b>rte_timer_alt_manage</b>   <b>(uint32_t</b>   <b>timer_data_id,</b>   <b>unsigned</b>  <b>int</b>  <b>*</b>  <b>poll_lcores,</b>  <b>int</b>  <b>n_poll_lcores,</b>
       <b>rte_timer_alt_manage_cb_t</b> <b>f)</b>
       Manage a set of timer lists and execute the specified callback function  for  all  expired  timers.  This
       function  is  similar  to  <b>rte_timer_manage()</b>,  except  that it allows a caller to specify the timer_data
       instance that should be operated on, as well as a set of lcore IDs identifying which timer  lists  should
       be processed. Callback functions of individual timers are ignored.

       <b>See</b> <b>also</b>
           <b>rte_timer_manage()</b>

       <b>Parameters</b>
           <u>timer_data_id</u>  An  identifier  indicating  which  instance  of  timer  data  should  be used for this
           operation.
           <u>poll_lcores</u> An array of lcore ids identifying the timer lists  that  should  be  processed.  NULL  is
           allowed  - if NULL, the timer list corresponding to the lcore calling this routine is processed (same
           as <b>rte_timer_manage()</b>).
           <u>n_poll_lcores</u> The size of the poll_lcores array. If 'poll_lcores' is NULL, this parameter is ignored.
           <u>f</u> The callback function which should be called for all expired timers.

       <b>Returns</b>

           • 0: success

           • -EINVAL: invalid timer_data_id

   <b>int</b>  <b>rte_timer_stop_all</b>  <b>(uint32_t</b>  <b>timer_data_id,</b>  <b>unsigned</b>   <b>int</b>   <b>*</b>   <b>walk_lcores,</b>   <b>int</b>   <b>nb_walk_lcores,</b>
       <b>rte_timer_stop_all_cb_t</b> <b>f,</b> <b>void</b> <b>*</b> <b>f_arg)</b>
       Walk the pending timer lists for the specified lcore IDs, and for each timer that is encountered, stop it
       and call the specified callback function to process it further.

       <b>Parameters</b>
           <u>timer_data_id</u>  An  identifier  indicating  which  instance  of  timer  data  should  be used for this
           operation.
           <u>walk_lcores</u> An array of lcore ids identifying the timer lists that should be processed.
           <u>nb_walk_lcores</u> The size of the walk_lcores array.
           <u>f</u> The callback function which should be called for each timers. Can be NULL.
           <u>f_arg</u> An arbitrary argument that will be passed to f, if it is called.

       <b>Returns</b>

           • 0: success

           • EINVAL: invalid timer_data_id

   <b>int</b> <b>rte_timer_alt_dump_stats</b> <b>(uint32_t</b> <b>timer_data_id,</b> <b>FILE</b> <b>*</b> <b>f)</b>
       This function is the same as <b>rte_timer_dump_stats()</b>, except that it allows  the  caller  to  specify  the
       rte_timer_data instance that should be used.

       <b>See</b> <b>also</b>
           <b>rte_timer_dump_stats()</b>

       <b>Parameters</b>
           <u>timer_data_id</u>  An  identifier  indicating  which  instance  of  timer  data  should  be used for this
           operation.
           <u>f</u> A pointer to a file for output

       <b>Returns</b>

           • 0: success

           • -EINVAL: invalid timer_data_id

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                                  <u><a href="../man3/rte_timer.h.3.html">rte_timer.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>