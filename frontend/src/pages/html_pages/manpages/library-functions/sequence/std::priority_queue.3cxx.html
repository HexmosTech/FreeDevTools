<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::priority_queue< _Tp, _Sequence, _Compare > - A standard container automatically sorting its</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::priority_queue&lt; _Tp, _Sequence, _Compare &gt; - A standard container automatically sorting its
       contents.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;queue&gt;

   <b>Public</b> <b>Types</b>
       <b>typedef</b> _Sequence::const_reference <b>const_reference</b>
       <b>typedef</b> _Sequence <b>container_type</b>
       <b>typedef</b> _Sequence::reference <b>reference</b>
       <b>typedef</b> _Sequence::size_type <b>size_type</b>
       <b>typedef</b> _Compare <b>value_compare</b>
       <b>typedef</b> _Sequence::value_type <b>value_type</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       template&lt;<b>typename</b> <b>_Seq</b>  = _Sequence, <b>typename</b> _Requires  = typename
           enable_if&lt;__and_&lt;is_default_constructible&lt;_Compare&gt;,                    is_default_constructible&lt;_Seq&gt;&gt;::value&gt;::type&gt;
           <b>priority_queue</b> ()
           Default constructor creates no elements.
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> _Alloc , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b> _Requires  = _Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           const _Alloc &amp;<b>__alloc</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; <b>priority_queue</b>
           (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last, const _Compare &amp;__x, _Sequence &amp;&amp;<b>__s</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> _Alloc , <b>typename</b> _Requires  = _Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b>
           (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last, const _Compare &amp;__x, _Sequence &amp;&amp;<b>__s</b>, const _Alloc
           &amp;<b>__alloc</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> _Alloc , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b> _Requires  = _Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           const _Compare &amp;__x, const _Alloc &amp;<b>__alloc</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; <b>priority_queue</b>
           (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last, const _Compare &amp;__x, const _Sequence &amp;<b>__s</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b> _Alloc , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;,
           <b>typename</b> _Requires  = _Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last,
           const _Compare &amp;__x, const _Sequence &amp;<b>__s</b>, const _Alloc &amp;<b>__alloc</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; <b>priority_queue</b>
           (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last, const _Compare &amp;__x=_Compare())
           Builds a queue from a range.
       template&lt;<b>typename</b> _Alloc , <b>typename</b> _Requires  = _Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (const _Alloc &amp;__a)
       template&lt;<b>typename</b> _Alloc , <b>typename</b> _Requires  = _Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (const _Compare &amp;__x,
           _Sequence &amp;&amp;__c, const _Alloc &amp;__a)
       <b>priority_queue</b> (const _Compare &amp;__x, _Sequence &amp;&amp;<b>__s</b>=_Sequence())
       template&lt;<b>typename</b> _Alloc , <b>typename</b> _Requires  = _Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (const _Compare &amp;__x,
           const _Alloc &amp;__a)
       template&lt;<b>typename</b> _Alloc , <b>typename</b> _Requires  = _Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (const _Compare &amp;__x,
           const _Sequence &amp;__c, const _Alloc &amp;__a)
       <b>priority_queue</b> (const _Compare &amp;__x, const _Sequence &amp;<b>__s</b>)
       template&lt;<b>typename</b> _Alloc , <b>typename</b> _Requires  = _Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (const <b>priority_queue</b>
           &amp;__q, const _Alloc &amp;__a)
       template&lt;<b>typename</b> _Alloc , <b>typename</b> _Requires  = _Uses&lt;_Alloc&gt;&gt; <b>priority_queue</b> (<b>priority_queue</b> &amp;&amp;__q,
           const _Alloc &amp;__a)
       template&lt;typename... _Args&gt; <b>void</b> <b>emplace</b> (<b>_Args</b> &amp;&amp;... <b>__args</b>)
       bool <b>empty</b> () const
       <b>void</b> <b>pop</b> ()
           Removes first element.
       <b>void</b> <b>push</b> (const value_type &amp;__x)
           Add data to the queue.
       <b>void</b> <b>push</b> (value_type &amp;&amp;__x)
       size_type <b>size</b> () const
       <b>void</b> <b>swap</b> (<b>priority_queue</b> &amp;<b>__pq</b>) noexcept(__and_&lt;//c++1<b>z</b> <b>or</b> <b>gnu</b>++11 <b>__is_nothrow_swappable</b>&lt; _Sequence &gt;,
           <b>__is_nothrow_swappable</b>&lt; _Compare &gt; &gt;::value)
       const_reference <b>top</b> () const

   <b>Protected</b> <b>Attributes</b>
       _Sequence <b>c</b>
       _Compare <b>comp</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp,</b> <b>typename</b> <b>_Sequence</b> <b>=</b> <b>vector&lt;_Tp&gt;,</b> <b>typename</b> <b>_Compare</b> <b>=</b> <b>less&lt;typename</b>
       <b>_Sequence::value_type&gt;&gt;</b>
       class std::priority_queue&lt; _Tp, _Sequence, _Compare &gt;"A standard container automatically sorting its
       contents.

       <b>Template</b> <b>Parameters</b>
           <b>_</b><u>Tp</u> Type of element.
           <b>_</b><u>Sequence</u> Type of underlying sequence, defaults to vector&lt;_Tp&gt;.
           <b>_</b><u>Compare</u> Comparison function object type, defaults to less&lt;_Sequence::value_type&gt;.

       This is not a true container, but an <u>adaptor</u>. It holds another container, and provides a wrapper
       interface to that container. The wrapper is what enforces priority-based sorting and queue behavior. Very
       few of the standard container/sequence interface requirements are met (e.g., iterators).

       The second template parameter defines the type of the underlying sequence/container. It defaults to
       std::vector, but it can be any type that supports front(), push_back, pop_back, and random-access
       iterators, such as std::deque or an appropriate user-defined type.

       The third template parameter supplies the means of making priority comparisons. It defaults to
       less&lt;value_type&gt; but can be anything defining a strict weak ordering.

       Members not found in <u>normal</u> containers are container_type, which is a typedef for the second Sequence
       parameter, and push, pop, and top, which are standard queue operations.

       <b>Note</b>
           No equality/comparison operators are provided for priority_queue.

           Sorting of the elements takes place as they are added to, and removed from, the priority_queue using
           the priority_queue's member functions. If you access the elements by other means, and change their
           data such that the sorting order would be different, the priority_queue will not re-sort the elements
           for you. (How could it know to do so?)

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Sequence</b>  <b>=</b> <b>vector&lt;_Tp&gt;,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>less&lt;typename</b>
       <b>_Sequence::value_type&gt;&gt;</b> <b>template&lt;typename</b> <b>_Seq</b>  <b>=</b> <b>_Sequence,</b> <b>typename</b> <b>_Requires</b>  <b>=</b> <b>typename</b>
       <b>enable_if&lt;__and_&lt;is_default_constructible&lt;_Compare&gt;,</b>                  <b>is_default_constructible&lt;_Seq&gt;&gt;::value&gt;::type&gt;</b>
       <b>std::priority_queue&lt;</b> <b>_Tp,</b> <b>_Sequence,</b> <b>_Compare</b> <b>&gt;::priority_queue</b> <b>()</b> <b>[inline]</b>
       Default constructor creates no elements.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Sequence</b>  <b>=</b> <b>vector&lt;_Tp&gt;,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>less&lt;typename</b>
       <b>_Sequence::value_type&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>,</b> <b>typename</b>  <b>=</b>
       <b>std::_RequireInputIter&lt;_InputIterator&gt;&gt;</b> <b>std::priority_queue&lt;</b> <b>_Tp,</b> <b>_Sequence,</b> <b>_Compare</b> <b>&gt;::priority_queue</b>
       <b>(_InputIterator</b> <b>__first,</b> <b>_InputIterator</b> <b>__last,</b> <b>const</b> <b>_Compare</b> <b>&amp;</b> <b>__x</b> <b>=</b> <b>_Compare())</b> <b>[inline]</b>
       Builds a queue from a range.

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.
           <b>__</b><u>x</u> A comparison functor describing a strict weak ordering.
           <b>__</b><u>s</u> An initial sequence with which to start.

       Begins by copying <b>__</b><u>s</u>, inserting a copy of the elements from [first,last) into the copy of <b>__</b><u>s</u>, then
       ordering the copy according to <b>__</b><u>x</u>.

       For more information on function objects, see the documentation on <b>functor</b> <b>base</b> <b>classes</b>.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Sequence</b>  <b>=</b> <b>vector&lt;_Tp&gt;,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>less&lt;typename</b>
       <b>_Sequence::value_type&gt;&gt;</b> <b>bool</b> <b>std::priority_queue&lt;</b> <b>_Tp,</b> <b>_Sequence,</b> <b>_Compare</b> <b>&gt;::empty</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Returns true if the queue is empty.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Sequence</b>  <b>=</b> <b>vector&lt;_Tp&gt;,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>less&lt;typename</b>
       <b>_Sequence::value_type&gt;&gt;</b> <b>void</b> <b>std::priority_queue&lt;</b> <b>_Tp,</b> <b>_Sequence,</b> <b>_Compare</b> <b>&gt;::pop</b> <b>()</b> <b>[inline]</b>
       Removes first element. This is a typical queue operation. It shrinks the queue by one. The time
       complexity of the operation depends on the underlying sequence.

       Note that no data is returned, and if the first element's data is needed, it should be retrieved before
       pop() is called.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Sequence</b>  <b>=</b> <b>vector&lt;_Tp&gt;,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>less&lt;typename</b>
       <b>_Sequence::value_type&gt;&gt;</b> <b>void</b> <b>std::priority_queue&lt;</b> <b>_Tp,</b> <b>_Sequence,</b> <b>_Compare</b> <b>&gt;::push</b> <b>(const</b> <b>value_type</b> <b>&amp;</b>
       <b>__x)</b> <b>[inline]</b>
       Add data to the queue.

       <b>Parameters</b>
           <b>__</b><u>x</u> Data to be added.

       This is a typical queue operation. The time complexity of the operation depends on the underlying
       sequence.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Sequence</b>  <b>=</b> <b>vector&lt;_Tp&gt;,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>less&lt;typename</b>
       <b>_Sequence::value_type&gt;&gt;</b> <b>size_type</b> <b>std::priority_queue&lt;</b> <b>_Tp,</b> <b>_Sequence,</b> <b>_Compare</b> <b>&gt;::size</b> <b>()</b> <b>const</b> <b>[inline]</b>

       Returns the number of elements in the queue.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Sequence</b>  <b>=</b> <b>vector&lt;_Tp&gt;,</b> <b>typename</b> <b>_Compare</b>  <b>=</b> <b>less&lt;typename</b>
       <b>_Sequence::value_type&gt;&gt;</b> <b>const_reference</b> <b>std::priority_queue&lt;</b> <b>_Tp,</b> <b>_Sequence,</b> <b>_Compare</b> <b>&gt;::top</b> <b>()</b> <b>const</b>
       <b>[inline]</b>
       Returns a read-only (constant) reference to the data at the first element of the queue.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc<u>std::priority_queue&lt;</u> <b>_</b><u>Tp,</u> <b>_</b><u>Sequence,</u> <b>_</b><u>Compare</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>