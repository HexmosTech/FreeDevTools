<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Seq - Sequence object, with features</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-perl-perl">libbio-perl-perl_1.7.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Seq - Sequence object, with features

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # This is the main sequence object in Bioperl

           # gets a sequence from a file
           $seqio  = Bio::SeqIO-&gt;new( '-format' =&gt; 'embl' , -file =&gt; 'myfile.dat');
           $seqobj = $seqio-&gt;next_seq();

           # SeqIO can both read and write sequences; see Bio::SeqIO
           # for more information and examples

           # get from database
           $db = Bio::DB::GenBank-&gt;new();
           $seqobj = $db-&gt;get_Seq_by_acc('X78121');

           # make from strings in script
           $seqobj = Bio::Seq-&gt;new( -display_id =&gt; 'my_id',
                                    -seq =&gt; $sequence_as_string);

           # gets sequence as a string from sequence object
           $seqstr   = $seqobj-&gt;seq(); # actual sequence as a string
           $seqstr   = $seqobj-&gt;subseq(10,50); # slice in biological coordinates

           # retrieves information from the sequence
           # features must implement Bio::SeqFeatureI interface

           @features = $seqobj-&gt;get_SeqFeatures(); # just top level
           foreach my $feat ( @features ) {
               print "Feature ",$feat-&gt;primary_tag," starts ",$feat-&gt;start," ends ",
                   $feat-&gt;end," strand ",$feat-&gt;strand,"\n";

               # features retain link to underlying sequence object
               print "Feature sequence is ",$feat-&gt;seq-&gt;seq(),"\n"
           }

           # sequences may have a species

           if( defined $seq-&gt;species ) {
               print "Sequence is from ",$species-&gt;binomial," [",$species-&gt;common_name,"]\n";
           }

           # annotation objects are Bio::AnnotationCollectionI's
           $ann      = $seqobj-&gt;annotation(); # annotation object

           # references is one type of annotations to get. Also get
           # comment and dblink. Look at Bio::AnnotationCollection for
           # more information

           foreach my $ref ( $ann-&gt;get_Annotations('reference') ) {
               print "Reference ",$ref-&gt;title,"\n";
           }

           # you can get truncations, translations and reverse complements, these
           # all give back Bio::Seq objects themselves, though currently with no
           # features transferred

           my $trunc = $seqobj-&gt;trunc(100,200);
           my $rev   = $seqobj-&gt;revcom();

           # there are many options to translate - check out the docs
           my $trans = $seqobj-&gt;translate();

           # these functions can be chained together

           my $trans_trunc_rev = $seqobj-&gt;trunc(100,200)-&gt;revcom-&gt;translate();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A Seq object is a sequence with sequence features placed on it. The Seq object contains a PrimarySeq
       object for the actual sequence and also implements its interface.

       In Bioperl we have 3 main players that people are going to use frequently

         Bio::PrimarySeq  - just the sequence and its names, nothing else.
         Bio::SeqFeatureI - a feature on a sequence, potentially with a sequence
                            and a location and annotation.
         Bio::Seq         - A sequence and a collection of sequence features
                            (an aggregate) with its own annotation.

       Although Bioperl is not tied heavily to file formats these distinctions do map to file formats sensibly
       and for some bioinformaticians this might help

         Bio::PrimarySeq  - Fasta file of a sequence
         Bio::SeqFeatureI - A single entry in an EMBL/GenBank/DDBJ feature table
         Bio::Seq         - A single EMBL/GenBank/DDBJ entry

       By having this split we avoid a lot of nasty circular references (sequence features can hold a reference
       to a sequence without the sequence holding a reference to the sequence feature). See Bio::PrimarySeq and
       Bio::SeqFeatureI for more information.

       Ian Korf really helped in the design of the Seq and SeqFeature system.

   <b>Examples</b>
       A simple and fundamental block of code:

         use Bio::SeqIO;

         my $seqIOobj = Bio::SeqIO-&gt;new(-file=&gt;"1.fa"); # create a SeqIO object
         my $seqobj = $seqIOobj-&gt;next_seq;              # get a Seq object

       With the Seq object in hand one has access to a powerful set of Bioperl methods and related Bioperl
       objects. This next script will take a file of sequences in EMBL format and create a file of the reverse-
       complemented sequences in Fasta format using Seq objects. It also prints out details about the exons it
       finds as sequence features in Genbank Flat File format.

         use Bio::Seq;
         use Bio::SeqIO;

         $seqin = Bio::SeqIO-&gt;new( -format =&gt; 'EMBL' , -file =&gt; 'myfile.dat');
         $seqout= Bio::SeqIO-&gt;new( -format =&gt; 'Fasta', -file =&gt; '&gt;output.fa');

         while((my $seqobj = $seqin-&gt;next_seq())) {
             print "Seen sequence ",$seqobj-&gt;display_id,", start of seq ",
                   substr($seqobj-&gt;seq,1,10),"\n";
             if( $seqobj-&gt;alphabet eq 'dna') {
                   $rev = $seqobj-&gt;revcom;
                   $id  = $seqobj-&gt;display_id();
                   $id  = "$id.rev";
                   $rev-&gt;display_id($id);
                   $seqout-&gt;write_seq($rev);
             }

             foreach $feat ( $seqobj-&gt;get_SeqFeatures() ) {
                  if( $feat-&gt;primary_tag eq 'exon' ) {
                     print STDOUT "Location ",$feat-&gt;start,":",
                           $feat-&gt;end," GFF[",$feat-&gt;gff_string,"]\n";
                  }
             }
         }

       Let's examine the script. The lines below import the Bioperl modules.  Seq is the main Bioperl sequence
       object and SeqIO is the Bioperl support for reading sequences from files and to files

         use Bio::Seq;
         use Bio::SeqIO;

       These two lines create two SeqIO streams: one for reading in sequences and one for outputting sequences:

         $seqin = Bio::SeqIO-&gt;new( -format =&gt; 'EMBL' , -file =&gt; 'myfile.dat');
         $seqout= Bio::SeqIO-&gt;new( -format =&gt; 'Fasta', -file =&gt; '&gt;output.fa');

       Notice that in the "$seqout" case there is a greater-than sign, indicating the file is being opened for
       writing.

       Using the

         '-argument' =&gt; value

       syntax is common in Bioperl. The file argument is like an argument to <b>open()</b> . You can also pass in
       filehandles or FileHandle objects by using the -fh argument (see Bio::SeqIO documentation for details).
       Many formats in Bioperl are handled, including Fasta, EMBL, GenBank, Swissprot (swiss), PIR, and GCG.

         $seqin = Bio::SeqIO-&gt;new( -format =&gt; 'EMBL' , -file =&gt; 'myfile.dat');
         $seqout= Bio::SeqIO-&gt;new( -format =&gt; 'Fasta', -file =&gt; '&gt;output.fa');

       This is the main loop which will loop progressively through sequences in a file, and each call to
       $seqio-&gt;<b>next_seq()</b> provides a new Seq object from the file:

         while((my $seqobj = $seqio-&gt;next_seq())) {

       This print line below accesses fields in the Seq object directly. The $seqobj-&gt;display_id is the way to
       access the display_id attribute of the Seq object. The $seqobj-&gt;seq method gets the actual sequence out
       as string. Then you can do manipulation of this if you want to (there are however easy ways of doing
       truncation, reverse-complement and translation).

         print "Seen sequence ",$seqobj-&gt;display_id,", start of seq ",
                      substr($seqobj-&gt;seq,1,10),"\n";

       Bioperl has to guess the alphabet of the sequence, being either 'dna', 'rna', or 'protein'. The alphabet
       attribute is one of these three possibilities.

         if( $seqobj-&gt;alphabet eq 'dna') {

       The $seqobj-&gt;revcom method provides the reverse complement of the Seq object as another Seq object. Thus,
       the $rev variable is a reference to another Seq object. For example, one could repeat the above print
       line for this Seq object (putting $rev in place of $seqobj). In this case we are going to output the
       object into the file stream we built earlier on.

         $rev = $seqobj-&gt;revcom;

       When we output it, we want the id of the outputted object to be changed to "$id.rev", ie, with .rev on
       the end of the name. The following lines retrieve the id of the sequence object, add .rev to this and
       then set the display_id of the rev sequence object to this. Notice that to set the display_id attribute
       you just need call the same method, <b>display_id()</b>, with the new value as an argument.  Getting and setting
       values with the same method is common in Bioperl.

         $id  = $seqobj-&gt;display_id();
         $id  = "$id.rev";
         $rev-&gt;display_id($id);

       The write_seq method on the SeqIO output object, $seqout, writes the $rev object to the filestream we
       built at the top of the script.  The filestream knows that it is outputting in fasta format, and so it
       provides fasta output.

         $seqout-&gt;write_seq($rev);

       This block of code loops over sequence features in the sequence object, trying to find ones who have been
       tagged as 'exon'.  Features have start and end attributes and can be outputted in Genbank Flat File
       format, GFF, a standarized format for sequence features.

         foreach $feat ( $seqobj-&gt;get_SeqFeatures() ) {
             if( $feat-&gt;primary_tag eq 'exon' ) {
                 print STDOUT "Location ",$feat-&gt;start,":",
                    $feat-&gt;end," GFF[",$feat-&gt;gff_string,"]\n";
             }
         }

       The code above shows how a few Bio::Seq methods suffice to read, parse, reformat and analyze sequences
       from a file. A full list of methods available to Bio::Seq objects is shown below. Bear in mind that some
       of these methods come from PrimarySeq objects, which are simpler than Seq objects, stripped of features
       (see Bio::PrimarySeq for more information).

         # these methods return strings, and accept strings in some cases:

         $seqobj-&gt;seq();              # string of sequence
         $seqobj-&gt;subseq(5,10);       # part of the sequence as a string
         $seqobj-&gt;accession_number(); # when there, the accession number
         $seqobj-&gt;alphabet();         # one of 'dna','rna',or 'protein'
         $seqobj-&gt;version()           # when there, the version
         $seqobj-&gt;keywords();         # when there, the Keywords line
         $seqobj-&gt;length()            # length
         $seqobj-&gt;desc();             # description
         $seqobj-&gt;primary_id();       # a unique id for this sequence regardless
                                      # of its display_id or accession number
         $seqobj-&gt;display_id();       # the human readable id of the sequence

       Some of these values map to fields in common formats. For example, The <b>display_id()</b> method returns the
       LOCUS name of a Genbank entry, the (\S+) following the &gt; character in a Fasta file, the ID from a
       SwissProt file, and so on. The <b>desc()</b> method will return the DEFINITION line of a Genbank file, the
       description following the display_id in a Fasta file, and the DE field in a SwissProt file.

         # the following methods return new Seq objects, but
         # do not transfer features across to the new object:

         $seqobj-&gt;trunc(5,10)  # truncation from 5 to 10 as new object
         $seqobj-&gt;revcom       # reverse complements sequence
         $seqobj-&gt;translate    # translation of the sequence

         # if new() can be called this method returns 1, else 0

         $seqobj-&gt;can_call_new

         # the following method determines if the given string will be accepted
         # by the seq() method - if the string is acceptable then validate()
         # returns 1, or 0 if not

         $seqobj-&gt;validate_seq($string)

         # the following method returns or accepts a Species object:

         $seqobj-&gt;species();

       Please see Bio::Species for more information on this object.

         # the following method returns or accepts an Annotation object
         # which in turn allows access to Annotation::Reference
         # and Annotation::Comment objects:

         $seqobj-&gt;annotation();

       These annotations typically refer to entire sequences, unlike features.  See Bio::AnnotationCollectionI,
       Bio::Annotation::Collection, Bio::Annotation::Reference, and Bio::Annotation::Comment for details.

       It is also important to be able to describe defined portions of a sequence. The combination of some
       description and the corresponding sub-sequence is called a feature - an exon and its coordinates within a
       gene is an example of a feature, or a domain within a protein.

         # the following methods return an array of SeqFeatureI objects:

         $seqobj-&gt;get_SeqFeatures # The 'top level' sequence features
         $seqobj-&gt;get_all_SeqFeatures # All sequence features, including sub-seq
                                      # features, such as features in an exon

         # to find out the number of features use:

         $seqobj-&gt;feature_count

       Here are just some of the methods available to SeqFeatureI objects:

         # these methods return numbers:

         $feat-&gt;start          # start position (1 is the first base)
         $feat-&gt;end            # end position (2 is the second base)
         $feat-&gt;strand         # 1 means forward, -1 reverse, 0 not relevant

         # these methods return or accept strings:

         $feat-&gt;primary_tag    # the name of the sequence feature, eg
                               # 'exon', 'glycoslyation site', 'TM domain'
         $feat-&gt;source_tag     # where the feature comes from, eg, 'EMBL_GenBank',
                               # or 'BLAST'

         # this method returns the more austere PrimarySeq object, not a
         # Seq object - the main difference is that PrimarySeq objects do not
         # themselves contain sequence features

         $feat-&gt;seq            # the sequence between start,end on the
                               # correct strand of the sequence

       See Bio::PrimarySeq for more details on PrimarySeq objects.

         # useful methods for feature comparisons, for start/end points

         $feat-&gt;overlaps($other)  # do $feat and $other overlap?
         $feat-&gt;contains($other)  # is $other completely within $feat?
         $feat-&gt;equals($other)    # do $feat and $other completely agree?

         # one can also add features

         $seqobj-&gt;add_SeqFeature($feat)     # returns 1 if successful

         # sub features. For complex join() statements, the feature
         # is one sequence feature with many sub SeqFeatures

         $feat-&gt;sub_SeqFeature  # returns array of sub seq features

       Please see Bio::SeqFeatureI and Bio::SeqFeature::Generic, for more information on sequence features.

       It is worth mentioning that one can also retrieve the start and end positions of a feature using a
       Bio::LocationI object:

         $location = $feat-&gt;location # $location is a Bio::LocationI object
         $location-&gt;start;           # start position
         $location-&gt;end;             # end position

       This is useful because one needs a Bio::Location::SplitLocationI object in order to retrieve the
       coordinates inside the Genbank or EMBL <b>join()</b> statements (e.g. "CDS
       join(51..142,273..495,1346..1474)"):

         if ( $feat-&gt;location-&gt;isa('Bio::Location::SplitLocationI') &amp;&amp;
                      $feat-&gt;primary_tag eq 'CDS' )  {
           foreach $loc ( $feat-&gt;location-&gt;sub_Location ) {
             print $loc-&gt;start . ".." . $loc-&gt;end . "\n";
           }
         }

       See Bio::LocationI and Bio::Location::SplitLocationI for more information.

</pre><h4><b>Implemented</b> <b>Interfaces</b></h4><pre>
       This class implements the following interfaces.

       Bio::SeqI
           Note that this includes implementing Bio::PrimarySeqI.

       Bio::IdentifiableI
       Bio::DescribableI
       Bio::AnnotatableI
       Bio::FeatureHolderI

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>Lists</b>
       User  feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments
       and suggestions preferably to one of the Bioperl mailing lists. Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list:

       <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather than to the module maintainer directly. Many experienced and reponsive experts will be  able  look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>Bugs</b>
       Report  bugs to the Bioperl bug tracking system to help us keep track the bugs and their resolution.  Bug
       reports can be submitted via the web:

         https://github.com/bioperl/bioperl-live/issues

</pre><h4><b>AUTHOR</b> <b>-</b> <b>Ewan</b> <b>Birney,</b> <b>inspired</b> <b>by</b> <b>Ian</b> <b>Korf</b> <b>objects</b></h4><pre>
       Email <a href="mailto:birney@ebi.ac.uk">birney@ebi.ac.uk</a>

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
        Jason Stajich E&lt;lt&gt;<a href="mailto:jason@bioperl.orgE">jason@bioperl.orgE</a>&lt;gt&gt;
        Mark A. Jensen maj -at- fortinbras -dot- us

</pre><h4><b>APPENDIX</b></h4><pre>
       The rest of the documentation details each of the object methods. Internal methods are  usually  preceded
       with a "_".

   <b>new</b>
        Title   : new
        Usage   : $seq = Bio::Seq-&gt;new( -seq =&gt; 'ATGGGGGTGGTGGTACCCT',
                                        -id  =&gt; 'human_id',
                                        -accession_number =&gt; 'AL000012',
                                      );

        Function: Returns a new Seq object from
                  basic constructors, being a string for the sequence
                  and strings for id and accession_number
        Returns : a new Bio::Seq object

</pre><h4><b>PrimarySeq</b> <b>interface</b></h4><pre>
       The PrimarySeq interface provides the basic sequence getting and setting methods for on all sequences.

       These methods implement the Bio::PrimarySeq interface by delegating to the primary_seq inside the object.
       This  means  that you can use a Seq object wherever there is a PrimarySeq, and of course, you are free to
       use these functions anyway.

   <b>seq</b>
        Title   : seq
        Usage   : $string = $obj-&gt;seq()
        Function: Get/Set the sequence as a string of letters. The
                  case of the letters is left up to the implementer.
                  Suggested cases are upper case for proteins and lower case for
                  DNA sequence (IUPAC standard),
                  but implementations are suggested to keep an open mind about
                  case (some users... want mixed case!)
        Returns : A scalar
        Args    : Optionally on set the new value (a string). An optional second
                  argument presets the alphabet (otherwise it will be guessed).
                  Both parameters may also be given in named parameter style
                  with -seq and -alphabet being the names.

   <b>validate_seq</b>
        Title   : validate_seq
        Usage   : if(! $seqobj-&gt;validate_seq($seq_str) ) {
                       print "sequence $seq_str is not valid for an object of
                       alphabet ",$seqobj-&gt;alphabet, "\n";
                  }
        Function: Test that the given sequence is valid, i.e. contains only valid
                  characters. The allowed characters are all letters (A-Z) and '-','.',
                  '*','?','=' and '~'. Spaces are not valid. Note that this
                  implementation does not take alphabet() into account.
        Returns : 1 if the supplied sequence string is valid, 0 otherwise.
        Args    : - Sequence string to be validated
                  - Boolean to throw an error if the sequence is invalid

   <b>length</b>
        Title   : length
        Usage   : $len = $seq-&gt;length()
        Function:
        Example :
        Returns : Integer representing the length of the sequence.
        Args    : None

</pre><h4><b>Methods</b> <b>from</b> <b>the</b> <b>Bio::PrimarySeqI</b> <b>interface</b></h4><pre>
   <b>subseq</b>
        Title   : subseq
        Usage   : $substring = $obj-&gt;subseq(10,40);
        Function: Returns the subseq from start to end, where the first base
                  is 1 and the number is inclusive, ie 1-2 are the first two
                  bases of the sequence

                  Start cannot be larger than end but can be equal

        Returns : A string
        Args    : 2 integers

   <b>display_id</b>
        Title   : display_id
        Usage   : $id = $obj-&gt;display_id or $obj-&gt;display_id($newid);
        Function: Gets or sets the display id, also known as the common name of
                  the Seq object.

                  The semantics of this is that it is the most likely string
                  to be used as an identifier of the sequence, and likely to
                  have "human" readability.  The id is equivalent to the LOCUS
                  field of the GenBank/EMBL databanks and the ID field of the
                  Swissprot/sptrembl database. In fasta format, the &gt;(\S+) is
                  presumed to be the id, though some people overload the id
                  to embed other information. Bioperl does not use any
                  embedded information in the ID field, and people are
                  encouraged to use other mechanisms (accession field for
                  example, or extending the sequence object) to solve this.

                  Notice that $seq-&gt;id() maps to this function, mainly for
                  legacy/convenience issues.
        Returns : A string
        Args    : None or a new id

   <b>accession_number</b>
        Title   : accession_number
        Usage   : $unique_biological_key = $obj-&gt;accession_number;
        Function: Returns the unique biological id for a sequence, commonly
                  called the accession_number. For sequences from established
                  databases, the implementors should try to use the correct
                  accession number. Notice that primary_id() provides the
                  unique id for the implementation, allowing multiple objects
                  to have the same accession number in a particular implementation.

                  For sequences with no accession number, this method should return
                  "unknown".

                  Can also be used to set the accession number.
        Example : $key = $seq-&gt;accession_number or $seq-&gt;accession_number($key)
        Returns : A string
        Args    : None or an accession number

   <b>desc</b>
        Title   : desc
        Usage   : $seqobj-&gt;desc($string) or $seqobj-&gt;desc()
        Function: Sets or gets the description of the sequence
        Example :
        Returns : The description
        Args    : The description or none

   <b>primary_id</b>
        Title   : primary_id
        Usage   : $unique_implementation_key = $obj-&gt;primary_id;
        Function: Returns the unique id for this object in this
                  implementation. This allows implementations to manage
                  their own object ids in a way the implementation can control
                  clients can expect one id to map to one object.

                  For sequences with no natural id, this method should return
                  a stringified memory location.

                  Can also be used to set the primary_id (or unset to undef).

                  [Note this method name is likely to change in 1.3]

        Example : $id = $seq-&gt;primary_id or $seq-&gt;primary_id($id)
        Returns : A string
        Args    : None or an id, or undef to unset the primary id.

   <b>can_call_new</b>
        Title   : can_call_new
        Usage   : if ( $obj-&gt;can_call_new ) {
                      $newobj = $obj-&gt;new( %param );
                  }
        Function: can_call_new returns 1 or 0 depending
                  on whether an implementation allows new
                  constructor to be called. If a new constructor
                  is allowed, then it should take the followed hashed
                  constructor list.

                  $myobject-&gt;new( -seq =&gt; $sequence_as_string,
                                  -display_id  =&gt; $id
                                  -accession_number =&gt; $accession
                                  -alphabet =&gt; 'dna',
                                );
        Example :
        Returns : 1 or 0
        Args    : None

   <b>alphabet</b>
        Title   : alphabet
        Usage   : if ( $obj-&gt;alphabet eq 'dna' ) { /Do Something/ }
        Function: Get/Set the type of sequence being one of
                  'dna', 'rna' or 'protein'. This is case sensitive.

                  This is not called &lt;type&gt; because this would cause
                  upgrade problems from the 0.5 and earlier Seq objects.

        Returns : A string either 'dna','rna','protein'. NB - the object must
                  make a call of the type - if there is no type specified it
                  has to guess.
        Args    : optional string to set : 'dna' | 'rna' | 'protein'

   <b>is_circular</b>
        Title   : is_circular
        Usage   : if( $obj-&gt;is_circular) { /Do Something/ }
        Function: Returns true if the molecule is circular
        Returns : Boolean value
        Args    : none

</pre><h4><b>Methods</b> <b>for</b> <b>Bio::IdentifiableI</b> <b>compliance</b></h4><pre>
   <b>object_id</b>
        Title   : object_id
        Usage   : $string    = $obj-&gt;object_id()
        Function: a string which represents the stable primary identifier
                  in this namespace of this object. For DNA sequences this
                  is its accession_number, similarly for protein sequences

                  This is aliased to accession_number().
        Returns : A scalar

   <b>version</b>
        Title   : version
        Usage   : $version    = $obj-&gt;version()
        Function: a number which differentiates between versions of
                  the same object. Higher numbers are considered to be
                  later and more relevant, but a single object described
                  the same identifier should represent the same concept

        Returns : A number

   <b>authority</b>
        Title   : authority
        Usage   : $authority    = $obj-&gt;authority()
        Function: a string which represents the organisation which
                  granted the namespace, written as the DNS name for
                  organisation (eg, wormbase.org)

        Returns : A scalar

   <b>namespace</b>
        Title   : namespace
        Usage   : $string    = $obj-&gt;namespace()
        Function: A string representing the name space this identifier
                  is valid in, often the database name or the name
                  describing the collection

        Returns : A scalar

</pre><h4><b>Methods</b> <b>for</b> <b>Bio::DescribableI</b> <b>compliance</b></h4><pre>
   <b>display_name</b>
        Title   : display_name
        Usage   : $string    = $obj-&gt;display_name()
        Function: A string which is what should be displayed to the user
                  the string should have no spaces (ideally, though a cautious
                  user of this interface would not assume this) and should be
                  less than thirty characters (though again, double checking
                  this is a good idea)

                  This is aliased to display_id().
        Returns : A scalar

   <b>description</b>
        Title   : description
        Usage   : $string    = $obj-&gt;description()
        Function: A text string suitable for displaying to the user a
                  description. This string is likely to have spaces, but
                  should not have any newlines or formatting - just plain
                  text. The string should not be greater than 255 characters
                  and clients can feel justified at truncating strings at 255
                  characters for the purposes of display

                  This is aliased to desc().
        Returns : A scalar

</pre><h4><b>Methods</b> <b>for</b> <b>implementing</b> <b>Bio::AnnotatableI</b></h4><pre>
   <b>annotation</b>
        Title   : annotation
        Usage   : $ann = $seq-&gt;annotation or
                  $seq-&gt;annotation($ann)
        Function: Gets or sets the annotation
        Returns : Bio::AnnotationCollectionI object
        Args    : None or Bio::AnnotationCollectionI object

       See Bio::AnnotationCollectionI and Bio::Annotation::Collection for more information

</pre><h4><b>Methods</b> <b>for</b> <b>delegating</b> <b>Bio::AnnotationCollectionI</b></h4><pre>
   <b>get_Annotations()</b>
        Usage   : my @annotations = $seq-&gt;get_Annotations('key')
        Function: Retrieves all the Bio::AnnotationI objects for a specific key
                  for this object
        Returns : list of Bio::AnnotationI - empty if no objects stored for a key
        Args    : string which is key for annotations

   <b>add_Annotation()</b>
        Usage   : $seq-&gt;add_Annotation('reference',$object);
                  $seq-&gt;add_Annotation($object,'Bio::MyInterface::DiseaseI');
                  $seq-&gt;add_Annotation($object);
                  $seq-&gt;add_Annotation('disease',$object,'Bio::MyInterface::DiseaseI');
        Function: Adds an annotation for a specific key for this sequence object.

                  If the key is omitted, the object to be added must provide a value
                  via its tagname().

                  If the archetype is provided, this and future objects added under
                  that tag have to comply with the archetype and will be rejected
                  otherwise.

        Returns : none
        Args    : annotation key ('disease', 'dblink', ...)
                  object to store (must be Bio::AnnotationI compliant)
                  [optional] object archetype to map future storage of object
                  of these types to

   <b>remove_Annotations()</b>
        Usage   : $seq-&gt;remove_Annotations()
        Function: Remove the annotations for the specified key from this sequence
                  object
        Returns : an list of Bio::AnnotationI compliant objects which were stored
                  under the given key(s) for this sequence object
        Args    : the key(s) (tag name(s), one or more strings) for which to
                  remove annotations (optional; if none given, flushes all
                  annotations)

   <b>get_num_of_annotations()</b>
        Usage   : my $count = $seq-&gt;get_num_of_annotations()
        Alias   : num_Annotations
        Function: Returns the count of all annotations stored for this sequence
                  object
        Returns : integer
        Args    : none

</pre><h4><b>Methods</b> <b>to</b> <b>implement</b> <b>Bio::FeatureHolderI</b></h4><pre>
       This includes methods for retrieving, adding, and removing features.

   <b>get_SeqFeatures</b>
        Title   : get_SeqFeatures
        Usage   :
        Function: Get the feature objects held by this feature holder.

                  Features which are not top-level are subfeatures of one or
                  more of the returned feature objects, which means that you
                  must traverse the subfeature arrays of each top-level
                  feature object in order to traverse all features associated
                  with this sequence.

                  Specific features can be obtained by primary tag, specified in
                  the argument.

                  Use get_all_SeqFeatures() if you want the feature tree
                  flattened into one single array.

        Example : my @feats = $seq-&gt;get_SeqFeatures or
                  my @genefeats = $seq-&gt;get_SeqFeatures('gene')
        Returns : an array of Bio::SeqFeatureI implementing objects
        Args    : [optional] string (feature tag)

   <b>get_all_SeqFeatures</b>
        Title   : get_all_SeqFeatures
        Usage   : @feat_ary = $seq-&gt;get_all_SeqFeatures();
        Function: Returns the tree of feature objects attached to this
                  sequence object flattened into one single array. Top-level
                  features will still contain their subfeature-arrays, which
                  means that you will encounter subfeatures twice if you
                  traverse the subfeature tree of the returned objects.

                  Use get_SeqFeatures() if you want the array to contain only
                  the top-level features.

        Returns : An array of Bio::SeqFeatureI implementing objects.
        Args    : None

   <b>feature_count</b>
        Title   : feature_count
        Usage   : $seq-&gt;feature_count()
        Function: Return the number of SeqFeatures attached to a sequence
        Returns : integer representing the number of SeqFeatures
        Args    : None

   <b>add_SeqFeature</b>
        Title   : add_SeqFeature
        Usage   : $seq-&gt;add_SeqFeature($feat);
        Function: Adds the given feature object to the feature array of this
                  sequence. The object passed is required to implement the
                  Bio::SeqFeatureI interface.
                  The 'EXPAND' qualifier (see L&lt;Bio::FeatureHolderI&gt;) is supported, but
                  has no effect,
        Returns : 1 on success
        Args    : A Bio::SeqFeatureI implementing object.

   <b>remove_SeqFeatures</b>
        Title   : remove_SeqFeatures
        Usage   : $seq-&gt;remove_SeqFeatures();
        Function: Removes all attached SeqFeatureI objects or those with the
                  specified primary tag
        Example : my @gene_feats = $seq-&gt;remove_seqFeatures('gene') or
                  my @feats = $seq-&gt;remove_seqFeatures()
        Returns : The array of Bio::SeqFeatureI objects removed from the sequence
        Args    : None, or a feature primary tag

</pre><h4><b>Methods</b> <b>provided</b> <b>in</b> <b>the</b> <b>Bio::PrimarySeqI</b> <b>interface</b></h4><pre>
       These methods are inherited from the PrimarySeq interface and work as one expects, building new  Bio::Seq
       objects or other information as expected. See Bio::PrimarySeq for more information.

       Sequence Features are <b>not</b> transferred to the new objects.  To reverse complement and include the features
       use Bio::SeqUtils::revcom_with_features.

   <b>revcom</b>
        Title   : revcom
        Usage   : $rev = $seq-&gt;revcom()
        Function: Produces a new Bio::Seq object which
                  is the reversed complement of the sequence. For protein
                  sequences this throws an exception of "Sequence is a protein.
                  Cannot revcom"

                  The id is the same id as the original sequence, and the
                  accession number is also identical. If someone wants to track
                  that this sequence has be reversed, it needs to define its own
                  extensions

                  To do an in-place edit of an object you can go:

                  $seq = $seq-&gt;revcom();

                  This of course, causes Perl to handle the garbage collection of
                  the old object, but it is roughly speaking as efficient as an
                  in-place edit.

        Returns : A new (fresh) Bio::Seq object
        Args    : None

   <b>trunc</b>
        Title   : trunc
        Usage   : $subseq = $myseq-&gt;trunc(10,100);
        Function: Provides a truncation of a sequence

        Example :
        Returns : A fresh Seq object
        Args    : A Seq object

   <b>id</b>
        Title   : id
        Usage   : $id = $seq-&gt;id()
        Function: This is mapped on display_id
        Returns : value of display_id()
        Args    : [optional] value to update display_id

</pre><h4><b>Seq</b> <b>only</b> <b>methods</b></h4><pre>
       These methods are specific to the Bio::Seq object, and not found on the Bio::PrimarySeq object

   <b>primary_seq</b>
        Title   : primary_seq
        Usage   : $seq-&gt;primary_seq or $seq-&gt;primary_seq($newval)
        Function: Get or set a PrimarySeq object
        Example :
        Returns : PrimarySeq object
        Args    : None or PrimarySeq object

   <b>species</b>
        Title   : species
        Usage   : $species = $seq-&gt;species() or $seq-&gt;species($species)
        Function: Gets or sets the species
        Returns : L&lt;Bio::Species&gt; object
        Args    : None or L&lt;Bio::Species&gt; object

       See Bio::Species for more information

perl v5.32.1                                       2021-08-15                                      <u>Bio::<a href="../man3pm/Seq.3pm.html">Seq</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>