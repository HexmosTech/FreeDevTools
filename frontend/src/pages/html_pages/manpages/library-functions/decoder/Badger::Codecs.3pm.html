<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badger::Codecs - modules for encoding and decoding data</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbadger-perl">libbadger-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Badger::Codecs - modules for encoding and decoding data

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # using class methods
           use Badger::Codecs;
           $encoded = Badger::Codecs-&gt;encode( base64 =&gt; $original );
           $decoded = Badger::Codecs-&gt;decode( base64 =&gt; $encoded );

           # creating a single codec object
           $codec   = Badger::Codecs-&gt;codec('base64');
           $encoded = $codec-&gt;encode($original);
           $decoded = $codec-&gt;decode($encoded);

           # creating a codecs collection
           $codecs  = Badger::Codecs-&gt;new(
               base   =&gt; ['My::Codec', 'Badger::Codec'],
               codecs =&gt; {
                   # most codec names are grokked automatigally from the
                   # base defined above - this hash is for any exceptions
                   wibble  =&gt; 'Ferret::Codec::Wibble',
                   frusset =&gt; 'Stoat::Codec::Frusset',
               }
           );

           # encode/decode via codecs collective
           $encoded = $codecs-&gt;encode( wibble =&gt; $original );
           $decoded = $codecs-&gt;decode( wibble =&gt; $encoded );

           # or via a specific codec
           $codec   = $codecs-&gt;codec('wibble');
           $encoded = $codec-&gt;encode($original);
           $decoded = $codec-&gt;decode($encoded);

           # importing a single codec
           use Badger::Codecs
               codec =&gt; 'url';

           # codec() returns a Badger::Codec::URL object
           $encoded = codec-&gt;encode($text);
           $decoded = codec-&gt;decode($encoded);

           # encode() and decode() are imported subroutines
           $encoded = encode($text);
           $decoded = decode($encoded);

           # import multiple codecs
           use Badger::Codecs
               codecs =&gt; 'base64 storable';

           # codec objects
           base64-&gt;encode(...);    base64-&gt;decode(...);
           storable-&gt;encode(...);  storable-&gt;decode(...);

           # imported subroutines
           encode_base64(...);     decode_base64(...);
           encode_storable(...);   decode_storable(...);

           # import a codec chain
           use Badger::Codecs
               codec =&gt; 'storable+base64';

           # as before, now both codecs are applied
           codec-&gt;encode(...);
           codec-&gt;decode(...);
           encode(...);
           decode(...)

           # multiple codecs with various options
           use Badger::Codecs
               codecs =&gt; {
                   link  =&gt; 'url+html',
                   str64 =&gt; 'storable+base64',
               };

           # codec objects
           link-&gt;encode(...);      link-&gt;decode(...);
           str64-&gt;encode(...);     str64-&gt;decode(...);

           # subroutines
           encode_link(...);       decode_link(...);
           encode_str64(...);      decode_str64(...);

           # accessing codecs via Badger::Class
           use Badger::Class
               codec =&gt; 'base64';

           codec();    encode(...);    decode(...);

           use Badger::Class
               codecs =&gt; 'base64 storable';

           base64();   encode_base64(...);    decode_base64(...);
           storable(); encode_storable(...);  decode_storable(...);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A <u>codec</u> is an object responsible for encoding and decoding data.  This module implements a codec manager
       to locate, load and instantiate codec objects.

   <b>Using</b> <b>Codecs</b>
       First you need to load the "Badger::Codecs" module.

           use Badger::Codecs;

       It can be used in regular OO style by first creating a "Badger::Codecs" object and then calling methods
       on it.

           my $codecs  = Badger::Codecs-&gt;new();
           my $codec   = $codecs-&gt;codec('url');
           my $encoded = $codec-&gt;encode($original);
           my $decoded = $codec-&gt;decode($encoded);

       You can also call class methods directly.

           my $codec   = Badger::Codecs-&gt;codec('url');
           my $encoded = $codec-&gt;encode($original);
           my $decoded = $codec-&gt;decode($encoded);

       Or like this:

           my $encoded = Badger::Codecs-&gt;encode(url =&gt; $original);
           my $decoded = Badger::Codecs-&gt;decode(url =&gt; $encoded);

       These examples are the equivalent of:

           use Badger::Codec::URL;
           my $codec   = Badger::Codec::URL-&gt;new;
           my $encoded = $codec-&gt;encode($original);
           my $decoded = $codec-&gt;decode($encoded);

       "Badger::Codecs" will do its best to locate and load the correct codec module for you. It defines a
       module base path (containing "Badger::Codec" and "BadgerX::Codec" by default) to which the name of the
       requested codec is appended in various forms.

       It first tries the name exactly as specified.  If no corresponding codec module is found then it tries a
       capitalised version of the name, followed by an upper case version of the name.  So if you ask for a
       "foo" codec, then you'll get back a "Badger::Codec::foo", "Badger::Codec::Foo", "Badger::Codec::FOO" or
       an error will be thrown if none of these can be found.

       NOTE: the above paragaph is incorrect.  It now tries the capitalised version first to work around Apple's
       case-insensitive file system.  This is subject to change.

           my $codec = Badger::Codecs-&gt;code('url');
               # tries: Badger::Codec + url = Badger::Codec::url   # Nope
               # tries: Badger::Codec + Url = Badger::Codec::Url   # Nope
               # tries: Badger::Codec + URL = Badger::Codec::URL   # Yay!

   <b>Chained</b> <b>Codecs</b>
       Codecs can be chained together in sequence. Specify the names of the individual codes separated by "+"
       characters. Whitespace between the names and "+" is optional. The codec chain returned
       (Badger::Codec::Chain) behaves exactly like any other codec. The only difference being that it is apply
       several codecs in sequence.

           my $codec = Badger::Codecs-&gt;codec('storable+base64');
           $encoded = $codec-&gt;encode($data);       # encode storable then base64
           $decoded = $codec-&gt;decode($encoded);    # decode base64 then storable

       Note that the decoding process for a chain happens in reverse order to ensure that a round trip between
       <b>encode()</b> and <b>decode()</b> returns the original unencoded data.

   <b>Import</b> <b>Hooks</b>
       The "codec" and "codecs" import hooks can be used to load and define codec subroutines into another
       module.

           package My::Module;

           use Badger::Codecs
               codec =&gt; 'base64';

       The "codec" import hook defines a "codec()" subroutine which returns a reference to a codec object.  It
       also defined "encode()" and "decode()" subroutines which are mapped to the codec.

           # using the codec reference
           $encoded = codec-&gt;encode($original);
           $decoded = codec-&gt;decode($encoded);

           # using the encode/decode subs
           $encoded = encode($original);
           $decoded = decode($encoded);

       The "codecs" import hook allows you to define several codecs at once. A subroutine is generated to
       reference each codec, along with encoding and decoding subroutines.

           use Badger::Codecs
               codecs =&gt; 'base64 storable';

           # codec objects
           $encoded = base64-&gt;encode($original);
           $decoded = base64-&gt;decode($encoded);
           $encoded = storable-&gt;encode($original);
           $decoded = storable-&gt;decode($encoded);

           # imported subroutines
           $encoded = encode_base64($original);
           $decoded = decode_base64($encoded);
           $encoded = encode_storable($original);
           $decoded = decode_storable($encoded);

       You can define alternate names for codecs by providing a reference to a hash array.

           use Badger::Codecs
               codecs =&gt; {
                   text =&gt; 'base64',
                   data =&gt; 'storable+base64',
               };

           # codec objects
           $encoded = text-&gt;encode($original);
           $decoded = text-&gt;decode($encoded);
           $encoded = data-&gt;encode($original);
           $decoded = data-&gt;decode($encoded);

           # imported subroutines
           $encoded = encode_text($original);
           $decoded = decode_text($encoded);
           $encoded = encode_data($original);
           $decoded = decode_data($encoded);

</pre><h4><b>IMPORTABLE</b> <b>SUBROUTINES</b></h4><pre>
   <b>Codec()</b>
       This subroutine can be used as a shortcut to the codec method.

           use Badger::Codecs 'Codec';

           my $yaml = Codec('YAML');
           print $yaml-&gt;encode($some_data);

</pre><h4><b>METHODS</b></h4><pre>
   <b>new()</b>
       Constructor method to create a new "Badger::Codecs" object.

           my $codecs  = Badger::Codecs-&gt;new();
           my $encoded = $codecs-&gt;encode( url =&gt; $source );

       See "CONFIGURATION OPTIONS" for details of the configuration options that can be specified.

   <b>base(@modules)</b>
       The <b>base()</b> method can be used to set the base module path.  It can be called as an object or class
       method.

           # object method
           my $codecs = Badger::Codecs-&gt;new;
           $codecs-&gt;base('My::Codec');
           $codecs-&gt;encode( Foo =&gt; $data );            # My::Codec::Foo

           # class method
           Badger::Codecs-&gt;base('My::Codec');
           Badger::Codecs-&gt;encode( Foo =&gt; $data );     # My::Codec::Foo

       Multiple items can be specified as a list of arguments or by reference to a list.

           $codecs-&gt;base('Ferret::Codec', 'Stoat::Codec');
           $codecs-&gt;base(['Ferret::Codec', 'Stoat::Codec']);

   <b>codecs(\%new_codecs)</b>
       The <b>codecs()</b> method can be used to add specific codec mappings to the internal "codecs" lookup table.  It
       can be called as an object method or a class method.

           # object method
           $codecs-&gt;codecs(
               wam =&gt; 'Ferret::Codec::Wam',
               bam =&gt; 'Stoat::Codec::Bam',
           );
           my $codec = $codecs-&gt;codec('wam');          # Ferret::Codec::Wam

           # class method
           Badger::Codecs-&gt;codecs(
               wam =&gt; 'Ferret::Codec::Wam',
               bam =&gt; 'Stoat::Codec::Bam',
           );
           my $codec = Badger::Codecs-&gt;codec('bam');   # Stoat::Codec::Bam

   <b>codec($type,</b> <b>%config)</b>
       Creates and returns a "Badger::Codec" object for the specified $type.  Any additional arguments are
       forwarded to the codec's constructor method.

           my $codec   = Badger::Codecs-&gt;codec('storable');
           my $encoded = $codec-&gt;encode($original);
           my $decoded = $codec-&gt;decode($encoded);

       If the named codec cannot be found then an error is thrown.

   <b>chain($type,</b> <b>%config)</b>
       Creates a new Badger::Codec::Chain object to represent a chain of codecs.

   <b>encode($type,</b> <b>$data)</b>
       All-in-one method for encoding data via a particular codec.

           # class method
           Badger::Codecs-&gt;encode( url =&gt; $source );

           # object method
           my $codecs = Badger::Codecs-&gt;new();
           $codecs-&gt;encode( url =&gt; $source );

   <b>decode($type,</b> <b>$data)</b>
       All-in-one method for decoding data via a particular codec.

           # class method
           Badger::Codecs-&gt;decode( url =&gt; $encoded );

           # object method
           my $codecs = Badger::Codecs-&gt;new();
           $codecs-&gt;decode( url =&gt; $encoded );

   <b>export_codec($package,$name,$alias)</b>
       Loads a single codec identified by $name and exports the "codec", "encode" and "decode" functions into
       the $package namespace.

           package Your::Module;
           use Badger::Codecs;
           Badger::Codecs-&gt;export_code('Your::Module', 'base64');

           # base64() returns the codec
           base64-&gt;encode($data);
           base64-&gt;decode($data)

           # encode() and decode() are shortcuts
           encode($data)
           decode($data);

       An $alias can be provided which will be used instead of "codec" and appended to the names of the "encode"
       and "decode" functions.

           package Your::Module;
           use Badger::Codecs;
           Badger::Codecs-&gt;export_codec('Your::Module', 'base64', 'munger');

           # munged() returns the codec
           munger-&gt;encode($data);
           munger-&gt;decode($data)

           # encode_munger() and decode_munger() are shortcuts
           encode_munger($data)
           decode_munger($data);

   <b>export_codecs($package,$names)</b>
       Loads and exports multiple codecs into $package. The codec $names can be specified as a a string of
       whitespace delimited codec names, a reference to a list of codec names, or a reference to a hash array
       mapping codec names to aliases (see <b>export_codec()</b>).

           Badger::Codecs-&gt;export_codecs('Your::Module', 'base64 storable');
           Badger::Codecs-&gt;export_codecs('Your::Module', ['base64', 'storable']);
           Badger::Codecs-&gt;export_codecs('Your::Module', {
               base64   =&gt; 'alias_for_base64',
               storable =&gt; 'alias_for_storage',
           });

   <b>load($name)</b>
       Loads a codec module identified by the $name argument.  Returns the name of the module implementing the
       codec.

           print Badger::Codecs-&gt;load('base64');       # Badger::Codec::Base64

   <b>found($name,$codec)</b>
       This is an internal method called by the base class Badger::Factory module when a codec is located and
       loaded.

   <b>found_object($name,$codec)</b>
       This is an internal method called by the base class Badger::Factory module when a cached codec object is
       found.

   <b>result($name,$codec,\@args)</b>
       This is an internal method called by the base class Badger::Factory module to return a final result for
       the requested code.  This method caches the codec object if no configuration arguments were provided.

</pre><h4><b>CONFIGURATION</b> <b>OPTIONS</b></h4><pre>
   <b>path</b>
       This option can be used to specify the name(s) of one or more modules which define a search path for
       codec modules. The default path contains "Badger::Codec" and "BadgerX::Codec".

           my $codecs = Badger::Codecs-&gt;new(
               path =&gt; 'My::Codec'
           );
           my $codec = $codecs-&gt;codec('Foo');      # My::Codec::Foo

       Multiple paths can be specified using a reference to a list.

           my $codecs = Badger::Codecs-&gt;new(
               path =&gt; ['My::Codec', 'Badger::Codec'],
           );
           my $codec = $codecs-&gt;codec('Bar');      # either My::Codec::Bar
                                                   # or Badger::Codec::Bar

   <b>codecs</b>
       The "codecs" configuration option can be used to define specific codec mappings to bypass the automagical
       name grokking mechanism.

           my $codecs = Badger::Codecs-&gt;new(
               codecs =&gt; {
                   foo =&gt; 'Ferret::Codec::Foo',
                   bar =&gt; 'Stoat::Codec::Bar',
               },
           );
           my $codec = $codecs-&gt;codec('foo');      # Ferret::Codec::Foo

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley &lt;<a href="http://wardley.org/">http://wardley.org/</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2005-2009 Andy Wardley. All rights reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2023-08-28                                <u>Badger::<a href="../man3pm/Codecs.3pm.html">Codecs</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>