<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>opus_decoder - Opus Decoder</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libopus-doc">libopus-doc_1.5.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       opus_decoder - Opus Decoder

        - This page describes the process and functions used to decode Opus.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Typedefs</b>
       typedef struct <b>OpusDecoder</b> <b>OpusDecoder</b>
           Opus decoder state.
       typedef struct <b>OpusDREDDecoder</b> <b>OpusDREDDecoder</b>
           Opus DRED decoder.
       typedef struct <b>OpusDRED</b> <b>OpusDRED</b>
           Opus DRED state.

   <b>Functions</b>
       int <b>opus_decoder_get_size</b> (int channels)
           Gets the size of an OpusDecoder structure.
       <b>OpusDecoder</b> * <b>opus_decoder_create</b> (<b>opus_int32</b> Fs, int channels, int *error)
           Allocates and initializes a decoder state.
       int <b>opus_decoder_init</b> (<b>OpusDecoder</b> *st, <b>opus_int32</b> Fs, int channels)
           Initializes a previously allocated decoder state.
       int <b>opus_decode</b> (<b>OpusDecoder</b> *st, const unsigned char *data, <b>opus_int32</b> len, <b>opus_int16</b> *pcm, int
           frame_size, int decode_fec)
           Decode an Opus packet.
       int <b>opus_decode_float</b> (<b>OpusDecoder</b> *st, const unsigned char *data, <b>opus_int32</b> len, float *pcm, int
           frame_size, int decode_fec)
           Decode an Opus packet with floating point output.
       int <b>opus_decoder_ctl</b> (<b>OpusDecoder</b> *st, int request,...)
           Perform a CTL function on an Opus decoder.
       void <b>opus_decoder_destroy</b> (<b>OpusDecoder</b> *st)
           Frees an OpusDecoder allocated by <b>opus_decoder_create()</b>.
       int <b>opus_dred_decoder_get_size</b> (void)
           Gets the size of an OpusDREDDecoder structure.
       <b>OpusDREDDecoder</b> * <b>opus_dred_decoder_create</b> (int *error)
           Allocates and initializes an OpusDREDDecoder state.
       int <b>opus_dred_decoder_init</b> (<b>OpusDREDDecoder</b> *dec)
           Initializes an OpusDREDDecoder state.
       void <b>opus_dred_decoder_destroy</b> (<b>OpusDREDDecoder</b> *dec)
           Frees an OpusDREDDecoder allocated by <b>opus_dred_decoder_create()</b>.
       int <b>opus_dred_decoder_ctl</b> (<b>OpusDREDDecoder</b> *dred_dec, int request,...)
           Perform a CTL function on an Opus DRED decoder.
       int <b>opus_dred_get_size</b> (void)
           Gets the size of an OpusDRED structure.
       <b>OpusDRED</b> * <b>opus_dred_alloc</b> (int *error)
           Allocates and initializes a DRED state.
       void <b>opus_dred_free</b> (<b>OpusDRED</b> *dec)
           Frees an OpusDRED allocated by opus_dred_create().
       int <b>opus_dred_parse</b> (<b>OpusDREDDecoder</b> *dred_dec, <b>OpusDRED</b> *dred, const unsigned char *data, <b>opus_int32</b>
           len, <b>opus_int32</b> max_dred_samples, <b>opus_int32</b> sampling_rate, int *dred_end, int defer_processing)
           Decode an Opus DRED packet.
       int <b>opus_dred_process</b> (<b>OpusDREDDecoder</b> *dred_dec, const <b>OpusDRED</b> *src, <b>OpusDRED</b> *dst)
           Finish decoding an Opus DRED packet.
       int <b>opus_decoder_dred_decode</b> (<b>OpusDecoder</b> *st, const <b>OpusDRED</b> *dred, <b>opus_int32</b> dred_offset, <b>opus_int16</b>
           *pcm, <b>opus_int32</b> frame_size)
           Decode audio from an Opus DRED packet with floating point output.
       int <b>opus_decoder_dred_decode_float</b> (<b>OpusDecoder</b> *st, const <b>OpusDRED</b> *dred, <b>opus_int32</b> dred_offset, float
           *pcm, <b>opus_int32</b> frame_size)
           Decode audio from an Opus DRED packet with floating point output.
       int <b>opus_packet_parse</b> (const unsigned char *data, <b>opus_int32</b> len, unsigned char *out_toc, const unsigned
           char *frames[48], <b>opus_int16</b> size[48], int *payload_offset)
           Parse an opus packet into one or more frames.
       int <b>opus_packet_get_bandwidth</b> (const unsigned char *data)
           Gets the bandwidth of an Opus packet.
       int <b>opus_packet_get_samples_per_frame</b> (const unsigned char *data, <b>opus_int32</b> Fs)
           Gets the number of samples per frame from an Opus packet.
       int <b>opus_packet_get_nb_channels</b> (const unsigned char *data)
           Gets the number of channels from an Opus packet.
       int <b>opus_packet_get_nb_frames</b> (const unsigned char packet[], <b>opus_int32</b> len)
           Gets the number of frames in an Opus packet.
       int <b>opus_packet_get_nb_samples</b> (const unsigned char packet[], <b>opus_int32</b> len, <b>opus_int32</b> Fs)
           Gets the number of samples of an Opus packet.
       int <b>opus_packet_has_lbrr</b> (const unsigned char packet[], <b>opus_int32</b> len)
           Checks whether an Opus packet has LBRR.
       int <b>opus_decoder_get_nb_samples</b> (const <b>OpusDecoder</b> *dec, const unsigned char packet[], <b>opus_int32</b> len)
           Gets the number of samples of an Opus packet.
       void <b>opus_pcm_soft_clip</b> (float *pcm, int frame_size, int channels, float *softclip_mem)
           Applies soft-clipping to bring a float signal within the [-1,1] range.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       This page describes the process and functions used to decode Opus.

       The decoding process also starts with creating a decoder state. This can be done with:

       int          error;
       OpusDecoder *dec;
       dec = opus_decoder_create(Fs, channels, &amp;error);

        where
       •
        Fs is the sampling rate and must be 8000, 12000, 16000, 24000, or 48000
       •
        channels is the number of channels (1 or 2)
       •
        error will hold the error code in case of failure (or <b>OPUS_OK</b> on success)
       •
        the return value is a newly created decoder state to be used for decoding
       While  <b>opus_decoder_create()</b>  allocates  memory  for  the  state,  it's  also possible to initialize pre-
       allocated memory:
       int          size;
       int          error;
       OpusDecoder *dec;
       size = opus_decoder_get_size(channels);
       dec = malloc(size);
       error = opus_decoder_init(dec, Fs, channels);

        where <b>opus_decoder_get_size()</b> returns the required size for the decoder state. Note that future versions
       of this code may change the size, so no assumptions should be made about it.
       The decoder state is always continuous in memory and only a shallow copy is sufficient to copy  it  (e.g.
       memcpy())
       To  decode a frame, <b>opus_decode()</b> or <b>opus_decode_float()</b> must be called with a packet of compressed audio
       data:
       frame_size = opus_decode(dec, packet, len, decoded, max_size, 0);

        where
       •
        packet is the byte array containing the compressed data
       •
        len is the exact number of bytes contained in the packet
       •
        decoded is the decoded audio data in opus_int16 (or float for <b>opus_decode_float()</b>)
       •
        max_size is the max duration of the frame in samples (per channel) that can fit into  the  decoded_frame
        array
       <b>opus_decode()</b> and <b>opus_decode_float()</b> return the number of samples (per channel) decoded from the packet.
       If  that  value  is negative, then an error has occurred. This can occur if the packet is corrupted or if
       the audio buffer is too small to hold the decoded audio.
       Opus is a stateful codec with overlapping blocks and as a result Opus packets are not coded independently
       of each other. Packets must be passed into the decoder serially and in the correct order  for  a  correct
       decode. Lost packets can be replaced with loss concealment by calling the decoder with a null pointer and
       zero length for the missing packet.
       A single codec state may only be accessed from a single thread at a time and any required locking must be
       performed by the caller. Separate streams must be decoded with separate decoder states and can be decoded
       in parallel unless the library was compiled with NONTHREADSAFE_PSEUDOSTACK defined.
</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>struct</b> <b>OpusDecoder</b> <b>OpusDecoder</b>
       Opus  decoder  state. This contains the complete state of an Opus decoder. It is position independent and
       can be freely copied.
       <b>See</b> <b>also</b>
           <b>opus_decoder_create</b>,<b>opus_decoder_init</b>
   <b>typedef</b> <b>struct</b> <b>OpusDRED</b> <b>OpusDRED</b>
       Opus DRED state. This contains the complete state of an Opus DRED packet. It is position independent  and
       can be freely copied.
       <b>See</b> <b>also</b>
           opus_dred_create,opus_dred_init
   <b>typedef</b> <b>struct</b> <b>OpusDREDDecoder</b> <b>OpusDREDDecoder</b>
       Opus  DRED  decoder. This contains the complete state of an Opus DRED decoder. It is position independent
       and can be freely copied.
       <b>See</b> <b>also</b>
           <b>opus_dred_decoder_create</b>,<b>opus_dred_decoder_init</b>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>int</b> <b>opus_decode</b> <b>(OpusDecoder</b> <b>*</b> <b>st,</b> <b>const</b> <b>unsigned</b>  <b>char</b>  <b>*</b>  <b>data,</b>  <b>opus_int32</b>  <b>len,</b>  <b>opus_int16</b>  <b>*</b>  <b>pcm,</b>  <b>int</b>
       <b>frame_size,</b> <b>int</b> <b>decode_fec)</b>
       Decode an Opus packet.
       <b>Parameters</b>
           <u>st</u> OpusDecoder*: Decoder state
           <u>data</u> char*: Input payload. Use a NULL pointer to indicate packet loss
           <u>len</u> opus_int32: Number of bytes in payload*
           <u>pcm</u>     opus_int16*:     Output     signal     (interleaved     if    2    channels).    length    is
           frame_size*channels*sizeof(opus_int16)
           <u>frame_size</u> Number of samples per channel of available space in <u>pcm</u>. If this is less than the  maximum
           packet  duration (120ms; 5760 for 48kHz), this function will not be capable of decoding some packets.
           In the case of PLC (data==NULL) or FEC (decode_fec=1),  then  frame_size  needs  to  be  exactly  the
           duration  of  audio that is missing, otherwise the decoder will not be in the optimal state to decode
           the next incoming packet. For the PLC and FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.
           <u>decode_fec</u> int: Flag (0 or 1) to request that any in-band forward error correction data  be  decoded.
           If no such data is available, the frame is decoded as if it were lost.
       <b>Returns</b>
           Number of decoded samples or <b>Error</b> <b>codes</b>
   <b>int</b>  <b>opus_decode_float</b>  <b>(OpusDecoder</b>  <b>*</b>  <b>st,</b>  <b>const</b>  <b>unsigned</b>  <b>char</b>  <b>*</b> <b>data,</b> <b>opus_int32</b> <b>len,</b> <b>float</b> <b>*</b> <b>pcm,</b> <b>int</b>
       <b>frame_size,</b> <b>int</b> <b>decode_fec)</b>
       Decode an Opus packet with floating point output.
       <b>Parameters</b>
           <u>st</u> OpusDecoder*: Decoder state
           <u>data</u> char*: Input payload. Use a NULL pointer to indicate packet loss
           <u>len</u> opus_int32: Number of bytes in payload
           <u>pcm</u> float*: Output signal (interleaved if 2 channels). length is frame_size*channels*sizeof(float)
           <u>frame_size</u> Number of samples per channel of available space in <u>pcm</u>. If this is less than the  maximum
           packet  duration (120ms; 5760 for 48kHz), this function will not be capable of decoding some packets.
           In the case of PLC (data==NULL) or FEC (decode_fec=1),  then  frame_size  needs  to  be  exactly  the
           duration  of  audio that is missing, otherwise the decoder will not be in the optimal state to decode
           the next incoming packet. For the PLC and FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.
           <u>decode_fec</u> int: Flag (0 or 1) to request that any in-band forward error correction data  be  decoded.
           If no such data is available the frame is decoded as if it were lost.
       <b>Returns</b>
           Number of decoded samples or <b>Error</b> <b>codes</b>
   <b>OpusDecoder</b> <b>*</b> <b>opus_decoder_create</b> <b>(opus_int32</b> <b>Fs,</b> <b>int</b> <b>channels,</b> <b>int</b> <b>*</b> <b>error)</b>
       Allocates and initializes a decoder state.
       <b>Parameters</b>
           <u>Fs</u>  opus_int32:  Sample  rate  to  decode  at (Hz). This must be one of 8000, 12000, 16000, 24000, or
           48000.
           <u>channels</u> int: Number of channels (1 or 2) to decode
           <u>error</u> int*: <b>OPUS_OK</b> Success or <b>Error</b> <b>codes</b>
       Internally Opus stores data at 48000 Hz, so that should be the default value for Fs. However, the decoder
       can efficiently decode to buffers at 8, 12, 16, and 24 kHz so if for some reason the  caller  cannot  use
       data  at  the full sample rate, or knows the compressed data doesn't use the full frequency range, it can
       request decoding at a reduced rate. Likewise, the decoder  is  capable  of  filling  in  either  mono  or
       interleaved stereo pcm buffers, at the caller's request.
   <b>int</b> <b>opus_decoder_ctl</b> <b>(OpusDecoder</b> <b>*</b> <b>st,</b> <b>int</b> <b>request,</b>  <b>...)</b>
       Perform  a  CTL function on an Opus decoder. Generally the request and subsequent arguments are generated
       by a convenience macro.
       <b>Parameters</b>
           <u>st</u> OpusDecoder*: Decoder state.
           <u>request</u> This and all remaining parameters should be replaced by one  of  the  convenience  macros  in
           <b>Generic</b> <b>CTLs</b> or <b>Decoder</b> <b>related</b> <b>CTLs</b>.
       <b>See</b> <b>also</b>
           <b>Generic</b> <b>CTLs</b>
           <b>Decoder</b> <b>related</b> <b>CTLs</b>
   <b>void</b> <b>opus_decoder_destroy</b> <b>(OpusDecoder</b> <b>*</b> <b>st)</b>
       Frees an OpusDecoder allocated by <b>opus_decoder_create()</b>.
       <b>Parameters</b>
           <u>st</u> OpusDecoder*: State to be freed.
   <b>int</b>  <b>opus_decoder_dred_decode</b>  <b>(OpusDecoder</b> <b>*</b> <b>st,</b> <b>const</b> <b>OpusDRED</b> <b>*</b> <b>dred,</b> <b>opus_int32</b> <b>dred_offset,</b> <b>opus_int16</b> <b>*</b>
       <b>pcm,</b> <b>opus_int32</b> <b>frame_size)</b>
       Decode audio from an Opus DRED packet with floating point output.
       <b>Parameters</b>
           <u>st</u> OpusDecoder*: Decoder state
           <u>dred</u> OpusDRED*: DRED state
           <u>dred_offset</u> opus_int32: position of the redundancy to decode (in samples before the beginning of  the
           real audio data in the packet).
           <u>pcm</u>     opus_int16*:     Output     signal     (interleaved     if    2    channels).    length    is
           frame_size*channels*sizeof(opus_int16)
           <u>frame_size</u> Number of samples per channel to decode in <u>pcm</u>. frame_size <b>must</b> be a multiple of 2.5 ms.
       <b>Returns</b>
           Number of decoded samples or <b>Error</b> <b>codes</b>
   <b>int</b> <b>opus_decoder_dred_decode_float</b> <b>(OpusDecoder</b> <b>*</b> <b>st,</b> <b>const</b> <b>OpusDRED</b> <b>*</b> <b>dred,</b> <b>opus_int32</b> <b>dred_offset,</b> <b>float</b>  <b>*</b>
       <b>pcm,</b> <b>opus_int32</b> <b>frame_size)</b>
       Decode audio from an Opus DRED packet with floating point output.
       <b>Parameters</b>
           <u>st</u> OpusDecoder*: Decoder state
           <u>dred</u> OpusDRED*: DRED state
           <u>dred_offset</u>  opus_int32: position of the redundancy to decode (in samples before the beginning of the
           real audio data in the packet).
           <u>pcm</u> float*: Output signal (interleaved if 2 channels). length is frame_size*channels*sizeof(float)
           <u>frame_size</u> Number of samples per channel to decode in <u>pcm</u>. frame_size <b>must</b> be a multiple of 2.5 ms.
       <b>Returns</b>
           Number of decoded samples or <b>Error</b> <b>codes</b>
   <b>int</b> <b>opus_decoder_get_nb_samples</b> <b>(const</b> <b>OpusDecoder</b> <b>*</b> <b>dec,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>packet[],</b> <b>opus_int32</b> <b>len)</b>
       Gets the number of samples of an Opus packet.
       <b>Parameters</b>
           <u>dec</u> OpusDecoder*: Decoder state
           <u>packet</u> char*: Opus packet
           <u>len</u> opus_int32: Length of packet
       <b>Returns</b>
           Number of samples
       <b>Return</b> <b>values</b>
           <u>OPUS_BAD_ARG</u> Insufficient data was passed to the function
           <u>OPUS_INVALID_PACKET</u> The compressed data passed is corrupted or of an unsupported type
   <b>int</b> <b>opus_decoder_get_size</b> <b>(int</b> <b>channels)</b>
       Gets the size of an OpusDecoder structure.
       <b>Parameters</b>
           <u>channels</u> int: Number of channels. This must be 1 or 2.
       <b>Returns</b>
           The size in bytes.
   <b>int</b> <b>opus_decoder_init</b> <b>(OpusDecoder</b> <b>*</b> <b>st,</b> <b>opus_int32</b> <b>Fs,</b> <b>int</b> <b>channels)</b>
       Initializes a previously allocated decoder state. The state  must  be  at  least  the  size  returned  by
       <b>opus_decoder_get_size()</b>.  This  is  intended  for  applications  which use their own allocator instead of
       malloc.
       <b>See</b> <b>also</b>
           <b>opus_decoder_create</b>,<b>opus_decoder_get_size</b>  To  reset  a  previously  initialized   state,   use   the
           <b>OPUS_RESET_STATE</b> CTL.
       <b>Parameters</b>
           <u>st</u> OpusDecoder*: Decoder state.
           <u>Fs</u>  opus_int32:  Sampling  rate  to decode to (Hz). This must be one of 8000, 12000, 16000, 24000, or
           48000.
           <u>channels</u> int: Number of channels (1 or 2) to decode
       <b>Return</b> <b>values</b>
           <b>OPUS_OK</b> <b>Success</b> <b>or</b> <b>Error</b> <b>codes</b>
   <b>OpusDRED</b> <b>*</b> <b>opus_dred_alloc</b> <b>(int</b> <b>*</b> <b>error)</b>
       Allocates and initializes a DRED state.
       <b>Parameters</b>
           <u>error</u> int*: <b>OPUS_OK</b> Success or <b>Error</b> <b>codes</b>
   <b>OpusDREDDecoder</b> <b>*</b> <b>opus_dred_decoder_create</b> <b>(int</b> <b>*</b> <b>error)</b>
       Allocates and initializes an OpusDREDDecoder state.
       <b>Parameters</b>
           <u>error</u> int*: <b>OPUS_OK</b> Success or <b>Error</b> <b>codes</b>
   <b>int</b> <b>opus_dred_decoder_ctl</b> <b>(OpusDREDDecoder</b> <b>*</b> <b>dred_dec,</b> <b>int</b> <b>request,</b>  <b>...)</b>
       Perform a CTL function on an Opus DRED decoder.  Generally  the  request  and  subsequent  arguments  are
       generated by a convenience macro.
       <b>Parameters</b>
           <u>dred_dec</u> OpusDREDDecoder*: DRED Decoder state.
           <u>request</u>  This  and  all  remaining  parameters should be replaced by one of the convenience macros in
           <b>Generic</b> <b>CTLs</b> or <b>Decoder</b> <b>related</b> <b>CTLs</b>.
       <b>See</b> <b>also</b>
           <b>Generic</b> <b>CTLs</b>
           <b>Decoder</b> <b>related</b> <b>CTLs</b>
   <b>void</b> <b>opus_dred_decoder_destroy</b> <b>(OpusDREDDecoder</b> <b>*</b> <b>dec)</b>
       Frees an OpusDREDDecoder allocated by <b>opus_dred_decoder_create()</b>.
       <b>Parameters</b>
           <u>dec</u> OpusDREDDecoder*: State to be freed.
   <b>int</b> <b>opus_dred_decoder_get_size</b> <b>(void)</b>
       Gets the size of an OpusDREDDecoder structure.
       <b>Returns</b>
           The size in bytes.
   <b>int</b> <b>opus_dred_decoder_init</b> <b>(OpusDREDDecoder</b> <b>*</b> <b>dec)</b>
       Initializes an OpusDREDDecoder state.
       <b>Parameters</b>
           <u>dec</u> OpusDREDDecoder*: State to be initialized.
   <b>void</b> <b>opus_dred_free</b> <b>(OpusDRED</b> <b>*</b> <b>dec)</b>
       Frees an OpusDRED allocated by opus_dred_create().
       <b>Parameters</b>
           <u>dec</u> OpusDRED*: State to be freed.
   <b>int</b> <b>opus_dred_get_size</b> <b>(void)</b>
       Gets the size of an OpusDRED structure.
       <b>Returns</b>
           The size in bytes.
   <b>int</b> <b>opus_dred_parse</b> <b>(OpusDREDDecoder</b> <b>*</b> <b>dred_dec,</b> <b>OpusDRED</b> <b>*</b> <b>dred,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>data,</b> <b>opus_int32</b> <b>len,</b>
       <b>opus_int32</b> <b>max_dred_samples,</b> <b>opus_int32</b> <b>sampling_rate,</b> <b>int</b> <b>*</b> <b>dred_end,</b> <b>int</b> <b>defer_processing)</b>
       Decode an Opus DRED packet.
       <b>Parameters</b>
           <u>dred_dec</u> OpusDRED*: DRED Decoder state
           <u>dred</u> OpusDRED*: DRED state
           <u>data</u> char*: Input payload
           <u>len</u> opus_int32: Number of bytes in payload
           <u>max_dred_samples</u> opus_int32: Maximum number of DRED samples that may be needed (if available  in  the
           packet).
           <u>sampling_rate</u>  opus_int32:  Sampling  rate  used  for  max_dred_samples argument. Needs not match the
           actual sampling rate of the decoder.
           <u>dred_end</u> opus_int32*: Number of non-encoded (silence) samples between the DRED timestamp and the last
           DRED sample.
           <u>defer_processing</u> int: Flag (0 or 1). If set to one, the CPU-intensive part of the  DRED  decoding  is
           deferred until <b>opus_dred_process()</b> is called.
       <b>Returns</b>
           Offset (positive) of the first decoded DRED samples, zero if no DRED is present, or <b>Error</b> <b>codes</b>
   <b>int</b> <b>opus_dred_process</b> <b>(OpusDREDDecoder</b> <b>*</b> <b>dred_dec,</b> <b>const</b> <b>OpusDRED</b> <b>*</b> <b>src,</b> <b>OpusDRED</b> <b>*</b> <b>dst)</b>
       Finish decoding an Opus DRED packet. The function only needs to be called if <b>opus_dred_parse()</b> was called
       with defer_processing=1. The source and destination will often be the same DRED state.
       <b>Parameters</b>
           <u>dred_dec</u> OpusDRED*: DRED Decoder state
           <u>src</u> OpusDRED*: Source DRED state to start the processing from.
           <u>dst</u> OpusDRED*: Destination DRED state to store the updated state after processing.
       <b>Returns</b>
           <b>Error</b> <b>codes</b>
   <b>int</b> <b>opus_packet_get_bandwidth</b> <b>(const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>data)</b>
       Gets the bandwidth of an Opus packet.
       <b>Parameters</b>
           <u>data</u> char*: Opus packet
       <b>Return</b> <b>values</b>
           <u>OPUS_BANDWIDTH_NARROWBAND</u> Narrowband (4kHz bandpass)
           <u>OPUS_BANDWIDTH_MEDIUMBAND</u> Mediumband (6kHz bandpass)
           <u>OPUS_BANDWIDTH_WIDEBAND</u> Wideband (8kHz bandpass)
           <u>OPUS_BANDWIDTH_SUPERWIDEBAND</u> Superwideband (12kHz bandpass)
           <u>OPUS_BANDWIDTH_FULLBAND</u> Fullband (20kHz bandpass)
           <u>OPUS_INVALID_PACKET</u> The compressed data passed is corrupted or of an unsupported type
   <b>int</b> <b>opus_packet_get_nb_channels</b> <b>(const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>data)</b>
       Gets the number of channels from an Opus packet.
       <b>Parameters</b>
           <u>data</u> char*: Opus packet
       <b>Returns</b>
           Number of channels
       <b>Return</b> <b>values</b>
           <u>OPUS_INVALID_PACKET</u> The compressed data passed is corrupted or of an unsupported type
   <b>int</b> <b>opus_packet_get_nb_frames</b> <b>(const</b> <b>unsigned</b> <b>char</b> <b>packet[],</b> <b>opus_int32</b> <b>len)</b>
       Gets the number of frames in an Opus packet.
       <b>Parameters</b>
           <u>packet</u> char*: Opus packet
           <u>len</u> opus_int32: Length of packet
       <b>Returns</b>
           Number of frames
       <b>Return</b> <b>values</b>
           <u>OPUS_BAD_ARG</u> Insufficient data was passed to the function
           <u>OPUS_INVALID_PACKET</u> The compressed data passed is corrupted or of an unsupported type
   <b>int</b> <b>opus_packet_get_nb_samples</b> <b>(const</b> <b>unsigned</b> <b>char</b> <b>packet[],</b> <b>opus_int32</b> <b>len,</b> <b>opus_int32</b> <b>Fs)</b>
       Gets the number of samples of an Opus packet.
       <b>Parameters</b>
           <u>packet</u> char*: Opus packet
           <u>len</u> opus_int32: Length of packet
           <u>Fs</u>  opus_int32:  Sampling  rate  in Hz. This must be a multiple of 400, or inaccurate results will be
           returned.
       <b>Returns</b>
           Number of samples
       <b>Return</b> <b>values</b>
           <u>OPUS_BAD_ARG</u> Insufficient data was passed to the function
           <u>OPUS_INVALID_PACKET</u> The compressed data passed is corrupted or of an unsupported type
   <b>int</b> <b>opus_packet_get_samples_per_frame</b> <b>(const</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>data,</b> <b>opus_int32</b> <b>Fs)</b>
       Gets the number of samples per frame from an Opus packet.
       <b>Parameters</b>
           <u>data</u> char*: Opus packet. This must contain at least one byte of data.
           <u>Fs</u> opus_int32: Sampling rate in Hz. This must be a multiple of 400, or  inaccurate  results  will  be
           returned.
       <b>Returns</b>
           Number of samples per frame.
   <b>int</b> <b>opus_packet_has_lbrr</b> <b>(const</b> <b>unsigned</b> <b>char</b> <b>packet[],</b> <b>opus_int32</b> <b>len)</b>
       Checks whether an Opus packet has LBRR.
       <b>Parameters</b>
           <u>packet</u> char*: Opus packet
           <u>len</u> opus_int32: Length of packet
       <b>Returns</b>
           1 is LBRR is present, 0 otherwise
       <b>Return</b> <b>values</b>
           <u>OPUS_INVALID_PACKET</u> The compressed data passed is corrupted or of an unsupported type
   <b>int</b>  <b>opus_packet_parse</b>  <b>(const</b>  <b>unsigned</b> <b>char</b> <b>*</b> <b>data,</b> <b>opus_int32</b> <b>len,</b> <b>unsigned</b> <b>char</b> <b>*</b> <b>out_toc,</b> <b>const</b> <b>unsigned</b>
       <b>char</b> <b>*</b> <b>frames[48],</b> <b>opus_int16</b> <b>size[48],</b> <b>int</b> <b>*</b> <b>payload_offset)</b>
       Parse an opus packet into one or more frames. Opus_decode will perform this operation internally so  most
       applications  do  not  need  to  use  this function. This function does not copy the frames, the returned
       pointers are pointers into the input packet.
       <b>Parameters</b>
           <u>data</u> char*: Opus packet to be parsed
           <u>len</u> opus_int32: size of data
           <u>out_toc</u> char*: TOC pointer
           <u>frames</u> char*[48] encapsulated frames
           <u>size</u> opus_int16[48] sizes of the encapsulated frames
           <u>payload_offset</u> int*: returns the position of the payload within the packet (in bytes)
       <b>Returns</b>
           number of frames
   <b>void</b> <b>opus_pcm_soft_clip</b> <b>(float</b> <b>*</b> <b>pcm,</b> <b>int</b> <b>frame_size,</b> <b>int</b> <b>channels,</b> <b>float</b> <b>*</b> <b>softclip_mem)</b>
       Applies soft-clipping to bring a float signal within the [-1,1] range. If the signal is already  in  that
       range,  nothing is done. If there are values outside of [-1,1], then the signal is clipped as smoothly as
       possible to both fit in the range and avoid creating excessive distortion in the process.
       <b>Parameters</b>
           <u>pcm</u> float*: Input PCM and modified PCM
           <u>frame_size</u> int Number of samples per channel to process
           <u>channels</u> int: Number of channels
           <u>softclip_mem</u> float*: State memory for the soft clipping process (one float per  channel,  initialized
           to zero)
</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for Opus from the source code.

Version 1.5.2                                Wed Jul 3 2024 11:41:33                             <u><a href="../man3/opus_decoder.3.html">opus_decoder</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>