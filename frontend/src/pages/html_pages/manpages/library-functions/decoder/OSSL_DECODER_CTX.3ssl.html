<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSSL_DECODER_CTX, OSSL_DECODER_CTX_new, OSSL_DECODER_settable_ctx_params, OSSL_DECODER_CTX_set_params,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       OSSL_DECODER_CTX, OSSL_DECODER_CTX_new, OSSL_DECODER_settable_ctx_params, OSSL_DECODER_CTX_set_params,
       OSSL_DECODER_CTX_free, OSSL_DECODER_CTX_set_selection, OSSL_DECODER_CTX_set_input_type,
       OSSL_DECODER_CTX_set_input_structure, OSSL_DECODER_CTX_add_decoder, OSSL_DECODER_CTX_add_extra,
       OSSL_DECODER_CTX_get_num_decoders, OSSL_DECODER_INSTANCE, OSSL_DECODER_CONSTRUCT, OSSL_DECODER_CLEANUP,
       OSSL_DECODER_CTX_set_construct, OSSL_DECODER_CTX_set_construct_data, OSSL_DECODER_CTX_set_cleanup,
       OSSL_DECODER_CTX_get_construct, OSSL_DECODER_CTX_get_construct_data, OSSL_DECODER_CTX_get_cleanup,
       OSSL_DECODER_export, OSSL_DECODER_INSTANCE_get_decoder, OSSL_DECODER_INSTANCE_get_decoder_ctx,
       OSSL_DECODER_INSTANCE_get_input_type, OSSL_DECODER_INSTANCE_get_input_structure - Decoder context
       routines

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/decoder.h&gt;

        typedef struct ossl_decoder_ctx_st OSSL_DECODER_CTX;

        OSSL_DECODER_CTX *OSSL_DECODER_CTX_new(void);
        const OSSL_PARAM *OSSL_DECODER_settable_ctx_params(OSSL_DECODER *decoder);
        int OSSL_DECODER_CTX_set_params(OSSL_DECODER_CTX *ctx,
                                        const OSSL_PARAM params[]);
        void OSSL_DECODER_CTX_free(OSSL_DECODER_CTX *ctx);

        int OSSL_DECODER_CTX_set_selection(OSSL_DECODER_CTX *ctx, int selection);
        int OSSL_DECODER_CTX_set_input_type(OSSL_DECODER_CTX *ctx,
                                            const char *input_type);
        int OSSL_DECODER_CTX_set_input_structure(OSSL_DECODER_CTX *ctx,
                                                 const char *input_structure);
        int OSSL_DECODER_CTX_add_decoder(OSSL_DECODER_CTX *ctx, OSSL_DECODER *decoder);
        int OSSL_DECODER_CTX_add_extra(OSSL_DECODER_CTX *ctx,
                                       OSSL_LIB_CTX *libctx,
                                       const char *propq);
        int OSSL_DECODER_CTX_get_num_decoders(OSSL_DECODER_CTX *ctx);

        typedef struct ossl_decoder_instance_st OSSL_DECODER_INSTANCE;
        OSSL_DECODER *
        OSSL_DECODER_INSTANCE_get_decoder(OSSL_DECODER_INSTANCE *decoder_inst);
        void *
        OSSL_DECODER_INSTANCE_get_decoder_ctx(OSSL_DECODER_INSTANCE *decoder_inst);
        const char *
        OSSL_DECODER_INSTANCE_get_input_type(OSSL_DECODER_INSTANCE *decoder_inst);
        OSSL_DECODER_INSTANCE_get_input_structure(OSSL_DECODER_INSTANCE *decoder_inst,
                                                  int *was_set);

        typedef int OSSL_DECODER_CONSTRUCT(OSSL_DECODER_INSTANCE *decoder_inst,
                                           const OSSL_PARAM *object,
                                           void *construct_data);
        typedef void OSSL_DECODER_CLEANUP(void *construct_data);

        int OSSL_DECODER_CTX_set_construct(OSSL_DECODER_CTX *ctx,
                                           OSSL_DECODER_CONSTRUCT *construct);
        int OSSL_DECODER_CTX_set_construct_data(OSSL_DECODER_CTX *ctx,
                                                void *construct_data);
        int OSSL_DECODER_CTX_set_cleanup(OSSL_DECODER_CTX *ctx,
                                         OSSL_DECODER_CLEANUP *cleanup);
        OSSL_DECODER_CONSTRUCT *OSSL_DECODER_CTX_get_construct(OSSL_DECODER_CTX *ctx);
        void *OSSL_DECODER_CTX_get_construct_data(OSSL_DECODER_CTX *ctx);
        OSSL_DECODER_CLEANUP *OSSL_DECODER_CTX_get_cleanup(OSSL_DECODER_CTX *ctx);

        int OSSL_DECODER_export(OSSL_DECODER_INSTANCE *decoder_inst,
                                void *reference, size_t reference_sz,
                                OSSL_CALLBACK *export_cb, void *export_cbarg);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>OSSL_DECODER_CTX</b> holds data about multiple decoders, as needed to figure out what the input data is
       and to attempt to unpack it into one of several possible related results.  This also includes chaining
       decoders, so the output from one can become the input for another.  This allows having generic format
       decoders such as PEM to DER, as well as more specialized decoders like DER to RSA.

       The chains may be limited by specifying an input type, which is considered a starting point.  This is
       both considered by <b>OSSL_DECODER_CTX_add_extra()</b>, which will stop adding one more decoder implementations
       when it has already added those that take the specified input type, and functions like
       <b><a href="../man3/OSSL_DECODER_from_bio.3.html">OSSL_DECODER_from_bio</a></b>(3), which will only start the decoding process with the decoder implementations
       that take that input type.  For example, if the input type is set to "DER", a PEM to DER decoder will be
       ignored.

       The input type can also be NULL, which means that the caller doesn't know what type of input they have.
       In this case, <b>OSSL_DECODER_from_bio()</b> will simply try with one decoder implementation after the other,
       and thereby discover what kind of input the caller gave it.

       For every decoding done, even an intermediary one, a constructor provided by the caller is called to
       attempt to construct an appropriate type / structure that the caller knows how to handle from the current
       decoding result.  The constructor is set with <b>OSSL_DECODER_CTX_set_construct()</b>.

       <b>OSSL_DECODER_INSTANCE</b> is an opaque structure that contains data about the decoder that was just used, and
       that may be useful for the constructor.  There are some functions to extract data from this type,
       described further down.

   <b>Functions</b>
       <b>OSSL_DECODER_CTX_new()</b> creates a new empty <b>OSSL_DECODER_CTX</b>.

       <b>OSSL_DECODER_settable_ctx_params()</b> returns an <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) array of parameter descriptors.

       <b>OSSL_DECODER_CTX_set_params()</b> attempts to set parameters specified with an <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) array <u>params</u>.
       These parameters are passed to all decoders that have been added to the <u>ctx</u> so far.  Parameters that an
       implementation doesn't recognise should be ignored by it.

       <b>OSSL_DECODER_CTX_free()</b> frees the given context <u>ctx</u>.  If the argument is NULL, nothing is done.

       <b>OSSL_DECODER_CTX_add_decoder()</b> populates the <b>OSSL_DECODER_CTX</b> <u>ctx</u> with a decoder, to be used to attempt
       to decode some encoded input.

       <b>OSSL_DECODER_CTX_add_extra()</b> finds decoders that generate input for already added decoders, and adds them
       as well.  This is used to build decoder chains.

       <b>OSSL_DECODER_CTX_set_input_type()</b> sets the starting input type.  This limits the decoder chains to be
       considered, as explained in the general description above.

       <b>OSSL_DECODER_CTX_set_input_structure()</b> sets the name of the structure that the input is expected to have.
       This may be used to determines what decoder implementations may be used.  NULL is a valid input
       structure, when it's not relevant, or when the decoder implementations are expected to figure it out.

       <b>OSSL_DECODER_CTX_get_num_decoders()</b> gets the number of decoders currently added to the context <u>ctx</u>.

       <b>OSSL_DECODER_CTX_set_construct()</b> sets the constructor <u>construct</u>.

       <b>OSSL_DECODER_CTX_set_construct_data()</b> sets the constructor data that is passed to the constructor every
       time it's called.

       <b>OSSL_DECODER_CTX_set_cleanup()</b> sets the constructor data <u>cleanup</u> function.  This is called by
       <b><a href="../man3/OSSL_DECODER_CTX_free.3.html">OSSL_DECODER_CTX_free</a></b>(3).

       <b>OSSL_DECODER_CTX_get_construct()</b>, <b>OSSL_DECODER_CTX_get_construct_data()</b> and
       <b>OSSL_DECODER_CTX_get_cleanup()</b> return the values that have been set by <b>OSSL_DECODER_CTX_set_construct()</b>,
       <b>OSSL_DECODER_CTX_set_construct_data()</b> and <b>OSSL_DECODER_CTX_set_cleanup()</b> respectively.

       <b>OSSL_DECODER_export()</b> is a fallback function for constructors that cannot use the data they get directly
       for diverse reasons.  It takes the same decode instance <u>decoder_inst</u> that the constructor got and an
       object <u>reference</u>, unpacks the object which it refers to, and exports it by creating an <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3)
       array that it then passes to <u>export_cb</u>, along with <u>export_arg</u>.

   <b>Constructor</b>
       A <b>OSSL_DECODER_CONSTRUCT</b> gets the following arguments:

       <u>decoder_inst</u>
           The <b>OSSL_DECODER_INSTANCE</b> for the decoder from which the constructor gets its data.

       <u>object</u>
           A  provider-native  object abstraction produced by the decoder.  Further information on the provider-
           native object abstraction can be found in <b><a href="../man7/provider-object.7.html">provider-object</a></b>(7).

       <u>construct_data</u>
           The pointer that was set with <b>OSSL_DECODE_CTX_set_construct_data()</b>.

       The constructor is expected to return 1 when the data it receives can be constructed, otherwise 0.

       These utility functions may be used by a constructor:

       <b>OSSL_DECODER_INSTANCE_get_decoder()</b> can be used to get the decoder implementation from a decoder instance
       <u>decoder_inst</u>.

       <b>OSSL_DECODER_INSTANCE_get_decoder_ctx()</b> can be used to get the decoder implementation's provider  context
       from a decoder instance <u>decoder_inst</u>.

       <b>OSSL_DECODER_INSTANCE_get_input_type()</b>  can be used to get the decoder implementation's input type from a
       decoder instance <u>decoder_inst</u>.

       <b>OSSL_DECODER_INSTANCE_get_input_structure()</b> can be used to  get  the  input  structure  for  the  decoder
       implementation from a decoder instance <u>decoder_inst</u>.  This may be NULL.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>OSSL_DECODER_CTX_new()</b> returns a pointer to a <b>OSSL_DECODER_CTX</b>, or NULL if the context structure couldn't
       be allocated.

       <b>OSSL_DECODER_settable_ctx_params()</b> returns an <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) array, or NULL if none is available.

       <b>OSSL_DECODER_CTX_set_params()</b>  returns 1 if all recognised parameters were valid, or 0 if one of them was
       invalid or caused some other failure in the implementation.

       <b>OSSL_DECODER_CTX_add_decoder()</b>,      <b>OSSL_DECODER_CTX_add_extra()</b>,      <b>OSSL_DECODER_CTX_set_construct()</b>,
       <b>OSSL_DECODER_CTX_set_construct_data()</b>  and  <b>OSSL_DECODER_CTX_set_cleanup()</b>  return  1 on success, or 0 on
       failure.

       <b>OSSL_DECODER_CTX_get_construct()</b>,                <b>OSSL_DECODER_CTX_get_construct_data()</b>                and
       <b>OSSL_DECODER_CTX_get_cleanup()</b>  return  the current pointers to the constructor, the constructor data and
       the cleanup functions, respectively.

       <b>OSSL_DECODER_CTX_num_decoders()</b> returns the current number of decoders.  It returns 0 if <u>ctx</u> is NULL.

       <b>OSSL_DECODER_export()</b> returns 1 on success, or 0 on failure.

       <b>OSSL_DECODER_INSTANCE_decoder()</b> returns an <b>OSSL_DECODER</b> pointer on success, or NULL on failure.

       <b>OSSL_DECODER_INSTANCE_decoder_ctx()</b> returns a provider context pointer on success, or NULL on failure.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/provider.7.html">provider</a></b>(7), <b><a href="../man3/OSSL_DECODER.3.html">OSSL_DECODER</a></b>(3), <b><a href="../man3/OSSL_DECODER_from_bio.3.html">OSSL_DECODER_from_bio</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The functions described here were added in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2020-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                             <u><a href="../man3SSL/OSSL_DECODER_CTX.3SSL.html">OSSL_DECODER_CTX</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>