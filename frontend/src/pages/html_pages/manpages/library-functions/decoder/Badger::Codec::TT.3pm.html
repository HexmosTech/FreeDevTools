<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badger::Codec::TT - encode/decode data using TT data syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbadger-perl">libbadger-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Badger::Codec::TT - encode/decode data using TT data syntax

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Badger::Codec::TT;
           my $codec   = Badger::Codec::TT-&gt;new();
           my $encoded = $codec-&gt;encode({ msg =&gt; "Hello World" });
           my $decoded = $codec-&gt;decode($encoded);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module implements a subclass of Badger::Codec which encodes and decodes data to and from an extended
       form of the data definition syntax used in the Template Toolkit. It mainly exists for testing purposes
       (so that we don't require people to install YAML or JSON just to run some of the Badger tests) and to
       support some legacy systems that use data encoded in this way (mostly dating back to the days before YAML
       and JSON were around). If you're starting out afresh then you're probably better off using YAML or JSON
       unless you have good reason not to.

       The syntax is similar to Perl in that it uses single quotes for literal strings, square brackets for list
       definitions and curly braces for hash definitions along with the "=&gt;" "fat comma" operator to separate
       hash keys and values. Data structures can be nested indefinitely. The unquoted "undef" token can be used
       to explicitly represent the undefined value.

           {
               message =&gt; 'Hello World, this is some text',
               things  =&gt; ['a list', 'of some things'],
               stuff   =&gt; {
                   pi  =&gt; 3.14,
                   foo =&gt; [ { nested =&gt; 'hash' }, ['nested', 'list' ] ],
                   nul =&gt; undef,
               },
           }

       TT syntax is more liberal than Perl.  It allows you to use "=" instead of "=&gt;" to separate keys and
       values in hash arrays, and commas between items are optional.

           {
               message = 'Hello World, this is some text'
               things  = ['a list' 'of some things']
               stuff   = {
                   pi  = 3.14
                   foo = [ { nested = 'hash' } ['nested' 'list' ] ]
                   nul = undef
               }
           }

       It will also accept ":" as a delimiter between hash keys and values, thus providing an overlap with a
       useful subset of JSON syntax:

           {
               message: 'Hello World, this is some text',
               things: ['a list' 'of some things'],
               stuff: {
                   pi:  3.14,
                   foo: [ { nested: 'hash' }, ['nested', 'list' ] ],
                   nul: undef
               }
           }

       The decoder is very liberal in what it will accept for delimiters. You can mix and match any of the above
       styles in the same document if you really want to.  However, you would be utterly batshit insane to do
       such a thing, let alone want for it. Just because we'll accept any of the commonly used formats doesn't
       mean that you should be using them all at once.

           {
               perl =&gt; 'Perl looks like this',
               tt   =  'TT looks like this'
               json: 'JSON looks like this
           }

       Note that while the syntax may be more liberal than either Perl or JSON, the semantics are decidedly
       stricter.  It is not possible to embed arbitrary Perl code, instantiate Javascript objects, or do
       anything else outside of defining vanilla data structures.

       The encoder generates TT syntax by default ("=" for assignment, with a single space to delimiter items).
       You can change these options using the "assign" and "comma" configuration options.

           my $codec = Badger::Codec::TT-&gt;new( assign =&gt; '=&gt;', comma =&gt; ',' );
           print $codec-&gt;encode($some_data);

</pre><h4><b>METHODS</b></h4><pre>
   <b>encode($data)</b>
       Encodes the Perl data in $data to a TT string.

           $encoded = Badger::Codec::TT-&gt;encode($data);

   <b>decode($tt)</b>
       Decodes the encoded TT string in $tt back into a Perl data structure.

           $decoded = Badger::Codec::TT-&gt;decode($encoded);

   <b>encoder()</b>
       This method returns a reference to an encoding subroutine.

           my $sub = Badger::Codec::TT-&gt;encoder;
           $encoded = $sub-&gt;($data);

   <b>decoder()</b>
       This method returns a reference to a decoding subroutine.

           my $sub = Badger::Codec::TT-&gt;decoder;
           $decoded = $sub-&gt;($encoded);

</pre><h4><b>INTERNAL</b> <b>SUBROUTINES</b></h4><pre>
   <b>_encode($data)</b>
       This internal subroutine performs the recursive encoding of the data.

   <b>_decode($tt)</b>
       This internal subroutine performs the recursive decoding of the data.

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley &lt;<a href="http://wardley.org/">http://wardley.org/</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2005-2009 Andy Wardley. All rights reserved.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Badger::Codecs, Badger::Codec, Template

perl v5.36.0                                       2023-08-28                             <u>Badger::Codec::<a href="../man3pm/TT.3pm.html">TT</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>