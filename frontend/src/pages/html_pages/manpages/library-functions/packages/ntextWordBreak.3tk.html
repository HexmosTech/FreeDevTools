<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ntextWordBreak - ntext Word Boundary Detection for the Text Widget</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tklib">tklib_0.9-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ntextWordBreak - ntext Word Boundary Detection for the Text Widget

</pre><h4><b>SYNOPSIS</b></h4><pre>

       package require <b>Tcl</b> <b>8.5-</b>

       package require <b>Tk</b> <b>8.5-</b>
       package require <b>ntext</b> <b>?1.0?</b>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>ntext</b> package provides a binding tag named <u>Ntext</u> for use by text widgets in place of the default <u>Text</u>
       binding tag.

       Navigation  and selection in a text widget require the detection of words and their boundaries.  The word
       boundary detection facilities provided by Tcl/Tk through the <u>Text</u> binding tag are  limited  because  they
       define only one class of "word" characters and one class of "non-word" characters.  The <u>Ntext</u> binding tag
       uses more general rules for word boundary detection, that define <u>two</u> classes of "word" characters and one
       class of "non-word" characters.

</pre><h4><b>CONFIGURATION</b> <b>OPTIONS</b></h4><pre>
       The  behaviour of <u>Ntext</u> may be configured application-wide by setting the values of a number of namespace
       variables.  One of these is relevant to word boundary detection:

       <b>::ntext::classicWordBreak</b>

       •      <b>0</b> - (default value) selects <u>Ntext</u>  behaviour,  i.e.  platform-independent,  two  classes  of  word
              characters and one class of non-word characters.

       •      <b>1</b>  - selects classic <u>Text</u> behaviour, i.e. platform-dependent, one class of word characters and one
              class of non-word characters

       •      After changing this value,  <u>Ntext</u>  's  regexp  matching  patterns  should  be  recalculated.   See
              <b>FUNCTIONS</b> for details and advanced configuration options.

</pre><h4><b>ADVANCED</b> <b>USE</b></h4><pre>
</pre><h4><b>VARIABLES</b> <b>(ADVANCED</b> <b>USE)</b></h4><pre>
       <b>::ntext::tcl_match_wordBreakAfter</b>

       <b>::ntext::tcl_match_wordBreakBefore</b>

       <b>::ntext::tcl_match_endOfWord</b>

       <b>::ntext::tcl_match_startOfNextWord</b>

       <b>::ntext::tcl_match_startOfPreviousWord</b>

       These  variables  hold the regexp patterns that are used by <u>Ntext</u> to search for word boundaries.  If they
       are changed, subsequent searches are immediately altered.  In many situations, it it unnecessary to alter
       the   values    of    these    variables    directly:    instead    call    one    of    the    functions
       <b>::ntext::initializeMatchPatterns</b>, <b>::ntext::createMatchPatterns</b>.

       In  the  <u>Text</u>  binding tag one can change the search rules by changing the values of the global variables
       <b>tcl_wordchars</b> and <b>tcl_nonwordchars</b>.  The equivalent operation  in  the  <u>Ntext</u>  binding  tag  is  to  call
       <b>::ntext::createMatchPatterns</b> with appropriate arguments.

</pre><h4><b>FUNCTIONS</b> <b>(ADVANCED</b> <b>USE)</b></h4><pre>
       If  a  simple  regexp  search should prove insufficient, the following functions (analogous to the Tcl/Tk
       core's <b>tcl_wordBreakAfter</b> etc) may be replaced by the developer:

       <b>ntext::new_wordBreakAfter</b>

       <b>ntext::new_wordBreakBefore</b>

       <b>ntext::new_endOfWord</b>

       <b>ntext::new_startOfNextWord</b>

       <b>ntext::new_startOfPreviousWord</b>

</pre><h4><b>FUNCTIONS</b></h4><pre>
       Each function calculates the five regexp search patterns that define the word boundary  searches.   These
       values are stored in the namespace variables listed above.

       <b>::ntext::initializeMatchPatterns</b>

       •      This  function is called when <u>Ntext</u> is first used, and needs to be called again only if the script
              changes the value of either <b>::ntext::classicWordBreak</b> or <b>::tcl_platform(platform)</b>.   The  function
              is  called  with  no  arguments.   It  is  useful when the desired search patterns are the default
              patterns for either the <u>Ntext</u> or <u>Text</u> binding tag, and so are implicitly specified by  the  values
              of <b>::ntext::classicWordBreak</b> and <b>::tcl_platform(platform)</b> alone.

       <b>::ntext::createMatchPatterns</b> <u>new_nonwordchars</u> <u>new_word1chars</u> ?new_word2chars?

       •      This  function is useful in a wider range of situations than <b>::ntext::initializeMatchPatterns</b>.  It
              calculates the regexp search patterns for any case with one class of "non-word" characters and one
              or two classes of "word" characters.

              Each argument should be a regexp expression defining a class  of  characters.   An  argument  will
              usually  be a bracket expression, but might alternatively be a class-shorthand escape, or a single
              character.  The third argument may be omitted, or supplied as the empty string, in which  case  it
              is unused.

              The  first  argument  is interpreted as the class of non-word characters; the second argument (and
              the third, if present) are classes of word characters.  The classes should  include  all  possible
              characters  and will normally be mutually exclusive: it is often convenient to define one class as
              the negation of the other two.

</pre><h4><b>WORD</b> <b>BOUNDARY</b> <b>MATCHING</b></h4><pre>
       The problem of word boundary selection is a vexed one, because text is used to represent  a  universe  of
       different  types  of information, and there are no simple rules that are useful for all data types or for
       all purposes.

       <u>Ntext</u> attempts to improve on the facilities available in classic <u>Text</u> by providing  facilities  for  more
       complex definitions of words (with three classes of characters instead of two).

       <u>What</u> <u>is</u> <u>a</u> <u>word?</u>  <u>Why</u> <u>two</u> <u>classes</u> <u>of</u> <u>word?</u>

       When  using  the  modified  cursor  keys  &lt;Control-Left&gt;  and &lt;Control-Right&gt; to navigate through a <u>Ntext</u>
       widget, the cursor is placed at the start of a word.  A word is defined as a  sequence  of  one  or  more
       characters  from  only  one of the two defined "word" classes; it may be preceded by a character from the
       other "word" class or from the "non-word" class.

       The double-click of mouse button 1 selects a word of text, where in this case a "word" may be as  defined
       above,  or  alternatively  may  be  a  sequence  of  one  or more characters from the "non-word" class of
       characters.

       Traditionally Tcl has defined only one word class and one non-word class: on Windows, the non-word  class
       is  whitespace,  and  so  alphanumerics  and  punctuation  belong to the same class.  On other platforms,
       punctuation is bundled with whitespace as "non-word" characters.  In  either  case,  the  navigation  and
       selection of text are unnecessarily coarse-grained, and sometimes give unhelpful results.

       The  use  of three classes of characters might make selection too fine-grained; but in this case, holding
       down the <u>Shift</u> key and double-clicking another word is an excellent way to select a longer range of  text
       (a useful binding that Tcl/Tk has long provided but which is missing in other systems).

       As  well  as  its  defaults, <u>Ntext</u> permits the developer to define their own classes of characters, or to
       revert to the classic <u>Text</u> definitions, or to specify their own regexp matching patterns.

</pre><h4><b>BUGS</b></h4><pre>
       This version of <b>ntext</b> is intended to be compatible with all releases of <b>Tk</b> 8.5, 8.6, and  8.7,  and  with
       the  branches  <u>core-8-5-branch</u>,  <u>core-8-6-branch</u>,  and  <u>trunk</u>  in the source code repository for <b>Tk</b>.  Any
       incompatibility with any of these versions, for any <b>Tk</b> windowing system, should be  reported  as  a  bug.
       Please    report    such   in   the   category   <u>ntext</u>   of   the   <u>Tklib</u>   <u>Trackers</u>   [https://core.tcl-
       lang.org/tklib/reportlist].

</pre><h4><b>EXAMPLE</b></h4><pre>
       To use <u>Ntext</u> with Tcl/Tk's usual word-boundary detection rules:

              package require ntext
              text .t
              bindtags .t {.t Ntext . all}
              set ::ntext::classicWordBreak 1
              ::ntext::initializeMatchPatterns

       See bindtags for more information.

       To define a different set of word-boundary detection rules:

              package require ntext
              text .t
              bindtags .t {.t Ntext . all}
              ::ntext::createMatchPatterns  {[[:space:][:cntrl:]]} {[[:punct:]]} {[^[:punct:][:space:][:cntrl:]]}

       See regexp, re_syntax for more information.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       bindtags, ntext, re_syntax, regexp, text

</pre><h4><b>KEYWORDS</b></h4><pre>
       bindtags, re_syntax, regexp, text

tklib                                                  1.0                                   <u><a href="../man3tk/ntextWordBreak.3tk.html">ntextWordBreak</a></u>(3tk)
</pre>
 </div>
</div></section>
</div>
</body>
</html>