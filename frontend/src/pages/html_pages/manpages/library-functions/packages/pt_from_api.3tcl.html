<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt_import_api - Parser Tools Import API</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt_import_api - Parser Tools Import API

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       <b>CONVERTER</b> <b>convert</b> <u>text</u>

       <b>IncludeFile</b> <u>currentfile</u> <u>path</u>

       <b>::import</b> <u>text</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       This  document  describes two APIs. First the API shared by all packages for the conversion of some other
       format into Parsing Expression Grammars , and then the API shared by the  packages  which  implement  the
       import plugins sitting on top of the conversion packages.

       Its intended audience are people who wish to create their own converter for some type of input, and/or an
       import plugin for their or some other converter.

       It resides in the Import section of the Core Layer of Parser Tools.

       IMAGE: arch_core_import

</pre><h4><b>CONVERTER</b> <b>API</b></h4><pre>
       Any (grammar) import converter has to follow the rules set out below:

       [1]    A  converter  is  a  package. Its name is arbitrary, however it is recommended to put it under the
              <b>::pt::peg::from</b> namespace.

       [2]    The package provides either a single Tcl command following the API  outlined  below,  or  a  class
              command  whose  instances  follow  the  same  API.  The  commands  which follow the API are called
              <u>converter</u> <u>commands</u>.

       [3]    A converter command has to provide the following  single  method  with  the  given  signature  and
              semantic.  Converter  commands are allowed to provide more methods of their own, but not less, and
              they may not provide different semantics for the standardized method.

              <b>CONVERTER</b> <b>convert</b> <u>text</u>
                     This method has to accept some <u>text</u>, a parsing expression  grammar  in  some  format.   The
                     result of the method has to be the canonical serialization of a parsing expression grammar,
                     as  specified in section <b>PEG</b> <b>serialization</b> <b>format</b>, the result of reading and converting the
                     input text.

</pre><h4><b>PLUGIN</b> <b>API</b></h4><pre>
       Any (grammar) import plugin has to follow the rules set out below:

       [1]    A plugin is a package.

       [2]    The name of a plugin package has the form pt::peg::import::<b>FOO</b>, where  <b>FOO</b>  is  the  name  of  the
              format the plugin will accept input for.

       [3]    The  plugin  can  expect that the package <b>pt::peg::import::plugin</b> is present, as indicator that it
              was invoked from a genuine plugin manager.

              It is recommended that a plugin does check for the presence of this package.

       [4]    The plugin can expect that a command named <b>IncludeFile</b> is present, with the signature

              <b>IncludeFile</b> <u>currentfile</u> <u>path</u>
                     This command has to be invoked by the plugin when it has to process an  included  file,  if
                     the format has the concept of such.

                     The plugin has to supply the following arguments

                     string <u>currentfile</u>
                            The  path of the file it is currently processing. This may be the empty string if no
                            such is known.

                     string <u>path</u>
                            The path of the include file as specified in the include directive being processed.

                     The result of the command will be a 5-element list containing

                     [1]    A boolean flag indicating the success (<b>True</b>) or failure (<b>False</b>) of the operation.

                     [2]    In case of success  the  contents  of  the  included  file,  and  the  empty  string
                            otherwise.

                     [3]    The resolved, i.e. absolute path of the included file, if possible, or the unchanged
                            <u>path</u>  argument.  This  is  for  display  in  an error message, or as the <u>currentfile</u>
                            argument of another call to <b>IncludeFile</b> should this file contain more files.

                     [4]    In case of success an empty string, and for failure a code indicating the reason for
                            it, one of

                            notfound
                                   The specified file could not be found.

                            notread
                                   The specified file was found, but not be read into memory.

                     [5]    An empty string in case of success of a <b>notfound</b> failure, and  an  additional  error
                            message describing the reason for a <b>notread</b> error in more detail.

       [5]    A plugin has to provide a single command, in the global namespace, with the signature shown below.
              Plugins  are allowed to provide more commands of their own, but not less, and they may not provide
              different semantics for the standardized command.

              <b>::import</b> <u>text</u>
                     This command has to accept the a text containing  a  parsing  expression  grammar  in  some
                     format.  The  result  of  the  command has to be the result of the converter invoked by the
                     plugin for the input grammar, the canonical serialization of the parsing expression grammar
                     contained in the input.

                     string <u>text</u>
                            This argument will contain the parsing expression grammar for which to generate  the
                            serialization.   The specification of what a <u>canonical</u> serialization is can be found
                            in the section <b>PEG</b> <b>serialization</b> <b>format</b>.

       [6]    A single usage cycle of a plugin consists of an invokation of the command <b>import</b>. This call has to
              leave the plugin in a state where another usage cycle can be run without problems.

</pre><h4><b>USAGE</b></h4><pre>
       To use a converter do

                  # Get the converter (single command here, not class)
                  package require the-converter-package

                  # Perform the conversion
                  set serial [theconverter convert $thegrammartext]

                  ... process the result ...

       To use a plugin <b>FOO</b> do

                  # Get an import plugin manager
                  package require pt::peg::import
                  pt::peg::import I

                  # Run the plugin, and the converter inside.
                  set serial [I import serial $thegrammartext FOO]

                  ... process the result ...

</pre><h4><b>PEG</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here we specify the format used by the Parser Tools to serialize Parsing Expression Grammars as immutable
       values for transport, comparison, etc.

       We distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a PEG may have more than one  regular
       serialization only exactly one of them will be <u>canonical</u>.

       regular serialization

              [1]    The serialization of any PEG is a nested Tcl dictionary.

              [2]    This  dictionary  holds a single key, <b>pt::grammar::peg</b>, and its value. This value holds the
                     contents of the grammar.

              [3]    The contents of the grammar are a Tcl dictionary holding the set of nonterminal symbols and
                     the starting expression. The relevant keys and their values are

                     <b>rules</b>  The value is a Tcl dictionary whose keys are the names of  the  nonterminal  symbols
                            known to the grammar.

                            [1]    Each nonterminal symbol may occur only once.

                            [2]    The empty string is not a legal nonterminal symbol.

                            [3]    The  value  for each symbol is a Tcl dictionary itself. The relevant keys and
                                   their values in this dictionary are

                                   <b>is</b>     The value is the serialization of the  parsing  expression  describing
                                          the  symbols  sentennial  structure,  as  specified  in the section <b>PE</b>
                                          <b>serialization</b> <b>format</b>.

                                   <b>mode</b>   The value can be one of three values specifying how  a  parser  should
                                          handle the semantic value produced by the symbol.

                                          <b>value</b>  The  semantic  value  of  the nonterminal symbol is an abstract
                                                 syntax  tree  consisting  of  a  single  node  node   for   the
                                                 nonterminal  itself,  which  has the ASTs of the symbol's right
                                                 hand side as its children.

                                          <b>leaf</b>   The semantic value of the nonterminal  symbol  is  an  abstract
                                                 syntax   tree   consisting  of  a  single  node  node  for  the
                                                 nonterminal, without any children. Any ASTs  generated  by  the
                                                 symbol's right hand side are discarded.

                                          <b>void</b>   The  nonterminal  has  no semantic value. Any ASTs generated by
                                                 the symbol's right hand side are discarded (as well).

                     <b>start</b>  The value is the serialization of the start parsing expression of  the  grammar,  as
                            specified in the section <b>PE</b> <b>serialization</b> <b>format</b>.

              [4]    The  terminal  symbols  of  the grammar are specified implicitly as the set of all terminal
                     symbols used in the start expression and on the RHS of the grammar rules.

       canonical serialization
              The canonical serialization of a grammar has the format as specified in  the  previous  item,  and
              then  additionally  satisfies  the  constraints below, which make it unique among all the possible
              serializations of this grammar.

              [1]    The keys found in all the nested Tcl dictionaries are sorted in ascending dictionary order,
                     as generated by Tcl's builtin command <b>lsort</b> <b>-increasing</b> <b>-dict</b>.

              [2]    The string representation of the value is the canonical representation of a Tcl dictionary.
                     I.e. it does not contain superfluous whitespace.

   <b>EXAMPLE</b>
       Assuming the following PEG for simple mathematical expressions

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       then its canonical serialization (except for whitespace) is

              pt::grammar::peg {
                  rules {
                      AddOp      {is {/ {t -} {t +}}                                                                mode value}
                      Digit      {is {/ {t 0} {t 1} {t 2} {t 3} {t 4} {t 5} {t 6} {t 7} {t 8} {t 9}}                mode value}
                      Expression {is {x {n Term} {* {x {n AddOp} {n Term}}}}                                        mode value}
                      Factor     {is {/ {x {t (} {n Expression} {t )}} {n Number}}                                  mode value}
                      MulOp      {is {/ {t *} {t /}}                                                                mode value}
                      Number     {is {x {? {n Sign}} {+ {n Digit}}}                                                 mode value}
                      Sign       {is {/ {t -} {t +}}                                                                mode value}
                      Term       {is {x {n Factor} {* {x {n MulOp} {n Factor}}}}                                    mode value}
                  }
                  start {n Expression}
              }

</pre><h4><b>PE</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here we specify the format used by the Parser Tools to serialize Parsing Expressions as immutable  values
       for transport, comparison, etc.

       We  distinguish  between  <u>regular</u> and <u>canonical</u> serializations.  While a parsing expression may have more
       than one regular serialization only exactly one of them will be <u>canonical</u>.

       Regular serialization

              <b>Atomic</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    The string <b>epsilon</b> is an atomic parsing expression. It matches the empty string.

                     [2]    The string <b>dot</b> is an atomic parsing expression. It matches any character.

                     [3]    The string <b>alnum</b> is an atomic parsing expression. It matches any Unicode alphabet or
                            digit character. This is a custom extension of PEs based on  Tcl's  builtin  command
                            <b>string</b> <b>is</b>.

                     [4]    The  string  <b>alpha</b>  is an atomic parsing expression. It matches any Unicode alphabet
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [5]    The  string  <b>ascii</b> is an atomic parsing expression. It matches any Unicode character
                            below U0080. This is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [6]    The string <b>control</b> is an atomic parsing expression. It matches any  Unicode  control
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [7]    The string <b>digit</b> is an atomic parsing  expression.  It  matches  any  Unicode  digit
                            character. Note that this includes characters outside of the [0..9] range. This is a
                            custom extension of PEs based on Tcl's builtin command <b>string</b> <b>is</b>.

                     [8]    The  string  <b>graph</b>  is an atomic parsing expression. It matches any Unicode printing
                            character, except for space. This is a  custom  extension  of  PEs  based  on  Tcl's
                            builtin command <b>string</b> <b>is</b>.

                     [9]    The  string <b>lower</b> is an atomic parsing expression. It matches any Unicode lower-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [10]   The string <b>print</b> is an atomic parsing expression. It matches  any  Unicode  printing
                            character, including space. This is a custom extension of PEs based on Tcl's builtin
                            command <b>string</b> <b>is</b>.

                     [11]   The string <b>punct</b> is an atomic parsing expression. It matches any Unicode punctuation
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [12]   The string <b>space</b> is an atomic parsing  expression.  It  matches  any  Unicode  space
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [13]   The string <b>upper</b> is an atomic parsing expression. It matches any Unicode  upper-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [14]   The  string  <b>wordchar</b>  is  an atomic parsing expression. It matches any Unicode word
                            character. This is  any  alphanumeric  character  (see  alnum),  and  any  connector
                            punctuation  characters  (e.g.  underscore). This is a custom extension of PEs based
                            on Tcl's builtin command <b>string</b> <b>is</b>.

                     [15]   The string <b>xdigit</b> is an atomic parsing expression. It matches any hexadecimal  digit
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [16]   The string <b>ddigit</b> is an atomic parsing expression.  It  matches  any  decimal  digit
                            character. This is a custom extension of PEs based on Tcl's builtin command <b>regexp</b>.

                     [17]   The  expression  [list t <b>x</b>] is an atomic parsing expression. It matches the terminal
                            string <b>x</b>.

                     [18]   The expression  [list  n  <b>A</b>]  is  an  atomic  parsing  expression.  It  matches  the
                            nonterminal <b>A</b>.

              <b>Combined</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    For  parsing  expressions <b>e1</b>, <b>e2</b>, ... the result of [list / <b>e1</b> <b>e2</b> ... ] is a parsing
                            expression as well.  This is the <u>ordered</u> <u>choice</u>, aka <u>prioritized</u> <u>choice</u>.

                     [2]    For parsing expressions <b>e1</b>, <b>e2</b>, ... the result of [list x <b>e1</b> <b>e2</b> ... ] is  a  parsing
                            expression as well.  This is the <u>sequence</u>.

                     [3]    For a parsing expression <b>e</b> the result of [list * <b>e</b>] is a parsing expression as well.
                            This is the <u>kleene</u> <u>closure</u>, describing zero or more repetitions.

                     [4]    For a parsing expression <b>e</b> the result of [list + <b>e</b>] is a parsing expression as well.
                            This is the <u>positive</u> <u>kleene</u> <u>closure</u>, describing one or more repetitions.

                     [5]    For a parsing expression <b>e</b> the result of [list &amp; <b>e</b>] is a parsing expression as well.
                            This is the <u>and</u> <u>lookahead</u> <u>predicate</u>.

                     [6]    For a parsing expression <b>e</b> the result of [list ! <b>e</b>] is a parsing expression as well.
                            This is the <u>not</u> <u>lookahead</u> <u>predicate</u>.

                     [7]    For a parsing expression <b>e</b> the result of [list ? <b>e</b>] is a parsing expression as well.
                            This is the <u>optional</u> <u>input</u>.

       Canonical serialization
              The  canonical  serialization  of a parsing expression has the format as specified in the previous
              item, and then additionally satisfies the constraints below, which make it unique  among  all  the
              possible serializations of this parsing expression.

              [1]    The  string representation of the value is the canonical representation of a pure Tcl list.
                     I.e. it does not contain superfluous whitespace.

              [2]    Terminals are <u>not</u> encoded as ranges (where start and end of the range are identical).

   <b>EXAMPLE</b>
       Assuming the parsing expression shown on the right-hand side of the rule

                  Expression &lt;- Term (AddOp Term)*

       then its canonical serialization (except for whitespace) is

                  {x {n Term} {* {x {n AddOp} {n Term}}}}

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>pt</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,  LL(k),  PEG,  TDPL,  context-free  languages,  expression,  grammar,  matching,  parser,   parsing
       expression,  parsing  expression grammar, push down automaton, recursive descent, state, top-down parsing
       languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.1                                   <u><a href="../man3tcl/pt_import_api.3tcl.html">pt_import_api</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>