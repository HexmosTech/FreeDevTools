<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fileutil_traverse - Iterative directory traversal</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fileutil_traverse - Iterative directory traversal

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>fileutil::traverse</b> <b>?0.7?</b>

       package require <b>fileutil</b>

       package require <b>control</b>

       <b>::fileutil::traverse</b> ?<u>objectName</u>? <u>path</u> ?<u>option</u> <u>value</u>...?

       <b>$traverser</b> <b>command</b> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <b>$traverser</b> <b>files</b>

       <b>$traverser</b> <b>foreach</b> <u>filevar</u> <u>script</u>

       <b>$traverser</b> <b>next</b> <u>filevar</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  package provides objects for the programmable traversal of directory hierarchies.  The main command
       exported by the package is:

       <b>::fileutil::traverse</b> ?<u>objectName</u>? <u>path</u> ?<u>option</u> <u>value</u>...?
              The command creates a new traversal object with an associated global Tcl  command  whose  name  is
              <u>objectName</u>. This command may be used to invoke various operations on the traverser.  If the string
              <b>%AUTO%</b> is used as the <u>objectName</u> then a unique name will be generated by the package itself.

              Regarding  the recognized options see section <b>OPTIONS</b>. Note that all these options can be set only
              during the creation of the traversal object. Changing them later is not possible and causes errors
              to be thrown if attempted.

              The object command has the following general form:

              <b>$traverser</b> <b>command</b> ?<u>arg</u> <u>arg</u> <u>...</u>?
                     <u>Command</u> and its <u>arg</u>uments determine the exact behavior of the object.

       The following commands are possible for traversal objects:

       <b>$traverser</b> <b>files</b>
              This method is the most highlevel one provided by traversal objects. When  invoked  it  returns  a
              list  containing  the names of all files and directories matching the current configuration of the
              traverser.

       <b>$traverser</b> <b>foreach</b> <u>filevar</u> <u>script</u>
              The highlevel <b>files</b> method (see above) is based on this mid-level method. When  invoked  it  finds
              all  files and directories matching per the current configuration and executes the <u>script</u> for each
              path. The current path under consideration is stored  in  the  variable  named  by  <u>filevar</u>.  Both
              variable  and script live / are executed in the context of the caller of the method. In the method
              <b>files</b> the script simply saves the found paths into the list to return.

       <b>$traverser</b> <b>next</b> <u>filevar</u>
              This is the lowest possible interface to the traverser, the core all higher methods are built  on.
              When  invoked  it  returns a boolean value indicating whether it found a path matching the current
              configuration (<b>True</b>), or not (<b>False</b>). If a path was found it is stored into the variable named  by
              <u>filevar</u>, in the context of the caller.

              The  <b>foreach</b>  method  simply  calls  this method in a loop until it returned <b>False</b>. This method is
              exposed so that we are also able to incrementally traverse a directory hierarchy in an event-based
              manner.

              Note that the traverser does follow symbolic links, except when doing so would cause it to enter a
              link-cycle. In other words, the command takes care to <u>not</u>  lose  itself  in  infinite  loops  upon
              encountering  circular  link  structures.  Note  that even links which are not followed will still
              appear in the result.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-prefilter</b> command_prefix
              This callback is executed for directories. Its result determines if the  traverser  recurses  into
              the  directory  or  not.  The  default  is to always recurse into all directories. The callback is
              invoked with a single argument, the <u>absolute</u> path of the directory, and has to  return  a  boolean
              value, <b>True</b> when the directory passes the filter, and <b>False</b> if not.

       <b>-filter</b> command_prefix
              This  callback  is  executed  for  all paths. Its result determines if the current path is a valid
              result, and returned by <b>next</b>. The default is to accept all paths as valid. The callback is invoked
              with a single argument, the <u>absolute</u> path to check, and has to return a boolean value,  <b>True</b>  when
              the path passes the filter, and <b>False</b> if not.

       <b>-errorcmd</b> command_prefix
              This  callback  is  executed  for  all  paths the traverser has trouble with. Like being unable to
              change into them, get their status, etc. The default is to ignore any such problems. The  callback
              is  invoked  with  a  two  arguments, the <u>absolute</u> path for which the error occured, and the error
              message. Errors thrown by the filter callbacks are  handled  through  this  callback  too.  Errors
              thrown by the error callback itself are not caught and ignored, but allowed to pass to the caller,
              i.e. however invoked the <b>next</b>. Any other results from the callback are ignored.

</pre><h4><b>WARNINGS</b> <b>AND</b> <b>INCOMPATIBILITIES</b></h4><pre>
       <b>0.4.4</b>  In  this version the traverser's broken system for handling symlinks was replaced with one working
              correctly and properly enumerating all the legal non-cyclic paths under a base directory.

              While correct this means that certain pathological directory hierarchies  with  cross-linked  sym-
              links  will  now  take  about  O(n**2)  time to enumerate whereas the original broken code managed
              <a href="../man3tcl/O.3tcl.html">O</a>(3tcl) due to its brokenness.

              A concrete example and extreme case is the "<u><a href="file:/sys">/sys</a></u>" hierarchy under Linux where some hundred devices
              exist under both "<u><a href="file:/sys/devices">/sys/devices</a></u>" and "<u><a href="file:/sys/class">/sys/class</a></u>" with  the  two  sub-hierarchies  linking  to  the
              other,  generating millions of legal paths to enumerate.  The structure, reduced to three devices,
              roughly looks like

                <a href="file:/sys/class/tty/tty0">/sys/class/tty/tty0</a> --&gt; ../../dev/tty0
                <a href="file:/sys/class/tty/tty1">/sys/class/tty/tty1</a> --&gt; ../../dev/tty1
                <a href="file:/sys/class/tty/tty2">/sys/class/tty/tty2</a> --&gt; ../../dev/tty1

                /sys/dev/tty0/bus
                /sys/dev/tty0/subsystem --&gt; ../../class/tty
                /sys/dev/tty1/bus
                /sys/dev/tty1/subsystem --&gt; ../../class/tty
                /sys/dev/tty2/bus
                /sys/dev/tty2/subsystem --&gt; ../../class/tty

       When having to handle such a pathological hierarchy it is recommended to use  the  <b>-prefilter</b>  option  to
       prevent the traverser from following symbolic links, like so:

                  package require fileutil::traverse

                  proc NoLinks {fileName} {
                      if {[string equal [file type $fileName] link]} {
                          return 0
                      }
                      return 1
                  }

                  fileutil::traverse T <a href="file:/sys/devices">/sys/devices</a> -prefilter NoLinks
                  T foreach p {
                      puts $p
                  }
                  T destroy

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category  <u>fileutil</u>  of  the  <u>Tcllib</u>  <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       directory traversal, traversal

</pre><h4><b>CATEGORY</b></h4><pre>
       Programming tools

tcllib                                                 0.7                               <u><a href="../man3tcl/fileutil_traverse.3tcl.html">fileutil_traverse</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>