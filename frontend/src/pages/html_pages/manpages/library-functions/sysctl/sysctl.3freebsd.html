<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sysctl, sysctlbyname, sysctlnametomib — get or set system information</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sysctl, sysctlbyname, sysctlnametomib — get or set system information

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C Library (libc, -lc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;sys/sysctl.h&gt;</b>

       <u>int</u>
       <b>sysctl</b>(<u>const</u> <u>int</u> <u>*name</u>, <u>u_int</u> <u>namelen</u>, <u>void</u> <u>*oldp</u>, <u>size_t</u> <u>*oldlenp</u>, <u>const</u> <u>void</u> <u>*newp</u>, <u>size_t</u> <u>newlen</u>);

       <u>int</u>
       <b>sysctlbyname</b>(<u>const</u> <u>char</u> <u>*name</u>, <u>void</u> <u>*oldp</u>, <u>size_t</u> <u>*oldlenp</u>, <u>const</u> <u>void</u> <u>*newp</u>, <u>size_t</u> <u>newlen</u>);

       <u>int</u>
       <b>sysctlnametomib</b>(<u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>*mibp</u>, <u>size_t</u> <u>*sizep</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>sysctl</b>()  function  retrieves system information and allows processes with appropriate privileges to
       set system information.  The information available from  <b>sysctl</b>()  consists  of  integers,  strings,  and
       tables.  Information may be retrieved and set from the command interface using the <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) utility.

       Unless explicitly noted below, <b>sysctl</b>() returns a consistent snapshot of the data requested.  Consistency
       is  obtained  by  locking  the  destination buffer into memory so that the data may be copied out without
       blocking.  Calls to <b>sysctl</b>() are serialized to avoid deadlock.

       The state is described using a ``Management Information Base'' (MIB) style name, listed in <u>name</u>, which is
       a <u>namelen</u> length array of integers.

       The <b>sysctlbyname</b>() function accepts an ASCII representation of the  name  and  internally  looks  up  the
       integer name vector.  Apart from that, it behaves the same as the standard <b>sysctl</b>() function.

       The  information  is  copied  into  the buffer specified by <u>oldp</u>.  The size of the buffer is given by the
       location specified by <u>oldlenp</u> before the call, and that location gives the amount of data copied after  a
       successful  call  and  after  a  call  that  returns  with  the error code ENOMEM.  If the amount of data
       available is greater than the size of the buffer supplied, the call supplies as much data as fits in  the
       buffer  provided  and  returns  with  the  error  code ENOMEM.  If the old value is not desired, <u>oldp</u> and
       <u>oldlenp</u> should be set to NULL.

       The size of the available data can be determined by calling <b>sysctl</b>() with the  NULL  argument  for  <u>oldp</u>.
       The  size  of  the  available  data  will  be  returned  in the location pointed to by <u>oldlenp</u>.  For some
       operations, the amount of space may change often.  For these operations, the system attempts to round  up
       so that the returned size is large enough for a call to return the data shortly thereafter.

       To  set  a new value, <u>newp</u> is set to point to a buffer of length <u>newlen</u> from which the requested value is
       to be taken.  If a new value is not to be set, <u>newp</u> should be set to NULL and <u>newlen</u> set to 0.

       The <b>sysctlnametomib</b>() function accepts an ASCII representation of the name, looks  up  the  integer  name
       vector,  and  returns  the  numeric  representation  in  the mib array pointed to by <u>mibp</u>.  The number of
       elements in the mib array is given by the location specified by <u>sizep</u> before the call, and that  location
       gives  the  number  of entries copied after a successful call.  The resulting <u>mib</u> and <u>size</u> may be used in
       subsequent <b>sysctl</b>() calls to get the data associated with the requested ASCII name.   This  interface  is
       intended for use by applications that want to repeatedly request the same variable (the <b>sysctl</b>() function
       runs  in  about  a  third  the  time  as  the  same  request  made via the <b>sysctlbyname</b>() function).  The
       <b>sysctlnametomib</b>() function is also useful for fetching mib prefixes and then adding  a  final  component.
       For example, to fetch process information for processes with pid's less than 100:

             int i, mib[4];
             size_t len;
             struct kinfo_proc kp;

             /* Fill out the first three components of the mib */
             len = 4;
             sysctlnametomib("kern.proc.pid", mib, &amp;len);

             /* Fetch and print entries for pid's &lt; 100 */
             for (i = 0; i &lt; 100; i++) {
                     mib[3] = i;
                     len = sizeof(kp);
                     if (sysctl(mib, 4, &amp;kp, &amp;len, NULL, 0) == -1)
                             perror("sysctl");
                     else if (len &gt; 0)
                             printkproc(&amp;kp);
             }

       The  top  level names are defined with a CTL_ prefix in &lt;<u>sys/sysctl.h</u>&gt;, and are as follows.  The next and
       subsequent levels down are found in the include files listed here, and  described  in  separate  sections
       below.

             <b>Name</b>              <b>Next</b> <b>Level</b> <b>Names</b>          <b>Description</b>
             CTL_DEBUG         &lt;<u>sys/sysctl.h</u>&gt;            Debugging
             CTL_VFS           &lt;<u>sys/mount.h</u>&gt;             File system
             CTL_HW            &lt;<u>sys/sysctl.h</u>&gt;            Generic CPU, I/O
             CTL_KERN          &lt;<u>sys/sysctl.h</u>&gt;            High kernel limits
             CTL_MACHDEP       &lt;<u>sys/sysctl.h</u>&gt;            Machine dependent
             CTL_NET           &lt;<u>sys/socket.h</u>&gt;            Networking
             CTL_USER          &lt;<u>sys/sysctl.h</u>&gt;            User-level
             CTL_VM            &lt;<u>vm/vm_param.h</u>&gt;           Virtual memory

       For example, the following retrieves the maximum number of processes allowed in the system:

             int mib[2], maxproc;
             size_t len;

             mib[0] = CTL_KERN;
             mib[1] = KERN_MAXPROC;
             len = <a href="../manmaxproc/sizeof.maxproc.html">sizeof</a>(maxproc);
             sysctl(mib, 2, &amp;maxproc, &amp;len, NULL, 0);

       To retrieve the standard search path for the system utilities:

             int mib[2];
             size_t len;
             char *p;

             mib[0] = CTL_USER;
             mib[1] = USER_CS_PATH;
             sysctl(mib, 2, NULL, &amp;len, NULL, 0);
             p = malloc(len);
             sysctl(mib, 2, p, &amp;len, NULL, 0);

   <b>CTL_DEBUG</b>
       The debugging variables vary from system to system.  A debugging variable may be added or deleted without
       need  to  recompile  <b>sysctl</b>()  to  know about it.  Each time it runs, <b>sysctl</b>() gets the list of debugging
       variables from the kernel and displays their current values.  The system defines twenty (<u>struct</u> <u>ctldebug</u>)
       variables named <u>debug0</u> through <u>debug19</u>.  They are declared as separate variables  so  that  they  can  be
       individually  initialized at the location of their associated variable.  The loader prevents multiple use
       of the same variable by issuing errors if a variable is initialized in more than one place.  For example,
       to export the variable <u>dospecialcheck</u> as a debugging variable, the following declaration would be used:

             int dospecialcheck = 1;
             struct ctldebug debug5 = { "dospecialcheck", &amp;dospecialcheck };

   <b>CTL_VFS</b>
       A distinguished second level name, VFS_GENERIC, is  used  to  get  general  information  about  all  file
       systems.   One  of its third level identifiers is VFS_MAXTYPENUM that gives the highest valid file system
       type number.  Its other third level identifier is VFS_CONF that returns configuration  information  about
       the  file  system type given as a fourth level identifier (see <u><a href="../man3/getvfsbyname.3.html">getvfsbyname</a></u>(3) as an example of its use).
       The remaining second level identifiers are the file system type number returned by a  <u><a href="../man2/statfs.2.html">statfs</a></u>(2)  call  or
       from  VFS_CONF.   The third level identifiers available for each file system are given in the header file
       that defines the mount argument structure for that file system.

   <b>CTL_HW</b>
       The string and integer information available for the CTL_HW level  is  detailed  below.   The  changeable
       column shows whether a process with appropriate privilege may change the value.

             <b>Second</b> <b>Level</b> <b>Name</b>    <b>Type</b>          <b>Changeable</b>
             HW_MACHINE           string        no
             HW_MODEL             string        no
             HW_NCPU              integer       no
             HW_BYTEORDER         integer       no
             HW_PHYSMEM           integer       no
             HW_USERMEM           integer       no
             HW_PAGESIZE          integer       no
             HW_FLOATINGPT        integer       no
             HW_MACHINE_ARCH      string        no
             HW_REALMEM           integer       no
             HW_AVAILPAGES        integer       no

       <b>HW_MACHINE</b>
               The machine class.

       <b>HW_MODEL</b>
               The machine model

       <b>HW_NCPU</b>
               The number of cpus.

       <b>HW_BYTEORDER</b>
               The byteorder (4321 or 1234).

       <b>HW_PHYSMEM</b>
               Amount  of  physical  memory (in bytes), minus the amount used by the kernel, pre-loaded modules,
               and (on x86) the dcons buffer.

       <b>HW_USERMEM</b>
               Amount of memory (in bytes) which is not wired.

       <b>HW_PAGESIZE</b>
               The software page size.

       <b>HW_FLOATINGPT</b>
               Nonzero if the floating point support is in hardware.

       <b>HW_MACHINE_ARCH</b>
               The machine dependent architecture type.

       <b>HW_REALMEM</b>
               Amount of memory (in bytes) reported by the firmware.  That value is sometimes not sane; in  that
               case, the kernel reports the max memory address instead.

       <b>HW_AVAILPAGES</b>
               The same value as <b>HW_PHYSMEM</b>, measured in pages rather than bytes.

   <b>CTL_KERN</b>
       The  string  and  integer information available for the CTL_KERN level is detailed below.  The changeable
       column shows whether a process with appropriate privilege may  change  the  value.   The  types  of  data
       currently available are process information, system vnodes, the open file entries, routing table entries,
       virtual memory statistics, load average history, and clock rate information.

             <b>Second</b> <b>Level</b> <b>Name</b>          <b>Type</b>                   <b>Changeable</b>
             KERN_ARGMAX                integer                no
             KERN_BOOTFILE              string                 yes
             KERN_BOOTTIME              struct timeval         no
             KERN_CLOCKRATE             struct clockinfo       no
             KERN_FILE                  struct xfile           no
             KERN_HOSTID                integer                yes
             KERN_HOSTUUID              string                 yes
             KERN_HOSTNAME              string                 yes
             KERN_JOB_CONTROL           integer                no
             KERN_MAXFILES              integer                yes
             KERN_MAXFILESPERPROC       integer                yes
             KERN_MAXPROC               integer                no
             KERN_MAXPROCPERUID         integer                yes
             KERN_MAXVNODES             integer                yes
             KERN_NGROUPS               integer                no
             KERN_NISDOMAINNAME         string                 yes
             KERN_OSRELDATE             integer                no
             KERN_OSRELEASE             string                 no
             KERN_OSREV                 integer                no
             KERN_OSTYPE                string                 no
             KERN_POSIX1                integer                no
             KERN_PROC                  node                   not applicable
             KERN_PROF                  node                   not applicable
             KERN_QUANTUM               integer                yes
             KERN_SAVED_IDS             integer                no
             KERN_SECURELVL             integer                raise only
             KERN_UPDATEINTERVAL        integer                no
             KERN_VERSION               string                 no
             KERN_VNODE                 struct xvnode          no

       <b>KERN_ARGMAX</b>
               The maximum bytes of argument to <u><a href="../man2/execve.2.html">execve</a></u>(2).

       <b>KERN_BOOTFILE</b>
               The full pathname of the file from which the kernel was loaded.

       <b>KERN_BOOTTIME</b>
               A  <u>struct</u>  <u>timeval</u>  structure  is returned.  This structure contains the time that the system was
               booted.

       <b>KERN_CLOCKRATE</b>
               A <u>struct</u> <u>clockinfo</u> structure is returned.  This structure contains the  clock,  statistics  clock
               and profiling clock frequencies, the number of micro-seconds per hz tick and the skew rate.

       <b>KERN_FILE</b>
               Return the entire file table.  The returned data consists of an array of <u>struct</u> <u>xfile</u>, whose size
               depends on the current number of such objects in the system.

       <b>KERN_HOSTID</b>
               Get or set the host ID.

       <b>KERN_HOSTUUID</b>
               Get or set the host's universally unique identifier (UUID).

       <b>KERN_HOSTNAME</b>
               Get or set the hostname.

       <b>KERN_JOB_CONTROL</b>
               Return 1 if job control is available on this system, otherwise 0.

       <b>KERN_MAXFILES</b>
               The maximum number of files that may be open in the system.

       <b>KERN_MAXFILESPERPROC</b>
               The  maximum  number  of files that may be open for a single process.  This limit only applies to
               processes with an effective uid of nonzero at the time of the  open  request.   Files  that  have
               already been opened are not affected if the limit or the effective uid is changed.

       <b>KERN_MAXPROC</b>
               The maximum number of concurrent processes the system will allow.

       <b>KERN_MAXPROCPERUID</b>
               The  maximum  number  of  concurrent  processes the system will allow for a single effective uid.
               This limit only applies to processes with an effective uid of nonzero  at  the  time  of  a  fork
               request.  Processes that have already been started are not affected if the limit is changed.

       <b>KERN_MAXVNODES</b>
               The maximum number of vnodes available on the system.

       <b>KERN_NGROUPS</b>
               The maximum number of supplemental groups.

       <b>KERN_NISDOMAINNAME</b>
               The name of the current YP/NIS domain.

       <b>KERN_OSRELDATE</b>
               The  kernel  release  version  in  the format <u>MmmRxx</u>, where <u>M</u> is the major version, <u>mm</u> is the two
               digit minor version, <u>R</u> is 0 if release branch, otherwise 1, and <u>xx</u> is updated when the  available
               APIs change.

               The  userland release version is available from &lt;<u>osreldate.h</u>&gt;; parse this file if you need to get
               the release version of the currently installed userland.

       <b>KERN_OSRELEASE</b>
               The system release string.

       <b>KERN_OSREV</b>
               The system revision string.

       <b>KERN_OSTYPE</b>
               The system type string.

       <b>KERN_POSIX1</b>
               The version of IEEE Std 1003.1 (“POSIX.1”) with which the system attempts to comply.

       <b>KERN_PROC</b>
               Return selected information about specific running processes.

               For the following names, an array of <u>struct</u> <u>kinfo_proc</u> structures is returned, whose size depends
               on the current number of such objects in the system.

                     <b>Third</b> <b>Level</b> <b>Name</b>          <b>Fourth</b> <b>Level</b>
                     KERN_PROC_ALL             None
                     KERN_PROC_PID             A process ID
                     KERN_PROC_PGRP            A process group
                     KERN_PROC_TTY             A tty device
                     KERN_PROC_UID             A user ID
                     KERN_PROC_RUID            A real user ID

               If the third level name is KERN_PROC_ARGS then the command line argument array is returned  in  a
               flattened  form,  i.e.,  zero-terminated arguments follow each other.  The total size of array is
               returned.  It is also possible for a process to set its own process title this way.  If the third
               level  name  is  KERN_PROC_PATHNAME,  the  path  of  the  process'  text  file  is  stored.   For
               KERN_PROC_PATHNAME, a process ID of <b>-1</b> implies the current process.

                     <b>Third</b> <b>Level</b> <b>Name</b>          <b>Fourth</b> <b>Level</b>
                     KERN_PROC_ARGS            A process ID
                     KERN_PROC_PATHNAME        A process ID

       <b>KERN_PROF</b>
               Return  profiling  information  about  the  kernel.  If the kernel is not compiled for profiling,
               attempts to retrieve any of the KERN_PROF values will fail with ENOENT.  The  third  level  names
               for  the string and integer profiling information is detailed below.  The changeable column shows
               whether a process with appropriate privilege may change the value.

                     <b>Third</b> <b>Level</b> <b>Name</b>      <b>Type</b>                   <b>Changeable</b>
                     GPROF_STATE           integer                yes
                     GPROF_COUNT           u_short[]              yes
                     GPROF_FROMS           u_short[]              yes
                     GPROF_TOS             struct tostruct        yes
                     GPROF_GMONPARAM       struct gmonparam       no

               The variables are as follows:

               <b>GPROF_STATE</b>
                       Returns GMON_PROF_ON or GMON_PROF_OFF to show that profiling is running or stopped.

               <b>GPROF_COUNT</b>
                       Array of statistical program counter counts.

               <b>GPROF_FROMS</b>
                       Array indexed by program counter of call-from points.

               <b>GPROF_TOS</b>
                       Array of <u>struct</u> <u>tostruct</u> describing destination of calls and their counts.

               <b>GPROF_GMONPARAM</b>
                       Structure giving the sizes of the above arrays.

       <b>KERN_QUANTUM</b>
               The maximum period of time, in microseconds, for which a process is allowed to run without  being
               preempted if other processes are in the run queue.

       <b>KERN_SAVED_IDS</b>
               Returns 1 if saved set-group and saved set-user ID is available.

       <b>KERN_SECURELVL</b>
               The system security level.  This level may be raised by processes with appropriate privilege.  It
               may not be lowered.

       <b>KERN_VERSION</b>
               The system version string.

       <b>KERN_VNODE</b>
               Return the entire vnode table.  Note, the vnode table is not necessarily a consistent snapshot of
               the  system.   The returned data consists of an array whose size depends on the current number of
               such objects in the system.  Each element of the array consists of a <u>struct</u> <u>xvnode</u>.

   <b>CTL_NET</b>
       The string and integer information available for the CTL_NET level is  detailed  below.   The  changeable
       column shows whether a process with appropriate privilege may change the value.

             <b>Second</b> <b>Level</b> <b>Name</b>          <b>Type</b>                   <b>Changeable</b>
             PF_ROUTE                   routing messages       no
             PF_INET                    IPv4 values            yes
             PF_INET6                   IPv6 values            yes

       <b>PF_ROUTE</b>
               Return the entire routing table or a subset of it.  The data is returned as a sequence of routing
               messages  (see  <u><a href="../man4/route.4.html">route</a></u>(4) for the header file, format and meaning).  The length of each message is
               contained in the message header.

               The third level name is a protocol number, which is currently always 0.  The fourth level name is
               an address family, which may be set to 0 to select all address families.  The fifth,  sixth,  and
               seventh level names are as follows:

                     <b>Fifth</b> <b>level</b>    <b>Sixth</b> <b>Level</b>    <b>Seventh</b> <b>Level</b>
                     NET_RT_FLAGS   rtflags        None
                     NET_RT_DUMP    None           None or fib number
                     NET_RT_IFLIST  0 or if_index  None
                     NET_RT_IFMALIST               0 or if_index    None
                     NET_RT_IFLISTL 0 or if_index  None

               The  NET_RT_IFMALIST name returns information about multicast group memberships on all interfaces
               if 0 is specified, or for the interface specified by <u>if_index</u>.

               The NET_RT_IFLISTL is like NET_RT_IFLIST, just returning message header structs  with  additional
               fields  allowing  the  interface  to  be  extended  without  breaking  binary compatibility.  The
               NET_RT_IFLISTL uses 'l' versions of the message header structures: <u>struct</u> <u>if_msghdrl</u>  and  <u>struct</u>
               <u>ifa_msghdrl</u>.

       <b>PF_INET</b>
               Get  or  set  various global information about the IPv4 (Internet Protocol version 4).  The third
               level name is the protocol.  The fourth level name is the variable name.  The  currently  defined
               protocols and names are:

               <b>Protocol</b>      <b>Variable</b>      <b>Type</b>      <b>Changeable</b>
               icmp          bmcastecho    integer   yes
               icmp          maskrepl      integer   yes
               ip            forwarding    integer   yes
               ip            redirect      integer   yes
               ip            ttl           integer   yes
               udp           checksum      integer   yes

               The variables are as follows:

               <b>icmp.bmcastecho</b>
                       Returns 1 if an ICMP echo request to a broadcast or multicast address is to be answered.

               <b>icmp.maskrepl</b>
                       Returns 1 if ICMP network mask requests are to be answered.

               <b>ip.forwarding</b>
                       Returns  1 when IP forwarding is enabled for the host, meaning that the host is acting as
                       a router.

               <b>ip.redirect</b>
                       Returns 1 when ICMP redirects may be sent by the host.  This option is ignored unless the
                       host is routing IP packets, and should normally be enabled on all systems.

               <b>ip.ttl</b>  The maximum time-to-live (hop count) value for an IP packet sourced by the system.   This
                       value applies to normal transport protocols, not to ICMP.

               <b>udp.checksum</b>
                       Returns  1 when UDP checksums are being computed and checked.  Disabling UDP checksums is
                       strongly discouraged.

                       For variables net.inet.*.ipsec, please refer to <u><a href="../man4/ipsec.4.html">ipsec</a></u>(4).

       <b>PF_INET6</b>
               Get or set various global information about the IPv6 (Internet Protocol version  6).   The  third
               level name is the protocol.  The fourth level name is the variable name.

               For  variables  net.inet6.*  please  refer to <u><a href="../man4/inet6.4.html">inet6</a></u>(4).  For variables net.inet6.*.ipsec6, please
               refer to <u><a href="../man4/ipsec.4.html">ipsec</a></u>(4).

   <b>CTL_USER</b>
       The string and integer information available for the CTL_USER level is detailed  below.   The  changeable
       column shows whether a process with appropriate privilege may change the value.

             <b>Second</b> <b>Level</b> <b>Name</b>           <b>Type</b>          <b>Changeable</b>
             USER_BC_BASE_MAX            integer       no
             USER_BC_DIM_MAX             integer       no
             USER_BC_SCALE_MAX           integer       no
             USER_BC_STRING_MAX          integer       no
             USER_COLL_WEIGHTS_MAX       integer       no
             USER_CS_PATH                string        no
             USER_EXPR_NEST_MAX          integer       no
             USER_LINE_MAX               integer       no
             USER_POSIX2_CHAR_TERM       integer       no
             USER_POSIX2_C_BIND          integer       no
             USER_POSIX2_C_DEV           integer       no
             USER_POSIX2_FORT_DEV        integer       no
             USER_POSIX2_FORT_RUN        integer       no
             USER_POSIX2_LOCALEDEF       integer       no
             USER_POSIX2_SW_DEV          integer       no
             USER_POSIX2_UPE             integer       no
             USER_POSIX2_VERSION         integer       no
             USER_RE_DUP_MAX             integer       no
             USER_STREAM_MAX             integer       no
             USER_TZNAME_MAX             integer       no

       <b>USER_BC_BASE_MAX</b>
               The maximum ibase/obase values in the <u><a href="../man1/bc.1.html">bc</a></u>(1) utility.

       <b>USER_BC_DIM_MAX</b>
               The maximum array size in the <u><a href="../man1/bc.1.html">bc</a></u>(1) utility.

       <b>USER_BC_SCALE_MAX</b>
               The maximum scale value in the <u><a href="../man1/bc.1.html">bc</a></u>(1) utility.

       <b>USER_BC_STRING_MAX</b>
               The maximum string length in the <u><a href="../man1/bc.1.html">bc</a></u>(1) utility.

       <b>USER_COLL_WEIGHTS_MAX</b>
               The  maximum  number of weights that can be assigned to any entry of the LC_COLLATE order keyword
               in the locale definition file.

       <b>USER_CS_PATH</b>
               Return a value for the PATH environment variable that finds all the standard utilities.

       <b>USER_EXPR_NEST_MAX</b>
               The maximum number of expressions that can be nested within parenthesis by the <u><a href="../man1/expr.1.html">expr</a></u>(1) utility.

       <b>USER_LINE_MAX</b>
               The maximum length in bytes of a text-processing utility's input line.

       <b>USER_POSIX2_CHAR_TERM</b>
               Return 1 if the system supports at least one terminal type capable of all operations described in
               IEEE Std 1003.2 (“POSIX.2”), otherwise 0.

       <b>USER_POSIX2_C_BIND</b>
               Return 1 if the system's  C-language  development  facilities  support  the  C-Language  Bindings
               Option, otherwise 0.

       <b>USER_POSIX2_C_DEV</b>
               Return 1 if the system supports the C-Language Development Utilities Option, otherwise 0.

       <b>USER_POSIX2_FORT_DEV</b>
               Return 1 if the system supports the FORTRAN Development Utilities Option, otherwise 0.

       <b>USER_POSIX2_FORT_RUN</b>
               Return 1 if the system supports the FORTRAN Runtime Utilities Option, otherwise 0.

       <b>USER_POSIX2_LOCALEDEF</b>
               Return 1 if the system supports the creation of locales, otherwise 0.

       <b>USER_POSIX2_SW_DEV</b>
               Return 1 if the system supports the Software Development Utilities Option, otherwise 0.

       <b>USER_POSIX2_UPE</b>
               Return 1 if the system supports the User Portability Utilities Option, otherwise 0.

       <b>USER_POSIX2_VERSION</b>
               The version of IEEE Std 1003.2 (“POSIX.2”) with which the system attempts to comply.

       <b>USER_RE_DUP_MAX</b>
               The  maximum number of repeated occurrences of a regular expression permitted when using interval
               notation.

       <b>USER_STREAM_MAX</b>
               The minimum maximum number of streams that a process may have open at any one time.

       <b>USER_TZNAME_MAX</b>
               The minimum maximum number of types supported for the name of a timezone.

   <b>CTL_VM</b>
       The string and integer information available for the CTL_VM level  is  detailed  below.   The  changeable
       column shows whether a process with appropriate privilege may change the value.

             <b>Second</b> <b>Level</b> <b>Name</b>          <b>Type</b>                 <b>Changeable</b>
             VM_LOADAVG                 struct loadavg       no
             VM_TOTAL                   struct vmtotal       no
             VM_SWAPPING_ENABLED        integer              maybe
             VM_V_FREE_MIN              integer              yes
             VM_V_FREE_RESERVED         integer              yes
             VM_V_FREE_TARGET           integer              yes
             VM_V_INACTIVE_TARGET       integer              yes
             VM_V_PAGEOUT_FREE_MIN      integer              yes
             VM_OVERCOMMIT              integer              yes

       <b>VM_LOADAVG</b>
               Return the load average history.  The returned data consists of a <u>struct</u> <u>loadavg</u>.

       <b>VM_TOTAL</b>
               Return  the  system  wide  virtual  memory  statistics.   The  returned data consists of a <u>struct</u>
               <u>vmtotal</u>.

       <b>VM_SWAPPING_ENABLED</b>
               1 if process swapping is enabled or 0 if disabled.  This variable is permanently set to 0 if  the
               kernel was built with swapping disabled.

       <b>VM_V_FREE_MIN</b>
               Minimum  amount  of  memory  (cache  memory  plus  free memory) required to be available before a
               process waiting on memory will be awakened.

       <b>VM_V_FREE_RESERVED</b>
               Processes will awaken the pageout daemon and wait for memory if the number  of  free  and  cached
               pages drops below this value.

       <b>VM_V_FREE_TARGET</b>
               The  total  amount  of  free  memory  (including  cache  memory) that the pageout daemon tries to
               maintain.

       <b>VM_V_INACTIVE_TARGET</b>
               The desired number of inactive pages that  the  pageout  daemon  should  achieve  when  it  runs.
               Inactive pages can be quickly inserted into process address space when needed.

       <b>VM_V_PAGEOUT_FREE_MIN</b>
               If  the  amount  of  free  and cache memory falls below this value, the pageout daemon will enter
               "memory conserving mode" to avoid deadlock.

       <b>VM_OVERCOMMIT</b>
               Overcommit behaviour, as described in <u><a href="../man7/tuning.7.html">tuning</a></u>(7).

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Upon successful completion, the value 0 is returned; otherwise the value -1 is returned  and  the  global
       variable <u>errno</u> is set to indicate the error.

</pre><h4><b>FILES</b></h4><pre>
       &lt;<u>sys/sysctl.h</u>&gt;        definitions   for   top   level  identifiers,  second  level  kernel  and  hardware
                             identifiers, and user level identifiers
       &lt;<u>sys/socket.h</u>&gt;        definitions for second level network identifiers
       &lt;<u>sys/gmon.h</u>&gt;          definitions for third level profiling identifiers
       &lt;<u>vm/vm_param.h</u>&gt;       definitions for second level virtual memory identifiers
       &lt;<u>netinet/in.h</u>&gt;        definitions  for  third  level  IPv4/IPv6  identifiers  and  fourth  level  IPv4/v6
                             identifiers
       &lt;<u>netinet/icmp_var.h</u>&gt;  definitions for fourth level ICMP identifiers
       &lt;<u>netinet/icmp6.h</u>&gt;     definitions for fourth level ICMPv6 identifiers
       &lt;<u>netinet/udp_var.h</u>&gt;   definitions for fourth level UDP identifiers

</pre><h4><b>ERRORS</b></h4><pre>
       The following errors may be reported:

       [EFAULT]           The buffer <u>name</u>, <u>oldp</u>, <u>newp</u>, or length pointer <u>oldlenp</u> contains an invalid address.

       [EINVAL]           The <u>name</u> array is less than two or greater than CTL_MAXNAME.

       [EINVAL]           A non-null <u>newp</u> is given and its specified length in <u>newlen</u> is too large or too small.

       [ENOMEM]           The length pointed to by <u>oldlenp</u> is too short to hold the requested value.

       [ENOMEM]           The  smaller  of  either the length pointed to by <u>oldlenp</u> or the estimated size of the
                          returned data exceeds the system limit on locked memory.

       [ENOMEM]           Locking the buffer <u>oldp</u>, or a portion of the buffer if the estimated size of the  data
                          to  be  returned  is smaller, would cause the process to exceed its per-process locked
                          memory limit.

       [ENOTDIR]          The <u>name</u> array specifies an intermediate rather than terminal name.

       [EISDIR]           The <u>name</u> array specifies a terminal name, but the actual name is not terminal.

       [ENOENT]           The <u>name</u> array specifies a value that is unknown.

       [EPERM]            An attempt is made to set a read-only value.

       [EPERM]            A process without appropriate privilege attempts to set a value.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/confstr.3.html">confstr</a></u>(3), <u><a href="../man3/kvm.3.html">kvm</a></u>(3), <u><a href="../man3/sysconf.3.html">sysconf</a></u>(3), <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>sysctl</b>() function first appeared in 4.4BSD.

Debian                                           March 22, 2019                                        <u><a href="../man3/SYSCTL.3.html">SYSCTL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>