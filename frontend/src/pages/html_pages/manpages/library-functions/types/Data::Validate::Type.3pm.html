<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Validate::Type - Data type validation functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-validate-type-perl">libdata-validate-type-perl_1.6.0-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Validate::Type - Data type validation functions.

</pre><h4><b>VERSION</b></h4><pre>
       Version 1.6.0

</pre><h4><b>SYNOPSIS</b></h4><pre>
               # Call with explicit package name.
               use Data::Validate::Type;
               if ( Data::Validate::Type::is_string( 'test' ) )
               {
                       # ...
               }

               # Import specific functions.
               use Data::Validate::Type qw( is_string );
               if ( is_string( 'test' ) )
               {
                       # ...
               }

               # Import functions for a given paradigm.
               use Data::Validate::Type qw( :boolean_tests );
               if ( is_string( 'test' ) )
               {
                       # ...
               }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Params::Util is a wonderful module, but suffers from a few drawbacks:

       •   Function names start with an underscore, which is usually used to indicate private functions.

       •   Function names are uppercase, which is usually used to indicate file handles or constants.

       •   Function names don't pass PerlCritic's validation, making them problematic to import.

       •   Functions  use  by default the convention that collection that collections need to not be empty to be
           valid (see _ARRAY0/_ARRAY for example), which is counter-intuitive.

       •   In Pure Perl mode, the functions are created via eval, which causes issues for Devel::Cover in  taint
           mode.

       Those drawbacks are purely cosmetic and don't affect the usefulness of the functions, except for the last
       one.  This  module  used to encapsulate Params::Util, but I had to refactor it out to fix the issues with
       Devel::Cover.

       Please note that I prefer long function names that are descriptive, to arcane short ones. This  increases
       readability, and the bulk of the typing can be spared with the use of a good IDE like Padre.

       Also,  this  is  work in progress - There is more functions that should be added here, if you need one in
       particular feel free to contact me.

</pre><h4><b>BOOLEAN</b> <b>TEST</b> <b>FUNCTIONS</b></h4><pre>
       Functions in this group return a boolean to indicate whether the  parameters  passed  match  the  test(s)
       specified by the functions or not.

       All the boolean functions can be imported at once in your namespace with the following line:

               use Data::Validate::Type qw( :boolean_tests );

   <b>is_string()</b>
       Return a boolean indicating if the variable passed is a string.

               my $is_string = Data::Validate::Type::is_string( $variable );

       Note: 0 and '' (empty string) are valid strings.

       Parameters:

       •   allow_empty

           Boolean, default 1. Allow the string to be empty or not.

   <b>is_arrayref()</b>
       Return a boolean indicating if the variable passed is an arrayref that can be dereferenced into an array.

               my $is_arrayref = Data::Validate::Type::is_arrayref( $variable );

               my $is_arrayref = Data::Validate::Type::is_arrayref(
                       $variable,
                       allow_empty =&gt; 1,
                       no_blessing =&gt; 0,
               );

               # Check if the variable is an arrayref of hashrefs.
               my $is_arrayref = Data::Validate::Type::is_arrayref(
                       $variable,
                       allow_empty           =&gt; 1,
                       no_blessing           =&gt; 0,
                       element_validate_type =&gt;
                               sub
                               {
                                       return Data::Validate::Type::is_hashref( $_[0] );
                               },
               );

       Parameters:

       •   allow_empty

           Boolean, default 1. Allow the array to be empty or not.

       •   no_blessing

           Boolean, default 0. Require that the variable is not blessed.

       •   element_validate_type

           None  by  default.  Set  it  to a coderef to validate the elements in the array.  The coderef will be
           passed the element to validate as first parameter, and it must return a  boolean  indicating  whether
           the element was valid or not.

   <b>is_hashref()</b>
       Return a boolean indicating if the variable passed is a hashref that can be dereferenced into a hash.

               my $is_hashref = Data::Validate::Type::is_hashref( $variable );

               my $is_hashref = Data::Validate::Type::is_hashref(
                       $variable,
                       allow_empty =&gt; 1,
                       no_blessing =&gt; 0,
               );

       Parameters:

       •   allow_empty

           Boolean, default 1. Allow the array to be empty or not.

       •   no_blessing

           Boolean, default 0. Require that the variable is not blessed.

   <b>is_coderef()</b>
       Return a boolean indicating if the variable passed is an coderef that can be dereferenced into a block of
       code.

               my $is_coderef = Data::Validate::Type::is_coderef( $variable );

   <b>is_number()</b>
       Return a boolean indicating if the variable passed is a number.

               my $is_number = Data::Validate::Type::is_number( $variable );
               my $is_number = Data::Validate::Type::is_number(
                       $variable,
                       positive =&gt; 1,
               );
               my $is_number = Data::Validate::Type::is_number(
                       $variable,
                       strictly_positive =&gt; 1,
               );

       Parameters:

       •   strictly_positive

           Boolean, default 0. Set to 1 to check for a strictly positive number.

       •   positive

           Boolean, default 0. Set to 1 to check for a positive number.

   <b>is_instance()</b>
       Return a boolean indicating if the variable is an instance of the given class.

       Note  that  this handles inheritance properly, so it will return true if the variable is an instance of a
       subclass of the class given.

               my $is_instance = Data::Validate::Type::is_instance(
                       $variable,
                       class =&gt; $class,
               );

       Parameters:

       •   class

           Required, the name of the class to check the variable against.

   <b>is_regex()</b>
       Return a boolean indicating if the variable is a regular expression.

               my $is_regex = Data::Validate::Type::is_regex( $variable );

</pre><h4><b>ASSERTION-BASED</b> <b>FUNCTIONS</b></h4><pre>
       Functions in this group do not return anything, but will die when the parameters passed don't  match  the
       test(s) specified by the functions.

       All the assertion test functions can be imported at once in your namespace with the following line:

               use Data::Validate::Type qw( :assertions );

   <b>assert_string()</b>
       Die unless the variable passed is a string.

               Data::Validate::Type::assert_string( $variable );

       Note: 0 and '' (empty string) are valid strings.

       Parameters:

       •   allow_empty

           Boolean, default 1. Allow the string to be empty or not.

   <b>assert_arrayref()</b>
       Die unless the variable passed is an arrayref that can be dereferenced into an array.

               Data::Validate::Type::assert_arrayref( $variable );

               Data::Validate::Type::assert_arrayref(
                       $variable,
                       allow_empty =&gt; 1,
                       no_blessing =&gt; 0,
               );

               # Require the variable to be an arrayref of hashrefs.
               Data::Validate::Type::assert_arrayref(
                       $variable,
                       allow_empty           =&gt; 1,
                       no_blessing           =&gt; 0,
                       element_validate_type =&gt;
                               sub
                               {
                                       return Data::Validate::Type::is_hashref( $_[0] );
                               },
               );

       Parameters:

       •   allow_empty

           Boolean, default 1. Allow the array to be empty or not.

       •   no_blessing

           Boolean, default 0. Require that the variable is not blessed.

       •   element_validate_type

           None  by  default.  Set  it  to a coderef to validate the elements in the array.  The coderef will be
           passed the element to validate as first parameter, and it must return a  boolean  indicating  whether
           the element was valid or not.

   <b>assert_hashref()</b>
       Die unless the variable passed is a hashref that can be dereferenced into a hash.

               Data::Validate::Type::assert_hashref( $variable );

               Data::Validate::Type::assert_hashref(
                       $variable,
                       allow_empty =&gt; 1,
                       no_blessing =&gt; 0,
               );

       Parameters:

       •   allow_empty

           Boolean, default 1. Allow the array to be empty or not.

       •   no_blessing

           Boolean, default 0. Require that the variable is not blessed.

   <b>assert_coderef()</b>
       Die unless the variable passed is an coderef that can be dereferenced into a block of code.

               Data::Validate::Type::assert_coderef( $variable );

   <b>assert_number()</b>
       Die unless the variable passed is a number.

               Data::Validate::Type::assert_number( $variable );
               Data::Validate::Type::assert_number(
                       $variable,
                       positive =&gt; 1,
               );
               Data::Validate::Type::assert_number(
                       $variable,
                       strictly_positive =&gt; 1,
               );

       Parameters:

       •   strictly_positive

           Boolean, default 0. Set to 1 to check for a strictly positive number.

       •   positive

           Boolean, default 0. Set to 1 to check for a positive number.

   <b>assert_instance()</b>
       Die unless the variable is an instance of the given class.

       Note  that  this  handles  inheritance  properly,  so it will not die if the variable is an instance of a
       subclass of the class given.

               Data::Validate::Type::assert_instance(
                       $variable,
                       class =&gt; $class,
               );

       Parameters:

       •   class

           Required, the name of the class to check the variable against.

   <b>assert_regex()</b>
       Die unless the variable is a regular expression.

               Data::Validate::Type::assert_regex( $variable );

</pre><h4><b>FILTERING</b> <b>FUNCTIONS</b></h4><pre>
       Functions in this group return the variable tested against when it matches the test(s) specified  by  the
       functions.

       All the filtering functions can be imported at once in your namespace with the following line:

               use Data::Validate::Type qw( :filters );

   <b>filter_string()</b>
       Return the variable passed if it is a string, otherwise return undef.

               Data::Validate::Type::filter_string( $variable );

       Note: 0 and '' (empty string) are valid strings.

       Parameters:

       •   allow_empty

           Boolean, default 1. Allow the string to be empty or not.

   <b>filter_arrayref()</b>
       Return the variable passed if it is an arrayref that can be dereferenced into an array, otherwise undef.

               Data::Validate::Type::filter_arrayref( $variable );

               Data::Validate::Type::filter_arrayref(
                       $variable,
                       allow_empty =&gt; 1,
                       no_blessing =&gt; 0,
               );

               # Only return the variable if it is an arrayref of hashrefs.
               Data::Validate::Type::filter_arrayref(
                       $variable,
                       allow_empty           =&gt; 1,
                       no_blessing           =&gt; 0,
                       element_validate_type =&gt;
                               sub
                               {
                                       return Data::Validate::Type::is_hashref( $_[0] );
                               },
               );

       Parameters:

       •   allow_empty

           Boolean, default 1. Allow the array to be empty or not.

       •   no_blessing

           Boolean, default 0. Require that the variable is not blessed.

       •   element_validate_type

           None  by  default.  Set  it  to a coderef to validate the elements in the array.  The coderef will be
           passed the element to validate as first parameter, and it must return a  boolean  indicating  whether
           the element was valid or not.

   <b>filter_hashref()</b>
       Return  the  variable  passed  if  it is a hashref that can be dereferenced into a hash, otherwise return
       undef.

               Data::Validate::Type::filter_hashref( $variable );

               Data::Validate::Type::filter_hashref(
                       $variable,
                       allow_empty =&gt; 1,
                       no_blessing =&gt; 0,
               );

       Parameters:

       •   allow_empty

           Boolean, default 1. Allow the array to be empty or not.

       •   no_blessing

           Boolean, default 0. Require that the variable is not blessed.

   <b>filter_coderef()</b>
       Return the variable passed if it is a coderef that can be dereferenced into a block  of  code,  otherwise
       return undef.

               Data::Validate::Type::filter_coderef( $variable );

   <b>filter_number()</b>
       Return the variable passed if it is a number, otherwise return undef.

               Data::Validate::Type::filter_number( $variable );
               Data::Validate::Type::filter_number(
                       $variable,
                       positive =&gt; 1,
               );
               Data::Validate::Type::filter_number(
                       $variable,
                       strictly_positive =&gt; 1,
               );

       Parameters:

       •   strictly_positive

           Boolean, default 0. Set to 1 to check for a strictly positive number.

       •   positive

           Boolean, default 0. Set to 1 to check for a positive number.

   <b>filter_instance()</b>
       Return the variable passed if it is an instance of the given class.

       Note  that  this  handles  inheritance properly, so it will return the variable if it is an instance of a
       subclass of the class given.

               Data::Validate::Type::filter_instance(
                       $variable,
                       class =&gt; $class,
               );

       Parameters:

       •   class

           Required, the name of the class to check the variable against.

   <b>filter_regex()</b>
       Return the variable passed if it is a regular expression.

               Data::Validate::Type::filter_regex( $variable );

</pre><h4><b>BUGS</b></h4><pre>
       Please    report    any    bugs    or    feature    requests    through    the    web    interface     at
       &lt;https://github.com/guillaumeaubert/Data-Validate-Type/issues&gt;.   I  will  be  notified,  and then you'll
       automatically be notified of progress on your bug as I make changes.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

               perldoc Data::Validate::Type

       You can also look for information at:

       •   GitHub (report bugs there)

           &lt;https://github.com/guillaumeaubert/Data-Validate-Type/issues&gt;

       •   AnnoCPAN: Annotated CPAN documentation

           &lt;<a href="http://annocpan.org/dist/Data-Validate-Type">http://annocpan.org/dist/Data-Validate-Type</a>&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/Data-Validate-Type">http://cpanratings.perl.org/d/Data-Validate-Type</a>&gt;

       •   MetaCPAN

           &lt;https://metacpan.org/release/Data-Validate-Type&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Guillaume Aubert &lt;https://metacpan.org/author/AUBERTG&gt;, "&lt;aubertg at cpan.org&gt;".

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Adam Kennedy for writing Params::Util. This module started as an encapsulation for Params::Util
       and I learnt quite a bit from it.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2012-2017 Guillaume Aubert.

       This code is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl  5
       itself.

       This  program  is  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
       the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See  the  LICENSE  file  for
       more details.

perl v5.36.0                                       2023-02-05                          <u>Data::Validate::<a href="../man3pm/Type.3pm.html">Type</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>