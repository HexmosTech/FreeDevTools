<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Compile::Cache - Cache compiled XML translators</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-compile-cache-perl">libxml-compile-cache-perl_1.06-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Compile::Cache - Cache compiled XML translators

</pre><h4><b>INHERITANCE</b></h4><pre>
        XML::Compile::Cache
          is a XML::Compile::Schema
          is a XML::Compile

</pre><h4><b>SYNOPSIS</b></h4><pre>
        my $cache = XML::Compile::Cache-&gt;new(...);

        $cache-&gt;declare('READER',  $type,  @options);
        $cache-&gt;declare(RW     =&gt; \@types, @options);
        $cache-&gt;declare(WRITER =&gt;  $type, \@options);

        $cache-&gt;compileAll;
        $cache-&gt;compileAll('RW');

        # get the cached code ref for the reader
        my $reader = $cache-&gt;reader($type, @opts);
        use Data::Dumper;
        print Dumper $reader-&gt;($xml);

        # get the cached code ref for the writer, and use it
        my $doc = XML::LibXML::Document-&gt;new('1.0', 'UTF-8');
        my $xml = $cache-&gt;writer($type)-&gt;($doc, $perl);
        print $xml-&gt;<a href="../man1/toString.1.html">toString</a>(1);

        # use the base-class uncached, the XML::Compile::Schema
        my $do = $cache-&gt;compile(READER =&gt; $type, @opts);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Extends "DESCRIPTION" in XML::Compile::Schema.

</pre><h4><b>METHODS</b></h4><pre>
       Extends "METHODS" in XML::Compile::Schema.

   <b>Constructors</b>
       Extends "Constructors" in XML::Compile::Schema.

       XML::Compile::Cache-&gt;<b>new</b>( [$xml], %options )
            -Option            --Defined in          --Default
             allow_undeclared                          &lt;false&gt;
             any_element                               'ATTEMPT'
             block_namespace     XML::Compile::Schema  []
             hook                XML::Compile::Schema  undef
             hooks               XML::Compile::Schema  []
             ignore_unused_tags  XML::Compile::Schema  &lt;false&gt;
             key_rewrite         XML::Compile::Schema  []
             opts_readers                              []
             opts_rw                                   []
             opts_writers                              []
             parser_options      XML::Compile          &lt;many&gt;
             prefixes                                  &lt;smart&gt;
             schema_dirs         XML::Compile          undef
             typemap                                   {}
             xsi_type                                  {}

           allow_undeclared =&gt; BOOLEAN
             When  true,  you may call the reader or writer with types which were not registered with <u>declare()</u>.
             In that case, the reader or writer may also get options passed for the compiler, as  long  as  they
             are consistent over each use of the type.

           any_element =&gt; CODE|'TAKE_ALL'|'SKIP_ALL'|'ATTEMPT'|'SLOPPY'
             See <u>anyElement()</u>.

             [1.02]  the  default  is to ATTEMPT compiling any handlers automatically.  Before version 1.02, the
             default was to SKIP_ALL elements which would match the occurs and namespace restrictions of the any
             specification.  However, that fails for reperative blocks (for instance, it  fails  for  an  choice
             which may occur unbounded times)

           block_namespace =&gt; NAMESPACE|TYPE|HASH|CODE|ARRAY
           hook =&gt; $hook|ARRAY
           hooks =&gt; ARRAY
           ignore_unused_tags =&gt; BOOLEAN|REGEXP
           key_rewrite =&gt; HASH|CODE|ARRAY
           opts_readers =&gt; HASH|ARRAY-of-PAIRS
           opts_rw =&gt; HASH|ARRAY-of-PAIRS
             Options  added  to  both  READERs  and  WRITERS.   Options  which  are  passed  with  <u>declare()</u> and
             "opts_readers" or "opts_writers" will overrule these.  See <u>addCompileOptions()</u>.

           opts_writers =&gt; HASH|ARRAY-of-PAIRS
           parser_options =&gt; HASH|ARRAY
           prefixes =&gt; HASH|ARRAY-of-PAIRS
             Define prefix name to name-space mappings.  Passed to compile(prefixes) for each reader and writer,
             but also used to permit <u>findName()</u> to accept types which use a prefix.

             Specify an ARRAY of (prefix, name-space) pairs, or a HASH which maps name-spaces to prefixes  (HASH
             order  is  reversed from ARRAY order!)  When you wish to collect the results, like usage counts, of
             the translation processing, you will need to specify a HASH.

              prefixes =&gt; [ mine =&gt; $myns, your =&gt; $yourns ]
              prefixes =&gt; { $myns =&gt; 'mine', $yourns =&gt; 'your' }

              # the previous is short for:
              prefixes =&gt; { $myns =&gt; [ uri =&gt; $myns, prefix =&gt; 'mine', used =&gt; 0 ]
                          , $yourns =&gt; [ uri =&gt; $yourns, prefix =&gt; 'your', ...] }

           schema_dirs =&gt; $directory|ARRAY-OF-directories
           typemap =&gt; HASH|ARRAY
           xsi_type =&gt; HASH|ARRAY

   <b>Accessors</b>
       Extends "Accessors" in XML::Compile::Schema.

       $obj-&gt;<b>addHook</b>($hook|LIST|undef)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addHooks</b>( $hook, [$hook, ...] )
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addKeyRewrite</b>($predef|CODE|HASH, ...)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addSchemaDirs</b>(@directories|$filename)
       XML::Compile::Cache-&gt;<b>addSchemaDirs</b>(@directories|$filename)
           Inherited, see "Accessors" in XML::Compile

       $obj-&gt;<b>addSchemas</b>($xml, %options)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addTypemap</b>(PAIR)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addTypemaps</b>(PAIRS)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addXsiType</b>( [HASH|ARRAY|LIST] )
           [1.01] add global xsi_type declarations.  Returns the xsiType set.  The ARRAY or LIST contains pairs,
           just like the HASH.

           The value component can be 'AUTO' to automatically detect the "xsi:type" extensions.  This does  only
           work for complex types.

       $obj-&gt;<b>allowUndeclared</b>( [BOOLEAN] )
           Whether it is permitted to create readers and writers which are not declared cleanly.

       $obj-&gt;<b>anyElement</b>('ATTEMPT'|'SLOPPY'|'SKIP_ALL'|'TAKE_ALL'|CODE)
           [as method since 0.99] How to process ANY elements, see also new(any_element).

           Reader:  "ATTEMPT" will convert all any elements, applying the reader for each element found. When an
           element is not found in a schema, it will be included as XML::LibXML::Element node.

           [0.93] Reader: With "SLOPPY", first automatic typed conversion is attempted. But is the type  is  not
           known, <u>XML::LibXML::Simple::XMLin()</u> is called to the resque.

       $obj-&gt;<b>blockNamespace</b>($ns|$type|HASH|CODE|ARRAY)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>hooks</b>( [&lt;'READER'|'WRITER'&gt;] )
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>typemap</b>( [HASH|ARRAY|PAIRS] )
           [0.98] Add global knowledge on typemaps.  Returns the typemap.

       $obj-&gt;<b>useSchema</b>( $schema, [$schema, ...] )
           Inherited, see "Accessors" in XML::Compile::Schema

   <b>Prefix</b> <b>management</b>
       The  cache  layer  on top of XML::Compile::Schema adds smart use of prefixes.  Of course, smartness comes
       with a small performance cost, but the code gets much cleaner.

       $obj-&gt;<b>addNicePrefix</b>(BASE, NAMESPACE)
           [1.03] Register NAMESPACE -if not yet defined- with prefix name  BASE.   When  that  prefix  name  is
           already  in use for some other namespace, BASE followed by a number are attempted (starting with 01).
           The prefix is returned.

           When the BASE already ends on a number, that number will get counted.

           example:

             my $prefix = $schema-&gt;addNicePrefix('call', $myns);
             # $prefix now can be call, call01, call02 etc

       $obj-&gt;<b>addPrefixes</b>( [PAIRS|ARRAY|HASH] )
           The X::C logic does auto-detect prefix/namespaces combinations from the  XML,  but  does  not  search
           extensively  for  namespace  declarations.  Also, sometimes the same namespace is used with different
           prefixes.  Sometimes, the same prefix is used for different namesapces.  To  complete  the  list,  or
           control the actual prefix being used, you explicitly declare combinations.

           The  <b>best</b>  <b>way</b>  to  add prefixes is via new(prefixes), which will give your names preference over the
           names found in the schema's which get loaded.  For instance, use "::WSDL-&gt;new(prefixes =&gt;  [  $prefix
           =&gt; $ns ]"

           [0.995]  Returns the HASH with prefix to name-space translations.  You should not modify the returned
           HASH: new PAIRS of prefix to namespace relations can be passed as arguments.

           [0.14] If a name-space appears for the second time,  then  the  new  prefix  will  be  recognized  by
           <u>findName()</u>,  but  not  used in the output.  When the prefix already exists for a different namespace,
           then an error will be casted.

           [0.90] You may also provide an ARRAY of pairs or a HASH.

       $obj-&gt;<b>learnPrefixes</b>($node)
           [0.993] Take all the prefixes defined in the $node, and XML::LibXML::Element.  This is not recursive:
           only on those defined at the top $node.

       $obj-&gt;<b>prefix</b>($prefix)
           Lookup a prefix definition.  This returns a HASH with namespace info.

       $obj-&gt;<b>prefixFor</b>($uri)
           Lookup the preferred prefix for the $uri.

       $obj-&gt;<b>prefixed</b>( $type|&lt;$ns,$local&gt; )
           Translate the fully qualified $type into a prefixed version.  Will produce undef if the namespace  is
           unknown.

           [0.993]  When  your  $type is not in packed form, you can specify a namespace and $local type name as
           separate arguments.

           example:

              print $schema-&gt;prefixed($type) || $type;
              print $schema-&gt;prefixed($ns, $local);

       $obj-&gt;<b>prefixes</b>( [$params] )
           Return prefixes table.  The $params are deprecated since [0.995], see <u>addPrefixes()</u>.

   <b>Compilers</b>
       The name of this module refers to its power to administer compiled XML encoders  (writers)  and  decoders
       (readers).   This  means  that  your  program  only  need  to  pass  on  a ::Cache object (for instance a
       XML::Compile::WSDL11, not a CODE reference for each compiled translator.

       Extends "Compilers" in XML::Compile::Schema.

       $obj-&gt;<b>addCompileOptions</b>( ['READERS'|'WRITERS'|'RW'], %options )
           [0.99] You may provide global compile options with new(opts_rw), "opts_readers"  and  "opts_writers",
           but also later using this method.

       $obj-&gt;<b>compile</b>( &lt;'READER'|'WRITER'&gt;, $type, %options )
           Inherited, see "Compilers" in XML::Compile::Schema

       $obj-&gt;<b>compileAll</b>( ['READERS'|'WRITERS'|'RW', [$ns]] )
           Compile  all  the  declared  readers and writers with the default 'RW').  You may also select to pre-
           compile only the READERS or only the WRITERS.  The selection can be limited further by  specifying  a
           $ns.

           By default, the processors are only compiled when used.  This method is especially useful in a <b>daemon</b>
           <b>process</b>, where preparations can take as much time as they want to... and running should be as fast as
           possible.

       $obj-&gt;<b>compileType</b>( &lt;'READER'|'WRITER'&gt;, $type, %options )
           Inherited, see "Compilers" in XML::Compile::Schema

       $obj-&gt;<b>dataToXML</b>( $node|REF-XML|XML-STRING|$filename|$fh|$known )
       XML::Compile::Cache-&gt;<b>dataToXML</b>( $node|REF-XML|XML-STRING|$filename|$fh|$known )
           Inherited, see "Compilers" in XML::Compile

       $obj-&gt;<b>initParser</b>(%options)
       XML::Compile::Cache-&gt;<b>initParser</b>(%options)
           Inherited, see "Compilers" in XML::Compile

       $obj-&gt;<b>reader</b>($type|$name, %options)
           Returns  the  reader  CODE  for  the $type or $name (see <u>findName()</u>).  %options are only permitted if
           new(allow_undeclared) is true, and the same as the previous call to this method.

           The reader will be compiled the first time that it is used, and that  same  CODE  reference  will  be
           returned  each  next  request  for the same $type.  Call <u>compileAll()</u> to have all readers compiled by
           force.

            -Option --Default
             is_type  &lt;false&gt;

           is_type =&gt; BOOLEAN
             [1.03] use <u>compileType()</u> with the  given  element,  to  replace  <u>compile()</u>  You  probably  want  an
             additional "element" parameter.

           example:

             my $schema = XML::Compile::Cache-&gt;new(\@xsd,
                prefixes =&gt; [ gml =&gt; $GML_NAMESPACE ] );
             my $data   = $schema-&gt;reader('gml:members')-&gt;($xml);

             my $getmem = $schema-&gt;reader('gml:members');
             my $data   = $getmem-&gt;($xml);

       $obj-&gt;<b>template</b>( &lt;'XML'|'PERL'|'TREE'&gt;, $element, %options )
           Inherited, see "Compilers" in XML::Compile::Schema

       $obj-&gt;<b>writer</b>($type|$name)
           Returns  the  writer  CODE  for  the  $type or $name (see <u>findName()</u>).  OPTIONS are only permitted if
           new(allow_undeclared) is true, and the same as the previous call to this method.

           The writer will be compiled the first time that it is used, and that  same  CODE  reference  will  be
           returned each next request for the same type.

            -Option --Default
             is_type  &lt;false&gt;

           is_type =&gt; BOOLEAN
             [1.03]  use  <u>compileType()</u>  with  the  given  element,  to  replace  <u>compile()</u> You probably want an
             additional "element" parameter.

           example:

             my $xml = $cache-&gt;writer('gml:members')-&gt;($doc, $data);

             my $doc = XML::LibXML::Document-&gt;new('1.0', 'UTF-8');
             my $wr  = $cache-&gt;writer('gml:members');
             my $xml = $wr-&gt;($doc, $data);
             $doc-&gt;setDocumentElement($xml);
             print $doc-&gt;<a href="../man1/toString.1.html">toString</a>(1);

   <b>Administration</b>
       Extends "Administration" in XML::Compile::Schema.

       $obj-&gt;<b>declare</b>( &lt;'READER'|'WRITER'|'RW'&gt;, &lt;$type|ARRAY&gt;, %options )
           Register that the indicated $type (or ARRAY of them) may be used, and needs to be translated with the
           %options (either specified as ARRAY or PAIRS).  Specify whether it may get used as READER, WRITER, or
           both (RW).  If the READER  and  WRITER  need  different  options,  then  you  need  to  declare  them
           separately; in that case you cannot use RW.

           The $type should be understood by <u>findName()</u>, so may be prefixed.

           example:

             $cache-&gt;declare(READER =&gt; 'pref:count', sloppy_integers =&gt; 1)
                   -&gt;declare(RW     =&gt; '{myns}mylocal');

             $cache-&gt;declare(WRITER =&gt; [ 'xsd:int', '{http://}aap' ]);

       $obj-&gt;<b>doesExtend</b>($exttype, $basetype)
           Inherited, see "Administration" in XML::Compile::Schema

       $obj-&gt;<b>elements</b>()
           Inherited, see "Administration" in XML::Compile::Schema

       $obj-&gt;<b>findName</b>($name)
           Translate  the  $name  specification  into  a schema defined full type.  The $name can be a full type
           (like '{namespace}localname', usually created with  <u>XML::Compile::Util::pack_type()</u>)  or  a  prefixed
           type (like 'myns:localname', where "myns" is defined via new(prefixes) or <u>prefixes()</u>).

           When the form is 'myns:' (so without local name), the namespace uri is returned.

           example: of <u>findName()</u>

             $schema-&gt;addPrefixes(pre =&gt; '<a href="http://namespace">http://namespace</a>');

             my $type = $schema-&gt;findName('pre:name');
             print $type;   # {<a href="http://namespace">http://namespace</a>}name

             my $ns   = $schema-&gt;findName('pre:');
             print $ns;     # <a href="http://namespace">http://namespace</a>

             my $type = $schema-&gt;findName('{somens}name');
             print $type;   # {somens}name    [a no-op]

       $obj-&gt;<b>findSchemaFile</b>($filename)
       XML::Compile::Cache-&gt;<b>findSchemaFile</b>($filename)
           Inherited, see "Administration" in XML::Compile

       $obj-&gt;<b>importDefinitions</b>($xmldata, %options)
           Inherited, see "Administration" in XML::Compile::Schema

       $obj-&gt;<b>knownNamespace</b>($ns|PAIRS)
       XML::Compile::Cache-&gt;<b>knownNamespace</b>($ns|PAIRS)
           Inherited, see "Administration" in XML::Compile

       $obj-&gt;<b>namespaces</b>()
           Inherited, see "Administration" in XML::Compile::Schema

       $obj-&gt;<b>printIndex</b>( [$fh], %options )
            -Option       --Default
             show_declared  &lt;true&gt;

           show_declared =&gt; BOOLEAN
             Add  an  indicator  to  each  line,  about  whether  readers  and writers are declare for the type.
             Declared readers and writers will show flags  "r"  and  "w"  respectively.   Compiled  readers  and
             writers carry a "R" and/or "W".

       $obj-&gt;<b>types</b>()
           Inherited, see "Administration" in XML::Compile::Schema

       $obj-&gt;<b>walkTree</b>($node, CODE)
           Inherited, see "Administration" in XML::Compile

</pre><h4><b>DETAILS</b></h4><pre>
       Extends "DETAILS" in XML::Compile::Schema.

</pre><h4><b>DESCRIPTIONS</b></h4><pre>
       "XML::Compile::Cache"  is  the  smart  brother  of  XML::Compile::Schema; it keeps track of your compiled
       readers and writers, and also helps you administer the parameters to handle compilation.  Besides, it lat
       you use easy prefixes instead of full namespaces.

       With <u>XML::Compile::Schema::compile()</u> (defined in the SUPER  class  of  this  module)  you  can  construct
       translators  from  XML to Perl and back.  These translators are code references, which are "expensive" to
       create, but "cheap" in use; call them as often as you want.  This module helps you administer them.

       When the schemas grow larger, it gets harder to see which code reference  have  already  be  created  and
       which  not. And, these code references need compile options which you do not want to distribute over your
       whole program.  Finally, in a daemon application, you do not want to create  the  translators  when  used
       (which can be in every client again), but once during the initiation of the daemon.

       One  of  the  most  important  contributions  to  the compile management, is the addition of smart prefix
       handling. This means that you can use  prefixed  names  in  stead  of  full  types,  often  created  with
       <u>XML::Compile::Util::pack_type()</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This  module  is  part  of XML-Compile-Cache distribution version 1.06, built on March 04, 2018. Website:
       <u><a href="http://perl.overmeer.net/xml-compile/">http://perl.overmeer.net/xml-compile/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2008-2018 by [Mark Overmeer]. For other contributors see ChangeLog.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.26.2                                       2018-03-20                           <u>XML::Compile::<a href="../man3pm/Cache.3pm.html">Cache</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>