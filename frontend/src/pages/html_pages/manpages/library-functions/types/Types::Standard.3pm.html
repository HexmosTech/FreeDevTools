<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Types::Standard - bundled set of built-in types for Type::Tiny</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtype-tiny-perl">libtype-tiny-perl_2.004000-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Types::Standard - bundled set of built-in types for Type::Tiny

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use v5.12;
        use strict;
        use warnings;

        package Horse {
          use Moo;
          use Types::Standard qw( Str Int Enum ArrayRef Object );
          use Type::Params qw( compile );
          use namespace::autoclean;

          has name =&gt; (
            is       =&gt; 'ro',
            isa      =&gt; Str,
            required =&gt; 1,
          );
          has gender =&gt; (
            is       =&gt; 'ro',
            isa      =&gt; Enum[qw( f m )],
          );
          has age =&gt; (
            is       =&gt; 'rw',
            isa      =&gt; Int-&gt;where( '$_ &gt;= 0' ),
          );
          has children =&gt; (
            is       =&gt; 'ro',
            isa      =&gt; ArrayRef[Object],
            default  =&gt; sub { return [] },
          );

          sub add_child {
            state $check = signature(
              method     =&gt; Object,
              positional =&gt; [ Object ],
            );                                         # method signature
            my ( $self, $child ) = $check-&gt;( @_ );     # unpack @_

            push @{ $self-&gt;children }, $child;
            return $self;
          }
        }

        package main;

        my $boldruler = Horse-&gt;new(
          name    =&gt; "Bold Ruler",
          gender  =&gt; 'm',
          age     =&gt; 16,
        );

        my $secretariat = Horse-&gt;new(
          name    =&gt; "Secretariat",
          gender  =&gt; 'm',
          age     =&gt; 0,
        );

        $boldruler-&gt;add_child( $secretariat );

        use Types::Standard qw( is_Object assert_Object );

        # is_Object($thing) returns a boolean
        my $is_it_an_object = is_Object($boldruler);

        # assert_Object($thing) returns $thing or dies
        say assert_Object($boldruler)-&gt;name;  # says "Bold Ruler"

</pre><h4><b>STATUS</b></h4><pre>
       This module is covered by the Type-Tiny stability policy.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This documents the details of the Types::Standard type library.  Type::Tiny::Manual is a better starting
       place if you're new.

       Type::Tiny bundles a few types which seem to be useful.

   <b>Moose-like</b>
       The following types are similar to those described in Moose::Util::TypeConstraints.

       •   <b>Any</b>

           Absolutely any value passes this type constraint (even undef).

       •   <b>Item</b>

           Essentially  the  same  as  <b>Any</b>.  All  other  type  constraints  in  this library inherit directly or
           indirectly from <b>Item</b>.

       •   <b>Bool</b>

           Values that are reasonable booleans. Accepts 1, 0, the empty string and undef.

           Other customers also bought: <b>BoolLike</b> from Types::TypeTiny.

       •   <b>Maybe[`a]</b>

           Given another type constraint, also accepts undef. For example, <b>Maybe[Int]</b> accepts all integers  plus
           undef.

       •   <b>Undef</b>

           Only undef passes this type constraint.

       •   <b>Defined</b>

           Only undef fails this type constraint.

       •   <b>Value</b>

           Any defined, non-reference value.

       •   <b>Str</b>

           Any string.

           (The only difference between <b>Value</b> and <b>Str</b> is that the former accepts typeglobs and vstrings.)

           Other customers also bought: <b>StringLike</b> from Types::TypeTiny.

       •   <b>Num</b>

           See <b>LaxNum</b> and <b>StrictNum</b> below.

       •   <b>Int</b>

           An integer; that is a string of digits 0 to 9, optionally prefixed with a hyphen-minus character.

           Expect inconsistent results for dualvars, and numbers too high (or negative numbers too low) for Perl
           to safely represent as an integer.

       •   <b>ClassName</b>

           The name of a loaded package. The package must have @ISA or $VERSION defined, or must define at least
           one sub to be considered a loaded package.

       •   <b>RoleName</b>

           Like  <b>ClassName</b>, but the package must <u>not</u> define a method called "new". This is subtly different from
           Moose's type constraint of the same name; let me know if this  causes  you  any  problems.  (I  can't
           promise I'll change anything though.)

       •   <b>Ref[`a]</b>

           Any defined reference value, including blessed objects.

           Unlike Moose, <b>Ref</b> is a parameterized type, allowing Scalar::Util::reftype checks, a la

              Ref["HASH"]  # hashrefs, including blessed hashrefs

       •   <b>ScalarRef[`a]</b>

           A value where "ref($value) eq "SCALAR" or ref($value) eq "REF"".

           If   parameterized,   the   referred  value  must  pass  the  additional  constraint.   For  example,
           <b>ScalarRef[Int]</b> must be a reference to a scalar which holds an integer value.

       •   <b>ArrayRef[`a]</b>

           A value where "ref($value) eq "ARRAY"".

           If parameterized, the elements of the  array  must  pass  the  additional  constraint.  For  example,
           <b>ArrayRef[Num]</b> must be a reference to an array of numbers.

           As an extension to Moose's <b>ArrayRef</b> type, a minimum and maximum array length can be given:

              ArrayRef[CodeRef, 1]        # ArrayRef of at least one CodeRef
              ArrayRef[FileHandle, 0, 2]  # ArrayRef of up to two FileHandles
              ArrayRef[Any, 0, 100]       # ArrayRef of up to 100 elements

           Other customers also bought: <b>ArrayLike</b> from Types::TypeTiny.

       •   <b>HashRef[`a]</b>

           A value where "ref($value) eq "HASH"".

           If  parameterized,  the  values  of  the  hash  must  pass  the  additional  constraint. For example,
           <b>HashRef[Num]</b> must be a reference to an hash where the values are  numbers.  The  hash  keys  are  not
           constrained, but Perl limits them to strings; see <b>Map</b> below if you need to further constrain the hash
           values.

           Other customers also bought: <b>HashLike</b> from Types::TypeTiny.

       •   <b>CodeRef</b>

           A value where "ref($value) eq "CODE"".

           Other customers also bought: <b>CodeLike</b> from Types::TypeTiny.

       •   <b>RegexpRef</b>

           A reference where re::is_regexp($value) is true, or a blessed reference where "$value-&gt;isa("Regexp")"
           is true.

       •   <b>GlobRef</b>

           A value where "ref($value) eq "GLOB"".

       •   <b>FileHandle</b>

           A file handle.

       •   <b>Object</b>

           A blessed object.

           (This also accepts regexp refs.)

   <b>Structured</b>
       Okay, so I stole some ideas from MooseX::Types::Structured.

       •   <b>Map[`k,</b> <b>`v]</b>

           Similar to <b>HashRef</b> but parameterized with type constraints for both the key and value. The constraint
           for keys would typically be a subtype of <b>Str</b>.

       •   <b>Tuple[...]</b>

           Subtype of <b>ArrayRef</b>, accepting a list of type constraints for each slot in the array.

           <b>Tuple[Int,</b> <b>HashRef]</b> would match "[1, {}]" but not "[{}, 1]".

       •   <b>Dict[...]</b>

           Subtype of <b>HashRef</b>, accepting a list of type constraints for each slot in the hash.

           For example <b>Dict[name</b> <b>=&gt;</b> <b>Str,</b> <b>id</b> <b>=&gt;</b> <b>Int]</b> allows "{ name =&gt; "Bob", id =&gt; 42 }".

       •   <b>Optional[`a]</b>

           Used  in  conjunction  with <b>Dict</b> and <b>Tuple</b> to specify slots that are optional and may be omitted (but
           not necessarily set to an explicit undef).

           <b>Dict[name</b> <b>=&gt;</b> <b>Str,</b> <b>id</b> <b>=&gt;</b> <b>Optional[Int]]</b> allows "{ name =&gt; "Bob" }" but not "{ name  =&gt;  "Bob",  id  =&gt;
           "BOB" }".

           Note  that  any  use  of  <b>Optional[`a]</b>  outside  the  context  of  parameterized  <b>Dict</b> and <b>Tuple</b> type
           constraints makes little sense, and its  behaviour  is  undefined.  (An  exception:  it  is  used  by
           Type::Params for a similar purpose to how it's used in <b>Tuple</b>.)

       This module also exports a <b>Slurpy</b> parameterized type, which can be used as follows.

       It  can  cause  additional  trailing  values in a <b>Tuple</b> to be slurped into a structure and validated. For
       example, slurping into an arrayref:

          my $type = Tuple[ Str, Slurpy[ ArrayRef[Int] ] ];

          $type-&gt;( ["Hello"] );                # ok
          $type-&gt;( ["Hello", 1, 2, 3] );       # ok
          $type-&gt;( ["Hello", [1, 2, 3]] );     # not ok

       Or into a hashref:

          my $type2 = Tuple[ Str, Slurpy[ Map[Int, RegexpRef] ] ];

          $type2-&gt;( ["Hello"] );                               # ok
          $type2-&gt;( ["Hello", 1, qr/one/i, 2, qr/two/] );      # ok

       It can cause additional values in a <b>Dict</b> to be slurped into a hashref and validated:

          my $type3 = Dict[ values =&gt; ArrayRef, Slurpy[ HashRef[Str] ] ];

          $type3-&gt;( { values =&gt; [] } );                        # ok
          $type3-&gt;( { values =&gt; [], name =&gt; "Foo" } );         # ok
          $type3-&gt;( { values =&gt; [], name =&gt; [] } );            # not ok

       In either <b>Tuple</b> or <b>Dict</b>, <b>Slurpy[Any]</b> can be used to indicate that additional values are  acceptable,  but
       should not be constrained in any way.

       <b>Slurpy[Any]</b>  is  an  optimized  code  path. Although the following are essentially equivalent checks, the
       former should run a lot faster:

          Tuple[ Int, Slurpy[Any] ]
          Tuple[ Int, Slurpy[ArrayRef] ]

       A function slurpy($type) is also exported which was historically how slurpy types were created.

       Outside of <b>Dict</b> and <b>Tuple</b>, <b>Slurpy[Foo]</b> should just act the same as <b>Foo</b>. But don't do that.

   <b>Objects</b>
       Okay, so I stole some ideas from MooX::Types::MooseLike::Base.

       •   <b>InstanceOf[`a]</b>

           Shortcut for a union of Type::Tiny::Class constraints.

           <b>InstanceOf["Foo",</b> <b>"Bar"]</b> allows objects blessed into the "Foo" or "Bar"  classes,  or  subclasses  of
           those.

           Given no parameters, just equivalent to <b>Object</b>.

       •   <b>ConsumerOf[`a]</b>

           Shortcut for an intersection of Type::Tiny::Role constraints.

           <b>ConsumerOf["Foo",</b>  <b>"Bar"]</b>  allows  objects  where "$o-&gt;DOES("Foo")" and "$o-&gt;DOES("Bar")" both return
           true.

           Given no parameters, just equivalent to <b>Object</b>.

       •   <b>HasMethods[`a]</b>

           Shortcut for a Type::Tiny::Duck constraint.

           <b>HasMethods["foo",</b> <b>"bar"]</b> allows objects where "$o-&gt;can("foo")" and "$o-&gt;can("bar")" both return true.

           Given no parameters, just equivalent to <b>Object</b>.

   <b>More</b>
       There are a few other types exported by this module:

       •   <b>Overload[`a]</b>

           With no parameters, checks that the value is an overloaded object. Can be given one  or  more  string
           parameters,  which are specific operations to check are overloaded. For example, the following checks
           for objects which overload addition and subtraction.

              Overload["+", "-"]

       •   <b>Tied[`a]</b>

           A reference to a tied scalar, array or hash.

           Can be parameterized with a type constraint which will be applied  to  the  object  returned  by  the
           tied() function. As a convenience, can also be parameterized with a string, which will be inflated to
           a Type::Tiny::Class.

              use Types::Standard qw(Tied);
              use Type::Utils qw(class_type);

              my $My_Package = class_type { class =&gt; "My::Package" };

              tie my %h, "My::Package";
              \%h ~~ Tied;                   # true
              \%h ~~ Tied[ $My_Package ];    # true
              \%h ~~ Tied["My::Package"];    # true

              tie my $s, "Other::Package";
              \$s ~~ Tied;                   # true
              $s  ~~ Tied;                   # false !!

           If you need to check that something is specifically a reference to a tied hash, use an intersection:

              use Types::Standard qw( Tied HashRef );

              my $TiedHash = (Tied) &amp; (HashRef);

              tie my %h, "My::Package";
              tie my $s, "Other::Package";

              \%h ~~ $TiedHash;     # true
              \$s ~~ $TiedHash;     # false

       •   <b>StrMatch[`a]</b>

           A string that matches a regular expression:

              declare "Distance",
                 as StrMatch[ qr{^([0-9]+)\s*(mm|cm|m|km)$} ];

           You can optionally provide a type constraint for the array of subexpressions:

              declare "Distance",
                 as StrMatch[
                    qr{^([0-9]+)\s*(.+)$},
                    Tuple[
                       Int,
                       enum(DistanceUnit =&gt; [qw/ mm cm m km /]),
                    ],
                 ];

           Here's an example using Regexp::Common:

              package Local::Host {
                 use Moose;
                 use Regexp::Common;
                 has ip_address =&gt; (
                    is         =&gt; 'ro',
                    required   =&gt; 1,
                    isa        =&gt; StrMatch[qr/^$RE{net}{IPv4}$/],
                    default    =&gt; '127.0.0.1',
                 );
              }

           On  certain  versions  of Perl, type constraints of the forms <b>StrMatch[qr/../</b> and <b>StrMatch[qr/\A..\z/</b>
           with any number of intervening dots can be optimized to simple length checks.

       •   <b>Enum[`a]</b>

           As per MooX::Types::MooseLike::Base:

              has size =&gt; (
                 is     =&gt; "ro",
                 isa    =&gt; Enum[qw( S M L XL XXL )],
              );

           You can enable coercion by passing "\1" before the list of values.

              has size =&gt; (
                 is     =&gt; "ro",
                 isa    =&gt; Enum[ \1, qw( S M L XL XXL ) ],
                 coerce =&gt; 1,
              );

           This will use the "closest_match" method in Type::Tiny::Enum to coerce closely matching strings.

       •   <b>OptList</b>

           An arrayref of arrayrefs in the style of Data::OptList output.

       •   <b>LaxNum</b>, <b>StrictNum</b>

           In Moose 2.09, the <b>Num</b> type constraint  implementation  was  changed  from  being  a  wrapper  around
           Scalar::Util's  "looks_like_number" function to a stricter regexp (which disallows things like "-Inf"
           and "Nan").

           Types::Standard provides <u>both</u> implementations. <b>LaxNum</b> is measurably faster.

           The   <b>Num</b>   type   constraint   is   currently   an   alias   for   <b>LaxNum</b>   unless   you   set   the
           "PERL_TYPES_STANDARD_STRICTNUM" environment variable to true before loading Types::Standard, in which
           case  it  becomes  an  alias for <b>StrictNum</b>.  The constant "Types::Standard::STRICTNUM" can be used to
           check if <b>Num</b> is being strict.

           Most people should probably use <b>Num</b> or <b>StrictNum</b>. Don't explicitly use <b>LaxNum</b> unless you specifically
           need an attribute which will accept things like "Inf".

       •   <b>CycleTuple[`a]</b>

           Similar to <b>Tuple</b>, but cyclical.

              CycleTuple[Int, HashRef]

           will allow "[1,{}]" and "[1,{},2,{}]" but disallow "[1,{},2]" and "[1,{},2,[]]".

           I think you understand <b>CycleTuple</b> already.

           Currently <b>Optional</b> and <b>Slurpy</b> parameters are forbidden. There are fairly limited use cases for  them,
           and it's not exactly clear what they should mean.

           The following is an efficient way of checking for an even-sized arrayref:

              CycleTuple[Any, Any]

           The following is an arrayref which would be suitable for coercing to a hashref:

              CycleTuple[Str, Any]

           All the examples so far have used two parameters, but the following is also a possible <b>CycleTuple</b>:

              CycleTuple[Str, Int, HashRef]

           This  will  be  an  arrayref  where the 0th, 3rd, 6th, etc values are strings, the 1st, 4th, 7th, etc
           values are integers, and the 2nd, 5th, 8th, etc values are hashrefs.

   <b>Coercions</b>
       Most of the types in this type library have no coercions.  The exception is <b>Bool</b>  as  of  Types::Standard
       1.003_003, which coerces from <b>Any</b> via "!!$_".

       Some  standalone  coercions  may  be  exported.  These  can  be  combined with type constraints using the
       "plus_coercions" method.

       •   <b>MkOpt</b>

           A coercion from <b>ArrayRef</b>, <b>HashRef</b> or <b>Undef</b> to <b>OptList</b>. Example usage in a Moose attribute:

              use Types::Standard qw( OptList MkOpt );

              has options =&gt; (
                 is     =&gt; "ro",
                 isa    =&gt; OptList-&gt;plus_coercions( MkOpt ),
                 coerce =&gt; 1,
              );

       •   <b>Split[`a]</b>

           Split a string on a regexp.

              use Types::Standard qw( ArrayRef Str Split );

              has name =&gt; (
                 is     =&gt; "ro",
                 isa    =&gt; ArrayRef-&gt;of(Str)-&gt;plus_coercions(Split[qr/\s/]),
                 coerce =&gt; 1,
              );

       •   <b>Join[`a]</b>

           Join an array of strings with a delimiter.

              use Types::Standard qw( Str Join );

              my $FileLines = Str-&gt;plus_coercions(Join["\n"]);

              has file_contents =&gt; (
                 is     =&gt; "ro",
                 isa    =&gt; $FileLines,
                 coerce =&gt; 1,
              );

   <b>Constants</b>
       "Types::Standard::STRICTNUM"
           Indicates whether <b>Num</b> is an alias for <b>StrictNum</b>. (It is usually an alias for <b>LaxNum</b>.)

   <b>Environment</b>
       "PERL_TYPES_STANDARD_STRICTNUM"
           Switches to more strict regexp-based number checking instead of using "looks_like_number".

       "PERL_TYPE_TINY_XS"
           If set to false, can be used to suppress the loading of XS implementions of some type constraints.

       "PERL_ONLY"
           If "PERL_TYPE_TINY_XS" does not exist, can be set to true to suppress XS  usage  similarly.  (Several
           other CPAN distributions also pay attention to this environment variable.)

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs to &lt;https://github.com/tobyink/p5-type-tiny/issues&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The Type::Tiny homepage &lt;https://typetiny.toby.ink/&gt;.

       Type::Tiny::Manual.

       Type::Tiny, Type::Library, Type::Utils, Type::Coercion.

       Moose::Util::TypeConstraints, Mouse::Util::TypeConstraints, MooseX::Types::Structured.

       Types::XSD provides some type constraints based on XML Schema's data types; this includes constraints for
       ISO8601-formatted datetimes, integer ranges (e.g. <b>PositiveInteger[maxInclusive=&gt;10]</b> and so on.

       Types::Encodings provides <b>Bytes</b> and <b>Chars</b> type constraints that were formerly found in Types::Standard.

       Types::Common::Numeric and Types::Common::String provide replacements for MooseX::Types::Common.

</pre><h4><b>AUTHOR</b></h4><pre>
       Toby Inkster &lt;<a href="mailto:tobyink@cpan.org">tobyink@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2013-2014, 2017-2023 by Toby Inkster.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTIES</b></h4><pre>
       THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  WITHOUT
       LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

perl v5.40.1                                       2025-05-06                               <u>Types::<a href="../man3pm/Standard.3pm.html">Standard</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>