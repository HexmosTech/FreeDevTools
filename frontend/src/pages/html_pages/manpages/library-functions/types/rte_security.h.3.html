<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_security.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_security.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;sys/types.h&gt;
       #include &lt;rte_compat.h&gt;
       #include &lt;rte_common.h&gt;
       #include &lt;rte_crypto.h&gt;
       #include &lt;rte_ip.h&gt;
       #include &lt;rte_mbuf_dyn.h&gt;

   <b>Data</b> <b>Structures</b>
       struct <b>rte_security_ipsec_tunnel_param</b>
       struct <b>rte_security_ipsec_sa_options</b>
       struct <b>rte_security_ipsec_lifetime</b>
       struct <b>rte_security_ipsec_xform</b>
       struct <b>rte_security_macsec_sa</b>
       struct <b>rte_security_macsec_sc</b>
       struct <b>rte_security_macsec_xform</b>
       struct <b>rte_security_pdcp_xform</b>
       struct <b>rte_security_docsis_xform</b>
       struct <b>rte_security_tls_record_sess_options</b>
       struct <b>rte_security_tls_record_lifetime</b>
       struct <b>rte_security_tls_record_xform</b>
       struct <b>rte_security_session_conf</b>
       struct <b>rte_security_capability</b>
       struct <b>rte_security_capability_idx</b>

   <b>Macros</b>
       #define <b>RTE_SECURITY_IPSEC_TUNNEL_VERIFY_DST_ADDR</b>   0x1
       #define <b>RTE_SEC_CTX_F_FAST_SET_MDATA</b>   0x00000001
       #define <b>RTE_SECURITY_MACSEC_NUM_AN</b>   4
       #define <b>RTE_SECURITY_MACSEC_SALT_LEN</b>   12
       #define <b>RTE_SECURITY_MACSEC_VALIDATE_DISABLE</b>   0
       #define <b>RTE_SECURITY_MACSEC_VALIDATE_NO_DISCARD</b>   1
       #define <b>RTE_SECURITY_MACSEC_VALIDATE_STRICT</b>   2
       #define <b>RTE_SECURITY_MACSEC_VALIDATE_NO_OP</b>   3
       #define <b>RTE_SECURITY_TLS_1_2_IMP_NONCE_LEN</b>   4
       #define <b>RTE_SECURITY_TLS_1_3_IMP_NONCE_LEN</b>   12
       #define <b>RTE_SECURITY_DTLS_1_2_IMP_NONCE_LEN</b>   4
       #define <b>RTE_SECURITY_PDCP_ORDERING_CAP</b>   0x00000001
       #define <b>RTE_SECURITY_PDCP_DUP_DETECT_CAP</b>   0x00000002
       #define <b>RTE_SECURITY_TX_OLOAD_NEED_MDATA</b>   0x00000001
       #define <b>RTE_SECURITY_TX_HW_TRAILER_OFFLOAD</b>   0x00000002
       #define <b>RTE_SECURITY_RX_HW_TRAILER_OFFLOAD</b>   0x00010000

   <b>Typedefs</b>
       <b>typedef</b> uint64_t <b>rte_security_dynfield_t</b>
       <b>typedef</b> struct <b>rte_mbuf</b> * <b>rte_security_oop_dynfield_t</b>

   <b>Enumerations</b>
       enum <b>rte_security_ipsec_sa_mode</b> { <b>RTE_SECURITY_IPSEC_SA_MODE_TRANSPORT</b> = 1,
           <b>RTE_SECURITY_IPSEC_SA_MODE_TUNNEL</b> }
       enum <b>rte_security_ipsec_sa_protocol</b> { <b>RTE_SECURITY_IPSEC_SA_PROTO_AH</b> = 1, <b>RTE_SECURITY_IPSEC_SA_PROTO_ESP</b>
           }
       enum <b>rte_security_ipsec_tunnel_type</b> { <b>RTE_SECURITY_IPSEC_TUNNEL_IPV4</b> = 1, <b>RTE_SECURITY_IPSEC_TUNNEL_IPV6</b>
           }
       enum <b>rte_security_ipsec_sa_direction</b> { <b>RTE_SECURITY_IPSEC_SA_DIR_EGRESS</b>,
           <b>RTE_SECURITY_IPSEC_SA_DIR_INGRESS</b> }
       enum <b>rte_security_macsec_direction</b> { <b>RTE_SECURITY_MACSEC_DIR_TX</b>, <b>RTE_SECURITY_MACSEC_DIR_RX</b> }
       enum <b>rte_security_macsec_alg</b> { <b>RTE_SECURITY_MACSEC_ALG_GCM_128</b>, <b>RTE_SECURITY_MACSEC_ALG_GCM_256</b>,
           <b>RTE_SECURITY_MACSEC_ALG_GCM_XPN_128</b>, <b>RTE_SECURITY_MACSEC_ALG_GCM_XPN_256</b> }
       enum <b>rte_security_pdcp_domain</b> { <b>RTE_SECURITY_PDCP_MODE_CONTROL</b>, <b>RTE_SECURITY_PDCP_MODE_DATA</b>,
           <b>RTE_SECURITY_PDCP_MODE_SHORT_MAC</b> }
       enum <b>rte_security_pdcp_direction</b> { <b>RTE_SECURITY_PDCP_UPLINK</b>, <b>RTE_SECURITY_PDCP_DOWNLINK</b> }
       enum <b>rte_security_pdcp_sn_size</b> { <b>RTE_SECURITY_PDCP_SN_SIZE_5</b> = 5, <b>RTE_SECURITY_PDCP_SN_SIZE_7</b> = 7,
           <b>RTE_SECURITY_PDCP_SN_SIZE_12</b> = 12, <b>RTE_SECURITY_PDCP_SN_SIZE_15</b> = 15, <b>RTE_SECURITY_PDCP_SN_SIZE_18</b> =
           18 }
       enum <b>rte_security_docsis_direction</b> { <b>RTE_SECURITY_DOCSIS_UPLINK</b>, <b>RTE_SECURITY_DOCSIS_DOWNLINK</b> }
       enum <b>rte_security_tls_version</b> { <b>RTE_SECURITY_VERSION_TLS_1_2</b>, <b>RTE_SECURITY_VERSION_TLS_1_3</b>,
           <b>RTE_SECURITY_VERSION_DTLS_1_2</b> }
       enum <b>rte_security_tls_sess_type</b> { <b>RTE_SECURITY_TLS_SESS_TYPE_READ</b>, <b>RTE_SECURITY_TLS_SESS_TYPE_WRITE</b> }
       enum <b>rte_security_session_action_type</b> { <b>RTE_SECURITY_ACTION_TYPE_NONE</b>,
           <b>RTE_SECURITY_ACTION_TYPE_INLINE_CRYPTO</b>, <b>RTE_SECURITY_ACTION_TYPE_INLINE_PROTOCOL</b>,
           <b>RTE_SECURITY_ACTION_TYPE_LOOKASIDE_PROTOCOL</b>, <b>RTE_SECURITY_ACTION_TYPE_CPU_CRYPTO</b> }
       enum <b>rte_security_session_protocol</b> { <b>RTE_SECURITY_PROTOCOL_IPSEC</b> = 1, <b>RTE_SECURITY_PROTOCOL_MACSEC</b>,
           <b>RTE_SECURITY_PROTOCOL_PDCP</b>, <b>RTE_SECURITY_PROTOCOL_DOCSIS</b>, <b>RTE_SECURITY_PROTOCOL_TLS_RECORD</b> }

   <b>Functions</b>
       void * <b>rte_security_session_create</b> (void *instance, struct <b>rte_security_session_conf</b> *conf, struct
           <b>rte_mempool</b> *mp)
       int <b>rte_security_session_update</b> (void *instance, void *sess, struct <b>rte_security_session_conf</b> *conf)
       unsigned int <b>rte_security_session_get_size</b> (void *instance)
       int <b>rte_security_session_destroy</b> (void *instance, void *sess)
       int <b>rte_security_macsec_sc_create</b> (void *instance, struct <b>rte_security_macsec_sc</b> *conf)
       int <b>rte_security_macsec_sc_destroy</b> (void *instance, uint16_t sc_id, enum <b>rte_security_macsec_direction</b>
           dir)
       int <b>rte_security_macsec_sa_create</b> (void *instance, struct <b>rte_security_macsec_sa</b> *conf)
       int <b>rte_security_macsec_sa_destroy</b> (void *instance, uint16_t sa_id, enum <b>rte_security_macsec_direction</b>
           dir)
       static <b>rte_security_dynfield_t</b> * <b>rte_security_dynfield</b> (struct <b>rte_mbuf</b> *mbuf)
       static __rte_experimental <b>rte_security_oop_dynfield_t</b> * <b>rte_security_oop_dynfield</b> (struct <b>rte_mbuf</b> *mbuf)
       static bool <b>rte_security_dynfield_is_registered</b> (void)
       static uint32_t <b>rte_security_ctx_flags_get</b> (void *ctx)
       static void <b>rte_security_ctx_flags_set</b> (void *ctx, uint32_t flags)
       static uint64_t <b>rte_security_session_opaque_data_get</b> (void *sess)
       static void <b>rte_security_session_opaque_data_set</b> (void *sess, uint64_t opaque)
       static uint64_t <b>rte_security_session_fast_mdata_get</b> (void *sess)
       static void <b>rte_security_session_fast_mdata_set</b> (void *sess, uint64_t fdata)
       int <b>__rte_security_set_pkt_metadata</b> (void *instance, void *sess, struct <b>rte_mbuf</b> *m, void *params)
       static int <b>rte_security_set_pkt_metadata</b> (void *instance, void *sess, struct <b>rte_mbuf</b> *mb, void *params)
       static int <b>__rte_security_attach_session</b> (struct <b>rte_crypto_sym_op</b> *sym_op, void *sess)
       static int <b>rte_security_attach_session</b> (struct <b>rte_crypto_op</b> *op, void *sess)
       int <b>rte_security_session_stats_get</b> (void *instance, void *sess, struct rte_security_stats *stats)
       int <b>rte_security_macsec_sa_stats_get</b> (void *instance, uint16_t sa_id, enum <b>rte_security_macsec_direction</b>
           dir, struct rte_security_macsec_sa_stats *stats)
       int <b>rte_security_macsec_sc_stats_get</b> (void *instance, uint16_t sc_id, enum <b>rte_security_macsec_direction</b>
           dir, struct rte_security_macsec_sc_stats *stats)
       const struct <b>rte_security_capability</b> * <b>rte_security_capabilities_get</b> (void *instance)
       const struct <b>rte_security_capability</b> * <b>rte_security_capability_get</b> (void *instance, struct
           <b>rte_security_capability_idx</b> *idx)
       __rte_experimental int <b>rte_security_rx_inject_configure</b> (void *ctx, uint16_t port_id, bool enable)
       __rte_experimental uint16_t <b>rte_security_inb_pkt_rx_inject</b> (void *ctx, struct <b>rte_mbuf</b> **pkts, void
           **sess, uint16_t nb_pkts)

   <b>Variables</b>
       int <b>rte_security_dynfield_offset</b>
       int <b>rte_security_oop_dynfield_offset</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       RTE Security Common Definitions

       Definition in file <b>rte_security.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_SECURITY_IPSEC_TUNNEL_VERIFY_DST_ADDR</b>   <b>0x1</b>
       IPSEC tunnel header verification mode

       Controls how outer IP header is verified in inbound.

       Definition at line <b>56</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SEC_CTX_F_FAST_SET_MDATA</b>   <b>0x00000001</b>
       Driver uses fast metadata update without using driver specific callback. For fast mdata, mbuf dynamic
       field would be registered by driver via rte_security_dynfield_register().

       Definition at line <b>63</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_MACSEC_NUM_AN</b>   <b>4</b>
       Maximum number of association numbers for a secure channel.

       Definition at line <b>345</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_MACSEC_SALT_LEN</b>   <b>12</b>
       Salt length for MACsec SA.

       Definition at line <b>347</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_MACSEC_VALIDATE_DISABLE</b>   <b>0</b>
       Disable Validation of MACsec frame.

       Definition at line <b>418</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_MACSEC_VALIDATE_NO_DISCARD</b>   <b>1</b>
       Validate MACsec frame but do not discard invalid frame.

       Definition at line <b>420</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_MACSEC_VALIDATE_STRICT</b>   <b>2</b>
       Validate MACsec frame and discart invalid frame.

       Definition at line <b>422</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_MACSEC_VALIDATE_NO_OP</b>   <b>3</b>
       Do not perform any MACsec operation.

       Definition at line <b>424</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_TLS_1_2_IMP_NONCE_LEN</b>   <b>4</b>
       Implicit nonce length to be used with AEAD algos in TLS 1.2

       Definition at line <b>601</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_TLS_1_3_IMP_NONCE_LEN</b>   <b>12</b>
       Implicit nonce length to be used with AEAD algos in TLS 1.3

       Definition at line <b>603</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_DTLS_1_2_IMP_NONCE_LEN</b>   <b>4</b>
       Implicit nonce length to be used with AEAD algos in DTLS 1.2

       Definition at line <b>605</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_PDCP_ORDERING_CAP</b>   <b>0x00000001</b>
       Underlying Hardware/driver which support PDCP may or may not support packet ordering. Set
       RTE_SECURITY_PDCP_ORDERING_CAP if it support. If it is not set, driver/HW assumes packets received are in
       order and it will be application's responsibility to maintain ordering.

       Definition at line <b>1340</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_PDCP_DUP_DETECT_CAP</b>   <b>0x00000002</b>
       Underlying Hardware/driver which support PDCP may or may not detect duplicate packet. Set
       RTE_SECURITY_PDCP_DUP_DETECT_CAP if it support. If it is not set, driver/HW assumes there is no duplicate
       packet received.

       Definition at line <b>1346</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_TX_OLOAD_NEED_MDATA</b>   <b>0x00000001</b>
       HW needs metadata update, see <b>rte_security_set_pkt_metadata()</b>.

       Definition at line <b>1350</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_TX_HW_TRAILER_OFFLOAD</b>   <b>0x00000002</b>
       HW constructs trailer of packets Transmitted packets will have the trailer added to them by hardware. The
       next protocol field will be based on the mbuf-&gt;inner_esp_next_proto field.

       Definition at line <b>1357</b> of file <b>rte_security.h</b>.

   <b>#define</b> <b>RTE_SECURITY_RX_HW_TRAILER_OFFLOAD</b>   <b>0x00010000</b>
       HW removes trailer of packets Received packets have no trailer, the next protocol field is supplied in
       the mbuf-&gt;inner_esp_next_proto field. Inner packet is not modified.

       Definition at line <b>1363</b> of file <b>rte_security.h</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>uint64_t</b> <b>rte_security_dynfield_t</b>
       Device-specific metadata field type

       Definition at line <b>915</b> of file <b>rte_security.h</b>.

   <b>typedef</b> <b>struct</b> <b>rte_mbuf*</b> <b>rte_security_oop_dynfield_t</b>
       Out-of-Place(OOP) processing field type

       Definition at line <b>920</b> of file <b>rte_security.h</b>.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>rte_security_ipsec_sa_mode</b>
       IPSec protocol mode

       <b>Enumerator</b>

       <u>RTE_SECURITY_IPSEC_SA_MODE_TRANSPORT</u>
              IPSec Transport mode

       <u>RTE_SECURITY_IPSEC_SA_MODE_TUNNEL</u>
              IPSec Tunnel mode

       Definition at line <b>28</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_ipsec_sa_protocol</b>
       IPSec Protocol

       <b>Enumerator</b>

       <u>RTE_SECURITY_IPSEC_SA_PROTO_AH</u>
              AH protocol

       <u>RTE_SECURITY_IPSEC_SA_PROTO_ESP</u>
              ESP protocol

       Definition at line <b>36</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_ipsec_tunnel_type</b>
       IPSEC tunnel type

       <b>Enumerator</b>

       <u>RTE_SECURITY_IPSEC_TUNNEL_IPV4</u>
              Outer header is IPv4

       <u>RTE_SECURITY_IPSEC_TUNNEL_IPV6</u>
              Outer header is IPv6

       Definition at line <b>44</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_ipsec_sa_direction</b>
       IPSec security association direction

       <b>Enumerator</b>

       <u>RTE_SECURITY_IPSEC_SA_DIR_EGRESS</u>
              Encrypt and generate digest

       <u>RTE_SECURITY_IPSEC_SA_DIR_INGRESS</u>
              Verify digest and decrypt

       Definition at line <b>265</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_macsec_direction</b>
       MACSec packet flow direction

       <b>Enumerator</b>

       <u>RTE_SECURITY_MACSEC_DIR_TX</u>
              Generate SecTag and encrypt/authenticate

       <u>RTE_SECURITY_MACSEC_DIR_RX</u>
              Remove SecTag and decrypt/verify

       Definition at line <b>337</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_macsec_alg</b>
       MACsec Supported Algorithm list as per IEEE Std 802.1AE.

       <b>Enumerator</b>

       <u>RTE_SECURITY_MACSEC_ALG_GCM_128</u>
              AES-GCM 128 bit block cipher

       <u>RTE_SECURITY_MACSEC_ALG_GCM_256</u>
              AES-GCM 256 bit block cipher

       <u>RTE_SECURITY_MACSEC_ALG_GCM_XPN_128</u>
              AES-GCM 128 bit block cipher with unique SSCI

       <u>RTE_SECURITY_MACSEC_ALG_GCM_XPN_256</u>
              AES-GCM 256 bit block cipher with unique SSCI

       Definition at line <b>410</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_pdcp_domain</b>
       PDCP Mode of session

       <b>Enumerator</b>

       <u>RTE_SECURITY_PDCP_MODE_CONTROL</u>
              PDCP control plane

       <u>RTE_SECURITY_PDCP_MODE_DATA</u>
              PDCP data plane

       <u>RTE_SECURITY_PDCP_MODE_SHORT_MAC</u>
              PDCP short mac

       Definition at line <b>505</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_pdcp_direction</b>
       PDCP Frame direction

       <b>Enumerator</b>

       <u>RTE_SECURITY_PDCP_UPLINK</u>
              Uplink

       <u>RTE_SECURITY_PDCP_DOWNLINK</u>
              Downlink

       Definition at line <b>512</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_pdcp_sn_size</b>
       PDCP Sequence Number Size selectors

       <b>Enumerator</b>

       <u>RTE_SECURITY_PDCP_SN_SIZE_5</u>
              PDCP_SN_SIZE_5: 5bit sequence number

       <u>RTE_SECURITY_PDCP_SN_SIZE_7</u>
              PDCP_SN_SIZE_7: 7bit sequence number

       <u>RTE_SECURITY_PDCP_SN_SIZE_12</u>
              PDCP_SN_SIZE_12: 12bit sequence number

       <u>RTE_SECURITY_PDCP_SN_SIZE_15</u>
              PDCP_SN_SIZE_15: 15bit sequence number

       <u>RTE_SECURITY_PDCP_SN_SIZE_18</u>
              PDCP_SN_SIZE_18: 18bit sequence number

       Definition at line <b>518</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_docsis_direction</b>
       DOCSIS direction

       <b>Enumerator</b>

       <u>RTE_SECURITY_DOCSIS_UPLINK</u>
              Uplink

       • Decryption, followed by CRC Verification

       <u>RTE_SECURITY_DOCSIS_DOWNLINK</u>
              Downlink

       • CRC Generation, followed by Encryption

       Definition at line <b>579</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_tls_version</b>
       TLS version

       <b>Enumerator</b>

       <u>RTE_SECURITY_VERSION_TLS_1_2</u>
              TLS 1.2

       <u>RTE_SECURITY_VERSION_TLS_1_3</u>
              TLS 1.3

       <u>RTE_SECURITY_VERSION_DTLS_1_2</u>
              DTLS 1.2

       Definition at line <b>608</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_tls_sess_type</b>
       TLS session type

       <b>Enumerator</b>

       <u>RTE_SECURITY_TLS_SESS_TYPE_READ</u>
              Record read session

       • Decrypt &amp; digest verification.

       <u>RTE_SECURITY_TLS_SESS_TYPE_WRITE</u>
              Record write session

       • Encrypt &amp; digest generation.

       Definition at line <b>615</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_session_action_type</b>
       Security session action type.

       <b>Enumerator</b>

       <u>RTE_SECURITY_ACTION_TYPE_NONE</u>
              No security actions

       <u>RTE_SECURITY_ACTION_TYPE_INLINE_CRYPTO</u>
              Crypto processing for security protocol is processed inline during transmission

       <u>RTE_SECURITY_ACTION_TYPE_INLINE_PROTOCOL</u>
              All security protocol processing is performed inline during transmission

       <u>RTE_SECURITY_ACTION_TYPE_LOOKASIDE_PROTOCOL</u>
              All security protocol processing including crypto is performed on a lookaside accelerator

       <u>RTE_SECURITY_ACTION_TYPE_CPU_CRYPTO</u>
              Similar to ACTION_TYPE_NONE but crypto processing for security protocol is processed synchronously
              by a CPU.

       Definition at line <b>731</b> of file <b>rte_security.h</b>.

   <b>enum</b> <b>rte_security_session_protocol</b>
       Security session protocol definition

       <b>Enumerator</b>

       <u>RTE_SECURITY_PROTOCOL_IPSEC</u>
              IPsec Protocol

       <u>RTE_SECURITY_PROTOCOL_MACSEC</u>
              MACSec Protocol

       <u>RTE_SECURITY_PROTOCOL_PDCP</u>
              PDCP Protocol

       <u>RTE_SECURITY_PROTOCOL_DOCSIS</u>
              DOCSIS Protocol

       <u>RTE_SECURITY_PROTOCOL_TLS_RECORD</u>
              TLS Record Protocol

       Definition at line <b>755</b> of file <b>rte_security.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b>  <b>*</b>  <b>rte_security_session_create</b>  <b>(void</b>  <b>*</b>  <b>instance,</b>  <b>struct</b>  <b>rte_security_session_conf</b>  <b>*</b>  <b>conf,</b> <b>struct</b>
       <b>rte_mempool</b> <b>*</b> <b>mp)</b>
       Create security session as specified by the session configuration

       <b>Parameters</b>
           <u>instance</u> security instance
           <u>conf</u> session configuration parameters
           <u>mp</u> mempool to allocate session objects from

       <b>Returns</b>

           • On success, pointer to session

           • On failure, NULL

   <b>int</b> <b>rte_security_session_update</b> <b>(void</b> <b>*</b> <b>instance,</b> <b>void</b> <b>*</b> <b>sess,</b> <b>struct</b> <b>rte_security_session_conf</b> <b>*</b> <b>conf)</b>
       Update security session as specified by the session configuration

       <b>Parameters</b>
           <u>instance</u> security instance
           <u>sess</u> session to update parameters
           <u>conf</u> update configuration parameters

       <b>Returns</b>

           • On success returns 0

           • On failure returns a negative errno value.

   <b>unsigned</b> <b>int</b> <b>rte_security_session_get_size</b> <b>(void</b> <b>*</b> <b>instance)</b>
       Get the size of the security session data for a device.

       <b>Parameters</b>
           <u>instance</u> security instance.

       <b>Returns</b>

           • Size of the private data, if successful

           • 0 if device is invalid or does not support the operation.

   <b>int</b> <b>rte_security_session_destroy</b> <b>(void</b> <b>*</b> <b>instance,</b> <b>void</b> <b>*</b> <b>sess)</b>
       Free security session header and the session private data and return it to its original mempool.

       <b>Parameters</b>
           <u>instance</u> security instance
           <u>sess</u> security session to be freed

       <b>Returns</b>

           • 0 if successful.

           • -EINVAL if session or context instance is NULL.

           • -EBUSY if not all device private data has been freed.

           • -ENOTSUP if destroying private data is not supported.

           • other negative values in case of freeing private data errors.

   <b>int</b> <b>rte_security_macsec_sc_create</b> <b>(void</b> <b>*</b> <b>instance,</b> <b>struct</b> <b>rte_security_macsec_sc</b> <b>*</b> <b>conf)</b>
       Create MACsec security channel (SC).

       <b>Parameters</b>
           <u>instance</u> security instance
           <u>conf</u> MACsec SC configuration params

       <b>Returns</b>

           • secure channel ID if successful.

           • -EINVAL if configuration params are invalid of instance is NULL.

           • -ENOTSUP if device does not support MACsec.

           • -ENOMEM if PMD is not capable to create more SC.

           • other negative value for other errors.

   <b>int</b> <b>rte_security_macsec_sc_destroy</b> <b>(void</b> <b>*</b> <b>instance,</b> <b>uint16_t</b> <b>sc_id,</b> <b>enum</b> <b>rte_security_macsec_direction</b> <b>dir)</b>
       Destroy MACsec security channel (SC).

       <b>Parameters</b>
           <u>instance</u> security instance
           <u>sc_id</u> SC ID to be destroyed
           <u>dir</u> direction of the SC

       <b>Returns</b>

           • 0 if successful.

           • -EINVAL if sc_id is invalid or instance is NULL.

           • -EBUSY if sc is being used by some session.

   <b>int</b> <b>rte_security_macsec_sa_create</b> <b>(void</b> <b>*</b> <b>instance,</b> <b>struct</b> <b>rte_security_macsec_sa</b> <b>*</b> <b>conf)</b>
       Create MACsec security association (SA).

       <b>Parameters</b>
           <u>instance</u> security instance
           <u>conf</u> MACsec SA configuration params

       <b>Returns</b>

           • positive SA ID if successful.

           • -EINVAL if configuration params are invalid of instance is NULL.

           • -ENOTSUP if device does not support MACsec.

           • -ENOMEM if PMD is not capable to create more SAs.

           • other negative value for other errors.

   <b>int</b> <b>rte_security_macsec_sa_destroy</b> <b>(void</b> <b>*</b> <b>instance,</b> <b>uint16_t</b> <b>sa_id,</b> <b>enum</b> <b>rte_security_macsec_direction</b> <b>dir)</b>
       Destroy MACsec security association (SA).

       <b>Parameters</b>
           <u>instance</u> security instance
           <u>sa_id</u> SA ID to be destroyed
           <u>dir</u> direction of the SA

       <b>Returns</b>

           • 0 if successful.

           • -EINVAL if sa_id is invalid or instance is NULL.

           • -EBUSY if sa is being used by some session.

   <b>static</b> <b>rte_security_dynfield_t</b> <b>*</b> <b>rte_security_dynfield</b> <b>(struct</b> <b>rte_mbuf</b> <b>*</b> <b>mbuf)</b> <b>[inline],</b>  <b>[static]</b>
       Get pointer to mbuf field for device-specific metadata.

       For performance reason, no check is done, the dynamic field may not be registered.

       <b>See</b> <b>also</b>
           <b>rte_security_dynfield_is_registered</b>

       <b>Parameters</b>
           <u>mbuf</u> packet to access

       <b>Returns</b>
           pointer to mbuf field

       Definition at line <b>937</b> of file <b>rte_security.h</b>.

   <b>static</b> <b>__rte_experimental</b> <b>rte_security_oop_dynfield_t</b> <b>*</b> <b>rte_security_oop_dynfield</b> <b>(struct</b>  <b>rte_mbuf</b>  <b>*</b>  <b>mbuf)</b>
       <b>[inline],</b>  <b>[static]</b>
       <b>Warning</b>
           <b>EXPERIMENTAL:</b> this API may change without prior notice

       Get  pointer  to  mbuf  field  for  original mbuf pointer when Out-Of-Place(OOP) processing is enabled in
       security session.

       <b>Parameters</b>
           <u>mbuf</u> packet to access

       <b>Returns</b>
           pointer to mbuf field

       Definition at line <b>956</b> of file <b>rte_security.h</b>.

   <b>static</b> <b>bool</b> <b>rte_security_dynfield_is_registered</b> <b>(void)</b> <b>[inline],</b>  <b>[static]</b>
       Check whether the dynamic field is registered.

       <b>Returns</b>
           true if rte_security_dynfield_register() has been called.

       Definition at line <b>968</b> of file <b>rte_security.h</b>.

   <b>static</b> <b>uint32_t</b> <b>rte_security_ctx_flags_get</b> <b>(void</b> <b>*</b> <b>ctx)</b> <b>[inline],</b>  <b>[static]</b>
       Get security flags from security instance.

       Definition at line <b>978</b> of file <b>rte_security.h</b>.

   <b>static</b> <b>void</b> <b>rte_security_ctx_flags_set</b> <b>(void</b> <b>*</b> <b>ctx,</b> <b>uint32_t</b> <b>flags)</b> <b>[inline],</b>  <b>[static]</b>
       Set security flags in security instance.

       Definition at line <b>987</b> of file <b>rte_security.h</b>.

   <b>static</b> <b>uint64_t</b> <b>rte_security_session_opaque_data_get</b> <b>(void</b> <b>*</b> <b>sess)</b> <b>[inline],</b>  <b>[static]</b>
       Get opaque data from session handle

       Definition at line <b>1000</b> of file <b>rte_security.h</b>.

   <b>static</b> <b>void</b> <b>rte_security_session_opaque_data_set</b> <b>(void</b> <b>*</b> <b>sess,</b> <b>uint64_t</b> <b>opaque)</b> <b>[inline],</b>  <b>[static]</b>
       Set opaque data in session handle

       Definition at line <b>1009</b> of file <b>rte_security.h</b>.

   <b>static</b> <b>uint64_t</b> <b>rte_security_session_fast_mdata_get</b> <b>(void</b> <b>*</b> <b>sess)</b> <b>[inline],</b>  <b>[static]</b>
       Get fast mdata from session handle

       Definition at line <b>1020</b> of file <b>rte_security.h</b>.

   <b>static</b> <b>void</b> <b>rte_security_session_fast_mdata_set</b> <b>(void</b> <b>*</b> <b>sess,</b> <b>uint64_t</b> <b>fdata)</b> <b>[inline],</b>  <b>[static]</b>
       Set fast mdata in session handle

       Definition at line <b>1029</b> of file <b>rte_security.h</b>.

   <b>int</b> <b>__rte_security_set_pkt_metadata</b> <b>(void</b> <b>*</b> <b>instance,</b> <b>void</b> <b>*</b> <b>sess,</b> <b>struct</b> <b>rte_mbuf</b> <b>*</b> <b>m,</b> <b>void</b> <b>*</b> <b>params)</b>
       Function to call PMD specific function pointer set_pkt_metadata()

   <b>static</b> <b>int</b> <b>rte_security_set_pkt_metadata</b> <b>(void</b> <b>*</b> <b>instance,</b> <b>void</b> <b>*</b> <b>sess,</b> <b>struct</b> <b>rte_mbuf</b> <b>*</b> <b>mb,</b> <b>void</b> <b>*</b>  <b>params)</b>
       <b>[inline],</b>  <b>[static]</b>
       Updates the buffer with device-specific defined metadata

       <b>Parameters</b>
           <u>instance</u> security instance
           <u>sess</u> security session
           <u>mb</u> packet mbuf to set metadata on.
           <u>params</u> device-specific defined parameters required for metadata

       <b>Returns</b>

           • On success, zero.

           • On failure, a negative value.

       Definition at line <b>1055</b> of file <b>rte_security.h</b>.

   <b>static</b> <b>int</b> <b>__rte_security_attach_session</b> <b>(struct</b> <b>rte_crypto_sym_op</b> <b>*</b> <b>sym_op,</b> <b>void</b> <b>*</b> <b>sess)</b> <b>[inline],</b>  <b>[static]</b>

       Attach a session to a symmetric crypto operation

       <b>Parameters</b>
           <u>sym_op</u> crypto operation
           <u>sess</u> security session

       Definition at line <b>1077</b> of file <b>rte_security.h</b>.

   <b>static</b> <b>int</b> <b>rte_security_attach_session</b> <b>(struct</b> <b>rte_crypto_op</b> <b>*</b> <b>op,</b> <b>void</b> <b>*</b> <b>sess)</b> <b>[inline],</b>  <b>[static]</b>
       Attach    a    session    to   a   crypto   operation.   This   API   is   needed   only   in   case   of
       RTE_SECURITY_SESS_CRYPTO_PROTO_OFFLOAD For other rte_security_session_action_type, ol_flags  in  <b>rte_mbuf</b>
       may be defined to perform security operations.

       <b>Parameters</b>
           <u>op</u> crypto operation
           <u>sess</u> security session

       Definition at line <b>1094</b> of file <b>rte_security.h</b>.

   <b>int</b> <b>rte_security_session_stats_get</b> <b>(void</b> <b>*</b> <b>instance,</b> <b>void</b> <b>*</b> <b>sess,</b> <b>struct</b> <b>rte_security_stats</b> <b>*</b> <b>stats)</b>
       Get security session statistics

       <b>Parameters</b>
           <u>instance</u> security instance
           <u>sess</u> security session If security session is NULL then global (per security instance) statistics will
           be  retrieved,  if  supported.  Global  statistics  collection  is  not  dependent on the per session
           statistics configuration.
           <u>stats</u> statistics

       <b>Returns</b>

           • On success, return 0

           • On failure, a negative value

   <b>int</b> <b>rte_security_macsec_sa_stats_get</b> <b>(void</b> <b>*</b> <b>instance,</b>  <b>uint16_t</b>  <b>sa_id,</b>  <b>enum</b>  <b>rte_security_macsec_direction</b>
       <b>dir,</b> <b>struct</b> <b>rte_security_macsec_sa_stats</b> <b>*</b> <b>stats)</b>
       Get MACsec SA statistics.

       <b>Parameters</b>
           <u>instance</u> security instance
           <u>sa_id</u> SA ID for which stats are needed
           <u>dir</u> direction of the SA
           <u>stats</u> statistics

       <b>Returns</b>

           • On success, return 0.

           • On failure, a negative value.

   <b>int</b>  <b>rte_security_macsec_sc_stats_get</b>  <b>(void</b>  <b>*</b>  <b>instance,</b> <b>uint16_t</b> <b>sc_id,</b> <b>enum</b> <b>rte_security_macsec_direction</b>
       <b>dir,</b> <b>struct</b> <b>rte_security_macsec_sc_stats</b> <b>*</b> <b>stats)</b>
       Get MACsec SC statistics.

       <b>Parameters</b>
           <u>instance</u> security instance
           <u>sc_id</u> SC ID for which stats are needed
           <u>dir</u> direction of the SC
           <u>stats</u> SC statistics

       <b>Returns</b>

           • On success, return 0.

           • On failure, a negative value.

   <b>const</b> <b>struct</b> <b>rte_security_capability</b> <b>*</b> <b>rte_security_capabilities_get</b> <b>(void</b> <b>*</b> <b>instance)</b>
       Returns array of security instance capabilities

       <b>Parameters</b>
           <u>instance</u> Security instance.

       <b>Returns</b>

           • Returns array of security capabilities.

           • Return NULL if no capabilities available.

   <b>const</b>   <b>struct</b>   <b>rte_security_capability</b>   <b>*</b>   <b>rte_security_capability_get</b>   <b>(void</b>   <b>*</b>    <b>instance,</b>    <b>struct</b>
       <b>rte_security_capability_idx</b> <b>*</b> <b>idx)</b>
       Query if a specific capability is available on security instance

       <b>Parameters</b>
           <u>instance</u> security instance.
           <u>idx</u> security capability index to match against

       <b>Returns</b>

           • Returns pointer to security capability on match of capability index criteria.

           • Return NULL if the capability not matched on security instance.

   <b>__rte_experimental</b> <b>int</b> <b>rte_security_rx_inject_configure</b> <b>(void</b> <b>*</b> <b>ctx,</b> <b>uint16_t</b> <b>port_id,</b> <b>bool</b> <b>enable)</b>
       <b>Warning</b>
           <b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice

       Configure security device to inject packets to an ethdev port.

       This  API  must be called only when both security device and the ethdev is in stopped state. The security
       device need to be configured before any packets are submitted to rte_security_inb_pkt_rx_inject API.

       <b>Parameters</b>
           <u>ctx</u> Security ctx
           <u>port_id</u> Port identifier of the ethernet device to which packets need to be injected.
           <u>enable</u> Flag to enable and disable connection between a security device and an ethdev port.

       <b>Returns</b>

           • 0 if successful.

           • -EINVAL if context NULL or port_id is invalid.

           • -EBUSY if devices are not in stopped state.

           • -ENOTSUP if security device does not support injecting to ethdev port.

       <b>See</b> <b>also</b>
           <b>rte_security_inb_pkt_rx_inject</b>

   <b>__rte_experimental</b> <b>uint16_t</b> <b>rte_security_inb_pkt_rx_inject</b> <b>(void</b> <b>*</b> <b>ctx,</b> <b>struct</b>  <b>rte_mbuf</b>  <b>**</b>  <b>pkts,</b>  <b>void</b>  <b>**</b>
       <b>sess,</b> <b>uint16_t</b> <b>nb_pkts)</b>
       <b>Warning</b>
           <b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice

       Perform security processing of packets and inject the processed packet to ethdev Rx.

       Rx  inject would behave similarly to ethdev loopback but with the additional security processing. In case
       of ethdev loopback, application would be submitting packets to ethdev Tx queues and would be received  as
       is from ethdev Rx queues. With Rx inject, packets would be received after security processing from ethdev
       Rx queues.

       With inline protocol offload capable ethdevs, Rx injection can be used to handle packets which failed the
       regular  security  Rx  path.  This  can  be  due  to  cases  such  as  outer fragmentation, in which case
       applications can reassemble the fragments and then subsequently submit  for  inbound  processing  and  Rx
       injection, so that packets are received as regular security processed packets.

       With  lookaside  protocol  offload capable cryptodevs, Rx injection can be used to perform packet parsing
       after security processing. This would allow for re-classification after security protocol  processing  is
       done (ie, inner packet parsing). The ethdev queue on which the packet would be received would be based on
       rte_flow rules matching the packet after security processing.

       The   security   device   which   is  injecting  packets  to  ethdev  Rx  need  to  be  configured  using
       rte_security_rx_inject_configure with enable flag set to true before any packets are submitted.

       If hash.fdir.h field is set in mbuf, it would be treated as the value for MARK pattern for the subsequent
       rte_flow parsing. The packet would appear as if it is received from port field in mbuf.

       Since the packet would be  received  back  from  ethdev  Rx  queues,  it  is  expected  that  application
       retains/adds L2 header with the mbuf field 'l2_len' reflecting the size of L2 header in the packet.

       <b>Parameters</b>
           <u>ctx</u> Security ctx
           <u>pkts</u> The address of an array of <u>nb_pkts</u> pointers to <b>rte_mbuf</b> <b>structures</b> <b>which</b> <b>contain</b> <b>the</b> <b>packets.</b>
           <u>sess</u> <b>The</b> <b>address</b> <b>of</b> <b>an</b> <b>array</b> <b>of</b> <u>nb_pkts</u> <b>pointers</b> <b>to</b> <b>security</b> <b>sessions</b> <b>corresponding</b> <b>to</b> <b>each</b> <b>packet.</b>
           <u>nb_pkts</u> <b>The</b> <b>maximum</b> <b>number</b> <b>of</b> <b>packets</b> <b>to</b> <b>process.</b>

       <b>Returns</b>
           The number of packets successfully injected to ethdev Rx. The return value can be less than the value
           of the <u>nb_pkts</u> parameter when the PMD internal queues have been filled up.

       <b>See</b> <b>also</b>
           <b>rte_security_rx_inject_configure</b>

</pre><h4><b>Variable</b> <b>Documentation</b></h4><pre>
   <b>int</b> <b>rte_security_dynfield_offset</b> <b>[extern]</b>
       Dynamic mbuf field for device-specific metadata

   <b>int</b> <b>rte_security_oop_dynfield_offset</b> <b>[extern]</b>
       Dynamic mbuf field for pointer to original mbuf for OOP processing session.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                               <u><a href="../man3/rte_security.h.3.html">rte_security.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>