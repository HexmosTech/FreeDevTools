<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIME::Field::ContType - a "Content-type" field</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmime-tools-perl">libmime-tools-perl_5.515-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MIME::Field::ContType - a "Content-type" field

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A subclass of Mail::Field.

       <u>Don't</u> <u>use</u> <u>this</u> <u>class</u> <u>directly...</u> <u>its</u> <u>name</u> <u>may</u> <u>change</u> <u>in</u> <u>the</u> <u>future!</u>  Instead, ask Mail::Field for new
       instances based on the field name!

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Mail::Field;
           use MIME::Head;

           # Create an instance from some text:
           $field = Mail::Field-&gt;new('Content-type',
                                     'text/HTML; charset="US-ASCII"');

           # Get the MIME type, like 'text/plain' or 'x-foobar'.
           # Returns 'text/plain' as default, as per RFC 2045:
           my ($type, $subtype) = split('/', $field-&gt;type);

           # Get generic information:
           print $field-&gt;name;

           # Get information related to "message" type:
           if ($type eq 'message') {
               print $field-&gt;id;
               print $field-&gt;number;
               print $field-&gt;total;
           }

           # Get information related to "multipart" type:
           if ($type eq 'multipart') {
               print $field-&gt;boundary;            # the basic value, fixed up
               print $field-&gt;multipart_boundary;  # empty if not a multipart message!
           }

           # Get information related to "text" type:
           if ($type eq 'text') {
               print $field-&gt;charset;      # returns 'us-ascii' as default
           }

</pre><h4><b>PUBLIC</b> <b>INTERFACE</b></h4><pre>
       boundary
           Return  the  boundary field.  The boundary is returned exactly as given in the "Content-type:" field;
           that is, the leading double-hyphen ("--") is <u>not</u> prepended.

           (Well, <u>almost</u> exactly... from RFC 2046:

              (If a boundary appears to end with white space, the white space
              must be presumed to have been added by a gateway, and must be deleted.)

           so we oblige and remove any trailing spaces.)

           Returns the empty string if there is no boundary, or if the boundary is illegal (e.g., if it is empty
           after all trailing whitespace has been removed).

       multipart_boundary
           Like boundary(), except that this will also return the empty string if the message is not a multipart
           message.  In other words, there's an automatic sanity check.

       type
           Try real hard to determine the content type (e.g., "text/plain", "image/gif",  "x-weird-type",  which
           is returned in all-lowercase.

           A happy thing: the following code will work just as you would want, even if there's no subtype (as in
           "x-weird-type")... in such a case, the $subtype would simply be the empty string:

               ($type, $subtype) = split('/', $head-&gt;mime_type);

           If the content-type information is missing, it defaults to "text/plain", as per RFC 2045:

               Default RFC 2822 messages are typed by this protocol as plain text in
               the US-ASCII character set, which can be explicitly specified as
               "Content-type: text/plain; charset=us-ascii".  If no Content-Type is
               specified, this default is assumed.

           <b>Note:</b>  under  the  "be liberal in what we accept" principle, this routine no longer syntax-checks the
           content type.  If it ain't empty, just downcase and return it.

</pre><h4><b>NOTES</b></h4><pre>
       Since nearly all (if not all) parameters must have non-empty values  to  be  considered  valid,  we  just
       return the empty string to signify missing fields.  If you need to get the <u>real</u> underlying value, use the
       inherited param() method (which returns undef if the parameter is missing).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       MIME::Field::ParamVal, Mail::Field

</pre><h4><b>AUTHOR</b></h4><pre>
       Eryq (<u><a href="mailto:eryq@zeegee.com">eryq@zeegee.com</a></u>), ZeeGee Software Inc (<u><a href="http://www.zeegee.com">http://www.zeegee.com</a></u>).  Dianne Skoll (<a href="mailto:dianne@skoll.ca">dianne@skoll.ca</a>)

perl v5.38.2                                       2024-04-27                         <u>MIME::Field::<a href="../man3pm/ContType.3pm.html">ContType</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>