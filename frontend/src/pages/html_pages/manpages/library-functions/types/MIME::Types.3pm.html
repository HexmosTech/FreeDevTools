<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIME::Types - Definition of MIME types</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmime-types-perl">libmime-types-perl_2.28-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MIME::Types - Definition of MIME types

</pre><h4><b>INHERITANCE</b></h4><pre>
        MIME::Types
          is an Exporter

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use MIME::Types;
        my $mt    = MIME::Types-&gt;new(...);    # MIME::Types object
        my $type  = $mt-&gt;type('text/plain');  # MIME::Type  object
        my $type  = $mt-&gt;mimeTypeOf('gif');
        my $type  = $mt-&gt;mimeTypeOf('picture.jpg');
        my @types = $mt-&gt;httpAccept('text/html, application/json;q=0.1')

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "MIME Type" is the old name for "Media Type".  This module dates from 1999, and name changes are painful,
       so we stuck with the original name.

       Media types are used in many applications (for instance as part of e-mail and HTTP traffic) to indicate
       the type of content which is transmitted.  or expected.  Read RFC6838 at
       <u>https://www.rfc-editor.org/rfc/rfc6838</u> (registrations) and RFC9694 at
       <u>https://www.rfc-editor.org/rfc/rfc9694</u> (top-levels) for the specification.

       Sometimes detailed knowledge about a mime-type is need, however this module only knows about the file-
       name extensions which relate to some filetype.  It can also be used to produce the right format: types
       which are not registered at IANA need to use 'x-' prefixes.

       This object administers a huge list of known mime-types, combined from various sources.  For instance, it
       contains <b>all</b> <b>IANA</b> types and the knowledge of Apache.  Probably the most complete table on the net!

   <b>MIME::Types</b> <b>and</b> <b>daemons</b> <b>(fork)</b>
       If your program uses fork (usually for a daemon), then you want to have the type table initialized before
       you start forking. So, first call

          my $mt = MIME::Types-&gt;new;

       Later, each time you create this object (you may, of course, also reuse the object you create here) you
       will get access to <b>the</b> <b>same</b> <b>global</b> <b>table</b> of types.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Constructors</b>
       MIME::Types-&gt;<b>new</b>(%options)
           Create a new "MIME::Types" object which manages the data.  In the current implementation, it does not
           matter whether you create this object often within your program, but in the future this may change.

            -Option         --Default
             db_file          &lt;installed source&gt;
             only_complete    &lt;false&gt;
             only_iana        &lt;false&gt;
             skip_extensions  &lt;false&gt;

           db_file =&gt; FILENAME
             The  location of the database which contains the type information.  Only the first instantiation of
             this object will have this parameter obeyed.

             [2.10] This parameter can be globally overruled via the "PERL_MIME_TYPE_DB"  environment  variable,
             which  may  be needed in case of PAR or other tricky installations.  For PAR, you probably set this
             environment variable to "inc/lib/MIME/types.db"

           only_complete =&gt; BOOLEAN
             Only include complete MIME type definitions: requires at least  one  known  extension.   This  will
             reduce the number of entries --and with that the amount of memory consumed-- considerably.

             In  your  program  you  have to decide: the first time that you call the creator ("new") determines
             whether you get the full or the partial information.

           only_iana =&gt; BOOLEAN
             Only load the types which are currently known by IANA.

           skip_extensions =&gt; BOOLEAN
             Do not load the table to map extensions to types, which is quite large.

   <b>Knowledge</b>
       $obj-&gt;<b>addType</b>($type, ...)
           Add one or more TYPEs to the set of  known  types.   Each  TYPE  is  a  "MIME::Type"  which  must  be
           experimental: either the main-type or the sub-type must start with "x-".

           Please  inform  the  maintainer  of  this  module  when registered types are missing.  Before version
           MIME::Types version 1.14, a warning was produced when an unknown IANA type was added.  This has  been
           removed,  because  some  people  need  that  to  get  their  application  to  work  locally... broken
           applications...

       $obj-&gt;<b>extensions</b>()
           Returns a list of all defined extensions.

       $obj-&gt;<b>listTypes</b>()
           Returns a list of all defined mime-types by name only.  This will <b>not</b> instantiate MIME::Type objects.
           See <b>types()</b>

       $obj-&gt;<b>mimeTypeOf</b>($filename)
           Returns the "MIME::Type" object which belongs to the FILENAME (or simply its filename  extension)  or
           "undef" if the file type is unknown.  The extension is used and considered case-insensitive.

           In  some  cases,  more  than  one  type is known for a certain filename extension.  In that case, the
           preferred one is taken (for an unclear definition of preference)

           example: use of <b>mimeTypeOf()</b>

            my $types = MIME::Types-&gt;new;
            my $mime = $types-&gt;mimeTypeOf('gif');

            my $mime = $types-&gt;mimeTypeOf('picture.jpg');
            print $mime-&gt;isBinary;

       $obj-&gt;<b>type</b>($string)
           Returns the "MIME::Type" which describes the type related to STRING.  [2.00] Only one  type  will  be
           returned.

           [before  2.00] One type may be described more than once.  Different extensions may be in use for this
           type, and different operating systems may cause more than one "MIME::Type" object to be defined.   In
           scalar context, only the first is returned.

       $obj-&gt;<b>types</b>()
           Returns  a  list  of  all  defined  mime-types.   For  reasons  of backwards compatibility, this will
           instantiate MIME::Type objects, which will be returned.  See <b>listTypes()</b>.

   <b>HTTP</b> <b>support</b>
       $obj-&gt;<b>httpAccept</b>($header)
           [2.07] Decompose  a  typical  HTTP-Accept  header,  and  sort  it  based  on  the  included  priority
           information.  Returned is a sorted list of type names, where the highest priority type is first.  The
           list may contain '*/*' (accept any) or a '*' as subtype.

           Ill-formated typenames are ignored.  On equal qualities, the order is kept.  See RFC2616 section 14.1

           example:

             my @types = $types-&gt;httpAccept('text/html, application/json;q=0.9');

       $obj-&gt;<b>httpAcceptBest</b>($accept|\@types, @have)
           [2.07]  The  $accept  string is processed via <b>httpAccept()</b> to order the types on preference.  You may
           also provide a list of ordered @types which may have been the result of that method, called earlier.

           As second parameter, you pass a LIST of types you @have  to  offer.   Those  need  to  be  MIME::Type
           objects.  The  preferred type will get selected.  When none of these are accepted by the client, this
           will return "undef".  It should result in a 406 server response.

           example:

              my $accept = $req-&gt;header('Accept');
              my @have   = map $mt-&gt;type($_), qw[text/plain text/html];
              my @ext    = $mt-&gt;httpAcceptBest($accept, @have);

       $obj-&gt;<b>httpAcceptSelect</b>($accept|\@types, @filenames|\@filenames)
           [2.07] Like <b>httpAcceptBest()</b>, but now we do not return a pair with mime-type and filename,  not  just
           the type.  If $accept is "undef", the first filename is returned.

           example:

              use HTTP::Status ':constants';
              use File::Glob   'bsd_glob';    # understands blanks in filename

              my @filenames   = bsd_glob "$imagedir/$fnbase.*;
              my $accept      = $req-&gt;header('Accept');
              my ($fn, $mime) = $mt-&gt;httpAcceptSelect($accept, @filenames);
              my $code        = defined $mime ? HTTP_NOT_ACCEPTABLE : HTTP_OK;

</pre><h4><b>FUNCTIONS</b></h4><pre>
       The  next  functions  are provided for backward compatibility with MIME::Types versions [0.06] and below.
       This code originates from Jeff Okamoto <u><a href="mailto:okamoto@corp.hp.com">okamoto@corp.hp.com</a></u> and others.

       <b>by_mediatype</b>(TYPE)
           This function takes a media type and returns a list or anonymous  array  of  anonymous  three-element
           arrays  whose  values  are  the  file  name suffix used to identify it, the media type, and a content
           encoding.

           TYPE can be a full type name (contains '/', and will be matched in full), a partial  type  (which  is
           used as regular expression) or a real regular expression.

       <b>by_suffix</b>(FILENAME|SUFFIX)
           Like "mimeTypeOf", but does not return an "MIME::Type" object. If the file +type is unknown, both the
           returned media type and encoding are empty strings.

           example: use of function <b>by_suffix()</b>

            use MIME::Types 'by_suffix';
            my ($mediatype, $encoding) = by_suffix('image.gif');

            my $refdata = by_suffix('image.gif');
            my ($mediatype, $encoding) = @$refdata;

       <b>import_mime_types</b>()
           This  method  has been removed: mime-types are only useful if understood by many parties.  Therefore,
           the IANA assigns names which can be used.  In the table kept by this "MIME::Types" module  all  these
           names,  plus  the  most  often  used temporary names are kept.  When names seem to be missing, please
           contact the maintainer for inclusion.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This module is part  of  MIME-Types  distribution  version  2.28,  built  on  April  18,  2025.  Website:
       <u><a href="http://perl.overmeer.net/CPAN/">http://perl.overmeer.net/CPAN/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 1999-2025 by [Mark Overmeer &lt;<a href="mailto:mark@overmeer.net">mark@overmeer.net</a>&gt;]. For other contributors see ChangeLog.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.1                                       2025-04-21                                   <u>MIME::<a href="../man3pm/Types.3pm.html">Types</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>