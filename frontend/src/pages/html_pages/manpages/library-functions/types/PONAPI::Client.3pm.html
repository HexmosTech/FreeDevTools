<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PONAPI::Client - Client to a {JSON:API} service (http://jsonapi.org/) v1.0</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libponapi-client-perl">libponapi-client-perl_0.002012-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PONAPI::Client - Client to a {JSON:API} service (<a href="http://jsonapi.org/">http://jsonapi.org/</a>) v1.0

</pre><h4><b>VERSION</b></h4><pre>
       version 0.002012

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use PONAPI::Client;
           my $client = PONAPI::Client-&gt;new(
               host =&gt; $host,
               port =&gt; $port,
           );

           $client-&gt;retrieve_all( type =&gt; $type );

           $client-&gt;retrieve(
               type =&gt; $type,
               id   =&gt; $id,
           );

           $client-&gt;retrieve_relationships(
               type     =&gt; $type,
               id       =&gt; $id,
               rel_type =&gt; $rel_type,
           );

           $client-&gt;retrieve_by_relationship(
               type     =&gt; $type,
               id       =&gt; $id,
               rel_type =&gt; $rel_type,
           );

           $client-&gt;create(
               type =&gt; $type,
               data =&gt; {
                   attributes    =&gt; { ... },
                   relationships =&gt; { ... },
               },
           );

           $client-&gt;delete(
               type =&gt; $type,
               id   =&gt; $id,
           );

           $client-&gt;update(
               type =&gt; $type,
               id   =&gt; $id,
               data =&gt; {
                   type =&gt; $type,
                   id   =&gt; $id,
                   attributes    =&gt; { ... },
                   relationships =&gt; { ... },
               }
           );

           $client-&gt;delete_relationships(
               type =&gt; $type,
               id   =&gt; $id,
               rel_type =&gt; $rel_type,
               data =&gt; [
                   { type =&gt; $rel_type, id =&gt; $rel_id },
                   ...
               ],
           );

           $client-&gt;create_relationships(
               type =&gt; $type,
               id   =&gt; $id,
               rel_type =&gt; $rel_type,
               data =&gt; [
                   { type =&gt; $rel_type, id =&gt; $rel_id },
                   ...
               ],
           );

           $client-&gt;update_relationships(
               type =&gt; $type,
               id   =&gt; $id,
               rel_type =&gt; $rel_type,
               # for a one-to-one:
               data =&gt; { type =&gt; $rel_type, id =&gt; $rel_id },
               # or for a one-to-many:
               data =&gt; [
                   { type =&gt; $rel_type, id =&gt; $rel_id },
                   ...
               ],
           );

           # If the endpoint uses an uncommon url format:
           $client-&gt;retrieve(
               type =&gt; 'foo',
               id   =&gt; 43,
               # Will generate a request to
               # host:port/type_foo_id_43
               uri_template =&gt; "type_{type}_id_{id}",
           );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "PONAPI::Client" is a {JSON:API} &lt;<a href="http://jsonapi.org/">http://jsonapi.org/</a>&gt; compliant client; it should be able to communicate
       with any API-compliant service.

       The client does a handful of checks required by the spec, then uses Hijk to communicate with the service.

       In most cases, all API methods return a response document:

           my $response = $client-&gt;retrieve(...);

       In list context however, all api methods will return the request status and the document:

           my ($status, $response) = $client-&gt;retrieve(...)

       Response documents will look something like these:

           # Successful retrieve(type =&gt; 'articles', id =&gt; 2)
           {
               jsonapi  =&gt; { version =&gt; "1.0"         },
               links    =&gt; { self    =&gt; "/articles/2" },
               data     =&gt; { ... },
               meta     =&gt; { ... }, # May not be there
               included =&gt; [ ... ], # May not be there, see C&lt;include&gt;
           }

           # Successful retrieve_all( type =&gt; 'articles' )
           {
               jsonapi =&gt; { version =&gt; "1.0"       },
               links   =&gt; { self    =&gt; "/articles" }, # May include pagination links
               data    =&gt; [
                   { ... },
                   { ... },
                   ...
               ],
               meta     =&gt; { ... }, # May not be there
               included =&gt; [ ... ], # May not be there, see C&lt;include&gt;
           }

           # Successful create(type =&gt; 'foo', data =&gt; { ... })
           {
               jsonapi =&gt; { version =&gt; "1.0"                 },
               links   =&gt; { self =&gt; "/foo/$created_id"       },
               data    =&gt; { type =&gt; 'foo', id =&gt; $created_id },
           }

           # Successful update(type =&gt; 'foo', id =&gt; 2, data =&gt; { ... })
           {
               jsonapi =&gt; { version =&gt; "1.0" },
               links   =&gt; { self =&gt; "/foo/2" }, # may not be there
               meta    =&gt; { ...              }, # may not be there
           }

           # Error, see <a href="http://jsonapi.org/format/">http://jsonapi.org/format/</a>#error-objects
           {
               jsonapi =&gt; { version =&gt; "1.0" },
               errors  =&gt; [
                   { ... }, # error 1
                   ...      # potentially others
               ],
           }

       However, there are situations where the server may respond with a "204 No Content" and no response
       document; depending on the situation, it might be worth checking the status.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       Creates a new "PONAPI::Client" object.  Takes a couple of attributes:

       host
           The hostname (or IP address) of the service.  Defaults to localhost.

       port
           Port of the service.  Defaults to 5000.

       send_version_header
           Sends a "X-PONAPI-Client-Version" header set to the {JSON:API} version the client supports.  Defaults
           to true.

   <b>retrieve_all</b>
           retrieve_all( type =&gt; $type, %optional_arguments )

       Retrieves <b>all</b> resources of the given type.  In SQL, this is similar to "SELECT * FROM $type".

       This handles several arguments:

       fields
           Spec &lt;<a href="http://jsonapi.org/format/">http://jsonapi.org/format/</a>#fetching-sparse-fieldsets&gt;.

           Instead  of returning every attribute and relationship from a given resource, "fields" can be used to
           specify exactly what is returned.

           This excepts a hashref of arrayrefs, where the keys are types, and the values  are  either  attribute
           names, or relationship names.

               $client-&gt;retrieve_all(
                   type   =&gt; 'people',
                   fields =&gt; { people =&gt; [ 'name', 'age' ] }
               )

           Note that an attribute not being in fields means the opposite to an attribute having empty fields:

               # No attributes or relationships for both people and comments
               $client-&gt;retrieve_all(
                   type   =&gt; 'people',
                   fields =&gt; { people =&gt; [], comments =&gt; [] },
               );

               # No attributes or relationships for comments, but
               # ALL attributes and relationships for people
               $client-&gt;retrieve_all(
                   type   =&gt; 'people',
                   fields =&gt; { comments =&gt; [] },
               );

       include
           Spec &lt;<a href="http://jsonapi.org/format/">http://jsonapi.org/format/</a>#fetching-includes&gt;.

           "include" can be used to fetch related resources.  The example below is fetching both all the people,
           and all comments made by those people:

               my $response = $client-&gt;retrieve_all(
                   type   =&gt; 'people',
                   include =&gt; ['comments']
               );

           "include"  expects an arrayref of relationship names.  In the response, the resources fetched will be
           in an arrayref under the top-level "included" key:

               say $_-&gt;{attributes}{body} for @{ $response-&gt;{included} }

       page
           Spec &lt;<a href="http://jsonapi.org/format/">http://jsonapi.org/format/</a>#fetching-pagination&gt;.

           Requests that the server paginate the results.  Each endpoint may have different pagination rules.

       sort
           Spec &lt;<a href="http://jsonapi.org/format/">http://jsonapi.org/format/</a>#fetching-sorting&gt;.

           Requests that the server sort the results in a given way:

               $client-&gt;retrieve_all(
                   type =&gt; 'people',
                   sort =&gt; [qw/ age  /], # sort by age, ascending
               );

               $client-&gt;retrieve_all(
                   type =&gt; 'people',
                   sort =&gt; [qw/ -age /], # sort by age, descending
               );

           Although not all endpoints will support this,  it  may  be  possible  to  sort  by  a  relationship's
           attribute:

               $client-&gt;retrieve_all(
                   type =&gt; 'people',
                   sort =&gt; [qw/ -comments.created_date /],
               );

       filter
           Spec &lt;<a href="http://jsonapi.org/format/">http://jsonapi.org/format/</a>#fetching-filtering&gt;.

           This one is entirely dependent on the endpoint.  It's usually employed to act as a "WHERE" clause:

               $client-&gt;retrieve_all(
                   type   =&gt; 'people',
                   filter =&gt; {
                       id  =&gt; [ 1, 2, 3, 4, 6 ], # IN ( 1, 2, ... )
                       age =&gt; 34,                # age = 34
                   },
               );

           Sadly, more complex filters are currently not available.

   <b>retrieve</b>
           retrieve( type =&gt; $type, id =&gt; $id, %optional_arguments )

       Similar to "retrieve_all", but retrieves a single resource.

   <b>retrieve_relationships</b>
           retrieve_relationships( type =&gt; $type, id =&gt; $id, rel_type =&gt; $rel_type, %optional_arguments )

       Retrieves  all  of  $id's  relationships  to $rel_type as resource identifiers; that is, as hashrefs that
       contain only "type" and "id":

           # retrieve_relationships(type=&gt;'people', id=&gt;2, rel_type=&gt;'comments')
           {
               jsonapi =&gt; { version =&gt; "1.0" },
               data    =&gt; [
                   { type =&gt; 'comments', id =&gt; 4  },
                   { type =&gt; 'comments', id =&gt; 9  },
                   { type =&gt; 'comments', id =&gt; 14 },
               ]
           }

       These two do roughly the same thing:

           my $response      = $client-&gt;retrieve( type =&gt; $type, id =&gt; $id );
           my $relationships = $response-&gt;{data}{relationships}{$rel_type};
           say join ", ", map $_-&gt;{id}, @$relationships;

           my $response = $client-&gt;retrieve_relationships(
               type     =&gt; $type,
               id       =&gt; $id,
               rel_type =&gt; $rel_type,
           );
           my $relationships = $response-&gt;{data};
           say join ", ", map $_-&gt;{id}, @$relationships;

       However, "retrieve_relationships" also allows you to page those relationships, which may be quite useful.

       Keep in mind that "retrieve_relationships" will return an arrayref for one-to-many relationships,  and  a
       hashref for one-to-ones.

   <b>retrieve_by_relationship</b>
           retrieve_by_relationship( type =&gt; $type, id =&gt; $id, rel_type =&gt; $rel_type, %optional_arguments )

       "retrieve_relationships"  on  steroids.   It  behaves the same way, but will retrieve full resources, not
       just resource identifiers; because of this, you can also  potentially  apply  more  complex  filters  and
       sorts.

   <b>create</b>
           create( type =&gt; $type, data =&gt; { ... }, id =&gt; $optional )

       Create  a resource of type $type using $data to populate it.  Data <b>must</b> include the type, and may include
       two other keys: "attributes" and "relationships":

           $client-&gt;create(
               type =&gt; 'comments',
               data =&gt; {
                   type          =&gt; 'comments',
                   attributes    =&gt; { body =&gt; 'abc' },
                   relationships =&gt; {
                       author   =&gt; { type =&gt; 'people', id =&gt; 55 },
                       liked_by =&gt; [
                           { type =&gt; 'people', id =&gt; 55  },
                           { type =&gt; 'people', id =&gt; 577 },
                       ],
                   }
               }
           }

       An optional "id" may be provided, in which case the server may choose to use it  when  creating  the  new
       resource.

   <b>update</b>
           update( type =&gt; $type, id =&gt; $id, data =&gt; { ... } )

       Can be used to update the resource.  Data <b>must</b> have "type" and "id" keys:

           $client-&gt;create(
               type =&gt; 'comments',
               id   =&gt; 5,
               data =&gt; {
                   type          =&gt; 'comments',
                   id            =&gt; 5,
                   attributes    =&gt; { body =&gt; 'new body!' },
                   relationships =&gt; {
                       author   =&gt; undef, # no author
                       liked_by =&gt; [
                           { type =&gt; 'people', id =&gt; 79 },
                       ],
                   }
               }
           }

       An  empty arrayref ("[]") can be used to clear one-to-many relationships, and "undef" to clear one-to-one
       relationships.

       A successful "update" will always return a response document; see the spec for more details.

       Spec &lt;<a href="http://jsonapi.org/format/">http://jsonapi.org/format/</a>#crud-updating&gt;.

   <b>delete</b>
           delete( type =&gt; $type, id =&gt; $id )

       Deletes the resource.

   <b>update_relationships</b>
          update_relationships( type =&gt; $type, id =&gt; $id, rel_type =&gt; $rel_type, data =&gt; $data )

       Update a resource's relationships.  Basically a shortcut to using "update".

       For one-to-one relationships, "data"  can  be  either  a  single  hashref,  or  undef.   For  one-to-many
       relationships, "data" can be an arrayref; an empty arrayref means 'clear the relationship'.

   <b>create_relationships</b>
          create_relationships( type =&gt; $type, id =&gt; $id, rel_type =&gt; $rel_type, data =&gt; [{ ... }] )

       Adds to the specified one-to-many relationship.

   <b>delete_relationships</b>
          delete_relationships( type =&gt; $type, id =&gt; $id, rel_type =&gt; $rel_type, data =&gt; [{ ... }] )

       Deletes from the specified one-to-many relationship.

</pre><h4><b>Endpoint</b> <b>URI</b> <b>format</b></h4><pre>
       By default, "PONAPI::Client" assumes urls on the endpoint are in this format:

           retrieve_all:               /$type
           retrieve:                   /$type/$id
           retrieve_by_relationships:  /$type/$id/$rel_type
           retrieve_relationships:     /$type/$id/relationships/$rel_type

           create:                     /$type or /$type/$id
           delete:                     /$type/$id
           update:                     /$type/$id

           update_relationships:       /$type/$id/relationships/$rel_type
           create_relationships:       /$type/$id/relationships/$rel_type
           delete_relationships:       /$type/$id/relationships/$rel_type

           # Will generate a request to /foo/99
           $client-&gt;retrieve(
               type =&gt; 'foo',
               id   =&gt; 99,
           );

       However, if another format is needed, two approaches are possible:

   <b>URI</b> <b>paths</b> <b>have</b> <b>a</b> <b>common</b> <b>prefix</b>
       If all the endpoint urls have a common prefix, ala "/v1/articles" instead of simply "/articles", then you
       can just set "uri_base" as needed:

           $client-&gt;retrieve(
               type     =&gt; 'foo',
               id       =&gt; 99,
               uri_base =&gt; '/v1'
           );

       We  can also set this when creating the client; if done this way, all requests generated from this client
       will include the base:

           my $new_client = PONAPI::Client-&gt;new(
               uri_base =&gt; '/v1',
               ...
           );

           # This will generate a request to /v1/foo/99
           $new_client-&gt;retrieve(
               type =&gt; 'foo',
               id   =&gt; 99,
           );

   <b>Completely</b> <b>different</b> <b>uris</b>
       If the endpoint's expected formats are  wildly  different,  you  can  specify  "uri_template"  with  your
       request:

           # Will generate a request to id_here_99_and_type_there/foo
           $client-&gt;retrieve(
               type =&gt; 'foo',
               id   =&gt; 99,
               uri_template =&gt; 'id_here_{id}_and_type_there/{type}'
           );

       These placeholders are recognized:

       •   type

       •   id

       •   rel_type

       This can only be done on a per-request basis.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Mickey Nasriachi &lt;<a href="mailto:mickey@cpan.org">mickey@cpan.org</a>&gt;

       •   Stevan Little &lt;<a href="mailto:stevan@cpan.org">stevan@cpan.org</a>&gt;

       •   Brian Fraser &lt;<a href="mailto:hugmeir@cpan.org">hugmeir@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2019 by Mickey Nasriachi, Stevan Little, Brian Fraser.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2022-12-07                                <u>PONAPI::<a href="../man3pm/Client.3pm.html">Client</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>