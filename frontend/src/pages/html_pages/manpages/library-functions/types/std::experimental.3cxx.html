<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::experimental - Namespace for features defined in ISO Technical Specifications.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::experimental - Namespace for features defined in ISO Technical Specifications.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Classes</b>
       class <b>any</b>
           A type-safe container of any type.
       class <b>bad_any_cast</b>
           Exception class thrown by a failed any_cast.
       class <b>bad_optional_access</b>
           Exception class thrown when a disengaged optional object is dereferenced.
       class <b>basic_string_view</b>
           A non-owning reference to a string.
       struct <b>in_place_t</b>
           Tag type for in-place construction.
       struct <b>nullopt_t</b>
           Tag type to disengage optional objects.
       class <b>optional</b>
           Class template for optional values.
       class <b>ostream_joiner</b>
           Output iterator that inserts a delimiter between elements.
       struct <b>owner_less&lt;</b> <b>shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;</b> <b>&gt;</b>
           Partial specialization of owner_less for shared_ptr.
       struct <b>owner_less&lt;</b> <b>weak_ptr&lt;</b> <b>_Tp</b> <b>&gt;</b> <b>&gt;</b>
           Partial specialization of owner_less for weak_ptr.
       class <b>propagate_const</b>
           Const-propagating wrapper.

   <b>Typedefs</b>
       template&lt;<b>typename</b> _RAIter , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_Pred</b> , <b>typename</b> _Val  = typename
           iterator_traits&lt;_RAIter&gt;::value_type, <b>typename</b> _Diff  = typename
           iterator_traits&lt;_RAIter&gt;::difference_type&gt; <b>using</b> <b>__boyer_moore_base_t</b> = std::__conditional_t&lt;
           std::__is_byte_like&lt; _Val, <b>_Pred</b> &gt;::value, __boyer_moore_array_base&lt; _Diff, 256, <b>_Pred</b> &gt;,
           __boyer_moore_map_base&lt; _Val, _Diff, <b>_Hash</b>, <b>_Pred</b> &gt; &gt;
       template&lt;<b>typename</b> _Tp &gt; <b>using</b> <b>__propagate_const_elem_type</b> = <b>remove_reference_t</b>&lt; <b>decltype</b>(*<b>std::declval</b>&lt;
           _Tp &amp; &gt;())&gt;
       <b>using</b> <b>erased_type</b> = <b>std::__erased_type</b>
       <b>using</b> <b>string_view</b> = <b>basic_string_view</b>&lt; char &gt;
       <b>using</b> <b>u16string_view</b> = <b>basic_string_view</b>&lt; <b>char16_t</b> &gt;
       <b>using</b> <b>u32string_view</b> = <b>basic_string_view</b>&lt; <b>char32_t</b> &gt;
       <b>using</b> <b>wstring_view</b> = <b>basic_string_view</b>&lt; wchar_t &gt;

   <b>Functions</b>
       template&lt;<b>typename</b> _Fn , <b>typename</b> _Tuple , std::size_t... _Idx&gt; constexpr <b>decltype</b>(<b>auto</b>) <b>__apply_impl</b> (_Fn
           &amp;&amp;__f, _Tuple &amp;&amp;__t, <b>std::index_sequence</b>&lt; _Idx... &gt;)
       template&lt;<b>typename</b> _Tp , size_t _Nm, size_t... _Idx&gt; constexpr <b>array</b>&lt; <b>remove_cv_t</b>&lt; _Tp &gt;, <b>_Nm</b> &gt; <b>__to_array</b>
           (_Tp(&amp;__a)[<b>_Nm</b>], <b>index_sequence</b>&lt; _Idx... &gt;)
       <b>std::default_random_engine</b> &amp; <b>_S_randint_engine</b> ()
       template&lt;<b>typename</b> _ValueType &gt; _ValueType <b>any_cast</b> (const <b>any</b> &amp;<b>__any</b>)
           Access the contained object.
       template&lt;<b>typename</b> _Fn , <b>typename</b> _Tuple &gt; constexpr <b>decltype</b>(<b>auto</b>) <b>apply</b> (_Fn &amp;&amp;__f, _Tuple &amp;&amp;__t)
       template&lt;<b>typename</b> _Tp &gt; bool <b>atomic_compare_exchange_strong</b> (shared_ptr&lt; _Tp &gt; *__p, shared_ptr&lt; _Tp &gt;
           *<b>__v</b>, shared_ptr&lt; _Tp &gt; <b>__w</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>atomic_compare_exchange_strong_explicit</b> (shared_ptr&lt; _Tp &gt; *__p, shared_ptr&lt;
           _Tp &gt; *<b>__v</b>, shared_ptr&lt; _Tp &gt; <b>__w</b>, <b>memory_order</b> <b>__success</b>, <b>memory_order</b> <b>__failure</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>atomic_compare_exchange_weak</b> (shared_ptr&lt; _Tp &gt; *__p, shared_ptr&lt; _Tp &gt;
           *<b>__v</b>, shared_ptr&lt; _Tp &gt; <b>__w</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>atomic_compare_exchange_weak_explicit</b> (shared_ptr&lt; _Tp &gt; *__p, shared_ptr&lt;
           _Tp &gt; *<b>__v</b>, shared_ptr&lt; _Tp &gt; <b>__w</b>, <b>memory_order</b> <b>__success</b>, <b>memory_order</b> <b>__failure</b>)
       template&lt;<b>typename</b> _Tp &gt; <b>void</b> <b>atomic_exchange</b> (shared_ptr&lt; _Tp &gt; *__p, shared_ptr&lt; _Tp &gt; __r)
       template&lt;<b>typename</b> _Tp &gt; shared_ptr&lt; _Tp &gt; <b>atomic_exchange_explicit</b> (const shared_ptr&lt; _Tp &gt; *__p,
           shared_ptr&lt; _Tp &gt; __r, <b>memory_order</b> <b>__mo</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>atomic_is_lock_free</b> (const shared_ptr&lt; _Tp &gt; *__p)
       template&lt;<b>typename</b> _Tp &gt; shared_ptr&lt; _Tp &gt; <b>atomic_load</b> (const shared_ptr&lt; _Tp &gt; *__p)
       template&lt;<b>typename</b> _Tp &gt; shared_ptr&lt; _Tp &gt; <b>atomic_load_explicit</b> (const shared_ptr&lt; _Tp &gt; *__p,
           <b>memory_order</b> <b>__mo</b>)
       template&lt;<b>typename</b> _Tp &gt; <b>void</b> <b>atomic_store</b> (shared_ptr&lt; _Tp &gt; *__p, shared_ptr&lt; _Tp &gt; __r)
       template&lt;<b>typename</b> _Tp &gt; shared_ptr&lt; _Tp &gt; <b>atomic_store_explicit</b> (const shared_ptr&lt; _Tp &gt; *__p,
           shared_ptr&lt; _Tp &gt; __r, <b>memory_order</b> <b>__mo</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Tp1</b> &gt; shared_ptr&lt; _Tp &gt; <b>const_pointer_cast</b> (const shared_ptr&lt; <b>_Tp1</b> &gt;
           &amp;__r) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Tp1</b> &gt; shared_ptr&lt; _Tp &gt; <b>dynamic_pointer_cast</b> (const shared_ptr&lt; <b>_Tp1</b> &gt;
           &amp;__r) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits , <b>typename</b> _Alloc , <b>typename</b> _Up &gt; <b>void</b> <b>erase</b> (<b>basic_string</b>&lt;
           _CharT, _Traits, _Alloc &gt; &amp;<b>__cont</b>, const _Up &amp;__value)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc , <b>typename</b> _Up &gt; <b>void</b> <b>erase</b> (<b>deque</b>&lt; _Tp, _Alloc &gt; &amp;<b>__cont</b>, const
           _Up &amp;__value)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc , <b>typename</b> _Up &gt; <b>void</b> <b>erase</b> (<b>forward_list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__cont</b>,
           const _Up &amp;__value)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc , <b>typename</b> _Up &gt; <b>void</b> <b>erase</b> (<b>list</b>&lt; _Tp, _Alloc &gt; &amp;<b>__cont</b>, const
           _Up &amp;__value)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc , <b>typename</b> _Up &gt; <b>void</b> <b>erase</b> (<b>vector</b>&lt; _Tp, _Alloc &gt; &amp;<b>__cont</b>, const
           _Up &amp;__value)
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits , <b>typename</b> _Alloc , <b>typename</b> _Predicate &gt; <b>void</b> <b>erase_if</b>
           (<b>basic_string</b>&lt; _CharT, _Traits, _Alloc &gt; &amp;<b>__cont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc , <b>typename</b> _Predicate &gt; <b>void</b> <b>erase_if</b> (<b>deque</b>&lt; _Tp, _Alloc &gt;
           &amp;<b>__cont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc , <b>typename</b> _Predicate &gt; <b>void</b> <b>erase_if</b> (<b>forward_list</b>&lt; _Tp, _Alloc
           &gt; &amp;<b>__cont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc , <b>typename</b> _Predicate &gt; <b>void</b> <b>erase_if</b> (<b>list</b>&lt; _Tp, _Alloc &gt;
           &amp;<b>__cont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> _Alloc , <b>typename</b> _Predicate &gt; <b>void</b>
           <b>erase_if</b> (<b>map</b>&lt; <b>_Key</b>, _Tp, _Compare, _Alloc &gt; &amp;<b>__cont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> _Compare , <b>typename</b> _Alloc , <b>typename</b> _Predicate &gt; <b>void</b>
           <b>erase_if</b> (<b>multimap</b>&lt; <b>_Key</b>, _Tp, _Compare, _Alloc &gt; &amp;<b>__cont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> _Alloc , <b>typename</b> _Predicate &gt; <b>void</b> <b>erase_if</b>
           (<b>multiset</b>&lt; <b>_Key</b>, _Compare, _Alloc &gt; &amp;<b>__cont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Compare , <b>typename</b> _Alloc , <b>typename</b> _Predicate &gt; <b>void</b> <b>erase_if</b> (<b>set</b>&lt;
           <b>_Key</b>, _Compare, _Alloc &gt; &amp;<b>__cont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_CPred</b> , <b>typename</b> _Alloc , <b>typename</b>
           _Predicate &gt; <b>void</b> <b>erase_if</b> (<b>unordered_map</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>_CPred</b>, _Alloc &gt; &amp;<b>__cont</b>, _Predicate
           <b>__pred</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> _Tp , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_CPred</b> , <b>typename</b> _Alloc , <b>typename</b>
           _Predicate &gt; <b>void</b> <b>erase_if</b> (<b>unordered_multimap</b>&lt; <b>_Key</b>, _Tp, <b>_Hash</b>, <b>_CPred</b>, _Alloc &gt; &amp;<b>__cont</b>,
           _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_CPred</b> , <b>typename</b> _Alloc , <b>typename</b> _Predicate &gt; <b>void</b>
           <b>erase_if</b> (<b>unordered_multiset</b>&lt; <b>_Key</b>, <b>_Hash</b>, <b>_CPred</b>, _Alloc &gt; &amp;<b>__cont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> <b>_Key</b> , <b>typename</b> <b>_Hash</b> , <b>typename</b> <b>_CPred</b> , <b>typename</b> _Alloc , <b>typename</b> _Predicate &gt; <b>void</b>
           <b>erase_if</b> (<b>unordered_set</b>&lt; <b>_Key</b>, <b>_Hash</b>, <b>_CPred</b>, _Alloc &gt; &amp;<b>__cont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc , <b>typename</b> _Predicate &gt; <b>void</b> <b>erase_if</b> (<b>vector</b>&lt; _Tp, _Alloc &gt;
           &amp;<b>__cont</b>, _Predicate <b>__pred</b>)
       template&lt;<b>typename</b> <b>_Mn</b> , <b>typename</b> <b>_Nn</b> &gt; constexpr <b>common_type_t</b>&lt; <b>_Mn</b>, <b>_Nn</b> &gt; <b>gcd</b> (<b>_Mn</b> <b>__m</b>, <b>_Nn</b> __n)
           noexcept
           Greatest common divisor.
       template&lt;<b>typename</b> <b>_Del</b> , <b>typename</b> _Tp &gt; <b>_Del</b> * <b>get_deleter</b> (const shared_ptr&lt; _Tp &gt; &amp;__p) noexcept
           C++14 20.8.2.2.10.
       template&lt;<b>typename</b> _Tp &gt; constexpr const _Tp &amp; <b>get_underlying</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>)
           noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr _Tp &amp; <b>get_underlying</b> (<b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>) noexcept
       template&lt;<b>typename</b> <b>_Mn</b> , <b>typename</b> <b>_Nn</b> &gt; constexpr <b>common_type_t</b>&lt; <b>_Mn</b>, <b>_Nn</b> &gt; <b>lcm</b> (<b>_Mn</b> <b>__m</b>, <b>_Nn</b> __n)
           Least common multiple.
       template&lt;<b>typename</b> <b>_Dest</b>  = void, typename... _Types&gt; constexpr <b>array</b>&lt; <b>typename</b> __make_array_elem&lt; <b>_Dest</b>,
           _Types... &gt;::type, sizeof...(<b>_Types</b>)&gt; <b>make_array</b> (<b>_Types</b> &amp;&amp;... __t)
           Create a std::array from a variable-length list of arguments.
       template&lt;<b>typename</b> _RAIter , <b>typename</b> <b>_Hash</b>  = std::hash&lt;typename
           std::iterator_traits&lt;_RAIter&gt;::value_type&gt;, <b>typename</b> <b>_BinaryPredicate</b>  = equal_to&lt;&gt;&gt;
           boyer_moore_horspool_searcher&lt; _RAIter, <b>_Hash</b>, <b>_BinaryPredicate</b> &gt; <b>make_boyer_moore_horspool_searcher</b>
           (_RAIter <b>__pat_first</b>, _RAIter <b>__pat_last</b>, <b>_Hash</b> <b>__hf</b>=<b>_Hash</b>(), <b>_BinaryPredicate</b>
           <b>__pred</b>=<b>_BinaryPredicate</b>())
           Generator function for boyer_moore_horspool_searcher.
       template&lt;<b>typename</b> _RAIter , <b>typename</b> <b>_Hash</b>  = std::hash&lt;typename
           std::iterator_traits&lt;_RAIter&gt;::value_type&gt;, <b>typename</b> <b>_BinaryPredicate</b>  = equal_to&lt;&gt;&gt;
           boyer_moore_searcher&lt; _RAIter, <b>_Hash</b>, <b>_BinaryPredicate</b> &gt; <b>make_boyer_moore_searcher</b> (_RAIter
           <b>__pat_first</b>, _RAIter <b>__pat_last</b>, <b>_Hash</b> <b>__hf</b>=<b>_Hash</b>(), <b>_BinaryPredicate</b> <b>__pred</b>=<b>_BinaryPredicate</b>())
           Generator function for boyer_moore_searcher.
       template&lt;<b>typename</b> <b>_ForwardIterator</b> , <b>typename</b> <b>_BinaryPredicate</b>  = std::equal_to&lt;&gt;&gt; default_searcher&lt;
           <b>_ForwardIterator</b>, <b>_BinaryPredicate</b> &gt; <b>make_default_searcher</b> (<b>_ForwardIterator</b> <b>__pat_first</b>,
           <b>_ForwardIterator</b> <b>__pat_last</b>, <b>_BinaryPredicate</b> <b>__pred</b>=<b>_BinaryPredicate</b>())
           Generator function for default_searcher.
       template&lt;<b>typename</b> _Tp &gt; observer_ptr&lt; _Tp &gt; <b>make_observer</b> (_Tp *__p) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits , <b>typename</b> _DelimT &gt; <b>ostream_joiner</b>&lt; <b>decay_t</b>&lt; _DelimT &gt;,
           _CharT, _Traits &gt; <b>make_ostream_joiner</b> (<b>basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;<b>__os</b>, _DelimT &amp;&amp;<b>__delimiter</b>)
           Object generator for ostream_joiner.
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator!=</b> (<b>__type_identity_t</b>&lt;
           <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator!=</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>__type_identity_t</b>&lt; <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator!=</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator!=</b> (const _Tp &amp;__t, const <b>propagate_const</b>&lt;
           _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator!=</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const _Up &amp;<b>__u</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator!=</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const <b>propagate_const</b>&lt; _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>operator!=</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>, <b>nullptr_t</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator!=</b> (const shared_ptr&lt; _Tp &gt; &amp;__a, <b>nullptr_t</b>) noexcept
       template&lt;<b>typename</b> <b>_Tp1</b> , <b>typename</b> _Tp2 &gt; bool <b>operator!=</b> (const shared_ptr&lt; <b>_Tp1</b> &gt; &amp;__a, const
           shared_ptr&lt; _Tp2 &gt; &amp;__b) noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>operator!=</b> (<b>nullptr_t</b>, const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator!=</b> (<b>nullptr_t</b>, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator!=</b> (<b>nullptr_t</b>, observer_ptr&lt; _Tp &gt; __p) noexcept
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator!=</b> (observer_ptr&lt; _Tp &gt; __p, <b>nullptr_t</b>) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator!=</b> (observer_ptr&lt; _Tp &gt; <b>__p1</b>, observer_ptr&lt; _Up &gt;
           <b>__p2</b>)
       constexpr <b>basic_string_view</b>&lt; char &gt; <b>operator''sv</b> (const char *<b>__str</b>, size_t <b>__len</b>) noexcept
       constexpr <b>basic_string_view</b>&lt; <b>char16_t</b> &gt; <b>operator''sv</b> (const <b>char16_t</b> *<b>__str</b>, size_t <b>__len</b>) noexcept
       constexpr <b>basic_string_view</b>&lt; <b>char32_t</b> &gt; <b>operator''sv</b> (const <b>char32_t</b> *<b>__str</b>, size_t <b>__len</b>) noexcept
       constexpr <b>basic_string_view</b>&lt; wchar_t &gt; <b>operator''sv</b> (const wchar_t *<b>__str</b>, size_t <b>__len</b>) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&lt;</b> (<b>__type_identity_t</b>&lt;
           <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&lt;</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>__type_identity_t</b>&lt; <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&lt;</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&lt;</b> (const _Tp &amp;__t, const <b>propagate_const</b>&lt;
           _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&lt;</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const _Up &amp;<b>__u</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&lt;</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const <b>propagate_const</b>&lt; _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator&lt;</b> (const shared_ptr&lt; _Tp &gt; &amp;__a, <b>nullptr_t</b>) noexcept
       template&lt;<b>typename</b> <b>_Tp1</b> , <b>typename</b> _Tp2 &gt; bool <b>operator&lt;</b> (const shared_ptr&lt; <b>_Tp1</b> &gt; &amp;__a, const shared_ptr&lt;
           _Tp2 &gt; &amp;__b) noexcept
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator&lt;</b> (<b>nullptr_t</b>, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator&lt;</b> (observer_ptr&lt; _Tp &gt; <b>__p1</b>, observer_ptr&lt; _Up &gt;
           <b>__p2</b>)
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; <b>basic_ostream</b>&lt; _CharT, _Traits &gt; &amp; <b>operator&lt;&lt;</b>
           (<b>basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;<b>__os</b>, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; <b>__str</b>)
       template&lt;<b>typename</b> <b>_Ch</b> , <b>typename</b> <b>_Tr</b> , <b>typename</b> _Tp &gt; <b>std::basic_ostream</b>&lt; <b>_Ch</b>, <b>_Tr</b> &gt; &amp; <b>operator&lt;&lt;</b>
           (<b>std::basic_ostream</b>&lt; <b>_Ch</b>, <b>_Tr</b> &gt; &amp;<b>__os</b>, const shared_ptr&lt; _Tp &gt; &amp;__p)
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&lt;=</b> (<b>__type_identity_t</b>&lt;
           <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&lt;=</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>__type_identity_t</b>&lt; <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&lt;=</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&lt;=</b> (const _Tp &amp;__t, const <b>propagate_const</b>&lt;
           _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&lt;=</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const _Up &amp;<b>__u</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&lt;=</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const <b>propagate_const</b>&lt; _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator&lt;=</b> (const shared_ptr&lt; _Tp &gt; &amp;__a, <b>nullptr_t</b>) noexcept
       template&lt;<b>typename</b> <b>_Tp1</b> , <b>typename</b> _Tp2 &gt; bool <b>operator&lt;=</b> (const shared_ptr&lt; <b>_Tp1</b> &gt; &amp;__a, const
           shared_ptr&lt; _Tp2 &gt; &amp;__b) noexcept
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator&lt;=</b> (<b>nullptr_t</b>, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator&lt;=</b> (observer_ptr&lt; _Tp &gt; <b>__p1</b>, observer_ptr&lt; _Up &gt;
           <b>__p2</b>)
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator==</b> (<b>__type_identity_t</b>&lt;
           <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator==</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>__type_identity_t</b>&lt; <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator==</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator==</b> (const _Tp &amp;__t, const <b>propagate_const</b>&lt;
           _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator==</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const _Up &amp;<b>__u</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator==</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const <b>propagate_const</b>&lt; _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>operator==</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>, <b>nullptr_t</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator==</b> (const shared_ptr&lt; _Tp &gt; &amp;__a, <b>nullptr_t</b>) noexcept
       template&lt;<b>typename</b> <b>_Tp1</b> , <b>typename</b> _Tp2 &gt; bool <b>operator==</b> (const shared_ptr&lt; <b>_Tp1</b> &gt; &amp;__a, const
           shared_ptr&lt; _Tp2 &gt; &amp;__b) noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>operator==</b> (<b>nullptr_t</b>, const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator==</b> (<b>nullptr_t</b>, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator==</b> (<b>nullptr_t</b>, observer_ptr&lt; _Tp &gt; __p) noexcept
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator==</b> (observer_ptr&lt; _Tp &gt; __p, <b>nullptr_t</b>) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator==</b> (observer_ptr&lt; _Tp &gt; <b>__p1</b>, observer_ptr&lt; _Up &gt;
           <b>__p2</b>)
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&gt;</b> (<b>__type_identity_t</b>&lt;
           <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&gt;</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>__type_identity_t</b>&lt; <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&gt;</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&gt;</b> (const _Tp &amp;__t, const <b>propagate_const</b>&lt;
           _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&gt;</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const _Up &amp;<b>__u</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&gt;</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const <b>propagate_const</b>&lt; _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator&gt;</b> (const shared_ptr&lt; _Tp &gt; &amp;__a, <b>nullptr_t</b>) noexcept
       template&lt;<b>typename</b> <b>_Tp1</b> , <b>typename</b> _Tp2 &gt; bool <b>operator&gt;</b> (const shared_ptr&lt; <b>_Tp1</b> &gt; &amp;__a, const shared_ptr&lt;
           _Tp2 &gt; &amp;__b) noexcept
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator&gt;</b> (<b>nullptr_t</b>, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator&gt;</b> (observer_ptr&lt; _Tp &gt; <b>__p1</b>, observer_ptr&lt; _Up &gt;
           <b>__p2</b>)
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&gt;=</b> (<b>__type_identity_t</b>&lt;
           <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&gt;=</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>__type_identity_t</b>&lt; <b>basic_string_view</b>&lt; _CharT, _Traits &gt; &gt; __y) noexcept
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits &gt; constexpr bool <b>operator&gt;=</b> (<b>basic_string_view</b>&lt; _CharT,
           _Traits &gt; __x, <b>basic_string_view</b>&lt; _CharT, _Traits &gt; __y) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&gt;=</b> (const _Tp &amp;__t, const <b>propagate_const</b>&lt;
           _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&gt;=</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const _Up &amp;<b>__u</b>)
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>operator&gt;=</b> (const <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>,
           const <b>propagate_const</b>&lt; _Up &gt; &amp;<b>__pu</b>)
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator&gt;=</b> (const shared_ptr&lt; _Tp &gt; &amp;__a, <b>nullptr_t</b>) noexcept
       template&lt;<b>typename</b> <b>_Tp1</b> , <b>typename</b> _Tp2 &gt; bool <b>operator&gt;=</b> (const shared_ptr&lt; <b>_Tp1</b> &gt; &amp;__a, const
           shared_ptr&lt; _Tp2 &gt; &amp;__b) noexcept
       template&lt;<b>typename</b> _Tp &gt; bool <b>operator&gt;=</b> (<b>nullptr_t</b>, const shared_ptr&lt; _Tp &gt; &amp;__a) noexcept
       template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator&gt;=</b> (observer_ptr&lt; _Tp &gt; <b>__p1</b>, observer_ptr&lt; _Up &gt;
           <b>__p2</b>)
       template&lt;<b>typename</b> _IntType &gt; _IntType <b>randint</b> (_IntType __a, _IntType __b)
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Tp1</b> &gt; shared_ptr&lt; _Tp &gt; <b>reinterpret_pointer_cast</b> (const shared_ptr&lt;
           <b>_Tp1</b> &gt; &amp;__r) noexcept
       <b>void</b> <b>reseed</b> ()
       <b>void</b> <b>reseed</b> (default_random_engine::result_type __value)
       template&lt;<b>typename</b> <b>_PopulationIterator</b> , <b>typename</b> <b>_SampleIterator</b> , <b>typename</b> <b>_Distance</b> &gt; <b>_SampleIterator</b>
           <b>sample</b> (<b>_PopulationIterator</b> __first, <b>_PopulationIterator</b> __last, <b>_SampleIterator</b> <b>__out</b>, <b>_Distance</b>
           __n)
       template&lt;<b>typename</b> <b>_PopulationIterator</b> , <b>typename</b> <b>_SampleIterator</b> , <b>typename</b> <b>_Distance</b> , <b>typename</b>
           <b>_UniformRandomNumberGenerator</b> &gt; <b>_SampleIterator</b> <b>sample</b> (<b>_PopulationIterator</b> __first,
           <b>_PopulationIterator</b> __last, <b>_SampleIterator</b> <b>__out</b>, <b>_Distance</b> __n, <b>_UniformRandomNumberGenerator</b>
           &amp;&amp;<b>__g</b>)
           Take a random sample from a population.
       template&lt;<b>typename</b> <b>_ForwardIterator</b> , <b>typename</b> <b>_Searcher</b> &gt; <b>_ForwardIterator</b> <b>search</b> (<b>_ForwardIterator</b>
           __first, <b>_ForwardIterator</b> __last, const <b>_Searcher</b> &amp;<b>__searcher</b>)
       template&lt;<b>typename</b> <b>_RandomAccessIterator</b> &gt; <b>void</b> <b>shuffle</b> (<b>_RandomAccessIterator</b> __first,
           <b>_RandomAccessIterator</b> __last)
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Tp1</b> &gt; shared_ptr&lt; _Tp &gt; <b>static_pointer_cast</b> (const shared_ptr&lt; <b>_Tp1</b> &gt;
           &amp;__r) noexcept
       <b>void</b> <b>swap</b> (<b>any</b> &amp;__x, <b>any</b> &amp;__y) noexcept
           Exchange the states of two any objects.
       template&lt;<b>typename</b> _Tp &gt; <b>void</b> <b>swap</b> (observer_ptr&lt; _Tp &gt; &amp;<b>__p1</b>, observer_ptr&lt; _Tp &gt; &amp;<b>__p2</b>) noexcept
       template&lt;<b>typename</b> _Tp &gt; constexpr <b>enable_if_t</b>&lt; <b>__is_swappable</b>&lt; _Tp &gt;::value, <b>void</b> &gt; <b>swap</b>
           (<b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt</b>, <b>propagate_const</b>&lt; _Tp &gt; &amp;<b>__pt2</b>) noexcept(<b>__is_nothrow_swappable</b>&lt; _Tp
           &gt;::value)
       template&lt;<b>typename</b> _Tp &gt; <b>void</b> <b>swap</b> (shared_ptr&lt; _Tp &gt; &amp;__a, shared_ptr&lt; _Tp &gt; &amp;__b) noexcept
       template&lt;<b>typename</b> _Tp &gt; <b>void</b> <b>swap</b> (weak_ptr&lt; _Tp &gt; &amp;__a, weak_ptr&lt; _Tp &gt; &amp;__b) noexcept
       template&lt;<b>typename</b> _Tp , size_t _Nm&gt; constexpr <b>array</b>&lt; <b>remove_cv_t</b>&lt; _Tp &gt;, <b>_Nm</b> &gt; <b>to_array</b> (_Tp(&amp;__a)[<b>_Nm</b>])
           noexcept(<b>is_nothrow_constructible</b>&lt; <b>remove_cv_t</b>&lt; _Tp &gt;, _Tp &amp; &gt;::value)
           Create a std::array from an array.

           template&lt;<b>typename</b> _ValueType &gt; _ValueType <b>any_cast</b> (<b>any</b> &amp;<b>__any</b>)
               Access the contained object.
           template&lt;<b>typename</b> _ValueType , <b>typename</b> <b>enable_if</b>&lt;!<b>is_move_constructible</b>&lt; _ValueType
               &gt;::value||<b>is_lvalue_reference</b>&lt; _ValueType &gt;::value, bool &gt;::type  = true&gt; _ValueType <b>any_cast</b>
               (<b>any</b> &amp;&amp;<b>__any</b>)
               Access the contained object.
           template&lt;<b>typename</b> _ValueType , <b>typename</b> <b>enable_if</b>&lt; <b>is_move_constructible</b>&lt; _ValueType &gt;::value
               &amp;&amp;!<b>is_lvalue_reference</b>&lt; _ValueType &gt;::value, bool &gt;::type  = false&gt; _ValueType <b>any_cast</b> (<b>any</b>
               &amp;&amp;<b>__any</b>)
               Access the contained object.

           template&lt;<b>typename</b> _ValueType &gt; const _ValueType * <b>any_cast</b> (const <b>any</b> *<b>__any</b>) noexcept
               Access the contained object.
           template&lt;<b>typename</b> _ValueType &gt; _ValueType * <b>any_cast</b> (<b>any</b> *<b>__any</b>) noexcept
               Access the contained object.

   <b>Variables</b>
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> _Tp &gt; constexpr bool <b>__sp_compatible_v</b>
       template&lt;<b>typename</b> _Tp , <b>typename</b> <b>_Yp</b> &gt; constexpr bool <b>__sp_is_constructible_v</b>
       constexpr <b>in_place_t</b> <b>in_place</b>
           Tag for in-place construction.
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_bind_expression_v</b>
           Variable template for std::is_bind_expression.
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_error_code_enum_v</b>
       template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_error_condition_enum_v</b>
       template&lt;<b>typename</b> _Tp &gt; constexpr int <b>is_placeholder_v</b>
           Variable template for std::is_placeholder.
       constexpr <b>nullopt_t</b> <b>nullopt</b>
           Tag to disengage optional objects.
       template&lt;<b>typename</b> <b>_R1</b> , <b>typename</b> <b>_R2</b> &gt; constexpr bool <b>ratio_equal_v</b>
       template&lt;<b>typename</b> <b>_R1</b> , <b>typename</b> <b>_R2</b> &gt; constexpr bool <b>ratio_greater_equal_v</b>
       template&lt;<b>typename</b> <b>_R1</b> , <b>typename</b> <b>_R2</b> &gt; constexpr bool <b>ratio_greater_v</b>
       template&lt;<b>typename</b> <b>_R1</b> , <b>typename</b> <b>_R2</b> &gt; constexpr bool <b>ratio_less_equal_v</b>
       template&lt;<b>typename</b> <b>_R1</b> , <b>typename</b> <b>_R2</b> &gt; constexpr bool <b>ratio_less_v</b>
       template&lt;<b>typename</b> <b>_R1</b> , <b>typename</b> <b>_R2</b> &gt; constexpr bool <b>ratio_not_equal_v</b>
       template&lt;<b>typename</b> _Tp &gt; constexpr size_t <b>tuple_size_v</b>

           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_void_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_null_pointer_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_integral_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_floating_point_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_array_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_pointer_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_lvalue_reference_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_rvalue_reference_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_member_object_pointer_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_member_function_pointer_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_enum_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_union_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_class_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_function_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_reference_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_arithmetic_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_fundamental_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_object_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_scalar_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_compound_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_member_pointer_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_const_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_volatile_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_trivial_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_trivially_copyable_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_standard_layout_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_pod_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_literal_type_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_empty_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_polymorphic_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_abstract_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_final_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_signed_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_unsigned_v</b>
           template&lt;<b>typename</b> _Tp , typename... _Args&gt; constexpr bool <b>is_constructible_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_default_constructible_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_copy_constructible_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_move_constructible_v</b>
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>is_assignable_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_copy_assignable_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_move_assignable_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_destructible_v</b>
           template&lt;<b>typename</b> _Tp , typename... _Args&gt; constexpr bool <b>is_trivially_constructible_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_trivially_default_constructible_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_trivially_copy_constructible_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_trivially_move_constructible_v</b>
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>is_trivially_assignable_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_trivially_copy_assignable_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_trivially_move_assignable_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_trivially_destructible_v</b>
           template&lt;<b>typename</b> _Tp , typename... _Args&gt; constexpr bool <b>is_nothrow_constructible_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_nothrow_default_constructible_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_nothrow_copy_constructible_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_nothrow_move_constructible_v</b>
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>is_nothrow_assignable_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_nothrow_copy_assignable_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_nothrow_move_assignable_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_nothrow_destructible_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>has_virtual_destructor_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr size_t <b>alignment_of_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr size_t <b>rank_v</b>
           template&lt;<b>typename</b> _Tp , unsigned _Idx = 0&gt; constexpr size_t <b>extent_v</b>
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; constexpr bool <b>is_same_v</b>
           template&lt;<b>typename</b> _Tp &gt; constexpr bool <b>is_same_v&lt;</b> <b>_Tp,</b> <b>_Tp</b> <b>&gt;</b>
           template&lt;<b>typename</b> _Base , <b>typename</b> <b>_Derived</b> &gt; constexpr bool <b>is_base_of_v</b>
           template&lt;<b>typename</b> _From , <b>typename</b> <b>_To</b> &gt; constexpr bool <b>is_convertible_v</b>

           template&lt;typename... _Bn&gt; constexpr bool <b>conjunction_v</b>
           template&lt;typename... _Bn&gt; constexpr bool <b>disjunction_v</b>
           template&lt;<b>typename</b> <b>_Pp</b> &gt; constexpr bool <b>negation_v</b>
       template&lt;typename... &gt; <b>using</b> <b>void_t</b> = <b>void</b>
           A metafunction that always yields void, used for detecting valid types.
       template&lt;<b>typename</b> <b>_Default</b> , <b>template</b>&lt; typename... &gt; <b>class</b> _Op, typename... _Args&gt; <b>using</b> <b>detected_or</b> =
           <b>std::__detected_or</b>&lt; <b>_Default</b>, _Op, _Args... &gt;
           A metafunction that always yields void, used for detecting valid types.
       template&lt;<b>typename</b> <b>_Default</b> , <b>template</b>&lt; typename... &gt; <b>class</b> _Op, typename... _Args&gt; <b>using</b> <b>detected_or_t</b> =
           <b>typename</b> detected_or&lt; <b>_Default</b>, _Op, _Args... &gt;::type
           A metafunction that always yields void, used for detecting valid types.
       template&lt;<b>template</b>&lt; typename... &gt; <b>class</b> _Op, typename... _Args&gt; <b>using</b> <b>detected_t</b> = detected_or_t&lt;
           nonesuch, _Op, _Args... &gt;
           A metafunction that always yields void, used for detecting valid types.
       template&lt;<b>template</b>&lt; typename... &gt; <b>class</b> _Op, typename... _Args&gt; <b>using</b> <b>is_detected</b> = <b>typename</b> detected_or&lt;
           <b>void</b>, _Op, _Args... &gt;::__is_detected
           A metafunction that always yields void, used for detecting valid types.
       template&lt;<b>typename</b> <b>_Expected</b> , <b>template</b>&lt; typename... &gt; <b>class</b> _Op, typename... _Args&gt; <b>using</b>
           <b>is_detected_exact</b> = <b>is_same</b>&lt; <b>_Expected</b>, detected_t&lt; _Op, _Args... &gt; &gt;
           A metafunction that always yields void, used for detecting valid types.
       template&lt;<b>typename</b> <b>_To</b> , <b>template</b>&lt; typename... &gt; <b>class</b> _Op, typename... _Args&gt; <b>using</b>
           <b>is_detected_convertible</b> = is_convertible&lt; detected_t&lt; _Op, _Args... &gt;, <b>_To</b> &gt;
           A metafunction that always yields void, used for detecting valid types.
       template&lt;<b>template</b>&lt; typename... &gt; <b>class</b> _Op, typename... _Args&gt; constexpr bool <b>is_detected_v</b>
           A metafunction that always yields void, used for detecting valid types.
       template&lt;<b>typename</b> <b>_Expected</b> , <b>template</b>&lt; typename... &gt; <b>class</b> _Op, typename... _Args&gt; constexpr bool
           <b>is_detected_exact_v</b>
           A metafunction that always yields void, used for detecting valid types.
       template&lt;<b>typename</b> <b>_To</b> , <b>template</b>&lt; typename... &gt; <b>class</b> _Op, typename... _Args&gt; constexpr bool
           <b>is_detected_convertible_v</b>
           A metafunction that always yields void, used for detecting valid types.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Namespace for features defined in ISO Technical Specifications.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Mn</b> <b>,</b> <b>typename</b> <b>_Nn</b> <b>&gt;</b> <b>constexpr</b> <b>common_type_t&lt;</b> <b>_Mn,</b> <b>_Nn</b> <b>&gt;</b>
       <b>std::experimental::fundamentals_v2::gcd</b> <b>(_Mn</b> <b>__m,</b> <b>_Nn</b> <b>__n)</b> <b>[constexpr],</b>  <b>[noexcept]</b>
       Greatest common divisor.

   <b>template&lt;typename</b> <b>_Del</b> <b>,</b> <b>typename</b> <b>_Tp</b> <b>&gt;</b> <b>_Del</b> <b>*</b> <b>std::experimental::fundamentals_v2::get_deleter</b> <b>(const</b>
       <b>shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;</b> <b>&amp;</b> <b>__p)</b> <b>[inline],</b>  <b>[noexcept]</b>
       C++14 20.8.2.2.10.

   <b>template&lt;typename</b> <b>_Mn</b> <b>,</b> <b>typename</b> <b>_Nn</b> <b>&gt;</b> <b>constexpr</b> <b>common_type_t&lt;</b> <b>_Mn,</b> <b>_Nn</b> <b>&gt;</b>
       <b>std::experimental::fundamentals_v2::lcm</b> <b>(_Mn</b> <b>__m,</b> <b>_Nn</b> <b>__n)</b> <b>[constexpr]</b>
       Least common multiple.

   <b>template&lt;typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>std::hash&lt;typename</b> <b>std::iterator_traits&lt;_RAIter&gt;::value_type&gt;,</b>
       <b>typename</b> <b>_BinaryPredicate</b>  <b>=</b> <b>equal_to&lt;&gt;&gt;</b> <b>boyer_moore_horspool_searcher&lt;</b> <b>_RAIter,</b> <b>_Hash,</b> <b>_BinaryPredicate</b>
       <b>&gt;</b> <b>std::experimental::fundamentals_v1::make_boyer_moore_horspool_searcher</b> <b>(_RAIter</b> <b>__pat_first,</b> <b>_RAIter</b>
       <b>__pat_last,</b> <b>_Hash</b> <b>__hf</b> <b>=</b> <b>_Hash(),</b> <b>_BinaryPredicate</b> <b>__pred</b> <b>=</b> <b>_BinaryPredicate())</b> <b>[inline]</b>
       Generator function for boyer_moore_horspool_searcher.

   <b>template&lt;typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Hash</b>  <b>=</b> <b>std::hash&lt;typename</b> <b>std::iterator_traits&lt;_RAIter&gt;::value_type&gt;,</b>
       <b>typename</b> <b>_BinaryPredicate</b>  <b>=</b> <b>equal_to&lt;&gt;&gt;</b> <b>boyer_moore_searcher&lt;</b> <b>_RAIter,</b> <b>_Hash,</b> <b>_BinaryPredicate</b> <b>&gt;</b>
       <b>std::experimental::fundamentals_v1::make_boyer_moore_searcher</b> <b>(_RAIter</b> <b>__pat_first,</b> <b>_RAIter</b> <b>__pat_last,</b>
       <b>_Hash</b> <b>__hf</b> <b>=</b> <b>_Hash(),</b> <b>_BinaryPredicate</b> <b>__pred</b> <b>=</b> <b>_BinaryPredicate())</b> <b>[inline]</b>
       Generator function for boyer_moore_searcher.

   <b>template&lt;typename</b> <b>_ForwardIterator</b> <b>,</b> <b>typename</b> <b>_BinaryPredicate</b>  <b>=</b> <b>std::equal_to&lt;&gt;&gt;</b> <b>default_searcher&lt;</b>
       <b>_ForwardIterator,</b> <b>_BinaryPredicate</b> <b>&gt;</b> <b>std::experimental::fundamentals_v1::make_default_searcher</b>
       <b>(_ForwardIterator</b> <b>__pat_first,</b> <b>_ForwardIterator</b> <b>__pat_last,</b> <b>_BinaryPredicate</b> <b>__pred</b> <b>=</b> <b>_BinaryPredicate())</b>
       <b>[inline]</b>
       Generator function for default_searcher.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>,</b> <b>typename</b> <b>_DelimT</b> <b>&gt;</b> <b>ostream_joiner&lt;</b> <b>decay_t&lt;</b> <b>_DelimT</b> <b>&gt;,</b> <b>_CharT,</b>
       <b>_Traits</b> <b>&gt;</b> <b>std::experimental::fundamentals_v2::make_ostream_joiner</b> <b>(basic_ostream&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b> <b>&amp;</b>
       <b>__os,</b> <b>_DelimT</b> <b>&amp;&amp;</b> <b>__delimiter)</b> <b>[inline]</b>
       Object generator for ostream_joiner.

   <b>template&lt;typename</b> <b>_PopulationIterator</b> <b>,</b> <b>typename</b> <b>_SampleIterator</b> <b>,</b> <b>typename</b> <b>_Distance</b> <b>,</b> <b>typename</b>
       <b>_UniformRandomNumberGenerator</b> <b>&gt;</b> <b>_SampleIterator</b> <b>std::experimental::fundamentals_v2::sample</b>
       <b>(_PopulationIterator</b> <b>__first,</b> <b>_PopulationIterator</b> <b>__last,</b> <b>_SampleIterator</b> <b>__out,</b> <b>_Distance</b> <b>__n,</b>
       <b>_UniformRandomNumberGenerator</b> <b>&amp;&amp;</b> <b>__g)</b>
       Take a random sample from a population.

</pre><h4><b>Variable</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>constexpr</b> <b>bool</b> <b>std::experimental::fundamentals_v1::is_bind_expression_v</b> <b>[constexpr]</b>
       Variable template for std::is_bind_expression.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>constexpr</b> <b>int</b> <b>std::experimental::fundamentals_v1::is_placeholder_v</b> <b>[constexpr]</b>
       Variable template for std::is_placeholder.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                            <u>std::<a href="../man3cxx/experimental.3cxx.html">experimental</a></u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>