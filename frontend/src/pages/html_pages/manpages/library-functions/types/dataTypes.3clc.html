<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data_Types - OpenCL data types.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/opencl-1.2-man-doc">opencl-1.2-man-doc_1.0~svn33624-5.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data_Types - OpenCL data types.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These are the data types available in the OpenCL C programming language. Click on a category name in the
       table below to see information about specific data types.
       ┌─────────────────────────┬───────────────────────────────────────┐
       │ <b>Data</b> <b>type</b> <b>category</b>      │ <b>Included</b> <b>data</b> <b>types</b>                   │
       ├─────────────────────────┼───────────────────────────────────────┤
       │ <b><a href="../man3clc/scalarDataTypes.3clc.html">scalarDataTypes</a></b>(3clc)   │ <b>bool</b>, <b>char</b>, <b>cl_char</b>, <b>unsigned</b> <b>char</b>,   │
       │                         │ <b>uchar</b>, <b>cl_uchar</b>, <b>short</b>, <b>cl_short</b>,     │
       │                         │ <b>unsigned</b> <b>short</b>, <b>ushort</b>, <b>int</b>, <b>unsigned</b> │
       │                         │ <b>int</b>, <b>uint</b>, <b>long</b>, <b>unsigned</b> <b>long</b>,       │
       │                         │ <b>ulong</b>, <b>float</b>, <b>half</b>, <b>size_t</b>,           │
       │                         │ <b>ptrdiff_t</b>, <b>intptr_t</b>, <b>uintptr_t</b>, <b>void</b>, │
       │                         │ <b>double</b>, and <b>half</b> floating point       │
       │                         │ types.                                │
       ├─────────────────────────┼───────────────────────────────────────┤
       │ <b><a href="../man3clc/vectorDataTypes.3clc.html">vectorDataTypes</a></b>(3clc)   │ <b>char</b><u>n</u>, <b>uchar</b><u>n</u>, <b>short</b><u>n</u>, <b>ushort</b><u>n</u>, <b>int</b><u>n</u>, │
       │                         │ <b>uint</b><u>n</u>, <b>long</b><u>n</u>, <b>ulong</b><u>n</u>, <b>float</b><u>n</u>,         │
       │                         │ double<u>n</u>, and optional half<u>n</u> types.    │
       ├─────────────────────────┼───────────────────────────────────────┤
       │ <b><a href="../man3clc/abstractDataTypes.3clc.html">abstractDataTypes</a></b>(3clc) │ <b>cl_platform_id</b>, <b>cl_device_id</b>,         │
       │                         │ <b>cl_context</b>, <b>cl_command_queue</b>, <b>cl_mem</b>, │
       │                         │ <b>cl_program</b>, <b>cl_kernel</b>, <b>cl_event</b>, and  │
       │                         │ <b>cl_sampler</b>.                           │
       ├─────────────────────────┼───────────────────────────────────────┤
       │ <b><a href="../man3clc/reservedDataTypes.3clc.html">reservedDataTypes</a></b>(3clc) │ <b>bool</b><u>n</u>, <b>half</b><u>n</u>, <b>quad</b>, <b>quad</b><u>n</u>, <b>complex</b>    │
       │                         │ <b>half</b>, <b>complex</b> <b>half</b><u>n</u>, <b>imaginary</b> <b>half</b>,  │
       │                         │ <b>imaginary</b> <b>half</b><u>n</u>, <b>complex</b> <b>float</b>,       │
       │                         │ <b>complex</b> <b>float</b><u>n</u>, <b>imaginary</b> <b>float</b>,      │
       │                         │ <b>imaginary</b> <b>float</b><u>n</u>, <b>complex</b> <b>double</b>,     │
       │                         │ <b>complex</b> <b>double</b><u>n</u>, <b>imaginary</b> <b>double</b>,    │
       │                         │ <b>imaginary</b> <b>double</b><u>n</u>, <b>complex</b> <b>quad</b>,      │
       │                         │ <b>complex</b> <b>quad</b><u>n</u>, <b>imaginary</b> <b>quad</b>,        │
       │                         │ <b>imaginary</b> <b>quad</b><u>n</u>, <b>float</b><u>n</u>x<u>m</u>, <b>double</b><u>n</u>x<u>m</u>, │
       │                         │ <b>long</b> <b>double</b>, <b>long</b> <b>double</b><u>n</u>, <b>long</b> <b>long</b>, │
       │                         │ <b>long</b> <b>long</b><u>n</u>, <b>unsigned</b> <b>long</b> <b>long</b>, <b>ulong</b> │
       │                         │ <b>long</b>, and <b>ulong</b> <b>long</b><u>n</u>.                │
       ├─────────────────────────┼───────────────────────────────────────┤
       │ <b><a href="../man3clc/otherDataTypes.3clc.html">otherDataTypes</a></b>(3clc)    │ <b>image2d_t</b>, <b>image3d_t</b>,                 │
       │                         │ <b>image2d_array_t</b>, <b>image1d_t</b>,           │
       │                         │ <b>image31_buffer_t</b>, <b>image1d_array_t</b>,    │
       │                         │ <b>sampler_t</b>, and <b>event_t</b>.               │
       └─────────────────────────┴───────────────────────────────────────┘

</pre><h4><b>ALIGNMENT</b> <b>OF</b> <b>TYPES</b></h4><pre>
       A data item declared to be a data type in memory is always aligned to the size of the data type in bytes.
       For example, a <b>float4</b> variable will be aligned to a 16-byte boundary, and a <b>char2</b> variable will be
       aligned to a 2-byte boundary.

       For 3-component vector data types, the size of the data type is 4 * sizeof(component). This means that a
       3-component vector data type will be aligned to a 4 * sizeof(component) boundary. The <b><a href="../man3clc/vloadn.3clc.html">vloadn</a></b>(3clc) and
       <b><a href="../man3clc/vstoren.3clc.html">vstoren</a></b>(3clc) built-in functions can be used to read and write, respectively, 3-component vector data
       types from an array of packed scalar data type.

       A built-in data type that is not a power of two bytes in size must be aligned to the next larger power of
       two. This rule applies to built-in types only, not structs or unions.

       The OpenCL compiler is responsible for aligning data items to the appropriate alignment as required by
       the data type. For arguments to a <b><a href="../man3clc/functionQualifiers.3clc.html">functionQualifiers</a></b>(3clc) function declared to be a pointer to a data
       type, the OpenCL compiler can assume that the pointee is always appropriately aligned as required by the
       data type. The behavior of an unaligned load or store is undefined, except for the <b><a href="../man3clc/vloadn.3clc.html">vloadn</a></b>(3clc),
       <b><a href="../man3clc/vload_halfn.3clc.html">vload_halfn</a></b>(3clc), <b><a href="../man3clc/vstoren.3clc.html">vstoren</a></b>(3clc), and <b><a href="../man3clc/vstore_halfn.3clc.html">vstore_halfn</a></b>(3clc) functions. The vector load functions can read a
       vector from an address aligned to the element type of the vector. The vector store functions can write a
       vector to an address aligned to the element type of the vector.

       The user is responsible for ensuring that data passed into and out of OpenCL buffers are natively aligned
       relative to the start of the buffer as described above. This implies that OpenCL buffers created with
       <b>CL_MEM_USE_HOST_PTR</b> need to provide an appropriately aligned host memory pointer that is aligned to the
       data types used to access these buffers in a kernel(s). As well, the user is responsible to ensure that
       data passed into and out of OpenCL images are properly aligned to the granularity of the data
       representing a single pixel (e.g.  <u>image_num_channels</u> * sizeof(<u>image_channel_data_type</u>)) except for
       <b>CL_RGB</b> and <b>CL_RGBx</b> images where the data must be aligned to the granularity of a single channel in a
       pixel (i.e. sizeof(<u>image_channel_data_type</u>)).

       OpenCL makes no requirement about the alignment of OpenCL application defined data types outside of
       buffers and images, except that the underlying vector primitives (e.g.  <b>__cl_float4</b>) where defined shall
       be directly accessible as such using appropriate named fields in the <b>cl_type</b> union. Nevertheless, it is
       recommended that the cl_platform.h header should attempt to naturally align OpenCL defined application
       data types (e.g.  <b>cl_float4</b>) according to their type.

</pre><h4><b>SPECIFICATION</b></h4><pre>
       <b>OpenCL</b> <b>Specification</b>[1]

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>The</b> <b>Khronos</b> <b>Group</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2007-2010 The Khronos Group Inc.
       Permission is hereby granted, free of charge, to any person obtaining a copy of this software and/or
       associated documentation files (the "Materials"), to deal in the Materials without restriction, including
       without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Materials, and to permit persons to whom the Materials are furnished to do so, subject to
       the condition that this copyright notice and permission notice shall be included in all copies or
       substantial portions of the Materials.

</pre><h4><b>NOTES</b></h4><pre>
        1. OpenCL Specification
           page 195, section 6.1.1 - Built-in Scalar Data Types

The Khronos Group                                  11/18/2024                                   <u>DATA</u> <u><a href="../man3clc/TYPES.3clc.html">TYPES</a></u>(3clc)
</pre>
 </div>
</div></section>
</div>
</body>
</html>