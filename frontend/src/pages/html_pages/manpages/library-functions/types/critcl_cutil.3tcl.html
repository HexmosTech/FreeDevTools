<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>critcl::cutil - CriTcl - C-level Utilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/critcl">critcl_3.3.1+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       critcl::cutil - CriTcl - C-level Utilities

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b>  <b>8.6</b>

       package require <b>critcl</b>  <b>?3.2?</b>

       package require <b>critcl::cutil</b>  <b>?0.3?</b>

       <b>::critcl::cutil::alloc</b>

       <b>::critcl::cutil::assertions</b> ?<u>enable</u>?

       <b>::critcl::cutil::tracer</b> ?<u>enable</u>?

       <b>type*</b> <b>ALLOC</b> <b>(type)</b>

       <b>type*</b> <b>ALLOC_PLUS</b> <b>(type,</b> <b>int</b> <b>n)</b>

       <b>type*</b> <b>NALLOC</b> <b>(type,</b> <b>int</b> <b>n)</b>

       <b>type*</b> <b>REALLOC</b> <b>(type*</b> <b>var,</b> <b>type,</b> <b>int</b> <b>n)</b>

       <b>void</b> <b>FREE</b> <b>(type*</b> <b>var)</b>

       <b>void</b> <b>STREP</b> <b>(Tcl_Obj*</b> <b>o,</b> <b>char*</b> <b>s,</b> <b>int</b> <b>len)</b>

       <b>void</b> <b>STREP_DS</b> <b>(Tcl_Obj*</b> <b>o,</b> <b>Tcl_DString*</b> <b>ds)</b>

       <b>void</b> <b>STRDUP</b> <b>(varname,</b> <b>char*</b> <b>str)</b>

       <b>void</b> <b>ASSERT</b> <b>(expression,</b> <b>char*</b> <b>message</b>

       <b>void</b> <b>ASSERT_BOUNDS</b> <b>(int</b> <b>index,</b> <b>int</b> <b>size)</b>

       <b>void</b> <b>STOPAFTER(n)</b>

       <b>TRACE_ON</b>

       <b>TRACE_OFF</b>

       <b>TRACE_TAG_ON</b>  <b>(identifier)</b>

       <b>TRACE_TAG_OFF</b> <b>(identifier)</b>

       <b>void</b> <b>TRACE_FUNC</b>

       <b>void</b> <b>TRACE_TAG_FUNC</b> <b>(tag)</b>

       <b>void</b> <b>TRACE_FUNC_VOID</b>

       <b>void</b> <b>TRACE_TAG_FUNC_VOID</b> <b>(tag)</b>

       <b>void</b> <b>TRACE_RETURN_VOID</b>

       <b>void</b> <b>TRACE_TAG_RETURN_VOID</b> <b>(tag)</b>

       <b>any</b> <b>TRACE_RETURN</b>     <b>(</b>     <b>char*</b> <b>format,</b> <b>any</b> <b>x)</b>

       <b>any</b> <b>TRACE_TAG_RETURN</b> <b>(tag,</b> <b>char*</b> <b>format,</b> <b>any</b> <b>x)</b>

       <b>void</b> <b>TRACE</b>     <b>(</b>     <b>char*</b> <b>format,</b> <b>...)</b>

       <b>void</b> <b>TRACE_TAG</b> <b>(tag,</b> <b>char*</b> <b>format,</b> <b>...)</b>

       <b>void</b> <b>TRACE_HEADER</b> <b>(int</b> <b>indent)</b>

       <b>void</b> <b>TRACE_TAG_HEADER</b> <b>(tag,</b> <b>int</b> <b>indent)</b>

       <b>void</b> <b>TRACE_CLOSER</b>

       <b>void</b> <b>TRACE_TAG_CLOSER</b> <b>(tag)</b>

       <b>void</b> <b>TRACE_ADD</b>          <b>(const</b> <b>char*</b> <b>format,</b> <b>...)</b>

       <b>void</b> <b>TRACE_TAG_ADD</b> <b>(tag,</b> <b>const</b> <b>char*</b> <b>format,</b> <b>...)</b>

       <b>void</b> <b>TRACE_PUSH_SCOPE</b> <b>(const</b> <b>char*</b> <b>name)</b>

       <b>void</b> <b>TRACE_PUSH_FUNC</b>

       <b>void</b> <b>TRACE_PUSH_POP</b>

       <b>TRACE_TAG_VAR</b> <b>(tag)</b>

       <b>TRACE_RUN</b> <b>(code);</b>

       <b>TRACE_DO</b> <b>(code);</b>

       <b>TRACE_TAG_DO</b> <b>(tag,</b> <b>code);</b>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Be  welcome  to the <u>C</u> <u>Runtime</u> <u>In</u> <u>Tcl</u> (short: <u>CriTcl</u>), a system for embedding and using C code from within
       <u>Tcl</u> [<a href="http://core.tcl-lang.org/tcl">http://core.tcl-lang.org/tcl</a>] scripts.

       This document is the reference manpage for the <b>critcl::cutil</b> package. This package encapsulates a  number
       of  C-level  utilites  for  easier  writing  of memory allocations, assertions, and narrative tracing and
       provides convenience commands to make these  utilities  accessible  to  critcl  projects.   Its  intended
       audience are mainly developers wishing to write Tcl packages with embedded C code.

       This package resides in the Core Package Layer of CriTcl.

       +----------------+
       |Applications    |
       | critcl         |
       | critcl::app    |
       +----------------+

       *================*
       |Core Packages   |
       | critcl         |
       | critcl::util   |
       *================*

       +----------------+
       |Support Packages|
       | stubs::*       |
       | md5, platform  |
       |  ...           |
       +----------------+

       The  reason  for  this  is that the main <b>critcl</b> package makes use of the facilities for narrative tracing
       when <b>critcl::config</b> <b>trace</b> is set, to instrument commands and procedures.

</pre><h4><b>API</b></h4><pre>
       <b>::critcl::cutil::alloc</b>
              This command provides a number C-preprocessor macros which make the writing of memory  allocations
              for structures and arrays of structures easier.

              When  run  the  header  file  "<u>critcl_alloc.h</u>"  is  directly  made available to the "<u>.critcl</u>" file
              containing the command, and becomes available for use in <b>#include</b> directives of companion  C  code
              declared via <b>critcl::csources</b>.

              The macros definitions and their signatures are:

                  type* ALLOC (type)
                  type* ALLOC_PLUS (type, int n)
                  type* NALLOC (type, int n)
                  type* REALLOC (type* var, type, int n)
                  void  FREE (type* var)

                  void STREP    (Tcl_Obj* o, char* s, int len);
                  void STREP_DS (Tcl_Obj* o, Tcl_DString* ds);
                  void STRDUP   (varname, char* str);

       The details of the semantics are explained in section <b>Allocation</b>.

       The result of the command is an empty string.

       <b>::critcl::cutil::assertions</b> ?<u>enable</u>?
              This command provides a number C-preprocessor macros for the writing of assertions in C code.

              When  invoked  the  header file "<u>critcl_assert.h</u>" is directly made available to the "<u>.critcl</u>" file
              containing the command, and becomes available for use in <b>#include</b> directives of companion  C  code
              declared via <b>critcl::csources</b>.

              The macro definitions and their signatures are

                  void ASSERT (expression, char* message);
                  void ASSERT_BOUNDS (int index, int size);

                  void STOPAFTER (int n);

       Note  that  these  definitions  are  conditional  on the existence of the macro <b>CRITCL_ASSERT</b>.  Without a
       <b>critcl::cflags</b> <b>-DCRITCL_ASSERT</b> all assertions in the C code are  quiescent  and  not  compiled  into  the
       object  file. In other words, assertions can be (de)activated at will during build time, as needed by the
       user.

       For convenience this is controlled by <u>enable</u>. By default (<b>false</b>) the facility available, but not  active.
       Using <b>true</b> not only makes it available, but activates it as well.

       The details of the semantics are explained in section <b>Assertions</b>.

       The result of the command is an empty string.

       <b>::critcl::cutil::tracer</b> ?<u>enable</u>?
              This command provides a number C-preprocessor macros for tracing C-level internals.

              When  invoked  the  header  file "<u>critcl_trace.h</u>" is directly made available to the "<u>.critcl</u>" file
              containing the command, and becomes available for use in <b>#include</b> directives of companion  C  code
              declared  via  <b>critcl::csources</b>. Furthermore the "<u>.c</u>" file containing the runtime support is added
              to the set of C companion files

              The macro definitions and their signatures are

                  /* (de)activation of named logical streams.
                   * These are declarators, not statements.
                   */

                  TRACE_ON;
                  TRACE_OFF;
                  TRACE_TAG_ON  (tag_identifier);
                  TRACE_TAG_OFF (tag_identifier);

                  /*
                   * Higher level trace statements (convenience commands)
                   */

                  void TRACE_FUNC   (const char* format, ...);
                  void TRACE_FUNC_VOID;
                  any  TRACE_RETURN (const char* format, any x);
                  void TRACE_RETURN_VOID;
                  void TRACE (const char* format, ...);

                  /*
                   * Low-level trace statements the higher level ones above
                   * are composed from. Scope management and output management.
                   */

                  void TRACE_PUSH_SCOPE (const char* scope);
                  void TRACE_PUSH_FUNC;
                  void TRACE_POP;

                  void TRACE_HEADER (int indent);
                  void TRACE_ADD (const char* format, ...);
                  void TRACE_CLOSER;

                  /*
                   * Convert tag to the underlying status variable.
                   */

                  TRACE_TAG_VAR (tag)

                  /*
                   * Conditional use of arbitrary code.
                   */

                  TRACE_RUN (code);
                  TRACE_DO (code);
                  TRACE_TAG_DO (code);

       Note that these definitions are conditional on the existence  of  the  macro  <b>CRITCL_TRACER</b>.   Without  a
       <b>critcl::cflags</b>  <b>-DCRITCL_TRACER</b>  all trace functionality in the C code is quiescent and not compiled into
       the object file. In other words, tracing can be (de)activated at will during build time, as needed by the
       user.

       For convenience this is controlled by <u>enable</u>. By default (<b>false</b>) the facility available, but not  active.
       Using  <b>true</b>  not  only  makes  it  available,  but  activates  it as well.  Further note that the command
       <b>critcl::config</b> now accepts a boolean option  <b>trace</b>.  Setting  it  activates  enter/exit  tracing  in  all
       commands based on <b>critcl::cproc</b>, with proper printing of arguments and results. This implicitly activates
       the tracing facility in general.

       The details of the semantics are explained in section <b>Tracing</b>

       The result of the command is an empty string.

</pre><h4><b>ALLOCATION</b></h4><pre>
       <b>type*</b> <b>ALLOC</b> <b>(type)</b>
              This macro allocates a single element of the given <u>type</u> and returns a pointer to that memory.

       <b>type*</b> <b>ALLOC_PLUS</b> <b>(type,</b> <b>int</b> <b>n)</b>
              This  macro  allocates  a  single  element of the given <u>type</u>, plus an additional <u>n</u> bytes after the
              structure and returns a pointer to that memory.

              This is for variable-sized structures of. An example of such  could  be  a  generic  list  element
              structure  which  stores  management  information  in  the structure itself, and the value/payload
              immediately after, in the same memory block.

       <b>type*</b> <b>NALLOC</b> <b>(type,</b> <b>int</b> <b>n)</b>
              This macro allocates <u>n</u> elements of the given <u>type</u> and returns a pointer to that memory.

       <b>type*</b> <b>REALLOC</b> <b>(type*</b> <b>var,</b> <b>type,</b> <b>int</b> <b>n)</b>
              This macro expands or shrinks the memory associated with the C variable <u>var</u> of type <u>type</u> to hold <u>n</u>
              elements of the type. It returns a pointer to that memory.  Remember, a reallocation may move  the
              data  to  a  new  location  in  memory  to  satisfy  the  request.  Returning a pointer instead of
              immediately assigning it to the <u>var</u> allows the user to validate the new pointer before  trying  to
              use it.

       <b>void</b> <b>FREE</b> <b>(type*</b> <b>var)</b>
              This macro releases the memory referenced by the pointer variable <u>var</u>.

       <b>void</b> <b>STREP</b> <b>(Tcl_Obj*</b> <b>o,</b> <b>char*</b> <b>s,</b> <b>int</b> <b>len)</b>
              This  macro properly sets the string representation of the Tcl object <u>o</u> to a copy of the string <u>s</u>,
              expected to be of length <u>len</u>.

       <b>void</b> <b>STREP_DS</b> <b>(Tcl_Obj*</b> <b>o,</b> <b>Tcl_DString*</b> <b>ds)</b>
              This macro properly sets the string representation of the Tcl object <u>o</u> to a  copy  of  the  string
              held by the <b>DString</b> <u>ds</u>.

       <b>void</b> <b>STRDUP</b> <b>(varname,</b> <b>char*</b> <b>str)</b>
              This  macro  duplicates  the  string  <u>str</u> into the heap and stores the result into the named <b>char*</b>
              variable <u>var</u>.

</pre><h4><b>ASSERTIONS</b></h4><pre>
       <b>void</b> <b>ASSERT</b> <b>(expression,</b> <b>char*</b> <b>message</b>
              This macro tests the <u>expression</u> and panics if it does not hold.  The specified <u>message</u> is used  as
              part of the panic.  The <u>message</u> has to be a static string, it cannot be a variable.

       <b>void</b> <b>ASSERT_BOUNDS</b> <b>(int</b> <b>index,</b> <b>int</b> <b>size)</b>
              This macro ensures that the <u>index</u> is in the range <b>0</b> to <b>size-1</b>.

       <b>void</b> <b>STOPAFTER(n)</b>
              This  macro  throws a panic after it is called <u>n</u> times.  Note, each separate instance of the macro
              has its own counter.

</pre><h4><b>TRACING</b></h4><pre>
       All output is printed to <b>stdout</b>.

       <b>TRACE_ON</b>

       <b>TRACE_OFF</b>

       <b>TRACE_TAG_ON</b>  <b>(identifier)</b>

       <b>TRACE_TAG_OFF</b> <b>(identifier)</b>
              These "commands" are actually  declarators,  for  use  outside  of  functions.  They  (de)activate
              specific  logical  streams,  named  either  explicitly by the user, or implicitly, refering to the
              current file.

              For example:

                  TRACE_TAG_ON (lexer_in);

       All high- and low-level trace commands producing output have the controlling tag as an implicit argument.
       The scope management commands do not take tags.

       <b>void</b> <b>TRACE_FUNC</b>

       <b>void</b> <b>TRACE_TAG_FUNC</b> <b>(tag)</b>

       <b>void</b> <b>TRACE_FUNC_VOID</b>

       <b>void</b> <b>TRACE_TAG_FUNC_VOID</b> <b>(tag)</b>
              Use these macros at the beginning of a C function to record entry into it. The name of the entered
              function is an implicit argument (<b>__func__</b>), forcing users to have a C99 compiler..

              The tracer's runtime maintains a stack of active functions and expects  that  function  return  is
              signaled by either <b>TRACE_RETURN</b>, <b>TRACE_RETURN_VOID</b>, or the equivalent forms taking a tag.

       <b>void</b> <b>TRACE_RETURN_VOID</b>

       <b>void</b> <b>TRACE_TAG_RETURN_VOID</b> <b>(tag)</b>
              Use these macros instead of

              return

       to     function.  Beyond  returning from the function this also signals the same to the tracer's runtime,
              popping the last entered function from its stack of active functions.

       <b>any</b> <b>TRACE_RETURN</b>     <b>(</b>     <b>char*</b> <b>format,</b> <b>any</b> <b>x)</b>

       <b>any</b> <b>TRACE_TAG_RETURN</b> <b>(tag,</b> <b>char*</b> <b>format,</b> <b>any</b> <b>x)</b>
              Use this macro instead of

              return x

       to     non-void function.  Beyond returning from the function with value <u>x</u> this also signals the same  to
              the  tracer's  runtime, popping the last entered function from its stack of active functions.  The
              <u>format</u> is expected to be a proper formatting string for <b>printf</b> and analogues, able to stringify <u>x</u>.

       <b>void</b> <b>TRACE</b>     <b>(</b>     <b>char*</b> <b>format,</b> <b>...)</b>

       <b>void</b> <b>TRACE_TAG</b> <b>(tag,</b> <b>char*</b> <b>format,</b> <b>...)</b>
              This macro is the trace facilities' equivalent  of  <b>printf</b>,  printing  arbitrary  data  under  the
              control of the <u>format</u>.

              The printed text is closed with a newline, and indented as per the stack of active functions.

       <b>void</b> <b>TRACE_HEADER</b> <b>(int</b> <b>indent)</b>

       <b>void</b> <b>TRACE_TAG_HEADER</b> <b>(tag,</b> <b>int</b> <b>indent)</b>
              This  is  the  low-level macro which prints the beginning of a trace line. This prefix consists of
              physical location (file name and line number), if available,  indentation  as  per  the  stack  of
              active scopes (if activated), and the name of the active scope.

       <b>void</b> <b>TRACE_CLOSER</b>

       <b>void</b> <b>TRACE_TAG_CLOSER</b> <b>(tag)</b>
              This is the low-level macro which prints the end of a trace line.

       <b>void</b> <b>TRACE_ADD</b>          <b>(const</b> <b>char*</b> <b>format,</b> <b>...)</b>

       <b>void</b> <b>TRACE_TAG_ADD</b> <b>(tag,</b> <b>const</b> <b>char*</b> <b>format,</b> <b>...)</b>
              This is the low-level macro which adds formatted data to the line.

       <b>void</b> <b>TRACE_PUSH_SCOPE</b> <b>(const</b> <b>char*</b> <b>name)</b>

       <b>void</b> <b>TRACE_PUSH_FUNC</b>

       <b>void</b> <b>TRACE_PUSH_POP</b>
              These  are  the low-level macros for scope management. The first two forms push a new scope on the
              stack of active scopes, and the last forms pops the last scope pushed.

       <b>TRACE_TAG_VAR</b> <b>(tag)</b>
              Helper macro converting from a tag identifier to the name of the underlying status variable.

       <b>TRACE_RUN</b> <b>(code);</b>
              Conditionally insert the <u>code</u> at compile time when the tracing facility is activated.

       <b>TRACE_DO</b> <b>(code);</b>

       <b>TRACE_TAG_DO</b> <b>(tag,</b> <b>code);</b>
              Insert the <u>code</u> at compile time when the tracing facility is activated, and execute the same  when
              either the implicit tag for the file or the user-specified tag is active.

</pre><h4><b>AUTHORS</b></h4><pre>
       Andreas Kupries

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such at <u>https://github.com/andreas-kupries/critcl</u>.  Please also report any ideas for  enhancements
       you may have for either package and/or documentation.

</pre><h4><b>KEYWORDS</b></h4><pre>
       C  code,  Embedded  C  Code,  code  generator,  compile &amp; run, compiler, dynamic code generation, dynamic
       compilation, generate package, linker, on demand compilation, on-the-fly compilation

</pre><h4><b>CATEGORY</b></h4><pre>
       Glueing/Embedded C code

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2011-2024 Andreas Kupries

doc                                                    0.3                                   <u>critcl::<a href="../man3tcl/cutil.3tcl.html">cutil</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>