<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openmpi-doc">openmpi-doc_5.0.7-1build1_all</a> <br><br><pre>
</pre><h4><b>SYNTAX</b></h4><pre>
   <b>C</b> <b>Syntax</b>
          #include &lt;mpi.h&gt;

          int MPI_Type_create_struct(int count, int array_of_blocklengths[],
               const MPI_Aint array_of_displacements[], const MPI_Datatype array_of_types[],
               MPI_Datatype *newtype)

   <b>Fortran</b> <b>Syntax</b>
          USE MPI
          ! or the older form: INCLUDE 'mpif.h'
          MPI_TYPE_CREATE_STRUCT(COUNT, ARRAY_OF_BLOCKLENGTHS,
                       ARRAY_OF_DISPLACEMENTS, ARRAY_OF_TYPES, NEWTYPE, IERROR)
               INTEGER COUNT, ARRAY_OF_BLOCKLENGTHS(*), ARRAY_OF_TYPES(*),
               INTEGER NEWTYPE, IERROR
               INTEGER(KIND=MPI_ADDRESS_KIND) ARRAY_OF_DISPLACEMENTS(*)

   <b>Fortran</b> <b>2008</b> <b>Syntax</b>
          USE mpi_f08
          MPI_Type_create_struct(count, array_of_blocklengths,
                       array_of_displacements, array_of_types, newtype, ierror)
               INTEGER, INTENT(IN) :: count, array_of_blocklengths(count)
               INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) ::
               array_of_displacements(count)
               TYPE(MPI_Datatype), INTENT(IN) :: array_of_types(count)
               TYPE(MPI_Datatype), INTENT(OUT) :: newtype
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

</pre><h4><b>INPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>count</b>:   Number   of   blocks   (integer)   —   also   number  of  entries  in  arrays  <u>array_of_types</u>,
         <u>array_of_displacements</u>, and <u>array_of_blocklengths</u>.

       • <b>array_of_blocklengths</b>: Number of elements in each block (array of integers).

       • <b>array_of_displacements</b>: Byte displacement of each block (array of integers).

       • <b>array_of_types</b>: Type of elements in each block (array of handles to data-type objects).

</pre><h4><b>OUTPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>newtype</b>: New data type (handle).

       • <b>ierror</b>: Fortran only: Error status (integer).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>MPI_Type_create_struct</u> creates a structured data type. This routine replaces  <u>MPI_Type_struct</u>,  which  is
       now deprecated.

       <u>MPI_Type_create_struct</u>    is    the    most    general   type   constructor.   It   further   generalizes
       <u>MPI_Type_create_hindexed</u> in that it allows each block to consist of replications of different datatypes.

       <b>Example</b> <b>1:</b> Let <b>type1</b> have type map

          {(double, 0), (char, 8)}

       with extent 16. Let <b>B</b> <b>=</b> <b>(2,</b> <b>1,</b> <b>3)</b>, <b>D</b> <b>=</b> <b>(0,</b> <b>16,</b> <b>26)</b>, and <b>T</b> <b>=</b> <b>(MPI_FLOAT,</b> <b>type1,</b> <b>MPI_CHAR)</b>.  Then a call to
       <b>MPI_Type_create_struct(3,</b> <b>B,</b> <b>D,</b> <b>T,</b> <b>newtype)</b> returns a datatype with type map

          {
           (float, 0), (float,4),             // 2 float
           (double, 16), (char, 24),          // 1 type1
           (char, 26), (char, 27), (char, 28) // 3 char
          }

       That is, two copies of <b>MPI_FLOAT</b> starting at 0, followed by one copy of <b>type1</b> starting at 16, followed by
       three copies of <b>MPI_CHAR</b>, starting at 26.

       <b>Example</b> <b>2:</b>

       An example of a struct with only some components part of the type

          struct MyStruct {
              double x[2], y;
              char a;
              int n;
          };

          // create a new type where we only send x, y and n
          int B[] = {
              2, // 2 double's
              1, // 1 double
              1, // 1 int
              1  // alignment padding
          };
          MPI_Aint D[] = {
              offsetof(struct MyStruct, x),
              offsetof(struct MyStruct, y),
              offsetof(struct MyStruct, n),
              sizeof(struct MyStruct)
          };
          MPI_Datatype T[] = {
              MPI_DOUBLE,
              MPI_DOUBLE,
              MPI_INT,
              MPI_UB
          };

          MPI_Datatype mpi_dt_mystruct;
          MPI_Type_create_struct(4, B, D, T, &amp;mpi_dt_mystruct);
          MPI_Type_commit(&amp;mpi_dt_mystruct);

          // We can now send a struct (omitting a)

          struct MyStruct values[3];

          if ( rank == 0 ) {
              // ... initialize values
              MPI_Send(values, 3, mpi_dt_mystruct, 1, 0, MPI_COMM_WORLD);
          } else if ( rank == 1 ) {
              MPI_Recv(values, 3, mpi_dt_mystruct, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
          }

       For more information, see section 5.1.2 of the MPI-4.0 Standard.

</pre><h4><b>NOTES</b></h4><pre>
       If an upper bound is set explicitly by using the MPI datatype <b>MPI_UB</b>, the  corresponding  index  must  be
       positive.

       The  MPI-1  Standard  originally  made vague statements about padding and alignment; this was intended to
       allow the simple definition of structures that could be sent with a count greater than one. For example,

          struct {int a; char b;} foo;

       may have

          sizeof(foo) = sizeof(int) + sizeof(char);

       defining the extent of a datatype as including an epsilon, which would have allowed an implementation  to
       make  the  extent  an  MPI  datatype  for this structure equal to <b>2*sizeof(int)</b>. However, since different
       systems might define different paddings, a clarification to the standard made epsilon zero. Thus, if  you
       define  a structure datatype and wish to send or receive multiple items, you should explicitly include an
       <b>MPI_UB</b> entry as the last member of the structure. See the above example.

</pre><h4><b>ERRORS</b></h4><pre>
       Almost all MPI routines return an error value; C routines as  the  return  result  of  the  function  and
       Fortran routines in the last argument.

       Before  the  error  value  is  returned,  the current MPI error handler associated with the communication
       object (e.g., communicator, window, file) is called.  If no communication object is associated  with  the
       MPI  call,  then  the call is considered attached to MPI_COMM_SELF and will call the associated MPI error
       handler.  When  MPI_COMM_SELF  is  not  initialized   (i.e.,   before   <u>MPI_Init</u>/<u>MPI_Init_thread</u>,   after
       <u>MPI_Finalize</u>,  or  when using the Sessions Model exclusively) the error raises the initial error handler.
       The initial error handler can be changed by calling <u>MPI_Comm_set_errhandler</u> on MPI_COMM_SELF  when  using
       the  World  model,  or the mpi_initial_errhandler CLI argument to mpiexec or info key to <u>MPI_Comm_spawn</u>/‐
       <u>MPI_Comm_spawn_multiple</u>.  If no other appropriate error handler has been set, then the  MPI_ERRORS_RETURN
       error  handler  is  called for MPI I/O functions and the MPI_ERRORS_ABORT error handler is called for all
       other MPI functions.

       Open MPI includes three predefined error handlers that can be used:

       • <b>MPI_ERRORS_ARE_FATAL</b> Causes the program to abort all connected MPI processes.

       • <b>MPI_ERRORS_ABORT</b> An error handler that can be invoked on a communicator, window, file, or session. When
         called on a communicator, it acts as if <u>MPI_Abort</u> was called on  that  communicator.  If  called  on  a
         window  or file, acts as if <u>MPI_Abort</u> was called on a communicator containing the group of processes in
         the corresponding window or file. If called on a session, aborts only the local process.

       • <b>MPI_ERRORS_RETURN</b> Returns an error code to the application.

       MPI applications can also implement their own error handlers by calling:

       • <u>MPI_Comm_create_errhandler</u> then <u>MPI_Comm_set_errhandler</u>

       • <u>MPI_File_create_errhandler</u> then <u>MPI_File_set_errhandler</u>

       • <u>MPI_Session_create_errhandler</u> then <u>MPI_Session_set_errhandler</u> or at <u>MPI_Session_init</u>

       • <u>MPI_Win_create_errhandler</u> then <u>MPI_Win_set_errhandler</u>

       Note that MPI does not guarantee that an MPI program can continue past an error.

       See the <u>MPI</u> <u>man</u> <u>page</u> for a full list of <u>MPI</u> <u>error</u> <u>codes</u>.

       See the Error Handling section of the MPI-3.1 standard for more information.

       <b>SEE</b> <b>ALSO:</b>

          • <u>MPI_Type_struct</u>

          • <u>MPI_Type_create_hindexed</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Jun 07, 2025                         <u><a href="../man3/MPI_TYPE_CREATE_STRUCT.3.html">MPI_TYPE_CREATE_STRUCT</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>