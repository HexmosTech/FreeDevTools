<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MooseX::Types - Organise your Moose types in libraries</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmoosex-types-perl">libmoosex-types-perl_0.51-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MooseX::Types - Organise your Moose types in libraries

</pre><h4><b>VERSION</b></h4><pre>
       version 0.51

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Library</b> <b>Definition</b>
         package MyLibrary;

         # predeclare our own types
         use MooseX::Types -declare =&gt; [
             qw(
                 PositiveInt
                 NegativeInt
                 ArrayRefOfPositiveInt
                 ArrayRefOfAtLeastThreeNegativeInts
                 LotsOfInnerConstraints
                 StrOrArrayRef
                 MyDateTime
                 )
         ];

         # import builtin types
         use MooseX::Types::Moose qw/Int HashRef/;

         # type definition.
         subtype PositiveInt,
             as Int,
             where { $_ &gt; 0 },
             message { "Int is not larger than 0" };

         subtype NegativeInt,
             as Int,
             where { $_ &lt; 0 },
             message { "Int is not smaller than 0" };

         # type coercion
         coerce PositiveInt,
             from Int,
                 via { 1 };

         # with parameterized constraints.

         subtype ArrayRefOfPositiveInt,
           as ArrayRef[PositiveInt];

         subtype ArrayRefOfAtLeastThreeNegativeInts,
           as ArrayRef[NegativeInt],
           where { scalar(@$_) &gt; 2 };

         subtype LotsOfInnerConstraints,
           as ArrayRef[ArrayRef[HashRef[Int]]];

         # with TypeConstraint Unions

         subtype StrOrArrayRef,
           as Str|ArrayRef;

         # class types

         class_type 'DateTime';

         # or better

         class_type MyDateTime, { class =&gt; 'DateTime' };

         coerce MyDateTime,
           from HashRef,
           via { DateTime-&gt;new(%$_) };

         1;

   <b>Usage</b>
         package Foo;
         use Moose;
         use MyLibrary qw( PositiveInt NegativeInt );

         # use the exported constants as type names
         has 'bar',
             isa    =&gt; PositiveInt,
             is     =&gt; 'rw';
         has 'baz',
             isa    =&gt; NegativeInt,
             is     =&gt; 'rw';

         sub quux {
             my ($self, $value);

             # test the value
             print "positive\n" if is_PositiveInt($value);
             print "negative\n" if is_NegativeInt($value);

             # coerce the value, NegativeInt doesn't have a coercion
             # helper, since it didn't define any coercions.
             $value = to_PositiveInt($value) or die "Cannot coerce";
         }

         1;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The type system provided by Moose effectively makes all of its builtin type global, as are any types you
       declare with Moose. This means that every module that declares a type named "PositiveInt" is sharing the
       same type object. This can be a problem when different parts of the code base want to use the same name
       for different things.

       This package lets you declare types using short names, but behind the scenes it namespaces all your type
       declarations, effectively prevent name clashes between packages.

       This is done by creating a type library module like "MyApp::Types" and then importing types from that
       module into other modules.

       As a side effect, the declaration mechanism allows you to write type names as barewords (really function
       calls), which catches typos in names at compile time rather than run time.

       This module also provides some helper functions for using Moose types outside of attribute declarations.

       If you mix string-based names with types created by this module, it will warn, with a few exceptions. If
       you are declaring a class_type() or role_type() within your type library, or if you use a fully qualified
       name like "MyApp::Foo".

</pre><h4><b>LIBRARY</b> <b>DEFINITION</b></h4><pre>
       A MooseX::Types is just a normal Perl module. Unlike Moose itself, it does not install "use strict" and
       "use warnings" in your class by default, so this is up to you.

       The only thing a library is required to do is

         use MooseX::Types -declare =&gt; \@types;

       with @types being a list of types you wish to define in this library.  This line will install a proper
       base class in your package as well as the full set of handlers for your declared types. It will then hand
       control over to Moose::Util::TypeConstraints' "import" method to export the functions you will need to
       declare your types.

       If you want to use Moose' built-in types (e.g. for subtyping) you will want to

         use MooseX::Types::Moose @types;

       to import the helpers from the shipped MooseX::Types::Moose library which can export all types that come
       with Moose.

       You will have to define coercions for your types or your library won't export a "to_$type" coercion
       helper for it.

       Note that you currently cannot define types containing "::", since exporting would be a problem.

       You also don't need to use "warnings" and "strict", since the definition of a library automatically
       exports those.

</pre><h4><b>LIBRARY</b> <b>USAGE</b></h4><pre>
       You can import the "type helpers" of a library by "use"ing it with a list of types to import as
       arguments. If you want all of them, use the ":all" tag. For example:

         use MyLibrary      ':all';
         use MyOtherLibrary qw( TypeA TypeB );

       MooseX::Types comes with a library of Moose' built-in types called MooseX::Types::Moose.

       The exporting mechanism is, since version 0.5, implemented via a wrapper around Sub::Exporter. This means
       you can do something like this:

         use MyLibrary TypeA =&gt; { -as =&gt; 'MyTypeA' },
                       TypeB =&gt; { -as =&gt; 'MyTypeB' };

</pre><h4><b>TYPE</b> <b>HANDLER</b> <b>FUNCTIONS</b></h4><pre>
   <b>$type</b>
       A constant with the name of your type. It contains the type's fully qualified name. Takes no value, as
       all constants.

   <b>is_$type</b>
       This handler takes a value and tests if it is a valid value for this $type. It will return true or false.

   <b>to_$type</b>
       A handler that will take a value and coerce it into the $type. It will return a false value if the type
       could not be coerced.

       <b>Important</b> <b>Note</b>: This handler will only be exported for types that can do type coercion. This has the
       advantage that a coercion to a type that has not defined any coercions will lead to a compile-time error.

</pre><h4><b>WRAPPING</b> <b>A</b> <b>LIBRARY</b></h4><pre>
       You can define your own wrapper subclasses to manipulate the behaviour of a set of library exports. Here
       is an example:

         package MyWrapper;
         use strict;
         use MRO::Compat;
         use base 'MooseX::Types::Wrapper';

         sub coercion_export_generator {
             my $class = shift;
             my $code = $class-&gt;next::method(@_);
             return sub {
                 my $value = $code-&gt;(@_);
                 warn "Coercion returned undef!"
                     unless defined $value;
                 return $value;
             };
         }

         1;

       This class wraps the coercion generator (e.g., to_Int()) and warns if a coercion returned an undefined
       value. You can wrap any library with this:

         package Foo;
         use strict;
         use MyWrapper MyLibrary =&gt; [qw( Foo Bar )],
                       Moose     =&gt; [qw( Str Int )];

         ...
         1;

       The "Moose" library name is a special shortcut for MooseX::Types::Moose.

   <b>Generator</b> <b>methods</b> <b>you</b> <b>can</b> <b>overload</b>
       type_export_generator( $short, $full )
           Creates a closure returning the type's Moose::Meta::TypeConstraint object.

       check_export_generator( $short, $full, $undef_message )
           This creates the closure used to test if a value is valid for this type.

       coercion_export_generator( $short, $full, $undef_message )
           This is the closure that's doing coercions.

   <b>Provided</b> <b>Parameters</b>
       $short
           The short, exported name of the type.

       $full
           The fully qualified name of this type as Moose knows it.

       $undef_message
           A message that will be thrown when type functionality is used but the type does not yet exist.

</pre><h4><b>RECURSIVE</b> <b>SUBTYPES</b></h4><pre>
       As of version 0.08, MooseX::Types has experimental support for Recursive subtypes.  This will allow:

           subtype Tree() =&gt; as HashRef[Str|Tree];

       Which validates things like:

           {key=&gt;'value'};
           {key=&gt;{subkey1=&gt;'value', subkey2=&gt;'value'}}

       And  so  on.   This  feature is new and there may be lurking bugs so don't be afraid to hunt me down with
       patches and test cases if you have trouble.

</pre><h4><b>NOTES</b> <b>REGARDING</b> <b>TYPE</b> <b>UNIONS</b></h4><pre>
       MooseX::Types uses MooseX::Types::TypeDecorator to do some overloading  which  generally  allows  you  to
       easily create union types:

         subtype StrOrArrayRef,
             as Str|ArrayRef;

       As  with  parameterized  constraints, this overloading extends to modules using the types you define in a
       type library.

         use Moose;
         use MooseX::Types::Moose qw(HashRef Int);

         has 'attr' =&gt; ( isa =&gt; HashRef | Int );

       And everything should just work as you'd think.

</pre><h4><b>METHODS</b></h4><pre>
   <b>import</b>
       Installs the MooseX::Types::Base class into the caller and exports types according to  the  specification
       described in "LIBRARY DEFINITION". This will continue to Moose::Util::TypeConstraints' "import" method to
       export helper functions you will need to declare your types.

   <b>type_export_generator</b>
       Generate  a  type  export,  e.g.  Int(). This will return either a Moose::Meta::TypeConstraint object, or
       alternatively a MooseX::Types::UndefinedType object if the type was not yet defined.

   <b>create_arged_type_constraint</b> <b>($name,</b> <b>@args)</b>
       Given a String $name with @args find the matching type constraint and parameterize it with @args.

   <b>create_base_type_constraint</b> <b>($name)</b>
       Given a String $name, find the matching type constraint.

   <b>create_type_decorator</b> <b>($type_constraint)</b>
       Given a $type_constraint, return a lightweight MooseX::Types::TypeDecorator instance.

   <b>coercion_export_generator</b>
       This generates a coercion handler function, e.g. to_Int($value).

   <b>check_export_generator</b>
       Generates a constraint check closure, e.g. is_Int($value).

</pre><h4><b>CAVEATS</b></h4><pre>
       The following are lists of gotchas and their workarounds for developers coming from the  standard  string
       based type constraint names

   <b>Uniqueness</b>
       A  library  makes  the  types quasi-unique by prefixing their names with (by default) the library package
       name. If you're only using the type handler functions provided by MooseX::Types, you shouldn't ever  have
       to use a type's actual full name.

   <b>Argument</b> <b>separation</b> <b>('=&gt;'</b> <b>versus</b> <b>',')</b>
       The  perlop manpage has this to say about the '=&gt;' operator: "The =&gt; operator is a synonym for the comma,
       but forces any word (consisting entirely of word characters) to its left to be interpreted  as  a  string
       (as of 5.001). This includes words that might otherwise be considered a constant or function call."

       Due to this stringification, the following will NOT work as you might think:

         subtype StrOrArrayRef =&gt; as Str | ArrayRef;

       The  "StrOrArrayRef"  type  will  have its stringification activated -- this causes the subtype to not be
       created.  Since the bareword type constraints are not strings you really should not  try  to  treat  them
       that  way.   You will have to use the ',' operator instead.  The authors of this package realize that all
       the Moose documentation and examples nearly uniformly use the '=&gt;' version of the comma operator and this
       could be an issue if you are converting code.

       Patches welcome for discussion.

   <b>Compatibility</b> <b>with</b> <b>Sub::Exporter</b>
       If you want to use Sub::Exporter with a Type Library, you need to make  sure  you  export  all  the  type
       constraints declared AS WELL AS any additional export targets. For example if you do:

         package TypeAndSubExporter;

         use MooseX::Types::Moose qw(Str);
         use MooseX::Types -declare =&gt; [qw(MyStr)];
         use Sub::Exporter -setup =&gt; { exports =&gt; [qw(something)] };

         subtype MyStr, as Str;

         sub something {
             return 1;
         }

         # then in another module ...

         package Foo;
         use TypeAndSubExporter qw(MyStr);

       You'll  get  a ""MyStr" is not exported by the TypeAndSubExporter module" error.  It can be worked around
       by:

         - use Sub::Exporter -setup =&gt; { exports =&gt; [ qw(something) ] };
         + use Sub::Exporter -setup =&gt; { exports =&gt; [ qw(something MyStr) ] };

       This is a workaround and I am exploring how to make these modules work better together.  I  realize  this
       workaround  will lead a lot of duplication in your export declarations and will be onerous for large type
       libraries.  Patches and detailed test cases welcome. See the tests directory for a start on this.

</pre><h4><b>COMBINING</b> <b>TYPE</b> <b>LIBRARIES</b></h4><pre>
       You may want  to  combine  a  set  of  types  for  your  application  with  other  type  libraries,  like
       MooseX::Types::Moose or MooseX::Types::Common::String.

       The MooseX::Types::Combine module provides a simple API for combining a set of type libraries together.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Moose, Moose::Util::TypeConstraints, MooseX::Types::Moose, Sub::Exporter

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Many thanks to the "#moose" cabal on "irc.perl.org".

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs         may        be        submitted        through        the        RT        bug        tracker
       &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=MooseX-Types&gt;     (or     <a href="mailto:bug-MooseX-Types@rt.cpan.org">bug-MooseX-Types@rt.cpan.org</a>
       &lt;<a href="mailto:bug-MooseX-Types@rt.cpan.org">mailto:bug-MooseX-Types@rt.cpan.org</a>&gt;).

       There    is    also    a    mailing    list    available    for    users   of   this   distribution,   at
       &lt;<a href="http://lists.perl.org/list/moose.html">http://lists.perl.org/list/moose.html</a>&gt;.

       There is also an irc channel available for users of this  distribution,  at  "#moose"  on  "irc.perl.org"
       &lt;irc://irc.perl.org/#moose&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       Robert "phaylon" Sedlacek &lt;<a href="mailto:rs@474.at">rs@474.at</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

       •   John Napiorkowski &lt;<a href="mailto:jjnapiork@cpan.org">jjnapiork@cpan.org</a>&gt;

       •   Robert 'phaylon' Sedlacek &lt;<a href="mailto:phaylon@cpan.org">phaylon@cpan.org</a>&gt;

       •   Rafael Kitover &lt;<a href="mailto:rkitover@cpan.org">rkitover@cpan.org</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

       •   Matt S Trout &lt;<a href="mailto:mst@shadowcat.co.uk">mst@shadowcat.co.uk</a>&gt;

       •   Graham Knop &lt;<a href="mailto:haarg@haarg.org">haarg@haarg.org</a>&gt;

       •   Hans Dieter Pearcey &lt;<a href="mailto:hdp@weftsoar.net">hdp@weftsoar.net</a>&gt;

       •   Jesse Luehrs &lt;<a href="mailto:doy@tozt.net">doy@tozt.net</a>&gt;

       •   Mark Fowler &lt;<a href="mailto:mark@twoshortplanks.com">mark@twoshortplanks.com</a>&gt;

       •   Tomas Doran (t0m) &lt;<a href="mailto:bobtfish@bobtfish.net">bobtfish@bobtfish.net</a>&gt;

       •   Justin Hunter &lt;<a href="mailto:justin.d.hunter@gmail.com">justin.d.hunter@gmail.com</a>&gt;

       •   Kent Fredric &lt;<a href="mailto:kentfredric@gmail.com">kentfredric@gmail.com</a>&gt;

       •   Paul Fenwick &lt;<a href="mailto:pjf@perltraining.com.au">pjf@perltraining.com.au</a>&gt;

       •   Tadeusz Sośnierz &lt;<a href="mailto:tadeusz.sosnierz@onet.pl">tadeusz.sosnierz@onet.pl</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2007 by Robert "phaylon" Sedlacek.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.1                                       2025-04-27                                 <u>MooseX::<a href="../man3pm/Types.3pm.html">Types</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>