<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::Types - define fundamental PDL Datatypes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/pdl">pdl_2.100-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::Types - define fundamental PDL Datatypes

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PDL::Types;

        $pdl = ushort( 2.0, 3.0 );
        print "The actual c type used to store ushort's is '" .
           $pdl-&gt;type-&gt;realctype() . "'\n";
        The actual c type used to store ushort's is 'unsigned short'

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Internal module - holds all the PDL Type info.  The type info can be accessed easily using the
       "PDL::Type" object returned by the type method as shown in the synopsis.

       Skip to the end of this document to find out how to change the set of types supported by PDL.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       A number of functions are available for module writers to get/process type information. These are used in
       various places (e.g. "PDL::PP", "PDL::Core") to generate the appropriate type loops, etc.

   <b>typesrtkeys</b>
       Returns an array of keys of typehash sorted in order of type complexity

        pdl&gt; @typelist = PDL::Types::typesrtkeys;
        pdl&gt; print @typelist;
        PDL_SB PDL_B PDL_S PDL_US PDL_L PDL_UL PDL_IND PDL_ULL PDL_LL PDL_F PDL_D PDL_LD PDL_CF PDL_CD PDL_CLD

   <b>ppdefs</b>
       Returns an array of pp symbols for all real types. This informs the default "GenericTypes" for "pp_def"
       functions, making support for complex types require an "opt-in".

        pdl&gt; print PDL::Types::ppdefs
        A B S U L K N P Q F D E

   <b>ppdefs_complex</b>
       Returns an array of pp symbols for all complex types.

        pdl&gt; print PDL::Types::ppdefs_complex
        G C H

   <b>ppdefs_all</b>
       Returns an array of pp symbols for all types including complex.

        pdl&gt; print PDL::Types::ppdefs_all
        A B S U L K N P Q F D E G C H

   <b>typesynonyms</b>
       return type related synonym definitions to be included in pdl.h .  This routine must be updated to
       include new types as required.  Mostly the automatic updating should take care of the vital things.

</pre><h4><b>PDL</b> <b>TYPES</b> <b>OVERVIEW</b></h4><pre>
       As of 2.065, PDL supports these types:

       SByte
           Signed 8-bit value.

       Byte
           Unsigned 8-bit value.

       Short
           Signed 16-bit value.

       UShort
           Unsigned 16-bit value.

       Long
           Signed 32-bit value.

       ULong
           Unsigned 32-bit value.

       Indx
           Signed value, same size as a pointer on the system in use.

       ULongLong
           Unsigned 64-bit value.

       LongLong
           Signed 64-bit value.

       Float
           IEEE 754 &lt;https://en.wikipedia.org/wiki/IEEE_754&gt; single-precision real floating-point value.

       Double
           IEEE 754 double-precision real value.

       LDouble
           A C99 "long double", defined as "at least as precise as a double", but often more precise.

       CFloat
           A C99 complex single-precision floating-point value.

       CDouble
           A C99 complex double-precision floating-point value.

       CLDouble
           A C99 complex "long double" - see above for description.

       As of 2.099, documentation for PDL::Type is separate. See there for more.

</pre><h4><b>DEVELOPER</b> <b>NOTES</b> <b>ON</b> <b>ADDING/REMOVING</b> <b>TYPES</b></h4><pre>
       You can change the types that PDL knows about by editing entries in the definition of the variable @types
       that appears close to the top of the file <u>lib/PDL/Types.pm</u>.

   <b>Format</b> <b>of</b> <b>a</b> <b>type</b> <b>entry</b>
       Each  entry  in the @HASHES array is a hash reference. Here is an example taken from the actual code that
       defines the "ushort" type:

         {
           identifier =&gt; 'US',
           onecharident =&gt; 'U',   # only needed if different from identifier
           ctype =&gt; 'PDL_Ushort',
           realctype =&gt; 'unsigned short',
           ppforcetype =&gt; 'ushort',
           usenan =&gt; 0,
           packtype =&gt; 'S*',
           defbval =&gt; 'USHRT_MAX',
           real=&gt;1,
           integer=&gt;1,
           unsigned=&gt;1,
         },

       Before we start to explain the fields please take this important message on board: <u>entries</u> <u>must</u> <u>be</u> <u>listed</u>
       <u>in</u> <u>order</u> <u>of</u> <u>increasing</u> <u>complexity</u>. This is critical to ensure that PDL's type conversion works correctly.
       Basically, a less complex type will be converted to a more complex type as required.

   <b>Fields</b> <b>in</b> <b>a</b> <b>type</b> <b>entry</b>
       Each type entry has a number of required and optional entry.

       A list of all the entries:

       •   identifier

           <u>Required</u>. A short sequence of uppercase letters that identifies this type uniquely. More  than  three
           characters is probably overkill.

       •   onecharident

           <u>Optional</u>.  Only  required  if  the "identifier" has more than one character.  This should be a unique
           uppercase character that will be used to reference this type in PP macro expressions of the "TBSULFD"
           type - see "$T" in PDL::PP.

       •   ctype

           <u>Required</u>. The "typedef"ed name that will be used to access this type from C code.

       •   realctype

           <u>Required</u>. The C compiler type that is used to implement this type.  For portability reasons this  one
           might be platform dependent.

       •   ppforcetype

           <u>Required</u>. The type name used in PP signatures to refer to this type.

       •   usenan

           <u>Required</u>.  Flag  that  signals if this type has to deal with NaN issues.  Generally only required for
           floating point types.

       •   packtype

           <u>Required</u>. The Perl pack type used to pack Perl values into the machine representation for this  type.
           For details see "perldoc -f pack".

       •   integer

           <u>Required</u>. Boolean - is this an integer type?

       •   unsigned

           <u>Required</u>. Boolean - is this an unsigned type?

       •   real

           <u>Required</u>. Boolean - is this a real (not complex) type?

       •   realversion

           String - the real version of this type (e.g. cdouble -&gt; 'D').

       •   complexversion

           String - the complex version of this type (e.g. double -&gt; 'C').

       Also have a look at the entries at the top of <u>lib/PDL/Types.pm</u>.

   <b>Other</b> <b>things</b> <b>you</b> <b>need</b> <b>to</b> <b>do</b>
       You  need to check modules that do I/O (generally in the <u>IO</u> part of the directory tree). In the future we
       might add fields to type entries to automate this. This  requires  changes  to  those  IO  modules  first
       though.

       You may also need to update any type macros in PP files (i.e. "$TBSULFD...") to reflect the new type - PP
       will throw an error if you have a "$T..." macro which misses types supported by the operation.

perl v5.40.1                                       2025-03-27                                    <u>PDL::<a href="../man3pm/Types.3pm.html">Types</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>