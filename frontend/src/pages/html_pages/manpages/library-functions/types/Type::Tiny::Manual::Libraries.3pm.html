<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type::Tiny::Manual::Libraries - defining your own type libraries</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtype-tiny-perl">libtype-tiny-perl_2.004000-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Type::Tiny::Manual::Libraries - defining your own type libraries

</pre><h4><b>MANUAL</b></h4><pre>
   <b>Defining</b> <b>a</b> <b>Type</b>
       A type is an object and you can create a new one using the constructor:

         use Type::Tiny;

         my $type = Type::Tiny-&gt;new(%args);

       A full list of the available arguments can be found in the Type::Tiny documentation, but the most
       important ones to begin with are:

       "name"
           The name of your new type. Type::Tiny uses a convention of UpperCamelCase names for type constraints.
           The  type  name  may  also  begin with one or two leading underscores to indicate a type intended for
           internal use only.  Types using non-ASCII characters may cause problems on  older  versions  of  Perl
           (pre-5.8).

           Although  this  is  optional  and types may be anonymous, a name is required for a type constraint to
           added to a type library.

       "constraint"
           A code reference checking $_ and returning a boolean. Alternatively, a string of  Perl  code  may  be
           provided.

           If  you've  been  paying attention, you can probably guess that the string of Perl code may result in
           more efficient type checks.

       "parent"
           An existing type constraint to inherit from. A value will need to pass the parent  constraint  before
           its own constraint would be called.

             my $Even = Type::Tiny-&gt;new(
               name       =&gt; 'EvenNumber',
               parent     =&gt; Types::Standard::Int,
               constraint =&gt; sub {
                 # in this sub we don't need to check that $_ is an Int
                 # because the parent will take care of that!

                 $_ % 2 == 0
               },
             );

           Although  the "parent" is optional, it makes sense whenever possible to inherit from an existing type
           constraint to benefit from any optimizations or XS implementations they may provide.

   <b>Defining</b> <b>a</b> <b>Library</b>
       A  library  is   a   Perl   module   that   exports   type   constraints   as   subs.    Types::Standard,
       Types::Common::Numeric, and Types::Common::String are type libraries that are bundled with Type::Tiny.

       To create a type library, create a package that inherits from Type::Library.

         package MyTypes {
           use Type::Library -base;

           ...; # your type definitions go here
         }

       The "-base" flag is just a shortcut for:

         package MyTypes {
           use Type::Library;
           our @ISA = 'Type::Library';
         }

       You can add types like this:

         package MyTypes {
           use Type::Library -base;

           my $Even = Type::Tiny-&gt;new(
             name       =&gt; 'EvenNumber',
             parent     =&gt; Types::Standard::Int,
             constraint =&gt; sub {
               # in this sub we don't need to check that $_ is an Int
               # because the parent will take care of that!

               $_ % 2 == 0
             },
           );

           __PACKAGE__-&gt;add_type($Even);
         }

       There  is  a  shortcut  for  adding  types if they're going to be blessed Type::Tiny objects and not, for
       example, a subclass of Type::Tiny.  You can just pass %args directly to "add_type".

         package MyTypes {
           use Type::Library -base;

           __PACKAGE__-&gt;add_type(
             name       =&gt; 'EvenNumber',
             parent     =&gt; Types::Standard::Int,
             constraint =&gt; sub {
               # in this sub we don't need to check that $_ is an Int
               # because the parent will take care of that!

               $_ % 2 == 0
             },
           );
         }

       The "add_type" method returns the type it just added, so it can be stored in a variable.

         my $Even = __PACKAGE__-&gt;add_type(...);

       This can be useful if you wish to use $Even as the parent type to some other type you're going to  define
       later.

       Here's a bigger worked example:

         package Example::Types {
           use Type::Library -base;
           use Types::Standard -types;
           use DateTime;

           # Type::Tiny::Class is a subclass of Type::Tiny for creating
           # InstanceOf-like types. It's kind of better though because
           # it does cool stuff like pass through $type-&gt;new(%args) to
           # the class's constructor.
           #
           my $dt = __PACKAGE__-&gt;add_type(
             Type::Tiny::Class-&gt;new(
               name    =&gt; 'Datetime',
               class   =&gt; 'DateTime',
             )
           );

           my $dth = __PACKAGE__-&gt;add_type(
             name    =&gt; 'DatetimeHash',
             parent  =&gt; Dict[
               year       =&gt; Int,
               month      =&gt; Optional[ Int ],
               day        =&gt; Optional[ Int ],
               hour       =&gt; Optional[ Int ],
               minute     =&gt; Optional[ Int ],
               second     =&gt; Optional[ Int ],
               nanosecond =&gt; Optional[ Int ],
               time_zone  =&gt; Optional[ Str ],
             ],
           );

           my $eph = __PACKAGE__-&gt;add_type(
             name    =&gt; 'EpochHash',
             parent  =&gt; Dict[ epoch =&gt; Int ],
           );

           # Can't just use "plus_coercions" method because that creates
           # a new anonymous child type to add the coercions to. We want
           # to add them to the type which exists in this library.
           #
           $dt-&gt;coercion-&gt;add_type_coercions(
             Int,    q{ DateTime-&gt;from_epoch(epoch =&gt; $_) },
             Undef,  q{ DateTime-&gt;now() },
             $dth,   q{ DateTime-&gt;new(%$_) },
             $eph,   q{ DateTime-&gt;from_epoch(%$_) },
           );

           __PACKAGE__-&gt;make_immutable;
         }

       "make_immutable" freezes to coercions of all the types in the package, so no outside code can tamper with
       the  coercions, and allows Type::Tiny to make optimizations to the coercions, knowing they won't later be
       altered. You should always do this at the end.

       The library will export types  <b>Datetime</b>,  <b>DatetimeHash</b>,  and  <b>EpochHash</b>.  The  <b>Datetime</b>  type  will  have
       coercions from <b>Int</b>, <b>Undef</b>, <b>DatetimeHash</b>, and <b>EpochHash</b>.

   <b>Extending</b> <b>Libraries</b>
       Type::Utils provides a helpful function "extends".

         package My::Types {
           use Type::Library -base;
           use Type::Utils qw( extends );

           BEGIN { extends("Types::Standard") };

           # define your own types here
         }

       The  "extends"  function (which you should usually use in a "BEGIN { }" block not only loads another type
       library, but it also adds all the types from it to your library.

       This means code using the above My::Types doesn't need to do:

         use Types::Standard qw( Str );
         use My::Types qw( Something );

       It can just do:

         use My::Types qw( Str Something );

       Because all the types from Types::Standard have been copied across into My::Types and are also  available
       there.

       "extends"  can  be  passed  a list of libraries; you can inherit from multiple existing libraries. It can
       also recognize and import types from MooseX::Types, MouseX::Types, and Specio::Exporter libraries.

       Since Type::Library 1.012, there has been a shortcut for "extends".

         package My::Types {
           use Type::Library -extends =&gt; [ 'Types::Standard' ];

           # define your own types here
         }

       The "-extends" flag takes an arrayref of type libraries to extend.  It automatically implies  "-base"  so
       you don't need to use both.

   <b>Custom</b> <b>Error</b> <b>Messages</b>
       A type constraint can have custom error messages. It's pretty simple:

         Type::Tiny-&gt;new(
           name       =&gt; 'EvenNumber',
           parent     =&gt; Types::Standard::Int,
           constraint =&gt; sub {
             # in this sub we don't need to check that $_ is an Int
             # because the parent will take care of that!

             $_ % 2 == 0
           },
           message   =&gt; sub {
             sprintf '%s is not an even number', Type::Tiny::_dd($_);
           },
         );

       The message coderef just takes a value in $_ and returns a string.  It may use Type::Tiny::_dd() as a way
       of  pretty-printing  a  value.   (Don't  be  put  off by the underscore in the function name. _dd() is an
       officially supported part of Type::Tiny's API now.)

       You don't have to use _dd(). You can generate any error string you like. But _dd()  will  help  you  make
       undef and the empty string look different, and will pretty-print references, and so on.

       There's  no  need  to  supply  an error message coderef unless you really want custom error messages. The
       default sub should be reasonable.

   <b>Inlining</b>
       In Perl, sub calls are relatively expensive in terms  of  memory  and  CPU  use.   The  <b>PositiveInt</b>  type
       inherits  from  <b>Int</b>  which  inherits  from  <b>Num</b> which inherits from <b>Str</b> which inherits from <b>Defined</b> which
       inherits from <b>Item</b> which inherits from <b>Any</b>.

       So you might think that to check of $value is a <b>PositiveInt</b>, it needs to be checked all the  way  up  the
       inheritance  chain.  But this is where one of Type::Tiny's big optimizations happens. Type::Tiny can glue
       together a bunch of checks with a stringy eval, and get a single coderef that can do all  the  checks  in
       one go.

       This  is  why  when Type::Tiny gives you a choice of using a coderef or a string of Perl code, you should
       usually choose the string of Perl code.  A single coderef can "break the chain".

       But these automatically generated strings of Perl code are not always as efficient as they could be.  For
       example, imagine that <b>HashRef</b> is defined as:

         my $Defined = Type::Tiny-&gt;new(
           name       =&gt; 'Defined',
           constraint =&gt; 'defined($_)',
         );
         my $Ref = Type::Tiny-&gt;new(
           name       =&gt; 'Ref',
           parent     =&gt; $Defined,
           constraint =&gt; 'ref($_)',
         );
         my $HashRef = Type::Tiny-&gt;new(
           name       =&gt; 'HashRef',
           parent     =&gt; $Ref,
           constraint =&gt; 'ref($_) eq "HASH"',
         );

       Then the combined check is:

         defined($_) and ref($_) and ref($_) eq "HASH"

       Actually in practice it's even more complicated, because Type::Tiny needs to localize and set $_ first.

       But in practice, the following should be a sufficient check:

         ref($_) eq "HASH"

       It is possible for the <b>HashRef</b> type to have more control over the string of code generated.

         my $HashRef = Type::Tiny-&gt;new(
           name       =&gt; 'HashRef',
           parent     =&gt; $Ref,
           constraint =&gt; 'ref($_) eq "HASH"',
           inlined    =&gt; sub {
             my $varname = pop;
             sprintf 'ref(%s) eq "HASH"', $varname;
           },
         );

       The  inlined  coderef  gets  passed  the  name  of  a  variable to check. This could be '$_' or '$var' or
       "$some{deep}{thing}[0]". Because it is passed the name of a variable to check, instead of always checking
       $_, this enables very efficient checking for parameterized types.

       Although in this case, the inlining coderef is just returning a string, technically it returns a list  of
       strings. If there's multiple strings, Type::Tiny will join them together in a big "&amp;&amp;" statement.

       As  a  special  case,  if  the  first item in the returned list of strings is undef, then Type::Tiny will
       substitute the parent type constraint's inlined string in its place. So  an  inlieing  coderef  for  even
       numbers might be:

         Type::Tiny-&gt;new(
           name       =&gt; 'EvenNumber',
           parent     =&gt; Types::Standard::Int,
           constraint =&gt; sub { $_ % 2 == 0 },
           inlined    =&gt; sub {
             my $varname = pop;
             return (undef, "$varname % 2 == 0");
           },
         );

       Even  if  you  provide  a  coderef  as  a  string, an inlining coderef has the potential to generate more
       efficient code, so you should consider providing one.

   <b>Pre-Declaring</b> <b>Types</b>
         use Type::Library -base,
           -declare =&gt; qw( Foo Bar Baz );

       This declares types <b>Foo</b>, <b>Bar</b>, and <b>Baz</b> at compile time so they can safely be used  as  barewords  in  your
       type library.

       This also allows recursively defined types to (mostly) work!

         use Type::Library -base,
           -declare =&gt; qw( NumericArrayRef );
         use Types::Standard qw( Num ArrayRef );

         __PACKAGE__-&gt;add_type(
           name     =&gt; NumericArrayRef,
           parent   =&gt; ArrayRef-&gt;of( Num | NumericArrayRef ),
         );

       (Support for recursive type definitions added in Type::Library 1.009_000.)

   <b>Parameterizable</b> <b>Types</b>
       This  is probably the most "meta" concept that is going to be covered.  Building your own type constraint
       that can be parameterized like <b>ArrayRef</b> or <b>HasMethods</b>.

       The type constraint we'll build will be <b>MultipleOf[$i]</b> which checks that an integer is a multiple of $i.

         __PACKAGE__-&gt;add_type(
           name       =&gt; 'MultipleOf',
           parent     =&gt; Int,

           # This coderef gets passed the contents of the square brackets.
           constraint_generator =&gt; sub {
             my $i = assert_Int(shift);
             # needs to return a coderef to use as a constraint for the
             # parameterized type
             return sub { $_ % $i == 0 };
           },

           # optional but recommended
           inline_generator =&gt; sub {
             my $i = shift;
             return sub {
               my $varname = pop;
               return (undef, "$varname % $i == 0");
             };
           },

           # probably the most complex bit
           coercion_generator =&gt; sub {
             my $i = $_[2];
             require Type::Coercion;
             return Type::Coercion-&gt;new(
               type_coercion_map =&gt; [
                 Num, qq{ int($i * int(\$_/$i)) }
               ],
             );
           },
         );

       Now we can define an even number like this:

         __PACKAGE__-&gt;add_type(
           name     =&gt; 'EvenNumber',
           parent   =&gt; __PACKAGE__-&gt;get_type('MultipleOf')-&gt;<a href="../man2/of.2.html">of</a>(2),
           coercion =&gt; 1,  # inherit from parent
         );

       Note that it is possible for a type constraint to have a "constraint" <u>and</u> a "constraint_generator".

         BaseType          # uses the constraint
         BaseType[]        # constraint_generator with no arguments
         BaseType[$x]      # constraint_generator with an argument

       In the  <b>MultipleOf</b>  example  above,  <b>MultipleOf[]</b>  with  no  number  would  throw  an  error  because  of
       assert_Int(shift) not finding an integer.

       But it is certainly possible for <b>BaseType[]</b> to be meaningful and distinct from "BaseType".

       For example, <b>Tuple</b> is just the same as <b>ArrayRef</b> and accepts any arrayref as being valid. But <b>Tuple[]</b> will
       only  accept  arrayrefs  with zero elements in them. (Just like <b>Tuple[Any,Any]</b> will only accept arrayrefs
       with two elements.)

</pre><h4><b>NEXT</b> <b>STEPS</b></h4><pre>
       After that last example, probably have a little lie down. Once you're recovered, here's your next step:

       •   Type::Tiny::Manual::UsingWithMoose

           How to use Type::Tiny  with  Moose,  including  the  advantages  of  Type::Tiny  over  built-in  type
           constraints, and Moose-specific features.

</pre><h4><b>AUTHOR</b></h4><pre>
       Toby Inkster &lt;<a href="mailto:tobyink@cpan.org">tobyink@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2013-2014, 2017-2023 by Toby Inkster.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTIES</b></h4><pre>
       THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  WITHOUT
       LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

perl v5.40.1                                       2025-05-06                 <u>Type::Tiny::Manual::<a href="../man3pm/Libraries.3pm.html">Libraries</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>