<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>qbrb.h - This implements a ring buffer that works in "chunks", not bytes.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libqb-dev">libqb-dev_2.0.8-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       qbrb.h - This implements a ring buffer that works in "chunks", not bytes.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;qb/qbrb.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       So  you  write/read  a  complete  chunk  or  not  at  all. There are two types of ring buffer: normal and
       overwrite. Overwrite will reclaim the oldest chunks inorder to make way for new ones, the normal  version
       will refuse to write a new chunk if the ring buffer is full.

       This implementation is capable of working across processes, but one process must only write and the other
       process read.

       The read process will do the following:

            rb = qb_rb_open("test2", 2000, QB_RB_FLAG_SHARED_PROCESS|QB_RB_FLAG_CREATE);
            for (i = 0; i &lt; 200; i++) {
       try_read_again:
               l = qb_rb_chunk_read(rb, (void *)out, 32, 1000);
               if (l &lt; 0) {
                       goto try_read_again;
               }
            }
            ...
            qb_rb_close(rb);

       The write process will do the following:

            rb = qb_rb_open("test2", 2000, QB_RB_FLAG_SHARED_PROCESS);
            for (i = 0; i &lt; 200; i++) {
       try_write_again:
               l = qb_rb_chunk_write(rb, &amp;v, sizeof(v));
               if (l &lt; sizeof(v)) {
                       goto try_write_again;
               }
            }
            ...
            qb_rb_close(rb);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/qb_rb_close.3.html">qb_rb_close</a></u>(3), <u><a href="../man3/qb_rb_refcount_get.3.html">qb_rb_refcount_get</a></u>(3), <u><a href="../man3/qb_rb_chmod.3.html">qb_rb_chmod</a></u>(3), <u><a href="../man3/qb_rb_chown.3.html">qb_rb_chown</a></u>(3), <u><a href="../man3/qb_rb_open.3.html">qb_rb_open</a></u>(3),
       <u><a href="../man3/qb_rb_write_to_file.3.html">qb_rb_write_to_file</a></u>(3), <u><a href="../man3/qb_rb_create_from_file.3.html">qb_rb_create_from_file</a></u>(3), <u><a href="../man3/qb_rb_chunks_used.3.html">qb_rb_chunks_used</a></u>(3), <u><a href="../man3/qb_rb_chunk_reclaim.3.html">qb_rb_chunk_reclaim</a></u>(3),
       <u><a href="../man3/qb_rb_space_used.3.html">qb_rb_space_used</a></u>(3), <u><a href="../man3/qb_rb_chunk_write.3.html">qb_rb_chunk_write</a></u>(3), <u><a href="../man3/qb_rb_shared_user_data_get.3.html">qb_rb_shared_user_data_get</a></u>(3), <u><a href="../man3/qb_rb_chunk_commit.3.html">qb_rb_chunk_commit</a></u>(3),
       <u><a href="../man3/qb_rb_chunk_peek.3.html">qb_rb_chunk_peek</a></u>(3), <u><a href="../man3/qb_rb_space_free.3.html">qb_rb_space_free</a></u>(3), <u><a href="../man3/qb_rb_name_get.3.html">qb_rb_name_get</a></u>(3), <u><a href="../man3/qb_rb_chunk_alloc.3.html">qb_rb_chunk_alloc</a></u>(3), <u><a href="../man3/qb_rb_chunk_read.3.html">qb_rb_chunk_read</a></u>(3)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2010-2020 Red Hat, Inc.

LIBQB                                              2023-07-21                                          <u><a href="../man3/QBRB.H.3.html">QBRB.H</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>