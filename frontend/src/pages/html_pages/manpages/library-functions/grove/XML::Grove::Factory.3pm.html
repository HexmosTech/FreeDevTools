<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Grove::Factory - simplify creation of XML::Grove objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-grove-perl">libxml-grove-perl_0.46alpha-14_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Grove::Factory - simplify creation of XML::Grove objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use XML::Grove::Factory;

        ### An object that creates Grove objects directly
        my $gf = XML::Grove::Factory-&gt;grove_factory;

        $grove = $gf-&gt;document( CONTENTS );
        $element = $gf-&gt;element( $name, { ATTRIBUTES }, CONTENTS );
        $pi = $gf-&gt;pi( $target, $data );
        $comment = $gf-&gt;comment( $data );

        ### An object that creates elements by method name
        my $ef = XML::Grove::Factory-&gt;element_factory();

        $element = $ef-&gt;NAME( { ATTRIBUTES }, CONTENTS);

        ### Similar to `element_factory', but creates functions in the
        ### current package
        XML::Grove::Factory-&gt;element_functions( PREFIX, ELEMENTS );

        $element = NAME( { ATTRIBUTES }, CONTENTS );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "XML::Grove::Factory" provides objects or defines functions that let you simply and quickly create the
       most commonly used XML::Grove objects.  "XML::Grove::Factory" supports three types of object creation.
       The first type is to create raw XML::Grove objects.  The second type creates XML elements by element
       name.  The third type is like the second, but defines local functions for you to call instead of using an
       object, which might save typing in some cases.

       The three types of factories can be mixed.  For example, you can use local functions for all element
       names that don't conflict with your own sub names or contain special characters, and then use a
       `"grove_factory()"' object for those elements that do conflict.

       In the examples that follow, each example is creating an XML instance similar to the following, assuming
       it's pretty printed:

           &lt;?xml version="1.0"?&gt;
           &lt;HTML&gt;
             &lt;HEAD&gt;
               &lt;TITLE&gt;Some Title&lt;/TITLE&gt;
             &lt;/HEAD&gt;
             &lt;BODY bgcolor="#FFFFFF"&gt;
               &lt;P&gt;A paragraph.&lt;/P&gt;
             &lt;/BODY&gt;
           &lt;/HTML&gt;

</pre><h4><b>GROVE</b> <b>FACTORY</b></h4><pre>
       $gf = XML::Grove::Factory-&gt;<b>grove_factory()</b>
           Creates a new grove factory object that creates raw XML::Grove objects.

       $gf-&gt;document( <u>CONTENTS</u> );
           Creates  an  XML::Grove::Document  object.   <u>CONTENTS</u>  may  contain  processing instructions, strings
           containing only whitespace characters, and a single  element  object  (but  note  that  there  is  no
           checking).  Strings are converted to XML::Grove::Characters objects.

       $gf-&gt;element($name, <u>CONTENTS</u>);
       $gf-&gt;element($name, { <u>ATTRIBUTES</u> }, <u>CONTENTS</u>);
           Creates an XML::Grove::Element object with the name `$name'.  If the argument following `$name' is an
           anonymous  hash,  <u>ATTRIBUTES</u>,  then they will be copied to the elements attributes.  <u>CONTENTS</u> will be
           stored in the element's content (note that there is no validity checking).  Strings in  <u>CONTENTS</u>  are
           converted to XML::Grove::Characters objects.

       $gf-&gt;pi( <u>TARGET</u>, <u>DATA</u>)
       $gf-&gt;pi( <u>DATA</u> )
           Create an XML::Grove::PI object with <u>TARGET</u> and <u>DATA</u>.

       $gf-&gt;comment( <u>DATA</u> )
           Create an XML::Grove::Comment object with <u>DATA</u>.

   <b>GROVE</b> <b>FACTORY</b> <b>EXAMPLE</b>
        use XML::Grove::Factory;

        $gf = XML::Grove::Factory-&gt;grove_factory;

        $element =
          $gf-&gt;element('HTML',
            $gf-&gt;element('HEAD',
              $gf-&gt;element('TITLE', 'Some Title')),
            $gf-&gt;element('BODY', { bgcolor =&gt; '#FFFFFF' },
              $gf-&gt;element('P', 'A paragraph.')));

</pre><h4><b>ELEMENT</b> <b>FACTORY</b></h4><pre>
       $ef = XML::Grove::Factory-&gt;<b>element_factory()</b>
           Creates  a  new  element factory object for creating elements.  `"element_factory()"' objects work by
           creating an element for any name used to call the object.

       $ef-&gt;<u>NAME</u>( <u>CONTENTS</u> )
       $ef-&gt;<u>NAME</u>( { <u>ATTRIBUTES</u> }, <u>CONTENTS</u>)
           Creates an XML::Grove::Element object with the  given  <u>NAME</u>,  <u>ATTRIBUTES</u>,  and  <u>CONTENTS</u>.   The  hash
           containing  <u>ATTRIBUTES</u>  is optional if this element doesn't need attributes.  Strings in <u>CONTENTS</u> are
           converted to XML::Grove::Characters objects.

   <b>ELEMENT</b> <b>FACTORY</b> <b>EXAMPLE</b>
        use XML::Grove::Factory;

        $ef = XML::Grove::Factory-&gt;element_factory();

        $element =
          $ef-&gt;HTML(
            $ef-&gt;HEAD(
              $ef-&gt;TITLE('Some Title')),
            $ef-&gt;BODY({ bgcolor =&gt; '#FFFFFF' },
              $ef-&gt;P('A paragraph.')));

</pre><h4><b>ELEMENT</b> <b>FUNCTIONS</b></h4><pre>
       XML::Grove::Factory-&gt;element_functions (PREFIX, ELEMENTS)
           Creates functions in the current package for creating elements with the names provided  in  the  list
           <u>ELEMENTS</u>.   <u>PREFIX</u> will be prepended to every function name, or <u>PREFIX</u> can be an empty string ('') if
           you're confident that there won't be any conflicts with functions in your package.

       <u>NAME</u>( <u>CONTENTS</u> )
       <u>NAME</u>( { <u>ATTRIBUTES</u> }, <u>CONTENTS</u> )
       <u>PREFIXNAME</u>( <u>CONTENTS</u> )
       <u>PREFIXNAME</u>( { <u>ATTRIBUTES</u> }, <u>CONTENTS</u> )
           Functions created for `"<u>NAME</u>"' or `"<u>PREFIXNAME</u>"' can be called to create XML::Grove::Element  objects
           with  the  given  <u>NAME</u>,  <u>ATTRIBUTES</u>, and <u>CONTENT</u>.  The hash containing <u>ATTRIBUTES</u> is optional if this
           element doesn't need attributes.  Strings in <u>CONTENT</u> are converted to XML::Grove::Characters objects.

   <b>ELEMENT</b> <b>FACTORY</b> <b>EXAMPLE</b>
        use XML::Grove::Factory;

        XML::Grove::Factory-&gt;element_functions('', qw{ HTML HEAD TITLE BODY P });

        $element =
          HTML(
            HEAD(
              TITLE('Some Title')),
            BODY({ bgcolor =&gt; '#FFFFFF' },
              P('A paragraph.')));

</pre><h4><b>AUTHOR</b></h4><pre>
       Ken MacLeod, <a href="mailto:ken@bitsko.slc.ut.us">ken@bitsko.slc.ut.us</a>

       Inspired by the HTML::AsSubs module by Gisle Aas.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b>XML::<a href="../man3/Grove.3.html">Grove</a></b>(3).

       Extensible Markup Language (XML) &lt;<a href="http://www.w3c.org/XML">http://www.w3c.org/XML</a>&gt;

perl v5.36.0                                       2022-11-29                           <u>XML::Grove::<a href="../man3pm/Factory.3pm.html">Factory</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>