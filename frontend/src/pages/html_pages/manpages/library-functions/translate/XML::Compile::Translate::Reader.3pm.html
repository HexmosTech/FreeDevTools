<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Compile::Translate::Reader - translate XML to HASH</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-compile-perl">libxml-compile-perl_1.64-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Compile::Translate::Reader - translate XML to HASH

</pre><h4><b>INHERITANCE</b></h4><pre>
        XML::Compile::Translate::Reader
          is a XML::Compile::Translate

</pre><h4><b>SYNOPSIS</b></h4><pre>
        my $schema = XML::Compile::Schema-&gt;new(...);
        my $code   = $schema-&gt;compile(READER =&gt; ...);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The translator understands schemas, but does not encode that into actions.  This module implements those
       actions to translate from XML into a (nested) Perl HASH structure.

       Extends "DESCRIPTION" in XML::Compile::Translate.

</pre><h4><b>METHODS</b></h4><pre>
       Extends "METHODS" in XML::Compile::Translate.

</pre><h4><b>DETAILS</b></h4><pre>
       Extends "DETAILS" in XML::Compile::Translate.

   <b>Translator</b> <b>options</b>
       Extends "Translator options" in XML::Compile::Translate.

   <b>Processing</b> <b>Wildcards</b>
       If you want to collect information from the XML structure, which is permitted by "any" and "anyAttribute"
       specifications in the schema, you have to implement that yourself.  The problem is "XML::Compile" has
       less knowledge than you about the possible data.

       <u>option</u> <u>any_attribute</u>

       By default, the "anyAttribute" specification is ignored.  When "TAKE_ALL" is given, all attributes which
       are fulfilling the name-space requirement added to the returned data-structure.  As key, the absolute
       element name will be used, with as value the related unparsed XML element.

       In the current implementation, if an explicit attribute is also covered by the name-spaces permitted by
       the anyAttribute definition, then it will also appear in that list (and hence the handler will be called
       as well).

       Use XML::Compile::Schema::compile(any_attribute) to write your own handler, to influence the behavior.
       The handler will be called for each attribute, and you must return list of pairs of derived information.
       When the returned is empty, the attribute data is lost.  The value may be a complex structure.

       <b>.</b> <b>Example:</b> <b>anyAttribute</b> <b>in</b> <b>a</b> <b>READER</b>

       Say your schema looks like this:

        &lt;schema targetNamespace="<a href="http://mine">http://mine</a>"
           xmlns:me="<a href="http://mine">http://mine</a>" ...&gt;
          &lt;element name="el"&gt;
            &lt;complexType&gt;
              &lt;attribute name="a" type="xs:int" /&gt;
              &lt;anyAttribute namespace="##targetNamespace"
                 processContents="lax"&gt;
            &lt;/complexType&gt;
          &lt;/element&gt;
          &lt;simpleType name="non-empty"&gt;
            &lt;restriction base="NCName" /&gt;
          &lt;/simpleType&gt;
        &lt;/schema&gt;

       Then, in an application, you write:

        my $r = $schema-&gt;compile
         ( READER =&gt; pack_type('<a href="http://mine">http://mine</a>', 'el')
         , anyAttribute =&gt; 'ALL'
         );
        # or lazy: READER =&gt; '{<a href="http://mine">http://mine</a>}el'

        my $h = $r-&gt;( &lt;&lt;'__XML' );
          &lt;el xmlns:me="<a href="http://mine">http://mine</a>"&gt;
            &lt;a&gt;42&lt;/a&gt;
            &lt;b type="me:non-empty"&gt;
               everything
            &lt;/b&gt;
          &lt;/el&gt;
        __XML

        use Data::Dumper 'Dumper';
        print Dumper $h;
        __XML__

       The output is something like

        $VAR1 =
         { a =&gt; 42
         , '{<a href="http://mine">http://mine</a>}a' =&gt; ... # XML::LibXML::Node with &lt;a&gt;42&lt;/a&gt;
         , '{<a href="http://mine">http://mine</a>}b' =&gt; ... # XML::LibXML::Node with &lt;b&gt;everything&lt;/b&gt;
         };

       You can improve the reader with a callback.  When you know that the extra attribute is always of type
       "non-empty", then you can do

        my $read = $schema-&gt;compile
         ( READER =&gt; '{<a href="http://mine">http://mine</a>}el'
         , anyAttribute =&gt; \&amp;filter
         );

        my $anyAttRead = $schema-&gt;compile
         ( READER =&gt; '{<a href="http://mine">http://mine</a>}non-empty'
         );

        sub filter($$$$)
        {   my ($fqn, $xml, $path, $translator) = @_;
            return () if $fqn ne '{<a href="http://mine">http://mine</a>}b';
            (b =&gt; $anyAttRead-&gt;($xml));
        }

        my $h = $r-&gt;( see above );
        print Dumper $h;

       Which will result in

        $VAR1 =
         { a =&gt; 42
         , b =&gt; 'everything'
         };

       The filter will be called twice, but return nothing in the first case.  You can implement any kind of
       complex processing in the filter.

       <u>option</u> <u>any_element</u>

       By default, the "any" definition in a schema will ignore all elements from the container which are not
       used.  Also in this case "TAKE_ALL" is required to produce "any" results.  "SKIP_ALL" will ignore all
       results, although this are being processed for validation needs.

       <u>option</u> <u>any_type</u> <u>CODE</u>

       By default, the elements which have type "xsd:anyType" will return an XML::LibXML::Element when there are
       sub-elements.  Otherwise, it will return the textual content.

       If you pass your own CODE reference, you can change this behavior.  It will get called with the path, the
       node, and the default handler.  Be awayre the $node may actually be a string already.

          $schema-&gt;compile(READER =&gt; ..., any_type =&gt; \&amp;handle_any_type);
          sub handle_any_type($$$)
          { my ($path, $node, $handler) = @_;
            ref $node or return $node;
            $node;
          }

   <b>Mixed</b> <b>elements</b>
       [available since 0.86] ComplexType and ComplexContent components can be declared with the
       "&lt;mixed="true""&gt; attribute.  This implies that text is not limited to the content of containers, but may
       also be used inbetween elements.  Usually, you will only find ignorable white-space between elements.

       In this example, the "a" container is marked to be mixed:
         &lt;a id="5"&gt; before &lt;b&gt;2&lt;/b&gt; after &lt;/a&gt;

       Often the "mixed" option is bending one of both ways: either the element is needed as text, or the
       element should be parsed and the text ignored.  The reader has various options to avoid the need of
       processing raw XML::LibXML nodes.

       [1.00] When the return is a HASH, that HASH will also contain the "_MIXED_ELEMENT_MODE" key, to help
       people understand what happens.  This is not possible for all modes, only for some.

       With XML::Compile::Schema::<a href="../manmixed_elements/compile.mixed_elements.html">compile</a>(mixed_elements) set to

       ATTRIBUTES  (the default)
           a HASH is returned, the attributes are processed.  The node is found as XML::LibXML::Element with the
           key '_'.  Above example will produce
             $r = { id =&gt; 5, _ =&gt; $xmlnode };

       TEXTUAL
           Like the previous, but now the textual representation of the content is returned with key '_'.  Above
           example will produce
             $r = { id =&gt; 5, _ =&gt; ' before 2 after '};

       STRUCTURAL
           will  remove  all  mixed-in  text,  and  treat  the  element  as normal element.  The example will be
           transformed into
             $r = { id =&gt; 5, b =&gt; 2 };

       XML_NODE
           return the XML::LibXML::Node itself.  The example:
             $r = $xmlnode;

       XML_STRING
           return the mixed node as XML string, just as in the source.  Be warned that it is  rather  expensive:
           the string was parsed and then stringified again, which is costly for large nodes.  Result:
             $r = '&lt;a id="5"&gt; before &lt;b&gt;2&lt;/b&gt; after &lt;/a&gt;';

       CODE reference
           the reference is called with the XML::LibXML::Node as first argument.  When a value is returned (even
           undef),  then the right tag with the value will be included in the translators result.  When an empty
           list is returned by the code reference, then nothing is returned (which may result in an error if the
           element is required according to the schema)

       When some of your mixed elements need different behavior from other elements, then you have  to  go  play
       with the normal hooks in specific cases.

   <b>Schema</b> <b>hooks</b>
       <u>hooks</u> <u>executed</u> <u>before</u> <u>the</u> <u>XML</u> <u>is</u> <u>being</u> <u>processed</u>

       The  "before"  hooks  receives an XML::LibXML::Node object and the path string.  It must return a new (or
       same) XML node which will be used from then on.  You probably can best  modify  a  node  clone,  not  the
       original as provided by the user.  When "undef" is returned, the whole node will disappear.

       This hook offers a predefined "PRINT_PATH".

       <b>.</b> <b>Example:</b> <b>to</b> <b>trace</b> <b>the</b> <b>paths</b>

        $schema-&gt;addHook
          ( action =&gt; 'READER'
          , path   =&gt; qr/./
          , before =&gt; 'PRINT_PATH'
          );

       <u>hooks</u> <u>executed</u> <u>as</u> <u>replacement</u>

       Your  "replace"  hook  should  return  a  list  of  key-value  pairs.  To  produce  it,  it  will get the
       XML::LibXML::Element, the translator settings as HASH, the path, and the localname.

       This hook has a predefined "SKIP", which will not process the found element, but simply return the string
       "SKIPPED" as value.  This way, a whole tree of unneeded translations can be avoided.

       [1.51] The predefined hook "XML_NODE" will not attempt to parse the selected  element,  but  returns  the
       XML::LibXML::Element node instead.  This may break on some schema-contained validations.

       Sometimes,  the  Schema spec is such a mess, that XML::Compile cannot automatically translate it.  I have
       seen cases where confusion over name-spaces is created: a choice between three  elements  with  the  same
       name but different types.  Well, in such case you may use XML::LibXML::Simple to translate a part of your
       tree.  Simply

        use XML::LibXML::Simple  qw/XMLin/;
        $schema-&gt;addHook
          ( action  =&gt; 'READER'
          , type    =&gt; 'tns:xyz'     # or pack_type($tns,'xyz')
         #  path    =&gt; qr!/company$! # by element name
          , replace =&gt;
              sub { my ($xml, $args, $path, $type, $r) = @_;
                    ($type =&gt; XMLin($xml, ...));
                  }
          );

       <u>hooks</u> <u>for</u> <u>post-processing,</u> <u>after</u> <u>the</u> <u>data</u> <u>is</u> <u>collected</u>

       Your code reference gets called with three parameters: the XML node, the data collected and the path.  Be
       careful  that the collected data might be a SCALAR (for simpleType).  Return a HASH or a SCALAR.  "undef"
       may work, unless it is the value of a required element you throw awy.

       This  hook  also  offers  a  predefined  "PRINT_PATH".   Besides,  it  has  "INCLUDE_PATH",   "XML_NODE",
       "NODE_TYPE",  "ELEMENT_ORDER", and "ATTRIBUTE_ORDER", which will result in additional fields in the HASH,
       respectively containing the NODE which was processed (an  XML::LibXML::Element),  the  type_of_node,  the
       element names, and the attribute names.  The keys start with an underscore "_".

   <b>Typemaps</b>
       In  a  typemap,  a  relation  between  an  XML  element  type and a Perl class (or object) is made.  Each
       translator back-end will implement this a little differently.  This  section  is  about  how  the  reader
       handles typemaps.

       <u>Typemap</u> <u>to</u> <u>Class</u>

       Usually,  an  XML type will be mapped on a Perl class.  The Perl class implements the "fromXML" method as
       constructor.

        $schema-&gt;addTypemaps($sometype =&gt; 'My::Perl::Class');

        package My::Perl::Class;
        ...
        sub fromXML
        {   my ($class, $data, $xmltype) = @_;
            my $self = $class-&gt;new($data);
            ...
            $self;
        }

       Your method returns the data which will be included in the result tree of the reader.  You may return  an
       object, the unmodified $data, or "undef".  When "undef" is returned, this may fail the schema parser when
       the data element is required.

       In the simpelest implementation, the class stores its data exactly as the XML structure:

        package My::Perl::Class;
        sub fromXML
        {   my ($class, $data, $xmltype) = @_;
            bless $data, $class;
        }

        # The same, even shorter:
        sub fromXML { bless $_[1], $_[0] }

       <u>Typemap</u> <u>to</u> <u>Object</u>

       Another  option is to implement an object factory: one object which creates other objects.  In this case,
       the $xmltype parameter can come of use, to have one object spawning many different other objects.

        my $object = My::Perl::Class-&gt;new(...);
        $schema-&gt;typemap($sometype =&gt; $object);

        package My::Perl::Class;
        sub fromXML
        {   my ($object, $xmltype, $data) = @_;
            return Some::Other::Class-&gt;new($data);
        }

       This object factory may be a very simple solution when you map XML onto objects which are not under  your
       control; where there is not way to add the "fromXML" method.

       <u>Typemap</u> <u>to</u> <u>CODE</u>

       The light version of an object factory works with CODE references.

        $schema-&gt;typemap($t1 =&gt; \&amp;myhandler);
        sub myhandler
        {   my ($backend, $data, $type) = @_;
            return My::Perl::Class-&gt;new($data)
                if $backend eq 'READER';
            $data;
        }

        # shorter
        $schema-&gt;typemap($t1 =&gt; sub {My::Perl::Class-&gt;new($_[1])} );

       <u>Typemap</u> <u>implementation</u>

       Internally,  the typemap is simply translated into an "after" hook for the specific type.  After the data
       was processed via the usual mechanism, the hook will call method "fromXML" on the  class  or  object  you
       specified  with  the  data  which  was read.  You may still use "before" and "replace" hooks, if you need
       them.

       Syntactic sugar:

         $schema-&gt;typemap($t1 =&gt; 'My::Package');
         $schema-&gt;typemap($t2 =&gt; $object);

       is comparible to

         $schema-&gt;typemap($t1 =&gt; sub {My::Package-&gt;fromXML(@_)});
         $schema-&gt;typemap($t2 =&gt; sub {$object-&gt;fromXML(@_)} );

       with some extra checks.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This module is part of XML-Compile distribution  version  1.64,  built  on  October  21,  2024.  Website:
       <u><a href="http://perl.overmeer.net/xml-compile/">http://perl.overmeer.net/xml-compile/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2006-2024 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.0                                       2024-10-27               <u>XML::Compile::Translate::<a href="../man3pm/Reader.3pm.html">Reader</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>