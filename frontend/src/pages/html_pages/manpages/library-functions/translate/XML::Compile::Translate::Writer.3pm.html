<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Compile::Translate::Writer - translate HASH to XML</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-compile-perl">libxml-compile-perl_1.64-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Compile::Translate::Writer - translate HASH to XML

</pre><h4><b>INHERITANCE</b></h4><pre>
        XML::Compile::Translate::Writer
          is a XML::Compile::Translate

</pre><h4><b>SYNOPSIS</b></h4><pre>
        my $schema = XML::Compile::Schema-&gt;new(...);
        my $code   = $schema-&gt;compile(WRITER =&gt; ...);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The translator understands schemas, but does not encode that into actions.  This module implements those
       actions to translate from a (nested) Perl HASH structure onto XML.

       Extends "DESCRIPTION" in XML::Compile::Translate.

</pre><h4><b>METHODS</b></h4><pre>
       Extends "METHODS" in XML::Compile::Translate.

</pre><h4><b>DETAILS</b></h4><pre>
       Extends "DETAILS" in XML::Compile::Translate.

   <b>Translator</b> <b>options</b>
       Extends "Translator options" in XML::Compile::Translate.

   <b>Processing</b> <b>Wildcards</b>
       Complex elements can define "any" (element) and "anyAttribute" components, with unpredictable content.
       In this case, you are quite on your own in processing those constructs.  The use of both schema
       components should be avoided: please specify your data-structures explicit by clean type extensions.

       The procedure for the WRITER is simple: add key-value pairs to your hash, in which the value is a fully
       prepared XML::LibXML::Attr or XML::LibXML::Element.  The keys have the form "{namespace}type".  The
       <u>namespace</u> component is important, because only spec conformant namespaces will be used. The elements and
       attributes are added in random order.

       <b>.</b> <b>Example:</b> <b>specify</b> <b>anyAttribute</b>

        use XML::Compile::Util qw/pack_type/;

        my $attr = $doc-&gt;createAttributeNS($somens, $sometype, 42);
        my $h = { a =&gt; 12     # normal element or attribute
                , "{$somens}$sometype"        =&gt; $attr # anyAttribute
                , pack_type($somens, $mytype) =&gt; $attr # nicer
                , "$prefix:$sometype"         =&gt; $attr # [1.28]
                };

   <b>Mixed</b> <b>elements</b>
       [0.79] ComplexType and ComplexContent components can be declared with the "&lt;mixed="true""&gt; attribute.

       XML::Compile does not have a way to express these mixtures of information and text as Perl data-
       structures; the only way you can use those to the full extend, is by juggling with XML::LibXML nodes
       yourself.

       You may provide a XML::LibXML::Element, which is complete, or a HASH which contains attributes values and
       an XML node with key '_'.  When '_' contains a string, it will be translated into an XML text node.

       XML::Compile::Schema::<a href="../manmixed_elements/compile.mixed_elements.html">compile</a>(mixed_elements) can be set to

       ATTRIBUTES (default)
           Add  attributes  to  the  provided  node.   When you provide a HASH, it is taken as node content with
           attributes.  The content has to be stored with key '_'.  When it is not a  HASH,  the  data  is  node
           content.

           There  are  various  ways  you  can  specify  content.   Up to [1.51], you could only pass a matching
           XML::LibXML::Element.  Release [1.51] added strings to the spectrum.  If the string does not  contain
           encoded  entities  or &lt; and &gt;, then it is assumed to be a real perl string.  When the string contains
           an XML fragment which has the same localname as to be created, that  will  be  used.   When  the  XML
           fragment is not wrapped in the expected node, this is created for you.

           In any case, attributes provided with the content will get added to the content data.

       STRUCTURAL
           [0.89] behaves as if the attribute is not there: a data-structure can be used or an XML node.

   <b>Schema</b> <b>hooks</b>
       All writer hooks behave differently.  Be warned that the user values can be a SCALAR or a HASH, dependent
       on the type.  You can intervene on higher data-structure levels, to repair lower levels, if you want to.

       [1.48]  The  hooks  get  a  long list of parameters.  The $fulltype indicates the type of object which is
       being processed, which is especially useful with the 'extends' selector.

       <u>hooks</u> <u>executed</u> <u>before</u> <u>normal</u> <u>processing</u>

       The "before" hook gives you the opportunity to fix the user supplied data structure.  The  XML  generator
       will complain about missing, superfluous, and erroneous values which you probably want to avoid.

       The "before" hook returns new values.  Just must not interfere with the user provided data.  When "undef"
       is returned, the whole node will be cancelled.

       On the moment, the only predefined "before" hook is "PRINT_PATH".

       <b>.</b> <b>Example:</b> <b>before</b> <b>hook</b> <b>on</b> <b>user-provided</b> <b>HASH.</b>

        sub beforeOnComplex($$$$)
        {   my ($doc, $values, $path, $fulltype) = @_;

            my %copy = %$values;
            $copy{extra} = 42;
            delete $copy{superfluous};
            $copy{count} =~ s/\D//g;    # only digits
            \%copy;
        }

       <b>.</b> <b>Example:</b> <b>before</b> <b>hook</b> <b>on</b> <b>simpleType</b> <b>data</b>

        sub beforeOnSimple($$$$)
        {   my ($doc, $value, $path, $fulltype) = @_;
            $value * 100;    # convert euro to euro-cents
        }

       <b>.</b> <b>Example:</b> <b>before</b> <b>hook</b> <b>with</b> <b>object</b> <b>for</b> <b>complexType</b>

        sub beforeOnObject($$$$)
        {   my ($doc, $obj, $path, $fulltype) = @_;

            +{ name     =&gt; $obj-&gt;name
             , price    =&gt; $obj-&gt;euro
             , currency =&gt; 'EUR'
             };
        }

       <u>hooks</u> <u>replacing</u> <u>the</u> <u>usual</u> <u>XML</u> <u>node</u> <u>generation</u>

       Only  one  "replace"  hook can be defined.  It must return a XML::LibXML::Node or "undef".  The hook must
       use the "XML::LibXML::Document" node (which is provided as first argument) to create a node.

       As parameters, the called replace function will receive the document, user-provided values,  location  in
       the data tree (for error messages), the tag of the node with prefix attached, and a reference to the code
       which would be executed if the replace hook had not been active.

       On the moment, the only predefined "replace" hook is "SKIP".

       <b>.</b> <b>Example:</b> <b>replace</b> <b>hook</b>

        sub replace($$$$$)
        {  my ($doc, $values, $path, $tag, $r, $fulltype) = @_
           my $node = $doc-&gt;createElement($tag);
           $node-&gt;appendText($values-&gt;{text});
           $node;
        }

       <u>hooks</u> <u>executed</u> <u>after</u> <u>the</u> <u>node</u> <u>was</u> <u>created</u>

       The  "after"  hooks,  will each get a chance to modify the produced XML node, for instance to encapsulate
       it.  Each time, the new XML node has to be returned.

       On the moment, the only predefined "after" hook is "PRINT_PATH".

       <b>.</b> <b>Example:</b> <b>add</b> <b>an</b> <b>extra</b> <b>sibbling</b> <b>after</b> <b>the</b> <b>usual</b> <b>process</b>

        sub after($$$$)
        {   my ($doc, $node, $path, $values, $fulltype) = @_;
            my $child = $doc-&gt;createAttributeNS($myns, earth =&gt; 42);
            $node-&gt;addChild($child);
            $node;
        }

       <u>fixing</u> <u>bad</u> <u>schemas</u>

       When a schema makes a mess out of things, we can fix that with hooks.  Also, when you  need  things  that
       XML::Compile does not support (yet).

       <b>.</b> <b>Example:</b> <b>creating</b> <b>nodes</b> <b>with</b> <b>text</b>

        {  my $text;

           sub before($$$)
           {   my ($doc, $values, $path) = @_;
               my %copy = %$values;
               $text = delete $copy{text};
               \%copy;
           }

           sub after($$$)
           {   my ($doc, $node, $path) = @_;
               $node-&gt;addChild($doc-&gt;createTextNode($text));
               $node;
           }

           $schema-&gt;addHook
            ( action =&gt; 'WRITER'
            , type   =&gt; 'mixed'
            , before =&gt; \&amp;before
            , after  =&gt; \&amp;after
            );
        }

   <b>Typemaps</b>
       In  a  typemap,  a  relation  between  an  XML  element  type and a Perl class (or object) is made.  Each
       translator back-end will implement this a little differently.  This  section  is  about  how  the  writer
       handles typemaps.

       <u>Typemap</u> <u>to</u> <u>Class</u>

       Usually,  an  XML  type  will be mapped on a Perl class.  The Perl class implements the "toXML" method as
       serializer.  That method should either return a data structure which fits that of the specific  type,  or
       an XML::LibXML::Element.

       When  translating  the  data-structure  to XML, the process may encounter objects.  Only if these objects
       appear at locations where a typemap is defined, they are treated smartly.  When some other data  than  an
       objects  is  found  on  a  location  which has a typemap definition, it will be used as such; objects are
       optional.

       The object (if present) will be checked to be of the expected class.  It will  be  a  compile-time  error
       when the class does not implement the "toXML" method.

        $schema-&gt;typemap($sometype =&gt; 'My::Perl::Class');

        package My::Perl::Class;
        ...
        sub toXML
        {   my ($self, $xmltype, $doc) = @_;
            ...
            { a =&gt; { b =&gt; 42 }, c =&gt; 'aaa' };
        }

       The  $self  is  the  object found in the data-structure provided by the user.  $doc can be used to create
       your own XML::LibXML::Element.  It is possible to use the same object on locations for  different  types:
       in this case, the toXML method can distiguisk what kind of data to return based on the $xmltype.

       <u>Typemap</u> <u>to</u> <u>Object</u>

       In  this  case, some helper object arranges the serialization of the provided object.  This is especially
       useful when the provided object does not have the toXML  implemented,  for  instance  because  it  is  an
       implementation not under your control.  The helper object works like an interface.

        my $object = My::Perl::Class-&gt;new(...);
        $schema-&gt;typemap($sometype =&gt; $object);

        package My::Perl::Class;
        sub toXML
        {   my ($self, $object, $xmltype, $doc) = @_;
            ...
        }

       The  toXML  will only be called then $object is blessed.  If you wish to have access to some data-type in
       any case, then use a simple "before" hook.

       <u>Typemap</u> <u>to</u> <u>CODE</u>

       The light version of an interface object uses CODE references.  The CODE reference is only  called  if  a
       blessed  value  is  found  in  the  user provided data.  It cannot be checked automatically whether it is
       blessed according to the expectation.

        $schema-&gt;typemap($t1 =&gt; \&amp;myhandler);

        sub myhandler
        {   my ($backend, $object, $xmltype, $doc) = @_;
            ...
        }

       <u>Typemap</u> <u>implementation</u>

       The typemap for the writer is implemented as a 'before' hook: just before the writer wants to start.

       Of course, it could have been implemented by accepting an object anywhere in the  input  data.   However,
       this  would  mean  that  all the (many) internal parser constructs would need to be extended.  That would
       slow-down the writer considerably.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This module is part of XML-Compile distribution  version  1.64,  built  on  October  21,  2024.  Website:
       <u><a href="http://perl.overmeer.net/xml-compile/">http://perl.overmeer.net/xml-compile/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2006-2024 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.0                                       2024-10-27               <u>XML::Compile::Translate::<a href="../man3pm/Writer.3pm.html">Writer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>