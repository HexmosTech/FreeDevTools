<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convert::TNEF - Perl module to read TNEF files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconvert-tnef-perl">libconvert-tnef-perl_0.18-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
        Convert::TNEF - Perl module to read TNEF files

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Convert::TNEF;

        $tnef = Convert::TNEF-&gt;read($iohandle, \%parms)
         or die Convert::TNEF::errstr;

        $tnef = Convert::TNEF-&gt;read_in($filename, \%parms)
         or die Convert::TNEF::errstr;

        $tnef = Convert::TNEF-&gt;read_ent($mime_entity, \%parms)
         or die Convert::TNEF::errstr;

        $tnef-&gt;purge;

        $message = $tnef-&gt;message;

        @attachments = $tnef-&gt;attachments;

        $attribute_value      = $attachments[$i]-&gt;data($att_attribute_name);
        $attribute_value_size = $attachments[$i]-&gt;size($att_attribute_name);
        $attachment_name = $attachments[$i]-&gt;name;
        $long_attachment_name = $attachments[$i]-&gt;longname;

        $datahandle = $attachments[$i]-&gt;datahandle($att_attribute_name);

</pre><h4><b>DESCRIPTION</b></h4><pre>
        TNEF stands for Transport Neutral Encapsulation Format, and if you've
        ever been unfortunate enough to receive one of these files as an email
        attachment, you may want to use this module.

        read() takes as its first argument any file handle open
        for reading. The optional second argument is a hash reference
        which contains one or more of the following keys:

        output_dir - Path for storing TNEF attribute data kept in files
        (default: current directory).

        output_prefix - File prefix for TNEF attribute data kept in files
        (default: 'tnef').

        output_to_core - TNEF attribute data will be saved in core memory unless
        it is greater than this many bytes (default: 4096). May also be set to
        'NONE' to keep all data in files, or 'ALL' to keep all data in core.

        buffer_size - Buffer size for reading in the TNEF file (default: 1024).

        debug - If true, outputs all sorts of info about what the read() function
        is reading, including the raw ascii data along with the data converted
        to hex (default: false).

        display_after_err - If debug is true and an error is encountered,
        reads and displays this many bytes of data following the error
        (default: 32).

        debug_max_display - If debug is true then read and display at most
        this many bytes of data for each TNEF attribute (default: 1024).

        debug_max_line_size - If debug is true then at most this many bytes of
        data will be displayed on each line for each TNEF attribute
        (default: 64).

        ignore_checksum - If true, will ignore checksum errors while parsing
        data (default: false).

        read() returns an object containing the TNEF 'attributes' read from the
        file and the data for those attributes. If all you want are the
        attachments, then this is mostly garbage, but if you're interested then
        you can see all the garbage by turning on debugging. If the garbage
        proves useful to you, then let me know how I can maybe make it more
        useful.

        If an error is encountered, an undefined value is returned and the
        package variable $errstr is set to some helpful message.

        read_in() is a convienient front end for read() which takes a filename
        instead of a handle.

        read_ent() is another convient front end for read() which can take a
        MIME::Entity object (or any object with like methods, specifically
        open("r"), read($buff,$num_bytes), and close ).

        purge() deletes any on-disk data that may be in the attachments of
        the TNEF object.

        message() returns the message portion of the tnef object, if any.
        The thing it returns is like an attachment, but its not an attachment.
        For instance, it more than likely does not have a name or any
        attachment data.

        attachments() returns a list of the attachments that the given TNEF
        object contains. Returns a list ref if not called in array context.

        data() takes a TNEF attribute name, and returns a string value for that
        attribute for that attachment. Its your own problem if the string is too
        big for memory. If no argument is given, then the 'AttachData' attribute
        is assumed, which is probably the attachment data you're looking for.

        name() is the same as data(), except the attribute 'AttachTitle' is
        the default, which returns the 8 character + 3 character extension name
        of the attachment.

        longname() returns the long filename and extension of an attachment. This
        is embedded within a MAPI property of the 'Attachment' attribute data, so
        we attempt to extract the name out of that.

        size() takes an TNEF attribute name, and returns the size in bytes for
        the data for that attachment attribute.

        datahandle() is a method for attachments which takes a TNEF attribute
        name, and returns the data for that attribute as a handle which is
        the same as a MIME::Body handle.  See MIME::Body for all the applicable
        methods. If no argument is given, then 'AttachData' is assumed.

</pre><h4><b>EXAMPLES</b></h4><pre>
        # Here's a rather long example where mail is retrieved
        # from a POP3 server based on header information, then
        # it is MIME parsed, and then the TNEF contents
        # are extracted and converted.

        use strict;
        use Net::POP3;
        use MIME::Parser;
        use Convert::TNEF;

        my $mail_dir = "mailout";
        my $mail_prefix = "mail";

        my $pop = new Net::POP3 ( "pop3server_name" );
        my $num_msgs = $pop-&gt;login("user_name","password");
        die "Can't login: $!" unless defined $num_msgs;

        # Get mail by sender and subject
        my $mail_out_idx = 0;
        MESSAGE: for ( my $i=1; $i&lt;= $num_msgs;  $i++ ) {
         my $header = join "", @{$pop-&gt;top($i)};

         for ($header) {
          next MESSAGE unless
           /^from:.*someone\@somewhere.net/im &amp;&amp;
           /^subject:\s*important stuff/im
         }

         my $fname = $mail_prefix."-".$$.++$mail_out_idx.".doc";
         open (MAILOUT, "&gt;$mail_dir/$fname")
          or die "Can't open $mail_dir/$fname: $!";
         # If the get() complains, you need the new libnet bundle
         $pop-&gt;get($i, \*MAILOUT) or die "Can't read mail";
         close MAILOUT or die "Error closing $mail_dir/$fname";
         # If you want to delete the mail on the server
         # $pop-&gt;delete($i);
        }

        close MAILOUT;
        $pop-&gt;quit();

        # Parse the mail message into separate mime entities
        my $parser=new MIME::Parser;
        $parser-&gt;output_dir("mimemail");

        opendir(DIR, $mail_dir) or die "Can't open directory $mail_dir: $!";
        my @files = map { $mail_dir."/".$_ } sort
         grep { -f "$mail_dir/$_" and /$mail_prefix-$$-/o } readdir DIR;
        closedir DIR;

        for my $file ( @files ) {
         my $entity=$parser-&gt;parse_in($file) or die "Couldn't parse mail";
         print_tnef_parts($entity);
         # If you want to delete the working files
         # $entity-&gt;purge;
        }

        sub print_tnef_parts {
         my $ent = shift;

         if ( $ent-&gt;parts ) {
          for my $sub_ent ( $ent-&gt;parts ) {
           print_tnef_parts($sub_ent);
          }
         } elsif ( $ent-&gt;mime_type =~ /ms-tnef/i ) {

          # Create a tnef object
          my $tnef = Convert::TNEF-&gt;read_ent($ent,{output_dir=&gt;"tnefmail"})
           or die $Convert::TNEF::errstr;
          for ($tnef-&gt;attachments) {
           print "Title:",$_-&gt;name,"\n";
           print "Data:\n",$_-&gt;data,"\n";
          }

          # If you want to delete the working files
          # $tnef-&gt;purge;
         }
        }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b>IO::<a href="../man3/Wrap.3.html">Wrap</a></b>(3), <b>MIME::<a href="../man3/Parser.3.html">Parser</a></b>(3), <b>MIME::<a href="../man3/Entity.3.html">Entity</a></b>(3), <b>MIME::<a href="../man3/Body.3.html">Body</a></b>(3)

</pre><h4><b>CAVEATS</b></h4><pre>
        The parsing may depend on the endianness (see perlport) and width of
        integers on the system where the TNEF file was created. If this proves
        to be the case (check the debug output), I'll see what I can do
        about it.

</pre><h4><b>AUTHOR</b></h4><pre>
        Douglas Wilson, <a href="mailto:dougw@cpan.org">dougw@cpan.org</a>

perl v5.40.1                                       2025-07-21                                          <u><a href="../man3pm/TNEF.3pm.html">TNEF</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>