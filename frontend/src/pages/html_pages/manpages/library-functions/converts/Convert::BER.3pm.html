<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convert::BER - ASN.1 Basic Encoding Rules</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconvert-ber-perl">libconvert-ber-perl_1.3200-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Convert::BER - ASN.1 Basic Encoding Rules

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Convert::BER;

           $ber = new Convert::BER;

           $ber-&gt;encode(
               INTEGER =&gt; 1,
               SEQUENCE =&gt; [
                   BOOLEAN =&gt; 0,
                   STRING =&gt; "Hello",
               ],
               REAL =&gt; 3.7,
           );

           $ber-&gt;decode(
               INTEGER =&gt; \$i,
               SEQUENCE =&gt; [
                   BOOLEAN =&gt; \$b,
                   STRING =&gt; \$s,
               ],
               REAL =&gt; \$r,
           );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>WARNING</b> this module is no longer supported, See Convert::ASN1

       "Convert::BER" provides an OO interface to encoding and decoding data using the ASN.1 Basic Encoding
       Rules (BER), a platform independent way of encoding structured binary data together with the structure.

</pre><h4><b>METHODS</b></h4><pre>
       new
       new ( BUFFER )
       new ( opList )
           "new" creates a new "Convert::BER" object.

       encode ( opList )
           Encode data in <u>opList</u> appending to the data in the buffer.

       decode ( opList )
           Decode  the  data  in  the  buffer as described by <u>opList</u>, starting where the last decode finished or
           position set by "pos".

       buffer ( [ BUFFER ] )
           Return the buffer contents. If <u>BUFFER</u> is specified set the buffer contents and reset pos to zero.

       pos ( [ POS ] )
           Without any arguments "pos" returns the offset where the last decode finished, or the last offset set
           by "pos". If <u>POS</u> is specified then <u>POS</u> will be where the next decode starts.

       tag ( )
           Returns the tag at the current position in the buffer.

       length ( )
           Returns the length of the buffer.

       error ( )
           Returns the error message associated with the last method, if any. This value  is  not  automatically
           reset. If "encode" or "decode" returns undef, check this.

       dump ( [ FH ] )
           Dump  the buffer to the filehandle "FH", or STDERR if not specified. The output contains the hex dump
           of each element, and an ASN.1-like text representation of that element.

       hexdump  ( [ FH ] )
           Dump the buffer to the filehandle "FH", or STDERR if not  specified.  The  output  is  hex  with  the
           possibly-printable text alongside.

</pre><h4><b>IO</b> <b>METHODS</b></h4><pre>
       read ( IO )
       write ( IO )
       recv ( SOCK )
       send ( SOCK [, ADDR ] )

</pre><h4><b>OPLIST</b></h4><pre>
       An  <u>opList</u>  is  a  list  of  <u>operator</u>-<u>value</u>  pairs. An operator can be any of those defined below, or any
       defined by sub-classing "Convert::BER", which will probably be derived from the primitives given here.

       The <u>value</u>s depend on whether BER is being encoded or decoded:

       Encoding
           If the <u>value</u> is a scalar, just encode it. If the <u>value</u> is a reference to a  list,  then  encode  each
           item  in  the  list in turn. If the <u>value</u> is a code reference, then execute the code. If the returned
           value is a scalar, encode that value. If the returned value is a reference to  a  list,  encode  each
           item in the list in turn.

       Decoding
           If  the  <u>value</u>  is  a  reference  to  a  scalar,  decode the value into the scalar. If the <u>value</u> is a
           reference to a list, then decode all the items of this type into the list. Note that there must be at
           least one item to decode, otherwise the decode will fail. If the <u>value</u>  is  a  code  reference,  then
           execute the code and decode the value into the reference returned from the evaluated code.

</pre><h4><b>PRIMITIVE</b> <b>OPERATORS</b></h4><pre>
       These operators encode and decode the basic primitive types defined by BER.

   <b>BOOLEAN</b>
       A BOOLEAN value is either true or false.

       Encoding
           The <u>value</u> is tested for boolean truth, and encoded appropriately.

               # Encode a TRUE value
               $ber-&gt;encode(
                   BOOLEAN =&gt; 1,
               ) or die;

       Decoding
           The decoded <u>value</u>s will be either 1 or 0.

               # Decode a boolean value into $bval
               $ber-&gt;decode(
                   BOOLEAN =&gt; \$bval,
               ) or die;

   <b>INTEGER</b>
       An  INTEGER  value  is  either  a positive whole number, or a negative whole number, or zero. Numbers can
       either be native perl integers, or values of the "Math::BigInt" class.

       Encoding
           The <u>value</u> is the integer value to be encoded.

               $ber-&gt;encode(
                   INTEGER =&gt; -123456,
               ) or die;

       Decoding
           The <u>value</u> will be the decoded integer value.

               $ber-&gt;decode(
                   INTEGER =&gt; \$ival,
               ) or die;

   <b>STRING</b>
       This is an OCTET STRING, which is an arbitrarily long binary value.

       Encoding
           The <u>value</u> contains the binary value to be encoded.

               $ber-&gt;encode(
                   STRING =&gt; "\xC0First character is hex C0",
               ) or die;

       Decoding
           The <u>value</u> will be the binary bytes.

               $ber-&gt;decode(
                   STRING =&gt; \$sval,
               ) or die;

   <b>NULL</b>
       There is no value for NULL. You often use NULL in ASN.1 when you want to denote that  something  else  is
       absent rather than just not encoding the 'something else'.

       Encoding
           The <u>value</u>s are ignored, but must be present.

               $ber-&gt;encode(
                   NULL =&gt; undef,
               ) or die;

       Decoding
           Dummy values are stored in the returned <u>value</u>s, as though they were present in the encoding.

               $ber-&gt;decode(
                   NULL =&gt; \$nval,
               ) or die;

   <b>OBJECT_ID</b>
       An  OBJECT_ID  value  is  an  OBJECT IDENTIFIER (also called an OID). This is a hierarchically structured
       value that is used in protocols to uniquely identify something. For example,  SNMP  (the  Simple  Network
       Management  Protocol)  uses  OIDs  to  denote  the information being requested, and LDAP (the Lightweight
       Directory Access Protocol, RFC 2251) uses OIDs to denote each attribute in a directory entry.

       Each level of the OID hierarchy is either zero or a positive integer.

       Encoding
           The <u>value</u> should be a dotted-decimal representation of the OID.

               $ber-&gt;encode(
                   OBJECT_ID =&gt; '2.5.4.0', # LDAP objectClass
               ) or die;

       Decoding
           The <u>value</u> will be the dotted-decimal representation of the OID.

               $ber-&gt;decode(
                   OBJECT_ID =&gt; \$oval,
               ) or die;

   <b>ENUM</b>
       The ENUMERATED type is effectively the same as the INTEGER type. It exists so that friendly names can  be
       assigned to certain integer values. To be useful, you should sub-class this operator.

   <b>BIT_STRING</b>
       The BIT STRING type is an arbitrarily long string of bits - 0's and 1's.

       Encoding
           The  <u>value</u>  is  a  string of arbitrary 0 and 1 characters. As these are packed into 8-bit octets when
           encoding and there may not be a multiple of 8 bits to be encoded, trailing padding bits are added  in
           the encoding.

               $ber-&gt;encode(
                   BIT_STRING =&gt; '0011',
               ) or die;

       Decoding
           The  <u>value</u>  will  be  a string of 0 and 1 characters. The string will have the same number of bits as
           were encoded (the padding bits are ignored.)

               $ber-&gt;decode(
                   BIT_STRING =&gt; \$bval,
               ) or die;

   <b>BIT_STRING8</b>
       This is a variation of the BIT_STRING operator, which is optimized for  writing  bit  strings  which  are
       multiples  of  8-bits  in  length.  You  can  use  the BIT_STRING operator to decode BER encoded with the
       BIT_STRING8 operator (and vice-versa.)

       Encoding
           The <u>value</u> should be the packed bits to encode, <b>not</b> a string of 0 and 1 characters.

               $ber-&gt;encode(
                   BIT_STRING8 =&gt; pack('B8', '10110101'),
               ) or die;

       Decoding
           The <u>value</u> will be the decoded packed bits.

               $ber-&gt;decode(
                   BIT_STRING8 =&gt; \$bval,
               ) or die;

   <b>REAL</b>
       The REAL type encodes an floating-point number. It requires the POSIX module.

       Encoding
           The <u>value</u> should be the number to encode.

               $ber-&gt;encode(
                   REAL =&gt; 3.14159265358979,
               ) or die;

       Decoding
           The <u>value</u> will be the decoded floating-point value.

               $ber-&gt;decode(
                   REAL =&gt; \$rval,
               );

   <b>ObjectDescriptor</b>
       The ObjectDescriptor type encodes an ObjectDescriptor string. It is a sub-class of "STRING".

   <b>UTF8String</b>
       The UTF8String type encodes a string encoded in UTF-8. It is a sub-class of "STRING".

   <b>NumericString</b>
       The NumericString type encodes a NumericString, which is defined to only contain the characters  0-9  and
       space. It is a sub-class of "STRING".

   <b>PrintableString</b>
       The  PrintableString type encodes a PrintableString, which is defined to only contain the characters A-Z,
       a-z, 0-9, space, and the punctuation characters ()-+=:',./?. It is a sub-class of "STRING".

   <b>TeletexString/T61String</b>
       The TeletexString type encodes a TeletexString, which is a string containing characters according to  the
       T.61 character set. Each T.61 character may be one or more bytes wide. It is a sub-class of "STRING".

       T61String is an alternative name for TeletexString.

   <b>VideotexString</b>
       The VideotexString type encodes a VideotexString, which is a string. It is a sub-class of "STRING".

   <b>IA5String</b>
       The  IA5String type encodes an IA5String. IA5 (International Alphabet 5) is equivalent to US-ASCII. It is
       a sub-class of "STRING".

   <b>UTCTime</b>
       The UTCTime type encodes a UTCTime value. Note this value only represents years using two digits,  so  it
       is not recommended in Y2K-compliant applications. It is a sub-class of "STRING".

       UTCTime values must be strings like:

           yymmddHHMM[SS]Z
       or:
           yymmddHHMM[SS]sHHMM

       Where  yy  is the year, mm is the month (01-12), dd is the day (01-31), HH is the hour (00-23), MM is the
       minutes (00-60). SS is the optional seconds (00-61).

       The time is either terminated by the literal character  Z,  or  a  timezone  offset.  The  "Z"  character
       indicates Zulu time or UTC. The timezone offset specifies the sign s, which is + or -, and the difference
       in hours and minutes.

   <b>GeneralizedTime</b>
       The  GeneralizedTime  type  encodes a GeneralizedTime value. Unlike "UTCTime" it represents years using 4
       digits, so is Y2K-compliant. It is a sub-class of "STRING".

       GeneralizedTime values must be strings like:

           yyyymmddHHMM[SS][.U][Z]
       or:
           yyyymmddHHMM[SS][.U]sHHMM

       Where yyyy is the year, mm is the month (01-12), dd is the day (01-31), HH is the hour (00-23), MM is the
       minutes (00-60). SS is the optional seconds (00-61). U is the optional fractional seconds value; a  comma
       is permitted instead of a dot before this value.

       The  time may be terminated by the literal character Z, or a timezone offset. The "Z" character indicates
       Zulu time or UTC. The timezone offset specifies the sign s, which is + or -, and the difference in  hours
       and minutes. If there is timezone specified UTC is assumed.

   <b>GraphicString</b>
       The GraphicString type encodes a GraphicString value. It is a sub-class of "STRING".

   <b>VisibleString/ISO646String</b>
       The VisibleString type encodes a VisibleString value, which is a value using the ISO646 character set. It
       is a sub-class of "STRING".

       ISO646String is an alternative name for VisibleString.

   <b>GeneralString</b>
       The GeneralString type encodes a GeneralString value. It is a sub-class of "STRING".

   <b>UniversalString/CharacterString</b>
       The  UniveralString  type  encodes  a UniveralString value, which is a value using the ISO10646 character
       set. Each character in ISO10646 is 4-bytes wide. It is a sub-class of "STRING".

       CharacterString is an alternative name for UniversalString.

   <b>BMPString</b>
       The BMPString type encodes a BMPString value, which is a value using  the  Unicode  character  set.  Each
       character in the Unicode character set is 2-bytes wide. It is a sub-class of "STRING".

</pre><h4><b>CONSTRUCTED</b> <b>OPERATORS</b></h4><pre>
       These  operators  are  used to build constructed types, which contain values in different types, like a C
       structure.

   <b>SEQUENCE</b>
       A SEQUENCE is a complex type that contains other types, a bit like  a  C  structure.  Elements  inside  a
       SEQUENCE are encoded and decoded in the order given.

       Encoding
           The  <u>value</u>  should  be  a  reference to an array containing another <u>opList</u> which defines the elements
           inside the SEQUENCE.

               $ber-&gt;encode(
                   SEQUENCE =&gt; [
                       INTEGER =&gt; 123,
                       BOOLEAN =&gt; [ 1, 0 ],
                   ]
               ) or die;

       Decoding
           The <u>value</u> should a reference to an array that contains the <u>opList</u> which decodes the contents  of  the
           SEQUENCE.

               $ber-&gt;decode(
                   SEQUENCE =&gt; [
                       INTEGER =&gt; \$ival,
                       BOOLEAN =&gt; \@bvals,
                   ]
               ) or die;

   <b>SET</b>
       A  SET is an complex type that contains other types, rather like a SEQUENCE. Elements inside a SET may be
       present in any order.

       Encoding
           The <u>value</u> is the same as for the SEQUENCE operator.

               $ber-&gt;encode(
                   SET =&gt; [
                       INTEGER =&gt; 13,
                       STRING =&gt; 'Hello',
                   ]
               ) or die;

       Decoding
           The <u>value</u> should be a reference to an <b>equivalent</b> <u>opList</u> to that used to encode the SET. The  ordering
           of the <u>opList</u> should not matter.

               $ber-&gt;decode(
                   SET =&gt; [
                       STRING =&gt; \$sval,
                       INTEGER =&gt; \$ival,
                   ]
               ) or die;

   <b>SEQUENCE_OF</b>
       A SEQUENCE_OF is an ordered list of other types.

       Encoding
           The  <u>value</u>  is a <u>ref</u> followed by an <u>opList</u>. The <u>ref</u> must be a reference to a list or a hash: if it is
           to a list, then the <u>opList</u> will be repeated once for every element in the list. If it is to  a  hash,
           then the <u>opList</u> will be repeated once for every key in the hash (note that ordering of keys in a hash
           is not guaranteed by perl.)

           The  remaining  <u>opList</u> will then usually contain <u>value</u>s which are code references. If the <u>ref</u> is to a
           list, then the contents of that item in the list  are  passed  as  the  only  argument  to  the  code
           reference. If the <u>ref</u> is to a hash, then only the key is passed to the code.

               @vals = ( [ 10, 'Foo' ], [ 20, 'Bar' ] ); # List of refs to lists
               $ber-&gt;encode(
                   SEQUENCE_OF =&gt; [ \@vals,
                       SEQUENCE =&gt; [
                           INTEGER =&gt; sub { $_[0][0] }, # Passed a ref to the inner list
                           STRING =&gt; sub { $_[0][1] }, # Passed a ref to the inner list
                       ]
                   ]
               ) or die;
               %hash = ( 40 =&gt; 'Baz', 30 =&gt; 'Bletch' ); # Just a hash
               $ber-&gt;decode(
                   SEQUENCE_OF =&gt; [ \%hash,
                       SEQUENCE =&gt; [
                           INTEGER =&gt; sub { $_[0] }, # Passed the key
                           STRING =&gt; sub { $hash{$_[0]} }, # Passed the key
                       ]
                   ]
               );

       Decoding
           The  <u>value</u>  must  be  a  reference to a list containing a <u>ref</u> and an <u>opList</u>. The <u>ref</u> must always be a
           reference to a scalar. Each value in the &lt;opList&gt; is usually a code reference. The code referenced is
           called with the value of the <u>ref</u> (dereferenced); the value of the <u>ref</u> is incremented for each item in
           the SEQUENCE_OF.

               $ber-&gt;decode(
                   SEQUENCE_OF =&gt; [ \$count,
                       # In the following subs, make space at the end of an array, and
                       # return a reference to that newly created space.
                       SEQUENCE =&gt; [
                           INTEGER =&gt; sub { $ival[$_[0]] = undef; \$ival[-1] },
                           STRING =&gt; sub { $sval[$_[0]] = undef; \$sval[-1] },
                       ]
                   ]
               ) or die;

   <b>SET_OF</b>
       A SET_OF is an unordered list. This is treated in an identical way  to  a  SEQUENCE_OF,  except  that  no
       ordering should be inferred from the list passed or returned.

</pre><h4><b>SPECIAL</b> <b>OPERATORS</b></h4><pre>
   <b>BER</b>
       It is sometimes useful to construct or deconstruct BER encodings in several pieces. The BER operator lets
       you do this.

       Encoding
           The  <u>value</u>  should be another "Convert::BER" object, which will be inserted into the buffer. If <u>value</u>
           is undefined then nothing is added.

               $tmp-&gt;encode(
                   SEQUENCE =&gt; [
                       INTEGER =&gt; 20,
                       STRING =&gt; 'Foo',
                   ]
               );
               $ber-&gt;encode(
                   BER =&gt; $tmp,
                   BOOLEAN =&gt; 1
               );

       Decoding
           <u>value</u> should be a reference to a scalar, which will contain a "Convert::BER" object. This object will
           contain the remainder of the current sequence or set being decoded.

               # After this, ber2 will contain the encoded INTEGER B&lt;and&gt; STRING.
               # sval will be ignored and left undefined, but bval will be decoded. The
               # decode of ber2 will return the integer and string values.
               $ber-&gt;decode(
                   SEQUENCE =&gt; [
                       BER =&gt; \$ber2,
                       STRING =&gt; \$sval,
                   ],
                   BOOLEAN =&gt; \$bval,
               );
               $ber2-&gt;decode(
                   INTEGER =&gt; \$ival,
                   STRING =&gt; \$sval2,
               );

   <b>ANY</b>
       This is like the "BER" operator except that when decoding only the next item is decoded and  placed  into
       the "Convert::BER" object returned. There is no difference when encoding.

       Decoding
           <u>value</u> should be a reference to a scalar, which will contain a "Convert::BER" object. This object will
           only contain the next single item in the current sequence being decoded.

               # After this, ber2 will decode further, and ival and sval
               # will be decoded.
               $ber-&gt;decode(
                   INTEGER = \$ival,
                   ANY =&gt; \$ber2,
                   STRING =&gt; \$sval,
               );

   <b>OPTIONAL</b>
       This operator allows you to specify that an element is absent from the encoding.

       Encoding
           The  <u>value</u>  should  be  a  reference to another list with another <u>opList</u>. If all of the values of the
           inner <u>opList</u> are defined, the entire OPTIONAL <u>value</u> will be encoded, otherwise it will be omitted.

               $ber-&gt;encode(
                   SEQUENCE =&gt; [
                       INTEGER =&gt; 16, # Will be encoded
                       OPTIONAL =&gt; [
                           INTEGER =&gt; undef, # Will not be encoded
                       ],
                       STRING =&gt; 'Foo', # Will be encoded
                   ]
               );

       Decoding
           The contents  of  <u>value</u>  are  decoded  if  possible,  if  not  then  decode  continues  at  the  next
           <u>operator</u>-<u>value</u> pair.

               $ber-&gt;decode(
                   SEQUENCE =&gt; [
                       INTEGER =&gt; \$ival1,
                       OPTIONAL =&gt; [
                           INTEGER =&gt; \$ival2,
                       ],
                       STRING =&gt; \$sval,
                   ]
               );

   <b>CHOICE</b>
       The  <u>opList</u>  is  a list of alternate <u>operator</u>-<u>value</u> pairs. Only one will be encoded, and only one will be
       decoded.

       Encoding
           A scalar at the start of the <u>opList</u> identifies which <u>opList</u>  alternative  to  use  for  encoding  the
           value. A value of 0 means the first one is used, 1 means the second one, etc.

               # Encode the BMPString alternate of the CHOICE
               $ber-&gt;encode(
                   CHOICE =&gt; [ 2,
                       PrintableString =&gt; 'Printable',
                       TeletexString   =&gt; 'Teletex/T61',
                       BMPString       =&gt; 'BMP/Unicode',
                       UniversalString =&gt; 'Universal/ISO10646',
                   ]
               ) or die;

       Decoding
           A  reference  to a scalar at the start of the <u>opList</u> is used to store which alternative is decoded (0
           for the first one, 1 for the second one, etc.) Pass undef instead of the ref if you don't care  about
           this, or you store all the alternate values in different variables.

               # Decode the above.
               # Afterwards, $alt will be set to 2, $str will be set to 'BMP/Unicode'.
               $ber-&gt;decode(
                   CHOICE =&gt; [ \$alt,
                       PrintableString =&gt; \$str,
                       TeletexString   =&gt; \$str,
                       BMPString       =&gt; \$str,
                       UniversalString =&gt; \$str,
                   ]
               ) or die;

</pre><h4><b>TAGS</b></h4><pre>
       In  BER  everything  being encoded has a tag, a length, and a value. Normally the tag is derived from the
       operator - so INTEGER has a different tag from a BOOLEAN, for instance.

       In some applications it is necessary to change the tags used. For example, a SET may need to contain  two
       different INTEGER values. Tags may be changed in two ways, either IMPLICITly or EXPLICITly. With IMPLICIT
       tagging,  the new tag completely replaces the old tag. With EXPLICIT tagging, the new tag is used <b>as</b> <b>well</b>
       <b>as</b> the old tag.

       "Convert::BER" supports two ways of using IMPLICIT tagging. One method is  to  sub-class  "Convert::BER",
       which  is  described in the next section. For small applications or those that think sub-classing is just
       too much then the operator may be passed an arrayref. The array must contain two elements, the  first  is
       the usual operator name and the second is the tag value to use, as shown below.

           $ber-&gt;encode(
               [ SEQUENCE =&gt; 0x34 ] =&gt; [
                   INTEGER =&gt; 10,
                   STRING  =&gt; "A"
               ]
           ) or die;

       This  will encode a sequence, with a tag value of 0x34, which will contain and integer and a string which
       will have their default tag values.

       You   may   wish   to   construct   your   tags   using    some    pre-defined    functions    such    as
       &amp;Convert::BER::BER_APPLICATION,  &amp;Convert::BER::BER_CONTEXT,  etc,  instead of calculating the tag values
       yourself.

       To use EXPLICIT tagging, enclose the original element in a SEQUENCE, and just override the SEQUENCE's tag
       as above. Don't forget to set the constructed bit using &amp;Convert::BER::BER_CONSTRUCTOR. For example,  the
       ASN.1 definition:

           Foo ::= SEQUENCE {
               [0] EXPLICIT INTEGER,
               INTEGER
           }

       might be encoded using this:

           $ber-&gt;encode(
               SEQUENCE =&gt; [
                   [ SEQUENCE =&gt; &amp;Convert::BER::BER_CONTEXT |
                                 &amp;Convert::BER::BER_CONSTRUCTOR | 0 ] =&gt; [
                       INTEGER =&gt; 10,
                   ],
                   INTEGER =&gt; 11,
               ],
           ) or die;

</pre><h4><b>SUB-CLASSING</b></h4><pre>
       For  large  applications  where operators with non default tags are used a lot the above mechanism can be
       very error-prone. For this reason, "Convert::BER" may be sub-classed.

       To do this the sub-class must call a static method "define". The arguments  to  "define"  is  a  list  of
       arrayrefs.  Each arrayref will define one new operator. Each arrayref contains three values, the first is
       the name of the operator, the second is how the data is encoded and the third is the tag  value.  To  aid
       with the creation of these arguments "Convert::BER" exports some variables and constant subroutines.

       For  each  operator  defined by "Convert::BER", or a "Convert::BER" sub-class, a scalar variable with the
       same name is available for import, for  example  $INTEGER  is  available  from  "Convert::BER".  And  any
       operators  defined  by  a  new  sub-class  will  be  available  for import from that class.  One of these
       variables may be used as the second element of each arrayref.

       "Convert::BER" also exports some constant subroutines that can be used  to  create  the  tag  value.  The
       subroutines exported are:

               BER_BOOLEAN
               BER_INTEGER
               BER_BIT_STR
               BER_OCTET_STR
               BER_NULL
               BER_OBJECT_ID
               BER_SEQUENCE
               BER_SET

               BER_UNIVERSAL
               BER_APPLICATION
               BER_CONTEXT
               BER_PRIVATE
               BER_PRIMITIVE
               BER_CONSTRUCTOR

       "Convert::BER"  also  provides  a  subroutine called "ber_tag" to calculate an integer value that will be
       used to represent a tag. For tags with values less than 30 this is not needed, but for tags  &gt;=  30  then
       tag value passed for an operator definition must be the result of "ber_tag"

       "ber_tag" takes two arguments, the first is the tag class and the second is the tag value.

       Using this information a sub-class of Convert::BER can be created as shown below.

           package Net::LDAP::BER;

           use Convert::BER qw(/^(\$|BER_)/);

           use strict;
           use vars qw($VERSION @ISA);

           @ISA = qw(Convert::BER);
           $VERSION = "1.00";

           Net::LDAP::BER-&gt;define(

             # Name            Type      Tag
             ########################################

             [ REQ_UNBIND     =&gt; $NULL,
                                 BER_APPLICATION                   | 0x02 ],

             [ REQ_COMPARE    =&gt; $SEQUENCE,
                                 BER_APPLICATION | BER_CONSTRUCTOR | 0x0E ],

             [ REQ_ABANDON    =&gt; $INTEGER,
                                 ber_tag(BER_APPLICATION, 0x10) ],
           );

       This  will  create  a new class "Net::LDAP::BER" which has three new operators available. This class then
       may be used as follows

           $ber = new Net::LDAP::BER;

           $ber-&gt;encode(
               REQ_UNBIND =&gt; 0,
               REQ_COMPARE =&gt; [
                   REQ_ABANDON =&gt; 123,
               ]
           );

           $ber-&gt;decode(
               REQ_UNBIND =&gt; \$var,
               REQ_COMPARE =&gt; [
                   REQ_ABANDON =&gt; \$num,
               ]
           );

       Which will encode or decode the data using the formats and tags  defined  in  the  "Net::LDAP::BER"  sub-
       class. It also helps to make the code more readable.

   <b>DEFINING</b> <b>NEW</b> <b>PACKING</b> <b>OPERATORS</b>
       As  well  as defining new operators which inherit from existing operators it is also possible to define a
       new operator and how data is encoded and decoded. The interface for doing this is still changing but will
       be documented here when it is done. To be continued ...

</pre><h4><b>LIMITATIONS</b></h4><pre>
       Convert::BER cannot support tags that contain more  bits  than  can  be  stored  in  a  scalar  variable,
       typically this is 32 bits.

       Convert::BER cannot support items that have a packed length which cannot be stored in 32 bits.

</pre><h4><b>BUGS</b></h4><pre>
       The "SET" decode method fails if the encoded order is different to the <u>opList</u> order.

</pre><h4><b>AUTHOR</b></h4><pre>
       Graham Barr &lt;<a href="mailto:gbarr@pobox.com">gbarr@pobox.com</a>&gt;

       Significant POD updates from Chris Ridd &lt;<a href="mailto:Chris.Ridd@messagingdirect.com">Chris.Ridd@messagingdirect.com</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  (c)  1995-2000  Graham  Barr.  All  rights  reserved.   This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

perl v5.36.0                                       2022-11-19                                           <u><a href="../man3pm/BER.3pm.html">BER</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>