<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web::API - A Simple base module to implement almost every RESTful API with just a few lines of</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libweb-api-perl">libweb-api-perl_2.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Web::API - A Simple base module to implement almost every RESTful API with just a few lines of
       configuration

</pre><h4><b>VERSION</b></h4><pre>
       version 2.8

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>NOTE:</b> as of version 2.1 "strict_ssl" is enabled by default for obvious security reasons, this may break
       your current library implementation, sorry.

       Implement the RESTful API of your choice in 10 minutes, roughly.

           package Net::CloudProvider;

           use Mouse;

           with 'Web::API';

           our $VERSION = "0.1";

           has 'commands' =&gt; (
               is      =&gt; 'rw',
               default =&gt; sub {
                   {
                       list_nodes =&gt; { method =&gt; 'GET' },
                       node_info  =&gt; { method =&gt; 'GET', require_id =&gt; 1 },
                       create_node =&gt; {
                           method             =&gt; 'POST',
                           default_attributes =&gt; {
                               allowed_hot_migrate            =&gt; 1,
                               required_virtual_machine_build =&gt; 1,
                               cpu_shares                     =&gt; 5,
                               required_ip_address_assignment =&gt; 1,
                               primary_network_id             =&gt; 1,
                               required_automatic_backup      =&gt; 0,
                               swap_disk_size                 =&gt; 1,
                           },
                           mandatory =&gt; [
                               'label',
                               'hostname',
                               'template_id',
                               'cpus',
                               'memory',
                               'primary_disk_size',
                               'required_virtual_machine_build',
                               'cpu_shares',
                               'primary_network_id',
                               'required_ip_address_assignment',
                               'required_automatic_backup',
                               'swap_disk_size',
                           ]
                       },
                       update_node =&gt; { method =&gt; 'PUT',    require_id =&gt; 1 },
                       delete_node =&gt; { method =&gt; 'DELETE', require_id =&gt; 1 },
                       start_node  =&gt; {
                           method       =&gt; 'POST',
                           require_id   =&gt; 1,
                           post_id_path =&gt; 'startup',
                       },
                       stop_node =&gt; {
                           method       =&gt; 'POST',
                           require_id   =&gt; 1,
                           post_id_path =&gt; 'shutdown',
                       },
                       suspend_node =&gt; {
                           method       =&gt; 'POST',
                           require_id   =&gt; 1,
                           post_id_path =&gt; 'suspend',
                       },
                   };
               },
           );

           sub commands {
               my ($self) = @_;
               return $self-&gt;commands;
           }

           sub BUILD {
               my ($self) = @_;

               $self-&gt;user_agent(__PACKAGE__ . ' ' . $VERSION);
               $self-&gt;live_url('https://ams01.cloudprovider.net/virtual_machines');
               $self-&gt;content_type('application/json');
               $self-&gt;extension('json');
               $self-&gt;wrapper('virtual_machine');
               $self-&gt;mapping({
                       os        =&gt; 'template_id',
                       debian    =&gt; 1,
                       id        =&gt; 'label',
                       disk_size =&gt; 'primary_disk_size',
               });

               return $self;
           }

           1;

       later use as:

           use Net::CloudProvider;

           my $nc = Net::CloudProvider-&gt;new(user =&gt; 'foobar', api_key =&gt; 'secret');
           my $response = $nc-&gt;create_node({
               id                             =&gt; 'funnybox',
               hostname                       =&gt; 'node.funnybox.com',
               os                             =&gt; 'debian',
               cpus                           =&gt; 2,
               memory                         =&gt; 256,
               disk_size                      =&gt; 5,
               allowed_hot_migrate            =&gt; 1,
               required_virtual_machine_build =&gt; 1,
               cpu_shares                     =&gt; 5,
               required_ip_address_assignment =&gt; 1,
           });

</pre><h4><b>ATTRIBUTES</b></h4><pre>
   <b>commands</b>
       most important configuration part of the module which has to be provided by the module you are writing.

       the following keys are valid/possible:

           method
           path
           mandatory
           default_attributes
           headers
           extension
           content_type
           incoming_content_type
           outgoing_content_type
           wrapper
           query_keys
           require_id (deprecated, use path)
           pre_id_path (deprecated, use path)
           post_id_path (deprecated, use path)

       the request path for commands is being build as:

           $base_url/$path.$extension

       an example for "path":

           path =&gt; 'users/:user_id/labels'

       this will add "user_id" to the list of mandatory keys for this command automatically.

   <b>live_url</b> <b>(required)</b>
       get/set base URL to API, can include paths

   <b>test_url</b> <b>(optional)</b>
       get/set base URL for test system if applicable

   <b>test</b> <b>(optional)</b>
       get/set boolean to run against base URL from test system or live system

   <b>api_key</b> <b>(required</b> <b>in</b> <b>most</b> <b>cases)</b>
       get/set API key (also used as basic auth password)

   <b>user</b> <b>(optional)</b>
       get/set API username/account name

   <b>api_key_field</b> <b>(optional)</b>
       get/set name of the hash key that has to hold the "api_key" e.g. in POST content payloads

   <b>api_version</b> <b>(optional)</b>
       get/set API version to be used

       default: 1

   <b>mapping</b> <b>(optional)</b>
       supply mapping table, hashref of format { "key" =&gt; "value", ... }

   <b>wrapper</b> <b>(optional)</b>
       get/set name of the key that is used to wrap all options of a command in.  unfortunately some APIs
       increase the depth of a hash by wrapping everything into a single key (who knows why...), which means
       this:

           $wa-&gt;command(%options);

       turns %options into:

           { wrapper =&gt; \%options }

       before encoding and sending it off.

   <b>header</b> <b>(optional)</b>
       get/set custom headers sent with every request

   <b>auth_type</b>
       get/set authentication type. currently supported are only 'basic', 'header', 'hash_key', 'get_params',
       'oauth_header', 'oauth_params' or 'none'

       default: none

   <b>auth_header</b> <b>(optional)</b>
       get/set the name of the header used for Authorization credentials

       default: Authorization

   <b>auth_header_token_format</b>
       get/set format of the auth_header token.

       default: 'Token token=%s'

   <b>default_method</b> <b>(optional)</b>
       get/set default HTTP method

       default: GET

   <b>extension</b> <b>(optional)</b>
       get/set file extension, e.g. 'json'

   <b>user_agent</b> <b>(optional)</b>
       get/set User Agent String

       default: "Web::API $VERSION"

   <b>timeout</b> <b>(optional)</b>
       get/set LWP::UserAgent timeout

   <b>strict_ssl</b> <b>(optional)</b>
       enable/disable strict SSL certificate hostname checking as a convenience alternatively you can supply
       your own LWP::Useragent compatible agent for the "agent" attribute.

       default: true

   <b>agent</b> <b>(optional)</b>
       get/set LWP::UserAgent object

   <b>retry_http_codes</b> <b>(optional)</b>
       get/set array of HTTP response codes that trigger a retry of the request

   <b>retry_errors</b> <b>(optional)</b>
       define an array reference of regexes that should trigger a retry of the request if matched against an
       error found via one of the "error_keys"

   <b>retry_times</b> <b>(optional)</b>
       get/set number of times a request will be retried at most

       default: 3

   <b>retry_delay</b> <b>(optional)</b>
       get/set delay to wait between retries. accepts float for millisecond support.

       default: 1.0

   <b>content_type</b> <b>(optional)</b>
       global content type, which is used for in and out going request/response headers and to encode and decode
       the payload if no other more specific content types are set, e.g. "incoming_content_type",
       "outgoing_content_type" or content types set individually per command attribute.

       default: 'text/plain'

   <b>incoming_content_type</b> <b>(optional)</b>
       default: undef

   <b>outgoing_content_type</b> <b>(optional)</b>
       default: undef

   <b>debug</b> <b>(optional)</b>
       enable/disabled debug logging

       default: false

   <b>cookies</b> <b>(optional)</b>
       this is used to store and retrieve cookies before and after requests were made to keep authenticated
       sessions alive for the time this object exists in memory you can add your own cookies to be send with
       every request. See HTTP::Cookies for more information.

       default: HTTP::Cookies-&gt;<b>new()</b>

   <b>consumer_secret</b> <b>(required</b> <b>for</b> <b>all</b> <b>oauth_*</b> <b>auth_types)</b>
       default: undef

   <b>access_token</b> <b>(required</b> <b>for</b> <b>all</b> <b>oauth_*</b> <b>auth_types)</b>
       default: undef

   <b>access_secret</b> <b>(required</b> <b>for</b> <b>all</b> <b>oauth_*</b> <b>auth_types)</b>
       default: undef

   <b>signature_method</b> <b>(required</b> <b>for</b> <b>all</b> <b>oauth_*</b> <b>auth_types)</b>
       default: undef

   <b>encoder</b> <b>(custom</b> <b>options</b> <b>encoding</b> <b>subroutine)</b>
       Receives "\%options" and "content-type" as the only 2 arguments and has to return a single scalar.

       default: undef

   <b>decoder</b> <b>(custom</b> <b>response</b> <b>content</b> <b>decoding</b> <b>subroutine)</b>
       Receives "content" and "content-type" as the only 2 scalar arguments and has to return a single hash
       reference.

       default: undef

   <b>oauth_post_body</b> <b>(required</b> <b>for</b> <b>all</b> <b>oauth_*</b> <b>auth_types)</b>
       enable/disable adding of command options as extra parameters to the OAuth request generation and therefor
       be included in the OAuth signature calculation.

       default: true

   <b>error_keys</b>
       get/set list of array keys that will be search for in the decoded response data structure. the same
       format as for mandatory keys is supported:

           some.deeply.nested.error.message

       will search for an error message at

           $decoded_response-&gt;{some}-&gt;{deeply}-&gt;{nested}-&gt;{error}-&gt;{messsage}

       and if the key exists and its value is defined it will be provided as "$response-"{error}&gt; and matched
       against all regexes from the `retry_errors` array ref if provided to trigger a retry on particular
       errors.

</pre><h4><b>INTERNAL</b> <b>SUBROUTINES/METHODS</b></h4><pre>
   <b>nonce</b>
       generates new OAuth nonce for every request

   <b>log</b>
   <b>decode</b>
   <b>encode</b>
   <b>talk</b>
   <b>map_options</b>
   <b>check_mandatory</b>
   <b>key_exists</b>
   <b>wrap</b>
   <b>request</b>
       retry request with delay if "retry_http_codes" is set, otherwise just try once.

   <b>needs_retry</b>
       returns true if the HTTP code or error found match either "retry_http_codes" or "retry_errors"
       respectively.  returns false otherwise.

       if "retry_errors" are defined it will try to decode the response content and store the decoded structure
       internally so we don't have to decode again at the end.

       needs the last response object and the 'Accept' content type header from the request for decoding.

   <b>find_error</b>
       go through "error_keys" and find a potential error message in the decoded/parsed response and return it.

   <b>format_response</b>
   <b>build_uri</b>
   <b>build_content_type</b>
       configure in/out content types

       order of precedence: 1. per command "incoming_content_type" / "outgoing_content_type" 2. per command
       general "content_type" 3. content type based on file path extension (only for incoming) 4. global
       "incoming_content_type" / "outgoing_content_type" 5. global general "content_type"

   <b>DESTROY</b>
       catch DESTROY call and tear down / clean up if necessary at this point there is nothing to do though.
       This prevents AUTOLOAD from logging an unknown command error message

   <b>AUTOLOAD</b> <b>magic</b>
       install a method for each new command and call it in an "eval {}" to catch exceptions and set an error in
       a unified way.

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests on GitHub's issue tracker
       &lt;https://github.com/nupfel/Web-API/issues&gt;.  Pull requests welcome.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the <b><a href="../man1/perldoc.1.html">perldoc</a></b>(1) command.

           perldoc Web::API

       You can also look for information at:

       •   GitHub repository

           &lt;https://github.com/nupfel/Web-API&gt;

       •   MetaCPAN

           &lt;https://metacpan.org/module/Web::API&gt;

       •   AnnoCPAN: Annotated CPAN documentation

           &lt;<a href="http://annocpan.org/dist/Web">http://annocpan.org/dist/Web</a>::API&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/Web">http://cpanratings.perl.org/d/Web</a>::API&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       HTTP::Cookies, LWP::UserAgent, Net::OAuth

</pre><h4><b>AUTHOR</b></h4><pre>
       Tobias Kirschstein &lt;<a href="mailto:lev@cpan.org">lev@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2013 by Tobias Kirschstein.

       This is free software, licensed under:

         The (three-clause) BSD License

perl v5.38.2                                       2024-04-13                                      <u>Web::<a href="../man3pm/API.3pm.html">API</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>