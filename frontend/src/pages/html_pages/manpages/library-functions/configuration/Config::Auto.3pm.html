<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Config::Auto - Magical config file parser</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconfig-auto-perl">libconfig-auto-perl_0.44-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Config::Auto - Magical config file parser

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Config::Auto;

           ### Not very magical at all.
           $config = Config::Auto::parse("myprogram.conf", format =&gt; "colon");

           ### Considerably more magical.
           $config = Config::Auto::parse("myprogram.conf");

           ### Highly magical.
           $config = Config::Auto::parse();

           ### Using the OO interface
           $ca     = Config::Auto-&gt;new( source =&gt; $text );
           $ca     = Config::Auto-&gt;new( source =&gt; $fh );
           $ca     = Config::Auto-&gt;new( source =&gt; $filename );

           $href   = $ca-&gt;score;           # compute the score for various formats

           $config = $ca-&gt;parse;           # parse the config

           $format = $ca-&gt;format;          # detected (or provided) config format
           $str    = $ca-&gt;as_string;       # config file stringified
           $fh     = $ca-&gt;fh;              # config file handle
           $file   = $ca-&gt;file;            # config filename
           $aref   = $ca-&gt;data;            # data from your config, split by newlines

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module was written after having to write Yet Another Config File Parser for some variety of colon-
       separated config. I decided "never again".

       Config::Auto aims to be the most "DWIM" config parser available, by detecting configuration styles,
       include paths and even config filenames automagically.

       See the "HOW IT WORKS" section below on implementation details.

</pre><h4><b>ACCESSORS</b></h4><pre>
   <b>@formats</b> <b>=</b> <b>Config::Auto-&gt;formats</b>
       Returns a list of supported formats for your config files. These formats are also the keys as used by the
       "score()" method.

       "Config::Auto" recognizes the following formats:

       •   perl    =&gt; perl code

       •   colon   =&gt; colon separated (e.g., key:value)

       •   space   =&gt; space separated (e.g., key value)

       •   equal   =&gt; equal separated (e.g., key=value)

       •   bind    =&gt; bind style (not available)

       •   irssi   =&gt; irssi style (not available)

       •   xml     =&gt; xml (via XML::Simple)

       •   ini     =&gt; .ini format (via Config::IniFiles)

       •   list    =&gt; list (e.g., foo bar baz)

       •   yaml    =&gt; yaml (via YAML.pm)

</pre><h4><b>METHODS</b></h4><pre>
   <b>$obj</b> <b>=</b> <b>Config::Auto-&gt;new(</b> <b>[source</b> <b>=&gt;</b> <b>$text|$fh|$filename,</b> <b>path</b> <b>=&gt;</b> <b>\@paths,</b> <b>format</b> <b>=&gt;</b> <b>FORMAT_NAME]</b> <b>);</b>
       Returns a "Config::Auto" object based on your configs source. This can either be:

       a filehandle
           Any opened filehandle, or "IO::Handle"/"IO::String" object.

       a plain text string
           Any plain string containing one or more newlines.

       a filename
           Any plain string pointing to a file on disk

       nothing
           A heuristic will be applied to find your config file, based on the name of your script; $0.

       Although  "Config::Auto"  is  at  its  most  magical  when called with no parameters, its behavior can be
       controlled explicitly by using one or two arguments.

       If a filename is passed as the "source" argument, the same paths are  checked,  but  "Config::Auto"  will
       look for a file with the passed name instead of the $0-based names.

       Supplying the "path" parameter will add additional directories to the search paths. The current directory
       is  searched  first, then the paths specified with the path parameter. "path" can either be a scalar or a
       reference to an array of paths to check.

       The "format" parameters forces "Config::Auto" to interpret the contents of the configuration file in  the
       given format without trying to guess.

   <b>$rv</b> <b>=</b> <b>$obj-&gt;parse</b> <b>|</b> <b>Config::Auto::parse(</b> <b>[$text|$fh|$filename,</b> <b>path</b> <b>=&gt;</b> <b>\@paths,</b> <b>format</b> <b>=&gt;</b> <b>FORMAT_NAME]</b> <b>);</b>
       Parses  the  source  you  provided  in  the  "new()"  call and returns a data structure representing your
       configuration file.

       You can also call it in a procedural context ("Config::Auto::parse()"), where the first argument  is  the
       source,  and the following arguments are named. This function is provided for backwards compatiblity with
       releases prior to 0.29.

   <b>$href</b> <b>=</b> <b>$obj-&gt;score;</b>
       Takes a look at the contents of your configuration data and produces a 'score' determining  which  format
       it most likely contains.

       They  keys  are  equal to formats as returned by the "Config::Auto-&gt;formats" and their values are a score
       between 1 and 100. The format with the highest score will be  used  to  parse  your  configuration  data,
       unless you provided the "format" option explicitly to the "new()" method.

   <b>$aref</b> <b>=</b> <b>$obj-&gt;data;</b>
       Returns an array ref of your configuration data, split by newlines.

   <b>$fh</b> <b>=</b> <b>$obj-&gt;fh;</b>
       Returns  a  filehandle,  opened  for  reading, containing your configuration data. This works even if you
       provided a plain text string or filename to parse.

   <b>$filename</b> <b>=</b> <b>$obj-&gt;file;</b>
       Returns a filename containing your configuration data. This works even if you provided a plaintext string
       or filehandle to parse. In that case, a temporary file will be written holding your configuration data.

   <b>$str</b> <b>=</b> <b>$obj-&gt;as_string;</b>
       Returns a string representation of your configuration data.

</pre><h4><b>GLOBAL</b> <b>VARIABLES</b></h4><pre>
       <u>$DisablePerl</u>

       Set this variable to true if you do not wish to "eval" perl style configuration files.

       Default is "false"

       <u>$Untaint</u>

       Set this variable to true if you automatically  want  to  untaint  values  obtained  from  a  perl  style
       configuration. See "perldoc perlsec" for details on tainting.

       Default is "false"

       <u>$Debug</u>

       Set  this variable to true to get extra debug information from "Config::Auto" when finding and/or parsing
       config files fails.

       Default is "false"

</pre><h4><b>HOW</b> <b>IT</b> <b>WORKS</b></h4><pre>
       When you call "Config::Auto-&gt;new" or "Config::Auto::parse" with no arguments, we  first  look  at  $0  to
       determine the program's name. Let's assume that's "snerk". We look for the following files:

           snerkconfig
           <a href="file:~/snerkconfig">~/snerkconfig</a>
           /etc/snerkconfig
           /usr/local/etc/snerkconfig

           snerk.config
           <a href="file:~/snerk.config">~/snerk.config</a>
           /etc/snerk.config
           /usr/local/etc/snerk.config

           snerkrc
           <a href="file:~/snerkrc">~/snerkrc</a>
           /etc/snerkrc
           /usr/local/etc/snerkrc

           .snerkrc
           <a href="file:~/.snerkrc">~/.snerkrc</a>
           /etc/.snerkrc
           /usr/local/etc/.snerkrc

       Additional search paths can be specified with the "path" option.

       We  take  the first one we find, and examine it to determine what format it's in. The algorithm used is a
       heuristic "which is a fancy way of saying that it doesn't work." (Mark  Dominus.)  We  know  about  colon
       separated,  space  separated, equals separated, XML, Perl code, Windows INI, BIND9 and irssi style config
       files. If it chooses the wrong one, you can force it with the "format" option.

       If you don't want it ever to detect and execute config  files  which  are  made  up  of  Perl  code,  set
       "$Config::Auto::DisablePerl = 1".

       When  using  the  perl  format,  your configuration file will be eval'd. This will cause taint errors. To
       avoid these warnings, set "$Config::Auto::Untaint = 1".  This setting will not untaint the data  in  your
       configuration file and should only be used if you trust the source of the filename.

       Then  the  file  is parsed and a data structure is returned. Since we're working magic, we have to do the
       best we can under the circumstances - "You rush a miracle man, you get rotten miracles." (Miracle Max) So
       there are no guarantees about the structure that's returned. If you have a  fairly  regular  config  file
       format,  you'll  get  a regular data structure back. If your config file is confusing, so will the return
       structure be. Isn't life tragic?

</pre><h4><b>EXAMPLES</b></h4><pre>
       Here's what we make of some common Unix config files:

       <u><a href="file:/etc/resolv.conf">/etc/resolv.conf</a></u>:

           $VAR1 = {
               'nameserver' =&gt; [ '163.1.2.1', '129.67.1.1', '129.67.1.180' ],
               'search' =&gt; [ 'oucs.ox.ac.uk', 'ox.ac.uk' ]
           };

       <u><a href="file:/etc/passwd">/etc/passwd</a></u>:

           $VAR1 = {
               'root' =&gt; [ 'x', '0', '0', 'root', '<a href="file:/root">/root</a>', '<a href="file:/bin/bash">/bin/bash</a>' ],
               ...
           };

       <u>/etc/gpm.conf</u>:

           $VAR1 = {
               'append' =&gt; '""',
               'responsiveness' =&gt; '',
               'device' =&gt; '/dev/psaux',
               'type' =&gt; 'ps2',
               'repeat_type' =&gt; 'ms3'
           };

       <u><a href="file:/etc/nsswitch.conf">/etc/nsswitch.conf</a></u>:

           $VAR1 = {
               'netgroup' =&gt; 'nis',
               'passwd' =&gt; 'compat',
               'hosts' =&gt; [ 'files', 'dns' ],
               ...
           };

</pre><h4><b>MEMORY</b> <b>USAGE</b></h4><pre>
       This module is as light as possible on memory, only using modules when they  are  absolutely  needed  for
       configuration file parsing.

</pre><h4><b>TROUBLESHOOTING</b></h4><pre>
       When using a Perl config file, the configuration is borked
           Give  "Config::Auto"  more  hints  (e.g.,  add  #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> to beginning of file) or indicate the
           format in the "new"/"parse()" command.

</pre><h4><b>TODO</b></h4><pre>
       BIND9 and irssi file format parsers currently don't exist. It would be good to add support for "mutt" and
       "vim" style "set"-based RCs.

</pre><h4><b>BUG</b> <b>REPORTS</b></h4><pre>
       Please report bugs or other issues to &lt;<a href="mailto:bug-config-auto@rt.cpan.org">bug-config-auto@rt.cpan.org</a>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       Versions 0.04 and higher of this module by Jos Boumans &lt;<a href="mailto:kane@cpan.org">kane@cpan.org</a>&gt;.

       This module originally by Simon Cozens.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This library is free software; you may redistribute and/or modify it under the same terms as Perl itself.

perl v5.34.0                                       2022-06-11                                  <u>Config::<a href="../man3pm/Auto.3pm.html">Auto</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>