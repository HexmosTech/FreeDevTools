<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Config::Tiny - Read/Write .ini style files with as little code as possible</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconfig-tiny-perl">libconfig-tiny-perl_2.30-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Config::Tiny - Read/Write .ini style files with as little code as possible

</pre><h4><b>SYNOPSIS</b></h4><pre>
               # In your configuration file
               rootproperty=blah

               [section]
               one=twp
               greetings[]=Hello
               three= four
               Foo =Bar
               greetings[]=World!
               empty=

               # In your program
               use Config::Tiny;

               # Create an empty config
               my $Config = Config::Tiny-&gt;new;

               # Create a config with data
               my $config = Config::Tiny-&gt;new({
                       _ =&gt; { rootproperty =&gt; "Bar" },
                       section =&gt; { one =&gt; "value", Foo =&gt; 42 } });

               # Open the config
               $Config = Config::Tiny-&gt;read( 'file.conf' );
               $Config = Config::Tiny-&gt;read( 'file.conf', 'utf8' ); # Neither ':' nor '&lt;:' prefix!
               $Config = Config::Tiny-&gt;read( 'file.conf', 'encoding(iso-8859-1)');

               # Reading properties
               my $rootproperty = $Config-&gt;{_}-&gt;{rootproperty};
               my $one = $Config-&gt;{section}-&gt;{one};
               my $Foo = $Config-&gt;{section}-&gt;{Foo};

               # Changing data
               $Config-&gt;{newsection} = { this =&gt; 'that' }; # Add a section
               $Config-&gt;{section}-&gt;{Foo} = 'Not Bar!';     # Change a value
               delete $Config-&gt;{_};                        # Delete a value or section

               # Save a config
               $Config-&gt;write( 'file.conf' );
               $Config-&gt;write( 'file.conf', 'utf8' ); # Neither ':' nor '&gt;:' prefix!

               # Shortcuts
               my($rootproperty) = $$Config{_}{rootproperty};

               my($config) = Config::Tiny -&gt; read_string('alpha=bet');
               my($value)  = $$config{_}{alpha}; # $value is 'bet'.

               my($config) = Config::Tiny -&gt; read_string("[init]\nalpha=bet");
               my($value)  = $$config{init}{alpha}; # $value is 'bet'.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Config::Tiny" is a Perl class to read and write .ini style configuration files with as little code as
       possible, reducing load time and memory overhead.

       Most of the time it is accepted that Perl applications use a lot of memory and modules.

       The *::Tiny family of modules is specifically intended to provide an ultralight alternative to the
       standard modules.

       This module is primarily for reading human written files, and anything we write shouldn't need to have
       documentation/comments. If you need something with more power move up to Config::Simple, Config::General
       or one of the many other "Config::*" modules.

       Lastly, Config::Tiny does <b>not</b> preserve your comments, whitespace, or the order of your config file.

       See Config::Tiny::Ordered (and possibly others) for the preservation of the order of the entries in the
       file.

</pre><h4><b>CONFIGURATION</b> <b>FILE</b> <b>SYNTAX</b></h4><pre>
       Files are the same format as for MS Windows "*.ini" files. For example:

               [section]
               var1=value1
               var2=value2

       But see also ARRAY SYNTAX just below.

       If a property is outside of a section at the beginning of a file, it will be assigned to the "root
       section", available at "$Config-&gt;{_}".

       Lines starting with '#' or ';' are considered comments and ignored, as are blank lines.

       When writing back to the config file, all comments, custom whitespace, and the ordering of your config
       file elements are discarded. If you need to keep the human elements of a config when writing back,
       upgrade to something better, this module is not for you.

</pre><h4><b>ARRAY</b> <b>SYNTAX</b></h4><pre>
   <b>Basic</b> <b>Syntax</b>
       As of V 2.30, this module supports the case of a key having an array of values.

       Sample data (copied from t/test.conf):

               root=something

               [section]
               greetings[]=Hello
               one=two
               Foo=Bar
               greetings[]=World!
               this=Your Mother!
               blank=

               [Section Two]
               something else=blah
                remove = whitespace

       Note specifically that the key name greetings has the empty bracket pair [] as a suffix.  This tells the
       code that it is not to overwrite the 1st value with the 2nd value, but rather to push these values onto a
       stack called 'greetings'.

       Note also that you could have used:

               [section]
               greetings[]=Hello
               greetings[]=World!
               one=two
               Foo=Bar
               this=Your Mother!
               blank=

       Clearly, the 2 lines using greetings[] do not have to be side-by-side.

       If you use e.g. Data::Dumper::Concise to give you a <b>Dumper()</b> function (not method), then 'say
       Dumper($Config)' the output will look like:

               bless( {
                 "Section Two" =&gt; {
                    remove =&gt; "whitespace",
                    "something else" =&gt; "blah",
                  },
                  _ =&gt; {
                    root =&gt; "something",
                  },
                  section =&gt; {
                    Foo =&gt; "Bar",
                    blank =&gt; "",
                    greetings =&gt; [
                      "Hello",
                      "World!",
                    ],
                    one =&gt; "two",
                    this =&gt; "Your Mother!",
                  },
                }, 'Config::Tiny' )

       You can see this structure in t/02.main.t starting at line 45. Observe too that the key names are
       reported in alphabetical order (by the module Data::Dumper::Concise) despite the differing order in the
       setting of these keys, and that the array syntax result is that greetings has an array for a value.

       To access these values, use code like this:

               Dumper($Config);
               Dumper($Config-&gt;{section});
               Dumper($Config-&gt;{section}-&gt;{greetings});
               Dumper($Config-&gt;{section}-&gt;{greetings}-&gt;[0]);
               Dumper($Config-&gt;{section}-&gt;{greetings}-&gt;[1]);
               Dumper(ref $Config);

   <b>Warning</b>
       $Config is a blessed value, which means it is accessed differently than if it was a hash ref. The latter
       could be accessed as:

               Dumper($$Config{section}{greetings}); # Don't do this for blessed values!

       Finally, if a hash ref rather than a blessed value, you could also use, as above:

               Dumper($Config-&gt;{section}-&gt;{greetings}); # Don't do this for blessed values!

       My (Ron Savage) personal preference for hashrefs is the one without the gross '-&gt;' chars, but that
       requires you to double up the initial $ character (which I hope you noticed!).

</pre><h4><b>METHODS</b></h4><pre>
   <b>errstr()</b>
       Returns a string representing the most recent error, or the empty string.

       You can also retrieve the error message from the $Config::Tiny::errstr variable.

   <b>new([$config])</b>
       Here, the [] indicate an optional parameter.

       The constructor "new" creates and returns a "Config::Tiny" object.

       This will normally be a new, empty configuration, but you may also pass a hashref here which will be
       turned into an object of this class. This hashref should have a structure suitable for a configuration
       file, that is, a hash of hashes where the key "_" is treated specially as the root section.

   <b>read($filename,</b> <b>[$encoding])</b>
       Here, the [] indicate an optional parameter.

       The "read" constructor reads a config file, $filename, and returns a new "Config::Tiny" object containing
       the properties in the file.

       $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.

       Do not add a prefix to $encoding, such as '&lt;' or '&lt;:'.

       Returns the object on success, or "undef" on error.

       When "read" fails, "Config::Tiny" sets an error message internally you can recover via
       "Config::Tiny-&gt;errstr". Although in <b>some</b> cases a failed "read" will also set the operating system error
       variable $!, not all errors do and you should not rely on using the $! variable.

       See t/04.utf8.t and t/04.utf8.txt.

   <b>read_string($string)</b>
       The "read_string" method takes as argument the contents of a config file as a string and returns the
       "Config::Tiny" object for it.

   <b>write($filename,</b> <b>[$encoding])</b>
       Here, the [] indicate an optional parameter.

       The "write" method generates the file content for the properties, and writes it to disk to the filename
       specified.

       $encoding may be used to indicate the encoding of the file, e.g. 'utf8' or 'encoding(iso-8859-1)'.

       Do not add a prefix to $encoding, such as '&gt;' or '&gt;:'.

       Returns true on success or "undef" on error.

       See t/04.utf8.t and t/04.utf8.txt.

   <b>write_string()</b>
       Generates the file content for the object and returns it as a string.

</pre><h4><b>FAQ</b></h4><pre>
   <b>What</b> <b>happens</b> <b>if</b> <b>a</b> <b>key</b> <b>is</b> <b>repeated?</b>
       Case 1: The last value is retained, overwriting any previous values.

       See t/06.repeat.key.t for sample code.

       Case 2: However, by using the new array syntax, as of V 2.30, you can assign a set of values to a key.

       For details, see the "ARRAY SYNTAX" section above for sample code.

       See t/test.conf for sample data.

   <b>Why</b> <b>can't</b> <b>I</b> <b>put</b> <b>comments</b> <b>at</b> <b>the</b> <b>ends</b> <b>of</b> <b>lines?</b>
       o The # char is only introduces a comment when it's at the start of a line.
           So a line like:

                   key=value # A comment

           Sets key to 'value # A comment', which, presumably, you did not intend.

           This conforms to the syntax discussed in "CONFIGURATION FILE SYNTAX".

       o Comments matching /\s\;\s.+$//g; are ignored.
           This means you can't preserve the suffix using:

                   key = Prefix ; Suffix

           Result: key is now 'Prefix'.

           But you can do this:

                   key = Prefix;Suffix

           Result: key is now 'Prefix;Suffix'.

           Or this:

                   key = Prefix; Suffix

           Result: key is now 'Prefix; Suffix'.

       See t/07.trailing.comment.t.

   <b>Why</b> <b>can't</b> <b>I</b> <b>omit</b> <b>the</b> <b>'='</b> <b>signs?</b>
       E.g.:

               [Things]
               my =
               list =
               of =
               things =

       Instead of:

               [Things]
               my
               list
               of
               things

       Because  the  use  of  '='  signs  is  a  type of mandatory documentation. It indicates that that section
       contains 4 items, and not 1 odd item split over 4 lines.

   <b>Why</b> <b>do</b> <b>I</b> <b>have</b> <b>to</b> <b>assign</b> <b>the</b> <b>result</b> <b>of</b> <b>a</b> <b>method</b> <b>call</b> <b>to</b> <b>a</b> <b>variable?</b>
       This question comes from RT#85386.

       Yes, the syntax may seem odd, but you don't have to call both <b>new()</b> and <b>read_string()</b>.

       Try:

               perl -MData::Dumper -MConfig::Tiny -E 'my $c=Config::Tiny-&gt;read_string("one=s"); say Dumper $c'

       Or:

               my($config) = Config::Tiny -&gt; read_string('alpha=bet');
               my($value)  = $$config{_}{alpha}; # $value is 'bet'.

       Or even, a bit ridiculously:

               my($value) = ${Config::Tiny -&gt; read_string('alpha=bet')}{_}{alpha}; # $value is 'bet'.

   <b>Can</b> <b>I</b> <b>use</b> <b>a</b> <b>file</b> <b>called</b> <b>'0'</b> <b>(zero)?</b>
       Yes. See t/05.zero.t (test code) and t/0 (test data).

</pre><h4><b>CAVEATS</b></h4><pre>
       Some edge cases in section headers are not supported, and additionally may not be detected  when  writing
       the config file.

       Specifically,  section  headers with leading whitespace, trailing whitespace, or newlines anywhere in the
       section header, will not be written correctly to the file and may cause file corruption.

</pre><h4><b>Repository</b></h4><pre>
       &lt;https://github.com/ronsavage/Config-Tiny.git&gt;

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs should be reported via the CPAN bug tracker at

       &lt;https://github.com/ronsavage/Config-Tiny/issues&gt;

       For other issues, or commercial enhancement or support, contact the author.

</pre><h4><b>AUTHOR</b></h4><pre>
       Adam Kennedy &lt;<a href="mailto:adamk@cpan.org">adamk@cpan.org</a>&gt;

       Maintanence from V 2.15: Ron Savage &lt;<a href="http://savage.net.au/">http://savage.net.au/</a>&gt;.

</pre><h4><b>ACKNOWLEGEMENTS</b></h4><pre>
       Thanks to Sherzod Ruzmetov &lt;<a href="mailto:sherzodr@cpan.org">sherzodr@cpan.org</a>&gt; for Config::Simple, which inspired this  module  by  being
       not quite "simple" enough for me :).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See, amongst many: Config::Simple and Config::General.

       See  Config::Tiny::Ordered  (and possibly others) for the preservation of the order of the entries in the
       file.

       IOD. Ini On Drugs.

       IOD::Examples

       App::IODUtils

       Config::IOD::Reader

       Config::Perl::V. Config data from Perl itself.

       Config::Onion

       Config::IniFiles

       Config::INIPlus

       Config::Hash. Allows nested data.

       Config::MVP. Author: RJBS. Uses Moose. Extremely complex.

       Config::TOML. See next few lines:

       &lt;https://github.com/dlc/toml&gt;

       &lt;https://github.com/alexkalderimis/config-toml.pl&gt;. 1 Star rating.

       &lt;https://github.com/toml-lang/toml&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2002 - 2011 Adam Kennedy.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       The full text of the license can be found in the LICENSE file included with this module.

perl v5.36.0                                       2023-10-26                                  <u>Config::<a href="../man3pm/Tiny.3pm.html">Tiny</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>