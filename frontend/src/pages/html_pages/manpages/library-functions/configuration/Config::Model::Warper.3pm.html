<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Config::Model::Warper - Warp tree properties</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconfig-model-perl">libconfig-model-perl_2.155-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Config::Model::Warper - Warp tree properties

</pre><h4><b>VERSION</b></h4><pre>
       version 2.155

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # internal class

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Depending on the value of a warp master (In fact a Config::Model::Value or a Config::Model::CheckList
       object), this class changes the properties of a node (Config::Model::WarpedNode), a hash
       (Config::Model::HashId), a list (Config::Model::ListId), a checklist (Config::Model::CheckList) or
       another value.

</pre><h4><b>Warper</b> <b>and</b> <b>warped</b></h4><pre>
       Warping an object means that the properties of the object is changed depending on the value of another
       object.

       The changed object is referred as the <u>warped</u> object.

       The other object that holds the important value is referred as the <u>warp</u> <u>master</u> or the <u>warper</u> object.

       You can also set up several warp master for one warped object. This means that the properties of the
       warped object is changed according to a combination of values of the warp masters.

</pre><h4><b>Warp</b> <b>arguments</b></h4><pre>
       Warp arguments are passed in a hash ref whose keys are "follow" and and "rules":

   <b>Warp</b> <b>follow</b> <b>argument</b>
       Grab string leading to the "Config::Model::Value" or Config::Model::CheckList warp master. E.g.:

        follow =&gt; '! tree_macro'

       In case of several warp master, "follow" is set to an array ref of several grab string:

        follow =&gt; [ '! macro1', '- macro2' ]

       You can also use named parameters:

        follow =&gt; { m1 =&gt; '! macro1', m2 =&gt; '- macro2' }

       Note: By design "follow" argument of warper module is a plain path to keep warp mechanism (relatively)
       simple. "follow" argument of Config::Model::ValueComputer has more features and is documented there

   <b>Warp</b> <b>rules</b> <b>argument</b>
       String, hash ref or array ref that specify the warped object property changes.  These rules specifies the
       actual property changes for the warped object depending on the value(s) of the warp master(s).

       E.g. for a simple case (rules is a hash ref) :

        follow =&gt; '! macro1' ,
        rules =&gt; { A =&gt; { &lt;effect when macro1 is A&gt; },
                   B =&gt; { &lt;effect when macro1 is B&gt; }
                 }

       In case of similar effects, you can use named parameters and a boolean expression to specify the effect.
       The first match is applied. In this case, rules is a list ref:

         follow =&gt; { m =&gt; '! macro1' } ,
         rules =&gt; [ '$m eq "A"'               =&gt; { &lt;effect for macro1 == A&gt; },
                    '$m eq "B" or $m eq"C "'  =&gt; { &lt;effect for macro1 == B|C &gt; }
                  ]

       In case of several warp masters, "follow" must use named parameters, and rules must use boolean
       expression:

        follow =&gt; { m1 =&gt; '! macro1', m2 =&gt; '- macro2' } ,
        rules =&gt; [
                  '$m1 eq "A" &amp;&amp; $m2 eq "C"' =&gt; { &lt;effect for A C&gt; },
                  '$m1 eq "A" &amp;&amp; $m2 eq "D"' =&gt; { &lt;effect for A D&gt; },
                  '$m1 eq "B" &amp;&amp; $m2 eq "C"' =&gt; { &lt;effect for B C&gt; },
                  '$m1 eq "B" &amp;&amp; $m2 eq "D"' =&gt; { &lt;effect for B D&gt; },
                 ]

       Of course some combinations of warp master values can have the same effect:

        follow =&gt; { m1 =&gt; '! macro1', m2 =&gt; '- macro2' } ,
        rules =&gt; [
                  '$m1 eq "A" &amp;&amp; $m2 eq "C"' =&gt; { &lt;effect X&gt; },
                  '$m1 eq "A" &amp;&amp; $m2 eq "D"' =&gt; { &lt;effect Y&gt; },
                  '$m1 eq "B" &amp;&amp; $m2 eq "C"' =&gt; { &lt;effect Y&gt; },
                  '$m1 eq "B" &amp;&amp; $m2 eq "D"' =&gt; { &lt;effect Y&gt; },
                 ]

       In this case, you can use different boolean expression to save typing:

        follow =&gt; { m1 =&gt; '! macro1', m2 =&gt; '- macro2' } ,
        rules =&gt; [
                  '$m1 eq "A" &amp;&amp; $m2 eq "C"' =&gt; { &lt;effect X&gt; },
                  '$m1 eq "A" &amp;&amp; $m2 eq "D"' =&gt; { &lt;effect Y&gt; },
                  '$m1 eq "B" &amp;&amp; ( $m2 eq "C" or $m2 eq "D") ' =&gt; { &lt;effect Y&gt; },
                 ]

       Note that the boolean expression is sanitized and used in a Perl eval, so you can use most Perl syntax
       and regular expressions.

       Functions (like &amp;foo) are called like "$self-&gt;foo" before evaluation of the boolean expression.

       The rules must be declared with a slightly different way when a check_list is used as a warp master: a
       check_list has not a simple value. The rule must check whether a value is checked or not amongs all the
       possible items of a check list.

       For example, let's say that $cl in the rule below point to a check list whose items are "A" and "B". The
       rule must verify if the item is set or not:

         rules =&gt; [
              '$cl.is_set(A)' =&gt;  { &lt;effect when A is set&gt; },
              '$cl.is_set(B)' =&gt;  { &lt;effect when B is set&gt; },
              # can be combined
              '$cl.is_set(B) and $cl.is_set(A)' =&gt;  { &lt;effect when A and B are set&gt; },
          ],

       With this feature, you can control with a check list whether some element must be shown or not (assuming
       "FooClass" and "BarClass" classes are declared):

           element =&gt; [
               # warp master
               my_check_list =&gt; {
                   type       =&gt; 'check_list',
                   choice     =&gt; ['has_foo','has_bar']
               },
               # controlled element that show up only when has_foo is set
               foo =&gt; {
                   type =&gt; 'warped_node',
                   level =&gt; 'hidden',
                   config_class_name =&gt; 'FooClass',
                   follow =&gt; {
                       selected =&gt; '- my_check_list'
                   },
                   'rules' =&gt; [
                       '$selected.is_set(has_foo)' =&gt; {
                           level =&gt; 'normal'
                       }
                   ]
               },
               # controlled element that show up only when has_bar is set
               bar =&gt; {
                   type =&gt; 'warped_node',
                   level =&gt; 'hidden',
                   config_class_name =&gt; 'BarClass',
                   follow =&gt; {
                       selected =&gt; '- my_check_list'
                   },
                   'rules' =&gt; [
                       '$selected.is_set(has_bar)' =&gt; {
                           level =&gt; 'normal'
                       }
                   ]
               }
           ]

</pre><h4><b>Methods</b></h4><pre>
   <b>warp_error</b>
       This method returns a string describing:

       •   The location(s) of the warp master

       •   The current value(s) of the warp master(s)

       •   The  other  values accepted by the warp master that can be tried (if the warp master is an enumerated
           type)

</pre><h4><b>How</b> <b>does</b> <b>this</b> <b>work</b> <b>?</b></h4><pre>
       Registration
           •   When a warped object is created, the constructor registers to the warp masters. The  warp  master
               are  found  by  using  the  special string passed to the "follow" parameter. As explained in grab
               method, the string provides the location of the warp master in the  configuration  tree  using  a
               symbolic form.

           •   Then the warped object retrieve the value(s) of the warp master(s)

           •   Then  the  warped  object warps itself using the above value(s). Depending on these value(s), the
               properties of the warped object are modified.

       Master update
           •   When a warp master value is updated, the warp master calls <u>all</u> its warped object  and  pass  them
               the new master value.

           •   Then each warped object modifies properties according to the new warp master value.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dominique Dumont, (ddumont at cpan dot org)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Config::Model::AnyThing,    Config::Model::HashId,    Config::Model::ListId,   Config::Model::WarpedNode,
       Config::Model::Value

</pre><h4><b>AUTHOR</b></h4><pre>
       Dominique Dumont

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2005-2022 by Dominique Dumont.

       This is free software, licensed under:

         The GNU Lesser General Public License, Version 2.1, February 1999

perl v5.40.0                                       2024-11-30                         <u>Config::Model::<a href="../man3pm/Warper.3pm.html">Warper</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>