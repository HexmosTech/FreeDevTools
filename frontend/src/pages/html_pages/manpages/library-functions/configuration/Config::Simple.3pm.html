<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Config::Simple - simple configuration file class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconfig-simple-perl">libconfig-simple-perl_4.59-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Config::Simple - simple configuration file class

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Config::Simple;

         # --- Simple usage. Loads the config. file into a hash:
         Config::Simple-&gt;import_from('app.ini', \%Config);

         # --- OO interface:
         $cfg = new Config::Simple('app.ini');

         # accessing values:
         $user = $cfg-&gt;param('User');

         # getting the values as a hash:
         %Config = $cfg-&gt;vars();

         # updating value with a string
         $cfg-&gt;param('User', 'sherzodR');

         # updating a value with an array:
         $cfg-&gt;param('Users', ['sherzodR', 'geek', 'merlyn']);

         # adding a new block to an ini-file:
         $cfg-&gt;param(-block=&gt;'last-access', -values=&gt;{'time'=&gt;time()});

         # accessing a block of an ini-file;
         $mysql = $cfg-&gt;param(-block=&gt;'mysql');

         # saving the changes back to file:
         $cfg-&gt;save();

         # --- tie() interface
         tie %Config, "Config::Simple", 'app.ini';

</pre><h4><b>ABSTRACT</b></h4><pre>
       Reading and writing configuration files is one of the most frequent tasks of any software design.
       Config::Simple is the library that helps you with it.

       Config::Simple is a class representing configuration file object.  It supports several configuration file
       syntax and tries to identify the file syntax automatically. Library supports parsing, updating and
       creating configuration files.

</pre><h4><b>ABOUT</b> <b>CONFIGURATION</b> <b>FILES</b></h4><pre>
       Keeping configurable variables in your program source code is ugly, really.  And for people without much
       of a programming experience, configuring your programs is like performing black magic. Besides, if you
       need to access these values from within multiple files, want your programs to be able to update
       configuration files or want to provide a friendlier user interface for your configuration files, you just
       have to store them in an external file. That's where Config::Simple comes into play, making it very easy
       to read and write configuration files.

       If you have never used configuration files before, here is a brief overview of various syntax to choose
       from. Otherwise you can jump to "PROGRAMMING STYLE".

   <b>SIMPLE</b> <b>CONFIGURATION</b> <b>FILE</b>
       Simple syntax is what you need for most of your projects. These are, as the name asserts, the simplest.
       File consists of key/value pairs, delimited by nothing but white space. Keys (variables) should be
       strictly alpha-numeric with possible dashes (-). Values can hold any arbitrary text. Here is an example
       of such a configuration file:

         Alias     /exec
         TempFile  /usr/tmp

       Comments start with a pound ('#') sign and cannot share the same line with other configuration data.

   <b>HTTP-LIKE</b> <b>SYNTAX</b>
       This format of separating key/value pairs is used by HTTP messages.  Each key/value is separated by semi-
       colon (:). Keys are alphanumeric strings with possible '-'. Values can be any arbitrary text:

       Example:

         Alias: /exec
         TempFile: /usr/tmp

       It is OK to have spaces around ':'. Comments start with '#' and cannot share the same line with other
       configuration data.

   <b>INI-FILE</b>
       These configuration files are more native to Win32 systems. Data is organized in blocks. Each key/value
       pair is delimited with an equal (=) sign. Blocks are declared on their own lines enclosed in '[' and ']':

         [BLOCK1]
         KEY1=VALUE1
         KEY2=VALUE2

         [BLOCK2]
         KEY1=VALUE1
         KEY2=VALUE2

       Your Winamp 2.x play list is an example of such a configuration file.

       This is the perfect choice if you need to organize your configuration file into categories:

         [site]
         url="<a href="http://www.handalak.com">http://www.handalak.com</a>"
         title="Web site of a \"Geek\""
         author=sherzodr

         [mysql]
         dsn="dbi:mysql:db_name;host=handalak.com"
         user=sherzodr
         password=marley01

   <b>SIMPLIFIED</b> <b>INI-FILE</b>
       These files are pretty much similar to traditional ini-files, except they don't have any block
       declarations. This style is handy if you do not want any categorization in your configuration file, but
       still want to use '=' delimited key/value pairs.  While working with such files, Config::Simple assigns
       them to a default block, called 'default' by default :-).

         url = "<a href="http://www.handalak.com">http://www.handalak.com</a>"

       Comments can begin with either pound ('#') or semi-colon (';'). Each comment should reside on its own
       line

</pre><h4><b>PROGRAMMING</b> <b>STYLE</b></h4><pre>
       Most of the programs simply need to be able to read settings from a configuration file and assign them to
       a hash. If that's all you need, you can simply use its <b>import_from()</b> - class method with the name of the
       configuration file and a reference to an existing (possibly empty) hash:

         Config::Simple-&gt;import_from('myconf.cfg', \%Config);

       Now your hash %Config holds all the configuration file's key/value pairs.  Keys of a hash are variable
       names inside your configuration file, and values are their respective values. If "myconf.cfg" was a
       traditional ini-file, keys of the hash consist of block name and variable delimited with a dot, such as
       "block.var".

       If that's all you need, you can stop right here. Otherwise, read on. There is much more Config::Simple
       offers.

   <b>READING</b> <b>THE</b> <b>CONFIGURATION</b> <b>FILE</b>
       To be able to use more features of the library, you will need to use its object interface:

         $cfg = new Config::Simple('app.cfg');

       The above line reads and parses the configuration file accordingly.  It tries to guess which syntax is
       used by passing the file to <b>guess_syntax()</b> method.  Alternatively, you can create an empty object, and
       only then read the configuration file in:

         $cfg = new Config::Simple();
         $cfg-&gt;read('app.cfg');

       As in the first example, <b>read()</b> also calls <b>guess_syntax()</b> method on the file.

       If, for any reason, it fails to guess the syntax correctly (which is less likely), you can try to debug
       by using its <b>guess_syntax()</b> method. It expects file handle for a  configuration file and returns the name
       of a syntax. Return value is one of "ini", "simple" or "http".

         open(FH, "app.cfg");
         printf("This file uses '%s' syntax\n", $cfg-&gt;guess_syntax(\*FH));

   <b>ACCESSING</b> <b>VALUES</b>
       After you read the configuration file in successfully, you can use <b>param()</b> method to access the
       configuration values. For example:

         $user = $cfg-&gt;param("User");

       will return the value of "User" from either simple configuration file, or http-styled configuration as
       well as simplified ini-files. To access the value from a traditional ini-file, consider the following
       syntax:

         $user = $cfg-&gt;param("mysql.user");

       The above returns the value of "user" from within "[mysql]" block. Notice the use of dot "." to delimit
       block and key names.

       Config::Simple also supports <b>vars()</b> method, which, depending on the context used, returns all the values
       either as hashref or hash:

         my %Config = $cfg-&gt;vars();
         print "Username: $Config{User}";

         # If it was a traditional ini-file:
         print "Username: $Config{'mysql.user'}";

       If you call <b>vars()</b> in scalar context, you will end up with a reference to a hash:

         my $Config = $cfg-&gt;vars();
         print "Username: $Config-&gt;{User}";

       If you know what you're doing, you can also have an option of importing all the names from the
       configuration file into your current name space as global variables.  All the block/key names will be
       uppercased and will be converted to Perl's valid variable names; that is, all the dots (block-key
       separator) and other '\W' characters will be substituted with underscore '_':

         $cfg = new Config::Simple('app.cfg');
         $cfg-&gt;import_names();

         # or, with a single line:
         Config::Simple-&gt;new('app.cfg')-&gt;import_names();

         print STDERR "Debugging mode is on" if $DEBUG_MODE;

       In the above example, if there was a variable 'mode' under '[debug]' block, it will be now accessible via
       $DEBUG_MODE, as opposed to $cfg-&gt;param('debug.mode');

       import_names() by default imports the values to its caller's name space.  Optionally, you can specify
       where to import the values by passing the name of the name space as the first argument. It also prevents
       potential name collisions:

         Config::Simple-&gt;new('app.cfg')-&gt;import_names('CFG');
         print STDERR "Debugging mode is on" if $CFG::DEBUG_MODE;

       If all you want is to import values from a configuration file, the above syntax may still seem longer
       than necessary. That's why Config::Simple supports <b>import_from()</b> - class method, which is called with the
       name of the configuration file. It will call <b>import_names()</b> for you:

         Config::Simple-&gt;import_from('app.cfg');

       The above line imports all the variables into the caller's name space. It's similar to calling
       <b>import_names()</b> on an object. If you pass a string as the second argument, it will treat it as the
       alternative name space to import the names into. As we already showed in the very first example, you can
       also pass a reference to an existing hash as the second argument. In this case, that hash will be
       modified with the values of the configuration file.

         # import into $CFG name space:
         Config::Simple-&gt;import_from('app.cfg', 'CFG');

         # import into %Config hash:
         Config::Simple-&gt;import_from('app.cfg', \%Config);

       The above line imports all the values to 'CFG' name space. <b>import_from()</b> returns underlying
       Config::Simple object (which you may not even need anymore):

         $cfg = Config::Simple-&gt;import_from('app.cfg', \my %Config);
         $cfg-&gt;write('app.cfg.bak');

   <b>UPDATING</b> <b>THE</b> <b>VALUES</b>
       Configuration values, once read into Config::Simple, can be updated from within your program by using the
       same <b>param()</b> method used for accessing them. For example:

         $cfg-&gt;param("User", "sherzodR");

       The above line changes the value of "User" to "sherzodR". Similar syntax is applicable for ini-files as
       well:

         $cfg-&gt;param("mysql.user", "sherzodR");

       If the key you're trying to update does not exist, it will be created. For example, to add a new
       "[session]" block to your ini-file, assuming this block doesn't already exist:

         $cfg-&gt;param("session.life", "+1M");

       You can also delete values calling <b>delete()</b> method with the name of the variable:

         $cfg-&gt;delete('mysql.user'); # deletes 'user' under [mysql] block

   <b>SAVING/WRITING</b> <b>CONFIGURATION</b> <b>FILES</b>
       The above updates to the configuration values are in-memory operations. They do not reflect in the file
       itself. To modify the files accordingly, you need to call either "<b>write()</b>" or "<b>save()</b>" methods on the
       object:

         $cfg-&gt;write();

       The above line writes the modifications to the configuration file. Alternatively, you can pass a name to
       either <b>write()</b> or <b>save()</b> to indicate the name of the file to create instead of modifying existing
       configuration file:

         $cfg-&gt;write("app.cfg.bak");

       If you want the changes saved at all times, you can turn "autosave" mode on by passing true value to
       $cfg-&gt;<b>autosave()</b>. It will make sure before your program is terminated, all the configuration values are
       written back to its file:

         $cfg = new Config::Simple('aff.cfg');
         $cfg-&gt;<a href="../man1/autosave.1.html">autosave</a>(1);

   <b>CREATING</b> <b>CONFIGURATION</b> <b>FILES</b>
       Occasionally, your programs may want to create their own configuration files on the fly, possibly from a
       user input. To create a configuration file from scratch using Config::Simple, simply create an empty
       configuration file object and define your syntax. You can do it by either passing "syntax" option to
       <b>new()</b>, or by calling <b>syntax()</b> method. Then play with <b>param()</b> method as you normally would.  When you're
       done, call <b>write()</b> method with the name of the configuration file:

         $cfg = new Config::Simple(syntax=&gt;'ini');
         # or you could also do:
         # $cfg-&gt;autosave('ini')

         $cfg-&gt;param("mysql.dsn", "DBI:mysql:db;host=handalak.com");
         $cfg-&gt;param("mysql.user", "sherzodr");
         $cfg-&gt;param("mysql.pass", 'marley01');
         $cfg-&gt;param("site.title", 'sherzodR "The Geek"');
         $cfg-&gt;write("new.cfg");

       This creates a file "new.cfg" with the following content:

         ; Config::Simple 4.43
         ; Sat Mar  8 00:32:49 2003

         [site]
         title=sherzodR "The Geek"

         [mysql]
         pass=marley01
         dsn=DBI:mysql:db;host=handalak.com
         user=sherzodr

       Neat, huh? Supported syntax keywords are "ini", "simple" or "http". Currently there is no support for
       creating simplified ini-files.

   <b>MULTIPLE</b> <b>VALUES</b>
       Ever wanted to define array of values in your single configuration variable? I have!  That's why
       Config::Simple supports this fancy feature as well. Simply separate your values with a comma:

         Files hp.cgi, template.html, styles.css

       Now <b>param()</b> method returns an array of values:

         @files = $cfg-&gt;param("Files");
         unlink $_ for @files;

       If you want a comma as part of a value, enclose the value(s) in double quotes:

         CVSFiles "hp.cgi,v", "template.html,v", "styles.css,v"

       In case you want either of the values to hold literal quote ("), you can escape it with a backlash:

         SiteTitle "sherzod \"The Geek\""

   <b>TIE</b> <b>INTERFACE</b>
       If OO style intimidates you, and import_from() is too simple for you, Config::Simple also supports <b>tie()</b>
       interface. This interface allows you to <b>tie()</b> an ordinary Perl hash to the configuration file. From that
       point on, you can use the variable as an ordinary Perl hash.

         tie %Config, "Config::Simple", 'app.cfg';

         # Using %Config as an ordinary hash
         print "Username is '$Config{User}'\n";
         $Config{User} = 'sherzodR';

       The difference between "import_from($file, \%Hash)" is, all the changes you make to the hash after
       <b>tie()</b>ing it, will also reflect in the configuration file object.  If <b>autosave()</b> was turned on, they will
       also be written back to file:

         tie %Config, "Config::Simple", "app.cfg";
         tied(%Config)-&gt;<a href="../man1/autosave.1.html">autosave</a>(1);

       To access the method provided in OO syntax, you need to get underlying Config::Simple object. You can do
       so with <b>tied()</b> function:

         tied(%Config)-&gt;write();

       WARNING: tie interface is experimental and not well tested yet. Let me know if you encounter a problem.

</pre><h4><b>MISCELLANEOUS</b></h4><pre>
   <b>CASE</b> <b>SENSITIVITY</b>
       By default, configuration file keys and values are case sensitive. Which means, $cfg-&gt;param("User") and
       $cfg-&gt;param("user") are referring to two different values.  But it is possible to force Config::Simple to
       ignore cases all together by enabling "-lc" switch while loading the library:

         use Config::Simple ('-lc');

       WARNING: If you call <b>write()</b> or <b>save()</b>, while working on "-lc" mode, all the case information of the
       original file will be lost. So use it if you know what you're doing.

   <b>USING</b> <b>QUOTES</b>
       Some people suggest if values consist of none alpha-numeric strings, they should be enclosed in double
       quotes. Well, says them! Although Config::Simple supports parsing such configuration files already, it
       doesn't follow this rule while writing them.  If you really need it to generate such compatible
       configuration files, "-strict" switch is what you need:

         use Config::Simple '-strict';

       Now, when you write the configuration data back to files, if values hold any none alpha-numeric strings,
       they will be quoted accordingly. All the double quotes that are part of the value will be escaped with a
       backslash.

   <b>EXCEPTION</b> <b>HANDLING</b>
       Config::Simple doesn't believe in dying that easily (unless you insult it using wrong syntax).  It leaves
       the decision to the programmer implementing the library. You can use its <b>error()</b> - class method to access
       underlying error message. Methods that require you to check for their return values are <b>read()</b> and
       <b>write()</b>. If you pass filename to <b>new()</b>, you will need to check its return value as well. They return any
       true value indicating success, undef otherwise:

         # following new() always returns true:
         $cfg = new Config::Simple();

         # read() can fail:
         $cfg-&gt;read('app.cfg') or die $cfg-&gt;error();

         # following new() can fail:
         $cfg = new Config::Simple('app.cfg') or die Config::Simple-&gt;error();

         # import_from() calls read(), so it can fail:
         Config::Simple-&gt;import_from('app.cfg', \%Config) or die Config::Simple-&gt;error();

         # write() may fail:
         $cfg-&gt;write() or die $cfg-&gt;error();

         # tie() may fail, since it calls new() with a filename
         tie %Config, "Config::Simple", 'app.cfg' or die Config::Simple-&gt;error();

</pre><h4><b>METHODS</b></h4><pre>
       <b>new()</b>
           -  constructor.  Optionally  accepts  several  arguments.  Returns  Config::Simple object.  Supported
           arguments are <b>filename</b>, <b>syntax</b>, <b>autosave</b>. If there is a single argument, will be treated as the  name
           of the configuration file.

       autosave([$bool])
           -  turns  'autosave'  mode  on if passed true argument. Returns current autosave mode if used without
           arguments. In 'autosave' mode Config::Simple writes all the changes back  to  its  file  without  you
           having to call <b>write()</b> or <b>save()</b>

       <b>read()</b>
           -  accepts name  of the configuration file to parse. Before that, it tries to guess the syntax of the
           file by calling <b>guess_syntax()</b> method. Then calls either  of  <b>parse_ini_file()</b>,  <b>parse_cfg_file()</b>  or
           <b>parse_http_file()</b>  accordingly. If the name of the file is provided to the constructor - <b>new()</b>, there
           is no need to call <b>read()</b>.

       param([$name], [$value])
           - used for accessing and updating configuration variables. If used with no arguments returns all  the
           available names from the configuration file.

       delete($name)
           -  deletes  a variable from a configuration file. $name has the same meaning and syntax as it does in
           param($name)

       <b>clear()</b>
           - clears all the data from the object. Calling <b>save()</b> or turning <b>autosave()</b> on results  in  an  empty
           configuration file as well.

       <b>vars()</b>
           - depending on the context used, returns all the values available in the configuration file either as
           a hash or a reference to a hash

       import_names([$NS])
           - imports all the names from the configuration file to the caller's name space. Optional argument, if
           passed,  will  be  treated  as  the  name space variables to be imported into.  All the names will be
           uppercased. Non-alphanumeric strings in the values will be underscored

       import_from($file, \%hash | $NS)
           - class method. If the second argument is a reference to an existing  hash,  it  will  load  all  the
           configuration  contents into that hash. If the second argument is a string, it will be treated as the
           name space variables should be imported into, just like <b>import_names()</b> does.

       get_block($name)
           is mostly used for accessing blocks in ini-styled configuration files.  Returns a hashref of all  the
           key/value pairs of a given block. Also supported by <b>param()</b> method with the help of "-block" option:

             $hash = $cfg-&gt;get_block('Project');
             # is the same as saying:
             $hash = $cfg-&gt;param(-block=&gt;'Project');

       set_block($name, $values)
           used  in assigning contents to a block in ini-styled configuration files. $name should be the name of
           a [block], and $values is assumed to be a hashref mapping key/value pairs.  Also supported by <b>param()</b>
           method with the help of "-block" and "-value" (or "-values") options:

             $cfg-&gt;set_block('Project', {Count=&gt;3, 'Multiple Column' =&gt; 20});
             # is the same as:
             $cfg-&gt;param(-block=&gt;'Project', -value=&gt;{Count=&gt;3, 'Multiple Column' =&gt; 20});

           Warning: all the contents of a block, if previously existed will be wiped out.  If you  want  to  set
           specific key/value pairs, use explicit method:

             $cfg-&gt;param('Project.Count', 3);

       <b>as_string()</b>
           -  returns  the configuration file as a chunk of text. It is the same text used by <b>write()</b> and <b>save()</b>
           to store the new configuration file back to file.

       <b>write()</b>
           - writes the configuration file into disk. Argument, if passed, will be treated as the  name  of  the
           file configuration variables should be saved in.

       <b>save()</b>
           - same as <b>write()</b>.

       <b>dump()</b>
           - for debugging only. Dumps the whole Config::Simple object using Data::Dumper.  Argument, if passed,
           will  be  treated  as the name of the file object should be dumped in.  The second argument specifies
           amount of indentation as documented in Data::Dumper manual. Default indent size is 2.

       <b>error()</b>
           - returns the last error message from read/write or import_* operations.

</pre><h4><b>TODO</b></h4><pre>
       •   Support for lines with continuation character, '\'. Currently its support  is  restricted  and  quite
           possibly buggy.

       •   Retaining  comments  while  writing  the  configuration  files  back  and/or methods for manipulating
           comments. Everyone loves comments!

       •   Retain the order of the blocks and other variables in the configuration files.

</pre><h4><b>BUGS</b></h4><pre>
       Submit bugs and possibly patches to Sherzod B. Ruzmetov &lt;<a href="mailto:sherzodr@cpan.org">sherzodr@cpan.org</a>&gt;.

</pre><h4><b>CREDITS</b></h4><pre>
       Michael Caldwell (<a href="mailto:mjc@mjcnet.com">mjc@mjcnet.com</a>)
           whitespace support, "-lc" switch and for various bug fixes

       Scott Weinstein (<a href="mailto:Scott.Weinstein@lazard.com">Scott.Weinstein@lazard.com</a>)
           bug fix in TIEHASH

       Ruslan U. Zakirov &lt;<a href="mailto:cubic@wr.miee.ru">cubic@wr.miee.ru</a>&gt;
           default name space suggestion and patch

       Hirosi Taguti
           <b>import_names()</b> and <b>import_from()</b> idea.

       Vitaly Kushneriuk
           for bug fixes and suggestions

</pre><h4><b>COPYRIGHT</b></h4><pre>
         Copyright (C) 2002-2003 Sherzod B. Ruzmetov.

         This software is free library. You can modify and/or distribute it
         under the same terms as Perl itself

</pre><h4><b>AUTHOR</b></h4><pre>
         Sherzod B. Ruzmetov E&lt;lt&gt;<a href="mailto:sherzodr@cpan.orgE">sherzodr@cpan.orgE</a>&lt;gt&gt;
         URI: <a href="http://author.handalak.com">http://author.handalak.com</a>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Config::General, Config::Simple, Config::Tiny

perl v5.38.2                                       2024-03-04                                        <u><a href="../man3pm/Simple.3pm.html">Simple</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>