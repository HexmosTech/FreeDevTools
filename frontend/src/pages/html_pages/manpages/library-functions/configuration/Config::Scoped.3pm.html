<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Config::Scoped - feature rich configuration file parser</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconfig-scoped-perl">libconfig-scoped-perl_0.22-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Config::Scoped - feature rich configuration file parser

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Config::Scoped;

         $cs = Config::Scoped-&gt;new( file =&gt; $config_file, ... );
         $cfg_hash = $cs-&gt;parse;

</pre><h4><b>ABSTRACT</b></h4><pre>
       <b>Config::Scoped</b> is a configuration file parser.

   <b>Features</b>
       •   recursive data structures with scalars, lists, and hashes

       •   simplified syntax with minimal punctuation

       •   parses many Perl data structures without <b>eval</b>, <b>do</b> or <b>require</b>

       •   Perl quoting syntax: single quotes (<b>''</b>), double quotes(<b>""</b>), and here-docs (<b>&lt;&lt;EOF</b>)

       •   Perl code evaluation in <b>Safe</b> compartments

       •   parses ISC named and dhcpd config files

       •   include files with recursion checks

       •   controlled macro expansion in double quoted tokens

       •   lexically scoped parameter assignments and directives

       •   duplicate macro, parameter, and declaration checks

       •   file permission and ownership safety checks

       •   fine control over error checking

       •   error messages report config file names and line numbers

       •   exception-based error handling

       •   based on <b>Parse::RecDescent</b>

       •   configuration caching with MD5 checksums on the original files

       •   may be subclassed to build parsers with specialized features

</pre><h4><b>REQUIRES</b></h4><pre>
       •   <b>Parse::RecDescent</b>

       •   <b>Error</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       Nothing.

</pre><h4><b>METHODS</b></h4><pre>
       <b>Config::Scoped-&gt;new</b>
             $cs = Config::Scoped-&gt;new(
               file     =&gt; $config_file,
               lc       =&gt; $lc,
               safe     =&gt; $compartment,
               warnings =&gt; $warnings,
               your_key =&gt; $your_value, { ... },
             );

           Creates and returns a new <b>Config::Scoped</b> object. The following parameters are optional.

           <b>$config_file</b>
               The  configuration file to parse. If omitted, then a <b>$config_string</b> must be provided to the <b>parse</b>
               method (see below).

           <b>$lc</b> If true, all declaration and parameter names will be converted to lower case.

           <b>$compartment</b>
               A <b>Safe</b> compartment for evaluating Perl code blocks in the configuration file. Defaults to a  <b>Safe</b>
               compartment with no extra shares and the <b>:default</b> operator tag.

           <b>$warnings</b>
               may be the literal string <b>'on'</b> or <b>'off'</b> to set all warnings simultan.

               Or define a hash reference with the following keys to set each warning as specified.

                 $warnings = { declaration  =&gt; 'off',
                               digests      =&gt; 'off',
                               macro        =&gt; 'off',
                               parameter    =&gt; 'off',
                               permissions  =&gt; 'off',
                               your_warning =&gt; 'off',
                };

               All warnings are on by default.

           <b>Arbitrary</b> <b>key/value</b> <b>pairs</b>
               will be stored in the <b>$cs</b> object. This is useful primarily for subclassing.

       <b>$cs-&gt;parse</b>
               $cfg_hash = $cs-&gt;parse;
               $cfg_hash = $cs-&gt;parse(text =&gt; $config_string);

           Parses the configuration and returns a reference to the config hash.

           The  first form parses the <b>$config_file</b> that was provided to the constructor. If <b>$config_file</b> was not
           provided to the constructor, this form <b>die</b>s.

           The second form parses the <b>$config_string</b>.

           This method must only be called once.

       <b>$cs-&gt;store_cache</b>
               $cs-&gt;store_cache;
               $cs-&gt;store_cache(cache =&gt; $cache_file);

           Stores the config hash on disk for rapid retrieval. If <b>$config_file</b> was provided to the  constructor,
           then the stored form includes checksums of <b>$config_file</b> and any included files.

           The first  form writes to <b>$config_file.dump</b> The second form writes to <b>$cache_file</b>.

           If <b>$config_file</b> was not provided to the constructor, the first form <b>die</b>s.

       <b>$cs-&gt;retrieve_cache</b>
               $cfg_hash = $cs-&gt;retrieve_cache;
               $cfg_hash = $cs-&gt;retrieve_cache&gt;(cache =&gt; $cache_file);

           Retrieves the <b>$config</b> hash from a file that was created by <b>store_cache</b>.

           The first  form reads <b>$config_file.dump</b> The second form reads <b>$cache_file</b>.

           If <b>$config_file</b> was not provided to the constructor, the first form <b>die</b>s.

           The stored file is subject to <b>digests</b> and <b>permissions</b> checks.

       <b>$cs-&gt;set_warnings</b>
               $cs-&gt;set_warnings(name =&gt; $name, switch =&gt; 'on|off');

           Change warning for <b>$name</b> after construction.

       <b>$cs-&gt;warnings_on</b>
               $on = $cs-&gt;warnings_on(name =&gt; $name);

           Returns true if warning <b>$name</b> is on. This is useful primarily for subclassing.

</pre><h4><b>EXCEPTIONS</b></h4><pre>
       All methods <b>die</b> on error.

       <b>Config::Scoped::Error</b>  defines a hierarchy of classes that represent <b>Config::Scoped</b> errors. When a method
       detects an error, it creates an instance of the corresponding class and throws it. The error classes  are
       all subclasses of <b>Config::Scoped::Error</b>. See Config::Scoped::Error for the complete list.

       If  the  exception  is not caught, the program terminates, and <b>Config::Scoped</b> prints the config file name
       and line number where the error was detected to <b>STDERR</b>.

</pre><h4><b>CONFIG</b> <b>FILE</b> <b>FORMAT</b></h4><pre>
       <b>Config::Scoped</b> parses configuration files.

       If we have a config file like

         % cat host.cfg
         host {
             name = cpan.org
             port = 22
         }
         %

       we can parse it into Perl with code like

           $cs = Config::Scoped-&gt;new( file =&gt; 'host.cfg' );
           $cfg_hash = $cs-&gt;parse;

       The result is always a hash ref. We'll call this the <b>config</b> <b>hash</b>, and its contents for the  example  file
       above is:

           $cfg_hash = {
              host =&gt; {
                 name =&gt; 'cpan.org',
                 port =&gt; 22,
              }
             }

   <b>Config</b> <b>files</b> <b>and</b> <b>config</b> <b>strings</b>
       As  described,  <b>Config::Scoped</b> can obtain a configuration from a <b>$config_file</b>, passed to the constructor,
       or from a <b>$config_string</b>,  passed  to  the  <b>parse</b>  method.  For  simplicity,  we'll  talk  about  parsing
       configuration files, distinguishing configuration strings only when necessary.

   <b>File</b> <b>layout</b>
       Config files are free-form text files.  Comments begin with <b>#</b>, and extend to the end of the line.

   <b>Declarations</b>
       The  top-level  elements  of  a  config  file  are called <b>declarations</b>. A declaration consists of a name,
       followed by a block

         foo {
         }

         bar {
         }

       The declaration names become keys in the config hash. The value of each key  is  another  hash  ref.  The
       config shown above parses to

           $cfg_hash = {
              foo =&gt; {},
              bar =&gt; {},
             }

       You can create additional levels in the config hash simply by listing successive declaration names before
       the block. This config

         dog hound {
         }

         dog beagle {
         }

         cat {
         }

       parses to

           $cfg_hash = {
              dog =&gt; {
                 hound  =&gt; {},
                 beagle =&gt; {},
              },

              cat =&gt; {}
             }

       Declarations may not be nested.

   <b>Parameters</b>
       The  ultimate  purpose of a configuration file is to provide data values for a program.  These values are
       specified by <b>parameters</b>.

       Parameters have the form

         name = value

       and go inside declaration blocks. The

         name = value

       parameters in a spec file become key and value pairs inside the declaration hashes in Perl code.

       For example, this configuration

         dog {
             legs  = 4
             wings = 0
         }

         bird {
             legs  = 2
             wings = 2
         }

       parses to

           $cfg_hash = {
              dog =&gt; {
                 legs  =&gt; 4,
                 wings =&gt; 0,
              },

              bird =&gt; {
                 legs  =&gt; 2,
                 wings =&gt; 2,
              }
             }

       <b>Parameter</b> <b>values</b> can be <b>scalars</b>, <b>lists</b> or <b>hashes</b>.

       Scalar values may be numbers or strings

         shape = square
         sides = 4

       Lists values are enclosed in square brackets

         colors = [ red green blue ]
         primes = [ 2 3 5 7 11 13  ]

       Hash values are enclosed in curly brackets

         capitals = {
               England =&gt; London
               France  =&gt; Paris
         }

       A hash value is also called a <b>hash</b> <b>block</b>.

       Lists and hashes can be nested to arbitrary depth

         Europe {
            currency = euro

            cities   = {
               England =&gt; [ London Birmingham Liverpool ]
               France  =&gt; [ Paris Canne Calais ]
            }
          }

       parses to

           $cfg_hash = {
              Europe =&gt; {
                 currency =&gt; 'euro',

                 cities =&gt; {
                    England =&gt; [ 'London', 'Birmingham', 'Liverpool' ],
                    France  =&gt; [ 'Paris',  'Canne',      'Calais' ],
                 }
              }
             }

       The <b>Config::Scoped</b> data syntax is similar to the Perl data syntax, and  <b>Config::Scoped</b>  will  parse  many
       Perl  data  structures.  In  general,  <b>Config::Scoped</b>  requires  less  punctuation  that  Perl. Note that
       <b>Config::Scoped</b> allows arrow (<b>=&gt;</b>) or equals (<b>=</b>) between hash keys and values, but not comma (<b>,</b>)

         capitals = { England =&gt; London        # OK
                      France  =  Paris         # OK
                      Germany ,  Berlin        # error
                    }

   <b>_GLOBAL</b>
       If a config file contains no declarations at all

         name = cpan.org
         port = 22

       then any parameters will be placed in a <b>_GLOBAL</b> declaration in the config hash

          $cfg_hash = {
             _GLOBAL =&gt; {
                name =&gt; 'cpan.org',
                port =&gt; 22,
             }
            }

       This allows very simple config files with just parameters and no declarations.

   <b>Blocks,</b> <b>scoping</b> <b>and</b> <b>inheritance</b>
       Each declaration block in a config file creates a lexical scope.  Parameters  inside  a  declaration  are
       scoped to that block. Parameters are inherited by all following declarations within their scope.

       If all your animals have four legs, you can save some typing by writing

           legs = 4
           cat {}
           dog {}

       which parses to

          $cfg_hash = {
             cat =&gt; { legs =&gt; 4 },
             dog =&gt; { legs =&gt; 4 },
            }

       If  some of your animals have two legs, you can create additional scopes with anonymous blocks to control
       inheritance

           {
             legs = 4
             cat {}
             dog {}
           }
           {
             legs = 2
             bird {}
           }

       parses to

          $cfg_hash = {
             cat  =&gt; { legs =&gt; 4 },
             dog  =&gt; { legs =&gt; 4 },
             bird =&gt; { legs =&gt; 2 },
            }

       Anonymous blocks may be nested.

       Each hash block also creates a scope. The hash does not inherit parameters from outside its own scope.

   <b>Perl</b> <b>code</b> <b>evaluation</b>
       If you can't express what you need within the <b>Config::Scoped</b> syntax, your escape hatch is

         eval { ... }

       This does a Perl <b>eval</b> on the block, and replaces the construct with the results of the <b>eval</b>.

         start = eval { localtime }
         foo   = eval { warn 'foo,' if $debug; return 'bar' }

       The block is evaluated in scalar context. However, it may return  a  list  or  hash  reference,  and  the
       underlying list or hash can become a parameter value.

       For example

         foo {
           list = eval { [ 1 .. 3 ]                 }
           hash = eval { { a =&gt; 1, b =&gt; 2, c =&gt; 3 } }
         }

       parses to

          $cfg_hash = {
             foo =&gt; {
                list =&gt; [ 1, 2, 3 ],
                hash =&gt; { a =&gt; 1, b =&gt; 2, c =&gt; 3 },
             }
            }

       The  block is evaluated inside the parser's <b>Safe</b> compartment. Variables can be made available to the <b>eval</b>
       by sharing them with the compartment.

       To set the <b>$debug</b> variable in the example above, do

           $compartment     = Safe-&gt;new('MY_SHARE');
           $MY_SHARE::debug = 1;

           $cs = Config::Scoped-&gt;new(
             file =&gt; 'config.txt',
             safe =&gt; $compartment,
           );

           $cfg_hash = $cs-&gt;parse;

       Only global variables can be shared with a compartment; lexical variables cannot.

       <b>perl_code</b> is a synonym for <b>eval</b>.

   <b>Tokens</b> <b>and</b> <b>quoting</b>
       A <b>token</b> is a

       •   declaration name

       •   parameter name

       •   hash key

       •   scalar value

       •   macro name

       •   macro value

       •   include path

       •   warning name

       Any token may be quoted.

       Tokens that contain special characters must be quoted. The special characters are

         \s {} [] &lt;&gt; () ; , ' " = # %

       <b>Config::Scoped</b> uses the Perl quoting syntax.

       Tokens may be quoted with either single or double quotes

         a = 'New York'
         b = "New Jersey\n"

       Here-docs are supported

         a = &lt;&lt;EOT
         New York
         New Jersey
         EOT

       but generalized quotes (<b>q()</b>, <b>qq()</b>, etc.) are not. Text in here-docs is regarded as single-quoted  if  the
       delimiter  is  enclosed in single quotes, and double-quoted if the delimiter is enclosed in double quotes
       or unquoted.

       Double-quoted tokens are evaluated as Perl strings inside the parser's <b>Safe</b> compartment. They are subject
       to the usual Perl backslash and variable interpolation, as well  as  macro  expansion.  Variables  to  be
       interpolated are passed via the <b>Safe</b> compartment, as shown above in "Perl code evaluation". If you need a
       literal  <b>$</b>  or  <b>@</b>  in  a  double-quoted  string,  be  sure  to escape it with a backslash (<b>\</b>) to suppress
       interpolation.

       An

         eval { ... }

       may appear anywhere that a token is expected. For example

         foo {
             eval { 'b' . 'c' } = 1
         }

       parses to

           $cfg_hash = { foo =&gt; { bc =&gt; 1 } }

</pre><h4><b>DIRECTIVES</b></h4><pre>
       <b>Config::Scoped</b> has three directives: <b>%macro</b>, <b>%warning</b>, and <b>%include</b>.

   <b>Macros</b>
       <b>Config::Scoped</b> supports macros. A macro is defined with

         %macro name value

       Macros may be defined

       •   at file scope

       •   within anonymous blocks

       •   within declaration blocks

       •   within hash blocks

       Macros defined within blocks are lexically scoped to those blocks.

       Macro substitution occurs

       •   within <b>any</b> double-quoted text

       •   within the <b>entirety</b> of Perl <b>eval</b> blocks

       •   nowhere else

   <b>Include</b> <b>files</b>
       <b>Config::Scoped</b> supports include files.

       To include one config file within another, write

         %include path/to/file

       <b>%include</b> directives may appear

       •   at file scope

       •   within anonymous blocks

       •   nowhere else

       In particular, <b>%include</b> directives may not appear within declaration blocks or hash blocks.

       Parameters and macros in include files are imported to the current scope. You can control this scope with
       an anonymous block

         {
           %include dog.cfg
           dog { }  # sees imports from dog.cfg
         }
         bird { }   # does not see imports from dog.cfg

       Warnings are scoped to the included file and do not leak to the parent file.

       Pathnames are either

       •   absolute

       •   relative to the dirname of the current configuration file

       For example, this config

           # in configuration file /etc/myapp/global.cfg
           %include shared.cfg

       includes the file <u>/etc/myapp/shared.cfg</u>.

       When parsing a configuration string, the path is relative to the current working directory.

       Include files are not actually included as text. Rather, they  are  processed  by  a  recursive  call  to
       <b>Config::Scoped</b>. Subclass implementers may need to be aware of this.

   <b>Warnings</b>
       <b>Config::Scoped</b> can check for 5 problems with config files

       •   duplicate declaration names

       •   duplicate parameter definitions

       •   duplicate macro definitions

       •   insecure config file permissions

       •   invalid config cache digests

       The  API  refers to these as "warnings", but they are actually errors, and if they occur, the parse fails
       and throws an exception. For consistency with the API, we'll use the term "warning" in the POD.

       The five warnings are identified by five predefined <b>warning</b> <b>names</b>

       •   <b>declaration</b>

       •   <b>parameter</b>

       •   <b>macro</b>

       •   <b>permissions</b>

       •   <b>digests</b>

       The <b>permissions</b> check requires that the config file

       •   be owned by root or the real UID of the running process AND

       •   have no group or world write permissions

       These restrictions help prevent an attacker from subverting a program by altering its config files.

       The <b>store_cache</b> method computes MD5 checksums for the config file and all included files. These checksums
       are stored with the cached configuration.

       The <b>retrieve_cache</b> method recomputes the checksums of the files and compares them to the stored values.

       The <b>digests</b> check requires that the checksums agree. This helps prevent programs from  relying  on  stale
       configuration caches.

       All warnings are enabled by default.

       Warnings can be disabled by passing the <b>warning</b> key to the constructor or with the <b>set_warnings</b> method.

       Warnings can also be controlled with the <b>%warnings</b> directive, which has the form

       <b>%warnings</b> [<b>name</b>] <b>off</b>|<b>on</b>

       A <b>%warnings</b> directive applies to the <b>name</b>d warning, or to all warnings, if <b>name</b> is omitted.

       <b>%warnings</b>  directives  allow  warnings to be turned on and off as necessary throughout the config file. A
       <b>%warnings</b> directive may appear

       •   at file scope

       •   within anonymous blocks

       •   within declaration blocks

       •   within hash blocks

       Each <b>%warnings</b> directive is lexically scoped to its enclosing file or block.

       Example

         legs = 4
         cat  {}
         dog  {}
         bird
         {
             legs = 2
         }

       fails with a duplicate parameter warning, but

         legs = 4
         cat  {}
         dog  {}
         bird
         {
             %warnings parameter off;
             legs = 2
         }

       successfully parses to

           $cfg_hash = {
               cat  =&gt; { legs =&gt; 4 },
               dog  =&gt; { legs =&gt; 4 },
               bird =&gt; { legs =&gt; 2 },
             }

</pre><h4><b>Best</b> <b>practices</b></h4><pre>
       As with all things Perl, there's  more  than  one  way  to  write  configuration  files.  Here  are  some
       suggestions for writing config files that are concise, readable, and maintainable.

   <b>Perl</b> <b>data</b>
       <b>Config::Scoped</b>  accepts  most Perl data syntax. This allows Perl data to pulled into config files largely
       unaltered

         foo
         {
            a = 1;
            b = [ 'red', 'green', 'blue' ];
            c = { x =&gt; 5,
                  y =&gt; 6 };
         }

       However, <b>Config::Scoped</b> doesn't require as much punctuation  as  Perl,  and  config  files  written  from
       scratch will be cleaner without it

         foo
         {
            a = 1
            b = [ red green blue ]
            c = { x =&gt; 5
                  y =&gt; 6 }
         }

   <b>Anonymous</b> <b>blocks</b>
       Don't use anonymous blocks unless you need to restrict the scope of something. In particular, there is no
       need for a top-level anonymous block around the whole config file

         {             # unnecessary
             foo { }
         }

   <b>Inheritance</b>
       Parameters  that are outside of a declaration are inherited by <b>all</b> following declarations in their scope.
       Don't do this unless you mean it

         wheels = 4
         car
         {
             # OK
         }
         cat
         {
             # I can haz weelz?
         }

   <b>Blocks,</b> <b>blocks,</b> <b>we</b> <b>got</b> <b>blocks...</b>
       <b>Config::Scoped</b> has four different kinds of blocks

       •   anonymous

       •   declaration

       •   eval

       •   hash

       They all look the same, but they aren't, and they have different rules and restrictions. See "CONFIG FILE
       FORMAT" for descriptions of each.

   <b>Macros</b>
       Macros are evil, and <b>Config::Scoped</b> macros are specially evil, because

       •   they don't respect token boundaries

       •   where multiple substitutions are possible, the substitution order is undefined

       •   substituted text may or may not be rescanned for further substitutions

       Caveat scriptor.

</pre><h4><b>SUBCLASSING</b></h4><pre>
       <b>Config::Scoped</b> has no  formally  defined  subclass  interface.  Here  are  some  guidelines  for  writing
       subclasses.   Implementers  who  override  (or  redefine)  base  class  methods  may  need  to  read  the
       <b>Config::Scoped</b> sources for more information.

       Arbitrary

         $your_key =&gt; $value

       pairs may be passed to the <b>Config::Scoped</b> constructor. They will be stored in the  <b>$cs-&gt;{local}</b>  hashref,
       and methods may access them with code like

         $cs-&gt;{local}{$your_key}

       To  avoid  conflict with existing keys in the <b>local</b> hash, consider distinguishing your keys with a unique
       prefix.

       Arbitrary warning names may be defined, set with <b>new</b> and <b>set_warnings</b>, used in <b>%warnings</b> directives,  and
       tested with <b>warnings_on</b>. Methods can call <b>warnings_on</b> to find out whether a warning is currently enabled.

       All   methods   throw  exceptions  (<b>die</b>)  on  error.  The  exception  object  should  be  a  subclass  of
       <b>Config::Scoped::Error</b>. You can use one of the classes defined in <b>Config::Scoped::Error</b>, or you can derive
       your own. This code

           Config::Scoped::Error-&gt;throw(
               -file =&gt; $cs-&gt;_get_file(%args),
               -line =&gt; $cs-&gt;_get_line(%args),
               -text =&gt; $message,
           );

       will generate an error message that reports the location in the config file where the error was detected,
       rather than a location in Perl code.

       <b>Config::Scoped</b>  performs  validation  checks  on  the  elements  of  configuration  files  (declarations,
       parameters,  macros,  etc).  Here  are  the interfaces to the validation methods. Subclasses can override
       these methods to modify or extend the validation checks.

       <b>$macro_value</b> <b>=</b> <b>$cs-&gt;macro_validate&gt;(name</b> <b>=&gt;</b> <b>$name,</b> <b>value</b> <b>=&gt;</b> <b>$value)</b>
           Called for each <b>%macro</b> directive.

           Receives the <b>$name</b> and <b>$value</b> from the directive. The returned <b>$macro_value</b> becomes the actual  value
           of the macro.

           If the macro is invalid, throws a <b>Config::Scoped::Error::Validate::Macro</b> exception.

       <b>$param_value</b> <b>=</b> <b>$cs-&gt;parameter_validate&gt;(name</b> <b>=&gt;</b> <b>$name,</b> <b>value</b> <b>=&gt;</b> <b>$value)</b>
           Called for each parameter definition.

           Receives the <b>$name</b> and <b>$value</b> from the definition. The returned <b>$param_value</b> becomes the actual value
           of the parameter.

           If the parameter is invalid, throws a <b>Config::Scoped::Error::Validate::Parameter</b> exception.

       <b>$cs-&gt;declaration_validate(name</b> <b>=&gt;</b> <b>$name,</b> <b>value</b> <b>=&gt;</b> <b>$value,</b> <b>tail</b> <b>=&gt;</b> <b>$tail)</b>
           Called for each declaration.

           <b>$name</b>  is  an  array  ref  giving  the chain of names for the declaration block. <b>$value</b> is a hash ref
           containing all the parameters in the declaration block. <b>$tail</b>  is  a  hash  ref  containing  all  the
           parameters in any previously defined declaration with the same name(s).

           For example, the declaration

             foo bar baz { a=1 b=2 }

           leads to the call

             $cs-&gt;declaration_validate(name  =&gt; [ qw(foo bar baz) ],
                                           value =&gt; { a =&gt; '1', b =&gt; '2' },
                                           tail  =&gt; $cs-&gt;{local}{config}{foo}{bar}{baz});

           The  method  can test %$tail to discover if there is an existing, non-empty declaration with the same
           name(s).

           The method has no return value. However, the method can alter the contents of %$value.  Upon  return,
           the parameters in %$value become the actual contents of the declaration block.

           If the declaration is invalid, throws a <b>Config::Scoped::Error::Validate::Declaration</b> exception.

       <b>$cs-&gt;permissions_validate(file</b> <b>=&gt;</b> <b>$file,</b> <b>handle</b> <b>=&gt;</b> <b>$handle)</b>
           Called  for  the  config  file,  each  included  file, and each retrieved cache file. One of <b>$file</b> or
           <b>$handle</b> must be non-null.

           Throws a <b>Config::Scoped::Error::Validate::Permissions</b> exception if the file is not safe to read.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   <b>Error</b>

       •   <b>Safe</b>

       •   <b>Config::Scoped::Error</b>

       •   <b>Parse::RecDescent</b>

       •   "Quote and Quote-like Operators" in perlop

</pre><h4><b>TODO</b></h4><pre>
       Tests
           Still more tests needed.

</pre><h4><b>BUGS</b></h4><pre>
       If you find parser bugs, please send the stripped down config file and additional version information  to
       the author.

</pre><h4><b>CREDITS</b></h4><pre>
       POD by Steven W. McDougall &lt;<a href="mailto:swmcd@world.std.com">swmcd@world.std.com</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Karl Gaissmaier &lt;karl.gaissmaier at uni-ulm.de&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2004-2012 by Karl Gaissmaier

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.38.2                                       2024-01-21                                <u>Config::<a href="../man3pm/Scoped.3pm.html">Scoped</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>