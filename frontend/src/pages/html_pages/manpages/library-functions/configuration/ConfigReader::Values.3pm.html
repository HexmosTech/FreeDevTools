<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ConfigReader::Values  -  stores a set of configuration values</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libconfigreader-perl">libconfigreader-perl_0.5-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ConfigReader::Values  -  stores a set of configuration values

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class stores a set of configuration values that have been read from a configuration file.  Methods
       are provided to define directives, assign and retrieve values, and to create accessor subroutines.

       As this class will usually be subclassed to implement a reader for a specific style of configuration
       files, the user-oriented methods will be described first.  Methods used to help implement a subclass are
       described later.

</pre><h4><b>USER</b> <b>METHODS</b></h4><pre>
   <b>"directive($directive,</b> <b>[$parser,</b> <b>[$default,</b> <b>[$whence]]])"</b>
       Defines a directive named $directive for the configuration file.  You may optionally specify a parsing
       function or method for the directive, and a default value.

       If $directive is a simple string, it will be used as both the name of the directive inside of the program
       and in the configuration file.  You can use an array ref of the form

            ['program-name', 'name1', 'name2', 'name3' ...]

       to use 'program-name' inside of the program, but to recognize any of 'name1', 'name2', 'name3' as the
       name of directive in the configuration file.

       A directive will be set to undef if you don't specify a default value and it is not set in the
       configuration file.

       Any errors or warnings that occur while parsing the default value are normally reported as orginating in
       the caller's module.  You can change the reported location by specifying $whence.

   <b>"required($directive,</b> <b>[$parser,</b> <b>[$whence]])"</b>
       Defines a directive which must be specified in the configuration file.

   <b>"ignore($directive,</b> <b>[$whence])"</b>
       Defines a directive which will be accepted but ignored in the configuration file.

   <b>"directives()"</b>
       Returns an array of the configuration directive names.

   <b>"value($directive,</b> <b>[$whence])"</b>
       Returns the value of the configuration directive $directive.

   <b>"define_accessors([$package,</b> <b>[@names]])"</b>
       Creates subroutines in the caller's package to access configuration values.  For example, if one of the
       configuration directives is named "Input_File", you can do:

           $config-&gt;define_accessors();
           ...

           open(IN, Input_File());

       The names of the created subroutines is returned in an array.  If you'd like to export the accessor
       subroutines, you can say:

           push @EXPORT, $config-&gt;define_accessors();

       You can specify the package in which to create the subroutines with the optional $package argument.  You
       may also specify which configuration directives to create accessor subroutines for.  By default,
       subroutines will be created for all the directives.

</pre><h4><b>IMPLEMENTATION</b> <b>METHODS</b></h4><pre>
       The following methods will probably be called by a subclass implementing a reader for a particular style
       of configuration files.

   <b>new(</b> <b>[$spec]</b> <b>)</b>
       The static method <b>new()</b> creates and returns a new ConfigReader::Values object.

       Unless the optional $spec argument is present, a new ConfigReader::Spec object will be created to store
       the configuration specification.  The <b>directive()</b>, <b>required()</b>, <b>ignore()</b>, <b>value()</b>, and <b>directive()</b> methods
       described above are passed through to the spec object.

       By setting $spec, you can use a different class (perhaps a subclass) to store the specification.

       You can also set $spec if you want to use one specification for multiple sets of values.  Files like
       /etc/termcap describe a configuration for multiple objects (terminals, in this case), but use the same
       directives to describe each object.

   <b>"values()"</b>
       Returns the hash ref which actually stores the configuration directive values.  The key of the hash ref
       is the directive name.

   <b>"spec()"</b>
       Returns the internal spec object used to store the configuration specification.

   <b>"assign($directive,</b> <b>$value_string,</b> <b>$whence)"</b>
       Normally called while reading the configuration file, assigns a value to the directive named $directive.
       The $value_string will be parsed by the directive's parsing function or method, if any.  $whence should
       describe the line in the configuration file which contained the value string.

   <b>"assign_defaults($whence)"</b>
       After the configuration file is read, the <b>assign_defaults()</b> method is called to assign the default values
       for directives which were not specified in the configuration file.  $whence should describe the name of
       the configuration file.

perl v5.36.0                                       2022-10-13                          <u>ConfigReader::<a href="../man3pm/Values.3pm.html">Values</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>