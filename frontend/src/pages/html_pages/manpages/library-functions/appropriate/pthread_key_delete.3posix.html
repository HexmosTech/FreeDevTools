<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       pthread_key_delete — thread-specific data key deletion

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;

       int pthread_key_delete(pthread_key_t <u>key</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>pthread_key_delete</u>()  function  shall  delete  a  thread-specific  data  key  previously returned by
       <u>pthread_key_create</u>().  The thread-specific data values associated with <u>key</u> need not be NULL at  the  time
       <u>pthread_key_delete</u>()  is  called.  It  is  the  responsibility of the application to free any application
       storage or perform any cleanup actions for data structures related  to  the  deleted  key  or  associated
       thread-specific data in any threads; this cleanup can be done either before or after <u>pthread_key_delete</u>()
       is  called.  Any  attempt  to  use  <u>key</u>  following  the call to <u>pthread_key_delete</u>() results in undefined
       behavior.

       The <u>pthread_key_delete</u>() function shall be callable  from  within  destructor  functions.  No  destructor
       functions  shall  be  invoked  by  <u>pthread_key_delete</u>().   Any  destructor  function  that  may have been
       associated with <u>key</u> shall no longer be called upon thread exit.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       If successful, the <u>pthread_key_delete</u>() function shall return zero; otherwise, an error number  shall  be
       returned to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>pthread_key_delete</u>() function shall not return an error code of <b>[EINTR]</b>.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       None.

</pre><h4><b>RATIONALE</b></h4><pre>
       A thread-specific data key deletion function has been included in order to allow the resources associated
       with  an  unused  thread-specific data key to be freed. Unused thread-specific data keys can arise, among
       other scenarios, when a dynamically loaded module that allocated a key is unloaded.

       Conforming applications are responsible for performing any cleanup actions  needed  for  data  structures
       associated  with the key to be deleted, including data referenced by thread-specific data values. No such
       cleanup is done by <u>pthread_key_delete</u>().  In particular, destructor functions are not called.  There  are
       several reasons for this division of responsibility:

        1. The  associated  destructor  functions used to free thread-specific data at thread exit time are only
           guaranteed to work correctly when called in the  thread  that  allocated  the  thread-specific  data.
           (Destructors  themselves may utilize thread-specific data.) Thus, they cannot be used to free thread-
           specific data in other threads at key deletion time.  Attempting to have them called by other threads
           at key deletion time would  require  other  threads  to  be  asynchronously  interrupted.  But  since
           interrupted  threads  could  be  in  an  arbitrary  state,  including holding locks necessary for the
           destructor to run, this approach would fail. In general,  there  is  no  safe  mechanism  whereby  an
           implementation could free thread-specific data at key deletion time.

        2. Even if there were a means of safely freeing thread-specific data associated with keys to be deleted,
           doing  so  would require that implementations be able to enumerate the threads with non-NULL data and
           potentially keep them from creating more thread-specific data while the key  deletion  is  occurring.
           This  special  case  could  cause  extra synchronization in the normal case, which would otherwise be
           unnecessary.

       For an application to know that it is safe to delete a key, it has to know  that  all  the  threads  that
       might potentially ever use the key do not attempt to use it again. For example, it could know this if all
       the  client  threads have called a cleanup procedure declaring that they are through with the module that
       is being shut down, perhaps by setting a reference count to zero.

       If an implementation detects that the value specified by the <u>key</u> argument  to  <u>pthread_key_delete</u>()  does
       not  refer  to  a a key value obtained from <u>pthread_key_create</u>() or refers to a key that has been deleted
       with <u>pthread_key_delete</u>(), it is recommended that the function should fail and report an <b>[EINVAL]</b> error.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>pthread_key_create</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;pthread.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                            <u><a href="../man3POSIX/PTHREAD_KEY_DELETE.3POSIX.html">PTHREAD_KEY_DELETE</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>