<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slurm::Bitstr - Bitstring functions in libslurm</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libslurm-perl">libslurm-perl_24.11.5-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Slurm::Bitstr - Bitstring functions in libslurm

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Slurm;

        $bitmap = Slurm::Bitstr::<a href="../man32/alloc.32.html">alloc</a>(32);
        if ($bitmap-&gt;<a href="../man10/test.10.html">test</a>(10)) {
               print "bit 10 is set\n";
        }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Slurm::Bitstr class is a wrapper of the bit string functions in libslurm. This package is loaded and
       bootstrapped with package Slurm.

</pre><h4><b>METHODS</b></h4><pre>
       <u>$bitmap</u> <u>=</u> <u>Slurm::Bitstr::alloc($nbits);</u>

       Allocate a bitstring object with $nbits bits. An opaque bitstr object is returned. This is a <b>CLASS</b>
       <b>METHOD</b>.

       <u>$bitmap-&gt;realloc($nbits);</u>

       Reallocate a bitstring(expand or contract size). $nbits is the number of bits in the new bitstring.

       <u>$len</u> <u>=</u> <u>$bitmap-&gt;<b>size()</b>;</u>

       Return the number of possible bits in a bitstring.

       <u>$cond</u> <u>=</u> <u>$bitmap-&gt;test($n);</u>

       Check if bit $n of $bitmap is set.

       <u>$bitmap-&gt;set($n);</u>

       Set bit $n of $bitmap.

       <u>$bitmap-&gt;clear($n);</u>

       Clear bit $n of $bitmap.

       <u>$bitmap-&gt;nset($start,</u> <u>$stop);</u>

       Set bits $start .. $stop in $bitmap.

       <u>$bitmap-&gt;nclear($start,</u> <u>$stop);</u>

       Clear bits $start .. $stop in $bitmap.

       <u>$pos</u> <u>=</u> <u>$bitmap-&gt;<b>ffc()</b>;</u>

       Find first bit clear in $bitmap.

       <u>$pos</u> <u>=</u> <u>$bitmap-&gt;nffc($n)</u>

       Find the first $n contiguous bits clear in $bitmap.

       <u>$pos</u> <u>=</u> <u>$bitmap-&gt;noc($n,</u> <u>$seed);</u>

       Find $n contiguous bits clear in $bitmap starting at offset $seed.

       <u>$pos</u> <u>=</u> <u>$bitmap-&gt;nffs($n);</u>

       Find the first $n contiguous bits set in $bitmap.

       <u>$pos</u> <u>=</u> <u>$bitmap-&gt;<b>ffs()</b>;</u>

       Find first bit set in $bitmap;

       <u>$pos</u> <u>=</u> <u>$bitmap-&gt;<b>fls()</b>;</u>

       Find last bit set in $bitmap;

       <u>$bitmap-&gt;<b>fill_gaps()</b>;</u>

       Set all bits of $bitmap between the first and last bits set(i.e. fill in the gaps to make set bits
       contiguous).

       <u>$cond</u> <u>=</u> <u>$bitmap1-&gt;super_set($bitmap2);</u>

       Return 1 if all bits set in $bitmap1 are also set in $bitmap2, 0 otherwise.

       <u>$cond</u> <u>=</u> <u>$bitmap1-&gt;equal($bitmap2);</u>

       Return 1 if $bitmap1 and $bitmap2 are identical, 0 otherwise.

       <u>$bitmap1-&gt;and($bitmap2);</u>

       $bitmap1 &amp;= $bitmap2.

       <u>$bitmap-&gt;<b>not()</b>;</u>

       $bitmap = ~$bitmap.

       <u>$bitmap1-&gt;or($bitmap2);</u>

       $bitmap1 |= $bitmap2.

       <u>$new</u> <u>=</u> <u>$bitmap-&gt;<b>copy()</b>;</u>

       Return a copy of the supplied bitmap.

       <u>$dest_bitmap-&gt;copybits($src_bitmap);</u>

       Copy all bits of $src_bitmap to $dest_bitmap.

       <u>$n</u> <u>=</u> <u>$bitmap-&gt;<b>set_count()</b>;</u>

       Count the number of bits set in bitstring.

       <u>$n</u> <u>=</u> <u>$bitmap1-&gt;overlap($bitmap2);</u>

       Return number of bits set in $bitmap1 that are also set in $bitmap2, 0 if no overlap.

       <u>$n</u> <u>=</u> <u>$bitmap-&gt;<b>clear_count()</b>;</u>

       Count the number of bits clear in bitstring.

       <u>$n</u> <u>=</u> <u>$bitmap-&gt;<b>nset_max_count()</b>;</u>

       Return the count of the largest number of contiguous bits set in $bitmap.

       <u>$sum</u> <u>=</u> <u>$bitmap-&gt;inst_and_set_count($int_array);</u>

       And $int_array and $bitmap and sum the elements corresponding to set entries in $bitmap.

       <u>$new</u> <u>=</u> <u>$bitmap-&gt;rotate_copy($n,</u> <u>$nbits);</u>

       Return a copy of $bitmap rotated by $n bits. Number of bit in the new bitmap is $nbits.

       <u>$bitmap-&gt;rotate($n);</u>

       Rotate $bitmap by $n bits.

       <u>$new</u> <u>=</u> <u>$bitmap-&gt;pick_cnt($nbits);</u>

       Build a bitmap containing the first $nbits of $bitmap which are set.

       <u>$str</u> <u>=</u> <u>$bitmap-&gt;<b>fmt()</b>;</u>

       Convert $bitmap to range string format, e.g. 0-5,42

       <u>$rc</u> <u>=</u> <u>$bitmap-&gt;unfmt($str);</u>

       Convert range string format to bitmap.

       <u>$array</u> <u>=</u> <u>Slurm::Bitstr::bitfmt2int($str);</u>

       Convert $str describing bitmap (output from <b>fmt()</b>, e.g. "0-30,45,50-60") into an array of integer
       (start/edn) pairs terminated by -1 (e.g. "0, 30, 45, 45, 50, 60, -1").

       <u>$str</u> <u>=</u> <u>$bitmap-&gt;<b>fmt_hexmask()</b>;</u>

       Given a bit string, allocate and return a string in the form of:
           "0x0123ABC\0"
              ^     ^
              |     |
             MSB   LSB

       <u>$rc</u> <u>=</u> <u>$bitmap-&gt;unfmt_hexmask($str);</u>

       Give a hex mask string "0x0123ABC\0", convert to a bit string.
                                 ^     ^
                                 |     |
                                MSB   LSB

       <u>$str</u> <u>=</u> <u>$bitmap-&gt;<b>fmt_binmask()</b>;</u>

       Given a bit string, allocate and return a binary string in the form of:
                                   "0001010\0"
                                    ^     ^
                                    |     |
                                   MSB   LSB

       <u>$rc</u> <u>=</u> <u>$bitmap-&gt;unfmt_binmask($str);</u>

       Give a bin mask string "0001010\0", convert to a bit string.
                               ^     ^
                               |     |
                              MSB   LSB

       <u>$pos</u> <u>=</u> <u>$bitmap-&gt;get_bit_num($n);</u>

       Find position of the $n-th set bit(0 based, i.e., the first set bit is the 0-th) in $bitmap. Returns -1
       if there are less than $n bits set.

       <u>$n</u> <u>=</u> <u>$bitmap-&gt;get_pos_num($pos);</u>

       Find the number of bits set minus one in $bitmap between bit position [0 .. $pos]. Returns -1 if no bits
       are set between [0 .. $pos].

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Slurm

</pre><h4><b>AUTHOR</b></h4><pre>
       This library is created by Hongjia Cao, &lt;hjcao(AT)nudt.edu.cn&gt; and Danny Auble, &lt;da(AT)llnl.gov&gt;. It is
       distributed with Slurm.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself, either Perl version 5.8.4 or, at your option, any later version of Perl 5 you may have available.

perl v5.40.1                                       2025-07-13                                 <u>Slurm::<a href="../man3pm/Bitstr.3pm.html">Bitstr</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>