<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Set::Infinite - Sets of intervals</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libset-infinite-perl">libset-infinite-perl_0.65-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Set::Infinite - Sets of intervals

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Set::Infinite;

         $set = Set::Infinite-&gt;new(1,2);    # [1..2]
         print $set-&gt;union(5,6);            # [1..2],[5..6]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Set::Infinite is a Set Theory module for infinite sets.

       A set is a collection of objects.  The objects that belong to a set are called its members, or
       "elements".

       As objects we allow (almost) anything:  reals, integers, and objects (such as dates).

       We allow sets to be infinite.

       There is no account for the order of elements. For example, {1,2} = {2,1}.

       There is no account for repetition of elements. For example, {1,2,2} = {1,1,1,2} = {1,2}.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>new</b>
       Creates a new set object:

           $set = Set::Infinite-&gt;new;             # empty set
           $set = Set::Infinite-&gt;new( 10 );       # single element
           $set = Set::Infinite-&gt;new( 10, 20 );   # single range
           $set = Set::Infinite-&gt;new(
                     [ 10, 20 ], [ 50, 70 ] );    # two ranges

       empty set
               $set = Set::Infinite-&gt;new;

       set with a single element
               $set = Set::Infinite-&gt;new( 10 );

               $set = Set::Infinite-&gt;new( [ 10 ] );

       set with a single span
               $set = Set::Infinite-&gt;new( 10, 20 );

               $set = Set::Infinite-&gt;new( [ 10, 20 ] );
               # 10 &lt;= x &lt;= 20

       set with a single, open span
               $set = Set::Infinite-&gt;new(
                   {
                       a =&gt; 10, open_begin =&gt; 0,
                       b =&gt; 20, open_end =&gt; 1,
                   }
               );
               # 10 &lt;= x &lt; 20

       set with multiple spans
               $set = Set::Infinite-&gt;new( 10, 20,  100, 200 );

               $set = Set::Infinite-&gt;new( [ 10, 20 ], [ 100, 200 ] );

               $set = Set::Infinite-&gt;new(
                   {
                       a =&gt; 10, open_begin =&gt; 0,
                       b =&gt; 20, open_end =&gt; 0,
                   },
                   {
                       a =&gt; 100, open_begin =&gt; 0,
                       b =&gt; 200, open_end =&gt; 0,
                   }
               );

       The "new()" method expects <u>ordered</u> parameters.

       If you have unordered ranges, you can build the set using "union":

           @ranges = ( [ 10, 20 ], [ -10, 1 ] );
           $set = Set::Infinite-&gt;new;
           $set = $set-&gt;union( @$_ ) for @ranges;

       The data structures passed to "new" must be <u>immutable</u>.  So this is not good practice:

           $set = Set::Infinite-&gt;new( $object_a, $object_b );
           $object_a-&gt;set_value( 10 );

       This is the recommended way to do it:

           $set = Set::Infinite-&gt;new( $object_a-&gt;clone, $object_b-&gt;clone );
           $object_a-&gt;set_value( 10 );

   <b>clone</b> <b>/</b> <b>copy</b>
       Creates a new object, and copy the object data.

   <b>empty_set</b>
       Creates an empty set.

       If called from an existing set, the empty set inherits the "type" and "density" characteristics.

   <b>universal_set</b>
       Creates a set containing "all" possible elements.

       If called from an existing set, the universal set inherits the "type" and "density" characteristics.

</pre><h4><b>SET</b> <b>FUNCTIONS</b></h4><pre>
   <b>union</b>
           $set = $set-&gt;union($b);

       Returns the set of all elements from both sets.

       This function behaves like an "OR" operation.

           $set1 = new Set::Infinite( [ 1, 4 ], [ 8, 12 ] );
           $set2 = new Set::Infinite( [ 7, 20 ] );
           print $set1-&gt;union( $set2 );
           # output: [1..4],[7..20]

   <b>intersection</b>
           $set = $set-&gt;intersection($b);

       Returns the set of elements common to both sets.

       This function behaves like an "AND" operation.

           $set1 = new Set::Infinite( [ 1, 4 ], [ 8, 12 ] );
           $set2 = new Set::Infinite( [ 7, 20 ] );
           print $set1-&gt;intersection( $set2 );
           # output: [8..12]

   <b>complement</b>
   <b>minus</b>
   <b>difference</b>
           $set = $set-&gt;complement;

       Returns the set of all elements that don't belong to the set.

           $set1 = new Set::Infinite( [ 1, 4 ], [ 8, 12 ] );
           print $set1-&gt;complement;
           # output: (-inf..1),(4..8),(12..inf)

       The complement function might take a parameter:

           $set = $set-&gt;minus($b);

       Returns the set-difference, that is, the elements that don't belong to the given set.

           $set1 = new Set::Infinite( [ 1, 4 ], [ 8, 12 ] );
           $set2 = new Set::Infinite( [ 7, 20 ] );
           print $set1-&gt;minus( $set2 );
           # output: [1..4]

   <b>symmetric_difference</b>
       Returns  a  set containing elements that are in either set, but not in both. This is the "set" version of
       "XOR".

</pre><h4><b>DENSITY</b> <b>METHODS</b></h4><pre>
   <b>real</b>
           $set1 = $set-&gt;real;

       Returns a set with density "0".

   <b>integer</b>
           $set1 = $set-&gt;integer;

       Returns a set with density "1".

</pre><h4><b>LOGIC</b> <b>FUNCTIONS</b></h4><pre>
   <b>intersects</b>
           $logic = $set-&gt;intersects($b);

   <b>contains</b>
           $logic = $set-&gt;contains($b);

   <b>is_empty</b>
   <b>is_null</b>
           $logic = $set-&gt;is_null;

   <b>is_nonempty</b>
       This set that has at least 1 element.

   <b>is_span</b>
       This set that has a single span or interval.

   <b>is_singleton</b>
       This set that has a single element.

   <b>is_subset(</b> <b>$set</b> <b>)</b>
       Every element of this set is a member of the given set.

   <b>is_proper_subset(</b> <b>$set</b> <b>)</b>
       Every element of this set is a member of the given set.  Some members of the given set are  not  elements
       of this set.

   <b>is_disjoint(</b> <b>$set</b> <b>)</b>
       The given set has no elements in common with this set.

   <b>is_too_complex</b>
       Sometimes a set might be too complex to enumerate or print.

       This  happens with sets that represent infinite recurrences, such as when you ask for a quantization on a
       set bounded by -inf or inf.

       See also: "count" method.

</pre><h4><b>SCALAR</b> <b>FUNCTIONS</b></h4><pre>
   <b>min</b>
           $i = $set-&gt;min;

   <b>max</b>
           $i = $set-&gt;max;

   <b>size</b>
           $i = $set-&gt;size;

   <b>count</b>
           $i = $set-&gt;count;

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
   <b>stringification</b>
           print $set;

           $str = "$set";

       See also: "as_string".

   <b>comparison</b>
           sort

           &gt; &lt; == &gt;= &lt;= &lt;=&gt;

       See also: "spaceship" method.

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
           Set::Infinite-&gt;separators(@i)

               chooses the interval separators for stringification.

               default are [ ] ( ) '..' ','.

           inf

               returns an 'Infinity' number.

           minus_inf

               returns '-Infinity' number.

   <b>type</b>
           type( "My::Class::Name" )

       Chooses a default object data type.

       Default is none (a normal Perl SCALAR).

</pre><h4><b>SPECIAL</b> <b>SET</b> <b>FUNCTIONS</b></h4><pre>
   <b>span</b>
           $set1 = $set-&gt;span;

       Returns the set span.

   <b>until</b>
       Extends a set until another:

           0,5,7 -&gt; until 2,6,10

       gives

           [0..2), [5..6), [7..10)

   <b>start_set</b>
   <b>end_set</b>
       These methods do the inverse of the "until" method.

       Given:

           [0..2), [5..6), [7..10)

       start_set is:

           0,5,7

       end_set is:

           2,6,10

   <b>intersected_spans</b>
           $set = $set1-&gt;intersected_spans( $set2 );

       The method returns a new set, containing all spans that are intersected by the given set.

       Unlike the "intersection" method, the spans are not modified.  See diagram below:

                      set1   [....]   [....]   [....]   [....]
                      set2      [................]

              intersection      [.]   [....]   [.]

         intersected_spans   [....]   [....]   [....]

   <b>quantize</b>
           quantize( parameters )

               Makes equal-sized subsets.

               Returns an ordered set of equal-sized subsets.

               Example:

                   $set = Set::Infinite-&gt;new([1,3]);
                   print join (" ", $set-&gt;quantize( quant =&gt; 1 ) );

               Gives:

                   [1..2) [2..3) [3..4)

   <b>select</b>
           select( parameters )

       Selects set spans based on their ordered positions

       "select" has a behaviour similar to an array "slice".

                   by       - default=All
                   count    - default=Infinity

        0  1  2  3  4  5  6  7  8      # original set
        0  1  2                        # count =&gt; 3
           1              6            # by =&gt; [ -2, 1 ]

   <b>offset</b>
           offset ( parameters )

       Offsets the subsets. Parameters:

           value   - default=[0,0]
           mode    - default='offset'. Possible values are: 'offset', 'begin', 'end'.
           unit    - type of value. Can be 'days', 'weeks', 'hours', 'minutes', 'seconds'.

   <b>iterate</b>
           iterate ( sub { } , @args )

       Iterates on the set spans, over a callback subroutine.  Returns the union of all partial results.

       The callback argument $_[0] is a span. If there are additional arguments they are passed to the callback.

       The callback can return a span, a hashref (see "Set::Infinite::Basic"), a scalar, an object, or "undef".

       [EXPERIMENTAL]  "iterate"  accepts  an  optional  "backtrack_callback"  argument.   The  purpose  of  the
       "backtrack_callback"  is  to  <u>reverse</u>  the <b>iterate()</b> function, overcoming the limitations of the internal
       backtracking algorithm.  The syntax is:

           iterate ( sub { } , backtrack_callback =&gt; sub { }, @args )

       The "backtrack_callback" can return a span, a hashref, a scalar, an object, or "undef".

       For example, the following snippet adds a constant to each element of an unbounded set:

           $set1 = $set-&gt;iterate(
                        sub { $_[0]-&gt;min + 54, $_[0]-&gt;max + 54 },
                     backtrack_callback =&gt;
                        sub { $_[0]-&gt;min - 54, $_[0]-&gt;max - 54 },
                     );

   <b>first</b> <b>/</b> <b>last</b>
           first / last

       In scalar context returns the first or last interval of a set.

       In list context returns the first or last interval of a set, and the remaining set (the 'tail').

       See also: "min", "max", "min_a", "max_a" methods.

   <b>type</b>
           type( "My::Class::Name" )

       Chooses a default object data type.

       default is none (a normal perl SCALAR).

</pre><h4><b>INTERNAL</b> <b>FUNCTIONS</b></h4><pre>
   <b>_backtrack</b>
           $set-&gt;_backtrack( 'intersection', $b );

       Internal function to evaluate recurrences.

   <b>numeric</b>
           $set-&gt;numeric;

       Internal function to ignore the set "type".  It is used  in  some  internal  optimizations,  when  it  is
       possible to use scalar values instead of objects.

   <b>fixtype</b>
           $set-&gt;fixtype;

       Internal function to fix the result of operations that use the <b>numeric()</b> function.

   <b>tolerance</b>
           $set = $set-&gt;<a href="../man0/tolerance.0.html">tolerance</a>(0)    # defaults to real sets (default)
           $set = $set-&gt;<a href="../man1/tolerance.1.html">tolerance</a>(1)    # defaults to integer sets

       Internal function for changing the set "density".

   <b>min_a</b>
           ($min, $min_is_open) = $set-&gt;min_a;

   <b>max_a</b>
           ($max, $max_is_open) = $set-&gt;max_a;

   <b>as_string</b>
       Implements the "stringification" operator.

       Stringification of unbounded recurrences is not implemented.

       Unbounded  recurrences are stringified as "function descriptions", if the class variable $PRETTY_PRINT is
       set.

   <b>spaceship</b>
       Implements the "comparison" operator.

       Comparison of unbounded recurrences is not implemented.

</pre><h4><b>CAVEATS</b></h4><pre>
       •   constructor "span" notation

               $set = Set::Infinite-&gt;new(10,1);

           Will be interpreted as [1..10]

       •   constructor "multiple-span" notation

               $set = Set::Infinite-&gt;new(1,2,3,4);

           Will be interpreted as [1..2],[3..4] instead of [1,2,3,4].  You probably want  -&gt;new([1],[2],[3],[4])
           instead, or maybe -&gt;new(1,4)

       •   "range operator"

               $set = Set::Infinite-&gt;new(1..3);

           Will be interpreted as [1..2],3 instead of [1,2,3].  You probably want -&gt;new(1,3) instead.

</pre><h4><b>INTERNALS</b></h4><pre>
       The base <u>set</u> object, without recurrences, is a "Set::Infinite::Basic".

       A  <u>recurrence-set</u>  is  represented by a <u>method</u> <u>name</u>, one or two <u>parent</u> <u>objects</u>, and extra arguments.  The
       "list" key is set to an empty array, and the "too_complex" key is set to 1.

       This is a structure that holds the union of two "complex sets":

         {
           too_complex =&gt; 1,             # "this is a recurrence"
           list   =&gt; [ ],                # not used
           method =&gt; 'union',            # function name
           parent =&gt; [ $set1, $set2 ],   # "leaves" in the syntax-tree
           param  =&gt; [ ]                 # optional arguments for the function
         }

       This is a structure that holds the complement of a "complex set":

         {
           too_complex =&gt; 1,             # "this is a recurrence"
           list   =&gt; [ ],                # not used
           method =&gt; 'complement',       # function name
           parent =&gt; $set,               # "leaf" in the syntax-tree
           param  =&gt; [ ]                 # optional arguments for the function
         }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See modules DateTime::Set, DateTime::Event::Recurrence, DateTime::Event::ICal, DateTime::Event::Cron  for
       up-to-date information on date-sets.

       The perl-date-time project &lt;<a href="http://datetime.perl.org">http://datetime.perl.org</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Flavio S. Glock &lt;<a href="mailto:fglock@gmail.com">fglock@gmail.com</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2003 Flavio Soibelmann Glock.  All rights reserved.  This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

       The full text of the license can be found in the LICENSE file included with this module.

perl v5.36.0                                       2022-10-22                                 <u>Set::<a href="../man3pm/Infinite.3pm.html">Infinite</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>