<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARC::Batch - Perl module for handling files of MARC::Record objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmarc-record-perl">libmarc-record-perl_2.0.7-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MARC::Batch - Perl module for handling files of MARC::Record objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
       MARC::Batch hides all the file handling of files of "MARC::Record"s.  "MARC::Record" still does the file
       I/O, but "MARC::Batch" handles the multiple-file aspects.

           use MARC::Batch;

           # If you have weird control fields...
           use MARC::Field;
           MARC::Field-&gt;allow_controlfield_tags('FMT', 'LDX');

           my $batch = MARC::Batch-&gt;new( 'USMARC', @files );
           while ( my $marc = $batch-&gt;next ) {
               print $marc-&gt;subfield(245,"a"), "\n";
           }

</pre><h4><b>EXPORT</b></h4><pre>
       None.  Everything is a class method.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new(</b> <b>$type,</b> <b>@files</b> <b>)</b>
       Create a "MARC::Batch" object that will process @files.

       $type must be either "USMARC" or "MicroLIF".  If you want to specify "MARC::File::USMARC" or
       "MARC::File::MicroLIF", that's OK, too. "new()" returns a new MARC::Batch object.

       @files can be a list of filenames:

           my $batch = MARC::Batch-&gt;new( 'USMARC', 'file1.marc', 'file2.marc' );

       Your @files may also contain filehandles. So if you've got a large file that's gzipped you can open a
       pipe to <u>gzip</u> and pass it in:

           my $fh = IO::File-&gt;new( 'gunzip -c marc.dat.gz |' );
           my $batch = MARC::Batch-&gt;new( 'USMARC', $fh );

       And you can mix and match if you really want to:

           my $batch = MARC::Batch-&gt;new( 'USMARC', $fh, 'file1.marc' );

   <b>next()</b>
       Read the next record from that batch, and return it as a MARC::Record object.  If the current file is at
       EOF, close it and open the next one. "next()" will return "undef" when there is no more data to be read
       from any batch files.

       By default, "next()" also will return "undef" if an error is encountered while reading from the batch. If
       not checked for this can cause your iteration to terminate prematurely. To alter this behavior, see
       "strict_off()". You can retrieve warning messages using the "warnings()" method.

       Optionally you can pass in a filter function as a subroutine reference if you are only interested in
       particular fields from the record. This can boost performance.

   <b>strict_off()</b>
       If you would like "MARC::Batch" to continue after it has encountered what it believes to be bad MARC data
       then use this method to turn strict <b>OFF</b>.  A call to "strict_off()" always returns true (1).

       "strict_off()" can be handy when you don't care about the quality of your MARC data, and just want to
       plow through it. For safety, "MARC::Batch" strict is <b>ON</b> by default.

   <b>strict_on()</b>
       The opposite of "strict_off()", and the default state. You shouldn't have to use this method unless
       you've previously used "strict_off()", and want it back on again.  When strict is <b>ON</b> calls to <b>next()</b> will
       return undef when an error is encountered while reading MARC data. <b>strict_on()</b> always returns true (1).

   <b>warnings()</b>
       Returns a list of warnings that have accumulated while processing a particular batch file. As a side
       effect the warning buffer will be cleared.

           my @warnings = $batch-&gt;warnings();

       This method is also used internally to set warnings, so you probably don't want to be passing in anything
       as this will set warnings on your batch object.

       "warnings()" will return the empty list when there are no warnings.

   <b>warnings_off()</b>
       Turns off the default behavior of printing warnings to STDERR. However, even with warnings off the
       messages can still be retrieved using the <b>warnings()</b> method if you wish to check for them.

       "warnings_off()" always returns true (1).

   <b>warnings_on()</b>
       Turns on warnings so that diagnostic information is printed to STDERR. This is on by default so you
       shouldn't have to use it unless you've previously turned off warnings using <b>warnings_off()</b>.

       <b>warnings_on()</b> always returns true (1).

   <b>filename()</b>
       Returns the currently open filename or "undef" if there is not currently a file open on this batch
       object.

</pre><h4><b>RELATED</b> <b>MODULES</b></h4><pre>
       MARC::Record, MARC::Lint

</pre><h4><b>TODO</b></h4><pre>
       None yet.  Send me your ideas and needs.

</pre><h4><b>LICENSE</b></h4><pre>
       This code may be distributed under the same terms as Perl itself.

       Please note that these modules are not products of or supported by the employers of the various
       contributors to the code.

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Lester, "&lt;<a href="mailto:andy@petdance.com">andy@petdance.com</a>&gt;"

perl v5.36.0                                       2022-10-13                                   <u>MARC::<a href="../man3pm/Batch.3pm.html">Batch</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>