<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO::HTML - Open an HTML file with automatic charset detection</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-html-perl">libio-html-perl_1.004-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IO::HTML - Open an HTML file with automatic charset detection

</pre><h4><b>VERSION</b></h4><pre>
       This document describes version 1.004 of IO::HTML, released September 26, 2020.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use IO::HTML;                 # exports html_file by default
         use HTML::TreeBuilder;

         my $tree = HTML::TreeBuilder-&gt;new_from_file(
                      html_file('foo.html')
                    );

         # Alternative interface:
         open(my $in, '&lt;:raw', 'bar.html');
         my $encoding = IO::HTML::sniff_encoding($in, 'bar.html');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       IO::HTML provides an easy way to open a file containing HTML while automatically determining its
       encoding.  It uses the HTML5 encoding sniffing algorithm specified in section 8.2.2.2 of the draft
       standard.

       The algorithm as implemented here is:

       1.  If  the  file begins with a byte order mark indicating UTF-16LE, UTF-16BE, or UTF-8, then that is the
           encoding.

       2.  If the first $bytes_to_check bytes of the file contain a "&lt;meta&gt;" tag that indicates the charset, and
           Encode recognizes the specified charset name, then that  is  the  encoding.   (This  portion  of  the
           algorithm is implemented by "find_charset_in".)

           The "&lt;meta&gt;" tag can be in one of two formats:

             &lt;meta charset="..."&gt;
             &lt;meta http-equiv="Content-Type" content="...charset=..."&gt;

           The  search  is  case-insensitive,  and  the  order  of attributes within the tag is irrelevant.  Any
           additional attributes of the tag are ignored.  The first matching tag with a recognized encoding ends
           the search.

       3.  If the first $bytes_to_check bytes of the file are valid UTF-8 (with at least 1 non-ASCII character),
           then the encoding is UTF-8.

       4.  If all else fails, use the default character encoding.   The  HTML5  standard  suggests  the  default
           encoding   should  be  locale  dependent,  but  currently  it  is  always  "cp1252"  unless  you  set
           $IO::HTML::default_encoding to a different value.  Note: "sniff_encoding" does not apply  this  step;
           only "html_file" does that.

</pre><h4><b>SUBROUTINES</b></h4><pre>
   <b>html_file</b>
         $filehandle = html_file($filename, \%options);

       This function (exported by default) is the primary entry point.  It opens the file specified by $filename
       for  reading,  uses  "sniff_encoding" to find a suitable encoding layer, and applies it.  It also applies
       the ":crlf" layer.  If the file begins with a BOM, the filehandle is positioned just after the BOM.

       The optional second argument is a hashref containing options.  The  possible  keys  are  described  under
       "find_charset_in".

       If  "sniff_encoding"  is  unable  to  determine the encoding, it defaults to $IO::HTML::default_encoding,
       which is set to "cp1252" (a.k.a. Windows-1252) by default.  According to the standard, the default should
       be locale dependent, but that is not currently implemented.

       It dies if the file  cannot  be  opened,  or  if  "sniff_encoding"  cannot  determine  the  encoding  and
       $IO::HTML::default_encoding has been set to "undef".

   <b>html_file_and_encoding</b>
         ($filehandle, $encoding, $bom)
           = html_file_and_encoding($filename, \%options);

       This  function  (exported  only  by  request) is just like "html_file", but returns more information.  In
       addition to the filehandle, it returns the name of the encoding used, and a  flag  indicating  whether  a
       byte  order  mark was found (if $bom is true, the file began with a BOM).  This may be useful if you want
       to write the file out again (especially in conjunction with the "html_outfile" function).

       The optional second argument is a hashref containing options.  The  possible  keys  are  described  under
       "find_charset_in".

       It  dies  if  the  file  cannot  be  opened,  or  if  "sniff_encoding"  cannot determine the encoding and
       $IO::HTML::default_encoding has been set to "undef".

       The result of calling "html_file_and_encoding" in scalar context is undefined (in the C sense of there is
       no guarantee what you'll get).

   <b>html_outfile</b>
         $filehandle = html_outfile($filename, $encoding, $bom);

       This function (exported only by request) opens $filename for output using $encoding, and writes a BOM  to
       it  if $bom is true.  If $encoding is "undef", it defaults to $IO::HTML::default_encoding.  $encoding may
       be either an encoding name or an Encode::Encoding object.

       It dies if the file cannot be opened, or if both $encoding and $IO::HTML::default_encoding are "undef".

   <b>sniff_encoding</b>
         ($encoding, $bom) = sniff_encoding($filehandle, $filename, \%options);

       This function (exported only by request) runs the HTML5 encoding sniffing algorithm on $filehandle (which
       must be seekable, and should have been opened in ":raw" mode).  $filename is used only for error messages
       (if there's a problem using the filehandle), and defaults to  "file"  if  omitted.   The  optional  third
       argument is a hashref containing options.  The possible keys are described under "find_charset_in".

       It  returns Perl's canonical name for the encoding, which is not necessarily the same as the MIME or IANA
       charset name.  It returns "undef" if the encoding cannot be determined.  $bom is true if the  file  began
       with a byte order mark.  In scalar context, it returns only $encoding.

       The  filehandle's  position  is  restored  to  its original position (normally the beginning of the file)
       unless $bom is true.  In that case, the position is immediately after the BOM.

       Tip: If you want to run "sniff_encoding" on a file you've already loaded into a string, open an in-memory
       file on the string, and pass that handle:

         ($encoding, $bom) = do {
           open(my $fh, '&lt;', \$string);  sniff_encoding($fh)
         };

       (This only makes sense if $string contains bytes, not characters.)

   <b>find_charset_in</b>
         $encoding = find_charset_in($string_containing_HTML, \%options);

       This function (exported only by request) looks for charset information in a "&lt;meta&gt;" tag in  a  possibly-
       incomplete  HTML document using the "two step" algorithm specified by HTML5.  It does not look for a BOM.
       The "&lt;meta&gt;" tag must begin within the first $IO::HTML::bytes_to_check bytes of the string.

       It returns Perl's canonical name for the encoding, which is not necessarily the same as the MIME or  IANA
       charset  name.   It  returns  "undef"  if  no  charset  is  specified  or if the specified charset is not
       recognized by the Encode module.

       The optional second argument is a hashref containing options.  The following keys are recognized:

       "encoding"
           If true, return the Encode::Encoding object instead of its name.  Defaults to false.

       "need_pragma"
           If true (the default), follow the HTML5 spec and examine  the  "content"  attribute  only  of  "&lt;meta
           http-equiv="Content-Type"".   If  set  to  0,  relax  the  HTML5 spec, and look for "charset=" in the
           "content" attribute of <u>every</u> meta tag.

</pre><h4><b>EXPORTS</b></h4><pre>
       By default, only "html_file" is exported.  Other functions may be exported on request.

       For people who prefer not to export functions, all functions beginning with "html_" have an alias without
       that prefix (e.g. you  can  call  "IO::HTML::file(...)"  instead  of  "IO::HTML::html_file(...)".   These
       aliases are not exportable.

       The following export tags are available:

       ":all"
           All exportable functions.

       ":rw"
           "html_file", "html_file_and_encoding", "html_outfile".

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The     HTML5     specification,     section     8.2.2.2     Determining    the    character    encoding:
       &lt;<a href="http://www.w3.org/TR/html5/syntax.html">http://www.w3.org/TR/html5/syntax.html</a>#determining-the-character-encoding&gt;

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       "Could not read %s: %s"
           The specified file could not be read from for the reason specified by $!.

       "Could not seek %s: %s"
           The specified file could not be rewound for the reason specified by $!.

       "Failed to open %s: %s"
           The specified file could not be opened for reading for the reason specified by $!.

       "No default encoding specified"
           The   "sniff_encoding"   algorithm   didn't   find   an   encoding    to    use,    and    you    set
           $IO::HTML::default_encoding to "undef".

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
       There  are two global variables that affect IO::HTML.  If you need to change them, you should do so using
       "local" if possible:

         my $file = do {
           # This file may define the charset later in the header
           local $IO::HTML::bytes_to_check = 4096;
           html_file(...);
         };

       $bytes_to_check
           This is the number of bytes that "sniff_encoding" will read from the stream.  It is also  the  number
           of  bytes  that  "find_charset_in" will search for a "&lt;meta&gt;" tag containing charset information.  It
           must be a positive integer.

           The HTML 5 specification recommends using the default value of 1024, but some pages do not follow the
           specification.

       $default_encoding
           This is the encoding that "html_file" and "html_file_and_encoding" will use if  no  encoding  can  be
           detected by "sniff_encoding".  The default value is "cp1252" (a.k.a. Windows-1252).

           Setting it to "undef" will cause the file subroutines to croak if "sniff_encoding" fails to determine
           the encoding.  ("sniff_encoding" itself does not use $default_encoding).

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       IO::HTML  has  no  non-core dependencies for Perl 5.8.7+.  With earlier versions of Perl 5.8, you need to
       upgrade Encode to at least version 2.10, and you may need to upgrade Exporter to at least version 5.57.

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       None reported.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       No bugs have been reported.

</pre><h4><b>AUTHOR</b></h4><pre>
       Christopher J. Madsen  "&lt;perl AT cjmweb.net&gt;"

       Please report any bugs or feature requests to "&lt;bug-IO-HTML AT rt.cpan.org&gt;" or through the web interface
       at &lt;<a href="http://rt.cpan.org/Public/Bug/Report.html">http://rt.cpan.org/Public/Bug/Report.html</a>?Queue=IO-HTML&gt;.

       You can follow or contribute to IO-HTML's development at &lt;https://github.com/madsen/io-html&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2020 by Christopher J. Madsen.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE  THIS  SOFTWARE  IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE, TO THE EXTENT
       PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS  AND/OR  OTHER
       PARTIES  PROVIDE  THE  SOFTWARE  "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND, EITHER EXPRESSED OR IMPLIED,
       INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS  FOR  A  PARTICULAR
       PURPOSE.  THE  ENTIRE  RISK  AS  TO  THE  QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER,  OR  ANY
       OTHER  PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENSE, BE LIABLE
       TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING  OUT  OF
       THE  USE  OR  INABILITY  TO  USE  THE  SOFTWARE  (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
       RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE  TO  OPERATE
       WITH  ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
       DAMAGES.

perl v5.34.0                                       2022-04-09                                      <u>IO::<a href="../man3pm/HTML.3pm.html">HTML</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>