<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>huddle - Create and manipulate huddle object</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       huddle - Create and manipulate huddle object

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>huddle</b> <b>?0.5?</b>

       <b>huddle</b> <b>create</b> <u>key</u> <u>value</u> ?<u>key</u> <u>value</u> <u>...</u>?

       <b>huddle</b> <b>list</b> ?<u>value</u> <u>value</u> <u>...</u>?

       <b>huddle</b> <b>number</b> <u>number</u>

       <b>huddle</b> <b>string</b> <u>string</u>

       <b>huddle</b> <b>boolean</b> <u>expression</u> <u>to</u> <u>evaluate</u> <u>as</u> <u>true</u> <u>or</u> <u>false</u>

       <b>huddle</b> <b>true</b>

       <b>huddle</b> <b>false</b>

       <b>huddle</b> <b>null</b>

       <b>huddle</b> <b>get</b> <u>object</u> <u>key</u> ?<u>key</u> <u>...</u>?

       <b>huddle</b> <b>gets</b> <u>object</u> <u>key</u> ?<u>key</u> <u>...</u>?

       <b>huddle</b> <b>set</b> <u>objectVar</u> <u>key</u> ?<u>key</u> <u>...</u>? <u>value</u>

       <b>huddle</b> <b>remove</b> <u>object</u> <u>key</u> ?<u>key</u> <u>...</u>?

       <b>huddle</b> <b>combine</b> <u>object1</u> <u>object2</u> ?<u>object3</u> <u>...</u>?

       <b>huddle</b> <b>equal</b> <u>object1</u> <u>object2</u>

       <b>huddle</b> <b>append</b> <u>objectVar</u> <u>key</u> <u>value</u> ?<u>key</u> <u>value</u> <u>...</u>?

       <b>huddle</b> <b>append</b> <u>objectVar</u> <u>value</u> ?<u>value</u> <u>...</u>?

       <b>huddle</b> <b>keys</b> <u>object</u>

       <b>huddle</b> <b>llength</b> <u>object</u>

       <b>huddle</b> <b>type</b> <u>object</u> ?<u>key</u> <u>key...</u>?

       <b>huddle</b> <b>strip</b> <u>object</u>

       <b>huddle</b> <b>jsondump</b> <u>object</u> ?<u>offset</u>? ?<u>newline</u>? ?<u>begin_offset</u>?

       <b>huddle</b> <b>compile</b> <u>spec</u> <u>data</u>

       <b>huddle</b> <b>isHuddle</b> <u>object</u>

       <b>huddle</b> <b>checkHuddle</b> <u>object</u>

       <b>huddle</b> <b>to_node</b> <u>object</u> ?<u>tag</u>?

       <b>huddle</b> <b>wrap</b> <u>tag</u> <u>src</u>

       <b>huddle</b> <b>call</b> <u>tag</u> <u>command</u> <u>args</u>

       <b>huddle</b> <b>addType</b> <u>callback</u>

       <b>callback</b> <u>command</u> ?<u>args</u>?

       <b>setting</b>

       <b>get_sub</b> <u>src</u> <u>key</u>

       <b>strip</b> <u>src</u>

       <b>set</b> <u>src</u> <u>key</u> <u>value</u>

       <b>remove</b> <u>src</u> <u>key</u> <u>value</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Huddle  provides  a generic Tcl-based serialization/intermediary format.  Currently, each node is wrapped
       in a tag with simple type information.

       When converting huddle-notation to other serialization formats like JSON or YAML this type information is
       used to select the proper notation.  And when going from JSON/YAML/... to huddle their  notation  can  be
       used to select the proper huddle type.

       In that manner huddle can serve as a common intermediary format.

              huddle-format: &gt;
                {HUDDLE {huddle-node}}
              huddle-node: &gt;
                {tag content}
              each content of tag means:
                s: (content is a) string
                L: list, each sub node is a huddle-node
                D: dict, each sub node is a huddle-node
              confirmed:
                - JSON
                - YAML(generally, but cannot discribe YAML-tags)
              limitation:
                - cannot discribe aliases from a node to other node.

       The <b>huddle</b> package returns data as a Tcl <b>dict</b>.  Either the <b>dict</b> package or Tcl 8.5 is required for use.

</pre><h4><b>COMMANDS</b></h4><pre>
       <b>huddle</b> <b>create</b> <u>key</u> <u>value</u> ?<u>key</u> <u>value</u> <u>...</u>?
              Create a huddle object as a dict. It can contain other huddle objects.

       <b>huddle</b> <b>list</b> ?<u>value</u> <u>value</u> <u>...</u>?
              Create a huddle object as a list. It can contain other huddle objects.

       <b>huddle</b> <b>number</b> <u>number</u>
              Create a huddle object as a number.

       <b>huddle</b> <b>string</b> <u>string</u>
              Create a huddle object as a string.

       <b>huddle</b> <b>boolean</b> <u>expression</u> <u>to</u> <u>evaluate</u> <u>as</u> <u>true</u> <u>or</u> <u>false</u>

              Create a huddle object as a boolean evaluating an expression as true or false-
       <b>huddle</b> <b>true</b>
              Create a huddle object as a boolean true.

       <b>huddle</b> <b>false</b>
              Create a huddle object as a boolean false.

       <b>huddle</b> <b>null</b>
              Create a huddle object as a null.

       <b>huddle</b> <b>get</b> <u>object</u> <u>key</u> ?<u>key</u> <u>...</u>?
              Almost the same as <b>dict</b> <b>get</b>.  Get a sub-object from the huddle object.  <u>key</u> can be used to huddle-
              list's index.

       <b>huddle</b> <b>gets</b> <u>object</u> <u>key</u> ?<u>key</u> <u>...</u>?
              Get a sub-object from the huddle object, stripped.

       <b>huddle</b> <b>set</b> <u>objectVar</u> <u>key</u> ?<u>key</u> <u>...</u>? <u>value</u>
              Almost the same as <b>dict</b> <b>set</b>.  Set a sub-object from the huddle object.  <u>key</u> can be used to huddle-
              list's index.

       <b>huddle</b> <b>remove</b> <u>object</u> <u>key</u> ?<u>key</u> <u>...</u>?
              Almost  the  same as <b>dict</b> <b>remove</b>.  Remove a sub-object from the huddle object.  <u>key</u> can be used to
              huddle-list's index.

       <b>huddle</b> <b>combine</b> <u>object1</u> <u>object2</u> ?<u>object3</u> <u>...</u>?
              Merging huddle objects given.

              % set aa [huddle create a b c d]
              HUDDLE {D {a {s b} c {s d}}}
              % set bb [huddle create a k l m]
              HUDDLE {D {a {s k} l {s m}}}
              % huddle combine $aa $bb
              HUDDLE {D {a {s k} c {s d} l {s m}}}

       <b>huddle</b> <b>equal</b> <u>object1</u> <u>object2</u>
              Comparing two huddle objects recursively.  When to equal, returns 1, otherwise 0.

              % set aa [huddle create a b c d]
              HUDDLE {D {a {s b} c {s d}}}
              % set bb [huddle create c d a b]
              HUDDLE {D {c {s d} a {s b}}}
              % huddle equal $aa $bb
              1

       <b>huddle</b> <b>append</b> <u>objectVar</u> <u>key</u> <u>value</u> ?<u>key</u> <u>value</u> <u>...</u>?

       <b>huddle</b> <b>append</b> <u>objectVar</u> <u>value</u> ?<u>value</u> <u>...</u>?
              Appending child elements. When for dicts, giving key/value. When for lists, giving values.

              % set aa [huddle create a b c d]
              HUDDLE {D {a {s b} c {s d}}}
              % huddle append aa a k l m
              HUDDLE {D {a {s k} c {s d} l {s m}}}
              % set bb [huddle list i j k l]
              HUDDLE {L {{s i} {s j} {s k} {s l}}}
              % huddle append bb g h i
              HUDDLE {L {{s i} {s j} {s k} {s l} {s g} {s h} {s i}}}

       <b>huddle</b> <b>keys</b> <u>object</u>
              The same as <b>dict</b> <b>keys</b>.

       <b>huddle</b> <b>llength</b> <u>object</u>
              The same as <b>llength</b>.

       <b>huddle</b> <b>type</b> <u>object</u> ?<u>key</u> <u>key...</u>?
              Return the element type of specified by keys.  if ?key? is not given, returns  the  type  of  root
              node.

              <b>string</b> the node is a tcl's string.

              <b>dict</b>   the node is a dict.

              <b>list</b>   the node is a list.

              <b>number</b> the node is a number.

              <b>boolean</b>
                     the node is a boolean.

              <b>null</b>   the node is a null.

              % huddle type {HUDDLE {s str}}
              string
              % huddle type {HUDDLE {L {{s a} {s b} {s c}}}}
              list
              % huddle type {HUDDLE {D {aa {s b} cc {s d}}}} cc
              string

       <b>huddle</b> <b>strip</b> <u>object</u>
              Stripped all tags. Converted to normal Tcl's list/dict.

       <b>huddle</b> <b>jsondump</b> <u>object</u> ?<u>offset</u>? ?<u>newline</u>? ?<u>begin_offset</u>?
              dump a json-stream from the huddle-object.

              <b>offset</b> ""
                     begin offset as spaces "  ".

              # normal output has some indents. some strings are escaped.
              % huddle jsondump {HUDDLE {L {{L {{s i} {s baa} {s \\k} {L {{s 1.0} {s true} {s /g} {s h}}} {L {{s g}}}}} {s t}}}}
              [
                [
                  "i",
                  "baa",
                  "\\k",
                  [
                    1.0,
                    true,
                    "\/g",
                    "h"
                  ],
                  ["g"]
                ],
                "t"
              ]
              # stripped output
              % huddle jsondump {HUDDLE {D {dd {D {bb {D {a {s baa} c {s {d
              a}}}} cc {D {g {s h}}}}} ee {D {i {s j} k {s 1} j {s { m\a}}}}}}} "" ""
              {"dd": {"bb": {"a": "baa","c": "d\na"},"cc": {"g": "h"}},"ee": {"i": "j","k": 1,"j": " m\\a"}}

       <b>huddle</b> <b>compile</b> <u>spec</u> <u>data</u>
              construct a huddle object from plain old tcl values.  <u>spec</u> is defined as follows:

              <b>string</b> data is simply a string

              <b>list</b>   data is a tcl list of strings

              <b>dict</b>   data is a tcl dict of strings

              list list
                     data is a tcl list of lists

              list dict
                     data is a tcl list of dicts

              dict xx list
                     data is a tcl dict where the value of key xx is a tcl list

              dict * list
                     data is a tcl dict of lists <u>data</u> is plain old tcl values

              % huddle compile {dict * list} {a {1 2 3} b {4 5}}
              HUDDLE {D {a {L {{s 1} {s 2} {s 3}}} b {L {{s 4} {s 5}}}}}
              % huddle compile {dict * {list {dict d list}}} {a {{c 1} {d {2 2 2} e 3}} b {{f 4 g 5}}}
              HUDDLE {D {a {L {{D {c {s 1}}} {D {d {L {{s 2} {s 2} {s 2}}} e {s 3}}}}} b {L {{D {f {s 4} g {s 5}}}}}}}

       <b>huddle</b> <b>isHuddle</b> <u>object</u>
              if <u>object</u> is a huddle, returns 1. the other, returns 0.

       <b>huddle</b> <b>checkHuddle</b> <u>object</u>
              if <u>object</u> is not a huddle, rises an error.

       <b>huddle</b> <b>to_node</b> <u>object</u> ?<u>tag</u>?
              for type-callbacks.

              if <u>object</u> is a huddle, returns root-node. the other, returns <b>[list</b> <b>s</b> <b>$object]</b>.

              % huddle to_node str
              s str
              % huddle to_node str !!str
              !!str str
              % huddle to_node {HUDDLE {s str}}
              s str
              % huddle to_node {HUDDLE {l {a b c}}}
              l {a b c}

       <b>huddle</b> <b>wrap</b> <u>tag</u> <u>src</u>
              for type-callbacks.

              Create a huddle object from <u>src</u> with specified <u>tag</u>.

              % huddle wrap "" str
              HUDDLE str
              % huddle wrap s str
              HUDDLE {s str}

       <b>huddle</b> <b>call</b> <u>tag</u> <u>command</u> <u>args</u>
              for type-callbacks.

              devolving <u>command</u> to default <u>tag</u>-callback

       <b>huddle</b> <b>addType</b> <u>callback</u>
              add a user-specified-type/tag to the huddle library.  To see "Additional Type".

              <b>callback</b>
                     callback function name for additional type.

</pre><h4><b>TYPE</b> <b>CALLBACK</b></h4><pre>
       The definition of callback for user-type.

       <b>callback</b> <u>command</u> ?<u>args</u>?

              <b>command</b>
                     huddle subcomand which is needed to reply by the callback.

              <b>args</b>   arguments of subcommand. The number of list of arguments is different for each subcommand.

       The callback procedure shuould reply the following subcommands.

       <b>setting</b>
              only returns a fixed dict of the type infomation for setting the user-tag.

              <b>type</b> typename
                     typename of the type

              <b>method</b> {method1 method2 method3 ...}
                     method list as huddle subcommand. Then, you can call <b>[huddle</b> <b>method1</b> <b>...]</b>

              <b>tag</b> {tag1 child/parent tag2 child/parent ...}
                     tag  list  for  huddle-node as a dict. if the type has child-nodes, use "parent", otherwise
                     use "child".

       <b>get_sub</b> <u>src</u> <u>key</u>
              returns a sub node specified by <u>key</u>.

              <b>src</b>    a node content in huddle object.

       <b>strip</b> <u>src</u>
              returns stripped node contents. if the type has child nodes, every node must be stripped.

       <b>set</b> <u>src</u> <u>key</u> <u>value</u>
              sets a sub-node from the tagged-content, and returns self.

       <b>remove</b> <u>src</u> <u>key</u> <u>value</u>
              removes a sub-node from the tagged-content, and returns self.

       <b>strip</b> must be defined at all types.  <b>get_sub</b> must be defined at container types.  <b>set/remove</b>  shuould  be
       defined, if you call them.

              # callback sample for my-dict
              proc my_dict_setting {command args} {
                  switch -- $command {
                      setting { ; # type definition
                          return {
                              type dict
                              method {create keys}
                              tag {d child D parent}
                              constructor create
                              str s
                          }
                          # type:   the type-name
                          # method: add methods to huddle's subcommand.
                          #          "get_sub/strip/set/remove/equal/append" called by huddle module.
                          #          "strip" must be defined at all types.
                          #          "get_sub" must be defined at container types.
                          #          "set/remove/equal/append" shuould be defined, if you call them.
                          # tag:    tag definition("child/parent" word is maybe obsoleted)
                      }
                      get_sub { ; # get a sub-node specified by "key" from the tagged-content
                          foreach {src key} $args break
                          return [dict get $src $key]
                      }
                      strip { ; # strip from the tagged-content
                          foreach {src nop} $args break
                          foreach {key val} $src {
                              lappend result $key [huddle strip $val]
                          }
                          return $result
                      }
                      set { ; # set a sub-node from the tagged-content
                          foreach {src key value} $args break
                          dict set src $key $value
                          return $src
                      }
                      remove { ; # remove a sub-node from the tagged-content
                          foreach {src key value} $args break
                          return [dict remove $src $key]
                      }
                      equal { ; # check equal for each node
                          foreach {src1 src2} $args break
                          if {[llength $src1] != [llength $src2]} {return 0}
                          foreach {key1 val1} $src1 {
                              if {![dict exists $src2 $key1]} {return 0}
                              if {![huddle _equal_subs $val1 [dict get $src2 $key1]]} {return 0}
                          }
                          return 1
                      }
                      append { ; # append nodes
                          foreach {str src list} $args break
                          if {[llength $list] % 2} {error {wrong # args: should be "huddle append objvar ?key value ...?"}}
                          set resultL $src
                          foreach {key value} $list {
                              if {$str ne ""} {
                                  lappend resultL $key [huddle to_node $value $str]
                              } else {
                                  lappend resultL $key $value
                              }
                          }
                          return [eval dict create $resultL]
                      }
                      create { ; # $args: all arguments after "huddle create"
                          if {[llength $args] % 2} {error {wrong # args: should be "huddle create ?key value ...?"}}
                          set resultL {}
                          foreach {key value} $args {
                              lappend resultL $key [huddle to_node $value]
                          }
                          return [huddle wrap D $resultL]
                      }
                      keys {
                          foreach {src nop} $args break
                          return [dict keys [lindex [lindex $src 1] 1]]
                      }
                      default {
                          error "$command is not callback for dict"
                      }
                  }
              }

              # inheritance sample from default dict-callback
              proc ::yaml::_huddle_mapping {command args} {
                  switch -- $command {
                      setting { ; # type definition
                          return {
                              type dict
                              method {mapping}
                              tag {!!map parent}
                              constructor mapping
                              str !!str
                          }
                      }
                      mapping { ; # $args: all arguments after "huddle mapping"
                          if {[llength $args] % 2} {error {wrong # args: should be "huddle mapping ?key value ...?"}}
                          set resultL {}
                          foreach {key value} $args {
                              lappend resultL $key [huddle to_node $value !!str]
                          }
                          return [huddle wrap !!map $resultL]
                      }
                      default { ; # devolving to default dict-callback
                          return [huddle call D $command $args]
                      }
                  }
              }

</pre><h4><b>HOW</b> <b>TO</b> <b>ADD</b> <b>TYPE</b></h4><pre>
       You  can  add  huddle-node  types  e.g. ::struct::tree.  To do so, first, define a callback-procedure for
       additional tagged-type.  The proc get argments as <u>command</u> and ?<u>args</u>?. It has some switch-sections.

       And, addType subcommand will called.

              huddle addType my_dict_setting

</pre><h4><b>WORKING</b> <b>SAMPLE</b></h4><pre>
              # create as a dict
              % set bb [huddle create a b c d]
              HUDDLE {D {a {s b} c {s d}}}

              # create as a list
              % set cc [huddle list e f g h]
              HUDDLE {L {{s e} {s f} {s g} {s h}}}
              % set bbcc [huddle create bb $bb cc $cc]
              HUDDLE {D {bb {D {a {s b} c {s d}}} cc {L {{s e} {s f} {s g} {s h}}}}}
              % set folding [huddle list $bbcc p [huddle list q r] s]
              HUDDLE {L {{D {bb {D {a {s b} c {s d}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q} {s r}}} {s s}}}

              # normal Tcl's notation
              % huddle strip $folding
              {bb {a b c d} cc {e f g h}} p {q r} s

              # get a sub node
              % huddle get $folding 0 bb
              HUDDLE {D {a {s b} c {s d}}}
              % huddle gets $folding 0 bb
              a b c d

              # overwrite a node
              % huddle set folding 0 bb c kkk
              HUDDLE {L {{D {bb {D {a {s b} c {s kkk}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q} {s r}}} {s s}}}

              # remove a node
              % huddle remove $folding 2 1
              HUDDLE {L {{D {bb {D {a {s b} c {s kkk}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q}}} {s s}}}
              % huddle strip $folding
              {bb {a b c kkk} cc {e f g h}} p {q r} s

              # dump as a JSON stream
              % huddle jsondump $folding
              [
                {
                  "bb": {
                    "a": "b",
                    "c": "kkk"
                  },
                  "cc": [
                    "e",
                    "f",
                    "g",
                    "h"
                  ]
                },
                "p",
                [
                  "q",
                  "r"
                ],
                "s"
              ]

</pre><h4><b>LIMITATIONS</b></h4><pre>
       now printing.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report such in the category <u>huddle</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       yaml

</pre><h4><b>KEYWORDS</b></h4><pre>
       data exchange, exchange format, huddle, json, parsing, text processing, yaml

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2008-2011 KATO Kanryu &lt;<a href="mailto:kanryu6@users.sourceforge.net">kanryu6@users.sourceforge.net</a>&gt;
       Copyright (c) 2015 Miguel Martínez López &lt;<a href="mailto:aplicacionamedida@gmail.com">aplicacionamedida@gmail.com</a>&gt;

tcllib                                                 0.5                                          <u><a href="../man3tcl/huddle.3tcl.html">huddle</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>