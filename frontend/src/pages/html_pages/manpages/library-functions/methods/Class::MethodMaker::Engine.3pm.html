<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::MethodMaker::Engine - The parameter passing, method installation & non-data-structure methods of</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-methodmaker-perl">libclass-methodmaker-perl_2.25-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::MethodMaker::Engine - The parameter passing, method installation &amp; non-data-structure methods of
       Class::MethodMaker.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This class is for internal implementation only.  It is not a public API.

       The non-data-structure methods do form part of the public API, but not called directly: rather, called
       through the "use"/"import" interface, as for data-structure methods.

</pre><h4><b>The</b> <b>Class::MethodMaker</b> <b>Method</b> <b>Installation</b> <b>Engine</b></h4><pre>
   <b>import</b>
       This performs argument parsing ready for calling create_methods.  In particular, this is the point at
       which v1 &amp; v2 calls are distinguished.

       This is implicitly called as part of a "use" statement:

         use Class::MethodMaker
           [ scalar =&gt; [qw/ foo bar baz /],
             new    =&gt; [qw/ new /]        ,
           ];

       is equivalent to

         Class::MethodMaker-&gt;import([scalar =&gt; [qw/ foo bar baz /],
                                     new    =&gt; [qw/ new /]        ,
                                    ]);

       See perldoc -f use for details of this equivalence.

       The methods created are installed into the class calling the import - or more accurately, the first class
       up the calling stack that is not "Class::MethodMaker" or a subclass thereof.

       SYNOPSIS
             Class::MethodMaker-&gt;import([scalar =&gt; [+{ -type   =&gt; 'File::Stat',
                                                       -forward =&gt; [qw/ mode size /],
                                                       '*_foo' =&gt; '*_fig',
                                                       '*_gop' =&gt; undef,
                                                       '*_bar' =&gt; '*_bar',
                                                       '*_hal' =&gt; '*_sal',
                                                      },
                                                    qw/ -static bob /,
                                                   ]
                                        ]);

   <b>parse_options</b>
       Parse  the  arguments  given  to import and call create_methods appropriately.  See main text for options
       syntax.

       SYNOPSIS
             Class::MethodMaker-&gt;parse_options('TargetClass',
                                               [scalar =&gt;
                                                 [{ -type =&gt; 'File::stat',
                                                    -forward =&gt; [qw/ mode
                                                                     size /],
                                                    '*_foo' =&gt; '*_fig',
                                                    '*_gop' =&gt; undef,
                                                    '*_bar' =&gt; '*_bar',
                                                    '*_hal' =&gt; '*_sal',
                                                  },
                                                  qw( -static bob ),
                                                 ]])},

             Class::MethodMaker-&gt;parse_options('TargetClass2',
                                               [scalar =&gt;
                                                 ['baz',
                                                  { -type =&gt; 'File::stat',
                                                    -forward =&gt; [qw/ mode
                                                                     size /],
                                                    '*_foo' =&gt; '*_fog',
                                                    '*_bar' =&gt; '*_bar',
                                                    '*_hal' =&gt; '*_sal',
                                                  },
                                                  qw( -static bob ),
                                                 ]],
                                               +{ -type =&gt; 'Math::BigInt', },
                                               +{'*_foo' =&gt; '*_fig',
                                                 '*_gop' =&gt; undef,},
                                              )},

       ARGUMENTS
           target_class
               The class into which to install components

           args
               The arguments to parse, as a single arrayref.

           options
               A hashref of options to apply to all components created by this call (subject  to  overriding  by
               explicit option calls).

           renames
               A  hashref  of  renames to apply to all components created by this call (subject to overriding by
               explicit rename calls).

   <b>create_methods</b>
       Add methods to a class.  Methods for multiple components  may  be  added  this  way,  but  create_methods
       handles  only  one  set  of  options.  parse_options is responsible for sorting which options to apply to
       which components, and calling create_methods appropriately.

       SYNOPSIS
             Class::MethodMaker-&gt;create_methods($target_class,
                                                scalar =&gt; bob,
                                                +{ static =&gt; 1,
                                                   type   =&gt; 'File::Stat',
                                                   forward =&gt; [qw/ mode size /], },
                                                +{ '*_foo' =&gt; '*_fig',
                                                   '*_gop' =&gt; undef,
                                                   '*_bar' =&gt; '*_bar',
                                                   '*_hal' =&gt; '*_sal', }
                                               );

       ARGUMENTS
           targetclass
               The class to add methods to.

           type
               The basic data structure to use for the component, e.g., "scalar".

           compname
               Component name.  The name must be a valid identifier, i.e., a continuous non-empty string of word
               ("\w") characters, of which the first may not be a digit.

           options
               A hashref.  Some options ("static", "type", "default", "default_ctor") are handled by  the  auto-
               extender.   These  will  be  invoked  if the name is present as a key and the value is true.  Any
               other options are passed through to the method in question.  The options should be  named  as-is;
               no leading hyphen should be applied (i.e., use "{static =&gt; 1}" not "{-static =&gt; 1}").

           renames
               A  list of customer renames.  It is a hashref from method name to rename.  The method name is the
               generic name (i.e., featuring a "*" to replace with the component name).  The rename is the value
               to rename with.  It may itself contain a "*" to replace with the component name.   If  rename  is
               undef,  the  method  is <u>not</u> installed.  For methods that would not be installed by default, use a
               rename value that is the same as the method name.

               So, if a type would normally install methods

                 '*_foo', '*_gop', '*_tom'

               and optionally installs (but not by default)

                 '*_bar', '*_wiz', '*_hal'

               using a renames value of

                 { '*_foo' =&gt; '*_fig',
                   '*_gop' =&gt; undef,
                   '*_bar' =&gt; '*_bar',
                   '*_hal' =&gt; '*_sal',
                 }

               with a component name of "xx", then *_foo  is  installed  as  "xx_fig",  *_bar  is  installed  as
               "xx_bar",  *_wiz  is  not  installed, *_hal is installed as "xx_sal", *_gop is not installed, and
               *_tom is installed as "xx_tom".

               The value may actually be an arrayref, in which case the function may be called  by  any  of  the
               multiple names specified.

   <b>install_methods</b>
       SYNOPSIS
             Class::MethodMaker-&gt;install_methods
               ($classname, { incr =&gt; sub { $i++ },
                              decr =&gt; sub { $i-- },
                            }
               );

       ARGUMENTS
           target
               The class into which the methods are to be installed

           methods
               The  methods  to  install,  as  a  hashref.   Keys  are  the method names; values are the methods
               themselves, as code refs.

</pre><h4><b>Non-data-structure</b> <b>components</b></h4><pre>
   <b>new</b>
         use Class::MethodMaker
           [ new =&gt; 'new' ];

       Creates a basic constructor.

       Takes a single string or a reference to an array of strings as its argument.  For each string  creates  a
       simple method that creates and returns an object of the appropriate class.

       The generated method may be called as a class method, as usual, or as in instance method, in which case a
       new object of the same class as the instance will be created.

       <u>Options</u>

       -hash
           The  constructor will accept as arguments a list of pairs, from component name to initial value.  For
           each pair, the named component is initialized by calling the method of the same name with  the  given
           value.  E.g.,

             package MyClass;
             use Class::MethodMaker
               [ new    =&gt; [qw/ -hash new /],
                 scalar =&gt; [qw/ b c /],
               ];

             sub d {
               my $self = shift;
               $self-&gt;{d} = $_[0]
                 if @_;
               return $self-&gt;{d};
             }

             package main;
             # The statement below implicitly calls
             # $m-&gt;<a href="../man1/b.1.html">b</a>(1); $m-&gt;<a href="../man2/c.2.html">c</a>(2); $m-&gt;<a href="../man3/d.3.html">d</a>(3)
             # on the newly constructed m.
             my $m = MyClass-&gt;new(b =&gt; 1, c =&gt; 2, d =&gt; 3);

           Note that this can also call user-supplied methods that have the name of the component.

           Instead  of  a  list  of  pairs,  a  single  hashref  may  also  be  passed,  which  will be expanded
           appropriately.  So the above is equivalent to:

             my $m = MyClass-&gt;new({ b =&gt; 1, c =&gt; 2, d =&gt; 3 });

           <u>Advanced</u> <u>Users:</u> Class::MethodMaker method renaming is taken into account, so even if the  "*"  method
           is renamed or removed, this will still work.

       -init
           This  option  causes  the  new  method  to  call  an initializer method.  The method is called "init"
           (original, eh?) by default, but the option may be given an alternative value.   The  init  method  is
           passed  any  arguments  that  were  passed to the constructor, but the method is invoked on the newly
           constructed instance.

             use Class::MethodMaker
               [ new =&gt; [qw/ -init new1 /, { -init =&gt; 'bob' } =&gt; 'init2' ]];

           Constructing with new1 involves an implicit call to "init", whilst constructing with new2 involves an
           implicit call to "bob" (<u>instead</u> of "init").

           It is the responsibility of the user to ensure that an "init" method (or whatever name) is defined.

       -singleton
           Creates a basic constructor which only ever returns a single instance of the class: i.e.,  after  the
           first  call,  repeated calls to this constructor return the <u>same</u> instance.  Note that the instance is
           instantiated at the time of the first call, not before.

   <b>abstract</b>
         use Class::MethodMaker
           [ abstract =&gt; [ qw / foo bar baz / ] ];

       This creates a number of methods that will die if called.   This  is  intended  to  support  the  use  of
       abstract methods, that must be overridden in a useful subclass.

   <b>copy</b>
         use Class::MethodMaker
           [ copy =&gt; [qw/ shallow -deep deep /] ];

       This creates method that produce a copy of self.  The copy is a by default a <u>shallow</u> copy; any references
       will  be  shared by the instance upon which the method is called and the returned newborn.  One option is
       taken, "-deep", which causes the method to create  <u>deep</u>  copies  instead  (i.e.,  references  are  copied
       recursively).

       <b>Implementation</b> <b>Note:</b>

       Deep  copies are performed using the "Storable" module if available, else "Data::Dumper".  The "Storable"
       module is liable to be much quicker.  However, this implementation note is not an API specification:  the
       implementation  details are open to change in a future version as faster/better ways of performing a deep
       copy become available.

       Note that deep copying does not currently support the copying of coderefs, ties or XS-based objects.

</pre><h4><b>AUTHOR</b></h4><pre>
       Martyn J. Pearce &lt;<a href="mailto:fluffy@cpan.org">fluffy@cpan.org</a>&gt;

perl v5.40.0                                       2024-11-15                    <u>Class::MethodMaker::<a href="../man3pm/Engine.3pm.html">Engine</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>