<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tgsy2 - tgsy2: Sylvester equation panel (?)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tgsy2 - tgsy2: Sylvester equation panel (?)

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>ctgsy2</b> (trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, rdsum,
           rdscal, info)
           <b>CTGSY2</b> solves the generalized Sylvester equation (unblocked algorithm).
       subroutine <b>dtgsy2</b> (trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, rdsum,
           rdscal, iwork, pq, info)
           <b>DTGSY2</b> solves the generalized Sylvester equation (unblocked algorithm).
       subroutine <b>stgsy2</b> (trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, rdsum,
           rdscal, iwork, pq, info)
           <b>STGSY2</b> solves the generalized Sylvester equation (unblocked algorithm).
       subroutine <b>ztgsy2</b> (trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, rdsum,
           rdscal, info)
           <b>ZTGSY2</b> solves the generalized Sylvester equation (unblocked algorithm).

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>ctgsy2</b> <b>(character</b> <b>trans,</b> <b>integer</b> <b>ijob,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b>
       <b>integer</b> <b>lda,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldd,</b> <b>*</b> <b>)</b> <b>d,</b> <b>integer</b> <b>ldd,</b> <b>complex,</b> <b>dimension(</b> <b>lde,</b> <b>*</b> <b>)</b> <b>e,</b> <b>integer</b> <b>lde,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldf,</b> <b>*</b> <b>)</b> <b>f,</b> <b>integer</b> <b>ldf,</b> <b>real</b> <b>scale,</b> <b>real</b> <b>rdsum,</b> <b>real</b> <b>rdscal,</b> <b>integer</b> <b>info)</b>
       <b>CTGSY2</b> solves the generalized Sylvester equation (unblocked algorithm).

       <b>Purpose:</b>

            CTGSY2 solves the generalized Sylvester equation

                        A * R - L * B = scale *  C               (1)
                        D * R - L * E = scale * F

            using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
            (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
            N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
            (i.e., (A,D) and (B,E) in generalized Schur form).

            The solution (R, L) overwrites (C, F). 0 &lt;= SCALE &lt;= 1 is an output
            scaling factor chosen to avoid overflow.

            In matrix notation solving equation (1) corresponds to solve
            Zx = scale * b, where Z is defined as

                   Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)
                       [ kron(In, D)  -kron(E**H, Im) ],

            Ik is the identity matrix of size k and X**H is the transpose of X.
            kron(X, Y) is the Kronecker product between the matrices X and Y.

            If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b
            is solved for, which is equivalent to solve for R and L in

                        A**H * R  + D**H * L   = scale * C           (3)
                        R  * B**H + L  * E**H  = scale * -F

            This case is used to compute an estimate of Dif[(A, D), (B, E)] =
            = sigma_min(Z) using reverse communication with CLACON.

            CTGSY2 also (IJOB &gt;= 1) contributes to the computation in CTGSYL
            of an upper bound on the separation between to matrix pairs. Then
            the input (A, D), (B, E) are sub-pencils of two matrix pairs in
            CTGSYL.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': solve the generalized Sylvester equation (1).
                     = 'T': solve the 'transposed' system (3).

           <u>IJOB</u>

                     IJOB is INTEGER
                     Specifies what kind of functionality to be performed.
                     = 0: solve (1) only.
                     = 1: A contribution from this subsystem to a Frobenius
                          norm-based estimate of the separation between two matrix
                          pairs is computed. (look ahead strategy is used).
                     = 2: A contribution from this subsystem to a Frobenius
                          norm-based estimate of the separation between two matrix
                          pairs is computed. (SGECON on sub-systems is used.)
                     Not referenced if TRANS = 'T'.

           <u>M</u>

                     M is INTEGER
                     On entry, M specifies the order of A and D, and the row
                     dimension of C, F, R and L.

           <u>N</u>

                     N is INTEGER
                     On entry, N specifies the order of B and E, and the column
                     dimension of C, F, R and L.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA, M)
                     On entry, A contains an upper triangular matrix.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the matrix A. LDA &gt;= max(1, M).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB, N)
                     On entry, B contains an upper triangular matrix.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the matrix B. LDB &gt;= max(1, N).

           <u>C</u>

                     C is COMPLEX array, dimension (LDC, N)
                     On entry, C contains the right-hand-side of the first matrix
                     equation in (1).
                     On exit, if IJOB = 0, C has been overwritten by the solution
                     R.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the matrix C. LDC &gt;= max(1, M).

           <u>D</u>

                     D is COMPLEX array, dimension (LDD, M)
                     On entry, D contains an upper triangular matrix.

           <u>LDD</u>

                     LDD is INTEGER
                     The leading dimension of the matrix D. LDD &gt;= max(1, M).

           <u>E</u>

                     E is COMPLEX array, dimension (LDE, N)
                     On entry, E contains an upper triangular matrix.

           <u>LDE</u>

                     LDE is INTEGER
                     The leading dimension of the matrix E. LDE &gt;= max(1, N).

           <u>F</u>

                     F is COMPLEX array, dimension (LDF, N)
                     On entry, F contains the right-hand-side of the second matrix
                     equation in (1).
                     On exit, if IJOB = 0, F has been overwritten by the solution
                     L.

           <u>LDF</u>

                     LDF is INTEGER
                     The leading dimension of the matrix F. LDF &gt;= max(1, M).

           <u>SCALE</u>

                     SCALE is REAL
                     On exit, 0 &lt;= SCALE &lt;= 1. If 0 &lt; SCALE &lt; 1, the solutions
                     R and L (C and F on entry) will hold the solutions to a
                     slightly perturbed system but the input matrices A, B, D and
                     E have not been changed. If SCALE = 0, R and L will hold the
                     solutions to the homogeneous system with C = F = 0.
                     Normally, SCALE = 1.

           <u>RDSUM</u>

                     RDSUM is REAL
                     On entry, the sum of squares of computed contributions to
                     the Dif-estimate under computation by CTGSYL, where the
                     scaling factor RDSCAL (see below) has been factored out.
                     On exit, the corresponding sum of squares updated with the
                     contributions from the current sub-system.
                     If TRANS = 'T' RDSUM is not touched.
                     NOTE: RDSUM only makes sense when CTGSY2 is called by
                     CTGSYL.

           <u>RDSCAL</u>

                     RDSCAL is REAL
                     On entry, scaling factor used to prevent overflow in RDSUM.
                     On exit, RDSCAL is updated w.r.t. the current contributions
                     in RDSUM.
                     If TRANS = 'T', RDSCAL is not touched.
                     NOTE: RDSCAL only makes sense when CTGSY2 is called by
                     CTGSYL.

           <u>INFO</u>

                     INFO is INTEGER
                     On exit, if INFO is set to
                       =0: Successful exit
                       &lt;0: If INFO = -i, input argument number i is illegal.
                       &gt;0: The matrix pairs (A, D) and (B, E) have common or very
                           close eigenvalues.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

   <b>subroutine</b> <b>dtgsy2</b> <b>(character</b> <b>trans,</b> <b>integer</b> <b>ijob,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b>
       <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b>
       <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldd,</b> <b>*</b> <b>)</b> <b>d,</b> <b>integer</b> <b>ldd,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lde,</b>
       <b>*</b> <b>)</b> <b>e,</b> <b>integer</b> <b>lde,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldf,</b> <b>*</b> <b>)</b> <b>f,</b> <b>integer</b> <b>ldf,</b> <b>double</b> <b>precision</b> <b>scale,</b> <b>double</b>
       <b>precision</b> <b>rdsum,</b> <b>double</b> <b>precision</b> <b>rdscal,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>pq,</b> <b>integer</b> <b>info)</b>
       <b>DTGSY2</b> solves the generalized Sylvester equation (unblocked algorithm).

       <b>Purpose:</b>

            DTGSY2 solves the generalized Sylvester equation:

                        A * R - L * B = scale * C                (1)
                        D * R - L * E = scale * F,

            using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
            (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
            N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
            must be in generalized Schur canonical form, i.e. A, B are upper
            quasi triangular and D, E are upper triangular. The solution (R, L)
            overwrites (C, F). 0 &lt;= SCALE &lt;= 1 is an output scaling factor
            chosen to avoid overflow.

            In matrix notation solving equation (1) corresponds to solve
            Z*x = scale*b, where Z is defined as

                   Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)
                       [ kron(In, D)  -kron(E**T, Im) ],

            Ik is the identity matrix of size k and X**T is the transpose of X.
            kron(X, Y) is the Kronecker product between the matrices X and Y.
            In the process of solving (1), we solve a number of such systems
            where Dim(In), Dim(In) = 1 or 2.

            If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,
            which is equivalent to solve for R and L in

                        A**T * R  + D**T * L   = scale * C           (3)
                        R  * B**T + L  * E**T  = scale * -F

            This case is used to compute an estimate of Dif[(A, D), (B, E)] =
            sigma_min(Z) using reverse communication with DLACON.

            DTGSY2 also (IJOB &gt;= 1) contributes to the computation in DTGSYL
            of an upper bound on the separation between to matrix pairs. Then
            the input (A, D), (B, E) are sub-pencils of the matrix pair in
            DTGSYL. See DTGSYL for details.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': solve the generalized Sylvester equation (1).
                     = 'T': solve the 'transposed' system (3).

           <u>IJOB</u>

                     IJOB is INTEGER
                     Specifies what kind of functionality to be performed.
                     = 0: solve (1) only.
                     = 1: A contribution from this subsystem to a Frobenius
                          norm-based estimate of the separation between two matrix
                          pairs is computed. (look ahead strategy is used).
                     = 2: A contribution from this subsystem to a Frobenius
                          norm-based estimate of the separation between two matrix
                          pairs is computed. (DGECON on sub-systems is used.)
                     Not referenced if TRANS = 'T'.

           <u>M</u>

                     M is INTEGER
                     On entry, M specifies the order of A and D, and the row
                     dimension of C, F, R and L.

           <u>N</u>

                     N is INTEGER
                     On entry, N specifies the order of B and E, and the column
                     dimension of C, F, R and L.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA, M)
                     On entry, A contains an upper quasi triangular matrix.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the matrix A. LDA &gt;= max(1, M).

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB, N)
                     On entry, B contains an upper quasi triangular matrix.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the matrix B. LDB &gt;= max(1, N).

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC, N)
                     On entry, C contains the right-hand-side of the first matrix
                     equation in (1).
                     On exit, if IJOB = 0, C has been overwritten by the
                     solution R.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the matrix C. LDC &gt;= max(1, M).

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (LDD, M)
                     On entry, D contains an upper triangular matrix.

           <u>LDD</u>

                     LDD is INTEGER
                     The leading dimension of the matrix D. LDD &gt;= max(1, M).

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (LDE, N)
                     On entry, E contains an upper triangular matrix.

           <u>LDE</u>

                     LDE is INTEGER
                     The leading dimension of the matrix E. LDE &gt;= max(1, N).

           <u>F</u>

                     F is DOUBLE PRECISION array, dimension (LDF, N)
                     On entry, F contains the right-hand-side of the second matrix
                     equation in (1).
                     On exit, if IJOB = 0, F has been overwritten by the
                     solution L.

           <u>LDF</u>

                     LDF is INTEGER
                     The leading dimension of the matrix F. LDF &gt;= max(1, M).

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     On exit, 0 &lt;= SCALE &lt;= 1. If 0 &lt; SCALE &lt; 1, the solutions
                     R and L (C and F on entry) will hold the solutions to a
                     slightly perturbed system but the input matrices A, B, D and
                     E have not been changed. If SCALE = 0, R and L will hold the
                     solutions to the homogeneous system with C = F = 0. Normally,
                     SCALE = 1.

           <u>RDSUM</u>

                     RDSUM is DOUBLE PRECISION
                     On entry, the sum of squares of computed contributions to
                     the Dif-estimate under computation by DTGSYL, where the
                     scaling factor RDSCAL (see below) has been factored out.
                     On exit, the corresponding sum of squares updated with the
                     contributions from the current sub-system.
                     If TRANS = 'T' RDSUM is not touched.
                     NOTE: RDSUM only makes sense when DTGSY2 is called by DTGSYL.

           <u>RDSCAL</u>

                     RDSCAL is DOUBLE PRECISION
                     On entry, scaling factor used to prevent overflow in RDSUM.
                     On exit, RDSCAL is updated w.r.t. the current contributions
                     in RDSUM.
                     If TRANS = 'T', RDSCAL is not touched.
                     NOTE: RDSCAL only makes sense when DTGSY2 is called by
                           DTGSYL.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (M+N+2)

           <u>PQ</u>

                     PQ is INTEGER
                     On exit, the number of subsystems (of size 2-by-2, 4-by-4 and
                     8-by-8) solved by this routine.

           <u>INFO</u>

                     INFO is INTEGER
                     On exit, if INFO is set to
                       =0: Successful exit
                       &lt;0: If INFO = -i, the i-th argument had an illegal value.
                       &gt;0: The matrix pairs (A, D) and (B, E) have common or very
                           close eigenvalues.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

   <b>subroutine</b> <b>stgsy2</b> <b>(character</b> <b>trans,</b> <b>integer</b> <b>ijob,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b>
       <b>lda,</b> <b>real,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b> <b>real,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>real,</b> <b>dimension(</b>
       <b>ldd,</b> <b>*</b> <b>)</b> <b>d,</b> <b>integer</b> <b>ldd,</b> <b>real,</b> <b>dimension(</b> <b>lde,</b> <b>*</b> <b>)</b> <b>e,</b> <b>integer</b> <b>lde,</b> <b>real,</b> <b>dimension(</b> <b>ldf,</b> <b>*</b> <b>)</b> <b>f,</b> <b>integer</b>
       <b>ldf,</b> <b>real</b> <b>scale,</b> <b>real</b> <b>rdsum,</b> <b>real</b> <b>rdscal,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>pq,</b> <b>integer</b> <b>info)</b>
       <b>STGSY2</b> solves the generalized Sylvester equation (unblocked algorithm).

       <b>Purpose:</b>

            STGSY2 solves the generalized Sylvester equation:

                        A * R - L * B = scale * C                (1)
                        D * R - L * E = scale * F,

            using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
            (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
            N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
            must be in generalized Schur canonical form, i.e. A, B are upper
            quasi triangular and D, E are upper triangular. The solution (R, L)
            overwrites (C, F). 0 &lt;= SCALE &lt;= 1 is an output scaling factor
            chosen to avoid overflow.

            In matrix notation solving equation (1) corresponds to solve
            Z*x = scale*b, where Z is defined as

                   Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)
                       [ kron(In, D)  -kron(E**T, Im) ],

            Ik is the identity matrix of size k and X**T is the transpose of X.
            kron(X, Y) is the Kronecker product between the matrices X and Y.
            In the process of solving (1), we solve a number of such systems
            where Dim(In), Dim(In) = 1 or 2.

            If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,
            which is equivalent to solve for R and L in

                        A**T * R  + D**T * L   = scale * C           (3)
                        R  * B**T + L  * E**T  = scale * -F

            This case is used to compute an estimate of Dif[(A, D), (B, E)] =
            sigma_min(Z) using reverse communication with SLACON.

            STGSY2 also (IJOB &gt;= 1) contributes to the computation in STGSYL
            of an upper bound on the separation between to matrix pairs. Then
            the input (A, D), (B, E) are sub-pencils of the matrix pair in
            STGSYL. See STGSYL for details.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': solve the generalized Sylvester equation (1).
                     = 'T': solve the 'transposed' system (3).

           <u>IJOB</u>

                     IJOB is INTEGER
                     Specifies what kind of functionality to be performed.
                     = 0: solve (1) only.
                     = 1: A contribution from this subsystem to a Frobenius
                          norm-based estimate of the separation between two matrix
                          pairs is computed. (look ahead strategy is used).
                     = 2: A contribution from this subsystem to a Frobenius
                          norm-based estimate of the separation between two matrix
                          pairs is computed. (SGECON on sub-systems is used.)
                     Not referenced if TRANS = 'T'.

           <u>M</u>

                     M is INTEGER
                     On entry, M specifies the order of A and D, and the row
                     dimension of C, F, R and L.

           <u>N</u>

                     N is INTEGER
                     On entry, N specifies the order of B and E, and the column
                     dimension of C, F, R and L.

           <u>A</u>

                     A is REAL array, dimension (LDA, M)
                     On entry, A contains an upper quasi triangular matrix.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the matrix A. LDA &gt;= max(1, M).

           <u>B</u>

                     B is REAL array, dimension (LDB, N)
                     On entry, B contains an upper quasi triangular matrix.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the matrix B. LDB &gt;= max(1, N).

           <u>C</u>

                     C is REAL array, dimension (LDC, N)
                     On entry, C contains the right-hand-side of the first matrix
                     equation in (1).
                     On exit, if IJOB = 0, C has been overwritten by the
                     solution R.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the matrix C. LDC &gt;= max(1, M).

           <u>D</u>

                     D is REAL array, dimension (LDD, M)
                     On entry, D contains an upper triangular matrix.

           <u>LDD</u>

                     LDD is INTEGER
                     The leading dimension of the matrix D. LDD &gt;= max(1, M).

           <u>E</u>

                     E is REAL array, dimension (LDE, N)
                     On entry, E contains an upper triangular matrix.

           <u>LDE</u>

                     LDE is INTEGER
                     The leading dimension of the matrix E. LDE &gt;= max(1, N).

           <u>F</u>

                     F is REAL array, dimension (LDF, N)
                     On entry, F contains the right-hand-side of the second matrix
                     equation in (1).
                     On exit, if IJOB = 0, F has been overwritten by the
                     solution L.

           <u>LDF</u>

                     LDF is INTEGER
                     The leading dimension of the matrix F. LDF &gt;= max(1, M).

           <u>SCALE</u>

                     SCALE is REAL
                     On exit, 0 &lt;= SCALE &lt;= 1. If 0 &lt; SCALE &lt; 1, the solutions
                     R and L (C and F on entry) will hold the solutions to a
                     slightly perturbed system but the input matrices A, B, D and
                     E have not been changed. If SCALE = 0, R and L will hold the
                     solutions to the homogeneous system with C = F = 0. Normally,
                     SCALE = 1.

           <u>RDSUM</u>

                     RDSUM is REAL
                     On entry, the sum of squares of computed contributions to
                     the Dif-estimate under computation by STGSYL, where the
                     scaling factor RDSCAL (see below) has been factored out.
                     On exit, the corresponding sum of squares updated with the
                     contributions from the current sub-system.
                     If TRANS = 'T' RDSUM is not touched.
                     NOTE: RDSUM only makes sense when STGSY2 is called by STGSYL.

           <u>RDSCAL</u>

                     RDSCAL is REAL
                     On entry, scaling factor used to prevent overflow in RDSUM.
                     On exit, RDSCAL is updated w.r.t. the current contributions
                     in RDSUM.
                     If TRANS = 'T', RDSCAL is not touched.
                     NOTE: RDSCAL only makes sense when STGSY2 is called by
                           STGSYL.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (M+N+2)

           <u>PQ</u>

                     PQ is INTEGER
                     On exit, the number of subsystems (of size 2-by-2, 4-by-4 and
                     8-by-8) solved by this routine.

           <u>INFO</u>

                     INFO is INTEGER
                     On exit, if INFO is set to
                       =0: Successful exit
                       &lt;0: If INFO = -i, the i-th argument had an illegal value.
                       &gt;0: The matrix pairs (A, D) and (B, E) have common or very
                           close eigenvalues.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

   <b>subroutine</b> <b>ztgsy2</b> <b>(character</b> <b>trans,</b> <b>integer</b> <b>ijob,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b>
       <b>integer</b> <b>lda,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b>
       <b>ldc,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldd,</b> <b>*</b> <b>)</b> <b>d,</b> <b>integer</b> <b>ldd,</b> <b>complex*16,</b> <b>dimension(</b> <b>lde,</b> <b>*</b> <b>)</b> <b>e,</b> <b>integer</b> <b>lde,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldf,</b> <b>*</b> <b>)</b> <b>f,</b> <b>integer</b> <b>ldf,</b> <b>double</b> <b>precision</b> <b>scale,</b> <b>double</b> <b>precision</b> <b>rdsum,</b> <b>double</b>
       <b>precision</b> <b>rdscal,</b> <b>integer</b> <b>info)</b>
       <b>ZTGSY2</b> solves the generalized Sylvester equation (unblocked algorithm).

       <b>Purpose:</b>

            ZTGSY2 solves the generalized Sylvester equation

                        A * R - L * B = scale * C               (1)
                        D * R - L * E = scale * F

            using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
            (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
            N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
            (i.e., (A,D) and (B,E) in generalized Schur form).

            The solution (R, L) overwrites (C, F). 0 &lt;= SCALE &lt;= 1 is an output
            scaling factor chosen to avoid overflow.

            In matrix notation solving equation (1) corresponds to solve
            Zx = scale * b, where Z is defined as

                   Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)
                       [ kron(In, D)  -kron(E**H, Im) ],

            Ik is the identity matrix of size k and X**H is the conjugate transpose of X.
            kron(X, Y) is the Kronecker product between the matrices X and Y.

            If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b
            is solved for, which is equivalent to solve for R and L in

                        A**H * R  + D**H * L   = scale * C           (3)
                        R  * B**H + L  * E**H  = scale * -F

            This case is used to compute an estimate of Dif[(A, D), (B, E)] =
            = sigma_min(Z) using reverse communication with ZLACON.

            ZTGSY2 also (IJOB &gt;= 1) contributes to the computation in ZTGSYL
            of an upper bound on the separation between to matrix pairs. Then
            the input (A, D), (B, E) are sub-pencils of two matrix pairs in
            ZTGSYL.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': solve the generalized Sylvester equation (1).
                     = 'T': solve the 'transposed' system (3).

           <u>IJOB</u>

                     IJOB is INTEGER
                     Specifies what kind of functionality to be performed.
                     =0: solve (1) only.
                     =1: A contribution from this subsystem to a Frobenius
                         norm-based estimate of the separation between two matrix
                         pairs is computed. (look ahead strategy is used).
                     =2: A contribution from this subsystem to a Frobenius
                         norm-based estimate of the separation between two matrix
                         pairs is computed. (DGECON on sub-systems is used.)
                     Not referenced if TRANS = 'T'.

           <u>M</u>

                     M is INTEGER
                     On entry, M specifies the order of A and D, and the row
                     dimension of C, F, R and L.

           <u>N</u>

                     N is INTEGER
                     On entry, N specifies the order of B and E, and the column
                     dimension of C, F, R and L.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA, M)
                     On entry, A contains an upper triangular matrix.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the matrix A. LDA &gt;= max(1, M).

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB, N)
                     On entry, B contains an upper triangular matrix.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the matrix B. LDB &gt;= max(1, N).

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC, N)
                     On entry, C contains the right-hand-side of the first matrix
                     equation in (1).
                     On exit, if IJOB = 0, C has been overwritten by the solution
                     R.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the matrix C. LDC &gt;= max(1, M).

           <u>D</u>

                     D is COMPLEX*16 array, dimension (LDD, M)
                     On entry, D contains an upper triangular matrix.

           <u>LDD</u>

                     LDD is INTEGER
                     The leading dimension of the matrix D. LDD &gt;= max(1, M).

           <u>E</u>

                     E is COMPLEX*16 array, dimension (LDE, N)
                     On entry, E contains an upper triangular matrix.

           <u>LDE</u>

                     LDE is INTEGER
                     The leading dimension of the matrix E. LDE &gt;= max(1, N).

           <u>F</u>

                     F is COMPLEX*16 array, dimension (LDF, N)
                     On entry, F contains the right-hand-side of the second matrix
                     equation in (1).
                     On exit, if IJOB = 0, F has been overwritten by the solution
                     L.

           <u>LDF</u>

                     LDF is INTEGER
                     The leading dimension of the matrix F. LDF &gt;= max(1, M).

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     On exit, 0 &lt;= SCALE &lt;= 1. If 0 &lt; SCALE &lt; 1, the solutions
                     R and L (C and F on entry) will hold the solutions to a
                     slightly perturbed system but the input matrices A, B, D and
                     E have not been changed. If SCALE = 0, R and L will hold the
                     solutions to the homogeneous system with C = F = 0.
                     Normally, SCALE = 1.

           <u>RDSUM</u>

                     RDSUM is DOUBLE PRECISION
                     On entry, the sum of squares of computed contributions to
                     the Dif-estimate under computation by ZTGSYL, where the
                     scaling factor RDSCAL (see below) has been factored out.
                     On exit, the corresponding sum of squares updated with the
                     contributions from the current sub-system.
                     If TRANS = 'T' RDSUM is not touched.
                     NOTE: RDSUM only makes sense when ZTGSY2 is called by
                     ZTGSYL.

           <u>RDSCAL</u>

                     RDSCAL is DOUBLE PRECISION
                     On entry, scaling factor used to prevent overflow in RDSUM.
                     On exit, RDSCAL is updated w.r.t. the current contributions
                     in RDSUM.
                     If TRANS = 'T', RDSCAL is not touched.
                     NOTE: RDSCAL only makes sense when ZTGSY2 is called by
                     ZTGSYL.

           <u>INFO</u>

                     INFO is INTEGER
                     On exit, if INFO is set to
                       =0: Successful exit
                       &lt;0: If INFO = -i, input argument number i is illegal.
                       &gt;0: The matrix pairs (A, D) and (B, E) have common or very
                           close eigenvalues.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                              Sun Jul 20 2025 01:40:05                                    <u><a href="../man3/tgsy2.3.html">tgsy2</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>