<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Tools::Run::Analysis - Module representing any (remote or local) analysis tool</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-perl-perl">libbio-perl-perl_1.7.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Tools::Run::Analysis - Module representing any (remote or local) analysis tool

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # run analysis 'seqret' using a default location and a default
         # access method (which means using a Web Service at EBI)
         use Bio::Tools::Run::Analysis;
         print new Bio::Tools::Run::Analysis (-name =&gt; 'edit::seqret')
              -&gt;wait_for ({ sequence_direct_data =&gt; 'tatatacgtatacga',
                            osformat =&gt; 'embl'
                            })
              -&gt;result ('outseq');

         # run a longer job without waiting for its completion
         use Bio::Tools::Run::Analysis;
         my $job = Bio::Tools::Run::Analysis-&gt;new(-name =&gt; 'edit::seqret')
                        -&gt;run ({ sequence_direct_data =&gt; 'tatatacgtatacga',
                                 osformat =&gt; 'embl'
                                 });
         # ...and after a while
         $job-&gt;result ('outseq');

         # get all results in the same invocation (as a hash reference
         # with result names as keys) - let the module decide which
         # results are binary (images in this examples) and save those
         # in file (or files); it also shows how to tell that the module
         # should read input data from a local file first
         use Bio::Tools::Run::Analysis;
         my $results =
           Bio::Tools::Run::Analysis-&gt;new(-name =&gt; 'alignment_multiple::prettyplot')
              -&gt;wait_for ( { msf_direct_data =&gt; '@/home/testdata/my.seq' } )
              -&gt;results ('?');
         use Data::Dumper;
         print Dumper ($results);

         # get names, types of all inputs and results,
         # get short and detailed (in XML) service description
         use Bio::Tools::Run::Analysis;
         my $service = Bio::Tools::Run::Analysis-&gt;new(-name =&gt; 'edit::seqret');
         my $hash1 = $service-&gt;input_spec;
         my $hash2 = $service-&gt;result_spec;
         my $hash3 = $service-&gt;analysis_spec;
         my $xml = $service-&gt;describe;

         # get current job status
         use Bio::Tools::Run::Analysis;
         print new Bio::Tools::Run::Analysis (-name =&gt; 'edit::seqret')
           -&gt;run ( { #...input data...
                   } )
           -&gt;status;

         # run a job and print its job ID, keep the job un-destroyed
         use Bio::Tools::Run::Analysis;
         my $job =
           Bio::Tools::Run::Analysis-&gt;new(-name =&gt; 'edit::seqret',
                                          -destroy_on_exit =&gt; 0)
           -&gt;run ( { sequence_direct_data =&gt; '@/home/testdata/mzef.seq' } );
         print $job-&gt;id . "\n";
         # ...it prints (for example):
         #    edit::seqret/c8ef56:ef535489ac:-7ff4

         # ...in another time, on another planet, you may say
         use Bio::Tools::Run::Analysis;
         my $job =
           Bio::Tools::Run::Analysis::Job-&gt;new(-name =&gt; 'edit::seqret',
                                               -id =&gt; 'edit::seqret/c8ef56:ef535489ac:-7ff4');
         print join ("\n",
                   $job-&gt;status,
                   'Finished: ' . $job-&gt;ended (1),   # (1) means 'formatted'
                   'Elapsed time: ' . $job-&gt;elapsed,
                   $job-&gt;last_event,
                   $job-&gt;result ('outseq')
                   );

         # ...or you may achieve the same keeping module
         # Bio::Tools::Run::Analysis::Job invisible
         use Bio::Tools::Run::Analysis;
         my $job =
           Bio::Tools::Run::Analysis-&gt;new(-name =&gt; 'edit::seqret')
               -&gt;create_job ('edit::seqret/c8ef56:ef535489ac:-7ff4');
         print join ("\n",
                   $job-&gt;status,
                   # ...
                   );

         # ...and later you may free this job resources
         $job-&gt;remove;

         #
         # --- See DESCRIPTION for using generator 'applmaker.pl':
         #

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The module represents an access to the local and/or remote analysis tools in a unified way that allows
       adding new access methods (protocols) seamlessly.

       At the moment of writing, there is available a <u>SOAP</u> access to almost all EMBOSS applications, running at
       the European Bioinformatics Institute.

       The documentation of all "public" methods are to be found in "Bio::AnalysisI". A tutorial (and examples
       how to call almost all public methods) is in the script "panalysis.PLS" (go to the "scripts" directory
       and type "perldoc panalysis.PLS").

       The module "Bio::Tools::Run::Analysis" uses general approach allowing to set arbitrary input data and to
       retrieve results by naming them. However, sometimes is more convenient to use a specific module,
       representing one analysis tool, that already knows about available input and result names. Such analyses-
       specific Perl modules can be generated by "papplmaker.PLS" generator. Its features and usage are
       documented in the generator (go to the "scripts" directory and type "perldoc papplmaker.PLS").

         # this will generate module Seqret.pm
         perl papplmaker.PLS -n edit.seqret -m Seqret

         # ...which can be used with data-specific methods
         use Seqret;
         my $outseq = new Seqret
           -&gt;sequence_direct_data ('@/home/testdata/my.seq')
           -&gt;osformat ('embl')
           -&gt;wait_for
           -&gt;outseq
           ;
         print $outseq;

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>Lists</b>
       User feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments
       and suggestions preferably to the Bioperl mailing list.  Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list:

       <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather than to the module maintainer directly. Many experienced and reponsive experts will be able look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>Bugs</b>
       Report bugs to the Bioperl bug tracking system to help us keep track of the bugs and their resolution.
       Bug reports can be submitted via the web:

         <a href="http://redmine.open-bio.org/projects/bioperl/">http://redmine.open-bio.org/projects/bioperl/</a>

</pre><h4><b>AUTHOR</b></h4><pre>
       Martin Senger (<a href="mailto:martin.senger@gmail.com">martin.senger@gmail.com</a>)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2003, Martin Senger and EMBL-EBI.  All Rights Reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>DISCLAIMER</b></h4><pre>
       This software is provided "as is" without warranty of any kind.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       â€¢   <a href="http://www.ebi.ac.uk/soaplab/Perl_Client.html">http://www.ebi.ac.uk/soaplab/Perl_Client.html</a>

</pre><h4><b>APPENDIX</b></h4><pre>
       Here is the rest of the object methods.  Internal methods are preceded with an underscore _.

   <b>new</b>
        Usage   : my $tool =
                    Bio::Tools::Run::Analysis-&gt;new(-access =&gt; 'soap',
                                                   -name =&gt; 'edit.seqret',
                                                   ...
                                                   );
        Returns : a new Bio::Tools::Run::Analysis object representing the given tool
        Args    : There may be additional arguments which are specific
                  to the access method (see methods 'new' or '_initialize'
                  of the access-specific implementations (such as module
                  Bio::Tools::Run::Analysis::soap for a SOAP-based access).

                  The recognised and used arguments are:
                    -access
                    -location
                    -name
                    -httpproxy
                    -timeout

       It  builds,  populates  and returns a new "Bio::Tools::Run::Analysis" object. This is how it is seen from
       the outside. But in fact, it builds, populates and  returns  a  more  specific  lower-level  object,  for
       example "Bio::Tools::Run::Analysis::soap" object - which one it depends on the "-access" parameter.

       -access
           It  indicates  what lower-level module to load.  Default is 'soap'.  Other (but future) possibilities
           may be:

              -access =&gt; 'novella'
              -access =&gt; 'local'

       -location
           A location of  the  service.  The  contents  is  access-specific  (see  details  in  the  lower-level
           implementation modules).

           Default  is  "<a href="http://www.ebi.ac.uk/soaplab/services">http://www.ebi.ac.uk/soaplab/services</a>"  (  services  running at European Bioinformatics
           Institute on top of most of EMBOSS analyses, and on few others).

       -name
           A name of an analysis tool, or a name of its higher-level abstraction, possibly including a  category
           where  the  analysis belong to. There is no default value (which usually means that this parameter is
           mandatory unless your <u>-location</u> parameter includes also the name (but it is then access-dependent).

       -destroy_on_exit =&gt; '0'
           Default value is '1' which  means  that  all  Bio::Tools::Run::Analysis::Job  objects  -  when  being
           finalised - will send a request to the remote site to forget the results of these jobs.

           If  you  change  it to '0' make sure that you know the job identification - otherwise you will not be
           able to re-established connection with it (later, when you use your program again). This can be  done
           by  calling  method  "id"  on  the  job  object  (such  object  is  returned by any of these methods:
           "create_job", "run", "wait_for").

       -httpproxy
           In addition to the <u>location</u> parameter, you may need to specify also a location/URL of an  HTTP  proxy
           server (if your site requires one). The expected format is "<a href="http://server">http://server</a>:port".  There is no default
           value. It is also an access-specific parameter which may not be used by all access methods.

       -timeout
           For  long(er)  running  jobs  the  HTTP connection may be time-outed. In order to avoid it (or, vice-
           versa, to call timeout sooner) you may specify "timeout" with the number of  seconds  the  connection
           will be kept alive. Zero means to keep it alive forever. The default value is two minutes.

   <b>VERSION</b> <b>and</b> <b>Revision</b>
        Usage   : print $Bio::Tools::Run::Analysis::VERSION;
                  print $Bio::Tools::Run::Analysis::Revision;

</pre><h4><b>Module</b> <b>Bio::Tools::Run::Analysis::Job</b></h4><pre>
       It represents a job, a single execution of an analysis tool. Usually you do not instantiate these objects
       - they are returned by methods "create_job", "run", and "wait_for" of "Bio::Tools::Run::Analysis" object.

       However, if you wish to re-create a job you need to know its ID (method "id" gives it to you). The ID can
       be   passed   directly   to   the   "new"   method,   or   again   you   may   use   "create_job"   of  a
       "Bio::Tools::Run::Analysis" object with the ID as parameter. See SYNOPSIS above for an example.

       Remember that  all  public  methods  of  this  module  are  described  in  details  in  interface  module
       "Bio::AnalysisI" and in the tutorial in the "analysis.pl" script.

   <b>new</b>
        Usage   : my $job = Bio::Tools::Run::Analysis::Job-&gt;new
                              (-access =&gt; 'soap',
                               -name =&gt; 'edit.seqret',
                               -id =&gt; 'xxxyyy111222333'
                               );
        Returns : a re-created object representing a job
        Args    : The same arguments as for Bio::Tools::Run::Analysis object:
                    -access
                    -location
                    -name
                    -httpproxy
                    -timeout
                    (and perhaps others)
                  Additionally and specifically for this object:
                    -id
                    -analysis

       -id A  job  ID  created  some  previous  time and now used to re-create the same job (in order to re-gain
           access to this job results, for example).

       -analysis
           A "Bio::Tools::Run::Analysis" object whose properties (such as "-access" and "-location" are used  to
           re-create this job object.

</pre><h4><b>Module</b> <b>Bio::Tools::Run::Analysis::Utils</b></h4><pre>
       It  contains several general utilities. These are "functions", not methods. Therefore call them like, for
       example:

           &amp;Bio::Tools::Run::Analysis::Utils::format_time (...);

   <b>format_time</b>
        Usage   : Bio::Tools::Run::Analysis::Utils::format_time ($time);
        Returns : Slightly formatted $time
        Args    : $time is number of seconds from the beginning of Epoch

       It returns what "localtime" returns which means that return value is different in the  array  and  scalar
       context  (see  localtime).  If $time is ``-1'' it returns 'n/a' (in the scalar context) or an empty array
       (in the array context). If $time is too small to represent the distance from the beginning of the  Epoch,
       it  returns  it unchanged (the same in any contex) - this is reasonable for $time representing an elapsed
       time.

       The function is used to format times coming back from various job time methods.

   <b>_load_access_module</b>
        Usage   : $class-&gt;_load_access_module ($access)
        Returns : 1 on success, undef on failure
        Args    : 'access' should contain the last part of the
                  name of a module who does the real implementation

       It does (in the run-time) a similar thing as

          require Bio::Tools::Run::Analysis::$access

       It prints an error on STDERR if it fails to find and  load  the  module  (for  example,  because  of  the
       compilation errors in the module).

   <b>_guess_access</b>
        Usage   : Bio::Tools::Run::Analysis::Utils::guess_access ($rh_params)
        Returns : string with a guessed access protocol (e.g. 'soap'),
                  or undef if the guessing failed
        Args    : 'rh_params' is a hash reference containing parameters given
                  to the 'new' method.

       It  makes  an expert guess what kind of access/transport protocol should be used to access the underlying
       analysis. The guess is based on the parameters in <u>rh_params</u>. Remember that this method is called only  if
       there was no <u>-access</u> parameter which could tell directly what access method to use.

perl v5.32.1                                       2021-08-15                     <u>Bio::Tools::Run::<a href="../man3pm/Analysis.3pm.html">Analysis</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>