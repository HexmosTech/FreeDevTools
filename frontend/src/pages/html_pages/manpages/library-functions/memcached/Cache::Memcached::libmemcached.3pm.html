<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cache::Memcached::libmemcached - Cache interface to Memcached::libmemcached</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcache-memcached-libmemcached-perl">libcache-memcached-libmemcached-perl_0.04001-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Cache::Memcached::libmemcached - Cache interface to Memcached::libmemcached

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Cache::Memcached::libmemcached;

         my $memd = Cache::Memcached::libmemcached-&gt;new({
             servers =&gt; [
                   "10.0.0.15:11211",
                   [ "10.0.0.15:11212", 2 ], # weight
                   "/var/sock/memcached"
             ],
             compress_threshold =&gt; 10_000,
             # ... many more options supported
         });

         $memd-&gt;set("my_key", "Some value");
         $memd-&gt;set("object_key", { 'complex' =&gt; [ "object", 2, 4 ]});

         $val = $memd-&gt;get("my_key");
         $val = $memd-&gt;get("object_key");
         print $val-&gt;{complex}-&gt;[2] if $val;

         $memd-&gt;incr("key");
         $memd-&gt;decr("key");
         $memd-&gt;incr("key", 2);

         $memd-&gt;delete("key");
         $memd-&gt;remove("key"); # Alias to delete

         my $hashref = $memd-&gt;get_multi(@keys);

         # Import Memcached::libmemcached constants - explicitly by name or by tags
         # see Memcached::libmemcached::constants for a list
         use Cache::Memcached::libmemcached qw(MEMCACHED_DISTRIBUTION_CONSISTENT);
         use Cache::Memcached::libmemcached qw(
             :defines
             :memcached_allocated
             :memcached_behavior
             :memcached_callback
             :memcached_connection
             :memcached_hash
             :memcached_return
             :memcached_server_distribution
         );

         my $memd = Cache::Memcached::libmemcached-&gt;new({
             distribution_method =&gt; MEMCACHED_DISTRIBUTION_CONSISTENT,
             hashing_algorithm   =&gt; MEMCACHED_HASH_FNV1A_32,
             behavior_... =&gt; ...,
             ...
         });

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is the Cache::Memcached compatible interface to libmemcached, a C library to interface with
       memcached.

       Cache::Memcached::libmemcached is built on top of Memcached::libmemcached.  While Memcached::libmemcached
       aims to port libmemcached API to perl, Cache::Memcached::libmemcached attempts to be API compatible with
       Cache::Memcached, so it can be used as a drop-in replacement.

       Cache::Memcached::libmemcached <u>inherits</u> from Memcached::libmemcached.  While you are free to use the
       Memcached::libmemcached specific methods directly on the object, doing so will mean that your code is no
       longer compatible with the original Cache::Memcached API therefore losing some of the portability in case
       you want to replace it with some other package.

</pre><h4><b>Cache::Memcached</b> <b>COMPATIBLE</b> <b>METHODS</b></h4><pre>
       Except for the minor incompatibilities, below methods are compatible with Cache::Memcached.

   <b>new</b>
       Takes one parameter, a hashref of options.

       <u>Cache::Memcached</u> <u>options:</u>

       <u>servers</u>

       The value is passed to the "set_servers" method.

       <u>compress_threshold</u>

       Set a compression threshold, in bytes. Values larger than this threshold will be compressed by set and
       decompressed by get.

       <u>namespace</u>

       The value is passed to the "namespace" method.

       <u>debug</u>

       Sets the "trace_level" for the Memcached::libmemcached object.

       <u>readonly,</u> <u>no_rehash</u>

       These Cache::Memcached options are not supported.

       <u>Options</u> <u>specific</u> <u>to</u> <u>Cache::Memcached::libmemcached:</u>

       <u>compress_savings</u>

       <u>behavior_*</u>

       Any of the <u>many</u> behaviors documented in Memcached::libmemcached::memcached_behavior can be specified by
       using argument key names that start with "behavior_". For example:

           behavior_ketama_weighted =&gt; 1,
           behavior_noreply =&gt; 1,
           behavior_number_of_replicas =&gt; 2,
           behavior_server_failure_limit =&gt; 3,
           behavior_auto_eject_hosts =&gt; 1,

       <u>no_block</u>

       <u>hashing_algorithm</u>

       <u>distribution_method</u>

       <u>binary_protocol</u>

       These are equivalent to the same options prefixed with "behavior_".

   <b>set_servers</b>
         $memd-&gt;set_servers( [ 'serv1:port1', 'serv2:port2', ... ]);

       Calls "server_add" for each element of the supplied arrayref.  See "server_add" for details of valid
       values, including how to specify weights.

   <b>namespace</b>
         $memd-&gt;namespace;
         $memd-&gt;namespace($string);

       Without the argument return the current namespace prefix.  With the argument set the namespace prefix to
       <u>$string</u>, and return the old prefix.

       The effect is to pefix all keys with the provided namespace value. That is, if you set namespace to
       "app1:" and later do a set of "foo" to "bar", memcached is actually seeing you set "app1:foo" to "bar".

       The namespace string must be less than 128 bytes (MEMCACHED_PREFIX_KEY_MAX_SIZE).

   <b>get</b>
         my $val = $memd-&gt;get($key);

       Retrieves a key from the memcached. Returns the value (automatically thawed with Storable, if necessary)
       or undef.

       Currently the arrayref form of $key is NOT supported. Perhaps in the future.

   <b>get_multi</b>
         my $hashref = $memd-&gt;get_multi(@keys);

       Retrieves multiple keys from the memcache doing just one query.  Returns a hashref of key/value pairs
       that were available.

   <b>set</b>
         $memd-&gt;set($key, $value[, $expires]);

       Unconditionally sets a key to a given value in the memcache. Returns true if it was stored successfully.

       Currently the arrayref form of $key is NOT supported. Perhaps in the future.

   <b>add</b>
         $memd-&gt;add($key, $value[, $expires]);

       Like <b>set()</b>, but only stores in memcache if they key doesn't already exist.

   <b>replace</b>
         $memd-&gt;replace($key, $value[, $expires]);

       Like <b>set()</b>, but only stores in memcache if they key already exist.

   <b>append</b>
         $memd-&gt;append($key, $value);

       Appends $value to whatever value associated with $key. Only available for memcached &gt; 1.2.4

   <b>prepend</b>
         $memd-&gt;prepend($key, $value);

       Prepends $value to whatever value associated with $key. Only available for memcached &gt; 1.2.4

   <b>incr</b>
   <b>decr</b>
         my $newval = $memd-&gt;incr($key);
         my $newval = $memd-&gt;decr($key);

         my $newval = $memd-&gt;incr($key, $offset);
         my $newval = $memd-&gt;decr($key, $offset);

       Atomically increments or decrements the specified the integer value specified by $key. Returns undef if
       the key doesn't exist on the server.

   <b>delete</b>
   <b>remove</b>
         $memd-&gt;delete($key);
         $memd-&gt;delete($key, $time);

       Deletes a key.

       If $time is non-zero then the item is marked for later expiration. Expiration works by placing the item
       into a delete queue, which means that it won't possible to retrieve it by the "get" command, but "add"
       and "replace" command with this key will also fail (the "set" command will succeed, however). After the
       time passes, the item is finally deleted from server memory.

   <b>flush_all</b>
         $memd-&gt;fush_all;

       Runs the memcached "flush_all" command on all configured hosts, emptying all their caches.

   <b>set_compress_threshold</b>
         $memd-&gt;set_compress_threshold($threshold);

       Set the compress threshold.

   <b>enable_compress</b>
         $memd-&gt;enable_compress($bool);

       This is actually an alias to <b>set_compress_enable()</b>. The original version from Cache::Memcached is,
       despite its naming, a setter as well.

   <b>stats</b>
         my $h = $memd-&gt;stats();
         my $h = $memd-&gt;stats($keys);

       Returns a hashref of statistical data regarding the memcache server(s), the $memd object, or both. $keys
       can be an arrayref of keys wanted, a single key wanted, or absent (in which case the default value is "[
       '' ]"). For each key the "stats" command is run on each server.

       For example "&lt;$memd-"stats([ '', 'sizes' ])&gt;&gt; would return a structure like this:

           {
               hosts =&gt; {
                   'N.N.N.N:P' =&gt; {
                       misc =&gt; {
                           ...
                       },
                       sizes =&gt; {
                           ...
                       },
                   },
                   ...,
               },
               totals =&gt; {
                   ...
               }
           }

       The general stats (where the key is "") are returned with a key of "misc".  The "totals" element contains
       the aggregate totals for all hosts of some of the statistics.

   <b>disconnect_all</b>
       Disconnects from servers

   <b>cas</b>
         $memd-&gt;cas($key, $cas, $value[, $exptime]);

       Overwrites data in the server as long as the "cas" value is still the same in the server.

       You can get the cas value of a result by calling <b>memcached_result_cas()</b> on a <b><a href="../man3/memcached_result_st.3.html">memcached_result_st</a></b>(3)
       structure.

       Support for "cas" is disabled by default as there is a slight performance penalty. To enable it use the
       "support_cas" option to "new".

</pre><h4><b>Cache::Memcached::Fast</b> <b>COMPATIBLE</b> <b>METHODS</b></h4><pre>
   <b>server_versions</b>
           $href = $memd-&gt;server_versions;

       Returns a reference to hash, where $href-&gt;{$server} holds corresponding server version string, e.g.
       "1.4.4". $server is either host:port or /path/to/unix.sock.

</pre><h4><b>Cache::Memcached::libmemcached</b> <b>SPECIFIC</b> <b>METHODS</b></h4><pre>
       These methods are libmemcached-specific.

   <b>server_add</b>
           $self-&gt;server_add( $server_host_port );   # 10.10.10.10:11211
           $self-&gt;server_add( $server_socket_path ); # /path/to/socket
           $self-&gt;server_add( [ $server, $weight ] );
           $self-&gt;server_add( { address =&gt; $server, weight =&gt; $weight } );

       Adds a memcached server address with an optional weight (default 0).

</pre><h4><b>UTILITY</b> <b>METHODS</b></h4><pre>
       WARNING: Please do not consider the existence for these methods to be final.  They may be renamed or may
       entirely disappear from future releases.

   <b>get_compress_threshold</b>
       Return the current value of compress_threshold

   <b>set_compress_enable</b>
       Set the value of compress_enable

   <b>get_compress_enable</b>
       Return the current value of compress_enable

   <b>set_compress_savings</b>
       Set the value of compress_savings

   <b>get_compress_savings</b>
       Return the current value of compress_savings

</pre><h4><b>BEHAVIOR</b> <b>CUSTOMIZATION</b></h4><pre>
       Memcached::libmemcached supports <u>many</u> 'behaviors' that can be used to configure the behavior of the
       library and its interaction with the servers.

       Certain libmemcached behaviors can be configured with the following methods.

       (NOTE: This API is not fixed yet)

   <b>set_no_block</b>
         $memd-&gt;set_no_block( 1 );

       Set to use blocking/non-blocking I/O. When this is in effect, <b>get()</b> becomes flaky, so don't attempt to
       call it. This has the most effect for <b>set()</b> operations, because libmemcached stops waiting for server
       response after writing to the socket (<b>set()</b> will also always return success).

       Please consult the man page for "memcached_behavior_set()" for details before setting.

   <b>is_no_block</b>
       Get the current value of no_block behavior.

   <b>set_distribution_method</b>
         $memd-&gt;set_distribution_method( MEMCACHED_DISTRIBUTION_CONSISTENT );

       Set the distribution behavior.

   <b>get_distribution_method</b>
       Get the distribution behavior.

   <b>set_hashing_algorithm</b>
         $memd-&gt;set_hashing_algorithm( MEMCACHED_HASH_KETAMA );

       Set the hashing algorithm used.

   <b>get_hashing_algorithm</b>
       Get the hashing algorithm used.

   <b>set_binary_protocol</b>
   <b>is_binary_protocol</b>
         $memd-&gt;set_binary_protocol( 1 );
         $binary = $memd-&gt;is_binary_protocol();

       Use "set_binary_protocol" to enable/disable binary protocol.  Use "is_binary_protocol" to determine the
       current setting.

</pre><h4><b>OPTIMIZE</b> <b>FLAG</b></h4><pre>
       If you are 100% sure that you won't be using the master key support (where you provide an arrayref as the
       key) you can get about 4~5% performance boost by setting the environment variable named
       PERL_LIBMEMCACHED_OPTIMIZE to a true value <u>before</u> loading the module.

       This is an EXPERIMENTAL optimization and will possibly be replaced by implementing the methods in C in
       Memcached::libmemcached.

</pre><h4><b>VARIOUS</b> <b>MEMCACHED</b> <b>MODULES</b></h4><pre>
       Below are the various memcached modules available on CPAN.

       Please check tool/benchmark.pl for a live comparison of these modules.  (except for Cache::Memcached::XS,
       which I wasn't able to compile under my main dev environment)

   <b>Cache::Memcached</b>
       This is the "original" module. It's mostly written in Perl, is slow, and lacks significant features like
       support for the binary protocol.

   <b>Cache::Memcached::libmemcached</b>
       Cache::Memcached::libmemcached, this module, is a perl binding for libmemcached
       (<a href="http://tangent.org/552/libmemcached.html">http://tangent.org/552/libmemcached.html</a>).  Not to be confused with libmemcache (see below).

   <b>Cache::Memcached::Fast</b>
       Cache::Memcached::Fast is a memcached client written in XS from scratch.  As of this writing benchmarks
       shows that Cache::Memcached::Fast is faster on <b>get_multi()</b>, and Cache::Memcached::libmemcached is faster
       on regular <b>get()</b>/<b>set()</b>.  Cache::Memcached::Fast doesn't support the binary protocol.

   <b>Memcached::libmemcached</b>
       Memcached::libmemcached is a thin binding to the libmemcached C library and provides access to most of
       the libmemcached API.

       If you don't care about a drop-in replacement for Cache::Memcached, and want to benefit from the feature-
       rich efficient API that libmemcached offers, this is the way to go.

       Since the Memcached::libmemcached module is also the parent class of this module you can call
       Memcached::libmemcached methods directly.

   <b>Cache::Memcached::XS</b>
       Cache::Memcached::XS is a binding for libmemcache (<a href="http://people.freebsd.org/~seanc/libmemcache/">http://people.freebsd.org/~seanc/libmemcache/</a>).  The
       main memcached site at <a href="http://danga.com/memcached/apis.bml">http://danga.com/memcached/apis.bml</a> seems to indicate that the underlying
       libmemcache is no longer in active development.  The module hasn't been updated since 2006.

</pre><h4><b>TODO</b></h4><pre>
       Check and improve compatibility with Cache::Memcached::Fast.

       Add <b>forget_dead_hosts()</b> for greater Cache::Memcached compatibility?

       Treat PERL_LIBMEMCACHED_OPTIMIZE as the default and add a subclass that handles the arrayref master key
       concept. Then the custom methods (get set add replace prepend append cas delete) can then all be removed
       and the libmemcached ones used directly.  Alternatively, add master key via array ref support to the
       methods in ::libmemcached. Either way the effect on performance should be significant.

       Redo tools/benchmarks.pl performance tests (ensuring that methods are not called in void context unless
       it's appropriate).

       Try using Cache::Memcached::Fast's test suite to test this module.  Via private
       lib/Cache/Memcached/libmemcachedAsFast.pm wrapper.

       Implement automatic no-reply on calls in void context (like Cache::Memcached::Fast).  That should yield a
       signigicant performance boost.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (c) 2008 Daisuke Maki &lt;<a href="mailto:daisuke@endeworks.jp">daisuke@endeworks.jp</a>&gt;

       With contributions by Tim Bunce.

</pre><h4><b>LICENSE</b></h4><pre>
       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       See <a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>

perl v5.36.0                                       2022-12-04                <u>Cache::Memcached::<a href="../man3pm/libmemcached.3pm.html">libmemcached</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>