<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDL::Audio - SDL Bindings for Audio</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsdl-perl">libsdl-perl_2.548-5build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SDL::Audio - SDL Bindings for Audio

</pre><h4><b>CATEGORY</b></h4><pre>
       Core, Audio

</pre><h4><b>CONSTANTS</b></h4><pre>
       The constants are exported by default. You can avoid this by doing:

        use SDL::Audio ();

       and access them directly:

        SDL::Audio::AUDIO_S16SYS;

       or by choosing the export tags below:

       Export tag: ':format'

        AUDIO_U8
        AUDIO_S8
        AUDIO_U16LSB
        AUDIO_S16LSB
        AUDIO_U16MSB
        AUDIO_S16MSB
        AUDIO_U16
        AUDIO_S16
        AUDIO_U16SYS
        AUDIO_S16SYS

       Export tag: ':status'

        SDL_AUDIO_STOPPED
        SDL_AUDIO_PLAYING
        SDL_AUDIO_PAUSED

</pre><h4><b>METHODS</b></h4><pre>
   <b>open</b>
         use SDL;
         use SDL::Audio;

         SDL::init(SDL_INIT_AUDIO);

         my $desired = SDL::AudioSpec-&gt;new();

         my $obtained;

         SDL::Audio::open( $desired, $obtained );

         # $obtained-&gt;... (A new SDL::AudioSpec now);

       This function opens the audio device with the desired parameters, and returns 0 if successful, placing
       the actual hardware parameters in the structure pointed to by obtained. If obtained is NULL, the audio
       data passed to the callback function will be guaranteed to be in the requested format, and will be
       automatically converted to the hardware audio format if necessary. This function returns -1 if it failed
       to open the audio device, or couldn't set up the audio thread.

       To open the audio device a desired SDL::AudioSpec must be created.

         my $desired = SDL::AudioSpec-&gt;new();

       You must then fill this structure with your desired audio specifications.

       The desired audio frequency in samples-per-second.
               $desired-&gt;freq

       The desired audio format. See SDL::AudioSpec
               $desired-&gt;format

       The desired channels (1 for mono, 2 for stereo, 4 for surround, 6 for surround with center and lfe).
               $desired-&gt;channels

       The desired size of the audio buffer in samples. This number should be a power of two, and may be
       adjusted by the audio driver to a value more suitable for the hardware. Good values seem to range between
       512 and 8192 inclusive, depending on the application and CPU speed. Smaller values yield faster response
       time, but can lead to underflow if the application is doing heavy processing and cannot fill the audio
       buffer in time. A stereo sample consists of both right and left channels in LR ordering. Note that the
       number of samples is directly related to time by the following formula: ms = (samples*1000)/freq
               $desired-&gt;samples

       This should be set to a function that will be called when the audio device is ready for more data. It is
       passed a pointer to the audio buffer, and the length in bytes of the audio buffer. This function usually
       runs in a separate thread, and so you should protect data structures that it accesses by calling
       SDL::Audio::lock and SDL::Audio::unlock in your code.
           THIS IS NOT READY YET

               $desired-&gt;callback

               my $callback = sub{ my ($userdata, $stream, $len) = @_;  };

               $userdata is a reference stored in the userdata field of the SDL::AudioSpec.
               $stream is a pointer to the audio buffer you want to fill with information and $len is the length of the audio buffer in bytes.

               $desired-&gt;userdata

               This pointer is passed as the first parameter to the callback function.

       SDL::Audio::open  reads these fields from the desired SDL::AudioSpec structure passed to the function and
       attempts to find an audio configuration matching your  desired.  As  mentioned  above,  if  the  obtained
       parameter  is  NULL then SDL with convert from your desired audio settings to the hardware settings as it
       plays.

       If obtained is NULL then the desired SDL::AudioSpec is your working specification, otherwise the obtained
       SDL::AudioSpec becomes the working specification and the desired specification can be deleted.  The  data
       in  the  working  specification  is  used when building SDL::AudioCVT's for converting loaded data to the
       hardware format.

       SDL::Audio::open  calculates  the  size  and  silence  fields  for  both  the  $desired   and   $obtained
       specifications.  The  size  field  stores  the total size of the audio buffer in bytes, while the silence
       stores the value used to represent silence in the audio buffer

       The audio device starts out playing silence when it's opened,  and  should  be  enabled  for  playing  by
       calling  <b>SDL::Audio::<a href="../man0/pause.0.html">pause</a></b>(0) when you are ready for your audio callback function to be called. Since the
       audio driver may modify the requested size of the audio buffer, you  should  allocate  any  local  mixing
       buffers after you open the audio device.

   <b>pause</b>
        pause( $bool )

       This  function  pauses  and  unpauses the audio callback processing. It should be called with "$bool = 0"
       after opening the audio device to start playing sound. This is so you can safely initialize data for your
       callback function after opening the audio device. Silence will be written to the audio device during  the
       pause.

   <b>get_status</b>
        int get_status();

       Returns  either  "SDL_AUDIO_STOPPED",  "SDL_AUDIO_PLAYING" or "SDL_AUDIO_PAUSED" depending on the current
       audio state.

   <b>load_wav</b>
        SDL::AudioSpec load_wav( $filename, $spec );

       This function loads a WAVE file into memory.

       If this function succeeds, it returns the given "SDL::AudioSpec", filled with the audio  data  format  of
       the wave data, and sets "buf" to a buffer containing the audio data, and sets "len" to the length of that
       audio  buffer,  in bytes. You need to free the audio buffer with "SDL::Audio::free_wav" when you are done
       with it.

       This function returns NULL and sets the SDL error message if the wave file  cannot  be  opened,  uses  an
       unknown data format, or is corrupt.  Currently raw, MS-ADPCM and IMA-ADPCM WAVE files are supported.

       Example:

        use SDL;
        use SDL::Audio;
        use SDL::AudioSpec;

        SDL::init(SDL_INIT_AUDIO);

        # Converting some WAV data to hardware format

        my $desired  = SDL::AudioSpec-&gt;new();
        my $obtained = SDL::AudioSpec-&gt;new();

        # Set desired format
        $desired-&gt;<a href="../man22050/freq.22050.html">freq</a>(22050);
        $desired-&gt;<a href="../man1/channels.1.html">channels</a>(1);
        $desired-&gt;format(AUDIO_S16);
        $desired-&gt;<a href="../man8192/samples.8192.html">samples</a>(8192);

        # Open the audio device
        if( SDL::Audio::open($desired, $obtained) &lt; 0 )
        {
            printf( STDERR "Couldn't open audio: %s\n", SDL::get_error() );
            exit(-1);
        }

        # Load the test.wav
        my $wav_ref = SDL::Audio::load_wav('../../test/data/sample.wav', $obtained);

        unless( $wav_ref )
        {
            warn( "Could not open sample.wav: %s\n", SDL::get_error() );
            SDL::Audio::close_audio();
            SDL::quit;
            exit(-1);
        }

        my ( $wav_spec, $wav_buf, $wav_len ) = @{$wav_ref};

   <b>free_wav</b>
        free_wav( $buffer )

       After  a  WAVE  file  has  been  opened with "load_wav" its data can eventually be freed with "free_wav".
       "buffer" is the buffer created by "load_wav".

   <b>convert</b>
        SDL::Audio-&gt;convert( cvt, data, len )

       Converts audio data to a desired audio format.

       "convert"  takes  as  first  parameter  "cvt",  which  was   previously   initialized.   Initializing   a
       "SDL::AudioCVT"   is   a   two   step  process.   First  of  all,  the  structure  must  be  created  via
       "SDL::AudioCVT-&gt;build" along with source and destination format  parameters.  Secondly,  the  "data"  and
       "len"  fields must be setup. "data" should point to the audio data buffer being source and destination at
       once and "len" should be set to the buffer length in bytes. Remember, the length of the buffer pointed to
       by buf should be "len*len_mult" bytes in length.

       Once the "SDL::AudioCVT" structure is initialized, we can pass it to "convert", which  will  convert  the
       audio  data  pointed  to  by  "data".  If  "convert"  fails  "undef" is returned, otherwise the converted
       "SDL::AudioCVT" structure.

       If the conversion completed successfully then the converted audio data can be read from  "cvt-&gt;buf".  The
       amount of valid, converted, audio data in the buffer is equal to "cvt-&gt;len*cvt-&gt;len_ratio".

       Example:

        use SDL;
        use SDL::Audio;
        use SDL::AudioSpec;
        use SDL::AudioCVT;

        SDL::init(SDL_INIT_AUDIO);

        # Converting some WAV data to hardware format

        my $desired  = SDL::AudioSpec-&gt;new();
        my $obtained = SDL::AudioSpec-&gt;new();

        # Set desired format
        $desired-&gt;<a href="../man22050/freq.22050.html">freq</a>(22050);
        $desired-&gt;<a href="../man1/channels.1.html">channels</a>(1);
        $desired-&gt;format(AUDIO_S16);
        $desired-&gt;<a href="../man8192/samples.8192.html">samples</a>(8192);

        # Open the audio device
        if( SDL::Audio::open($desired, $obtained) &lt; 0 )
        {
            printf( STDERR "Couldn't open audio: %s\n", SDL::get_error() );
            exit(-1);
        }

        # Load the test.wav
        my $wav_ref = SDL::Audio::load_wav('../../test/data/sample.wav', $obtained);

        unless( $wav_ref )
        {
            warn( "Could not open sample.wav: %s\n", SDL::get_error() );
            SDL::Audio::close_audio();
            SDL::quit;
            exit(-1);
        }

        my ( $wav_spec, $wav_buf, $wav_len ) = @{$wav_ref};

        # Build AudioCVT
        my $wav_cvt = SDL::AudioCVT-&gt;build( $wav_spec-&gt;format, $wav_spec-&gt;channels, $wav_spec-&gt;freq,
                                            $obtained-&gt;format, $obtained-&gt;channels, $obtained-&gt;freq);

        # Check that the convert was built
        if( $wav_cvt == -1 )
        {
            warn( "Couldn't build converter!\n" );
            SDL::Audio::close();
            SDL::Audio::free_wav($wav_buf);
            SDL::quit();
            exit(-1);
        }

        # And now we're ready to convert
        SDL::Audio::convert($wav_cvt, $wav_buf, $wav_len);

        # We can free original WAV data now
        SDL::Audio::free_wav($wav_buf);

       <b>TODO</b>: What to do with it? How to use callback? See <a href="http://www.libsdl.org/cgi/docwiki.cgi/SDL_ConvertAudio">http://www.libsdl.org/cgi/docwiki.cgi/SDL_ConvertAudio</a>

   <b>mix</b>
       Mixes audio data

       <b>Not</b> <b>implemented</b> <b>yet</b>. See: &lt;<a href="http://www.libsdl.org/cgi/docwiki.cgi/SDL_MixAudio">http://www.libsdl.org/cgi/docwiki.cgi/SDL_MixAudio</a>&gt;

   <b>lock</b>
        lock();

       The  lock  manipulated by these functions protects the callback function. During a "lock" period, you can
       be guaranteed that the callback function is not running. Do not call this from the callback  function  or
       you will cause deadlock.

   <b>unlock</b>
        unlock();

       Unlocks a previous "lock" call.

   <b>close</b>
        close();

       Shuts down audio processing and closes the audio device.

</pre><h4><b>AUTHORS</b></h4><pre>
       See "AUTHORS" in SDL.

perl v5.40.0                                       2024-10-20                              <u>pods::SDL::<a href="../man3pm/Audio.3pm.html">Audio</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>