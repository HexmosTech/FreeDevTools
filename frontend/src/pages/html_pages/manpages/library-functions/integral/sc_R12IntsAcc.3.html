<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sc::R12IntsAcc - R12IntsAcc accumulates transformed (MO) integrals stored as (ijxy) where i, j, x, and, y</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libsc-doc">libsc-doc_2.3.1-21_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sc::R12IntsAcc - <b>R12IntsAcc</b> accumulates transformed (MO) integrals stored as (ijxy) where i, j, x, and, y
       lie in spaces I, J, <b>X</b>, and <b>Y</b>, respectively.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;r12ia.h&gt;

       Inherits <b>sc::SavableState</b>.

       Inherited by <b>sc::R12IntsAcc_MemoryGrp</b>, <b>sc::R12IntsAcc_MPIIOFile</b>, and <b>sc::R12IntsAcc_Node0File</b>.

   <b>Public</b> <b>Types</b>
       enum <b>tbint_type</b> { <b>eri</b> =0, <b>r12</b> =1, <b>r12t1</b> =2, <b>r12t2</b> =3 }
           Types of two-body operators that <b>R12IntsAcc</b> understands.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>R12IntsAcc</b> (int <b>num_te_types</b>, int <b>ni</b>, int <b>nj</b>, int <b>nx</b>, int <b>ny</b>)
       <b>R12IntsAcc</b> (<b>StateIn</b> &amp;)
       void <b>save_data_state</b> (<b>StateOut</b> &amp;)
           Save the base classes (with save_data_state) and the members in the same order that the <b>StateIn</b> CTOR
           initializes them.
       int <b>num_te_types</b> () const
           The number of types of integrals that are being handled together.
       int <b>ni</b> () const
           Rank of index space i.
       int <b>nj</b> () const
           Rank of index space j.
       int <b>nx</b> () const
           Rank of index space x.
       int <b>ny</b> () const
           Rank of index space y.
       size_t <b>blocksize</b> () const
           Size of each block of the integrals of one type, in double words.
       int <b>next_orbital</b> () const
           The index of the first orbital in the next integrals batch to be stored.
       virtual void <b>store_memorygrp</b> (<b>Ref</b>&lt; <b>MemoryGrp</b> &gt; &amp;mem, int <b>ni</b>, const size_t blksize=0)=0
           Stores all pair block of integrals held in mem in a layout assumed throughout <b>MBPT2_R12</b>.
       virtual void <b>store_pair_block</b> (int i, int j, double *ints)=0
           All member functions of this class and its children indices i and j don't include frozen orbitals
           Stores an ij pair block of integrals (assumes the block resides locally)
       virtual void <b>commit</b> ()
           Commit the content of the accumulator for reading.
       bool <b>is_committed</b> ()
           Has the content of the accumulator been commited for reading?
       virtual void <b>activate</b> ()
           Call before starting to read content.
       virtual void <b>deactivate</b> ()
           Call when done reading content.
       const bool <b>is_active</b> ()
           Check if can read content.
       virtual double * <b>retrieve_pair_block</b> (int i, int j, <b>tbint_type</b> oper_type)=0
           Retrieves an ij pair block of integrals.
       virtual void <b>release_pair_block</b> (int i, int j, <b>tbint_type</b> oper_type)=0
           Releases an ij pair block of integrals (if needed)
       virtual bool <b>is_local</b> (int i, int j) const =0
           Is this block stored locally?
       virtual bool <b>is_avail</b> (int i, int j) const =0
           Is this block available to this task?
       virtual bool <b>has_access</b> (int proc) const =0
           Does this task have access to all the integrals?
       int <b>tasks_with_access</b> (vector&lt; int &gt; &amp;twa_map) const
           Returns the total number of tasks with access to integrals.
       virtual bool <b>can_restart</b> () const =0
           Can this specialization be used in restarts?

   <b>Static</b> <b>Public</b> <b>Attributes</b>
       static const int <b>max_num_te_types_</b> = 4

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       virtual int <b>ntasks</b> () const =0
           total number of tasks
       virtual int <b>taskid</b> () const =0
           ID of this task.
       void <b>inc_next_orbital</b> (int <b>ni</b>)
           The index of the first orbital in the next integrals batch to be stored.

   <b>Protected</b> <b>Attributes</b>
       int <b>ni_</b>
       int <b>nj_</b>
       int <b>nx_</b>
       int <b>ny_</b>
       size_t <b>nxy_</b>
       size_t <b>blksize_</b>
       size_t <b>blocksize_</b>
       int <b>next_orbital_</b>
       bool <b>committed_</b>
       bool <b>active_</b>

   <b>Additional</b> <b>Inherited</b> <b>Members</b>
</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       <b>R12IntsAcc</b> accumulates transformed (MO) integrals stored as (ijxy) where i, j, x, and, y lie in spaces I,
       J, <b>X</b>, and <b>Y</b>, respectively.

       ijxy is only the storage format, the actual type may be (ix|jy), (ij|xy), etc.

       Transformed integrals are usually computed using a parallel MO integrals transformation procedure. In
       general, such transformations will require multiple passes through AO integrals. Each pass produces a
       batch of transformed integrals. For example, a batch in direct parallel MP2 energy algorithm is a set of
       integrals {(ix|jy)} in which i indices are in a finite subrange of O and x, j, and y take any of their
       allowed values. For example, if batch I contains all integrals (ix|jy) with i greater than or equal m but
       less than n, then batch I+1 contains integrals (ix|jy) with i greater than n. Integrals in batch 0 have
       indices i greater than or equal to 0.

       After each pass the MO integrals are contained in a <b>MemoryGrp</b> object. The object is 'stored' in
       accumulator using store_memorygrp(Ref&lt;MemoryGrp&gt;&amp; mem, int ni). After all batches have been stored, the
       content of <b>R12IntsAcc</b> needs to be 'committed' using <b>commit().</b> <b>After</b> <b>that</b> <b>blocks</b> <b>of</b> <b>MO</b> <b>integrals</b> <b>can</b> <b>be</b>
       <b>accessed</b> <b>using</b> <b>retrieve_pair_block.</b>

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>sc::R12IntsAcc::save_data_state</b> <b>(StateOut</b> <b>&amp;)</b> <b>[virtual]</b>
       Save the base classes (with save_data_state) and the members in the same order that the <b>StateIn</b> CTOR
       initializes them. This must be implemented by the derived class if the class has data.

       Reimplemented from <b>sc::SavableState</b>.

       Reimplemented in <b>sc::R12IntsAcc_MPIIOFile_Ind</b>, <b>sc::R12IntsAcc_MPIIOFile</b>, <b>sc::R12IntsAcc_Node0File</b>, and
       <b>sc::R12IntsAcc_MemoryGrp</b>.

   <b>virtual</b> <b>void</b> <b>sc::R12IntsAcc::store_memorygrp</b> <b>(Ref&lt;</b> <b>MemoryGrp</b> <b>&gt;</b> <b>&amp;</b> <b>mem,</b> <b>int</b> <b>ni,</b> <b>const</b> <b>size_t</b> <b>blksize</b> <b>=</b> <b>0)</b> <b>[pure</b>
       <b>virtual]</b>
       Stores all pair block of integrals held in mem in a layout assumed throughout <b>MBPT2_R12</b>. Let's suppose
       the number of tasks is nproc, nj is the number of j indices, ni is the number of i indices of integrals
       held in mem at the moment. Then all integrals with a given i and j are stored on task (i*nj+j)/nproc and
       this ij block is (i*nj+j)nproc -th block on this task. Each ij block contains num_te_types_ subblocks of
       integrals. Each subblock of integrals has blksize bytes allocated for it. Note that blksize may be larger
       than blksize_ because an ij-block of partially transformed integrals may be larger than the block of
       fully transformed integrals.

       Implemented in <b>sc::R12IntsAcc_MPIIOFile_Ind</b>, <b>sc::R12IntsAcc_Node0File</b>, and <b>sc::R12IntsAcc_MemoryGrp</b>.

   <b>int</b> <b>sc::R12IntsAcc::tasks_with_access</b> <b>(vector&lt;</b> <b>int</b> <b>&gt;</b> <b>&amp;</b> <b>twa_map)</b> <b>const</b>
       Returns the total number of tasks with access to integrals. If task i has access to the integrals, then
       twa_map[i] is its index among the tasks with access, -1 otherwise.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for MPQC from the source code.

Version 2.3.1                                    Sun Oct 4 2020                                <u>sc::<a href="../man3/R12IntsAcc.3.html">R12IntsAcc</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>