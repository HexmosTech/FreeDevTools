<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sc::Integral - The Integral abstract class acts as a factory to provide objects that compute one and two</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libsc-doc">libsc-doc_2.3.1-21_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sc::Integral - The <b>Integral</b> abstract class acts as a factory to provide objects that compute one and two
       electron integrals.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;integral.h&gt;

       Inherits <b>sc::SavableState</b>.

       Inherited by <b>sc::IntegralCCA</b>, <b>sc::IntegralCints</b>, and <b>sc::IntegralV3</b>.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>Integral</b> (<b>StateIn</b> &amp;)
           Restore the <b>Integral</b> object from the given <b>StateIn</b> object.
       <b>Integral</b> (const <b>Ref</b>&lt; <b>KeyVal</b> &gt; &amp;)
           Construct the <b>Integral</b> object from the given <b>KeyVal</b> object.
       void <b>save_data_state</b> (<b>StateOut</b> &amp;)
           Save the base classes (with save_data_state) and the members in the same order that the <b>StateIn</b> CTOR
           initializes them.
       virtual <b>Integral</b> * <b>clone</b> ()=0
           Clones the given <b>Integral</b> factory. The new factory may need to have set_basis and set_storage to be
           called on it.
       virtual int <b>equiv</b> (const <b>Ref</b>&lt; <b>Integral</b> &gt; &amp;)
           Returns nonzero if this and the given <b>Integral</b> object have the same integral ordering, normalization
           conventions, etc.
       void <b>set_storage</b> (size_t i)
           Sets the total amount of storage, in bytes, that is available.
       size_t <b>storage_used</b> ()
           Returns how much storage has been used.
       size_t <b>storage_unused</b> ()
           Returns how much storage was not needed.
       virtual size_t <b>storage_required_eri</b> (const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b1, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt;
           &amp;b2=0, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b3=0, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b4=0)
           Returns how much storage will be needed to initialize a two-body integrals evaluator for electron
           repulsion integrals.
       virtual size_t <b>storage_required_grt</b> (const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b1, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt;
           &amp;b2=0, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b3=0, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b4=0)
           Returns how much storage will be needed to initialize a two-body integrals evaluator for linear R12
           integrals.
       virtual size_t <b>storage_required_eri_deriv</b> (const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b1, const <b>Ref</b>&lt; <b>GaussianBasisSet</b>
           &gt; &amp;b2=0, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b3=0, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b4=0)
           Returns how much storage will be needed to initialize a two-body integrals evaluator for derivative
           electron repulsion integrals.
       void <b>adjust_storage</b> (ptrdiff_t s)
           The specific integral classes use this to tell <b>Integral</b> how much memory they are using/freeing.
       <b>Ref</b>&lt; <b>PetiteList</b> &gt; <b>petite_list</b> ()
           Return the <b>PetiteList</b> object.
       <b>Ref</b>&lt; <b>PetiteList</b> &gt; <b>petite_list</b> (const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;)
           Return the <b>PetiteList</b> object for the given basis set.
       <b>ShellRotation</b> <b>shell_rotation</b> (int am, <b>SymmetryOperation</b> &amp;, int pure=0)
           Return the <b>ShellRotation</b> object for a shell of the given angular momentum.
       virtual void <b>set_basis</b> (const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b1, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b2=0, const
           <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b3=0, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b4=0)
           Set the basis set for each center.
       virtual <b>CartesianIter</b> * <b>new_cartesian_iter</b> (int)=0
           Return a <b>CartesianIter</b> object.
       virtual <b>RedundantCartesianIter</b> * <b>new_redundant_cartesian_iter</b> (int)=0
           Return a <b>RedundantCartesianIter</b> object.
       virtual <b>RedundantCartesianSubIter</b> * <b>new_redundant_cartesian_sub_iter</b> (int)=0
           Return a <b>RedundantCartesianSubIter</b> object.
       virtual <b>SphericalTransformIter</b> * <b>new_spherical_transform_iter</b> (int l, int inv=0, int subl=-1)=0
           Return a <b>SphericalTransformIter</b> object.
       virtual const <b>SphericalTransform</b> * <b>spherical_transform</b> (int l, int inv=0, int subl=-1)=0
           Return a <b>SphericalTransform</b> object.
       virtual <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>overlap</b> ()=0
           Return a <b>OneBodyInt</b> that computes the overlap.
       virtual <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>kinetic</b> ()=0
           Return a <b>OneBodyInt</b> that computes the kinetic energy.
       virtual <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>point_charge</b> (const <b>Ref</b>&lt; <b>PointChargeData</b> &gt; &amp;)=0
           Return a <b>OneBodyInt</b> that computes the integrals for interactions with point charges.
       virtual <b>Ref</b>&lt; <b>OneBodyOneCenterInt</b> &gt; <b>point_charge1</b> (const <b>Ref</b>&lt; <b>PointChargeData</b> &gt; &amp;)
           Return a <b>OneBodyInt</b> that computes the integrals for interactions with point charges.
       virtual <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>nuclear</b> ()=0
           Return a <b>OneBodyInt</b> that computes the nuclear repulsion integrals.
       virtual <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>hcore</b> ()=0
           Return a <b>OneBodyInt</b> that computes the core Hamiltonian integrals.
       virtual <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>efield_dot_vector</b> (const <b>Ref</b>&lt; <b>EfieldDotVectorData</b> &gt; &amp;)=0
           Return a <b>OneBodyInt</b> that computes the electric field integrals dotted with a given vector.
       virtual <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>dipole</b> (const <b>Ref</b>&lt; <b>DipoleData</b> &gt; &amp;)=0
           Return a <b>OneBodyInt</b> that computes electric dipole moment integrals.
       virtual <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>quadrupole</b> (const <b>Ref</b>&lt; <b>DipoleData</b> &gt; &amp;)=0
           Return a <b>OneBodyInt</b> that computes electric quadrupole moment integrals.
       virtual <b>Ref</b>&lt; <b>OneBodyDerivInt</b> &gt; <b>overlap_deriv</b> ()=0
           Return a <b>OneBodyDerivInt</b> that computes overlap derivatives.
       virtual <b>Ref</b>&lt; <b>OneBodyDerivInt</b> &gt; <b>kinetic_deriv</b> ()=0
           Return a <b>OneBodyDerivInt</b> that computes kinetic energy derivatives.
       virtual <b>Ref</b>&lt; <b>OneBodyDerivInt</b> &gt; <b>nuclear_deriv</b> ()=0
           Return a <b>OneBodyDerivInt</b> that computes nuclear repulsion derivatives.
       virtual <b>Ref</b>&lt; <b>OneBodyDerivInt</b> &gt; <b>hcore_deriv</b> ()=0
           Return a <b>OneBodyDerivInt</b> that computes core Hamiltonian derivatives.
       virtual <b>Ref</b>&lt; <b>TwoBodyThreeCenterInt</b> &gt; <b>electron_repulsion3</b> ()
           Return a <b>TwoBodyThreeCenterInt</b> that computes electron repulsion integrals.
       virtual <b>Ref</b>&lt; <b>TwoBodyThreeCenterDerivInt</b> &gt; <b>electron_repulsion3_deriv</b> ()
           Return a <b>TwoBodyThreeCenterInt</b> that computes electron repulsion integrals.
       virtual <b>Ref</b>&lt; <b>TwoBodyTwoCenterInt</b> &gt; <b>electron_repulsion2</b> ()
           Return a <b>TwoBodyTwoCenterInt</b> that computes electron repulsion integrals.
       virtual <b>Ref</b>&lt; <b>TwoBodyTwoCenterDerivInt</b> &gt; <b>electron_repulsion2_deriv</b> ()
           Return a <b>TwoBodyTwoCenterInt</b> that computes electron repulsion integrals.
       virtual <b>Ref</b>&lt; <b>TwoBodyInt</b> &gt; <b>electron_repulsion</b> ()=0
           Return a <b>TwoBodyInt</b> that computes electron repulsion integrals.
       virtual <b>Ref</b>&lt; <b>TwoBodyDerivInt</b> &gt; <b>electron_repulsion_deriv</b> ()=0
           Return a <b>TwoBodyDerivInt</b> that computes electron repulsion derivatives.
       virtual <b>Ref</b>&lt; <b>TwoBodyInt</b> &gt; <b>grt</b> ()
           Return a <b>TwoBodyInt</b> that computes two-electron integrals specific to linear R12 methods.
       <b>Ref</b>&lt; <b>MessageGrp</b> &gt; <b>messagegrp</b> ()
           Return the <b>MessageGrp</b> used by the integrals objects.

   <b>Static</b> <b>Public</b> <b>Member</b> <b>Functions</b>
       static <b>Integral</b> * <b>initial_integral</b> (int &amp;argc, char **argv)
           Create an integral factory.
       static void <b>set_default_integral</b> (const <b>Ref</b>&lt; <b>Integral</b> &gt; &amp;)
           Specifies a new default <b>Integral</b> factory.
       static <b>Integral</b> * <b>get_default_integral</b> ()
           Returns the default <b>Integral</b> factory.

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       <b>Integral</b> (const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b1, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b2, const <b>Ref</b>&lt;
           <b>GaussianBasisSet</b> &gt; &amp;b3, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b4)
           Initialize the <b>Integral</b> object given a <b>GaussianBasisSet</b> for each center.

   <b>Protected</b> <b>Attributes</b>
       <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; <b>bs1_</b>
       <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; <b>bs2_</b>
       <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; <b>bs3_</b>
       <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; <b>bs4_</b>
       size_t <b>storage_</b>
       size_t <b>storage_used_</b>
       <b>Ref</b>&lt; <b>MessageGrp</b> &gt; <b>grp_</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       The <b>Integral</b> abstract class acts as a factory to provide objects that compute one and two electron
       integrals.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>virtual</b> <b>Ref&lt;OneBodyInt&gt;</b> <b>sc::Integral::dipole</b> <b>(const</b> <b>Ref&lt;</b> <b>DipoleData</b> <b>&gt;</b> <b>&amp;)</b> <b>[pure</b> <b>virtual]</b>
       Return a <b>OneBodyInt</b> that computes electric dipole moment integrals. The canonical order of integrals in a
       set is x, y, z.

       Implemented in <b>sc::IntegralCCA</b>, <b>sc::IntegralCints</b>, and <b>sc::IntegralV3</b>.

   <b>virtual</b> <b>Ref&lt;TwoBodyTwoCenterInt&gt;</b> <b>sc::Integral::electron_repulsion2</b> <b>()</b> <b>[virtual]</b>
       Return a <b>TwoBodyTwoCenterInt</b> that computes electron repulsion integrals. If this is not re-implemented it
       will throw.

       Reimplemented in <b>sc::IntegralV3</b>.

   <b>virtual</b> <b>Ref&lt;TwoBodyTwoCenterDerivInt&gt;</b> <b>sc::Integral::electron_repulsion2_deriv</b> <b>()</b> <b>[virtual]</b>
       Return a <b>TwoBodyTwoCenterInt</b> that computes electron repulsion integrals. If this is not re-implemented it
       will throw.

   <b>virtual</b> <b>Ref&lt;TwoBodyThreeCenterInt&gt;</b> <b>sc::Integral::electron_repulsion3</b> <b>()</b> <b>[virtual]</b>
       Return a <b>TwoBodyThreeCenterInt</b> that computes electron repulsion integrals. If this is not re-implemented
       it will throw.

       Reimplemented in <b>sc::IntegralV3</b>.

   <b>virtual</b> <b>Ref&lt;TwoBodyThreeCenterDerivInt&gt;</b> <b>sc::Integral::electron_repulsion3_deriv</b> <b>()</b> <b>[virtual]</b>
       Return a <b>TwoBodyThreeCenterInt</b> that computes electron repulsion integrals. If this is not re-implemented
       it will throw.

   <b>virtual</b> <b>int</b> <b>sc::Integral::equiv</b> <b>(const</b> <b>Ref&lt;</b> <b>Integral</b> <b>&gt;</b> <b>&amp;)</b> <b>[virtual]</b>
       Returns nonzero if this and the given <b>Integral</b> object have the same integral ordering, normalization
       conventions, etc.

   <b>virtual</b> <b>Ref&lt;TwoBodyInt&gt;</b> <b>sc::Integral::grt</b> <b>()</b> <b>[virtual]</b>
       Return a <b>TwoBodyInt</b> that computes two-electron integrals specific to linear R12 methods. According to the
       convention in the literature, 'g' stands for electron repulsion integral, 'r' for the integral of r12
       operator, and 't' for the commutator integrals. Implementation for this kind of <b>TwoBodyInt</b> is optional.

       Reimplemented in <b>sc::IntegralCints</b>.

   <b>static</b> <b>Integral*</b> <b>sc::Integral::initial_integral</b> <b>(int</b> <b>&amp;</b> <b>argc,</b> <b>char</b> <b>**</b> <b>argv)</b> <b>[static]</b>
       Create an integral factory. This routine looks for a -integral argument, then the environmental variable
       INTEGRAL. The argument to -integral should be either string for a <b>ParsedKeyVal</b> constructor or a
       classname. This factory is not guaranteed to have its storage and basis sets set up properly, hence
       set_basis and set_storage need to be called on it.

   <b>virtual</b> <b>CartesianIter*</b> <b>sc::Integral::new_cartesian_iter</b> <b>(int)</b> <b>[pure</b> <b>virtual]</b>
       Return a <b>CartesianIter</b> object. The caller is responsible for freeing the object.

       Implemented in <b>sc::IntegralCCA</b>, <b>sc::IntegralCints</b>, and <b>sc::IntegralV3</b>.

   <b>virtual</b> <b>RedundantCartesianIter*</b> <b>sc::Integral::new_redundant_cartesian_iter</b> <b>(int)</b> <b>[pure</b> <b>virtual]</b>
       Return a <b>RedundantCartesianIter</b> object. The caller is responsible for freeing the object.

       Implemented in <b>sc::IntegralCCA</b>, <b>sc::IntegralCints</b>, and <b>sc::IntegralV3</b>.

   <b>virtual</b> <b>RedundantCartesianSubIter*</b> <b>sc::Integral::new_redundant_cartesian_sub_iter</b> <b>(int)</b> <b>[pure</b> <b>virtual]</b>
       Return a <b>RedundantCartesianSubIter</b> object. The caller is responsible for freeing the object.

       Implemented in <b>sc::IntegralCCA</b>, <b>sc::IntegralCints</b>, and <b>sc::IntegralV3</b>.

   <b>virtual</b> <b>SphericalTransformIter*</b> <b>sc::Integral::new_spherical_transform_iter</b> <b>(int</b> <b>l,</b> <b>int</b> <b>inv</b> <b>=</b> <b>0,</b> <b>int</b> <b>subl</b> <b>=</b>
       <b>-1)</b> <b>[pure</b> <b>virtual]</b>
       Return a <b>SphericalTransformIter</b> object. The caller is responsible for freeing the object.

       Implemented in <b>sc::IntegralCCA</b>, <b>sc::IntegralCints</b>, and <b>sc::IntegralV3</b>.

   <b>virtual</b> <b>Ref&lt;OneBodyInt&gt;</b> <b>sc::Integral::nuclear</b> <b>()</b> <b>[pure</b> <b>virtual]</b>
       Return a <b>OneBodyInt</b> that computes the nuclear repulsion integrals. Charges from the atoms on center one
       are used. If center two is not identical to center one, then the charges on center two are included as
       well.

       Implemented in <b>sc::IntegralCCA</b>, <b>sc::IntegralCints</b>, and <b>sc::IntegralV3</b>.

   <b>virtual</b> <b>Ref&lt;OneBodyInt&gt;</b> <b>sc::Integral::quadrupole</b> <b>(const</b> <b>Ref&lt;</b> <b>DipoleData</b> <b>&gt;</b> <b>&amp;)</b> <b>[pure</b> <b>virtual]</b>
       Return a <b>OneBodyInt</b> that computes electric quadrupole moment integrals. The canonical order of integrals
       in a set is x^2, xy, xz, y^2, yz, z^2.

       Implemented in <b>sc::IntegralCCA</b>, <b>sc::IntegralCints</b>, and <b>sc::IntegralV3</b>.

   <b>void</b> <b>sc::Integral::save_data_state</b> <b>(StateOut</b> <b>&amp;)</b> <b>[virtual]</b>
       Save the base classes (with save_data_state) and the members in the same order that the <b>StateIn</b> CTOR
       initializes them. This must be implemented by the derived class if the class has data.

       Reimplemented from <b>sc::SavableState</b>.

       Reimplemented in <b>sc::IntegralCCA</b>, <b>sc::IntegralCints</b>, and <b>sc::IntegralV3</b>.

   <b>ShellRotation</b> <b>sc::Integral::shell_rotation</b> <b>(int</b> <b>am,</b> <b>SymmetryOperation</b> <b>&amp;,</b> <b>int</b> <b>pure</b> <b>=</b> <b>0)</b>
       Return the <b>ShellRotation</b> object for a shell of the given angular momentum. Pass nonzero to pure to do
       solid harmonics.

   <b>virtual</b> <b>const</b> <b>SphericalTransform*</b> <b>sc::Integral::spherical_transform</b> <b>(int</b> <b>l,</b> <b>int</b> <b>inv</b> <b>=</b> <b>0,</b> <b>int</b> <b>subl</b> <b>=</b> <b>-1)</b> <b>[pure</b>
       <b>virtual]</b>
       Return a <b>SphericalTransform</b> object. The pointer is only valid while this <b>Integral</b> object is valid.

       Implemented in <b>sc::IntegralCCA</b>, <b>sc::IntegralCints</b>, and <b>sc::IntegralV3</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for MPQC from the source code.

Version 2.3.1                                    Sun Oct 4 2020                                  <u>sc::<a href="../man3/Integral.3.html">Integral</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>