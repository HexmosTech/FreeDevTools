<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sc::IntegralV3 - IntegralV3 computes integrals between Gaussian basis functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libsc-doc">libsc-doc_2.3.1-21_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sc::IntegralV3 - <b>IntegralV3</b> computes integrals between Gaussian basis functions.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;intv3.h&gt;

       Inherits <b>sc::Integral</b>.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>IntegralV3</b> (const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b1=0, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b2=0, const <b>Ref</b>&lt;
           <b>GaussianBasisSet</b> &gt; &amp;b3=0, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b4=0)
       <b>IntegralV3</b> (<b>StateIn</b> &amp;)
       <b>IntegralV3</b> (const <b>Ref</b>&lt; <b>KeyVal</b> &gt; &amp;)
       void <b>save_data_state</b> (<b>StateOut</b> &amp;)
           Save the base classes (with save_data_state) and the members in the same order that the <b>StateIn</b> CTOR
           initializes them.
       <b>Integral</b> * <b>clone</b> ()
           Clones the given <b>Integral</b> factory. The new factory may need to have set_basis and set_storage to be
           called on it.
       <b>CartesianIter</b> * <b>new_cartesian_iter</b> (int)
           Return a <b>CartesianIter</b> object.
       <b>RedundantCartesianIter</b> * <b>new_redundant_cartesian_iter</b> (int)
           Return a <b>RedundantCartesianIter</b> object.
       <b>RedundantCartesianSubIter</b> * <b>new_redundant_cartesian_sub_iter</b> (int)
           Return a <b>RedundantCartesianSubIter</b> object.
       <b>SphericalTransformIter</b> * <b>new_spherical_transform_iter</b> (int l, int inv=0, int subl=-1)
           Return a <b>SphericalTransformIter</b> object.
       const <b>SphericalTransform</b> * <b>spherical_transform</b> (int l, int inv=0, int subl=-1)
           Return a <b>SphericalTransform</b> object.
       <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>overlap</b> ()
           Return a <b>OneBodyInt</b> that computes the overlap.
       <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>kinetic</b> ()
           Return a <b>OneBodyInt</b> that computes the kinetic energy.
       <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>point_charge</b> (const <b>Ref</b>&lt; <b>PointChargeData</b> &gt; &amp;=0)
           Return a <b>OneBodyInt</b> that computes the integrals for interactions with point charges.
       <b>Ref</b>&lt; <b>OneBodyOneCenterInt</b> &gt; <b>point_charge1</b> (const <b>Ref</b>&lt; <b>PointChargeData</b> &gt; &amp;)
           Return a <b>OneBodyInt</b> that computes the integrals for interactions with point charges.
       <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>nuclear</b> ()
           Return a <b>OneBodyInt</b> that computes the nuclear repulsion integrals.
       <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>hcore</b> ()
           Return a <b>OneBodyInt</b> that computes the core Hamiltonian integrals.
       <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>efield_dot_vector</b> (const <b>Ref</b>&lt; <b>EfieldDotVectorData</b> &gt; &amp;=0)
           Return a <b>OneBodyInt</b> that computes the electric field integrals dotted with a given vector.
       <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>dipole</b> (const <b>Ref</b>&lt; <b>DipoleData</b> &gt; &amp;=0)
           Return a <b>OneBodyInt</b> that computes electric dipole moment integrals.
       <b>Ref</b>&lt; <b>OneBodyInt</b> &gt; <b>quadrupole</b> (const <b>Ref</b>&lt; <b>DipoleData</b> &gt; &amp;=0)
           Return a <b>OneBodyInt</b> that computes electric quadrupole moment integrals.
       <b>Ref</b>&lt; <b>OneBodyDerivInt</b> &gt; <b>overlap_deriv</b> ()
           Return a <b>OneBodyDerivInt</b> that computes overlap derivatives.
       <b>Ref</b>&lt; <b>OneBodyDerivInt</b> &gt; <b>kinetic_deriv</b> ()
           Return a <b>OneBodyDerivInt</b> that computes kinetic energy derivatives.
       <b>Ref</b>&lt; <b>OneBodyDerivInt</b> &gt; <b>nuclear_deriv</b> ()
           Return a <b>OneBodyDerivInt</b> that computes nuclear repulsion derivatives.
       <b>Ref</b>&lt; <b>OneBodyDerivInt</b> &gt; <b>hcore_deriv</b> ()
           Return a <b>OneBodyDerivInt</b> that computes core Hamiltonian derivatives.
       <b>Ref</b>&lt; <b>TwoBodyInt</b> &gt; <b>electron_repulsion</b> ()
           Return a <b>TwoBodyInt</b> that computes electron repulsion integrals.
       <b>Ref</b>&lt; <b>TwoBodyTwoCenterInt</b> &gt; <b>electron_repulsion2</b> ()
           Return a <b>TwoBodyTwoCenterInt</b> that computes electron repulsion integrals.
       <b>Ref</b>&lt; <b>TwoBodyThreeCenterInt</b> &gt; <b>electron_repulsion3</b> ()
           Return a <b>TwoBodyThreeCenterInt</b> that computes electron repulsion integrals.
       <b>Ref</b>&lt; <b>TwoBodyDerivInt</b> &gt; <b>electron_repulsion_deriv</b> ()
           Return a <b>TwoBodyDerivInt</b> that computes electron repulsion derivatives.
       void <b>set_basis</b> (const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b1, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b2=0, const <b>Ref</b>&lt;
           <b>GaussianBasisSet</b> &gt; &amp;b3=0, const <b>Ref</b>&lt; <b>GaussianBasisSet</b> &gt; &amp;b4=0)
           Set the basis set for each center.

   <b>Additional</b> <b>Inherited</b> <b>Members</b>
</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       <b>IntegralV3</b> computes integrals between Gaussian basis functions.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>Ref&lt;OneBodyInt&gt;</b> <b>sc::IntegralV3::dipole</b> <b>(const</b> <b>Ref&lt;</b> <b>DipoleData</b> <b>&gt;</b> <b>&amp;</b> <b>=</b> <b>0)</b> <b>[virtual]</b>
       Return a <b>OneBodyInt</b> that computes electric dipole moment integrals. The canonical order of integrals in a
       set is x, y, z.

       Implements <b>sc::Integral</b>.

   <b>Ref&lt;TwoBodyTwoCenterInt&gt;</b> <b>sc::IntegralV3::electron_repulsion2</b> <b>()</b> <b>[virtual]</b>
       Return a <b>TwoBodyTwoCenterInt</b> that computes electron repulsion integrals. If this is not re-implemented it
       will throw.

       Reimplemented from <b>sc::Integral</b>.

   <b>Ref&lt;TwoBodyThreeCenterInt&gt;</b> <b>sc::IntegralV3::electron_repulsion3</b> <b>()</b> <b>[virtual]</b>
       Return a <b>TwoBodyThreeCenterInt</b> that computes electron repulsion integrals. If this is not re-implemented
       it will throw.

       Reimplemented from <b>sc::Integral</b>.

   <b>CartesianIter*</b> <b>sc::IntegralV3::new_cartesian_iter</b> <b>(int)</b> <b>[virtual]</b>
       Return a <b>CartesianIter</b> object. The caller is responsible for freeing the object.

       Implements <b>sc::Integral</b>.

   <b>RedundantCartesianIter*</b> <b>sc::IntegralV3::new_redundant_cartesian_iter</b> <b>(int)</b> <b>[virtual]</b>
       Return a <b>RedundantCartesianIter</b> object. The caller is responsible for freeing the object.

       Implements <b>sc::Integral</b>.

   <b>RedundantCartesianSubIter*</b> <b>sc::IntegralV3::new_redundant_cartesian_sub_iter</b> <b>(int)</b> <b>[virtual]</b>
       Return a <b>RedundantCartesianSubIter</b> object. The caller is responsible for freeing the object.

       Implements <b>sc::Integral</b>.

   <b>SphericalTransformIter*</b> <b>sc::IntegralV3::new_spherical_transform_iter</b> <b>(int</b> <b>l,</b> <b>int</b> <b>inv</b> <b>=</b> <b>0,</b> <b>int</b> <b>subl</b> <b>=</b> <b>-1)</b>
       <b>[virtual]</b>
       Return a <b>SphericalTransformIter</b> object. The caller is responsible for freeing the object.

       Implements <b>sc::Integral</b>.

   <b>Ref&lt;OneBodyInt&gt;</b> <b>sc::IntegralV3::nuclear</b> <b>()</b> <b>[virtual]</b>
       Return a <b>OneBodyInt</b> that computes the nuclear repulsion integrals. Charges from the atoms on center one
       are used. If center two is not identical to center one, then the charges on center two are included as
       well.

       Implements <b>sc::Integral</b>.

   <b>Ref&lt;OneBodyInt&gt;</b> <b>sc::IntegralV3::quadrupole</b> <b>(const</b> <b>Ref&lt;</b> <b>DipoleData</b> <b>&gt;</b> <b>&amp;</b> <b>=</b> <b>0)</b> <b>[virtual]</b>
       Return a <b>OneBodyInt</b> that computes electric quadrupole moment integrals. The canonical order of integrals
       in a set is x^2, xy, xz, y^2, yz, z^2.

       Implements <b>sc::Integral</b>.

   <b>void</b> <b>sc::IntegralV3::save_data_state</b> <b>(StateOut</b> <b>&amp;)</b> <b>[virtual]</b>
       Save the base classes (with save_data_state) and the members in the same order that the <b>StateIn</b> CTOR
       initializes them. This must be implemented by the derived class if the class has data.

       Reimplemented from <b>sc::Integral</b>.

   <b>const</b> <b>SphericalTransform*</b> <b>sc::IntegralV3::spherical_transform</b> <b>(int</b> <b>l,</b> <b>int</b> <b>inv</b> <b>=</b> <b>0,</b> <b>int</b> <b>subl</b> <b>=</b> <b>-1)</b> <b>[virtual]</b>
       Return a <b>SphericalTransform</b> object. The pointer is only valid while this <b>Integral</b> object is valid.

       Implements <b>sc::Integral</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for MPQC from the source code.

Version 2.3.1                                    Sun Oct 4 2020                                <u>sc::<a href="../man3/IntegralV3.3.html">IntegralV3</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>