<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Validator::Schema - validate XML against a subset of W3C XML Schema</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-validator-schema-perl">libxml-validator-schema-perl_1.10-2.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Validator::Schema - validate XML against a subset of W3C XML Schema

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use XML::SAX::ParserFactory;
         use XML::Validator::Schema;

         #
         # create a new validator object, using foo.xsd
         #
         $validator = XML::Validator::Schema-&gt;new(file =&gt; 'foo.xsd');

         #
         # create a SAX parser and assign the validator as a Handler
         #
         $parser = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $validator);

         #
         # validate foo.xml against foo.xsd
         #
         eval { $parser-&gt;parse_uri('foo.xml') };
         die "File failed validation: $@" if $@;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module allows you to validate XML documents against a W3C XML Schema.  This module does not
       implement the full W3C XML Schema recommendation (<a href="http://www.w3.org/XML/Schema">http://www.w3.org/XML/Schema</a>), but a useful subset.
       See the SCHEMA SUPPORT section below.

       <b>IMPORTANT</b> <b>NOTE</b>: To get line and column numbers in the error messages generated by this module you must
       install XML::Filter::ExceptionLocator and use XML::SAX::ExpatXS as your SAX parser.  This module is much
       more useful if you can tell where your errors are, so using these modules is highly recommended!

</pre><h4><b>INTERFACE</b></h4><pre>
       •   "XML::Validator::Schema-&gt;new(file =&gt; 'file.xsd', cache =&gt; 1)"

           Call  this  method  to create a new XML::Validator:Schema object.  The only required option is "file"
           which must provide a path to an XML Schema document.

           Setting the optional "cache" parameter to 1 causes XML::Validator::Schema  to  keep  a  copy  of  the
           schema  parse  tree  in  memory.   The  tree  will be reused on subsequent calls with the same "file"
           parameter, as long as the mtime on the schema file hasn't changed.  This can save a lot  of  time  if
           you're validating many documents against a single schema.

           Since XML::Validator::Schema is a SAX filter you will normally pass this object to a SAX parser:

             $validator = XML::Validator::Schema-&gt;new(file =&gt; 'foo.xsd');
             $parser = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $validator);

           Then you can proceed to validate files using the parser:

             eval { $parser-&gt;parse_uri('foo.xml') };
             die "File failed validation: $@" if $@;

           Setting  the  optional  "debug"  parameter  to 1 causes XML::Validator::Schema to output elements and
           associated attributes while parsing and validating the XML document. This provides useful information
           on the position where the validation failed (although not at useful as the line  and  column  numbers
           included when XML::Filter::ExceptiionLocator and XML::SAX::ExpatXS are used).

</pre><h4><b>RATIONALE</b></h4><pre>
       I'm  writing  a  piece  of software which uses Xerces/C++ ( <a href="http://xml.apache.org/xerces-c/">http://xml.apache.org/xerces-c/</a> ) to validate
       documents against XML Schema schemas.  This works very well, but I'd like to release my  project  to  the
       world.   Requiring  users to install Xerces is simply too onerous a requirement; few will have it already
       and the Xerces installation system leaves much to be desired.

       On CPAN, the only available XML Schema validator is XML::Schema.  Unfortunately, this module isn't  ready
       for  use  as  it  lacks  the  ability  to  actually  parse the XML Schema document format!  I looked into
       enhancing XML::Schema but I must admit that I'm not smart enough to understand the code...  One day, when
       XML::Schema is completed I will replace this module with a wrapper around it.

       This module represents my attempt to support enough XML Schema syntax to be useful without attempting  to
       tackle the full standard.  I'm sure this will mean that it can't be used in all situations, but hopefully
       that won't prevent it from being used at all.

</pre><h4><b>SCHEMA</b> <b>SUPPORT</b></h4><pre>
   <b>Supported</b> <b>Elements</b>
       The  following  elements  are  supported  by  the  XML  Schema parser.  If you don't see an element or an
       attribute here then you definitely can't use it in a schema document.

       You can expect that the schema document parser will produce an error if you include  elements  which  are
       not supported.  However, unsupported attributes <u>may</u> be silently ignored.  This should not be misconstrued
       as a feature and will eventually be fixed.

       All  of  these elements must be in the <a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a> namespace, either using a default
       namespace or a prefix.

         &lt;schema&gt;

            Supported attributes: targetNamespace, elementFormDefault,
            attributeFormDefault

            Notes: the only supported values for elementFormDefault and
            attributeFormDefault are "unqualified."  As such, targetNamespace
            is essentially ignored.

         &lt;element name="foo"&gt;

            Supported attributes: name, type, minOccurs, maxOccurs, ref

         &lt;attribute&gt;

            Supported attributes: name, type, use, ref

         &lt;sequence&gt;

            Supported attributes: minOccurs, maxOccurs

         &lt;choice&gt;

            Supported attributes: minOccurs, maxOccurs

         &lt;all&gt;

            Supported attributes: minOccurs, maxOccurs

         &lt;complexType&gt;

           Supported attributes: name

         &lt;simpleContent&gt;

           The only supported sub-element is &lt;extension&gt;.

         &lt;extension&gt;

           Supported attributes: base

           Notes: only allowed inside &lt;simpleContent&gt;

         &lt;simpleType&gt;

           Supported attributes: name

         &lt;restriction&gt;

           Supported attributes: base

           Notes: only allowed inside &lt;simpleType&gt;

         &lt;whiteSpace&gt;

           Supported attributes: value

         &lt;pattern&gt;

           Supported attributes: value

         &lt;enumeration&gt;

           Supported attributes: value

         &lt;length&gt;

           Supported attributes: value

         &lt;minLength&gt;

           Supported attributes: value

         &lt;maxLength&gt;

           Supported attributes: value

         &lt;minInclusive&gt;

           Supported attributes: value

         &lt;minExclusive&gt;

           Supported attributes: value

         &lt;maxInclusive&gt;

           Supported attributes: value

         &lt;maxExclusive&gt;

           Supported attributes: value

         &lt;totalDigits&gt;

           Supported attributes: value

         &lt;fractionDigits&gt;

           Supported attributes: value

         &lt;annotation&gt;

         &lt;documentation&gt;

           Supported attributes: name

         &lt;union&gt;
           Supported attributes: MemberTypes

   <b>Simple</b> <b>Type</b> <b>Support</b>
       Supported built-in types are:

         string

         normalizedString

         token

         NMTOKEN

          Notes: the spec says NMTOKEN should only be used for attributes,
          but this rule is not enforced.

         boolean

         decimal

          Notes: the enumeration facet is not supported on decimal or any
          types derived from decimal.

         integer

         int

         short

         byte

         unsignedInt

         unsignedShort

         unsignedByte

         positiveInteger

         negativeInteger

         nonPositiveInteger

         nonNegativeInteger

         dateTime

           Notes: Although dateTime correctly validates the lexical format it does not
           offer comparison facets (min*, max*, enumeration).

         double

           Notes: Although double correctly validates the lexical format it
           does not offer comparison facets (min*, max*, enumeration).  Also,
           minimum and maximum constraints as described in the spec are not
           checked.

         float

           Notes: The restrictions on double support apply to float as well.

         duration

         time

         date

         gYearMonth

         gYear

         gMonthDay

         gDay

         gMonth

         hexBinary

         base64Binary

         anyURI

         QName

         NOTATION

   <b>Miscellaneous</b> <b>Details</b>
       Other known devations from the specification:

       •   Patterns specified in pattern simpleType restrictions are Perl regexes with none of  the  XML  Schema
           extensions available.

       •   No  effort  is  made  to prevent the declaration of facets which "loosen" the restrictions on a type.
           This is a bug and will be fixed in a future release.   Until  then  types  which  attempt  to  loosen
           restrictions on their base class will behave unpredictably.

       •   No  attempt  has  been  made  to exclude content models which are ambiguous, as the spec demands.  In
           fact, I don't see any compelling reason to do so, aside from strict  compliance  to  the  spec.   The
           content  model  implementaton  uses  regular  expressions  which  should  be  able to handle loads of
           ambiguity without significant performance problems.

       •   Marking a facet "fixed" has no effect.

       •   SimpleTypes must come after their base types in the schema body.  For example, this is ok:

               &lt;xs:simpleType name="foo"&gt;
                   &lt;xs:restriction base="xs:string"&gt;
                       &lt;xs:minLength value="10"/&gt;
                   &lt;/xs:restriction&gt;
               &lt;/xs:simpleType&gt;
               &lt;xs:simpleType name="foo_bar"&gt;
                   &lt;xs:restriction base="foo"&gt;
                       &lt;xs:length value="10"/&gt;
                   &lt;/xs:restriction&gt;
               &lt;/xs:simpleType&gt;

           But this is not:

               &lt;xs:simpleType name="foo_bar"&gt;
                   &lt;xs:restriction base="foo"&gt;
                       &lt;xs:length value="10"/&gt;
                   &lt;/xs:restriction&gt;
               &lt;/xs:simpleType&gt;
               &lt;xs:simpleType name="foo"&gt;
                   &lt;xs:restriction base="xs:string"&gt;
                       &lt;xs:minLength value="10"/&gt;
                   &lt;/xs:restriction&gt;
               &lt;/xs:simpleType&gt;

</pre><h4><b>CAVEATS</b></h4><pre>
       Here are a few gotchas that you should know about:

       •   No Unicode testing has been performed, although it seems possible that the module will handle Unicode
           data correctly.

       •   Namespace processing is almost entirely missing from the module.

       •   Little work has been done to ensure that invalid schemas fail gracefully.  Until that is done you may
           want to develop your schemas using a more mature validator (like Xerces or XML Spy) before using them
           with this module.

</pre><h4><b>BUGS</b></h4><pre>
       Please use "rt.cpan.org" to report bugs in this module:

         <a href="http://rt.cpan.org">http://rt.cpan.org</a>

       Please note that I will delete bugs which merely point out the lack of support for a  particular  feature
       of XML Schema.  Those are feature requests, and believe me, I know we've got a long way to go.

</pre><h4><b>SUPPORT</b></h4><pre>
       This  module  is  supported  on  the  perl-xml mailing-list.  Please join the list if you have questions,
       suggestions or patches:

         <a href="http://listserv.activestate.com/mailman/listinfo/perl-xml">http://listserv.activestate.com/mailman/listinfo/perl-xml</a>

</pre><h4><b>CVS</b></h4><pre>
       If you'd like to help develop XML::Validator::Schema you'll want to check out a copy of the CVS tree:

         <a href="http://sourceforge.net/cvs/">http://sourceforge.net/cvs/</a>?group_id=89764

</pre><h4><b>CREDITS</b></h4><pre>
       The following people have contributed bug reports, test cases and/or code:

         Russell B Cecala (aka Plankton)
         David Wheeler
         Toby Long-Leather
         Mathieu
         <a href="mailto:h.bridge@fasol.fujitsu.com">h.bridge@fasol.fujitsu.com</a>
         <a href="mailto:michael.jacob@schering.de">michael.jacob@schering.de</a>
         <a href="mailto:josef@clubphoto.com">josef@clubphoto.com</a>
         <a href="mailto:adamk@ali.as">adamk@ali.as</a>
         Jean Flouret

</pre><h4><b>AUTHOR</b></h4><pre>
       Sam Tregar &lt;<a href="mailto:sam@tregar.com">sam@tregar.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2002-2003 Sam Tregar

       This program is free software; you can redistribute it and/or modify it under the same terms  as  Perl  5
       itself.

</pre><h4><b>A</b> <b>NOTE</b> <b>ON</b> <b>DEVELOPMENT</b> <b>METHODOLOGY</b></h4><pre>
       This  module  isn't  just  an  XML  Schema  validator,  it's  also  a test of the Test Driven Development
       methodology.  I've been writing tests while I develop code for a while  now,  but  TDD  goes  further  by
       requiring  tests  to  be  written  <u>before</u> code.  One consequence of this is that the module code may seem
       naive; it really is <u>just</u> <u>enough</u> code to pass the current test suite.  If I'm doing it  right  then  there
       shouldn't be a single line of code that isn't directly related to passing a test.  As I add functionality
       (by  way  of  writing  tests)  I'll  refactor the code a great deal, but I won't add code only to support
       future development.

       For more information I recommend "Test Driven Development: By Example" by Kent Beck.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::Schema

       <a href="http://www.w3.org/XML/Schema">http://www.w3.org/XML/Schema</a>

       <a href="http://xml.apache.org/xerces-c/">http://xml.apache.org/xerces-c/</a>

perl v5.32.0                                       2021-01-05                                        <u><a href="../man3pm/Schema.3pm.html">Schema</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>