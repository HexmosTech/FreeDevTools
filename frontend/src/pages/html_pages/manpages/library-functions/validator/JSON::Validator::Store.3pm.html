<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON::Validator::Store - Load and caching JSON schemas</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libjson-validator-perl">libjson-validator-perl_5.15+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       JSON::Validator::Store - Load and caching JSON schemas

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use JSON::Validator;
         my $jv = JSON::Validator-&gt;new;
         $jv-&gt;store-&gt;add("urn:uuid:ee564b8a-7a87-4125-8c96-e9f123d6766f" =&gt; {...});
         $jv-&gt;store-&gt;load("<a href="http://api.example.com/my/schema.json">http://api.example.com/my/schema.json</a>");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       JSON::Validator::Store is a class for loading and caching JSON-Schemas.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
   <b>cache_paths</b>
         my $store     = $store-&gt;cache_paths(\@paths);
         my $array_ref = $store-&gt;cache_paths;

       A list of directories to where cached specifications are stored. Defaults to "JSON_VALIDATOR_CACHE_PATH"
       environment variable and the specs that is bundled with this distribution.

       "JSON_VALIDATOR_CACHE_PATH" can be a list of directories, each separated by ":".

       See "Bundled specifications" in JSON::Validator for more details.

   <b>schemas</b>
         my $hash_ref = $store-&gt;schemas;
         my $store = $store-&gt;schemas({});

       Hold the schemas as data structures. The keys are schema "id".

   <b>ua</b>
         my $ua    = $store-&gt;ua;
         my $store = $store-&gt;ua(Mojo::UserAgent-&gt;new);

       Holds a Mojo::UserAgent object, used by "schema" to load a JSON schema from remote location.

       The default Mojo::UserAgent will detect proxy settings and have "max_redirects" in Mojo::UserAgent set to
       3.

</pre><h4><b>METHODS</b></h4><pre>
   <b>add</b>
         my $normalized_id = $store-&gt;add($id =&gt; \%schema);

       Used to add a schema data structure. Note that $id might not be the same as $normalized_id.

   <b>exists</b>
         my $normalized_id = $store-&gt;exists($id);

       Returns a $normalized_id if it is present in the "schemas".

   <b>get</b>
         my $schema = $store-&gt;get($normalized_id);

       Used to retrieve a $schema added by "add" or "load".

   <b>load</b>
         my $normalized_id = $store-&gt;load('https://...');
         my $normalized_id = $store-&gt;load('data://main/foo.json');
         my $normalized_id = $store-&gt;load('---\nid: yaml');
         my $normalized_id = $store-&gt;load('{"id":"yaml"}');
         my $normalized_id = $store-&gt;load(\$text);
         my $normalized_id = $store-&gt;load('/path/to/foo.json');
         my $normalized_id = $store-&gt;load('file:///path/to/foo.json');
         my $normalized_id = $store-&gt;load('/load/from/ua-server-app');

       Can load a $schema from many different sources. The input can be a string or a string-like object, and
       the "load" method will try to resolve it in the order listed in above.

       Loading schemas from $text will generate an $normalized_id in "schemas" looking like
       "urn:text:$text_checksum". This might change in the future!

       Loading files from disk will result in a $normalized_id that always start with "file://".

       Loading can also be done with relative path, which will then load from:

         $store-&gt;ua-&gt;server-&gt;app;

       This method is EXPERIMENTAL, but unlikely to change significantly.

   <b>resolve</b>
         $hash_ref = $store-&gt;resolve($url, \%defaults);

       Takes a $url (can also be a file, urn, ...) with or without a fragment and returns this structure about
       the schema:

         {
           base_url =&gt; $str,  # the part before the fragment in the $url
           fragment =&gt; $str,  # fragment part of the $url
           id       =&gt; $str,  # store ID
           root     =&gt; ...,   # the root schema
           schema   =&gt; ...,   # the schema inside "root" if fragment is present
         }

       This method is EXPERIMENTAL and can change without warning.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       JSON::Validator.

perl v5.40.1                                       2025-03-29                        <u>JSON::Validator::<a href="../man3pm/Store.3pm.html">Store</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>