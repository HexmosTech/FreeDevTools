<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Filter::SAXT - Replicates SAX events to several SAX event handlers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-filter-saxt-perl">libxml-filter-saxt-perl_0.01-9_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Filter::SAXT - Replicates SAX events to several SAX event handlers

</pre><h4><b>SYNOPSIS</b></h4><pre>
        $saxt = new XML::Filter::SAXT ( { Handler =&gt; $out1 },
                                        { DocumentHandler =&gt; $out2 },
                                        { DTDHandler =&gt; $out3,
                                          Handler =&gt; $out4
                                        }
                                      );

        $perlsax = new XML::Parser::PerlSAX ( Handler =&gt; $saxt );
        $perlsax-&gt;parse ( [OPTIONS] );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       SAXT is like the Unix 'tee' command in that it multiplexes the input stream to several output streams. In
       this case, the input stream is a PerlSAX event producer (like XML::Parser::PerlSAX) and the output
       streams are PerlSAX handlers or filters.

       The SAXT constructor takes a list of hash references. Each hash specifies an output handler. The hash
       keys can be: DocumentHandler, DTDHandler, EntityResolver or Handler, where Handler is a combination of
       the previous three and acts as the default handler.  E.g. if DocumentHandler is not specified, it will
       try to use Handler.

   <b>EXAMPLE</b>
       In this example we use XML::Parser::PerlSAX to parse an XML file and to invoke the PerlSAX callbacks of
       our SAXT object. The SAXT object then forwards the callbacks to XML::Checker, which will 'die' if it
       encounters an error, and to XML::Handler::BuildDOM, which will store the XML in an XML::DOM::Document.

        use XML::Parser::PerlSAX;
        use XML::Filter::SAXT;
        use XML::Handler::BuildDOM;
        use XML::Checker;

        my $checker = new XML::Checker;
        my $builder = new XML::Handler::BuildDOM (KeepCDATA =&gt; 1);
        my $tee = new XML::Filter::SAXT ( { Handler =&gt; $checker },
                                          { Handler =&gt; $builder } );

        my $parser = new XML::Parser::PerlSAX (Handler =&gt; $tee);
        eval
        {
           # This is how you set the error handler for XML::Checker
           local $XML::Checker::FAIL = \&amp;my_fail;

           my $dom_document = $parser-&gt;parsefile ("file.xml");
           ... your code here ...
        };
        if ($@)
        {
           # Either XML::Parser::PerlSAX threw an exception (bad XML)
           # or XML::Checker found an error and my_fail died.
           ... your error handling code here ...
        }

        # XML::Checker error handler
        sub my_fail
        {
          my $code = shift;
          die XML::Checker::error_string ($code, @_)
               if $code &lt; 200;   # warnings and info messages are &gt;= 200
        }

</pre><h4><b>CAVEATS</b></h4><pre>
       This is still alpha software.  Package names and interfaces are subject to change.

</pre><h4><b>AUTHOR</b></h4><pre>
       Enno Dersken is the original author.

       Send bug reports, hints, tips, suggestions to T.J. Mather at &lt;<u><a href="mailto:tjmather@tjmather.com">tjmather@tjmather.com</a></u>&gt;.

perl v5.36.0                                       2022-12-06                                          <u><a href="../man3pm/SAXT.3pm.html">SAXT</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>