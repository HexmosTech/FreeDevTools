<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Handler::Trees - PerlSAX handlers for building tree structures</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-handler-trees-perl">libxml-handler-trees-perl_0.02-9_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Handler::Trees - PerlSAX handlers for building tree structures

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use XML::Handler::Trees;
         use XML::Parser::PerlSAX;

         my $p=XML::Parser::PerlSAX-&gt;new();
         my $h=XML::Handler::Tree-&gt;new();
         my $tree=$p-&gt;parse(Handler=&gt;$h,Source=&gt;{SystemId=&gt;'file.xml'});

         my $p=XML::Parser::PerlSAX-&gt;new();
         my $h=XML::Handler::EasyTree-&gt;new(Noempty=&gt;1);
         my $easytree=$p-&gt;parse(Handler=&gt;$h,Source=&gt;{SystemId=&gt;'file.xml'});

         my $p=XML::Parser::PerlSAX-&gt;new();
         my $h=XML::Handler::TreeBuilder-&gt;new();
         $h-&gt;<a href="../man1/store_pis.1.html">store_pis</a>(1);
         my $tree=$p-&gt;parse(Handler=&gt;$h,Source=&gt;{SystemId=&gt;'file.xml'});

</pre><h4><b>DESCRIPTION</b></h4><pre>
       XML::Handler::Trees provides three PerlSAX handler classes for building tree structures.
       XML::Handler::Tree builds the same type of tree as the "Tree" style in XML::Parser.
       XML::Handler::EasyTree builds the same type of tree as the "EasyTree" style added to XML::Parser by
       XML::Parser::EasyTree.  XML::Handler::TreeBuilder builds the same type of tree as Sean M. Burke's
       XML::TreeBuilder.  These classes make it possible to construct these tree structures from sources other
       than XML::Parser.

       All three handlers can be driven by either PerlSAX 1 or PerlSAX 2 drivers.  In all cases, the
       <b>end_document()</b> method returns a reference to the constructed tree, which normally becomes the return
       value of the PerlSAX driver.

</pre><h4><b>CLASS</b> <b>XML::Handler::Tree</b></h4><pre>
       This handler builds the same type of tree structure as the "Tree" style in XML::Parser.  Some modules
       such as Dan Brian's XML::SimpleObject work with this type of tree.  See the documentation for XML::Parser
       for details.

   <b>METHODS</b>
       $handler = XML::Handler::Tree-&gt;<b>new()</b>
           Creates a handler object.

</pre><h4><b>CLASS</b> <b>XML::Handler::EasyTree</b></h4><pre>
       This  handler  builds  a lightweight tree structure representing the XML document.  This structure is, at
       least in this author's opinion, easier to work with than the "standard" style of tree.  It  is  the  same
       type  of  structure  as  built by XML::Parser when using XML::Parser::EasyTree, or by the get_simple_tree
       method in XML::Records.

       The tree is returned as a reference to an array of tree nodes, each of which is  a  hash  reference.  All
       nodes  have  a 'type' key whose value is the type of the node: 'e' for element nodes, 't' for text nodes,
       and 'p' for processing instruction nodes. All nodes also have a 'content' key whose value is a  reference
       to an array holding the element's child nodes for element nodes, the string value for text nodes, and the
       data  value  for  processing  instruction nodes. Element nodes also have an 'attrib' key whose value is a
       reference to a hash of attribute names and values and a 'name' key whose value  is  the  element's  name.
       Processing instructions also have a 'target' key whose value is the PI's target.

       EasyTree nodes are ordinary Perl hashes and are not objects.  Contiguous runs of text are always returned
       in a single node.

       The  reason  the  parser  returns  an  array reference rather than the root element's node is that an XML
       document can legally contain processing instructions outside the root element (the xml-stylesheet  PI  is
       commonly used this way).

       If namespace information is available (only possible with PerlSAX 2), element and attribute names will be
       prefixed  with  their  (possibly  empty) namespace URI enclosed in curly brackets, and namespace prefixes
       will be stripped from names.

   <b>METHODS</b>
       $handler = XML::Handler::EasyTree-&gt;new([options])
           Creates a handler object.  Options can be provided hash-style:

           Noempty
               If this is set to a true value, text nodes consisting entirely of whitespace will not  be  stored
               in the tree.  The default is false.

           Latin
               If  this  is  set  to a true value, characters with Unicode values in the Latin-1 range (160-255)
               will be stored in the tree as Latin-1 rather than UTF-8.  The default is false.

           Searchable
               If   this   is   set   to   a   true   value,   the   parser    will    return    a    tree    of
               XML::Handler::EasyTree::Searchable objects rather than bare array references, providing access to
               the  navigation  methods  listed below.  The top-level node returned will be a dummy element node
               with a name of "__TOPLEVEL__".  It is  false  by  default.   Setting  this  option  automatically
               enables the Noempty option.

   <b>XML::Handler::EasyTree::Searchable</b> <b>METHODS</b>
       If  the  Searchable  option  is  set,  all  nodes  in the tree will be XML::Handler::EasyTree::Searchable
       objects, which have the same structure as EasyTree nodes but also implement the following methods similar
       to those in XML::SimpleObject.

       $name = $node-&gt;<b>name()</b>
           Returns the name of the node. Ideally, it should return a "fully qualified" name, but it doesn't.

       $val = $node-&gt;<b>value()</b>
           Returns the text value associated with a node object.  Returns undef if the node has no text children
           or its first child is not a text node.

       $newobj = $obj-&gt;child( $name );
           Returns a child (elements only) of the object with the $name.

           For the case where there is more than one child that match $name, the array context semantics haven't
           been completely worked out: - in an array context, all children are returned.  - in  scalar  context,
           the first child matching $name is returned.

           In  a  scalar context, The XML::Parser::SimpleObj class returns an object containing all the children
           matching $name, unless there is only one child in which case it returns  that  child  (see  commented
           code). I find that behavior confusing.

       @children = $obj-&gt;children( $name );
           Returns  a list of all children (elements only) of the $obj that match $name -- in the order in which
           they appeared in the original xml text.

       @children_names = $obj-&gt;<b>children_names()</b>;
           Returns a list of all the names of the objects children (elements only) in the order  in  which  they
           appeared in the original text.

       $attrib = $obj-&gt;attribute( $att_name );
           Returns the string associated with the attribute of the object. If not found returns a null string.

       @attribute_list = $obj-&gt;<b>attribute_list()</b>;
           Returns a list (in no particular order) of the attribute names associated with the object

       $text = $obj-&gt;<b>dump_tree()</b>;
           Returns  a  textual  representation  (in  xml  form)  of  the  object's  hierarchy. Only elements are
           processed. The result will be in whatever character encoding the SAX driver delivered (which may  not
           be the same encoding as the original source).

       $text = $obj-&gt;<b>pretty_dump_tree()</b>;
           Identical to <b>dump_tree()</b>, except that newline and indentation embellishments are added

   <b>EXAMPLE</b>
        #! <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w

        use XML::Handler::Trees;
        use XML::Parser::PerlSAX;
        use strict;

        my $p=XML::Parser::PerlSAX-&gt;new();
        my $h=XML::Handler::EasyTree-&gt;new( Searchable=&gt;1 );
        my $easytree=$p-&gt;parse( Handler =&gt; $h, Source =&gt; { SystemId =&gt; 'systemB.xml' } );

        my $vme = $easytree-&gt;child( "vmesystem" );

        print "\n";
        print "vmesystem config: ", $vme-&gt;attribute( "configuration_name" ), "\n";

        print "\n";
        print "vmesystem children: ", join( ', ', $vme-&gt;children_names() ), "\n";

        print "\n";
        print "gps model is ", $vme-&gt;child( "gps" )-&gt;child( "model" )-&gt;value(), "\n";
        my $gps = $vme-&gt;child( "gps" );
        print "gps slot is ", $gps-&gt;child( "slot" )-&gt;value(), "\n";

        print "\n";
        print "reconstructed XML: \n";
        print $easytree-&gt;dump_tree(), "\n";

        # print "\n";
        # print "recontructed XML (pretty): \n";
        # print $easytree-&gt;pretty_dump_tree(), "\n";

        print "\n";
        exit;

</pre><h4><b>CLASS</b> <b>XML::Handler::TreeBuilder</b></h4><pre>
       This handler builds XML document trees constructed of XML::Element objects (XML::Element is a subclass of
       HTML::Element  adapted  for XML).  To use it, XML::TreeBuilder and its prerequisite HTML::Tree need to be
       installed.  See the documentation for those modules for information  on  how  to  work  with  these  tree
       structures.

   <b>METHODS</b>
       $handler = XML::Handler::TreeBuilder-&gt;<b>new()</b>
           Creates a handler which builds a tree rooted in an XML::Element.

       $root-&gt;store_comments(value)
           This  determines  whether  comments  will be stored in the tree (not all SAX drivers generate comment
           events).  Currently, this is off by default.

       $root-&gt;store_declarations(value)
           This determines whether markup declarations will be stored in the tree.  Currently, this  is  off  by
           default.   The  present implementation does not store markup declarations in any case; this method is
           provided for future use.

       $root-&gt;store_pis(value)
           This determines whether processing instructions will be stored in the tree.  Currently, this  is  off
           (false) by default.

</pre><h4><b>AUTHOR</b></h4><pre>
       Eric Bohlman (<a href="mailto:ebohlman@omsdev.com">ebohlman@omsdev.com</a>)

       PerlSAX 2 compatibility added by Matt Sergeant (<a href="mailto:matt@sergeant.org">matt@sergeant.org</a>)

       XML::EasyTree::Searchable written by Stuart McDow (<a href="mailto:smcdow@moontower.org">smcdow@moontower.org</a>)

       Copyright (c) 2001 Eric Bohlman.

       Portions of this code Copyright (c) 2001 Matt Sergeant.

       Portions of this code Copyright (c) 2001 Stuart McDow.

       All  rights  reserved.  This program is free software; you can redistribute it and/or modify it under the
       same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        L&lt;perl&gt;
        L&lt;XML::Parser&gt;
        L&lt;XML::SimpleObject&gt;
        L&lt;XML::Parser::EasyTree&gt;
        L&lt;XML::TreeBuilder&gt;
        L&lt;XML::Element&gt;
        L&lt;HTML::Element&gt;
        L&lt;PerlSAX&gt;

perl v5.36.0                                       2022-10-13                                         <u><a href="../man3pm/Trees.3pm.html">Trees</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>