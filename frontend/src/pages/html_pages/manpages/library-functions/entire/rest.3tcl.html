<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rest - define REST web APIs and call them inline or asychronously</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rest - define REST web APIs and call them inline or asychronously

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>rest</b> <b>?1.7?</b>

       <b>::rest::simple</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::get</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::post</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::patch</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::head</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::put</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::delete</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::save</b> <u>name</u> <u>file</u>

       <b>::rest::describe</b> <u>name</u>

       <b>::rest::parameters</b> <u>url</u> ?<u>key</u>?

       <b>::rest::parse_opts</b> <u>static</u> <u>required</u> <u>optional</u> <u>words</u>

       <b>::rest::substitute</b> <u>string</u> <u>var</u>

       <b>::rest::create_interface</b> <u>name</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       There  are  two  types  of  usage  this  package  supports: <u>simple</u> <u>calls</u>, and complete <u>interfaces</u>.  In an
       <u>interface</u> you specify a set of rules and then the package builds the commands  which  correspond  to  the
       REST methods. These commands can have many options such as input and output transformations and data type
       specific  formatting.  This  results  in a cleaner and simpler script.  On the other hand, while a <u>simple</u>
       <u>call</u> is easier and quicker to implement it is also less featureful. It takes the url and  a  few  options
       about  the  command  and  returns  the  result  directly. Any formatting or checking is up to rest of the
       script.

</pre><h4><b>SIMPLE</b> <b>USAGE</b></h4><pre>
       In simple usage you make calls using the http method procedures and then check or  process  the  returned
       data yourself

       <b>::rest::simple</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::get</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::post</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::patch</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::head</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::put</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

       <b>::rest::delete</b> <u>url</u> <u>query</u> ?<u>config</u>? ?<u>body</u>?

              These  commands  are  all  equivalent except for the http method used.  If you use <b>simple</b> then the
              method should be specified as an option in the <u>config</u> dictionary. If that is not done it  defaults
              to  <b>get</b>.  If a <u>body</u> is needed then the <u>config</u> dictionary must be present, however it is allowed to
              be empty.

              The <u>config</u> dictionary supports the following keys

              <b>auth</b>

              <b>content-type</b>

              <b>cookie</b>

              <b>error-body</b>

              <b>format</b>

              <b>headers</b>

              <b>method</b>

              <b>timeout</b>

       Two quick examples:

       Example 1, Yahoo Boss:

                  set appid APPID
                  set search tcl
                  set res [rest::get <a href="http://boss.yahooapis.com/ysearch/web/v1/">http://boss.yahooapis.com/ysearch/web/v1/</a>$search [list appid $appid]]
                  set res [rest::format_json $res]

       Example 2, Twitter:

                  set url   <a href="http://twitter.com/statuses/update.json">http://twitter.com/statuses/update.json</a>
                  set query [list status $text]
                  set res [rest::simple $url $query {
                      method post
                      auth   {basic user password}
                      format json
                  }]

</pre><h4><b>INTERFACE</b> <b>USAGE</b></h4><pre>
       An interface to a REST API consists of a series of definitions of REST calls contained in an array.   The
       name  of  that array becomes a namespace containing the defined commands. Each key of the array specifies
       the name of the call, with  the  associated  configuration  a  dictionary,  i.e.  key/value  pairs.   The
       acceptable keys, i.e. legal configuration options are described below.  After creating the definitions in
       the  array  simply calling <b>rest::create_interface</b> with the array as argument will then create the desired
       commands.

       Example, Yahoo Weather:

                  package require rest

                  set yweather(forecast) {
                     url      <a href="http://weather.yahooapis.com/forecastrss">http://weather.yahooapis.com/forecastrss</a>
                     req_args { p: }
                     opt_args { u: }
                  }
                  rest::create_interface yweather
                  puts [yweather::forecast -p 94089]

       <b>::rest::save</b> <u>name</u> <u>file</u>
              This command saves a copy of the dynamically created procedures for all the API calls specified in
              the array variable <u>name</u> to the <u>file</u>, for later loading.

              The result of the command is the empty string

       <b>::rest::describe</b> <u>name</u>
              This command prints a description of all API calls specified in the array  variable  <u>name</u>  to  the
              channel <b>stdout</b>.

              The result of the command is the empty string.

       <b>::rest::parameters</b> <u>url</u> ?<u>key</u>?
              This  command  parses  an  <u>url</u>  query  string into a dictionary and returns said dictionary as its
              result.

              If <u>key</u> is specified the command will not return the entire dictionary, but only the value of  that
              <u>key</u>.

       <b>::rest::parse_opts</b> <u>static</u> <u>required</u> <u>optional</u> <u>words</u>
              This command implements a custom parserfor command options.

              dict <u>static</u>
                     A dictionary of options and their values that are always present in the output.

              list <u>required</u>
                     A list of options that must be supplied by <u>words</u>

              list <u>optional</u>
                     A list of options that may appear in the <u>words</u>, but are not required.  The elements must be
                     in one of three forms:

                     name   The option may be present or not, no default.

                     name:  When present the option requires an argument.

                     name:value
                            When not present use <b>value</b> as default.

              list <u>words</u>
                     The words to parse into options and values.

       The  result  of  the  command  is  a  list  containing  two  elements.  The first element is a dictionary
       containing the parsed options and their values.  The second element is a list of the remaining words.

       <b>::rest::substitute</b> <u>string</u> <u>var</u>
              This command takes a <u>string</u>, substitutes values  for  any  option  identifiers  found  inside  and
              returns the modified string as its results.

              The  values to substitute are found in the variable <u>var</u>, which is expected to contain a dictionary
              mapping from the option identifiers to replace to their  values.   <u>Note</u>  that  option  identifiers
              which have no key in <u>var</u> are replaced with the empty string.

              The  option  identifiers  in  <u>string</u>  have  to  follow  the syntax <b>%...%</b> where <b>...</b> may contain any
              combination of lower-case alphanumeric characters, plus underscore, colon and dash.

       <b>::rest::create_interface</b> <u>name</u>
              This command creates procedures for all the API calls specified in the array variable <u>name</u>.

              The name of that array becomes a namespace containing the defined commands. Each key of the  array
              specifies  the  name  of  the call, with the associated configuration a dictionary, i.e. key/value
              pairs.  The legal keys and their meanings are:

              <b>url</b>    The value of this <u>required</u> option must be the target of the http request.

              <b>description</b>
                     The value of this option must be a short string describing the call.  Default to the  empty
                     string, if not specified.  Used only by <b>::rest::describe</b>.

              <b>body</b>   The value of this option indicates if arguments are required for the call's request body or
                     not. The acceptable values are listed below.  Defaults to <b>optional</b> if not specified.

                     <b>none</b>   The call has no request body, none must be supplied.

                     <b>optional</b>
                            A request body can be supplied, but is not required.

                     <b>required</b>
                            A request body must be supplied.

                     <b>argument</b>
                            This  value must be followed by the name of an option, treating the entire string as
                            a list. The request body will be used as the value of that option.

                     <b>mime_multipart</b>
                            A  request  body  must  be  supplied  and  will  be  interpreted  as  each  argument
                            representing  one  part  of  a  mime/multipart  document.   Arguments  must be lists
                            containing 2 elements, a list of header keys and values, and the mime part body,  in
                            this order.

                     <b>mime_multipart/&lt;value&gt;</b>
                            Same as mime_multipart, but the <b>Content-Type</b> header is set to <b>multipart/&lt;value&gt;</b>.

              <b>method</b> The  value of this option must be the name of the HTTP method to call on the url.  Defaults
                     to GET, if not specified.  The acceptable values are <b>GET</b>,  <b>POST</b>,  and  <b>PUT</b>,  regardless  of
                     letter-case.

              <b>copy</b>   When  present the value of this option specifies the name of a previously defined call. The
                     definition of that call is copied to the current call, except for the options specified  by
                     the current call itself.

              <b>unset</b>  When present the value of this option contains a list of options in the current call. These
                     options  are  removed from the definition. Use this after <b>copy</b>ing an existing definition to
                     remove options, instead of overriding their value.

              <b>headers</b>
                     Specification of additional header fields. The value of this option must be  a  dictionary,
                     interpreted  to  contain  the new header fields and their values. The default is to not add
                     any additional headers.

              <b>content-type</b>
                     The value of this option specifies the content type for the request data.

              <b>req_args</b>
                     The value of this option is a list naming the required arguments of the call.  Names ending
                     in a colon will require a value.

              <b>opt_args</b>
                     The value of this option a list naming the arguments that may be present for a call but are
                     not required.

              <b>static_args</b>
                     The value of this option a list naming the arguments that are always the same.  No sense in
                     troubling the user with these.  A leading dash (<b>-</b>) is allowed but not required to  maintain
                     consistency with the command line.

              <b>auth</b>   The  value  of  this  option specifies how to authenticate the calls.  No authentication is
                     done if the option is not specified.

                     <b>basic</b>  The user  may  configure  the  <u>basic</u>  <u>authentication</u>  by  overriding  the  procedure
                            <b>basic_auth</b>  in  the  namespace of interface. This procedure takes two arguments, the
                            username and password, in this order.

                     <b>bearer</b> The user may configure a bearer token as authentication.  The  value  is  the  token
                            passed to the HTTP authorization header.

                     <b>sign</b>   The  value  must  actually be a list with the second element the name of a procedure
                            which will be called to perform request signing.

              <b>callback</b>
                     If this option is present then the method will be created as an <u>async</u> call. Such calls will
                     return immediately with the value of the  associated  http  token  instead  of  the  call's
                     result. The event loop must be active to use this option.

                     The value of this option is treated as a command prefix which is invoked when the HTTP call
                     is  complete.  The  prefix  will receive at least two additional arguments, the name of the
                     calling procedure and the status of the result (one of <b>OK</b> or <b>ERROR</b>), in this order.

                     In case of <b>OK</b> a third argument is added, the data associated with the result.

                     If and only if the <b>ERROR</b> is a redirection, the location redirected  to  will  be  added  as
                     argument.   Further, if the configuration key <b>error-body</b> is set to <b>true</b> the data associated
                     with the result will be added as argument as well.

                     The http request header will be available in that procedure via <b>upvar</b> <b>token</b> <b>token</b>.

              <b>cookie</b> The value of this option is a list of cookies to be passed in the http header.  This  is  a
                     shortcut to the <b>headers</b> option.

              <b>input_transform</b>
                     The  value  of this option is a command prefix or script to perform a transformation on the
                     query before invoking the call.  A  script  transform  is  wrapped  into  an  automatically
                     generated internal procedure.

                     If not specified no transformation is done.

                     The  command (prefix) must accept a single argument, the query (a dictionary) to transform,
                     and must return the modified query (again as dictionary) as its result.  The  request  body
                     is accessible in the transform command via <b>upvar</b> <b>body</b> <b>body</b>.

              <b>format</b>

              <b>result</b> The  value  of  this option specifies the format of the returned data.  Defaults to <b>auto</b> if
                     not specified.  The acceptable values are:

                     <b>auto</b>   Auto detect between <b>xml</b> and <b>json</b>.

                     <b>discard</b>

                     <b>json</b>

                     <b>raw</b>

                     <b>rss</b>    This is formatted as a special case of <b>xml</b>.

                     <b>tdom</b>

                     <b>xml</b>

              <b>pre_transform</b>
                     The value of this option is a command prefix or script to perform a transformation  on  the
                     result  of  a call (<u>before</u> the application of the output transform as per <b>format</b>). A script
                     transform is wrapped into an automatically generated internal procedure.

                     If not specified no transformation is done.

                     The command (prefix) must accept a single argument,  the  result  to  transform,  and  must
                     return the modified result as its result.

                     The http request header is accessible in the transform command via <b>upvar</b> <b>token</b> <b>token</b>

              <b>post_transform</b>
                     The  value  of this option is a command prefix or script to perform a transformation on the
                     result of a call (<u>after</u> the application of the output transform as per  <b>format</b>).  A  script
                     transform is wrapped into an automatically generated internal procedure.

                     If not specified no transformation is done.

                     The  command  (prefix)  must  accept  a  single argument, the result to transform, and must
                     return the modified result as its result.

                     The http request header is accessible in the transform command via <b>upvar</b> <b>token</b> <b>token</b>

              <b>check_result</b>
                     The value of this option must be list of two expressions, either of which may be empty.

                     The first expression is checks the OK condition, it must return <b>true</b>  when  the  result  is
                     satisfactory, and <b>false</b> otherwise.

                     The  second  expression  is  the  ERROR  condition, it must return <b>false</b> unless there is an
                     error, then it has to return <b>true</b>.

              <b>error_body</b>
                     The value of this option determines whether to return the  response  when  encountering  an
                     HTTP error, or not. The default is to not return the response body on error.

                     See <b>callback</b> above for more information.

              <b>timeout</b>
                     The  value of this option determines whether to set a timeout on the HTTP call. By default,
                     no timeout is set.

                     Timeout value is accepted in milliseconds.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Yahoo Geo:

              set ygeo(parse) {
                  url <a href="http://wherein.yahooapis.com/v1/document">http://wherein.yahooapis.com/v1/document</a>
                  method post
                  body { arg documentContent }
              }
              ygeo::parse "san jose ca"
              # "san jose ca" will be interpreted as if it were specified as the -documentContent option

       Google Docs:

              set gdocs(upload) {
                  url <a href="http://docs.google.com/feeds/default/private/full">http://docs.google.com/feeds/default/private/full</a>
                  body mime_multipart
              }
              gdocs::upload [list {Content-Type application/atom+xml} $xml] [list {Content-Type image/jpeg} $filedata]

       Delicious:

              set delicious(updated) {
                  url https://api.del.icio.us/v1/posts/update
                  auth basic
              }

              rest::create_interface flickr

              flickr::basic_auth username password

       Flickr:

              set flickr(auth.getToken) {
                 url <a href="http://api.flickr.com/services/rest/">http://api.flickr.com/services/rest/</a>
                 req_args { api_key: secret: }
                 auth { sign do_signature }
              }

              rest::create_interface flickr

              proc ::flickr::do_signature {query} {
                  # perform some operations on the query here
                  return $query
              }

</pre><h4><b>INCLUDED</b></h4><pre>
       The package provides functional but incomplete implementations for the following services:

       <b>del.icio.us</b>

       <b>facebook</b>

       <b>flickr</b>

       <b>twitter</b>

       <b>google</b> <b>calendar</b>

       <b>yahoo</b> <b>boss</b>

       <b>yahoo</b> <b>weather</b>

       Please either read the package's implementation,  or  use  <b>rest::describe</b>  after  loading  it  for  their
       details.

       Do not forget developers' documentation on the respective sites either.

</pre><h4><b>TLS</b></h4><pre>
       The  <b>rest</b>  package  can  be  used  with  <u>https</u>-secured  services,  by  requiring the <b>TLS</b> package and then
       registering it with the <b>http</b> package it is sitting on top of.  Example

                  package require tls
                  http::register https 443 ::tls::socket

</pre><h4><b>TLS</b> <b>SECURITY</b> <b>CONSIDERATIONS</b></h4><pre>
       This package uses the <b>TLS</b> package to handle the security for <b>https</b> urls and other socket connections.

       Policy decisions like the set of protocols to support and what ciphers to use are not the  responsibility
       of  <b>TLS</b>,  nor  of  this  package  itself  however.   Such  decisions  are the responsibility of whichever
       application is using the package, and are likely influenced by the set of servers  the  application  will
       talk to as well.

       For        example,        in        light        of        the        recent        <u>POODLE</u>        <u>attack</u>
       [<a href="http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html">http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html</a>]  discovered
       by  Google  many  servers  will  disable  support  for  the  SSLv3  protocol.   To handle this change the
       applications using <b>TLS</b> must be patched, and not this package, nor <b>TLS</b> itself.  Such a  patch  may  be  as
       simple as generally activating <b>tls1</b> support, as shown in the example below.

                  package require tls
                  tls::init -tls1 1 ;# forcibly activate support for the TLS1 protocol

                  ... your own application code ...

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>rest</u> of the <u>Tcllib</u> <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].   Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

tcllib                                                 1.7                                            <u><a href="../man3tcl/rest.3tcl.html">rest</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>