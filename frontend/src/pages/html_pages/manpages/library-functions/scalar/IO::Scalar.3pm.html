<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO::Scalar - IO:: interface for reading/writing a scalar</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-stringy-perl">libio-stringy-perl_2.113-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IO::Scalar - IO:: interface for reading/writing a scalar

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Perform I/O on strings, using the basic OO interface...

           use 5.005;
           use IO::Scalar;
           $data = "My message:\n";

           ### Open a handle on a string, and append to it:
           $SH = new IO::Scalar \$data;
           $SH-&gt;print("Hello");
           $SH-&gt;print(", world!\nBye now!\n");
           print "The string is now: ", $data, "\n";

           ### Open a handle on a string, read it line-by-line, then close it:
           $SH = new IO::Scalar \$data;
           while (defined($_ = $SH-&gt;getline)) {
               print "Got line: $_";
           }
           $SH-&gt;close;

           ### Open a handle on a string, and slurp in all the lines:
           $SH = new IO::Scalar \$data;
           print "All lines:\n", $SH-&gt;getlines;

           ### Get the current position (either of two ways):
           $pos = $SH-&gt;getpos;
           $offset = $SH-&gt;tell;

           ### Set the current position (either of two ways):
           $SH-&gt;setpos($pos);
           $SH-&gt;seek($offset, 0);

           ### Open an anonymous temporary scalar:
           $SH = new IO::Scalar;
           $SH-&gt;print("Hi there!");
           print "I printed: ", ${$SH-&gt;sref}, "\n";      ### get at value

       Don't like OO for your I/O?  No problem.  Thanks to the magic of an invisible <b>tie()</b>, the following now
       works out of the box, just as it does with IO::Handle:

           use 5.005;
           use IO::Scalar;
           $data = "My message:\n";

           ### Open a handle on a string, and append to it:
           $SH = new IO::Scalar \$data;
           print $SH "Hello";
           print $SH ", world!\nBye now!\n";
           print "The string is now: ", $data, "\n";

           ### Open a handle on a string, read it line-by-line, then close it:
           $SH = new IO::Scalar \$data;
           while (&lt;$SH&gt;) {
               print "Got line: $_";
           }
           close $SH;

           ### Open a handle on a string, and slurp in all the lines:
           $SH = new IO::Scalar \$data;
           print "All lines:\n", &lt;$SH&gt;;

           ### Get the current position (WARNING: requires 5.6):
           $offset = tell $SH;

           ### Set the current position (WARNING: requires 5.6):
           seek $SH, $offset, 0;

           ### Open an anonymous temporary scalar:
           $SH = new IO::Scalar;
           print $SH "Hi there!";
           print "I printed: ", ${$SH-&gt;sref}, "\n";      ### get at value

       And for you folks with 1.x code out there: the old <b>tie()</b> style still works, though this is <u>unnecessary</u>
       <u>and</u> <u>deprecated</u>:

           use IO::Scalar;

           ### Writing to a scalar...
           my $s;
           tie *OUT, 'IO::Scalar', \$s;
           print OUT "line 1\nline 2\n", "line 3\n";
           print "String is now: $s\n"

           ### Reading and writing an anonymous scalar...
           tie *OUT, 'IO::Scalar';
           print OUT "line 1\nline 2\n", "line 3\n";
           tied(OUT)-&gt;seek(0,0);
           while (&lt;OUT&gt;) {
               print "Got line: ", $_;
           }

       Stringification works, too!

           my $SH = new IO::Scalar \$data;
           print $SH "Hello, ";
           print $SH "world!";
           print "I printed: $SH\n";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class is part of the IO::Stringy distribution; see IO::Stringy for change log and general
       information.

       The IO::Scalar class implements objects which behave just like IO::Handle (or FileHandle) objects, except
       that you may use them to write to (or read from) scalars.  These handles are automatically "tiehandle"d
       (though please see "WARNINGS" for information relevant to your Perl version).

       Basically, this:

           my $s;
           $SH = new IO::Scalar \$s;
           $SH-&gt;print("Hel", "lo, ");         ### OO style
           $SH-&gt;print("world!\n");            ### ditto

       Or this:

           my $s;
           $SH = tie *OUT, 'IO::Scalar', \$s;
           print OUT "Hel", "lo, ";           ### non-OO style
           print OUT "world!\n";              ### ditto

       Causes $s to be set to:

           "Hello, world!\n"

</pre><h4><b>PUBLIC</b> <b>INTERFACE</b></h4><pre>
   <b>Construction</b>
       new [ARGS...]
           <u>Class</u>  <u>method.</u>   Return a new, unattached scalar handle.  If any arguments are given, they're sent to
           <b>open()</b>.

       open [SCALARREF]
           <u>Instance</u> <u>method.</u>  Open the scalar handle on a new scalar, pointed to by SCALARREF.  If  no  SCALARREF
           is given, a "private" scalar is created to hold the file data.

           Returns the self object on success, undefined on error.

       opened
           <u>Instance</u> <u>method.</u>  Is the scalar handle opened on something?

       close
           <u>Instance</u>  <u>method.</u>   Disassociate the scalar handle from its underlying scalar.  Done automatically on
           destroy.

   <b>Input</b> <b>and</b> <b>output</b>
       flush
           <u>Instance</u> <u>method.</u>  No-op, provided for OO compatibility.

       fileno
           <u>Instance</u> <u>method.</u>  No-op, returns undef

       getc
           <u>Instance</u> <u>method.</u>  Return the next character, or undef if none remain.

       getline
           <u>Instance</u> <u>method.</u>  Return the next line, or undef on end of string.  Can safely be called in an  array
           context.  Currently, lines are delimited by "\n".

       getlines
           <u>Instance</u>  <u>method.</u>   Get  all  remaining  lines.   It  will <b>croak()</b> if accidentally called in a scalar
           context.

       print ARGS...
           <u>Instance</u> <u>method.</u>  Print ARGS to the underlying scalar.

           <b>Warning:</b> this continues to always cause a seek to the end of the string, but if you  perform  <b>seek()</b>s
           and <b>tell()</b>s, it is still safer to explicitly seek-to-end before subsequent <b>print()</b>s.

       read BUF, NBYTES, [OFFSET]
           <u>Instance</u>  <u>method.</u>   Read some bytes from the scalar.  Returns the number of bytes actually read, 0 on
           end-of-file, undef on error.

       write BUF, NBYTES, [OFFSET]
           <u>Instance</u> <u>method.</u>  Write some bytes to the scalar.

       sysread BUF, LEN, [OFFSET]
           <u>Instance</u> <u>method.</u>  Read some bytes from the scalar.  Returns the number of bytes actually read,  0  on
           end-of-file, undef on error.

       syswrite BUF, NBYTES, [OFFSET]
           <u>Instance</u> <u>method.</u>  Write some bytes to the scalar.

   <b>Seeking/telling</b> <b>and</b> <b>other</b> <b>attributes</b>
       autoflush
           <u>Instance</u> <u>method.</u>  No-op, provided for OO compatibility.

       binmode
           <u>Instance</u> <u>method.</u>  No-op, provided for OO compatibility.

       clearerr
           <u>Instance</u> <u>method.</u>  Clear the error and EOF flags.  A no-op.

       eof <u>Instance</u> <u>method.</u>  Are we at end of file?

       seek OFFSET, WHENCE
           <u>Instance</u> <u>method.</u>  Seek to a given position in the stream.

       sysseek OFFSET, WHENCE
           <u>Instance</u> <u>method.</u> Identical to "seek OFFSET, WHENCE", <u>q.v.</u>

       tell
           <u>Instance</u> <u>method.</u>  Return the current position in the stream, as a numeric offset.

       setpos POS
           <u>Instance</u> <u>method.</u>  Set the current position, using the opaque value returned by getpos().

       getpos
           <u>Instance</u> <u>method.</u>  Return the current position in the string, as an opaque object.

       sref
           <u>Instance</u> <u>method.</u>  Return a reference to the underlying scalar.

</pre><h4><b>AUTHOR</b></h4><pre>
       Eryq (<u><a href="mailto:eryq@zeegee.com">eryq@zeegee.com</a></u>).  President, ZeeGee Software Inc (<u><a href="http://www.zeegee.com">http://www.zeegee.com</a></u>).

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Dianne Skoll (<u><a href="mailto:dfs@roaringpenguin.com">dfs@roaringpenguin.com</a></u>).

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 1997 Erik (Eryq) Dorfman, ZeeGee Software, Inc. All rights reserved.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.38.2                                       2024-07-31                                    <u>IO::<a href="../man3pm/Scalar.3pm.html">Scalar</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>