<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scalar::Util - A selection of general-utility scalar subroutines</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libscalar-list-utils-perl">libscalar-list-utils-perl_1.63-1build4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Scalar::Util - A selection of general-utility scalar subroutines

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                               tainted weaken isweak isvstring looks_like_number
                               set_prototype);
                               # and other useful utils appearing below

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Scalar::Util" contains a selection of subroutines that people have expressed would be nice to have in
       the perl core, but the usage would not really be high enough to warrant the use of a keyword, and the
       size would be so small that being individual extensions would be wasteful.

       By default "Scalar::Util" does not export any subroutines.

   <b>Core</b> <b>Perl</b> <b>"builtin"</b> <b>Functions</b>
       Many functions in this module have served as the inspiration for a new experimental facility in recent
       versions of Perl. From various development versions, starting at 5.35.7, equivalent functions to many of
       these utilities are available in the "builtin::" package.

           use Scalar::Util qw(blessed);

           $class = blessed $obj;

           $class = builtin::blessed $obj;  # equivalent

       For more information, see the documentation on builtin.

</pre><h4><b>FUNCTIONS</b> <b>FOR</b> <b>REFERENCES</b></h4><pre>
       The following functions all perform some useful activity on reference values.

   <b>blessed</b>
           my $pkg = blessed( $ref );

       If $ref is a blessed reference, the name of the package that it is blessed into is returned. Otherwise
       "undef" is returned.

           $scalar = "foo";
           $class  = blessed $scalar;           # undef

           $ref    = [];
           $class  = blessed $ref;              # undef

           $obj    = bless [], "Foo";
           $class  = blessed $obj;              # "Foo"

       Take care when using this function simply as a truth test (such as in "if(blessed $ref)...") because the
       package name "0" is defined yet false.

       <u>Since</u> <u>Perl</u> <u>version</u> <u>5.35.7</u> an equivalent function is available as "builtin::blessed".

   <b>refaddr</b>
           my $addr = refaddr( $ref );

       If $ref is reference, the internal memory address of the referenced value is returned as a plain integer.
       Otherwise "undef" is returned.

           $addr = refaddr "string";           # undef
           $addr = refaddr \$var;              # eg 12345678
           $addr = refaddr [];                 # eg 23456784

           $obj  = bless {}, "Foo";
           $addr = refaddr $obj;               # eg 88123488

       <u>Since</u> <u>Perl</u> <u>version</u> <u>5.35.7</u> an equivalent function is available as "builtin::refaddr".

   <b>reftype</b>
           my $type = reftype( $ref );

       If $ref is a reference, the basic Perl type of the variable referenced is returned as a plain string
       (such as "ARRAY" or "HASH"). Otherwise "undef" is returned.

           $type = reftype "string";           # undef
           $type = reftype \$var;              # SCALAR
           $type = reftype [];                 # ARRAY

           $obj  = bless {}, "Foo";
           $type = reftype $obj;               # HASH

       Note that for internal reasons, all precompiled regexps ("qr/.../") are blessed references; thus ref()
       returns the package name string "Regexp" on these but reftype() will return the underlying C structure
       type of "REGEXP" in all capitals.

       <u>Since</u> <u>Perl</u> <u>version</u> <u>5.35.7</u> an equivalent function is available as "builtin::reftype".

   <b>weaken</b>
           weaken( $ref );

       The lvalue $ref will be turned into a weak reference. This means that it will not hold a reference count
       on the object it references. Also, when the reference count on that object reaches zero, the reference
       will be set to undef. This function mutates the lvalue passed as its argument and returns no value.

       This is useful for keeping copies of references, but you don't want to prevent the object being DESTROY-
       ed at its usual time.

           {
             my $var;
             $ref = \$var;
             weaken($ref);                     # Make $ref a weak reference
           }
           # $ref is now undef

       Note that if you take a copy of a scalar with a weakened reference, the copy will be a strong reference.

           my $var;
           my $foo = \$var;
           weaken($foo);                       # Make $foo a weak reference
           my $bar = $foo;                     # $bar is now a strong reference

       This may be less obvious in other situations, such as grep(), for instance when grepping through a list
       of weakened references to objects that may have been destroyed already:

           @object = grep { defined } @object;

       This will indeed remove all references to destroyed objects, but the remaining references to objects will
       be strong, causing the remaining objects to never be destroyed because there is now always a strong
       reference to them in the @object array.

       <u>Since</u> <u>Perl</u> <u>version</u> <u>5.35.7</u> an equivalent function is available as "builtin::weaken".

   <b>unweaken</b>
           unweaken( $ref );

       <u>Since</u> <u>version</u> <u>1.36.</u>

       The lvalue "REF" will be turned from a weak reference back into a normal (strong) reference again. This
       function mutates the lvalue passed as its argument and returns no value. This undoes the action performed
       by "weaken".

       This function is slightly neater and more convenient than the otherwise-equivalent code

           my $tmp = $REF;
           undef $REF;
           $REF = $tmp;

       (because in particular, simply assigning a weak reference back to itself does not work to unweaken it;
       "$REF = $REF" does not work).

       <u>Since</u> <u>Perl</u> <u>version</u> <u>5.35.7</u> an equivalent function is available as "builtin::unweaken".

   <b>isweak</b>
           my $weak = isweak( $ref );

       Returns true if $ref is a weak reference.

           $ref  = \$foo;
           $weak = isweak($ref);               # false
           weaken($ref);
           $weak = isweak($ref);               # true

       <b>NOTE</b>: Copying a weak reference creates a normal, strong, reference.

           $copy = $ref;
           $weak = isweak($copy);              # false

       <u>Since</u> <u>Perl</u> <u>version</u> <u>5.35.7</u> an equivalent function is available as "builtin::is_weak".

</pre><h4><b>OTHER</b> <b>FUNCTIONS</b></h4><pre>
   <b>dualvar</b>
           my $var = dualvar( $num, $string );

       Returns a scalar that has the value $num in a numeric context and the value $string in a string context.

           $foo = dualvar 10, "Hello";
           $num = $foo + 2;                    # 12
           $str = $foo . " world";             # Hello world

   <b>isdual</b>
           my $dual = isdual( $var );

       <u>Since</u> <u>version</u> <u>1.26.</u>

       If $var is a scalar that has both numeric and string values, the result is true.

           $foo = dualvar 86, "Nix";
           $dual = isdual($foo);               # true

       Note that a scalar can be made to have both string and numeric content through standard operations:

           $foo = "10";
           $dual = isdual($foo);               # false
           $bar = $foo + 0;
           $dual = isdual($foo);               # true

       The $! variable is commonly dual-valued, though it is also magical in other ways:

           $! = 1;
           $dual = isdual($!);                 # true
           print("$!\n");                      # "Operation not permitted"

       <b>CAUTION</b>: This function is not as useful as it may seem. Dualvars are not a distinct concept in Perl, but
       a standard internal construct of all scalar values. Almost any value could be considered as a dualvar by
       this function through the course of normal operations.

   <b>isvstring</b>
           my $vstring = isvstring( $var );

       If $var is a scalar which was coded as a vstring, the result is true.

           $vs   = v49.46.48;
           $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
           printf($fmt,$vs);

   <b>looks_like_number</b>
           my $isnum = looks_like_number( $var );

       Returns true if perl thinks $var is a number. See "looks_like_number" in perlapi.

   <b>openhandle</b>
           my $fh = openhandle( $fh );

       Returns $fh itself, if $fh may be used as a filehandle and is open, or if it is a tied handle. Otherwise
       "undef" is returned.

           $fh = openhandle(*STDIN);           # \*STDIN
           $fh = openhandle(\*STDIN);          # \*STDIN
           $fh = openhandle(*NOTOPEN);         # undef
           $fh = openhandle("scalar");         # undef

   <b>readonly</b>
           my $ro = readonly( $var );

       Returns true if $var is readonly.

           sub foo { readonly($_[0]) }

           $readonly = foo($bar);              # false
           $readonly = <a href="../man0/foo.0.html">foo</a>(0);                 # true

   <b>set_prototype</b>
           my $code = set_prototype( $code, $prototype );

       Sets the prototype of the function given by the $code reference, or deletes it if $prototype is "undef".
       Returns the $code reference itself.

           set_prototype \&amp;foo, '$$';

   <b>tainted</b>
           my $t = tainted( $var );

       Return true if $var is tainted.

           $taint = tainted("constant");       # false
           $taint = tainted($ENV{PWD});        # true if running under -T

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Module use may give one of the following errors during import.

       Vstrings are not implemented in this version of perl
           The  version of perl that you are using does not implement Vstrings, to use "isvstring" you will need
           to use a newer release of perl.

</pre><h4><b>KNOWN</b> <b>BUGS</b></h4><pre>
       There is a bug in perl5.6.0 with UV's that are &gt;= 1&lt;&lt;31. This will show up as tests 8 and 9 of  dualvar.t
       failing

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       List::Util

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  (c)  1997-2007  Graham  Barr  &lt;<a href="mailto:gbarr@pobox.com">gbarr@pobox.com</a>&gt;.  All  rights  reserved.  This program is free
       software; you can redistribute it and/or modify it under the same terms as Perl itself.

       Additionally "weaken" and "isweak" which are

       Copyright (c) 1999 Tuomas J. Lukka &lt;<a href="mailto:lukka@iki.fi">lukka@iki.fi</a>&gt;. All rights reserved.  This program is  free  software;
       you can redistribute it and/or modify it under the same terms as perl itself.

       Copyright  (C)  2004, 2008  Matthijs van Duin.  All rights reserved.  Copyright (C) 2014 cPanel Inc.  All
       rights reserved.  This program is free software; you can redistribute it and/or modify it under the  same
       terms as Perl itself.

perl v5.40.0                                       2024-10-20                                  <u>Scalar::<a href="../man3pm/Util.3pm.html">Util</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>