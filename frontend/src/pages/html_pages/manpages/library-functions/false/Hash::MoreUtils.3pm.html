<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hash::MoreUtils - Provide the stuff missing in Hash::Util</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhash-moreutils-perl">libhash-moreutils-perl_0.06-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Hash::MoreUtils - Provide the stuff missing in Hash::Util

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Hash::MoreUtils qw(:all);

         my %h = (foo =&gt; "bar", FOO =&gt; "BAR", true =&gt; 1, false =&gt; 0);
         my %s = slice \%h, qw(true false); # (true =&gt; 1, false =&gt; 0)
         my %f = slice_false \%h; # (false =&gt; 0)
         my %u = slice_grep { $_ =~ m/^[A-Z]/ }, \%h; # (FOO =&gt; "BAR")

         my %r = safe_reverse \%h; # (bar =&gt; "foo", BAR =&gt; "FOO", 0 =&gt; "false", 1 =&gt; "true")

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Similar to List::MoreUtils, "Hash::MoreUtils" contains trivial but commonly-used functionality for
       hashes. The primary focus for the moment is providing a common API - speeding up by XS is far away at the
       moment.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>"slice"</b> <b>HASHREF[,</b> <b>LIST]</b>
       Returns a hash containing the (key, value) pair for every key in LIST.

       If no "LIST" is given, all keys are assumed as "LIST".

   <b>"slice_def"</b> <b>HASHREF[,</b> <b>LIST]</b>
       As "slice", but only includes keys whose values are defined.

       If no "LIST" is given, all keys are assumed as "LIST".

   <b>"slice_exists"</b> <b>HASHREF[,</b> <b>LIST]</b>
       As "slice" but only includes keys which exist in the hashref.

       If no "LIST" is given, all keys are assumed as "LIST".

   <b>"slice_without"</b> <b>HASHREF[,</b> <b>LIST</b> <b>]</b>
       As "slice" but without any (key/value) pair whose key is in LIST.

       If no "LIST" is given, in opposite to slice an empty list is assumed, thus nothing will be deleted.

   <b>"slice_missing"</b> <b>HASHREF[,</b> <b>LIST]</b>
       Returns a HASH containing the (key =&gt; undef) pair for every "LIST" element (as key) that does not exist
       hashref.

       If no "LIST" is given there are obviously no non-existent keys in "HASHREF" so the returned HASH is
       empty.

   <b>"slice_notdef"</b> <b>HASHREF[,</b> <b>LIST]</b>
       Searches for undefined slices with the given "LIST" elements as keys in the given "HASHREF".  Returns a
       "HASHREF" containing the slices (key -&gt; undef) for every undefined item.

       To search for undefined slices "slice_notdef" needs a "LIST" with items to search for (as keys). If no
       "LIST" is given it returns an empty "HASHREF" even when the given "HASHREF" contains undefined slices.

   <b>"slice_true"</b> <b>HASHREF[,</b> <b>LIST]</b>
       A special "slice_grep" which returns only those elements of the hash which's values evaluates to "TRUE".

       If no "LIST" is given, all keys are assumed as "LIST".

   <b>"slice_false"</b> <b>HASHREF[,</b> <b>LIST]</b>
       A special "slice_grep" which returns only those elements of the hash which's values evaluates to "FALSE".

       If no "LIST" is given, all keys are assumed as "LIST".

   <b>"slice_grep"</b> <b>BLOCK,</b> <b>HASHREF[,</b> <b>LIST]</b>
       As "slice", with an arbitrary condition.

       If no "LIST" is given, all keys are assumed as "LIST".

       Unlike "grep", the condition is not given aliases to elements of anything.  Instead, %_ is set to the
       contents of the hashref, to avoid accidentally auto-vivifying when checking keys or values.  Also,
       'uninitialized' warnings are turned off in the enclosing scope.

   <b>"slice_map"</b> <b>HASHREF[,</b> <b>MAP]</b>
       Returns a hash containing the (key, value) pair for every key in "MAP".

       If no "MAP" is given, all keys of "HASHREF" are assumed mapped to themselves.

   <b>"slice_def_map"</b> <b>HASHREF[,</b> <b>MAP]</b>
       As "slice_map", but only includes keys whose values are defined.

       If no "MAP" is given, all keys of "HASHREF" are assumed mapped to themselves.

   <b>"slice_exists_map"</b> <b>HASHREF[,</b> <b>MAP]</b>
       As "slice_map" but only includes keys which exist in the hashref.

       If no "MAP" is given, all keys of "HASHREF" are assumed mapped to themselves.

   <b>"slice_missing_map"</b> <b>HASHREF[,</b> <b>MAP]</b>
       As "slice_missing" but checks for missing keys (of "MAP") and map to the value (of "MAP") as key in the
       returned HASH.  The slices of the returned "HASHREF" are always undefined.

       If no "MAP" is given, "slice_missing" will be used on "HASHREF" which will return an empty HASH.

   <b>"slice_notdef_map"</b> <b>HASHREF[,</b> <b>MAP]</b>
       As "slice_notdef" but checks for undefined keys (of "MAP") and map to the value (of "MAP") as key in the
       returned HASH.

       If no "MAP" is given, "slice_notdef" will be used on "HASHREF" which will return an empty HASH.

   <b>"slice_true_map"</b> <b>HASHREF[,</b> <b>MAP]</b>
       As "slice_map", but only includes pairs whose values are "TRUE".

       If no "MAP" is given, all keys of "HASHREF" are assumed mapped to themselves.

   <b>"slice_false_map"</b> <b>HASHREF[,</b> <b>MAP]</b>
       As "slice_map", but only includes pairs whose values are "FALSE".

       If no "MAP" is given, all keys of "HASHREF" are assumed mapped to themselves.

   <b>"slice_grep_map"</b> <b>BLOCK,</b> <b>HASHREF[,</b> <b>MAP]</b>
       As "slice_map", with an arbitrary condition.

       If no "MAP" is given, all keys of "HASHREF" are assumed mapped to themselves.

       Unlike "grep", the condition is not given aliases to elements of anything.  Instead, %_ is set to the
       contents of the hashref, to avoid accidentally auto-vivifying when checking keys or values.  Also,
       'uninitialized' warnings are turned off in the enclosing scope.

   <b>"hashsort"</b> <b>[BLOCK,]</b> <b>HASHREF</b>
         my @array_of_pairs  = hashsort \%hash;
         my @pairs_by_length = hashsort sub { length($a) &lt;=&gt; length($b) }, \%hash;

       Returns the (key, value) pairs of the hash, sorted by some property of the keys.  By default (if no sort
       block given), sorts the keys with "cmp".

       I'm not convinced this is useful yet.  If you can think of some way it could be more so, please let me
       know.

   <b>"safe_reverse"</b> <b>[BLOCK,]</b> <b>HASHREF</b>
         my %dup_rev = safe_reverse \%hash

         sub croak_dup {
             my ($k, $v, $r) = @_;
             exists( $r-&gt;{$v} ) and
               croak "Cannot safe reverse: $v would be mapped to both $k and $r-&gt;{$v}";
             $v;
         };
         my %easy_rev = safe_reverse \&amp;croak_dup, \%hash

       Returns safely reversed hash (value, key pairs of original hash). If no "BLOCK" is given, following
       routine will be used:

         sub merge_dup {
             my ($k, $v, $r) = @_;
             return exists( $r-&gt;{$v} )
                    ? ( ref($r-&gt;{$v}) ? [ @{$r-&gt;{$v}}, $k ] : [ $r-&gt;{$v}, $k ] )
                    : $k;
         };

       The "BLOCK" will be called with 3 arguments:

       "key"   The key from the "( key, value )" pair in the original hash

       "value" The value from the "( key, value )" pair in the original hash

       "ref-hash"
               Reference to the reversed hash (read-only)

       The "BLOCK" is expected to return the value which will used for the resulting hash.

</pre><h4><b>AUTHOR</b></h4><pre>
       Hans Dieter Pearcey, "&lt;<a href="mailto:hdp@cpan.org">hdp@cpan.org</a>&gt;", Jens Rehsack, "&lt;<a href="mailto:rehsack@cpan.org">rehsack@cpan.org</a>&gt;"

</pre><h4><b>BUGS</b></h4><pre>
       Please  report  any  bugs  or  feature  requests  to "<a href="mailto:bug-hash-moreutils@rt.cpan.org">bug-hash-moreutils@rt.cpan.org</a>", or through the web
       interface at &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=Hash-MoreUtils&gt;.  I will  be  notified,  and
       then you'll automatically be notified of progress on your bug as I make changes.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc Hash::MoreUtils

       You can also look for information at:

       •   RT: CPAN's request tracker

           &lt;<a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=Hash-MoreUtils&gt;

       •   AnnoCPAN: Annotated CPAN documentation

           &lt;<a href="http://annocpan.org/dist/Hash-MoreUtils">http://annocpan.org/dist/Hash-MoreUtils</a>&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/Hash-MoreUtils">http://cpanratings.perl.org/d/Hash-MoreUtils</a>&gt;

       •   Search CPAN

           &lt;<a href="http://search.cpan.org/dist/Hash-MoreUtils/">http://search.cpan.org/dist/Hash-MoreUtils/</a>&gt;

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2005 Hans Dieter Pearcey, all rights reserved.  Copyright 2010-2018 Jens Rehsack

       This  program  is  free software; you can redistribute it and/or modify it under the terms of either: the
       GNU General Public License as published by the Free Software Foundation; or the Artistic License.

       See <a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a> for more information.

perl v5.36.0                                       2022-12-06                               <u>Hash::<a href="../man3pm/MoreUtils.3pm.html">MoreUtils</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>