<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>exec - Invoke subprocesses</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       exec - Invoke subprocesses

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>exec</b> ?<u>switches</u>? <u>arg</u> ?<u>arg</u> <u>...</u>? ?<b>&amp;</b>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  command  treats  its  arguments  as  the specification of one or more subprocesses to execute.  The
       arguments take the form of a standard shell pipeline where each <u>arg</u> becomes one word of  a  command,  and
       each  distinct  command  becomes  a  subprocess.  The result of the command is the standard output of the
       final subprocess in the pipeline, interpreted using the  system  <b>encoding</b>;  to  use  any  other  encoding
       (especially including binary data), the pipeline must be <b>open</b>ed, configured and read explicitly.

       If  the initial arguments to <b>exec</b> start with <b>-</b> then they are treated as command-line switches and are not
       part of the pipeline specification.  The following switches are currently supported:

       <b>-ignorestderr</b>
                    Stops the <b>exec</b> command from treating the output of messages to the pipeline's standard error
                    channel as an error case.

       <b>-keepnewline</b> Retains a trailing newline in the pipeline's output.  Normally a trailing  newline  will  be
                    deleted.

       <b>--</b>           Marks the end of switches.  The argument following this one will be treated as the first <u>arg</u>
                    even if it starts with a <b>-</b>.

       If  an  <u>arg</u> (or pair of <u>arg</u>s) has one of the forms described below then it is used by <b>exec</b> to control the
       flow of input  and  output  among  the  subprocess(es).   Such  arguments  will  not  be  passed  to  the
       subprocess(es).  In forms such as “<b>&lt;</b> <u>fileName</u>”, <u>fileName</u> may either be in a separate argument from “<b>&lt;</b>” or
       in the same argument with no intervening space (i.e.  “<b>&lt;</b><u>fileName</u>”).

       <b>|</b>              Separates distinct commands in the pipeline.  The standard output of the preceding command
                      will be piped into the standard input of the next command.

       <b>|&amp;</b>             Separates  distinct  commands in the pipeline.  Both standard output and standard error of
                      the preceding command will be piped into the standard input of  the  next  command.   This
                      form of redirection overrides forms such as 2&gt; and &gt;&amp;.

       <b>&lt;</b> <u>fileName</u>     The  file named by <u>fileName</u> is opened and used as the standard input for the first command
                      in the pipeline.

       <b>&lt;@</b> <u>fileId</u>      <u>FileId</u> must be the identifier for an open file, such as the return value from  a  previous
                      call  to  <b>open</b>.   It  is used as the standard input for the first command in the pipeline.
                      <u>FileId</u> must have been opened for reading.

       <b>&lt;&lt;</b> <u>value</u>       <u>Value</u> is passed to the first command as its standard input.

       <b>&gt;</b> <u>fileName</u>     Standard output  from  the  last  command  is  redirected  to  the  file  named  <u>fileName</u>,
                      overwriting its previous contents.

       <b>2&gt;</b> <u>fileName</u>    Standard error from all commands in the pipeline is redirected to the file named <u>fileName</u>,
                      overwriting its previous contents.

       <b>&gt;&amp;</b> <u>fileName</u>    Both  standard  output  from  the  last  command  and standard error from all commands are
                      redirected to the file named <u>fileName</u>, overwriting its previous contents.

       <b>&gt;&gt;</b> <u>fileName</u>    Standard output from the last command is redirected to the file named <u>fileName</u>,  appending
                      to it rather than overwriting it.

       <b>2&gt;&gt;</b> <u>fileName</u>   Standard error from all commands in the pipeline is redirected to the file named <u>fileName</u>,
                      appending to it rather than overwriting it.

       <b>&gt;&gt;&amp;</b> <u>fileName</u>   Both  standard  output  from  the  last  command  and standard error from all commands are
                      redirected to the file named <u>fileName</u>, appending to it rather than overwriting it.

       <b>&gt;@</b> <u>fileId</u>      <u>FileId</u> must be the identifier for an open file, such as the return value from  a  previous
                      call to <b>open</b>.  Standard output from the last command is redirected to <u>fileId</u>'s file, which
                      must have been opened for writing.

       <b>2&gt;@</b> <u>fileId</u>     <u>FileId</u>  must  be the identifier for an open file, such as the return value from a previous
                      call to <b>open</b>.  Standard error from all commands in the pipeline is redirected to  <u>fileId</u>'s
                      file.  The file must have been opened for writing.

       <b>2&gt;@1</b>           Standard  error  from  all  commands  in the pipeline is redirected to the command result.
                      This operator is only valid at the end of the command pipeline.

       <b>&gt;&amp;@</b> <u>fileId</u>     <u>FileId</u> must be the identifier for an open file, such as the return value from  a  previous
                      call  to  <b>open</b>.   Both  standard  output from the last command and standard error from all
                      commands are redirected to <u>fileId</u>'s file.  The file must have been opened for writing.

       If standard output has not been redirected then the <b>exec</b> command returns the  standard  output  from  the
       last  command  in  the pipeline, unless “2&gt;@1” was specified, in which case standard error is included as
       well.  If any of the commands in the pipeline exit abnormally or are killed or suspended, then <b>exec</b>  will
       return  an  error  and  the  error  message will include the pipeline's output followed by error messages
       describing the abnormal terminations; the <b>-errorcode</b> return option will  contain  additional  information
       about  the  last  abnormal  termination encountered.  If any of the commands writes to its standard error
       file and that standard error is not redirected and <b>-ignorestderr</b> is not specified, then <b>exec</b> will  return
       an  error;   the  error  message  will include the pipeline's standard output, followed by messages about
       abnormal terminations (if any), followed by the standard error output.

       If the last character of the result or error message is a newline then that character is normally deleted
       from the result or error message.  This is consistent with other Tcl return values, which do not normally
       end with newlines.  However, if <b>-keepnewline</b> is specified then the trailing newline is retained.

       If standard input is not redirected with “&lt;”, “&lt;&lt;” or “&lt;@” then the standard input for the first  command
       in the pipeline is taken from the application's current standard input.

       If  the  last <u>arg</u> is “&amp;” then the pipeline will be executed in background.  In this case the <b>exec</b> command
       will return a list whose elements are the  process  identifiers  for  all  of  the  subprocesses  in  the
       pipeline.   The  standard  output  from  the  last  command  in the pipeline will go to the application's
       standard output if it has not been redirected, and error output from all of the commands in the  pipeline
       will go to the application's standard error file unless redirected.

       The  first  word in each command is taken as the command name; if the result contains no slashes then the
       directories in the PATH environment variable are searched for an executable by the given  name.   If  the
       name  contains  a  slash  then  it  must refer to an executable reachable from the current directory.  No
       “glob” expansion or other shell-like substitutions are performed on the arguments to commands.

</pre><h4><b>PORTABILITY</b> <b>ISSUES</b></h4><pre>
       <b>Windows</b> (all versions)
              Reading from or writing to a socket, using the “<b>@</b> <u>fileId</u>” notation, does not work.   When  reading
              from a socket, a 16-bit DOS application will hang and a 32-bit application will return immediately
              with  end-of-file.  When either type of application writes to a socket, the information is instead
              sent to the console, if one is present, or is discarded.

              Note that the current escape resp. quoting of arguments for windows works  only  with  executables
              using  CommandLineToArgv,  CRT-library  or  similar,  as  well  as  with  the  windows batch files
              (excepting the newline, see below).  Although it is the common escape algorithm, but, in fact, the
              way how the executable parses  the  command-line  (resp.  splits  it  into  single  arguments)  is
              decisive.

              Unfortunately,  there  is  currently  no way to supply newline character within an argument to the
              batch files (<b>.cmd</b> or <b>.bat</b>)  or  to  the  command  processor  (<b>cmd.exe</b>  <b>/c</b>),  because  this  causes
              truncation of command-line (also the argument chain) on the first newline character.  But it works
              properly with an executable (using CommandLineToArgv, etc).

              <b>Argument</b> <b>quoting</b>
                     The  arguments  of  the  <b>exec</b>  command  are  mapped to the arguments of the called program.
                     Additional quote characters (<b>"</b>) are automatically   added  around  arguments  if  expected.
                     Special characters are escaped by inserting backslash characters.

                     The  MS-Windows  environment  does  execute  programs mentioned in the arguments and called
                     batch  files  (conspec)  replace  environment  variables,  which  may  have  side   effects
                     (vulnerabilities)  or  break  any already existing quoting (for example, if the environment
                     variable contains a special character like a <b>"</b>).  Examples are:
                            % exec my-echo.cmd {test&amp;whoami}
                              test
                              mylogin
                            % exec my-echo.cmd "ENV X:%X%"
                              ENV X: CONTENT OF X
                     The following  formatting  is  automatically  performed  on  any  argument  item  to  avoid
                     subprogram  execution: Any special character argument containing a special character (<b>&amp;</b>, <b>|</b>,
                     <b>^</b>, <b>&lt;</b>, <b>&gt;</b>, <b>!</b>, <b>(</b>, <b>)</b>, <b>(</b>, <b>%</b>) is automatically enclosed in quotes (<b>"</b>). Any data quote is  escaped
                     by insertion of backslash characters.

                     The  automatic  resolving  of environment variables using "<b>%var%</b>" is critical, but has more
                     use than danger and is not escaped.

              The Tk console text widget does not  provide  real  standard  IO  capabilities.   Under  Tk,  when
              redirecting  from  standard input, all applications will see an immediate end-of-file; information
              redirected to standard output or standard error will be discarded.

              Either forward or backward slashes are accepted as path separators for arguments to Tcl  commands.
              When  executing  an  application,  the  path  name  specified for the application may also contain
              forward or backward slashes as  path  separators.   Bear  in  mind,  however,  that  most  Windows
              applications  accept arguments with forward slashes only as option delimiters and backslashes only
              in paths.  Any arguments to an application that specify a path name with forward slashes will  not
              automatically  be  converted  to  use  the  backslash  character.  If an argument contains forward
              slashes as the path separator, it may or may not be recognized as a path name,  depending  on  the
              program.

              Two  or more forward or backward slashes in a row in a path refer to a network path.  For example,
              a simple concatenation of the root directory <b>c:/</b> with a subdirectory  <b>/windows/system</b>  will  yield
              <b>c://windows/system</b>  (two  slashes  together), which refers to the mount point called <b>system</b> on the
              machine called <b>windows</b> (and the <b>c:/</b> is ignored), and is not equivalent to <b>c:/windows/system</b>, which
              describes a directory on  the  current  computer.   The  <b>file</b>  <b>join</b>  command  should  be  used  to
              concatenate path components.

              Note that there are two general types of Win32 console applications:

                     [1]    CLI — CommandLine Interface, simple stdio exchange. <b>netstat.exe</b> for example.

                     [2]    TUI  —  Textmode  User  Interface, any application that accesses the console API for
                            doing such things as cursor movement, setting text color, detecting key presses  and
                            mouse movement, etc.  An example would be <b>telnet.exe</b> from Windows 2000.  These types
                            of applications are not common in a windows environment, but do exist.

              <b>exec</b>  will  not  work  well  with  TUI applications when a console is not present, as is done when
              launching applications under wish.  It is  desirable  to  have  console  applications  hidden  and
              detached.   This  is a designed-in limitation as <b>exec</b> wants to communicate over pipes.  The Expect
              extension addresses this issue when communicating with a TUI application.

              When attempting to execute an application, <b>exec</b> first searches for the name as it  was  specified.
              Then,  in  order,  <b>.com</b>,  <b>.exe</b>, <b>.bat</b> and <b>.cmd</b> are appended to the end of the specified name and it
              searches for the longer name.  If a directory name was not specified as part  of  the  application
              name,  the following directories are automatically searched in order when attempting to locate the
              application:

              •  The directory from which the Tcl executable was loaded.

              •  The current directory.

              •  The Windows 32-bit system directory.

              •  The Windows home directory.

              •  The directories listed in the path.

              In order to execute shell built-in commands like <b>dir</b> and <b>copy</b>, the caller must prepend the desired
              command with “<b>cmd.exe</b> <b>/c</b> ” because built-in commands are not implemented using executables.

       <b>Unix</b> (including macOS)
              The <b>exec</b> command is fully functional and works as described.

</pre><h4><b>UNIX</b> <b>EXAMPLES</b></h4><pre>
       Here are some examples of the use of the <b>exec</b> command on Unix.  To execute a simple program and  get  its
       result:

              <b>exec</b> uname -a

   <b>WORKING</b> <b>WITH</b> <b>NON-ZERO</b> <b>RESULTS</b>
       To  execute  a  program  that can return a non-zero result, you should wrap the call to <b>exec</b> in <b>catch</b> and
       check the contents of the <b>-errorcode</b> return option if you have an error:

              set status 0
              if {[catch {<b>exec</b> grep foo bar.txt} results options]} {
                  set details [dict get $options -errorcode]
                  if {[lindex $details 0] eq "CHILDSTATUS"} {
                      set status [lindex $details 2]
                  } else {
                      # Some other error; regenerate it to let caller handle
                      return -options $options -level 0 $results
                  }
              }

       This is more easily written using the <b>try</b> command, as that makes it simpler to  trap  specific  types  of
       errors. This is done using code like this:

              try {
                  set results [<b>exec</b> grep foo bar.txt]
                  set status 0
              } trap CHILDSTATUS {results options} {
                  set status [lindex [dict get $options -errorcode] 2]
              }

   <b>WORKING</b> <b>WITH</b> <b>QUOTED</b> <b>ARGUMENTS</b>
       When  translating  a command from a Unix shell invocation, care should be taken over the fact that single
       quote characters have no special significance to Tcl.  Thus:

              awk '{sum += $1} END {print sum}' numbers.list

       would be translated into something like:

              <b>exec</b> awk {{sum += $1} END {print sum}} numbers.list

   <b>WORKING</b> <b>WITH</b> <b>GLOBBING</b>
       If you are converting invocations involving shell globbing, you should remember that Tcl does not  handle
       globbing or expand things into multiple arguments by default.  Instead you should write things like this:

              <b>exec</b> ls -l {*}[glob *.tcl]

   <b>WORKING</b> <b>WITH</b> <b>USER-SUPPLIED</b> <b>SHELL</b> <b>SCRIPT</b> <b>FRAGMENTS</b>
       One  useful  technique  can  be to expose to users of a script the ability to specify a fragment of shell
       script to execute that will have some data passed in on standard input  that  was  produced  by  the  Tcl
       program.   This  is a common technique for using the <u>lpr</u> program for printing. By far the simplest way of
       doing this is to pass the user's script to the user's shell for processing,  as  this  avoids  a  lot  of
       complexity with parsing other languages.

              set lprScript [<u>get</u> <u>from</u> <u>user...</u>]
              set postscriptData [<u>generate</u> <u>somehow...</u>]

              <b>exec</b> $env(SHELL) -c $lprScript &lt;&lt; $postscriptData

</pre><h4><b>WINDOWS</b> <b>EXAMPLES</b></h4><pre>
       Here  are  some  examples  of  the  use  of the <b>exec</b> command on Windows.  To start an instance of <u>notepad</u>
       editing a file without waiting for the user to finish editing the file:

              <b>exec</b> notepad myfile.txt &amp;

       To print a text file using <u>notepad</u>:

              <b>exec</b> notepad /p myfile.txt

   <b>WORKING</b> <b>WITH</b> <b>CONSOLE</b> <b>PROGRAMS</b>
       If a program calls other programs, such as is common with compilers, then you may need to resort to batch
       files to hide the console windows that sometimes pop up:

              <b>exec</b> cmp.bat somefile.c -o somefile

       With the file <u>cmp.bat</u> looking something like:

              @gcc %*

       or like another variant using single parameters:

              @gcc %1 %2 %3 %4 %5 %6 %7 %8 %9

   <b>WORKING</b> <b>WITH</b> <b>COMMAND</b> <b>BUILT-INS</b>
       Sometimes you need to be careful, as different programs may have the same name and be in the path. It can
       then happen that typing a command at the DOS prompt finds <u>a</u> <u>different</u> <u>program</u> than the same  command  run
       via <b>exec</b>. This is because of the (documented) differences in behaviour between <b>exec</b> and DOS batch files.

       When  in  doubt,  use the command <b>auto_execok</b>: it will return the complete path to the program as seen by
       the <b>exec</b> command.  This applies especially when you want to run “internal” commands like <u>dir</u> from  a  Tcl
       script (if you just want to list filenames, use the <b>glob</b> command.)  To do that, use this:

              <b>exec</b> {*}[auto_execok dir] *.tcl

   <b>WORKING</b> <b>WITH</b> <b>NATIVE</b> <b>FILENAMES</b>
       Many  programs  on  Windows  require  filename  arguments  to  be  passed in with backslashes as pathname
       separators. This is done with the help of the <b>file</b> <b>nativename</b> command. For example, to make  a  directory
       (on  NTFS) encrypted so that only the current user can access it requires use of the <u>CIPHER</u> command, like
       this:

              set secureDir [file join [file home] Desktop/SecureDirectory]
              file mkdir $secureDir
              <b>exec</b> CIPHER /e /s:[file nativename $secureDir]

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/error.3tcl.html">error</a>(3tcl), <a href="../man3tcl/file.3tcl.html">file</a>(3tcl), <a href="../man3tcl/open.3tcl.html">open</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       execute, pipeline, redirection, subprocess

Tcl                                                    8.5                                            <u><a href="../man3tcl/exec.3tcl.html">exec</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>