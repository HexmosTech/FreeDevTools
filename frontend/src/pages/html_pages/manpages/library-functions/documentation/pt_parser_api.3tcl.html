<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt_parser_api - Parser API</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt_parser_api - Parser API

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       <b>className</b> ?<u>objectName</u>?

       <u>objectName</u> <b>destroy</b>

       <u>objectName</u> <b>parse</b> <u>chan</u>

       <u>objectName</u> <b>parset</b> <u>text</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       This document describes the API shared by the grammar interpreter provided by the package <b>pt::peg::interp</b>
       and  the  parsers  generated  by the <b>pt</b> application for the result formats <b>critcl</b>, <b>snit</b>, and <b>oo</b> regarding
       access to the actual parsing functionality.

       Its intended audience are people who wish to create a parser for some language of  theirs  and  then  use
       that parser within a Tcl-based package or application.

       It resides in the User Layer of Parser Tools.

       IMAGE: arch_user_pkg

</pre><h4><b>CLASS</b> <b>API</b></h4><pre>
       <b>className</b> ?<u>objectName</u>?
              The  class  command  constructs  parser  instances, i.e. objects. The result of the command is the
              fully-qualified name of the instance command.

              If no <u>objectName</u> is specified the class will generate and use an automatic name. If the <u>objectName</u>
              was specified, but is not fully qualified the command will be created in the current namespace.

</pre><h4><b>INSTANCE</b> <b>API</b></h4><pre>
       All parser instances provide at least the methods shown below:

       <u>objectName</u> <b>destroy</b>
              This method destroys the parser instance, releasing all claimed memory and  other  resources,  and
              deleting the instance command.

              The result of the command is the empty string.

       <u>objectName</u> <b>parse</b> <u>chan</u>
              This  method runs the parser using the contents of <u>chan</u> as input (starting at the current location
              in the channel), until parsing is not possible anymore, either because parsing has  completed,  or
              run into a syntax error.

              Note here that the Parser Tools are based on Tcl 8.5+. In other words, the channel argument is not
              restricted to files, sockets, etc. We have the full power of <u>reflected</u> <u>channels</u> available.

              It  should  also  be  noted that the parser pulls the characters from the input stream as it needs
              them. If a parser created by this package has to be operated in a push aka event-driven manner  it
              will  be necessary to go to Tcl 8.6+ and use the <b>coroutine::auto</b> to wrap it into a coroutine where
              <b>read</b> is properly changed for push-operation.

              Upon successful completion the command returns an abstract syntax tree as its result.  This AST is
              in the form specified in section <b>AST</b> <b>serialization</b> <b>format</b>.  As a plain nested Tcl-list it can then
              be processed with any Tcl commands the user likes, doing transformations,  semantic  checks,  etc.
              To  help  in this the package <b>pt::ast</b> provides a set of convenience commands for validation of the
              tree's basic structure, printing it for debugging, and walking it either from the  bottom  up,  or
              top down.

              When  encountering  a  syntax error the command will throw an error instead.  This error will be a
              4-element Tcl-list, containing, in the order listed below:

              [1]    The string <b>pt::rde</b> identifying it as parser runtime error.

              [2]    The location of the parse error, as character offset  from  the  beginning  of  the  parsed
                     input.

              [3]    The  location  of parse error, now as a 2-element list containing line-number and column in
                     the line.

              [4]    A set of atomic parsing expressions indicating encoding the characters  and/or  nonterminal
                     symbols  the  parser  expected  to see at the location of the parse error, but did not get.
                     For the specification of atomic parsing expressions please see the section <b>PE</b> <b>serialization</b>
                     <b>format</b>.

       <u>objectName</u> <b>parset</b> <u>text</u>
              This method runs the parser using the string in <u>text</u> as input.  In all other ways it behaves  like
              the method <b>parse</b>, shown above.

</pre><h4><b>USAGE</b></h4><pre>
       A generated parser is used like this

                  package require the-parser-package ;# Generated by result-formats 'critcl', 'snit' or 'oo' of 'pt'.
                  set parser [the-parser-class]

                  set ast [$parser parse $channel]
                  ... process the abstract syntax tree ...

       When using a grammar interpreter for parsing some differences creep in

                  package require the-grammar-package ;# Generated by result-format 'container' of 'pt'.
                  set grammar [the-grammar-class]

                  package require pt::peg::interp
                  set parser [pt::peg::interp]

                  $parser use $grammar

                  set ast [$parser parse $channel]
                  $parser destroy

                  ... process the abstract syntax tree ...

</pre><h4><b>AST</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here  we  specify  the  format  used  by  the  Parser  Tools to serialize Abstract Syntax Trees (ASTs) as
       immutable values for transport, comparison, etc.

       Each node in an AST represents a nonterminal symbol of a grammar, and the range of  tokens/characters  in
       the  input  covered  by  it.  ASTs  do not contain terminal symbols, i.e. tokens/characters. These can be
       recovered from the input given a symbol's location.

       We distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a tree may have more than one regular
       serialization only exactly one of them will be <u>canonical</u>.

       Regular serialization

              [1]    The serialization of any AST is the serialization of its root node.

              [2]    The serialization of any node is a Tcl list containing at least three elements.

                     [1]    The first element is the name of the nonterminal symbol stored in the node.

                     [2]    The second and third element are the locations of the first and last  token  in  the
                            token stream the node represents (covers).

                            [1]    Locations  are provided as non-negative integer offsets from the beginning of
                                   the token stream, with the first token found in the stream located at  offset
                                   0 (zero).

                            [2]    The end location has to be equal to or larger than the start location.

                     [3]    All  elements  after  the  first three represent the children of the node, which are
                            themselves nodes. This means that the serializations of nodes without children, i.e.
                            leaf nodes, have exactly three elements.  The children are stored in the  list  with
                            the leftmost child first, and the rightmost child last.

       Canonical serialization
              The canonical serialization of an abstract syntax tree has the format as specified in the previous
              item,  and  then  additionally satisfies the constraints below, which make it unique among all the
              possible serializations of this tree.

              [1]    The string representation of the value is the canonical representation of a pure Tcl  list.
                     I.e. it does not contain superfluous whitespace.

   <b>EXAMPLE</b>
       Assuming the parsing expression grammar below

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       and the input string

               120+5
       then a parser should deliver the abstract syntax tree below (except for whitespace)

              set ast {Expression 0 4
                  {Factor 0 4
                      {Term 0 2
                          {Number 0 2
                              {Digit 0 0}
                              {Digit 1 1}
                              {Digit 2 2}
                          }
                      }
                      {AddOp 3 3}
                      {Term 4 4
                          {Number 4 4
                              {Digit 4 4}
                          }
                      }
                  }
              }

       Or, more graphical

       .nf  +-  Digit  0  0  |  1  |             |  +-  Term  0  2  ---  Number  0  2  -+-  Digit  1  1  |  2  |
       |            | |                           +- Digit 2 2 |  0  |                                         |
       Expression    0    4   ---   Factor   0   4   -+-----------------------------   AddOp   3   3   |   +   |
       | +- Term 4 4 --- Number 4 4 --- Digit 4 4 | 5 .fi

</pre><h4><b>PE</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here we specify the format used by the Parser Tools to serialize Parsing Expressions as immutable  values
       for transport, comparison, etc.

       We  distinguish  between  <u>regular</u> and <u>canonical</u> serializations.  While a parsing expression may have more
       than one regular serialization only exactly one of them will be <u>canonical</u>.

       Regular serialization

              <b>Atomic</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    The string <b>epsilon</b> is an atomic parsing expression. It matches the empty string.

                     [2]    The string <b>dot</b> is an atomic parsing expression. It matches any character.

                     [3]    The string <b>alnum</b> is an atomic parsing expression. It matches any Unicode alphabet or
                            digit character. This is a custom extension of PEs based on  Tcl's  builtin  command
                            <b>string</b> <b>is</b>.

                     [4]    The  string  <b>alpha</b>  is an atomic parsing expression. It matches any Unicode alphabet
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [5]    The  string  <b>ascii</b> is an atomic parsing expression. It matches any Unicode character
                            below U0080. This is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [6]    The string <b>control</b> is an atomic parsing expression. It matches any  Unicode  control
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [7]    The string <b>digit</b> is an atomic parsing  expression.  It  matches  any  Unicode  digit
                            character. Note that this includes characters outside of the [0..9] range. This is a
                            custom extension of PEs based on Tcl's builtin command <b>string</b> <b>is</b>.

                     [8]    The  string  <b>graph</b>  is an atomic parsing expression. It matches any Unicode printing
                            character, except for space. This is a  custom  extension  of  PEs  based  on  Tcl's
                            builtin command <b>string</b> <b>is</b>.

                     [9]    The  string <b>lower</b> is an atomic parsing expression. It matches any Unicode lower-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [10]   The string <b>print</b> is an atomic parsing expression. It matches  any  Unicode  printing
                            character, including space. This is a custom extension of PEs based on Tcl's builtin
                            command <b>string</b> <b>is</b>.

                     [11]   The string <b>punct</b> is an atomic parsing expression. It matches any Unicode punctuation
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [12]   The string <b>space</b> is an atomic parsing  expression.  It  matches  any  Unicode  space
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [13]   The string <b>upper</b> is an atomic parsing expression. It matches any Unicode  upper-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [14]   The  string  <b>wordchar</b>  is  an atomic parsing expression. It matches any Unicode word
                            character. This is  any  alphanumeric  character  (see  alnum),  and  any  connector
                            punctuation  characters  (e.g.  underscore). This is a custom extension of PEs based
                            on Tcl's builtin command <b>string</b> <b>is</b>.

                     [15]   The string <b>xdigit</b> is an atomic parsing expression. It matches any hexadecimal  digit
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [16]   The string <b>ddigit</b> is an atomic parsing expression.  It  matches  any  decimal  digit
                            character. This is a custom extension of PEs based on Tcl's builtin command <b>regexp</b>.

                     [17]   The  expression  [list t <b>x</b>] is an atomic parsing expression. It matches the terminal
                            string <b>x</b>.

                     [18]   The expression  [list  n  <b>A</b>]  is  an  atomic  parsing  expression.  It  matches  the
                            nonterminal <b>A</b>.

              <b>Combined</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    For  parsing  expressions <b>e1</b>, <b>e2</b>, ... the result of [list / <b>e1</b> <b>e2</b> ... ] is a parsing
                            expression as well.  This is the <u>ordered</u> <u>choice</u>, aka <u>prioritized</u> <u>choice</u>.

                     [2]    For parsing expressions <b>e1</b>, <b>e2</b>, ... the result of [list x <b>e1</b> <b>e2</b> ... ] is  a  parsing
                            expression as well.  This is the <u>sequence</u>.

                     [3]    For a parsing expression <b>e</b> the result of [list * <b>e</b>] is a parsing expression as well.
                            This is the <u>kleene</u> <u>closure</u>, describing zero or more repetitions.

                     [4]    For a parsing expression <b>e</b> the result of [list + <b>e</b>] is a parsing expression as well.
                            This is the <u>positive</u> <u>kleene</u> <u>closure</u>, describing one or more repetitions.

                     [5]    For a parsing expression <b>e</b> the result of [list &amp; <b>e</b>] is a parsing expression as well.
                            This is the <u>and</u> <u>lookahead</u> <u>predicate</u>.

                     [6]    For a parsing expression <b>e</b> the result of [list ! <b>e</b>] is a parsing expression as well.
                            This is the <u>not</u> <u>lookahead</u> <u>predicate</u>.

                     [7]    For a parsing expression <b>e</b> the result of [list ? <b>e</b>] is a parsing expression as well.
                            This is the <u>optional</u> <u>input</u>.

       Canonical serialization
              The  canonical  serialization  of a parsing expression has the format as specified in the previous
              item, and then additionally satisfies the constraints below, which make it unique  among  all  the
              possible serializations of this parsing expression.

              [1]    The  string representation of the value is the canonical representation of a pure Tcl list.
                     I.e. it does not contain superfluous whitespace.

              [2]    Terminals are <u>not</u> encoded as ranges (where start and end of the range are identical).

   <b>EXAMPLE</b>
       Assuming the parsing expression shown on the right-hand side of the rule

                  Expression &lt;- Term (AddOp Term)*

       then its canonical serialization (except for whitespace) is

                  {x {n Term} {* {x {n AddOp} {n Term}}}}

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>pt</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,  LL(k),  PEG,  TDPL,  context-free  languages,  expression,  grammar,  matching,  parser,   parsing
       expression,  parsing  expression grammar, push down automaton, recursive descent, state, top-down parsing
       languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.1                                   <u><a href="../man3tcl/pt_parser_api.3tcl.html">pt_parser_api</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>