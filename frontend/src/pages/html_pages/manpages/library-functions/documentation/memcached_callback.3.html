<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>memcached_callback - libmemcached Documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmemcached-dev">libmemcached-dev_1.1.4-1.1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       memcached_callback - libmemcached Documentation

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;libmemcached/memcached.h&gt;</b>
              Compile and link with -lmemcached

       <u>memcached_return_t</u> <b>memcached_callback_set(</b><u>memcached_st</u> <b>*ptr,</b> <u>memcached_callback_t</u> <b>flag,</b> <b>const</b> <b>void</b> <b>*data)</b>

              <b>Parameters</b>

                     • <b>ptr</b> -- pointer to initialized <u>memcached_st</u> struct

                     • <b>flag</b> -- <u>memcached_callback_t</u> flag to set

                     • <b>data</b> -- data corresponding to <u>flag</u>

              <b>Returns</b>
                     <u>memcached_return_t</u> indicating success

       <b>void</b> <b>*memcached_callback_get(</b><u>memcached_st</u> <b>*ptr,</b> <u>memcached_callback_t</u> <b>flag,</b> <u>memcached_return_t</u> <b>*error)</b>

              <b>Parameters</b>

                     • <b>ptr</b> -- pointer to initialized <u>memcached_st</u> struct

                     • <b>flag</b> -- <u>memcached_callback_t</u> flag to query

                     • <b>error</b> -- pointer to <u>memcached_return_t</u> indicating success

              <b>Returns</b>
                     the <b>data</b> previously set

       <b>typedef</b> <b>enum</b> <u>memcached_callback_t</u> <b>memcached_callback_t</b>

       <b>enum</b> <b>memcached_callback_t</b>

              <b>enumerator</b> <b>MEMCACHED_CALLBACK_CLEANUP_FUNCTION</b>
                     When  <u>memcached_free()</u>  or <b>memcached_reset</b> is called this function will be executed. At the
                     point of its execution all connections are closed.

                     Its signature is:

                     <b>typedef</b> <u>memcached_return_t</u> <b>(*memcached_cleanup_fn)(const</b> <u>memcached_st</u> <b>*ptr)</b>

              <b>enumerator</b> <b>MEMCACHED_CALLBACK_CLONE_FUNCTION</b>
                     When <u>memcached_clone()</u> is called this function will be executed.

                     Its signature is:

                     <b>typedef</b> <u>memcached_return_t</u> <b>(*memcached_clone_fn)(</b><u>memcached_st</u> <b>*destination,</b> <b>const</b>
                     <u>memcached_st</u> <b>*source)</b>

              <b>enumerator</b> <b>MEMCACHED_CALLBACK_PREFIX_KEY</b>
                     See <u>MEMCACHED_CALLBACK_NAMESPACE</u>.

              <b>enumerator</b> <b>MEMCACHED_CALLBACK_NAMESPACE</b>
                     You can set a value which will be used to  create  a  domain  for  your  keys.   The  value
                     specified  here  will  be  prefixed to each of your keys. The value can not be greater then
                     <u>MEMCACHED_MAX_NAMESPACE</u> - 1 and will reduce <u>MEMCACHED_MAX_KEY</u> by the value of your key.

                     The prefix key is only applied to the primary key, not the master  key.   <u>MEMCACHED_FAILURE</u>
                     will  be  returned  if  no  key  is  set.  In  the  case  of  a  key  which  is  too  long,
                     <u>MEMCACHED_BAD_KEY_PROVIDED</u> will be returned.

                     If you set a value with the value being NULL then the prefix key is disabled.

              <b>enumerator</b> <b>MEMCACHED_CALLBACK_USER_DATA</b>
                     This allows you to store a pointer to a specific piece of data. This can be retrieved  from
                     inside  of  <u>memcached_fetch_execute()</u>.  Cloning a <u>memcached_st</u> will copy the pointer to the
                     clone.

              <b>enumerator</b> <b>MEMCACHED_CALLBACK_MALLOC_FUNCTION</b>
                     Deprecated since version &lt;0.32: Use <u>memcached_set_memory_allocators()</u> instead.

              <b>enumerator</b> <b>MEMCACHED_CALLBACK_REALLOC_FUNCTION</b>
                     Deprecated since version &lt;0.32: Use <u>memcached_set_memory_allocators()</u> instead.

              <b>enumerator</b> <b>MEMCACHED_CALLBACK_FREE_FUNCTION</b>
                     Deprecated since version &lt;0.32: Use <u>memcached_set_memory_allocators()</u> instead.

              <b>enumerator</b> <b>MEMCACHED_CALLBACK_GET_FAILURE</b>
                     This function implements the read through cache behavior.  On  failure  of  retrieval  this
                     callback will be called.

                     You are responsible for populating the result object provided. This result object will then
                     be stored in the server and returned to the calling process.

                     You  must  clone the <u>memcached_st</u> in order to make use of it. The value will be stored only
                     if you return <u>MEMCACHED_SUCCESS</u> or <u>MEMCACHED_BUFFERED</u>.  Returning  <u>MEMCACHED_BUFFERED</u>  will
                     cause  the  object to be buffered and not sent immediately (if this is the default behavior
                     based on your connection setup this will happen automatically).

                     The prototype for this is:

                     <b>typedef</b> <u>memcached_return_t</u> <b>(*memcached_trigger_key)(</b><u>memcached_st</u> <b>*ptr,</b> <b>char</b> <b>*key,</b> <b>size_t</b>
                     <b>key_length,</b> <u>memcached_result_st</u> <b>*result)</b>

              <b>enumerator</b> <b>MEMCACHED_CALLBACK_DELETE_TRIGGER</b>
                     This function implements a trigger upon successful deletion of  a  key.   The  <u>memcached_st</u>
                     structure will need to be cloned in order to make use of it.

                     The prototype for this is:

                     <b>typedef</b> <u>memcached_return_t</u> <b>(*memcached_trigger_delete_key)(</b><u>memcached_st</u> <b>*ptr,</b> <b>char</b> <b>*key,</b>
                     <b>size_t</b> <b>key_length)</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>libmemcached</b>  can  have callbacks set key execution points. These either provide function calls at points
       in the code, or return pointers to structures for particular usages.

       <u>memcached_callback_get()</u>  takes  a  callback  flag  and  returns  the  structure  or  function   set   by
       <u>memcached_callback_set()</u>.

       <u>memcached_callback_set()</u>  changes  the function/structure assigned by a callback flag. No connections are
       reset.

       You can use <u>MEMCACHED_CALLBACK_USER_DATA</u> to provide custom context if required for any of the callbacks.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u>memcached_callback_get()</u> returns the function or structure that was provided.   Upon  error,  nothing  is
       set, NULL is returned, and the <u>memcached_return_t</u> argument is set to <u>MEMCACHED_FAILURE</u>.

       <u>memcached_callback_set()</u>  returns  <u>MEMCACHED_SUCCESS</u> upon successful setting, otherwise <u>MEMCACHED_FAILURE</u>
       on error.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/memcached.1.html">memcached</a>(1)</b> <b><a href="../man3/libmemcached.3.html">libmemcached</a>(3)</b> <b><a href="../man3/memcached_strerror.3.html">memcached_strerror</a>(3)</b>

1.1                                               Mar 31, 2024                             <u><a href="../man3/MEMCACHED_CALLBACK.3.html">MEMCACHED_CALLBACK</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>