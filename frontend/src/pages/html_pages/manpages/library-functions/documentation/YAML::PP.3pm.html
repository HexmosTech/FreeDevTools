<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YAML::PP - YAML 1.2 processor</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libyaml-pp-perl">libyaml-pp-perl_0.39.0-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       YAML::PP - YAML 1.2 processor

</pre><h4><b>SYNOPSIS</b></h4><pre>
       WARNING: Most of the inner API is not stable yet.

       Here are a few examples of the basic load and dump methods:

           use YAML::PP;
           my $ypp = YAML::PP-&gt;new;

           my $yaml = &lt;&lt;'EOM';
           --- # Document one is a mapping
           name: Tina
           age: 29
           favourite language: Perl

           --- # Document two is a sequence
           - plain string
           - 'in single quotes'
           - "in double quotes we have escapes! like \t and \n"
           - | # a literal block scalar
             line1
             line2
           - &gt; # a folded block scalar
             this is all one
             single line because the
             linebreaks will be folded
           EOM

           my @documents = $ypp-&gt;load_string($yaml);
           my @documents = $ypp-&gt;load_file($filename);

           my $yaml = $ypp-&gt;dump_string($data1, $data2);
           $ypp-&gt;dump_file($filename, $data1, $data2);

           # Enable perl data types and objects
           my $ypp = YAML::PP-&gt;new(schema =&gt; [qw/ + Perl /]);
           my $yaml = $yp-&gt;dump_string($data_with_perl_objects);

           # Legacy interface
           use YAML::PP qw/ Load Dump LoadFile DumpFile /;
           my @documents = Load($yaml);
           my @documents = LoadFile($filename);
           my @documents = LoadFile($filehandle);
           my $yaml = = Dump(@documents);
           DumpFile($filename, @documents);
           DumpFile($filenhandle @documents);

       Some utility scripts, mostly useful for debugging:

           # Load YAML into a data structure and dump with Data::Dumper
           yamlpp-load &lt; file.yaml

           # Load and Dump
           yamlpp-load-dump &lt; file.yaml

           # Print the events from the parser in yaml-test-suite format
           yamlpp-events &lt; file.yaml

           # Parse and emit events directly without loading
           yamlpp-parse-emit &lt; file.yaml

           # Create ANSI colored YAML. Can also be useful for invalid YAML, showing
           # you the exact location of the error
           yamlpp-highlight &lt; file.yaml

</pre><h4><b>DESCRIPTION</b></h4><pre>
       YAML::PP is a modular YAML processor.

       It aims to support "YAML 1.2" and "YAML 1.1". See &lt;https://yaml.org/&gt;.  Some (rare) syntax elements are
       not yet supported and documented below.

       YAML is a serialization language. The YAML input is called "YAML Stream".  A stream consists of one or
       more "Documents", separated by a line with a document start marker "---". A document optionally ends with
       the document end marker "...".

       This allows one to process continuous streams additionally to a fixed input file or string.

       The YAML::PP frontend will currently load all documents, and return only the first if called with scalar
       context.

       The YAML backend is implemented in a modular way that allows one to add custom handling of YAML tags,
       perl objects and data types. The inner API is not yet stable. Suggestions welcome.

       You can check out all current parse and load results from the yaml-test-suite here:
       &lt;https://perlpunk.github.io/YAML-PP-p5/test-suite.html&gt;

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
           my $ypp = YAML::PP-&gt;new;

           # use YAML 1.2 Failsafe Schema
           my $ypp = YAML::PP-&gt;new( schema =&gt; ['Failsafe'] );
           # use YAML 1.2 JSON Schema
           my $ypp = YAML::PP-&gt;new( schema =&gt; ['JSON'] );
           # use YAML 1.2 Core Schema
           my $ypp = YAML::PP-&gt;new( schema =&gt; ['Core'] );

           # Die when detecting cyclic references
           my $ypp = YAML::PP-&gt;new( cyclic_refs =&gt; 'fatal' );

           my $ypp = YAML::PP-&gt;new(
               boolean =&gt; 'perl',
               schema =&gt; ['Core'],
               cyclic_refs =&gt; 'fatal',
               indent =&gt; 4,
               header =&gt; 1,
               footer =&gt; 0,
               version_directive =&gt; 0,
           );

       Options:

       boolean
           Values: "perl" (currently default), "JSON::PP", "boolean", "perl_experimental"

           This option is for loading and dumping.

           In  case  of  perl  5.36  and  later,  builtin booleans should work out of the box (since YAML::PP &gt;=
           0.38.0).

               print YAML::PP-&gt;new-&gt;dump_string([ builtin::true, !1 ]);
               # ---
               # - true
               # - false

           For earlier perl versions, you can use "pseudo" booleans like documented in the following examples.

               # load/dump booleans via boolean.pm
               my $ypp = YAML::PP-&gt;new( boolean =&gt; 'boolean' );
               # load/dump booleans via JSON::PP::true/false
               my $ypp = YAML::PP-&gt;new( boolean =&gt; 'JSON::PP' );

           You can also specify more than one class, comma separated.  This is important for dumping.

               boolean =&gt; 'JSON::PP,boolean'
               Booleans will be loaded as JSON::PP::Booleans, but when dumping, also
               'boolean' objects will be recognized

               boolean =&gt; 'JSON::PP,*'
               Booleans will be loaded as JSON::PP::Booleans, but when dumping, all
               currently supported boolean classes will be recognized

               boolean =&gt; '*'
               Booleans will be loaded as perl booleans, but when dumping, all
               currently supported boolean classes will be recognized

               boolean =&gt; ''
               Booleans will be loaded as perl booleans, but when dumping, nothing
               will be recognized as booleans.
               This option is for backwards compatibility for perl versions &lt; 5.36,
               if you rely on [!!1, !1] being dumped as [1, ''].

           The option "perl_experimental" was introduced when experimental boolean support  was  added  to  perl
           5.36.  Since  it  will  not be experimental anymore in perl 5.40 \o/ the option is deprecated and the
           same as "perl".

       schema
           Default: "['Core']"

           This option is for loading and dumping.

           Array reference. Here you can define what schema to use.  Supported standard Schemas are: "Failsafe",
           "JSON", "Core", "YAML1_1".

           To      get      an      overview      how      the      different      Schemas      behave,      see
           &lt;https://perlpunk.github.io/YAML-PP-p5/schemas.html&gt;

           Additionally you can add further schemas, for example "Merge".

       cyclic_refs
           Default: "fatal" (since 0.037)

           Before  the default was "allow", but this can lead to memory leaks when loading on untrusted data, so
           it was changed to "fatal" by default.

           This option is for loading only.

           Defines what to do when a cyclic reference is detected when loading.

               # fatal  - die
               # warn   - Just warn about them and replace with undef
               # ignore - replace with undef
               # allow  - Default

       duplicate_keys
           Default: 0

           Since version 0.027

           This option is for loading.

           The YAML Spec says duplicate mapping keys should be forbidden.

           When set to true, duplicate keys in mappings are allowed (and will overwrite the previous key).

           When set to false, duplicate keys will result in an error when loading.

           This is especially useful when you have a longer mapping and don't see  the  duplicate  key  in  your
           editor:

               ---
               a: 1
               b: 2
               # .............
               a: 23 # error

       indent
           Default: 2

           This option is for dumping.

           Use that many spaces for indenting

       width
           Since version 0.025

           Default: 80

           This option is for dumping.

           Maximum columns when dumping.

           This is only respected when dumping flow collections right now.

           in the future it will be used also for wrapping long strings.

       header
           Default: 1

           This option is for dumping.

           Print document header "---"

       footer
           Default: 0

           This option is for dumping.

           Print document footer "..."

       require_footer
           Default: 0

           Will  require a "..." at the end of each document.  This can be useful in a context where you want to
           make sure you received the complete content, for example over network.

               # Good
               ---
               a: 1
               ...
               ---
               a: 2
               ...

               # Bad
               ---
               a: 1
               ---
               a: 2

       yaml_version
           Since version 0.020

           This option is for loading and dumping.

           Default: 1.2

           Note that in this case, a directive "%YAML 1.1" will basically be ignored and everything loaded  with
           the "1.2 Core" Schema.

           If  you  want  to  support both YAML 1.1 and 1.2, you have to specify that, and the schema ("Core" or
           "YAML1_1") will be chosen automatically.

               my $yp = YAML::PP-&gt;new(
                   yaml_version =&gt; ['1.2', '1.1'],
               );

           This is the same as

               my $yp = YAML::PP-&gt;new(
                   schema =&gt; ['+'],
                   yaml_version =&gt; ['1.2', '1.1'],
               );

           because the "+" stands for the default schema per version.

           When loading, and there is no %YAML directive, 1.2 will be considered  as  default,  and  the  "Core"
           schema will be used.

           If there is a "%YAML 1.1" directive, the "YAML1_1" schema will be used.

           Of course, you can also make 1.1 the default:

               my $yp = YAML::PP-&gt;new(
                   yaml_version =&gt; ['1.1', '1.2'],
               );

           You can also specify 1.1 only:

               my $yp = YAML::PP-&gt;new(
                   yaml_version =&gt; ['1.1'],
               );

           In this case also documents with "%YAML 1.2" will be loaded with the "YAML1_1" schema.

       version_directive
           Since version 0.020

           This option is for dumping.

           Default: 0

           Print  Version  Directive  "%YAML 1.2" (or "%YAML 1.1") on top of each YAML document. It will use the
           first version specified in the "yaml_version" option.

       preserve
           Since version 0.021

           Default: false

           This option is for loading and dumping.

           Preserving scalar styles is still experimental.

               use YAML::PP::Common qw/ :PRESERVE /;

               # Preserve the order of hash keys
               my $yp = YAML::PP-&gt;new( preserve =&gt; PRESERVE_ORDER );

               # Preserve the quoting style of scalars
               my $yp = YAML::PP-&gt;new( preserve =&gt; PRESERVE_SCALAR_STYLE );

               # Preserve block/flow style (since 0.024)
               my $yp = YAML::PP-&gt;new( preserve =&gt; PRESERVE_FLOW_STYLE );

               # Preserve alias names (since 0.027)
               my $yp = YAML::PP-&gt;new( preserve =&gt; PRESERVE_ALIAS );

               # Combine, e.g. preserve order and scalar style
               my $yp = YAML::PP-&gt;new( preserve =&gt; PRESERVE_ORDER | PRESERVE_SCALAR_STYLE );

           Do NOT rely on the internal implementation of it.

           If you load the following input:

               ---
               z: 1
               a: 2
               ---
               - plain
               - 'single'
               - "double"
               - |
                 literal
               - &gt;
                 folded
               ---
               block mapping: &amp;alias
                 flow sequence: [a, b]
               same mapping: *alias
               flow mapping: {a: b}

           with this code:

               my $yp = YAML::PP-&gt;new(
                   preserve =&gt; PRESERVE_ORDER | PRESERVE_SCALAR_STYLE
                               | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS
               );
               my ($hash, $styles, $flow) = $yp-&gt;load_file($file);
               $yp-&gt;dump_file($hash, $styles, $flow);

           Then dumping it will return the same output.

           Note that YAML allows repeated definition of anchors. They cannot be preserved  with  YAML::PP  right
           now. Example:

               ---
               - &amp;seq [a]
               - *seq
               - &amp;seq [b]
               - *seq

           Because  the  data  could be shuffled before dumping again, the anchor definition could be broken. In
           this case repeated anchor names will be discarded when loading and dumped with numeric  anchors  like
           usual.

           Implementation:

           When  loading,  hashes  will be tied to an internal class ("YAML::PP::Preserve::Hash") that keeps the
           key order.

           Scalars will be  returned  as  objects  of  an  internal  class  ("YAML::PP::Preserve::Scalar")  with
           overloading. If you assign to such a scalar, the object will be replaced by a simple scalar.

               # assignment, style gets lost
               $styles-&gt;[1] .= ' append';

           You  can  also  pass 1 as a value. In this case all preserving options will be enabled, also if there
           are new options added in the future.

           There   are   also    methods    to    create    preserved    nodes    from    scratch.    See    the
           preserved_(scalar|mapping|sequence) "METHODS" below.

   <b>load_string</b>
           my $doc = $ypp-&gt;load_string("foo: bar");
           my @docs = $ypp-&gt;load_string("foo: bar\n---\n- a");

       Input should be Unicode characters.

       So if you read from a file, you should decode it, for example with Encode::decode().

       Note  that  in scalar context, "load_string" and "load_file" return the first document (like YAML::Syck),
       while YAML and YAML::XS return the last.

   <b>load_file</b>
           my $doc = $ypp-&gt;load_file("file.yaml");
           my @docs = $ypp-&gt;load_file("file.yaml");

       Strings will be loaded as unicode characters.

   <b>dump_string</b>
           my $yaml = $ypp-&gt;dump_string($doc);
           my $yaml = $ypp-&gt;dump_string($doc1, $doc2);
           my $yaml = $ypp-&gt;dump_string(@docs);

       Input strings should be Unicode characters.

       Output will return Unicode characters.

       So if you want to write that to a file (or pass to YAML::XS, for example), you typically  encode  it  via
       Encode::encode().

   <b>dump_file</b>
           $ypp-&gt;dump_file("file.yaml", $doc);
           $ypp-&gt;dump_file("file.yaml", $doc1, $doc2);
           $ypp-&gt;dump_file("file.yaml", @docs);

       Input data should be Unicode characters.

   <b>dump</b>
       This  will  dump  to  a  predefined writer. By default it will just use the YAML::PP::Writer and output a
       string.

           my $writer = MyWriter-&gt;new(\my $output);
           my $yp = YAML::PP-&gt;new(
               writer =&gt; $writer,
           );
           $yp-&gt;dump($data);

   <b>preserved_scalar</b>
       Since version 0.024

       Experimental. Please report bugs or let me know this is useful and works.

       You can define a certain scalar style when dumping data.  Figuring out the best style is a hard task  and
       practically impossible to get it right for all cases. It's also a matter of taste.

           use YAML::PP::Common qw/ PRESERVE_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE /;
           my $yp = YAML::PP-&gt;new(
               preserve =&gt; PRESERVE_SCALAR_STYLE,
           );
           # a single linebreak would normally be dumped with double quotes: "\n"
           my $scalar = $yp-&gt;preserved_scalar("\n", style =&gt; YAML_LITERAL_SCALAR_STYLE );

           my $data = { literal =&gt; $scalar };
           my $dump = $yp-&gt;dump_string($data);
           # output
           ---
           literal: |+

           ...

   <b>preserved_mapping,</b> <b>preserved_sequence</b>
       Since version 0.024

       Experimental. Please report bugs or let me know this is useful and works.

       With this you can define which nodes are dumped with the more compact flow style instead of block style.

       If you add "PRESERVE_ORDER" to the "preserve" option, it will also keep the order of the keys in a hash.

           use YAML::PP::Common qw/
               PRESERVE_ORDER PRESERVE_FLOW_STYLE
               YAML_FLOW_MAPPING_STYLE YAML_FLOW_SEQUENCE_STYLE
           /;
           my $yp = YAML::PP-&gt;new(
               preserve =&gt; PRESERVE_FLOW_STYLE | PRESERVE_ORDER
           );

           my $hash = $yp-&gt;preserved_mapping({}, style =&gt; YAML_FLOW_MAPPING_STYLE);
           # Add values after initialization to preserve order
           %$hash = (z =&gt; 1, a =&gt; 2, y =&gt; 3, b =&gt; 4);

           my $array = $yp-&gt;preserved_sequence([23, 24], style =&gt; YAML_FLOW_SEQUENCE_STYLE);

           my $data = $yp-&gt;preserved_mapping({});
           %$data = ( map =&gt; $hash, seq =&gt; $array );

           my $dump = $yp-&gt;dump_string($data);
           # output
           ---
           map: {z: 1, a: 2, y: 3, b: 4}
           seq: [23, 24]

   <b>loader</b>
       Returns or sets the loader object, by default YAML::PP::Loader

   <b>dumper</b>
       Returns or sets the dumper object, by default YAML::PP::Dumper

   <b>schema</b>
       Returns or sets the schema object

   <b>default_schema</b>
       Creates and returns the default schema

</pre><h4><b>FUNCTIONS</b></h4><pre>
       The  functions  "Load", "LoadFile", "Dump" and "DumpFile" are provided as a drop-in replacement for other
       existing YAML processors.  No function is exported by default.

       Note that in scalar context, "Load" and "LoadFile" return the first  document  (like  YAML::Syck),  while
       YAML and YAML::XS return the last.

       Load
               use YAML::PP qw/ Load /;
               my $doc = Load($yaml);
               my @docs = Load($yaml);

           Works like "load_string".

       LoadFile
               use YAML::PP qw/ LoadFile /;
               my $doc = LoadFile($file);
               my @docs = LoadFile($file);
               my @docs = LoadFile($filehandle);

           Works like "load_file".

       Dump
               use YAML::PP qw/ Dump /;
               my $yaml = Dump($doc);
               my $yaml = Dump(@docs);

           Works like "dump_string".

       DumpFile
               use YAML::PP qw/ DumpFile /;
               DumpFile($file, $doc);
               DumpFile($file, @docs);
               DumpFile($filehandle, @docs);

           Works like "dump_file".

</pre><h4><b>PLUGINS</b></h4><pre>
       You can alter the behaviour of YAML::PP by using the following schema classes:

       YAML::PP::Schema::Failsafe
           One of the three YAML 1.2 official schemas

       YAML::PP::Schema::JSON
           One of the three YAML 1.2 official schemas.

       YAML::PP::Schema::Core
           One of the three YAML 1.2 official schemas. Default

       YAML::PP::Schema::YAML1_1
           Schema implementing the most common YAML 1.1 types

       YAML::PP::Schema::Perl
           Serializing Perl objects and types

       YAML::PP::Schema::Binary
           Serializing binary data

       YAML::PP::Schema::Merge
           YAML 1.1 merge keys for mappings

       YAML::PP::Schema::Catchall
           Experimental.

           It was accidentally added in 0.38.1, and unknown tags forbidden.  This was reverted in 0.39.0

           By default they will result in an error.

       YAML::PP::Schema::Include
           Include other YAML files via "!include" tags

       YAML::PP::Schema::Tie::IxHash
           Deprecated. See option "preserve"

       To make the parsing process faster, you can plugin the libyaml parser with YAML::PP::LibYAML.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       The process of loading and dumping is split into the following steps:

           Load:

           YAML Stream        Tokens        Event List        Data Structure
                     ---------&gt;    ---------&gt;        ---------&gt;
                       lex           parse           construct

           Dump:

           Data Structure       Event List        YAML Stream
                       ---------&gt;        ---------&gt;
                       represent           emit

       You  can  dump  basic  perl  types  like hashes, arrays, scalars (strings, numbers).  For dumping blessed
       objects and things like coderefs have a look at YAML::PP::Perl/YAML::PP::Schema::Perl.

       YAML::PP::Lexer
           The Lexer is reading the YAML  stream  into  tokens.  This  makes  it  possible  to  generate  syntax
           highlighted YAML output.

           Note that the API to retrieve the tokens will change.

       YAML::PP::Parser
           The  Parser  retrieves  the  tokens  from  the  Lexer.  The main YAML content is then parsed with the
           Grammar.

       YAML::PP::Grammar
       YAML::PP::Constructor
           The Constructor creates a data structure from the Parser events.

       YAML::PP::Loader
           The Loader combines the constructor and parser.

       YAML::PP::Dumper
           The Dumper will delegate to the Representer

       YAML::PP::Representer
           The Representer will create Emitter events from the given data structure.

       YAML::PP::Emitter
           The Emitter creates a YAML stream.

   <b>YAML::PP::Parser</b>
       Still TODO:

       Implicit collection keys
               ---
               [ a, b, c ]: value

       Implicit mapping in flow style sequences
           This is supported since 0.029 (except some not relevant cases):

               ---
               [ a, b, c: d ]
               # equals
               [ a, b, { c: d } ]

       Plain mapping keys ending with colons
               ---
               key ends with two colons::: value

           This was implemented in 0.037.

       Supported Characters
           If you have valid YAML that's not parsed, or the other way round, please create an issue.

       Line and Column Numbers
           You will see line and column numbers in the error message. The column numbers might still be wrong in
           some cases.

       Error Messages
           The error messages need to be improved.

       Unicode Surrogate Pairs
           Currently loaded as single characters without validating

       Possibly more

   <b>YAML::PP::Constructor</b>
       The Constructor now supports all three YAML 1.2 Schemas, Failsafe, JSON and Core.  Additionally  you  can
       choose the schema for YAML 1.1 as "YAML1_1".

       Too    see    what    strings    are    resolved    as    booleans,    numbers,   null   etc.   look   at
       &lt;https://perlpunk.github.io/YAML-PP-p5/schema-examples.html&gt;.

       You can choose the Schema like this:

           my $ypp = YAML::PP-&gt;new(schema =&gt; ['JSON']); # default is 'Core'

       The Tags "!!seq" and "!!map" are still ignored for now.

       It supports:

       Handling of Anchors/Aliases
           Like in modules like YAML, the Constructor will  use  references  for  mappings  and  sequences,  but
           obviously not for scalars.

           YAML::XS  uses real aliases, which allows also aliasing scalars. I might add an option for that since
           aliasing is now available in pure perl.

       Boolean Handling
           You can choose between 'perl' (1/'', currently default), 'JSON::PP'  and  'boolean'.pm  for  handling
           boolean  types.   That  allows  you  to  dump the data structure with one of the JSON modules without
           losing information about booleans.

       Numbers
           Numbers are created as real numbers instead of strings, so that they are dumped correctly by  modules
           like JSON::PP or JSON::XS, for example.

       Complex Keys
           Mapping Keys in YAML can be more than just scalars. Of course, you can't load that into a native perl
           structure.  The  Constructor  will  stringify  those keys with Data::Dumper instead of just returning
           something like <a href="../man0x55dc1b5d0178/HASH.0x55dc1b5d0178.html">HASH</a>(0x55dc1b5d0178).

           Example:

               use YAML::PP;
               use JSON::PP;
               my $ypp = YAML::PP-&gt;new;
               my $coder = JSON::PP-&gt;new-&gt;ascii-&gt;pretty-&gt;allow_nonref-&gt;canonical;
               my $yaml = &lt;&lt;'EOM';
               complex:
                   ?
                       ?
                           a: 1
                           c: 2
                       : 23
                   : 42
               EOM
               my $data = $yppl-&gt;load_string($yaml);
               say $coder-&gt;encode($data);
               __END__
               {
                  "complex" : {
                     "{'{a =&gt; 1,c =&gt; 2}' =&gt; 23}" : 42
                  }
               }

       TODO:

       Parse Tree
           I would like to generate a complete parse tree, that allows you to manipulate the data structure  and
           also  dump it, including all whitespaces and comments.  The spec says that this is throwaway content,
           but I read that many people wish to be able to keep the comments.

   <b>YAML::PP::Dumper,</b> <b>YAML::PP::Emitter</b>
       The Dumper should be able to dump strings correctly, adding quotes whenever a  plain  scalar  would  look
       like a special string, like "true", or when it contains or starts with characters that are not allowed.

       Most strings will be dumped as plain scalars without quotes. If they contain special characters or have a
       special  meaning,  they  will be dumped with single quotes. If they contain control characters, including
       &lt;"\n"&gt;, they will be dumped with double quotes.

       It will recognize JSON::PP::Boolean and boolean.pm objects and dump them correctly.

       Numbers which also have a "PV" flag will be recognized as numbers and not as strings:

           my $int = 23;
           say "int: $int"; # $int will now also have a PV flag

       That means that if you accidentally use a string in numeric context, it will  also  be  recognized  as  a
       number:

           my $string = "23";
           my $something = $string + 0;
           print $yp-&gt;dump_string($string);
           # will be emitted as an integer without quotes!

       The layout is like libyaml output:

           key:
           - a
           - b
           - c
           ---
           - key1: 1
             key2: 2
             key3: 3
           ---
           - - a1
             - a2
           - - b1
             - b2

</pre><h4><b>FAQ</b> <b>-</b> <b>Frequently</b> <b>Asked</b> <b>Questions</b></h4><pre>
       Are "&lt;&lt;" merge keys supported?
           Yes, this can be enabled optionally, see YAML::PP::Schema::Merge

       Is there a linter / formatter for YAML
           There  is the widely used "yamllint" &lt;https://yamllint.readthedocs.io/&gt;, based on python's PyYAML. It
           is very configurable and will report errors or warnings.  It cannot format.

           Now there is also YAML::Tidy, which will format the given file according to  your  configuration.  So
           far only a few configuration options exist, but they can already be quite helpful.

</pre><h4><b>Which</b> <b>YAML</b> <b>module</b> <b>should</b> <b>I</b> <b>use?</b></h4><pre>
       There are many YAML modules on CPAN. For historical reasons some of them aren't handling YAML correctly.

       Most  of  them  are not compatible with the YAML spec and with each other, meaning they can interpret the
       same YAML differently.

       The  behaviours  we  are  discussing  here  can   be   divided   into   parsing   issues   (syntax)   and
       loading/constructing issues (for example type resolving which decides what is a number, boolean or null).

       See               also               &lt;https://matrix.yaml.info/&gt;               (parsing)              and
       &lt;https://perlpunk.github.io/YAML-PP-p5/schema-examples.html&gt; (loading).

       "YAML.pm"
           It was written even before the YAML 1.0 spec was finished and by that enabled perl users  to  process
           YAML  very early. It might work for you if you have simple data, but it's missing quite some features
           and can also produce YAML that doesn't roundtrip. Nowadays it might be a good idea to switch.

       YAML::XS
           A libyaml binding that is robust and widely used. However, there are two things to consider.

           1. (syntax) libyaml diverged from the spec in several aspects. They are rare  though.   2.  The  type
           resolving does not adhere to YAML 1.1 or YAML 1.2, meaning it is
              incompatible with other YAML libraries in perl or other languages.

       YAML::Tiny
           It  implements  both  a tiny subset of YAML, but also a superset. Meaning it will happily accept some
           YAML documents that are not officially valid.  Type resolving is also not  implemented  according  to
           the spec.

       YAML::Syck
           A  binding  to  libsyck.  It is even less compatible to YAML than libyaml. Also type resolving is not
           implemented according to the spec.

       YAML::PP
           Regarding YAML syntax, it is the second most YAML 1.2 compatible perl module.  The  cases  it  cannot
           (yet)  parse  are  not  relevant in perl programming, e.g. hash keys that are not strings.  Regarding
           type resolving, it is compatible with the YAML 1.2 Core schema, so it should be possible to  exchange
           data  as  YAML  with other libraries in other languages.  One downside is that it is the slowest perl
           YAML module.

       YAML::Parser
           This is a parser generated by the YAML grammar, and it's passing all official tests. A  YAML::PP::Ref
           frontend  exists  that you can use just like YAML::PP.  It is quite slow (although it might be ok for
           small files depending on the use case).  The error messages  it  creates  on  invalid  YAML  are  not
           helpful currently.

       YAML::PP::LibYAML
           This  combines  the YAML::LibYAML::API binding for parsing with the YAML::PP frontend for loading and
           type resolving.  It is faster than YAML::PP but slower than YAML::XS.  The divergence from  the  YAML
           spec  regarding syntax is usually not a problem, and at the same time you have the advantage of being
           compatible to the YAML 1.2 Core Schema.

</pre><h4><b>WHY</b></h4><pre>
       Why did I start to write a new YAML module?

       All the available parsers and loaders for Perl are  behaving  differently,  and  more  important,  aren't
       conforming to the spec. YAML::XS is doing pretty well, but "libyaml" only handles YAML 1.1 and diverges a
       bit from the spec. The pure perl loaders lack support for a number of features.

       I  was  going over YAML.pm issues end of 2016, integrating old patches from rt.cpan.org and creating some
       pull requests myself. I realized that it would be difficult to patch YAML.pm to parse YAML  1.1  or  even
       1.2, and it would also break existing usages relying on the current behaviour.

       In 2016 Ingy döt Net initiated two really cool projects:

       "YAML TEST SUITE"
       "YAML EDITOR"

       These  projects are a big help for any developer. So I got the idea to write my own parser and started on
       New Year's Day 2017.  Without the test suite and the editor I would have never started this.

       I also started another YAML Test project which allows one to get a quick  overview  of  which  frameworks
       support which YAML features:

       "YAML TEST MATRIX"

   <b>YAML</b> <b>TEST</b> <b>SUITE</b>
       &lt;https://github.com/yaml/yaml-test-suite&gt;

       It contains almost 400 test cases and expected parsing events and more.  There will be more tests coming.
       This  test  suite  allows  you  to write parsers without turning the examples from the Specification into
       tests yourself.  Also the examples aren't completely covering all cases - the test suite aims to do that.

       Thanks also to Felix Krause, who is writing a YAML parser in Nim.  He turned all the spec  examples  into
       test cases.

   <b>YAML</b> <b>EDITOR</b>
       This is a tool to play around with several YAML parsers and loaders in vim.

       &lt;https://github.com/yaml/yaml-editor&gt;

       The  project  contains  the  code to build the frameworks (16 as of this writing) and put it into one big
       Docker image.

       It also contains the yaml-editor itself, which will start a vim in the docker container. It uses a lot of
       funky vimscript that makes playing with it easy and useful. You can choose which frameworks you  want  to
       test and see the output in a grid of vim windows.

       Especially  when  writing a parser it is extremely helpful to have all the test cases and be able to play
       around with your own examples to see how they are handled.

   <b>YAML</b> <b>TEST</b> <b>MATRIX</b>
       I was curious to see how the different frameworks handle the test cases, so, using the test suite and the
       docker image, I wrote some code that runs the tests, manipulates  the  output  to  compare  it  with  the
       expected output, and created a matrix view.

       &lt;https://github.com/perlpunk/yaml-test-matrix&gt;

       You can find the latest build at &lt;https://matrix.yaml.info&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Ingy döt Net
           Ingy  is  one of the creators of YAML. In 2016 he started the YAML Test Suite and the YAML Editor. He
           also made useful suggestions on the class hierarchy of YAML::PP.

       Felix "flyx" Krause
           Felix answered countless questions about the YAML Specification.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       YAML
       YAML::XS
       YAML::Syck
       YAML::Tiny
       YAML::PP::LibYAML
       YAML::LibYAML::API
       YAML::Tidy
       &lt;https://www.yaml.info/&gt;

</pre><h4><b>SPONSORS</b></h4><pre>
       The Perl Foundation &lt;https://www.perlfoundation.org/&gt; sponsored this project (and the  YAML  Test  Suite)
       with a grant of 2500 USD in 2017-2018.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2017-2022 by Tina Müller

       This library is free software and may be distributed under the same terms as perl itself.

perl v5.40.0                                       2025-02-15                                      <u>YAML::<a href="../man3pm/PP.3pm.html">PP</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>