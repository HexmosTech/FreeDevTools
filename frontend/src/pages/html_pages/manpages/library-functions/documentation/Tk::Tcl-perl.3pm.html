<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_vs_perl - very old suspect documentation on porting.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-tk">perl-tk_804.036+dfsg1-5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_vs_perl - very old suspect documentation on porting.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This isn't really a .pod yet, nor is it Tcl vs perl it is a copy of John's comparison of Malcolm's
       original perl/Tk port with the current one. It is also out-of-date in places.

         From: <a href="mailto:john@WPI.EDU">john@WPI.EDU</a> (John Stoffel )

         Here are some thoughts on the new Tk extension and how I think the
         organization of the commands looks.  Mostly, I'm happy with it, it
         makes some things more organized and more consistent with tcl/tk, but
         since the overlying language is so different, I don't think we need to
         follow exactly the tcl/tk model for how to call the language.

         The basic structure of the Tk program is:

             require Tk;

             $top = MainWindow-&gt;new();

             #
             # create widgets
             #

             Tk::MainLoop;

             sub method1 {
             }

             sub methodN {
             }

         This is pretty much the same as tkperl5a5, with some cosmetic naming
         changes, and some more useful command name and usage changes.  A quick
         comparison in no particular order follows:

         tkperl5a5                             Tk
         -------------------------------       -----------------------------------
         $top=tkinit(name,display,sync);       $top=MainWindow-&gt;new();

         tkpack $w, ... ;              $w-&gt;pack(...)

         $w = Class::new($top, ...);   $w = $top-&gt;Class(...);

         tkmainloop;                   Tk::MainLoop;

         tkbind($w,"&lt;key&gt;",sub);               $w-&gt;bind("&lt;key&gt;",sub);

         tkdelete($w, ...);            $w-&gt;delete(...);

         $w-&gt;scanmark(...);            $w-&gt;scan("mark", ...);

         $w-&gt;scandragto(...);          $w-&gt;scan("dragto", ...);

         $w-&gt;tkselect();                       $w-&gt;Select();

         $w-&gt;selectadjust(...);                $w-&gt;selection("adjust", ...);

         $w-&gt;selectto(...);            $w-&gt;selection("to", ...);

         $w-&gt;selectfrom(...);          $w-&gt;selection("from", ...);

         $w-&gt;tkindex(...);             $w-&gt;index(...);

         tclcmd("xxx",...);              &amp;Tk::xxx(...)    # all Tk commands, but no Tcl at all

         tclcmd("winfo", xxx, $w, ...);  $w-&gt;xxx(...);

                                       $w-&gt;mark(...);

                                       $w-&gt;tag(...);

         $w-&gt;grabstatus();             $w-&gt;grab("status");

         $w-&gt;grabrelease(...);         $w-&gt;grab("release", ...);

         focus($w);                    $w-&gt;focus;

         update();                     Tk-&gt;update();

         idletasks();                  Tk-&gt;update("idletasks");

         wm("cmd",$w, ...);            $w-&gt;cmd(...);

         destroy($w);                  $w-&gt;destroy();

                                       Tk::option(...);
                                         $w-&gt;OptionGet(name,Class)

                                       $w-&gt;place(...)

                                       Tk::property(...);

         $w = Entry::new($parent,...)

         is now

         $w = $parent-&gt;Entry(...)

         As this allows new to be inherited from a Window class.

           -method=&gt;x,-slave=&gt;y

          is now

           -command =&gt; [x,y]

         1st element of list is treated as "method" if y is an object reference.
         (You can have -command =&gt; [a,b,c,d,e] too; b..e get passed as args).

         Object references are now hashes rather than scalars and there
         is only ever one such per window.  The Tcl_CmdInfo and PathName
         are entries in the hash.

         (This allows derived classes to
         re-bless the hash and keep their on stuff in it too.)

         Tk's "Tcl_Interp" is in fact a ref to "." window.
         You can find all the Tk windows descended from it as their object
         references get added (by PathName) into this hash.
         $w-&gt;MainWindow returns this hash from any window.

         I think that it should extend to multiple tkinits / Tk-&gt;news
         with different Display's - if Tk code does.

         Finally "bind" passes window as "extra" (or only)
         argument. Thus

         Tk::Button-&gt;bind(&lt;Any-Enter&gt;,"Enter");

         Binds Enter events to Tk::Button::Enter by default
         but gets called as $w-&gt;Enter so derived class of Button can just
         define its own Enter method. &amp;EvWref and associated globals and race
         conditions are no longer needed.

         One thing to beware of : commands bound to events with $widget-&gt;bind
         follow same pattern, but get passed extra args :

         $widget-&gt;bind(&lt;Any-1&gt;,[sub {print shift}, $one, $two ]);

         When sub gets called it has :

            $widget $one $two

         passed.

         1st extra arg is reference to the per-widget hash that serves as the
         perl object for the widget.

         Every time an XEvent a reference to a special class is placed
         in the widget hash. It can be retrieved by $w-&gt;XEvent method.

         The methods of the XEvent class are the
         Tcl/Tk % special characters.

         Thus:

         $widget-&gt;bind(&lt;Any-KeyPress&gt;,
                       sub {
                        my $w = shift;
                        my $e = $w-&gt;XEvent;
                        print $w-&gt;PathName," ",$e-&gt;A," pressed ,$e-&gt;xy,"\n");
                       });

         XEvent-&gt;xy is a special case which returns "@" . $e-&gt;x . "," . $e-&gt;y
         which is common in Text package.

         Because of passing a blessed widget hash to "bound" subs they can be
         bound to (possibly inherited) methods of the widget's class:

         Class-&gt;bind(&lt;Any-Down&gt;,Down);

         sub Class::Down
         {
          my $w = shift;
          # handle down arrow
         }

         Also:

         -command and friends can take a list the 1st element can be a ref to
         as sub or a method name. Remaining elements are passed as args to the
         sub at "invoke" time. Thus :

         $b= $w-&gt;Button(blah blah, '-command' =&gt; [sub{print shift} , $fred ]);

         Should do the trick, provided $fred is defined at time of button creation.

         Thus 1st element of list is equivalent to Malcolm's -method and second
         would be his -slave.  Any further elements are a bonus and avoid
         having to pass ref to an array/hash as a slave.

perl v5.40.1                                       2025-04-13                                      <u><a href="../man3pm/Tcl-perl.3pm.html">Tcl-perl</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>