<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPI::Lexer - The PPI Lexer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libppi-perl">libppi-perl_1.283-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PPI::Lexer - The PPI Lexer

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use PPI;

         # Create a new Lexer
         my $Lexer = PPI::Lexer-&gt;new;

         # Build a PPI::Document object from a Token stream
         my $Tokenizer = PPI::Tokenizer-&gt;load('My/Module.pm');
         my $Document = $Lexer-&gt;lex_tokenizer($Tokenizer);

         # Build a PPI::Document object for some raw source
         my $source = "print 'Hello World!'; kill(Humans-&gt;all);";
         $Document = $Lexer-&gt;lex_source($source);

         # Build a PPI::Document object for a particular file name
         $Document = $Lexer-&gt;lex_file('My/Module.pm');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The is the PPI Lexer. In the larger scheme of things, its job is to take token streams, in a variety of
       forms, and "lex" them into nested structures.

       Pretty much everything in this module happens behind the scenes at this point. In fact, at the moment you
       don't really need to instantiate the lexer at all, the three main methods will auto-instantiate
       themselves a "PPI::Lexer" object as needed.

       All methods do a one-shot "lex this and give me a PPI::Document object".

       In fact, if you are reading this, what you <b>probably</b> want to do is to just "load a document", in which
       case you can do this in a much more direct and concise manner with one of the following.

         use PPI;

         $Document = PPI::Document-&gt;load( $filename );
         $Document = PPI::Document-&gt;new( $string );

       See PPI::Document for more details.

       For more unusual tasks, by all means forge onwards.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       The "new" constructor creates a new "PPI::Lexer" object. The object itself is merely used to hold various
       buffers and state data during the lexing process, and holds no significant data between -&gt;lex_xxxxx
       calls.

       Returns a new "PPI::Lexer" object

   <b>lex_file</b> <b>$filename</b>
       The "lex_file" method takes a filename as argument. It then loads the file, creates a PPI::Tokenizer for
       the content and lexes the token stream produced by the tokenizer. Basically, a sort of all-in-one method
       for getting a PPI::Document object from a file name.

       Additional arguments are passed to the tokenizer as a hash.

       Returns a PPI::Document object, or "undef" on error.

   <b>lex_source</b> <b>$string</b>
       The "lex_source" method takes a normal scalar string as argument. It creates a PPI::Tokenizer object for
       the string, and then lexes the resulting token stream.

       Additional arguments are passed to the tokenizer as a hash.

       Returns a PPI::Document object, or "undef" on error.

   <b>lex_tokenizer</b> <b>$Tokenizer</b>
       The "lex_tokenizer" takes as argument a PPI::Tokenizer object. It lexes the token stream from the
       tokenizer into a PPI::Document object.

       Additional arguments are set on the PPI::Document produced.

       Returns a PPI::Document object, or "undef" on error.

   <b>errstr</b>
       For any error that occurs, you can use the "errstr", as either a static or object method, to access the
       error message.

       If no error occurs for any particular action, "errstr" will return false.

</pre><h4><b>TO</b> <b>DO</b></h4><pre>
       - Add optional support for some of the more common source filters

       - Some additional checks for blessing things into various Statement and Structure subclasses.

</pre><h4><b>SUPPORT</b></h4><pre>
       See the support section in the main module.

</pre><h4><b>AUTHOR</b></h4><pre>
       Adam Kennedy &lt;<a href="mailto:adamk@cpan.org">adamk@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2001 - 2011 Adam Kennedy.

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       The full text of the license can be found in the LICENSE file included with this module.

perl v5.40.1                                       2025-08-10                                    <u>PPI::<a href="../man3pm/Lexer.3pm.html">Lexer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>