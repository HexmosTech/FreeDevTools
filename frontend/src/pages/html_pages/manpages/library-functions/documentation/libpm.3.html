<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Initialization</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnetpbm-dev">libnetpbm-dev_11.10.02-1build1_amd64</a> <br><br><pre>
</pre><h4><b>Functions</b></h4><pre>
   <b>Initialization</b>
       <b>Overview</b>

       <b>void</b> <b>pm_init(</b> <b>const</b> <b>char</b> <b>*</b> <u>progname</u><b>,</b> <b>unsigned</b> <b>int</b> <u>flags</u> <b>);</b>

       <b>void</b> <b>pm_proginit(</b> <b>int</b> <b>*</b> <u>argcP</u><b>,</b> <b>const</b> <b>char</b> <b>**</b> <u>argv</u> <b>);</b>

       <b>Description</b>

       All  Netpbm  programs  must  call  <b>pm_proginit()</b> just after startup, before they process their arguments.
       <b>pm_proginit()</b>, among other things, processes  Netpbm  universal  arguments  and  removes  them  from  the
       argument list.

       A  program  that  isn't  a Netpbm program, but just uses <b>libnetpbm</b> services, need not invoke <b>pm_proginit</b>.
       But such a program must invoke <b>pm_init()</b>.

       By "Netpbm program," we mean a program that is part of the Netpbm package or is intended to act like one.
       <b>pm_proginit()</b> does things that all Netpbm programs do by convention.  For example, it scans the  argument
       list for  common options , handles them, and removes them from the argument list.  Ergo, if you want your
       program  to have the same common options as those in the Netpbm package, you might use <b>pm_proginit()</b>, and
       if you don't, you must not.

       <b>Note:</b> The <u>argv</u> argument is supposed to be the POSIX  program  arguments.   The  conventional  way  for  a
       program  to  declare  its  arguments is with <b>char</b> <b>**</b>, as opposed to <b>pm_proginit</b>'s <b>const</b> <b>char</b> <b>**</b> and other
       functions the program calls (for example, <b>getopt</b>) may expect them to be declared that  way.   Because  of
       limitations  of  type  compatibility in C, you may get a compiler warning if you pass a value declared as
       <b>char</b> <b>**</b> as <b>pm_proginit</b>'s <u>argv</u> argument.  To avoid that,  either  declare  the  'argv'  argument  of  your
       program's  main  function  as  <b>const</b> <b>char</b> <b>**</b> (as Netpbm programs do) or cast it to that (e.g. (const char
       **)argv) before passing it to <b>pm_proginit</b>.

       <b>pm_proginit()</b> is primarily intended for Netpbm developers, so you should not expect  it  to  have  stable
       function across releases, and you must go to the comments in the source code to see exactly what it does.

       Any  program  that  uses <b>libnetpbm</b> but does not call <b>pm_proginit</b> (i.e. is not a Netpbm program) must call
       <b>pm_init()</b>.  The conventional place to do this is at the very beginning of the program.  This sets up some
       program-global variables for use by the <b>libnetpbm</b> functions.

       The <u>progname</u> argument is the program name  for  <b>libnetpbm</b>  functions  to  use  in  messages  they  issue.
       Normally, you would use argv[0] for this.

       <u>flags</u> is meaningless, but for forward compatibility, you must set it to zero.

       <b>pm_init()</b>  and  <b>pm_proginit()</b> have been around at least since Netpbm 9.25 (March 2002).  Another function
       named <b>pm_init()</b> exists in older Netpbm, but was for internal  use.   Netpbm  programs  of  that  era  use
       <b>pbm_init()</b>,  etc  to  do  what  <b>pm_proginit()</b>  does  today.   Today,  <b>pbm_init()</b>, etc. exist for backward
       compatibility and are identical the <b>pm_proginit()</b>.

   <b>File</b> <b>Or</b> <b>Image</b> <b>Stream</b> <b>Access</b>
       <b>Overview</b>

       <b>FILE</b> <b>*pm_openr(</b> <b>char</b> <b>*</b> <u>name</u> <b>);</b>

       <b>FILE</b> <b>*pm_openw(</b> <b>char</b> <b>*</b> <u>name</u> <b>);</b>

       <b>FILE</b> <b>*pm_openr_seekable(</b> <b>const</b> <b>char</b> <b>*</b> <u>name</u> <b>);</b>

       <b>FILE</b> <b>*pm_close(</b> <b>FILE</b> <b>*</b> <u>fp</u> <b>);</b>

       <b>void</b> <b>pm_tell2(</b> <b>FILE</b> <b>*</b>  <u>fileP</u><b>,</b> <b>pm_filepos</b> <b>*</b> <u>fileposP</u><b>,</b> <b>unsigned</b> <b>int</b> <u>fileposSize</u> <b>);</b>

       <b>unsigned</b> <b>int</b> <b>pm_tell(</b> <b>FILE</b> <b>*</b> <u>fileP</u> <b>);</b>

       <b>void</b> <b>pm_seek2(</b> <b>FILE</b> <b>*</b>  <u>fileP</u><b>,</b> <b>const</b> <b>pm_filepos</b> <b>*</b> <u>fileposP</u><b>,</b> <b>unsigned</b> <b>int</b> <u>fileposSize</u> <b>);</b>

       <b>void</b> <b>pm_seek(</b> <b>FILE</b> <b>*</b>  <u>fileP</u><b>,</b> <b>unsigned</b> <b>long</b> <u>filepos</u> <b>);</b>

       <b>char</b> <b>*pm_read_unknown_size(</b> <b>FILE</b> <b>*</b> <u>fp</u><b>,</b> <b>long</b> <b>*</b> <u>nread</u> <b>);</b>

       <b>Description</b>

       An image stream is just a file stream (represented in the standard C library as type <b>FILE</b> <b>*</b>).

       These routines work on files &gt; 2 GiB if the  underlying  system  does,  using  the  standard  large  file
       interface.   Before  Netpbm  10.15  (April  2003), though, they would fail to open any file that large or
       process any offset in a file that could not be represented in 32 bits.

       <b>pm_openr()</b> opens the given file for reading, with appropriate error checking.  A filename of <b>-</b>  is  taken
       to  mean  Standard  Input.  <b>pm_openw()</b> opens the given file for writing, with appropriate error checking.
       <b>pm_close()</b> closes the file descriptor, with appropriate error checking.

       <b>pm_openr_seekable()</b> appears to open the file just like <b>pm_openr()</b>, but the file thus opened is guaranteed
       to be seekable (you can use ftell() and fseek() on it).  <b>pm_openr_seekable()</b> pulls this  off  by  copying
       the  entire  file  to a temporary file and giving you the handle of the temporary file, if it has to.  If
       the file you name is a regular file, it's already seekable so  <b>pm_openr_seekable()</b>  just  does  the  same
       thing as <b>pm_openr()</b>.

       But  if  it  is,  say, a pipe, it isn't seekable.  So <b>pm_openr_seekable()</b> reads the pipe until EOF into a
       temporary file, then opens that temporary file and  returns  the  handle  of  the  temporary  file.   The
       temporary file is seekable.

        The  file  <b>pm_openr_seekable()</b> creates is one that the operating system recognizes as temporary, so when
       you close the file, by any means, it gets deleted.

       You need a seekable file if you intend to make multiple passes through the file.  The only alternative is
       to read the entire image into memory and work from that copy.  That may use too much memory.   Note  that
       the image takes less space in the file cache than in a buffer in memory.  As much as 96 times less space!
       Each sample is an integer in the buffer, which is usually 96 bits.  In the file, a sample may be as small
       as 1 bit and rarely more than 8 bits.

       <b>pm_tell2()</b> returns a handle for the current position of the image stream (file), whether it be the header
       or  a row of the raster.  Use the handle as an argument to <b>pm_seek2()</b> to reposition the file there later.
       The file must be seekable (which you can ensure by opening it with <b>pm_openr_seekable()</b>) or this may fail.

       The file position handle is of type <b>pm_filepos</b>, which is intended to be opaque, i.e. used only with these
       two functions.  In practice, it is a file offset and is 32 bits or 64 bits depending upon the  capability
       of  the  underlying  system.   For maximum backward and forward compatibility, the functions that take or
       return a <b>pm_filepos</b> have a <u>fileposSize</u> argument for the size of the data structure.  In  C,  simply  code
       <b>sizeof(pm_filepos)</b> for that.

       <b>pm_seek()</b> and <b>pm_tell</b> are for backward compatibility only.  Do not use them in new code.  These functions
       are not capable of handle positions in files whose byte offset cannot be represented in 32 bits.

       <b>pm_tell2()</b> and <b>pm_seek2()</b> replaced <b>pm_tell()</b> and <b>pm_seek()</b> in Netpbm 10.15 (April 2003).

       <b>pm_read_unknown_size()</b>  reads  an  entire file or input stream of unknown size to a buffer.  It allocates
       more memory as needed.  The calling routine has to free the allocated buffer with <b>free()</b>.

       <b>pm_read_unknown_size()</b> returns a pointer to the allocated buffer.  The <b>nread</b> argument returns the  number
       of bytes read.

   <b>Endian</b> <b>I/O</b>
       <b>Entry</b> <b>Points</b>

       <b>void</b> <b>pm_readchar(</b> <b>FILE</b> <b>*</b> <u>in</u><b>,</b> <b>char</b> <b>*</b> <u>sP</u> <b>);</b>

       <b>void</b> <b>pm_writechar(</b> <b>FILE</b> <b>*</b> <u>out</u><b>,</b> <b>char</b> <u>s</u> <b>);</b>

       <b>int</b> <b>pm_readbigshort(</b> <b>FILE</b> <b>*</b> <u>in</u><b>,</b> <b>short</b> <b>*</b> <u>sP</u> <b>);</b>

       <b>int</b> <b>pm_writebigshort(</b> <b>FILE</b> <b>*</b> <u>out</u><b>,</b> <b>short</b> <u>s</u> <b>);</b>

       <b>int</b> <b>pm_readbiglong(</b> <b>FILE</b> <b>*</b> <u>in</u><b>,</b> <b>long</b> <b>*</b> <u>lP</u> <b>);</b>

       <b>int</b> <b>pm_writebiglong(</b> <b>FILE</b> <b>*</b> <u>out</u><b>,</b> <b>long</b> <u>l</u> <b>);</b>

       <b>int</b> <b>pm_readlittleshort(</b> <b>FILE</b> <b>*</b> <u>in</u><b>,</b> <b>short</b> <b>*</b> <u>sP</u> <b>);</b>

       <b>int</b> <b>pm_writelittleshort(</b> <b>FILE</b> <b>*</b> <u>out</u><b>,</b> <b>short</b> <u>s</u> <b>);</b>

       <b>int</b> <b>pm_readlittlelong(</b> <b>FILE</b> <b>*</b> <u>in</u><b>,</b> <b>long</b> <b>*</b> <u>lP</u> <b>);</b>

       <b>int</b> <b>pm_writelittlelong(</b> <b>FILE</b> <b>*</b> <u>out</u><b>,</b> <b>long</b> <u>l</u> <b>);</b>

       <b>void</b> <b>pm_readcharu(</b> <b>FILE</b> <b>*</b> <u>in</u><b>,</b> <b>char</b> <b>*</b> <u>sP</u> <b>);</b>

       <b>void</b> <b>pm_writecharu(</b> <b>FILE</b> <b>*</b> <u>out</u><b>,</b> <b>char</b> <u>s</u> <b>);</b>

       <b>int</b> <b>pm_readbigshortu(</b> <b>FILE</b> <b>*</b> <u>in</u><b>,</b> <b>short</b> <b>*</b> <u>sP</u> <b>);</b>

       <b>int</b> <b>pm_writebigshortu(</b> <b>FILE</b> <b>*</b> <u>out</u><b>,</b> <b>short</b> <u>s</u> <b>);</b>

       <b>int</b> <b>pm_readbiglongu(</b> <b>FILE</b> <b>*</b> <u>in</u><b>,</b> <b>long</b> <b>*</b> <u>lP</u> <b>);</b>

       <b>int</b> <b>pm_writebiglongu(</b> <b>FILE</b> <b>*</b> <u>out</u><b>,</b> <b>long</b> <u>l</u> <b>);</b>

       <b>int</b> <b>pm_readlittleshortu(</b> <b>FILE</b> <b>*</b> <u>in</u><b>,</b> <b>short</b> <b>*</b> <u>sP</u> <b>);</b>

       <b>int</b> <b>pm_writelittleshortu(</b> <b>FILE</b> <b>*</b> <u>out</u><b>,</b> <b>short</b> <u>s</u> <b>);</b>

       <b>int</b> <b>pm_readlittlelongu(</b> <b>FILE</b> <b>*</b> <u>in</u><b>,</b> <b>long</b> <b>*</b> <u>lP</u> <b>);</b>

       <b>int</b> <b>pm_writelittlelongu(</b> <b>FILE</b> <b>*</b> <u>out</u><b>,</b> <b>long</b> <u>l</u> <b>);</b>

       <b>Description</b>

       <b>pm_readchar()</b>,      <b>pm_writechar()</b>,      <b>pm_readbigshort()</b>,     <b>pm_writebigshort()</b>,     <b>pm_readbiglong()</b>,
       <b>pm_writebiglong()</b>,     <b>pm_readlittleshort()</b>,     <b>pm_writelittleshort()</b>,     <b>pm_readlittlelong()</b>,      and
       <b>pm_writelittlelong()</b>  are  routines  to read and write 1-byte, 2-byte, and 4-byte pure binary integers in
       either big- or little-endian byte order.  Note that a "long int" C type might be wider than 4 bytes,  but
       the "long" routines still read and write 4 bytes.

       <b>pm_readbiglongu()</b>,  etc.  (names  ending  in <b>u</b>) are the same except they work on unsigned versions of the
       type.

       The routines with declared return values always  return  0.   Before  Netpbm  10.27  (March  2005),  they
       returned  -1 on failure, including EOF.  Now, they issue an error message to Standard Error and abort the
       program if the I/O fails or encounters EOF.

       The 1-byte routines were new in Netpbm 10.27 (March 2005).  The  unsigned  versions  were  new  somewhere
       around Netpbm 10.21 (2004).

   <b>Maxval</b> <b>Arithmetic</b>
       <b>Entry</b> <b>Points</b>

       <b>int</b> <b>pm_maxvaltobits(</b> <b>int</b> <u>maxval</u> <b>);</b>

       <b>int</b> <b>pm_bitstomaxval(</b> <b>int</b> <u>bits</u> <b>);</b>

       <b>unsigned</b> <b>int</b> <b>pm_lcm(</b> <b>unsigned</b> <b>int</b> <u>x</u><b>,</b> <b>unsigned</b> <b>int</b> <u>y</u><b>,</b> <b>unsigned</b> <b>int</b> <u>z</u><b>,</b> <b>unsigned</b> <b>int</b> <u>limit</u> <b>);</b>

       <b>Description</b>

       <b>pm_maxvaltobits()</b>  and <b>pm_bitstomaxval()</b> convert between a maxval and the minimum number of bits required
       to hold it.

       <b>pm_lcm()</b> computes the least common multiple of 3 integers.  You also specify a limit and if the LCM would
       be higher than that limit, <b>pm_lcm()</b> just returns that limit.

   <b>Gamma</b> <b>Arithmetic</b>
       <b>Entry</b> <b>Points</b>

       <b>float</b> <b>pm_gamma709(</b> <b>float</b> <u>intensity</u> <b>);</b>

       <b>float</b> <b>pm_ungamma709(</b> <b>float</b> <u>brightness</u> <b>);</b>

       <b>Description</b>

       In graphics processing, there are two common ways of representing numerically the intensity of  a  pixel,
       or a component of a pixel.

       The  obvious  way  is  with  a number that is directly proportional to the light intensity (e.g. 10 means
       twice as many milliwatts per square centimeter as 5).  There are two problems with this:

       •      To the human eye, a 1 milliwatt per square centimeter difference
                     in a bright image is much less apparent than a 1 milliwatt per
                     square centimeter difference in a dark image.  So if you have
                     a fixed number of bits in which to store the intensity value,
                     you're wasting resolution at the bright end and skimping on it at
                     the dark end.

       •      Monitor inputs and camera outputs aren't directly proportional to
                     the light intensity they project or detect.

       For these reasons, light intensities are often represented  in  graphics  processing  by  an  exponential
       scale.   The  transfer  function  is  called a gamma function and the resulting numbers are called gamma-
       corrected or gamma-adjusted.  There are  various  gamma  functions.   The  Netpbm  formats  specify  that
       intensities are represented by gamma-adjusted numbers of a particular gamma transfer function.

       These  functions  let  you convert back and forth between these two scales, using the same gamma transfer
       function that is specified in the Netpbm format specifications.

       <b>pm_gamma709</b> converts from an intensity-proportional intensity value to a gamma-adjusted  intensity  value
       (roughly  proportional  to  brightness, which is the human subjective perception of intensity), using the
       ITU-R Recommendation BT.709 gamma transfer function.

       <b>pm_ungamma709</b> is the inverse of <b>pm_gamma709</b>.

   <b>Messages</b>
       <b>Overview</b>

       <b>void</b> <b>pm_message(</b> <b>char</b> <b>*</b> <u>fmt</u><b>,</b> <b>...</b> <b>);</b>

       <b>void</b> <b>pm_setusermessagefn(pm_usermessagefn</b> <b>*</b> <u>function</u><b>);</b>

       <b>Description</b>

       <b>pm_message()</b> is a <b>printf()</b> style routine to write an informational message to  the  Standard  Error  file
       stream.  <b>pm_message()</b> suppresses the message, however, if the user specified the <b>-quiet</b> common option  on
       the  command  line.   Note  that  Netpbm  programs  are  often used interactively, but also often used by
       programs.  In the interactive case, it is nice to issue messages about what the program is doing, but  in
       the  program  case,  such messages are usually undesirable.  By using <b>pm_message()</b> for all your messages,
       you make your program usable in both cases.  Without any effort on  your  part,  program  users  of  your
       program can avoid the messages by specifying the <b>-quiet</b> option.

       Netpbm  distinguishes  between  error  messages  and  information  messages;  <b>pm_message()</b>  is  just  for
       informational messages.  To issue an error message, see <b>pm_errormsg()</b> .

       <b>pm_setusermessagefn</b> registers a handler for informational messages, called a user message  routine.   Any
       library function (including <b>pm_message()</b>) that wants to issue an informational message in the future will
       call that function with the message as an argument instead of writing the message to Standard Error.

       The  argument  the  user message routine gets is English text designed for human reading.  It is just the
       text of the message; there is no attempt at formatting in it  (so  you  won't  see  any  newline  or  tab
       characters).

       To capture error messages in addition to informational messages, see <b>pm_setusererrormsgfn()</b> .

       You  can remove the user message routine, so that the library issues future informational messages in its
       default way (write to Standard Error) by specifying a null pointer for <u>function</u>.

       Example:

           static pm_usermessagefn logfilewrite;

           static void
           logfilewrite(const char * const msg) {
               fprintf(mymsglog, "Netpbm message: %s", msg);
           }

           pm_setusermessagefn(&amp;logfilewrite);

           pm_message("Message for the message log");

   <b>System</b> <b>Utilities</b>
       •      <b><a href="../man1/pm_system.1.html">pm_system</a></b>(1)

       •      <b><a href="../man1/pm_tmpfile.1.html">pm_tmpfile</a></b>(1)

   <b>Keyword</b> <b>Matching</b>
       <b>Entry</b> <b>Points</b>

       <b>void</b> <b>pm_keymatch();</b>

       <b>Description</b>

       This subroutine is obsolete.  It used to be used for command line option processing.  Today, you  can  do
       better  option  processing  more  easily  with the shhopt facility.  See any recent program in the Netpbm
       package for an example.

       <b>pm_keymatch()</b> does a case-insensitive match of <b>str</b> against <b>keyword</b>.  <b>str</b> can be a  leading  substring  of
       <b>keyword</b>, but at least <b>minchars</b> must be present.

</pre><h4><b>DOCUMENT</b> <b>SOURCE</b></h4><pre>
       This  manual  page was generated by the Netpbm tool 'makeman' from HTML source.  The master documentation
       is at

              <b><a href="http://netpbm.sourceforge.net/doc/libpm.html">http://netpbm.sourceforge.net/doc/libpm.html</a></b>

netpbm documentation                              08 March 2024                   <u>Libnetbpm</u> <u>Utility</u> <u><a href="../man3/Functions.3.html">Functions</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>