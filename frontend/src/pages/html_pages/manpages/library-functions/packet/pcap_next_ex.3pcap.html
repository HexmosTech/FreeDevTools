<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pcap_next_ex, pcap_next - read the next packet from a pcap_t</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpcap0.8-dev">libpcap0.8-dev_1.10.5-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pcap_next_ex, pcap_next - read the next packet from a pcap_t

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;pcap/pcap.h&gt;</b>

       <b>int</b> <b>pcap_next_ex(pcap_t</b> <b>*p,</b> <b>struct</b> <b>pcap_pkthdr</b> <b>**pkt_header,</b>
           <b>const</b> <b>u_char</b> <b>**pkt_data);</b>
       <b>const</b> <b>u_char</b> <b>*pcap_next(pcap_t</b> <b>*p,</b> <b>struct</b> <b>pcap_pkthdr</b> <b>*h);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>pcap_next_ex</b>()  reads  the  next packet and returns a success/failure indication.  If the packet was read
       without problems, the pointer pointed to by the <u>pkt_header</u> argument is set to point  to  the  <b>pcap_pkthdr</b>
       struct for the packet, and the pointer pointed to by the <u>pkt_data</u> argument is set to point to the data in
       the  packet.   The  <b>struct</b> <b>pcap_pkthdr</b> and the packet data are not to be freed by the caller, and are not
       guaranteed to be  valid  after  the  next  call  to  <b>pcap_next_ex</b>(),  <b>pcap_next</b>(),  <b><a href="../man3PCAP/pcap_loop.3PCAP.html">pcap_loop</a></b>(3PCAP),  or
       <b><a href="../man3PCAP/pcap_dispatch.3PCAP.html">pcap_dispatch</a></b>(3PCAP); if the code needs them to remain valid, it must make a copy of them.

       <b>pcap_next</b>()  reads  the  next  packet  (by  calling <b>pcap_dispatch</b>() with a <u>cnt</u> of 1) and returns a <b>u_char</b>
       pointer to the data in that packet.  The packet data is not to  be  freed  by  the  caller,  and  is  not
       guaranteed   to   be   valid  after  the  next  call  to  <b>pcap_next_ex</b>(),  <b>pcap_next</b>(),  <b>pcap_loop</b>(),  or
       <b>pcap_dispatch</b>(); if the code needs it to remain valid, it must  make  a  copy  of  it.   The  <b>pcap_pkthdr</b>
       structure pointed to by <u>h</u> is filled in with the appropriate values for the packet.

       The bytes of data from the packet begin with a link-layer header.  The format of the link-layer header is
       indicated  by  the  return  value  of  the <b><a href="../man3PCAP/pcap_datalink.3PCAP.html">pcap_datalink</a></b>(3PCAP) routine when handed the <b>pcap_t</b> value also
       passed to  <b>pcap_loop</b>()  or  <b>pcap_dispatch</b>().   <u>https://www.tcpdump.org/linktypes.html</u>  lists  the  values
       <b>pcap_datalink</b>()  can  return and describes the packet formats that correspond to those values.  The value
       it returns will be valid for all packets received unless and until  <b><a href="../man3PCAP/pcap_set_datalink.3PCAP.html">pcap_set_datalink</a></b>(3PCAP)  is  called;
       after  a  successful call to <b>pcap_set_datalink</b>(), all subsequent packets will have a link-layer header of
       the type specified by the link-layer header type value passed to <b>pcap_set_datalink</b>().

       Do <b>NOT</b> assume that the packets for a given capture or ``savefile`` will have any given link-layer  header
       type,  such  as  <b>DLT_EN10MB</b>  for Ethernet.  For example, the "any" device on Linux will have a link-layer
       header type of <b>DLT_LINUX_SLL</b> or <b>DLT_LINUX_SLL2</b> even if all devices on the system at the  time  the  "any"
       device is opened have some other data link type, such as <b>DLT_EN10MB</b> for Ethernet.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>pcap_next_ex</b>() returns <b>1</b> if the packet was read without problems, <b>0</b> if packets are being read from a live
       capture  and  the  packet  buffer  timeout  expired,  <b>PCAP_ERROR_BREAK</b>  if  packets are being read from a
       ``savefile'' and there are no more packets to read from the savefile, <b>PCAP_ERROR_NOT_ACTIVATED</b> if  called
       on  a  capture  handle  that has been created but not activated, or <b>PCAP_ERROR</b> if an error occurred while
       reading the packet.  If <b>PCAP_ERROR</b> is returned, <b><a href="../man3PCAP/pcap_geterr.3PCAP.html">pcap_geterr</a></b>(3PCAP) or <b><a href="../man3PCAP/pcap_perror.3PCAP.html">pcap_perror</a></b>(3PCAP)  may  be  called
       with <u>p</u> as an argument to fetch or display the error text.

       <b>pcap_next</b>() returns a pointer to the packet data on success, and returns <b>NULL</b> if an error occurred, or if
       no  packets  were read from a live capture (if, for example, they were discarded because they didn't pass
       the packet filter, or if, on platforms that support a  packet  buffer  timeout  that  starts  before  any
       packets  arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture
       device is in non-blocking mode and no packets were available to be read),  or  if  no  more  packets  are
       available  in  a  ``savefile.''  Unfortunately, there is no way to determine whether an error occurred or
       not.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3PCAP/pcap.3PCAP.html">pcap</a></b>(3PCAP)

                                                  5 March 2022                               <u><a href="../man3PCAP/PCAP_NEXT_EX.3PCAP.html">PCAP_NEXT_EX</a></u>(3PCAP)
</pre>
 </div>
</div></section>
</div>
</body>
</html>