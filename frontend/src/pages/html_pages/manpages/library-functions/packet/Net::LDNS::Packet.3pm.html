<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::LDNS::Packet - objects representing DNS packets</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-ldns-perl">libnet-ldns-perl_0.75-7build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::LDNS::Packet - objects representing DNS packets

</pre><h4><b>SYNOPSIS</b></h4><pre>
           my $p = $resolver-&gt;query('www.iis.se');
           foreach my $rr ($p-&gt;answer) {
               say $rr-&gt;string if $rr-&gt;type eq 'A';
           }

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
       new($name, $type, $class)
           Create a new packet, holding nothing by a query record for the provided triplet. $type and $class are
           optional, and default to A and IN respectively.

       new_from_wireformat($data)
           Creates  a  new  Net::LDNS::Packet  object  from  the  given  wireformat data, if possible. Throws an
           exception if not.

</pre><h4><b>INSTANCE</b> <b>METHODS</b></h4><pre>
       rcode([$string])
           Returns the packet RCODE. If given an argument, tries to set the RCODE to the relevant value. If  the
           given string isn't recognized as an RCODE, an exception will be thrown.

       opcode([$string])
           Returns  the  packet  OPCODE. If given an argument, tries to set the OPCODE to the relevant value. If
           the given string isn't recognized as an OPCODE, an exception will be thrown.

       id([$value])
           Returns the packet id number. If given an argument, sets the ID value to that value.

       <b>qr()</b>
       <b>aa()</b>
       <b>tc()</b>
       <b>rd()</b>
       <b>cd()</b>
       <b>ra()</b>
       <b>ad()</b>
       <b>do()</b>
           Reads and/or sets the equivalently named flags.

       <b>size()</b>
           Returns the length of the packet's wireformat form in octets.

       <b>edns_size()</b>
           Gets and/or sets the EDNS0 UDP size.

       <b>edns_rcode()</b>
           Gets and/or sets the EDNS0 Extended RCODE field.

       <b>needs_edns()</b>
           This method returns true if the packet has the DO flag set, an EDNS0 size  set,  and  EDNS0  extended
           RCODE  set  or  if  the  OPT  pseudo-RR has one or more RDATA fields. It can fail to correctly flag a
           packet with an OPT pseudo-RR as having EDNS, if the pseudo-RR specifies  an  UDP  size  of  zero,  an
           extended RCODE of zero and the DO flag is unset. Since any UDP size less than 512 must be interpreted
           as 512, packets like that should be very rare in practice if they exist at all.

           Note that the OPT pseudo-RR is not visible as an RR in the packet, nor is it included in the RR count
           header fields.

       <b>has_edns()</b>
           An alias for <b>needs_edns()</b>.

       edns_version($version)
           Get  or  set  the  EDNS version in the packet. For incoming packets, returns 0 if the packet does not
           have an OPT pseudo-RR and 0 if it's an EDNS0 packet. It's thus rather pointless until  such  time  as
           EDNS1 is defined.

       querytime([$value])
           Returns  the time the query this packet is the answer to took to execute, in milliseconds. If given a
           value, sets the querytime to that value.

       answerfrom($ipaddr)
           Returns and optionally sets the IP address the packet was received from. If an attempt is made to set
           it to a string that cannot be parsed as an IPv4 or IPv6 address, an exception is thrown.

       timestamp($time)
           The time when the query was sent or received (the ldns docs don't specify), as a floating-point value
           on the Unix time_t scale (that is, the same kind of value used  by  <b>Time::HiRes::time()</b>).  Conversion
           effects between floating-point and "struct timeval" means that the precision of the value is probably
           not reliable at the microsecond level, even if you computer's clock happen to be.

       <b>question()</b>
       <b>answer()</b>
       <b>authority()</b>
       <b>additional()</b>
           Returns  list  of  objects  representing  the  RRs  in  the  named  section.  They will be of classes
           appropriate to their types, but all will have "Net::LDNS::RR" as a base class.

       unique_push($section, $rr)
           Push an RR object into the given section, if an identical RR isn't already present.  If  the  section
           isn't  one of "question", "answer", "authority" or "additional" an exception will be thrown. $rr must
           be a Net::LDNS::RR subclass.

       <b>string()</b>
           Returns a string with the packet and its contents in common presentation format.

       <b>wireformat()</b>
           Returns a Perl string holding the packet in wire format.

       <b>type()</b>
           Returns the ldns library's guess as to the content of the packet.  One  of  the  strings  "question",
           "referral", "answer", "nxdomain", "nodata" or "unknown".

perl v5.40.0                                       2024-10-20                             <u>Net::LDNS::<a href="../man3pm/Packet.3pm.html">Packet</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>