<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTPDataQueue - A packet queue handler for building different kinds of RTP protocol systems.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libccrtp-doc">libccrtp-doc_2.0.9-4.1build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       RTPDataQueue - A packet queue handler for building different kinds of RTP protocol systems.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;ioqueue.h&gt;

       Inherits <b>IncomingDataQueue</b>, and <b>OutgoingDataQueue</b>.

       Inherited by <b>QueueRTCPManager</b>, and <b>RTPDuplex</b>.

   <b>Public</b> <b>Types</b>
       enum <b>Tos</b> { <b>tosBestEffort</b>, <b>tosEnhanced</b> }
           <b>rtp.h</b> cc++/rtp.h

   <b>Public</b> <b>Member</b> <b>Functions</b>
       void <b>setTypeOfService</b> (<b>Tos</b> tos)
           Specify the kind of service the application expects to use.
       void <b>enableStack</b> ()
           Enable packet queue processing in the stack.
       void <b>disableStack</b> ()
           Disable packet queue processing in the stack.
       bool <b>isActive</b> () const
           Get active connection state flag.
       uint32 <b>getCurrentTimestamp</b> () const
           Get the timestamp that should be given for a packet whose payload sampling instant corresponds to the
           current system time.
       void <b>setSessionBandwidth</b> (uint32 bw)
           Specify the bandwidth of the current session.
       uint32 <b>getDefaultSessionBandwidth</b> () const
       uint32 <b>getSessionBandwidth</b> () const
       void <b>setTimeclock</b> ()
           Set the packet timeclock for synchronizing timestamps.
       timeout_t <b>getTimeclock</b> () const
           Get the packet timeclock for synchronizing timestamps.

       Public Member Functions inherited from <b>IncomingDataQueue</b>
       <b>SyncSourcesIterator</b> <b>begin</b> ()
       <b>SyncSourcesIterator</b> <b>end</b> ()
       const <b>AppDataUnit</b> * <b>getData</b> (uint32 stamp, const <b>SyncSource</b> *src=NULL)
           Retreive data from a specific timestamped packet if such a packet is currently available in the
           receive buffer.
       bool <b>isWaiting</b> (const <b>SyncSource</b> *src=NULL) const
           Determine if packets are waiting in the reception queue.
       uint32 <b>getFirstTimestamp</b> (const <b>SyncSource</b> *src=NULL) const
           Get timestamp of first packet waiting in the queue.
       void <b>setMinValidPacketSequence</b> (uint8 packets)
           When receiving packets from a new source, it may be convenient to reject a first few packets before
           we are really sure the source is valid.
       uint8 <b>getDefaultMinValidPacketSequence</b> () const
       uint8 <b>getMinValidPacketSequence</b> () const
           Get the minimun number of consecutive packets that must be received from a source before accepting
           its data packets.
       void <b>setMaxPacketMisorder</b> (uint16 packets)
       uint16 <b>getDefaultMaxPacketMisorder</b> () const
       uint16 <b>getMaxPacketMisorder</b> () const
       void <b>setMaxPacketDropout</b> (uint16 packets)
           It also prevents packets sent after a restart of the source being immediately accepted.
       uint16 <b>getDefaultMaxPacketDropout</b> () const
       uint16 <b>getMaxPacketDropout</b> () const
       void <b>setInQueueCryptoContext</b> (<b>CryptoContext</b> *cc)
           Set input queue <b>CryptoContext</b>.
       void <b>removeInQueueCryptoContext</b> (<b>CryptoContext</b> *cc)
           Remove input queue <b>CryptoContext</b>.
       <b>CryptoContext</b> * <b>getInQueueCryptoContext</b> (uint32 ssrc)
           Get an input queue <b>CryptoContext</b> identified by SSRC.

       Public Member Functions inherited from <b>IncomingDataQueueBase</b>
       size_t <b>getDefaultMaxRecvPacketSize</b> () const
       size_t <b>getMaxRecvPacketSize</b> () const
       void <b>setMaxRecvPacketSize</b> (size_t maxsize)

       Public Member Functions inherited from <b>RTPQueueBase</b>
       bool <b>setPayloadFormat</b> (const <b>PayloadFormat</b> &amp;pf)
           Set the payload format in use, for timing and payload type identification purposes.
       uint32 <b>getLocalSSRC</b> () const
       uint32 <b>getCurrentRTPClockRate</b> () const
           Get the clock rate in RTP clock units (for instance, 8000 units per second for PCMU, or 90000 units
           per second for MP2T).
       <b>PayloadType</b> <b>getCurrentPayloadType</b> () const
       timeval <b>getInitialTime</b> () const

       Public Member Functions inherited from <b>OutgoingDataQueue</b>
       bool <b>addDestination</b> (const InetHostAddress &amp;ia, tpport_t dataPort=<b>DefaultRTPDataPort</b>, tpport_t
           controlPort=0)
       bool <b>addDestination</b> (const InetMcastAddress &amp;ia, tpport_t dataPort=<b>DefaultRTPDataPort</b>, tpport_t
           controlPort=0)
       bool <b>forgetDestination</b> (const InetHostAddress &amp;ia, tpport_t dataPort=<b>DefaultRTPDataPort</b>, tpport_t
           controlPort=0)
       bool <b>forgetDestination</b> (const InetMcastAddress &amp;ia, tpport_t dataPort=<b>DefaultRTPDataPort</b>, tpport_t
           controlPort=0)
       void <b>addContributor</b> (uint32 csrc)
           Add csrc as the CSRC identifier of a new contributor.
       bool <b>removeContributor</b> (uint32 csrc)
           Remove CSRC from the list of contributors.
       bool <b>isSending</b> () const
           Determine if outgoing packets are waiting to send.
       void <b>putData</b> (uint32 stamp, const unsigned char *data=NULL, size_t len=0)
           This is used to create a data packet in the send queue.
       void <b>sendImmediate</b> (uint32 stamp, const unsigned char *data=NULL, size_t len=0)
           This is used to create a data packet and send it immediately.
       void <b>setPadding</b> (uint8 <b>paddinglen</b>)
           Set padding.
       void <b>setMark</b> (bool mark)
           Set marker bit for the packet in which the next data provided will be send.
       bool <b>getMark</b> () const
           Get whether the mark bit will be set in the next packet.
       size_t <b>setPartial</b> (uint32 timestamp, unsigned char *data, size_t offset, size_t max)
           Set partial data for an already queued packet.
       <b>microtimeout_t</b> <b>getDefaultSchedulingTimeout</b> () const
       void <b>setSchedulingTimeout</b> (<b>microtimeout_t</b> to)
           Set the default scheduling timeout to use when no data packets are waiting to be sent.
       <b>microtimeout_t</b> <b>getDefaultExpireTimeout</b> () const
       void <b>setExpireTimeout</b> (<b>microtimeout_t</b> to)
           Set the 'expired' timer for expiring packets pending in the send queue which have gone unsent and are
           already 'too late' to be sent now.
       <b>microtimeout_t</b> <b>getExpireTimeout</b> () const
       uint32 <b>getSendPacketCount</b> () const
           Get the total number of packets sent so far.
       uint32 <b>getSendOctetCount</b> () const
           Get the total number of octets (payload only) sent so far.
       uint16 <b>getSequenceNumber</b> () const
           Get the sequence number of the next outgoing packet.
       void <b>setOutQueueCryptoContext</b> (<b>CryptoContext</b> *cc)
           Set output queue <b>CryptoContext</b>.
       void <b>removeOutQueueCryptoContext</b> (<b>CryptoContext</b> *cc)
           Remove output queue <b>CryptoContext</b>.
       <b>CryptoContext</b> * <b>getOutQueueCryptoContext</b> (uint32 ssrc)
           Get an output queue <b>CryptoContext</b> identified by SSRC.

       Public Member Functions inherited from <b>OutgoingDataQueueBase</b>
       size_t <b>getDefaultMaxSendSegmentSize</b> ()
       void <b>setMaxSendSegmentSize</b> (size_t size)
           Set maximum payload segment size before fragmenting sends.
       size_t <b>getMaxSendSegmentSize</b> ()

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       <b>RTPDataQueue</b> (uint32 size=<b>defaultMembersHashSize</b>)
           Constructor.
       <b>RTPDataQueue</b> (uint32 *ssrc, uint32 size=<b>defaultMembersHashSize</b>)
           Using this constructor you can start a session with the given ssrc, instead of the usual randomly
           generated one.
       virtual <b>~RTPDataQueue</b> ()
           The queue destructor flushes the queue and stops all services.
       virtual void <b>timerTick</b> ()
           A plugin point for timer tick driven events.
       void <b>renewLocalSSRC</b> ()
       void <b>endQueue</b> ()
           This method ends the queue.
       virtual bool <b>isPendingData</b> (<b>microtimeout_t</b> timeout)=0
           This function is used to check for and schedule against arriving packets based on the derived
           connection type.

       Protected Member Functions inherited from <b>IncomingDataQueue</b>
       <b>IncomingDataQueue</b> (uint32 size)
       virtual <b>~IncomingDataQueue</b> ()
       bool <b>checkSSRCInIncomingRTPPkt</b> (<b>SyncSourceLink</b> &amp;sourceLink, bool is_new, InetAddress &amp;na, tpport_t tp)
           Apply collision and loop detection and correction algorithm when receiving RTP data packets.
       void <b>setSourceExpirationPeriod</b> (uint8 intervals)
           Set the number of RTCP intervals that the stack will wait to change the state of a source from
           stateActive to stateInactive, or to delete the source after being in stateInactive.
       virtual size_t <b>takeInDataPacket</b> ()
           This function is used by the service thread to process the next incoming packet and place it in the
           receive list.
       <b>IncomingDataQueue::IncomingRTPPktLink</b> * <b>getWaiting</b> (uint32 timestamp, const <b>SyncSource</b> *src=NULL)
           This is used to fetch a packet in the receive queue and to expire packets older than the current
           timestamp.
       bool <b>recordReception</b> (<b>SyncSourceLink</b> &amp;srcLink, const <b>IncomingRTPPkt</b> &amp;pkt, const timeval recvtime)
           Log reception of a new RTP packet from this source.
       void <b>recordExtraction</b> (const <b>IncomingRTPPkt</b> &amp;pkt)
           Log extraction of a packet from this source from the scheduled reception queue.
       void <b>purgeIncomingQueue</b> ()
       virtual void <b>onNewSyncSource</b> (const <b>SyncSource</b> &amp;)
           Virtual called when a new synchronization source has joined the session.
       virtual bool <b>onRTPPacketRecv</b> (<b>IncomingRTPPkt</b> &amp;)
           A virtual function to support parsing of arriving packets to determine if they should be kept in the
           queue and to dispatch events.
       virtual void <b>onExpireRecv</b> (<b>IncomingRTPPkt</b> &amp;)
           A hook to filter packets in the receive queue that are being expired.
       virtual bool <b>onSRTPPacketError</b> (<b>IncomingRTPPkt</b> &amp;pkt, int32 errorCode)
           A hook that gets called if the decoding of an incoming SRTP was erroneous.
       virtual bool <b>end2EndDelayed</b> (<b>IncomingRTPPktLink</b> &amp;)
       bool <b>insertRecvPacket</b> (<b>IncomingRTPPktLink</b> *packetLink)
           Insert a just received packet in the queue (both general and source specific queues).
       virtual size_t <b>recvData</b> (unsigned char *buffer, size_t length, InetHostAddress &amp;host, tpport_t &amp;port)=0
           This function performs the physical I/O for reading a packet from the source.
       virtual size_t <b>getNextDataPacketSize</b> () const =0

       Protected Member Functions inherited from <b>IncomingDataQueueBase</b>
       <b>IncomingDataQueueBase</b> ()
       virtual <b>~IncomingDataQueueBase</b> ()

       Protected Member Functions inherited from <b>RTPQueueBase</b>
       <b>RTPQueueBase</b> (uint32 *ssrc=NULL)
       void <b>setLocalSSRC</b> (uint32 ssrc)
       uint32 <b>getLocalSSRCNetwork</b> () const
       virtual <b>~RTPQueueBase</b> ()
       virtual size_t <b>dispatchBYE</b> (const std::string &amp;)
           A plugin point for posting of BYE messages.

       Protected Member Functions inherited from <b>MembershipBookkeeping</b>
       <b>MembershipBookkeeping</b> (uint32 initialSize=<b>defaultMembersHashSize</b>)
           The initial size is a hint to allocate the resources needed in order to keep the members' identifiers
           and associated information.
       virtual <b>~MembershipBookkeeping</b> ()
           Purges all RTPSource structures created during the session, as well as the hash table and the list of
           sources.
       <b>SyncSourceLink</b> * <b>getLink</b> (const <b>SyncSource</b> &amp;source) const
       bool <b>isMine</b> (const <b>SyncSource</b> &amp;source) const
           Get whether a synchronization source is recorded in this membership controller.
       bool <b>isRegistered</b> (uint32 ssrc)
           Returns whether there is already a synchronizacion source with 'ssrc' SSRC identifier.
       <b>SyncSourceLink</b> * <b>getSourceBySSRC</b> (uint32 ssrc, bool &amp;created)
           Get the description of a source by its ssrc identifier.
       bool <b>BYESource</b> (uint32 ssrc)
           Mark the source identified by ssrc as having sent a BYE packet.
       bool <b>removeSource</b> (uint32 ssrc)
           Remove the description of the source identified by ssrc
       <b>SyncSourceLink</b> * <b>getFirst</b> ()
       <b>SyncSourceLink</b> * <b>getLast</b> ()
       uint32 <b>getMembersCount</b> ()
       void <b>setMembersCount</b> (uint32 n)
       uint32 <b>getSendersCount</b> ()
       size_t <b>getDefaultMembersHashSize</b> ()

       Protected Member Functions inherited from <b>SyncSourceHandler</b>
       <b>SyncSourceHandler</b> ()
       virtual <b>~SyncSourceHandler</b> ()
       void * <b>getLink</b> (const <b>SyncSource</b> &amp;source) const
           This requires <b>SyncSource</b> - <b>SyncSourceHandler</b> friendship.
       void <b>setLink</b> (<b>SyncSource</b> &amp;source, void *link)
       void <b>setParticipant</b> (<b>SyncSource</b> &amp;source, <b>Participant</b> &amp;p)
       void <b>setState</b> (<b>SyncSource</b> &amp;source, <b>SyncSource::State</b> ns)
       void <b>setSender</b> (<b>SyncSource</b> &amp;source, bool active)
       void <b>setDataTransportPort</b> (<b>SyncSource</b> &amp;source, tpport_t p)
       void <b>setControlTransportPort</b> (<b>SyncSource</b> &amp;source, tpport_t p)
       void <b>setNetworkAddress</b> (<b>SyncSource</b> &amp;source, InetAddress addr)

       Protected Member Functions inherited from <b>ParticipantHandler</b>
       <b>ParticipantHandler</b> ()
       virtual <b>~ParticipantHandler</b> ()
       void <b>setSDESItem</b> (<b>Participant</b> *part, <b>SDESItemType</b> item, const std::string &amp;val)
       void <b>setPRIVPrefix</b> (<b>Participant</b> *part, const std::string val)

       Protected Member Functions inherited from <b>ApplicationHandler</b>
       <b>ApplicationHandler</b> ()
       virtual <b>~ApplicationHandler</b> ()
       void <b>addParticipant</b> (<b>RTPApplication</b> &amp;app, <b>Participant</b> &amp;part)
       void <b>removeParticipant</b> (<b>RTPApplication</b> &amp;app, RTPApplication::ParticipantLink *pl)

       Protected Member Functions inherited from <b>ConflictHandler</b>
       <b>ConflictHandler</b> ()
       virtual <b>~ConflictHandler</b> ()
       <b>ConflictingTransportAddress</b> * <b>searchDataConflict</b> (InetAddress na, tpport_t dtp)
       <b>ConflictingTransportAddress</b> * <b>searchControlConflict</b> (InetAddress na, tpport_t ctp)
       void <b>updateConflict</b> (<b>ConflictingTransportAddress</b> &amp;ca)
       void <b>addConflict</b> (const InetAddress &amp;na, tpport_t dtp, tpport_t ctp)

       Protected Member Functions inherited from <b>OutgoingDataQueue</b>
       <b>OutgoingDataQueue</b> ()
       virtual <b>~OutgoingDataQueue</b> ()
       void <b>dispatchImmediate</b> (<b>OutgoingRTPPkt</b> *packet)
           This is used to write the RTP data packet to one or more destinations.
       <b>microtimeout_t</b> <b>getSchedulingTimeout</b> ()
           This computes the timeout period for scheduling transmission of the next packet at the 'head' of the
           send buffer.
       size_t <b>dispatchDataPacket</b> ()
           This function is used by the service thread to process the next outgoing packet pending in the
           sending queue.
       void <b>setNextSeqNum</b> (uint32 seqNum)
           For thoses cases in which the application requires a method to set the sequence number for the
           outgoing stream (such as for implementing the RTSP PLAY command).
       uint32 <b>getCurrentSeqNum</b> (void)
       void <b>setInitialTimestamp</b> (uint32 ts)
       uint32 <b>getInitialTimestamp</b> ()
       void <b>purgeOutgoingQueue</b> ()
       virtual void <b>setControlPeer</b> (const InetAddress &amp;host, tpport_t port)

       Protected Member Functions inherited from <b>OutgoingDataQueueBase</b>
       <b>OutgoingDataQueueBase</b> ()
       virtual <b>~OutgoingDataQueueBase</b> ()

       Protected Member Functions inherited from <b>DestinationListHandler</b>
       void <b>writeLockDestinationList</b> () const
       bool <b>addDestinationToList</b> (const InetAddress &amp;ia, tpport_t data, tpport_t control)
           Locks the object before modifying it.
       bool <b>removeDestinationFromList</b> (const InetAddress &amp;ia, tpport_t dataPort, tpport_t controlPort)
           Locks the object before modifying it.
       <b>DestinationListHandler</b> ()
       <b>~DestinationListHandler</b> ()
       bool <b>isSingleDestination</b> () const
           Get whether there is only a destination in the list.
       <b>TransportAddress</b> * <b>getFirstDestination</b> () const
       void <b>lockDestinationList</b> () const
       void <b>unlockDestinationList</b> () const

   <b>Additional</b> <b>Inherited</b> <b>Members</b>
       Static Public Member Functions inherited from <b>IncomingDataQueue</b>
       static size_t <b>getDefaultMembersSize</b> ()

       Protected Attributes inherited from <b>IncomingDataQueue</b>
       ThreadLock <b>recvLock</b>
       <b>IncomingRTPPktLink</b> * <b>recvFirst</b>
       <b>IncomingRTPPktLink</b> * <b>recvLast</b>
       uint8 <b>minValidPacketSequence</b>
       uint16 <b>maxPacketMisorder</b>
       uint16 <b>maxPacketDropout</b>
       uint8 <b>sourceExpirationPeriod</b>
       Mutex <b>cryptoMutex</b>
       std::list&lt; <b>CryptoContext</b> * &gt; <b>cryptoContexts</b>

       Protected Attributes inherited from <b>ConflictHandler</b>
       <b>ConflictingTransportAddress</b> * <b>firstConflict</b>
       <b>ConflictingTransportAddress</b> * <b>lastConflict</b>

       Protected Attributes inherited from <b>OutgoingDataQueue</b>
       Mutex <b>cryptoMutex</b>
       std::list&lt; <b>CryptoContext</b> * &gt; <b>cryptoContexts</b>

       Protected Attributes inherited from <b>DestinationListHandler</b>
       std::list&lt; <b>TransportAddress</b> * &gt; <b>destList</b>

       Static Protected Attributes inherited from <b>IncomingDataQueue</b>
       static const uint8 <b>defaultMinValidPacketSequence</b>
       static const uint16 <b>defaultMaxPacketMisorder</b>
       static const uint16 <b>defaultMaxPacketDropout</b>
       static const size_t <b>defaultMembersSize</b>

       Static Protected Attributes inherited from <b>MembershipBookkeeping</b>
       static const size_t <b>defaultMembersHashSize</b>
       static const uint32 <b>SEQNUMMOD</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       A packet queue handler for building different kinds of RTP protocol systems.

       The queue manages both incoming and outgoing RTP packets, as well as synchronization and
       transmission/reception timers. By making the queue handler a seperate base class it becomes possible to
       define RTP classes for RTP profiles and sessions of different types.

       Outgoing packets are sent via the <b>OutgoingDataQueue::putData</b> method.

       Incoming packets can be retrieved via <b>IncomingDataQueue::getData</b> method.

       <b>Author</b>
           David Sugar <a href="mailto:dyfet@ostel.com">dyfet@ostel.com</a>

       RTP data queue handler.

</pre><h4><b>Member</b> <b>Enumeration</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>RTPDataQueue::Tos</b>
       <b>rtp.h</b> cc++/rtp.h Type of network service the application uses.

       If the application uses enhanced network service, for instance Integrated Services or Differentiated
       Services, it <u>has</u> <u>not</u> to ensure fair competition with TCP, provided that the requested service is actually
       being delivered. Whenever the application uses best-effort service or the requested enhanced service is
       not actually being delivered, it <u>has</u> to ensure fair competition with TCP. By default, best-effot is
       assumed.

       <b>Note</b>
           Although not required, RTP packets are always sent on top of UDP segments. No other underlying
           transport protocol is supported at present.

       <b>Enumerator</b>

       <u>tosBestEffort</u>
              Best-effort network service.

       <u>tosEnhanced</u>
              Enhanced network service.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>RTPDataQueue::RTPDataQueue</b> <b>(uint32</b> <b>size</b> <b>=</b> <b>defaultMembersHashSize)</b> <b>[protected]</b>
       Constructor. This will generate a random application SSRC identifier.

       <b>Parameters</b>
           <u>size</u> an estimation of the number of participants in the session

   <b>RTPDataQueue::RTPDataQueue</b> <b>(uint32</b> <b>*</b> <b>ssrc,</b> <b>uint32</b> <b>size</b> <b>=</b> <b>defaultMembersHashSize)</b> <b>[protected]</b>
       Using  this  constructor  you  can  start  a  session  with the given ssrc, instead of the usual randomly
       generated one. This is necessary when you  need  to  initiate  several  sessions  having  the  same  SSRC
       identifier,  for  instance,  to implement layered encoding, in which case each layer is managed through a
       different session but all sessions share the same SSRC identifier.

       <b>Warning</b>
           This doesn't seem to be a good solution

       <b>Parameters</b>
           <u>ssrc</u> Synchronization SouRCe identifier for this session
           <u>size</u> an estimation of the number of participants in the session

   <b>virtual</b> <b>RTPDataQueue::~RTPDataQueue</b> <b>()</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       The queue destructor flushes the queue and stops all services.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>RTPDataQueue::disableStack</b> <b>(void)</b> <b>[inline]</b>
       Disable packet queue processing in the stack.

   <b>void</b> <b>RTPDataQueue::enableStack</b> <b>(void)</b> <b>[inline]</b>
       Enable packet queue processing in the stack. This method will not any thread of execution.

   <b>void</b> <b>RTPDataQueue::endQueue</b> <b>()</b> <b>[protected]</b>
       This method ends the queue.

   <b>uint32</b> <b>RTPDataQueue::getCurrentTimestamp</b> <b>()</b> <b>const</b>
       Get the timestamp that should be given for a packet whose payload sampling  instant  corresponds  to  the
       current  system  time.  The timestamp applications should provide for each packet represents the sampling
       instant of its payload and should not be a reading  of  the  system  clock.  Nevertheless,  the  internal
       operation  of  the RTP stack relies on the accuracy of the provided timestamp, since several computations
       assume that there is a certain degree of correspondence between the timestamp and the system clock.

       It is recommended that applications use this method in order to <u>periodically</u> <u>adjust</u> <u>the</u> <u>RTP</u> <u>timestamp</u>.

       In particular, it is advisable getting the timestamp corresponding to the first sampling instant  or  any
       instant after a period of inactivity through a call to this method.

       Applications should use the nominal sampling or any other value provided by the coder in order to compute
       the next timestamps with minimum computational requirement.

       For  instance,  an  application  using  an RTP profile that specifies a fixed sampling rate of 8 Khz with
       eight bits per sample, continuously transmitting audio blocks 80 octets long, would transmit 100  packets
       every  second. Every packet would carry a timestamp 80 units greater than the previous one. So, the first
       timestamp would be obtained from this method, whereas the following ones  would  be  computed  adding  80
       every  time.  Also  the  timestamp  should be increased for every block whether it is put in the queue or
       dropped.

       The aforementioned increment can be obtained from the RTPDataQueue::getTimestampIncrement() method rather
       than computing it by hand in the application.

       <b>Note</b>
           Frame based applications must follow a specific timestamping method, probably specified in a profile.

           You should take into account that by default ccRTP assumes that the application  begins  sampling  at
           the  queue creation time. Moreover, the first sampling instant is assigned a 'user visible' timestamp
           of 0, although the RTP stack will then add internally a ramdom offset  unknown  to  the  application.
           That  is  to say, the application may count samples from 0 in order to get the timestamp for the next
           packet, provided  that  the  first  sampling  instant  is  the  same  as  the  queue  creation  time.
           Nevertheless,  this simpler way of starting will not be as accurate as it would be if the application
           got at least the first timestamp through getCurrentTimestamp. <u>We</u>  <u>provide</u>  <u>this</u>  <u>option</u>  <u>since</u>  <u>ccRTP</u>
           <u>interface</u>  <u>is</u>  <u>evolving,</u>  <u>but</u>  <u>we</u>  <u>admit</u> <u>that</u> <u>it</u> <u>is</u> <u>ugly,</u> <u>we</u> <u>could</u> <u>remove</u> <u>this</u> <u>option</u> <u>or</u> <u>even</u> <u>replace</u>
           <u>uint32</u> <u>timestamps</u> <u>with</u> <u>a</u> <u>restrictively</u> <u>regulated</u> <u>object;</u> <u>suggestions</u> <u>are</u> <u>gladly</u> <u>welcomed</u>

       <b>Examples</b>
           <b>rtphello.cpp</b>.

   <b>uint32</b> <b>RTPDataQueue::getDefaultSessionBandwidth</b> <b>()</b> <b>const</b> <b>[inline]</b>
   <b>uint32</b> <b>RTPDataQueue::getSessionBandwidth</b> <b>()</b> <b>const</b> <b>[inline]</b>
   <b>timeout_t</b> <b>RTPDataQueue::getTimeclock</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Get the packet timeclock for synchronizing timestamps.

       <b>Returns</b>
           runtime in milliseconds since last set.

   <b>bool</b> <b>RTPDataQueue::isActive</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Get active connection state flag.

       <b>Returns</b>
           true if connection 'active'.

       <b>Examples</b>
           <b>audiorx.cpp</b>, <b>audiotx.cpp</b>, and <b>rtphello.cpp</b>.

   <b>virtual</b> <b>bool</b> <b>RTPDataQueue::isPendingData</b> <b>(microtimeout_t</b> <b>timeout)</b> <b>[protected],</b>  <b>[pure</b> <b>virtual]</b>
       This function is used to check for and schedule against arriving packets based on the derived  connection
       type.

       <b>Returns</b>
           true if packet waiting for processing.

       <b>Parameters</b>
           <u>number</u> of microseconds to wait.

       Implemented  in <b>RTPDuplex</b>, <b>TRTPSessionBase&lt;</b> <b>RTPDataChannel,</b> <b>RTCPChannel,</b> <b>ServiceQueue</b> <b>&gt;</b>, <b>TRTPSessionBase&lt;</b>
       <b>DualRTPUDPIPv4Channel,</b> <b>DualRTPUDPIPv4Channel,</b> <b>AVPQueue</b>  <b>&gt;</b>,  and  <b>SingleThreadRTPSession&lt;</b>  <b>RTPDataChannel,</b>
       <b>RTCPChannel,</b> <b>ServiceQueue</b> <b>&gt;</b>.

   <b>void</b> <b>RTPDataQueue::renewLocalSSRC</b> <b>()</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       Reimplemented from <b>IncomingDataQueue</b>.

   <b>void</b> <b>RTPDataQueue::setSessionBandwidth</b> <b>(uint32</b> <b>bw)</b> <b>[inline]</b>
       Specify the bandwidth of the current session.

       <b>Parameters</b>
           <u>bw</u> bandwidth of the current session, in bits/s.

       <b>See</b> <b>also</b>
           <b>AVPQueue::setControlBandwidth()</b>

   <b>void</b> <b>RTPDataQueue::setTimeclock</b> <b>()</b> <b>[inline]</b>
       Set the packet timeclock for synchronizing timestamps.

   <b>void</b> <b>RTPDataQueue::setTypeOfService</b> <b>(Tos</b> <b>tos)</b> <b>[inline]</b>
       Specify the kind of service the application expects to use.

       <b>Parameters</b>
           <u>tos</u> type of service the application expects to use

       <b>Note</b>
           If  enhanced  service  is specified but packet loss is high (the requested service does not appear to
           actually be delivered) ccRTP defaults to best-effort suitable behaviour: guarantee  fair  competition
           with TCP.

   <b>virtual</b> <b>void</b> <b>RTPDataQueue::timerTick</b> <b>(void)</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       A plugin point for timer tick driven events.

       Reimplemented in <b>SingleThreadRTPSession&lt;</b> <b>RTPDataChannel,</b> <b>RTCPChannel,</b> <b>ServiceQueue</b> <b>&gt;</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for ccRTP from the source code.

                                                      ccRTP                                      <u><a href="../man3/RTPDataQueue.3.html">RTPDataQueue</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>