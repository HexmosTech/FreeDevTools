<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>packet.unpack - Unpack module</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/nfstest">nfstest_3.2-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       packet.unpack - Unpack module

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Provides the object for managing and unpacking raw data from a working buffer.

</pre><h4><b>CLASSES</b></h4><pre>
   <b>class</b> <b>Unpack(builtins.object)</b>
       Unpack object

       Usage:
           from packet.unpack import Unpack

           x = Unpack(buffer)

           # Get 32 bytes from the working buffer and move the offset pointer
           data = <a href="../man32/x.read.32.html">x.read</a>(32)

           # Get all the unprocessed bytes from the working buffer
           # (all bytes starting from the offset pointer)
           # Do not move the offset pointer
           data = x.getbytes()

           # Get all bytes from the working buffer from the given offset
           # Do not move the offset pointer
           data = x.getbytes(offset)

           # Return the number of unprocessed bytes left in the working buffer
           size = x.size()
           size = len(x)

           # Get the offset pointer
           offset = x.tell()

           # Set the offset pointer
           x.seek(offset)

           # Append the given data to the working buffer
           x.append(data)

           # Insert the given data to the working buffer right before the
           # offset pointer. This resets the working buffer completely
           # and the offset pointer is initialized to zero. It is like
           # re-instantiating the object like:
           #   x = Unpack(data + x.getbytes())
           x.insert(data)

           # Save state
           sid = x.save_state()

           # Restore state
           x.restore_state(sid)

           # Unpack an 'unsigned short' (2 bytes in network order)
           short_int = x.unpack(2, '!H')[0]

           # Unpack different basic types
           char      = x.unpack_char()
           uchar     = x.unpack_uchar()
           short     = x.unpack_short()
           ushort    = x.unpack_ushort()
           int       = x.unpack_int()
           uint      = x.unpack_uint()
           int64     = x.unpack_int64()
           uint64    = x.unpack_uint64()
           data1     = x.unpack_opaque()
           data2     = <a href="../man64/x.unpack_opaque.64.html">x.unpack_opaque</a>(64)  # Length of opaque must be &lt;= 64
           data3     = <a href="../man32/x.unpack_fopaque.32.html">x.unpack_fopaque</a>(32)

           # Get string where length is given as an unsigned integer
           buffer = x.unpack_string()
           # Get string of fixed length
           buffer = <a href="../man32/x.unpack_string.32.html">x.unpack_string</a>(32)
           # Get string where length is given as a short integer
           buffer = x.unpack_string(Unpack.unpack_short)
           buffer = x.unpack_string(ltype=Unpack.unpack_short)
           # Get string padded to a 4 byte boundary, discard padding bytes
           buffer = x.unpack_string(pad=4)

           # Get an array of unsigned integers
           alist = x.unpack_array()
           # Get a fixed length array of unsigned integers
           alist = x.unpack_array(ltype=10)
           # Get an array of short integers
           alist = x.unpack_array(Unpack.unpack_short)
           # Get an array of strings, the length of the array is given
           # by a short integer
           alist = x.unpack_array(Unpack.unpack_string, Unpack.unpack_short)
           # Get an array of strings, the length of each string is given by
           # a short integer and each string is padded to a 4 byte boundary
           alist = x.unpack_array(Unpack.unpack_string, uargs={'ltype':Unpack.unpack_short, 'pad':4})
           # Get an array of objects decoded by item_obj where the first
           # argument to item_obj is the unpack object, e.g., item = item_obj(x)
           alist = x.unpack_array(item_obj)

           # Get a list of unsigned integers
           alist = x.unpack_list()
           # Get a list of short integers
           alist = x.unpack_list(Unpack.unpack_short)
           # Get a list of strings, the next item flag is given
           # by a short integer
           alist = x.unpack_list(Unpack.unpack_string, Unpack.unpack_short)
           # Get a list of strings, the length of each string is given by
           # a short integer and each string is padded to a 4 byte boundary
           alist = x.unpack_list(Unpack.unpack_string, uargs={'ltype':Unpack.unpack_short, 'pad':4})

           # Unpack a conditional, it unpacks a conditional flag first and
           # if it is true it unpacks the item given and returns it. If the
           # conditional flag decoded is false, the method returns None
           buffer = x.unpack_conditional(Unpack.unpack_opaque)

           # Unpack an array of unsigned integers and convert array into
           # a single long integer
           bitmask = unpack_bitmap()

       <b>Methods</b> <b>defined</b> <b>here:</b>
       ---------------------

       <b>__init__(self,</b> <b>data)</b>
       Constructor

       Initialize object's private data.

              <b>data:</b>  Raw packet data

       <b>__len__</b> <b>=</b> <b>size(self)</b>

       <b>append(self,</b> <b>data)</b>
       Append data to the working buffer.

       <b>getbytes(self,</b> <b>offset=None)</b>
       Get the number of bytes given from the working buffer.
       Do not move the offset pointer.

              <b>offset:</b>
                     Starting offset of data to return [default: current offset]

       <b>insert(self,</b> <b>data)</b>
       Insert data to the beginning of the current working buffer.

       <b>read(self,</b> <b>size,</b> <b>pad=0)</b>
       Get the number of bytes given from the working buffer.
       Move the offset pointer.

              <b>size:</b>  Length of data to get

              <b>pad:</b>   Get and discard padding bytes [default: 0]
                     If given, data is padded to this byte boundary

       <b>restore_state(self,</b> <b>sid)</b>
       Restore state given by the state id

       <b>save_state(self)</b>
       Save state and return the state id

       <b>seek(self,</b> <b>offset)</b>
       Set the offset pointer.

       <b>size(self)</b>
       Return the number of unprocessed bytes left in the working buffer

       <b>tell(self)</b>
       Get the offset pointer.

       <b>unpack(self,</b> <b>size,</b> <b>fmt)</b>
       Get the number of bytes given from the working buffer and process
       it according to the given format.
       Return a tuple of unpack items, see struct.unpack.

              <b>size:</b>  Length of data to process

              <b>fmt:</b>   Format string on how to process data

       <b>unpack_array(self,</b> <b>unpack_item=&lt;function</b> <b>Unpack.unpack_uint</b> <b>at</b> <b>0x7fdc09097d08&gt;,</b> <b>ltype=&lt;function</b> <b>Unpack.unpack_uint</b> <b>at</b> <b>0x7fdc09097d08&gt;,</b> <b>uargs={},</b> <b>maxcount=0,</b> <b>islist=False)</b>
       Get a variable length array, the type of objects in the array
       is given by the unpacking function unpack_item and the type
       to decode the length of the array is given by ltype

              <b>unpack_item:</b>
                     Unpack function for each item in the array [default: unpack_uint]

              <b>ltype:</b> Function to decode length of array [default: unpack_uint]
                     Could also be given as an integer to have a fixed length array

              <b>uargs:</b> Named arguments to pass to unpack_item function [default: {}]

              <b>maxcount:</b>
                     Maximum length of array [default: any length]

       <b>unpack_bitmap(self)</b>
       Unpack an array of unsigned integers and convert array into
       a single long integer

       <b>unpack_char(self)</b>
       Get a signed char

       <b>unpack_conditional(self,</b> <b>unpack_item=&lt;function</b> <b>Unpack.unpack_uint</b> <b>at</b> <b>0x7fdc09097d08&gt;,</b> <b>ltype=&lt;function</b> <b>Unpack.unpack_uint</b> <b>at</b> <b>0x7fdc09097d08&gt;,</b> <b>uargs={})</b>
       Get an item if condition flag given by ltype is true, if condition
       flag is false then return None

              <b>unpack_item:</b>
                     Unpack function for item if condition is true [default: unpack_uint]

              <b>ltype:</b> Function to decode the condition flag [default: unpack_uint]

              <b>uargs:</b> Named arguments to pass to unpack_item function [default: {}]

       <b>unpack_fopaque(self,</b> <b>size)</b>
       Get a fixed length opaque

       <b>unpack_futf8(self,</b> <b>size)</b>
       Get a fixed length utf8 string

       <b>unpack_int(self)</b>
       Get a signed integer

       <b>unpack_int64(self)</b>
       Get a signed 64 bit integer

       <b>unpack_list(self,</b> <b>*kwts,</b> <b>**kwds)</b>
       Get an indeterminate size list, the type of objects in the list
       is given by the unpacking function unpack_item and the type
       to decode the next item flag is given by ltype

              <b>unpack_item:</b>
                     Unpack function for each item in the list [default: unpack_uint]

              <b>ltype:</b> Function to decode the next item flag [default: unpack_uint]

              <b>uargs:</b> Named arguments to pass to unpack_item function [default: {}]

       <b>unpack_opaque(self,</b> <b>maxcount=0)</b>
       Get a variable length opaque up to a maximum length of maxcount

       <b>unpack_short(self)</b>
       Get a signed short integer

       <b>unpack_string(self,</b> <b>ltype=&lt;function</b> <b>Unpack.unpack_uint</b> <b>at</b> <b>0x7fdc09097d08&gt;,</b> <b>pad=0,</b> <b>maxcount=0)</b>
       Get a variable length string

              <b>ltype:</b> Function to decode length of string [default: unpack_uint]
                     Could also be given as an integer to have a fixed length string

              <b>pad:</b>   Get and discard padding bytes [default: 0]
                     If given, string is padded to this byte boundary

              <b>maxcount:</b>
                     Maximum length of string [default: any length]

       <b>unpack_uchar(self)</b>
       Get an unsigned char

       <b>unpack_uint(self)</b>
       Get an unsigned integer

       <b>unpack_uint64(self)</b>
       Get an unsigned 64 bit integer

       <b>unpack_ushort(self)</b>
       Get an unsigned short integer

       <b>unpack_utf8(self,</b> <b>maxcount=0)</b>
       Get a variable length utf8 string up to a maximum length of maxcount

</pre><h4><b>BUGS</b></h4><pre>
       No known bugs.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jorge Mora (<a href="mailto:mora@netapp.com">mora@netapp.com</a>)

NFStest 3.2                                       21 March 2023                                        <u><a href="../man3/UNPACK.3.html">UNPACK</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>