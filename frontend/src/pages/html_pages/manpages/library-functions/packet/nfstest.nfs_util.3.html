<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nfstest.nfs_util - NFS utilities module</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/nfstest">nfstest_3.2-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       nfstest.nfs_util - NFS utilities module

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Provides  a  set  of  tools  for  testing NFS including methods for starting a packet trace, stopping the
       packet trace and then open the packet trace for analysis.  It also provides a mechanism to enable NFS/RPC
       kernel debug and saving the log messages for further analysis.

       Furthermore, methods for finding specific NFSv4 operations within the packet trace are also included.

</pre><h4><b>CLASSES</b></h4><pre>
   <b>class</b> <b>NFSUtil(nfstest.host.Host)</b>
       NFSUtil object

       NFSUtil() -&gt; New NFSUtil object

       Usage:
           from nfstest.nfs_util import NFSUtil

           # Create object for local host
           x = NFSUtil()

           # Create client host object
           clientobj = x.create_host('192.168.0.11')

           # Use buffered matching on packets
           x.set_pktlist()

           # Get the next LOOKUP packets
           pktcall, pktreply = x.find_nfs_op(OP_LOOKUP)

           # Get OPEN information for the given file name
           fh, open_stid, deleg_stid = x.find_open(filename="file1")

           # Get address and port number from universal address string
           ipaddr, port = x.get_addr_port(addr)

           # Get packets and DS list for GETDEVICEINFO
           pktcall, pktreply, dslist = x.find_getdeviceinfo()

           # Get packets for EXCHANGE_ID
           pktcall, pktreply = x.find_exchange_id()

           # Get the NFS operation object from the given packet
           getfh = x.getop(x.pktreply, OP_GETFH)

           # Get the stateid which must be used by I/O operations
           stateid = x.get_stateid("file1")

           # Get the client id
           clientid = x.get_clientid()

           # Get the session id for the given clientid
           sessionid = x.get_sessionid(clientid=clientid)

           # Get the root file handle from PUTROOTFH for the given session id
           x.get_rootfh(sessionid=sessionid)

           # Get the file handle for the given path
           dirfh = x.get_pathfh("/vol1/data")

           # Display the state id in CRC32 format
           stidstr = x.stid_str(stateid)

           # Get the number of bytes available in the given directory
           freebytes = x.get_freebytes("/mnt/t")

       <b>Methods</b> <b>defined</b> <b>here:</b>
       ---------------------

       <b>__del__(self)</b>
       Destructor

       <b>__init__(self,</b> <b>**kwargs)</b>
       Constructor

       Initialize object's private data.

       <b>cleanup(self)</b>
       Gracefully stop the packet trace and un-reference all client
       objects

       <b>create_host(self,</b> <b>host,</b> <b>**kwargs)</b>
       Create client host object and set defaults.

       <b>find_exchange_id(self,</b> <b>**kwargs)</b>
       Find the call and its corresponding reply for the NFSv4 EXCHANGE_ID
       going to the server specified by the ipaddr and port.

              <b>ipaddr:</b>
                     Destination IP address [default: self.server_ipaddr]

              <b>port:</b>  Destination port [default: self.port]

              Store the callback IP/TCP expression in object attribute cb_dst

              Return a tuple: (pktcall, pktreply).

       <b>find_getdeviceinfo(self,</b> <b>deviceid=None,</b> <b>usecache=True)</b>
       Find the call and its corresponding reply for the NFSv4 GETDEVICEINFO
       going to the server specified by the ipaddr for self.server and port
       given by self.port.

              <b>deviceid:</b>
                     Look for an specific deviceid [default: any deviceid]

              <b>usecache:</b>
                     If GETDEVICEINFO is not found look for it in the cache and if
                     deviceid is None use the one found in self.layout.
                     [default: True]

              Return a tuple: (pktcall, pktreply, dslist).

       <b>find_layoutget(self,</b> <b>filehandle,</b> <b>status=0)</b>
       Find the call and its corresponding reply for the NFSv4 LAYOUTGET
       of the given file handle going to the server specified by the
       ipaddr for self.server and port given by self.port.

       Return a tuple: (layoutget, layoutget_res).
       Layout information is stored in object attribute "layout".

       <b>find_layoutrecall(self,</b> <b>status=0)</b>
       Find NFSv4 CB_LAYOUTRECALL call and return its reply.
       The reply must also match the given status.

       <b>find_nfs_op(self,</b> <b>op,</b> <b>**kwargs)</b>
       Find the call and its corresponding reply for the specified NFSv4
       operation going to the server specified by the ipaddr and port.
       The reply must also match the given status. Also the following
       object attributes are defined: pktcall referencing the packet call
       while pktreply referencing the packet reply.

              <b>op:</b>    NFS operation to find

              <b>ipaddr:</b>
                     Destination IP address [default: self.server_ipaddr]
                     A value of None matches any IP address

              <b>port:</b>  Destination port [default: self.port]
                     A value of None matches any destination port

              <b>proto:</b> Protocol [default: self.proto]

              <b>match:</b> Match string to include [default: '']

              <b>status:</b>
                     Match the status of the operation [default: 0]
                     A value of None matches any status.

              <b>src_ipaddr:</b>
                     Source IP address [default: None]
                     A value of None matches any IP address

              <b>maxindex:</b>
                     The match fails if packet index hits this limit [default: None]
                     A value of None means there is no limit

              <b>call_only:</b>
                     Find the call only [default: False]

              <b>first_call:</b>
                     Return on first call even if reply is not found [default: False]

              <b>last_call:</b>
                     Return last call even if reply is not found [default: False]

              <b>nfs_version:</b>
                     NFS version to use in search [default: mounted NFS version]

              Return a tuple: (pktcall, pktreply).

       <b>find_open(self,</b> <b>**kwargs)</b>
       Find the call and its corresponding reply for the NFSv4 OPEN of the
       given file going to the server specified by the ipaddr and port.
       The following object attributes are defined: opencall and pktcall
       both referencing the packet call while openreply and pktreply both
       referencing the packet reply.
       In the case for NFSv3, search for LOOKUP or CREATE to get the file
       handle.

              <b>filename:</b>
                     Find open call and reply for this file [default: None]

              <b>claimfh:</b>
                     Find open call and reply for this file handle using CLAIM_FH
                     [default: None]

              <b>ipaddr:</b>
                     Destination IP address [default: self.server_ipaddr]

              <b>port:</b>  Destination port [default: self.port]

              <b>proto:</b> Protocol [default: self.proto]

              <b>deleg_type:</b>
                     Expected delegation type on reply [default: None]

              <b>deleg_stateid:</b>
                     Delegation stateid expected on call in delegate_cur_info [default: None]

              <b>fh:</b>    Find open call and reply for this file handle when using
                     deleg_stateid or as the directory FH when deleg_stateid
                     is not set [default: None]

              <b>src_ipaddr:</b>
                     Source IP address [default: any IP address]

              <b>maxindex:</b>
                     The match fails if packet index hits this limit [default: no limit]

              <b>anyclaim:</b>
                     Find open for either regular open or using delegate_cur_info [default: False]

              <b>nfs_version:</b>
                     NFS version to use in search [default: mounted NFS version]

              Must specify either filename, claimfh or both.
              Return a tuple: (filehandle, open_stateid, deleg_stateid).

       <b>get_abs_offset(self,</b> <b>offset,</b> <b>ds_index=None)</b>
       Get real file offset given by the (read/write) offset on the given
       data server index, taking into account the type of layout
       (dense/sparse), the stripe_size, first stripe index and the number
       of filehandles. The layout information is taken from object
       attribute layout.

       <b>get_addr_port(self,</b> <b>addr)</b>
       Get address and port number from universal address string

       <b>get_clientid(self,</b> <b>**kwargs)</b>
       Return the client id for the given IP address and port number.

              <b>ipaddr:</b>
                     Destination IP address [default: self.server_ipaddr]

              <b>port:</b>  Destination port [default: self.port]

       <b>get_filehandle(self,</b> <b>ds_index)</b>
       Return filehandle from the layout list of filehandles.

       <b>get_freebytes(self,</b> <b>dir=None)</b>
       Get the number of bytes available in the given directory.
       It takes into account the effective user running the test.
       The root user is allowed to use all the available disk space
       on the device, on the other hand a regular user is allowed a
       little bit less.

       <b>get_pathfh(self,</b> <b>path,</b> <b>**kwargs)</b>
       Return the file handle for the given path by searching the packet
       trace for every component in the path.
       The file handle for each component is used to search for the file
       handle in the next component.

              <b>path:</b>  File system path

              <b>dirfh:</b> Directory file handle to start with [default: None]

              <b>ipaddr:</b>
                     Destination IP address [default: self.server_ipaddr]

              <b>port:</b>  Destination port [default: self.port]

              <b>proto:</b> Protocol [default: self.proto]

       <b>get_rootfh(self,</b> <b>**kwargs)</b>
       Return the root file handle from PUTROOTFH

              <b>sessionid:</b>
                     Search the PUTROOTFH tied to this session id [default: None]

              <b>ipaddr:</b>
                     Destination IP address [default: self.server_ipaddr]

              <b>port:</b>  Destination port [default: self.port]

       <b>get_sessionid(self,</b> <b>**kwargs)</b>
       Return the session id for the given IP address and port number.

              <b>clientid:</b>
                     Search the CREATE_SESSION tied to this client id [default: None]

              <b>ipaddr:</b>
                     Destination IP address [default: self.server_ipaddr]

              <b>port:</b>  Destination port [default: self.port]

       <b>get_stateid(self,</b> <b>filename,</b> <b>**kwargs)</b>
       Search the packet trace for the file name given to get the OPEN
       so all related state ids can be searched. A couple of object
       attributes are defined, one is the correct state id that should
       be used by I/O operations. The second is a dictionary table
       which maps the state id to a string identifying if the state
       id is an open, lock or delegation state id.

              <b>ipaddr:</b>
                     Destination IP address [default: self.server_ipaddr]

              <b>port:</b>  Destination port [default: self.port]

              <b>noreset:</b>
                     Do not reset the state id map [default: False]

              <b>write:</b> Search for a write delegation/lock stateid if True or a read
                     delegation/lock stateid if False. Default is to search for
                     any type [default: None]

       <b>getop(self,</b> <b>pkt,</b> <b>op)</b>
       Get the NFS operation object from the given packet

       <b>match_nfs_version(self,</b> <b>nfs_version,</b> <b>post=True)</b>
       Return the match string to search for the correct NFS version.

              <b>nfs_version:</b>
                     NFS version to use in search.

              <b>post:</b>  Add "and" conjunction at the end of matching string if this
                     is true. Add it at the beginning if it is false. If this is
                     set to None just return the matching string.

       <b>nfs_op(self,</b> <b>nfs4,</b> <b>nfs3)</b>
       Return the item according to what NFS version is mounted

       <b>nfs_op_name(self,</b> <b>op)</b>
       Return the name for the given NFSv4 operation or NFSv3 procedure

       <b>set_pktlist(self,</b> <b>**kwargs)</b>
       Set the current packet list for buffered matching in which the
       match method will only use this list instead of getting the next
       packet from the packet trace file. The default is to get all
       packets unless any of the arguments is given.

       NOTE: all READ reply data and all WRITE request data is discarded
       to avoid having memory issues.

              <b>layer:</b> Comma separated list of layers to include [default: 'nfs']

              <b>ops:</b>   List of NFSv4 operations to include in the packet list
                     [default: None]

              <b>cbs:</b>   List of NFSv4 callback operations to include in the packet list
                     [default: None]

              <b>procs:</b> List of NFSv3 procedures to include in the packet list
                     [default: None]

              <b>maxindex:</b>
                     Include packets up to but not including the packet indexed
                     by this argument [default: None]
                     A value of None means there is no limit

              <b>pktdisp:</b>
                     Display all cached packets [default: False]

       <b>stid_str(self,</b> <b>stateid)</b>
       Display the state id in CRC32 format

       <b>verify_close(self,</b> <b>filehandle,</b> <b>stateid,</b> <b>pindex=None)</b>
       Verify CLOSE is sent to the server. Also make sure there is
       only one CLOSE call sent. Also the following object attributes
       are defined: pktcall references the first CLOSE call while
       pktreply references the first CLOSE reply.

              <b>filehandle:</b>
                     Find CLOSE for this file handle

              <b>stateid:</b>
                     Open stateid expected

              <b>pindex:</b>
                     Packet index where to start the search [default: None]

       <b>verify_commit(self,</b> <b>ipaddr,</b> <b>port,</b> <b>filehandle,</b> <b>init=False)</b>
       Verify commits are properly sent to the server specified by the
       given ipaddr and port.

              <b>ipaddr:</b>
                     Destination IP address of MDS or DS

              <b>port:</b>  Destination port number of MDS or DS

              <b>filehandle:</b>
                     Find commits for this file handle

              <b>init:</b>  Initialized test variables [default: False]

              Return the number of commits sent to the server.

       <b>verify_create_session(self,</b> <b>ipaddr,</b> <b>port,</b> <b>ds=False,</b> <b>nocreate=False,</b> <b>ds_index=None,</b> <b>exchid_status=0,</b> <b>cs_status=0)</b>
       Verify initial connection to the metadata server(MDS)/data server(DS).
       Verify if EXCHANGE_ID, CREATE_SESSION, RECLAIM_COMPLETE,
       GETATTR asking for FATTR4_LEASE_TIME, and GETATTR asking for
       FATTR4_FS_LAYOUT_TYPES are all sent or not to the server.

              <b>ipaddr:</b>
                     Destination IP address of MDS or DS

              <b>port:</b>  Destination port number of MDS or DS

              <b>ds:</b>    True if ipaddr/port defines a DS, otherwise MDS [default: False]

              <b>nocreate:</b>
                     True if expecting the client NOT to send EXCHANGE_ID,
                     CREATE_SESSION, and RECLAIM_COMPLETE. Otherwise, verify all
                     these operations are sent by the client [default: False]

              <b>ds_index:</b>
                     DS index used for displaying purposes only [default: None]

              <b>exchid_status:</b>
                     Expected status for EXCHANGE_ID [default: 0]

              <b>cs_status:</b>
                     Expected status for CREATE_SESSION [default: 0]

              Return the sessionid and it is also stored in the object
              attribute sessionid.

       <b>verify_io(self,</b> <b>iomode,</b> <b>stateid,</b> <b>ipaddr=None,</b> <b>port=None,</b> <b>proto=None,</b> <b>src_ipaddr=None,</b> <b>filehandle=None,</b> <b>ds_index=None,</b> <b>init=False,</b> <b>maxindex=None,</b> <b>pattern=None)</b>
       Verify I/O is sent to the server specified by the ipaddr and port.

              <b>iomode:</b>
                     Verify reads (iomode == 1) or writes (iomode == 2)

              <b>stateid:</b>
                     Expected stateid to use in all I/O requests

              <b>ipaddr:</b>
                     Destination IP address of MDS or DS
                     [default: do not match destination]

              <b>port:</b>  Destination port number of MDS or DS
                     [default: do not match destination port]

              <b>proto:</b> Protocol [default: self.proto]

              <b>src_ipaddr:</b>
                     Source IP address of request
                     [default: do not match source]

              <b>filehandle:</b>
                     Find I/O for this file handle. This option is used when
                     verifying I/O sent to the MDS
                     [default: use filehandle given by ds_index]

              <b>ds_index:</b>
                     Data server index. This option is used when verifying I/O sent
                     to the DS -- filehandle is taken from x.layout for this index
                     [default: None]

              <b>init:</b>  Initialized test variables [default: False]

              <b>maxindex:</b>
                     The match fails if packet index hits this limit [default: no limit]

              <b>pattern:</b>
                     Data pattern to compare [default: default data pattern]

              Return the number of I/O operations sent to the server.

       <b>verify_layoutcommit(self,</b> <b>filehandle,</b> <b>filesize)</b>
       Verify layoutcommit is properly sent to the server specified by
       the ipaddr for self.server and port given by self.port.
       Verify a GETATTR asking for file size is sent within the same
       compound as the LAYOUTCOMMIT.
       Verify GETATTR returns correct size for the file.

              <b>filehandle:</b>
                     Find layoutcommit for this file handle

              <b>filesize:</b>
                     Expected size of file

       <b>verify_layoutget(self,</b> <b>filehandle,</b> <b>iomode,</b> <b>riomode=None,</b> <b>status=0,</b> <b>offset=None,</b> <b>length=None,</b> <b>openfh={})</b>
       Verify the client sends a LAYOUTGET for the given file handle.

              <b>filehandle:</b>
                     Find LAYOUTGET for this file handle

              <b>iomode:</b>
                     Expected I/O mode for LAYOUTGET call

              <b>riomode:</b>
                     Expected I/O mode for LAYOUTGET reply if specified, else verify
                     reply I/O mode is equal to call I/O mode if iomode == 2.
                     If iomode == 1, the reply I/O mode could be equal to 1 or 2

              <b>status:</b>
                     Expected status for LAYOUTGET reply [default: 0]

              <b>offset:</b>
                     Expected layout range for LAYOUTGET reply [default: None]

              <b>length:</b>
                     Expected layout range for LAYOUTGET reply [default: None]

              <b>openfh:</b>
                     Open information for file (filehandle, open/delegation/lock stateids,
                     and delegation type) if file has been previously opened [default: {}]

              If both offset and length are not given, verify LAYOUTGET reply
              should be a full layout [0, NFS4_UINT64_MAX]. If only one is
              provided the following defaults are used: offset = 0,
              length = NFS4_UINT64_MAX.

              Return True if a layout is found and it is supported.

       <b>verify_layoutreturn(self,</b> <b>layout_list)</b>
       Verify layoutreturn is properly sent to the server specified by
       the ipaddr for self.server and port given by self.port.

              <b>layout_list:</b>
                     List of layouts

       <b>verify_pnfs_supported(self,</b> <b>filehandle,</b> <b>server_type,</b> <b>path=None,</b> <b>fstype=False)</b>
       Verify pNFS is supported in the given server path.
       Finds the GETATTR asking for FATTR4_SUPPORTED_ATTRS(bit 0 and its
       reply to verify FATTR4_FS_LAYOUT_TYPES is supported for the path.
       Then it finds the GETATTR asking for FATTR4_FS_LAYOUT_TYPES(bit 62)
       to verify LAYOUT4_NFSV4_1_FILES is returned in fs_layout_types.

       <b>verify_stripe(self,</b> <b>offset,</b> <b>size,</b> <b>ds_index)</b>
       Verify if read/write is sent to the correct data server according
       to stripe size, first stripe index and the number of filehandles.
       The layout information is taken from object attribute layout.

              <b>offset:</b>
                     Real file offset

              <b>size:</b>  I/O size

              <b>ds_index:</b>
                     Data server index

              Return True if stripe is correctly verified, False otherwise.

       <b>Static</b> <b>methods</b> <b>defined</b> <b>here:</b>
       ----------------------------

       <b>bitmap_str(bitmap,</b> <b>count,</b> <b>bmap,</b> <b>blist)</b>
       Return the string representation of bitmap.

              <b>bitmap:</b>
                     Bitmap to convert

              <b>count:</b> Number of occurrences of bitmap

              <b>bmap:</b>  Dictionary mapping the bits to strings

              <b>blist:</b> List of all possible bit combinations

       <b>iomode_str(iomode)</b>
       Return a string representation of iomode.
       This could be run as an instance or class method.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/baseobj.3.html">baseobj</a>(3),</b>     <b><a href="../man3/formatstr.3.html">formatstr</a>(3),</b>      <b><a href="../man3/nfstest.host.3.html">nfstest.host</a>(3),</b>      <b><a href="../man3/nfstest.utils.3.html">nfstest.utils</a>(3),</b>      <b><a href="../man3/packet.nfs.nfs3_const.3.html">packet.nfs.nfs3_const</a>(3),</b>
       <b><a href="../man3/packet.nfs.nfs4.3.html">packet.nfs.nfs4</a>(3),</b> <b><a href="../man3/packet.nfs.nfs4_const.3.html">packet.nfs.nfs4_const</a>(3),</b> <b><a href="../man3/packet.unpack.3.html">packet.unpack</a>(3)</b>

</pre><h4><b>BUGS</b></h4><pre>
       No known bugs.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jorge Mora (<a href="mailto:mora@netapp.com">mora@netapp.com</a>)

NFStest 3.2                                       21 March 2023                                      <u><a href="../man3/NFS_UTIL.3.html">NFS_UTIL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>