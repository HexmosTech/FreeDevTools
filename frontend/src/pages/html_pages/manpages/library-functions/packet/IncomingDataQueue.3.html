<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IncomingDataQueue - Queue for incoming RTP data packets in an RTP session.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libccrtp-doc">libccrtp-doc_2.0.9-4.1build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IncomingDataQueue - Queue for incoming RTP data packets in an RTP session.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;iqueue.h&gt;

       Inherits <b>IncomingDataQueueBase</b>, and <b>MembershipBookkeeping</b>.

       Inherited by <b>RTPDataQueue</b>.

   <b>Classes</b>
       class <b>SyncSourcesIterator</b>
           iterator through the list of synchronizations sources in this session

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>SyncSourcesIterator</b> <b>begin</b> ()
       <b>SyncSourcesIterator</b> <b>end</b> ()
       const <b>AppDataUnit</b> * <b>getData</b> (uint32 stamp, const <b>SyncSource</b> *src=NULL)
           Retreive data from a specific timestamped packet if such a packet is currently available in the
           receive buffer.
       bool <b>isWaiting</b> (const <b>SyncSource</b> *src=NULL) const
           Determine if packets are waiting in the reception queue.
       uint32 <b>getFirstTimestamp</b> (const <b>SyncSource</b> *src=NULL) const
           Get timestamp of first packet waiting in the queue.
       void <b>setMinValidPacketSequence</b> (uint8 packets)
           When receiving packets from a new source, it may be convenient to reject a first few packets before
           we are really sure the source is valid.
       uint8 <b>getDefaultMinValidPacketSequence</b> () const
       uint8 <b>getMinValidPacketSequence</b> () const
           Get the minimun number of consecutive packets that must be received from a source before accepting
           its data packets.
       void <b>setMaxPacketMisorder</b> (uint16 packets)
       uint16 <b>getDefaultMaxPacketMisorder</b> () const
       uint16 <b>getMaxPacketMisorder</b> () const
       void <b>setMaxPacketDropout</b> (uint16 packets)
           It also prevents packets sent after a restart of the source being immediately accepted.
       uint16 <b>getDefaultMaxPacketDropout</b> () const
       uint16 <b>getMaxPacketDropout</b> () const
       void <b>setInQueueCryptoContext</b> (<b>CryptoContext</b> *cc)
           Set input queue <b>CryptoContext</b>.
       void <b>removeInQueueCryptoContext</b> (<b>CryptoContext</b> *cc)
           Remove input queue <b>CryptoContext</b>.
       <b>CryptoContext</b> * <b>getInQueueCryptoContext</b> (uint32 ssrc)
           Get an input queue <b>CryptoContext</b> identified by SSRC.

       Public Member Functions inherited from <b>IncomingDataQueueBase</b>
       size_t <b>getDefaultMaxRecvPacketSize</b> () const
       size_t <b>getMaxRecvPacketSize</b> () const
       void <b>setMaxRecvPacketSize</b> (size_t maxsize)

       Public Member Functions inherited from <b>RTPQueueBase</b>
       bool <b>setPayloadFormat</b> (const <b>PayloadFormat</b> &amp;pf)
           Set the payload format in use, for timing and payload type identification purposes.
       uint32 <b>getLocalSSRC</b> () const
       uint32 <b>getCurrentRTPClockRate</b> () const
           Get the clock rate in RTP clock units (for instance, 8000 units per second for PCMU, or 90000 units
           per second for MP2T).
       <b>PayloadType</b> <b>getCurrentPayloadType</b> () const
       timeval <b>getInitialTime</b> () const

   <b>Static</b> <b>Public</b> <b>Member</b> <b>Functions</b>
       static size_t <b>getDefaultMembersSize</b> ()

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       <b>IncomingDataQueue</b> (uint32 size)
       virtual <b>~IncomingDataQueue</b> ()
       bool <b>checkSSRCInIncomingRTPPkt</b> (<b>SyncSourceLink</b> &amp;sourceLink, bool is_new, InetAddress &amp;na, tpport_t tp)
           Apply collision and loop detection and correction algorithm when receiving RTP data packets.
       void <b>setSourceExpirationPeriod</b> (uint8 intervals)
           Set the number of RTCP intervals that the stack will wait to change the state of a source from
           stateActive to stateInactive, or to delete the source after being in stateInactive.
       virtual size_t <b>takeInDataPacket</b> ()
           This function is used by the service thread to process the next incoming packet and place it in the
           receive list.
       void <b>renewLocalSSRC</b> ()
       <b>IncomingDataQueue::IncomingRTPPktLink</b> * <b>getWaiting</b> (uint32 timestamp, const <b>SyncSource</b> *src=NULL)
           This is used to fetch a packet in the receive queue and to expire packets older than the current
           timestamp.
       bool <b>recordReception</b> (<b>SyncSourceLink</b> &amp;srcLink, const <b>IncomingRTPPkt</b> &amp;pkt, const timeval recvtime)
           Log reception of a new RTP packet from this source.
       void <b>recordExtraction</b> (const <b>IncomingRTPPkt</b> &amp;pkt)
           Log extraction of a packet from this source from the scheduled reception queue.
       void <b>purgeIncomingQueue</b> ()
       virtual void <b>onNewSyncSource</b> (const <b>SyncSource</b> &amp;)
           Virtual called when a new synchronization source has joined the session.
       virtual bool <b>onRTPPacketRecv</b> (<b>IncomingRTPPkt</b> &amp;)
           A virtual function to support parsing of arriving packets to determine if they should be kept in the
           queue and to dispatch events.
       virtual void <b>onExpireRecv</b> (<b>IncomingRTPPkt</b> &amp;)
           A hook to filter packets in the receive queue that are being expired.
       virtual bool <b>onSRTPPacketError</b> (<b>IncomingRTPPkt</b> &amp;pkt, int32 errorCode)
           A hook that gets called if the decoding of an incoming SRTP was erroneous.
       virtual bool <b>end2EndDelayed</b> (<b>IncomingRTPPktLink</b> &amp;)
       bool <b>insertRecvPacket</b> (<b>IncomingRTPPktLink</b> *packetLink)
           Insert a just received packet in the queue (both general and source specific queues).
       virtual size_t <b>recvData</b> (unsigned char *buffer, size_t length, InetHostAddress &amp;host, tpport_t &amp;port)=0
           This function performs the physical I/O for reading a packet from the source.
       virtual size_t <b>getNextDataPacketSize</b> () const =0

       Protected Member Functions inherited from <b>IncomingDataQueueBase</b>
       <b>IncomingDataQueueBase</b> ()
       virtual <b>~IncomingDataQueueBase</b> ()

       Protected Member Functions inherited from <b>RTPQueueBase</b>
       <b>RTPQueueBase</b> (uint32 *ssrc=NULL)
       void <b>setLocalSSRC</b> (uint32 ssrc)
       uint32 <b>getLocalSSRCNetwork</b> () const
       virtual <b>~RTPQueueBase</b> ()
       virtual size_t <b>dispatchBYE</b> (const std::string &amp;)
           A plugin point for posting of BYE messages.

       Protected Member Functions inherited from <b>MembershipBookkeeping</b>
       <b>MembershipBookkeeping</b> (uint32 initialSize=<b>defaultMembersHashSize</b>)
           The initial size is a hint to allocate the resources needed in order to keep the members' identifiers
           and associated information.
       virtual <b>~MembershipBookkeeping</b> ()
           Purges all RTPSource structures created during the session, as well as the hash table and the list of
           sources.
       <b>SyncSourceLink</b> * <b>getLink</b> (const <b>SyncSource</b> &amp;source) const
       bool <b>isMine</b> (const <b>SyncSource</b> &amp;source) const
           Get whether a synchronization source is recorded in this membership controller.
       bool <b>isRegistered</b> (uint32 ssrc)
           Returns whether there is already a synchronizacion source with 'ssrc' SSRC identifier.
       <b>SyncSourceLink</b> * <b>getSourceBySSRC</b> (uint32 ssrc, bool &amp;created)
           Get the description of a source by its ssrc identifier.
       bool <b>BYESource</b> (uint32 ssrc)
           Mark the source identified by ssrc as having sent a BYE packet.
       bool <b>removeSource</b> (uint32 ssrc)
           Remove the description of the source identified by ssrc
       <b>SyncSourceLink</b> * <b>getFirst</b> ()
       <b>SyncSourceLink</b> * <b>getLast</b> ()
       uint32 <b>getMembersCount</b> ()
       void <b>setMembersCount</b> (uint32 n)
       uint32 <b>getSendersCount</b> ()
       size_t <b>getDefaultMembersHashSize</b> ()

       Protected Member Functions inherited from <b>SyncSourceHandler</b>
       <b>SyncSourceHandler</b> ()
       virtual <b>~SyncSourceHandler</b> ()
       void * <b>getLink</b> (const <b>SyncSource</b> &amp;source) const
           This requires <b>SyncSource</b> - <b>SyncSourceHandler</b> friendship.
       void <b>setLink</b> (<b>SyncSource</b> &amp;source, void *link)
       void <b>setParticipant</b> (<b>SyncSource</b> &amp;source, <b>Participant</b> &amp;p)
       void <b>setState</b> (<b>SyncSource</b> &amp;source, <b>SyncSource::State</b> ns)
       void <b>setSender</b> (<b>SyncSource</b> &amp;source, bool active)
       void <b>setDataTransportPort</b> (<b>SyncSource</b> &amp;source, tpport_t p)
       void <b>setControlTransportPort</b> (<b>SyncSource</b> &amp;source, tpport_t p)
       void <b>setNetworkAddress</b> (<b>SyncSource</b> &amp;source, InetAddress addr)

       Protected Member Functions inherited from <b>ParticipantHandler</b>
       <b>ParticipantHandler</b> ()
       virtual <b>~ParticipantHandler</b> ()
       void <b>setSDESItem</b> (<b>Participant</b> *part, <b>SDESItemType</b> item, const std::string &amp;val)
       void <b>setPRIVPrefix</b> (<b>Participant</b> *part, const std::string val)

       Protected Member Functions inherited from <b>ApplicationHandler</b>
       <b>ApplicationHandler</b> ()
       virtual <b>~ApplicationHandler</b> ()
       void <b>addParticipant</b> (<b>RTPApplication</b> &amp;app, <b>Participant</b> &amp;part)
       void <b>removeParticipant</b> (<b>RTPApplication</b> &amp;app, RTPApplication::ParticipantLink *pl)

       Protected Member Functions inherited from <b>ConflictHandler</b>
       <b>ConflictHandler</b> ()
       virtual <b>~ConflictHandler</b> ()
       <b>ConflictingTransportAddress</b> * <b>searchDataConflict</b> (InetAddress na, tpport_t dtp)
       <b>ConflictingTransportAddress</b> * <b>searchControlConflict</b> (InetAddress na, tpport_t ctp)
       void <b>updateConflict</b> (<b>ConflictingTransportAddress</b> &amp;ca)
       void <b>addConflict</b> (const InetAddress &amp;na, tpport_t dtp, tpport_t ctp)

   <b>Protected</b> <b>Attributes</b>
       ThreadLock <b>recvLock</b>
       <b>IncomingRTPPktLink</b> * <b>recvFirst</b>
       <b>IncomingRTPPktLink</b> * <b>recvLast</b>
       uint8 <b>minValidPacketSequence</b>
       uint16 <b>maxPacketMisorder</b>
       uint16 <b>maxPacketDropout</b>
       uint8 <b>sourceExpirationPeriod</b>
       Mutex <b>cryptoMutex</b>
       std::list&lt; <b>CryptoContext</b> * &gt; <b>cryptoContexts</b>

       Protected Attributes inherited from <b>ConflictHandler</b>
       <b>ConflictingTransportAddress</b> * <b>firstConflict</b>
       <b>ConflictingTransportAddress</b> * <b>lastConflict</b>

   <b>Static</b> <b>Protected</b> <b>Attributes</b>
       static const uint8 <b>defaultMinValidPacketSequence</b>
       static const uint16 <b>defaultMaxPacketMisorder</b>
       static const uint16 <b>defaultMaxPacketDropout</b>
       static const size_t <b>defaultMembersSize</b>

       Static Protected Attributes inherited from <b>MembershipBookkeeping</b>
       static const size_t <b>defaultMembersHashSize</b>
       static const uint32 <b>SEQNUMMOD</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Queue for incoming RTP data packets in an RTP session.

       <b>Author</b>
           Federico Montesino Pouzols <a href="mailto:fedemp@altern.org">fedemp@altern.org</a>

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>IncomingDataQueue::IncomingDataQueue</b> <b>(uint32</b> <b>size)</b> <b>[protected]</b>
       <b>Parameters</b>
           <u>size</u> initial size of the membership table.

   <b>virtual</b> <b>IncomingDataQueue::~IncomingDataQueue</b> <b>()</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>SyncSourcesIterator</b> <b>IncomingDataQueue::begin</b> <b>()</b> <b>[inline]</b>
   <b>bool</b> <b>IncomingDataQueue::checkSSRCInIncomingRTPPkt</b> <b>(SyncSourceLink</b> <b>&amp;</b> <b>sourceLink,</b> <b>bool</b> <b>is_new,</b> <b>InetAddress</b> <b>&amp;</b>
       <b>na,</b> <b>tpport_t</b> <b>tp)</b> <b>[protected]</b>
       Apply collision and loop detection and correction algorithm when receiving RTP data packets. Follows
       section 8.2 in draft-ietf-avt-rtp-new.

       <b>Parameters</b>
           <u>sourceLink</u> link to the source object.
           <u>is_new</u> whether the source has been just recorded.
           <u>na</u> data packet network address.
           <u>tp</u> data packet source transport port.

       <b>Returns</b>
           whether the packet must not be discarded.

   <b>SyncSourcesIterator</b> <b>IncomingDataQueue::end</b> <b>()</b> <b>[inline]</b>
   <b>virtual</b> <b>bool</b> <b>IncomingDataQueue::end2EndDelayed</b> <b>(IncomingRTPPktLink</b> <b>&amp;)</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
   <b>const</b> <b>AppDataUnit</b> <b>*</b> <b>IncomingDataQueue::getData</b> <b>(uint32</b> <b>stamp,</b> <b>const</b> <b>SyncSource</b> <b>*</b> <b>src</b> <b>=</b> <b>NULL)</b>
       Retreive data from a specific timestamped packet if such a packet is currently available in the receive
       buffer.

       <b>Parameters</b>
           <u>stamp</u> Data unit timestamp.
           <u>src</u> Optional synchronization source selector.

       <b>Returns</b>
           data retrieved from the reception buffer.

       <b>Return</b> <b>values</b>
           <u>null</u> pointer if no packet with such timestamp is available.

       <b>Examples</b>
           <b>audiorx.cpp</b>, <b>rtpduphello.cpp</b>, <b>rtphello.cpp</b>, and <b>rtplisten.cpp</b>.

   <b>uint16</b> <b>IncomingDataQueue::getDefaultMaxPacketDropout</b> <b>()</b> <b>const</b> <b>[inline]</b>
   <b>uint16</b> <b>IncomingDataQueue::getDefaultMaxPacketMisorder</b> <b>()</b> <b>const</b> <b>[inline]</b>
   <b>static</b> <b>size_t</b> <b>IncomingDataQueue::getDefaultMembersSize</b> <b>()</b> <b>[inline],</b>  <b>[static]</b>
   <b>uint8</b> <b>IncomingDataQueue::getDefaultMinValidPacketSequence</b> <b>()</b> <b>const</b> <b>[inline]</b>
   <b>uint32</b> <b>IncomingDataQueue::getFirstTimestamp</b> <b>(const</b> <b>SyncSource</b> <b>*</b> <b>src</b> <b>=</b> <b>NULL)</b> <b>const</b>
       Get timestamp of first packet waiting in the queue.

       <b>Parameters</b>
           <u>src</u> optional source selector.

       <b>Returns</b>
           timestamp of first arrival packet.

       <b>Examples</b>
           <b>audiorx.cpp</b>, <b>rtpduphello.cpp</b>, <b>rtphello.cpp</b>, and <b>rtplisten.cpp</b>.

   <b>CryptoContext</b> <b>*</b> <b>IncomingDataQueue::getInQueueCryptoContext</b> <b>(uint32</b> <b>ssrc)</b>
       Get an input queue <b>CryptoContext</b> identified by SSRC.

       <b>Parameters</b>
           <u>ssrc</u> Request <b>CryptoContext</b> for this incoming SSRC

       <b>Returns</b>
           Pointer to <b>CryptoContext</b> of the SSRC of NULL if no context available for this SSRC.

   <b>uint16</b> <b>IncomingDataQueue::getMaxPacketDropout</b> <b>()</b> <b>const</b> <b>[inline]</b>
   <b>uint16</b> <b>IncomingDataQueue::getMaxPacketMisorder</b> <b>()</b> <b>const</b> <b>[inline]</b>
   <b>uint8</b> <b>IncomingDataQueue::getMinValidPacketSequence</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Get the minimun number of consecutive packets that must be received from a source before accepting its
       data packets.

   <b>virtual</b> <b>size_t</b> <b>IncomingDataQueue::getNextDataPacketSize</b> <b>()</b> <b>const</b> <b>[protected],</b>  <b>[pure</b> <b>virtual]</b>
       Implemented in <b>RTPDuplex</b>, <b>TRTPSessionBase&lt;</b> <b>RTPDataChannel,</b> <b>RTCPChannel,</b> <b>ServiceQueue</b> <b>&gt;</b>, and
       <b>TRTPSessionBase&lt;</b> <b>DualRTPUDPIPv4Channel,</b> <b>DualRTPUDPIPv4Channel,</b> <b>AVPQueue</b> <b>&gt;</b>.

   <b>IncomingDataQueue::IncomingRTPPktLink</b> <b>*</b> <b>IncomingDataQueue::getWaiting</b> <b>(uint32</b> <b>timestamp,</b> <b>const</b> <b>SyncSource</b> <b>*</b>
       <b>src</b> <b>=</b> <b>NULL)</b> <b>[protected]</b>
       This is used to fetch a packet in the receive queue and to expire packets older than the current
       timestamp.

       <b>Returns</b>
           packet buffer object for current timestamp if found.

       <b>Parameters</b>
           <u>timestamp</u> timestamp requested.
           <u>src</u> optional source selector

       <b>Note</b>
           if found, the packet is removed from the reception queue

   <b>bool</b> <b>IncomingDataQueue::insertRecvPacket</b> <b>(IncomingRTPPktLink</b> <b>*</b> <b>packetLink)</b> <b>[protected]</b>
       Insert a just received packet in the queue (both general and source specific queues). If the packet was
       already in the queue (same SSRC and sequence number), it is not inserted but deleted.

       <b>Parameters</b>
           <u>packetLink</u> link to a packet just received and generally validated and processed by onRTPPacketRecv.

       <b>Returns</b>
           whether the packet was successfully inserted.

       <b>Return</b> <b>values</b>
           <u>false</u> when the packet is duplicated (there is already a packet from the same source with the same
           timestamp).
           <u>true</u> when the packet is not duplicated.

   <b>bool</b> <b>IncomingDataQueue::isWaiting</b> <b>(const</b> <b>SyncSource</b> <b>*</b> <b>src</b> <b>=</b> <b>NULL)</b> <b>const</b>
       Determine if packets are waiting in the reception queue.

       <b>Parameters</b>
           <u>src</u> Optional synchronization source selector.

       <b>Returns</b>
           True if packets are waiting.

   <b>virtual</b> <b>void</b> <b>IncomingDataQueue::onExpireRecv</b> <b>(IncomingRTPPkt</b> <b>&amp;)</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       A hook to filter packets in the receive queue that are being expired. This hook may be used to do some
       application specific processing on expired packets before they are deleted.

       <b>Parameters</b>
           <u>-</u> packet expired from the recv queue.

   <b>virtual</b> <b>void</b> <b>IncomingDataQueue::onNewSyncSource</b> <b>(const</b> <b>SyncSource</b> <b>&amp;)</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       Virtual called when a new synchronization source has joined the session.

       <b>Parameters</b>
           <u>-</u> new synchronization source

       <b>Examples</b>
           <b>rtplisten.cpp</b>.

   <b>virtual</b> <b>bool</b> <b>IncomingDataQueue::onRTPPacketRecv</b> <b>(IncomingRTPPkt</b> <b>&amp;)</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       A virtual function to support parsing of arriving packets to determine if they should be kept in the
       queue and to dispatch events. A generic header validity check (as specified in RFC 1889) is performed on
       every incoming packet. If the generic check completes successfully, this method is called before the
       packet is actually inserted into the reception queue.

       May be used to perform additional validity checks or to do some application specific processing.

       <b>Parameters</b>
           <u>-</u> packet just received.

       <b>Returns</b>
           true if packet is kept in the incoming packets queue.

   <b>virtual</b> <b>bool</b> <b>IncomingDataQueue::onSRTPPacketError</b> <b>(IncomingRTPPkt</b> <b>&amp;</b> <b>pkt,</b> <b>int32</b> <b>errorCode)</b> <b>[inline],</b>
       <b>[protected],</b>  <b>[virtual]</b>
       A hook that gets called if the decoding of an incoming SRTP was erroneous.

       <b>Parameters</b>
           <u>pkt</u> The SRTP packet with error.
           <u>errorCode</u> The error code: -1 - SRTP authentication failure, -2 - replay check failed

       <b>Returns</b>
           True: put the packet in incoming queue for further processing by the applications; false: dismiss
           packet. The default implementation returns false.

   <b>void</b> <b>IncomingDataQueue::purgeIncomingQueue</b> <b>()</b> <b>[protected]</b>
   <b>void</b> <b>IncomingDataQueue::recordExtraction</b> <b>(const</b> <b>IncomingRTPPkt</b> <b>&amp;</b> <b>pkt)</b> <b>[protected]</b>
       Log extraction of a packet from this source from the scheduled reception queue.

       <b>Parameters</b>
           <u>pkt</u> Packet extracted from the queue.

   <b>bool</b> <b>IncomingDataQueue::recordReception</b> <b>(SyncSourceLink</b> <b>&amp;</b> <b>srcLink,</b> <b>const</b> <b>IncomingRTPPkt</b> <b>&amp;</b> <b>pkt,</b> <b>const</b> <b>timeval</b>
       <b>recvtime)</b> <b>[protected]</b>
       Log reception of a new RTP packet from this source. Usually updates data such as the packet counter, the
       expected sequence number for the next packet and the time the last packet was received at.

       <b>Parameters</b>
           <u>srcLink</u> Link structure for the synchronization source of this packet.
           <u>pkt</u> Packet just created and to be logged.
           <u>recvtime</u> Reception time.

       <b>Returns</b>
           whether, according to the source state and statistics, the packet is considered valid and must be
           inserted in the incoming packets queue.

   <b>virtual</b> <b>size_t</b> <b>IncomingDataQueue::recvData</b> <b>(unsigned</b> <b>char</b> <b>*</b> <b>buffer,</b> <b>size_t</b> <b>length,</b> <b>InetHostAddress</b> <b>&amp;</b> <b>host,</b>
       <b>tpport_t</b> <b>&amp;</b> <b>port)</b> <b>[protected],</b>  <b>[pure</b> <b>virtual]</b>
       This function performs the physical I/O for reading a packet from the source. It is a virtual that is
       overridden in the derived class.

       <b>Returns</b>
           number of bytes read.

       <b>Parameters</b>
           <u>buffer</u> of read packet.
           <u>length</u> of data to read.
           <u>host</u> address of source.
           <u>port</u> number of source.

       Implemented in <b>RTPDuplex</b>, <b>TRTPSessionBase&lt;</b> <b>RTPDataChannel,</b> <b>RTCPChannel,</b> <b>ServiceQueue</b> <b>&gt;</b>, and
       <b>TRTPSessionBase&lt;</b> <b>DualRTPUDPIPv4Channel,</b> <b>DualRTPUDPIPv4Channel,</b> <b>AVPQueue</b> <b>&gt;</b>.

   <b>void</b> <b>IncomingDataQueue::removeInQueueCryptoContext</b> <b>(CryptoContext</b> <b>*</b> <b>cc)</b>
       Remove input queue <b>CryptoContext</b>. The endQueue method (provided by RTPQueue) also deletes all registered
       CryptoContexts.

       <b>Parameters</b>
           <u>cc</u> Pointer to initialized <b>CryptoContext</b> to remove. If pointer if NULL then delete the whole queue

   <b>void</b> <b>IncomingDataQueue::renewLocalSSRC</b> <b>()</b> <b>[protected],</b>  <b>[virtual]</b>
       Reimplemented from <b>RTPQueueBase</b>.

       Reimplemented in <b>RTPDataQueue</b>.

   <b>void</b> <b>IncomingDataQueue::setInQueueCryptoContext</b> <b>(CryptoContext</b> <b>*</b> <b>cc)</b>
       Set input queue <b>CryptoContext</b>. The endQueue method (provided by RTPQueue) deletes all registered
       CryptoContexts.

       <b>Parameters</b>
           <u>cc</u> Pointer to initialized <b>CryptoContext</b>.

   <b>void</b> <b>IncomingDataQueue::setMaxPacketDropout</b> <b>(uint16</b> <b>packets)</b> <b>[inline]</b>
       It also prevents packets sent after a restart of the source being immediately accepted.

   <b>void</b> <b>IncomingDataQueue::setMaxPacketMisorder</b> <b>(uint16</b> <b>packets)</b> <b>[inline]</b>
   <b>void</b> <b>IncomingDataQueue::setMinValidPacketSequence</b> <b>(uint8</b> <b>packets)</b> <b>[inline]</b>
       When receiving packets from a new source, it may be convenient to reject a first few packets before we
       are really sure the source is valid. This method sets how many data packets must be received in sequence
       before the source is considered valid and the stack starts to accept its packets.

       <b>Note</b>
           the default (see <b>defaultMinValidPacketSequence()</b>) value for this parameter is 0, so that no packets
           are rejected (data packets are accepted from the first one).

           this validation is performed after the generic header validation and the additional validation done
           in <b>onRTPPacketRecv()</b>.

           if any valid RTCP packet is received from this source, it will be immediatly considered valid
           regardless of the number of sequential data packets received.

       <b>Parameters</b>
           <u>packets</u> number of sequential packet required

   <b>void</b> <b>IncomingDataQueue::setSourceExpirationPeriod</b> <b>(uint8</b> <b>intervals)</b> <b>[inline],</b>  <b>[protected]</b>
       Set the number of RTCP intervals that the stack will wait to change the state of a source from
       stateActive to stateInactive, or to delete the source after being in stateInactive. Note that this value
       should be uniform accross all participants and SHOULD be fixed for a particular profile.

       <b>Parameters</b>
           <u>intervals</u> number of RTCP report intervals

       <b>Note</b>
           If RTCP is not being used, the RTCP interval is assumed to be the default: 5 seconds.

           The default for this value is, as RECOMMENDED, 5.

   <b>virtual</b> <b>size_t</b> <b>IncomingDataQueue::takeInDataPacket</b> <b>()</b> <b>[protected],</b>  <b>[virtual]</b>
       This function is used by the service thread to process the next incoming packet and place it in the
       receive list.

       <b>Returns</b>
           number of payload bytes received. &lt;0 if error.

       Reimplemented in <b>SingleThreadRTPSession&lt;</b> <b>RTPDataChannel,</b> <b>RTCPChannel,</b> <b>ServiceQueue</b> <b>&gt;</b>.

</pre><h4><b>Member</b> <b>Data</b> <b>Documentation</b></h4><pre>
   <b>std::list&lt;CryptoContext</b> <b>*&gt;</b> <b>IncomingDataQueue::cryptoContexts</b> <b>[protected]</b>
   <b>Mutex</b> <b>IncomingDataQueue::cryptoMutex</b> <b>[mutable],</b>  <b>[protected]</b>
   <b>const</b> <b>uint16</b> <b>IncomingDataQueue::defaultMaxPacketDropout</b> <b>[static],</b>  <b>[protected]</b>
   <b>const</b> <b>uint16</b> <b>IncomingDataQueue::defaultMaxPacketMisorder</b> <b>[static],</b>  <b>[protected]</b>
   <b>const</b> <b>size_t</b> <b>IncomingDataQueue::defaultMembersSize</b> <b>[static],</b>  <b>[protected]</b>
   <b>const</b> <b>uint8</b> <b>IncomingDataQueue::defaultMinValidPacketSequence</b> <b>[static],</b>  <b>[protected]</b>
   <b>uint16</b> <b>IncomingDataQueue::maxPacketDropout</b> <b>[protected]</b>
   <b>uint16</b> <b>IncomingDataQueue::maxPacketMisorder</b> <b>[protected]</b>
   <b>uint8</b> <b>IncomingDataQueue::minValidPacketSequence</b> <b>[protected]</b>
   <b>IncomingRTPPktLink*</b> <b>IncomingDataQueue::recvFirst</b> <b>[protected]</b>
   <b>IncomingRTPPktLink</b> <b>*</b> <b>IncomingDataQueue::recvLast</b> <b>[protected]</b>
   <b>ThreadLock</b> <b>IncomingDataQueue::recvLock</b> <b>[mutable],</b>  <b>[protected]</b>
   <b>uint8</b> <b>IncomingDataQueue::sourceExpirationPeriod</b> <b>[protected]</b>
</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for ccRTP from the source code.

                                                      ccRTP                                 <u><a href="../man3/IncomingDataQueue.3.html">IncomingDataQueue</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>