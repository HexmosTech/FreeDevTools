<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ct_netconfc - NETCONF client module.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ct_netconfc - NETCONF client module.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       NETCONF  client  module  compliant with RFC 6241, NETCONF Configuration Protocol, and RFC 6242, Using the
       NETCONF Configuration Protocol over Secure SHell (SSH), and with support  for  RFC  5277,  NETCONF  Event
       Notifications.

       <u>Connecting</u> <u>to</u> <u>a</u> <u>NETCONF</u> <u>server</u>

       Call  <u>connect/1,2</u>  to establish a connection to a server, then pass the returned handle to <u>session/1-3</u> to
       establish a NETCONF session on a new SSH channel. Each call to <u>session/1-3</u> establishes a new  session  on
       the same connection, and results in a hello message to the server.

       Alternately,  <u>open/1,2</u>  can  be  used  to  establish  a  single  session  on a dedicated connection. (Or,
       equivalently, <u>only_open/1,2</u> followed by <u>hello/1-3</u>.)

       Connect/session options can be specified in a configuration file with entries like the following.

        {server_id(), [option()]}.

       The <u>server_id()</u> or an associated <u>ct:target_name()</u> can then be passed to the aforementioned  functions  to
       use the referenced configuration.

       <u>Signaling</u>

       Protocol  operations in the NETCONF protocol are realized as remote procedure calls (RPCs) from client to
       server and a corresponding reply from server to client. RPCs are sent  using  like-named  functions  (eg.
       <u>edit_config/3-5</u>  to  send an edit-config RPC), with the server reply as return value. There are functions
       for each RPC defined in RFC 6241 and the create-subscription RPC from RFC 5277, all of which are wrappers
       on <u>send_rpc/2,3</u>, that can be used to send an arbitrary RPC not defined in RFC 6241 or RFC 5277.

       All of the signaling functions have one variant with a <u>Timeout</u> argument and one without, corresponding to
       an infinite timeout. The latter is inappropriate in most cases since a non-response by the  server  or  a
       missing message-id causes the call to hang indefinitely.

       <u>Logging</u>

       The  NETCONF  server uses <u>error_logger</u> for logging of NETCONF traffic. A special purpose error handler is
       implemented in <u>ct_conn_log_h</u>. To use this error handler, add the <u>cth_conn_log</u> hook in the test suite, for
       example:

        suite() -&gt;
           [{ct_hooks, [{cth_conn_log, [{<u>ct:conn_log_mod()</u>, <u>ct:conn_log_options()</u>}]}]}].

       <u>conn_log_mod()</u> is the name of the <u>Common</u> <u>Test</u> module implementing the connection protocol,  for  example,
       <u>ct_netconfc</u>.

       Hook option <u>log_type</u> specifies the type of logging:

         <u>raw</u>:
           The  sent and received NETCONF data is logged to a separate text file "as is" without any formatting.
           A link to the file is added to the test case HTML log.

         <u>pretty</u>:
           The sent and received NETCONF data is logged to a separate text file with XML data nicely indented. A
           link to the file is added to the test case HTML log.

         <u>html</u> <u>(default)</u>:
           The sent and received NETCONF traffic is pretty printed directly in the test case HTML log.

         <u>silent</u>:
           NETCONF traffic is not logged.

       By default, all NETCONF traffic is logged in one single log file. However, different connections  can  be
       logged in separate files. To do this, use hook option <u>hosts</u> and list the names of the servers/connections
       to  be  used  in  the suite. The connections must be named for this to work, that is, they must be opened
       with <u>open/2</u>.

       Option <u>hosts</u> has no effect if <u>log_type</u> is set to <u>html</u> or <u>silent</u>.

       The hook options can also be specified in a configuration file with configuration variable <u>ct_conn_log</u>:

        {ct_conn_log,[{<u>ct:conn_log_mod()</u>, <u>ct:conn_log_options()</u>}]}.

       For example:

        {ct_conn_log,[{ct_netconfc,[{log_type,pretty},
                                    {hosts,[<u>ct:key_or_name()</u>]}]}]}

   <b>Note:</b>
       Hook options specified in a configuration file overwrite the hard-coded hook options in the test suite.

       <u>Logging</u> <u>Example</u> <u>1:</u>

       The following <u>ct_hooks</u> statement causes pretty printing of NETCONF  traffic  to  separate  logs  for  the
       connections named <u>nc_server1</u> and <u>nc_server2</u>. Any other connections are logged to default NETCONF log.

        suite() -&gt;
           [{ct_hooks, [{cth_conn_log, [{ct_netconfc,[{log_type,pretty}},
                                                      {hosts,[nc_server1,nc_server2]}]}
                                       ]}]}].

       Connections must be opened as follows:

        open(nc_server1,[...]),
        open(nc_server2,[...]).

       <u>Logging</u> <u>Example</u> <u>2:</u>

       The following configuration file causes raw logging of all NETCONF traffic in to one single text file:

        {ct_conn_log,[{ct_netconfc,[{log_type,raw}]}]}.

       The <u>ct_hooks</u> statement must look as follows:

        suite() -&gt;
           [{ct_hooks, [{cth_conn_log, []}]}].

       The  same  <u>ct_hooks</u>  statement  without  the  configuration  file would cause HTML logging of all NETCONF
       connections in to the test case HTML log.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>client()</b> = handle() | server_id() | ct:target_name()

              Handle to a NETCONF session, as required by signaling functions.

       <b>handle()</b>

              Handle to a connection to a NETCONF server as returned by <u>connect/1,2</u>, or to a session as returned
              by <u>session/1-3</u>, <u>open/1,2</u>, or <u>only_open/1,2</u>.

       <b>xs_datetime()</b> = string()

              Date and time of a startTime/stopTime element in an RFC 5277 create-subscription request.  Of  XML
              primitive type <u>dateTime</u>, which has the (informal) form

               [-]YYYY-MM-DDThh:mm:ss[.s][Z|(+|-)hh:mm]

              where <u>T</u> and <u>Z</u> are literal and <u>.s</u> is one or more fractional seconds.

       <b>notification()</b> =
           {notification, xml_attributes(), [simple_xml()]}

              Event notification messages sent as a result of calls to <u>create_subscription/2,3</u>.

       <b>option()</b> =
           {host | ssh, host()} |
           {port, inet:port_number()} |
           {timeout, timeout()} |
           {capability, string() | [string()]} |
           {receiver, term()} |
           ssh:client_option()

              Options  <u>host</u> and <u>port</u> specify the server endpoint to which to connect, and are passed directly to
              <u>ssh:connect/4</u>, as are arbitrary ssh options. Common options are <u>user</u>, <u>password</u> and <u>user_dir</u>.

              Option <u>timeout</u> specifies the number of milliseconds to allow for connection establishment and,  if
              the  function in question results in an outgoing hello message, reception of the server hello. The
              timeout applies to connection and hello independently; one timeout for  connection  establishment,
              another for hello reception.

              Option  <u>receiver</u> specifies a destination for incoming notification messages; a left operand of the
              send operator (<u>!</u>). If not specified then a process  calling  <u>create_subscription/2,3</u>  becomes  the
              receiver,  but  explicitly  setting a receiver makes it possible to receive notifications that are
              not ordered by calling this function. Multiple receiver options can be specified.

              Receiver options are ignored by connect/1-3.

              Option <u>capability</u> specifies the content of a corresponding element in an outgoing  hello  message,
              each  option  specifying  the  content  of  a  single  element.  If  no base NETCONF capability is
              configured then  the  RFC  4741  1.0  capability,  "urn:ietf:params:netconf:base:1.0",  is  added,
              otherwise  not.  In particular, the RFC 6241 1.1 capability must be explicitly configured. NETCONF
              capabilities can be specified using the shorthand notation defined in  RFC  6241,  any  capability
              string   starting   with   a   colon   being   prefixed  by  either  "urn:ietf:params:netconf"  or
              "urn:ietf:params:netconf:capability", as appropriate.

              Capability options are ignored by connect/1-3 and only_open/1-2, which don't result in an outgoing
              hello message.

       <b>server_id()</b> = atom()

              Identity of connection or session configuration in a configuration file.

       <b>stream_data()</b> =
           {description, string()} |
           {replaySupport, string()} |
           {replayLogCreationTime, string()} |
           {replayLogAgedTime, string()}

       <b>stream_name()</b> = string()

       <b>streams()</b> = [{stream_name(), [stream_data()]}]

              Stream information as returned by <u>get_event_streams/1-3</u>. See  RFC  5277,  "XML  Schema  for  Event
              Notifications", for detail on the format of the string values.

       <b>xml_attribute_tag()</b> = atom()

       <b>xml_attribute_value()</b> = string()

       <b>xml_attributes()</b> =
           [{xml_attribute_tag(), xml_attribute_value()}]

       <b>xml_content()</b> = [simple_xml() | iolist()]

       <b>xml_tag()</b> = atom()

       <b>simple_xml()</b> =
           {xml_tag(), xml_attributes(), xml_content()} |
           {xml_tag(), xml_content()} |
           xml_tag()

              Representation of XML, as described in application <u>xmerl</u>.

       <b>xpath()</b> = {xpath, string()}

       <b>error_reason()</b> = term()

       <b>host()</b> = inet:hostname() | inet:ip_address()

       <b>netconf_db()</b> = running | startup | candidate

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>action(Client,</b> <b>Action)</b> <b>-&gt;</b> <b>Result</b>

       <b>action(Client,</b> <b>Action,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Action = simple_xml()
                 Timeout = timeout()
                 Result = ok | {ok, [simple_xml()]} | {error, error_reason()}

              Executes an action. If the return type is void, <u>ok</u> is returned instead of <u>{ok,[simple_xml()]}</u>.

       <b>close_session(Client)</b> <b>-&gt;</b> <b>Result</b>

       <b>close_session(Client,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Timeout = timeout()
                 Result = ok | {error, error_reason()}

              Requests graceful termination of the session associated with the client.

              When  a  NETCONF  server  receives  a <u>close-session</u> request, it gracefully closes the session. The
              server releases any locks and resources associated with the  session  and  gracefully  closes  any
              associated connections. Any NETCONF requests received after a <u>close-session</u> request are ignored.

       <b>connect(Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Options = [option()]
                 Result = {ok, handle()} | {error, error_reason()}

              Opens an SSH connection to a NETCONF server.

              If the server options are specified in a configuration file, use <u>connect/2</u> instead.

              The  opaque  <u>handle()</u>  reference  returned from this function is required as connection identifier
              when opening sessions over this connection, see <u>session/1-3</u>.

       <b>connect(KeyOrName,</b> <b>ExtraOptions)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 KeyOrName = ct:key_or_name()
                 ExtraOptions = [option()]
                 Result = {ok, handle()} | {error, error_reason()}

              Open an SSH connection to a named NETCONF server.

              If <u>KeyOrName</u> is a configured <u>server_id()</u> or a <u>target_name()</u> associated with such an Id,  then  the
              options for this server are fetched from the configuration file.

              The  options  list  is added to those of the configuration file. If an option is specified in both
              lists, the configuration file takes precedence.

              If the server is not specified in a configuration file, use <u>connect/1</u> instead.

              The opaque <u>handle()</u> reference returned from this function can be  used  as  connection  identifier
              when  opening  sessions  over  this  connection,  see  <u>session/1-3</u>.  However,  if  <u>KeyOrName</u>  is a
              <u>target_name()</u>, that is, if the server is named  through  a  call  to  <u>ct:require/2</u>  or  a  <u>require</u>
              statement in the test suite, then this name can be used instead of <u>handle()</u>.

       <b>copy_config(Client,</b> <b>Target,</b> <b>Source)</b> <b>-&gt;</b> <b>Result</b>

       <b>copy_config(Client,</b> <b>Target,</b> <b>Source,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Target = Source = netconf_db()
                 Timeout = timeout()
                 Result = ok | {error, error_reason()}

              Copies configuration data.

              Which  source  and  target options that can be issued depends on the capabilities supported by the
              server. That is, <u>:candidate</u> and/or <u>:startup</u> are required.

       <b>create_subscription(Client,</b> <b>Values)</b> <b>-&gt;</b> <b>Result</b>

       <b>create_subscription(Client,</b> <b>Values,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Values =
                     #{stream =&gt; Stream,
                       filter =&gt; Filter,
                       start =&gt; StartTime,
                       stop =&gt; StopTime}
                 Stream = stream_name()
                 Filter = simple_xml() | [simple_xml()]
                 StartTime = StopTime = xs_datetime()
                 Timeout = timeout()
                 Result = ok | {error, error_reason()}

              Creates a subscription for event notifications by sending an RFC 5277 create-subscription  RPC  to
              the server. The calling process receives events as messages of type <u>notification()</u>.

              From RFC 5722, 2.1 Subscribing to Receive Event Notifications:

                <u>Stream</u>:
                  Indicates  which stream of event is of interest. If not present, events in the default NETCONF
                  stream are sent.

                <u>Filter</u>:
                  Indicates which subset of all possible events is of interest. The parameter format is the same
                  as that of the filter parameter in the NETCONF protocol operations. If not present, all events
                  not precluded by other parameters are sent.

                <u>StartTime</u>:
                  Used to trigger the replay feature and indicate that the  replay  is  to  start  at  the  time
                  specified.  If <u>StartTime</u> is not present, this is not a replay subscription. It is not valid to
                  specify start times that are later than the current time. If <u>StartTime</u>  is  specified  earlier
                  than  the  log  can  support, the replay begins with the earliest available notification. This
                  parameter is of type <u>dateTime</u> and compliant to RFC 3339.  Implementations  must  support  time
                  zones.

                <u>StopTime</u>:
                  Used  with  the  optional  replay feature to indicate the newest notifications of interest. If
                  <u>StopTime</u> is not present, the notifications continues until  the  subscription  is  terminated.
                  Must  be  used  with  and be later than <u>StartTime</u>. Values of <u>StopTime</u> in the future are valid.
                  This parameter is of type <u>dateTime</u> and compliant to RFC  3339.  Implementations  must  support
                  time zones.

              See  RFC  5277 for more details. The requirement that <u>StopTime</u> must only be used with <u>StartTime</u> is
              not enforced, to allow an invalid request to be sent to the server.

              Prior to OTP 22.1, this function was documented as having 15 variants  in  6  arities.  These  are
              still  exported  for  backwards  compatibility,  but  no longer documented. The map-based variants
              documented above provide the same functionality with simpler arguments.

          <b>Note:</b>
              create-subscription is no longer the only RPC with which NETCONF notifications can be ordered: RFC
              8639 adds establish-subscription and future RFCs may add other methods. Specify a <u>receiver</u>  option
              at session creation to provide a destination for incoming notifications independently of a call to
              <u>create_subscription/2,3</u>,  and  use  <u>send_rpc/2,3</u> to send establish-subscription and other arbirary
              RPCs.

       <b>delete_config(Client,</b> <b>Target)</b> <b>-&gt;</b> <b>Result</b>

       <b>delete_config(Client,</b> <b>Target,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Target = startup | candidate
                 Timeout = timeout()
                 Result = ok | {error, error_reason()}

              Deletes configuration data.

              The running configuration cannot be deleted and <u>:candidate</u> or <u>:startup</u> must be advertised  by  the
              server.

       <b>disconnect(Conn)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>error_reason()}</b>

              Types:

                 Conn = handle()

              Closes the given SSH connection.

              If  there  are  open  NETCONF sessions on the connection, these will be brutally aborted. To avoid
              this, close each session with <u>close_session/1,2</u>

       <b>edit_config(Client,</b> <b>Target,</b> <b>Config)</b> <b>-&gt;</b> <b>Result</b>

       <b>edit_config(Client,</b> <b>Target,</b> <b>Config,</b> <b>OptParams)</b> <b>-&gt;</b> <b>Result</b>

       <b>edit_config(Client,</b> <b>Target,</b> <b>Config,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

       <b>edit_config(Client,</b> <b>Target,</b> <b>Config,</b> <b>OptParams,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Target = netconf_db()
                 Config = simple_xml() | [simple_xml()]
                 OptParams = [simple_xml()]
                 Timeout = timeout()
                 Result = ok | {error, error_reason()}

              Edits configuration data.

              By default only the running target is available, unless the server includes <u>:candidate</u> or <u>:startup</u>
              in its list of capabilities.

              <u>OptParams</u> can be used for  specifying  optional  parameters  (<u>default-operation</u>,  <u>test-option</u>,  or
              <u>error-option</u>)  to  be  added to the <u>edit-config</u> request. The value must be a list containing valid
              simple XML, for example:

               [{'default-operation', ["none"]},
                {'error-option', ["rollback-on-error"]}]

              If <u>OptParams</u> is not given, the default value <u>[]</u> is used.

       <b>get(Client,</b> <b>Filter)</b> <b>-&gt;</b> <b>Result</b>

       <b>get(Client,</b> <b>Filter,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Filter = simple_xml() | xpath()
                 Timeout = timeout()
                 Result = {ok, [simple_xml()]} | {error, error_reason()}

              Gets data.

              This operation returns both configuration and state data from the server.

              Filter type <u>xpath</u> can be used only if the server supports <u>:xpath</u>.

       <b>get_capabilities(Client)</b> <b>-&gt;</b> <b>Result</b>

       <b>get_capabilities(Client,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Timeout = timeout()
                 Result = [string()] | {error, error_reason()}

              Returns the server capabilities as received in its hello message.

       <b>get_config(Client,</b> <b>Source,</b> <b>Filter)</b> <b>-&gt;</b> <b>Result</b>

       <b>get_config(Client,</b> <b>Source,</b> <b>Filter,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Source = netconf_db()
                 Filter = simple_xml() | xpath()
                 Timeout = timeout()
                 Result = {ok, [simple_xml()]} | {error, error_reason()}

              Gets configuration data.

              To be able to access another source than <u>running</u>, the  server  must  advertise  <u>:candidate</u>  and/or
              <u>:startup</u>.

              Filter type <u>xpath</u> can be used only if the server supports <u>:xpath</u>.

       <b>get_event_streams(Client)</b> <b>-&gt;</b> <b>Result</b>

       <b>get_event_streams(Client,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

       <b>get_event_streams(Client,</b> <b>Streams)</b> <b>-&gt;</b> <b>Result</b>

       <b>get_event_streams(Client,</b> <b>Streams,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Streams = [stream_name()]
                 Timeout = timeout()
                 Result = {ok, streams()} | {error, error_reason()}

              Sends a request to get the specified event streams.

              <u>Streams</u>  is  a  list  of stream names. The following filter is sent to the NETCONF server in a <u>get</u>
              request:

               &lt;netconf xmlns="urn:ietf:params:xml:ns:netmod:notification"&gt;
                 &lt;streams&gt;
                   &lt;stream&gt;
                     &lt;name&gt;StreamName1&lt;/name&gt;
                   &lt;/stream&gt;
                   &lt;stream&gt;
                     &lt;name&gt;StreamName2&lt;/name&gt;
                   &lt;/stream&gt;
                   ...
                 &lt;/streams&gt;
               &lt;/netconf&gt;

              If <u>Streams</u> is an empty list, <u>all</u> streams are requested by sending the following filter:

               &lt;netconf xmlns="urn:ietf:params:xml:ns:netmod:notification"&gt;
                 &lt;streams/&gt;
               &lt;/netconf&gt;

              If more complex filtering  is  needed,  use  <u>ct_netconfc:get/2,3</u>  and  specify  the  exact  filter
              according to "XML Schema for Event Notifications" in RFC 5277.

       <b>get_session_id(Client)</b> <b>-&gt;</b> <b>Result</b>

       <b>get_session_id(Client,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Timeout = timeout()
                 Result = integer() &gt;= 1 | {error, error_reason()}

              Returns the session Id associated with the specified client.

       <b>hello(Client)</b> <b>-&gt;</b> <b>Result</b>

       <b>hello(Client,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

       <b>hello(Client,</b> <b>Options,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = handle()
                 Options = [{capability, [string()]}]
                 Timeout = timeout()
                 Result = ok | {error, error_reason()}

              Exchanges <u>hello</u> messages with the server. Returns when the server hello has been received or after
              the specified timeout.

              Note that capabilities for an outgoing hello can be passed directly to <u>open/2</u>.

       <b>kill_session(Client,</b> <b>SessionId)</b> <b>-&gt;</b> <b>Result</b>

       <b>kill_session(Client,</b> <b>SessionId,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 SessionId = integer() &gt;= 1
                 Timeout = timeout()
                 Result = ok | {error, error_reason()}

              Forces termination of the session associated with the supplied session Id.

              The server side must abort any ongoing operations, release any locks and resources associated with
              the session, and close any associated connections.

              Only  if  the  server is in the confirmed commit phase, the configuration is restored to its state
              before entering the confirmed commit phase. Otherwise, no configuration rollback is performed.

              If the specified <u>SessionId</u> is equal to the current session Id, an error is returned.

       <b>lock(Client,</b> <b>Target)</b> <b>-&gt;</b> <b>Result</b>

       <b>lock(Client,</b> <b>Target,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Target = netconf_db()
                 Timeout = timeout()
                 Result = ok | {error, error_reason()}

              Locks the configuration target.

              Which target parameters that can be used depends on if <u>:candidate</u> and/or <u>:startup</u> are supported by
              the server. If successfull, the configuration system of the device is unavailable to other clients
              (NETCONF, CORBA, SNMP, and so on). Locks are intended to be short-lived.

              Operation <u>kill_session/2,3</u> can be used to force the release of a lock  owned  by  another  NETCONF
              session. How this is achieved by the server side is implementation-specific.

       <b>only_open(Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Options = [option()]
                 Result = {ok, handle()} | {error, error_reason()}

              Opens a NETCONF session, but does not send <u>hello</u>.

              As <u>open/1</u>, but does not send a <u>hello</u> message.

       <b>only_open(KeyOrName,</b> <b>ExtraOptions)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 KeyOrName = ct:key_or_name()
                 ExtraOptions = [option()]
                 Result = {ok, handle()} | {error, error_reason()}

              Opens a named NETCONF session, but does not send <u>hello</u>.

              As <u>open/2</u>, but does not send a <u>hello</u> message.

       <b>open(Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Options = [option()]
                 Result = {ok, handle()} | {error, error_reason()}

              Opens a NETCONF session and exchanges <u>hello</u> messages.

              If  the  server  options are specified in a configuration file, or if a named client is needed for
              logging purposes (see section Logging in this module), use <u>open/2</u> instead.

              The opaque <u>handle()</u> reference returned from this function is required as  client  identifier  when
              calling any other function in this module.

       <b>open(KeyOrName,</b> <b>ExtraOption)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 KeyOrName = ct:key_or_name()
                 ExtraOption = [option()]
                 Result = {ok, handle()} | {error, error_reason()}

              Opens a named NETCONF session and exchanges <u>hello</u> messages.

              If  <u>KeyOrName</u>  is a configured <u>server_id()</u> or a <u>target_name()</u> associated with such an Id, then the
              options for this server are fetched from the configuration file.

              The options list is added to those of the configuration file. If an option is  specified  in  both
              lists, the configuration file take precedence.

              If the server is not specified in a configuration file, use <u>open/1</u> instead.

              The  opaque  <u>handle()</u>  reference returned from this function can be used as client identifier when
              calling any other function in this module. However, if <u>KeyOrName</u> is a <u>target_name()</u>, that  is,  if
              the  server is named through a call to <u>ct:require/2</u> or a <u>require</u> statement in the test suite, then
              this name can be used instead of <u>handle()</u>.

              See also <u>ct:require/2</u>.

       <b>send(Client,</b> <b>SimpleXml)</b> <b>-&gt;</b> <b>Result</b>

       <b>send(Client,</b> <b>SimpleXml,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 SimpleXml = simple_xml()
                 Timeout = timeout()
                 Result = simple_xml() | {error, error_reason()}

              Sends an XML document to the server.

              The specified XML document is sent "as is" to the server. This function can be  used  for  sending
              XML documents that cannot be expressed by other interface functions in this module.

       <b>send_rpc(Client,</b> <b>SimpleXml)</b> <b>-&gt;</b> <b>Result</b>

       <b>send_rpc(Client,</b> <b>SimpleXml,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 SimpleXml = simple_xml()
                 Timeout = timeout()
                 Result = [simple_xml()] | {error, error_reason()}

              Sends a NETCONF <u>rpc</u> request to the server.

              The  specified  XML document is wrapped in a valid NETCONF <u>rpc</u> request and sent to the server. The
              <u>message-id</u> and namespace attributes are added to element <u>rpc</u>.

              This function can be used for sending <u>rpc</u> requests that cannot be  expressed  by  other  interface
              functions in this module.

       <b>session(Conn)</b> <b>-&gt;</b> <b>Result</b>

       <b>session(Conn,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

       <b>session(KeyOrName,</b> <b>Conn)</b> <b>-&gt;</b> <b>Result</b>

       <b>session(KeyOrName,</b> <b>Conn,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Conn = handle()
                 Options = [session_option()]
                 KeyOrName = ct:key_or_name()
                 Result = {ok, handle()} | {error, error_reason()}
                 <b>session_option()</b> =
                     {timeout, timeout()} |
                     {receiver, term()} |
                     {capability, string() | [string()]}

              Opens  a  NETCONF  session  as a channel on the given SSH connection, and exchanges hello messages
              with the server.

              The opaque <u>handle()</u> reference returned from this function can be used as  client  identifier  when
              calling  any  other  function  in  this  module.  However,  if  <u>KeyOrName</u>  is  used  and  it  is a
              <u>target_name()</u>, that is, if the server is named  through  a  call  to  <u>ct:require/2</u>  or  a  <u>require</u>
              statement in the test suite, then this name can be used instead of <u>handle()</u>.

       <b>unlock(Client,</b> <b>Target)</b> <b>-&gt;</b> <b>Result</b>

       <b>unlock(Client,</b> <b>Target,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Client = client()
                 Target = netconf_db()
                 Timeout = timeout()
                 Result = ok | {error, error_reason()}

              Unlocks the configuration target.

              If the client earlier has acquired a lock through <u>lock/2,3</u>, this operation releases the associated
              lock. To access another target than <u>running</u>, the server must support <u>:candidate</u> and/or <u>:startup</u>.

Ericsson AB                                     common_test 1.22                               <u><a href="../man3erl/ct_netconfc.3erl.html">ct_netconfc</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>