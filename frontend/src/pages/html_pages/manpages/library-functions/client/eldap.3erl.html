<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>eldap - LDAP Client</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       eldap - LDAP Client

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides a client api to the Lightweight Directory Access Protocol (LDAP).

       References:

         * RFC 4510 - RFC 4519

         * RFC 2830

       The above publications can be found at IETF.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       Type definitions that are used more than once in this module:

         <u>handle()</u>:
           Connection handle

         <u>attribute()</u> <u>=</u>:
           <u>{Type</u> <u>=</u> <u>string(),</u> <u>Values=[string()]}</u>

         <u>modify_op()</u>:
           See mod_add/2, mod_delete/2, mod_replace/2

         <u>scope()</u>:
           See baseObject/0, singleLevel/0, wholeSubtree/0

         <u>dereference()</u>:
           See neverDerefAliases/0, derefInSearching/0, derefFindingBaseObj/0, derefAlways/0

         <u>filter()</u>:
           See   present/1,   substrings/2,  equalityMatch/2,  greaterOrEqual/2,  lessOrEqual/2,  approxMatch/2,
           extensibleMatch/2, 'and'/1, 'or'/1, 'not'/1

         <u>return_value()</u> <u>=</u> :
           <u>ok</u> <u>|</u> <u>{ok,</u> <u>{referral,referrals()}}</u> <u>|</u> <u>{error,Error}</u>

         <u>referrals()</u> <u>=</u>:
           <u>[Address</u> <u>=</u> <u>string()]</u> The contents of <u>Address</u> is server dependent.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>open([Host])</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Handle = handle()

              Setup a connection to an LDAP server, the <u>HOST</u>'s are tried in order.

       <b>open([Host],</b> <b>[Option])</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Handle = handle()
                 Option = {port, integer()} | {log, function()} | {timeout,  integer()}  |  {ssl,  boolean()}  |
                 {sslopts, list()} | {tcpopts, list()}

              Setup a connection to an LDAP server, the <u>HOST</u>'s are tried in order.

              The log function takes three arguments, <u>fun(Level,</u> <u>FormatString,</u> <u>[FormatArg])</u> <u>end</u>.

              Timeout set the maximum time in milliseconds that each server request may take.

              All TCP socket options are accepted except <u>active</u>, <u>binary</u>, <u>deliver</u>, <u>list</u>, <u>mode</u> and <u>packet</u>

       <b>close(Handle)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Handle = handle()

              Shutdown the connection after sending an unbindRequest to the server. If the connection is tls the
              connection will be closed with <u>ssl:close/1</u>, otherwise with <u>gen_tcp:close/1</u>.

       <b>start_tls(Handle,</b> <b>Options)</b> <b>-&gt;</b> <b>return_value()</b>

              Same as start_tls(Handle, Options, infinity)

       <b>start_tls(Handle,</b> <b>Options,</b> <b>Timeout)</b> <b>-&gt;</b> <b>return_value()</b>

              Types:

                 Handle = handle()
                 Options = ssl:ssl_options()
                 Timeout = infinity | positive_integer()

              Upgrade the connection associated with <u>Handle</u> to a tls connection if possible.

              The upgrade is done in two phases: first the server is asked for permission to upgrade. Second, if
              the request is acknowledged, the upgrade to tls is performed.

              Error  responses  from  phase  one will not affect the current encryption state of the connection.
              Those responses are:

                <u>tls_already_started</u>:
                  The connection is already encrypted. The connection is not affected.

                <u>{response,ResponseFromServer}</u>:
                  The upgrade was refused by the LDAP server. The <u>ResponseFromServer</u> is an  atom  delivered  byt
                  the LDAP server explained in section 2.3 of rfc 2830. The connection is not affected, so it is
                  still un-encrypted.

              Errors in the second phase will however end the connection:

                <u>Error</u>:
                  Any error responded from ssl:connect/3

              The <u>Timeout</u> parameter is for the actual tls upgrade (phase 2) while the timeout in eldap:open/2 is
              used for the initial negotiation about upgrade (phase 1).

       <b>simple_bind(Handle,</b> <b>Dn,</b> <b>Password)</b> <b>-&gt;</b> <b>return_value()</b>

              Types:

                 Handle = handle()
                 Dn = string()
                 Password = string()

              Authenticate the connection using simple authentication.

       <b>add(Handle,</b> <b>Dn,</b> <b>[Attribute])</b> <b>-&gt;</b> <b>return_value()</b>

              Types:

                 Handle = handle()
                 Dn = string()
                 Attribute = attribute()

              Add an entry. The entry must not exist.

                add(Handle,
                    "cn=Bill Valentine, ou=people, o=Example Org, dc=example, dc=com",
                     [{"objectclass", ["person"]},
                      {"cn", ["Bill Valentine"]},
                      {"sn", ["Valentine"]},
                      {"telephoneNumber", ["545 555 00"]}]
                   )

       <b>delete(Handle,</b> <b>Dn)</b> <b>-&gt;</b> <b>return_value()</b>

              Types:

                 Dn = string()

              Delete an entry.

                delete(Handle, "cn=Bill Valentine, ou=people, o=Example Org, dc=example, dc=com")

       <b>mod_add(Type,</b> <b>[Value])</b> <b>-&gt;</b> <b>modify_op()</b>

              Types:

                 Type = string()
                 Value = string()

              Create an add modification operation.

       <b>mod_delete(Type,</b> <b>[Value])</b> <b>-&gt;</b> <b>modify_op()</b>

              Types:

                 Type = string()
                 Value = string()

              Create a delete modification operation.

       <b>mod_replace(Type,</b> <b>[Value])</b> <b>-&gt;</b> <b>modify_op()</b>

              Types:

                 Type = string()
                 Value = string()

              Create a replace modification operation.

       <b>modify(Handle,</b> <b>Dn,</b> <b>[ModifyOp])</b> <b>-&gt;</b> <b>return_value()</b>

              Types:

                 Dn = string()
                 ModifyOp = modify_op()

              Modify an entry.

                modify(Handle, "cn=Bill Valentine, ou=people, o=Example Org, dc=example, dc=com",
                       [eldap:mod_replace("telephoneNumber", ["555 555 00"]),
                     eldap:mod_add("description", ["LDAP Hacker"]) ])

       <b>modify_password(Handle,</b> <b>Dn,</b> <b>NewPasswd)</b> <b>-&gt;</b> <b>return_value()</b> <b>|</b> <b>{ok,</b> <b>GenPasswd}</b>

              Types:

                 Dn = string()
                 NewPasswd = string()

              Modify the password of a user. See modify_password/4.

       <b>modify_password(Handle,</b> <b>Dn,</b> <b>NewPasswd,</b> <b>OldPasswd)</b> <b>-&gt;</b> <b>return_value()</b> <b>|</b> <b>{ok,</b> <b>GenPasswd}</b>

              Types:

                 Dn = string()
                 NewPasswd = string()
                 OldPasswd = string()
                 GenPasswd = string()

              Modify the password of a user.

                * <u>Dn</u>.  The  user  to  modify.  Should  be  ""  if the modify request is for the user of the LDAP
                  session.

                * <u>NewPasswd</u>. The new password to set. Should be "" if the server is to generate the password. In
                  this case, the result will be <u>{ok,</u> <u>GenPasswd}</u>.

                * <u>OldPasswd</u>. Sometimes required by server policy for a user to change  their  password.  If  not
                  required, use modify_password/3.

       <b>modify_dn(Handle,</b> <b>Dn,</b> <b>NewRDN,</b> <b>DeleteOldRDN,</b> <b>NewSupDN)</b> <b>-&gt;</b> <b>return_value()</b>

              Types:

                 Dn = string()
                 NewRDN = string()
                 DeleteOldRDN = boolean()
                 NewSupDN = string()

              Modify  the  DN of an entry. <u>DeleteOldRDN</u> indicates whether the current RDN should be removed from
              the attribute list after the operation. <u>NewSupDN</u> is the new parent that the RDN shall be moved to.
              If the old parent should remain as parent, <u>NewSupDN</u> shall be "".

                modify_dn(Handle, "cn=Bill Valentine, ou=people, o=Example Org, dc=example, dc=com ",
                          "cn=Bill Jr Valentine", true, "")

       <b>search(Handle,</b> <b>SearchOptions)</b> <b>-&gt;</b> <b>{ok,</b> <b>#eldap_search_result{}}</b> <b>|</b> <b>{ok,</b>  <b>{referral,referrals()}}</b>  <b>|</b>  <b>{error,</b>
       <b>Reason}</b>

              Types:

                 SearchOptions = #eldap_search{} | [SearchOption]
                 SearchOption  =  {base,  string()}  |  {filter,  filter()}  |  {scope,  scope()} | {attributes,
                 [string()]} | {deref, dereference()} | | {types_only, boolean()} | {timeout, integer()}

              Search the directory with the supplied the SearchOptions. The base  and  filter  options  must  be
              supplied. Default values: scope is <u>wholeSubtree()</u>, deref is <u>derefAlways()</u>, types_only is <u>false</u> and
              timeout is <u>0</u> (meaning infinity).

                Filter = eldap:substrings("cn", [{any,"V"}]),
                search(Handle, [{base, "dc=example, dc=com"}, {filter, Filter}, {attributes, ["cn"]}]),

              The  <u>timeout</u> option in the <u>SearchOptions</u> is for the ldap server, while the timeout in eldap:open/2
              is used for each individual request in the search operation.

       <b>baseObject()</b> <b>-&gt;</b> <b>scope()</b>

              Search baseobject only.

       <b>singleLevel()</b> <b>-&gt;</b> <b>scope()</b>

              Search the specified level only, i.e. do not recurse.

       <b>wholeSubtree()</b> <b>-&gt;</b> <b>scope()</b>

              Search the entire subtree.

       <b>neverDerefAliases()</b> <b>-&gt;</b> <b>dereference()</b>

              Never derefrence aliases, treat aliases as entries.

       <b>derefAlways()</b> <b>-&gt;</b> <b>dereference()</b>

              Always derefrence aliases.

       <b>derefInSearching()</b> <b>-&gt;</b> <b>dereference()</b>

              Derefrence aliases only when searching.

       <b>derefFindingBaseObj()</b> <b>-&gt;</b> <b>dereference()</b>

              Derefrence aliases only in finding the base.

       <b>present(Type)</b> <b>-&gt;</b> <b>filter()</b>

              Types:

                 Type = string()

              Create a filter which filters on attribute type presence.

       <b>substrings(Type,</b> <b>[SubString])</b> <b>-&gt;</b> <b>filter()</b>

              Types:

                 Type = string()
                 SubString = {StringPart, string()}
                 StringPart = initial | any | final

              Create a filter which filters on substrings.

       <b>equalityMatch(Type,</b> <b>Value)</b> <b>-&gt;</b> <b>filter()</b>

              Types:

                 Type = string()
                 Value = string()

              Create a equality filter.

       <b>greaterOrEqual(Type,</b> <b>Value)</b> <b>-&gt;</b> <b>filter()</b>

              Types:

                 Type = string()
                 Value = string()

              Create a greater or equal filter.

       <b>lessOrEqual(Type,</b> <b>Value)</b> <b>-&gt;</b> <b>filter()</b>

              Types:

                 Type = string()
                 Value = string()

              Create a less or equal filter.

       <b>approxMatch(Type,</b> <b>Value)</b> <b>-&gt;</b> <b>filter()</b>

              Types:

                 Type = string()
                 Value = string()

              Create a approximation match filter.

       <b>extensibleMatch(MatchValue,</b> <b>OptionalAttrs)</b> <b>-&gt;</b> <b>filter()</b>

              Types:

                 MatchValue = string()
                 OptionalAttrs = [Attr]
                 Attr = {matchingRule,string()} | {type,string()} | {dnAttributes,boolean()}

              Creates an extensible match filter. For example,

                eldap:extensibleMatch("Bar", [{type,"sn"}, {matchingRule,"caseExactMatch"}]))

              creates a filter which performs a <u>caseExactMatch</u> on the attribute <u>sn</u> and matches  with  the  value
              <u>"Bar"</u>. The default value of <u>dnAttributes</u> is <u>false</u>.

       <b>'and'([Filter])</b> <b>-&gt;</b> <b>filter()</b>

              Types:

                 Filter = filter()

              Creates a filter where all <u>Filter</u> must be true.

       <b>'or'([Filter])</b> <b>-&gt;</b> <b>filter()</b>

              Types:

                 Filter = filter()

              Create a filter where at least one of the <u>Filter</u> must be true.

       <b>'not'(Filter)</b> <b>-&gt;</b> <b>filter()</b>

              Types:

                 Filter = filter()

              Negate a filter.

Ericsson AB                                        eldap 1.2.9                                       <u><a href="../man3erl/eldap.3erl.html">eldap</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>