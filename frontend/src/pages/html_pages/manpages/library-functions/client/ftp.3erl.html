<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ftp - A File Transfer Protocol client.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ftp - A File Transfer Protocol client.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  implements  a  client for file transfer according to a subset of the File Transfer Protocol
       (FTP), see RFC 959.

       The FTP client always tries to use passive FTP mode and only resort to active FTP  mode  if  this  fails.
       This default behavior can be changed by start option mode.

       An  FTP  client  is  always  started as part of the ftp application and legacy start_service function, is
       deprecated in OTP-24

       For a simple example of an FTP session, see FTP User's Guide.

       In addition to the ordinary functions for receiving and sending files (see <u>recv/2</u>,  <u>recv/3</u>,  <u>send/2</u>,  and
       <u>send/3</u>)  there  are  functions  for  receiving  remote files as binaries (see <u>recv_bin/2</u>) and for sending
       binaries to be stored as remote files (see <u>send_bin/3</u>).

       A set of functions is provided for sending and receiving contiguous parts of a file to  be  stored  in  a
       remote  file.  For  send,  see  <u>send_chunk_start/2</u>,  <u>send_chunk/2</u>, and <u>send_chunk_end/1</u>. For receive, see
       <u>recv_chunk_start/2</u> and <u>recv_chunk/</u>).

       The return values of the following functions depend much on the implementation of the FTP server  at  the
       remote  host.  In particular, the results from <u>ls</u> and <u>nlist</u> varies. Often real errors are not reported as
       errors by <u>ls</u>, even if, for example, a file or directory does not exist. <u>nlist</u> is usually more strict, but
       some implementations have the peculiar behaviour of responding with an error if the request is a  listing
       of the contents of a directory that exists but is empty.

</pre><h4><b>FTP</b> <b>CLIENT</b> <b>START/STOP</b></h4><pre>
       The  FTP  client  can  be  started  and stopped dynamically in runtime by calling the <u>ftp</u> application API
       <u>ftp:open(Host,</u> <u>Options)</u> and <u>ftp:close(Client)</u>.

       The available configuration options are as follows:

         <b>{host,</b> <b>Host}:</b>

           Host = <u>string()</u> <u>|</u> <u>ip_address()</u>

         <b>{port,</b> <b>Port}:</b>

           Port = <u>integer()</u> <u>&gt;</u> <u>0</u>

           Default is <u>0</u> which aliases to <u>21</u> or <u>990</u> when used with <u>{tls_sec_method,ftps}</u>).

         <b>{mode,</b> <b>Mode}:</b>

           Mode = <u>active</u> <u>|</u> <u>passive</u>

           Default is <u>passive</u>.

         <b>{verbose,</b> <b>Verbose}:</b>

           Verbose = <u>boolean()</u>

           Determines if the FTP communication is to be verbose or not.

           Default is <u>false</u>.

         <b>{debug,</b> <b>Debug}:</b>

           Debug = <u>trace</u> <u>|</u> <u>debug</u> <u>|</u> <u>disable</u>

           Debugging using the dbg toolkit.

           Default is <u>disable</u>.

         <b>{ipfamily,</b> <b>IpFamily}:</b>

           IpFamily = <u>inet</u> <u>|</u> <u>inet6</u> <u>|</u> <u>inet6fb4</u>

           With <u>inet6fb4</u> the client behaves as before, that is, tries to use IPv6, and only  if  that  does  not
           work it uses IPv4).

           Default is <u>inet</u> (IPv4).

         <b>{timeout,</b> <b>Timeout}:</b>

           Timeout = <u>non_neg_integer()</u>

           Connection time-out.

           Default is <u>60000</u> (milliseconds).

         <b>{dtimeout,</b> <b>DTimeout}:</b>

           DTimeout = <u>non_neg_integer()</u> <u>|</u> <u>infinity</u>

           Data connect time-out. The time the client waits for the server to connect to the data socket.

           Default is <u>infinity</u>.

         <b>{progress,</b> <b>Progress}:</b>

           Progress = <u>ignore</u> <u>|</u> <u>{CBModule,</u> <u>CBFunction,</u> <u>InitProgress}</u>

           <u>CBModule</u> <u>=</u> <u>atom()</u>, <u>CBFunction</u> <u>=</u> <u>atom()</u>

           <u>InitProgress</u> <u>=</u> <u>term()</u>

           Default is <u>ignore</u>.

       Option  <u>progress</u> is intended to be used by applications that want to create some type of progress report,
       such as a progress bar in a GUI. Default for the progress option is <u>ignore</u>, that is, the  option  is  not
       used.  When the progress option is specified, the following happens when <u>ftp:send/[3,4]</u> or <u>ftp:recv/[3,4]</u>
       are called:

         * Before a file is transferred, the following call is made to indicate the start of the  file  transfer
           and  how  large  the  file is. The return value of the callback function is to be a new value for the
           <u>UserProgressTerm</u> that will be used as input the next time the callback function is called.

            <u>CBModule:CBFunction(InitProgress,</u> <u>File,</u> <u>{file_size,</u> <u>FileSize})</u>

         * Every time a chunk of bytes is transferred the following call is made:

            <u>CBModule:CBFunction(UserProgressTerm,</u> <u>File,</u> <u>{transfer_size,</u> <u>TransferSize})</u>

         * At the end of the file the following call is made to indicate the end of the transfer:

            <u>CBModule:CBFunction(UserProgressTerm,</u> <u>File,</u> <u>{transfer_size,</u> <u>0})</u>

       The callback function is to be defined as follows:

        <u>CBModule:CBFunction(UserProgressTerm,</u> <u>File,</u> <u>Size)</u> <u>-&gt;</u> <u>UserProgressTerm</u>

        <u>CBModule</u> <u>=</u> <u>CBFunction</u> <u>=</u> <u>atom()</u>

        <u>UserProgressTerm</u> <u>=</u> <u>term()</u>

        <u>File</u> <u>=</u> <u>string()</u>

        <u>Size</u> <u>=</u> <u>{transfer_size,</u> <u>integer()}</u> <u>|</u> <u>{file_size,</u> <u>integer()}</u> <u>|</u> <u>{file_size,</u> <u>unknown}</u>

       For remote files, <u>ftp</u> cannot determine the file size in a platform independent way. In this case the size
       becomes <u>unknown</u> and it is left to the application to determine the size.

   <b>Note:</b>
       The callback is made by a middleman process, hence the file transfer is not affected by the code  in  the
       progress  callback  function.  If  the  callback crashes, this is detected by the FTP connection process,
       which then prints an info-report and goes on as if the progress option was set to <u>ignore</u>.

       The file transfer type is set to the default of the FTP server  when  the  session  is  opened.  This  is
       usually ASCII mode.

       The  current local working directory (compare <u>lpwd/1</u>) is set to the value reported by <u>file:get_cwd/1</u>, the
       wanted local directory.

       The return value <u>Pid</u> is used as a reference to the newly created FTP client in all other  functions,  and
       they  are  to  be  called by the process that created the connection. The FTP client process monitors the
       process that created it and terminates if that process terminates.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       The following type definitions are used by more than one function in the FTP client API:

       <u>pid()</u> = identifier of an FTP connection

       <u>string()</u> = list of ASCII characters

       <u>shortage_reason()</u> = <u>etnospc</u> <u>|</u> <u>epnospc</u>

       <u>restriction_reason()</u> = <u>epath</u> <u>|</u> <u>efnamena</u> <u>|</u> <u>elogin</u> <u>|</u> <u>enotbinary</u> - all restrictions are not always  relevant
       to all functions

       <u>common_reason()</u> = <u>econn</u> <u>|</u> <u>eclosed</u> <u>|</u> <u>term()</u> - some explanation of what went wrong

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>account(Pid,</b> <b>Account)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Account = string()
                 Reason = eacct | common_reason()

              Sets the account for an operation, if needed.

       <b>append(Pid,</b> <b>LocalFile)</b> <b>-&gt;</b>
       <b>append(Pid,</b> <b>LocalFile,</b> <b>RemoteFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 LocalFile = RemoteFile = string()
                 Reason = epath | elogin | etnospc | epnospc | efnamena | common_reason

              Transfers  the  file  <u>LocalFile</u>  to the remote server. If <u>RemoteFile</u> is specified, the name of the
              remote file that the file is appended to is set to <u>RemoteFile</u>, otherwise to <u>LocalFile</u>. If the file
              does not exists, it is created.

       <b>append_bin(Pid,</b> <b>Bin,</b> <b>RemoteFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Bin = binary()
                 RemoteFile = string()
                 Reason = restriction_reason()| shortage_reason() | common_reason()

              Transfers the binary <u>Bin</u> to the remote server and appends it to the file <u>RemoteFile</u>. If  the  file
              does not exist, it is created.

       <b>append_chunk(Pid,</b> <b>Bin)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Bin = binary()
                 Reason = echunk | restriction_reason() | common_reason()

              Transfers  the  chunk <u>Bin</u> to the remote server, which appends it to the file specified in the call
              to <u>append_chunk_start/2</u>.

              For some errors, for example, file system full, it is necessary to call  <u>append_chunk_end</u>  to  get
              the proper reason.

       <b>append_chunk_start(Pid,</b> <b>File)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 File = string()
                 Reason = restriction_reason() | common_reason()

              Starts  the  transfer  of  chunks for appending to the file <u>File</u> at the remote server. If the file
              does not exist, it is created.

       <b>append_chunk_end(Pid)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Reason = echunk | restriction_reason() | shortage_reason()

              Stops transfer of chunks for appending to the remote  server.  The  file  at  the  remote  server,
              specified in the call to <u>append_chunk_start/2</u>, is closed by the server.

       <b>cd(Pid,</b> <b>Dir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Dir = string()
                 Reason = restriction_reason() | common_reason()

              Changes the working directory at the remote server to <u>Dir</u>.

       <b>close(Pid)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Pid = pid()

              Ends an FTP session, created using function open.

       <b>delete(Pid,</b> <b>File)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 File = string()
                 Reason = restriction_reason() | common_reason()

              Deletes the file <u>File</u> at the remote server.

       <b>formaterror(Tag)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Tag = {error, atom()} | atom()

              Given  an  error  return  value  <u>{error,</u>  <u>AtomReason}</u>,  this  function  returns  a readable string
              describing the error.

       <b>lcd(Pid,</b> <b>Dir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Dir = string()
                 Reason = restriction_reason()

              Changes the working directory to <u>Dir</u> for the local client.

       <b>lpwd(Pid)</b> <b>-&gt;</b> <b>{ok,</b> <b>Dir}</b>

              Types:

                 Pid = pid()

              Returns the current working directory at the local client.

       <b>ls(Pid)</b> <b>-&gt;</b>
       <b>ls(Pid,</b> <b>Pathname)</b> <b>-&gt;</b> <b>{ok,</b> <b>Listing}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Pathname = string()
                 Listing = string()
                 Reason = restriction_reason() | common_reason()

              Returns a list of files in long format.

              <u>Pathname</u> can be a directory, a group of  files,  or  a  file.  The  <u>Pathname</u>  string  can  contain
              wildcards.

              <u>ls/1</u> implies the current remote directory of the user.

              The  format of <u>Listing</u> depends on the operating system. On UNIX, it is typically produced from the
              output of the <u>ls</u> <u>-l</u> shell command.

       <b>mkdir(Pid,</b> <b>Dir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Dir = string()
                 Reason = restriction_reason() | common_reason()

              Creates the directory <u>Dir</u> at the remote server.

       <b>nlist(Pid)</b> <b>-&gt;</b>
       <b>nlist(Pid,</b> <b>Pathname)</b> <b>-&gt;</b> <b>{ok,</b> <b>Listing}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Pathname = string()
                 Listing = string()
                 Reason = restriction_reason() | common_reason()

              Returns a list of files in short format.

              <u>Pathname</u> can be a directory, a group of  files,  or  a  file.  The  <u>Pathname</u>  string  can  contain
              wildcards.

              <u>nlist/1</u> implies the current remote directory of the user.

              The format of <u>Listing</u> is a stream of filenames where each filename is separated by &lt;CRLF&gt; or &lt;NL&gt;.
              Contrary  to  function  <u>ls</u>,  the  purpose  of  <u>nlist</u>  is  to  enable a program to process filename
              information automatically.

       <b>open(Host)</b> <b>-&gt;</b> <b>{ok,</b> <b>Pid}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>open(Host,</b> <b>Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>Pid}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Host = string() | ip_address()
                 Opts = options()
                 options() = [option()]
                 option() = start_option() | open_option()
                 start_option() = {verbose, verbose()} | {debug, debug()}
                 verbose() = boolean() (default is false)
                 debug() = disable | debug | trace (default is disable)
                 open_option() = {ipfamily, ipfamily()} | {port, port()} | {mode, mode()} | {tls, tls_options()}
                 | {tls_sec_method, tls_sec_method()} | {tls_ctrl_session_reuse, boolean() (default is false)} |
                 {timeout,  timeout()}  |  {dtimeout,  dtimeout()}  |  {progress,  progress()}   |   {sock_ctrl,
                 sock_opts()} | {sock_data_act, sock_opts()} | {sock_data_pass, sock_opts()}
                 ipfamily() = inet | inet6 | inet6fb4 (default is inet)
                 port()  =  non_neg_integer()  (default  is  0  which  aliases  to  21  or  990  when  used with
                 {tls_sec_method,ftps})
                 mode() = active | passive (default is passive)
                 tls_options() = [ssl:tls_option()]
                 tls_sec_method() = ftps | ftpes (default is ftpes)
                 sock_opts() = [gen_tcp:option() except for ipv6_v6only, active, packet, mode,  packet_size  and
                 header
                 timeout() = integer() &gt; 0 (default is 60000 milliseconds)
                 dtimeout() = integer() &gt; 0 | infinity (default is infinity)
                 progress() = ignore | {module(), function(), initial_data()} (default is ignore)
                 module() = atom()
                 function() = atom()
                 initial_data() = term()
                 Reason = ehost | term()

              Starts a FTP client process and opens a session with the FTP server at <u>Host</u>.

              If  option <u>{tls,</u> <u>tls_options()}</u> is present, the FTP session is transported over <u>tls</u> (<u>ftps</u>, see RFC
              4217). The list <u>tls_options()</u> can be empty. The function <u>ssl:connect/3</u> is used for  securing  both
              the control connection and the data sessions.

              The suboption <u>{tls_sec_method,</u> <u>tls_sec_method()}</u> (defaults to <u>ftpes</u>) when set to <u>ftps</u> will connect
              immediately  with  SSL  instead  of  upgrading with STARTTLS. This suboption is ignored unless the
              suboption <u>tls</u> is also set.

              The option <u>{tls_ctrl_session_reuse,</u> <u>boolean()}</u> (defaults to <u>false</u>) when set  to  <u>true</u>  the  client
              will  re-use  the TLS session from the control channel on the data channel as enforced by many FTP
              servers as (proposed and implemented first by vsftpd).

              The options <u>sock_ctrl</u>, <u>sock_data_act</u> and <u>sock_data_pass</u> passes  options  down  to  the  underlying
              transport   layer   (tcp).  The  default  value  for  <u>sock_ctrl</u>  is  <u>[]</u>.  Both  <u>sock_data_act</u>  and
              <u>sock_data_pass</u> uses the value of <u>sock_ctrl</u> as default value.

              A session opened in this way is closed using function close.

       <b>pwd(Pid)</b> <b>-&gt;</b> <b>{ok,</b> <b>Dir}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Reason = restriction_reason() | common_reason()

              Returns the current working directory at the remote server.

       <b>recv(Pid,</b> <b>RemoteFile)</b> <b>-&gt;</b>
       <b>recv(Pid,</b> <b>RemoteFile,</b> <b>LocalFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 RemoteFile = LocalFile = string()
                 Reason = restriction_reason() | common_reason() | file_write_error_reason()
                 file_write_error_reason() = see file:write/2

              Transfers the file <u>RemoteFile</u> from the remote server to the file system of the  local  client.  If
              <u>LocalFile</u> is specified, the local file will be <u>LocalFile</u>, otherwise <u>RemoteFile</u>.

              If   the   file   write   fails  (for  example,  <u>enospc</u>),  the  command  is  aborted  and  <u>{error,</u>
              <u>file_write_error_reason()}</u> is returned. However, the file is <u>not</u> removed.

       <b>recv_bin(Pid,</b> <b>RemoteFile)</b> <b>-&gt;</b> <b>{ok,</b> <b>Bin}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Bin = binary()
                 RemoteFile = string()
                 Reason = restriction_reason() | common_reason()

              Transfers the file <u>RemoteFile</u> from the remote server and receives it as a binary.

       <b>recv_chunk_start(Pid,</b> <b>RemoteFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 RemoteFile = string()
                 Reason = restriction_reason() | common_reason()

              Starts transfer of the file <u>RemoteFile</u> from the remote server.

       <b>recv_chunk(Pid)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Bin}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Bin = binary()
                 Reason = restriction_reason() | common_reason()

              Receives a chunk of the remote file (<u>RemoteFile</u> of <u>recv_chunk_start</u>). The return values  have  the
              following meaning:

                * <u>ok</u> = the transfer is complete.

                * <u>{ok,</u> <u>Bin}</u> = just another chunk of the file.

                * <u>{error,</u> <u>Reason}</u> = transfer failed.

       <b>rename(Pid,</b> <b>Old,</b> <b>New)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 CurrFile = NewFile = string()
                 Reason = restriction_reason() | common_reason()

              Renames <u>Old</u> to <u>New</u> at the remote server.

       <b>rmdir(Pid,</b> <b>Dir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Dir = string()
                 Reason = restriction_reason() | common_reason()

              Removes directory <u>Dir</u> at the remote server.

       <b>send(Pid,</b> <b>LocalFile)</b> <b>-&gt;</b>
       <b>send(Pid,</b> <b>LocalFile,</b> <b>RemoteFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 LocalFile = RemoteFile = string()
                 Reason = restriction_reason() | common_reason() | shortage_reason()

              Transfers  the  file  <u>LocalFile</u>  to the remote server. If <u>RemoteFile</u> is specified, the name of the
              remote file is set to <u>RemoteFile</u>, otherwise to <u>LocalFile</u>.

       <b>send_bin(Pid,</b> <b>Bin,</b> <b>RemoteFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Bin = binary()
                 RemoteFile = string()
                 Reason = restriction_reason() | common_reason() | shortage_reason()

              Transfers the binary <u>Bin</u> into the file <u>RemoteFile</u> at the remote server.

       <b>send_chunk(Pid,</b> <b>Bin)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Bin = binary()
                 Reason = echunk | restriction_reason() | common_reason()

              Transfers the chunk <u>Bin</u> to the remote server, which writes it into the file specified in the  call
              to <u>send_chunk_start/2</u>.

              For  some  errors, for example, file system full, it is necessary to to call <u>send_chunk_end</u> to get
              the proper reason.

       <b>send_chunk_start(Pid,</b> <b>File)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 File = string()
                 Reason = restriction_reason() | common_reason()

              Starts transfer of chunks into the file <u>File</u> at the remote server.

       <b>send_chunk_end(Pid)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Reason = restriction_reason() | common_reason() | shortage_reason()

              Stops transfer of chunks to the remote server. The file at the remote  server,  specified  in  the
              call to <u>send_chunk_start/2</u> is closed by the server.

       <b>start_service(ServiceConfig)</b> <b>-&gt;</b> <b>{ok,</b> <b>Pid}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 ServiceConfig = [{Option, Value}]
                 Option = property()
                 Value = term()

              Dynamically starts an <u>FTP</u> session after the <u>ftp</u> application has been started.

          <b>Note:</b>
              As  long  as  the  <u>ftp</u> application is operational, the FTP sessions are supervised and can be soft
              code upgraded.

       <b>stop_service(Reference)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Reference = pid() | term() - service-specified reference
                 Reason = term()

              Stops a started FTP session.

       <b>type(Pid,</b> <b>Type)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Type = ascii | binary
                 Reason = etype | restriction_reason() | common_reason()

              Sets the file transfer type to <u>ascii</u> or <u>binary</u>.  When  an  FTP  session  is  opened,  the  default
              transfer type of the server is used, most often <u>ascii</u>, which is default according to RFC 959.

       <b>user(Pid,</b> <b>User,</b> <b>Password)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 User = Password = string()
                 Reason = euser | common_reason()

              Performs login of <u>User</u> with <u>Password</u>.

       <b>user(Pid,</b> <b>User,</b> <b>Password,</b> <b>Account)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 User = Password = string()
                 Reason = euser | common_reason()

              Performs login of <u>User</u> with <u>Password</u> to the account specified by <u>Account</u>.

       <b>quote(Pid,</b> <b>Command)</b> <b>-&gt;</b> <b>[FTPLine]</b>

              Types:

                 Pid = pid()
                 Command = string()
                 FTPLine = string()

          <b>Note:</b>
              The  telnet  end of line characters, from the FTP protocol definition, CRLF, for example, "\\r\\n"
              has been removed.

              Sends an arbitrary FTP command and returns verbatim a list of the  lines  sent  back  by  the  FTP
              server.  This  function  is intended to give application accesses to FTP commands that are server-
              specific or that cannot be provided by this FTP client.

          <b>Note:</b>
              FTP commands requiring a data connection cannot be successfully issued with this function.

</pre><h4><b>ERRORS</b></h4><pre>
       The possible error reasons and the corresponding diagnostic strings  returned  by  <u>formaterror/1</u>  are  as
       follows:

         <u>echunk</u>:
           Synchronization error during chunk sending according to one of the following:

           * A call is made to <u>send_chunk/2</u> or <u>send_chunk_end/1</u> before a call to <u>send_chunk_start/2</u>.

           * A  call  has been made to another transfer function during chunk sending, that is, before a call to
             <u>send_chunk_end/1</u>.

         <u>eclosed</u>:
           The session is closed.

         <u>econn</u>:
           Connection to the remote server is prematurely closed.

         <u>ehost</u>:
           Host is not found, FTP server is not found, or connection is rejected by FTP server.

         <u>elogin</u>:
           User is not logged in.

         <u>enotbinary</u>:
           Term is not a binary.

         <u>epath</u>:
           No such file or directory, or directory already exists, or permission denied.

         <u>etype</u>:
           No such type.

         <u>euser</u>:
           Invalid username or password.

         <u>etnospc</u>:
           Insufficient storage space in system [452].

         <u>epnospc</u>:
           Exceeded storage allocation (for current directory or dataset) [552].

         <u>efnamena</u>:
           Filename not allowed [553].

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3erl/file.3erl.html">file</a>(3erl) <a href="../man3erl/filename.3erl.html">filename</a>(3erl) and J. Postel and J. Reynolds: File Transfer Protocol (RFC 959).

Ericsson AB                                          ftp 1.1                                           <u><a href="../man3erl/ftp.3erl.html">ftp</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>