<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>inet_res - A rudimentary DNS client.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       inet_res - A rudimentary DNS client.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module performs DNS name resolving to recursive name servers.

       See  also  ERTS  User's  Guide:  Inet Configuration for more information about how to configure an Erlang
       runtime system for IP communication, and how to enable this DNS client by  defining  <u>'dns'</u>  as  a  lookup
       method. The DNS client then acts as a backend for the resolving functions in <u>inet</u>.

       This DNS client can resolve DNS records even if it is not used for normal name resolving in the node.

       This  is  not  a  full-fledged  resolver,  only a DNS client that relies on asking trusted recursive name
       servers.

</pre><h4><b>NAME</b> <b>RESOLVING</b></h4><pre>
       UDP queries are used unless resolver option <u>usevc</u> is <u>true</u>, which forces TCP queries. If the query is  too
       large for UDP, TCP is used instead. For regular DNS queries, 512 bytes is the size limit.

       When  EDNS  is  enabled  (resolver  option <u>edns</u> is set to the EDNS version (that is, <u>0</u> instead of <u>false</u>),
       resolver option <u>udp_payload_size</u> sets  the  limit.  If  a  name  server  replies  with  the  TC  bit  set
       (truncation),  indicating  that  the answer is incomplete, the query is retried to that name server using
       TCP. Resolver option <u>udp_payload_size</u> also sets the advertised size for the maximum allowed  reply  size,
       if  EDNS  is enabled, otherwise the name server uses the limit 512 bytes. If the reply is larger, it gets
       truncated, forcing a TCP requery.

       For UDP queries, resolver options <u>timeout</u> and <u>retry</u> control  retransmission.  Each  name  server  in  the
       <u>nameservers</u>  list  is  tried  with  a  time-out  of <u>timeout</u>/<u>retry</u>. Then all name servers are tried again,
       doubling the time-out, for a total of <u>retry</u> times.

       But  before  all  name  servers  are   tried   again,   there   is   a   (user   configurable)   timeout,
       <u>servfail_retry_timeout</u>.  The  point  of  this  is  to  prevent  the new query to be handled by a server's
       servfail cache (a client that is to eager will actually only get what is in the servfail cache). If there
       is too little time left of the resolver call's timeout to do a retry, the resolver call may return before
       the call's timeout has expired.

       For queries not using the <u>search</u> list, if the query to all <u>nameservers</u> results in <u>{error,nxdomain}</u> or  an
       empty answer, the same query is tried for <u>alt_nameservers</u>.

</pre><h4><b>RESOLVER</b> <b>TYPES</b></h4><pre>
       The following data types concern the resolver:

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>res_option()</b> =
           {alt_nameservers, [nameserver()]} |
           {edns, 0 | false} |
           {inet6, boolean()} |
           {nameservers, [nameserver()]} |
           {recurse, boolean()} |
           {retry, integer()} |
           {timeout, integer()} |
           {udp_payload_size, integer()} |
           {usevc, boolean()} |
           {nxdomain_reply, boolean()}

       <b>nameserver()</b> = {inet:ip_address(), Port :: 1..65535}

       <b>res_error()</b> =
           formerr | qfmterror | servfail | nxdomain | notimp | refused |
           badvers | timeout

</pre><h4><b>DNS</b> <b>TYPES</b></h4><pre>
       The following data types concern the DNS client:

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>dns_name()</b> = string()

              A string with no adjacent dots.

       <b>rr_type()</b> =
           a | aaaa | caa | cname | gid | hinfo | ns | mb | md | mg |
           mf | minfo | mx | naptr | null | ptr | soa | spf | srv | txt |
           uid | uinfo | unspec | uri | wks

       <b>dns_class()</b> = in | chaos | hs | any

       <b>dns_msg()</b> = term()

              This  is  the  start  of  a  hiearchy  of  opaque data structures that can be examined with access
              functions in <u>inet_dns</u>, which return lists of <u>{Field,Value}</u> tuples.  The  arity  2  functions  only
              return the value for a specified field.

              dns_msg() = DnsMsg
                  inet_dns:msg(DnsMsg) -&gt;
                      [ {header, dns_header()}
                      | {qdlist, dns_query()}
                      | {anlist, dns_rr()}
                      | {nslist, dns_rr()}
                      | {arlist, dns_rr()} ]
                  inet_dns:msg(DnsMsg, header) -&gt; dns_header() % for example
                  inet_dns:msg(DnsMsg, Field) -&gt; Value

              dns_header() = DnsHeader
                  inet_dns:header(DnsHeader) -&gt;
                      [ {id, integer()}
                      | {qr, boolean()}
                      | {opcode, query | iquery | status | integer()}
                      | {aa, boolean()}
                      | {tc, boolean()}
                      | {rd, boolean()}
                      | {ra, boolean()}
                      | {pr, boolean()}
                      | {rcode, integer(0..16)} ]
                  inet_dns:header(DnsHeader, Field) -&gt; Value

              query_type() = axfr | mailb | maila | any | rr_type()

              dns_query() = DnsQuery
                  inet_dns:dns_query(DnsQuery) -&gt;
                      [ {domain, dns_name()}
                      | {type, query_type()}
                      | {class, dns_class()} ]
                  inet_dns:dns_query(DnsQuery, Field) -&gt; Value

              dns_rr() = DnsRr
                  inet_dns:rr(DnsRr) -&gt; DnsRrFields | DnsRrOptFields
                  DnsRrFields = [ {domain, dns_name()}
                                | {type, rr_type()}
                                | {class, dns_class()}
                                | {ttl, integer()}
                                | {data, dns_data()} ]
                  DnsRrOptFields = [ {domain, dns_name()}
                                   | {type, opt}
                                   | {udp_payload_size, integer()}
                                   | {ext_rcode, integer()}
                                   | {version, integer()}
                                   | {z, integer()}
                                   | {data, dns_data()} ]
                  inet_dns:rr(DnsRr, Field) -&gt; Value

              There is an information function for the types above:

              inet_dns:record_type(dns_msg()) -&gt; msg;
              inet_dns:record_type(dns_header()) -&gt; header;
              inet_dns:record_type(dns_query()) -&gt; dns_query;
              inet_dns:record_type(dns_rr()) -&gt; rr;
              inet_dns:record_type(_) -&gt; undefined.

              So,   <u>inet_dns:(inet_dns:record_type(X))(X)</u>   converts   any  of  these  data  structures  into  a
              <u>{Field,Value}</u> list.

       <b>dns_data()</b> =
           dns_name() |
           inet:ip4_address() |
           inet:ip6_address() |
           {MName :: dns_name(),
            RName :: dns_name(),
            Serial :: integer(),
            Refresh :: integer(),
            Retry :: integer(),
            Expiry :: integer(),
            Minimum :: integer()} |
           {inet:ip4_address(), Proto :: integer(), BitMap :: binary()} |
           {CpuString :: string(), OsString :: string()} |
           {RM :: dns_name(), EM :: dns_name()} |
           {Prio :: integer(), dns_name()} |
           {Prio :: integer(),
            Weight :: integer(),
            Port :: integer(),
            dns_name()} |
           {Order :: integer(),
            Preference :: integer(),
            Flags :: string(),
            Services :: string(),
            Regexp :: string(),
            dns_name()} |
           [string()] |
           binary()

              <u>Regexp</u> is a string with characters encoded in the UTF-8 coding standard.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>getbyname(Name,</b> <b>Type)</b> <b>-&gt;</b> <b>{ok,</b> <b>Hostent}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>getbyname(Name,</b> <b>Type,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>Hostent}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = dns_name()
                 Type = rr_type()
                 Timeout = timeout()
                 Hostent = inet:hostent()
                 Reason = inet:posix() | res_error()

              Resolves a DNS record of the specified type for the specified  host,  of  class  <u>in</u>.  Returns,  on
              success, a <u>hostent()</u> record with <u>dns_data()</u> elements in the address list field.

              This  function  uses resolver option <u>search</u> that is a list of domain names. If the name to resolve
              contains no dots, it is prepended to each domain name in the search list, and they  are  tried  in
              order.  If  the  name  contains dots, it is first tried as an absolute name and if that fails, the
              search list is used. If the name has a trailing dot, it is supposed to be an absolute name and the
              search list is not used.

       <b>gethostbyaddr(Address)</b> <b>-&gt;</b> <b>{ok,</b> <b>Hostent}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>gethostbyaddr(Address,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>Hostent}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Address = inet:ip_address()
                 Timeout = timeout()
                 Hostent = inet:hostent()
                 Reason = inet:posix() | res_error()

              Backend functions used by <u>inet:gethostbyaddr/1</u>.

       <b>gethostbyname(Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>Hostent}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>gethostbyname(Name,</b> <b>Family)</b> <b>-&gt;</b> <b>{ok,</b> <b>Hostent}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>gethostbyname(Name,</b> <b>Family,</b> <b>Timeout)</b> <b>-&gt;</b>
                        {ok, Hostent} | {error, Reason}

              Types:

                 Name = dns_name()
                 Hostent = inet:hostent()
                 Timeout = timeout()
                 Family = inet:address_family()
                 Reason = inet:posix() | res_error()

              Backend functions used by <u>inet:gethostbyname/1,2</u>.

              This function uses resolver option <u>search</u> just like <u>getbyname/2,3</u>.

              If resolver option <u>inet6</u> is <u>true</u>, an IPv6 address is looked up.

       <b>lookup(Name,</b> <b>Class,</b> <b>Type)</b> <b>-&gt;</b> <b>[dns_data()]</b>

       <b>lookup(Name,</b> <b>Class,</b> <b>Type,</b> <b>Opts)</b> <b>-&gt;</b> <b>[dns_data()]</b>

       <b>lookup(Name,</b> <b>Class,</b> <b>Type,</b> <b>Opts,</b> <b>Timeout)</b> <b>-&gt;</b> <b>[dns_data()]</b>

              Types:

                 Name = dns_name() | inet:ip_address()
                 Class = dns_class()
                 Type = rr_type()
                 Opts = [res_option() | verbose]
                 Timeout = timeout()

              Resolves the DNS data for the record of the specified type and class for the  specified  name.  On
              success,  filters  out  the  answer records with the correct <u>Class</u> and <u>Type</u>, and returns a list of
              their data fields. So, a lookup for type <u>any</u> gives an empty answer, as  the  answer  records  have
              specific types that are not <u>any</u>. An empty answer or a failed lookup returns an empty list.

              Calls  <u>resolve/*</u>  with  the  same arguments and filters the result, so <u>Opts</u> is described for those
              functions.

       <b>resolve(Name,</b> <b>Class,</b> <b>Type)</b> <b>-&gt;</b> <b>{ok,</b> <b>dns_msg()}</b> <b>|</b> <b>Error</b>

       <b>resolve(Name,</b> <b>Class,</b> <b>Type,</b> <b>Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>dns_msg()}</b> <b>|</b> <b>Error</b>

       <b>resolve(Name,</b> <b>Class,</b> <b>Type,</b> <b>Opts,</b> <b>Timeout)</b> <b>-&gt;</b>
                  {ok, dns_msg()} | Error

              Types:

                 Name = dns_name() | inet:ip_address()
                 Class = dns_class()
                 Type = rr_type()
                 Opts = [Opt]
                 Opt = res_option() | verbose | atom()
                 Timeout = timeout()
                 Error = {error, Reason} | {error, {Reason, dns_msg()}}
                 Reason = inet:posix() | res_error()

              Resolves a DNS record of the specified type  and  class  for  the  specified  name.  The  returned
              <u>dns_msg()</u> can be examined using access functions in <u>inet_db</u>, as described in section in DNS Types.

              If  <u>Name</u>  is  an  <u>ip_address()</u>,  the domain name to query for is generated as the standard reverse
              <u>".IN-ADDR.ARPA."</u> name for an IPv4 address, or the <u>".IP6.ARPA."</u> name for an IPv6 address.  In  this
              case, you most probably want to use <u>Class</u> <u>=</u> <u>in</u> and <u>Type</u> <u>=</u> <u>ptr</u>, but it is not done automatically.

              <u>Opts</u>  overrides  the  corresponding  resolver  options.  If option <u>nameservers</u> is specified, it is
              assumed that it is the complete list of name serves, so resolver option <u>alt_nameserves</u> is ignored.
              However, if option <u>alt_nameserves</u> is also specified to this function, it is used.

              Option <u>verbose</u> (or rather <u>{verbose,true}</u>)  causes  diagnostics  printout  through  <u>io:format/2</u>  of
              queries, replies retransmissions, and so on, similar to from utilities, such as <u>dig</u> and <u>nslookup</u>.

              Option <u>nxdomain_reply</u> (or rather <u>{nxdomain_reply,true}</u>) causes nxdomain errors from DNS servers to
              be  returned  as  <u>{error,</u>  <u>{nxdomain,</u> <u>dns_msg()}}</u>. <u>dns_msg()</u> contains the additional sections that
              where included by the answering server. This is mainly useful to inspect the SOA record to get the
              TTL for negative caching.

              If <u>Opt</u> is any atom, it is interpreted as <u>{Opt,true}</u> unless  the  atom  string  starts  with  <u>"no"</u>,
              making the interpretation <u>{Opt,false}</u>. For example, <u>usevc</u> is an alias for <u>{usevc,true}</u> and <u>nousevc</u>
              is an alias for <u>{usevc,false}</u>.

              Option <u>inet6</u> has no effect on this function. You probably want to use <u>Type</u> <u>=</u> <u>a</u> <u>|</u> <u>aaaa</u> instead.

</pre><h4><b>EXAMPLE</b></h4><pre>
       This  access  functions  example  shows  how <u>lookup/3</u> can be implemented using <u>resolve/3</u> from outside the
       module:

       example_lookup(Name, Class, Type) -&gt;
           case inet_res:resolve(Name, Class, Type) of
               {ok,Msg} -&gt;
                   [inet_dns:rr(RR, data)
                    || RR &lt;- inet_dns:msg(Msg, anlist),
                        inet_dns:rr(RR, type) =:= Type,
                        inet_dns:rr(RR, class) =:= Class];
               {error,_} -&gt;
                   []
            end.

</pre><h4><b>LEGACY</b> <b>FUNCTIONS</b></h4><pre>
       These are deprecated because the annoying double meaning  of  the  name  servers/time-out  argument,  and
       because they have no decent place for a resolver options list.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>nslookup(Name,</b> <b>Class,</b> <b>Type)</b> <b>-&gt;</b> <b>{ok,</b> <b>dns_msg()}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>nslookup(Name,</b> <b>Class,</b> <b>Type,</b> <b>Timeout)</b> <b>-&gt;</b>
                   {ok, dns_msg()} | {error, Reason}

       <b>nslookup(Name,</b> <b>Class,</b> <b>Type,</b> <b>Nameservers)</b> <b>-&gt;</b>
                   {ok, dns_msg()} | {error, Reason}

              Types:

                 Name = dns_name() | inet:ip_address()
                 Class = dns_class()
                 Type = rr_type()
                 Timeout = timeout()
                 Nameservers = [nameserver()]
                 Reason = inet:posix() | res_error()

              Resolves a DNS record of the specified type and class for the specified name.

       <b>nnslookup(Name,</b> <b>Class,</b> <b>Type,</b> <b>Nameservers)</b> <b>-&gt;</b>
                    {ok, dns_msg()} | {error, Reason}

       <b>nnslookup(Name,</b> <b>Class,</b> <b>Type,</b> <b>Nameservers,</b> <b>Timeout)</b> <b>-&gt;</b>
                    {ok, dns_msg()} | {error, Reason}

              Types:

                 Name = dns_name() | inet:ip_address()
                 Class = dns_class()
                 Type = rr_type()
                 Timeout = timeout()
                 Nameservers = [nameserver()]
                 Reason = inet:posix()

              Resolves a DNS record of the specified type and class for the specified name.

Ericsson AB                                        kernel 8.2                                     <u><a href="../man3erl/inet_res.3erl.html">inet_res</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>