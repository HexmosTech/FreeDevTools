<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ssh_sftp - SFTP client.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ssh_sftp - SFTP client.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  implements  an  SSH  FTP  (SFTP)  client. SFTP is a secure, encrypted file transfer service
       available for SSH.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>sftp_option()</b> =
           {timeout, timeout()} |
           {sftp_vsn, integer() &gt;= 1} |
           {window_size, integer() &gt;= 1} |
           {packet_size, integer() &gt;= 1}

   <b>Error</b> <b>cause</b>
       <b>reason()</b> = atom() | string() | tuple()

              A description of the reason why an operation failed.

              The <u>atom()</u> value is formed from the sftp error codes in the protocol-level responses as defined in
              draft-ietf-secsh-filexfer-13 section 9.1. The codes are named as <u>SSH_FX_*</u>  which  are  transformed
              into  lowercase  of the star-part. E.g. the error code <u>SSH_FX_NO_SUCH_FILE</u> will cause the <u>reason()</u>
              to be <u>no_such_file</u>.

              The <u>string()</u> reason is the error information from the server in case of an  exit-signal.  If  that
              information is empty, the reason is the exit signal name.

              The <u>tuple()</u> reason are other errors like for example <u>{exit_status,1}</u>.

   <b>Crypto</b> <b>operations</b> <b>for</b> <b>open_tar</b>
       <b>tar_crypto_spec()</b> = encrypt_spec() | decrypt_spec()

       <b>encrypt_spec()</b> = {init_fun(), crypto_fun(), final_fun()}

       <b>decrypt_spec()</b> = {init_fun(), crypto_fun()}

              Specifies the encryption or decryption applied to tar files when using open_tar/3 or open_tar/4.

              The  encryption  or  decryption  is  applied to the generated stream of bytes prior to sending the
              resulting stream to the SFTP server.

              For code examples see Section Example with encryption in the ssh Users Guide.

       <b>init_fun()</b> =
           fun(() -&gt; {ok, crypto_state()}) |
           fun(() -&gt; {ok, crypto_state(), chunk_size()})

       <b>chunk_size()</b> = undefined | integer() &gt;= 1

       <b>crypto_state()</b> = any()

              The <u>init_fun()</u> in the tar_crypto_spec is applied once prior to any  other  <u>crypto</u>  operation.  The
              intention  is  that  this  function  initiates the encryption or decryption for example by calling
              crypto:crypto_init/4 or similar. The <u>crypto_state()</u> is the state such a function may return.

              If the selected cipher needs to have the input data partioned into blocks of a certain  size,  the
              <u>init_fun()</u>  should  return  the second form of return value with the <u>chunk_size()</u> set to the block
              size. If the <u>chunk_size()</u> is <u>undefined</u>, the size of the <u>PlainBin</u>s varies, because this is intended
              for stream crypto, whereas a fixed <u>chunk_size()</u> is intended for block crypto. A  <u>chunk_size()</u>  can
              be changed in the return from the <u>crypto_fun()</u>. The value can be changed between <u>pos_integer()</u> and
              <u>undefined</u>.

       <b>crypto_fun()</b> =
           fun((TextIn :: binary(), crypto_state()) -&gt; crypto_result())

       <b>crypto_result()</b> =
           {ok, TextOut :: binary(), crypto_state()} |
           {ok, TextOut :: binary(), crypto_state(), chunk_size()}

              The  initial  <u>crypto_state()</u>  returned from the init_fun() is folded into repeated applications of
              the <u>crypto_fun()</u> in the tar_crypto_spec. The binary returned from that fun is sent to  the  remote
              SFTP server and the new <u>crypto_state()</u> is used in the next call of the <u>crypto_fun()</u>.

              If the <u>crypto_fun()</u> reurns a <u>chunk_size()</u>, that value is as block size for further blocks in calls
              to <u>crypto_fun()</u>.

       <b>final_fun()</b> =
           fun((FinalTextIn :: binary(), crypto_state()) -&gt;
                   {ok, FinalTextOut :: binary()})

              If  doing encryption, the <u>final_fun()</u> in the tar_crypto_spec is applied to the last piece of data.
              The <u>final_fun()</u> is responsible for padding (if needed) and encryption of that last piece.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>apread(ChannelPid,</b> <b>Handle,</b> <b>Position,</b> <b>Len)</b> <b>-&gt;</b> <b>{async,</b> <b>N}</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Handle = term()
                 Position = Len = integer()
                 Error = {error, reason()}
                 N = term()

              The <u>apread/4</u> function reads from a  specified  position,  combining  the  <u>position/3</u>  and  <u>aread/3</u>
              functions.

       <b>apwrite(ChannelPid,</b> <b>Handle,</b> <b>Position,</b> <b>Data)</b> <b>-&gt;</b> <b>{async,</b> <b>N}</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Handle = term()
                 Position = integer()
                 Data = binary()
                 Error = {error, reason()}
                 N = term()

              The  <u>apwrite/4</u>  function  writes  to  a  specified position, combining the <u>position/3</u> and <u>awrite/3</u>
              functions.

       <b>aread(ChannelPid,</b> <b>Handle,</b> <b>Len)</b> <b>-&gt;</b> <b>{async,</b> <b>N}</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Handle = term()
                 Len = integer()
                 Error = {error, reason()}
                 N = term()

              Reads from an open file, without waiting for the result. If the  handle  is  valid,  the  function
              returns  <u>{async,</u>  <u>N}</u>, where <u>N</u> is a term guaranteed to be unique between calls of <u>aread</u>. The actual
              data is sent as a message to the calling process. This  message  has  the  form  <u>{async_reply,</u>  <u>N,</u>
              <u>Result}</u>, where <u>Result</u> is the result from the read, either <u>{ok,</u> <u>Data}</u>, <u>eof</u>, or <u>{error,</u> <u>reason()}</u>.

       <b>awrite(ChannelPid,</b> <b>Handle,</b> <b>Data)</b> <b>-&gt;</b> <b>{async,</b> <b>N}</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Handle = term()
                 Data = binary()
                 Error = {error, reason()}
                 N = term()

              Writes  to  an  open  file,  without  waiting for the result. If the handle is valid, the function
              returns <u>{async,</u> <u>N}</u>, where <u>N</u> is a term guaranteed to be unique between calls of <u>awrite</u>. The  result
              of  the  <u>write</u>  operation  is  sent as a message to the calling process. This message has the form
              <u>{async_reply,</u> <u>N,</u> <u>Result}</u>, where <u>Result</u> is the  result  from  the  write,  either  <u>ok</u>,  or  <u>{error,</u>
              <u>reason()}</u>.

       <b>close(ChannelPid,</b> <b>Handle)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

       <b>close(ChannelPid,</b> <b>Handle,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Handle = term()
                 Timeout = timeout()
                 Error = {error, reason()}

              Closes a handle to an open file or directory on the server.

       <b>delete(ChannelPid,</b> <b>Name)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

       <b>delete(ChannelPid,</b> <b>Name,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Name = string()
                 Timeout = timeout()
                 Error = {error, reason()}

              Deletes the file specified by <u>Name</u>.

       <b>del_dir(ChannelPid,</b> <b>Name)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

       <b>del_dir(ChannelPid,</b> <b>Name,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Name = string()
                 Timeout = timeout()
                 Error = {error, reason()}

              Deletes  a  directory specified by <u>Name</u>. The directory must be empty before it can be successfully
              deleted.

       <b>list_dir(ChannelPid,</b> <b>Path)</b> <b>-&gt;</b> <b>{ok,</b> <b>FileNames}</b> <b>|</b> <b>Error</b>

       <b>list_dir(ChannelPid,</b> <b>Path,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>FileNames}</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Path = string()
                 Timeout = timeout()
                 FileNames = [FileName]
                 FileName = string()
                 Error = {error, reason()}

              Lists the given directory on the server, returning the filenames as a list of strings.

       <b>make_dir(ChannelPid,</b> <b>Name)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

       <b>make_dir(ChannelPid,</b> <b>Name,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Name = string()
                 Timeout = timeout()
                 Error = {error, reason()}

              Creates a directory specified by <u>Name</u>. <u>Name</u> must be a full path to a new directory. The  directory
              can only be created in an existing directory.

       <b>make_symlink(ChannelPid,</b> <b>Name,</b> <b>Target)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

       <b>make_symlink(ChannelPid,</b> <b>Name,</b> <b>Target,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Name = Target = string()
                 Timeout = timeout()
                 Error = {error, reason()}

              Creates a symbolic link pointing to <u>Target</u> with the name <u>Name</u>.

       <b>open(ChannelPid,</b> <b>Name,</b> <b>Mode)</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>Error</b>

       <b>open(ChannelPid,</b> <b>Name,</b> <b>Mode,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Name = string()
                 Mode = [read | write | append | binary | raw]
                 Timeout = timeout()
                 Handle = term()
                 Error = {error, reason()}

              Opens a file on the server and returns a handle, which can be used for reading or writing.

       <b>opendir(ChannelPid,</b> <b>Path)</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>Error</b>

       <b>opendir(ChannelPid,</b> <b>Path,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Path = string()
                 Timeout = timeout()
                 Handle = term()
                 Error = {error, reason()}

              Opens  a  handle  to  a  directory  on  the  server.  The handle can be used for reading directory
              contents.

       <b>open_tar(ChannelPid,</b> <b>Path,</b> <b>Mode)</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>Error</b>

       <b>open_tar(ChannelPid,</b> <b>Path,</b> <b>Mode,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Path = string()
                 Mode = [read | write | {crypto, tar_crypto_spec()}]
                 Timeout = timeout()
                 Handle = term()
                 Error = {error, reason()}

              Opens a handle to a tar file on the server, associated with <u>ChannelPid</u>. The handle can be used for
              remote tar creation and extraction. The actual writing  and  reading  is  performed  by  calls  to
              erl_tar:add/3,4  and  erl_tar:extract/2.  Note:  The erl_tar:init/3 function should not be called,
              that one is called by this open_tar function.

              For code examples see Section SFTP Client with TAR Compression in the ssh Users Guide.

              The <u>crypto</u> mode option is explained in the data types section above,  see  Crypto  operations  for
              open_tar.  Encryption  is  assumed if the <u>Mode</u> contains <u>write</u>, and decryption if the <u>Mode</u> contains
              <u>read</u>.

       <b>position(ChannelPid,</b> <b>Handle,</b> <b>Location)</b> <b>-&gt;</b>
                   {ok, NewPosition} | Error

       <b>position(ChannelPid,</b> <b>Handle,</b> <b>Location,</b> <b>Timeout)</b> <b>-&gt;</b>
                   {ok, NewPosition} | Error

              Types:

                 ChannelPid = pid()
                 Handle = term()
                 Location =
                     Offset |
                     {bof, Offset} |
                     {cur, Offset} |
                     {eof, Offset} |
                     bof | cur | eof
                 Timeout = timeout()
                 Offset = NewPosition = integer()
                 Error = {error, reason()}

              Sets the file position of the file referenced by <u>Handle</u>. Returns <u>{ok,</u> <u>NewPosition}</u> (as an absolute
              offset) if successful, otherwise <u>{error,</u> <u>reason()}</u>. <u>Location</u> is one of the following:

                <u>Offset</u>:
                  The same as <u>{bof,</u> <u>Offset}</u>.

                <u>{bof,</u> <u>Offset}</u>:
                  Absolute offset.

                <u>{cur,</u> <u>Offset}</u>:
                  Offset from the current position.

                <u>{eof,</u> <u>Offset}</u>:
                  Offset from the end of file.

                <u>bof</u> <u>|</u> <u>cur</u> <u>|</u> <u>eof</u>:
                  The same as eariler with <u>Offset</u> 0, that is, <u>{bof,</u> <u>0}</u> <u>|</u> <u>{cur,</u> <u>0}</u> <u>|</u> <u>{eof,</u> <u>0}</u>.

       <b>pread(ChannelPid,</b> <b>Handle,</b> <b>Position,</b> <b>Len)</b> <b>-&gt;</b>
                {ok, Data} | eof | Error

       <b>pread(ChannelPid,</b> <b>Handle,</b> <b>Position,</b> <b>Len,</b> <b>Timeout)</b> <b>-&gt;</b>
                {ok, Data} | eof | Error

              Types:

                 ChannelPid = pid()
                 Handle = term()
                 Position = Len = integer()
                 Timeout = timeout()
                 Data = string() | binary()
                 Error = {error, reason()}

              The <u>pread/3,4</u> function reads from a specified position,  combining  the  <u>position/3</u>  and  <u>read/3,4</u>
              functions.

       <b>pwrite(ChannelPid,</b> <b>Handle,</b> <b>Position,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

       <b>pwrite(ChannelPid,</b> <b>Handle,</b> <b>Position,</b> <b>Data,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Handle = term()
                 Position = integer()
                 Data = iolist()
                 Timeout = timeout()
                 Error = {error, reason()}

              The  <u>pwrite/3,4</u>  function  writes  to a specified position, combining the <u>position/3</u> and <u>write/3,4</u>
              functions.

       <b>read(ChannelPid,</b> <b>Handle,</b> <b>Len)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>eof</b> <b>|</b> <b>Error</b>

       <b>read(ChannelPid,</b> <b>Handle,</b> <b>Len,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>eof</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Handle = term()
                 Len = integer()
                 Timeout = timeout()
                 Data = string() | binary()
                 Error = {error, reason()}

              Reads <u>Len</u> bytes from the file referenced by <u>Handle</u>. Returns <u>{ok,</u> <u>Data}</u>, <u>eof</u>, or <u>{error,</u> <u>reason()}</u>.
              If the file is opened with <u>binary</u>, <u>Data</u> is a binary, otherwise it is a string.

              If the file is read past <u>eof</u>, only the remaining bytes are read and  returned.  If  no  bytes  are
              read, <u>eof</u> is returned.

       <b>read_file(ChannelPid,</b> <b>File)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>Error</b>

       <b>read_file(ChannelPid,</b> <b>File,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 File = string()
                 Data = binary()
                 Timeout = timeout()
                 Error = {error, reason()}

              Reads a file from the server, and returns the data in a binary.

       <b>read_file_info(ChannelPid,</b> <b>Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>FileInfo}</b> <b>|</b> <b>Error</b>

       <b>read_file_info(ChannelPid,</b> <b>Name,</b> <b>Timeout)</b> <b>-&gt;</b>
                         {ok, FileInfo} | Error

              Types:

                 ChannelPid = pid()
                 Name = string()
                 Timeout = timeout()
                 FileInfo = file:file_info()
                 Error = {error, reason()}

              Returns  a  <u>file_info</u>  record  from  the  file  system  object  specified  by  <u>Name</u> or <u>Handle</u>. See
              file:read_file_info/2 for information about the record.

              Depending on the underlying OS:es links might be followed and info on the  final  file,  directory
              etc is returned. See read_link_info/2 on how to get information on links instead.

       <b>read_link(ChannelPid,</b> <b>Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>Target}</b> <b>|</b> <b>Error</b>

       <b>read_link(ChannelPid,</b> <b>Name,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>Target}</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Name = Target = string()
                 Timeout = timeout()
                 Error = {error, reason()}

              Reads the link target from the symbolic link specified by <u>name</u>.

       <b>read_link_info(ChannelPid,</b> <b>Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>FileInfo}</b> <b>|</b> <b>Error</b>

       <b>read_link_info(ChannelPid,</b> <b>Name,</b> <b>Timeout)</b> <b>-&gt;</b>
                         {ok, FileInfo} | Error

              Types:

                 ChannelPid = pid()
                 Name = string()
                 FileInfo = file:file_info()
                 Timeout = timeout()
                 Error = {error, reason()}

              Returns   a   <u>file_info</u>   record  from  the  symbolic  link  specified  by  <u>Name</u>  or  <u>Handle</u>.  See
              file:read_link_info/2 for information about the record.

       <b>rename(ChannelPid,</b> <b>OldName,</b> <b>NewName)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

       <b>rename(ChannelPid,</b> <b>OldName,</b> <b>NewName,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 OldName = NewName = string()
                 Timeout = timeout()
                 Error = {error, reason()}

              Renames a file named <u>OldName</u> and gives it the name <u>NewName</u>.

       <b>start_channel(ConnectionRef)</b> <b>-&gt;</b>
       <b>start_channel(ConnectionRef,</b> <b>SftpOptions)</b> <b>-&gt;</b> <b>{ok,</b> <b>ChannelPid}</b> <b>|</b> <b>Error</b>
       <b>start_channel(Host)</b> <b>-&gt;</b>
       <b>start_channel(Host,</b> <b>Options)</b> <b>-&gt;</b>
       <b>start_channel(Host,</b> <b>Port,</b> <b>Options)</b> <b>-&gt;</b>
       <b>start_channel(TcpSocket)</b> <b>-&gt;</b>
       <b>start_channel(TcpSocket,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>ChannelPid,</b> <b>ConnectionRef}</b> <b>|</b> <b>Error</b>

              Types:

                 Host = ssh:host()
                 Port = inet:port_number()
                 TcpSocket = ssh:open_socket()
                 Options = [ sftp_option() | ssh:client_option() ]
                 SftpOptions = [ sftp_option() ]
                 ChannelPid = pid()
                 ConnectionRef = ssh:connection_ref()
                 Error = {error, reason()}

              If no connection reference is provided, a  connection  is  set  up,  and  the  new  connection  is
              returned.  An SSH channel process is started to handle the communication with the SFTP server. The
              returned <u>pid</u> for this process is to be used as input to all other API functions in this module.

              Options:

                <u>{timeout,</u> <u>timeout()}</u>:
                  There are two ways to set a timeout for the underlying ssh connection:

                  * If the connection timeout option <u>connect_timeout</u> is set, that value is  used  also  for  the
                    negotiation timeout and this option (<u>timeout</u>) is ignored.

                  * Otherwise,  this  option  (<u>timeout</u>)  is used as the negotiation timeout only and there is no
                    connection timeout set

                  The value defaults to <u>infinity</u>.

                <u>{sftp_vsn,</u> <u>integer()}</u>:
                  Desired SFTP protocol version. The actual version is the minimum of the  desired  version  and
                  the maximum supported versions by the SFTP server.

              All  other  options  are  directly  passed  to ssh:connect/3 or ignored if a connection is already
              provided.

       <b>stop_channel(ChannelPid)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 ChannelPid = pid()

              Stops an SFTP channel. Does not close the SSH connection. Use ssh:close/1 to close it.

       <b>write(ChannelPid,</b> <b>Handle,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

       <b>write(ChannelPid,</b> <b>Handle,</b> <b>Data,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Handle = term()
                 Data = iodata()
                 Timeout = timeout()
                 Error = {error, reason()}

              Writes <u>data</u> to the file referenced by <u>Handle</u>. The file is to be opened with <u>write</u> or <u>append</u>  flag.
              Returns <u>ok</u> if successful or <u>{error,</u> <u>reason()}</u> otherwise.

       <b>write_file(ChannelPid,</b> <b>File,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

       <b>write_file(ChannelPid,</b> <b>File,</b> <b>Data,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 File = string()
                 Data = iodata()
                 Timeout = timeout()
                 Error = {error, reason()}

              Writes  a  file  to  the  server.  The  file is created if it does not exist but overwritten if it
              exists.

       <b>write_file_info(ChannelPid,</b> <b>Name,</b> <b>FileInfo)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

       <b>write_file_info(ChannelPid,</b> <b>Name,</b> <b>FileInfo,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>Error</b>

              Types:

                 ChannelPid = pid()
                 Name = string()
                 FileInfo = file:file_info()
                 Timeout = timeout()
                 Error = {error, reason()}

              Writes  file  information  from  a  <u>file_info</u>  record  to  the  file  specified   by   <u>Name</u>.   See
              file:write_file_info/[2,3] for information about the record.

Ericsson AB                                         ssh 4.13                                      <u><a href="../man3erl/ssh_sftp.3erl.html">ssh_sftp</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>