<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>debuginfod_find_debuginfo - request debuginfo from debuginfod</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       debuginfod_find_debuginfo - request debuginfo from debuginfod

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;elfutils/debuginfod.h&gt;</b>

       Link with <b>-ldebuginfod</b>.

       CONNECTION HANDLE

       <b>debuginfod_client</b> <b>*debuginfod_begin(void);</b>
       <b>void</b> <b>debuginfod_end(debuginfod_client</b> <b>*</b><u>client</u><b>);</b>

       LOOKUP FUNCTIONS

       <b>int</b> <b>debuginfod_find_debuginfo(debuginfod_client</b> <b>*</b><u>client</u><b>,</b>
                                     <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b><u>build_id</u><b>,</b>
                                     <b>int</b> <u>build_id_len</u><b>,</b>
                                     <b>char</b> <b>**</b> <u>path</u><b>);</b>
       <b>int</b> <b>debuginfod_find_executable(debuginfod_client</b> <b>*</b><u>client</u><b>,</b>
                                      <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b><u>build_id</u><b>,</b>
                                      <b>int</b> <u>build_id_len</u><b>,</b>
                                      <b>char</b> <b>**</b> <u>path</u><b>);</b>
       <b>int</b> <b>debuginfod_find_source(debuginfod_client</b> <b>*</b><u>client</u><b>,</b>
                                  <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b><u>build_id</u><b>,</b>
                                  <b>int</b> <u>build_id_len</u><b>,</b>
                                  <b>const</b> <b>char</b> <b>*</b><u>filename</u><b>,</b>
                                  <b>char</b> <b>**</b> <u>path</u><b>);</b>
       <b>int</b> <b>debuginfod_find_section(debuginfod_client</b> <b>*</b><u>client</u><b>,</b>
                                  <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b><u>build_id</u><b>,</b>
                                  <b>int</b> <u>build_id_len</u><b>,</b>
                                  <b>const</b> <b>char</b> <b>*</b> <u>section</u><b>,</b>
                                  <b>char</b> <b>**</b> <u>path</u><b>);</b>
       <b>int</b> <b>debuginfod_find_metadata(debuginfod_client</b> <b>*</b><u>client</u><b>,</b>
                                   <b>const</b> <b>char</b> <b>*</b><u>key</u><b>,</b>
                                   <b>const</b> <b>char</b> <b>*</b><u>value</u><b>,</b>
                                   <b>char</b> <b>**</b> <u>path</u><b>);</b>

       OPTIONAL FUNCTIONS

       <b>typedef</b> <b>int</b> <b>(*debuginfod_progressfn_t)(debuginfod_client</b> <b>*</b><u>client</u><b>,</b>
                                              <b>long</b> <b>a,</b> <b>long</b> <b>b);</b>
       <b>void</b> <b>debuginfod_set_progressfn(debuginfod_client</b> <b>*</b><u>client</u><b>,</b>
                                      <b>debuginfod_progressfn_t</b> <u>progressfn</u><b>);</b>
       <b>void</b> <b>debuginfod_set_verbose_fd(debuginfod_client</b> <b>*</b><u>client</u><b>,</b>
                                      <b>int</b> <u>fd</u><b>);</b>
       <b>void</b> <b>debuginfod_set_user_data(debuginfod_client</b> <b>*</b><u>client</u><b>,</b>
                                     <b>void</b> <b>*</b><u>data</u><b>);</b>
       <b>void*</b> <b>debuginfod_get_user_data(debuginfod_client</b> <b>*</b><u>client</u><b>);</b>
       <b>const</b> <b>char*</b> <b>debuginfod_get_url(debuginfod_client</b> <b>*</b><u>client</u><b>);</b>
       <b>int</b> <b>debuginfod_add_http_header(debuginfod_client</b> <b>*</b><u>client</u><b>,</b>
                                      <b>const</b> <b>char*</b> <u>header</u><b>);</b>
       <b>const</b> <b>char*</b> <b>debuginfod_get_headers(debuginfod_client</b> <b>*</b><u>client</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>debuginfod_begin</b>()  creates  a  <b>debuginfod_client</b>  connection  handle  that should be used with all other
       calls.  <b>debuginfod_end</b>() should be called on the <b>client</b> handle to release  all  state  and  storage  when
       done.

       <b>debuginfod_find_debuginfo</b>(),   <b>debuginfod_find_executable</b>(),   and   <b>debuginfod_find_source</b>()  query  the
       debuginfod server URLs contained in <b>$DEBUGINFOD_URLS</b> (see below) for the debuginfo, executable or  source
       file  with  the  given  <u>build_id</u>. <u>build_id</u> should be a pointer to either a null-terminated, lowercase hex
       string or a binary blob. If <u>build_id</u> is given as a  hex  string,  <u>build_id_len</u>  should  be  0.  Otherwise
       <u>build_id_len</u> should be the number of bytes in the binary blob.

       <b>debuginfod_find_source</b>()  also requires a <u>filename</u> in order to specify a particular source file. <u>filename</u>
       should be an absolute path that includes the compilation directory of the CU associated with  the  source
       file.   Relative  path  names  commonly  appear in the DWARF file's source directory, but these paths are
       relative to individual compilation unit AT_comp_dir paths, and yet an executable is made up  of  multiple
       CUs. Therefore, to disambiguate, debuginfod expects source queries to prefix relative path names with the
       CU compilation-directory, followed by a mandatory "/".

       Note:  the  caller  may  or  may  not  elide <b>../</b> or <b><a href="file:/./">/./</a></b> or extraneous <b>///</b> sorts of path components in the
       directory names.  debuginfod accepts both  forms.   Specifically,  debuginfod  canonicalizes  path  names
       according to RFC3986 section 5.2.4 (Remove Dot Segments), plus reducing any <b>//</b> to <b>/</b> in the path.

       <b>debuginfod_find_section</b>() queries the debuginfod server URLs contained in <b>$DEBUGINFOD_URLS</b> for the binary
       contents  of  an  ELF/DWARF  section contained in a debuginfo or executable file with the given <u>build_id</u>.
       <u>section</u> should be the name of the desired ELF/DWARF section.   If  a  server  does  not  support  section
       queries,  debuginfod_find_section  may query the server for the debuginfo and/or executable with <u>build_id</u>
       in order to retrieve and extract the section.

       <b>debuginfod_find_metadata</b>() queries all debuginfod server URLs contained in <b>$DEBUGINFOD_URLS</b> for  metadata
       for  all matches of a given key/value query against files in their indexes.  The resulting file is a JSON
       document.  See the <u><a href="../man1/debuginfod-find.1.html">debuginfod-find</a>(1)</u> man page for examples of the supported types of  key/value  queries
       and their JSON results.

       If  <u>path</u>  is  not NULL and the query is successful, <u>path</u> is set to the path of the file in the cache. The
       caller must <b>free</b>() this value.

       The URLs in <b>$DEBUGINFOD_URLS</b> may  be  queried  in  parallel.  As  soon  as  a  debuginfod  server  begins
       transferring the target file all of the connections to the other servers are closed.

       A  <b>client</b>  handle  should be used from only one thread at a time.  A handle may be reused for a series of
       lookups, which can improve performance due to retention of connections and caches.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>debuginfod_begin</b> returns the <b>debuginfod_client</b> handle to use with all other calls.  On error <b>NULL</b> will be
       returned and <b>errno</b> will be set.

       If a find family function is successful, the resulting file is saved to  the  client  cache  and  a  file
       descriptor  to  that  file  is  returned.   The file descriptor points to the beginning of the file.  The
       caller needs to <b>close</b>() this descriptor.  Otherwise, a negative error code is returned.

</pre><h4><b>OPTIONAL</b> <b>FUNCTIONS</b></h4><pre>
       A small number of optional functions are available to tune or  query  the  operation  of  the  debuginfod
       client.

   <b>PROGRESS</b> <b>CALLBACK</b>
       As  the  <b>debuginfod_find_*</b>()  functions  may block for seconds or longer, a progress callback function is
       called periodically, if configured with <b>debuginfod_set_progressfn</b>().  This function sets a  new  progress
       callback function (or NULL) for the client handle.

       The  given  callback function is called from the context of each thread that is invoking any of the other
       lookup functions.  It is given two  numeric  parameters  that,  if  thought  of  as  a  numerator  <u>a</u>  and
       denominator  <u>b</u>,  together  represent  a  completion fraction <u>a/b</u>.  The denominator may be zero initially,
       until a quantity such as an exact download size becomes known.

       The progress callback function is also the supported way  to  <u>interrupt</u>  the  download  operation.   (The
       library  does  <u>not</u> modify or trigger signals.)  The progress callback must return 0 to continue the work,
       or any other value to stop work as soon as possible.  Consequently, the <b>debuginfod_find_*</b>() function will
       likely return with an error, but might still succeed.

   <b>VERBOSE</b> <b>OUTPUT</b>
       The <b>debuginfod_find_*</b>() functions may use several techniques to retrieve the requested files, through the
       cache or  through  one  or  multiple  servers  or  file  URLs.  To  show  how  a  query  is  handled  the
       <b>debuginfod_set_verbose_fd</b>()  can  be  used to set a particular file descriptor on which verbose output is
       given about the query steps and eventual errors encountered.

   <b>USER</b> <b>DATA</b> <b>POINTER</b>
       A  single  <u>void</u>  <u>*</u>  pointer  associated  with  the  connection  handle  may   be   set   any   time   via
       <b>debuginfod_set_user_data</b>()<b>,</b>  and  retrieved  via  <b>debuginfod_get_user_data</b>()<b>.</b>   The value is undefined if
       unset.

   <b>URL</b>
       The  URL  of  the  current  or  most  recent  outgoing  download,  if  known,  may   be   retrieved   via
       <b>debuginfod_get_url</b>()  from the progressfn callback, or afterwards.  It may be NULL.  The resulting string
       is owned by the library, and must not be modified or freed.  The caller should copy it if  it  is  needed
       beyond the release of the client object.

   <b>HTTP</b> <b>HEADER</b>
       Before  each  lookup function is initiated, a client application may add HTTP request headers.  These are
       reset after each lookup function.  <b>debuginfod_add_http_header</b>() may be called with strings  of  the  form
       <b>"Header:</b>  <b>value"</b>.   These  strings are copied by the library.  A zero return value indicates success, but
       out-of-memory conditions may result in a non-zero <u>-ENOMEM</u>. If the string is in  the  wrong  form  <u>-EINVAL</u>
       will be returned.

       <u>$DEBUGINFOD_HEADERS_FILE</u>  specifies  a  file  to supply headers to outgoing requests. Each non-whitespace
       line of this file is handled as if <b>debuginfod_add_http_header</b>() were called on the contents.

       Note that the current debuginfod-client library implementation uses libcurl, but you  shouldn't  rely  on
       that  fact.  Don't  use  this  function  for  replacing  any  standard headers, except for the User-Agent
       mentioned below. You can use this function to add authorization information for  access  control,  or  to
       provide optional headers to the server for logging purposes.

       By  default,  the  library  adds  a  descriptive  <u>User-Agent:</u> header to outgoing requests.  If the client
       application adds a header with the same name, this default is suppressed.

       During or after a lookup, a client application may call <b>debuginfod_get_headers</b>() to gather the subset  of
       HTTP  response  headers  received  from the current or most recent debuginfod server.  Only those headers
       prefixed with <b>X-DEBUGINFOD</b> (case-insensitive) are kept.  They are returned as a single string, with  each
       "header:  value"  terminated  with  a \n (not \r\n as in HTTP).  It may be NULL.  The resulting string is
       owned by the library, and must not be modified or freed.  The caller should copy the returned  string  if
       it is needed beyond the release of the client object.

</pre><h4><b>MACROS</b></h4><pre>
   <b>DEBUGINFOD_SONAME</b>
       Defined to the string that could be passed to <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3) if the library is loaded at runtime, for example

           void *debuginfod_so = dlopen(DEBUGINFOD_SONAME, RTLD_LAZY);

</pre><h4><b>SECURITY</b></h4><pre>
       If  IMA  signature(s)  are  available  from  the  RPMs that contain requested files, then <b>debuginfod</b> will
       extract those signatures into response headers, and <b>debuginfod_find_*</b>() will  perform  verification  upon
       the  files.   Validation  policy  is  controlled  via  tags  inserted into $DEBUGINFOD_URLS.  By default,
       <b>debuginfod_find_*</b>() acts in ignore mode.

       If accessed across HTTP rather than HTTPS, the network should be trustworthy.  Authentication information
       through the  internal  <u>libcurl</u>  library  is  not  currently  enabled,  except  for  the  basic  plaintext
       <u>http[s]://userid:password@hostname/</u> style.  (The debuginfod server does not perform authentication, but a
       front-end proxy server could.)

</pre><h4><b>ERRORS</b></h4><pre>
       The  following  list is not comprehensive. Error codes may also originate from calls to various C Library
       functions.

       <b>EACCESS</b>
              Denied access to resource located at the URL.

       <b>ECONNREFUSED</b>
              Unable to connect to remote host. Also returned when an HTTPS connection couldn't be verified (bad
              certificate).

       <b>ECONNRESET</b>
              Unable to either send or receive network data.

       <b>EHOSTUNREACH</b>
              Unable to resolve remote host.

       <b>EINVAL</b> One or more arguments are incorrectly formatted. <u>build_id</u>  may  be  too  long  (greater  than  256
              characters), <u>filename</u> may not be an absolute path or a debuginfod URL is malformed.

       <b>EIO</b>    Unable to write data received from server to local file.

       <b>EMLINK</b> Too many HTTP redirects.

       <b>ENETUNREACH</b>
              Unable to initialize network connection.

       <b>ENOENT</b> Could  not  find  the  resource  located at URL. Often this error code indicates that a debuginfod
              server was successfully contacted but the server could not find the target file.

       <b>ENOMEM</b> System is unable to allocate resources.

       <b>ENOSYS</b> <b>$DEBUGINFOD_URLS</b> is not defined.

       <b>ETIME</b>  Query failed due to timeout. <b>$DEBUGINFOD_TIMEOUT</b> and <b>$DEBUGINFOD_MAXTIME</b> control this.

       <b>EF2BIG</b> Query aborted due to the file requested being too big.  The <b>$DEBUGINFOD_MAXSIZE</b> controls this.

       <b>EBADMSG</b>
              File content failed IMA verification against a known signer certificate.

       <b>ENOKEY</b> File content failed IMA verification due to missing signer certificate.

       <b>ENODATA</b>
              File content failed IMA verification because of a missing signature.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man8/debuginfod.8.html">debuginfod</a>(8)</u>

                                                                                            <u>DEBUGINFOD_FIND_*</u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>