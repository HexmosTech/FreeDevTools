<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::MakeMethods::Docs::Examples - Sample Declarations and Usage</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-makemethods-perl">libclass-makemethods-perl_1.01-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::MakeMethods::Docs::Examples - Sample Declarations and Usage

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following examples indicate some of the capabilities of Class::MakeMethods.

   <b>A</b> <b>Contrived</b> <b>Example</b>
       Object-oriented Perl code is widespread -- you've probably seen code like the below a million times:

         my $obj = MyStruct-&gt;new( foo=&gt;"Foozle", bar=&gt;"Bozzle" );
         if ( $obj-&gt;foo() =~ /foo/i ) {
           $obj-&gt;bar("Barbados!");
         }

       Here's a possible implementation for the class whose interface is shown above:

         package MyStruct;

         sub new {
           my $callee = shift;
           my $self = bless { @_ }, (ref $callee || $callee);
           return $self;
         }

         sub foo {
           my $self = shift;
           if ( scalar @_ ) {
             $self-&gt;{'foo'} = shift();
           } else {
             $self-&gt;{'foo'}
           }
         }

         sub bar {
           my $self = shift;
           if ( scalar @_ ) {
             $self-&gt;{'bar'} = shift();
           } else {
             $self-&gt;{'bar'}
           }
         }

       Class::MakeMethods allows you to simply declare those methods to be of a predefined type, and it
       generates and installs the necessary methods in your package at compile-time.

       Here's the equivalent declaration for that same basic class:

         package MyStruct;
         use Class::MakeMethods::Standard::Hash (
           'new'       =&gt; 'new',
           'scalar'    =&gt; 'foo',
           'scalar'    =&gt; 'bar',
         );

   <b>A</b> <b>Typical</b> <b>Example</b>
       The following example shows a common case of constructing a class with several types of accessor methods

         package MyObject;
         use Class::MakeMethods::Standard::Hash (
           new =&gt; 'new',
           scalar =&gt; [ 'foo', 'bar' ],
           array =&gt; 'my_list',
           hash =&gt; 'my_index',
         );

       This class now has a constructor named new, two scalar accessors named foo and bar, and a pair of
       reference accessors named my_list and my_index. Typical usage of the class might include calls like the
       following:

         my $obj = MyObject-&gt;new( foo =&gt; 'Foozle' );
         print $obj-&gt;foo();

         $obj-&gt;bar('Barbados');
         print $obj-&gt;bar();

         $obj-&gt;my_list(0 =&gt; 'Foozle', 1 =&gt; 'Bang!');
         print $obj-&gt;<a href="../man1/my_list.1.html">my_list</a>(1);

         $obj-&gt;my_index('broccoli' =&gt; 'Blah!', 'foo' =&gt; 'Fiddle');
         print $obj-&gt;my_index('foo');

   <b>Lvalue</b> <b>Accessors</b>
       The Template subclasses support an optional "--lvalue" modifier that causes your accessors method to be
       marked as returning an lvalue which can be assigned to. (This feature is only available on Perl 5.6 or
       later.)

         package MyStruct;
         use Class::MakeMethods::Template::Hash (
           'new'                   =&gt; 'new',
           'scalar --get --lvalue' =&gt; 'foo',
           'array --get --lvalue'  =&gt; 'bar',
         );

         $obj-&gt;foo = "Foozle";
         print $obj-&gt;foo;

         $obj-&gt;bar = ( 'baz', 'beep', 'boop' );
         print $obj-&gt;bar-&gt;[1]; # beep

   <b>String</b> <b>and</b> <b>Numeric</b> <b>Accessors</b>
       In addition to the "scalar" accessor supported by the "Standard::*" classes, the Template subclasses also
       provide specialized accessors that can facilitate the use of specific types of data.

       For example, we could declare the following class to hold information about available Perl packages:

         package MyVersionInfo;
         use Class::MakeMethods::Template::Hash (
           'new'     =&gt; 'new',
           'string'  =&gt; 'package',
           'number'  =&gt; 'version',
         );

         sub summary {
           my $self = shift;
           return $self-&gt;package() . " is at version " . $self-&gt;version()
         }

       You could use this class as follows:

         package main;
         use MyVersionInfo;

         my $obj = MyVersionInfo-&gt;new( package=&gt;"Class::MakeMethods");
         $obj-&gt;version( 2.0 );
         print $obj-&gt;summary();

       These accessors will provide a bit of diagnostic type checking; an attempt to call "$obj-&gt;version("foo")"
       will cause your program to croak.

   <b>String</b> <b>Concatenation</b> <b>Interface</b>
       The following defines a get_concat method "i", and specifies a string to use when joining additional
       values when this method is called.

         use Class::MakeMethods::Template::Hash
           'string' =&gt; [ '--get_concat', 'i', { join =&gt; ' - ' } ];

       (See Class::MakeMethods::Template::Generic for information about the "string" "get_concat" interface.)

   <b>Access</b> <b>Control</b> <b>Example</b>
       The following defines a secret_password method, which will croak if it is called from outside of the
       declaring package.

         use Class::MakeMethods::Composite::Hash
           'scalar' =&gt; [ 'secret_password' =&gt; { permit =&gt; 'pp' } ];

       (See Class::MakeMethods::Composite for information about the "permit" modifier.)

       For template classes, the same thing is accomplished with '--private':

         use Class::MakeMethods::Template::Hash
           'scalar' =&gt; [ '--private', 'secret_password' ];

       (See Class::MakeMethods::Template::Universal for information about the "private" modifier.)

   <b>Lazy-Init</b> <b>Interface</b>
       Templapte scalar accessors declared with the "init_and_get" interface can be used for "memoization" or
       lazy-evaluation for object attributes. If the current accessor value is undefined, they will first call a
       user-provided init_* method and save its value.

         package MyWidget;
         use Class::MakeMethods::Template::Hash (
           'new --with_values' =&gt; [ 'new' ],
           'scalar --init_and_get' =&gt; [ 'foo', 'count', 'result' ],
         );

         sub init_foo {
           return 'foofle';
         }

         sub init_count {
           return '3';
         }

         sub init_result {
           my $self = shift;
           return $self-&gt;foo x $self-&gt;count;
         }
         ...

         my $widget = MyWidget-&gt;new();
         print $widget-&gt;result; # output: fooflefooflefoofle

         # if values are predefined, the init methods are not used
         my $other_widget = MyWidget-&gt;new( foo =&gt; 'bar', count =&gt; 2 );
         print $widget-&gt;result; # output: barbar

       (See Class::MakeMethods::Template::Generic for more information about "init_and_get". This interface is
       also supported by all of Generic's subclasses, so you can add lazy-init methods for global data, class
       data, array objects, etc. Unfortunately, to date it is only supported for scalar-value accessors...)

   <b>Helper</b> <b>Methods</b>
       Template methods often include similarly-named "helper" methods. For example, specifying the
       "--with_clear" interface for Template::*:scalar methods creates an extra method for each accessor x named
       clear_x.

         package MyClass;
         use Class::MakeMethods::Template::Hash('scalar --with_clear' =&gt; 'foo');

         my $obj = MyClass-&gt;new;
         $obj-&gt;<a href="../man23/foo.23.html">foo</a>(23);
         $obj-&gt;clear_foo;
         print $obj-&gt;foo();

   <b>Reference</b> <b>Accessor</b> <b>and</b> <b>Helper</b> <b>Methods</b>
       For references to arrays and hashes, the Template subclasses provide accessors with extra "helper
       methods" to facilitate method-based interaction.

       Here's a class whose instances each store a string and an array reference, along with a method to search
       the directories:

         package MySearchPath;
         use Class::MakeMethods::Template::Hash (
           'new'     =&gt; 'new',
           'string'  =&gt; 'name',
           'array'   =&gt; 'directories',
         );

         sub search {
           my $self = shift;
           my $target = shift;
           foreach my $dir ( $self-&gt;directories ) {
             my $candidate = $dir . '/' . $target;
             return $candidate if ( -e $candidate );
           }
           return;
         }

       Note that the directories accessor returns the contents of the array when called in a list context,
       making it easier to loop over.

       And here's a sample usage:

         package main;
         use MySearchPath;

         my $libs = MySearchPath-&gt;new( name=&gt;"libs", directories=&gt;['<a href="file:/usr/lib">/usr/lib</a>'] );
         $libs-&gt;push_directories( '<a href="file:/usr/local/lib">/usr/local/lib</a>' );

         print "Searching in " . $libs-&gt;count_directories() . "directories.\n";
         foreach ( 'libtiff', 'libjpeg' ) {
           my $file = $libs-&gt;search("$_.so");
           print "Checking $_: " . ( $file || 'not found' ) . "\n";
         }

       Note the use of the push_* and count_* "helper" accessor methods, which are defined by default for all
       'Template::*:array' declarations.

       Consult Class::MakeMethods::Template::Generic for more information about the available types of reference
       accessors, and the various methods they define.

   <b>Object</b> <b>Accessors</b>
       There's also a specialized accessor for object references:

         package MyStruct;
         use Class::MakeMethods::Template::Hash (
           'new'    =&gt; 'new',
           'object' =&gt; [ 'widget' =&gt; {class=&gt;'MyWidgetClass', delegate=&gt;"twiddle"} ],
         );

       (Note that the "class" and "delegate" values specified above are method parameters, which provide
       additional information about the "widget" declaration; see "Standard Declaration Syntax" for more
       information.)

       The above declaration creates methods equivalent to the following:

         package MyStruct;

         sub widget {
           my $self = shift;
           if ( scalar @_ ) {
             if (ref $_[0] and UNIVERSAL::isa($_[0], 'MyWidgetClass')) {
               $self-&gt;{widget} = shift;
             } else {
               $self-&gt;{widget} = MyWidgetClass-&gt;new(@_);
             }
           } else {
             return $self-&gt;{widget};
           }
         }

         sub clear_widget {
           my $self = shift;
           $self-&gt;{widget} = undef;
         }

         sub twiddle {
           my $self = shift;
           my $obj = $self-&gt;widget()
             or Carp::croak("Can't forward twiddle because widget is empty");
           $obj-&gt;twiddle(@_)
         }

   <b>Mixing</b> <b>Object</b> <b>and</b> <b>Global</b> <b>Methods</b>
       Here's a package declaration using two of the included subclasses, "Standard::Hash", for creating and
       accessing hash-based objects, and "Basic::Global", for simple global-value accessors:

         package MyQueueItem;

         use Class::MakeMethods::Standard::Hash (
           new =&gt; { name =&gt; 'new', defaults=&gt;{ foo =&gt; 'Foozle' } },
           scalar =&gt; [ 'foo', 'bar' ],
           hash =&gt; 'history'
         );

         use Class::MakeMethods::Basic::Global (
           scalar =&gt; 'Debug',
           array  =&gt; 'InQueue',
         );

         sub AddQueueItem {
           my $class = shift;
           my $instance = shift;
           $instance-&gt;history('AddQueueItem' =&gt; time());
           $class-&gt;InQueue([0, 0], $instance);
         }

         sub GetQueueItem {
           my $class = shift;
           $class-&gt;InQueue([0, 1], []) or $class-&gt;new
         }

   <b>Adding</b> <b>Custom</b> <b>Initialization</b> <b>to</b> <b>Constructors</b>
       Frequently you'll want to provide some custom code to initialize new objects of your class. Most of the
       *:new constructor methods provides a way to ensure that this code is consistently called every time a new
       instance is created.

       Composite::Hash:new { post_rules =&gt; [] }
           The  Composite  classes allow you to add pre- and post-operations to any method, so you can pass in a
           code-ref to be executed after the <b>new()</b> method.

             package MyClass;

             sub new_post_init {
               my $self = ${(pop)-&gt;{result}}; # get result of original new()
               length($self-&gt;foo) or $self-&gt;foo('FooBar');   # default value
               warn "Initialized new object '$self'";
             }

             use Class::MakeMethods (
               'Composite::Hash:new' =&gt; [
                   'new' =&gt; { post_rules=&gt;[ \&amp;new_post_init ] }
               ],
               'Composite::Hash:scalar' =&gt; 'foo;,
             );
             ...
             package main;
             my $self = MyClass-&gt;new( foo =&gt; 'Foozle' )

       Template::Hash:new --and_then_init
           Use 'Template::Hash:new --and_then_init', which will first create the object and initialize  it  with
           the provided values, and then call an <b>init()</b> method on the new object before returning it.

             package MyClass;
             use Class::MakeMethods::Template::Hash (
               'new --and_then_init' =&gt; 'new'
               'string'  =&gt; 'foo'
             );
             sub init {
               my $self = shift;
               length($self-&gt;foo) or $self-&gt;foo('FooBar');   # default value
               warn "Initialized new object '$self'";
             }
             ...
             package main;
             my $self = MyClass-&gt;new( foo =&gt; 'Foozle' )

       Template::Hash:new --with_init
           If  you  don't want your constructor to use the default hash-of-method-names style of initialization,
           use 'Template::Hash:new --with_init', which will create an empty object, pass its  arguments  to  the
           <b>init()</b> method on the new object, and then return it.

             package MyClass;
             use Class::MakeMethods::Template::Hash (
               'new --with_init' =&gt; 'new'
               'string'  =&gt; 'foo'
             );
             sub init {
               my $self = shift;
               $self-&gt;foo( shift || 'FooBar' ); # init with arg or default
               warn "Initialized new object '$self'";
             }
             ...
             package main;
             my $self = MyClass-&gt;new( 'Foozle' )

       Some additional notes about these constructors:

       •   The  "Template::*:new"  methods  allow  you  to  specify  a name for your method other than "init" by
           passing the "init_method" parameter:

             use Class::MakeMethods::Template::Hash (
               'new --and_then_init' =&gt; [
                   'new' =&gt; { init_method =&gt;  'my_init' }
               ],
             );

       •   If you know that you're not going to  have  a  complex  class  hierarchy,  you  can  reduce  resource
           consumption a bit by changing the above declarations from "*::Hash" to "*::Array" so your objects end
           up as blessed arrays rather than blessed hashes.

   <b>Changing</b> <b>Method</b> <b>Names</b>
       The  Template subclasses allow you to control the names assigned to the methods you generate by selecting
       from several naming interfaces.

       For example, the accessors declared above use a default, Perl-ish style  interface,  in  which  a  single
       method  can be called without an argument to retrieve the value, or with an argument to set it.  However,
       you can also select a more Java-like syntax, with separate  get*  and  set*  methods,  by  including  the
       '--java' template specification:

         package MyStruct;
         use Class::MakeMethods::Template::Hash (
           'new'     =&gt; 'new',
           'scalar'  =&gt; '--java Foo',
         );

       (Note  that  the declaration of Foo could also have been written as 'scalar --java' =&gt; 'Foo' or "'scalar'
       =&gt; ['--java', 'Foo']", or "'scalar' =&gt; [ 'foo' =" { 'interface'=&gt;'java' } ], all of which are interpreted
       identically; see the Class::MakeMethods section on "Argument Normalization" for details.)

       Usage of this accessor would then be as follows:

         package main;
         use MyStruct;

         my $obj = MyStruct-&gt;new( setFoo =&gt; "Foozle" );
         print $obj-&gt;getFoo();
         $obj-&gt;setFoo("Bozzle");

   <b>Selecting</b> <b>Specific</b> <b>Helper</b> <b>Methods</b>
       You can use the ability to specify interfaces to select specific helper methods rather than  getting  the
       default collection.

       For  example,  let's  say you wanted to use a Template::Hash:array, but you only wanted two methods to be
       installed in your class, a <b>foo()</b> accessor and a <b>shift_foo()</b> mutator. Any of  the  below  combinations  of
       syntax should do the trick:

         use Class::MakeMethods::Template::Hash
           'array' =&gt; [
             'foo' =&gt; { interface=&gt;{'foo'=&gt;'get_set', 'shift_foo'=&gt;'shift'} },
           ];

       If you're going to have a lot of methods with the same interface, you could pre-declare a named interface
       once and use it repeatedly:

         BEGIN {
           require Class::MakeMethods::Template::Hash;
           Class::MakeMethods::Template::Hash-&gt;named_method('array')-&gt;
               {'interface'}-&gt;{'my_get_set_shift'} =
                   { '*'=&gt;'get_set', 'shift_*'=&gt;'shift' };
         }

         use Class::MakeMethods::Template::Hash
           'array --my_get_set_shift' =&gt; [ 'foo', 'bar' ];

   <b>Tree</b> <b>Structure</b> <b>Example</b>
       In this example we will create a pair of classes with references to other objects.

       The first class is a single-value data object implemented as a reference to a scalar.

         package MyTreeData;
         use Class::MakeMethods::Template::Scalar (
           'new'     =&gt; 'new',
           'string'  =&gt; 'value',
         );

       The  second  class  defines  a node in a tree, with a constructor, an accessor for a data object from the
       class above, and accessors for a list of child nodes.

         package MyTreeNode;
         use Class::MakeMethods::Template::Hash (
           'new'     =&gt; 'new',
           'object -class MyTreeData'  =&gt; 'data',
           'array_of_objects -class MyTreeNode' =&gt; 'children',
         );

         sub depth_first_data {
           my $self = shift;
           return $self-&gt;data, map { $_-&gt;depth_first_data() } $self-&gt;children;
         }

       Here's a sample of how the above classes could be used in a program.

         package main;
         use MyTreeData;
         use MyTreeNode;

         my $node = MyTreeNode-&gt;new(
             data =&gt; { value=&gt;'data1' },
             children =&gt; [ { value=&gt;'data3' } ]
         );
         $node-&gt;push_children( MyTreeNode-&gt;new( data =&gt; { value=&gt;'data2' } ) );

         foreach my $data ( $node-&gt;depth_first_data ) {
           print $data-&gt;value();
         }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See Class::MakeMethods for general information about this distribution.

   <b>Annotated</b> <b>Tutorials</b>
       Ron Savage has posted a pair of annotated examples, linked to below.  Each demonstrates building a  class
       with MakeMethods, and each includes scads of comments that walk you through the logic and demonstrate how
       the various methods work together.

         <a href="http://savage.net.au/Perl-tutorials.html">http://savage.net.au/Perl-tutorials.html</a>
         <a href="http://savage.net.au/Perl-tutorials/tut-33.tgz">http://savage.net.au/Perl-tutorials/tut-33.tgz</a>
         <a href="http://savage.net.au/Perl-tutorials/tut-34.tgz">http://savage.net.au/Perl-tutorials/tut-34.tgz</a>

perl v5.36.0                                       2022-10-13                   <u>MakeMethods::Docs::<a href="../man3pm/Examples.3pm.html">Examples</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>