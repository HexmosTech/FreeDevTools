<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PAPI_profil - Generate a histogram of hardware counter overflows vs. PC addresses.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpapi-dev">libpapi-dev_7.1.0-5build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PAPI_profil - Generate a histogram of hardware counter overflows vs. PC addresses.

</pre><h4><b>SYNOPSIS</b></h4><pre>
</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       <b>C</b> <b>Interface:</b>
           #include &lt;<b>papi.h</b>&gt;
           int <b>PAPI_profil(void</b> <b>*buf,</b> <b>unsigned</b> <b>bufsiz,</b> <b>unsigned</b> <b>long</b> <b>offset,</b> <b>unsigned</b> <b>scale,</b> <b>int</b> <b>EventSet,</b> <b>int</b>
           <b>EventCode,</b> <b>int</b> <b>threshold,</b> <b>int</b> <b>flags</b> <b>)</b>;

       <b>Fortran</b> <b>Interface</b>
           The profiling routines have no Fortran interface.

       <b>Parameters</b>
           <u>*buf</u> -- pointer to a buffer of bufsiz bytes in which the histogram counts are stored in an array of
           unsigned short, unsigned int, or unsigned long long values, or 'buckets'. The size of the buckets is
           determined by values in the flags argument.
           <u>bufsiz</u> -- the size of the histogram buffer in bytes. It is computed from the length of the code
           region to be profiled, the size of the buckets, and the scale factor as discussed above.
           <u>offset</u> -- the start address of the region to be profiled.
           <u>scale</u> -- broadly and historically speaking, a contraction factor that indicates how much smaller the
           histogram buffer is than the region to be profiled. More precisely, scale is interpreted as an
           unsigned 16-bit fixed-point fraction with the decimal point implied on the left. Its value is the
           reciprocal of the number of addresses in a subdivision, per counter of histogram buffer. Below is a
           table of representative values for scale.
           <u>EventSet</u> -- The PAPI EventSet to profile. This EventSet is marked as profiling-ready, but profiling
           doesn't actually start until a <b>PAPI_start()</b> call is issued.
           <u>EventCode</u> -- Code of the Event in the EventSet to profile. This event must already be a member of the
           EventSet.
           <u>threshold</u> -- minimum number of events that must occur before the PC is sampled. If hardware overflow
           is supported for your component, this threshold will trigger an interrupt when reached. Otherwise,
           the counters will be sampled periodically and the PC will be recorded for the first sample that
           exceeds the threshold. If the value of threshold is 0, profiling will be disabled for this event.
           <u>flags</u> -- bit pattern to control profiling behavior. Defined values are shown in the table above.

       <b>Return</b> <b>values</b>
           <u>PAPI_OK</u>
           <u>PAPI_EINVAL</u> One or more of the arguments is invalid.
           <u>PAPI_ENOMEM</u> Insufficient memory to complete the operation.
           <u>PAPI_ENOEVST</u> The EventSet specified does not exist.
           <u>PAPI_EISRUN</u> The EventSet is currently counting events.
           <u>PAPI_ECNFLCT</u> The underlying counter hardware can not count this event and other events in the
           EventSet simultaneously.
           <u>PAPI_ENOEVNT</u> The PAPI preset is not available on the underlying hardware.

       <b>PAPI_profil()</b> provides hardware event statistics by profiling the occurrence of specified hardware
       counter events. It is designed to mimic the UNIX SVR4 profil call.

       The statistics are generated by creating a histogram of hardware counter event overflows vs. program
       counter addresses for the current process. The histogram is defined for a specific region of program code
       to be profiled, and the identified region is logically broken up into a set of equal size subdivisions,
       each of which corresponds to a count in the histogram.

       With each hardware event overflow, the current subdivision is identified and its corresponding histogram
       count is incremented. These counts establish a relative measure of how many hardware counter events are
       occurring in each code subdivision.

       The resulting histogram counts for a profiled region can be used to identify those program addresses that
       generate a disproportionately high percentage of the event of interest.

       Events to be profiled are specified with the EventSet and EventCode parameters. More than one event can
       be simultaneously profiled by calling <b>PAPI_profil()</b> several times with different EventCode values.
       Profiling can be turned off for a given event by calling <b>PAPI_profil()</b> with a threshold value of 0.

       <b>Representative</b> <b>values</b> <b>for</b> <b>the</b> <b>scale</b> <b>variable</b>

           HEX      DECIMAL  DEFININTION 0x20000  131072   Maps precisely one instruction address to a unique
           bucket in buf.  0x10000   65536   Maps precisely two instruction addresses to a unique bucket in buf.
           0x0FFFF   65535   Maps approximately two instruction addresses to a unique bucket in buf.  0x08000
           32768   Maps every four instruction addresses to a bucket in buf.  0x04000   16384   Maps every eight
           instruction addresses to a bucket in buf.  0x00002       2   Maps all instruction addresses to the
           same bucket in buf.  0x00001       1   Undefined.  0x00000       0   Undefined.

       Historically, the scale factor was introduced to allow the allocation of buffers smaller than the code
       size to be profiled. Data and instruction sizes were assumed to be multiples of 16-bits. These
       assumptions are no longer necessarily true. <b>PAPI_profil()</b> has preserved the traditional definition of
       scale where appropriate, but deprecated the definitions for 0 and 1 (disable scaling) and extended the
       range of scale to include 65536 and 131072 to allow for exactly two addresses and exactly one address per
       profiling bucket.

       The value of bufsiz is computed as follows:

       bufsiz = (end - start)*(bucket_size/2)*(scale/65536) where

       • bufsiz - the size of the buffer in bytes
       • end, start - the ending and starting addresses of the profiled region
       • bucket_size - the size of each bucket in bytes; 2, 4, or 8 as defined in flags
       <b>Defined</b> <b>bits</b> <b>for</b> <b>the</b> <b>flags</b> <b>variable:</b>

           • PAPI_PROFIL_POSIX Default type of profiling, similar to profil (3).

           • PAPI_PROFIL_RANDOM Drop a random 25% of the samples.

           • PAPI_PROFIL_WEIGHTED Weight the samples by their value.

           • PAPI_PROFIL_COMPRESS Ignore samples as values in the hash buckets get big.

           • PAPI_PROFIL_BUCKET_16 Use unsigned short (16 bit) buckets, This is the default bucket.

           • PAPI_PROFIL_BUCKET_32 Use unsigned int (32 bit) buckets.

           • PAPI_PROFIL_BUCKET_64 Use unsigned long long (64 bit) buckets.

           • PAPI_PROFIL_FORCE_SW Force software overflow in profiling.

       <b>Example</b>

           int retval;
           unsigned long length;
           PAPI_exe_info_t *prginfo;
           unsigned short *profbuf;

           if ((prginfo = PAPI_get_executable_info()) == NULL)
              <a href="../man1/handle_error.1.html">handle_error</a>(1);

           length = (unsigned long)(prginfo-&gt;text_end - prginfo-&gt;text_start);

           profbuf = (unsigned short *)malloc(length);
           if (profbuf == NULL)
              <a href="../man1/handle_error.1.html">handle_error</a>(1);
           memset(profbuf,0x00,length);

           if ((retval = PAPI_profil(profbuf, length, start, 65536, EventSet,
               PAPI_FP_INS, 1000000, PAPI_PROFIL_POSIX | PAPI_PROFIL_BUCKET_16))
              != PAPI_OK)
              handle_error(retval);

       <b>See</b> <b>also</b>
           <b>PAPI_overflow</b>
           <b>PAPI_sprofil</b>
</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for PAPI from the source code.

Version 7.1.0.0                                  Thu Dec 14 2023                                  <u><a href="../man3/PAPI_profil.3.html">PAPI_profil</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>