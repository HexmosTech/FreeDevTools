<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tracefs_hist_add_sort_key, tracefs_hist_set_sort_key, tracefs_hist_sort_key_direction,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtracefs-doc">libtracefs-doc_1.8.1-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tracefs_hist_add_sort_key, tracefs_hist_set_sort_key, tracefs_hist_sort_key_direction,
       tracefs_hist_add_name, tracefs_hist_append_filter, tracefs_hist_echo_cmd, tracefs_hist_command,
       tracefs_hist_get_name, tracefs_hist_get_event, tracefs_hist_get_system - Update and describe an event
       histogram

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tracefs.h&gt;</b>

       int <b>tracefs_hist_add_sort_key</b>(struct tracefs_hist *<u>hist</u>,
                                     const char *<u>sort_key</u>);

       int <b>tracefs_hist_set_sort_key</b>(struct tracefs_hist *<u>hist</u>,
                                     const char *<u>sort_key</u>, <u>...</u>);
       int <b>tracefs_hist_sort_key_direction</b>(struct tracefs_hist *<u>hist</u>,
                                           const char *<u>sort_key</u>,
                                           enum tracefs_hist_sort_direction <u>dir</u>);

       int <b>tracefs_hist_add_name</b>(struct tracefs_hist *<u>hist</u>, const char *<u>name</u>);

       int <b>tracefs_hist_append_filter</b>(struct tracefs_hist *<u>hist</u>,
                                      enum tracefs_filter <u>type</u>,
                                      const char *<u>field</u>,
                                      enum tracefs_compare <u>compare</u>,
                                      const char *<u>val</u>);

       int <b>tracefs_hist_echo_cmd</b>(struct trace_seq *<u>s</u>, struct tracefs_instance *<u>instance</u>,
                                 struct tracefs_hist *<u>hist</u>,
                                 enum tracefs_hist_command <u>command</u>);

       int <b>tracefs_hist_command</b>(struct tracefs_instance *<u>instance</u>,
                                struct tracefs_hist *<u>hist</u>,
                                enum tracefs_hist_command <u>command</u>);

       const char *<b>tracefs_hist_get_name</b>(struct tracefs_hist *<u>hist</u>);

       const char *<b>tracefs_hist_get_event</b>(struct tracefs_hist *<u>hist</u>);

       const char *<b>tracefs_hist_get_system</b>(struct tracefs_hist *<u>hist</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Event histograms are created by the trigger file in the event directory. The syntax can be complex and
       difficult to get correct. This API handles the syntax, and facilitates the creation and interaction with
       the event histograms. See <b>https://www.kernel.org/doc/html/latest/trace/histogram.html</b> for more
       information.

       <b>tracefs_hist_add_sort_key</b>() will add a key to sort on. The <u>hist</u> is the histogram descriptor to add the
       sort key to. The <u>sort_key</u> is a string that must match either an already defined key of the histogram, or
       an already defined value. If <u>hist</u> already has sorting keys (previously added) the new <u>sort_key</u> will have
       lower priority(be secondary or so on) when sorting.

       <b>tracefs_hist_set_sort_key</b>() will reset the list of key to sort on. The <u>hist</u> is the histogram descriptor
       to reset the sort key to. The <u>sort_key</u> is a string that must match either an already defined key of the
       histogram, or an already defined value. Multiple sort keys may be added to denote a secondary, sort order
       and so on, but all sort keys must match an existing key or value, or be TRACEFS_HIST_HITCOUNT. The last
       parameter of <b>tracefs_hist_add_sort_key</b>() must be NULL.

       <b>tracefs_hist_sort_key_direction</b>() allows to change the direction of an existing sort key of <u>hist</u>. The
       <u>sort_key</u> is the sort key to change, and <u>dir</u> can be either TRACEFS_HIST_SORT_ASCENDING or
       TRACEFS_HIST_SORT_DESCENDING, to make the direction of the sort key either ascending or descending
       respectively.

       <b>tracefs_hist_add_name</b>() adds a name to a histogram. A histogram may be named and if the name matches
       between more than one event, and they have compatible keys, the multiple histograms with the same name
       will be merged into a single histogram (shown by either eventâ€™s hist file). The <u>hist</u> is the histogram to
       name, and the <u>name</u> is the name to give it.

       <b>tracefs_hist_append_filter</b>() creates a filter or appends to it for the histogram event. Depending on
       <u>type</u>, it will build a string of tokens for parenthesis or logic statements, or it may add a comparison of
       <u>field</u> to <u>val</u> based on <u>compare</u>.

       If <u>type</u> is: <b>TRACEFS_FILTER_COMPARE</b> - See below <b>TRACEFS_FILTER_AND</b> - Append "&amp;&amp;" to the filter
       <b>TRACEFS_FILTER_OR</b> - Append "||" to the filter <b>TRACEFS_FILTER_NOT</b> - Append "!" to the filter
       <b>TRACEFS_FILTER_OPEN_PAREN</b> - Append "(" to the filter <b>TRACEFS_FILTER_CLOSE_PAREN</b> - Append ")" to the
       filter

       <u>field</u>, <u>compare</u>, and <u>val</u> are ignored unless <u>type</u> is equal to <b>TRACEFS_FILTER_COMPARE</b>, then <u>compare</u> will be
       used for the following:

       <b>TRACEFS_COMPARE_EQ</b> - <u>field</u> == <u>val</u>

       <b>TRACEFS_COMPARE_NE</b> - <u>field</u> != <u>val</u>

       <b>TRACEFS_COMPARE_GT</b> - <u>field</u> &gt; <u>val</u>

       <b>TRACEFS_COMPARE_GE</b> - <u>field</u> &gt;= <u>val</u>

       <b>TRACEFS_COMPARE_LT</b> - <u>field</u> &lt; <u>val</u>

       <b>TRACEFS_COMPARE_LE</b> - <u>field</u> &lt;= <u>val</u>

       <b>TRACEFS_COMPARE_RE</b> - <u>field</u> ~ "<u>val</u>" : where <u>field</u> is a string.

       <b>TRACEFS_COMPARE_AND</b> - <u>field</u> &amp; <u>val</u> : where <u>field</u> is a flags field.

       <b>trace_hist_echo_cmd</b>() prints the commands needed to create the given histogram in the given <u>instance</u>, or
       NULL for the top level, into the <u>seq</u>. The command that is printed is described by <u>command</u> and shows the
       functionality that would be done by <b><a href="../man3/tracefs_hist_command.3.html">tracefs_hist_command</a></b>(3).

       <b>tracefs_hist_command</b>() is called to process a command on the histogram <u>hist</u> for its event in the given
       <u>instance</u>, or NULL for the top level. The <u>cmd</u> can be one of:

       <b>TRACEFS_HIST_CMD_START</b> or zero to start execution of the histogram.

       <b>TRACEFS_HIST_CMD_PAUSE</b> to pause the given histogram.

       <b>TRACEFS_HIST_CMD_CONT</b> to continue a paused histogram.

       <b>TRACEFS_HIST_CMD_CLEAR</b> to reset the values of a histogram.

       <b>TRACEFS_HIST_CMD_DESTROY</b> to destroy the histogram (undo a START).

       The below functions are wrappers to tracefs_hist_command() to make the calling conventions a bit easier
       to understand what is happening.

</pre><h4><b>KEY</b> <b>TYPES</b></h4><pre>
       <b>tracefs_hist_alloc_nd</b>() and <b>tracefs_hist_add_key</b>() both add a key and requires that key to have a type.
       The types may be:

       <b>TRACEFS_HIST_KEY_NORMAL</b> or zero (0) which is to not modify the type.

       <b>TRACEFS_HIST_KEY_HEX</b> to display the key in hex.

       <b>TRACEFS_HIST_KEY_SYM</b> to display the key as a kernel symbol (if found). If the key is an address, this is
       useful as it will display the function names instead of just a number.

       <b>TRACEFS_HIST_KEY_SYM_OFFSET</b> similar to <b>TRACEFS_HIST_KEY_SYM</b> but will also include the offset of the
       function to match the exact address.

       <b>TRACEFS_HIST_KEY_SYSCALL</b> If the key is a system call "id" (the number passed from user space to the
       kernel to tell it what system call it is calling), then the name of the system call is displayed.

       <b>TRACEFS_HIST_KEY_EXECNAME</b> If "common_pid" is the key (the pid of the executing task), instead of showing
       the number, show the name of the running task.

       <b>TRACEFS_HIST_KEY_LOG</b> will display the key in a binary logarithmic scale.

       <b>TRACEFS_HIST_KEY_USECS</b> for use with "common_timestamp" or TRACEFS_HIST_TIMESTAMP, in which case it will
       show the timestamp in microseconds instead of nanoseconds.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>tracefs_hist_get_name</b>() returns the name of the histogram or NULL on error. The returned string belongs
       to the histogram object and is freed with the histogram by <b>tracefs_hist_free</b>().

       <b>tracefs_hist_get_event</b>() returns the event name of the histogram or NULL on error. The returned string
       belongs to the histogram object and is freed with the histogram by <b>tracefs_hist_free</b>().

       <b>tracefs_hist_get_system</b>() returns the system name of the histogram or NULL on error. The returned string
       belongs to the histogram object and is freed with the histogram by <b>tracefs_hist_free</b>().

       <b>tracefs_hist_alloc_nd</b>() returns an allocated histogram descriptor which must be freed by
       <b>tracefs_hist_free</b>() or NULL on error.

       <b>tracefs_hist_get_name</b>(), <b>tracefs_hist_get_event</b>() and <b>tracefs_hist_get_system</b>() return strings owned by
       the histogram object.

       All the other functions return zero on success or -1 on error.

</pre><h4><b>EXAMPLE</b></h4><pre>
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;tracefs.h&gt;

           enum commands {
                   START,
                   PAUSE,
                   CONT,
                   RESET,
                   DELETE,
                   SHOW,
           };

           static void parse_system_event(char *group, char **system, char **event)
           {
                   *system = strtok(group, "/");
                   *event = strtok(NULL, "/");
                   if (!*event) {
                           *event = *system;
                           *system = NULL;
                   }
           }

           static int parse_keys(char *keys, struct tracefs_hist_axis **axes)
           {
                   char *sav = NULL;
                   char *key;
                   int cnt = 0;

                   for (key = strtok_r(keys, ",", &amp;sav); key; key = strtok_r(NULL, ",", &amp;sav)) {
                           struct tracefs_hist_axis *ax;
                           char *att;

                           ax = realloc(*axes, sizeof(*ax) * (cnt + 2));
                           if (!ax) {
                                   perror("Failed to allocate axes");
                                   exit(-1);
                           }
                           ax[cnt].key = key;
                           ax[cnt].type = 0;
                           ax[cnt + 1].key = NULL;
                           ax[cnt + 1].type = 0;

                           *axes = ax;

                           att = strchr(key, '.');
                           if (att) {
                                   *att++ = '\0';
                                   if (strcmp(att, "hex") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_HEX;
                                   else if (strcmp(att, "sym") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_SYM;
                                   else if (strcmp(att, "sym_offset") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_SYM_OFFSET;
                                   else if (strcmp(att, "syscall") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_SYSCALL;
                                   else if (strcmp(att, "exec") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_EXECNAME;
                                   else if (strcmp(att, "log") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_LOG;
                                   else if (strcmp(att, "usecs") == 0)
                                           ax[cnt].type = TRACEFS_HIST_KEY_USECS;
                                   else {
                                           fprintf(stderr, "Undefined attribute '%s'\n", att);
                                           fprintf(stderr,"  Acceptable attributes:\n");
                                           fprintf(stderr,"    hex, sym, sym_offset, syscall, exe, log, usecs\n");
                                           exit(-1);
                                   }
                           }
                           cnt++;
                   }
                   return cnt;
           }

           static void process_hist(enum commands cmd, const char *instance_name,
                                    char *group, char *keys, char *vals, char *sort,
                                    char *ascend, char *desc)
           {
                   struct tracefs_instance *instance = NULL;
                   struct tracefs_hist *hist;
                   struct tep_handle *tep;
                   struct tracefs_hist_axis *axes = NULL;
                   char *system;
                   char *event;
                   char *sav;
                   char *val;
                   int ret;
                   int cnt;

                   if (instance_name) {
                           instance = tracefs_instance_create(instance_name);
                           if (!instance) {
                                   fprintf(stderr, "Failed instance create\n");
                                   exit(-1);
                           }
                   }

                   tep = tracefs_local_events(NULL);
                   if (!tep) {
                           perror("Could not read events");
                           exit(-1);
                   }

                   parse_system_event(group, &amp;system, &amp;event);

                   if (cmd == SHOW) {
                           char *content;
                           content = tracefs_event_file_read(instance, system, event,
                                                             "hist", NULL);
                           if (!content) {
                                   perror("Reading hist file");
                                   exit(-1);
                           }
                           printf("%s\n", content);
                           free(content);
                           return;
                   }

                   if (!keys) {
                           fprintf(stderr, "Command needs -k option\n");
                           exit(-1);
                   }

                   cnt = parse_keys(keys, &amp;axes);
                   if (!cnt) {
                           fprintf(stderr, "No keys??\n");
                           exit(-1);
                   }

                   /* Show examples of hist1d and hist2d */
                   switch (cnt) {
                   case 1:
                           hist = tracefs_hist_alloc(tep, system, event,
                                                     axes[0].key, axes[0].type);
                           break;
                   case 2:
                           hist = tracefs_hist_alloc_2d(tep, system, event,
                                                        axes[0].key, axes[0].type,
                                                        axes[1].key, axes[1].type);
                           break;
                   default:
                           /* Really, 1 and 2 could use this too */
                           hist = tracefs_hist_alloc_nd(tep, system, event, axes);
                   }
                   if (!hist) {
                           fprintf(stderr, "Failed hist create\n");
                           exit(-1);
                   }

                   if (vals) {
                           sav = NULL;
                           for (val = strtok_r(vals, ",", &amp;sav); val; val = strtok_r(NULL, ",", &amp;sav)) {
                                   ret = tracefs_hist_add_value(hist, val);
                                   if (ret) {
                                           fprintf(stderr, "Failed to add value %s\n", val);
                                           exit(-1);
                                   }
                           }
                   }

                   if (sort) {
                           sav = NULL;
                           for (val = strtok_r(sort, ",", &amp;sav); val; val = strtok_r(NULL, ",", &amp;sav)) {
                                   ret = tracefs_hist_add_sort_key(hist, val);
                                   if (ret) {
                                           fprintf(stderr, "Failed to add sort key/val %s\n", val);
                                           exit(-1);
                                   }
                           }
                   }

                   if (ascend) {
                           sav = NULL;
                           for (val = strtok_r(ascend, ",", &amp;sav); val; val = strtok_r(NULL, ",", &amp;sav)) {
                                   ret = tracefs_hist_sort_key_direction(hist, val, TRACEFS_HIST_SORT_ASCENDING);
                                   if (ret) {
                                           fprintf(stderr, "Failed to add ascending key/val %s\n", val);
                                           exit(-1);
                                   }
                           }
                   }

                   if (desc) {
                           sav = NULL;
                           for (val = strtok_r(desc, ",", &amp;sav); val; val = strtok_r(NULL, ",", &amp;sav)) {
                                   ret = tracefs_hist_sort_key_direction(hist, val, TRACEFS_HIST_SORT_DESCENDING);
                                   if (ret) {
                                           fprintf(stderr, "Failed to add descending key/val %s\n", val);
                                           exit(-1);
                                   }
                           }
                   }

                   tracefs_error_clear(instance);

                   switch (cmd) {
                   case START:
                           ret = tracefs_hist_start(instance, hist);
                           if (ret) {
                                   char *err = tracefs_error_last(instance);
                                   if (err)
                                           fprintf(stderr, "\n%s\n", err);
                           }
                           break;
                   case PAUSE:
                           ret = tracefs_hist_pause(instance, hist);
                           break;
                   case CONT:
                           ret = tracefs_hist_continue(instance, hist);
                           break;
                   case RESET:
                           ret = tracefs_hist_reset(instance, hist);
                           break;
                   case DELETE:
                           ret = tracefs_hist_destroy(instance, hist);
                           break;
                   case SHOW:
                           /* Show was already done */
                           break;
                   }
                   if (ret)
                           fprintf(stderr, "Failed: command\n");
                   exit(ret);
           }

           int main (int argc, char **argv, char **env)
           {
                   enum commands cmd;
                   char *instance = NULL;
                   char *cmd_str;
                   char *event = NULL;
                   char *keys = NULL;
                   char *vals = NULL;
                   char *sort = NULL;
                   char *desc = NULL;
                   char *ascend = NULL;

                   if (argc &lt; 2) {
                           fprintf(stderr, "usage: %s command [-B instance][-e [system/]event][-k keys][-v vals][-s sort]\n", argv[0]);
                           fprintf(stderr, "      [-a ascending][-d descending]\n");
                           exit(-1);
                   }

                   cmd_str = argv[1];

                   if (!strcmp(cmd_str, "start"))
                           cmd = START;
                   else if (!strcmp(cmd_str, "pause"))
                           cmd = PAUSE;
                   else if (!strcmp(cmd_str, "cont"))
                           cmd = CONT;
                   else if (!strcmp(cmd_str, "reset"))
                           cmd = RESET;
                   else if (!strcmp(cmd_str, "delete"))
                           cmd = DELETE;
                   else if (!strcmp(cmd_str, "show"))
                           cmd = SHOW;
                   else {
                           fprintf(stderr, "Unknown command %s\n", cmd_str);
                           exit(-1);
                   }

                   for (;;) {
                           int c;

                           c = getopt(argc - 1, argv + 1, "e:k:v:B:s:d:a:");
                           if (c == -1)
                                   break;

                           switch (c) {
                           case 'e':
                                   event = optarg;
                                   break;
                           case 'k':
                                   keys = optarg;
                                   break;
                           case 'v':
                                   vals = optarg;
                                   break;
                           case 'B':
                                   instance = optarg;
                                   break;
                           case 's':
                                   sort = optarg;
                                   break;
                           case 'd':
                                   desc = optarg;
                                   break;
                           case 'a':
                                   ascend = optarg;
                                   break;
                           }
                   }
                   if (!event) {
                           event = "kmem/kmalloc";
                           if (!keys)
                                   keys = "call_site.sym,bytes_req";
                           if (!vals)
                                   vals = "bytes_alloc";
                           if (!sort)
                                   sort = "bytes_req,bytes_alloc";
                           if (!desc)
                                   desc = "bytes_alloc";
                   }
                   process_hist(cmd, instance, event, keys, vals, sort, ascend, desc);
           }

</pre><h4><b>FILES</b></h4><pre>
           <b>tracefs.h</b>
                   Header file to include in order to have access to the library APIs.
           <b>-ltracefs</b>
                   Linker switch to add when building a program that uses the library.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/libtracefs.3.html">libtracefs</a></b>(3), <b><a href="../man3/libtraceevent.3.html">libtraceevent</a></b>(3), <b><a href="../man1/trace-cmd.1.html">trace-cmd</a></b>(1), <b><a href="../man3/tracefs_hist_pause.3.html">tracefs_hist_pause</a></b>(3), <b><a href="../man3/tracefs_hist_continue.3.html">tracefs_hist_continue</a></b>(3),
       <b><a href="../man3/tracefs_hist_reset.3.html">tracefs_hist_reset</a></b>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
           <b>Steven</b> <b>Rostedt</b> &lt;<b><a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a></b>[1]&gt;
           <b>Tzvetomir</b> <b>Stoyanov</b> &lt;<b><a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a></b>[2]&gt;
           <b>sameeruddin</b> <b>shaik</b> &lt;<b><a href="mailto:sameeruddin.shaik8@gmail.com">sameeruddin.shaik8@gmail.com</a></b>[3]&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<b><a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a></b>[4]&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       libtracefs is Free Software licensed under the GNU LGPL 2.1

</pre><h4><b>RESOURCES</b></h4><pre>
       <b>https://git.kernel.org/pub/scm/libs/libtrace/libtracefs.git/</b>

</pre><h4><b>COPYING</b></h4><pre>
       Copyright (C) 2020 VMware, Inc. Free use of this software is granted under the terms of the GNU Public
       License (GPL).

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a>
           <a href="mailto:rostedt@goodmis.org">mailto:rostedt@goodmis.org</a>

        2. <a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a>
           <a href="mailto:tz.stoyanov@gmail.com">mailto:tz.stoyanov@gmail.com</a>

        3. <a href="mailto:sameeruddin.shaik8@gmail.com">sameeruddin.shaik8@gmail.com</a>
           <a href="mailto:sameeruddin.shaik8@gmail.com">mailto:sameeruddin.shaik8@gmail.com</a>

        4. <a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a>
           <a href="mailto:linux-trace-devel@vger.kernel.org">mailto:linux-trace-devel@vger.kernel.org</a>

libtracefs 1.8.1                                   06/05/2025                                      <u><a href="../man3/LIBTRACEFS.3.html">LIBTRACEFS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>