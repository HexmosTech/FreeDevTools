<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PAPI_sprofil - Generate PC histogram data from multiple code regions where hardware counter overflow</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpapi-dev">libpapi-dev_7.1.0-5build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PAPI_sprofil - Generate PC histogram data from multiple code regions where hardware counter overflow
       occurs.

</pre><h4><b>SYNOPSIS</b></h4><pre>
</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       <b>C</b> <b>Interface:</b>
           #include &lt;<b>papi.h</b>&gt;
           int <b>PAPI_sprofil(</b> <b>PAPI_sprofil_t</b> <b>*</b> <b>prof,</b> <b>int</b> <b>profcnt,</b> <b>int</b> <b>EventSet,</b> <b>int</b> <b>EventCode,</b> <b>int</b> <b>threshold,</b> <b>int</b>
           <b>flags</b> <b>)</b>;

       <b>Parameters</b>
           <u>*prof</u> pointer to an array of <b>PAPI_sprofil_t</b> structures. Each copy of the structure contains the
           following:

           • buf  -- pointer to a buffer of bufsiz bytes in which the histogram counts are stored in an array of
             unsigned short, unsigned int, or unsigned long long values, or 'buckets'. The size of  the  buckets
             is determined by values in the flags argument.
           • bufsiz  --  the  size  of the histogram buffer in bytes. It is computed from the length of the code
             region to be profiled, the size of the buckets, and the scale factor as discussed below.
           • offset -- the start address of the region to be profiled.
           • scale -- broadly and historically speaking, a contraction factor that indicates  how  much  smaller
             the  histogram buffer is than the region to be profiled. More precisely, scale is interpreted as an
             unsigned 16-bit fixed-point fraction with the decimal point implied on the left. Its value  is  the
             reciprocal of the number of addresses in a subdivision, per counter of histogram buffer.
           <u>profcnt</u> number of structures in the prof array for hardware profiling.
           <u>EventSet</u>  The  PAPI  EventSet  to  profile. This EventSet is marked as profiling-ready, but profiling
           doesn't actually start until a <b>PAPI_start()</b> call is issued.
           <u>EventCode</u> Code of the Event in the EventSet to profile. This event must already be a  member  of  the
           EventSet.
           <u>threshold</u>  minimum number of events that must occur before the PC is sampled. If hardware overflow is
           supported for your component, this threshold will trigger an interrupt when reached.  Otherwise,  the
           counters  will  be sampled periodically and the PC will be recorded for the first sample that exceeds
           the threshold. If the value of threshold is 0, profiling will be disabled for this event.
           <u>flags</u> bit pattern to control profiling  behavior.  Defined  values  are  given  in  a  table  in  the
           documentation for PAPI_pofil

       <b>Return</b> <b>values</b>
           <u>Return</u>  values  for  <b>PAPI_sprofil()</b> are identical to those for <b>PAPI_profil</b>. Please refer to that page
           for further details.

       <b>PAPI_sprofil()</b> is a structure driven profiler that profiles one or more disjoint regions  of  code  in  a
       single  call.  It  accepts  a  pointer  to  a  preinitialized  array of sprofil structures, and initiates
       profiling based on the values contained in the array. Each structure in the array defines  the  profiling
       parameters that are normally passed to <b>PAPI_profil()</b>. For more information on profiling, <b>PAPI_profil</b>

       <b>Example:</b>

           int retval;
           unsigned long length;
           PAPI_exe_info_t *prginfo;
           unsigned short *profbuf1, *profbuf2, profbucket;
           PAPI_sprofil_t sprof[3];

           prginfo = PAPI_get_executable_info();
           if (prginfo == NULL) handle_error( NULL );
           length = (unsigned long)(prginfo-&gt;text_end - prginfo-&gt;text_start);
           // Allocate 2 buffers of equal length
           profbuf1 = (unsigned short *)malloc(length);
           profbuf2 = (unsigned short *)malloc(length);
           if ((profbuf1 == NULL) || (profbuf2 == NULL))
             handle_error( NULL );
           memset(profbuf1,0x00,length);
           memset(profbuf2,0x00,length);
           // First buffer
           sprof[0].pr_base = profbuf1;
           sprof[0].pr_size = length;
           sprof[0].pr_off = (vptr_t) DO_FLOPS;
           sprof[0].pr_scale = 0x10000;
           // Second buffer
           sprof[1].pr_base = profbuf2;
           sprof[1].pr_size = length;
           sprof[1].pr_off = (vptr_t) DO_READS;
           sprof[1].pr_scale = 0x10000;
           // Overflow bucket
           sprof[2].pr_base = profbucket;
           sprof[2].pr_size = 1;
           sprof[2].pr_off = 0;
           sprof[2].pr_scale = 0x0002;
           retval = PAPI_sprofil(sprof, EventSet, PAPI_FP_INS, 1000000,
           PAPI_PROFIL_POSIX | PAPI_PROFIL_BUCKET_16)) != PAPI_OK)
           if ( retval != PAPI_OK ) handle_error( retval );

       <b>See</b> <b>also</b>
           <b>PAPI_overflow</b>
           <b>PAPI_get_executable_info</b>
           <b>PAPI_profil</b>
</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for PAPI from the source code.

Version 7.1.0.0                                  Thu Dec 14 2023                                 <u><a href="../man3/PAPI_sprofil.3.html">PAPI_sprofil</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>