<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::Basic -- Basic utility functions for PDL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/pdl">pdl_2.100-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::Basic -- Basic utility functions for PDL

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module contains basic utility functions for creating and manipulating ndarrays. Most of these
       functions are simplified interfaces to the more flexible functions in the modules PDL::Primitive and
       PDL::Slices.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PDL::Basic;

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>xvals</b>
       Fills an ndarray with X index values.  Uses similar specifications to "zeroes" and
       "new_from_specification".

       CAVEAT:

       If you use the single argument ndarray form (top row in the usage table) the output will have the same
       type as the input, except that as of 2.064, the returned ndarray will default to at least type "double".
       As of 2.085, this will respect a given type as in the second or third form below.

        $x = xvals($somearray); # at least type double
        $x = xvals([OPTIONAL TYPE],$nx,$ny,$nz...);
        $x = xvals([OPTIONAL TYPE], $somarray-&gt;dims);

       etc. see zeroes.

         pdl&gt; print xvals zeroes(5,10)
         [
          [0 1 2 3 4]
          [0 1 2 3 4]
          [0 1 2 3 4]
          [0 1 2 3 4]
          [0 1 2 3 4]
          [0 1 2 3 4]
          [0 1 2 3 4]
          [0 1 2 3 4]
          [0 1 2 3 4]
          [0 1 2 3 4]
         ]

   <b>yvals</b>
       Fills an ndarray with Y index values.  See the CAVEAT for "xvals".

        $x = yvals($somearray); yvals(inplace($somearray));
        $x = yvals([OPTIONAL TYPE],$nx,$ny,$nz...);

       etc. see zeroes.

        pdl&gt; print yvals zeroes(5,10)
        [
         [0 0 0 0 0]
         [1 1 1 1 1]
         [2 2 2 2 2]
         [3 3 3 3 3]
         [4 4 4 4 4]
         [5 5 5 5 5]
         [6 6 6 6 6]
         [7 7 7 7 7]
         [8 8 8 8 8]
         [9 9 9 9 9]
        ]

   <b>zvals</b>
       Fills an ndarray with Z index values.  See the CAVEAT for "xvals".

        $x = zvals($somearray); zvals(inplace($somearray));
        $x = zvals([OPTIONAL TYPE],$nx,$ny,$nz...);

       etc. see zeroes.

        pdl&gt; print zvals zeroes(3,4,2)
        [
         [
          [0 0 0]
          [0 0 0]
          [0 0 0]
          [0 0 0]
         ]
         [
          [1 1 1]
          [1 1 1]
          [1 1 1]
          [1 1 1]
         ]
        ]

   <b>xlinvals</b>
       X axis values between endpoints (see "xvals").  Works with dim-length of one as of 2.093, giving the
       starting point.

        $w = zeroes(100,100);
        $x = $w-&gt;xlinvals(0.5,1.5);
        $y = $w-&gt;ylinvals(-2,-1);
        # calculate Z for X between 0.5 and 1.5 and
        # Y between -2 and -1.
        $z = f($x,$y);

       "xlinvals", "ylinvals" and "zlinvals" return an ndarray with the same shape as their first argument and
       linearly scaled values between the two other arguments along the given axis.

   <b>ylinvals</b>
       Y axis values between endpoints (see "yvals").

       See "xlinvals" for more information.

   <b>zlinvals</b>
       Z axis values between endpoints (see "zvals").

       See "xlinvals" for more information.

   <b>xlogvals</b>
       X axis values logarithmically spaced between endpoints (see "xvals").  Works with dim-length of one as of
       2.093, giving the starting point.

        $w = zeroes(100,100);
        $x = $w-&gt;xlogvals(1e-6,1e-3);
        $y = $w-&gt;ylinvals(1e-4,1e3);
        # calculate Z for X between 1e-6 and 1e-3 and
        # Y between 1e-4 and 1e3.
        $z = f($x,$y);

       "xlogvals", "ylogvals" and "zlogvals" return an ndarray with the same shape as their first argument and
       logarithmically scaled values between the two other arguments along the given axis.

   <b>ylogvals</b>
       Y axis values logarithmically spaced between endpoints (see "yvals").

       See "xlogvals" for more information.

   <b>zlogvals</b>
       Z axis values logarithmically spaced between endpoints (see "zvals").

       See "xlogvals" for more information.

   <b>allaxisvals</b>
       Synonym for "ndcoords" - enumerates all coordinates in a PDL or dim list, adding an extra dim on the
       front to accommodate the vector coordinate index (the form expected by "indexND", "range", and
       "interpND").  See "ndcoords" for more detail.

         $indices = allaxisvals($pdl);
         $indices = allaxisvals(@dimlist);
         $indices = allaxisvals($type,@dimlist);

   <b>ndcoords</b>
       Enumerate pixel coordinates for an N-D ndarray

       Returns an enumerated list of coordinates suitable for use in indexND or range: you feed in a dimension
       list and get out an ndarray whose 0th dimension runs over dimension index and whose 1st through Nth
       dimensions are the dimensions given in the input.  If you feed in an ndarray instead of a perl list, then
       the dimension list is used, as in "xvals" etc.

       Unlike "xvals" etc., if you supply an ndarray input, you get out an ndarray of the default ndarray type:
       double.   This causes less surprises than the previous default of keeping the data type of the input
       ndarray since that rarely made sense in most usages.

         $indices = ndcoords($pdl);
         $indices = ndcoords(@dimlist);
         $indices = ndcoords($type,@dimlist);

         pdl&gt; print ndcoords(2,3)

         [
          [
           [0 0]
           [1 0]
          ]
          [
           [0 1]
           [1 1]
          ]
          [
           [0 2]
           [1 2]
          ]
         ]

         pdl&gt; $w = zeroes(byte,2,3);        # $w is a 2x3 byte ndarray
         pdl&gt; $y = ndcoords($w);            # $y inherits $w's type
         pdl&gt; $c = ndcoords(long,$w-&gt;dims); # $c is a long ndarray, same dims as $y
         pdl&gt; help $y;
         This variable is   Byte D [2,2,3]              P            0.01Kb
         pdl&gt; help $c;
         This variable is   Long D [2,2,3]              P            0.05Kb

   <b>hist</b>
       Create histogram of an ndarray

        $hist = hist($data);
        ($xvals,$hist) = hist($data);

       or

        $hist = hist($data,$min,$max,$step);
        ($xvals,$hist) = hist($data,[$min,$max,$step]);

       If "hist" is run in list context, $xvals gives the computed bin centres as double values.

       A nice idiom (with PDL::Graphics::Simple) is

        bins hist($data), {yrange=&gt;[0,$data-&gt;<a href="../man0/dim.0.html">dim</a>(0)]};  # Plot histogram

        pdl&gt; p $y
        [13 10 13 10 9 13 9 12 11 10 10 13 7 6 8 10 11 7 12 9 11 11 12 6 12 7]
        pdl&gt; $h = hist $y,0,20,1; # hist with step 1, min 0 and 20 bins
        pdl&gt; p $h
        [0 0 0 0 0 0 2 3 1 3 5 4 4 4 0 0 0 0 0 0]

   <b>whist</b>
       Create a weighted histogram of an ndarray

        $hist = whist($data, $wt, [$min,$max,$step]);
        ($xvals,$hist) = whist($data, $wt, [$min,$max,$step]);

       If requested, $xvals gives the computed bin centres as type double values.  $data and $wt should have the
       same dimensionality and extents.

       A nice idiom (with PDL::Graphics::Simple) is

        bin whist $data, $wt;  # Plot histogram
        bins whist($data, $wt), {yrange=&gt;[0,$data-&gt;<a href="../man0/dim.0.html">dim</a>(0)]};  # Plot histogram

        pdl&gt; p $y
        [13 10 13 10 9 13 9 12 11 10 10 13 7 6 8 10 11 7 12 9 11 11 12 6 12 7]
        pdl&gt; $wt = grandom($y-&gt;nelem)
        pdl&gt; $h = whist $y, $wt, 0, 20, 1 # hist with step 1, min 0 and 20 bins
        pdl&gt; p $h
        [0 0 0 0 0 0 -0.49552342  1.7987439 0.39450696  4.0073722 -2.6255299 -2.5084501  2.6458365  4.1671676 0 0 0 0 0 0]

   <b>sequence</b>
       Create array filled with a sequence of values

        $w = sequence($y); $w = sequence [OPTIONAL TYPE], @dims;

       etc. see zeroes.

        pdl&gt; p <a href="../man10/sequence.10.html">sequence</a>(10)
        [0 1 2 3 4 5 6 7 8 9]
        pdl&gt; p sequence(3,4)
        [
         [ 0  1  2]
         [ 3  4  5]
         [ 6  7  8]
         [ 9 10 11]
        ]

   <b>rvals</b>
       Fills an ndarray with radial distance values from some centre.

        $r = rvals $ndarray,{OPTIONS};
        $r = rvals [OPTIONAL TYPE],$nx,$ny,...{OPTIONS};

        Options:

        Centre =&gt; [$x,$y,$z...] # Specify centre
        Center =&gt; [$x,$y.$z...] # synonym.
        Center =&gt; $c            # as 1d array
        Squared =&gt; 1 # return distance squared (i.e., don't take the square root)

        pdl&gt; print rvals long,7,7,{Centre=&gt;[2,2]}
        [
         [2 2 2 2 2 3 4]
         [2 1 1 1 2 3 4]
         [2 1 0 1 2 3 4]
         [2 1 1 1 2 3 4]
         [2 2 2 2 2 3 4]
         [3 3 3 3 3 4 5]
         [4 4 4 4 4 5 5]
        ]

       If "Center" is not specified, the midpoint for a given dimension of size "N" is given by  int(N/2)  so
       that the midpoint always falls on an exact pixel point in the data.  For dimensions of even size, that
       means the midpoint is shifted by 1/2 pixel from the true center of that dimension.

       If "Center" has less components than the number of dimensions of the array, its remaining components are
       computed as above. If it has more, a warning is issued.

       Also note that the calculation for "rvals" for integer values does not promote the datatype so you will
       have wraparound when the value calculated for " r**2 " is greater than the datatype can hold.  If you
       need exact values, be sure to use large integer or floating point datatypes.

       For a more general metric, one can define, e.g.,

        sub distance {
          my ($w,$centre,$f) = @_;
          my ($r) = $w-&gt;allaxisvals-$centre;
          $f-&gt;($r);
        }
        sub l1 { sumover(abs($_[0])); }
        sub euclid { use PDL::Math 'pow'; pow(sumover(pow($_[0],2)),0.5); }
        sub linfty { maximum(abs($_[0])); }

       so now

        distance($w, $centre, \&amp;euclid);

       will emulate rvals, while "\&amp;l1" and "\&amp;linfty" will generate other well-known norms.

   <b>axisvals</b>
       Fills an ndarray with index values on Nth dimension

        $z = axisvals ($ndarray, $nth);

       This is the routine, for which "xvals", "yvals" etc are mere shorthands. "axisvals" can be used to fill
       along any dimension, using a parameter.

       See also "allaxisvals", which generates all axis values simultaneously in a form useful for "range",
       "interpND", "indexND", etc.

       Note the 'from specification' style (see zeroes) is not available here, for obvious reasons.

   <b>transpose</b>
       transpose rows and columns.

        $y = transpose($w);

        pdl&gt; $w = sequence(3,2)
        pdl&gt; p $w
        [
         [0 1 2]
         [3 4 5]
        ]
        pdl&gt; p transpose( $w )
        [
         [0 3]
         [1 4]
         [2 5]
        ]

   <b>t</b>
        $pdl = $pdl-&gt;t(SCALAR(conj))
        conj : Conjugate Transpose = 1 | Transpose = 0, default = 0;

       Convenient function for transposing real or complex 2D array(s).  For complex data, if conj is true
       returns conjugate transposed array(s).  Supports broadcasting. Not exported.

       Originally by Gr√©gory Vanuxem.

perl v5.40.1                                       2025-03-27                                    <u>PDL::<a href="../man3pm/Basic.3pm.html">Basic</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>