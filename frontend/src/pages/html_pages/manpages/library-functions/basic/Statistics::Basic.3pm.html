<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statistics::Basic - A collection of very basic statistics modules</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstatistics-basic-perl">libstatistics-basic-perl_1.6611-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Statistics::Basic - A collection of very basic statistics modules

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Statistics::Basic qw(:all);

       These actually return objects, not numbers.  The objects will interpolate as nicely formated numbers
       (using Number::Format).  Or the actual number will be returned when the object is used as a number.

           my $median = median( 1,2,3 );
           my $mean   = mean(  [1,2,3]); # array refs are ok too

           my $variance = variance( 1,2,3 );
           my $stddev   = stddev(   1,2,3 );

       Although passing unblessed numbers and array refs to these functions works, it's sometimes better to pass
       vector objects so the objects can reuse calculated values.

           my $v1       = $mean-&gt;query_vector;
           my $variance = variance( $v1 );
           my $stddev   = stddev(   $v1 );

       Here, the mean used by the variance and the variance used by the standard deviation will not need to be
       recalculated.  Now consider these two calculations.

           my $covariance  = covariance(  [1 .. 3], [1 .. 3] );
           my $correlation = correlation( [1 .. 3], [1 .. 3] );

       The covariance above would need to be recalculated by the correlation when these functions are called
       this way.  But, if we instead built vectors first, that wouldn't happen:

           # $v1 is defined above
           my $v2  = vector(1,2,3);
           my $cov = covariance(  $v1, $v2 );
           my $cor = correlation( $v1, $v2 );

       Now $cor can reuse the variance calculated in $cov.

       All of the functions above return objects that interpolate or evaluate as a single string or as a number.
       Statistics::Basic::LeastSquareFit and Statistics::Basic::Mode are different:

           my $unimodal   = mode(1,2,3,3);
           my $multimodal = mode(1,2,3);

           print "The modes are: $unimodal and $multimodal.\n";
           print "The first is multimodal... " if $unimodal-&gt;is_multimodal;
           print "The second is multimodal.\n" if $multimodal-&gt;is_multimodal;

       In the first case, $unimodal will interpolate as a string <b>and</b> function correctly as a number.  However,
       in the second case, trying to use $multimodal as a number will "croak" an error -- it still interpolates
       fine though.

           my $lsf = leastsquarefit($v1, $v2);

       This $lsf will interpolate fine, showing "LSF( alpha: $alpha, beta: $beta )", but it will "croak" if you
       try to use the object as a number.

           my $v3             = $multimodal-&gt;query;
           my ($alpha, $beta) = $lsf-&gt;query;
           my $average        = $mean-&gt;query;

       All of the objects allow you to explicitly query, if you're not in the mood to use overload.

           my @answers = (
               $mode-&gt;query,
               $median-&gt;query,
               $stddev-&gt;query,
           );

</pre><h4><b>SHORTCUTS</b></h4><pre>
       The following shortcut functions can be used in place of calling the module's "new()" method directly.

       They all take either array refs <b>or</b> lists as arguments, with the exception of the shortcuts that need two
       vectors to process (e.g.  Statistics::Basic::Correlation).

       <b>vector()</b>
           Returns  a  Statistics::Basic::Vector object.  Arguments to "vector()" can be any of: an array ref, a
           list of numbers, or a blessed vector object.  If passed a blessed vector  object,  vector  will  just
           return the vector passed in.

       <b>mean()</b> <b>average()</b> <b>avg()</b>
           Returns a Statistics::Basic::Mean object.  You can choose to call "mean()" as "average()" or "avg()".
           Arguments can be any of: an array ref, a list of numbers, or a blessed vector object.

       <b>median()</b>
           Returns  a  Statistics::Basic::Median  object.   Arguments  can  be  any  of: an array ref, a list of
           numbers, or a blessed vector object.

       <b>mode()</b>
           Returns a Statistics::Basic::Mode object.  Arguments can be any of: an array ref, a list of  numbers,
           or a blessed vector object.

       <b>variance()</b> <b>var()</b>
           Returns  a  Statistics::Basic::Variance  object.   You  can  choose  to call "variance()" as "var()".
           Arguments can be any of: an array ref, a list of numbers, or a blessed vector object.   If  you  will
           also be calculating the mean of the same list of numbers it's recommended to do this:

               my $vec  = vector(1,2,3);
               my $mean = mean($vec);
               my $var  = variance($vec);

           This would also work:

               my $mean = mean(1,2,3);
               my $var  = variance($mean-&gt;query_vector);

           This will calculate the same mean twice:

               my $mean = mean(1,2,3);
               my $var  = variance(1,2,3);

           If you really only need the variance, ignore the above and this is fine:

               my $variance = variance(1,2,3,4,5);

       <b>stddev()</b>
           Returns  a  Statistics::Basic::StdDev  object.   Arguments  can  be  any  of: an array ref, a list of
           numbers, or a blessed vector object.  Pass a vector object to "stddev()" to avoid  recalculating  the
           variance and mean if applicable (see "variance()").

       <b>covariance()</b> <b>cov()</b>
           Returns a Statistics::Basic::Covariance object.  Arguments to "covariance()" or "cov()" must be array
           ref  or  vector  objects.  There must be precisely two arguments (or none, setting the vectors to two
           empty ones), and they must be the same length.

       <b>correlation()</b> <b>cor()</b> <b>corr()</b>
           Returns a Statistics::Basic::Correlation object.  Arguments to  "correlation()"  or  "cor()"/"corr()"
           must  be  array  ref  or vector objects.  There must be precisely two arguments (or none, setting the
           vectors to two empty ones), and they must be the same length.

       <b>leastsquarefit()</b> <b>LSF()</b> <b>lsf()</b>
           Returns   a   Statistics::Basic::LeastSquareFit   object.    Arguments   to   "leastsquarefit()"   or
           "lsf()"/"LSF()" must be array ref or vector objects.  There must be precisely two arguments (or none,
           setting the vectors to two empty ones), and they must be the same length.

       <b>computed()</b>
           Returns  a  Statistics::Basic::ComputedVector object.  Argument must be a blessed vector object.  See
           the section on "COMPUTED VECTORS" for more information on this.

       <b>handle_missing_values()</b> <b>handle_missing()</b>
           Returns two Statistics::Basic::ComputedVector objects.  Arguments to  this  function  should  be  two
           vector arguments.  See the section on "MISSING VALUES" for further information on this function.

</pre><h4><b>COMPUTED</b> <b>VECTORS</b></h4><pre>
       Sometimes  it will be handy to have a vector computed from another (or at least that updates based on the
       first).  Consider the case of outliers:

           my @a = ( (1,2,3) x 7, 15 );
           my @b = ( (1,2,3) x 7 );

           my $v1 = vector(@a);
           my $v2 = vector(@b);
           my $v3 = computed($v1);
              $v3-&gt;set_filter(sub {
                  my $m = mean($v1);
                  my $s = stddev($v1);

                  grep { abs($_-$m) &lt;= $s } @_;
              });

       This filter sets $v3 to always be equal to $v1 such that all the elements that differ from  the  mean  by
       more  than  a  standard deviation are removed.  As such, "$v2" eq "$v3" since 15 is clearly an outlier by
       inspection.

           print "$v1\n";
           print "$v3\n";

       ... prints:

           [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 15]
           [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]

</pre><h4><b>MISSING</b> <b>VALUES</b></h4><pre>
       Something I get asked about quite a lot is, "can S::B handle missing values?"  The  answer  used  to  be,
       "that  really  depends  on your data set, use grep," but I recently decided (5/29/09) that it was time to
       just go ahead and add this feature.

       Strictly speaking, the feature was already there.  You simply need to add a couple filters to your  data.
       See "t/75_filtered_missings.t" for the test example.

       This is what people usually mean when they ask if S::B can "handle" missing data:

           my $v1 = vector(1,2,3,undef,4);
           my $v2 = vector(1,2,3,4, undef);
           my $v3 = computed($v1);
           my $v4 = computed($v2);

           $v3-&gt;set_filter(sub {
               my @v = $v2-&gt;query;
               map {$_[$_]} grep { defined $v[$_] and defined $_[$_] } 0 .. $#_;
           });

           $v4-&gt;set_filter(sub {
               my @v = $v1-&gt;query;
               map {$_[$_]} grep { defined $v[$_] and defined $_[$_] } 0 .. $#_;
           });

           print "$v1 $v2\n"; # prints: [1, 2, 3, _, 4] [1, 2, 3, 4, _]
           print "$v3 $v4\n"; # prints: [1, 2, 3] [1, 2, 3]

       But I've made it even simpler.  Since this is such a common request, I have provided a helper function to
       build the filters automatically:

           my $v1 = vector(1,2,3,undef,4);
           my $v2 = vector(1,2,3,4, undef);

           my ($f1, $f2) = handle_missing_values($v1, $v2);

           print "$f1 $f2\n"; # prints: [1, 2, 3] [1, 2, 3]

       Note  that  in  practice,  you  would  still manipulate (insert, and shift) $v1 and $v2, <u>not</u> the computed
       vectors.  But for correlations and the like, you would use $f1 and $f2.

           $v1-&gt;<a href="../man5/insert.5.html">insert</a>(5);
           $v2-&gt;<a href="../man6/insert.6.html">insert</a>(6);

           my $correlation = correlation($f1, $f2);

       You can still insert on $f1 and $f2, but it updates the input vector rather than the computed one  (which
       is just a filter handler).

</pre><h4><b>REUSE</b> <b>DETAILS</b></h4><pre>
       Most  of the objects have a variety of query functions that allow you to extract the objects used within.
       Although, the objects are smart enough to prevent needless duplication.  That  is,  the  following  would
       test would pass:

           use Statistics::Basic qw(:all);

           my $v1 = vector(1,2,3,4,5);
           my $v2 = vector($v1);
           my $sd = stddev( $v1 );
           my $v3 = $sd-&gt;query_vector;
           my $m1 = mean( $v1 );
           my $m2 = $sd-&gt;query_mean;
           my $m3 = Statistics::Basic::Mean-&gt;new( $v1 );
           my $v4 = $m3-&gt;query_vector;

           use Scalar::Util qw(refaddr);
           use Test; plan tests =&gt; 5;

           ok( refaddr($v1), refaddr($v2) );
           ok( refaddr($v2), refaddr($v3) );
           ok( refaddr($m1), refaddr($m2) );
           ok( refaddr($m2), refaddr($m3) );
           ok( refaddr($v3), refaddr($v4) );

           # this is t/54_* in the distribution

       Also,  note  that the mean is only calculated once even though we've calculated a variance and a standard
       deviation above.

       Suppose you'd like a copy of the Statistics::Basic::Variance object  that  the  Statistics::Basic::StdDev
       object is using.  All of the objects within should be accessible with query functions as follows.

</pre><h4><b>QUERY</b> <b>FUNCTIONS</b></h4><pre>
       <b>query()</b>
           This  method  exists  in  all of the objects.  Statistics::Basic::LeastSquareFit is the only one that
           returns two values (alpha and beta) as a list.  Statistics::Basic::Vector returns either the list  of
           elements  in  the  vector,  or  reference to that array (depending on the context).  All of the other
           "query()" methods return a single number, the number the module purports to calculate.

       <b>query_mean()</b>
           Returns   the   Statistics::Basic::Mean    object    used    by    Statistics::Basic::Variance    and
           Statistics::Basic::StdDev.

       <b>query_mean1()</b>
           Returns   the   first   Statistics::Basic::Mean   object   used   by   Statistics::Basic::Covariance,
           Statistics::Basic::Correlation and Statistics::Basic::LeastSquareFit.

       <b>query_mean2()</b>
           Returns  the  second  Statistics::Basic::Mean  object  used  by  Statistics::Basic::Covariance,   and
           Statistics::Basic::Correlation.

       <b>query_covariance()</b>
           Returns   the   Statistics::Basic::Covariance   object  used  by  Statistics::Basic::Correlation  and
           Statistics::Basic::LeastSquareFit.

       <b>query_variance()</b>
           Returns the Statistics::Basic::Variance object used by Statistics::Basic::StdDev.

       <b>query_variance1()</b>
           Returns the first Statistics::Basic::Variance object used by Statistics::Basic::LeastSquareFit.

       <b>query_vector()</b>
           Returns the Statistics::Basic::Vector object used by any of the single vector modules.

       <b>query_vector1()</b>
           Returns the first Statistics::Basic::Vector object used by any of the two vector modules.

       <b>query_vector2()</b>
           Returns the second Statistics::Basic::Vector object used by any of the two vector modules.

       <b>is_multimodal()</b>
           Statistics::Basic::Mode  objects  sometimes  return  Statistics::Basic::Vector  objects  instead   of
           numbers.  When "is_multimodal()" is true, the mode is a vector, not a scalar.

       <b>y_given_x()</b>
           Statistics::Basic::LeastSquareFit is meant for finding a line of best fit.  This function can be used
           to find the "y" for a given "x" based on the calculated $beta (slope) and $alpha (y-offset).

       <b>x_given_y()</b>
           Statistics::Basic::LeastSquareFit is meant for finding a line of best fit.  This function can be used
           to find the "x" for a given "y" based on the calculated $beta (slope) and $alpha (y-offset).

           This  function  can  produce  divide-by-zero errors since it must divide by the slope to find the "x"
           value.  (The slope should rarely be zero though, that's a vertical line and would represent very  odd
           data points.)

</pre><h4><b>INSERT</b> <b>and</b> <b>SET</b> <b>FUNCTIONS</b></h4><pre>
       These  objects  are all intended to be useful while processing long columns of data, like data you'd find
       in a database.

       <b>insert()</b>
           Vectors try to stay the same size when they accept new elements, FIFO style.

               my $v1 = vector(1,2,3); # a 3 touple
                  $v1-&gt;<a href="../man4/insert.4.html">insert</a>(4); # still a 3 touple

               print "$v1\n"; # prints: [2, 3, 4]

               $v1-&gt;<a href="../man7/insert.7.html">insert</a>(7); # still a 3 touple
               print "$v1\n"; # prints: [3, 4, 7]

           All of the other Statistics::Basic modules have this  function  too.   The  modules  that  track  two
           vectors will need two arguments to insert though.

               my $mean = mean([1,2,3]);
                  $mean-&gt;<a href="../man4/insert.4.html">insert</a>(4);

               print "mean: $mean\n"; # prints 3 ... (2+3+4)/3

               my $correlation = correlation($mean-&gt;query_vector,
                   $mean-&gt;query_vector-&gt;copy);

               print "correlation: $correlation\n"; # 1

               $correlation-&gt;insert(3,4);
               print "correlation: $correlation\n"; # 0.5

           Also, note that the underlying vectors keep track of recalculating automatically.

               my $v = vector(1,2,3);
               my $m = mean($v);
               my $s = stddev($v);

           The mean has not been calculated yet.

               print "$s; $m\n"; # 0.82; 2

           The mean has been calculated once (even though the Statistics::Basic::StdDev uses it).

               $v-&gt;<a href="../man4/insert.4.html">insert</a>(4); print "$s; $m\n"; 0.82; 3
               $m-&gt;<a href="../man5/insert.5.html">insert</a>(5); print "$s; $m\n"; 0.82; 4
               $s-&gt;<a href="../man6/insert.6.html">insert</a>(6); print "$s; $m\n"; 0.82; 5

           The mean has been calculated thrice more and only thrice more.

       <b>append()</b> <b>ginsert()</b>
           You  can  grow  the vectors instead of sliding them (FIFO). For this, use "append()" (or "ginsert()",
           same thing).

               my $v = vector(1,2,3);
               my $m = mean($v);
               my $s = stddev($v);

               $v-&gt;<a href="../man4/append.4.html">append</a>(4); print "$s; $m\n"; 1.12; 2.5
               $m-&gt;<a href="../man5/append.5.html">append</a>(5); print "$s; $m\n"; 1.41; 3
               $s-&gt;<a href="../man6/append.6.html">append</a>(6); print "$s; $m\n"; 1.71; 1.71

               print "$v\n"; # [1, 2, 3, 4, 5, 6]
               print "$s\n"; # 1.71

           Of course, with a correlation, or a covariance, it'd look more like this:

               my $c = correlation([1,2,3], [3,4,5]);
                  $c-&gt;append(7,7);

               print "c=$c\n"; # c=0.98

       <b>set_vector()</b>
           This allows you to set the vector to a known state.  It takes either array ref or vector objects.

               my $v1 = vector(1,2,3);
               my $v2 = $v1-&gt;copy;
                  $v2-&gt;set_vector([4,5,6]);

               my $m = mean();

               $m-&gt;set_vector([1,2,3]);
               $m-&gt;set_vector($v2);

               my $c = correlation();

               $c-&gt;set_vector($v1,$v2);
               $c-&gt;set_vector([1,2,3], [4,5,6]);

       <b>set_size()</b>
           This sets the size of the vector.  When the vector is made bigger, the vector is filled  to  the  new
           length with leading zeros (i.e., they are the first to be kicked out after new "insert()"s.

               my $v = vector(1,2,3);
                  $v-&gt;<a href="../man7/set_size.7.html">set_size</a>(7);

               print "$v\n"; # [0, 0, 0, 0, 1, 2, 3]

               my $m = mean();
                  $m-&gt;<a href="../man7/set_size.7.html">set_size</a>(7);

               print "", $m-&gt;query_vector, "\n";
                # [0, 0, 0, 0, 0, 0, 0]

               my $c = correlation([3],[3]);
                  $c-&gt;<a href="../man7/set_size.7.html">set_size</a>(7);

               print "", $c-&gt;query_vector1, "\n";
               print "", $c-&gt;query_vector2, "\n";
                # [0, 0, 0, 0, 0, 0, 3]
                # [0, 0, 0, 0, 0, 0, 3]

</pre><h4><b>OPTIONS</b></h4><pre>
       Each of the following options can be specified on package import like this.

           use Statistics::Basic qw(unbias=0); # start with unbias disabled
           use Statistics::Basic qw(unbias=1); # start with unbias enabled

       When specified on import, each option has certain defaults.

           use Statistics::Basic qw(unbias); # start with unbias enabled
           use Statistics::Basic qw(nofill); # start with nofill enabled
           use Statistics::Basic qw(toler);  # start with toler disabled
           use Statistics::Basic qw(ipres);  # start with ipres=2

       Additionally,  with  the exception of "ignore_env", they can all be accessed via package variables of the
       same name in all upper case.  Example:

           # code code code

           $Statistics::Basic::UNBIAS = 0; # turn UNBIAS off

           # code code code

           $Statistics::Basic::UNBIAS = 1; # turn it back on

           # code code code

           {
               local $Statistics::Basic::DEBUG_STATS_B = 1; # debug, this block only
           }

       Special   caveat:   "toler"   can   in    fact    be    changed    via    the    package    var    (e.g.,
       "$Statistics::Basic::TOLER=0.0001").   But,  for  speed  reasons,  it  must  be  defined before any other
       packages are imported or it will not actually do anything when changed.

       <b>unbias</b>
           This module uses the <b>sum(X</b> <b>-</b> <b>mean(X))/N</b> definition of variance.

           If   you   wish   to   use   the   <u>unbiased</u>,   <b>sum(X-mean(X)/(N-1)</b>   definition,   then    set    the
           $Statistics::Basic::UNBIAS true (possibly with "use Statistics::Basic qw(unbias)").

           This can be changed at any time with the package variable or at compile time.

           This feature was requested by "Robert McGehee &lt;<a href="mailto:xxxxxxxx@wso.williams.edu">xxxxxxxx@wso.williams.edu</a>&gt;".

           [NOTE  2008-11-06:  &lt;<a href="http://cpanratings.perl.org/dist/Statistics-Basic">http://cpanratings.perl.org/dist/Statistics-Basic</a>&gt;,  this  can  also  be  called
           "<b>population</b> <b>(n)</b>" vs "<b>sample</b> <b>(n-1)</b>" and is indeed fully addressed right here!]

       <b>ipres</b>
           "ipres" defaults to 2.  It is passed to Number::Format as  the  second  argument  to  <b>format_number()</b>
           during string interpolation (see: overload).

       <b>toler</b>
           When set, $Statistics::Basic::TOLER (which is not enabled by default), instructs the stats objects to
           test true when <u>within</u> some tolerable range, pretty much like this:

               sub is_equal {
                   return abs($_[0]-$_[1])&lt;$Statistics::Basic::TOLER
                       if defined($Statistics::Basic::TOLER)

                   return $_[0] == $_[1]
               }

           For  performance  reasons,  this  must  be  defined  before the import of any other Statistics::Basic
           modules or the modules will fail to overload the "==" operator.

           $Statistics::Basic::TOLER totally disabled:

               use Statistics::Basic qw(:all toler);

           $Statistics::Basic::TOLER disabled, but changeable:

               use Statistics::Basic qw(:all toler=0);

               $Statistics::Basic::TOLER = 0.000_001;

           You can <u>change</u> the tolerance at runtime, but it must be set (or unset) at  compile  time  before  the
           packages load.

       <b>nofill</b>
           Normally when you set the size of a vector it automatically fills with zeros on the first-out side of
           the vector.  You can disable the autofilling with this option.  It can be changed at any time.

       <b>debug</b>
           Enable  debugging  with "use Statistics::Basic qw(debug)" or disable a specific level (including 0 to
           disable) with "use Statistics::Basic qw(debug=2)".

           This is also accessible at runtime using $Statistics::Basic::DEBUG_STATS_B and can be switched on and
           off at any time.

       <b>ignore_env</b>
           Normally the defaults for these options can be changed in the environment of the program.  Example:

               UNBIAS=1 perl ./myprog.pl

           This does the same thing as  "$Statistics::Basic::UNBIAS=1"  or  "use  Statistics::Basic  qw(unbias)"
           unless you disable the %ENV checking with this option.

               use Statistics::Basic qw(ignore_env);

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       You can change the defaults (assuming ignore_env is not used) from your bash prompt.  Example:

           DEBUG_STATS_B=1 perl ./myprog.pl

       <b>$ENV{DEBUG_STATS_B}</b>
           Sets the default value of "debug".

       <b>$ENV{UNBIAS}</b>
           Sets the default value of "unbias".

       <b>$ENV{NOFILL}</b>
           Sets the default value of "nofill".

       <b>$ENV{IPRES}</b>
           Sets the default value of "ipres".

       <b>$ENV{TOLER}</b>
           Sets the default value of "toler".

</pre><h4><b>OVERLOADS</b></h4><pre>
       All  of  the objects are true in numeric context.  All of the objects print useful strings when evaluated
       as a string.  Most of the  objects  evaluate  usefully  as  numbers,  although  Statistics::Basic::Vector
       objects,  Statistics::Basic::ComputedVector objects, and Statistics::Basic::LeastSquareFit objects do not
       -- they instead raise an error.

</pre><h4><b>Author's</b> <b>note</b> <b>on</b> <b>Statistics::Descriptive</b></h4><pre>
       I've been asked a couple times now why I don't link to Statistics::Descriptive in my  see  also  section.
       As  a rule, I only link to packages there that I think are related or that I actually used in the package
       construction.  I've never personally used Descriptive, but it surely seems to do quite a lot more.  In  a
       sense, this package really doesn't do statistics, not like a scientist would think about it anyway.  So I
       always figured people could find their own way to Descriptive anyway.

       The one thing this package does do, that I don't think Descriptive does (correct me if I'm wrong) is time
       difference  computations.   If  there are say, 200 things in the mean object, then after inserting (using
       this package) there'll still be 200 things, allowing the computation of a moving average, moving  stddev,
       moving  correlation,  etc.   You might argue that this is rarely needed, but it is really the only time I
       need to compute these things.

         while( $data = $fetch_sth-&gt;fetchrow_arrayref ) {
             $mean-&gt;insert($data);
             $moving_avg_sth-&gt;execute(0 + $mean);
         }

       Since I opened the topic I'd also like to mention that I find this package easier  to  use.   That  is  a
       matter of taste and since I wrote this, you might say I'm a little biased.  Your mileage may vary.

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Miller "&lt;<a href="mailto:jettero@cpan.org">jettero@cpan.org</a>&gt;"

       I  am  using  this software in my own projects...  If you find bugs, please please please let me know. :)
       Actually, let me know if you find it handy at all.  Half the fun of releasing this stuff is knowing  that
       people use it.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2012 Paul Miller -- Licensed under the LGPL version 2.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1),    Number::Format,   overload,   Statistics::Basic::Vector,   Statistics::Basic::ComputedVector,
       Statistics::Basic::_OneVectorBase,          Statistics::Basic::Mean,           Statistics::Basic::Median,
       Statistics::Basic::Mode,              Statistics::Basic::Variance,             Statistics::Basic::StdDev,
       Statistics::Basic::_TwoVectorBase,     Statistics::Basic::Correlation,     Statistics::Basic::Covariance,
       Statistics::Basic::LeastSquareFit

perl v5.36.0                                       2022-11-19                             <u>Statistics::<a href="../man3pm/Basic.3pm.html">Basic</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>