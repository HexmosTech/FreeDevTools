<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device::I2C - Control and read hardware devices with i2c(SMBus)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdevice-i2c-perl">libdevice-i2c-perl_0.06-2build4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Device::I2C - Control and read hardware devices with i2c(SMBus)

</pre><h4><b>VERSION</b></h4><pre>
       version 0.06

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use Device::I2C;
          use Fcntl;
          $dev = Device::I2C-&gt;new('/dev/i2c-1', O_RDWR);
          $dev-&gt;<a href="../man0x4c/checkDevice.0x4c.html">checkDevice</a>(0x4c);
          print $dev-&gt;<a href="../man0x20/readByteData.0x20.html">readByteData</a>(0x20);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a perl interface to I2C interface using libi2c-dev library.

       Prerequisites:

       For Debian and derivative distros(including raspbian) use the following to install dependencies:

         sudo apt-get install libi2c-dev i2c-tools build-essential

       If you are using Angstrom Linux use the following:

         opkg install i2c-tools
         opkg install i2c-tools-dev

       For ArchLINUX use the following steps:

         pacman -S base-devel
         pacman -S i2c-tools

       Special Instructions for enabling the I2C driver on a Raspberry Pi:

       You will need to comment out the driver from the blacklist. currently the I2C driver isn't being loaded.

            sudo vim /etc/modprobe.d/raspi-blacklist.conf

       Replace this line

            blacklist i2c-bcm2708

       with this

            #blacklist i2c-bcm2708

       You now need to edit the modules conf file.

            sudo vim <a href="file:/etc/modules">/etc/modules</a>

       Add these two lines;

            i2c-dev
            i2c-bcm2708

       Now run this command(replace 1 with 0 for older model Pi)

            sudo i2cdetect -y 1

       If that doesnt work on your system you may alternatively use this:

            sudo i2cdetect -r 1

       you should now see the addresses of the i2c devices connected to your i2c bus

</pre><h4><b>METHODS</b></h4><pre>
   <b>fileError</b>
       returns IO::Handle-&gt;<b>error()</b> for the device handle since the last clearerr

   <b>checkDevice</b>
        $self-&gt;checkDevice($register_address)

       Check device

   <b>selectDevice</b>
        $self-&gt;selectDevice($register_address)

       Select device

   <b>writeQuick</b>
        $self-&gt;writeQuick($value)

       This sends a single bit to the device, at the place of the Rd/Wr bit.

   <b>readByte</b>
        $self-&gt;readByte()

       This reads a single byte from a device, without specifying a device register. Some devices are so simple
       that this interface is enough; for others, it is a shorthand if you want to read the same register as in
       the previous I2C command

   <b>writeByte</b>
        $self-&gt;writeByte()

       This operation is the reverse of readByte: it sends a single byte to a device.

   <b>readByteData</b>
        $self-&gt;readByteData($register_address)

       This reads a single byte from a device, from a designated register.  The register is specified through
       the Comm byte.

   <b>writeByteData</b>
        $self-&gt;writeByteData($register_address,$value)

       This writes a single byte to a device, to a designated register. The register is specified through the
       Comm byte. This is the opposite of the Read Byte operation.

   <b>readNBytes</b>
        $self-&gt;readNBytes($lowest_byte_address, $number_of_bytes);

       Read together N bytes of Data in linear register order. i.e. to read from 0x28,0x29,0x2a

        $self-&gt;readNBytes(0x28,3);

   <b>readWordData</b>
        $self-&gt;readWordData($register_address)

       This operation is very like Read Byte; again, data is read from a device, from a designated register that
       is specified through the Comm byte. But this time, the data is a complete word (16 bits).

   <b>writeWordData</b>
        $self-&gt;writeWordData($register_address,$value)

       This is the opposite of the Read Word operation. 16 bits of data is written to a device, to the
       designated register that is specified through the Comm byte.

   <b>processCall</b>
        $self-&gt;processCall($register_address,$value)

       This command selects a device register (through the Comm byte), sends 16 bits of data to it, and reads 16
       bits of data in return.

   <b>writeBlockData</b>
        $self-&gt;writeBlockData($register_address, $values)

       Writes a maximum of 32 bytes in a single block to the i2c device.  The supplied $values should be an
       array ref containing the bytes to be written.

       The register address should be one that is at the beginning of a contiguous block of registers of equal
       length to the array of values passed.  Not adhering to this will almost certainly result in unexpected
       behaviour in the device.

   <b>readBlockData</b>
        $self-&gt;readBlockData($register_address, $numBytes)

       Read $numBytes form the given register address, data is returned as array

       The register address is often 0x00 or the value your device expects

       common usage with micro controllers that receive and send large amounts of data: they almost always needs
       a 'command' to be written to them then they send a response: e.g: 1) send 'command' with writeBlockData,
       or writeByteData, for example 'get last telegram' 2) read 'response' with readBlockData of size
       $numBytes, controller is sending the last telegram

   <b>DEMOLISH</b>
       Destructor

</pre><h4><b>CONSTANTS</b></h4><pre>
   <b>I2C_SLAVE</b>
   <b>I2C_SLAVE_FORCE</b>
</pre><h4><b>CREATING</b> <b>YOUR</b> <b>OWN</b> <b>CHIPSET</b> <b>DRIVERS</b></h4><pre>
       Writing your own chipset driver for your own i2c devices is quiet simple. You just need to know the i2c
       address of your device and the registers that you need to read or write. Example in the
       Device::I2C::ADV7611.

</pre><h4><b>NOTES</b></h4><pre>
       Based on the Device::SMBus without Moo. On my device Moo based script started 5 second.

       The SMBus was defined by Intel in 1995. It carries clock, data, and instructions and is based on Philips'
       I2C serial bus protocol. Its clock frequency range is 10 kHz to 100 kHz. (PMBus extends this to 400 kHz.)
       Its voltage levels and timings are more strictly defined than those of I2C, but devices belonging to the
       two systems are often successfully mixed on the same bus. SMBus is used as an interconnect in several
       platform management standards including: ASF, DASH, IPMI.

</pre><h4><b>USAGE</b></h4><pre>
       •   This  module  provides a simplified object oriented interface to the libi2c-dev library for accessing
           electronic peripherals connected on the I2C bus.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   Device::SMBus

       •   Device::I2C::ADV7611

       •   IO::File

       •   Fcntl

</pre><h4><b>SUPPORT</b></h4><pre>
   <b>Bugs</b> <b>/</b> <b>Feature</b> <b>Requests</b>
       Please      report      any      bugs      or      feature      requests      through      github      at
       &lt;https://github.com/sv99/perl-device-i2c/issues&gt;.   You will be notified automatically of any progress on
       your issue.

   <b>Source</b> <b>Code</b>
       This is open source software.  The code repository is available for public review and contribution  under
       the terms of the license.

       &lt;https://github.com/sv99/perl-device-i2c&gt;

         git clone git://github.com/sv99/perl-device-i2c.git

</pre><h4><b>AUTHOR</b></h4><pre>
       Slava Volkov &lt;<a href="mailto:sv99@inbox.ru">sv99@inbox.ru</a>&gt;

</pre><h4><b>CONTRIBUTOR</b></h4><pre>
       Slava Volkov &lt;svolkov att cpan dott org&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2016 by Slava Volkov.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-10-20                                   <u>Device::<a href="../man3pm/I2C.3pm.html">I2C</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>