<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device::Cdio - Module for CD Input and Control library.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdevice-cdio-perl">libdevice-cdio-perl_2.0.0-2build7_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Device::Cdio - Module for CD Input and Control library.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This encapsulates CD-ROM reading and control. Applications wishing to be oblivious of the OS- and device-
       dependent properties of a CD-ROM can use this library.

           use Device::Cdio;
           use Device::Cdio::Device;

           $cd_drives = Device::Cdio::get_devices($perlcdio::DRIVER_DEVICE);
           $cd_drives = Device::Cdio::get_devices_with_cap($perlcdio::FS_AUDIO, 0);
           foreach my $drive (@$cd_drives) {
              print "Drive $drive\n";
           }
           foreach my $driver_name (sort keys(%Device::Cdio::drivers)) {
              print "Driver $driver_name is installed.\n"
                 if Device::Cdio::have_driver($driver_name) and
                 $driver_name !~ m{device|Unknown};
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is an Perl Object-Oriented interface to the GNU CD Input and Control library, "libcdio", written in
       C. The library encapsulates CD-ROM reading and control. Perl programs wishing to be oblivious of the OS-
       and device-dependent properties of a CD-ROM can use this library.

       The encapsulation is done in two parts. The lower-level Perl interface is called perlcdio and is
       generated by SWIG.

       This module uses "perlcdio". Actually, there are no objects in module, but there are in its sub modules
       Device::Cdio::Device and Device::Cdio::Track.

       Although "perlcdio" is perfectly usable on its own, it is expected that Cdio is what most people will
       use. As "perlcdio" more closely models the C interface "libcdio", it is conceivable (if unlikely) that
       die-hard libcdio C users who are very familiar with that interface could prefer that.

   <b>CALLING</b> <b>ROUTINES</b>
       Routines accept named parameters as well as positional parameters.  For named parameters, each argument
       name is preceded by a dash. For example:

           Device::Cdio::have_driver(-driver_id=&gt;'GNU/Linux')

       Each argument name is preceded by a dash.  Neither case nor order matters in the argument list.
       "-driver_id", "-Driver_ID", and "-DRIVER_ID" are all acceptable.  In fact, only the first argument needs
       to begin with a dash.  If a dash is present in the first argument, we assume dashes for the subsequent
       parameters.

       In the documentation below and elsewhere in this package the parameter name that can be used in this
       style of call is given in the parameter list. For example, for "close_tray" the documentation below
       reads:

          close_tray(drive=undef, driver_id=$perlcdio::DRIVER_UNKNOWN)
           -&gt; ($drc, $driver_id)

       So the parameter names are "drive", and "driver_id". Neither parameter is required. If "drive" is not
       specified, a value of "undef" will be used. And if "driver_id" is not specified, a value of
       $perlcdio::DRIVER_UNKNOWN is used.

       The older, more traditional style of positional parameters is also supported. So the "have_driver"
       example from above can also be written:

           Device::Cdio::have_driver('GNU/Linux')

       Finally, since no parameter name can be confused with a an integer, negative values will not get confused
       as a named parameter.

</pre><h4><b>SUBROUTINES</b></h4><pre>
   <b>close_tray</b>
       close_tray(drive=undef, driver_id=$perlcdio::DRIVER_UNKNOWN)
        -&gt; ($drc, $driver_id)

       close media tray in CD drive if there is a routine to do so.

       In an array context, the driver return-code status and the name of the driver used are returned.  In a
       scalar context, just the return code status is returned.

   <b>driver_strerror</b>
       driver_strerror(rc)-&gt;$errmsg

       Convert a driver return code into a string text message.

   <b>get_default_device_driver</b>
       get_default_device_driver(driver_id=DRIVER_DEVICE)-&gt; ($device, $driver)

       Return a string containing the default CD device if none is specified.  if driver_id is DRIVER_UNKNOWN or
       DRIVER_DEVICE then find a suitable one set the default device for that.

       undef is returned as the driver if we couldn't get a default device.

   <b>get_devices</b>
       $revices = get_devices(driver_id=$Cdio::DRIVER_UNKNOWN);

       Return an array of device names. If you want a specific devices for a driver, give that device. If you
       want hardware devices, give $perlcdio::DRIVER_DEVICE and if you want all possible devices, image drivers
       and hardware drivers give $perlcdio::DRIVER_UNKNOWN.  undef is returned if we couldn't return a list of
       devices.

       In some situations of drivers or OS's we can't find a CD device if there is no media in it and it is
       possible for this routine to return undef even though there may be a hardware CD-ROM.

   <b>get_devices_ret</b>
       get_devices_ret($driver_id)-&gt;(@devices, $driver_id)

       Like get_devices, but we may change the p_driver_id if we were given $perlcdio::DRIVER_DEVICE or
       $perlcdio::DRIVER_UNKNOWN.  This is because often one wants to get a drive name and then <u>open</u> it
       afterwords. Giving the driver back facilitates this, and speeds things up for libcdio as well.

   <b>get_devices_with_cap</b>
       $devices = get_devices_with_cap($capabilities, $any);

       Get an array of device names in search_devices that have at least the capabilities listed by the
       capabilities parameter.

       If "any" is set false then ALL capabilities listed in the extended portion of capabilities (i.e. not the
       basic filesystem) must be satisfied. If "any" is set true, then if any of the capabilities matches, we
       call that a success.

       To find a CD-drive of any type, use the mask $perlcdio::FS_MATCH_ALL.

       The array of device names is returned or undef if we couldn't get a default device.  It is also possible
       to return a () but after This means nothing was found.

   <b>get_devices_with_cap_ret</b>
       Like get_devices_with_cap but we return the driver we found as well. This is because often one wants to
       search for kind of drive and then *open* it afterward. Giving the driver back facilitates this, and
       speeds things up for libcdio as well.

   <b>have_driver</b>
       have_driver(driver_id) -&gt; bool

       Return 1 if we have driver driver_id. undef is returned if driver_id is invalid. driver_id can either be
       an integer driver name defined in perlcdio or a string as defined in the hash %drivers.

   <b>is_binfile</b>
       is_binfile(binfile)-&gt;cue_name

       Determine if binfile is the BIN file part of a CDRWIN Compact Disc image.

       Return the corresponding CUE file if bin_name is a BIN file or undef if not a BIN file.

   <b>is_cuefile</b>
       is_cuefile(cuefile)-&gt;bin_name

       Determine if cuefile is the CUE file part of a CDRWIN Compact Disc image.

       Return the corresponding BIN file if cue_name is a CUE file or undef if not a CUE file.

   <b>is_device</b>
       is_device(source, driver_id=$perlcdio::DRIVER_UNKNOWN)-&gt;bool

       Return True if source refers to a real hardware CD-ROM.

   <b>is_nrg</b>
       is_nrg(nrgfile)-&gt;bool

       Determine if nrgfile is a Nero NRG file disc image.

   <b>is_tocfile</b>
       is_tocfile(tocfile_name)-&gt;bool

       Determine if tocfile_name is a cdrdao CD disc image.

   <b>convert_drive_cap_misc</b>
       convert_drive_cap_misc(bitmask)-&gt;hash_ref

       Convert bit mask for miscellaneous drive properties into a hash reference of drive capabilities

   <b>convert_drive_cap_read</b>
       convert_drive_cap_read($bitmask)-&gt;hash_ref

       Convert bit mask for read drive properties into a hash reference of drive capabilities

   <b>convert_drive_cap_write</b>
       convert_drive_cap_write($bitmask)-&gt;hash_ref

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Device::Cdio::Device for device objects and Device::Cdio::Track for track objects and
       Device::Cdio::ISO9660 for working with ISO 9660 filesystems.

       perlcdio is the lower-level interface to libcdio.

       &lt;<a href="http://www.gnu.org/software/libcdio/doxygen/files.html">http://www.gnu.org/software/libcdio/doxygen/files.html</a>&gt; is documentation via doxygen for "libcdio".

</pre><h4><b>AUTHORS</b></h4><pre>
       Rocky Bernstein

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2006, 2011 Rocky Bernstein &lt;<a href="mailto:rocky@cpan.org">rocky@cpan.org</a>&gt;

       This program is free software: you can redistribute it and/or modify it under the terms of the GNU
       General Public License as published by the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
       the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
       License for more details.

       You should have received a copy of the GNU General Public License along with this program.  If not, see
       The GNU General Public License &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>#GPL&gt;.

perl v5.40.0                                       2025-01-30                                  <u>Device::<a href="../man3pm/Cdio.3pm.html">Cdio</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>