<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device::Cdio::Device - Class for disc and device aspects of Cdio.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdevice-cdio-perl">libdevice-cdio-perl_2.0.0-2build7_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Device::Cdio::Device - Class for disc and device aspects of Cdio.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Device::Cdio::Device;
           $d = Device::Cdio::Device-&gt;new(-driver_id=&gt;$perlcdio::DRIVER_DEVICE);
           $drive_name = $d-&gt;get_device();
           ($i_read_cap, $i_write_cap, $i_misc_cap) =  $d-&gt;get_drive_cap();

           $start_lsn = $d-&gt;get_first_track()-&gt;get_lsn();
           $end_lsn=$d-&gt;get_disc_last_lsn();
           $drc = $d-&gt;audio_play_lsn($start_lsn, $end_lsn);
           ($vendor, $model, $release, $drc) = $d-&gt;get_hwinfo();

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
         new(source, driver_id, access_mode)-&gt;$device_object

       Create a new Device object. Either parameter "source", "driver_id" or "access_mode" can be "undef". In
       fact it is probably best to not to give an "access_mode" unless you know what you are doing.

   <b>audio_pause</b>
         audio_pause()-&gt; $status

       Pause playing CD through analog output.  The device status is returned.

   <b>audio_play_lsn</b>
         audio_play_lsn(start_lsn, end_lsn)-&gt; $status

       Playing CD through analog output at the given lsn to the ending lsn The device status is returned.

   <b>audio_resume</b>
         audio_resume()-&gt; $status

       Resume playing an audio CD through the analog interface.  The device status is returned.

   <b>audio_stop</b>
         audio_stop()-&gt; $status

       Stop playing an audio CD through the analog interface.  The device status is returned.

   <b>close</b>
         close()-&gt;bool

       Free resources associated with cdio.  Call this when done using using CD reading/control operations for
       the current device.

   <b>eject_media</b>
         eject_media()-&gt;drc

       Eject media in CD drive if there is a routine to do so.  status is returned.

   <b>get_arg</b>
         get_arg(key)-&gt;string

   <b>get_device</b>
         get_device()-&gt;str

       Get the default CD device.

       If the CD object has an opened CD, return the name of the device used.  (In fact this is the same thing
       as issuing "d-&gt;get_arg("source")").

       If we haven't initialized a specific device driver, then find a suitable one and return the default
       device for that.

       In some situations of drivers or OS's we can't find a CD device if there is no media in it and it is
       possible for this routine to return undef even though there may be a hardware CD-ROM.

   <b>get_disc_last_lsn</b>
         get_disc_last_lsn(self)-&gt;int

       Get the LSN of the end of the CD. $perlcdio::INVALID_LSN is returned if there was an error.

   <b>get_disc_mode</b>
         get_disc_mode() -&gt; str

       Get disc mode - the kind of CD: CD-DA, CD-ROM mode 1, CD-MIXED, etc.  that we've got. The notion of 'CD'
       is extended a little to include DVD's.

   <b>get_drive_cap</b>
         get_drive_cap()-&gt;(read_cap, write_cap, misc_cap)

       Get drive capabilities of device.

       In some situations of drivers or OS's we can't find a CD device if there is no media in it. In this
       situation capabilities will show up as empty even though there is a hardware CD-ROM.

   <b>get_drive_cap_dev</b>
         get_drive_cap_dev(device=undef)-&gt;(read_cap, write_cap, misc_cap)

       Get drive capabilities of device.

       In some situations of drivers or OS's we can't find a CD device if there is no media in it. In this
       situation capabilities will show up as empty even though there is a hardware CD-ROM.

   <b>get_driver_name</b>
         get_driver_name()-&gt; string

       return a string containing the name of the driver in use.  "undef" is returned if there's an error.

   <b>get_driver_id</b>
         get_driver_id()-&gt; int

   <b>get_first_track</b>
         get_first_track()-&gt;Track

       return a Track object of the first track. $perlcdio::INVALID_TRACK or $perlcdio::BAD_PARAMETER is
       returned if there was a problem.

       Return the driver id of the driver in use.  if object has not been initialized or is None, return
       $perlcdio::DRIVER_UNKNOWN.

   <b>get_hwinfo</b>
         get_hwinfo()-&gt;(vendor, model, release, drc)

       Get the CD-ROM hardware info via a SCSI MMC INQUIRY command.  An exception is raised if we had an error.

   <b>audio_get_volume</b>
           my($arr, $rc) = $dev-&gt;audio_get_volume;

       Returns the volume settings of device's 4 channels and the device return code.  In scalar environmet only
       the device return code!  See perlcdio::driver_errmsg($rc) for return-values meanings when "$rc != 0".

   <b>audio_play_track_index</b>
           $drc = $dev-&gt;audio_play_track_index($start_track, $start_index, $end_track, $end_track);

       Playing CD through analog output at the desired start track and index, to the end track and index. Tracks
       should be in the valid CD track range 0..99.

       Just as a track number is burned into the CD, so is a an index for a track.

       See perlcdio::driver_errmsg($drc) for return-values meanings when "$drc != 0".

   <b>audio_set_volume</b>
           $drc = $dev-&gt;audio_set_volume($channel1_volume, $channel2_volume,
                                         $channel3_volume, $channel4_volume);

       Set the volume levels of the channels 1-4. Values from 0-255 are possible.  Stereo CDROM devices (which
       is most of them) use only channels 1 and 2.

       Use -1 when the existing value should be kept.  See perlcdio::driver_errmsg($drc) for return-values
       meanings when "$drc != 0".

   <b>get_disk_cdtext,</b> <b>get_track_cdtext</b>
           $hash = $dev-&gt;get_disk_cdtext;
           $hash = $dev-&gt;get_cdtext_for_track(track, field);
           $hash = $dev-&gt;get_cdtext_field_for_track(track, field);
           $hash = $dev-&gt;get_cdtext_field_for_track(track, field);

       Returns a hash reference hash-&gt;{cdtext_field}="text" if found any cdtext on disk;

   <b>get_disk_cdtext_field_for_track</b>
           $str = $dev-&gt;get_cdtext_field_for_track($field, $track=0, $cdtext=$self-&gt;{cdtext});

       Returns the text associated with field $field of track $track of $cdtext if there is any.

   <b>cdtext_destroy</b>
       $dev-&gt;<b>cdtext_destroy()</b>

       Removes CD-TEXT memor resources associated a disc and sets $dev-&gt;{cdtext} to undef.

       Use this when you are done accessing with CD-TEXT information.

       Note: $def-&gt;<b>close()</b> runs this as part of its operation.

   <b>get_cddb_discid</b>
           $discid = $dev-&gt;get_cddb_discid;

       Returns the calculated cddb discid integer. Usually used as hexstring!

   <b>audio_get_status</b>
           my($hash, $drc) = $dev-&gt;audio_get_status;

       Returns a hash reference with the audio-subchannel-mmc status values:

           audio_status : value
           status_text  : audio_status as text
                       (INVALID,ERROR,NO_STATUS,UNKNOWN,playing,paused,completed)
           track : track number
           index : index in track
           msf time values as ints minutes, seconds,frames :
               abs_m,abs_s,abs_f  : total disc time played
               rel_m,rel_s,el_f   : track time played
           disk_s  : seconds disk played
           track_s : seconds track played
           address
           control

   <b>is_tray_open</b>
           $dev-&gt;is_tray_open

       returns true if tray seems open, 0 otherwise.

   <b>get_joliet_level</b>
         get_joliet_level()-&gt;int

       Return the Joliet level recognized for cdio.  This only makes sense for something that has an ISO-9660
       filesystem.

   <b>get_last_session</b>
         get_last_session(self) -&gt; (track_lsn, drc)

       Get the LSN of the first track of the last session of on the CD.

   <b>get_last_track</b>
         get_last_track()-&gt;Track

       return a Track object of the last track. $perlcdio::INVALID_TRACK or $perlcdio::BAD_PARAMETER is returned
       if there was a problem.

   <b>get_mcn</b>
       <b>get_mcn()</b>-&gt;str

       Get the media catalog number (MCN) from the CD.

   <b>get_media_changed</b>
         get_media_changed() -&gt; int

       Find out if media has changed since the last call.  Return 1 if media has changed since last call, 0 if
       not.  A negative number indicates the driver status error.

   <b>guess_cd_type</b>
       $hash = $dev-&gt;guess_cd_type($lsn,$track);

       Try to determine what kind of CD-image and/or filesystem we have at track $track. First argument is the
       start lsn of track $track. Returns a hash reference with following keys:

           cdio_fs_t     (enum cdio_fs_t from libcdio) FIXME: add text
           cdio_fs_cap_t (enum cdio_fs_cap_t from libcdio) FIXME: add text
           joliet_level  If has Joliet extensions, this is the associated level
                           number (i.e. 1, 2, or 3).
           iso_label      32 byte ISO fs label.
           isofs_size     size of ISO fs.
           UDFVerMajor    UDF fs version.
           UDFVerMinor    UDF fs version.

   <b>get_num_tracks</b>
         get_num_tracks()-&gt;int

       Return the number of tracks on the CD.  $perlcdio::INVALID_TRACK is raised on error.

   <b>get_track</b>
         get_track(track_num)-&gt;track

       Set a new track object of the current disc for the given track number.

   <b>get_track_for_lsn</b>
         get_track_for_lsn(LSN)-&gt;Track

       Find the track which contains LSN.  undef is returned if the lsn outside of the CD or if there was some
       error.

       If the LSN is before the pregap of the first track, A track object with a 0 track is returned.  Otherwise
       we return the track that spans the lsn.

   <b>have_ATAPI</b>
         have_ATAPI()-&gt;bool

       return 1 if CD-ROM understand ATAPI commands.

   <b>lseek</b>
         lseek(offset, whence)-&gt;int

       Reposition read offset. Similar to (if not the same as) libc's <b>fseek()</b>

       offset is the amount to seek and whence is like corresponding parameter in libc's lseek, e.g.  it should
       be SEEK_SET or SEEK_END.

       the offset is returned or -1 on error.

   <b>open</b>
         open(source=undef, driver_id=$libcdio::DRIVER_UNKNOWN,
              access_mode=undef)-&gt;$cdio_obj

       Sets up to read from place specified by source, driver_id and access mode. This should be called before
       using any other routine except those that act on a CD-ROM drive by name. It is implicitly called when a
       new is done specifying a source or driver id.

       If "undef" is given as the source, we'll use the default driver device.  If "undef" is given as the
       driver_id, we'll find a suitable device driver.  Device is opened so that subsequent operations can be
       performed.

   <b>read</b>
         read(size)-&gt;(size, data)

       Reads the next size bytes.  Similar to (if not the same as) libc's <b>read()</b>

       The number of bytes read and the data is returned.

   <b>read_data_blocks</b>
         read_data_blocks(lsn, blocks=1)-&gt;($data, $size, $drc)

       Reads a number of data sectors (AKA blocks).

       lsn is sector to read, blocks is the number of bytes.

       The size of the data will be a multiple of $perlcdio::ISO_BLOCKSIZE.

       The number of data, size of the data, and the return code status is returned in an array context. In a
       scalar context just the data is returned. "undef" is returned as the data on error.

   <b>read_sectors</b>
         read_sectors($lsn, $read_mode, $blocks=1)-&gt;($data, $size, $drc)
         read_sectors($lsn, $read_mode, $blocks=1)-&gt;$data

       Reads a number of sectors (AKA blocks).

       lsn is sector to read, bytes is the number of bytes.

       If read_mode is $perlcdio::MODE_AUDIO, the return data size will be a multiple of
       $perlcdio::CDIO_FRAMESIZE_RAW i_blocks bytes.

       If read_mode is $perlcdio::MODE_DATA, data will be a multiple of $perlcdio::ISO_BLOCKSIZE,
       $perlcdio::M1RAW_SECTOR_SIZE or $perlcdio::M2F2_SECTOR_SIZE bytes depending on what mode the data is in.

       If read_mode is $perlcdio::MODE_M2F1, data will be a multiple of $perlcdio::M2RAW_SECTOR_SIZE bytes.

       If read_mode is $perlcdio::MODE_M2F2, the return data size will be a multiple of $perlcdio::CD_FRAMESIZE
       bytes.

       The number of data, size of the data, and the return code status is returned in an array context. In a
       scalar context just the data is returned. undef is returned as the data on error.

   <b>set_blocksize</b>
         set_blocksize(blocksize) -&gt; $status

       Set the blocksize for subsequent reads.  The operation status code is returned.

   <b>set_speed</b>
         set_speed(speed)-&gt;drc

       The operation status code is returned.

   <b>read_pvd</b>
       $pvd = $dev-&gt;read_pvd;

       Reads and returns the ISO-9660 Primary Volume Descriptor (PVD) from the disk.  You can use
       perliso9660::get_pvd_type($pvd) ... methods to get the values.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Device::Cdio for the top-level module, Device::Cdio::Track for track objects, and Device::Cdio::ISO9660
       for working with ISO9660 filesystems.

       perlcdio is the lower-level interface to libcdio.

       &lt;<a href="http://www.gnu.org/software/libcdio">http://www.gnu.org/software/libcdio</a>&gt; has documentation on libcdio including the a manual and the API via
       doxygen.

</pre><h4><b>AUTHORS</b></h4><pre>
       Rocky Bernstein

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2006, 2008, 2017 Rocky Bernstein &lt;<a href="mailto:rocky@cpan.org">rocky@cpan.org</a>&gt;

       This program is free software: you can redistribute it and/or modify it under the terms of the GNU
       General Public License as published by the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
       the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
       License for more details.

       You should have received a copy of the GNU General Public License along with this program.  If not, see
       The GNU General Public License &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>#GPL&gt;.

perl v5.40.0                                       2025-01-30                          <u>Device::Cdio::<a href="../man3pm/Device.3pm.html">Device</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>