<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Annotation::TagTree - AnnotationI with tree-like hierarchal key-value relationships ('structured</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-perl-perl">libbio-perl-perl_1.7.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Annotation::TagTree - AnnotationI with tree-like hierarchal key-value relationships ('structured
       tags') that can be represented as simple text.

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use Bio::Annotation::TagTree;
          use Bio::Annotation::Collection;

          my $col = Bio::Annotation::Collection-&gt;new();

          # data structure can be an array reference with a data structure
          # corresponding to that defined by Data::Stag:

          my $sv = Bio::Annotation::TagTree-&gt;new(-tagname =&gt; 'mytag1',
                                                 -value =&gt; $data_structure);
          $col-&gt;add_Annotation($sv);

          # regular text passed is parsed based on the tagformat().
          my $sv2 = Bio::Annotation::TagTree-&gt;new(-tagname =&gt; 'mytag2',
                                                 -tagformat =&gt; 'xml',
                                                 -value =&gt; $xmltext);
          $col-&gt;add_Annotation($sv2);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This takes tagged data values and stores them in a hierarchal structured element-value hierarchy
       (complements of Chris Mungall's Data::Stag module). Data can then be represented as text using a variety
       of output formats (indention, itext, xml, spxr). Furthermore, the data structure can be queried using
       various means. See Data::Stag for details.

       Data passed in using <b>value()</b> or the '-value' parameter upon instantiation can either be:

       1) an array reference corresponding to the data structure for Data::Stag;

       2) a text string in 'xml', 'itext', 'spxr', or 'indent' format. The default format is 'xml'; this can be
       changed using <b>tagformat()</b> prior to using <b>value()</b> or by passing in the proper format using '-tagformat'
       upon instantiation;

       3) another Bio::Annotation::TagTree or Data::Stag node instance.  In both cases a deep copy (duplicate)
       of the instance is generated.

       Beyond checking for an array reference no format guessing occurs (so, for roundtrip tests ensure that the
       IO formats correspond). For now, we recommend when using text input to set <b>tagformat()</b> to one of these
       formats prior to data loading to ensure the proper Data::Stag parser is selected. After data loading, the
       <b>tagformat()</b> can be changed to change the text string format returned by <b>value()</b>. (this may be rectified
       in the future)

       This Annotation type is fully BioSQL compatible and could be considered a temporary replacement for
       nested Bio::Annotation::Collections, at least until BioSQL and bioperl-db can support nested annotation
       collections.

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>Lists</b>
       User feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments
       and suggestions preferably to one of the Bioperl mailing lists. Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list:

       <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather than to the module maintainer directly. Many experienced and reponsive experts will be able look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>Bugs</b>
       Report bugs to the Bioperl bug tracking system to help us keep track the bugs and their resolution.  Bug
       reports can be submitted via or the web:

         https://github.com/bioperl/bioperl-live/issues

</pre><h4><b>AUTHOR</b></h4><pre>
       Chris Fields

</pre><h4><b>APPENDIX</b></h4><pre>
       The rest of the documentation details each of the object methods. Internal methods are usually preceded
       with a _

   <b>new</b>
        Title   : new
        Usage   : my $sv = Bio::Annotation::TagTree-&gt;new();
        Function: Instantiate a new TagTree object
        Returns : Bio::Annotation::TagTree object
        Args    : -value =&gt; $value to initialize the object data field [optional]
                  -tagname =&gt; $tag to initialize the tagname [optional]
                  -tagformat =&gt; format for output [optional]
                             (types 'xml', 'itext', 'sxpr', 'indent', default = 'itext')
                  -node =&gt; Data::Stag node or Bio::Annotation::TagTree instance

</pre><h4><b>AnnotationI</b> <b>implementing</b> <b>functions</b></h4><pre>
   <b>as_text</b>
        Title   : as_text
        Usage   : my $text = $obj-&gt;as_text
        Function: return the string "Value: $v" where $v is the value
        Returns : string
        Args    : none

   <b>display_text</b>
        Title   : display_text
        Usage   : my $str = $ann-&gt;display_text();
        Function: returns a string. Unlike as_text(), this method returns a string
                  formatted as would be expected for the specific implementation.

                  One can pass a callback as an argument which allows custom text
                  generation; the callback is passed the current instance and any text
                  returned
        Example :
        Returns : a string
        Args    : [optional] callback

   <b>hash_tree</b>
        Title   : hash_tree
        Usage   : my $hashtree = $value-&gt;hash_tree
        Function: For supporting the AnnotationI interface just returns the value
                  as a hashref with the key 'value' pointing to the value
                  Maybe reimplement using Data::Stag::hash()?
        Returns : hashrf
        Args    : none

   <b>tagname</b>
        Title   : tagname
        Usage   : $obj-&gt;tagname($newval)
        Function: Get/set the tagname for this annotation value.

                  Setting this is optional. If set, it obviates the need to provide
                  a tag to AnnotationCollection when adding this object.
        Example :
        Returns : value of tagname (a scalar)
        Args    : new value (a scalar, optional)

</pre><h4><b>Specific</b> <b>accessors</b> <b>for</b> <b>TagTree</b></h4><pre>
   <b>value</b>
        Title   : value
        Usage   : $obj-&gt;value($newval)
        Function: Get/set the value for this annotation.
        Returns : value of value
        Args    : newvalue (optional)

   <b>tagformat</b>
        Title   : tagformat
        Usage   : $obj-&gt;tagformat($newval)
        Function: Get/set the output tag format for this annotation.
        Returns : value of tagformat
        Args    : newvalue (optional) - format for the data passed into value
                  must be of values 'xml', 'indent', 'sxpr', 'itext', 'perl'

   <b>node</b>
        Title   : node
        Usage   : $obj-&gt;node()
        Function: Get/set the topmost Data::Stag node used for this annotation.
        Returns : Data::Stag node implementation
                  (default is Data::Stag::StagImpl)
        Args    : (optional) Data::Stag node implementation
                  (optional)'copy' =&gt; flag to create a copy of the node

   <b>Data::Stag</b> <b>convenience</b> <b>methods</b>
       Because Data::Stag uses blessed arrays and the core Bioperl class uses blessed hashes, TagTree uses an
       internal instance of a Data::Stag node for data storage.  Therefore the following methods actually
       delegate to the Data:::Stag internal instance.

       For consistency (since one could recursively check child nodes), methods retain the same names as
       Data::Stag. Also, no 'magic' (AUTOLOAD'ed) methods are employed, simply b/c full-fledged Data::Stag
       functionality can be attained by grabbing the Data::Stag instance using <b>node()</b>.

   <b>element</b>
        Title   : element
        Usage   :
        Function: Returns the element name (key name) for this node
        Example :
        Returns : scalar
        Args    : none

   <b>data</b>
        Title   : data
        Usage   :
        Function: Returns the data structure (array ref) for this node
        Example :
        Returns : array ref
        Args    : none

   <b>children</b>
        Title   : children
        Usage   :
        Function: Get the top-level array of Data::Stag nodes or (if the top level is
                  a terminal node) a scalar value.

                  This is similar to StructuredValue's get_values() method, with the
                  key difference being instead of array refs and scalars you get either
                  Data::Stag nodes or the value for this particular node.

                  For consistency (since one could recursively check nodes),
                  we use the same method name as Data::Stag children().
        Example :
        Returns : an array
        Args    : none

   <b>subnodes</b>
        Title   : subnodes
        Usage   :
        Function: Get the top-level array of Data::Stag nodes.  Unlike children(),
                  this only returns an array of nodes (if this is a terminal node,
                  no value is returned)
        Example :
        Returns : an array of nodes
        Args    : none

   <b>get</b>
        Title   : get
        Usage   :
        Function: Returns the nodes or value for the named element or path
        Example :
        Returns : returns array of nodes or a scalar (if node is terminal)
                  dependent on wantarray
        Args    : none

   <b>find</b>
        Title   : find
        Usage   :
        Function: Recursively searches for and returns the nodes or values for the
                  named element or path
        Example :
        Returns : returns array of nodes or scalars (for terminal nodes)
        Args    : none

   <b>findnode</b>
        Title   : findnode
        Usage   :
        Function: Recursively searches for and returns a list of nodes
                  of the given element path
        Example :
        Returns : returns array of nodes
        Args    : none

   <b>findval</b>
        Title   : findval
        Usage   :
        Function:
        Example :
        Returns : returns array of nodes or values
        Args    : none

   <b>addchild</b>
        Title   : addchild
        Usage   : $struct-&gt;addchild(['name' =&gt; [['foo'=&gt; 'bar1']]]);
        Function: add new child node to the current node.  One can pass in a node, TagTree,
                  or data structure; for instance, in the above, this would translate
                  to (in XML):

                  &lt;name&gt;
                    &lt;foo&gt;bar1&lt;/foo&gt;
                  &lt;/name&gt;

        Returns : node
        Args    : first arg = element name
                  all other args are added as tag-value pairs

   <b>add</b>
        Title   : add
        Usage   : $struct-&gt;add('foo', 'bar1', 'bar2', 'bar3');
        Function: add tag-value nodes to the current node.  In the above, this would
                  translate to (in XML):
                  &lt;foo&gt;bar1&lt;/foo&gt;
                  &lt;foo&gt;bar2&lt;/foo&gt;
                  &lt;foo&gt;bar3&lt;/foo&gt;
        Returns :
        Args    : first arg = element name
                  all other args are added as tag-value pairs

   <b>set</b>
        Title   : set
        Usage   : $struct-&gt;set('foo','bar');
        Function: sets a single tag-value pair in the current node.  Note this
                  differs from add() in that this replaces any data already present
        Returns : node
        Args    : first arg = element name
                  all other args are added as tag-value pairs

   <b>unset</b>
        Title   : unset
        Usage   : $struct-&gt;unset('foo');
        Function: unsets all key-value pairs of the passed element from the
                  current node
        Returns : node
        Args    : element name

   <b>free</b>
        Title   : free
        Usage   : $struct-&gt;free
        Function: removes all data from the current node
        Returns :
        Args    :

   <b>hash</b>
        Title   : hash
        Usage   : $struct-&gt;hash;
        Function: turns the tag-value tree into a hash, all data values are array refs
        Returns : hash
        Args    : first arg = element name
                  all other args are added as tag-value pairs

   <b>pairs</b>
        Title   : pairs
        Usage   : $struct-&gt;pairs;
        Function: turns the tag-value tree into a hash, all data values are scalar
        Returns : hash
        Args    : first arg = element name
                  all other args are added as tag-value pairs, note that duplicates
                  will be lost

   <b>qmatch</b>
        Title    : qmatch
        Usage    : @persons = $s-&gt;qmatch('person', ('name'=&gt;'fred'));
        Function : returns all elements in the node tree which match the
                   element name and the key-value pair
        Returns  : Array of nodes
        Args     : return-element str, match-element str, match-value str

   <b>tnodes</b>
        Title    : tnodes
        Usage    : @termini = $s-&gt;tnodes;
        Function : returns all terminal nodes below this node
        Returns  : Array of nodes
        Args     : return-element str, match-element str, match-value str

   <b>ntnodes</b>
        Title    : ntnodes
        Usage    : @termini = $s-&gt;ntnodes;
        Function : returns all nonterminal nodes below this node
        Returns  : Array of nodes
        Args     : return-element str, match-element str, match-value str

   <b>StructureValue-like</b> <b>methods</b>
   <b>get_all_values</b>
        Title    : get_all_values
        Usage    : @termini = $s-&gt;get_all_values;
        Function : returns all terminal node values
        Returns  : Array of values
        Args     : return-element str, match-element str, match-value str

       This is meant to emulate the values one would get from StructureValue's <b>get_all_values()</b> method. Note,
       however, using this method dissociates the tag-value relationship (i.e. you only get the value list, no
       elements)

perl v5.32.1                                       2021-08-15                      <u>Bio::Annotation::<a href="../man3pm/TagTree.3pm.html">TagTree</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>