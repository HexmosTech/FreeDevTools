<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_CreateEventSource,  Tcl_DeleteEventSource, Tcl_SetMaxBlockTime, Tcl_QueueEvent, Tcl_ThreadQueueEvent,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_CreateEventSource,  Tcl_DeleteEventSource, Tcl_SetMaxBlockTime, Tcl_QueueEvent, Tcl_ThreadQueueEvent,
       Tcl_ThreadAlert,   Tcl_GetCurrentThread,   Tcl_DeleteEvents,   Tcl_InitNotifier,    Tcl_FinalizeNotifier,
       Tcl_WaitForEvent,  Tcl_AlertNotifier, Tcl_SetTimer, Tcl_ServiceAll, Tcl_ServiceEvent, Tcl_GetServiceMode,
       Tcl_SetServiceMode, Tcl_ServiceModeHook, Tcl_SetNotifier - the event queue and notifier interfaces

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       <b>Tcl_CreateEventSource</b>(<u>setupProc,</u> <u>checkProc,</u> <u>clientData</u>)

       <b>Tcl_DeleteEventSource</b>(<u>setupProc,</u> <u>checkProc,</u> <u>clientData</u>)

       <b>Tcl_SetMaxBlockTime</b>(<u>timePtr</u>)

       <b>Tcl_QueueEvent</b>(<u>evPtr,</u> <u>position</u>)

       <b>Tcl_ThreadQueueEvent</b>(<u>threadId,</u> <u>evPtr,</u> <u>position</u>)

       <b>Tcl_ThreadAlert</b>(<u>threadId</u>)

       Tcl_ThreadId
       <b>Tcl_GetCurrentThread</b>()

       <b>Tcl_DeleteEvents</b>(<u>deleteProc,</u> <u>clientData</u>)

       void *
       <b>Tcl_InitNotifier</b>()

       <b>Tcl_FinalizeNotifier</b>(<u>clientData</u>)

       int
       <b>Tcl_WaitForEvent</b>(<u>timePtr</u>)

       <b>Tcl_AlertNotifier</b>(<u>clientData</u>)

       <b>Tcl_SetTimer</b>(<u>timePtr</u>)

       int
       <b>Tcl_ServiceAll</b>()

       int
       <b>Tcl_ServiceEvent</b>(<u>flags</u>)

       int
       <b>Tcl_GetServiceMode</b>()

       int
       <b>Tcl_SetServiceMode</b>(<u>mode</u>)

       <b>Tcl_ServiceModeHook</b>(<u>mode</u>)

       <b>Tcl_SetNotifier</b>(<u>notifierProcPtr</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       Tcl_EventSetupProc <u>*setupProc</u> (in)                 Procedure to invoke  to  prepare  for  event  wait  in
                                                          <b>Tcl_DoOneEvent</b>.

       Tcl_EventCheckProc <u>*checkProc</u> (in)                 Procedure  for  <b>Tcl_DoOneEvent</b> to invoke after waiting
                                                          for events.  Checks to see if any events have occurred
                                                          and, if so, queues them.

       void <u>*clientData</u> (in)                              Arbitrary  one-word  value  to  pass   to   <u>setupProc</u>,
                                                          <u>checkProc</u>, or <u>deleteProc</u>.

       const Tcl_Time <u>*timePtr</u> (in)                       Indicates  the  maximum  amount of time to wait for an
                                                          event.  This is specified as an interval (how long  to
                                                          wait),  not an absolute time (when to wakeup).  If the
                                                          pointer passed to <b>Tcl_WaitForEvent</b> is NULL,  it  means
                                                          there  is  no  maximum  wait  time:   wait  forever if
                                                          necessary.

       Tcl_Event <u>*evPtr</u> (in)                              An event to add to the event queue.  The  storage  for
                                                          the event must have been allocated by the caller using
                                                          <b>Tcl_Alloc</b>.

       int <u>position</u> (in)                                  Where   to   add   the   new   event   in  the  queue:
                                                          <b>TCL_QUEUE_TAIL</b>,  <b>TCL_QUEUE_HEAD</b>,  <b>TCL_QUEUE_MARK</b>,  and
                                                          whether  to  do  an  alert  if  the  queue  is  empty:
                                                          <b>TCL_QUEUE_ALERT_IF_EMPTY</b>.

       Tcl_ThreadId <u>threadId</u> (in)                         A unique identifier for a thread.

       Tcl_EventDeleteProc <u>*deleteProc</u> (in)               Procedure  to  invoke  for  each   queued   event   in
                                                          <b>Tcl_DeleteEvents</b>.

       int <u>flags</u> (in)                                     What  types of events to service.  These flags are the
                                                          same as those passed to <b>Tcl_DoOneEvent</b>.

       int <u>mode</u> (in)                                      Indicates  whether  events  should  be   serviced   by
                                                          <b>Tcl_ServiceAll</b>.   Must  be  one of <b>TCL_SERVICE_NONE</b> or
                                                          <b>TCL_SERVICE_ALL</b>.

       const <u>Tcl_NotifierProcs*</u> (notifierProcPtr)         Structure of  function  pointers  describing  notifier
                                                          procedures  that  are to replace the ones installed in
                                                          the  executable.   See  <b>REPLACING</b>  <b>THE</b>  <b>NOTIFIER</b>   for
                                                          details.
________________________________________________________________________________________________________________

</pre><h4><b>INTRODUCTION</b></h4><pre>
       The  interfaces  described  here  are  used  to  customize  the  Tcl  event  loop.   The  two most common
       customizations are to add new sources of events and to merge Tcl's event loop with some other event loop,
       such as one provided by an application in which Tcl is embedded.  Each of these tasks is described  in  a
       separate section below.

       The  procedures  in  this  manual  entry  are  the building blocks out of which the Tcl event notifier is
       constructed.  The event notifier is the lowest layer in the Tcl event mechanism.  It  consists  of  three
       things:

       [1]    Event sources: these represent the ways in which events can be generated.  For example, there is a
              timer event source that implements the <b>Tcl_CreateTimerHandler</b> procedure and the <b>after</b> command, and
              there  is a file event source that implements the <b>Tcl_CreateFileHandler</b> procedure on Unix systems.
              An event source must work with the notifier to detect events at the right times,  record  them  on
              the  event  queue,  and  eventually  notify  higher-level  software  that they have occurred.  The
              procedures <b>Tcl_CreateEventSource</b>, <b>Tcl_DeleteEventSource</b>, and <b>Tcl_SetMaxBlockTime</b>,  <b>Tcl_QueueEvent</b>,
              and <b>Tcl_DeleteEvents</b> are used primarily by event sources.

       [2]    The  event queue: there is a single queue for each thread containing a Tcl interpreter, containing
              events that have been detected but not yet serviced.  Event sources place events onto the queue so
              that they may be processed in order at appropriate times during the event loop.  The  event  queue
              guarantees a fair discipline of event handling, so that no event source can starve the others.  It
              also  allows events to be saved for servicing at a future time.  <b>Tcl_QueueEvent</b> is used (primarily
              by event sources) to add events to the current thread's event queue and <b>Tcl_DeleteEvents</b>  is  used
              to remove events from the queue without processing them.

       [3]    The  event  loop:  in order to detect and process events, the application enters a loop that waits
              for events to occur, places them on the event queue, and then processes them.   Most  applications
              will  do  this  by  calling  the procedure <b>Tcl_DoOneEvent</b>, which is described in a separate manual
              entry.

       Most Tcl applications need not worry about any of the  internals  of  the  Tcl  notifier.   However,  the
       notifier  now  has  enough  flexibility  to be retargeted either for a new platform or to use an external
       event loop (such as the Motif event loop, when Tcl is embedded in a Motif application).   The  procedures
       <b>Tcl_WaitForEvent</b>  and <b>Tcl_SetTimer</b> are normally implemented by Tcl, but may be replaced with new versions
       to retarget the  notifier  (the  <b>Tcl_InitNotifier</b>,  <b>Tcl_AlertNotifier</b>,  <b>Tcl_FinalizeNotifier</b>,  <b>Tcl_Sleep</b>,
       <b>Tcl_CreateFileHandler</b>, and <b>Tcl_DeleteFileHandler</b> must also be replaced; see CREATING A NEW NOTIFIER below
       for    details).     The    procedures    <b>Tcl_ServiceAll</b>,   <b>Tcl_ServiceEvent</b>,   <b>Tcl_GetServiceMode</b>,   and
       <b>Tcl_SetServiceMode</b> are provided to help connect Tcl's event loop  to  an  external  event  loop  such  as
       Motif's.

</pre><h4><b>NOTIFIER</b> <b>BASICS</b></h4><pre>
       The  easiest  way to understand how the notifier works is to consider what happens when <b>Tcl_DoOneEvent</b> is
       called.  <b>Tcl_DoOneEvent</b> is passed a <u>flags</u> argument that indicates what sort of events it is OK to process
       and also whether or not to block if no events are ready.  <b>Tcl_DoOneEvent</b> does the following things:

       [1]    Check the event queue to see if it contains any events that can be serviced.  If so,  service  the
              first  possible  event,  remove  it  from  the  queue,  and  return.   It  does  this  by  calling
              <b>Tcl_ServiceEvent</b> and passing in the <u>flags</u> argument.

       [2]    Prepare to block for an event.  To do this, <b>Tcl_DoOneEvent</b> invokes a <u>setup</u> <u>procedure</u> in each event
              source.  The event source will perform event-source  specific  initialization  and  possibly  call
              <b>Tcl_SetMaxBlockTime</b> to limit how long <b>Tcl_WaitForEvent</b> will block if no new events occur.

       [3]    Call  <b>Tcl_WaitForEvent</b>.   This  procedure  is  implemented differently on different platforms;  it
              waits for an event to occur, based on the information provided by the event sources.  It may cause
              the application to block if <u>timePtr</u> specifies an interval other than 0.  <b>Tcl_WaitForEvent</b>  returns
              when  something  has  happened,  such as a file becoming readable or the interval given by <u>timePtr</u>
              expiring.  If there are no events for <b>Tcl_WaitForEvent</b>  to  wait  for,  so  that  it  would  block
              forever, then it returns immediately and <b>Tcl_DoOneEvent</b> returns 0.

       [4]    Call a <u>check</u> <u>procedure</u> in each event source.  The check procedure determines whether any events of
              interest to this source occurred.  If so, the events are added to the event queue.

       [5]    Check  the  event queue to see if it contains any events that can be serviced.  If so, service the
              first possible event, remove it from the queue, and return.

       [6]    See if there are idle callbacks pending. If so, invoke all of them and return.

       [7]    Either return 0 to indicate that no events were ready, or go back to  step  [2]  if  blocking  was
              requested by the caller.

</pre><h4><b>CREATING</b> <b>A</b> <b>NEW</b> <b>EVENT</b> <b>SOURCE</b></h4><pre>
       An  event  source consists of three procedures invoked by the notifier, plus additional C procedures that
       are invoked by higher-level code to arrange for event-driven callbacks.  The three procedures  called  by
       the notifier consist of the setup and check procedures described above, plus an additional procedure that
       is invoked when an event is removed from the event queue for servicing.

       The  procedure  <b>Tcl_CreateEventSource</b>  creates  a  new  event  source.   Its  arguments specify the setup
       procedure and check procedure for the event source.  <u>SetupProc</u> should match the following prototype:

              typedef void <b>Tcl_EventSetupProc</b>(
                      void *<u>clientData</u>,
                      int <u>flags</u>);

       The <u>clientData</u> argument will be the same as the <u>clientData</u>  argument  to  <b>Tcl_CreateEventSource</b>;   it  is
       typically  used  to point to private information managed by the event source.  The <u>flags</u> argument will be
       the same as the <u>flags</u> argument passed to <b>Tcl_DoOneEvent</b> except that it will never  be  0  (<b>Tcl_DoOneEvent</b>
       replaces  0  with <b>TCL_ALL_EVENTS</b>).  <u>Flags</u> indicates what kinds of events should be considered; if the bit
       corresponding to this event source is not set, the event source should return immediately  without  doing
       anything.  For example, the file event source checks for the <b>TCL_FILE_EVENTS</b> bit.

       <u>SetupProc</u>'s  job  is  to  make  sure that the application wakes up when events of the desired type occur.
       This is typically done in a platform-dependent fashion.  For example, under Unix an  event  source  might
       call <b>Tcl_CreateFileHandler</b>; under Windows it might request notification with a Windows event.  For timer-
       driven   event   sources  such  as  timer  events  or  any  polled  event,  the  event  source  can  call
       <b>Tcl_SetMaxBlockTime</b> to force the application to wake up after a specified time even  if  no  events  have
       occurred.   If  no  event  source  calls  <b>Tcl_SetMaxBlockTime</b>  then <b>Tcl_WaitForEvent</b> will wait as long as
       necessary for an event to occur; otherwise, it will only wait as long as the shortest interval passed  to
       <b>Tcl_SetMaxBlockTime</b>  by  one  of  the event sources.  If an event source knows that it already has events
       ready to report, it can request a zero maximum block time.  For example, the setup procedure  for  the  X
       event source looks to see if there are events already queued.  If there are, it calls <b>Tcl_SetMaxBlockTime</b>
       with  a 0 block time so that <b>Tcl_WaitForEvent</b> does not block if there is no new data on the X connection.
       The <u>timePtr</u> argument to <b>Tcl_WaitForEvent</b> points to a structure that describes a time interval in  seconds
       and microseconds:

              typedef struct {
                  long long <u>sec</u>;
                  long <u>usec</u>;
              } <b>Tcl_Time</b>;

       The <u>usec</u> field should be less than 1000000.

       Information  provided  to  <b>Tcl_SetMaxBlockTime</b>  is only used for the next call to <b>Tcl_WaitForEvent</b>; it is
       discarded after <b>Tcl_WaitForEvent</b> returns.  The next time an event wait is done each of the event sources'
       setup procedures will be called again, and they can specify new information for that event wait.

       If the application uses an external event loop rather than <b>Tcl_DoOneEvent</b>, the event sources may need  to
       call <b>Tcl_SetMaxBlockTime</b> at other times.  For example, if a new event handler is registered that needs to
       poll for events, the event source may call <b>Tcl_SetMaxBlockTime</b> to set the block time to zero to force the
       external  event  loop  to  call  Tcl.   In  this  case, <b>Tcl_SetMaxBlockTime</b> invokes <b>Tcl_SetTimer</b> with the
       shortest interval seen since the last call to <b>Tcl_DoOneEvent</b> or <b>Tcl_ServiceAll</b>.

       In addition to the generic procedure <b>Tcl_SetMaxBlockTime</b>, other platform-specific procedures may also  be
       available  for <u>setupProc</u>, if there is additional information needed by <b>Tcl_WaitForEvent</b> on that platform.
       For example, on Unix systems the <b>Tcl_CreateFileHandler</b> interface can be used to wait for file events.

       The second procedure provided by each event source is its check procedure,  indicated  by  the  <u>checkProc</u>
       argument to <b>Tcl_CreateEventSource</b>.  <u>CheckProc</u> must match the following prototype:

              typedef void <b>Tcl_EventCheckProc</b>(
                      void *<u>clientData</u>,
                      int <u>flags</u>);

       The  arguments  to  this  procedure  are  the  same  as  those  for  <u>setupProc</u>.   <b>CheckProc</b> is invoked by
       <b>Tcl_DoOneEvent</b> after it has waited for events.  Presumably at least one event source is now  prepared  to
       queue  an  event.   <b>Tcl_DoOneEvent</b>  calls each of the event sources in turn, so they all have a chance to
       queue any events that are ready.  The check procedure does two things.  First, it must see if any  events
       have triggered.  Different event sources do this in different ways.

       If  an  event source's check procedure detects an interesting event, it must add the event to Tcl's event
       queue.  To do this, the event source calls  <b>Tcl_QueueEvent</b>.   The  <u>evPtr</u>  argument  is  a  pointer  to  a
       dynamically allocated structure containing the event (see below for more information on memory management
       issues).   Each  event source can define its own event structure with whatever information is relevant to
       that event source.  However, the first element of the structure must be a structure  of  type  <b>Tcl_Event</b>,
       and the address of this structure is used when communicating between the event source and the rest of the
       notifier.  A <b>Tcl_Event</b> has the following definition:

              typedef struct Tcl_Event {
                  Tcl_EventProc *<u>proc</u>;
                  struct Tcl_Event *<u>nextPtr</u>;
              } <b>Tcl_Event</b>;

       The  event source must fill in the <u>proc</u> field of the event before calling <b>Tcl_QueueEvent</b>.  The <u>nextPtr</u> is
       used to link together the events in the queue and should not be modified by the event source.

       An event may be added to the queue at any of three positions,  depending  on  the  <u>position</u>  argument  to
       <b>Tcl_QueueEvent</b>:

       <b>TCL_QUEUE_TAIL</b>                  Add  the event at the back of the queue, so that all other pending events
                                       will be serviced first.  This is almost always the right  place  for  new
                                       events.

       <b>TCL_QUEUE_HEAD</b>                  Add  the  event  at  the  front of the queue, so that it will be serviced
                                       before all other queued events.

       <b>TCL_QUEUE_MARK</b>                  Add the event at the front of the queue, unless there are other events at
                                       the front whose position is <b>TCL_QUEUE_MARK</b>;  if so,  add  the  new  event
                                       just  after  all  other <b>TCL_QUEUE_MARK</b> events.  This value of <u>position</u> is
                                       used to insert an ordered sequence of events at the front of  the  queue,
                                       such  as  a series of Enter and Leave events synthesized during a grab or
                                       ungrab operation in Tk.

       <b>TCL_QUEUE_ALERT_IF_EMPTY</b>        When used in <b>Tcl_ThreadQueueEvent</b>  arranges  for  an  automatic  call  of
                                       <b>Tcl_ThreadAlert</b> when the queue was empty.

       When  it is time to handle an event from the queue (steps 1 and 4 above) <b>Tcl_ServiceEvent</b> will invoke the
       <u>proc</u> specified in the first queued <b>Tcl_Event</b> structure.  <u>Proc</u> must match the following prototype:

              typedef int <b>Tcl_EventProc</b>(
                      Tcl_Event *<u>evPtr</u>,
                      int <u>flags</u>);

       The first argument to <u>proc</u> is a pointer to the event, which will be the same as the first argument to the
       <b>Tcl_QueueEvent</b> call that added the event to the queue.  The second argument to <u>proc</u> is the <u>flags</u> argument
       for the current call to <b>Tcl_ServiceEvent</b>;  this is used by the event source to return immediately if  its
       events are not relevant.

       It  is  up  to  <u>proc</u>  to  handle  the  event,  typically  by invoking one or more Tcl commands or C-level
       callbacks.  Once the event source has finished handling the event it returns 1 to indicate that the event
       can be removed from the queue.  If for some reason the event source decides  that  the  event  cannot  be
       handled at this time, it may return 0 to indicate that the event should be deferred for processing later;
       in this case <b>Tcl_ServiceEvent</b> will go on to the next event in the queue and attempt to service it.  There
       are  several  reasons  why  an event source might defer an event.  One possibility is that events of this
       type are excluded by the <u>flags</u> argument.  For example, the file event source will always return 0 if  the
       <b>TCL_FILE_EVENTS</b>  bit  is  not  set  in  <u>flags</u>.   Another  example  of  deferring  events happens in Tk if
       <b>Tk_RestrictEvents</b> has been invoked to defer certain kinds of window events.

       When <u>proc</u> returns 1, <b>Tcl_ServiceEvent</b> will remove the event from the event queue and  free  its  storage.
       Note that the storage for an event must be allocated by the event source (using <b>Tcl_Alloc</b>) before calling
       <b>Tcl_QueueEvent</b>, but it will be freed by <b>Tcl_ServiceEvent</b>, not by the event source.

       Calling  <b>Tcl_QueueEvent</b> adds an event to the current thread's queue.  To add an event to another thread's
       queue, use <b>Tcl_ThreadQueueEvent</b>.  <b>Tcl_ThreadQueueEvent</b> accepts as an argument  a  Tcl_ThreadId  argument,
       which  uniquely  identifies  a  thread  in a Tcl application.  To obtain the Tcl_ThreadId for the current
       thread, use the <b>Tcl_GetCurrentThread</b> procedure.  (A thread would then need to  pass  this  identifier  to
       other threads for those threads to be able to add events to its queue.)  After adding an event to another
       thread's  queue,  you  then typically need to call <b>Tcl_ThreadAlert</b> to “wake up” that thread's notifier to
       alert it to the new event.

       <b>Tcl_DeleteEvents</b>  can  be  used  to  explicitly  remove  one  or  more  events  from  the  event   queue.
       <b>Tcl_DeleteEvents</b> calls <u>proc</u> for each event in the queue, deleting those for with the procedure returns 1.
       Events  for  which  the  procedure  returns  0  are  left  in the queue.  <u>Proc</u> should match the following
       prototype:

              typedef int <b>Tcl_EventDeleteProc</b>(
                      Tcl_Event *<u>evPtr</u>,
                      void *<u>clientData</u>);

       The <u>clientData</u> argument will be the same as the <u>clientData</u> argument to <b>Tcl_DeleteEvents</b>; it is  typically
       used to point to private information managed by the event source.  The <u>evPtr</u> will point to the next event
       in the queue.

       <b>Tcl_DeleteEventSource</b>  deletes  an event source.  The <u>setupProc</u>, <u>checkProc</u>, and <u>clientData</u> arguments must
       exactly match those provided to the <b>Tcl_CreateEventSource</b> for the event source to be deleted.  If no such
       source exists, <b>Tcl_DeleteEventSource</b> has no effect.

</pre><h4><b>CREATING</b> <b>A</b> <b>NEW</b> <b>NOTIFIER</b></h4><pre>
       The notifier consists of all the procedures described in  this  manual  entry,  plus  <b>Tcl_DoOneEvent</b>  and
       <b>Tcl_Sleep</b>,  which  are  available  on all platforms, and <b>Tcl_CreateFileHandler</b> and <b>Tcl_DeleteFileHandler</b>,
       which are Unix-specific.  Most of these procedures are generic,  in  that  they  are  the  same  for  all
       notifiers.   However, none of the procedures are notifier-dependent: <b>Tcl_InitNotifier</b>, <b>Tcl_AlertNotifier</b>,
       <b>Tcl_FinalizeNotifier</b>,     <b>Tcl_SetTimer</b>,     <b>Tcl_Sleep</b>,      <b>Tcl_WaitForEvent</b>,      <b>Tcl_CreateFileHandler</b>,
       <b>Tcl_DeleteFileHandler</b>  and  <b>Tcl_ServiceModeHook</b>.   To  support a new platform or to integrate Tcl with an
       application-specific event loop, you must write new versions of these procedures.

       <b>Tcl_InitNotifier</b> initializes the notifier state and returns a handle to the notifier  state.   Tcl  calls
       this  procedure  when  initializing  a  Tcl  interpreter.  Similarly, <b>Tcl_FinalizeNotifier</b> shuts down the
       notifier, and is called by <b>Tcl_Finalize</b> when shutting down a Tcl interpreter.

       <b>Tcl_WaitForEvent</b> is the lowest-level procedure in the notifier; it is  responsible  for  waiting  for  an
       “interesting”  event to occur or for a given time to elapse.  Before <b>Tcl_WaitForEvent</b> is invoked, each of
       the event sources' setup procedure will have been invoked.   The  <u>timePtr</u>  argument  to  <b>Tcl_WaitForEvent</b>
       gives  the  maximum  time  to  block  for  an  event, based on calls to <b>Tcl_SetMaxBlockTime</b> made by setup
       procedures and on other information (such as the <b>TCL_DONT_WAIT</b> bit in <u>flags</u>).

       Ideally, <b>Tcl_WaitForEvent</b> should only wait for an event to occur; it  should  not  actually  process  the
       event  in  any way.  Later on, the event sources will process the raw events and create Tcl_Events on the
       event queue in their <u>checkProc</u> procedures.  However, on some platforms (such  as  Windows)  this  is  not
       possible;  events  may  be  processed  in  <b>Tcl_WaitForEvent</b>,  including  queuing Tcl_Events and more (for
       example, callbacks for native widgets may be invoked).  The return value from  <b>Tcl_WaitForEvent</b>  must  be
       either  0,  1,  or  -1.   On  platforms such as Windows where events get processed in <b>Tcl_WaitForEvent</b>, a
       return value of 1 means that there may be more events still pending that have not been  processed.   This
       is  a  sign  to  the caller that it must call <b>Tcl_WaitForEvent</b> again if it wants all pending events to be
       processed. A 0 return value means that calling <b>Tcl_WaitForEvent</b> again will not have  any  effect:  either
       this   is  a  platform  where  <b>Tcl_WaitForEvent</b>  only  waits  without  doing  any  event  processing,  or
       <b>Tcl_WaitForEvent</b> knows for sure that there are no additional events to process (e.g. it returned  because
       the  time elapsed).  Finally, a return value of -1 means that the event loop is no longer operational and
       the application should probably unwind and terminate.  Under Windows this happens when a WM_QUIT  message
       is  received; under Unix it happens when <b>Tcl_WaitForEvent</b> would have waited forever because there were no
       active event sources and the timeout was infinite.

       <b>Tcl_AlertNotifier</b> is used to allow any thread to “wake up” the notifier to alert it to new events on  its
       queue.  <b>Tcl_AlertNotifier</b> requires as an argument the notifier handle returned by <b>Tcl_InitNotifier</b>.

       If  the  notifier  will  be  used with an external event loop, then it must also support the <b>Tcl_SetTimer</b>
       interface.  <b>Tcl_SetTimer</b> is invoked by <b>Tcl_SetMaxBlockTime</b> whenever the maximum blocking  time  has  been
       reduced.   <b>Tcl_SetTimer</b>  should  arrange  for  the external event loop to invoke <b>Tcl_ServiceAll</b> after the
       specified interval even if no events have occurred.  This interface is needed because <b>Tcl_WaitForEvent</b> is
       not invoked when there is an external event loop.  If the notifier will only be used from <b>Tcl_DoOneEvent</b>,
       then <b>Tcl_SetTimer</b> need not do anything.

       <b>Tcl_ServiceModeHook</b> is called by the platform-independent portion of the notifier when client code  makes
       a  call  to  <b>Tcl_SetServiceMode</b>.  This hook is provided to support operating systems that require special
       event handling when the application is in a modal loop (the Windows notifier,  for  instance,  uses  this
       hook to create a communication window).

       On  Unix  systems,  the  file  event  source also needs support from the notifier.  The file event source
       consists of the <b>Tcl_CreateFileHandler</b> and <b>Tcl_DeleteFileHandler</b> procedures, which are  described  in  the
       <b>Tcl_CreateFileHandler</b> manual page.

       The <b>Tcl_Sleep</b> and <b>Tcl_DoOneEvent</b> interfaces are described in their respective manual pages.

       The  easiest  way  to  create a new notifier is to look at the code for an existing notifier, such as the
       files <b>unix/tclUnixNotfy.c</b> or <b>win/tclWinNotify.c</b> in the Tcl source distribution.

</pre><h4><b>REPLACING</b> <b>THE</b> <b>NOTIFIER</b></h4><pre>
       A notifier that has been written according to the conventions above can also be installed  in  a  running
       process  in  place  of  the standard notifier.  This mechanism is used so that a single executable can be
       used (with the standard notifier) as a stand-alone program and reused (with a replacement notifier  in  a
       loadable extension) as an extension to another program, such as a Web browser plugin.

       To  do  this, the extension makes a call to <b>Tcl_SetNotifier</b> passing a pointer to a <b>Tcl_NotifierProcs</b> data
       structure.  The structure has the following layout:

              typedef struct {
                  Tcl_SetTimerProc *<u>setTimerProc</u>;
                  Tcl_WaitForEventProc *<u>waitForEventProc</u>;
                  Tcl_CreateFileHandlerProc *<u>createFileHandlerProc</u>;
                  Tcl_DeleteFileHandlerProc *<u>deleteFileHandlerProc</u>;
                  Tcl_InitNotifierProc *<u>initNotifierProc</u>;
                  Tcl_FinalizeNotifierProc *<u>finalizeNotifierProc</u>;
                  Tcl_AlertNotifierProc *<u>alertNotifierProc</u>;
                  Tcl_ServiceModeHookProc *<u>serviceModeHookProc</u>;
              } <b>Tcl_NotifierProcs</b>;

       Following the call to <b>Tcl_SetNotifier</b>, the pointers given  in  the  <b>Tcl_NotifierProcs</b>  structure  replace
       whatever notifier had been installed in the process.

       It is extraordinarily unwise to replace a running notifier. Normally, <b>Tcl_SetNotifier</b> should be called at
       process initialization time before the first call to <b>Tcl_InitNotifier</b>.

</pre><h4><b>EXTERNAL</b> <b>EVENT</b> <b>LOOPS</b></h4><pre>
       The  notifier  interfaces  are designed so that Tcl can be embedded into applications that have their own
       private event loops.  In this case, the application does not call <b>Tcl_DoOneEvent</b> except in  the  case  of
       recursive  event  loops  such as calls to the Tcl commands <b>update</b> or <b>vwait</b>.  Most of the time is spent in
       the external event loop of the application.  In this case the notifier  must  arrange  for  the  external
       event  loop  to  call  back  into  Tcl  when  something  happens on the various Tcl event sources.  These
       callbacks should arrange for appropriate Tcl events to be placed on the Tcl event queue.

       Because the external event loop is not calling <b>Tcl_DoOneEvent</b> on  a  regular  basis,  it  is  up  to  the
       notifier to arrange for <b>Tcl_ServiceEvent</b> to be called whenever events are pending on the Tcl event queue.
       The  easiest  way  to  do  this is to invoke <b>Tcl_ServiceAll</b> at the end of each callback from the external
       event loop.  This will ensure that all of the event sources are polled, any queued events  are  serviced,
       and  any  pending  idle handlers are processed before returning control to the application.  In addition,
       event sources that need to poll for events can call <b>Tcl_SetMaxBlockTime</b> to force the external event  loop
       to call Tcl even if no events are available on the system event queue.

       As  a  side  effect  of  processing  events  detected  in  the  main  external event loop, Tcl may invoke
       <b>Tcl_DoOneEvent</b> to start a recursive event loop in commands like <b>vwait</b>.  <b>Tcl_DoOneEvent</b>  will  invoke  the
       external  event  loop, which will result in callbacks as described in the preceding paragraph, which will
       result in calls to <b>Tcl_ServiceAll</b>.  However, in these cases  it  is  undesirable  to  service  events  in
       <b>Tcl_ServiceAll</b>.   Servicing  events  there  is unnecessary because control will immediately return to the
       external event loop and hence to <b>Tcl_DoOneEvent</b>, which  can  service  the  events  itself.   Furthermore,
       <b>Tcl_DoOneEvent</b>  is  supposed to service only a single event, whereas <b>Tcl_ServiceAll</b> normally services all
       pending events.  To handle this situation, <b>Tcl_DoOneEvent</b> sets a flag for <b>Tcl_ServiceAll</b> that  causes  it
       to return without servicing any events.  This flag is called the <u>service</u> <u>mode</u>; <b>Tcl_DoOneEvent</b> restores it
       to its previous value before it returns.

       In  some  cases,  however, it may be necessary for <b>Tcl_ServiceAll</b> to service events even when it has been
       invoked from <b>Tcl_DoOneEvent</b>.  This happens when there is yet another recursive event loop invoked via  an
       event  handler  called  by  <b>Tcl_DoOneEvent</b>  (such as one that is part of a native widget).  In this case,
       <b>Tcl_DoOneEvent</b> may not have a chance to service events so <b>Tcl_ServiceAll</b>  must  service  them  all.   Any
       recursive  event loop that calls an external event loop rather than <b>Tcl_DoOneEvent</b> must reset the service
       mode so that all events get processed in <b>Tcl_ServiceAll</b>.  This is done by invoking the <b>Tcl_SetServiceMode</b>
       procedure.  If <b>Tcl_SetServiceMode</b> is passed <b>TCL_SERVICE_NONE</b>, then calls to  <b>Tcl_ServiceAll</b>  will  return
       immediately  without  processing any events.  If <b>Tcl_SetServiceMode</b> is passed <b>TCL_SERVICE_ALL</b>, then calls
       to <b>Tcl_ServiceAll</b> will behave normally.  <b>Tcl_SetServiceMode</b> returns the previous  value  of  the  service
       mode,  which  should  be  restored when the recursive loop exits.  <b>Tcl_GetServiceMode</b> returns the current
       value of the service mode.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/Tcl_CreateFileHandler.3tcl.html">Tcl_CreateFileHandler</a>(3tcl),    <a href="../man3tcl/Tcl_DeleteFileHandler.3tcl.html">Tcl_DeleteFileHandler</a>(3tcl),    <a href="../man3tcl/Tcl_Sleep.3tcl.html">Tcl_Sleep</a>(3tcl),    <a href="../man3tcl/Tcl_DoOneEvent.3tcl.html">Tcl_DoOneEvent</a>(3tcl),
       <a href="../man3tcl/Thread.3tcl.html">Thread</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       event, notifier, event queue, event sources, file events, timer, idle, service mode, threads

Tcl                                                    8.1                                        <u><a href="../man3tcl/Notifier.3tcl.html">Notifier</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>