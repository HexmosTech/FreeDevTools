<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::Interface - Perl extension to access network interfaces</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-interface-perl">libnet-interface-perl_1.016-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::Interface - Perl extension to access network interfaces

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Net::Interface qw(
               cidr2mask
               full_inet_ntop
               ipV6compress
               mac_bin2hex
               mask2cidr
               net_symbols
               type
               scope
               inet_aton
               inet_ntoa
               inet_pton
               inet_ntop
               :afs
               :pfs
               :ifs
               :iffs
               :iffIN6
               :iftype
               :scope
               :constants
               :inet
               :all
               :lower
               :upper
         );

   <b>TAGS</b>
         Note: tags :afs, :pfs, :constants, :ifs
               include all AF_[family names], PF_[family names] and
               IFxxxx values that exist on this architecture.

               :iffs includes only IFF_xxx values
               :iffIN6 includes IN6_IFF_xxx values on BSD flavored OS's

               :inet includes inet_aton, inet_ntoa,
                       inet_pton, inet_ntop

         On platforms that support IPV6, :iftype :scope
         provide additional attribute screening

         :constants is a deprecated synonym for :ifs

       See Net::Interface::NetSymbols built specifically for this platform for a detailed list and description
       of all symbols available on this specific architecture and operating systems version.

       By default <b>Net::Interface</b> functions and methods return string IPv6 addresses and MAC addresses in
       uppercase.  To change that to lowercase:

         use Net::Interface qw(:lower);

       To ensure the current string case behavior even if the default changes:

         use Net::Interface qw(:upper);

   <b>FUNCTIONS</b> <b>and</b> <b>METHODS</b>
         @all_ifs = Net::Interface-&gt;interfaces();

         $this_if    = Net::Interface-&gt;new('eth0');
         $refresh_if = $any_if-&gt;new();
         $refresh_if = $this_if-&gt;delete($naddr);

         $create_if  = Net::Interface-&gt;new(\%iface_spec);

         @ifnames     = "@all_ifs";
         $if_name_txt = $if-&gt;name;

         print $if,"\n";       # prints the name
         print "@all_ifs\n"    # prints all names

        ---------------------------------------------
               WARNING API CHANGE !

           $naddr = $if-&gt;address([$family],[$index]);
           $naddr = $if-&gt;netmask([$family],[$index]);
           $naddr = $if-&gt;destination([$family],[$index]);
               same as
           $naddr = $if-&gt;broadcast([$family],[$index]);

           @addresses = $if-&gt;address([$family]);
           @netmasks  = $if-&gt;netmask([$family]);
           @destinats = $if-&gt;destination([$family]);
               same as
           @broaddrs  = $if-&gt;broadcast([$family]);

           $bin_mac = $if-&gt;hwaddress($hwaddr);
        ---------------------------------------------

         $val = $if-&gt;flags($val);
         $val = $if-&gt;mtu ($val);
         $val = $if-&gt;metric($val);
         $val = $if=&gt;index();

         $cidr = $if-&gt;mask2cidr([$naddmsk])
         $cidr = mask2cidr($naddrmsk);
         $naddrmsk = cidr2mask($cidr,[family])

         $mac_txt = if-&gt;mac_bin2hex();
         $mac_txt = mac_bin2hex($bin_mac);

         $naddr   = inet_aton($host or $dotquad);
         $dotquad = inet_ntoa($naddr);

         $info = $if-&gt;info();

           for ipV6 only
         $type  = $if-&gt;type([$naddr6]);
         $type  = type($naddr6);
         $scope = $if-&gt;scope([$naddr6]);
         $scope = scope($naddr6);

         $full_ipV6_txt = full_inet_ntop($naddr6);
         $ipV6_txt = inet_ntop($naddr6)
         $naddr6   = inet_pton($ipV6_txt);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Net::Interface</b> is a module that allows access to the host network interfaces in a manner similar to
       <u><b><a href="../man8/ifconfig.8.html">ifconfig</a></b>(8)</u>. Version 1.00 is a complete re-write and includes support for IPV6 as well as the traditional
       IPV4.

       Both read and write access to network device attributes including the creation of new logical and
       physical interfaces is available where supported by the OS and this module.

       NOTE: if your OS is not supported, please feel free to contribute new capabilities, patches, etc.... see:
       Net::Interface::Developer

       ANOTHER NOTE: Many of the operations of <b>Net::Interface</b>, particularly those that set interface values
       require privileged access to OS resources.  Wherever possible, <b>Net::Interface</b> will simply fail <u>softly</u>
       when there are not adequate privileges to perform the requested operation or where the operation is not
       supported.

</pre><h4><b>OPERATION</b></h4><pre>
       <b>Net::Interface</b> retrieves information about the network devices on its host in a fashion similar to
       <u><b><a href="../man8/ifconfig.8.html">ifconfig</a></b>(8)</u> running in a terminal window.  With <u><b><a href="../man8/ifconfig.8.html">ifconfig</a></b>(8)</u>, the information is returned to the screen
       and any additional activity on a particular network device goes on without the knowledge of the user.
       Similarly, <b>Net::Interface</b> only retrieves information about network devices when methods <u>interfaces</u> and
       <u>new</u> are invoked. Calls to <u>interfaces</u> retrieves information about all network devices known to the host.
       Calls to <u>new</u> make the same function call to the host library but rather than returning all the interface
       net device information to the user, it selects out only information for the specified device. The
       function call to the OS is the same. This information is cached in the object returned to the user
       interface and it is from this object that data is returned to the user program.

       To continually monitor a particular device, it is necessary to issue repeat calls to <u>new</u>.

</pre><h4><b>SYMBOLS</b></h4><pre>
       <b>Net::Interface</b> provide a large number of network interface symbols with a module generated on its build
       host. These symbols include all of the available AF_xxxx, PF_xxx, IFF_xxx symbols and many more. For a
       detailed list of all of these symbols, see Net::Interface::NetSymbols.

   <b>HINTS</b> <b>and</b> <b>TIPS</b> <b>for</b> <b>use</b> <b>SYMBOLS</b>
       Most of the symbols provided by <b>Net::Interface</b> have dual values.

       1) a numeric value when use in arithmetic context and

       2) a text value when used in string/text context

       Symbols are actually calls to functions. Because of this certain usage rules apply that are not
       necessarily obvious.

       If you make it a practice to build your Perl modules using:

         #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
         use strict;

       Then usage of symbols will require that they explicitly be called as functions. i.e.

         $functval = &amp;AF_INET          is OK

         $functval = AF_INET()         is better

       The first calling method allows the function to pick up the contents of <b>@_</b>. This works fine as long as <b>@_</b>
       is empty. Since symbols do not take arguments, when <b>@_</b> contains something the symbol call will fail with
       a message from Perl about inappropriate calling syntax.

       If you do not "use strict;" (not recommended) then bare symbols will work just fine in your Perl scripts.
       You can also imbed your symbols in blocks where <b>strict;</b> is not enforced.

         {
               no strict;
               $functval = AF_INET
         }

       Lastly, to access the numeric value of a symbol unconditionally:

         $numeric = 0 + AF_INET

</pre><h4><b>WARNING</b> <b>-</b> <b>API</b> <b>CHANGES</b></h4><pre>
       The following changes have been made to the API. This may <u>BREAK</u> existing code. If you have been using a
       previous version of Net::Interface you should verify that these API changes do not break your code.

       <b>NO</b> <b>LONGER</b> <b>SUPPORTED</b>

       •     <u>$naddr=$if-&gt;address($naddr);</u>

       •     <u>$naddr=$if-&gt;netmask($naddr);</u>

       •     <u>$naddr=$if-&gt;destination($naddr);</u>

       •     <u>$naddr=$if-&gt;broadcast($naddr);</u>

       •     <u>$mac</u> <u>=</u> <u>$if-</u>hwaddress($hwaddr);&gt;

       Setting  address  values  was never implemented in previous versions of Net::Interface. With this version
       (where supported) changing an address will be implemented using a hash argument containing  the  required
       and optional elements in a manner similar to <u><b><a href="../man8/ifconfig.8.html">ifconfig</a></b>(8)</u>. See:

               Net::Interface-&gt;new(\%iface_spec);

       <b>NO</b> <b>LONGER</b> <b>SUPPORTED</b>

       •     <u>($sa_family,$size,$naddr)=$if-&gt;address($naddr);</u>

       On  most  platforms,  multiple  addresses  and  multiple  address  families  can  be assigned to the same
       interface. The returned data described above conflicts with the requirement to report multiple  addresses
       for  a  particular  interface. In addition, the returned information only reflected the attributes of the
       <u>FIRST</u> address assigned to the device where there could be many of mixed families. i.e. AF_INET, AF_INET6,
       and perhaps more as the capabilities of this module are enhanced to support additional address families.

       The API has been changed to reflect this reality and the need to report multiple addresses  on  the  same
       interface.

               @addresses = $if-&gt;address([$family]);

       The new API is described in detail later in this document.

       <b>NO</b> <b>LONGER</b> <b>SUPPORTED</b>

       •     <u>($sa_family,$size,$hwaddr)=$if-&gt;hwaddress($hwaddr);</u>

       As  in  the  preceding  case, it is not possible to accurately report the address family attributes of an
       interface which may support assignments of more than one address from differing address families.

               see: if-&gt;info();

</pre><h4><b>METHODS</b></h4><pre>
       Brackets [] indicates an optional parameter.

       The return value for <u>SET</u> attempts on systems that do not support the operation is  not  settled.  Current
       practice is to silently ignore the set request. This may change so don't count on this behavior.

       Unless  otherwise  specified,  errors for all methods return either <b>undef</b> or and empty array depending on
       the expected return context.

       •   <u>-&gt;<b>interfaces()</b>;</u>

           Returns a list of interface objects for each interface that supports IPV4 or IPV6.

           On failure, returns an empty list.

               usage:

                   @all_ifs = Net::Interface-&gt;interfaces();

                   foreach my $if (@all_ifs) {
                     $if_name = $if-&gt;name;
                       or
                     print $if, "\n";      # (overloaded)
                   }

               Get or Set (where supported)
                   $old_mtu = $if-&gt;mtu($new_mtu);
                   $old_metric = $if-&gt;metric($new_metric);
               etc...

       •   <u>-&gt;<b>new()</b>;</u> has multiple calling invocations.

           This method will refresh the data for an existing interface OR it can modify and  existing  interface
           OR it can create a new interface or alias.

           •   $this_if = <u>-&gt;new('eth0');</u>

               Same  as  <u>-&gt;interfaces</u> above except for a single known interface. An interface object is returned
               for the specific logical device requested.

               On failure return <b>undef</b>

           •   $refresh_if = <u>-&gt;<b>new()</b>;</u>

               The a new (refreshed) interface object is returned for the same logical device.

           •   $new_if = <u>-&gt;new(%iface_spec);</u>

           •   $new_if = <u>-&gt;new(\%iface_spec);</u>

               A logical device is created or updated. The specification is contained in a hash  table  that  is
               passed to <u>new</u> either directly or as a reference.

               The  interface  specification  is  architecture  dependent.  For example, adding an address to an
               existing interface.

                       i.e.    Linux

                 $iface_spec = {
                       name      =&gt; 'eth0:0',
                       address   =&gt; inet_aton('192.168.1.2'),
                       netmask   =&gt; inet_aton('255.255.255.0),
                 # netmask may be optionally specified as:
                 #     cidr      =&gt; 24,
                       broadcast =&gt; inet_aton('192.168.1.255),
                 # optional values, defaults shown
                       metric    =&gt; 1,
                       mtu       =&gt; 1500,
                 };

               The address family is determined by inspection of the size of the address.

                       i.e.    BSD variants

                 $iface_spec = {
                       name      =&gt; 'eth0',    # primary interface
                       alias     =&gt; inet_aton('192.168.1.2'),
                       netmask   =&gt; inet_aton('255.255.255.255),
                 # netmask may be optionally specified as:
                 #     cidr      =&gt; 32,
                 # optional values, defaults shown
                       metric    =&gt; 1,
                       mtu       =&gt; 1500,
                 };

               The keyword <b>alias</b> says not to change the primary interface but instead to add an address  to  the
               interface.

       •   $refresh_if = <u>-&gt;delete($naddr);</u>

           Removes and address from an interface where supported.

       •   <u>-&gt;<b>name()</b>;</u>

           Return the <b>name</b> of the interface.

       •   <u>-&gt;address([$family],[$index]);</u>

           <b>SCALAR</b> <b>context</b>

           Get the interface specified by the optional $family and $index.

           Absent  a $family and $index, the first available interface for the family AF_INET (or if not present
           AF_INET6) will be returned.

           NOTE: this is not a definitive response. The OS may report the interfaces in any order.  Usually  the
           primary  interface is reported first but this is not guaranteed. Use ARRAY context instead to get all
           addresses.

           <b>ARRAY</b> <b>context</b>

           Returns a list of addresses assigned to this interface.

           If a $family is not specified then AF_INET is assumed or AF_INET6 if there are no  AF_INET  addresses
           present.

       •   <u>-&gt;netmask([$family],[$index]);</u>

           Similar  to  <u>-&gt;address([$family],[$index]);</u>  above.  Netmasks  are  reported in the same order as the
           addresses above, in matching positions in the returned array.

       •   <u>-&gt;destination([$family],[$index]);</u>

       •   <u>-&gt;broadcast([$family],[$index]);</u>

           These to methods are identical in execution. The returned address attribute(s) will be destination or
           broadcast addresses depending on the status of the POINTOPOINT flag.

           Similar to <u>-&gt;address([$family],[$index]);</u> above. If an address attribute is unknown, the  array  slot
           will contain <u>undef</u>.

       •   <u>-&gt;hwaddress([$hwaddr]);</u>

           Returns the binary value of the MAC address for the interface. Optionally, where supported, it allows
           setting of the MAC address.

             i.e.  $old_binmac = $if-&gt;hwaddress($new_binmac);
                   $new_binmac = $if-&gt;hwaddress();

       •   <u>-&gt;flags([$new_flags]);</u>

           Get or Set (where supported) the flags on the interface.

                   i.e. down an interface.
                   $flags  = $if-&gt;flags();
                   $mask   = ~IFF_UP;
                   $old_fg = $if-&gt;flags($flags &amp; $mask);
                   $flags  = $if-&gt;flags();

                   UPDATES the if object

           NOTE: returns undef if the interface is down or not configured.

       •   <u>-&gt;mtu([$new_mtu]);</u>

           Get or Set (where supported) the mtu of the interface.

                   $mtu = $if-&gt;mtu();
                   $old_mtu = $if-&gt;mtu($new_mtu);

                   UPDATES the if object

           NOTE: returns undef if the interface is down or not configured.

       •   <u>-&gt;metric([$new_metric]);</u>

           Get or Set (where supported) the metric for the interface.

                   $metric = $if-&gt;metric();
                   $old_metric = $if-&gt;metric($new_metric);

                   UPDATES the if object

           NOTE: returns undef if the interface is down or not configured.

       •   <u>-&gt;<b>index()</b>;</u>

           Get  the interface index, not to be confused with the index number of the IP assigned to a particular
           index.

           There is no provision to SET the index.

                   $index = $if-&gt;index();

       •   <u>-&gt;mask2cidr([$naddrmsk]);</u>

       •   $cidr = mask2cidr($naddrmsk);

           Returns the CIDR (prefix length) for the netmask $naddrmsk.

           When no <u>$naddrmsk</u> is specified the method will return the first address in the first family  starting
           with  AF_INET, AF_INET6, etc... This is particularly useful for interfaces with only a single address
           assigned.

           May be called as a METHOD or a FUNCTION.

       •   <u>-&gt;<b>mac_bin2hex()</b>;</u>

       •   $mac_txt = mac_bin2hex($bin_mac);

           Converts a binary MAC address into hex text.

             i.e. A1:B2:C3:D4:E5:F6

           May be called as a METHOD or a FUNCTION.

       •   <u>-&gt;<b>info()</b>;</u>

           Returns a pointer to a hash containing information about the interface as follows:

             $info = {
                   name    =&gt; 'eth0',
                   index   =&gt; 1,
                   mtu     =&gt; 1500,
                   metric  =&gt; 1,
                   flags   =&gt; 1234,
                   mac     =&gt; binary_mac_address,
                   $fam0   =&gt; {
                           number  =&gt; of_addresses,
                           size    =&gt; of_address,
                   },
                   $fam1   =&gt; etc....
             };

             where $famX is one of AF_INET, AF_INET6, etc...

       •   <u>-&gt;type([$naddr6]);</u>

       •   $type = type($naddr6);

           <b>ipV6</b> method. Returns attributes of an IPV6 address that may be tested with these bit masks:

             IPV6_ADDR_ANY                 unknown
             IPV6_ADDR_UNICAST             unicast
             IPV6_ADDR_MULTICAST           multicast
             IPV6_ADDR_ANYCAST             anycast
             IPV6_ADDR_LOOPBACK            loopback
             IPV6_ADDR_LINKLOCAL           link-local
             IPV6_ADDR_SITELOCAL           site-local
             IPV6_ADDR_COMPATv4            compat-v4
             IPV6_ADDR_SCOPE_MASK          scope-mask
             IPV6_ADDR_MAPPED              mapped
             IPV6_ADDR_RESERVED            reserved
             IPV6_ADDR_ULUA                uniq-lcl-unicast
             IPV6_ADDR_6TO4                6to4
             IPV6_ADDR_6BONE               6bone
             IPV6_ADDR_AGU                 global-unicast
             IPV6_ADDR_UNSPECIFIED         unspecified
             IPV6_ADDR_SOLICITED_NODE      solicited-node
             IPV6_ADDR_ISATAP              ISATAP
             IPV6_ADDR_PRODUCTIVE          productive
             IPV6_ADDR_6TO4_MICROSOFT      6to4-ms
             IPV6_ADDR_TEREDO              teredo
             IPV6_ADDR_ORCHID              orchid
             IPV6_ADDR_NON_ROUTE_DOC       non-routeable-doc

               i.e.  if ($type &amp; $mask) {
                         print $mask,"\n";
                     ...

           ... will print the string shown to the right of the bit mask.

           When no <u>$naddr6</u> is specified the method will  return  the  first  AF_INET6  address  found.  This  is
           particularly useful for interfaces with only a single address assigned.

           May be called as a METHOD or a FUNCTION with an $naddr6 argument.

       •   <u>-&gt;scope([$naddr6]);</u>

       •   $scope = scope($naddr6);

           Returns the RFC-2373 scope of an IPV6 address that may be equated to these constants.

             RFC2373_GLOBAL        global-scope    0xE
             RFC2373_ORGLOCAL      org-local       0x8
             RFC2373_SITELOCAL     site-local      0x5
             RFC2373_LINKLOCAL     link-local      0x2
             RFC2373_NODELOCAL     loopback        0x1

           One  additional  constant  is  provided  as  there is an out of band scope value mapped returned when
           determining scope. If you want <b>standard</b> RFC2373 scope only, &amp;&amp; the return value with 0xF

             LINUX_COMPATv4        lx-compat-v4    0x10

               i.e.  if ($scope = $const) {
                         print $const,"\n";
                     ...

           ... will print the string shown to the right of the constant.

           When no <u>$naddr6</u> is specified the method will  return  the  first  AF_INET6  address  found.  This  is
           particularly useful for interfaces with only a single address assigned.

           May be called as a METHOD or a FUNCTION with an $naddr6 argument.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       Unless  otherwise  specified,  errors for all methods return either <b>undef</b> or and empty array depending on
       the expected return context.

       •   $naddr = inet_aton($host or $dotquad);

           Converts a hostname or dotquad ipV4 address into a packed network address.

       •   $dotquad = inet_ntoa($naddr);

           Convert a binary IPV4 address into a dotquad text string.

       •   $ipV6_txt = full_inet_ntop($naddr6);

             Returns an uncompressed text string for a net6 address.

             i.e.   FE80:02A0:0000:0000:0000:0000:0123:4567

       •   $minimized = ipV6compress($ipV6_txt);

           Compress an ipV6 address to the minimum RFC-1884 format

             i.e.  FE80:02A0:0000:0000:0000:0000:0123:4567
             to    FE80:2A0::123:4567

       •   $ipV6_txt = inet_ntop($naddr6)

             Returns a minimized RFC-1884 IPV6 address

       •   $naddr6 = inet_pton($ipV6_txt);

           Takes an IPv6 text address of the form described in rfc1884 and  returns  a  naddr6  128  bit  binary
           address string in network order.

       •   $cidr = mask2cidr($naddrmsk);

       •   <u>-&gt;mask2cidr($naddrmsk);</u>

           Returns the CIDR (prefix length) for the netmask $naddrmsk.

           May be called as a FUNCTION or a METHOD.

       •   $mac_txt = mac_bin2hex($bin_mac);

       •   <u>-&gt;<b>mac_bin2hex()</b>;</u>

           Converts a binary MAC address into hex text.

             i.e. A1:B2:C3:D4:E5:F6

           May be called as a FUNCTION or a METHOD.

       •   $type = type($naddr6);

       •   <u>-&gt;type($naddr6);</u>

           <b>ipV6</b> method. Returns attributes of an IPV6 address that may be tested with the bit masks described in
           detail in the METHOD section above.

           May be called as a FUNCTION or a METHOD with an $naddr6 argument.

       •   $scope = scope($naddr6);

       •   <u>-&gt;scope($naddr6);</u>

           Returns  the  RFC-2373  scope  of  an  IPV6 address that may be equated module constants described in
           detail in the METHOD section above.

           May be called as a FUNCTION or a METHOD with an $naddr6 argument.

       •   $symbolptr = <b>net_symbols()</b>;

           Returns a hash containing most of the network symbols available for this architecture.

             where $symbolptr = {
                   SYMBOL_TEXT =&gt; value,
                   ...
             };

           Most all of these symbols have both a numeric and text value. Perl does the <b>right</b> thing and uses  the
           numeric value in all logic and arithmetic operations and provides the text value for print requests.

           To print the numeric value:

             print (0 + &amp;SYMBOL),"\n";

             i.e.  print (0 + AF_INET()),"\n";

           results in the digit <b>2</b> being printed, whereas:

                   print AF_INET,"\n";

           results in the string "<b>inet</b>" being printed.

             NOTE: that many symbols are OS dependent. Do not use
                   numeric values in your code, instead use the symbol.

             i.e. AF_INET, AF_INET6, AF_LINK, etc...

</pre><h4><b>PREREQUISITES</b></h4><pre>
       To  build  Net::Interface,  it  is necessary to have kernel development libriaries installed on the build
       system. Systems such as Ubuntu, FreeBSD, etc... do NOT come with these libraries installed.

       Your build system must have a fully populated directory

           /usr/include/sys

       Missing header files in the above directory will produce errors saying that symbols such as  AF_INET  and
       PF_INET are missing.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       This  version  of  Net::Interface  has been completely rewritten and updated to include support for IPV6.
       Credit should be given to the original author

               Stephen Zander &lt;<a href="mailto:gibreel@pobox.com">gibreel@pobox.com</a>&gt;

       for conceiving the idea behind Net::Interface and to the work done by

               Jerrad Pierce <a href="mailto:jpierce@cpan.org">jpierce@cpan.org</a>

       on the maintenance and improvements to the original version.

       Thanks also go to

               Jens Rehsack &lt;<a href="mailto:rehsack@web.de">rehsack@web.de</a>&gt;

       for inspiring me to create this updated version and for his assistance in vetting the design concepts and
       loads of other helpful things.

       The following functions are used in whole or in part as include  files  to  Interface.xs.  The  copyright
       (same as Perl itself) is include in the file.

           file:              functions:

         miniSocketXS.c  inet_aton, inet_ntoa

       inet_aton,  inet_ntoa  are  from  the  perl-5.8.0  release by Larry Wall, copyright 1989-2002. inet_aton,
       inet_ntoa code is current through perl-5.9.3 release.  Thank you Larry for making PERL possible  for  all
       of us.

</pre><h4><b>COPYRIGHT</b> <b>2008-2016</b> <b>Michael</b> <b>Robinton</b> <b>&lt;<a href="mailto:michael@bizsystems.com">michael@bizsystems.com</a>&gt;</b></h4><pre>
       All rights reserved.

       This program is free software; you can redistribute it and/or modify it under the terms of either:

         a) the GNU General Public License as published by the Free
         Software Foundation; either version 2, or (at your option) any
         later version, or

         b) the "Artistic License" which comes with this distribution.

       This  program  is  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
       the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either the GNU  General
       Public License or the Artistic License for more details.

       You  should  have  received  a  copy  of  the  Artistic License with this distribution, in the file named
       "Artistic".  If not, I'll be glad to provide one.

       You should also have received a copy of the GNU General Public License along with  this  program  in  the
       file named "Copying". If not, write to the

               Free Software Foundation, Inc.
               59 Temple Place, Suite 330
               Boston, MA  02111-1307, USA

       or visit their web page on the internet at:

               <a href="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</a>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/ifconfig.8.html">ifconfig</a></b>(8), Net::Interface::NetSymbols, Net::Interface::Developer

perl v5.40.1                                       2024-05-19                                     <u><a href="../man3pm/Interface.3pm.html">Interface</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>