<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>file - File interface module.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       file - File interface module.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides an interface to the file system.

   <b>Warning:</b>
       File  operations  are  only guaranteed to appear atomic when going through the same file server. A NIF or
       other OS process may observe intermediate steps on certain operations  on  some  operating  systems,  eg.
       renaming an existing file on Windows, or <u>write_file_info/2</u> on any OS at the time of writing.

       Regarding  filename  encoding,  the  Erlang  VM can operate in two modes. The current mode can be queried
       using function <u>native_name_encoding/0</u>. It returns <u>latin1</u> or <u>utf8</u>.

       In <u>latin1</u> mode, the Erlang VM does not change the encoding of filenames.  In  <u>utf8</u>  mode,  filenames  can
       contain  Unicode  characters  greater than 255 and the VM converts filenames back and forth to the native
       filename encoding (usually UTF-8, but UTF-16 on Windows).

       The default mode depends on the operating  system.  Windows,  MacOS  X  and  Android  enforce  consistent
       filename encoding and therefore the VM uses <u>utf8</u> mode.

       On  operating  systems with transparent naming (for example, all Unix systems except MacOS X), default is
       <u>utf8</u> if the terminal supports UTF-8, otherwise <u>latin1</u>. The default can be overridden using <u>+fnl</u> (to force
       <u>latin1</u> mode) or <u>+fnu</u> (to force <u>utf8</u> mode) when starting <u>erl</u>.

       On operating systems with transparent naming, files can be inconsistently named, for example, some  files
       are  encoded in UTF-8 while others are encoded in ISO Latin-1. The concept of <u>raw</u> <u>filenames</u> is introduced
       to handle file systems with inconsistent naming when running in <u>utf8</u> mode.

       A <u>raw</u> <u>filename</u> is a filename specified as a binary. The Erlang VM does not translate a filename specified
       as a binary on systems with transparent naming.

       When running in <u>utf8</u> mode, functions <u>list_dir/1</u> and <u>read_link/1</u> never return raw filenames. To return all
       filenames including raw filenames, use functions <u>list_dir_all/1</u> and <u>read_link_all/1</u>.

       See also section Notes About Raw Filenames in the STDLIB User's Guide.

   <b>Note:</b>
       File operations used to accept filenames containing null characters (integer value zero). This caused the
       name to be truncated and in some cases arguments to  primitive  operations  to  be  mixed  up.  Filenames
       containing  null characters inside the filename are now <u>rejected</u> and will cause primitive file operations
       fail.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>deep_list()</b> = [char() | atom() | deep_list()]

       <b>fd()</b>

              A file descriptor representing a file opened in <u>raw</u> mode.

       <b>filename()</b> = string()

              See also the documentation of the <u>name_all()</u> type.

       <b>filename_all()</b> = string() | binary()

              See also the documentation of the <u>name_all()</u> type.

       <b>io_device()</b> = pid() | fd()

              As returned by <u>open/2</u>; <u>pid()</u> is a process handling I/O-protocols.

       <b>name()</b> = string() | atom() | deep_list()

              If VM is in Unicode filename mode, <u>string()</u> and <u>char()</u> are allowed to  be  &gt;  255.  See  also  the
              documentation of the <u>name_all()</u> type.

       <b>name_all()</b> =
           string() | atom() | deep_list() | (RawFilename :: binary())

              If  VM  is in Unicode filename mode, characters are allowed to be &gt; 255. <u>RawFilename</u> is a filename
              not subject to Unicode translation, meaning that it can contain characters not conforming  to  the
              Unicode  encoding  expected from the file system (that is, non-UTF-8 characters although the VM is
              started in Unicode filename mode). Null  characters  (integer  value  zero)  are  <u>not</u>  allowed  in
              filenames (not even at the end).

       <b>posix()</b> =
           eacces | eagain | ebadf | ebadmsg | ebusy | edeadlk |
           edeadlock | edquot | eexist | efault | efbig | eftype |
           eintr | einval | eio | eisdir | eloop | emfile | emlink |
           emultihop | enametoolong | enfile | enobufs | enodev |
           enolck | enolink | enoent | enomem | enospc | enosr | enostr |
           enosys | enotblk | enotdir | enotsup | enxio | eopnotsupp |
           eoverflow | eperm | epipe | erange | erofs | espipe | esrch |
           estale | etxtbsy | exdev

              An  atom  that  is  named from the POSIX error codes used in Unix, and in the runtime libraries of
              most C compilers.

       <b>date_time()</b> = calendar:datetime()

              Must denote a valid date and time.

       <b>file_info()</b> =
           #file_info{size = integer() &gt;= 0 | undefined,
                      type =
                          device | directory | other | regular |
                          symlink | undefined,
                      access =
                          read | write | read_write | none | undefined,
                      atime =
                          file:date_time() |
                          integer() &gt;= 0 |
                          undefined,
                      mtime =
                          file:date_time() |
                          integer() &gt;= 0 |
                          undefined,
                      ctime =
                          file:date_time() |
                          integer() &gt;= 0 |
                          undefined,
                      mode = integer() &gt;= 0 | undefined,
                      links = integer() &gt;= 0 | undefined,
                      major_device = integer() &gt;= 0 | undefined,
                      minor_device = integer() &gt;= 0 | undefined,
                      inode = integer() &gt;= 0 | undefined,
                      uid = integer() &gt;= 0 | undefined,
                      gid = integer() &gt;= 0 | undefined}

       <b>location()</b> =
           integer() |
           {bof, Offset :: integer()} |
           {cur, Offset :: integer()} |
           {eof, Offset :: integer()} |
           bof | cur | eof

       <b>mode()</b> =
           read | write | append | exclusive | raw | binary |
           {delayed_write,
            Size :: integer() &gt;= 0,
            Delay :: integer() &gt;= 0} |
           delayed_write |
           {read_ahead, Size :: integer() &gt;= 1} |
           read_ahead | compressed |
           {encoding, unicode:encoding()} |
           sync

       <b>file_info_option()</b> =
           {time, local} | {time, universal} | {time, posix} | raw

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>advise(IoDevice,</b> <b>Offset,</b> <b>Length,</b> <b>Advise)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = io_device()
                 Offset = Length = integer()
                 Advise = posix_file_advise()
                 Reason = posix() | badarg
                 <b>posix_file_advise()</b> =
                     normal | sequential | random | no_reuse | will_need |
                     dont_need

              <u>advise/4</u> can be used to announce an intention to access file data in a  specific  pattern  in  the
              future, thus allowing the operating system to perform appropriate optimizations.

              On some platforms, this function might have no effect.

       <b>allocate(File,</b> <b>Offset,</b> <b>Length)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>posix()}</b>

              Types:

                 File = io_device()
                 Offset = Length = integer() &gt;= 0

              <u>allocate/3</u> can be used to preallocate space for a file.

              This function only succeeds in platforms that provide this feature.

       <b>change_group(Filename,</b> <b>Gid)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Gid = integer()
                 Reason = posix() | badarg

              Changes group of a file. See <u>write_file_info/2</u>.

       <b>change_mode(Filename,</b> <b>Mode)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Mode = integer()
                 Reason = posix() | badarg

              Changes permissions of a file. See <u>write_file_info/2</u>.

       <b>change_owner(Filename,</b> <b>Uid)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Uid = integer()
                 Reason = posix() | badarg

              Changes owner of a file. See <u>write_file_info/2</u>.

       <b>change_owner(Filename,</b> <b>Uid,</b> <b>Gid)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Uid = Gid = integer()
                 Reason = posix() | badarg

              Changes owner and group of a file. See <u>write_file_info/2</u>.

       <b>change_time(Filename,</b> <b>Mtime)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Mtime = date_time()
                 Reason = posix() | badarg

              Changes the modification and access times of a file. See <u>write_file_info/2</u>.

       <b>change_time(Filename,</b> <b>Atime,</b> <b>Mtime)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Atime = Mtime = date_time()
                 Reason = posix() | badarg

              Changes the modification and last access times of a file. See <u>write_file_info/2</u>.

       <b>close(IoDevice)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = io_device()
                 Reason = posix() | badarg | terminated

              Closes  the  file referenced by <u>IoDevice</u>. It mostly returns <u>ok</u>, except for some severe errors such
              as out of memory.

              Notice that if option <u>delayed_write</u> was used when opening the file,  <u>close/1</u>  can  return  an  old
              write error and not even try to close the file. See <u>open/2</u>.

       <b>consult(Filename)</b> <b>-&gt;</b> <b>{ok,</b> <b>Terms}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Terms = [term()]
                 Reason =
                     posix() |
                     badarg | terminated | system_limit |
                     {Line :: integer(), Mod :: module(), Term :: term()}

              Reads Erlang terms, separated by '.', from <u>Filename</u>. Returns one of the following:

                <u>{ok,</u> <u>Terms}</u>:
                  The file was successfully read.

                <u>{error,</u> <u>atom()}</u>:
                  An  error occurred when opening the file or reading it. For a list of typical error codes, see
                  <u>open/2</u>.

                <u>{error,</u> <u>{Line,</u> <u>Mod,</u> <u>Term}}</u>:
                  An error occurred when interpreting the Erlang terms in the file. To convert the three-element
                  tuple to an English description of the error, use <u>format_error/1</u>.

              <u>Example:</u>

              f.txt:  {person, "kalle", 25}.
                      {person, "pelle", 30}.

              1&gt; file:consult("f.txt").
              {ok,[{person,"kalle",25},{person,"pelle",30}]}

              The encoding of <u>Filename</u> can be set by a comment, as described in <u><a href="../man3erl/epp.3erl.html">epp</a>(3erl)</u>.

       <b>copy(Source,</b> <b>Destination)</b> <b>-&gt;</b> <b>{ok,</b> <b>BytesCopied}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>copy(Source,</b> <b>Destination,</b> <b>ByteCount)</b> <b>-&gt;</b>
               {ok, BytesCopied} | {error, Reason}

              Types:

                 Source = Destination = io_device() | Filename | {Filename, Modes}
                 Filename = name_all()
                 Modes = [mode()]
                 ByteCount = integer() &gt;= 0 | infinity
                 BytesCopied = integer() &gt;= 0
                 Reason = posix() | badarg | terminated

              Copies <u>ByteCount</u> bytes from  <u>Source</u>  to  <u>Destination</u>.  <u>Source</u>  and  <u>Destination</u>  refer  to  either
              filenames  or  IO  devices  from, for example, <u>open/2</u>. <u>ByteCount</u> defaults to <u>infinity</u>, denoting an
              infinite number of bytes.

              Argument <u>Modes</u> is a list of possible modes, see <u>open/2</u>, and defaults to <u>[]</u>.

              If both <u>Source</u> and <u>Destination</u> refer to filenames, the files are opened with  <u>[read,</u>  <u>binary]</u>  and
              <u>[write,</u> <u>binary]</u> prepended to their mode lists, respectively, to optimize the copy.

              If  <u>Source</u> refers to a filename, it is opened with <u>read</u> mode prepended to the mode list before the
              copy, and closed when done.

              If <u>Destination</u> refers to a filename, it is opened with <u>write</u>  mode  prepended  to  the  mode  list
              before the copy, and closed when done.

              Returns  <u>{ok,</u> <u>BytesCopied}</u>, where <u>BytesCopied</u> is the number of bytes that was copied, which can be
              less than <u>ByteCount</u> if end of file was encountered on the source. If the operation fails,  <u>{error,</u>
              <u>Reason}</u> is returned.

              Typical error reasons: as for <u>open/2</u> if a file had to be opened, and as for <u>read/2</u> and <u>write/2</u>.

       <b>datasync(IoDevice)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = io_device()
                 Reason = posix() | badarg | terminated

              Ensures  that  any  buffers  kept  by  the operating system (not by the Erlang runtime system) are
              written to disk. In many ways it resembles <u>fsync</u> but it does not update some of  the  metadata  of
              the file, such as the access time. On some platforms this function has no effect.

              Applications that access databases or log files often write a tiny data fragment (for example, one
              line  in  a  log  file)  and  then  call  <u>fsync()</u>  immediately  to ensure that the written data is
              physically stored on the hard disk. Unfortunately, <u>fsync()</u> always initiates two write  operations:
              one  for  the  newly  written  data  and another one to update the modification time stored in the
              <u>inode</u>. If the modification time is not a part of the transaction concept, <u>fdatasync()</u> can be  used
              to avoid unnecessary <u>inode</u> disk write operations.

              Available  only in some POSIX systems, this call results in a call to <u>fsync()</u>, or has no effect in
              systems not providing the <u>fdatasync()</u> syscall.

       <b>del_dir(Dir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Dir = name_all()
                 Reason = posix() | badarg

              Tries to delete directory <u>Dir</u>. The directory must be empty before it can be deleted. Returns <u>ok</u> if
              successful.

              Typical error reasons:

                <u>eacces</u>:
                  Missing search or write permissions for the parent directories of <u>Dir</u>.

                <u>eexist</u>:
                  The directory is not empty.

                <u>enoent</u>:
                  The directory does not exist.

                <u>enotdir</u>:
                  A component of <u>Dir</u> is not a directory. On some platforms, <u>enoent</u> is returned instead.

                <u>einval</u>:
                  Attempt to delete the current directory. On some platforms, <u>eacces</u> is returned instead.

       <b>del_dir_r(File)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 File = name_all()
                 Reason = posix() | badarg

              Deletes file or directory <u>File</u>. If <u>File</u> is a directory, its contents is first recursively deleted.
              Returns:

                <u>ok</u>:
                  The operation completed without errors.

                <u>{error,</u> <u>posix()}</u>:
                  An error occurred when accessing or deleting <u>File</u>. If some file or directory under <u>File</u>  could
                  not be deleted, <u>File</u> cannot be deleted as it is non-empty, and <u>{error,</u> <u>eexist}</u> is returned.

       <b>delete(Filename)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>delete(Filename,</b> <b>Opts)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Opts = [delete_option()]
                 Reason = posix() | badarg
                 <b>delete_option()</b> = raw

              Tries to delete file <u>Filename</u>. Returns <u>ok</u> if successful.

              If  the  option <u>raw</u> is set, the file server is not called. This can be useful in particular during
              the early boot stage when the file server is not yet registered, to still be able to delete  local
              files.

              Typical error reasons:

                <u>enoent</u>:
                  The file does not exist.

                <u>eacces</u>:
                  Missing permission for the file or one of its parents.

                <u>eperm</u>:
                  The file is a directory and the user is not superuser.

                <u>enotdir</u>:
                  A component of the filename is not a directory. On some platforms, <u>enoent</u> is returned instead.

                <u>einval</u>:
                  <u>Filename</u> has an improper type, such as tuple.

          <b>Warning:</b>
              In a future release, a bad type for argument <u>Filename</u> will probably generate an exception.

       <b>eval(Filename)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Reason =
                     posix() |
                     badarg | terminated | system_limit |
                     {Line :: integer(), Mod :: module(), Term :: term()}

              Reads  and  evaluates  Erlang  expressions, separated by '.' (or ',', a sequence of expressions is
              also an expression) from <u>Filename</u>. The result of the evaluation is not  returned;  any  expression
              sequence in the file must be there for its side effect. Returns one of the following:

                <u>ok</u>:
                  The file was read and evaluated.

                <u>{error,</u> <u>atom()}</u>:
                  An  error occurred when opening the file or reading it. For a list of typical error codes, see
                  <u>open/2</u>.

                <u>{error,</u> <u>{Line,</u> <u>Mod,</u> <u>Term}}</u>:
                  An error occurred when interpreting the Erlang expressions in the file. To convert the  three-
                  element tuple to an English description of the error, use <u>format_error/1</u>.

              The encoding of <u>Filename</u> can be set by a comment, as described in <u><a href="../man3erl/epp.3erl.html">epp</a>(3erl)</u>.

       <b>eval(Filename,</b> <b>Bindings)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Bindings = erl_eval:binding_struct()
                 Reason =
                     posix() |
                     badarg | terminated | system_limit |
                     {Line :: integer(), Mod :: module(), Term :: term()}

              The same as <u>eval/1</u>, but the variable bindings <u>Bindings</u> are used in the evaluation. For information
              about the variable bindings, see <u><a href="../man3erl/erl_eval.3erl.html">erl_eval</a>(3erl)</u>.

       <b>format_error(Reason)</b> <b>-&gt;</b> <b>Chars</b>

              Types:

                 Reason =
                     posix() |
                     badarg | terminated | system_limit |
                     {Line :: integer(), Mod :: module(), Term :: term()}
                 Chars = string()

              Given  the  error  reason returned by any function in this module, returns a descriptive string of
              the error in English.

       <b>get_cwd()</b> <b>-&gt;</b> <b>{ok,</b> <b>Dir}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Dir = filename()
                 Reason = posix()

              Returns <u>{ok,</u> <u>Dir}</u>, where <u>Dir</u> is the current working directory of the file server.

          <b>Note:</b>
              In rare circumstances, this function can fail on Unix. It can occur if read  permission  does  not
              exist for the parent directories of the current directory.

              A typical error reason:

                <u>eacces</u>:
                  Missing read permission for one of the parents of the current directory.

       <b>get_cwd(Drive)</b> <b>-&gt;</b> <b>{ok,</b> <b>Dir}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Drive = string()
                 Dir = filename()
                 Reason = posix() | badarg

              Returns  <u>{ok,</u> <u>Dir}</u> or <u>{error,</u> <u>Reason}</u>, where <u>Dir</u> is the current working directory of the specified
              drive.

              <u>Drive</u> is to be of the form "<u>Letter:</u>", for example, "c:".

              Returns <u>{error,</u> <u>enotsup}</u> on platforms that have no concept of current drive (Unix, for example).

              Typical error reasons:

                <u>enotsup</u>:
                  The operating system has no concept of drives.

                <u>eacces</u>:
                  The drive does not exist.

                <u>einval</u>:
                  The format of <u>Drive</u> is invalid.

       <b>list_dir(Dir)</b> <b>-&gt;</b> <b>{ok,</b> <b>Filenames}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Dir = name_all()
                 Filenames = [filename()]
                 Reason =
                     posix() |
                     badarg |
                     {no_translation, Filename :: unicode:latin1_binary()}

              Lists all files in a directory, <u>except</u> files  with  raw  filenames.  Returns  <u>{ok,</u>  <u>Filenames}</u>  if
              successful,  otherwise  <u>{error,</u>  <u>Reason}</u>. <u>Filenames</u> is a list of the names of all the files in the
              directory. The names are not sorted.

              Typical error reasons:

                <u>eacces</u>:
                  Missing search or write permissions for <u>Dir</u> or one of its parent directories.

                <u>enoent</u>:
                  The directory does not exist.

                <u>{no_translation,</u> <u>Filename}</u>:
                  <u>Filename</u> is a <u>binary()</u> with characters coded in ISO  Latin-1  and  the  VM  was  started  with
                  parameter <u>+fnue</u>.

       <b>list_dir_all(Dir)</b> <b>-&gt;</b> <b>{ok,</b> <b>Filenames}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Dir = name_all()
                 Filenames = [filename_all()]
                 Reason = posix() | badarg

              Lists all the files in a directory, including files with raw filenames. Returns <u>{ok,</u> <u>Filenames}</u> if
              successful,  otherwise  <u>{error,</u>  <u>Reason}</u>. <u>Filenames</u> is a list of the names of all the files in the
              directory. The names are not sorted.

              Typical error reasons:

                <u>eacces</u>:
                  Missing search or write permissions for <u>Dir</u> or one of its parent directories.

                <u>enoent</u>:
                  The directory does not exist.

       <b>make_dir(Dir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Dir = name_all()
                 Reason = posix() | badarg

              Tries to create directory  <u>Dir</u>.  Missing  parent  directories  are  <u>not</u>  created.  Returns  <u>ok</u>  if
              successful.

              Typical error reasons:

                <u>eacces</u>:
                  Missing search or write permissions for the parent directories of <u>Dir</u>.

                <u>eexist</u>:
                  A file or directory named <u>Dir</u> exists already.

                <u>enoent</u>:
                  A component of <u>Dir</u> does not exist.

                <u>enospc</u>:
                  No space is left on the device.

                <u>enotdir</u>:
                  A component of <u>Dir</u> is not a directory. On some platforms, <u>enoent</u> is returned instead.

       <b>make_link(Existing,</b> <b>New)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Existing = New = name_all()
                 Reason = posix() | badarg

              Makes  a  hard  link  from  <u>Existing</u> to <u>New</u> on platforms supporting links (Unix and Windows). This
              function returns <u>ok</u> if the link was successfully created, otherwise <u>{error,</u> <u>Reason}</u>. On  platforms
              not supporting links, <u>{error,enotsup}</u> is returned.

              Typical error reasons:

                <u>eacces</u>:
                  Missing read or write permissions for the parent directories of <u>Existing</u> or <u>New</u>.

                <u>eexist</u>:
                  <u>New</u> already exists.

                <u>enotsup</u>:
                  Hard links are not supported on this platform.

       <b>make_symlink(Existing,</b> <b>New)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Existing = New = name_all()
                 Reason = posix() | badarg

              Creates  a  symbolic  link  <u>New</u> to the file or directory <u>Existing</u> on platforms supporting symbolic
              links (most Unix systems and Windows, beginning with Vista). <u>Existing</u>  does  not  need  to  exist.
              Returns  <u>ok</u>  if  the  link  is  successfully  created, otherwise <u>{error,</u> <u>Reason}</u>. On platforms not
              supporting symbolic links, <u>{error,</u> <u>enotsup}</u> is returned.

              Typical error reasons:

                <u>eacces</u>:
                  Missing read or write permissions for the parent directories of <u>Existing</u> or <u>New</u>.

                <u>eexist</u>:
                  <u>New</u> already exists.

                <u>enotsup</u>:
                  Symbolic links are not supported on this platform.

                <u>eperm</u>:
                  User does not have privileges  to  create  symbolic  links  (<u>SeCreateSymbolicLinkPrivilege</u>  on
                  Windows).

       <b>native_name_encoding()</b> <b>-&gt;</b> <b>latin1</b> <b>|</b> <b>utf8</b>

              Returns  the filename encoding mode. If it is <u>latin1</u>, the system translates no filenames. If it is
              <u>utf8</u>, filenames are converted back and forth to the native filename encoding (usually  UTF-8,  but
              UTF-16 on Windows).

       <b>open(File,</b> <b>Modes)</b> <b>-&gt;</b> <b>{ok,</b> <b>IoDevice}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 File = Filename | iodata()
                 Filename = name_all()
                 Modes = [mode() | ram | directory]
                 IoDevice = io_device()
                 Reason = posix() | badarg | system_limit

              Opens  file  <u>File</u>  in the mode determined by <u>Modes</u>, which can contain one or more of the following
              options:

                <u>read</u>:
                  The file, which must exist, is opened for reading.

                <u>write</u>:
                  The file is opened for writing. It is created if it does not exist. If  the  file  exists  and
                  <u>write</u> is not combined with <u>read</u>, the file is truncated.

                <u>append</u>:
                  The file is opened for writing. It is created if it does not exist. Every write operation to a
                  file opened with <u>append</u> takes place at the end of the file.

                <u>exclusive</u>:
                  The  file  is  opened  for  writing.  It  is created if it does not exist. If the file exists,
                  <u>{error,</u> <u>eexist}</u> is returned.

            <b>Warning:</b>
                This option does not guarantee exclusiveness on file systems  not  supporting  <u>O_EXCL</u>  properly,
                such  as  NFS. Do not depend on this option unless you know that the file system supports it (in
                general, local file systems are safe).

                <u>raw</u>:
                  Allows faster access to a file, as no Erlang process is needed to handle the file. However,  a
                  file opened in this way has the following limitations:

                  * The  functions  in the <u>io</u> module cannot be used, as they can only talk to an Erlang process.
                    Instead, use functions <u>read/2</u>, <u>read_line/1</u>, and <u>write/2</u>.

                  * Especially if <u>read_line/1</u> is to be used on a <u>raw</u> file, it is  recommended  to  combine  this
                    option with option <u>{read_ahead,</u> <u>Size}</u> as line-oriented I/O is inefficient without buffering.

                  * Only the Erlang process that opened the file can use it.

                  * A remote Erlang file server cannot be used. The computer on which the Erlang node is running
                    must have access to the file system (directly or through NFS).

                <u>binary</u>:
                  Read operations on the file return binaries rather than lists.

                <u>{delayed_write,</u> <u>Size,</u> <u>Delay}</u>:
                  Data  in subsequent <u>write/2</u> calls is buffered until at least <u>Size</u> bytes are buffered, or until
                  the oldest buffered data is <u>Delay</u> milliseconds old. Then all buffered data is written  in  one
                  operating system call. The buffered data is also flushed before some other file operation than
                  <u>write/2</u> is executed.

                  The  purpose  of  this  option  is to increase performance by reducing the number of operating
                  system calls. Thus, the <u>write/2</u> calls must be for sizes significantly less than <u>Size</u>, and  not
                  interspersed by too many other file operations.

                  When  this  option  is  used,  the  result  of  <u>write/2</u>  calls  can prematurely be reported as
                  successful, and if a write error occurs, the error is reported as the result of the next  file
                  operation, which is not executed.

                  For  example,  when <u>delayed_write</u> is used, after a number of <u>write/2</u> calls, <u>close/1</u> can return
                  <u>{error,</u> <u>enospc}</u>, as there is not enough space on the disc for previously written data. <u>close/1</u>
                  must probably be called again, as the file is still open.

                <u>delayed_write</u>:
                  The same as <u>{delayed_write,</u> <u>Size,</u> <u>Delay}</u> with reasonable default values  for  <u>Size</u>  and  <u>Delay</u>
                  (roughly some 64 KB, 2 seconds).

                <u>{read_ahead,</u> <u>Size}</u>:
                  Activates  read  data  buffering.  If <u>read/2</u> calls are for significantly less than <u>Size</u> bytes,
                  read operations to the operating system are still performed for  blocks  of  <u>Size</u>  bytes.  The
                  extra  data  is buffered and returned in subsequent <u>read/2</u> calls, giving a performance gain as
                  the number of operating system calls is reduced.

                  The <u>read_ahead</u> buffer is also highly used by function <u>read_line/1</u> in <u>raw</u> mode, therefore  this
                  option is recommended (for performance reasons) when accessing raw files using that function.

                  If <u>read/2</u> calls are for sizes not significantly less than, or even greater than <u>Size</u> bytes, no
                  performance gain can be expected.

                <u>read_ahead</u>:
                  The same as <u>{read_ahead,</u> <u>Size}</u> with a reasonable default value for <u>Size</u> (roughly some 64 KB).

                <u>compressed</u>:
                  Makes  it  possible to read or write gzip compressed files. Option <u>compressed</u> must be combined
                  with <u>read</u> or <u>write</u>, but not both. Notice that the file  size  obtained  with  <u>read_file_info/1</u>
                  does probably not match the number of bytes that can be read from a compressed file.

                <u>{encoding,</u> <u>Encoding}</u>:
                  Makes  the  file  perform automatic translation of characters to and from a specific (Unicode)
                  encoding. Notice that the data supplied to <u>write/2</u>  or  returned  by  <u>read/2</u>  still  is  byte-
                  oriented; this option denotes only how data is stored in the disk file.

                  Depending  on  the  encoding,  different methods of reading and writing data is preferred. The
                  default encoding of <u>latin1</u> implies using this module (<u>file</u>) for reading and  writing  data  as
                  the  interfaces  provided  here  work with byte-oriented data. Using other (Unicode) encodings
                  makes the <u><a href="../man3erl/io.3erl.html">io</a>(3erl)</u> functions <u>get_chars</u>, <u>get_line</u>, and <u>put_chars</u> more  suitable,  as  they  can
                  work with the full Unicode range.

                  If  data  is  sent  to  an  <u>io_device()</u>  in a format that cannot be converted to the specified
                  encoding, or if data is read by a function that returns data in a format that cannot cope with
                  the character range of the data, an error occurs and the file is closed.

                  Allowed values for <u>Encoding</u>:

                  <u>latin1</u>:
                    The default encoding. Bytes supplied to the file, that is, <u>write/2</u> are written  "as  is"  on
                    the  file.  Likewise,  bytes  read  from  the file, that is, <u>read/2</u> are returned "as is". If
                    module <u><a href="../man3erl/io.3erl.html">io</a>(3erl)</u> is used for writing, the file can only cope with Unicode  characters  up  to
                    code point 255 (the ISO Latin-1 range).

                  <u>unicode</u> <u>or</u> <u>utf8</u>:
                    Characters are translated to and from UTF-8 encoding before they are written to or read from
                    the  file.  A  file  opened in this way can be readable using function <u>read/2</u>, as long as no
                    data stored on the file lies beyond the ISO Latin-1 range (0..255), but  failure  occurs  if
                    the  data  contains  Unicode  code  points beyond that range. The file is best read with the
                    functions in the Unicode aware module <u><a href="../man3erl/io.3erl.html">io</a>(3erl)</u>.

                    Bytes written to the file by any means are translated to UTF-8 encoding before being  stored
                    on the disk file.

                  <u>utf16</u> <u>or</u> <u>{utf16,big}</u>:
                    Works like <u>unicode</u>, but translation is done to and from big endian UTF-16 instead of UTF-8.

                  <u>{utf16,little}</u>:
                    Works  like  <u>unicode</u>,  but  translation  is done to and from little endian UTF-16 instead of
                    UTF-8.

                  <u>utf32</u> <u>or</u> <u>{utf32,big}</u>:
                    Works like <u>unicode</u>, but translation is done to and from big endian UTF-32 instead of UTF-8.

                  <u>{utf32,little}</u>:
                    Works like <u>unicode</u>, but translation is done to and from  little  endian  UTF-32  instead  of
                    UTF-8.

                  The  Encoding can be changed for a file "on the fly" by using function <u>io:setopts/2</u>. So a file
                  can be analyzed in latin1 encoding for, for example, a BOM, positioned beyond the BOM and then
                  be set for the right encoding before further reading.  For  functions  identifying  BOMs,  see
                  module <u><a href="../man3erl/unicode.3erl.html">unicode</a>(3erl)</u>.

                  This option is not allowed on <u>raw</u> files.

                <u>ram</u>:
                  <u>File</u>  must  be <u>iodata()</u>. Returns an <u>fd()</u>, which lets module <u>file</u> operate on the data in-memory
                  as if it is a file.

                <u>sync</u>:
                  On platforms supporting it, enables the POSIX <u>O_SYNC</u> synchronous I/O  flag  or  its  platform-
                  dependent  equivalent  (for example, <u>FILE_FLAG_WRITE_THROUGH</u> on Windows) so that writes to the
                  file block until the data is physically written to disk. However,  be  aware  that  the  exact
                  semantics of this flag differ from platform to platform. For example, none of Linux or Windows
                  guarantees  that  all  file  metadata  are  also  written before the call returns. For precise
                  semantics, check the details of your platform documentation. On platforms with no support  for
                  POSIX <u>O_SYNC</u> or equivalent, use of the <u>sync</u> flag causes <u>open</u> to return <u>{error,</u> <u>enotsup}</u>.

                <u>directory</u>:
                  Allows <u>open</u> to work on directories.

              Returns:

                <u>{ok,</u> <u>IoDevice}</u>:
                  The file is opened in the requested mode. <u>IoDevice</u> is a reference to the file.

                <u>{error,</u> <u>Reason}</u>:
                  The file cannot be opened.

              <u>IoDevice</u> is really the pid of the process that handles the file. This process monitors the process
              that  originally opened the file (the owner process). If the owner process terminates, the file is
              closed and the process itself terminates too. An <u>IoDevice</u> returned from this call can be  used  as
              an argument to the I/O functions (see <u><a href="../man3erl/io.3erl.html">io</a>(3erl)</u>).

          <b>Warning:</b>
              While  this  function  can be used to open any file, we recommend against using it for NFS-mounted
              files, FIFOs, devices, or similar since they can cause IO threads to hang forever.

              If your application needs to interact with these kinds of files we recommend  breaking  out  those
              parts to a port program instead.

          <b>Note:</b>
              In  previous versions of <u>file</u>, modes were specified as one of the atoms <u>read</u>, <u>write</u>, or <u>read_write</u>
              instead of a list. This is still allowed for reasons of backwards compatibility, but is not to  be
              used for new code. Also note that <u>read_write</u> is not allowed in a mode list.

              Typical error reasons:

                <u>enoent</u>:
                  The file does not exist.

                <u>eacces</u>:
                  Missing permission for reading the file or searching one of the parent directories.

                <u>eisdir</u>:
                  The named file is a directory.

                <u>enotdir</u>:
                  A  component  of the filename is not a directory, or the filename itself is not a directory if
                  <u>directory</u> mode was specified. On some platforms, <u>enoent</u> is returned instead.

                <u>enospc</u>:
                  There is no space left on the device (if <u>write</u> access was specified).

       <b>path_consult(Path,</b> <b>Filename)</b> <b>-&gt;</b>
                       {ok, Terms, FullName} | {error, Reason}

              Types:

                 Path = [Dir]
                 Dir = Filename = name_all()
                 Terms = [term()]
                 FullName = filename_all()
                 Reason =
                     posix() |
                     badarg | terminated | system_limit |
                     {Line :: integer(), Mod :: module(), Term :: term()}

              Searches the path <u>Path</u> (a list of directory names) until the file <u>Filename</u> is found.  If  <u>Filename</u>
              is  an  absolute  filename,  <u>Path</u>  is ignored. Then reads Erlang terms, separated by '.', from the
              file.

              Returns one of the following:

                <u>{ok,</u> <u>Terms,</u> <u>FullName}</u>:
                  The file is successfully read. <u>FullName</u> is the full name of the file.

                <u>{error,</u> <u>enoent}</u>:
                  The file cannot be found in any of the directories in <u>Path</u>.

                <u>{error,</u> <u>atom()}</u>:
                  An error occurred when opening the file or reading it. For a list of typical error codes,  see
                  <u>open/2</u>.

                <u>{error,</u> <u>{Line,</u> <u>Mod,</u> <u>Term}}</u>:
                  An  error  occurred  when  interpreting  the  Erlang  terms in the file. Use <u>format_error/1</u> to
                  convert the three-element tuple to an English description of the error.

              The encoding of <u>Filename</u> can be set by a comment as described in <u><a href="../man3erl/epp.3erl.html">epp</a>(3erl)</u>.

       <b>path_eval(Path,</b> <b>Filename)</b> <b>-&gt;</b> <b>{ok,</b> <b>FullName}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Path = [Dir :: name_all()]
                 Filename = name_all()
                 FullName = filename_all()
                 Reason =
                     posix() |
                     badarg | terminated | system_limit |
                     {Line :: integer(), Mod :: module(), Term :: term()}

              Searches the path <u>Path</u> (a list of directory names) until the file <u>Filename</u> is found.  If  <u>Filename</u>
              is  an  absolute filename, <u>Path</u> is ignored. Then reads and evaluates Erlang expressions, separated
              by '.' (or ',', a sequence of expressions is also an expression), from the  file.  The  result  of
              evaluation is not returned; any expression sequence in the file must be there for its side effect.

              Returns one of the following:

                <u>{ok,</u> <u>FullName}</u>:
                  The file is read and evaluated. <u>FullName</u> is the full name of the file.

                <u>{error,</u> <u>enoent}</u>:
                  The file cannot be found in any of the directories in <u>Path</u>.

                <u>{error,</u> <u>atom()}</u>:
                  An  error occurred when opening the file or reading it. For a list of typical error codes, see
                  <u>open/2</u>.

                <u>{error,</u> <u>{Line,</u> <u>Mod,</u> <u>Term}}</u>:
                  An error occurred when interpreting the Erlang expressions in the file. Use <u>format_error/1</u>  to
                  convert the three-element tuple to an English description of the error.

              The encoding of <u>Filename</u> can be set by a comment as described in <u><a href="../man3erl/epp.3erl.html">epp</a>(3erl)</u>.

       <b>path_open(Path,</b> <b>Filename,</b> <b>Modes)</b> <b>-&gt;</b>
                    {ok, IoDevice, FullName} | {error, Reason}

              Types:

                 Path = [Dir :: name_all()]
                 Filename = name_all()
                 Modes = [mode() | directory]
                 IoDevice = io_device()
                 FullName = filename_all()
                 Reason = posix() | badarg | system_limit

              Searches  the  path <u>Path</u> (a list of directory names) until the file <u>Filename</u> is found. If <u>Filename</u>
              is an absolute filename, <u>Path</u> is ignored. Then opens the file in the mode determined by <u>Modes</u>.

              Returns one of the following:

                <u>{ok,</u> <u>IoDevice,</u> <u>FullName}</u>:
                  The file is opened in the requested mode. <u>IoDevice</u> is a reference to the file and <u>FullName</u>  is
                  the full name of the file.

                <u>{error,</u> <u>enoent}</u>:
                  The file cannot be found in any of the directories in <u>Path</u>.

                <u>{error,</u> <u>atom()}</u>:
                  The file cannot be opened.

       <b>path_script(Path,</b> <b>Filename)</b> <b>-&gt;</b>
                      {ok, Value, FullName} | {error, Reason}

              Types:

                 Path = [Dir :: name_all()]
                 Filename = name_all()
                 Value = term()
                 FullName = filename_all()
                 Reason =
                     posix() |
                     badarg | terminated | system_limit |
                     {Line :: integer(), Mod :: module(), Term :: term()}

              Searches  the  path <u>Path</u> (a list of directory names) until the file <u>Filename</u> is found. If <u>Filename</u>
              is an absolute filename, <u>Path</u> is ignored. Then reads and evaluates Erlang  expressions,  separated
              by '.' (or ',', a sequence of expressions is also an expression), from the file.

              Returns one of the following:

                <u>{ok,</u> <u>Value,</u> <u>FullName}</u>:
                  The  file  is read and evaluated. <u>FullName</u> is the full name of the file and <u>Value</u> the value of
                  the last expression.

                <u>{error,</u> <u>enoent}</u>:
                  The file cannot be found in any of the directories in <u>Path</u>.

                <u>{error,</u> <u>atom()}</u>:
                  An error occurred when opening the file or reading it. For a list of typical error codes,  see
                  <u>open/2</u>.

                <u>{error,</u> <u>{Line,</u> <u>Mod,</u> <u>Term}}</u>:
                  An  error occurred when interpreting the Erlang expressions in the file. Use <u>format_error/1</u> to
                  convert the three-element tuple to an English description of the error.

              The encoding of <u>Filename</u> can be set by a comment as described in <u><a href="../man3erl/epp.3erl.html">epp</a>(3erl)</u>.

       <b>path_script(Path,</b> <b>Filename,</b> <b>Bindings)</b> <b>-&gt;</b>
                      {ok, Value, FullName} | {error, Reason}

              Types:

                 Path = [Dir :: name_all()]
                 Filename = name_all()
                 Bindings = erl_eval:binding_struct()
                 Value = term()
                 FullName = filename_all()
                 Reason =
                     posix() |
                     badarg | terminated | system_limit |
                     {Line :: integer(), Mod :: module(), Term :: term()}

              The same as <u>path_script/2</u> but the variable bindings <u>Bindings</u>  are  used  in  the  evaluation.  See
              <u><a href="../man3erl/erl_eval.3erl.html">erl_eval</a>(3erl)</u> about variable bindings.

       <b>pid2name(Pid)</b> <b>-&gt;</b> <b>{ok,</b> <b>Filename}</b> <b>|</b> <b>undefined</b>

              Types:

                 Filename = filename_all()
                 Pid = pid()

              If  <u>Pid</u> is an I/O device, that is, a pid returned from <u>open/2</u>, this function returns the filename,
              or rather:

                <u>{ok,</u> <u>Filename}</u>:
                  If the file server of this node is not a slave, the file was opened by the file server of this
                  node (this implies that <u>Pid</u> must be a local pid) and the file is not closed. <u>Filename</u>  is  the
                  filename in flat string format.

                <u>undefined</u>:
                  In all other cases.

          <b>Warning:</b>
              This function is intended for debugging only.

       <b>position(IoDevice,</b> <b>Location)</b> <b>-&gt;</b>
                   {ok, NewPosition} | {error, Reason}

              Types:

                 IoDevice = io_device()
                 Location = location()
                 NewPosition = integer()
                 Reason = posix() | badarg | terminated

              Sets  the  position  of the file referenced by <u>IoDevice</u> to <u>Location</u>. Returns <u>{ok,</u> <u>NewPosition}</u> (as
              absolute offset) if successful, otherwise <u>{error,</u> <u>Reason}</u>. <u>Location</u> is one of the following:

                <u>Offset</u>:
                  The same as <u>{bof,</u> <u>Offset}</u>.

                <u>{bof,</u> <u>Offset}</u>:
                  Absolute offset.

                <u>{cur,</u> <u>Offset}</u>:
                  Offset from the current position.

                <u>{eof,</u> <u>Offset}</u>:
                  Offset from the end of file.

                <u>bof</u> <u>|</u> <u>cur</u> <u>|</u> <u>eof</u>:
                  The same as above with <u>Offset</u> 0.

              Notice that offsets are counted in bytes, not in characters. If the  file  is  opened  using  some
              other  <u>encoding</u>  than <u>latin1</u>, one byte does not correspond to one character. Positioning in such a
              file can only be done to known character boundaries. That is, to a position earlier  retrieved  by
              getting a current position, to the beginning/end of the file or to some other position <u>known</u> to be
              on  a  correct  character  boundary by some other means (typically beyond a byte order mark in the
              file, which has a known byte-size).

              A typical error reason is:

                <u>einval</u>:
                  Either <u>Location</u> is illegal, or it is evaluated to a negative offset in the file.  Notice  that
                  if  the resulting position is a negative value, the result is an error, and after the call the
                  file position is undefined.

       <b>pread(IoDevice,</b> <b>LocNums)</b> <b>-&gt;</b> <b>{ok,</b> <b>DataL}</b> <b>|</b> <b>eof</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = io_device()
                 LocNums =
                     [{Location :: location(), Number :: integer() &gt;= 0}]
                 DataL = [Data]
                 Data = string() | binary() | eof
                 Reason = posix() | badarg | terminated

              Performs a sequence of <u>pread/3</u> in one operation, which is more efficient than calling them one  at
              a  time.  Returns  <u>{ok,</u>  <u>[Data,</u>  <u>...]}</u>  or  <u>{error,</u>  <u>Reason}</u>,  where  each <u>Data</u>, the result of the
              corresponding <u>pread</u>, is either a list or a binary depending on the mode of the file, or <u>eof</u> if the
              requested position is beyond end of file.

              As the position is specified as a byte-offset, take special caution when working with files  where
              <u>encoding</u>  is  set  to  something else than <u>latin1</u>, as not every byte position is a valid character
              boundary on such a file.

       <b>pread(IoDevice,</b> <b>Location,</b> <b>Number)</b> <b>-&gt;</b>
                {ok, Data} | eof | {error, Reason}

              Types:

                 IoDevice = io_device()
                 Location = location()
                 Number = integer() &gt;= 0
                 Data = string() | binary()
                 Reason = posix() | badarg | terminated

              Combines <u>position/2</u> and <u>read/2</u> in one operation, which is more efficient than calling them one  at
              a time.

              <u>Location</u> is only allowed to be an integer for <u>raw</u> and <u>ram</u> modes.

              The  current  position of the file after the operation is undefined for <u>raw</u> mode and unchanged for
              <u>ram</u> mode.

              As the position is specified as a byte-offset, take special caution when working with files  where
              <u>encoding</u>  is  set  to  something else than <u>latin1</u>, as not every byte position is a valid character
              boundary on such a file.

       <b>pwrite(IoDevice,</b> <b>LocBytes)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>{N,</b> <b>Reason}}</b>

              Types:

                 IoDevice = io_device()
                 LocBytes = [{Location :: location(), Bytes :: iodata()}]
                 N = integer() &gt;= 0
                 Reason = posix() | badarg | terminated

              Performs a sequence of <u>pwrite/3</u> in one operation, which is more efficient than calling them one at
              a time. Returns <u>ok</u> or <u>{error,</u> <u>{N,</u> <u>Reason}}</u>, where <u>N</u> is the number of successful writes done before
              the failure.

              When positioning in a file with other <u>encoding</u> than <u>latin1</u>, caution  must  be  taken  to  set  the
              position on a correct character boundary. For details, see <u>position/2</u>.

       <b>pwrite(IoDevice,</b> <b>Location,</b> <b>Bytes)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = io_device()
                 Location = location()
                 Bytes = iodata()
                 Reason = posix() | badarg | terminated

              Combines <u>position/2</u> and <u>write/2</u> in one operation, which is more efficient than calling them one at
              a time.

              <u>Location</u> is only allowed to be an integer for <u>raw</u> and <u>ram</u> modes.

              The  current  position of the file after the operation is undefined for <u>raw</u> mode and unchanged for
              <u>ram</u> mode.

              When positioning in a file with other <u>encoding</u> than <u>latin1</u>, caution  must  be  taken  to  set  the
              position on a correct character boundary. For details, see <u>position/2</u>.

       <b>read(IoDevice,</b> <b>Number)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>eof</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = io_device() | atom()
                 Number = integer() &gt;= 0
                 Data = string() | binary()
                 Reason =
                     posix() |
                     badarg | terminated |
                     {no_translation, unicode, latin1}

              Reads <u>Number</u> bytes/characters from the file referenced by <u>IoDevice</u>. The functions <u>read/2</u>, <u>pread/3</u>,
              and  <u>read_line/1</u>  are the only ways to read from a file opened in <u>raw</u> mode (although they work for
              normally opened files, too).

              For files where <u>encoding</u> is set to something else than <u>latin1</u>, one character can be represented by
              more than one byte on the file. The parameter <u>Number</u> always denotes the number of <u>characters</u>  read
              from the file, while the position in the file can be moved much more than this number when reading
              a Unicode file.

              Also, if <u>encoding</u> is set to something else than <u>latin1</u>, the <u>read/3</u> call fails if the data contains
              characters  larger  than  255, which is why module <u><a href="../man3erl/io.3erl.html">io</a>(3erl)</u> is to be preferred when reading such a
              file.

              The function returns:

                <u>{ok,</u> <u>Data}</u>:
                  If the file was opened in binary mode, the read bytes are returned in a binary, otherwise in a
                  list. The list or binary is shorter than the number of bytes requested  if  end  of  file  was
                  reached.

                <u>eof</u>:
                  Returned if <u>Number&gt;0</u> and end of file was reached before anything at all could be read.

                <u>{error,</u> <u>Reason}</u>:
                  An error occurred.

              Typical error reasons:

                <u>ebadf</u>:
                  The file is not opened for reading.

                <u>{no_translation,</u> <u>unicode,</u> <u>latin1}</u>:
                  The  file  is  opened  with  another  <u>encoding</u>  than <u>latin1</u> and the data in the file cannot be
                  translated to the byte-oriented data that this function returns.

       <b>read_file(Filename)</b> <b>-&gt;</b> <b>{ok,</b> <b>Binary}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Binary = binary()
                 Reason = posix() | badarg | terminated | system_limit

              Returns <u>{ok,</u> <u>Binary}</u>, where <u>Binary</u> is a binary data object that contains the contents of <u>Filename</u>,
              or <u>{error,</u> <u>Reason}</u> if an error occurs.

              Typical error reasons:

                <u>enoent</u>:
                  The file does not exist.

                <u>eacces</u>:
                  Missing permission for reading the file, or for searching one of the parent directories.

                <u>eisdir</u>:
                  The named file is a directory.

                <u>enotdir</u>:
                  A component of the filename is not a directory. On some platforms, <u>enoent</u> is returned instead.

                <u>enomem</u>:
                  There is not enough memory for the contents of the file.

       <b>read_file_info(File)</b> <b>-&gt;</b> <b>{ok,</b> <b>FileInfo}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>read_file_info(File,</b> <b>Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>FileInfo}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 File = name_all() | io_device()
                 Opts = [file_info_option()]
                 FileInfo = file_info()
                 Reason = posix() | badarg

              Retrieves information about a file.  Returns  <u>{ok,</u>  <u>FileInfo}</u>  if  successful,  otherwise  <u>{error,</u>
              <u>Reason}</u>.  <u>FileInfo</u> is a record <u>file_info</u>, defined in the Kernel include file <u>file.hrl</u>. Include the
              following directive in the module from which the function is called:

               -include_lib("kernel/include/file.hrl").

              The time type returned in <u>atime</u>, <u>mtime</u>, and <u>ctime</u> is dependent on the time type  set  in  <u>Opts</u>  <u>::</u>
              <u>{time,</u> <u>Type}</u> as follows:

                <u>local</u>:
                  Returns local time.

                <u>universal</u>:
                  Returns universal time.

                <u>posix</u>:
                  Returns seconds since or before Unix time epoch, which is 1970-01-01 00:00 UTC.

              Default is <u>{time,</u> <u>local}</u>.

              If  the option <u>raw</u> is set, the file server is not called and only information about local files is
              returned. Note that this will break this module's atomicity guarantees  as  it  can  race  with  a
              concurrent call to <u>write_file_info/1,2</u>.

              This  option  has  no  effect when the function is given an I/O device instead of a file name. Use
              <u>open/2</u> with the <u>raw</u> mode to obtain a file descriptor first.

          <b>Note:</b>
              As file times are stored in POSIX time on most OS, it is faster to  query  file  information  with
              option <u>posix</u>.

              The record <u>file_info</u> contains the following fields:

                <u>size</u> <u>=</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  Size of file in bytes.

                <u>type</u> <u>=</u> <u>device</u> <u>|</u> <u>directory</u> <u>|</u> <u>other</u> <u>|</u> <u>regular</u>:
                  The type of the file. Can also contain <u>symlink</u> when returned from read_link_info/1,2.

                <u>access</u> <u>=</u> <u>read</u> <u>|</u> <u>write</u> <u>|</u> <u>read_write</u> <u>|</u> <u>none</u>:
                  The current system access to the file.

                <u>atime</u> <u>=</u> <u>date_time()</u> <u>|</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  The last time the file was read.

                <u>mtime</u> <u>=</u> <u>date_time()</u> <u>|</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  The last time the file was written.

                <u>ctime</u> <u>=</u> <u>date_time()</u> <u>|</u> <u>integer()</u> <u>&gt;=0</u>:
                  The interpretation of this time field depends on the operating system. On Unix, it is the last
                  time the file or the <u>inode</u> was changed. In Windows, it is the create time.

                <u>mode</u> <u>=</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  The file permissions as the sum of the following bit values:

                  <u>8#00400</u>:
                    read permission: owner

                  <u>8#00200</u>:
                    write permission: owner

                  <u>8#00100</u>:
                    execute permission: owner

                  <u>8#00040</u>:
                    read permission: group

                  <u>8#00020</u>:
                    write permission: group

                  <u>8#00010</u>:
                    execute permission: group

                  <u>8#00004</u>:
                    read permission: other

                  <u>8#00002</u>:
                    write permission: other

                  <u>8#00001</u>:
                    execute permission: other

                  <u>16#800</u>:
                    set user id on execution

                  <u>16#400</u>:
                    set group id on execution

                  On Unix platforms, other bits than those listed above may be set.

                <u>links</u> <u>=</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  Number of links to the file (this is always 1 for file systems that have no concept of links).

                <u>major_device</u> <u>=</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  Identifies the file system where the file is located. In Windows, the number indicates a drive
                  as follows: 0 means A:, 1 means B:, and so on.

                <u>minor_device</u> <u>=</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  Only valid for character devices on Unix. In all other cases, this field is zero.

                <u>inode</u> <u>=</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  Gives the <u>inode</u> number. On non-Unix file systems, this field is zero.

                <u>uid</u> <u>=</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  Indicates the owner of the file. On non-Unix file systems, this field is zero.

                <u>gid</u> <u>=</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  Gives the group that the owner of the file belongs to. On non-Unix file systems, this field is
                  zero.

              Typical error reasons:

                <u>eacces</u>:
                  Missing search permission for one of the parent directories of the file.

                <u>enoent</u>:
                  The file does not exist.

                <u>enotdir</u>:
                  A component of the filename is not a directory. On some platforms, <u>enoent</u> is returned instead.

       <b>read_line(IoDevice)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>eof</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = io_device() | atom()
                 Data = string() | binary()
                 Reason =
                     posix() |
                     badarg | terminated |
                     {no_translation, unicode, latin1}

              Reads  a  line  of  bytes/characters from the file referenced by <u>IoDevice</u>. Lines are defined to be
              delimited by the linefeed (LF, <u>\n</u>) character, but any carriage  return  (CR,  <u>\r</u>)  followed  by  a
              newline  is  also  treated as a single LF character (the carriage return is silently ignored). The
              line is returned <u>including</u> the LF, but excluding any  CR  immediately  followed  by  an  LF.  This
              behaviour is consistent with the behaviour of <u>io:get_line/2</u>. If end of file is reached without any
              LF ending the last line, a line with no trailing LF is returned.

              The  function can be used on files opened in <u>raw</u> mode. However, it is inefficient to use it on <u>raw</u>
              files if the file is not opened with option <u>{read_ahead,</u> <u>Size}</u> specified. Thus, combining <u>raw</u>  and
              <u>{read_ahead,</u> <u>Size}</u> is highly recommended when opening a text file for raw line-oriented reading.

              If  <u>encoding</u> is set to something else than <u>latin1</u>, the <u>read_line/1</u> call fails if the data contains
              characters larger than 255, why module <u><a href="../man3erl/io.3erl.html">io</a>(3erl)</u> is to be preferred when reading such a file.

              The function returns:

                <u>{ok,</u> <u>Data}</u>:
                  One line from the file is returned,  including  the  trailing  LF,  but  with  CRLF  sequences
                  replaced by a single LF (see above).

                  If  the file is opened in binary mode, the read bytes are returned in a binary, otherwise in a
                  list.

                <u>eof</u>:
                  Returned if end of file was reached before anything at all could be read.

                <u>{error,</u> <u>Reason}</u>:
                  An error occurred.

              Typical error reasons:

                <u>ebadf</u>:
                  The file is not opened for reading.

                <u>{no_translation,</u> <u>unicode,</u> <u>latin1}</u>:
                  The file is opened with another <u>encoding</u> than <u>latin1</u> and  the  data  on  the  file  cannot  be
                  translated to the byte-oriented data that this function returns.

       <b>read_link(Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>Filename}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = name_all()
                 Filename = filename()
                 Reason = posix() | badarg

              Returns  <u>{ok,</u>  <u>Filename}</u>  if <u>Name</u> refers to a symbolic link that is not a raw filename, or <u>{error,</u>
              <u>Reason}</u> otherwise. On  platforms  that  do  not  support  symbolic  links,  the  return  value  is
              <u>{error,enotsup}</u>.

              Typical error reasons:

                <u>einval</u>:
                  <u>Name</u>  does  not  refer  to  a symbolic link or the name of the file that it refers to does not
                  conform to the expected encoding.

                <u>enoent</u>:
                  The file does not exist.

                <u>enotsup</u>:
                  Symbolic links are not supported on this platform.

       <b>read_link_all(Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>Filename}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = name_all()
                 Filename = filename_all()
                 Reason = posix() | badarg

              Returns <u>{ok,</u> <u>Filename}</u> if <u>Name</u> refers  to  a  symbolic  link  or  <u>{error,</u>  <u>Reason}</u>  otherwise.  On
              platforms that do not support symbolic links, the return value is <u>{error,enotsup}</u>.

              Notice that <u>Filename</u> can be either a list or a binary.

              Typical error reasons:

                <u>einval</u>:
                  <u>Name</u> does not refer to a symbolic link.

                <u>enoent</u>:
                  The file does not exist.

                <u>enotsup</u>:
                  Symbolic links are not supported on this platform.

       <b>read_link_info(Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>FileInfo}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>read_link_info(Name,</b> <b>Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>FileInfo}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = name_all()
                 Opts = [file_info_option()]
                 FileInfo = file_info()
                 Reason = posix() | badarg

              Works  like  <u>read_file_info/1,2</u> except that if <u>Name</u> is a symbolic link, information about the link
              is returned in the <u>file_info</u> record and the <u>type</u> field of the record is set to <u>symlink</u>.

              If the option <u>raw</u> is set, the file server is not called and only information about local files  is
              returned.  Note  that  this  will  break  this module's atomicity guarantees as it can race with a
              concurrent call to <u>write_file_info/1,2</u>

              If <u>Name</u> is not a symbolic link, this function returns the  same  result  as  <u>read_file_info/1</u>.  On
              platforms   that   do   not  support  symbolic  links,  this  function  is  always  equivalent  to
              <u>read_file_info/1</u>.

       <b>rename(Source,</b> <b>Destination)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Source = Destination = name_all()
                 Reason = posix() | badarg

              Tries to rename the file <u>Source</u> to <u>Destination</u>. It can be used to  move  files  (and  directories)
              between  directories,  but  it  is not sufficient to specify the destination only. The destination
              filename must also be specified. For example, if <u>bar</u>  is  a  normal  file  and  <u>foo</u>  and  <u>baz</u>  are
              directories, <u>rename("foo/bar",</u> <u>"baz")</u> returns an error, but <u>rename("foo/bar",</u> <u>"baz/bar")</u> succeeds.
              Returns <u>ok</u> if it is successful.

          <b>Note:</b>
              Renaming of open files is not allowed on most platforms (see <u>eacces</u> below).

              Typical error reasons:

                <u>eacces</u>:
                  Missing read or write permissions for the parent directories of <u>Source</u> or <u>Destination</u>. On some
                  platforms, this error is given if either <u>Source</u> or <u>Destination</u> is open.

                <u>eexist</u>:
                  <u>Destination</u>  is  not  an  empty  directory.  On  some  platforms,  also  given when <u>Source</u> and
                  <u>Destination</u> are not of the same type.

                <u>einval</u>:
                  <u>Source</u> is a root directory, or <u>Destination</u> is a subdirectory of <u>Source</u>.

                <u>eisdir</u>:
                  <u>Destination</u> is a directory, but <u>Source</u> is not.

                <u>enoent</u>:
                  <u>Source</u> does not exist.

                <u>enotdir</u>:
                  <u>Source</u> is a directory, but <u>Destination</u> is not.

                <u>exdev</u>:
                  <u>Source</u> and <u>Destination</u> are on different file systems.

       <b>script(Filename)</b> <b>-&gt;</b> <b>{ok,</b> <b>Value}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Value = term()
                 Reason =
                     posix() |
                     badarg | terminated | system_limit |
                     {Line :: integer(), Mod :: module(), Term :: term()}

              Reads and evaluates Erlang expressions, separated by '.' (or ',', a  sequence  of  expressions  is
              also an expression), from the file.

              Returns one of the following:

                <u>{ok,</u> <u>Value}</u>:
                  The file is read and evaluated. <u>Value</u> is the value of the last expression.

                <u>{error,</u> <u>atom()}</u>:
                  An  error occurred when opening the file or reading it. For a list of typical error codes, see
                  <u>open/2</u>.

                <u>{error,</u> <u>{Line,</u> <u>Mod,</u> <u>Term}}</u>:
                  An error occurred when interpreting the Erlang expressions in the file. Use <u>format_error/1</u>  to
                  convert the three-element tuple to an English description of the error.

              The encoding of <u>Filename</u> can be set by a comment as described in <u><a href="../man3erl/epp.3erl.html">epp</a>(3erl)</u>.

       <b>script(Filename,</b> <b>Bindings)</b> <b>-&gt;</b> <b>{ok,</b> <b>Value}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Bindings = erl_eval:binding_struct()
                 Value = term()
                 Reason =
                     posix() |
                     badarg | terminated | system_limit |
                     {Line :: integer(), Mod :: module(), Term :: term()}

              The  same  as  <u>script/1</u>  but  the  variable  bindings  <u>Bindings</u>  are  used  in the evaluation. See
              <u><a href="../man3erl/erl_eval.3erl.html">erl_eval</a>(3erl)</u> about variable bindings.

       <b>sendfile(Filename,</b> <b>Socket)</b> <b>-&gt;</b>
                   {ok, integer() &gt;= 0} |
                   {error, inet:posix() | closed | badarg | not_owner}

              Types:

                 Filename = name_all()
                 Socket =
                     inet:socket() |
                     socket:socket() |
                     fun((iolist()) -&gt; ok | {error, inet:posix() | closed})

              Sends the file <u>Filename</u> to <u>Socket</u>.  Returns  <u>{ok,</u>  <u>BytesSent}</u>  if  successful,  otherwise  <u>{error,</u>
              <u>Reason}</u>.

       <b>sendfile(RawFile,</b> <b>Socket,</b> <b>Offset,</b> <b>Bytes,</b> <b>Opts)</b> <b>-&gt;</b>
                   {ok, integer() &gt;= 0} |
                   {error, inet:posix() | closed | badarg | not_owner}

              Types:

                 RawFile = fd()
                 Socket =
                     inet:socket() |
                     socket:socket() |
                     fun((iolist()) -&gt; ok | {error, inet:posix() | closed})
                 Offset = Bytes = integer() &gt;= 0
                 Opts = [sendfile_option()]
                 <b>sendfile_option()</b> =
                     {chunk_size, integer() &gt;= 0} | {use_threads, boolean()}

              Sends  <u>Bytes</u>  from  the  file  referenced  by  <u>RawFile</u> beginning at <u>Offset</u> to <u>Socket</u>. Returns <u>{ok,</u>
              <u>BytesSent}</u> if successful, otherwise <u>{error,</u> <u>Reason}</u>. If <u>Bytes</u> is set  to  <u>0</u>  all  data  after  the
              specified <u>Offset</u> is sent.

              The  file  used  must  be  opened using the <u>raw</u> flag, and the process calling <u>sendfile</u> must be the
              controlling process of the socket. See <u>gen_tcp:controlling_process/2</u> or module <u>socket</u>'s  level <u>otp</u>
              socket option  <u>controlling_process</u>.

              If the OS used does not support  non-blocking  <u>sendfile</u>,  an  Erlang  fallback  using  <u>read/2</u>  and
              <u>gen_tcp:send/2</u> is used.

              The option list can contain the following options:

                <u>chunk_size</u>:
                  The  chunk size used by the Erlang fallback to send data. If using the fallback, set this to a
                  value that comfortably fits in the systems memory. Default is 20 MB.

       <b>set_cwd(Dir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Dir = name() | EncodedBinary
                 EncodedBinary = binary()
                 Reason = posix() | badarg | no_translation

              Sets the current working directory of the file server to <u>Dir</u>. Returns <u>ok</u> if successful.

              The functions in the module <u>file</u> usually treat binaries as raw filenames, that is, they are passed
              "as is" even when the encoding of the binary does not agree with <u>native_name_encoding()</u>.  However,
              this   function   expects   binaries   to   be   encoded   according  to  the  value  returned  by
              <u>native_name_encoding()</u>.

              Typical error reasons are:

                <u>enoent</u>:
                  The directory does not exist.

                <u>enotdir</u>:
                  A component of <u>Dir</u> is not a directory. On some platforms, <u>enoent</u> is returned.

                <u>eacces</u>:
                  Missing permission for the directory or one of its parents.

                <u>badarg</u>:
                  <u>Dir</u> has an improper type, such as tuple.

                <u>no_translation</u>:
                  <u>Dir</u> is a <u>binary()</u> with characters coded in ISO-latin-1 and the VM is  operating  with  unicode
                  filename encoding.

          <b>Warning:</b>
              In a future release, a bad type for argument <u>Dir</u> will probably generate an exception.

       <b>sync(IoDevice)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = io_device()
                 Reason = posix() | badarg | terminated

              Ensures  that  any  buffers  kept  by  the operating system (not by the Erlang runtime system) are
              written to disk. On some platforms, this function might have no effect.

              A typical error reason is:

                <u>enospc</u>:
                  Not enough space left to write the file.

       <b>truncate(IoDevice)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = io_device()
                 Reason = posix() | badarg | terminated

              Truncates the file referenced by <u>IoDevice</u> at the  current  position.  Returns  <u>ok</u>  if  successful,
              otherwise <u>{error,</u> <u>Reason}</u>.

       <b>write(IoDevice,</b> <b>Bytes)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = io_device() | atom()
                 Bytes = iodata()
                 Reason = posix() | badarg | terminated

              Writes  <u>Bytes</u> to the file referenced by <u>IoDevice</u>. This function is the only way to write to a file
              opened in <u>raw</u> mode (although it works for normally opened files too). Returns  <u>ok</u>  if  successful,
              and <u>{error,</u> <u>Reason}</u> otherwise.

              If  the  file  is  opened  with  <u>encoding</u> set to something else than <u>latin1</u>, each byte written can
              result in many bytes being written to the file, as the byte range 0..255  can  represent  anything
              between one and four bytes depending on value and UTF encoding type.

              Typical error reasons:

                <u>ebadf</u>:
                  The file is not opened for writing.

                <u>enospc</u>:
                  No space is left on the device.

       <b>write_file(Filename,</b> <b>Bytes)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Bytes = iodata()
                 Reason = posix() | badarg | terminated | system_limit

              Writes  the contents of the <u>iodata</u> term <u>Bytes</u> to file <u>Filename</u>. The file is created if it does not
              exist. If it exists, the previous contents are overwritten. Returns <u>ok</u>  if  successful,  otherwise
              <u>{error,</u> <u>Reason}</u>.

              Typical error reasons:

                <u>enoent</u>:
                  A component of the filename does not exist.

                <u>enotdir</u>:
                  A component of the filename is not a directory. On some platforms, <u>enoent</u> is returned instead.

                <u>enospc</u>:
                  No space is left on the device.

                <u>eacces</u>:
                  Missing permission for writing the file or searching one of the parent directories.

                <u>eisdir</u>:
                  The named file is a directory.

       <b>write_file(Filename,</b> <b>Bytes,</b> <b>Modes)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Bytes = iodata()
                 Modes = [mode()]
                 Reason = posix() | badarg | terminated | system_limit

              Same  as <u>write_file/2</u>, but takes a third argument <u>Modes</u>, a list of possible modes, see <u>open/2</u>. The
              mode flags <u>binary</u> and <u>write</u> are implicit, so they are not to be used.

       <b>write_file_info(Filename,</b> <b>FileInfo)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>write_file_info(Filename,</b> <b>FileInfo,</b> <b>Opts)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filename = name_all()
                 Opts = [file_info_option()]
                 FileInfo = file_info()
                 Reason = posix() | badarg

              Changes file information. Returns <u>ok</u> if successful,  otherwise  <u>{error,</u>  <u>Reason}</u>.  <u>FileInfo</u>  is  a
              record  <u>file_info</u>, defined in the Kernel include file <u>file.hrl</u>. Include the following directive in
              the module from which the function is called:

               -include_lib("kernel/include/file.hrl").

              The time type set in <u>atime</u>, <u>mtime</u>, and <u>ctime</u> depends on the time type set in <u>Opts</u> <u>::</u> <u>{time,</u>  <u>Type}</u>
              as follows:

                <u>local</u>:
                  Interprets the time set as local.

                <u>universal</u>:
                  Interprets it as universal time.

                <u>posix</u>:
                  Must be seconds since or before Unix time epoch, which is 1970-01-01 00:00 UTC.

              Default is <u>{time,</u> <u>local}</u>.

              If  the option <u>raw</u> is set, the file server is not called and only information about local files is
              returned.

              The following fields are used from the record, if they are specified:

                <u>atime</u> <u>=</u> <u>date_time()</u> <u>|</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  The last time the file was read.

                <u>mtime</u> <u>=</u> <u>date_time()</u> <u>|</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  The last time the file was written.

                <u>ctime</u> <u>=</u> <u>date_time()</u> <u>|</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  On Unix, any value specified for this field is ignored (the "ctime" for the file is set to the
                  current time). On Windows, this field is the new creation time to set for the file.

                <u>mode</u> <u>=</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  The file permissions as the sum of the following bit values:

                  <u>8#00400</u>:
                    Read permission: owner

                  <u>8#00200</u>:
                    Write permission: owner

                  <u>8#00100</u>:
                    Execute permission: owner

                  <u>8#00040</u>:
                    Read permission: group

                  <u>8#00020</u>:
                    Write permission: group

                  <u>8#00010</u>:
                    Execute permission: group

                  <u>8#00004</u>:
                    Read permission: other

                  <u>8#00002</u>:
                    Write permission: other

                  <u>8#00001</u>:
                    Execute permission: other

                  <u>16#800</u>:
                    Set user id on execution

                  <u>16#400</u>:
                    Set group id on execution

                  On Unix platforms, other bits than those listed above may be set.

                <u>uid</u> <u>=</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  Indicates the file owner. Ignored for non-Unix file systems.

                <u>gid</u> <u>=</u> <u>integer()</u> <u>&gt;=</u> <u>0</u>:
                  Gives the group that the file owner belongs to. Ignored for non-Unix file systems.

              Typical error reasons:

                <u>eacces</u>:
                  Missing search permission for one of the parent directories of the file.

                <u>enoent</u>:
                  The file does not exist.

                <u>enotdir</u>:
                  A component of the filename is not a directory. On some platforms, <u>enoent</u> is returned instead.

</pre><h4><b>POSIX</b> <b>ERROR</b> <b>CODES</b></h4><pre>
         * <u>eacces</u> - Permission denied

         * <u>eagain</u> - Resource temporarily unavailable

         * <u>ebadf</u> - Bad file number

         * <u>ebusy</u> - File busy

         * <u>edquot</u> - Disk quota exceeded

         * <u>eexist</u> - File already exists

         * <u>efault</u> - Bad address in system call argument

         * <u>efbig</u> - File too large

         * <u>eintr</u> - Interrupted system call

         * <u>einval</u> - Invalid argument

         * <u>eio</u> - I/O error

         * <u>eisdir</u> - Illegal operation on a directory

         * <u>eloop</u> - Too many levels of symbolic links

         * <u>emfile</u> - Too many open files

         * <u>emlink</u> - Too many links

         * <u>enametoolong</u> - Filename too long

         * <u>enfile</u> - File table overflow

         * <u>enodev</u> - No such device

         * <u>enoent</u> - No such file or directory

         * <u>enomem</u> - Not enough memory

         * <u>enospc</u> - No space left on device

         * <u>enotblk</u> - Block device required

         * <u>enotdir</u> - Not a directory

         * <u>enotsup</u> - Operation not supported

         * <u>enxio</u> - No such device or address

         * <u>eperm</u> - Not owner

         * <u>epipe</u> - Broken pipe

         * <u>erofs</u> - Read-only file system

         * <u>espipe</u> - Invalid seek

         * <u>esrch</u> - No such process

         * <u>estale</u> - Stale remote file handle

         * <u>exdev</u> - Cross-domain link

</pre><h4><b>PERFORMANCE</b></h4><pre>
       For increased performance, raw files are recommended.

       A normal file is really a process so it can be used as an I/O device (see <u>io</u>). Therefore,  when  data  is
       written  to  a  normal  file,  the  sending of the data to the file process, copies all data that are not
       binaries. Opening the file in binary mode and writing binaries is therefore recommended. If the  file  is
       opened  on  another  node,  or  if the file server runs as slave to the file server of another node, also
       binaries are copied.

   <b>Note:</b>
       Raw files use the file system of the host machine of the node.  For  normal  files  (non-raw),  the  file
       server  is used to find the files, and if the node is running its file server as slave to the file server
       of another node, and the other node runs on some  other  host  machine,  they  can  have  different  file
       systems. However, this is seldom a problem.

       <u>open/2</u>  can  be  given the options <u>delayed_write</u> and <u>read_ahead</u> to turn on caching, which will reduce the
       number of operating system calls and greatly improve performance for small reads and writes. However, the
       overhead won't disappear completely and it's best to keep the number of file operations to a minimum.  As
       a contrived example, the following function writes 4MB in 2.5 seconds when tested:

       create_file_slow(Name) -&gt;
           {ok, Fd} = file:open(Name, [raw, write, delayed_write, binary]),
           create_file_slow_1(Fd, 4 bsl 20),
           file:close(Fd).

       create_file_slow_1(_Fd, 0) -&gt;
           ok;
       create_file_slow_1(Fd, M) -&gt;
           ok = file:write(Fd, &lt;&lt;0&gt;&gt;),
           create_file_slow_1(Fd, M - 1).

       The following functionally equivalent code writes 128 bytes per call to <u>write/2</u> and so does the same work
       in 0.08 seconds, which is roughly 30 times faster:

       create_file(Name) -&gt;
           {ok, Fd} = file:open(Name, [raw, write, delayed_write, binary]),
           create_file_1(Fd, 4 bsl 20),
           file:close(Fd),
           ok.

       create_file_1(_Fd, 0) -&gt;
           ok;
       create_file_1(Fd, M) when M &gt;= 128 -&gt;
           ok = file:write(Fd, &lt;&lt;0:(128)/unit:8&gt;&gt;),
           create_file_1(Fd, M - 128);
       create_file_1(Fd, M) -&gt;
           ok = file:write(Fd, &lt;&lt;0:(M)/unit:8&gt;&gt;),
           create_file_1(Fd, M - 1).

       When  writing  data  it's  generally  more  efficient  to  write a list of binaries rather than a list of
       integers. It is not needed to flatten a deep list before writing. On Unix hosts,  scatter  output,  which
       writes  a  set  of  buffers  in one operation, is used when possible. In this way <u>write(FD,</u> <u>[Bin1,</u> <u>Bin2</u> <u>|</u>
       <u>Bin3])</u> writes the contents of the binaries without copying the data at all, except for perhaps deep  down
       in the operating system kernel.

   <b>Warning:</b>
       If  an  error occurs when accessing an open file with module <u>io</u>, the process handling the file exits. The
       dead file process can hang if a process tries to access it later. This will be fixed in a future release.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/filename.3erl.html">filename</a>(3erl)</u>

Ericsson AB                                        kernel 8.2                                         <u><a href="../man3erl/file.3erl.html">file</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>