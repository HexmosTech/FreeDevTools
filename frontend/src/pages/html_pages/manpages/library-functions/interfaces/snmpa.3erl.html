<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>snmpa - Interface Functions to the SNMP toolkit agent</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       snmpa - Interface Functions to the SNMP toolkit agent

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The module <u>snmpa</u> contains interface functions to the SNMP agent.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       oid() = [byte()]
       atl_type() = read | write | read_write
       notification_delivery_info() = #snmpa_notification_delivery_info{}

       The <u>oid()</u> type is used to represent an ASN.1 OBJECT IDENTIFIER.

       The record <u>snmpa_notification_delivery_info</u> contains the following fields:

         <u>tag</u> <u>=</u> <u>term()</u>:
           A user defined identity representing this notification send operation.

         <u>mod</u> <u>=</u> <u>module()</u>:
           A  module implementing the snmpa_notification_delivery_info_receiver behaviour. The info functions of
           this module will be called at various stages of delivery.

         <u>extra</u> <u>=</u> <u>term()</u>:
           This is any extra info the user wants to have supplied when the functions in the callback  module  is
           called.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>add_agent_caps(SysORID,</b> <b>SysORDescr)</b> <b>-&gt;</b> <b>SysORIndex</b>

              Types:

                 SysORID = oid()
                 SysORDescr = string()
                 SysORIndex = integer()

              This function can be used to add an AGENT-CAPABILITY statement to the sysORTable in the agent. The
              table is defined in the SNMPv2-MIB.

       <b>del_agent_caps(SysORIndex)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 SysORIndex = integer()

              This  function can be used to delete an AGENT-CAPABILITY statement to the sysORTable in the agent.
              This table is defined in the SNMPv2-MIB.

       <b>get_agent_caps()</b> <b>-&gt;</b> <b>[[SysORIndex,</b> <b>SysORID,</b> <b>SysORDescr,</b> <b>SysORUpTime]]</b>

              Types:

                 SysORIndex = integer()
                 SysORId = oid()
                 SysORDescr = string()
                 SysORUpTime = integer()

              Returns all AGENT-CAPABILITY statements in the sysORTable in the agent. This table is  defined  in
              the SNMPv2-MIB.

       <b>get(Agent,</b> <b>Vars)</b> <b>-&gt;</b> <b>Values</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>get(Agent,</b> <b>Vars,</b> <b>Context)</b> <b>-&gt;</b> <b>Values</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 Vars = [oid()]
                 Context = string()
                 Values = [term()]
                 Reason = {atom(), oid()}

              Performs  a  GET operation on the agent. All loaded MIB objects are visible in this operation. The
              agent calls the corresponding instrumentation functions just as if it was  a  GET  request  coming
              from a manager.

              Note  that the request specific parameters (such as current_request_id) are not accessible for the
              instrumentation functions if this function is used.

       <b>get_next(Agent,</b> <b>Vars)</b> <b>-&gt;</b> <b>Values</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>get_next(Agent,</b> <b>Vars,</b> <b>Context)</b> <b>-&gt;</b> <b>Values</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 Vars = [oid()]
                 Context = string()
                 Values = [{oid(), term()}]
                 Reason = {atom(), oid()}

              Performs a GET-NEXT operation on the agent. All loaded MIB objects are visible in this  operation.
              The agent calls the corresponding instrumentation functions just as if it was a GET request coming
              from a manager.

              Note  that  the request specific parameters (such as <u>snmpa:current_request_id/0</u> are not accessible
              for the instrumentation functions if this function is used.

       <b>backup(BackupDir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>backup(Agent,</b> <b>BackupDir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 BackupDir = string()
                 Agent = pid() | atom()
                 Reason = backup_in_progress | term()

              Backup persistent/permanent data handled by the agent (such as local-db, mib-data and vacm).

              Data stored by mnesia is not handled.

              BackupDir cannot be identical to DbDir.

              Simultaneous backup calls are <u>not</u> allowed. That is, two different processes cannot  simultaneously
              successfully call this function. One of them will be first, and succeed. The second will fail with
              the error reason <u>backup_in_progress</u>.

       <b>info()</b> <b>-&gt;</b> <b>[{Key,</b> <b>Value}]</b>
       <b>info(Agent)</b> <b>-&gt;</b> <b>[{Key,</b> <b>Value}]</b>

              Types:

                 Agent = pid() | atom()

              Returns  a list (a dictionary) containing information about the agent. Information includes loaded
              MIBs, registered sub-agents, some information about the memory allocation.

       <b>load_mib(Mib)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>load_mib(Agent,</b> <b>Mib)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 MibName = string()
                 Reason = already_loaded | term()

              Load a single <u>Mib</u> into an agent. The <u>MibName</u> is the name of the Mib, including the path  to  where
              the compiled mib is found. For example:

                        Dir = code:<a href="../manmy_app/priv_dir.my_app.html">priv_dir</a>(my_app) ++ "/mibs/",
                        snmpa:load_mib(snmp_master_agent, Dir ++ "MY-MIB").

       <b>load_mibs(Mibs)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>load_mibs(Mibs,</b> <b>Force)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>load_mibs(Agent,</b> <b>Mibs)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>load_mibs(Agent,</b> <b>Mibs,</b> <b>Force)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 Mibs = [MibName]
                 Force = boolean()
                 MibName = string()
                 Reason = {'load aborted at', MibName, InternalReason}
                 InternalReason = already_loaded | term()

              Load  <u>Mibs</u>  into  an  agent.  If  the  agent  cannot load all MIBs (the default value of the <u>Force</u>
              argument is <u>false</u>), it will indicate where loading was aborted. The <u>MibName</u> is  the  name  of  the
              Mib, including the path to where the compiled mib is found. For example,

                        Dir = code:<a href="../manmy_app/priv_dir.my_app.html">priv_dir</a>(my_app) ++ "/mibs/",
                        snmpa:load_mibs(snmp_master_agent, [Dir ++ "MY-MIB"]).

              If  <u>Force</u>  <u>=</u>  <u>true</u>  then the agent will continue attempting to load each mib even after failing to
              load a previous mib. Use with care.

       <b>unload_mib(Mib)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>unload_mib(Agent,</b> <b>Mib)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 MibName = string()
                 Reason = not_loaded | term()

              Unload a single <u>Mib</u> from an agent.

       <b>unload_mibs(Mibs)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>unload_mibs(Mibs,</b> <b>Force)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>unload_mibs(Agent,</b> <b>Mibs)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>unload_mibs(Agent,</b> <b>Mibs,</b> <b>Force)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 Mibs = [MibName]
                 Force = boolean()
                 MibName = string()
                 Reason = {'unload aborted at', MibName, InternalReason}
                 InternalReason = not_loaded | term()

              Unload <u>Mibs</u> from an agent. If it cannot unload all MIBs (the default value of the  <u>Force</u>  argument
              is <u>false</u>), it will indicate where unloading was aborted.

              If  <u>Force</u>  <u>=</u> <u>true</u> then the agent will continue attempting to unload each mib even after failing to
              unload a previous mib. Use with care.

       <b>which_mibs()</b> <b>-&gt;</b> <b>Mibs</b>
       <b>which_mibs(Agent)</b> <b>-&gt;</b> <b>Mibs</b>

              Types:

                 Agent = pid() | atom()
                 Mibs = [{MibName, MibFile}]
                 MibName = atom()
                 MibFile = string()

              Retrieve the list of all the mibs loaded into this agent. Default is the master agent.

       <b>whereis_mib(MibName)</b> <b>-&gt;</b> <b>{ok,</b> <b>MibFile}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>whereis_mib(Agent,</b> <b>MibName)</b> <b>-&gt;</b> <b>{ok,</b> <b>MibFile}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 MibName = atom()
                 MibFile = string()
                 Reason = term()

              Get the full path to the (compiled) mib-file.

       <b>current_request_id()</b> <b>-&gt;</b> <b>{value,</b> <b>RequestId}</b> <b>|</b> <b>false</b>
       <b>current_context()</b> <b>-&gt;</b> <b>{value,</b> <b>Context}</b> <b>|</b> <b>false</b>
       <b>current_community()</b> <b>-&gt;</b> <b>{value,</b> <b>Community}</b> <b>|</b> <b>false</b>
       <b>current_address()</b> <b>-&gt;</b> <b>{value,</b> <b>Address}</b> <b>|</b> <b>false</b>

              Types:

                 RequestId = integer()
                 Context = string()
                 Community = string()
                 Address = term()

              Get the request-id, context, community and address of the request currently being processed by the
              agent.

              Note that these functions is intended to be called by the instrumentation functions  and  <u>only</u>  if
              they  are  executed  in  the  context of the agent process (e.g. it does not work if called from a
              spawned process).

       <b>enum_to_int(Name,</b> <b>Enum)</b> <b>-&gt;</b> <b>{value,</b> <b>Int}</b> <b>|</b> <b>false</b>
       <b>enum_to_int(Db,</b> <b>Name,</b> <b>Enum)</b> <b>-&gt;</b> <b>{value,</b> <b>Int}</b> <b>|</b> <b>false</b>

              Types:

                 Db = term()
                 Name = atom()
                 Enum = atom()
                 Int = int()

              Converts the symbolic value <u>Enum</u> to the corresponding integer of the  enumerated  object  or  type
              <u>Name</u> in a MIB. The MIB must be loaded.

              <u>false</u> is returned if the object or type is not defined in any loaded MIB, or if it does not define
              the symbolic value as enumerated.

              <u>Db</u> is a reference to the symbolic store database (retrieved by a call to <u>get_symbolic_store_db/0</u>).

       <b>int_to_enum(Name,</b> <b>Int)</b> <b>-&gt;</b> <b>{value,</b> <b>Enum}</b> <b>|</b> <b>false</b>
       <b>int_to_enum(Db,</b> <b>Name,</b> <b>Int)</b> <b>-&gt;</b> <b>{value,</b> <b>Enum}</b> <b>|</b> <b>false</b>

              Types:

                 Db = term()
                 Name = atom()
                 Int = int()
                 Enum = atom()

              Converts the integer <u>Int</u> to the corresponding symbolic value of the enumerated object or type <u>Name</u>
              in a MIB. The MIB must be loaded.

              <u>false</u> is returned if the object or type is not defined in any loaded MIB, or if it does not define
              the symbolic value as enumerated.

              <u>Db</u> is a reference to the symbolic store database (retrieved by a call to <u>get_symbolic_store_db/0</u>).

       <b>name_to_oid(Name)</b> <b>-&gt;</b> <b>{value,</b> <b>oid()}</b> <b>|</b> <b>false</b>
       <b>name_to_oid(Db,</b> <b>Name)</b> <b>-&gt;</b> <b>{value,</b> <b>oid()}</b> <b>|</b> <b>false</b>

              Types:

                 Db = term()
                 Name = atom()

              Looks  up  the  OBJECT  IDENTIFIER  of  a  MIB  object,  given the symbolic name. Note, the OBJECT
              IDENTIFIER is given for the object, not for an instance.

              <u>false</u> is returned if the object is not defined in any loaded MIB.

              <u>Db</u> is a reference to the symbolic store database (retrieved by a call to <u>get_symbolic_store_db/0</u>).

       <b>oid_to_name(OID)</b> <b>-&gt;</b> <b>{value,</b> <b>Name}</b> <b>|</b> <b>false</b>
       <b>oid_to_name(Db,</b> <b>OID)</b> <b>-&gt;</b> <b>{value,</b> <b>Name}</b> <b>|</b> <b>false</b>

              Types:

                 Db = term()
                 OID = oid()
                 Name = atom()

              Looks up the symbolic name of a MIB object, given OBJECT IDENTIFIER.

              <u>false</u> is returned if the object is not defined in any loaded MIB.

              <u>Db</u> is a reference to the symbolic store database (retrieved by a call to <u>get_symbolic_store_db/0</u>).

       <b>which_aliasnames()</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Result = [atom()]

              Retrieve all alias-names known to the agent.

       <b>which_tables()</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Result = [atom()]

              Retrieve all tables known to the agent.

       <b>which_transports()</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Result = [{TDomain, TAddress} | {TDomain, TAddress, Kind}]
                 TDomain = transportDomainUdpIpv4 | transportDomainUdpIpv6
                 TAddress = {IpAddr, IpPort}
                 IpAddr = inet:ip_address()
                 IpPort = pos_integer()
                 Kind = req_responder | trap_sender

              Retrieve all configured transports.

       <b>which_variables()</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Result = [atom()]

              Retrieve all variables known to the agent.

       <b>which_notifications()</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Result = [{Name, MibName, Info}]
                 Name = atom()
                 MibName = atom()
                 Info = term()

              Retrieve all notifications (and traps) known to the agent.

       <b>log_to_txt(LogDir)</b>
       <b>log_to_txt(LogDir,</b> <b>Block</b> <b>|</b> <b>Mibs)</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>Block</b> <b>|</b> <b>OutFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>OutFile,</b> <b>Block</b> <b>|</b> <b>LogName)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>OutFile,</b> <b>LogName,</b> <b>Block</b> <b>|</b> <b>LogFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>OutFile,</b> <b>LogName,</b> <b>LogFile,</b> <b>Block</b> <b>|</b> <b>Start)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>OutFile,</b> <b>LogName,</b> <b>LogFile,</b> <b>Block,</b> <b>Start)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>OutFile,</b> <b>LogName,</b> <b>LogFile,</b> <b>Start,</b> <b>Stop)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>OutFile,</b> <b>LogName,</b> <b>LogFile,</b> <b>Block,</b> <b>Start,</b> <b>Stop)</b> <b>-&gt;</b>  <b>ok</b>  <b>|</b>  <b>{ok,</b>  <b>Cnt}</b>  <b>|</b>  <b>{error,</b>
       <b>Reason}</b>

              Types:

                 LogDir = string()
                 Mibs = [MibName]
                 MibName = string()
                 Block = boolean()
                 OutFile = string()
                 LogName = string()
                 LogFile = string()
                 Start   =   Stop   =   null   |   calendar:datetime()  |  {local_time,  calendar:datetime()}  |
                 {universal_time, calendar:datetime()}
                 Cnt = {NumOK, NumERR}
                 NumOK = non_neg_integer()
                 NumERR = pos_integer()
                 Reason = disk_log_open_error() | file_open_error() | term()
                 disk_log_open_error() = {LogName, term()}
                 file_open_error() = {OutFile, term()}

              Converts an Audit Trail Log to a  readable  text  file.  <u>OutFile</u>  defaults  to  "./snmpa_log.txt".
              <u>LogName</u> defaults to "snmpa_log". <u>LogFile</u> defaults to "snmpa.log".

              The  <u>Block</u>  option indicates if the log should be blocked during conversion. This could be usefull
              when converting large logs (when otherwise the log could  wrap  during  conversion).  Defaults  to
              <u>true</u>.

              See snmp:log_to_txt for more info.

       <b>log_to_io(LogDir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Block</b> <b>|</b> <b>Mibs)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>Block</b> <b>|</b> <b>LogName)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>LogName,</b> <b>Block</b> <b>|</b> <b>LogFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>LogName,</b> <b>LogFile,</b> <b>Block</b> <b>|</b> <b>Start)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>LogName,</b> <b>LogFile,</b> <b>Block,</b> <b>Start)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>LogName,</b> <b>LogFile,</b> <b>Start,</b> <b>Stop)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>LogName,</b> <b>LogFile,</b> <b>Block,</b> <b>Start,</b> <b>Stop)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 LogDir = string()
                 Mibs = [MibName]
                 MibName = string()
                 Block = boolean()
                 LogName = string()
                 LogFile = string()
                 Start   =   Stop   =   null   |   calendar:datetime()  |  {local_time,  calendar:datetime()}  |
                 {universal_time, calendar:datetime()}
                 Cnt = {NumOK, NumERR}
                 NumOK = non_neg_integer()
                 NumERR = pos_integer()
                 Reason = disk_log_open_error() | file_open_error() | term()
                 disk_log_open_error() = {LogName, term()}
                 file_open_error() = {OutFile, term()}

              Converts an Audit Trail Log to a readable format and prints  it  on  stdio.  <u>LogName</u>  defaults  to
              "snmpa_log". <u>LogFile</u> defaults to "snmpa.log".

              The  <u>Block</u>  option indicates if the log should be blocked during conversion. This could be usefull
              when converting large logs (when otherwise the log could  wrap  during  conversion).  Defaults  to
              <u>true</u>.

              See snmp:log_to_io for more info.

       <b>change_log_size(NewSize)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 NewSize = {MaxBytes, MaxFiles}
                 MaxBytes = integer()
                 MaxFiles = integer()
                 Reason = term()

              Changes  the  log size of the Audit Trail Log. The application must be configured to use the audit
              trail log function. Please refer to <a href="../man3erl/disk_log.3erl.html">disk_log</a>(3erl) in Kernel Reference Manual for a description of
              how to change the log size.

              The change is permanent, as long as the log is not deleted. That means, the log size is remembered
              across reboots.

       <b>set_log_type(NewType)</b> <b>-&gt;</b> <b>{ok,</b> <b>OldType}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>set_log_type(Agent,</b> <b>NewType)</b> <b>-&gt;</b> <b>{ok,</b> <b>OldType}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 NewType = OldType = atl_type()
                 Agent = pid() | atom()
                 Reason = term()

              Changes the run-time Audit Trail log type.

              Note that this has no effect on the application configuration as defined by  configuration  files,
              so a node restart will revert the config to whatever is in those files.

              This function is primarily useful in testing/debugging scenarios.

       <b>mib_of(Oid)</b> <b>-&gt;</b> <b>{ok,</b> <b>MibName}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>mib_of(Agent,</b> <b>Oid)</b> <b>-&gt;</b> <b>{ok,</b> <b>MibName}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 Oid = oid()
                 MibName = atom()
                 Reason = term()

              Finds  the  mib corresponding to the <u>Oid</u>. If it is a variable, the Oid must be &lt;Oid for var&gt;.0 and
              if it is a table, Oid must be &lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;

       <b>me_of(Oid)</b> <b>-&gt;</b> <b>{ok,</b> <b>Me}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>me_of(Agent,</b> <b>Oid)</b> <b>-&gt;</b> <b>{ok,</b> <b>Me}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 Oid = oid()
                 Me = #me{}
                 Reason = term()

              Finds the mib entry corresponding to the <u>Oid</u>. If it is a variable, the Oid must be &lt;Oid for var&gt;.0
              and if it is a table, Oid must be &lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;

       <b>invalidate_mibs_cache()</b> <b>-&gt;</b> <b>void()</b>
       <b>invalidate_mibs_cache(Agent)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Agent = pid() | atom()

              Invalidate the mib server cache.

              The entire contents of the cache will be deleted.

       <b>enable_mibs_cache()</b> <b>-&gt;</b> <b>void()</b>
       <b>enable_mibs_cache(Agent)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Agent = pid() | atom()

              Enable the mib server cache.

       <b>disable_mibs_cache()</b> <b>-&gt;</b> <b>void()</b>
       <b>disable_mibs_cache(Agent)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Agent = pid() | atom()

              Disable the mib server cache.

       <b>which_mibs_cache_size()</b> <b>-&gt;</b> <b>void()</b>
       <b>which_mibs_cache_size(Agent)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Agent = pid() | atom()

              Retreive the size of the mib server cache.

       <b>gc_mibs_cache()</b> <b>-&gt;</b> <b>{ok,</b> <b>NumElementsGCed}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>gc_mibs_cache(Agent)</b> <b>-&gt;</b> <b>{ok,</b> <b>NumElementsGCed}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>gc_mibs_cache(Age)</b> <b>-&gt;</b> <b>{ok,</b> <b>NumElementsGCed}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>gc_mibs_cache(Agent,</b> <b>Age)</b> <b>-&gt;</b> <b>{ok,</b> <b>NumElementsGCed}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>gc_mibs_cache(Age,</b> <b>GcLimit)</b> <b>-&gt;</b> <b>{ok,</b> <b>NumElementsGCed}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>gc_mibs_cache(Agent,</b> <b>Age,</b> <b>GcLimit)</b> <b>-&gt;</b> <b>{ok,</b> <b>NumElementsGCed}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 Age = integer() &gt; 0
                 GcLimit = integer() &gt; 0 | infinity
                 NumElementsGCed = integer() &gt;= 0
                 Reason = term()

              Perform mib server cache gc.

              Manually performs a mib server cache gc. This can be done regardless of the value  of  the  <u>autogc</u>
              option.  The  <u>NumElementsGCed</u>  value  indicates  how many elements where actually removed from the
              cache.

       <b>enable_mibs_cache_autogc()</b> <b>-&gt;</b> <b>void()</b>
       <b>enable_mibs_cache_autogc(Agent)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Agent = pid() | atom()

              Enable automatic gc of the mib server cache.

       <b>disable_mibs_cache_autogc()</b> <b>-&gt;</b> <b>void()</b>
       <b>disable_mibs_cache_autogc(Agent)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Agent = pid() | atom()

              Disable automatic gc of the mib server cache.

       <b>update_mibs_cache_age(NewAge)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>update_mibs_cache_age(Agent,</b> <b>NewAge)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 NewAge = integer() &gt; 0
                 Reason = term()

              Change the mib server cache <u>age</u> property.

       <b>update_mibs_cache_gclimit(NewGcLimit)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>update_mibs_cache_gclimit(Agent,</b> <b>NewGCLimit)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 NewGcLimit = integer() &gt; 0 | infinity
                 Reason = term()

              Change the mib server cache <u>gclimit</u> property.

       <b>register_notification_filter(Id,</b> <b>Mod,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>register_notification_filter(Agent,</b> <b>Id,</b> <b>Mod,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>register_notification_filter(Id,</b> <b>Mod,</b> <b>Data,</b> <b>Where)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>register_notification_filter(Agent,</b> <b>Id,</b> <b>Mod,</b> <b>Data,</b> <b>Where)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 Id = filter_id()
                 filter_id() = term()
                 Mod = atom()
                 Data = term()
                 Where = filter_position()
                 Reason = term()
                 filter_position() = first | last | {insert_before, filter_id()} | {insert_after, filter_id()}

              Registers a notification filter.

              <u>Mod</u> is a module implementing the <u>snmpa_notification_filter</u> behaviour.

              <u>Data</u> will be passed on to the filter when calling the functions of the behaviour.

       <b>unregister_notification_filter(Id)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>unregister_notification_filter(Agent,</b> <b>Id)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 Id = filter_id()
                 filter_id() = term()

              Unregister a notification filter.

       <b>which_notification_filter()</b> <b>-&gt;</b> <b>Filters</b>
       <b>which_notification_filter(Agent)</b> <b>-&gt;</b> <b>Filters</b>

              Types:

                 Agent = pid() | atom()
                 Filters = [filter_id()]
                 filter_id() = term()

              List all notification filters in an agent.

       <b>set_request_limit(NewLimit)</b> <b>-&gt;</b> <b>{ok,</b> <b>OldLimit}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>set_request_limit(Agent,</b> <b>NewLimit)</b> <b>-&gt;</b> <b>{ok,</b> <b>OldLimit}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 NewLimit = OldLimit = infinity | integer() &gt;= 0
                 Agent = pid() | atom()
                 Reason = term()

              Changes the request limit.

              Note that this has no effect on the application configuration as defined by  configuration  files,
              so a node restart will revert the config to whatever is in those files.

              This function is primarily useful in load regulation scenarios.

       <b>register_subagent(Agent,</b> <b>SubTreeOid,</b> <b>Subagent)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 SubTreeOid = oid()
                 SubAgent = pid()

              Registers a sub-agent under a sub-tree of another agent.

              It  is  easy  to  make  mistakes  when  registering  sub-agents  and  this activity should be done
              carefully. For example, a strange behaviour would result from the following configuration:

              snmp_agent:register_subagent(MAPid,[1,2,3,4],SA1),
              snmp_agent:register_subagent(SA1,[1,2,3], SA2).

              <u>SA2</u> will not get requests starting with object identifier <u>[1,2,3]</u> since <u>SA1</u> does not.

       <b>unregister_subagent(Agent,</b> <b>SubagentOidOrPid)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>SubAgentPid}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Agent = pid() | atom()
                 SubTreeOidorPid = oid() | pid()

              Unregister a sub-agent. If the second argument is a pid, then that sub-agent will be  unregistered
              from all trees in <u>Agent</u>.

       <b>send_notification2(Agent,</b> <b>Notification,</b> <b>SendOpts)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Agent = pid() | atom()
                 Notification = atom()
                 SendOpts = [send_option()]
                 send_option()  =  {receiver,  receiver()} | {name, notify_name()} | {context, context_name()} |
                 {varbinds, varbinds()} | {local_engine_id, string()} | {extra, extra_info()}
                 receiver() = no_receiver | {tag(), tag_receiver()} | notification_delivery_info()
                 tag() = term(()
                 tag_receiver() = pid() | registered_name() | {Mod, Func, Args}
                 registered_name() = atom()
                 Mod = atom()
                 Func = atom()
                 Args = list()
                 notify_name() = string()
                 context_name() = string()
                 varbinds() = [varbind()]
                 varbind() =  {variable(),  value()}  |  {{process_oid(),  variable()},  value()}  |  {column(),
                 row_index(), value()} |
                 variable() = aliasname() | oid()
                 aliasname() = atom()
                 process_oid() = keep (default) | truncate
                 value() = term()
                 column() = atom()
                 row_index() = [int()]
                 extra_info() = term()

              Send the notification <u>Notification</u> to the management targets defined for notify-name (<u>name</u>) in the
              <u>snmpNotifyTable</u> in SNMP-NOTIFICATION-MIB from the specified <u>context</u>.

              If no <u>name</u> is specified (or if it is <u>""</u>), the notification is sent to all management targets.

              If no <u>context</u> is specified, the default context, <u>""</u>, is used.

              The  send  option <u>receiver</u> specifies where information about delivery of Inform-Requests should be
              sent. The agent sends Inform-Requests and waits for acknowledgments from the  management  targets.
              The <u>receiver</u> can have three values:

                * <u>no_receiver</u> - No information is delivered.

                * <u>notification_delivery_info()</u>  -  The information is delivered via a function call according to
                  this data. See the DATA TYPES section above for details.

                * <u>{tag(),</u> <u>tag_receiver()}</u> - The information is delivered either via messages or via  a  function
                  call according to the value of <u>tag_receiver()</u>.

                  Delivery is done differently depending on the value of <u>tag_receiver()</u>:

                  * <u>pid()</u> <u>|</u> <u>registered_name()</u> - The info will be delivered in the following messages:

                    * <u>{snmp_targets,</u> <u>tag(),</u> <u>Addresses}</u>

                      This informs the user which target addresses the notification was sent to.

                    * <u>{snmp_notification,</u> <u>tag(),</u> <u>{got_response,</u> <u>Address}}</u>

                      This informs the user that this target address acknowledged the notification.

                    * <u>{snmp_notification,</u> <u>tag(),</u> <u>{no_response,</u> <u>Address}}</u>

                      This informs the user that this target address did not acknowledge the notification.

                    The  notification  is  sent  as an Inform-Request to each target address in <u>Addresses</u> and if
                    there are no targets for which an Inform-Request is sent, <u>Addresses</u> is the empty list <u>[]</u>.

                    The <u>tag_receiver()</u> will first be sent the <u>snmp_targets</u> message, and then for each address in
                    <u>Addresses</u> list, one of the two <u>snmp_notification</u> messages.

                  * <u>{Mod,</u> <u>Func,</u> <u>Args}</u> - The info will be delivered via the function call:

                    <u>Mod:Func([Msg</u> <u>|</u> <u>Args])</u>

                    where <u>Msg</u> has the same content and purpose as the messages descrived above.

              The 'process oid' "tag" that can be provided with the variable name / oids is indended to be  used
              for  oid  post processing. The value '<u>keep</u>', which is the default, leaves the oid as is. The value
              '<u>truncate</u>', will cause the oid to be "truncated". That is, any trailing ".0" will be removed.

          <b>Note:</b>
              There is a way to exclude a varbind from the notification. In the normal <u>varbinds</u> list,  providing
              the  special  value  <u>'$ignore-oid'</u>  (instead of a normal value) will exclude this varbind from the
              notification.

              A define for this has been added to the <u>snmp_types.hrl</u> include file, <u>NOTIFICATION_IGNORE_VB_VALUE</u>.

          <b>Note:</b>
              The <u>extra</u> info is not normally interpreted by the agent, instead it is passed through to the  net-
              if process. It is up to the implementor of that process to make use of this data.

              The  version of net-if provided by this application makes no use of this data, with one exception:
              Any tuple containing the atom <u>snmpa_default_notification_extra_info</u> may be used by the  agent  and
              is therefor <u>reserved</u>.

              See the net-if incomming messages for sending a  trap and  notification for more info.

       <b>send_notification(Agent,</b> <b>Notification,</b> <b>Receiver)</b>
       <b>send_notification(Agent,</b> <b>Notification,</b> <b>Receiver,</b> <b>Varbinds)</b>
       <b>send_notification(Agent,</b> <b>Notification,</b> <b>Receiver,</b> <b>NotifyName,</b> <b>Varbinds)</b>
       <b>send_notification(Agent,</b> <b>Notification,</b> <b>Receiver,</b> <b>NotifyName,</b> <b>ContextName,</b> <b>Varbinds)</b> <b>-&gt;</b> <b>void()</b>
       <b>send_notification(Agent,</b>  <b>Notification,</b>  <b>Receiver,</b>  <b>NotifyName,</b>  <b>ContextName,</b> <b>Varbinds,</b> <b>LocalEngineID)</b> <b>-&gt;</b>
       <b>void()</b>

              Types:

                 Agent = pid() | atom()
                 Notification = atom()
                 Receiver = no_receiver | {Tag, Recv} | notification_delivery_info()
                 Tag = term()
                 Recv = receiver()
                 receiver() = pid() | atom() | {Mod, Func, Args}
                 Mod = atom()
                 Func = atom()
                 Args = list()
                 NotifyName = string()
                 ContextName = string()
                 Varbinds = varbinds()
                 varbinds() = [varbind()]
                 varbind() = {Variable, Value} | {Column, RowIndex, Value} | {OID, Value}
                 Variable = atom()
                 Column = atom()
                 OID = oid()
                 Value = term()
                 RowIndex = [int()]
                 LocalEngineID = string()

              Sends the notification <u>Notification</u> to the  management  targets  defined  for  <u>NotifyName</u>  in  the
              <u>snmpNotifyTable</u> in SNMP-NOTIFICATION-MIB from the specified context.

              If no <u>NotifyName</u> is specified (or if it is <u>""</u>), the notification is sent to all management targets
              (<u>Addresses</u> below).

              If no <u>ContextName</u> is specified, the default <u>""</u> context is used.

              The  parameter  <u>Receiver</u>  specifies  where information about delivery of Inform-Requests should be
              sent. The agent sends Inform-Requests and waits for acknowledgments from  the  managers.  <u>Receiver</u>
              can have three values:

                * <u>no_receiver</u> - No information is delivered.

                * <u>notification_delivery_info()</u>  -  The information is delivered via a function call according to
                  this data. See the DATA TYPES section above for details.

                * <u>{Tag,</u> <u>Recv}</u> - The information is  delivered  either  via  messages  or  via  a  function  call
                  according to the value of <u>Recv</u>.

              If <u>Receiver</u> has the value <u>{Tag,</u> <u>Recv}</u>, the delivery is done according to <u>Recv</u>:

                * <u>pid()</u> <u>|</u> <u>atom()</u> - The info will be delivered in the following messages:

                  * <u>{snmp_targets,</u> <u>Tag,</u> <u>Addresses}</u>

                    This inform the user which target addresses the notification was sent to.

                  * <u>{snmp_notification,</u> <u>Tag,</u> <u>{got_response,</u> <u>Address}}</u>

                    This informs the user that this target address acknowledged the notification.

                  * <u>{snmp_notification,</u> <u>Tag,</u> <u>{no_response,</u> <u>Address}}</u>

                    This informs the user that this target address did not acknowledge notification.

                  The notification is sent as an Inform-Request to each target address in <u>Addresses</u> and if there
                  are no targets for which an Inform-Request is sent, <u>Addresses</u> is the empty list <u>[]</u>.

                  The  <u>receiver</u>  will  first  be  sent  the  <u>snmp_targets</u>  message, and then for each address in
                  <u>Addresses</u> list, one of the two <u>snmp_notification</u> messages.

                * <u>{Mod,</u> <u>Func,</u> <u>Args}</u> - The info will be delivered via the function call:

                  <u>Mod:Func([Msg</u> <u>|</u> <u>Args])</u>

                  where <u>Msg</u> has the same content and purpose as the messages descrived above.

              <u>Address</u> is a management target address and <u>Addresses</u> is a list  of  management  target  addresses.
              They are defined as followes:

                      Addresses  = [address()]
                      Address    = address()
                      address()  = v1_address() | v3_address()
                      v1_address() = {TDomain, TAddress}
                      v3_address() = {{TDomain, TAddress}, V3MsgData}
                      TDomain    = tdoamin()
                      TAddress   = taddress()
                      tdomain()  = The oid of snmpUDPDomain
                                   This is the only supported transport domain.
                      taddress() = [A1, A2, A3, A4, P1, P3]
                                   The 4 first bytes makes up the IP-address and the last 2,
                                   the UDP-port number.
                      V3MsgData  = v3_msg_data()
                      v3_msg_data() = term()

              If  <u>Receiver</u> is a <u>notification_delivery_info()</u> record, then the information about the notification
              delivery  will  be  delivered  to  the  <u>receiver</u>  via  the  callback  functions  defined  by   the
              snmpa_notification_delivery_info_receiver    behaviour   according   to   the   content   of   the
              <u>notification_delivery_info()</u> record.

              The optional argument <u>Varbinds</u> defines values for the objects in the notification. If no value  is
              given for an object, the <u>Agent</u> performs a get-operation to retrieve the value.

              <u>Varbinds</u> is a list of <u>Varbind</u>, where each <u>Varbind</u> is one of:

                * <u>{Variable,</u> <u>Value}</u>, where <u>Variable</u> is the symbolic name of a scalar variable referred to in the
                  notification specification.

                * <u>{Column,</u> <u>RowIndex,</u> <u>Value}</u>, where <u>Column</u> is the symbolic name of a column variable. <u>RowIndex</u> is
                  a  list  of indices for the specified element. If this is the case, the OBJECT IDENTIFIER sent
                  in the notification is the <u>RowIndex</u> appended to the OBJECT IDENTIFIER for  the  table  column.
                  This is the OBJECT IDENTIFIER which specifies the element.

                * <u>{OID,</u>  <u>Value}</u>,  where  <u>OID</u>  is  the  OBJECT  IDENTIFIER  for  an instance of an object, scalar
                  variable, or column variable.

              For example, to specify that <u>sysLocation</u> should have the value <u>"upstairs"</u> in the notification,  we
              could use one of:

                * <u>{sysLocation,</u> <u>"upstairs"}</u> or

                * <u>{[1,3,6,1,2,1,1,6,0],</u> <u>"upstairs"}</u> or

                * <u>{?sysLocation_instance,</u> <u>"upstairs"}</u> (provided that the generated <u>.hrl</u> file is included)

              If  a  variable in the notification is a table element, the <u>RowIndex</u> for the element must be given
              in the <u>Varbinds</u> list. In this case, the OBJECT IDENTIFIER sent in the notification is  the  OBJECT
              IDENTIFIER  that  identifies this element. This OBJECT IDENTIFIER could be used in a get operation
              later.

              This function is asynchronous, and does not return any information. If an error occurs, <u>user_err/2</u>
              of the error report module is called and the notification is discarded.

          <b>Note:</b>
              Note that the use of the LocalEngineID argument is only intended for special cases, if  the  agent
              is  to  "emulate"  multiple  EngineIDs!  By default, the agent uses the value of <u>SnmpEngineID</u> (see
              SNMP-FRAMEWORK-MIB).

              <u>ExtraInfo</u> is not normally used in any way by the agent. It is intended to be passed along  to  the
              net-if  process, which is a component that a user can implement themself. The users own net-if may
              then make use of ExtraInfo. The net-if provided with this application does not process ExtraInfo.

              There is one exception. <u>Any</u> tuple containing the atom <u>snmpa_default_notification_extra_info</u>  will,
              in this context, be considered belonging to this application, and may be processed by the agent.

       <b>discovery(TargetName,</b> <b>Notification)</b> <b>-&gt;</b> <b>{ok,</b> <b>ManagerEngineID}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>discovery(TargetName,</b> <b>Notification,</b> <b>Varbinds)</b> <b>-&gt;</b> <b>{ok,</b> <b>ManagerEngineID}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>discovery(TargetName,</b> <b>Notification,</b> <b>DiscoHandler)</b> <b>-&gt;</b> <b>{ok,</b> <b>ManagerEngineID}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>discovery(TargetName,</b> <b>Notification,</b> <b>ContextName,</b> <b>Varbinds)</b> <b>-&gt;</b> <b>{ok,</b> <b>ManagerEngineID}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>discovery(TargetName,</b> <b>Notification,</b> <b>Varbinds,</b> <b>DiscoHandler)</b> <b>-&gt;</b> <b>{ok,</b> <b>ManagerEngineID}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>discovery(TargetName,</b>  <b>Notification,</b>  <b>ContextName,</b>  <b>Varbinds,</b>  <b>DiscoHandler)</b>  <b>-&gt;</b>  <b>{ok,</b> <b>ManagerEngineID}</b> <b>|</b>
       <b>{error,</b> <b>Reason}</b>
       <b>discovery(TargetName,</b>   <b>Notification,</b>   <b>ContextName,</b>   <b>Varbinds,</b>   <b>DiscoHandler,</b>   <b>ExtraInfo)</b>   <b>-&gt;</b>   <b>{ok,</b>
       <b>ManagerEngineID}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 TargetName = string()
                 Notification = atom()
                 ContextName = string() (defaults to "")
                 Varbinds = varbinds()
                 varbinds() = [varbind()]
                 DiscoHandler = snmpa_discovery_handler()
                 ExtraInfo = term()
                 snmpa_discovery_handler() = Module implementing the snmpa_discovery_handler behaviour
                 ManagerEngineID = string()
                 varbind() = {Variable, Value} | {Column, RowIndex, Value} | {OID, Value}
                 Variable = atom()
                 Column = atom()
                 OID = oid()
                 Value = term()
                 RowIndex = [int()]
                 Reason = term()

              Initiate  the  discovery  process with the manager identified by <u>TargetName</u> using the notification
              <u>Notification</u>.

              This function is synchronous, which means that it will return when the discovery process has  been
              completed or failed.

              The <u>DiscoHandler</u> module is used during the discovery process. See discovery handler for more info.

              The <u>ExtraInfo</u> argument is passed on to the callback functions of the <u>DiscoHandler</u>.

          <b>Note:</b>
              If we are not at security-level <u>noAuthNoPriv</u>, this could be complicated, since the agent will then
              continue with stage 2, before which the usm-related updates must be done.

          <b>Note:</b>
              The default discovery handler will require additional actions by the caller and the discovery will
              not work if the security-level is higher then <u>noAuthNoPriv</u>.

       <b>convert_config(OldConfig)</b> <b>-&gt;</b> <b>AgentConfig</b>

              Types:

                 OldConfig = list()
                 AgentConfig = list()

              This  off-line  utility  function  can  be  used  to  convert the old snmp application config (pre
              snmp-4.0) to the new snmp agent config (as of snmp-4.0).

              For information about the old config (<u>OldConfig</u>) see the OTP R9C documentation.

              For information about the current agent config (<u>AgentConfig</u>), see the Configuring the  application
              chapter of the SNMP user's guide.

       <b>restart_worker()</b> <b>-&gt;</b> <b>void()</b>
       <b>restart_worker(Agent)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Agent = pid() | atom()

              Restart the worker process of a multi-threaded agent.

              This is a utility function, that can be useful when e.g. debugging instrumentation functions.

       <b>restart_set_worker()</b> <b>-&gt;</b> <b>void()</b>
       <b>restart_set_worker(Agent)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Agent = pid() | atom()

              Restart the set worker process of a multi-threaded agent.

              This is a utility function, that can be useful when e.g. debugging instrumentation functions.

       <b>print_mib_info()</b> <b>-&gt;</b> <b>void()</b>

              Prints the content of all the (snmp) tables and variables for all mibs handled by the snmp agent.

       <b>print_mib_tables()</b> <b>-&gt;</b> <b>void()</b>

              Prints the content of all the (snmp) tables for all mibs handled by the snmp agent.

       <b>print_mib_variables()</b> <b>-&gt;</b> <b>void()</b>

              Prints the content of all the (snmp) variables for all mibs handled by the snmp agent.

       <b>verbosity(Ref,Verbosity)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Ref  =  pid() | sub_agents | master_agent | net_if | mib_server | symbolic_store | note_store |
                 local_db
                 Verbosity = verbosity() | {subagents, verbosity()}
                 verbosity() = silence | info | log | debug | trace

              Sets verbosity for the designated process. For the lowest verbosity <u>silence</u>, nothing  is  printed.
              The higher the verbosity, the more is printed.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3erl/calendar.3erl.html">calendar</a>(3erl), <a href="../man1/erlc.1.html">erlc</a>(1)

Ericsson AB                                         snmp 5.11                                        <u><a href="../man3erl/snmpa.3erl.html">snmpa</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>