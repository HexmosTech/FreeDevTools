<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ssl - Interface Functions for Secure Socket Layer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ssl - Interface Functions for Secure Socket Layer

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  contains  interface functions for the TLS/DTLS protocol. For detailed information about the
       supported standards see <a href="../man7/ssl.7.html">ssl</a>(7).

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
   <b>Types</b> <b>used</b> <b>in</b> <b>TLS/DTLS</b>
       <b>socket()</b> = gen_tcp:socket()

       <b>sslsocket()</b> = any()

              An opaque reference to the TLS/DTLS connection, may be used for equality matching.

       <b>tls_option()</b> = tls_client_option() | tls_server_option()

       <b>tls_client_option()</b> =
           client_option() |
           common_option() |
           socket_option() |
           transport_option()

       <b>tls_server_option()</b> =
           server_option() |
           common_option() |
           socket_option() |
           transport_option()

       <b>socket_option()</b> =
           gen_tcp:connect_option() |
           gen_tcp:listen_option() |
           gen_udp:option()

              The default socket options are <u>[{mode,list},{packet,</u> <u>0},{header,</u> <u>0},{active,</u> <u>true}]</u>.

              For valid options, see the <a href="../man3erl/inet.3erl.html">inet</a>(3erl), <a href="../man3erl/gen_tcp.3erl.html">gen_tcp</a>(3erl) and <a href="../man3erl/gen_udp.3erl.html">gen_udp</a>(3erl)  manual  pages  in  Kernel.
              Note that stream oriented options such as packet are only relevant for TLS and not DTLS

       <b>active_msgs()</b> =
           {ssl, sslsocket(), Data :: binary() | list()} |
           {ssl_closed, sslsocket()} |
           {ssl_error, sslsocket(), Reason :: any()} |
           {ssl_passive, sslsocket()}

              When  a  TLS/DTLS socket is in active mode (the default), data from the socket is delivered to the
              owner of the socket in the form of messages as described above.

              The <u>ssl_passive</u> message is sent only when the socket is  in  <u>{active,</u>  <u>N}</u>  mode  and  the  counter
              dropped to 0. It indicates that the socket has transitioned to passive (<u>{active,</u> <u>false}</u>) mode.

       <b>transport_option()</b> =
           {cb_info,
            {CallbackModule :: atom(),
             DataTag :: atom(),
             ClosedTag :: atom(),
             ErrTag :: atom()}} |
           {cb_info,
            {CallbackModule :: atom(),
             DataTag :: atom(),
             ClosedTag :: atom(),
             ErrTag :: atom(),
             PassiveTag :: atom()}}

              Defaults to <u>{gen_tcp,</u> <u>tcp,</u> <u>tcp_closed,</u> <u>tcp_error,</u> <u>tcp_passive}</u> for TLS (for backward compatibility
              a four tuple will be converted to a five tuple with the last element "second_element"_passive) and
              <u>{gen_udp,</u>  <u>udp,</u>  <u>udp_closed,</u>  <u>udp_error}</u>  for  DTLS  (might  also  be changed to five tuple in the
              future). Can be used to customize the transport layer. The tag values should be the values used by
              the underlying transport in its active mode messages. For TLS the callback module must implement a
              reliable  transport  protocol,  behave  as  <u>gen_tcp</u>,   and   have   functions   corresponding   to
              <u>inet:setopts/2</u>,  <u>inet:getopts/2</u>,  <u>inet:peername/1</u>,  <u>inet:sockname/1</u>, and <u>inet:port/1</u>. The callback
              <u>gen_tcp</u> is treated specially and calls <u>inet</u> directly. For DTLS this  feature  must  be  considered
              exprimental.

       <b>host()</b> = hostname() | ip_address()

       <b>hostname()</b> = string()

       <b>ip_address()</b> = inet:ip_address()

       <b>protocol_version()</b> = tls_version() | dtls_version()

       <b>tls_version()</b> = 'tlsv1.2' | 'tlsv1.3' | tls_legacy_version()

       <b>dtls_version()</b> = 'dtlsv1.2' | dtls_legacy_version()

       <b>tls_legacy_version()</b> = tlsv1 | 'tlsv1.1'

       <b>dtls_legacy_version()</b> = dtlsv1

       <b>prf_random()</b> = client_random | server_random

       <b>verify_type()</b> = verify_none | verify_peer

       <b>ciphers()</b> = [erl_cipher_suite()] | string()

       <b>erl_cipher_suite()</b> =
           #{key_exchange := kex_algo(),
             cipher := cipher(),
             mac := hash() | aead,
             prf := hash() | default_prf}

       <b>cipher()</b> =
           aes_128_cbc | aes_256_cbc | aes_128_gcm | aes_256_gcm |
           aes_128_ccm | aes_256_ccm | aes_128_ccm_8 | aes_256_ccm_8 |
           chacha20_poly1305 |
           legacy_cipher()

       <b>legacy_cipher()</b> = rc4_128 | des_cbc | '3des_ede_cbc'

       <b>cipher_filters()</b> =
           [{key_exchange | cipher | mac | prf, algo_filter()}]

       <b>hash()</b> = sha | sha2() | legacy_hash()

       <b>sha2()</b> = sha224 | sha256 | sha384 | sha512

       <b>legacy_hash()</b> = md5

       <b>old_cipher_suite()</b> =
           {kex_algo(), cipher(), hash()} |
           {kex_algo(), cipher(), hash() | aead, hash()}

       <b>sign_algo()</b> = rsa | dsa | ecdsa | eddsa

       <b>sign_scheme()</b> =
           eddsa_ed25519 | eddsa_ed448 | ecdsa_secp256r1_sha256 |
           ecdsa_secp384r1_sha384 | ecdsa_secp521r1_sha512 |
           rsassa_pss_scheme() |
           sign_scheme_legacy()

       <b>rsassa_pss_scheme()</b> =
           rsa_pss_rsae_sha256 | rsa_pss_rsae_sha384 |
           rsa_pss_rsae_sha512 | rsa_pss_pss_sha256 |
           rsa_pss_pss_sha384 | rsa_pss_pss_sha512

       <b>sign_scheme_legacy()</b> =
           rsa_pkcs1_sha256 | rsa_pkcs1_sha384 | rsa_pkcs1_sha512 |
           rsa_pkcs1_sha1 | ecdsa_sha1

       <b>group()</b> =
           secp256r1 | secp384r1 | secp521r1 | ffdhe2048 | ffdhe3072 |
           ffdhe4096 | ffdhe6144 | ffdhe8192

       <b>kex_algo()</b> =
           rsa | dhe_rsa | dhe_dss | ecdhe_ecdsa | ecdh_ecdsa |
           ecdh_rsa | srp_rsa | srp_dss | psk | dhe_psk | rsa_psk |
           dh_anon | ecdh_anon | srp_anon | any

       <b>algo_filter()</b> =
           fun((kex_algo() | cipher() | hash() | aead | default_prf) -&gt;
                   true | false)

       <b>named_curve()</b> =
           sect571r1 | sect571k1 | secp521r1 | brainpoolP512r1 |
           sect409k1 | sect409r1 | brainpoolP384r1 | secp384r1 |
           sect283k1 | sect283r1 | brainpoolP256r1 | secp256k1 |
           secp256r1 | sect239k1 | sect233k1 | sect233r1 | secp224k1 |
           secp224r1 | sect193r1 | sect193r2 | secp192k1 | secp192r1 |
           sect163k1 | sect163r1 | sect163r2 | secp160k1 | secp160r1 |
           secp160r2

       <b>psk_identity()</b> = string()

       <b>srp_identity()</b> = {Username :: string(), Password :: string()}

       <b>srp_param_type()</b> =
           srp_1024 | srp_1536 | srp_2048 | srp_3072 | srp_4096 |
           srp_6144 | srp_8192

       <b>app_level_protocol()</b> = binary()

       <b>protocol_extensions()</b> =
           #{renegotiation_info =&gt; binary(),
             signature_algs =&gt; signature_algs(),
             alpn =&gt; app_level_protocol(),
             srp =&gt; binary(),
             next_protocol =&gt; app_level_protocol(),
             max_frag_enum =&gt; 1..4,
             ec_point_formats =&gt; [0..2],
             elliptic_curves =&gt; [public_key:oid()],
             sni =&gt; hostname()}

       <b>error_alert()</b> =
           {tls_alert, {tls_alert(), Description :: string()}}

       <b>tls_alert()</b> =
           close_notify | unexpected_message | bad_record_mac |
           record_overflow | handshake_failure | bad_certificate |
           unsupported_certificate | certificate_revoked |
           certificate_expired | certificate_unknown |
           illegal_parameter | unknown_ca | access_denied |
           decode_error | decrypt_error | export_restriction |
           protocol_version | insufficient_security | internal_error |
           inappropriate_fallback | user_canceled | no_renegotiation |
           unsupported_extension | certificate_unobtainable |
           unrecognized_name | bad_certificate_status_response |
           bad_certificate_hash_value | unknown_psk_identity |
           no_application_protocol

       <b>reason()</b> = any()

       <b>bloom_filter_window_size()</b> = integer()

       <b>bloom_filter_hash_functions()</b> = integer()

       <b>bloom_filter_bits()</b> = integer()

       <b>client_session_tickets()</b> = disabled | manual | auto

       <b>server_session_tickets()</b> = disabled | stateful | stateless

   <b>TLS/DTLS</b> <b>OPTION</b> <b>DESCRIPTIONS</b> <b>-</b> <b>COMMON</b> <b>for</b> <b>SERVER</b> <b>and</b> <b>CLIENT</b>
       <b>common_option()</b> =
           {protocol, protocol()} |
           {handshake, handshake_completion()} |
           {cert, cert() | [cert()]} |
           {certfile, cert_pem()} |
           {key, key()} |
           {keyfile, key_pem()} |
           {password, key_password()} |
           {ciphers, cipher_suites()} |
           {eccs, [named_curve()]} |
           {signature_algs, signature_algs()} |
           {signature_algs_cert, sign_schemes()} |
           {supported_groups, supported_groups()} |
           {secure_renegotiate, secure_renegotiation()} |
           {keep_secrets, keep_secrets()} |
           {depth, allowed_cert_chain_length()} |
           {verify_fun, custom_verify()} |
           {crl_check, crl_check()} |
           {crl_cache, crl_cache_opts()} |
           {max_handshake_size, handshake_size()} |
           {partial_chain, root_fun()} |
           {versions, protocol_versions()} |
           {user_lookup_fun, custom_user_lookup()} |
           {log_level, logging_level()} |
           {log_alert, log_alert()} |
           {hibernate_after, hibernate_after()} |
           {padding_check, padding_check()} |
           {beast_mitigation, beast_mitigation()} |
           {ssl_imp, ssl_imp()} |
           {session_tickets, session_tickets()} |
           {key_update_at, key_update_at()} |
           {middlebox_comp_mode, middlebox_comp_mode()}

       <b>protocol()</b> = tls | dtls

              Choose  TLS  or  DTLS  protocol  for the transport layer security. Defaults to <u>tls</u>. For DTLS other
              transports than UDP are not yet supported.

       <b>handshake_completion()</b> = hello | full

              Defaults to <u>full</u>. If hello is specified the handshake will pause after the hello message and  give
              the  user a possibility make decisions based on hello extensions before continuing or aborting the
              handshake by calling  handshake_continue/3 or  handshake_cancel/1

       <b>cert()</b> = public_key:der_encoded()

              The DER-encoded users certificate. Note that the cert option may also be  a  list  of  DER-encoded
              certificates  where  the  first  one  is  the  users  certificate and the rest of the certificates
              constitutes the certificate chain. For maximum interoperability  the  certificates  in  the  chain
              should  be  in  the correct order, the chain will be sent as is to the peer. If chain certificates
              are not  provided,  certificates  from  client_cacerts(),  server_cacerts(),  or  client_cafile(),
              server_cafile()  are  used to construct the chain. If this option is supplied, it overrides option
              <u>certfile</u>.

       <b>cert_pem()</b> = file:filename()

              Path to a file containing the user certificate on PEM  format  or  possible  several  certificates
              where  the  first  one  is  the users certificate and the rest of the certificates constitutes the
              certificate chain. For more details see cert(),

       <b>key()</b> =
           {'RSAPrivateKey' | 'DSAPrivateKey' | 'ECPrivateKey' |
            'PrivateKeyInfo',
            public_key:der_encoded()} |
           #{algorithm := rsa | dss | ecdsa,
             engine := crypto:engine_ref(),
             key_id := crypto:key_id(),
             password =&gt; crypto:password()}

              The DER-encoded user's private key or a map refering to a crypto engine and its key reference that
              optionally can be password protected, seealso  crypto:engine_load/4  and  Crypto's Users Guide. If
              this option is supplied, it overrides option <u>keyfile</u>.

       <b>key_pem()</b> = file:filename()

              Path to the file containing the user's private PEM-encoded key. As PEM-files can  contain  several
              entries, this option defaults to the same file as given by option <u>certfile</u>.

       <b>key_password()</b> = string()

              String containing the user's password. Only used if the private keyfile is password-protected.

       <b>cipher_suites()</b> = ciphers()

              A list of cipher suites that should be supported

              The  function   ssl:cipher_suites/2   can  be used to find all cipher suites that are supported by
              default and all cipher suites that may be configured.

              If you compose your own  <u>cipher_suites()</u>  make  sure  they  are  filtered  for  cryptolib  support
              ssl:filter_cipher_suites/2     Additionaly    the    functions     ssl:append_cipher_suites/2    ,
              ssl:prepend_cipher_suites/2,         ssl:suite_to_str/1,          ssl:str_to_suite/1,          and
              ssl:suite_to_openssl_str/1 also exist to help creating customized cipher suite lists.

          <b>Note:</b>
              Note  that  TLS-1.3  and  TLS-1.2  cipher  suites  are not overlapping sets of cipher suites so to
              support both these versions cipher suites from both versions need to  be  included.  Also  if  the
              supplied  list  does not comply with the configured versions or cryptolib so that the list becomes
              empty, this option will fallback on its appropriate default value for the configured versions.

              Non-default cipher suites including anonymous  cipher  suites  (PRE  TLS-1.3)  are  supported  for
              interop/testing  purposes and may be used by adding them to your cipher suite list. Note that they
              must also be supported/enabled by the peer to actually be used.

       <b>signature_algs()</b> = [{hash(), sign_algo()} | sign_scheme()]

              Explicitly list acceptable signature algorithms for certificates and  handshake  messages  in  the
              preferred  order.  The client will send its list as the client hello <u>signature_algorithm</u> extension
              introduced in TLS-1.2, see Section 7.4.1.4.1  in  RFC  5246.  Previously  these  algorithms  where
              implicitly chosen and partly derived from the cipher suite.

              In  TLS-1.2  a  somewhat  more  explicit  negotiation  is  made  possible using a list of {hash(),
              sign_algo()} pairs.

              In TLS-1.3 these algorithm pairs are replaced by so called  signature  schemes  sign_scheme()  and
              completely decoupled from the cipher suite.

              Signature algorithms used for certificates may be overridden by the signature schemes (algorithms)
              supplied by the <u>signature_algs_cert</u> option.

              TLS-1.2 default is

              <u>Default_TLS_12_Alg_Pairs</u> <u>=</u>

              [
              %% SHA2
              {sha512, ecdsa},
              {sha512, rsa},
              {sha384, ecdsa},
              {sha384, rsa},
              {sha256, ecdsa},
              {sha256, rsa},
              {sha224, ecdsa},
              {sha224, rsa},
              %% SHA
              {sha, ecdsa},
              {sha, rsa},
              {sha, dsa}
              ]

              Support for {md5, rsa} was removed from the the TLS-1.2 default in ssl-8.0 (OTP-22)

               <u>TLS_13</u> <b>_</b><u>Legacy_Schemes</u> <u>=</u>

               [
               %% Legacy algorithms only applicable to certificate signatures
              rsa_pkcs1_sha512, %% Corresponds to {sha512, rsa}
              rsa_pkcs1_sha384, %% Corresponds to {sha384, rsa}
              rsa_pkcs1_sha256, %% Corresponds to {sha256, rsa}
              ecdsa_sha1,       %% Corresponds to {sha, ecdsa}
              rsa_pkcs1_sha1    %% Corresponds to {sha, rsa}
              ]

               <u>Default_TLS_13_Schemes</u> <u>=</u>

               [
              %% ECDSA
              ecdsa_secp521r1_sha512,
              ecdsa_secp384r1_sha384,
              ecdsa_secp256r1_sha256,
              %% RSASSA-PSS
              rsa_pss_pss_sha512,
              rsa_pss_pss_sha384,
              rsa_pss_pss_sha256,
              rsa_pss_rsae_sha512,
              rsa_pss_rsae_sha384,
              rsa_pss_rsae_sha256,
              %% EDDSA
              eddsa_ed25519,
              eddsa_ed448]

              TLS-1.3 default is

              Default_TLS_13_Schemes ++ Legacy_TLS_13_Schemes

              If both TLS-1.3 and TLS-1.2 are supported the default will be

              Default_TLS_13_Schemes ++ Default_TLS_12_Alg_Pairs

              so appropriate algorithms can be chosen for the negotiated version.

          <b>Note:</b>
              TLS-1.2  algorithms will not be negotiated for TLS-1.3, but TLS-1.3 RSASSA-PSS rsassa_pss_scheme()
              signature schemes may be negotiated also for  TLS-1.2  from  24.1  (fully  working  from  24.1.3).
              However  if  TLS-1.3  is negotiated when both TLS-1.3 and TLS-1.2 is supported using defaults, the
              corresponding TLS-1.2 algorithms to the TLS-1.3 legacy signature schemes will be considered as the
              legacy schemes and applied only to certificate signatures.

       <b>sign_schemes()</b> = [sign_scheme()]

              Explicitly list acceptable signature schemes (algorithms), in prefered ordered, for  certificates,
              overrides the algorithms supplied in <u>signature_algs</u> option for certificates.

              In  addition  to the <u>signature_algorithms</u> extension from TLS 1.2, TLS 1.3 (RFC 5246 Section 4.2.3)
              adds the <u>signature_algorithms_cert</u> extension which enables  having  special  requirements  on  the
              signatures  used in the certificates that differs from the requirements on digital signatures as a
              whole. If this is not required this extension is not need.

              The client will send a <u>signature_algorithms_cert</u> extension (in the client hello message),  if  TLS
              version  1.2 (back-ported to TLS 1.2 in 24.1) or later is used, and the signature_algs_cert option
              is explicitly specified. By default, only the signature_algs extension is sent.

          <b>Note:</b>
              Note that supported signature schemes for TLS-1.2 are sign_scheme_legacy() and rsassa_pss_scheme()

       <b>supported_groups()</b> = [group()]

              TLS 1.3 introduces the "supported_groups" extension that  is  used  for  negotiating  the  Diffie-
              Hellman parameters in a TLS 1.3 handshake. Both client and server can specify a list of parameters
              that they are willing to use.

              If  it  is not specified it will use a default list ([x25519, x448, secp256r1, secp384r1]) that is
              filtered based on the installed crypto library version.

       <b>secure_renegotiation()</b> = boolean()

              Specifies if to reject renegotiation attempt that does  not  live  up  to  RFC  5746.  By  default
              <u>secure_renegotiate</u>  is  set  to  <u>true</u>,  that is, secure renegotiation is enforced. If set to <u>false</u>
              secure renegotiation will still be used if possible, but it falls back to  insecure  renegotiation
              if the peer does not support RFC 5746.

       <b>allowed_cert_chain_length()</b> = integer()

              Maximum  number  of non-self-issued intermediate certificates that can follow the peer certificate
              in a valid certification path. So, if depth is 0 the PEER must be signed by  the  trusted  ROOT-CA
              directly;  if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and
              so on. The default value is 10.

       <b>custom_verify()</b> =
           {Verifyfun :: function(), InitialUserState :: any()}

              The verification fun is to be defined as follows:

              fun(OtpCert :: #'OTPCertificate'{}, Event :: {bad_cert, Reason :: atom() |
                           {revoked, atom()}} |
                        {extension, #'Extension'{}} | valid | valid_peer, InitialUserState :: term()) -&gt;
                   {valid, UserState :: term()} |
                   {fail, Reason :: term()} | {unknown, UserState :: term()}.

              The verification fun is called during the X509-path validation  when  an  error  or  an  extension
              unknown  to the SSL application is encountered. It is also called when a certificate is considered
              valid by the path validation to allow  access  to  each  certificate  in  the  path  to  the  user
              application.  It  differentiates  between  the  peer  certificate and the CA certificates by using
              <u>valid_peer</u> or <u>valid</u> as second argument to the verification fun. See the  public_key  User's  Guide
              for definition of <u>#'OTPCertificate'{}</u> and <u>#'Extension'{}</u>.

                * If  the  verify  callback  fun returns <u>{fail,</u> <u>Reason}</u>, the verification process is immediately
                  stopped, an alert is sent to the peer, and the TLS/DTLS handshake terminates.

                * If the verify callback fun returns <u>{valid,</u> <u>UserState}</u>, the verification process continues.

                * If the verify callback fun always returns <u>{valid,</u> <u>UserState}</u>, the TLS/DTLS handshake does  not
                  terminate regarding verification failures and the connection is established.

                * If called with an extension unknown to the user application, return value <u>{unknown,</u> <u>UserState}</u>
                  is to be used.

                  Note  that  if  the  fun  returns <u>unknown</u> for an extension marked as critical, validation will
                  fail.

              Default option <u>verify_fun</u> in <u>verify_peer</u> <u>mode</u>:

              {fun(_,{bad_cert, _} = Reason, _) -&gt;
                    {fail, Reason};
                  (_,{extension, _}, UserState) -&gt;
                    {unknown, UserState};
                  (_, valid, UserState) -&gt;
                    {valid, UserState};
                  (_, valid_peer, UserState) -&gt;
                       {valid, UserState}
               end, []}

              Default option <u>verify_fun</u> in mode <u>verify_none</u>:

              {fun(_,{bad_cert, _}, UserState) -&gt;
                    {valid, UserState};
                  (_,{extension, #'Extension'{critical = true}}, UserState) -&gt;
                    {valid, UserState};
                  (_,{extension, _}, UserState) -&gt;
                    {unknown, UserState};
                  (_, valid, UserState) -&gt;
                    {valid, UserState};
                  (_, valid_peer, UserState) -&gt;
                       {valid, UserState}
               end, []}

              The possible path validation errors are given on form <u>{bad_cert,</u> <u>Reason}</u> where <u>Reason</u> is:

                <u>unknown_ca</u>:
                  No trusted CA was found in the trusted store. The trusted CA is normally a so called ROOT  CA,
                  which  is  a  self-signed  certificate.  Trust  can be claimed for an intermediate CA (trusted
                  anchor does not have to be self-signed according to X-509) by using option <u>partial_chain</u>.

                <u>selfsigned_peer</u>:
                  The chain consisted only of one self-signed certificate.

                <u>PKIX</u> <u>X-509-path</u> <u>validation</u> <u>error</u>:
                  For possible reasons, see public_key:pkix_path_validation/3

       <b>crl_check()</b> = boolean() | peer | best_effort

              Perform CRL (Certificate Revocation List) verification  (public_key:pkix_crls_validate/3)  on  all
              the   certificates   during   the  path  validation  (public_key:pkix_path_validation/3)   of  the
              certificate chain. Defaults to <u>false</u>.

                <u>peer</u>:
                  check is only performed on the peer certificate.

                <u>best_effort</u>:
                  if certificate revocation status cannot be determined it will be accepted as valid.

              The CA certificates specified for the connection will be used to construct the  certificate  chain
              validating the CRLs.

              The CRLs will be fetched from a local or external cache. See <a href="../man3erl/ssl_crl_cache_api.3erl.html">ssl_crl_cache_api</a>(3erl).

       <b>crl_cache_opts()</b> =
           {Module :: atom(),
            {DbHandle :: internal | term(), Args :: list()}}

              Specify  how  to  perform  lookup  and caching of certificate revocation lists. <u>Module</u> defaults to
              ssl_crl_cache with  <u>DbHandle</u>  being <u>internal</u> and an empty argument list.

              There are two implementations available:

                <u>ssl_crl_cache</u>:
                  This module maintains a cache of CRLs. CRLs can be added  to  the  cache  using  the  function
                  ssl_crl_cache:insert/1,  and  optionally  automatically  fetched through HTTP if the following
                  argument is specified:

                  <u>{http,</u> <u>timeout()}</u>:
                    Enables fetching of CRLs specified as http URIs inX509 certificate extensions. Requires  the
                    OTP inets application.

                <u>ssl_crl_hash_dir</u>:
                  This  module  makes use of a directory where CRLs are stored in files named by the hash of the
                  issuer name.

                  The file names consist of eight hexadecimal digits followed by <u>.rN</u>, where  <u>N</u>  is  an  integer,
                  e.g.  <u>1a2b3c4d.r0</u>.  For  the  first  version  of  the  CRL, <u>N</u> starts at zero, and for each new
                  version, <u>N</u> is incremented by one. The OpenSSL utility <u>c_rehash</u> creates symlinks  according  to
                  this pattern.

                  For  a  given  hash value, this module finds all consecutive <u>.r*</u> files starting from zero, and
                  those files taken together make up the revocation list. CRL files whose <u>nextUpdate</u> fields  are
                  in the past, or that are issued by a different CA that happens to have the same name hash, are
                  excluded.

                  The following argument is required:

                  <u>{dir,</u> <u>string()}</u>:
                    Specifies the directory in which the CRLs can be found.

       <b>root_fun()</b> = function()

              fun(Chain::[public_key:der_encoded()]) -&gt;
                   {trusted_ca, DerCert::public_key:der_encoded()} | unknown_ca}

              Claim    an    intermediate    CA    in    the    chain    as    trusted.    TLS   then   performs
              public_key:pkix_path_validation/3 with the selected CA as trusted  anchor  and  the  rest  of  the
              chain.

       <b>protocol_versions()</b> = [protocol_version()]

              TLS  protocol  versions  supported  by  started  clients  and  servers.  This option overrides the
              application environment option <u>protocol_version</u>  and  <u>dtls_protocol_version</u>.  If  the  environment
              option is not set, it defaults to all versions, supported by the SSL application. See also <a href="../man7/ssl.7.html">ssl</a>(7).

       <b>custom_user_lookup()</b> =
           {Lookupfun :: function(), UserState :: any()}

              The lookup fun is to defined as follows:

              fun(psk, PSKIdentity :: binary(), UserState :: term()) -&gt;
                   {ok, SharedSecret :: binary()} | error;
              fun(srp, Username :: binary(), UserState :: term()) -&gt;
                   {ok, {SRPParams :: srp_param_type(), Salt :: binary(),
                         DerivedKey :: binary()}} | error.

              For  Pre-Shared  Key  (PSK)  cipher  suites,  the lookup fun is called by the client and server to
              determine the shared secret. When called by the client, <u>PSKIdentity</u> is set to the  hint  presented
              by the server or to undefined. When called by the server, <u>PSKIdentity</u> is the identity presented by
              the client.

              For  Secure Remote Password (SRP), the fun is only used by the server to obtain parameters that it
              uses to generate its session keys. <u>DerivedKey</u> is to be derived according to   RFC  2945  and   RFC
              5054: <u>crypto:sha([Salt,</u> <u>crypto:sha([Username,</u> <u>&lt;&lt;$:&gt;&gt;,</u> <u>Password])])</u>

       <b>session_id()</b> = binary()

              Identifies a TLS session.

       <b>log_alert()</b> = boolean()

              If  set  to <u>false</u>, TLS/DTLS Alert reports are not displayed. Deprecated in OTP 22, use {log_level,
              logging_level()} instead.

       <b>logging_level()</b> = logger:level() | none | all

              Specifies the log level for a TLS/DTLS connection. Alerts are logged on <u>notice</u> level, which is the
              default level. The level <u>debug</u> triggers verbose logging of TLS/DTLS protocol  messages.  See  also
              <a href="../man7/ssl.7.html">ssl</a>(7)

       <b>hibernate_after()</b> = timeout()

              When  an integer-value is specified, <u>TLS/DTLS-connection</u> goes into hibernation after the specified
              number of milliseconds of inactivity, thus  reducing  its  memory  footprint.  When  <u>undefined</u>  is
              specified (this is the default), the process never goes into hibernation.

       <b>handshake_size()</b> = integer()

              Integer  (24  bits  unsigned).  Used to limit the size of valid TLS handshake packets to avoid DoS
              attacks. Defaults to 256*1024.

       <b>padding_check()</b> = boolean()

              Affects TLS-1.0 connections only. If set to <u>false</u>, it disables the block cipher padding  check  to
              be able to interoperate with legacy software.

          <b>Warning:</b>
              Using <u>{padding_check,</u> <u>boolean()}</u> makes TLS vulnerable to the Poodle attack.

       <b>beast_mitigation()</b> = one_n_minus_one | zero_n | disabled

              Affects  TLS-1.0  connections  only.  Used to change the BEAST mitigation strategy to interoperate
              with legacy software. Defaults to <u>one_n_minus_one</u>.

              <u>one_n_minus_one</u> - Perform 1/n-1 BEAST mitigation.

              <u>zero_n</u> - Perform 0/n BEAST mitigation.

              <u>disabled</u> - Disable BEAST mitigation.

          <b>Warning:</b>
              Using <u>{beast_mitigation,</u> <u>disabled}</u> makes TLS-1.0 vulnerable to the BEAST attack.

       <b>ssl_imp()</b> = new | old

              Deprecated since OTP-17, has no effect.

       <b>session_tickets()</b> =
           client_session_tickets() | server_session_tickets()

              Configures the session ticket functionalty in TLS 1.3 client and server.

       <b>key_update_at()</b> = integer() &gt;= 1

              Configures the maximum amount of bytes that can  be  sent  on  a  TLS  1.3  connection  before  an
              automatic key update is performed.

              There  are  cryptographic  limits on the amount of plaintext which can be safely encrypted under a
              given set of keys. The current default ensures that data  integrity  will  not  be  breached  with
              probability  greater  than 1/2^57. For more information see Limits on Authenticated Encryption Use
              in TLS.

          <b>Warning:</b>
              The default value of this option shall provide the above  mentioned  security  guarantees  and  it
              shall be reasonable for most applications (~353 TB).

       <b>middlebox_comp_mode()</b> = boolean()

              Configures the middlebox compatibility mode on a TLS 1.3 connection.

              A  significant  number  of  middleboxes  misbehave  when  a  TLS  1.3  connection  is  negotiated.
              Implementations can increase the chance of making connections through those middleboxes by  making
              the TLS 1.3 handshake more like a TLS 1.2 handshake.

              The middlebox compatibility mode is enabled (<u>true</u>) by default.

       <b>keep_secrets()</b> = boolean()

              Configures a TLS 1.3 connection for keylogging

              In  order to retrieve keylog information on a TLS 1.3 connection, it must be configured in advance
              to keep the client_random and various handshake secrets.

              The keep_secrets functionality is disabled (<u>false</u>) by default.

              Added in OTP 23.2

   <b>TLS/DTLS</b> <b>OPTION</b> <b>DESCRIPTIONS</b> <b>-</b> <b>CLIENT</b>
       <b>client_option()</b> =
           {verify, client_verify_type()} |
           {reuse_session, client_reuse_session()} |
           {reuse_sessions, client_reuse_sessions()} |
           {cacerts, client_cacerts()} |
           {cacertfile, client_cafile()} |
           {alpn_advertised_protocols, client_alpn()} |
           {client_preferred_next_protocols,
            client_preferred_next_protocols()} |
           {psk_identity, client_psk_identity()} |
           {srp_identity, client_srp_identity()} |
           {server_name_indication, sni()} |
           {max_fragment_length, max_fragment_length()} |
           {customize_hostname_check, customize_hostname_check()} |
           {fallback, fallback()} |
           {session_tickets, client_session_tickets()} |
           {use_ticket, use_ticket()} |
           {early_data, client_early_data()}

       <b>client_verify_type()</b> = verify_type()

              In mode <u>verify_none</u> the default behavior is to allow all x509-path  validation  errors.  See  also
              option verify_fun.

       <b>client_reuse_session()</b> =
           session_id() | {session_id(), SessionData :: binary()}

              Reuses  a specific session. The session should be refered by its session id if it is earlier saved
              with the option <u>{reuse_sessions,</u> <u>save}</u> since OTP-21.3 or explicitly specified by  its  session  id
              and associated data since OTP-22.3. See also  SSL's Users Guide, Session Reuse pre TLS 1.3

       <b>client_reuse_sessions()</b> = boolean() | save

              When  <u>save</u> is specified a new connection will be negotiated and saved for later reuse. The session
              ID can be fetched with connection_information/2 and used with the client option reuse_session  The
              boolean  value  true specifies that if possible, automatized session reuse will be performed. If a
              new session is created, and is unique in regard to previous stored sessions, it will be saved  for
              possible later reuse. Since OTP-21.3

       <b>client_cacerts()</b> = [public_key:der_encoded()]

              The DER-encoded trusted certificates. If this option is supplied it overrides option <u>cacertfile</u>.

       <b>client_cafile()</b> = file:filename()

              Path  to a file containing PEM-encoded CA certificates. The CA certificates are used during server
              authentication and when building the client certificate chain.

       <b>client_alpn()</b> = [app_level_protocol()]

              The list of protocols supported by the client to  be  sent  to  the  server  to  be  used  for  an
              Application-Layer  Protocol  Negotiation (ALPN). If the server supports ALPN then it will choose a
              protocol from this list; otherwise it will fail the connection  with  a  "no_application_protocol"
              alert. A server that does not support ALPN will ignore this value.

              The list of protocols must not contain an empty binary.

              The negotiated protocol can be retrieved using the <u>negotiated_protocol/1</u> function.

       <b>client_preferred_next_protocols()</b> =
           {Precedence :: server | client,
            ClientPrefs :: [app_level_protocol()]} |
           {Precedence :: server | client,
            ClientPrefs :: [app_level_protocol()],
            Default :: app_level_protocol()}

              Indicates that the client is to try to perform Next Protocol Negotiation.

              If  precedence  is server, the negotiated protocol is the first protocol to be shown on the server
              advertised list, which is also on the client preference list.

              If precedence is client, the negotiated protocol is the first protocol to be shown on  the  client
              preference list, which is also on the server advertised list.

              If  the  client  does  not  support  any of the server advertised protocols or the server does not
              advertise any protocols, the client falls back to the first protocol in its list or to the default
              protocol (if a default is supplied). If the server does not support Next Protocol Negotiation, the
              connection terminates if no default protocol is supplied.

       <b>max_fragment_length()</b> = undefined | 512 | 1024 | 2048 | 4096

              Specifies the maximum fragment length the client is prepared to accept from the  server.  See  RFC
              6066

       <b>client_psk_identity()</b> = psk_identity()

              Specifies  the identity the client presents to the server. The matching secret is found by calling
              <u>user_lookup_fun</u>

       <b>client_srp_identity()</b> = srp_identity()

              Specifies the username and password to use to authenticate to the server.

       <b>sni()</b> = hostname() | disable

              Specify the hostname to be used in TLS Server Name Indication extension. If not specified it  will
              default to the <u>Host</u> argument of connect/[3,4] unless it is of type inet:ipaddress().

              The  <u>HostName</u>  will  also  be  used  in  the  hostname  verification of the peer certificate using
              public_key:pkix_verify_hostname/2.

              The special value <u>disable</u> prevents the Server  Name  Indication  extension  from  being  sent  and
              disables the hostname verification check public_key:pkix_verify_hostname/2

       <b>customize_hostname_check()</b> = list()

              Customizes  the hostname verification of the peer certificate, as different protocols that use TLS
              such  as  HTTP  or  LDAP  may  want   to   do   it   differently,   for   possible   options   see
              public_key:pkix_verify_hostname/3

       <b>fallback()</b> = boolean()

              Send  special cipher suite TLS_FALLBACK_SCSV to avoid undesired TLS version downgrade. Defaults to
              false

          <b>Warning:</b>
              Note this option is not needed in normal TLS usage  and  should  not  be  used  to  implement  new
              clients. But legacy clients that retries connections in the following manner

               <u>ssl:connect(Host,</u> <u>Port,</u> <u>[...{versions,</u> <u>['tlsv2',</u> <u>'tlsv1.1',</u> <u>'tlsv1']}])</u>

               <u>ssl:connect(Host,</u> <u>Port,</u> <u>[...{versions,</u> <u>[tlsv1.1',</u> <u>'tlsv1']},</u> <u>{fallback,</u> <u>true}])</u>

               <u>ssl:connect(Host,</u> <u>Port,</u> <u>[...{versions,</u> <u>['tlsv1']},</u> <u>{fallback,</u> <u>true}])</u>

              may  use  it  to  avoid  undesired TLS version downgrade. Note that TLS_FALLBACK_SCSV must also be
              supported by the server for the prevention to work.

       <b>client_session_tickets()</b> = disabled | manual | auto

              Configures the session ticket functionality. Allowed values are <u>disabled</u>, <u>manual</u> and <u>auto</u>.  If  it
              is set to <u>manual</u> the client will send the ticket information to user process in a 3-tuple:

              <u>{ssl,</u> <u>session_ticket,</u> <u>{SNI,</u> <u>TicketData}}</u>

              where  <u>SNI</u> is the ServerNameIndication and <u>TicketData</u> is the extended ticket data that can be used
              in subsequent session resumptions.

              If it is set to <u>auto</u>, the client automatically handles received tickets and tries to use them when
              making new TLS connections (session resumption with pre-shared keys).

          <b>Note:</b>
              This option is supported by TLS 1.3 and above. See also  SSL's Users Guide,  Session  Tickets  and
              Session Resumption in TLS 1.3

       <b>use_ticket()</b> = [binary()]

              Configures  the  session  tickets  to  be used for session resumption. It is a mandatory option in
              <u>manual</u> mode (<u>session_tickets</u> <u>=</u> <u>manual</u>).

          <b>Note:</b>
              Session tickets are only sent to user if option <u>session_tickets</u> is set to <u>manual</u>

              This option is supported by TLS 1.3 and above. See also  SSL's Users Guide,  Session  Tickets  and
              Session Resumption in TLS 1.3

       <b>client_early_data()</b> = binary()

              Configures the early data to be sent by the client.

              In  order  to  be  able to verify that the server has the intention to process the early data, the
              following 3-tuple is sent to the user process:

              <u>{ssl,</u> <u>SslSocket,</u> <u>{early_data,</u> <u>Result}}</u>

              where <u>Result</u> is either <u>accepted</u> or <u>rejected</u>.

          <b>Warning:</b>
              It is the responsibility of the user to handle a rejected Early Data and  to  resend  when  it  is
              appropriate.

   <b>TLS/DTLS</b> <b>OPTION</b> <b>DESCRIPTIONS</b> <b>-</b> <b>SERVER</b>
       <b>server_option()</b> =
           {cacerts, server_cacerts()} |
           {cacertfile, server_cafile()} |
           {dh, dh_der()} |
           {dhfile, dh_file()} |
           {verify, server_verify_type()} |
           {fail_if_no_peer_cert, fail_if_no_peer_cert()} |
           {reuse_sessions, server_reuse_sessions()} |
           {reuse_session, server_reuse_session()} |
           {alpn_preferred_protocols, server_alpn()} |
           {next_protocols_advertised, server_next_protocol()} |
           {psk_identity, server_psk_identity()} |
           {sni_hosts, sni_hosts()} |
           {sni_fun, sni_fun()} |
           {honor_cipher_order, honor_cipher_order()} |
           {honor_ecc_order, honor_ecc_order()} |
           {client_renegotiation, client_renegotiation()} |
           {session_tickets, server_session_tickets()} |
           {anti_replay, anti_replay()} |
           {cookie, cookie()} |
           {early_data, server_early_data()}

       <b>server_cacerts()</b> = [public_key:der_encoded()]

              The DER-encoded trusted certificates. If this option is supplied it overrides option <u>cacertfile</u>.

       <b>server_cafile()</b> = file:filename()

              Path  to  a file containing PEM-encoded CA certificates. The CA certificates are used to build the
              server certificate chain and for client authentication. The CAs are  also  used  in  the  list  of
              acceptable  client  CAs  passed  to  the client when a certificate is requested. Can be omitted if
              there is no need to verify the client and  if  there  are  no  intermediate  CAs  for  the  server
              certificate.

       <b>dh_der()</b> = binary()

              The DER-encoded Diffie-Hellman parameters. If specified, it overrides option <u>dhfile</u>.

          <b>Warning:</b>
              The <u>dh_der</u> option is not supported by TLS 1.3. Use the <u>supported_groups</u> option instead.

       <b>dh_file()</b> = file:filename()

              Path  to  a  file  containing  PEM-encoded Diffie Hellman parameters to be used by the server if a
              cipher suite using Diffie Hellman key exchange is negotiated. If not specified, default parameters
              are used.

          <b>Warning:</b>
              The <u>dh_file</u> option is not supported by TLS 1.3. Use the <u>supported_groups</u> option instead.

       <b>server_verify_type()</b> = verify_type()

              A server only does x509-path validation in mode  <u>verify_peer</u>,  as  it  then  sends  a  certificate
              request to the client (this message is not sent if the verify option is <u>verify_none</u>). You can then
              also want to specify option <u>fail_if_no_peer_cert</u>.

       <b>fail_if_no_peer_cert()</b> = boolean()

              Used  together  with <u>{verify,</u> <u>verify_peer}</u> by an TLS/DTLS server. If set to <u>true</u>, the server fails
              if the client does not have a certificate to send, that is, sends an empty certificate. If set  to
              <u>false</u>,  it  fails  only  if  the  client  sends  an  invalid  certificate (an empty certificate is
              considered valid). Defaults to false.

       <b>server_reuse_sessions()</b> = boolean()

              The boolean value true specifies that the server will agree to reuse sessions. Setting it to false
              will result in an empty session table, that is  no  sessions  will  be  reused.  See  also  option
              reuse_session

       <b>server_reuse_session()</b> = function()

              Enables  the  TLS/DTLS  server to have a local policy for deciding if a session is to be reused or
              not. Meaningful only if <u>reuse_sessions</u> is set to <u>true</u>. <u>SuggestedSessionId</u> is a <u>binary()</u>,  <u>PeerCert</u>
              is  a  DER-encoded  certificate, <u>Compression</u> is an enumeration integer, and <u>CipherSuite</u> is of type
              <u>ciphersuite()</u>.

       <b>server_alpn()</b> = [app_level_protocol()]

              Indicates the server will try to perform Application-Layer Protocol Negotiation (ALPN).

              The list of protocols is in order of preference. The protocol negotiated will be the first in  the
              list  that  matches  one  of  the  protocols advertised by the client. If no protocol matches, the
              server will fail the connection with a "no_application_protocol" alert.

              The negotiated protocol can be retrieved using the <u>negotiated_protocol/1</u> function.

       <b>server_next_protocol()</b> = [app_level_protocol()]

              List of protocols to send to the client if the client indicates that it supports the Next Protocol
              extension. The client can select a protocol that is not on this list. The list of  protocols  must
              not  contain  an  empty binary. If the server negotiates a Next Protocol, it can be accessed using
              the <u>negotiated_next_protocol/1</u> method.

       <b>server_psk_identity()</b> = psk_identity()

              Specifies the server identity hint, which the server presents to the client.

       <b>honor_cipher_order()</b> = boolean()

              If set to <u>true</u>, use the server preference for cipher selection. If set to <u>false</u> (the default), use
              the client preference.

       <b>sni_hosts()</b> =
           [{hostname(), [server_option() | common_option()]}]

              If the server receives a SNI (Server Name Indication) from the client matching a  host  listed  in
              the  <u>sni_hosts</u>  option,  the  specific  options  for  that host will override previously specified
              options. The option <u>sni_fun</u>, and <u>sni_hosts</u> are mutually exclusive.

       <b>sni_fun()</b> = function()

              If the server receives a SNI (Server Name Indication) from the client, the given function will  be
              called  to retrieve [server_option()]  for the indicated server. These options will be merged into
              predefined [server_option()]  list. The function should be defined as: fun(ServerName :: string())
              -&gt; [server_option()]  and can be specified as a fun or as named <u>fun</u> <u>module:function/1</u>  The  option
              <u>sni_fun</u>, and <u>sni_hosts</u> are mutually exclusive.

       <b>client_renegotiation()</b> = boolean()

              In  protocols  that  support  client-initiated  renegotiation,  the  cost  of resources of such an
              operation is higher for the server than the client. This can act as a vector for denial of service
              attacks. The SSL application already takes measures to  counter-act  such  attempts,  but  client-
              initiated  renegotiation  can  be  strictly  disabled by setting this option to <u>false</u>. The default
              value is <u>true</u>. Note that disabling renegotiation can result  in  long-lived  connections  becoming
              unusable due to limits on the number of messages the underlying cipher suite can encipher.

       <b>honor_cipher_order()</b> = boolean()

              If  true,  use  the  server's  preference  for  cipher  selection. If false (the default), use the
              client's preference.

       <b>honor_ecc_order()</b> = boolean()

              If true, use the server's preference for ECC curve selection. If  false  (the  default),  use  the
              client's preference.

       <b>server_session_tickets()</b> = disabled | stateful | stateless

              Configures the session ticket functionality. Allowed values are <u>disabled</u>, <u>stateful</u> and <u>stateless</u>.

              If  it is set to <u>stateful</u> or <u>stateless</u>, session resumption with pre-shared keys is enabled and the
              server will send stateful or stateless session tickets to the client after successful connections.

              A stateful session ticket is a database reference  to  internal  state  information.  A  stateless
              session  ticket  is  a  self-encrypted binary that contains both cryptographic keying material and
              state data.

          <b>Note:</b>
              This option is supported by TLS 1.3 and above. See also  SSL's Users Guide,  Session  Tickets  and
              Session Resumption in TLS 1.3

       <b>anti_replay()</b> =
           '10k' | '100k' |
           {bloom_filter_window_size(),
            bloom_filter_hash_functions(),
            bloom_filter_bits()}

              Configures the server's built-in anti replay feature based on Bloom filters.

              Allowed  values  are the pre-defined <u>'10k'</u>, <u>'100k'</u> or a custom 3-tuple that defines the properties
              of the bloom filters: <u>{WindowSize,</u> <u>HashFunctions,</u> <u>Bits}</u>. <u>WindowSize</u> is the number of seconds after
              the current Bloom filter  is  rotated  and  also  the  window  size  used  for  freshness  checks.
              <u>HashFunctions</u> is the number hash functions and <u>Bits</u> is the number of bits in the bit vector. <u>'10k'</u>
              and <u>'100k'</u> are simple defaults with the following properties:

                * <u>'10k'</u>:  Bloom  filters  can  hold  10000  elements  with  3%  probability  of false positives.
                  <u>WindowSize</u>: 10, <u>HashFunctions</u>: 5, <u>Bits:</u> 72985 (8.91 KiB).

                * <u>'100k'</u>: Bloom filters can hold  100000  elements  with  3%  probability  of  false  positives.
                  <u>WindowSize</u>: 10, <u>HashFunctions</u>: 5, <u>Bits</u>: 729845 (89.09 KiB).

          <b>Note:</b>
              This  option  is  supported  by  TLS 1.3 and above and only with stateless session tickets. Ticket
              lifetime, the number of tickets sent by the server and the maximum number of tickets stored by the
              server in stateful mode are configured by application variables.  See  also   SSL's  Users  Guide,
              Anti-Replay Protection in TLS 1.3

       <b>cookie()</b> = boolean()

              If <u>true</u> (default), the server sends a cookie extension in its HelloRetryRequest messages.

          <b>Note:</b>
              The  cookie  extension  has  two  main  purposes.  It  allows  the  server  to force the client to
              demonstrate reachability at their apparent network  address  (thus  providing  a  measure  of  DoS
              protection).  This  is  primarily useful for non-connection-oriented transports. It also allows to
              offload the server's state to the client. The cookie extension is enabled by default as  it  is  a
              mandatory extension in RFC8446.

       <b>server_early_data()</b> = disabled | enabled

              Configures  if  the server accepts (<u>enabled</u>) or rejects (<u>rejects</u>) early data sent by a client. The
              default value is <u>disabled</u>.

          <b>Warning:</b>
              This option is a placeholder, early data is not yet implemented on the server side.

       <b>connection_info()</b> =
           [common_info() |
            curve_info() |
            ssl_options_info() |
            security_info()]

       <b>common_info()</b> =
           {protocol, protocol_version()} |
           {session_id, session_id()} |
           {session_resumption, boolean()} |
           {selected_cipher_suite, erl_cipher_suite()} |
           {sni_hostname, term()} |
           {srp_username, term()}

       <b>curve_info()</b> = {ecc, {named_curve, term()}}

       <b>ssl_options_info()</b> = tls_option()

       <b>security_info()</b> =
           {client_random, binary()} |
           {server_random, binary()} |
           {master_secret, binary()}

       <b>connection_info_items()</b> = [connection_info_item()]

       <b>connection_info_item()</b> =
           protocol | session_id | session_resumption |
           selected_cipher_suite | sni_hostname | srp_username | ecc |
           client_random | server_random | master_secret | keylog |
           tls_options_name()

       <b>tls_options_name()</b> = atom()

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>append_cipher_suites(Deferred,</b> <b>Suites)</b> <b>-&gt;</b> <b>ciphers()</b>

              Types:

                 Deferred = ciphers() | cipher_filters()
                 Suites = ciphers()

              Make <u>Deferred</u> suites become the least preferred suites, that is put them at the end of the  cipher
              suite  list  <u>Suites</u>  after  removing them from <u>Suites</u> if present. <u>Deferred</u> may be a list of cipher
              suites or a list of filters in which case the filters are use on <u>Suites</u> to  extract  the  Deferred
              cipher list.

       <b>cipher_suites(Description,</b> <b>Version)</b> <b>-&gt;</b> <b>ciphers()</b>

              Types:

                 Description =
                     default | all | exclusive | anonymous | exclusive_anonymous
                 Version = protocol_version()

              Lists  all  possible  cipher suites corresponding to <u>Description</u> that are available. The <u>exclusive</u>
              and <u>exclusive_anonymous</u> option will exclusively list cipher  suites  first  supported  in  <u>Version</u>
              whereas  the  other  options  are  inclusive  from the lowest possible version to <u>Version</u>. The <u>all</u>
              options includes all suites except the anonymous and no anonymous suites are supported by default.

          <b>Note:</b>
              TLS-1.3 has no overlapping cipher suites with  previous  TLS  versions,  that  is  the  result  of
              <u>cipher_suites(all,</u>  <u>'tlsv1.3').</u> contains a separate set of suites that can be used with TLS-1.3 an
              other set that can be used if a lower version is negotiated. PRE TLS-1.3 so  called  <u>PSK</u>  and  <u>SRP</u>
              suites  need  extra  configuration  to  work  see  user  lookup  function. No anonymous suites are
              supported by TLS-1.3.

              Also note that the cipher suites returned by this function are the cipher suites that the OTP  ssl
              application  can  support  provided  that  they are supported by the cryptolib linked with the OTP
              crypto application. Use  ssl:filter_cipher_suites(Suites, []). to filter the list for the  current
              cryptolib.  Note  that  cipher  suites  may  be  filtered  out because they are too old or too new
              depending on the cryptolib

       <b>cipher_suites(Description,</b> <b>Version,</b> <b>StringType</b> <b>::</b> <b>rfc</b> <b>|</b> <b>openssl)</b> <b>-&gt;</b>
                        [string()]

              Types:

                 Description = default | all | exclusive | anonymous
                 Version = protocol_version()

              Same as cipher_suites/2 but lists RFC or OpenSSL string names instead of erl_cipher_suite()

       <b>eccs()</b> <b>-&gt;</b> <b>NamedCurves</b>

       <b>eccs(Version)</b> <b>-&gt;</b> <b>NamedCurves</b>

              Types:

                 Version = protocol_version()
                 NamedCurves = [named_curve()]

              Returns a list of supported  ECCs.  <u>eccs()</u>  is  equivalent  to  calling  <u>eccs(Protocol)</u>  with  all
              supported protocols and then deduplicating the output.

       <b>clear_pem_cache()</b> <b>-&gt;</b> <b>ok</b>

              PEM  files,  used  by  ssl API-functions, are cached. The cache is regularly checked to see if any
              cache entries should be invalidated, however this function provides a way to unconditionally clear
              the whole cache.

       <b>connect(TCPSocket,</b> <b>TLSOptions)</b> <b>-&gt;</b>
                  {ok, sslsocket()} |
                  {error, reason()} |
                  {option_not_a_key_value_tuple, any()}

       <b>connect(TCPSocket,</b> <b>TLSOptions,</b> <b>Timeout)</b> <b>-&gt;</b>
                  {ok, sslsocket()} | {error, reason()}

              Types:

                 TCPSocket = socket()
                 TLSOptions = [tls_client_option()]
                 Timeout = timeout()

              Upgrades a <u>gen_tcp</u>, or equivalent, connected socket to a TLS socket, that is, performs the client-
              side TLS handshake.

          <b>Note:</b>
              If the option <u>verify</u> is set  to  <u>verify_peer</u>  the  option  <u>server_name_indication</u>  shall  also  be
              specified,   if   it   is   not   no   Server   Name   Indication  extension  will  be  sent,  and
              public_key:pkix_verify_hostname/2 will  be  called  with  the  IP-address  of  the  connection  as
              <u>ReferenceID</u>, which is probably not what you want.

              If  the option <u>{handshake,</u> <u>hello}</u> is used the handshake is paused after receiving the server hello
              message and the success response is <u>{ok,</u> <u>SslSocket,</u> <u>Ext}</u> instead of  <u>{ok,</u>  <u>SslSocket}</u>.  Thereafter
              the handshake is continued or canceled by calling <u>handshake_continue/3</u> or <u>handshake_cancel/1</u>.

              If  the  option  <u>active</u> is set to <u>once</u>, <u>true</u> or an integer value, the process owning the sslsocket
              will receive messages of type  active_msgs()

       <b>connect(Host,</b> <b>Port,</b> <b>TLSOptions)</b> <b>-&gt;</b>
                  {ok, sslsocket()} |
                  {ok, sslsocket(), Ext :: protocol_extensions()} |
                  {error, reason()} |
                  {option_not_a_key_value_tuple, any()}

       <b>connect(Host,</b> <b>Port,</b> <b>TLSOptions,</b> <b>Timeout)</b> <b>-&gt;</b>
                  {ok, sslsocket()} |
                  {ok, sslsocket(), Ext :: protocol_extensions()} |
                  {error, reason()} |
                  {option_not_a_key_value_tuple, any()}

              Types:

                 Host = host()
                 Port = inet:port_number()
                 TLSOptions = [tls_client_option()]
                 Timeout = timeout()

              Opens a TLS/DTLS connection to <u>Host</u>, <u>Port</u>.

              When the option <u>verify</u> is set to <u>verify_peer</u> the check public_key:pkix_verify_hostname/2  will  be
              performed  in  addition  to  the  usual  x509-path validation checks. If the check fails the error
              {bad_cert, hostname_check_failed} will be propagated to the path validation fun verify_fun,  where
              it   is   possible   to   do   customized   checks   by   using  the  full  possibilities  of  the
              public_key:pkix_verify_hostname/3 API. When the option  <u>server_name_indication</u>  is  provided,  its
              value  (the  DNS  name)  will be used as <u>ReferenceID</u> to public_key:pkix_verify_hostname/2. When no
              <u>server_name_indication</u> option is given, the <u>Host</u> argument will be used as Server  Name  Indication
              extension. The <u>Host</u> argument will also be used for the public_key:pkix_verify_hostname/2 check and
              if the <u>Host</u> argument is an <u>inet:ip_address()</u> the <u>ReferenceID</u> used for the check will be <u>{ip,</u> <u>Host}</u>
              otherwise <u>dns_id</u> will be assumed with a fallback to <u>ip</u> if that fails.

          <b>Note:</b>
              According  to  good practices certificates should not use IP-addresses as "server names". It would
              be very surprising if this happen outside a closed network.

              If the option <u>{handshake,</u> <u>hello}</u> is used the handshake is paused after receiving the server  hello
              message  and  the  success response is <u>{ok,</u> <u>SslSocket,</u> <u>Ext}</u> instead of <u>{ok,</u> <u>SslSocket}</u>. Thereafter
              the handshake is continued or canceled by calling <u>handshake_continue/3</u> or <u>handshake_cancel/1</u>.

              If the option <u>active</u> is set to <u>once</u>, <u>true</u> or an integer value, the process  owning  the  sslsocket
              will receive messages of type  active_msgs()

       <b>close(SslSocket)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SslSocket = sslsocket()
                 Reason = any()

              Closes a TLS/DTLS connection.

       <b>close(SslSocket,</b> <b>How)</b> <b>-&gt;</b>
                ok | {ok, port()} | {ok, port(), Data} | {error, Reason}

              Types:

                 SslSocket = sslsocket()
                 How = timeout() | {NewController :: pid(), timeout()}
                 Data = binary()
                 Reason = any()

              Closes  or downgrades a TLS connection. In the latter case the transport connection will be handed
              over to the <u>NewController</u> process after receiving the TLS close alert from the peer. The  returned
              transport  socket  will  have  the  following  options  set: <u>[{active,</u> <u>false},</u> <u>{packet,</u> <u>0},</u> <u>{mode,</u>
              <u>binary}]</u>.

              In case of downgrade, the close function might return some binary data that should be  treated  by
              the user as the first bytes received on the downgraded connection.

       <b>controlling_process(SslSocket,</b> <b>NewOwner)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SslSocket = sslsocket()
                 NewOwner = pid()
                 Reason = any()

              Assigns  a new controlling process to the SSL socket. A controlling process is the owner of an SSL
              socket, and receives all messages from the socket.

       <b>connection_information(SslSocket)</b> <b>-&gt;</b>
                                 {ok, Result} | {error, reason()}

              Types:

                 SslSocket = sslsocket()
                 Result = connection_info()

              Returns the most relevant information about the connection, ssl options that are undefined will be
              filtered out. Note that values that affect the security of the connection will only be returned if
              explicitly requested by connection_information/2.

          <b>Note:</b>
              The legacy <u>Item</u> <u>=</u> <u>cipher_suite</u> was removed in OTP-23. Previously it returned the cipher  suite  on
              its (undocumented) legacy format. It is replaced by <u>selected_cipher_suite</u>.

       <b>connection_information(SslSocket,</b> <b>Items)</b> <b>-&gt;</b>
                                 {ok, Result} | {error, reason()}

              Types:

                 SslSocket = sslsocket()
                 Items = connection_info_items()
                 Result = connection_info()

              Returns the requested information items about the connection, if they are defined.

              Note  that  client_random,  server_random,  master_secret  and  keylog  are values that affect the
              security of connection. Meaningful atoms, not specified above, are the ssl option names.

              In order to retrieve keylog and other secret information from a TLS 1.3  connection,  keep_secrets
              must be configured in advance and set to <u>true</u>.

          <b>Note:</b>
              If only undefined options are requested the resulting list can be empty.

       <b>filter_cipher_suites(Suites,</b> <b>Filters)</b> <b>-&gt;</b> <b>Ciphers</b>

              Types:

                 Suites = ciphers()
                 Filters = cipher_filters()
                 Ciphers = ciphers()

              Removes  cipher  suites  if  any  of the filter functions returns false for any part of the cipher
              suite. If no filter function is supplied for some part the default  behaviour  regards  it  as  if
              there  was  a  filter  function  that  returned  true. For examples see  Customizing cipher suites
              Additionaly this function also filters the cipher suites to exclude cipher suites not supported by
              the cryptolib used by the OTP crypto application. That is calling ssl:filter_cipher_suites(Suites,
              []) will be equivalent to only applying the filters for cryptolib support.

       <b>format_error(Reason</b> <b>::</b> <b>{error,</b> <b>Reason})</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Reason = any()

              Presents the error returned by an SSL function as a printable string.

       <b>getopts(SslSocket,</b> <b>OptionNames)</b> <b>-&gt;</b>
                  {ok, [gen_tcp:option()]} | {error, reason()}

              Types:

                 SslSocket = sslsocket()
                 OptionNames = [gen_tcp:option_name()]

              Gets the values of the specified socket options.

       <b>getstat(SslSocket)</b> <b>-&gt;</b> <b>{ok,</b> <b>OptionValues}</b> <b>|</b> <b>{error,</b> <b>inet:posix()}</b>

       <b>getstat(SslSocket,</b> <b>Options)</b> <b>-&gt;</b>
                  {ok, OptionValues} | {error, inet:posix()}

              Types:

                 SslSocket = sslsocket()
                 Options = [inet:stat_option()]
                 OptionValues = [{inet:stat_option(), integer()}]

              Gets one or more statistic options for the underlying TCP socket.

              See inet:getstat/2 for statistic options description.

       <b>handshake(HsSocket)</b> <b>-&gt;</b>
                    {ok, SslSocket} |
                    {ok, SslSocket, Ext} |
                    {error, Reason}

       <b>handshake(HsSocket,</b> <b>Timeout)</b> <b>-&gt;</b>
                    {ok, SslSocket} |
                    {ok, SslSocket, Ext} |
                    {error, Reason}

              Types:

                 HsSocket = sslsocket()
                 Timeout = timeout()
                 SslSocket = sslsocket()
                 Ext = protocol_extensions()
                 Reason = closed | timeout | error_alert()

              Performs the TLS/DTLS server-side handshake.

              Returns a new TLS/DTLS socket if the handshake is successful.

              If the option <u>active</u> is set to <u>once</u>, <u>true</u> or an integer value, the process  owning  the  sslsocket
              will receive messages of type  active_msgs()

       <b>handshake(Socket,</b> <b>Options)</b> <b>-&gt;</b>
                    {ok, SslSocket} |
                    {ok, SslSocket, Ext} |
                    {error, Reason}

       <b>handshake(Socket,</b> <b>Options,</b> <b>Timeout)</b> <b>-&gt;</b>
                    {ok, SslSocket} |
                    {ok, SslSocket, Ext} |
                    {error, Reason}

              Types:

                 Socket = socket() | sslsocket()
                 SslSocket = sslsocket()
                 Options = [server_option()]
                 Timeout = timeout()
                 Ext = protocol_extensions()
                 Reason = closed | timeout | {options, any()} | error_alert()

              If <u>Socket</u> is a ordinary <u>socket()</u>: upgrades a <u>gen_tcp</u>, or equivalent, socket to an SSL socket, that
              is, performs the TLS server-side handshake and returns a TLS socket.

          <b>Warning:</b>
              The  <u>Socket</u>  shall  be  in passive mode ({active, false}) before calling this function or else the
              behavior of this function is undefined.

              If <u>Socket</u> is an  sslsocket() : provides extra TLS/DTLS options to those specified in listen/2  and
              then  performs  the  TLS/DTLS  handshake.  Returns  a  new  TLS/DTLS  socket  if  the handshake is
              successful.

              If option <u>{handshake,</u> <u>hello}</u> is specified the handshake is paused after receiving the client hello
              message and the success response is <u>{ok,</u> <u>SslSocket,</u> <u>Ext}</u> instead of  <u>{ok,</u>  <u>SslSocket}</u>.  Thereafter
              the handshake is continued or canceled by calling <u>handshake_continue/3</u> or <u>handshake_cancel/1</u>.

              If  the  option  <u>active</u> is set to <u>once</u>, <u>true</u> or an integer value, the process owning the sslsocket
              will receive messages of type  active_msgs()

       <b>handshake_cancel(Sslsocket</b> <b>::</b> <b>#sslsocket{})</b> <b>-&gt;</b> <b>any()</b>

              Cancel the handshake with a fatal <u>USER_CANCELED</u> alert.

       <b>handshake_continue(HsSocket,</b> <b>Options)</b> <b>-&gt;</b>
                             {ok, SslSocket} | {error, Reason}

       <b>handshake_continue(HsSocket,</b> <b>Options,</b> <b>Timeout)</b> <b>-&gt;</b>
                             {ok, SslSocket} | {error, Reason}

              Types:

                 HsSocket = sslsocket()
                 Options = [tls_client_option() | tls_server_option()]
                 Timeout = timeout()
                 SslSocket = sslsocket()
                 Reason = closed | timeout | error_alert()

              Continue the TLS handshake possiby with new, additional or changed options.

       <b>listen(Port,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>ListenSocket}</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

              Types:

                 Port = inet:port_number()
                 Options = [tls_server_option()]
                 ListenSocket = sslsocket()

              Creates an SSL listen socket.

       <b>negotiated_protocol(SslSocket)</b> <b>-&gt;</b> <b>{ok,</b> <b>Protocol}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SslSocket = sslsocket()
                 Protocol = binary()
                 Reason = protocol_not_negotiated

              Returns the protocol negotiated through ALPN or NPN extensions.

       <b>peercert(SslSocket)</b> <b>-&gt;</b> <b>{ok,</b> <b>Cert}</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

              Types:

                 SslSocket = sslsocket()
                 Cert = public_key:der_encoded()

              The peer certificate is returned as a DER-encoded binary. The  certificate  can  be  decoded  with
              public_key:pkix_decode_cert/2  Suggested  further  reading about certificates is public_key User's
              Guide and ssl User's Guide

       <b>peername(SslSocket)</b> <b>-&gt;</b> <b>{ok,</b> <b>{Address,</b> <b>Port}}</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

              Types:

                 SslSocket = sslsocket()
                 Address = inet:ip_address()
                 Port = inet:port_number()

              Returns the address and port number of the peer.

       <b>prepend_cipher_suites(Preferred,</b> <b>Suites)</b> <b>-&gt;</b> <b>ciphers()</b>

              Types:

                 Preferred = ciphers() | cipher_filters()
                 Suites = ciphers()

              Make <u>Preferred</u> suites become the most preferred suites that is put them at the head of the  cipher
              suite  list  <u>Suites</u>  after removing them from <u>Suites</u> if present. <u>Preferred</u> may be a list of cipher
              suites or a list of filters in which case the filters are use on <u>Suites</u> to extract  the  preferred
              cipher list.

       <b>prf(SslSocket,</b> <b>Secret,</b> <b>Label,</b> <b>Seed,</b> <b>WantedLength)</b> <b>-&gt;</b>
              {ok, binary()} | {error, reason()}

              Types:

                 SslSocket = sslsocket()
                 Secret = binary() | master_secret
                 Label = binary()
                 Seed = [binary() | prf_random()]
                 WantedLength = integer() &gt;= 0

              Uses  the  Pseudo-Random Function (PRF) of a TLS session to generate extra key material. It either
              takes user-generated values for <u>Secret</u> and <u>Seed</u> or atoms directing it to use a specific value from
              the session security parameters.

       <b>recv(SslSocket,</b> <b>Length)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

       <b>recv(SslSocket,</b> <b>Length,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

              Types:

                 SslSocket = sslsocket()
                 Length = integer()
                 Data = binary() | list() | HttpPacket
                 Timeout = timeout()
                 HttpPacket = any()
                   See the description of <u>HttpPacket</u> in <u>erlang:decode_packet/3</u> in ERTS.

              Receives a packet from a socket in passive mode. A closed socket  is  indicated  by  return  value
              <u>{error,</u> <u>closed}</u>.

              Argument  <u>Length</u> is meaningful only when the socket is in mode <u>raw</u> and denotes the number of bytes
              to read. If <u>Length</u> = 0, all available bytes are returned. If <u>Length</u> &gt; 0, exactly <u>Length</u> bytes  are
              returned,  or  an  error;  possibly discarding less than <u>Length</u> bytes of data when the socket gets
              closed from the other side.

              Optional argument <u>Timeout</u> specifies a time-out in milliseconds. The default value is <u>infinity</u>.

       <b>renegotiate(SslSocket)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

              Types:

                 SslSocket = sslsocket()

              Initiates a new handshake. A notable return value is  <u>{error,</u>  <u>renegotiation_rejected}</u>  indicating
              that  the  peer  refused  to go through with the renegotiation, but the connection is still active
              using the previously negotiated session.

       <b>update_keys(SslSocket,</b> <b>Type)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

              Types:

                 SslSocket = sslsocket()
                 Type = write | read_write

              There are cryptographic limits on the amount of plaintext which can be safely  encrypted  under  a
              given  set  of keys. If the amount of data surpasses those limits, a key update is triggered and a
              new set of keys are installed. See also the option key_update_at.

              This function can be used to explicitly start a key update on a TLS 1.3 connection. There are  two
              types  of the key update: if <u>Type</u> is set to <u>write</u>, only the writing key is updated; if <u>Type</u> is set
              to <u>read_write</u>, both the reading and writing keys are updated.

       <b>send(SslSocket,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

              Types:

                 SslSocket = sslsocket()
                 Data = iodata()

              Writes <u>Data</u> to <u>SslSocket</u>.

              A notable return value is <u>{error,</u> <u>closed}</u> indicating that the socket is closed.

       <b>setopts(SslSocket,</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

              Types:

                 SslSocket = sslsocket()
                 Options = [gen_tcp:option()]

              Sets options according to <u>Options</u> for socket <u>SslSocket</u>.

       <b>shutdown(SslSocket,</b> <b>How)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

              Types:

                 SslSocket = sslsocket()
                 How = read | write | read_write

              Immediately closes a socket in one or two directions.

              <u>How</u> <u>==</u> <u>write</u> means closing the socket for writing, reading from it is still possible.

              To be able to handle that the peer has done a shutdown on the write side,  option  <u>{exit_on_close,</u>
              <u>false}</u> is useful.

       <b>sockname(SslSocket)</b> <b>-&gt;</b> <b>{ok,</b> <b>{Address,</b> <b>Port}}</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

              Types:

                 SslSocket = sslsocket()
                 Address = inet:ip_address()
                 Port = inet:port_number()

              Returns the local address and port number of socket <u>SslSocket</u>.

       <b>start()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>reason()}</b>

       <b>start(Type</b> <b>::</b> <b>permanent</b> <b>|</b> <b>transient</b> <b>|</b> <b>temporary)</b> <b>-&gt;</b>
                ok | {error, reason()}

              Starts the SSL application. Default type is <u>temporary</u>.

       <b>stop()</b> <b>-&gt;</b> <b>ok</b>

              Stops the SSL application.

       <b>str_to_suite(CipherSuiteName)</b> <b>-&gt;</b>
                       erl_cipher_suite() |
                       {error, {not_recognized, CipherSuiteName}}

              Types:

                 CipherSuiteName = string()

              Converts  an  RFC  or  OpenSSL name string to an erl_cipher_suite() Returns an error if the cipher
              suite is not supported or the name is not a valid cipher suite name.

       <b>suite_to_openssl_str(CipherSuite)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 CipherSuite = erl_cipher_suite()

              Converts erl_cipher_suite() to OpenSSL name string.

              PRE TLS-1.3 these names differ for RFC names

       <b>suite_to_str(CipherSuite)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 CipherSuite = erl_cipher_suite()

              Converts erl_cipher_suite() to RFC name string.

       <b>transport_accept(ListenSocket)</b> <b>-&gt;</b>
                           {ok, SslSocket} | {error, reason()}

       <b>transport_accept(ListenSocket,</b> <b>Timeout)</b> <b>-&gt;</b>
                           {ok, SslSocket} | {error, reason()}

              Types:

                 ListenSocket = sslsocket()
                 Timeout = timeout()
                 SslSocket = sslsocket()

              Accepts an incoming connection request on a listen socket. <u>ListenSocket</u> must be a socket  returned
              from   listen/2.  The socket returned is to be passed to  handshake/[2,3] to complete handshaking,
              that is, establishing the TLS/DTLS connection.

          <b>Warning:</b>
              Most API functions require that the TLS/DTLS connection is established to work as expected.

              The accepted socket inherits the options set for <u>ListenSocket</u> in  listen/2.

              The default value for <u>Timeout</u> is <u>infinity</u>. If <u>Timeout</u> is specified and no connection  is  accepted
              within the given time, <u>{error,</u> <u>timeout}</u> is returned.

       <b>versions()</b> <b>-&gt;</b> <b>[VersionInfo]</b>

              Types:

                 VersionInfo =
                     {ssl_app, string()} |
                     {supported | available | implemented, [tls_version()]} |
                     {supported_dtls | available_dtls | implemented_dtls,
                      [dtls_version()]}

              Lists  information,  mainly  concerning  TLS/DTLS  versions,  in runtime for debugging and testing
              purposes.

                <u>app_vsn</u>:
                  The application version of the SSL application.

                <u>supported</u>:
                  TLS versions supported with current application environment and crypto library  configuration.
                  Overridden  by  a  version option on  connect/[2,3,4],  listen/2, and handshake/[2,3]. For the
                  negotiated TLS version, see connection_information/1 .

                <u>supported_dtls</u>:
                  DTLS versions supported with current application environment and crypto library configuration.
                  Overridden by a version option on  connect/[2,3,4],  listen/2, and  handshake/[2,3].  For  the
                  negotiated DTLS version, see connection_information/1 .

                <u>available</u>:
                  All TLS versions supported with the linked crypto library.

                <u>available_dtls</u>:
                  All DTLS versions supported with the linked crypto library.

                <u>implemented</u>:
                  All  TLS  versions  supported  by the SSL application if linked with a crypto library with the
                  necessary support.

                <u>implemented_dtls</u>:
                  All DTLS versions supported by the SSL application if linked with a crypto  library  with  the
                  necessary support.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3erl/inet.3erl.html">inet</a>(3erl) and <a href="../man3erl/gen_tcp.3erl.html">gen_tcp</a>(3erl) <a href="../man3erl/gen_udp.3erl.html">gen_udp</a>(3erl)

Ericsson AB                                        ssl 10.6.1                                          <u><a href="../man3erl/ssl.3erl.html">ssl</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>