<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ct - Main user interface for the Common Test framework.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ct - Main user interface for the Common Test framework.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Main user interface for the <u>Common</u> <u>Test</u> framework.

       This  module  implements the command-line interface for running tests and basic functions for <u>Common</u> <u>Test</u>
       case issues, such as configuration and logging.

       <u>Test</u> <u>Suite</u> <u>Support</u> <u>Macros</u>

       The <u>config</u> macro is defined in <u>ct.hrl</u>. This macro is to be used to retrieve information from  the  <u>Config</u>
       variable  sent  to  all  test  cases.  It  is  used  with  two  arguments;  the  first is the name of the
       configuration variable to retrieve, the second is the <u>Config</u> variable supplied to the test case.

       Possible configuration variables include:

         * <u>data_dir</u> - Data file directory

         * <u>priv_dir</u> - Scratch file directory

         * Whatever added by <u>init_per_suite/1</u> or <u>init_per_testcase/2</u> in the test suite.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>handle()</b> <b>=</b> <b>pid()</b>

              The identity (handle) of a connection.

       <b>config_key()</b> <b>=</b> <b>atom()</b>

              A configuration key which exists in a configuration file

       <b>target_name()</b> <b>=</b> <b>atom()</b>

              A name and association to configuration data introduced through a require statement, or a call  to
              <u>ct:require/2</u>, for example, <u>ct:require(mynodename,{node,[telnet]})</u>.

       <b>key_or_name()</b> <b>=</b> <b>config_key()</b> <b>|</b> <b>target_name()</b>

       <b>conn_log_options()</b> <b>=</b> <b>[conn_log_option()]</b>

              Options  that  can  be  given  to  the <u>cth_conn_log</u> hook, which is used for logging of NETCONF and
              Telnet connections. See ct_netconfc or ct_telnet for description and examples of how to  use  this
              hook.

       <b>conn_log_option()</b> <b>=</b> <b>{log_type,conn_log_type()}</b> <b>|</b> <b>{hosts,[key_or_name()]}</b>

       <b>conn_log_type()</b> <b>=</b> <b>raw</b> <b>|</b> <b>pretty</b> <b>|</b> <b>html</b> <b>|</b> <b>silent</b>

       <b>conn_log_mod()</b> <b>=</b> <b>ct_netconfc</b> <b>|</b> <b>ct_telnet</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>abort_current_testcase(Reason)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>ErrorReason}</b>

              Types:

                 Reason = term()
                 ErrorReason = no_testcase_running | parallel_group

              Aborts  the  currently  executing  test case. The user must know with certainty which test case is
              currently executing. The function is therefore only safe to call from a  function  that  has  been
              called (or synchronously invoked) by the test case.

              <u>Reason</u>, the reason for aborting the test case, is printed in the test case log.

       <b>add_config(Callback,</b> <b>Config)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Callback = atom()
                 Config = string()
                 Reason = term()

              Loads  configuration  variables  using the specified callback module and configuration string. The
              callback module is to be either loaded or present in the code path. Loaded configuration variables
              can later be removed using function <u>ct:remove_config/2</u>.

       <b>break(Comment)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Comment = string()
                 Reason = {multiple_cases_running, TestCases} | 'enable break with release_shell option'
                 TestCases = [atom()]

              Cancels any active timetrap and pauses the execution of the current test case until the user calls
              function <u>continue/0</u>. The user can then interact with  the  Erlang  node  running  the  tests,  for
              example,  for  debugging purposes or for manually executing a part of the test case. If a parallel
              group is executing, <u>ct:break/2</u> is to be called instead.

              A cancelled timetrap is not automatically  reactivated  after  the  break,  but  must  be  started
              explicitly with <u>ct:timetrap/1</u>.

              In  order for the break/continue functionality to work, <u>Common</u> <u>Test</u> must release the shell process
              controlling <u>stdin</u>. This is done by setting start option <u>release_shell</u> to <u>true</u>.  For  details,  see
              section Running Tests from the Erlang Shell or from an Erlang Program in the User's Guide.

       <b>break(TestCase,</b> <b>Comment)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 TestCase = atom()
                 Comment = string()
                 Reason = 'test case not running' | 'enable break with release_shell option'

              Works  the  same  way as <u>ct:break/1</u>, only argument <u>TestCase</u> makes it possible to pause a test case
              executing in a parallel group. Function <u>ct:continue/1</u>  is  to  be  used  to  resume  execution  of
              <u>TestCase</u>.

              For details, see <u>ct:break/1</u>.

       <b>capture_get()</b> <b>-&gt;</b> <b>ListOfStrings</b>

              Types:

                 ListOfStrings = [string()]

              Equivalent to ct:capture_get([default]).

       <b>capture_get(ExclCategories)</b> <b>-&gt;</b> <b>ListOfStrings</b>

              Types:

                 ExclCategories = [atom()]
                 ListOfStrings = [string()]

              Returns  and  purges  the  list  of  text  strings buffered during the latest session of capturing
              printouts to <u>stdout</u>. Log categories that are to be ignored in <u>ListOfStrings</u> can be specified  with
              <u>ExclCategories</u>. If <u>ExclCategories</u> <u>=</u> <u>[]</u>, no filtering takes place.

              See also <u>ct:capture_start/0</u>, <u>ct:capture_stop/0</u>, <u>ct:log/3</u>.

       <b>capture_start()</b> <b>-&gt;</b> <b>ok</b>

              Starts capturing all text strings printed to <u>stdout</u> during execution of the test case.

              See also <u>ct:capture_get/1</u>, <u>ct:capture_stop/0</u>.

       <b>capture_stop()</b> <b>-&gt;</b> <b>ok</b>

              Stops capturing text strings (a session started with <u>capture_start/0</u>).

              See also <u>ct:capture_get/1</u>, <u>ct:capture_start/0</u>.

       <b>comment(Comment)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Comment = term()

              Prints the specified <u>Comment</u> in the comment field in the table on the test suite result page.

              If  called  several  times,  only  the  last  comment  is  printed.  The  test  case  return value
              <u>{comment,Comment}</u> overwrites the string set by this function.

       <b>comment(Format,</b> <b>Args)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Format = string()
                 Args = list()

              Prints the formatted string in the comment field in the table on the test suite result page.

              Arguments <u>Format</u> and <u>Args</u> are used in a call to <u>io_lib:format/2</u> to create the comment string.  The
              behavior of <u>comment/2</u> is otherwise the same as function <u>ct:comment/1</u>.

       <b>continue()</b> <b>-&gt;</b> <b>ok</b>

              This function must be called to continue after a test case (not executing in a parallel group) has
              called function <u>ct:break/1</u>.

       <b>continue(TestCase)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 TestCase = atom()

              This  function  must  be called to continue after a test case has called <u>ct:break/2</u>. If the paused
              test case, <u>TestCase</u>, executes in a parallel group, this function, rather than <u>continue/0</u>, must  be
              used to let the test case proceed.

       <b>decrypt_config_file(EncryptFileName,</b> <b>TargetFileName)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 EncryptFileName = string()
                 TargetFileName = string()
                 Reason = term()

              Decrypts  <u>EncryptFileName</u>, previously generated with <u>ct:encrypt_config_file/2,3</u>. The original file
              contents is saved in the target file. The encryption key, a string, must be available  in  a  text
              file  named  <u>.ct_config.crypt</u>,  either in the current directory, or the home directory of the user
              (it is searched for in that order).

       <b>decrypt_config_file(EncryptFileName,</b> <b>TargetFileName,</b> <b>KeyOrFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 EncryptFileName = string()
                 TargetFileName = string()
                 KeyOrFile = {key, string()} | {file, string()}
                 Reason = term()

              Decrypts <u>EncryptFileName</u>, previously generated with <u>ct:encrypt_config_file/2,3</u>. The original  file
              contents  is  saved  in  the  target  file.  The  key  must  have  the same value as that used for
              encryption.

       <b>encrypt_config_file(SrcFileName,</b> <b>EncryptFileName)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SrcFileName = string()
                 EncryptFileName = string()
                 Reason = term()

              Encrypts the source configuration file with DES3 and saves the result in file <u>EncryptFileName</u>. The
              key, a string, must be available in a text file named  <u>.ct_config.crypt</u>,  either  in  the  current
              directory, or the home directory of the user (it is searched for in that order).

              For  information  about  using  encrypted  configuration  files  when  running  tests, see section
              Encrypted Configuration Files in the User's Guide.

              For details on DES3 encryption/decryption, see application <u>Crypto</u>.

       <b>encrypt_config_file(SrcFileName,</b> <b>EncryptFileName,</b> <b>KeyOrFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SrcFileName = string()
                 EncryptFileName = string()
                 KeyOrFile = {key, string()} | {file, string()}
                 Reason = term()

              Encrypts the source configuration file  with  DES3  and  saves  the  result  in  the  target  file
              <u>EncryptFileName</u>. The encryption key to use is either the value in <u>{key,Key}</u> or the value stored in
              the file specified by <u>{file,File}</u>.

              For  information  about  using  encrypted  configuration  files  when  running  tests, see section
              Encrypted Configuration Files in the User's Guide.

              For details on DES3 encryption/decryption, see application <u>Crypto</u>.

       <b>fail(Reason)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Reason = term()

              Terminates a test case with the specified error <u>Reason</u>.

       <b>fail(Format,</b> <b>Args)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Format = string()
                 Args = list()

              Terminates a test case with an error message specified by a format string and  a  list  of  values
              (used as arguments to <u>io_lib:format/2</u>).

       <b>get_config(Required)</b> <b>-&gt;</b> <b>Value</b>

              Equivalent to <u>ct:get_config(Required,</u> <u>undefined,</u> <u>[])</u>.

       <b>get_config(Required,</b> <b>Default)</b> <b>-&gt;</b> <b>Value</b>

              Equivalent to <u>ct:get_config(Required,</u> <u>Default,</u> <u>[])</u>.

       <b>get_config(Required,</b> <b>Default,</b> <b>Opts)</b> <b>-&gt;</b> <b>ValueOrElement</b>

              Types:

                 Required = KeyOrName | {KeyOrName, SubKey} | {KeyOrName, SubKey, SubKey}
                 KeyOrName = atom()
                 SubKey = atom()
                 Default = term()
                 Opts = [Opt] | []
                 Opt = element | all
                 ValueOrElement = term() | Default

              Reads configuration data values.

              Returns  the  matching values or configuration elements, given a configuration variable key or its
              associated name (if one has been specified with <u>ct:require/2</u> or a <u>require</u> statement).

              <u>Example:</u>

              Given the following configuration file:

               {unix,[{telnet,IpAddr},
                      {user,[{username,Username},
                             {password,Password}]}]}.

              Then:

               ct:get_config(unix,Default) -&gt; [{telnet,IpAddr},
                {user, [{username,Username}, {password,Password}]}]
               ct:get_config({unix,telnet},Default) -&gt; IpAddr
               ct:get_config({unix,user,username},Default) -&gt; Username
               ct:get_config({unix,ftp},Default) -&gt; Default
               ct:get_config(unknownkey,Default) -&gt; Default

              If a configuration variable key has been associated with a name  (by  <u>ct:require/2</u>  or  a  <u>require</u>
              statement), the name can be used instead of the key to read the value:

               ct:require(myuser,{unix,user}) -&gt; ok.
               ct:get_config(myuser,Default) -&gt; [{username,Username}, {password,Password}]

              If  a  configuration  variable is defined in multiple files, use option <u>all</u> to access all possible
              values. The values are returned in a list. The order of the elements corresponds to the order that
              the configuration files were specified at startup.

              If configuration elements (key-value tuples) are to be returned as result instead of  values,  use
              option <u>element</u>. The returned elements are then on the form <u>{Required,Value}</u>.

              See also <u>ct:get_config/1</u>, <u>ct:get_config/2</u>, <u>ct:require/1</u>, <u>ct:require/2</u>.

       <b>get_event_mgr_ref()</b> <b>-&gt;</b> <b>EvMgrRef</b>

              Types:

                 EvMgrRef = atom()

              Gets  a reference to the <u>Common</u> <u>Test</u> event manager. The reference can be used to, for example, add
              a user-specific event handler while tests are running.

              <u>Example:</u>

               gen_event:add_handler(ct:get_event_mgr_ref(), my_ev_h, [])

       <b>get_progname()</b> <b>-&gt;</b> <b>string()</b>

              Returns the command used to start this Erlang instance. If this information could  not  be  found,
              the string <u>"no_prog_name"</u> is returned.

       <b>get_status()</b> <b>-&gt;</b> <b>TestStatus</b> <b>|</b> <b>{error,</b> <b>Reason}</b> <b>|</b> <b>no_tests_running</b>

              Types:

                 TestStatus = [StatusElem]
                 StatusElem  = {current, TestCaseInfo} | {successful, Successful} | {failed, Failed} | {skipped,
                 Skipped} | {total, Total}
                 TestCaseInfo = {Suite, TestCase} | [{Suite, TestCase}]
                 Suite = atom()
                 TestCase = atom()
                 Successful = integer()
                 Failed = integer()
                 Skipped = {UserSkipped, AutoSkipped}
                 UserSkipped = integer()
                 AutoSkipped = integer()
                 Total = integer()
                 Reason = term()

              Returns status of ongoing test. The returned list contains information about which  test  case  is
              executing  (a list of cases when a parallel test case group is executing), as well as counters for
              successful, failed, skipped, and total test cases so far.

       <b>get_target_name(Handle)</b> <b>-&gt;</b> <b>{ok,</b> <b>TargetName}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Handle = handle()
                 TargetName = target_name()

              Returns the name of the target that the specified connection belongs to.

       <b>get_testspec_terms()</b> <b>-&gt;</b> <b>TestSpecTerms</b> <b>|</b> <b>undefined</b>

              Types:

                 TestSpecTerms = [{Tag, Value}]
                 Value = [term()]

              Gets a list of all test specification terms used to configure and run this test.

       <b>get_testspec_terms(Tags)</b> <b>-&gt;</b> <b>TestSpecTerms</b> <b>|</b> <b>undefined</b>

              Types:

                 Tags = [Tag] | Tag
                 Tag = atom()
                 TestSpecTerms = [{Tag, Value}] | {Tag, Value}
                 Value = [{Node, term()}] | [term()]
                 Node = atom()

              Reads one or more terms from the test specification used to configure and run this  test.  <u>Tag</u>  is
              any  valid  test specification tag, for example, <u>label</u>, <u>config</u>, or <u>logdir</u>. User-specific terms are
              also available to read if option <u>allow_user_terms</u> is set.

              All value tuples returned, except user terms, have the node name as first element.

              To read test terms, use <u>Tag</u> <u>=</u> <u>tests</u> (rather than <u>suites</u>, <u>groups</u>, or <u>cases</u>). <u>Value</u> is then the list
              of <u>all</u> tests on the form <u>[{Node,Dir,[{TestSpec,GroupsAndCases1},...]},...]</u>, where <u>GroupsAndCases</u> <u>=</u>
              <u>[{Group,[Case]}]</u> <u>|</u> <u>[Case]</u>.

       <b>get_timetrap_info()</b> <b>-&gt;</b> <b>{Time,</b> <b>{Scaling,ScaleVal}}</b>

              Types:

                 Time = integer() | infinity
                 Scaling = true | false
                 ScaleVal = integer()

              Reads information about the timetrap set for the current test case. <u>Scaling</u>  indicates  if  <u>Common</u>
              <u>Test</u>  will  attempt  to  compensate  timetraps automatically for runtime delays introduced by, for
              example, tools like cover. <u>ScaleVal</u> is the value of the current scaling  multipler  (always  1  if
              scaling is disabled). Note the <u>Time</u> is not the scaled result.

       <b>get_verbosity(Category)</b> <b>-&gt;</b> <b>Level</b> <b>|</b> <b>undefined</b>

              Types:

                 Category = default | atom()
                 Level = integer()

              This  function  returns  the  verbosity  level for the specified logging category. See the  User's
              Guide for details. Use the value <u>default</u> to read the general verbosity level.

       <b>install(Opts)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Opts = [Opt]
                 Opt = {config, ConfigFiles} | {event_handler, Modules} | {decrypt, KeyOrFile}
                 ConfigFiles = [ConfigFile]
                 ConfigFile = string()
                 Modules = [atom()]
                 KeyOrFile = {key, Key} | {file, KeyFile}
                 Key = string()
                 KeyFile = string()

              Installs configuration files and event handlers.

              Run this function once before the first test.

              <u>Example:</u>

               install([{config,["config_node.ctc","config_user.ctc"]}])

              This function is automatically run by program <u>ct_run</u>.

       <b>listenv(Telnet)</b> <b>-&gt;</b> <b>[Env]</b>

              Types:

                 Telnet = term()
                 Env = {Key, Value}
                 Key = string()
                 Value = string()

              Performs command <u>listenv</u> on the specified Telnet connection and returns the result as  a  list  of
              key-value pairs.

       <b>log(Format)</b> <b>-&gt;</b> <b>ok</b>

              Equivalent to <u>ct:log(default,</u> <u>50,</u> <u>Format,</u> <u>[],</u> <u>[])</u>.

       <b>log(X1,</b> <b>X2)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 X1 = Category | Importance | Format
                 X2 = Format | FormatArgs

              Equivalent to <u>ct:log(Category,</u> <u>Importance,</u> <u>Format,</u> <u>FormatArgs,</u> <u>[])</u>.

       <b>log(X1,</b> <b>X2,</b> <b>X3)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 X1 = Category | Importance
                 X2 = Importance | Format
                 X3 = Format | FormatArgs | Opts

              Equivalent to <u>ct:log(Category,</u> <u>Importance,</u> <u>Format,</u> <u>FormatArgs,</u> <u>Opts)</u>.

       <b>log(X1,</b> <b>X2,</b> <b>X3,</b> <b>X4)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 X1 = Category | Importance
                 X2 = Importance | Format
                 X3 = Format | FormatArgs
                 X4 = FormatArgs | Opts

              Equivalent to <u>ct:log(Category,</u> <u>Importance,</u> <u>Format,</u> <u>FormatArgs,</u> <u>Opts)</u>.

       <b>log(Category,</b> <b>Importance,</b> <b>Format,</b> <b>FormatArgs,</b> <b>Opts)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Category = atom()
                 Importance = integer()
                 Format = string()
                 FormatArgs = list()
                 Opts = [Opt]
                 Opt = {heading,string()} | no_css | esc_chars

              Prints from a test case to the log file.

              This function is meant for printing a string directly from a test case to the test case log file.

              Default  <u>Category</u>  is  <u>default</u>,  default  <u>Importance</u>  is  <u>?STD_IMPORTANCE</u>,  and  default value for
              <u>FormatArgs</u> is <u>[]</u>.

              For details on <u>Category</u>, <u>Importance</u> and the <u>no_css</u> option, see section  Logging -  Categories  and
              Verbosity Levels in the User's Guide.

              Common  Test  will  not  escape special HTML characters (&lt;, &gt; and &amp;) in the text printed with this
              function, unless the <u>esc_chars</u> option is used.

       <b>make_priv_dir()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Reason = term()

              If the test is started with option <u>create_priv_dir</u> set to <u>manual_per_tc</u>, in  order  for  the  test
              case to use the private directory, it must first create it by calling this function.

       <b>notify(Name,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Name = atom()
                 Data = term()

              Sends  an  asynchronous  notification of type <u>Name</u> with <u>Data</u>to the Common Test event manager. This
              can later be caught by any installed event manager.

              See also <u><a href="../man3erl/gen_event.3erl.html">gen_event</a>(3erl)</u>.

       <b>pal(Format)</b> <b>-&gt;</b> <b>ok</b>

              Equivalent to <u>ct:pal(default,</u> <u>50,</u> <u>Format,</u> <u>[],</u> <u>[])</u>.

       <b>pal(X1,</b> <b>X2)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 X1 = Category | Importance | Format
                 X2 = Format | FormatArgs

              Equivalent to <u>ct:pal(Category,</u> <u>Importance,</u> <u>Format,</u> <u>FormatArgs,</u> <u>[])</u>.

       <b>pal(X1,</b> <b>X2,</b> <b>X3)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 X1 = Category | Importance
                 X2 = Importance | Format
                 X3 = Format | FormatArgs | Opts

              Equivalent to <u>ct:pal(Category,</u> <u>Importance,</u> <u>Format,</u> <u>FormatArgs,</u> <u>Opts)</u>.

       <b>pal(X1,</b> <b>X2,</b> <b>X3,</b> <b>X4)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 X1 = Category | Importance
                 X2 = Importance | Format
                 X3 = Format | FormatArgs
                 X4 = FormatArgs | Opts

              Equivalent to <u>ct:pal(Category,</u> <u>Importance,</u> <u>Format,</u> <u>FormatArgs,</u> <u>Opts)</u>.

       <b>pal(Category,</b> <b>Importance,</b> <b>Format,</b> <b>FormatArgs,</b> <b>Opts)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Category = atom()
                 Importance = integer()
                 Format = string()
                 FormatArgs = list()
                 Opts = [Opt]
                 Opt = {heading,string()} | no_css

              Prints and logs from a test case.

              This function is meant for printing a string from a test case, both to the test case log file  and
              to the console.

              Default  <u>Category</u>  is  <u>default</u>,  default  <u>Importance</u>  is  <u>?STD_IMPORTANCE</u>,  and  default value for
              <u>FormatArgs</u> is <u>[]</u>.

              For details on <u>Category</u> and <u>Importance</u>, see section Logging - Categories and Verbosity  Levels  in
              the User's Guide.

              Note  that  special  characters in the text (&lt;, &gt; and &amp;) will be escaped by Common Test before the
              text is printed to the log file.

       <b>parse_table(Data)</b> <b>-&gt;</b> <b>{Heading,</b> <b>Table}</b>

              Types:

                 Data = [string()]
                 Heading = tuple()
                 Table = [tuple()]

              Parses the printout from an SQL table and returns a list of tuples.

              The printout to parse is typically the result of a <u>select</u> command in SQL. The returned <u>Table</u> is  a
              list of tuples, where each tuple is a row in the table.

              <u>Heading</u> is a tuple of strings representing the headings of each column in the table.

       <b>print(Format)</b> <b>-&gt;</b> <b>ok</b>

              Equivalent to <u>ct:print(default,</u> <u>50,</u> <u>Format,</u> <u>[],</u> <u>[])</u>.

       <b>print(X1,</b> <b>X2)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 X1 = Category | Importance | Format
                 X2 = Format | FormatArgs

              Equivalent to <u>ct:print(Category,</u> <u>Importance,</u> <u>Format,</u> <u>FormatArgs,</u> <u>[])</u>.

       <b>print(X1,</b> <b>X2,</b> <b>X3)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 X1 = Category | Importance
                 X2 = Importance | Format
                 X3 = Format | FormatArgs | Opts

              Equivalent to <u>ct:print(Category,</u> <u>Importance,</u> <u>Format,</u> <u>FormatArgs,</u> <u>Opts)</u>.

       <b>print(X1,</b> <b>X2,</b> <b>X3,</b> <b>X4)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 X1 = Category | Importance
                 X2 = Importance | Format
                 X3 = Format | FormatArgs
                 X4 = FormatArgs | Opts

              Equivalent to <u>ct:print(Category,</u> <u>Importance,</u> <u>Format,</u> <u>FormatArgs,</u> <u>Opts)</u>.

       <b>print(Category,</b> <b>Importance,</b> <b>Format,</b> <b>FormatArgs,</b> <b>Opts)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Category = atom()
                 Importance = integer()
                 Format = string()
                 FormatArgs = list()
                 Opts = [Opt]
                 Opt = {heading,string()}

              Prints from a test case to the console.

              This function is meant for printing a string from a test case to the console.

              Default  <u>Category</u>  is  <u>default</u>,  default  <u>Importance</u>  is  <u>?STD_IMPORTANCE</u>,  and  default value for
              <u>FormatArgs</u> is <u>[]</u>.

              For details on <u>Category</u> and <u>Importance</u>, see section Logging - Categories and Verbosity  Levels  in
              the User's Guide.

       <b>reload_config(Required)</b> <b>-&gt;</b> <b>ValueOrElement</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Required = KeyOrName | {KeyOrName, SubKey} | {KeyOrName, SubKey, SubKey}
                 KeyOrName = atom()
                 SubKey = atom()
                 ValueOrElement = term()

              Reloads configuration file containing specified configuration key.

              This  function  updates the configuration data from which the specified configuration variable was
              read, and returns the (possibly) new value of this variable.

              If some variables were present in the configuration, but are not loaded using this function,  they
              are removed from the configuration table together with their aliases.

       <b>remaining_test_procs()</b> <b>-&gt;</b> <b>{TestProcs,SharedGL,OtherGLs}</b>

              Types:

                 TestProcs = [{pid(),GL}]
                 GL = pid()
                 SharedGL = pid()
                 OtherGLs = [pid()]

              This  function will return the identity of test- and group leader processes that are still running
              at the time of this call. <u>TestProcs</u> are processes in the system that have a Common Test IO process
              as group leader. <u>SharedGL</u> is the central Common Test IO process, responsible for printing  to  log
              files  for configuration functions and sequentially executing test cases. <u>OtherGLs</u> are Common Test
              IO processes that print to log files for test cases in parallel test case groups.

              The process information returned by this function may be used to locate  and  terminate  remaining
              processes  after tests have finished executing. The function would typically by called from Common
              Test Hook functions.

              Note that processes that execute configuration functions or  test  cases  are  never  included  in
              <u>TestProcs</u>.   It   is   therefore   safe   to  use  post  configuration  hook  functions  (such  as
              post_end_per_suite, post_end_per_group,  post_end_per_testcase)  to  terminate  all  processes  in
              <u>TestProcs</u> that have the current group leader process as its group leader.

              Note  also  that  the shared group leader (<u>SharedGL</u>) must never be terminated by the user, only by
              Common Test. Group leader processes for parallel  test  case  groups  (<u>OtherGLs</u>)  may  however  be
              terminated in post_end_per_group hook functions.

       <b>remove_config(Callback,</b> <b>Config)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Callback = atom()
                 Config = string()
                 Reason = term()

              Removes  configuration  variables  (together  with  their aliases) that were loaded with specified
              callback module and configuration string.

       <b>require(Required)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Required = Key | {Key, SubKeys} | {Key, SubKey, SubKeys}
                 Key = atom()
                 SubKeys = SubKey | [SubKey]
                 SubKey = atom()

              Checks if the required configuration is available. Arbitrarily deep tuples  can  be  specified  as
              <u>Required</u>. Only the last element of the tuple can be a list of <u>SubKey</u>s.

              <u>Example</u> <u>1.</u> Require the variable <u>myvar</u>:

               ok = ct:<a href="../manmyvar/require.myvar.html">require</a>(myvar).

              In this case the configuration file must at least contain:

               {myvar,Value}.

              <u>Example</u> <u>2.</u> Require key <u>myvar</u> with subkeys <u>sub1</u> and <u>sub2</u>:

               ok = ct:require({myvar,[sub1,sub2]}).

              In this case the configuration file must at least contain:

               {myvar,[{sub1,Value},{sub2,Value}]}.

              <u>Example</u> <u>3.</u> Require key <u>myvar</u> with subkey <u>sub1</u> with <u>subsub1</u>:

               ok = ct:require({myvar,sub1,sub2}).

              In this case the configuration file must at least contain:

               {myvar,[{sub1,[{sub2,Value}]}]}.

              See also <u>ct:get_config/1</u>, <u>ct:get_config/2</u>, <u>ct:get_config/3</u>, <u>ct:require/2</u>.

       <b>require(Name,</b> <b>Required)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = atom()
                 Required = Key | {Key, SubKey} | {Key, SubKey, SubKey}
                 SubKey = Key
                 Key = atom()

              Checks  if the required configuration is available and gives it a name. The semantics for <u>Required</u>
              is the same as in <u>ct:require/1</u> except that a list of <u>SubKey</u>s cannot be specified.

              If the requested data is available, the subentry is associated with <u>Name</u> so that the value of  the
              element  can  be  read  with <u>ct:get_config/1,2</u> provided <u>Name</u> is used instead of the whole <u>Required</u>
              term.

              <u>Example:</u>

              Require one node with a Telnet connection and an FTP connection. Name the node <u>a</u>:

               ok = ct:require(a,{machine,node}).

              All references to this node can then use the node name. For example, a file over  FTP  is  fetched
              like follows:

               ok = ct:ftp_get(a,RemoteFile,LocalFile).

              For this to work, the configuration file must at least contain:

               {machine,[{node,[{telnet,IpAddr},{ftp,IpAddr}]}]}.

          <b>Note:</b>
              The  behavior  of  this  function  changed  radically in <u>Common</u> <u>Test</u> 1.6.2. To keep some backwards
              compatability, it is still possible to do:
              <u>ct:require(a,{node,[telnet,ftp]}).</u>
              This associates the name <u>a</u> with the top-level <u>node</u> entry. For this to work, the configuration file
              must at least contain:
              <u>{node,[{telnet,IpAddr},{ftp,IpAddr}]}.</u>

              See also <u>ct:get_config/1</u>, <u>ct:get_config/2</u>, <u>ct:get_config/3</u>, <u>ct:require/1</u>.

       <b>run(TestDirs)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TestDirs = TestDir | [TestDir]

              Runs all test cases in all suites in the specified directories.

              See also <u>ct:run/3</u>.

       <b>run(TestDir,</b> <b>Suite)</b> <b>-&gt;</b> <b>Result</b>

              Runs all test cases in the specified suite.

              See also <u>ct:run/3</u>.

       <b>run(TestDir,</b> <b>Suite,</b> <b>Cases)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TestDir = string()
                 Suite = atom()
                 Cases = atom() | [atom()]
                 Result = [TestResult] | {error, Reason}

              Runs the specified test cases.

              Requires that <u>ct:install/1</u> has been run first.

              Suites (<u>*_SUITE.erl</u>) files must be stored in <u>TestDir</u> or <u>TestDir/test</u>. All suites are compiled when
              the test is run.

       <b>run_test(Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Opts = [OptTuples]
                 OptTuples = {dir, TestDirs} | {suite, Suites} | {group, Groups} | {testcase,  Cases}  |  {spec,
                 TestSpecs}  |  {join_specs,  Bool}  |  {label,  Label}  |  {config,  CfgFiles}  |  {userconfig,
                 UserConfig} | {allow_user_terms, Bool} |  {logdir,  LogDir}  |  {silent_connections,  Conns}  |
                 {stylesheet,  CSSFile}  |  {cover,  CoverSpecFile}  |  {cover_stop,  Bool} | {step, StepOpts} |
                 {event_handler,   EventHandlers}   |   {include,   InclDirs}   |   {auto_compile,    Bool}    |
                 {abort_if_missing_suites,  Bool} | {create_priv_dir, CreatePrivDir} | {multiply_timetraps, M} |
                 {scale_timetraps, Bool} | {repeat, N} | {duration, DurTime} | {until, StopTime} |  {force_stop,
                 ForceStop}  |  {decrypt,  DecryptKeyOrFile}  |  {refresh_logs,  LogDir}  | {logopts, LogOpts} |
                 {verbosity, VLevels}  |  {basic_html,  Bool}  |  {esc_chars,  Bool}  |  {keep_logs,KeepSpec}  |
                 {ct_hooks, CTHs} | {enable_builtin_hooks, Bool} | {release_shell, Bool}
                 TestDirs = [string()] | string()
                 Suites = [string()] | [atom()] | string() | atom()
                 Cases = [atom()] | atom()
                 Groups = GroupNameOrPath | [GroupNameOrPath]
                 GroupNameOrPath = [atom()] | atom() | all
                 TestSpecs = [string()] | string()
                 Label = string() | atom()
                 CfgFiles = [string()] | string()
                 UserConfig = [{CallbackMod, CfgStrings}] | {CallbackMod, CfgStrings}
                 CallbackMod = atom()
                 CfgStrings = [string()] | string()
                 LogDir = string()
                 Conns = all | [atom()]
                 CSSFile = string()
                 CoverSpecFile = string()
                 StepOpts = [StepOpt] | []
                 StepOpt = config | keep_inactive
                 EventHandlers = EH | [EH]
                 EH = atom() | {atom(), InitArgs} | {[atom()], InitArgs}
                 InitArgs = [term()]
                 InclDirs = [string()] | string()
                 CreatePrivDir = auto_per_run | auto_per_tc | manual_per_tc
                 M = integer()
                 N = integer()
                 DurTime = string(HHMMSS)
                 StopTime = string(YYMoMoDDHHMMSS) | string(HHMMSS)
                 ForceStop = skip_rest | Bool
                 DecryptKeyOrFile = {key, DecryptKey} | {file, DecryptFile}
                 DecryptKey = string()
                 DecryptFile = string()
                 LogOpts = [LogOpt]
                 LogOpt = no_nl | no_src
                 VLevels = VLevel | [{Category, VLevel}]
                 VLevel = integer()
                 Category = atom()
                 KeepSpec = all | pos_integer()
                 CTHs = [CTHModule | {CTHModule, CTHInitArgs}]
                 CTHModule = atom()
                 CTHInitArgs = term()
                 Result = {Ok, Failed, {UserSkipped, AutoSkipped}} | TestRunnerPid | {error, Reason}
                 Ok = integer()
                 Failed = integer()
                 UserSkipped = integer()
                 AutoSkipped = integer()
                 TestRunnerPid = pid()
                 Reason = term()

              Runs  tests  as specified by the combination of options in <u>Opts</u>. The options are the same as those
              used with program <u>ct_run</u>, see Run Tests from Command Line in the <u>ct_run</u> manual page.

              Here a <u>TestDir</u> can be used to point out the path to a <u>Suite</u>. Option <u>testcase</u> corresponds to option
              <u>-case</u> in program <u>ct_run</u>. Configuration files specified in  <u>Opts</u>  are  installed  automatically  at
              startup.

              <u>TestRunnerPid</u> is returned if <u>release_shell</u> <u>==</u> <u>true</u>. For details, see <u>ct:break/1</u>.

              <u>Reason</u> indicates the type of error encountered.

       <b>run_testspec(TestSpec)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TestSpec = [term()]
                 Result = {Ok, Failed, {UserSkipped, AutoSkipped}} | {error, Reason}
                 Ok = integer()
                 Failed = integer()
                 UserSkipped = integer()
                 AutoSkipped = integer()
                 Reason = term()

              Runs a test specified by <u>TestSpec</u>. The same terms are used as in test specification files.

              <u>Reason</u> indicates the type of error encountered.

       <b>set_verbosity(Category,</b> <b>Level)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Category = default | atom()
                 Level = integer()

              Use  this  function to set, or modify, the verbosity level for a logging category. See the  User's
              Guide for details. Use the value <u>default</u> to set the general verbosity level.

       <b>sleep(Time)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Time = {hours, Hours} | {minutes, Mins} | {seconds, Secs} | Millisecs | infinity
                 Hours = integer()
                 Mins = integer()
                 Secs = integer()
                 Millisecs = integer() | float()

              This function, similar to <u>timer:sleep/1</u> in STDLIB, suspends the test case for  a  specified  time.
              However,  this  function also multiplies <u>Time</u> with the <u>multiply_timetraps</u> value (if set) and under
              certain circumstances also scales up the time automatically if  <u>scale_timetraps</u>  is  set  to  <u>true</u>
              (default is <u>false</u>).

       <b>start_interactive()</b> <b>-&gt;</b> <b>ok</b>

              Starts <u>Common</u> <u>Test</u> in interactive mode.

              From  this  mode,  all test case support functions can be executed directly from the Erlang shell.
              The interactive mode can also be started from the OS command  line  with  <u>ct_run</u>  <u>-shell</u>  <u>[-config</u>
              <u>File...]</u>.

              If any functions (for example, Telnet or FTP) using "required configuration data" are to be called
              from the Erlang shell, configuration data must first be required with <u>ct:require/2</u>.

              <u>Example:</u>

               &gt; ct:require(unix_telnet, unix).
               ok
               &gt; ct_telnet:open(unix_telnet).
               {ok,&lt;0.105.0&gt;}
               &gt; ct_telnet:cmd(unix_telnet, "ls .").
               {ok,["ls","file1  ...",...]}

       <b>step(TestDir,</b> <b>Suite,</b> <b>Case)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Case = atom()

              Steps through a test case with the debugger.

              See also <u>ct:run/3</u>.

       <b>step(TestDir,</b> <b>Suite,</b> <b>Case,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Case = atom()
                 Opts = [Opt] | []
                 Opt = config | keep_inactive

              Steps  through a test case with the debugger. If option <u>config</u> has been specified, breakpoints are
              also set on the configuration functions in <u>Suite</u>.

              See also <u>ct:run/3</u>.

       <b>stop_interactive()</b> <b>-&gt;</b> <b>ok</b>

              Exits the interactive mode.

              See also <u>ct:start_interactive/0</u>.

       <b>sync_notify(Name,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Name = atom()
                 Data = term()

              Sends a synchronous notification of type <u>Name</u> with <u>Data</u> to the <u>Common</u> <u>Test</u> event manager. This can
              later be caught by any installed event manager.

              See also <u><a href="../man3erl/gen_event.3erl.html">gen_event</a>(3erl)</u>.

       <b>testcases(TestDir,</b> <b>Suite)</b> <b>-&gt;</b> <b>Testcases</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 TestDir = string()
                 Suite = atom()
                 Testcases = list()
                 Reason = term()

              Returns all test cases in the specified suite.

       <b>timetrap(Time)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Time = {hours, Hours} | {minutes, Mins} | {seconds, Secs} | Millisecs | infinity | Func
                 Hours = integer()
                 Mins = integer()
                 Secs = integer()
                 Millisecs = integer()
                 Func = {M, F, A} | function()
                 M = atom()
                 F = atom()
                 A = list()

              Sets a new timetrap for the running test case.

              If the argument is <u>Func</u>, the timetrap is triggered when  this  function  returns.  <u>Func</u>  can  also
              return a new <u>Time</u> value, which in that case is the value for the new timetrap.

       <b>userdata(TestDir,</b> <b>Suite)</b> <b>-&gt;</b> <b>SuiteUserData</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 TestDir = string()
                 Suite = atom()
                 SuiteUserData = [term()]
                 Reason = term()

              Returns any data specified with tag <u>userdata</u> in the list of tuples returned from <u>suite/0</u>.

       <b>userdata(TestDir,</b> <b>Suite,</b> <b>Case::GroupOrCase)</b> <b>-&gt;</b> <b>TCUserData</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 TestDir = string()
                 Suite = atom()
                 GroupOrCase = {group, GroupName} | atom()
                 GroupName = atom()
                 TCUserData = [term()]
                 Reason = term()

              Returns   any   data   specified   with   tag  <u>userdata</u>  in  the  list  of  tuples  returned  from
              <u>Suite:group(GroupName)</u> or <u>Suite:Case()</u>.

Ericsson AB                                     common_test 1.22                                        <u><a href="../man3erl/ct.3erl.html">ct</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>