<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POSIX::2008 - Perl interface to POSIX.1-2008</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libposix-2008-perl">libposix-2008-perl_0.24-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       POSIX::2008 - Perl interface to POSIX.1-2008

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use POSIX::2008 qw(:fcntl openat pwrite);

         sysopen my $dh, '<a href="file:/tmp">/tmp</a>', O_RDONLY|O_DIRECTORY|O_NOFOLLOW
           or die 'Dafuq?';
         my $fh = openat($dh, 'foobar', O_RDWR|O_CREAT);
         pwrite($fh, 'fuckyounsa', 10, 0);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       POSIX::2008 contains many of the interfaces specified by POSIX.1-2008
       &lt;https://pubs.opengroup.org/onlinepubs/9699919799/&gt; that the core POSIX module withholds, implements in
       Perl or fucked up.

       It also contains a few nonstandard interfaces present in Linux, BSD and Solaris that are extensions of
       the POSIX interfaces.

       This module is provided "as is" unless someone volunteers to maintain it.  Use at your own risk.

</pre><h4><b>FILE</b> <b>DESCRIPTORS</b> <b>AND</b> <b>HANDLES</b></h4><pre>
       Since version 0.05, all I/O functions that take numeric file descriptors also accept Perl file or
       directory handles, except for fdopen() and fdopendir().

       Since version 0.22, returned handles support IO::Handle methods.

</pre><h4><b>SYSTEM</b> <b>CALL</b> <b>RETURN</b> <b>VALUES</b></h4><pre>
       A system call return value of -1 meaning "error" is mapped to undef.

       A system call return value of 0 meaning "success" is mapped to "0 but true".

       For system calls where 0 does not just mean "success", 0 is returned unchanged. These are creat(),
       open(), read(), write(), readv(), writev(), pread(), pwrite(), preadv(), pwritev(), preadv2(),
       pwritev2(), getpriority(), nice(). openat() gets a special treatment in this regard, see below.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       "a64l"
           l = a64l(s);

       "abort"
           <b>abort()</b>;

       "abs"
           ui = abs(i);

           Calls llabs(), labs(), or abs(), whichever is the maximum supported by your system.

           Note  that  the  library functions use signed integers, so abs(~0) is 1.  If you don't want that, use
           CORE::abs().

       "access"
           ret = access(path, mode);

           <u>New</u> <u>in</u> <u>version</u> <u>0.08.</u>

       "acos"
           y = acos(x);

       "acosh"
           y = acosh(x);

       "alarm"
           remaining_sec = alarm(sec);

       "asin"
           y = asin(x);

       "asinh"
           y = asinh(x);

       "atan2"
           z = atan2(y, x);

       "atan"
           y = atan(x);

       "atanh"
           y = atanh(x);

       "atof"
           f = atof(s);

       "atoi"
           i = atoi(s);

           Calls atoll(), atol(), or atoi(), whichever is the maximum supported  by  your  system.  This  is  of
           course silly because you could just use int().

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.19:</u> Deprecated <u>atol</u> and <u>atoll</u> now covered by <u>atoi</u>.

       "basename"
           s = basename(path);

       "cabs"
           r = cabs(re, im);

       "cacos"
           (re, im) = cacos(re, im);

       "cacosh"
           (re, im) = cacosh(re, im);

       "carg"
           phi = carg(re, im);

       "casin"
           y = casin(x);

       "casinh"
           (re, im) = casinh(re, im);

       "catan"
           (re, im) = catan(re, im);

       "catanh"
           (re, im) = catanh(re, im);

       "catclose"
           ret = catclose(catd);

       "catgets"
           s = catgets(catd, set_id, msg_id, dflt_string);

       "catopen"
           catd = catopen(name, flag);

       "cbrt"
           y = cbrt(x);

       "ccos"
           (re, im) = ccos(re, im);

       "ccosh"
           (re, im) = ccosh(re, im);

       "ceil"
           y = ceil(x);

       "cexp"
           (re, im) = cexp(re, im);

           <u>New</u> <u>in</u> <u>version</u> <u>0.19.</u>

       "chdir"
           ret = chdir(dir);

           "dir" can be a path, a Perl file or directory handle, or a file descriptor.

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.19:</u> Deprecated <u>fchdir</u> now covered by <u>chdir</u>.

       "chmod"
           ret = chmod(what, mode);

           "what" can be a path, a Perl file or directory handle (see "NOTES"), or a file descriptor.

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.19:</u> Deprecated <u>fchmod</u> now covered by <u>chmod</u>.

       "chown"
           ret = chown(what, uid, gid);

           "what" can be a path, a Perl file or directory handle (see "NOTES"), or a file descriptor.

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.19:</u> Deprecated <u>fchown</u> now covered by <u>chown</u>.

       "cimag"
           im = cimag(re, im);

       "clock"
           t = <b>clock()</b>

           <u>New</u> <u>in</u> <u>version</u> <u>0.08.</u>

       "clock_getcpuclockid"
           clock_id = clock_getcpuclockid(pid);

           pid defaults to $$. Returns undef on error.

       "clock_getres"
           (sec, nsec) = clock_getres(clock_id);

           clock_id defaults to "CLOCK_REALTIME". Returns empty list on error.

       "clock_gettime"
           (sec, nsec) = clock_gettime(clock_id);

           clock_id defaults to "CLOCK_REALTIME". Returns empty list on error.

       "clock_nanosleep"
           (rem_sec, rem_nsec) = clock_nanosleep(clock_id, flags, sec, nsec);

           In scalar context returns the remaining seconds as a floating point number.

       "clock_settime"
           ret = clock_settime(clock_id, sec, nsec);

       "clog"
           (re, im) = clog(re, im);

       "close"
           ret = close(fd);

       "confstr"
           s = confstr(name);

           <u>name</u> is one of the "_CS_*" integer constants.

           Returns undef on error.

       "conj"
           (re, im) = conj(re, im);

       "copysign"
           xs = copysign(x, y);

       "cos"
           y = cos(x);

       "cosh"
           y = cosh(x);

       "cpow"
           (re, im) = cpow(re_x, im_x, re_y, im_y);

       "cproj"
           (re, im) = cproj(re, im);

       "creal"
           re = creal(re, im);

       "creat"
           ret = creat(path, mode=0666);

           <u>New</u> <u>in</u> <u>version</u> <u>0.22.</u>

       "csin"
           (re, im) = csin(re, im);

       "csinh"
           (re, im) = csinh(re, im);

       "csqrt"
           (re, im) = csqrt(re, im);

       "ctan"
           (re, im) = ctan(re, im);

       "ctanh"
           (re, im) = ctanh(re, im);

       "dirname"
           name = dirname(path);

       "div"
           (quot, rem) = div(numer, denom);

           Calls lldiv(), ldiv(), or div(), whichever is the maximum supported by your system.

           Note  that the library functions use signed integers, so "div(~0, 1)" is "(-1, 0)". If you don't want
           that, use Perls int(), "/" and "%".

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.19:</u> Deprecated <u>ldiv</u> and <u>lldiv</u> now covered by <u>div</u>.

       "dlclose"
           dlclose(dlhandle);

       "dlerror"
           <b>dlerror()</b>;

       "dlopen"
           dlhandle = dlopen(file, mode);

       "dlsym"
           addr = dlsym(dlhandle, name);

       "drand48"
           r = <b>drand48()</b>;

       "endutxent"
           <b>endutxent()</b>;

       "erand48"
           (r, X0, X1, X2) = erand48(X0, X1, X2);

       "erf"
           y = erf(x);

       "erfc"
           y = erfc(x);

       "execveat"
           execveat(dirfd, path, args, env=undef, flags=0);

           The <b>execveat()</b> system call is a nonstandard extension present in Linux.  See also fexecve().

           It executes the program referred to by <u>path</u>, which is interpreted relative to <u>dirfd</u> as with the other
           <u>*at</u> functions, passing <u>args</u> as its command-line arguments and optionally <u>env</u> as its environment.

           <u>args</u> must be an array reference and, by convention, <u>args-&gt;[0]</u> should be the name of the program being
           executed.

           <u>env</u> must be a hash reference. If omitted or undef, the environment of  the  calling  proces  is  used
           (which you can manipulate via %ENV).

           <u>flags</u>   is   a   bit   mask   that   can   include   zero  or  more  of  the  flags  "AT_EMPTY_PATH",
           "AT_SYMLINK_NOFOLLOW".

           <u>path</u> is executed "as is", i.e. no "PATH" search or interpretation of shell metacharacters takes place
           as opposed to Perl's built-in "exec".

           Returns undef on error, otherwise it doesn't return.

           Usage example:

             sysopen my $dh, '<a href="file:/usr">/usr</a>', O_DIRECTORY|O_PATH;
             execveat($dh, 'bin/date', [qw(date +%T)], {TZ =&gt; 'UTC'}, AT_SYMLINK_NOFOLLOW);

           <u>New</u> <u>in</u> <u>version</u> <u>0.22.</u>

       "exp"
           y = exp(x);

       "exp2"
           y = exp2(x);

       "expm1"
           y = expm1(x);

       "faccessat"
           ret = faccessat(dirfd, path, amode, flags=0);

           <u>flags</u> is the bitwise OR of zero or more of "AT_EACCESS", "AT_SYMLINK_NOFOLLOW".

       "fchmodat"
           ret = fchmodat(dirfd, path, mode, flags=0);

           <u>flags</u> can be 0 or "AT_SYMLINK_NOFOLLOW". Your system might support a different set of flags.

       "fchownat"
           ret = fchownat(dirfd, path, uid, gid, flags=0);

           <u>flags</u> can be 0 or "AT_SYMLINK_NOFOLLOW". Your system might support a different set of flags.

       "fdatasync"
           ret = fdatasync(fd);

       "fdopen"
           ret = fdopen(fd, mode);

           Returns a file handle associated with the <u>numeric</u> file descriptor <u>fd</u> or undef on error. <u>mode</u>  is  one
           of the values "r", "w", "a" with an optional "+" and/or "b".

           The file descriptor is not dup'ed and will be closed when the handle is closed.

           It's similar to IO::Handle::new_from_fd() with the following improvements:

           •   It <u>really</u> calls <a href="../man3/fdopen.3.html">fdopen</a>(3).

           •   It expects POSIX mode strings (e.g. "r", not "&lt;").

           •   It fails if <u>mode</u> is not compatible with the flags of <u>fd</u>.

           Usage example:

             my $fh = do {
               opendir my $dh, '.';
               fdopen(POSIX::dup(fileno $dh), 'r');
             };
             chmod 0700, $fh;  # this would fail with $dh from opendir

           <u>New</u> <u>in</u> <u>version</u> <u>0.05.</u>

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.22:</u> <u>fd</u> can no longer be a handle (that was a wrong turn).

       "fdopendir"
           ret = fdopendir(fd);

           Returns a directory handle associated with the numeric file descriptor <u>fd</u> or undef on error.

           The file descriptor is not dup'ed and will be closed when the handle is closed.

           Usage example:

             my $dh = do {
               sysopen my $fh, '<a href="file:/tmp">/tmp</a>', O_RDONLY|O_DIRECTORY|O_NOFOLLOW;
               fdopendir(POSIX::dup(fileno $fh));
             };
             my @dents = readdir $dh;  # this would fail with $fh from sysopen

           <u>New</u> <u>in</u> <u>version</u> <u>0.05.</u>

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.22:</u> <u>fd</u> can no longer be a handle (that was a wrong turn).

       "fdim"
           d = fdim(double x, double y);

       "feclearexcept"
           ret = feclearexcept(excepts);

           Returns "0 but true" on success, undef on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.20.</u>

       "fegetround"
           rounding_mode = <b>fegetround()</b>;

       "feraiseexcept"
           ret = feraiseexcept(excepts);

           Returns "0 but true" on success, undef on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.20.</u>

       "fesetround"
           ret = fesetround(round);

           Returns "0 but true" on success, undef on error.

       "fetestexcept"
           excepts_currently_set = fetestexcept(excepts);

           <u>New</u> <u>in</u> <u>version</u> <u>0.20.</u>

       "fexecve"
           fexecve(fd, args, env=undef);

           Executes  the  program  referred  to  by  the  file  descriptor  <u>fd</u>, passing <u>args</u> as its command-line
           arguments and optionally <u>env</u> as its environment.

           <u>args</u> must be an array reference and, by convention, <u>args-&gt;[0]</u> should be the name of the program being
           executed.

           <u>env</u> must be a hash reference. If omitted or undef, the environment of  the  calling  proces  is  used
           (which you can manipulate via %ENV).

           See the manpage for issues regarding the close-on-exec flag and the <a href="file:/proc">/proc</a> filesystem.

           Returns undef on error, otherwise it doesn't return.

           Usage example:

             sysopen my $fh, '<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?date">/usr/bin/date</a>', O_PATH;
             fexecve($fh, [qw(date +%T)], {TZ =&gt; 'UTC'});

           See also execveat().

           <u>New</u> <u>in</u> <u>version</u> <u>0.22.</u>

       "ffs"
           pos = ffs(i);

           Calls ffsll(), ffsl(), or ffs(), whichever is the maximum available on your system.

       "floor"
           y = floor(x);

       "fma"
           r = fma(x, y, z);

       "fmax"
           m = fmax(x, y);

       "fmin"
           m = fmin(x, y);

       "fmod"
           m = fmod(x, y);

       "fnmatch"
           ret = fnmatch(pattern, string, flags);

           Returns 0 if <u>string</u> matches <u>pattern</u>, "FNM_NOMATCH" if there is no match, undef if there is an error.

           <u>flags</u>   is  the  bitwise  OR  of  zero  or  more  of  "FNM_NOESCAPE",  "FNM_PATHNAME",  "FNM_PERIOD",
           "FNM_FILE_NAME", "FNM_LEADING_DIR", "FNM_CASEFOLD".

       "fpclassify"
           fpclassify(x);

           Returns one of "FP_NAN", "FP_INFINITE", "FP_ZERO", "FP_SUBNORMAL", "FP_NORMAL".

       "fstatat"
           (dev, ino, mode, nlink,  uid,  gid,  rdev,  size,  atim_sec,  mtim_sec,  ctim_sec,  blksize,  blocks,
           atim_nsec, mtim_nsec, ctim_nsec) = fstatat(dirfd, path, flags = 0);

           <u>flags</u>  is  the  bitwise  OR  of zero or more of "AT_SYMLINK_NOFOLLOW", "AT_NO_AUTOMOUNT". Your system
           might support a different set of flags.

           See stat() for notes on the return values and bugs in CORE::stat().

           Returns the empty list on error.

       "fsync"
           ret = fsync(fd);

       "futimens"
           ret = futimens(fd, atime_sec, atime_nsec, mtime_sec, mtime_nsec);

           atime_sec and mtime_sec default to 0, atime_nsec and mtime_nsec default to "UTIME_NOW".

       "getdate"
           (sec, min, hour, mday, mon, year, wday, yday, isdst) = getdate(string);

       "getdate_err"
           <b>getdate_err()</b> returns the value of the getdate_err variable.

       "getegid"
           egid = <b>getegid()</b>;

       "geteuid"
           euid = <b>geteuid()</b>;

       "getgid"
           gid = <b>getgid()</b>;

       "gethostid"
           hostid = <b>gethostid()</b>;

       "gethostname"
           hostname = <b>gethostname()</b>;

       "getitimer"
           (int_sec, int_usec, val_sec, val_usec) = getitimer(which);

           <u>which</u> is one of "ITIMER_REAL", "ITIMER_VIRTUAL", "ITIMER_PROF".

       "getpriority"
           prio = getpriority(which=PRIO_PROCESS, who=0);

           <u>which</u> can be one  of  "PRIO_PROCESS",  "PRIO_PGRP",  "PRIO_USER",  defaults  to  "PRIO_PROCESS".  <u>who</u>
           defaults to 0.

           Returns undef on error.

       "getsid"
           sid = getsid(pid);

           <u>pid</u> defaults to 0.

       "getuid"
           uid = <b>getuid()</b>;

       "getutxent"
           (user, id, line, pid, type, sec, usec) = <b>getutxent()</b>;

           <b>getutxent()</b> reads a line from the current file position in the utmp file.

       "getutxid"
           (user, id, line, pid, type, sec, usec) = getutxid(ut_type, ut_id);

           <b>getutxid()</b>  searches  forward  from the current file position in the utmp file based upon <u>ut_type</u> and
           <u>ut_id</u>. If <u>ut_type</u> is one of "RUN_LVL", "BOOT_TIME", "NEW_TIME", or "OLD_TIME", <b>getutxid()</b>  will  find
           the  first  entry  whose  <u>ut_type</u>  field  matches  <u>ut_type</u>.  If  <u>ut_type</u>  is  one  of "INIT_PROCESS",
           "LOGIN_PROCESS", "USER_PROCESS", or "DEAD_PROCESS", <b>getutxid()</b> will find the first entry whose  <u>ut_id</u>
           field matches <u>ut_id</u>.

       "getutxline"
           (user, id, line, pid, type, sec, usec) = getutxline(ut_line);

           <b>getutxline()</b>  searches  forward  from  the  current file position in the utmp file.  It scans entries
           whose <u>ut_type</u> is "USER_PROCESS" or "LOGIN_PROCESS" and returns the  first  one  whose  <u>ut_line</u>  field
           matches <u>ut_line</u>.

       "hypot"
           r = hypot(x, y);

       "ilogb"
           y = ilogb(x);

       "isalnum"
           ret = isalnum(charstring);

           Like <b>POSIX::isalnum()</b> but returns 0 for the empty string.

       "isalpha"
           ret = isalpha(charstring);

           Like <b>POSIX::isalpha()</b> but returns 0 for the empty string.

       "isascii"
           ret = isascii(charstring);

           POSIX.1-2008 marks it as obsolete, but I include it anyway.

           <u>New</u> <u>in</u> <u>version</u> <u>0.19.</u>

       "isatty"
           ret = isatty(fd);

       "isblank"
           ret = isblank(charstring);

           Like <b>POSIX::isblank()</b> but returns 0 for the empty string.

       "iscntrl"
           ret = iscntrl(charstring);

           Like <b>POSIX::iscntrl()</b> but returns 0 for the empty string.

       "isdigit"
           ret = isdigit(charstring);

           Like <b>POSIX::isdigit()</b> but returns 0 for the empty string.

       "isfinite"
           ret = isfinite(x);

       "isgraph"
           ret = isgraph(charstring);

           Like <b>POSIX::isgraph()</b> but returns 0 for the empty string.

       "isgreaterequal"
           ret = isgreaterequal(x, y);

           <u>New</u> <u>in</u> <u>version</u> <u>0.20.</u>

       "isinf"
           ret = isinf(x);

       "isless"
           ret = isless(x, y);

           <u>New</u> <u>in</u> <u>version</u> <u>0.20.</u>

       "islessequal"
           ret = islessequal(x, y);

           <u>New</u> <u>in</u> <u>version</u> <u>0.20.</u>

       "islessgreater"
           ret = islessgreater(x, y);

           <u>New</u> <u>in</u> <u>version</u> <u>0.20.</u>

       "islower"
           ret = islower(charstring);

           Like <b>POSIX::islower()</b> but returns 0 for the empty string.

       "isnan"
           ret = isnan(x);

       "isnormal"
           ret = isnormal(x);

       "isprint"
           ret = isprint(charstring);

           Like <b>POSIX::isprint()</b> but returns 0 for the empty string.

       "ispunct"
           ret = ispunct(charstring);

           Like <b>POSIX::ispunct()</b> but returns 0 for the empty string.

       "isspace"
           ret = isspace(charstring);

           Like <b>POSIX::isspace()</b> but returns 0 for the empty string.

       "isunordered"
           ret = isunordered(x, y);

           <u>New</u> <u>in</u> <u>version</u> <u>0.20.</u>

       "isupper"
           ret = isupper(charstring);

           Like <b>POSIX::isupper()</b> but returns 0 for the empty string.

       "isxdigit"
           ret = isxdigit(charstring);

           Like <b>POSIX::isxdigit()</b> but returns 0 for the empty string.

       "j0"
           y = j0(x);

           j0() is the Bessel function of the first kind of order 0.

       "j1"
           y = j1(x);

           j1() is the Bessel function of the first kind of order 1.

       "jn"
           y = jn(n, x);

           jn() is the Bessel function of the first kind of order <u>n</u>.

       "jrand48"
           (r, X0, X1, X2) = jrand48(X0, X1, X2);

       "killpg"
           ret = killpg(pgrp, sig);

       "l64a"
           s = l64a(n);

       "lchown"
           ret = lchown(path, uid, gid);

           <u>New</u> <u>in</u> <u>version</u> <u>0.08.</u>

       "ldexp"
           y = ldexp(x, exp);

       "lgamma"
           y = lgamma(x);

       "link"
           ret = link(path1, path2);

       "linkat"
           ret = linkat(fd1, path1, fd2, path2, flags=0);

           <u>flags</u> can be 0 or "AT_SYMLINK_FOLLOW". Your system might support a different set of flags.

       "log"
           y = log(x);

       "log10"
           y = log10(x);

       "log1p"
           y = log1p(x);

       "log2"
           y = log2(x);

       "logb"
           y = logb(x);

       "lrand48"
           r = <b>lrand48()</b>;

       "lround"
           l = lround(x);

           Calls  llround()  or lround() whichever is the maximum available on your system. If the rounded value
           is outside Perl's internal signed integer range, it is returned as a string. If the rounded value  is
           too large to be stored in a long long or long, undef is returned.

       "lstat"
           (dev,  ino,  mode,  nlink,  uid,  gid,  rdev,  size,  atim_sec,  mtim_sec, ctim_sec, blksize, blocks,
           atim_nsec, mtim_nsec, ctim_nsec) = lstat(path);

           "path" is assumed to be a string (or will be converted to a string).

           See stat() for notes on the return values and bugs in CORE::stat().

           Returns the empty list on error.

       "mkdir"
           ret = mkdir(path, [mode = 0777]);

       "mkdirat"
           ret = mkdirat(fd, path, mode);

       "mkdtemp"
           name = mkdtemp(template);

       "mkfifo"
           ret = mkfifo(path, mode);

       "mkfifoat"
           ret = mkfifoat(fd, path, mode);

       "mknod"
           ret = mknod(path, mode, dev);

       "mknodat"
           ret = mknodat(fd, path, mode, dev);

       "mkstemp"
           (fd, name) = mkstemp(template);

       "mrand48"
           <b>mrand48()</b>;

       "nanosleep"
           (rem_sec, rem_nsec) = nanosleep(sec, nsec);

           In scalar context returns the remaining seconds as a floating point number.

       "nearbyint"
           y = nearbyint(x);

       "nextafter"
           z = nextafter(x, y);

       "nexttoward"
           z = nexttoward(x, y);

       "nice"
           ret = nice(incr);

           Returns undef on error.

       "nrand48"
           r = <b>nrand48()</b>

       "open"
           ret = open(path, flags=O_RDONLY, mode=0666);

       "openat"
           ret = openat(dirfd, path, flags=O_RDONLY, mode=0666);

           If <u>dirfd</u> is numeric (i.e. a file descriptor), openat() returns a file descriptor. If <u>dirfd</u> is a  file
           or  directory  handle, the return value is also a handle whose type depends on the file type of <u>path</u>:
           If <u>path</u> is a directory, the return value is a directory handle, otherwise it's a file handle.

           To get a handle even for the special numeric <u>dirfd</u> value "AT_FDCWD", you can pass a reference to that
           value instead, i.e. "openat(\AT_FDCWD, ...)".

           Returns undef on error.

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.18:</u> Support added for "\AT_FDCWD" reference.

       "openat2"
           ret = openat2(dirfd, path, how);

           The openat2() system call is a Linux-specific extension of openat() and provides a  superset  of  its
           functionality.

           The <u>how</u> parameter is a hash reference corresponding to the <u>struct</u> <u>open_how</u>. It currently supports the
           keys <u>flags</u>, <u>mode</u> and <u>resolve</u>. Missing keys are treated as having a zero value.

           Example:

             my $fh = openat2(
               \AT_FDCWD, '/foobar',
               {flags =&gt; O_RDWR|O_CREAT, mode =&gt; 0600, resolve =&gt; RESOLVE_IN_ROOT}
             );

           Note  that,  unlike open() or openat(), openat2() is very picky about <u>flags</u> and <u>mode</u>. See the manpage
           for details.

           Returns undef on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.18.</u>

       "pathconf"
           ret = pathconf(what, name);

           "what" can be a path or, if your system supports <b>fpathconf()</b>, a Perl file or directory  handle  or  a
           file descriptor.

           <u>name</u> is one of the "_PC_*" integer constants.

           Returns undef on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.22.</u>

       "posix_fadvise"
           ret = posix_fadvise(fd, offset, len, advice);

           <u>advice</u> is one of the "POSIX_FADV_" constants.

           <u>New</u> <u>in</u> <u>version</u> <u>0.14.</u>

       "posix_fallocate"
           ret = posix_fallocate(fd, offset, len);

           <u>New</u> <u>in</u> <u>version</u> <u>0.14.</u>

       "pread"
           bytes_read = pread(fd, buf, count, offset=0, buf_offset=0);

           pread()  reads <u>count</u> bytes (not characters) of data from the file descriptor <u>fd</u> at file offset <u>offset</u>
           into the scalar <u>buf</u> without  changing  the  file  offset.  <u>buf</u>  will  be  enlarged  automatically  if
           necessary.

           <u>offset</u> and <u>buf_offset</u> are set to 0 if omitted or undef.

           pread()  treats  <u>buf</u>  just like sysread() does: <u>buf_offset</u> may be specified to place the read data at
           that position in <u>buf</u>. If <u>buf_offset</u> is past the end of <u>buf</u>, <u>buf</u> will  be  padded  with  zeros  before
           appending  the data. If <u>buf_offset</u> is negative, it is counted from the end of the string. <u>buf</u> will be
           grown or shrunk so that the last byte actually read is the last byte of <u>buf</u> after the read.

           Returns the number of bytes read, 0 at EOF, undef on error.

           Croaks if <u>buf</u> is read-only and <u>count</u> is non-zero.

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.13:</u> Argument order is now (count, offset) instead of (offset, count).

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.22:</u> Croak with read-only <u>buf</u> and non-zero <u>count</u>.

       "preadv"
           bytes_read = preadv(fd, buffers, sizes, offset=0);

           preadv() behaves like readv() but adds an optional <u>offset</u> argument, which specifies the file position
           at which the data is to be read. <u>offset</u> is set to 0 if omitted or undef.

           The file offset is not changed by this system call. The file referred to by <u>fd</u>  must  be  capable  of
           seeking.

           This syscall is present in Linux and BSD.

           <u>New</u> <u>in</u> <u>version</u> <u>0.13.</u>

       "preadv2"
           bytes_read = preadv2(fd, buffers, sizes, offset=0, flags=0);

           preadv2()  is  similar to preadv() but adds an optional <u>flags</u> argument, which is a bitwise OR of zero
           or more of the "RWF_*" flags (see the manpage for details). <u>flags</u> is set to 0 if omitted or undef.

           This syscall is Linux-specific.

           <u>New</u> <u>in</u> <u>version</u> <u>0.20.</u>

       "ptsname"
           name = ptsname(fd);

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.19:</u> Calls ptsname_r() if available.

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.22:</u> <u>fd</u> may also be a file handle.

       "pwrite"
           bytes_written = pwrite(fd, buf, count=undef, offset=0, buf_offset=0);

           pwrite() writes <u>count</u> bytes of data from the scalar <u>buf</u> to the file  descriptor  <u>fd</u>  at  file  offset
           <u>offset</u> without changing the file offset. The file referenced by <u>fd</u> must be capable of seeking.

           If <u>count</u> is omitted or undef, everything from <u>buf_offset</u> up to the end of <u>buf</u> is written.

           <u>buf_offset</u>  may be specified to write data from that position in <u>buf</u>. If <u>buf_offset</u> is negative it is
           counted from the end of the string.

           <u>offset</u> and <u>buf_offset</u> are set to 0 if omitted or undef.

           Returns the number of bytes written, undef on error.

           On Linux, if a file is opened with "O_APPEND",  pwrite()  appends  data  to  the  end  of  the  file,
           regardless of the value of <u>offset</u> (in violation of POSIX).

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.13:</u> Argument order is now (count, offset) instead of (offset, count).

       "pwritev"
           bytes_written = pwritev(fd, buffers, offset=0);

           pwritev()  behaves  like  writev()  but  adds  an  optional <u>offset</u> argument, which specifies the file
           position at which the data is to be written. <u>offset</u> is set to 0 if omitted or undef.

           The file offset is not changed by this system call. The file referred to by <u>fd</u>  must  be  capable  of
           seeking.

           On  Linux,  if  a  file  is  opened  with  "O_APPEND", pwritev() appends data to the end of the file,
           regardless of the value of <u>offset</u> (in violation of POSIX).

           This syscall is present in Linux and BSD.

           <u>New</u> <u>in</u> <u>version</u> <u>0.08.</u>

       "pwritev2"
           bytes_written = pwritev2(fd, buffers, offset=0, flags=0);

           pwritev2() is similar to pwritev() but adds an optional <u>flags</u> argument, which is a bitwise OR of zero
           or more of the "RWF_*" flags (see the manpage for details). <u>flags</u> is set to 0 if omitted or undef.

           This syscall is Linux-specific.

           <u>New</u> <u>in</u> <u>version</u> <u>0.20.</u>

       "random"
           r = <b>random()</b>;

       "raise"
           ret = raise(sig);

       "read"
           bytes_read = read(fd, buf, count);

           Like POSIX::read() but returns 0 at EOF instead of <u>"0</u> <u>but</u> <u>true"</u>. Croaks if <u>buf</u> is read-only and <u>count</u>
           is non-zero.

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.22:</u> Croak with read-only <u>buf</u> and non-zero <u>count</u>.

       "readv"
           bytes_read = readv(fd, buffers, sizes);

           readv() reads from the file descriptor <u>fd</u> into <u>buffers</u> as many  strings  as  there  are  elements  in
           <u>sizes</u>.

           <u>buffers</u>  must  be  a  <u>variable</u>  holding an array (@buf), an array reference or undef ($buf). If it is
           undef it will be upgraded to an array reference.

           <u>sizes</u> must be an array reference, i.e. "\@sizes", $sizes, or "[...]".

           <u>sizes</u> is expected to hold unsigned integers that specify how many bytes are  to  be  read  into  each
           buffer. A byte count of 0 or undef creates an empty string. <u>sizes</u> is processed in array order.

           <u>buffers</u>  will  be  extended  if  necessary, but it will never be shrunk. If <u>buffers</u> is not empty, any
           existing elements are replaced as long as sufficient data was read from <u>fd</u>.

           readv() returns the number of bytes read, undef on error.

           Note that it is not an error for a successful call to transfer fewer bytes than  requested.  In  this
           case there may be one "partially" filled buffer, i.e.  it contains fewer bytes than the corresponding
           size. Surplus size entries lead to corresponding empty buffers.

           Usage example:

             my $fh = openat(\AT_FDCWD, '/tmp/foobar', O_RDWR|O_CREAT|O_TRUNC);
             pwrite($fh, 'foobar', 6, 0);
             readv($fh, my $buf1, [3, 0, 8]); # $buf1: ['foo', '', 'bar']
             sysseek $fh, 0, 0;
             readv($fh, my @buf2, [1, 3, 2]); # @buf2: ('f', 'oob', 'ar')

           <u>New</u> <u>in</u> <u>version</u> <u>0.13.</u>

           <u>Changed</u>  <u>in</u>  <u>version</u>  <u>0.22:</u> <u>buffers</u> may be an undef variable, buffers beyond EOF are created as empty
           strings instead of being skipped.

       "readlink"
           name = readlink(path);

           Returns undef on error.

       "readlinkat"
           name = readlinkat(dirfd, path);

           Returns undef on error.

       "realpath"
           resolved_path = realpath(path);

           Calls the actual C library fuction realpath() and relies on it to be able to allocate memory for  the
           resolved path automatically (as required by POSIX-2008).

           Returns undef on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.18.</u>

       "remainder"
           rem = remainder(x, y);

           Returns  undef on error.

       "remove"
           ret = remove(path);

           Calls the actual C library function remove().

           Note  that  core  POSIX::remove() fails if <u>path</u> is a symlink to a directory because someone "couldn't
           read  the  plans  right  and  did  a  piss-poor  job  of  putting  it  together"  as  (-d  $_[0])   ?
           CORE::rmdir($_[0]) : CORE::unlink($_[0]). Quote from Armageddon.

           This  could  be fixed like this: "unlink $_[0] or ($!{EISDIR} or $!{EPERM}) and rmdir $_[0]" (correct
           errno check depends on OS), or by using the library call right away.

       "removeat"
           ret = removeat(dirfd, path);

           The removeat() function works exactly like remove() but <u>path</u> is interpreted relative to <u>dirfd</u> as with
           the other <u>*at</u> functions.

           This function is a home-grown non-standard extension only available in this module (to my knowledge).

           <u>New</u> <u>in</u> <u>version</u> <u>0.22.</u>

       "remquo"
           (rem, quo) = remquo(x, y);

           Returns the empty list on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.20.</u>

       "rename"
           ret = rename(old, new);

       "renameat"
           ret = renameat(olddirfd, oldpath, newdirfd, newpath);

       "renameat2"
           ret = renameat(olddirfd, oldpath, newdirfd, newpath, flags=0);

           The renameat2() system call is a Linux-specific extension of renameat() and provides  a  superset  of
           its functionality.

           <u>flags</u> is the bitwise OR of zero or more of "RENAME_EXCHANGE", "RENAME_NOREPLACE", "RENAME_WHITEOUT".

           <u>New</u> <u>in</u> <u>version</u> <u>0.21.</u>

       "rmdir"
           ret = rmdir(path);

           <u>New</u> <u>in</u> <u>version</u> <u>0.19.</u>

       "round"
           r = round(x);

       "scalbn"
           y = scalbn(x, n);

           Calls scalbln() or scalbn(), whichever is the maximum supported by your system.

       "seed48"
           (old_seed1, old_seed2, old_seed3) = seed48(seed1, seed2, seed3);

       "setegid"
           ret = setegid(gid);

       "seteuid"
           ret = seteuid(uid);

       "setgid"
           ret = setgid(gid);

       "setitimer"
           (old_int_sec, old_int_usec, old_val_sec, old_val_usec) = setitimer(which, int_sec, int_usec, val_sec,
           val_usec);

           <u>which</u> is one of "ITIMER_REAL", "ITIMER_VIRTUAL", "ITIMER_PROF".

       "setpriority"
           ret = setpriority(prio, which=PRIO_PROCESS, who=0);

           <u>which</u>  can  be  one  of  "PRIO_PROCESS",  "PRIO_PGRP",  "PRIO_USER",  defaults to "PRIO_PROCESS". <u>who</u>
           defaults to 0.

           Note that due to the support of default values for <u>which</u> and <u>who</u>, <u>prio</u> is the first  call  parameter,
           whereas in the actual syscall it is the last.

           Returns true on success, undef on error.

       "setregid"
           ret = setregid(rgid, egid);

       "setreuid"
           ret = setreuid(ruid, euid);

       "setsid"
           sid = <b>setsid()</b>;

           <u>New</u> <u>in</u> <u>version</u> <u>0.19.</u>

       "setuid"
           ret = setuid(uid);

       "setutxent"
           <b>setutxent()</b>;

       "sighold"
           ret = sighold(sig);

       "sigignore"
           ret = sigignore(sig);

       "signbit"
           b = signbit(x);

       "sigpause"
           sigpause(sig);

       "sigrelse"
           ret = sigrelse(sig);

       "sin"
           y = sin(x);

           <u>New</u> <u>in</u> <u>version</u> <u>0.19.</u>

       "sinh"
           y = sinh(x);

       "srand48"
           srand48(seedval);

       "srandom"
           srandom(seed);

       "stat"
           (dev,  ino,  mode,  nlink,  uid,  gid,  rdev,  size,  atim_sec,  mtim_sec, ctim_sec, blksize, blocks,
           atim_nsec, mtim_nsec, ctim_nsec) = stat(what);

           "what" can be a path, a Perl file handle or a file descriptor.

           "ctim_sec", "blksize", "blocks" and nanoseconds may not be available on your system.  Values  outside
           Perl's  internal integer range are returned as strings, i.e. if you need the exact values you should,
           for example, use "eq" instead of "==" for comparisons.

           Note that CORE::stat() lies to you in some cases: It returns <u>rdev</u> as a signed integer  even  if  your
           OS's  "dev_t"  is unsigned. It returns <u>size</u> as a floating point number if your OS's "off_t" is bigger
           than Perl's integer size. It returns the times as floating point numbers if  your  OS's  "time_t"  is
           unsigned.

           POSIX::2008::stat() doesn't mimic these bugs and uses the correct data types for all values.

           Returns the empty list on error.

       "strptime"
             (sec, min, hour, mday, mon, year, wday, yday, isdst) =
               strptime(s, format[, sec, min, hour, mday, mon, year, wday, yday, isdst]);

             ... = strptime(s, format, \@tm);

           strptime() converts the string <u>s</u> into a broken-down time according to the format string <u>format</u>.

           The  time  fields  may  optionally  be  initialized  in whole or in part either with up to 9 separate
           arguments or with a single array reference after the format.  Omitted arguments are treated as undef.
           In case of an array reference the array is updated according to the fields  affected  by  the  format
           string. If an error occurred the array is not udpated.

           In  list context returns the broken-down time or the empty list on error.  Fields not affected by the
           format string are returned as initialized.

           In scalar context returns the index of the first byte in <u>s</u> that was not processed or the byte  length
           of <u>s</u> if the whole string was consumed or undef on error.

           As strptime() acts on null-terminated strings, strings containing NUL bytes will only be processed up
           to the first NUL byte.

           <u>New</u> <u>in</u> <u>version</u> <u>0.02.</u>

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.24:</u> Accept an array reference as the third argument.

       "symlink"
           ret = symlink(target, linkpath);

       "symlinkat"
           ret = symlinkat(target, dirfd, linkpath);

       "sync"
           <b>sync()</b>;

           This function doesn't return any value.

       "sysconf"
           ret = sysconf(name);

           <u>name</u> is one of the "_SC_*" integer constants.

           Returns undef on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.22.</u>

       "tan"
           y = tan(x);

       "tanh"
           y = tanh(x);

       "tgamma"
           y = tgamma(x);

       "timer_create"
           timerid = timer_create(clockid, signal=undef);

           Creates a new per-process interval timer using the clock given by <u>clock_id</u> as the timing base. <u>signal</u>
           is the signal number to be delivered when the timer expires. If <u>signal</u> is omitted or undef, no signal
           is delivered and the progress of the timer can be monitored using timer_gettime().

           Calling a notification function on timer expiration is currently not supported.

           Returns undef on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.16.</u>

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.22:</u> <u>signal</u> is optional.

       "timer_delete"
           ret = timer_delete(timerid);

           Returns "0 but true" on success, undef on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.16.</u>

       "timer_getoverrun"
           count = timer_getoverrun(timerid);

           Returns undef on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.16.</u>

       "timer_gettime"
           (interval_sec, interval_nsec, initial_sec, initial_nsec) = timer_gettime(timerid);

           Returns the empty list on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.16.</u>

       "timer_settime"
           (old_int_sec,  old_int_nsec,  old_init_sec,  old_init_nsec)  = timer_settime(timerid, flags, int_sec,
           int_nsec, [init_sec, init_nsec]);

           <u>flags</u> may be 0 or "TIMER_ABSTIME". If the <u>init</u> values are omitted, they are set to the <u>int</u> values.

           <u>New</u> <u>in</u> <u>version</u> <u>0.16.</u>

       "truncate"
           ret = truncate(what, length);

           "what" can be a path, a Perl file handle, or a file descriptor.

           Note that it does not flush the file handle before truncating. Perl's built-in <b>truncate()</b> does  (this
           is undocumented, probably because it's silly).

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.19:</u> Deprecated <u>ftruncate</u> now covered by <u>truncate</u>.

       "trunc"
           y = trunc(x);

       "ttyname"
           name = ttyname(fd);

           Calls ttyname_r() if available.

           <u>New</u> <u>in</u> <u>version</u> <u>0.19.</u>

           <u>Changed</u> <u>in</u> <u>version</u> <u>0.22:</u> <u>fd</u> may also be a file handle.

       "unlink"
           ret = unlink(path);

           Calls the actual C library function unlink().

           Note  that  core  POSIX::unlink() calls CORE::unlink(), which, unless you start Perl with "-U", a) is
           prone to time-of-check/time-of-use race conditions due to an additional <b>lstat()</b>, and b) blindly fails
           with "EISDIR" for directories (due to said <b>lstat()</b>), ignoring that some OSes use "EPERM" in this case
           (as required by POSIX).

       "unlinkat"
           ret = unlinkat(dirfd, path, flags=0);

           <u>flags</u> can be 0 or "AT_REMOVEDIR".

       "utimensat"
           ret = utimensat(dirfd, path, flags, atime_sec, atime_nsec, mtime_sec, mtime_nsec);

           <u>flags</u> can be 0 or "AT_SYMLINK_NOFOLLOW", defaults to 0. Your system might support a different set  of
           flags.

           <u>atime_sec</u> and <u>mtime_sec</u> default to 0. <u>atime_nsec</u> and <u>mtime_nsec</u> default to "UTIME_NOW".

       "write"
           bytes_written = write(fd, buf, count=undef);

           Like  POSIX::write()  but returns 0 instead of "0 but true" if 0 bytes were written, and never writes
           more bytes than <u>buf</u> contains even if <u>count</u> exceeds the length of <u>buf</u>.

           If <u>count</u> is omitted or undef, it defaults to the length of <u>buf</u>.

       "writev"
           bytes_written = writev(fd, buffers);

           writev() writes multiple <u>buffers</u> of data to the file associated with the file descriptor <u>fd</u>.

           <u>buffers</u> must be an array reference, i.e. "\@buf", $buf or "[...]". The buffers are processed in array
           order.

           Note that "writev($fh, $buf);" is not the same as "print  $fh,  @$buf;"  or  "syswrite  $fh,  $_  for
           @$buf;" because writev() transfers data atomically as a single block. See the manpage for details.

           Returns the number of bytes written or undef on error.

           <u>New</u> <u>in</u> <u>version</u> <u>0.08.</u>

       "y0"
           y = y0(x);

           y0() is the Bessel function of the second kind of order 0.

       "y1"
           y = y1(x);

           y1() is the Bessel function of the second kind of order 1.

       "yn"
           y = yn(n, x);

           yn() is the Bessel function of the second kind of order n.

</pre><h4><b>EXPORTS</b></h4><pre>
       This module does not export anything by default. The following export tags are available:

        :at      All *at() functions like openat(), all AT_/RENAME_/RESOLVE_ constants
        :id      All get/set*id() functions like getuid() etc.
        :is      All is* functions like isdigit() etc.
        :rw      read(), readv(), write(), writev()
        :prw     pread(), preadv(), preadv2(), pwrite(), pwritev(), pwritev2()
        :clock   All clock* functions and CLOCK_ constants
        :fcntl   All F_, FD_, O_, POSIX_FADV_, SEEK_, _OK constants (for AT_ use :at)
        :fenv_h  All FE_ constants and fe* functions
        :fnm     fnmatch() and all FNM_ constants
        :stat_h  All S_I* and UTIME_ constants
        :time_h  All CLOCK_ and TIMER_ constants
        :timer   All timer_ functions and TIMER_ constants
        :utmpx_h   All *utx* functions and utmpx.h constants
        :confstr   confstr() and all _CS_ constants
        :pathconf  pathconf() and all _PC_ constants
        :sysconf   sysconf() and all _SC_ constants

       <u>New</u> <u>in</u> <u>version</u> <u>0.19:</u> :stat_h export tag.

       <u>New</u> <u>in</u> <u>version</u> <u>0.20:</u> :fenv_h export tag.

       <u>New</u> <u>in</u> <u>version</u> <u>0.22:</u> :confstr, :pathconf, :sysconf export tags.

</pre><h4><b>CONSTANTS</b></h4><pre>
       "AT_EACCESS"    "AT_EMPTY_PATH"    "AT_FDCWD"   "AT_NO_AUTOMOUNT"   "AT_REMOVEDIR"   "AT_RESOLVE_BENEATH"
       "AT_SYMLINK_FOLLOW"   "AT_SYMLINK_NOFOLLOW"   "RENAME_EXCHANGE"   "RENAME_NOREPLACE"    "RENAME_WHITEOUT"
       "RESOLVE_BENEATH"   "RESOLVE_CACHED"   "RESOLVE_IN_ROOT"   "RESOLVE_NO_MAGICLINKS"  "RESOLVE_NO_SYMLINKS"
       "RESOLVE_NO_XDEV"

       "ACCOUNTING" "EMPTY" "BOOT_TIME"  "NEW_TIME"  "OLD_TIME"  "DEAD_PROCESS"  "INIT_PROCESS"  "LOGIN_PROCESS"
       "USER_PROCESS" "RUN_LVL"

       "CLOCK_BOOTTIME"   "CLOCK_HIGHRES"   "CLOCK_MONOTONIC"   "CLOCK_MONOTONIC_COARSE"  "CLOCK_MONOTONIC_FAST"
       "CLOCK_MONOTONIC_PRECISE"     "CLOCK_MONOTONIC_RAW"      "CLOCK_PROCESS_CPUTIME_ID"      "CLOCK_REALTIME"
       "CLOCK_REALTIME_COARSE"       "CLOCK_REALTIME_FAST"       "CLOCK_REALTIME_PRECISE"       "CLOCK_SOFTTIME"
       "CLOCK_THREAD_CPUTIME_ID" "CLOCK_UPTIME" "CLOCK_UPTIME_FAST" "CLOCK_UPTIME_PRECISE"

       "F_DUPFD" "F_DUPFD_CLOEXEC"  "F_GETFD"  "F_SETFD"  "F_GETFL"  "F_SETFL"  "F_GETLK"  "F_SETLK"  "F_SETLKW"
       "F_GETOWN" "F_SETOWN" "F_RDLCK" "F_UNLCK" "F_WRLCK"

       "FD_CLOEXEC"

       "FE_ALL_EXCEPT"  "FE_DIVBYZERO"  "FE_INEXACT"  "FE_INVALID"  "FE_OVERFLOW"  "FE_UNDERFLOW" "FE_TONEAREST"
       "FE_TOWARDZERO" "FE_UPWARD" "FE_DOWNWARD"

       "FNM_CASEFOLD" "FNM_FILE_NAME" "FNM_LEADING_DIR" "FNM_NOESCAPE" "FNM_NOMATCH" "FNM_PATHNAME" "FNM_PERIOD"

       "FP_INFINITE" "FP_NAN" "FP_NORMAL" "FP_SUBNORMAL" "FP_ZERO"

       "TIMER_ABSTIME" "ITIMER_PROF" "ITIMER_REAL" "ITIMER_VIRTUAL"

       "O_ACCMODE" "O_APPEND" "O_ASYNC" "O_CLOEXEC" "O_CREAT" "O_DIRECT" "O_DIRECTORY" "O_DSYNC"  "O_EMPTY_PATH"
       "O_EXCL"  "O_EXEC"  "O_EXLOCK"  "O_LARGEFILE" "O_NDELAY" "O_NOATIME" "O_NOCTTY" "O_NOFOLLOW" "O_NONBLOCK"
       "O_NOSIGPIPE"  "O_PATH"  "O_RDONLY"  "O_REGULAR"  "O_RESOLVE_BENEATH"   "O_RDWR"   "O_RSYNC"   "O_SEARCH"
       "O_SHLOCK" "O_SYNC" "O_TMPFILE" "O_TRUNC" "O_TTY_INIT" "O_WRONLY" "FASYNC"

       "POSIX_FADV_NORMAL"        "POSIX_FADV_SEQUENTIAL"        "POSIX_FADV_RANDOM"        "POSIX_FADV_NOREUSE"
       "POSIX_FADV_WILLNEED" "POSIX_FADV_DONTNEED"

       "PRIO_PROCESS" "PRIO_PGRP" "PRIO_USER"

       "RTLD_DEEPBIND" "RTLD_GLOBAL" "RTLD_LAZY" "RTLD_LOCAL" "RTLD_MEMBER"  "RTLD_NOAUTODEFER"  "RTLD_NODELETE"
       "RTLD_NOLOAD" "RTLD_NOW"

       "RWF_APPEND" "RWF_DSYNC" "RWF_HIPRI" "RWF_NOWAIT" "RWF_SYNC"

       "SEEK_SET" "SEEK_CUR" "SEEK_END" "SEEK_DATA" "SEEK_HOLE" "F_OK" "R_OK" "W_OK" "X_OK"

       "S_IFMT"  "S_IFBLK"  "S_IFCHR"  "S_IFIFO"  "S_IFREG"  "S_IFDIR"  "S_IFLNK" "S_IFSOCK" "S_ISUID" "S_ISGID"
       "S_IRWXU" "S_IRUSR" "S_IWUSR" "S_IXUSR"  "S_IRWXG"  "S_IRGRP"  "S_IWGRP"  "S_IXGRP"  "S_IRWXO"  "S_IROTH"
       "S_IWOTH" "S_IXOTH" "S_ISVTX"

       "UTIME_NOW" "UTIME_OMIT"

       "_CS_GNU_LIBC_VERSION"      "_CS_GNU_LIBPTHREAD_VERSION"      "_CS_LFS64_CFLAGS"      "_CS_LFS64_LDFLAGS"
       "_CS_LFS64_LIBS"     "_CS_LFS64_LINTFLAGS"     "_CS_LFS_CFLAGS"     "_CS_LFS_LDFLAGS"      "_CS_LFS_LIBS"
       "_CS_LFS_LINTFLAGS"   "_CS_PATH"  "_CS_POSIX_V5_WIDTH_RESTRICTED_ENVS"  "_CS_POSIX_V6_ILP32_OFF32_CFLAGS"
       "_CS_POSIX_V6_ILP32_OFF32_LDFLAGS"  "_CS_POSIX_V6_ILP32_OFF32_LIBS"  "_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS"
       "_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS"  "_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS"  "_CS_POSIX_V6_ILP32_OFFBIG_LIBS"
       "_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS" "_CS_POSIX_V6_LP64_OFF64_CFLAGS"  "_CS_POSIX_V6_LP64_OFF64_LDFLAGS"
       "_CS_POSIX_V6_LP64_OFF64_LIBS"   "_CS_POSIX_V6_LP64_OFF64_LINTFLAGS"   "_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS"
       "_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS"                                      "_CS_POSIX_V6_LPBIG_OFFBIG_LIBS"
       "_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS"                                "_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS"
       "_CS_POSIX_V7_ILP32_OFF32_CFLAGS"   "_CS_POSIX_V7_ILP32_OFF32_LDFLAGS"    "_CS_POSIX_V7_ILP32_OFF32_LIBS"
       "_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS"                                   "_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS"
       "_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS"                                      "_CS_POSIX_V7_ILP32_OFFBIG_LIBS"
       "_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS"  "_CS_POSIX_V7_LP64_OFF64_CFLAGS" "_CS_POSIX_V7_LP64_OFF64_LDFLAGS"
       "_CS_POSIX_V7_LP64_OFF64_LIBS"   "_CS_POSIX_V7_LP64_OFF64_LINTFLAGS"   "_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS"
       "_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS"                                      "_CS_POSIX_V7_LPBIG_OFFBIG_LIBS"
       "_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS" "_CS_POSIX_V7_WIDTH_RESTRICTED_ENVS" "_CS_V5_WIDTH_RESTRICTED_ENVS"
       "_CS_V6_ENV"       "_CS_V6_WIDTH_RESTRICTED_ENVS"       "_CS_V7_ENV"       "_CS_V7_WIDTH_RESTRICTED_ENVS"
       "_CS_XBS5_ILP32_OFF32_CFLAGS"          "_CS_XBS5_ILP32_OFF32_LDFLAGS"         "_CS_XBS5_ILP32_OFF32_LIBS"
       "_CS_XBS5_ILP32_OFF32_LINTFLAGS"      "_CS_XBS5_ILP32_OFFBIG_CFLAGS"      "_CS_XBS5_ILP32_OFFBIG_LDFLAGS"
       "_CS_XBS5_ILP32_OFFBIG_LIBS"        "_CS_XBS5_ILP32_OFFBIG_LINTFLAGS"        "_CS_XBS5_LP64_OFF64_CFLAGS"
       "_CS_XBS5_LP64_OFF64_LDFLAGS"         "_CS_XBS5_LP64_OFF64_LIBS"          "_CS_XBS5_LP64_OFF64_LINTFLAGS"
       "_CS_XBS5_LPBIG_OFFBIG_CFLAGS"        "_CS_XBS5_LPBIG_OFFBIG_LDFLAGS"        "_CS_XBS5_LPBIG_OFFBIG_LIBS"
       "_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS"

       "_PC_2_SYMLINKS"   "_PC_ALLOC_SIZE_MIN"    "_PC_ASYNC_IO"    "_PC_CHOWN_RESTRICTED"    "_PC_FILESIZEBITS"
       "_PC_LINK_MAX"    "_PC_MAX_CANON"    "_PC_MAX_INPUT"    "_PC_NAME_MAX"    "_PC_NO_TRUNC"   "_PC_PATH_MAX"
       "_PC_PIPE_BUF"  "_PC_PRIO_IO"  "_PC_REC_INCR_XFER_SIZE"  "_PC_REC_MAX_XFER_SIZE"  "_PC_REC_MIN_XFER_SIZE"
       "_PC_REC_XFER_ALIGN" "_PC_SOCK_MAXBUF" "_PC_SYMLINK_MAX" "_PC_SYNC_IO" "_PC_VDISABLE"

       "_SC_2_CHAR_TERM"   "_SC_2_C_BIND"   "_SC_2_C_DEV"  "_SC_2_C_VERSION"  "_SC_2_FORT_DEV"  "_SC_2_FORT_RUN"
       "_SC_2_LOCALEDEF"   "_SC_2_PBS"    "_SC_2_PBS_ACCOUNTING"    "_SC_2_PBS_CHECKPOINT"    "_SC_2_PBS_LOCATE"
       "_SC_2_PBS_MESSAGE"  "_SC_2_PBS_TRACK"  "_SC_2_SW_DEV"  "_SC_2_UPE"  "_SC_2_VERSION"  "_SC_ADVISORY_INFO"
       "_SC_AIO_LISTIO_MAX"   "_SC_AIO_MAX"   "_SC_AIO_PRIO_DELTA_MAX"    "_SC_ARG_MAX"    "_SC_ASYNCHRONOUS_IO"
       "_SC_ATEXIT_MAX"   "_SC_AVPHYS_PAGES"   "_SC_BARRIERS"   "_SC_BASE"   "_SC_BC_BASE_MAX"  "_SC_BC_DIM_MAX"
       "_SC_BC_SCALE_MAX"    "_SC_BC_STRING_MAX"    "_SC_CHARCLASS_NAME_MAX"    "_SC_CHAR_BIT"    "_SC_CHAR_MAX"
       "_SC_CHAR_MIN"  "_SC_CHILD_MAX"  "_SC_CLK_TCK" "_SC_CLOCK_SELECTION" "_SC_COLL_WEIGHTS_MAX" "_SC_CPUTIME"
       "_SC_C_LANG_SUPPORT" "_SC_C_LANG_SUPPORT_R"  "_SC_DELAYTIMER_MAX"  "_SC_DEVICE_IO"  "_SC_DEVICE_SPECIFIC"
       "_SC_DEVICE_SPECIFIC_R"     "_SC_EQUIV_CLASS_MAX"     "_SC_EXPR_NEST_MAX"     "_SC_FD_MGMT"    "_SC_FIFO"
       "_SC_FILE_ATTRIBUTES"    "_SC_FILE_LOCKING"    "_SC_FILE_SYSTEM"    "_SC_FSYNC"    "_SC_GETGR_R_SIZE_MAX"
       "_SC_GETPW_R_SIZE_MAX"   "_SC_HOST_NAME_MAX"   "_SC_INT_MAX"   "_SC_INT_MIN"   "_SC_IOV_MAX"   "_SC_IPV6"
       "_SC_JOB_CONTROL"   "_SC_LEVEL1_DCACHE_ASSOC"    "_SC_LEVEL1_DCACHE_LINESIZE"    "_SC_LEVEL1_DCACHE_SIZE"
       "_SC_LEVEL1_ICACHE_ASSOC"  "_SC_LEVEL1_ICACHE_LINESIZE" "_SC_LEVEL1_ICACHE_SIZE" "_SC_LEVEL2_CACHE_ASSOC"
       "_SC_LEVEL2_CACHE_LINESIZE" "_SC_LEVEL2_CACHE_SIZE" "_SC_LEVEL3_CACHE_ASSOC"  "_SC_LEVEL3_CACHE_LINESIZE"
       "_SC_LEVEL3_CACHE_SIZE"   "_SC_LEVEL4_CACHE_ASSOC"   "_SC_LEVEL4_CACHE_LINESIZE"  "_SC_LEVEL4_CACHE_SIZE"
       "_SC_LINE_MAX"  "_SC_LOGIN_NAME_MAX"  "_SC_LONG_BIT"  "_SC_MAPPED_FILES"  "_SC_MB_LEN_MAX"  "_SC_MEMLOCK"
       "_SC_MEMLOCK_RANGE" "_SC_MEMORY_PROTECTION" "_SC_MESSAGE_PASSING" "_SC_MINSIGSTKSZ" "_SC_MONOTONIC_CLOCK"
       "_SC_MQ_OPEN_MAX"     "_SC_MQ_PRIO_MAX"     "_SC_MULTI_PROCESS"     "_SC_NETWORKING"    "_SC_NGROUPS_MAX"
       "_SC_NL_ARGMAX"   "_SC_NL_LANGMAX"   "_SC_NL_MSGMAX"   "_SC_NL_NMAX"   "_SC_NL_SETMAX"   "_SC_NL_TEXTMAX"
       "_SC_NPROCESSORS_CONF"  "_SC_NPROCESSORS_ONLN"  "_SC_NZERO" "_SC_OPEN_MAX" "_SC_PAGESIZE" "_SC_PAGE_SIZE"
       "_SC_PASS_MAX"      "_SC_PHYS_PAGES"      "_SC_PII"      "_SC_PII_INTERNET"      "_SC_PII_INTERNET_DGRAM"
       "_SC_PII_INTERNET_STREAM"    "_SC_PII_OSI"    "_SC_PII_OSI_CLTS"    "_SC_PII_OSI_COTS"    "_SC_PII_OSI_M"
       "_SC_PII_SOCKET"  "_SC_PII_XTI"  "_SC_PIPE"  "_SC_POLL"  "_SC_PRIORITIZED_IO"   "_SC_PRIORITY_SCHEDULING"
       "_SC_RAW_SOCKETS"   "_SC_READER_WRITER_LOCKS"   "_SC_REALTIME_SIGNALS"  "_SC_REGEXP"  "_SC_REGEX_VERSION"
       "_SC_RE_DUP_MAX"   "_SC_RTSIG_MAX"   "_SC_SAVED_IDS"   "_SC_SCHAR_MAX"    "_SC_SCHAR_MIN"    "_SC_SELECT"
       "_SC_SEMAPHORES"    "_SC_SEM_NSEMS_MAX"   "_SC_SEM_VALUE_MAX"   "_SC_SHARED_MEMORY_OBJECTS"   "_SC_SHELL"
       "_SC_SHRT_MAX"  "_SC_SHRT_MIN"  "_SC_SIGNALS"  "_SC_SIGQUEUE_MAX"   "_SC_SIGSTKSZ"   "_SC_SINGLE_PROCESS"
       "_SC_SPAWN"   "_SC_SPIN_LOCKS"   "_SC_SPORADIC_SERVER"  "_SC_SSIZE_MAX"  "_SC_SS_REPL_MAX"  "_SC_STREAMS"
       "_SC_STREAM_MAX" "_SC_SYMLOOP_MAX"  "_SC_SYNCHRONIZED_IO"  "_SC_SYSTEM_DATABASE"  "_SC_SYSTEM_DATABASE_R"
       "_SC_THREADS"      "_SC_THREAD_ATTR_STACKADDR"      "_SC_THREAD_ATTR_STACKSIZE"      "_SC_THREAD_CPUTIME"
       "_SC_THREAD_DESTRUCTOR_ITERATIONS"         "_SC_THREAD_KEYS_MAX"         "_SC_THREAD_PRIORITY_SCHEDULING"
       "_SC_THREAD_PRIO_INHERIT"              "_SC_THREAD_PRIO_PROTECT"              "_SC_THREAD_PROCESS_SHARED"
       "_SC_THREAD_ROBUST_PRIO_INHERIT"       "_SC_THREAD_ROBUST_PRIO_PROTECT"       "_SC_THREAD_SAFE_FUNCTIONS"
       "_SC_THREAD_SPORADIC_SERVER"  "_SC_THREAD_STACK_MIN" "_SC_THREAD_THREADS_MAX" "_SC_TIMEOUTS" "_SC_TIMERS"
       "_SC_TIMER_MAX"  "_SC_TRACE"  "_SC_TRACE_EVENT_FILTER"   "_SC_TRACE_EVENT_NAME_MAX"   "_SC_TRACE_INHERIT"
       "_SC_TRACE_LOG"  "_SC_TRACE_NAME_MAX"  "_SC_TRACE_SYS_MAX"  "_SC_TRACE_USER_EVENT_MAX" "_SC_TTY_NAME_MAX"
       "_SC_TYPED_MEMORY_OBJECTS"    "_SC_TZNAME_MAX"     "_SC_T_IOV_MAX"     "_SC_UCHAR_MAX"     "_SC_UINT_MAX"
       "_SC_UIO_MAXIOV"      "_SC_ULONG_MAX"      "_SC_USER_GROUPS"      "_SC_USER_GROUPS_R"     "_SC_USHRT_MAX"
       "_SC_V6_ILP32_OFF32" "_SC_V6_ILP32_OFFBIG" "_SC_V6_LP64_OFF64" "_SC_V6_LPBIG_OFFBIG" "_SC_V7_ILP32_OFF32"
       "_SC_V7_ILP32_OFFBIG"    "_SC_V7_LP64_OFF64"    "_SC_V7_LPBIG_OFFBIG"    "_SC_VERSION"     "_SC_WORD_BIT"
       "_SC_XBS5_ILP32_OFF32"      "_SC_XBS5_ILP32_OFFBIG"     "_SC_XBS5_LP64_OFF64"     "_SC_XBS5_LPBIG_OFFBIG"
       "_SC_XOPEN_CRYPT"          "_SC_XOPEN_ENH_I18N"          "_SC_XOPEN_LEGACY"          "_SC_XOPEN_REALTIME"
       "_SC_XOPEN_REALTIME_THREADS"  "_SC_XOPEN_SHM"  "_SC_XOPEN_STREAMS"  "_SC_XOPEN_UNIX"  "_SC_XOPEN_VERSION"
       "_SC_XOPEN_XCU_VERSION" "_SC_XOPEN_XPG2" "_SC_XOPEN_XPG3" "_SC_XOPEN_XPG4"

</pre><h4><b>NOTES</b></h4><pre>
       removeat() is a home-grown nonstandard extension present only in this module.

       preadv() and pwritev() are nonstandard extensions present in Linux and BSD.

       execveat(), openat2(), preadv2(), pwritev2() and renameat2() are nonstandard extensions present in Linux.

       fstatat(), lstat() and stat() do not set the special underscore filehandle "_" (mostly because I have  no
       clue how that works).

       open(),  openat()  and  openat2() do not set the "O_CLOEXEC" flag automatically. You have to take care of
       that yourself if needed.

       isalnum() and friends were cowardly removed from the POSIX module with Perl 5.24.0.  They  have  found  a
       cozy home here with a fix for a long-standing bug.

       "SEEK_DATA"  and "SEEK_HOLE" are nonstandard extensions present in Linux, Solaris, FreeBSD, and DragonFly
       BSD; they are proposed for inclusion in the next POSIX revision (Issue 8).

       For some inexplicable reason, Perl forbids you to use the built-in chmod() and chown()  on  an  opendir()
       handle  and  to  use readdir() and rewinddir() on a sysopen() handle (provided it refers to a directory).
       Needless to say that chmod() and chown() from POSIX::2008 happily work with  opendir()  handles,  and  of
       course you can use readdir() and rewinddir() on an openat() handle that refers to a directory.

</pre><h4><b>AUTHOR</b></h4><pre>
       Initially hacked together by Carsten Gaebler.

</pre><h4><b>LICENSE</b></h4><pre>
       This  library  is free software. You can redistribute and/or modify it under the terms of the Do What The
       Fuck You Want To Public License, Version 2, as  published  by  Sam  Hocevar.  See  the  COPYING  file  or
       &lt;<a href="http://www.wtfpl.net/">http://www.wtfpl.net/</a>&gt; for more details.

perl v5.40.0                                       2024-10-20                                   <u>POSIX::<a href="../man3pm/2008.3pm.html">2008</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>