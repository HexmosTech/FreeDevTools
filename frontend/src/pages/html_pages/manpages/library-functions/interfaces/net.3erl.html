<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>net - Network interface.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       net - Network interface.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides an API for the network interface.

   <b>Note:</b>
       There is currently <u>no</u> support for Windows.

   <b>Note:</b>
       The  content of this file is <u>only</u> valid if the system has been built with 'socket' (esock) support, which
       is the default.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>address_info()</b> =
           #{family := socket:domain(),
             socktype := socket:type(),
             protocol := socket:protocol(),
             address := socket:sockaddr()}

       <b>ifaddrs()</b> =
           #{name := string(),
             flags := [ifaddrs_flag()],
             addr := socket:sockaddr(),
             netmask := socket:sockaddr(),
             broadaddr := socket:sockaddr(),
             dstaddr := socket:sockaddr()}

              This type defines all addresses (and flags) associated with the interface.

              Not all fields of this map has to be present. The flags field can be used to test for some of  the
              fields. For example <u>broadaddr</u> will only be present if the <u>broadcast</u> flag is present in flags.

       <b>ifaddrs_flag()</b> =
           up | broadcast | debug | loopback | pointopoint | notrailers |
           running | noarp | promisc | master | slave | multicast |
           portsel | automedia | dynamic

       <b>ifaddrs_filter()</b> =
           all | default | inet | inet6 | packet |
           ifaddrs_filter_map() |
           ifaddrs_filter_fun()

                <b>all:</b>
                  All interfaces

                <b>default:</b>
                  Interfaces with address family <u>inetandinet6</u>

                <b>inet</b> <b>|</b> <b>inet6</b> <b>|</b> <b>packet:</b>
                  Interfaces with <u>only</u> the specified address family

       <b>ifaddrs_filter_map()</b> =
           #{family := default | inet | inet6 | packet | all,
             flags := any | [ifaddrs_flag()]}

              The  <u>family</u>  field  can  only  have  the  (above)  specified  values  (and  not  all the values of
              socket:domain()).

              The use of the <u>flags</u> field is that any flag provided must exist for the interface.

              For example, if <u>family</u> is set to <u>inet</u> and <u>flags</u> to <u>[broadcast,</u>  <u>multicast]</u>  only  interfaces  with
              address family <u>inet</u> and the flags <u>broadcast</u> and <u>multicast</u> will be listed.

       <b>ifaddrs_filter_fun()</b> = fun((ifaddrs()) -&gt; boolean())

              For each <u>ifaddrs</u> entry, return either <u>true</u> to keep the entry or <u>false</u> to discard the entry.

              For example, to get an interface list which only contains non-<u>loopback</u> <u>inet</u> interfaces:

                   net:getifaddrs(fun(#{addr  := #{family := inet},
                                        flags := Flags}) -&gt;
                                    not lists:member(loopback, Flags);
                               (_) -&gt;
                                    false
                               end).

       <b>name_info()</b> = #{host := string(), service := string()}

       <b>name_info_flags()</b> = [name_info_flag() | name_info_flag_ext()]

       <b>name_info_flag()</b> =
           namereqd | dgram | nofqdn | numerichost | numericserv

       <b>name_info_flag_ext()</b> = idn

       <b>network_interface_name()</b> = string()

       <b>network_interface_index()</b> = integer() &gt;= 0

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>gethostname()</b> <b>-&gt;</b> <b>{ok,</b> <b>HostName}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 HostName = string()
                 Reason = term()

              Returns the name of the current host.

       <b>getnameinfo(SockAddr)</b> <b>-&gt;</b> <b>{ok,</b> <b>Info}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>getnameinfo(SockAddr,</b> <b>Flags)</b> <b>-&gt;</b> <b>{ok,</b> <b>Info}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SockAddr = socket:sockaddr()
                 Flags = name_info_flags() | undefined
                 Info = name_info()
                 Reason = term()

              Address-to-name translation in a protocol-independant manner.

              This  function is the inverse of <u>getaddrinfo</u>. It converts a socket address to a corresponding host
              and service.

       <b>getaddrinfo(Host)</b> <b>-&gt;</b> <b>{ok,</b> <b>Info}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>getaddrinfo(Host,</b> <b>Service</b> <b>::</b> <b>undefined)</b> <b>-&gt;</b>
                      {ok, Info} | {error, Reason}

       <b>getaddrinfo(Host</b> <b>::</b> <b>undefined,</b> <b>Service)</b> <b>-&gt;</b>
                      {ok, Info} | {error, Reason}

       <b>getaddrinfo(Host,</b> <b>Service)</b> <b>-&gt;</b> <b>{ok,</b> <b>Info}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Host = Service = string()
                 Info = [address_info()]
                 Reason = term()

              Network address and service translation.

              This function is the inverse of <u>getnameinfo</u>. It converts  host  and  service  to  a  corresponding
              socket address.

              One of the <u>Host</u> and <u>Service</u> may be <u>undefined</u> but <u>not</u> both.

       <b>getifaddrs()</b> <b>-&gt;</b> <b>{ok,</b> <b>IfAddrs}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>getifaddrs(Filter)</b> <b>-&gt;</b> <b>{ok,</b> <b>IfAddrs}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>getifaddrs(Namespace)</b> <b>-&gt;</b> <b>{ok,</b> <b>IfAddrs}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>getifaddrs(Filter,</b> <b>Namespace)</b> <b>-&gt;</b> <b>{ok,</b> <b>IfAddrs}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Filter = ifaddrs_filter()
                 Namespace = file:filename_all()
                 IfAddrs = [ifaddrs()]
                 Reason = term()

              Get interface addresses.

              This  function  is  used  to  get the machines interface addresses, possibly filtered according to
              <u>Filter</u>.

              By default, a filter with the content: <u>#{family</u> <u>=&gt;</u> <u>default,</u> <u>flags</u>  <u>=&gt;</u>  <u>any}</u>  is  used.  This  will
              return all interfaces with adresses in the <u>inet</u> and <u>inet6</u> families.

       <b>if_name2index(Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>Idx}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = network_interface_name()
                 Idx = network_interface_index()
                 Reason = term()

              Mappings between network interface names and indexes.

       <b>if_index2name(Idx)</b> <b>-&gt;</b> <b>{ok,</b> <b>Name}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Idx = network_interface_index()
                 Name = network_interface_name()
                 Reason = term()

              Mappings between network interface index and names.

       <b>if_names()</b> <b>-&gt;</b> <b>Names</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Names = [{Idx, If}]
                 Idx = network_interface_index()
                 If = network_interface_name()
                 Reason = term()

              Get network interface names and indexes.

Ericsson AB                                        kernel 8.2                                          <u><a href="../man3erl/net.3erl.html">net</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>