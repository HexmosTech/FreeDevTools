<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ast_mapper - The interface of a -ppx rewriter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Ast_mapper - The interface of a -ppx rewriter

</pre><h4><b>Module</b></h4><pre>
       Module   Ast_mapper

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Ast_mapper</b>
        : <b>sig</b> <b>end</b>

       The interface of a -ppx rewriter

       A -ppx rewriter is a program that accepts a serialized abstract syntax tree and outputs another, possibly
       modified, abstract syntax tree.  This module encapsulates the interface between the compiler and the -ppx
       rewriters,  handling  such  details  as  the  serialization format, forwarding of command-line flags, and
       storing state.

       <b>Ast_mapper.mapper</b> enables AST rewriting using open  recursion.   A  typical  mapper  would  be  based  on
       <b>Ast_mapper.default_mapper</b>  ,  a deep identity mapper, and will fall back on it for handling the syntax it
       does not modify. For example:

       <b>open</b> <b>Asttypes</b>
       <b>open</b> <b>Parsetree</b>
       <b>open</b> <b>Ast_mapper</b>

       <b>let</b> <b>test_mapper</b> <b>argv</b> <b>=</b>
         <b>{</b> <b>default_mapper</b> <b>with</b>
           <b>expr</b> <b>=</b> <b>fun</b> <b>mapper</b> <b>expr</b> <b>-&gt;</b>
             <b>match</b> <b>expr</b> <b>with</b>
             <b>|</b> <b>{</b> <b>pexp_desc</b> <b>=</b> <b>Pexp_extension</b> <b>({</b> <b>txt</b> <b>=</b> <b>"test"</b> <b>},</b> <b>PStr</b> <b>[])}</b> <b>-&gt;</b>
               <b>Ast_helper.Exp.constant</b> <b>(Pconst_integer</b> <b>("42",</b> <b>None))</b>
             <b>|</b> <b>other</b> <b>-&gt;</b> <b>default_mapper.expr</b> <b>mapper</b> <b>other;</b> <b>}</b>

       <b>let</b> <b>()</b> <b>=</b>
         <b>register</b> <b>"ppx_test"</b> <b>test_mapper</b>

       This -ppx rewriter, which replaces <b>[%test]</b> in expressions with the constant <b>42</b> , can  be  compiled  using
       <b>ocamlc</b> <b>-o</b> <b>ppx_test</b> <b>-I</b> <b>+compiler-libs</b> <b>ocamlcommon.cma</b> <b>ppx_test.ml</b> .

       Warning: this module is unstable and part of <b>Compiler_libs</b> .

   <b>A</b> <b>generic</b> <b>Parsetree</b> <b>mapper</b>
       <u>type</u> <u>mapper</u> = {
        attribute : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.attribute</b> <b>-&gt;</b> <b>Parsetree.attribute</b> ;
        attributes : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.attribute</b> <b>list</b> <b>-&gt;</b> <b>Parsetree.attribute</b> <b>list</b> ;
        binding_op : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.binding_op</b> <b>-&gt;</b> <b>Parsetree.binding_op</b> ;
        case : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.case</b> <b>-&gt;</b> <b>Parsetree.case</b> ;
        cases : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.case</b> <b>list</b> <b>-&gt;</b> <b>Parsetree.case</b> <b>list</b> ;
        class_declaration : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.class_declaration</b> <b>-&gt;</b> <b>Parsetree.class_declaration</b> ;
        class_description : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.class_description</b> <b>-&gt;</b> <b>Parsetree.class_description</b> ;
        class_expr : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.class_expr</b> <b>-&gt;</b> <b>Parsetree.class_expr</b> ;
        class_field : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.class_field</b> <b>-&gt;</b> <b>Parsetree.class_field</b> ;
        class_signature : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.class_signature</b> <b>-&gt;</b> <b>Parsetree.class_signature</b> ;
        class_structure : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.class_structure</b> <b>-&gt;</b> <b>Parsetree.class_structure</b> ;
        class_type : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.class_type</b> <b>-&gt;</b> <b>Parsetree.class_type</b> ;
        class_type_declaration  : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.class_type_declaration</b> <b>-&gt;</b> <b>Parsetree.class_type_declaration</b>
       ;
        class_type_field : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.class_type_field</b> <b>-&gt;</b> <b>Parsetree.class_type_field</b> ;
        constant : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.constant</b> <b>-&gt;</b> <b>Parsetree.constant</b> ;
        constructor_declaration       :       <b>mapper</b>       <b>-&gt;</b>        <b>Parsetree.constructor_declaration</b>        <b>-&gt;</b>
       <b>Parsetree.constructor_declaration</b> ;
        directive_argument : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.directive_argument</b> <b>-&gt;</b> <b>Parsetree.directive_argument</b> ;
        expr : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.expression</b> <b>-&gt;</b> <b>Parsetree.expression</b> ;
        extension : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.extension</b> <b>-&gt;</b> <b>Parsetree.extension</b> ;
        extension_constructor : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.extension_constructor</b> <b>-&gt;</b> <b>Parsetree.extension_constructor</b> ;
        include_declaration : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.include_declaration</b> <b>-&gt;</b> <b>Parsetree.include_declaration</b> ;
        include_description : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.include_description</b> <b>-&gt;</b> <b>Parsetree.include_description</b> ;
        label_declaration : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.label_declaration</b> <b>-&gt;</b> <b>Parsetree.label_declaration</b> ;
        location : <b>mapper</b> <b>-&gt;</b> <b>Location.t</b> <b>-&gt;</b> <b>Location.t</b> ;
        module_binding : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.module_binding</b> <b>-&gt;</b> <b>Parsetree.module_binding</b> ;
        module_declaration : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.module_declaration</b> <b>-&gt;</b> <b>Parsetree.module_declaration</b> ;
        module_substitution : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.module_substitution</b> <b>-&gt;</b> <b>Parsetree.module_substitution</b> ;
        module_expr : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.module_expr</b> <b>-&gt;</b> <b>Parsetree.module_expr</b> ;
        module_type : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.module_type</b> <b>-&gt;</b> <b>Parsetree.module_type</b> ;
        module_type_declaration        :        <b>mapper</b>       <b>-&gt;</b>       <b>Parsetree.module_type_declaration</b>       <b>-&gt;</b>
       <b>Parsetree.module_type_declaration</b> ;
        open_declaration : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.open_declaration</b> <b>-&gt;</b> <b>Parsetree.open_declaration</b> ;
        open_description : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.open_description</b> <b>-&gt;</b> <b>Parsetree.open_description</b> ;
        pat : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.pattern</b> <b>-&gt;</b> <b>Parsetree.pattern</b> ;
        payload : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.payload</b> <b>-&gt;</b> <b>Parsetree.payload</b> ;
        signature : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.signature</b> <b>-&gt;</b> <b>Parsetree.signature</b> ;
        signature_item : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.signature_item</b> <b>-&gt;</b> <b>Parsetree.signature_item</b> ;
        structure : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.structure</b> <b>-&gt;</b> <b>Parsetree.structure</b> ;
        structure_item : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.structure_item</b> <b>-&gt;</b> <b>Parsetree.structure_item</b> ;
        toplevel_directive : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.toplevel_directive</b> <b>-&gt;</b> <b>Parsetree.toplevel_directive</b> ;
        toplevel_phrase : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.toplevel_phrase</b> <b>-&gt;</b> <b>Parsetree.toplevel_phrase</b> ;
        typ : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.core_type</b> <b>-&gt;</b> <b>Parsetree.core_type</b> ;
        type_declaration : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.type_declaration</b> <b>-&gt;</b> <b>Parsetree.type_declaration</b> ;
        type_extension : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.type_extension</b> <b>-&gt;</b> <b>Parsetree.type_extension</b> ;
        type_exception : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.type_exception</b> <b>-&gt;</b> <b>Parsetree.type_exception</b> ;
        type_kind : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.type_kind</b> <b>-&gt;</b> <b>Parsetree.type_kind</b> ;
        value_binding : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.value_binding</b> <b>-&gt;</b> <b>Parsetree.value_binding</b> ;
        value_description : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.value_description</b> <b>-&gt;</b> <b>Parsetree.value_description</b> ;
        with_constraint : <b>mapper</b> <b>-&gt;</b> <b>Parsetree.with_constraint</b> <b>-&gt;</b> <b>Parsetree.with_constraint</b> ;
        }

       A mapper record implements one "method" per syntactic category,  using  an  open  recursion  style:  each
       method takes as its first argument the mapper to be applied to children in the syntax tree.

       <u>val</u> <u>default_mapper</u> : <b>mapper</b>

       A default mapper, which implements a "deep identity" mapping.

   <b>Apply</b> <b>mappers</b> <b>to</b> <b>compilation</b> <b>units</b>
       <u>val</u> <u>tool_name</u> : <b>unit</b> <b>-&gt;</b> <b>string</b>

       Can be used within a ppx preprocessor to know which tool is calling it <b>"ocamlc"</b> , <b>"ocamlopt"</b> , <b>"ocamldoc"</b>
       ,  <b>"ocamldep"</b>  , <b>"ocaml"</b> , ...  Some global variables that reflect command-line options are automatically
       synchronized  between   the   calling   tool   and   the   ppx   preprocessor:   <b>Clflags.include_dirs</b>   ,
       <b>Clflags.hidden_include_dirs</b> , <b>Load_path</b> , <b>Clflags.open_modules</b> , <b>Clflags.for_package</b> , <b>Clflags.debug</b> .

       <u>val</u> <u>apply</u> : <b>source:string</b> <b>-&gt;</b> <b>target:string</b> <b>-&gt;</b> <b>mapper</b> <b>-&gt;</b> <b>unit</b>

       Apply a mapper (parametrized by the unit name) to a dumped parsetree found in the <b>source</b> file and put the
       result  in  the  <b>target</b>  file.  The  <b>structure</b>  or  <b>signature</b>  field  of  the  mapper  is  applied to the
       implementation or interface.

       <u>val</u> <u>run_main</u> : <b>(string</b> <b>list</b> <b>-&gt;</b> <b>mapper)</b> <b>-&gt;</b> <b>unit</b>

       Entry point to call to implement a standalone -ppx rewriter from a mapper, parametrized  by  the  command
       line  arguments.   The  current  unit  name  can  be  obtained  from <b>Location.input_name</b> .  This function
       implements proper error reporting for uncaught exceptions.

   <b>Registration</b> <b>API</b>
       <u>val</u> <u>register_function</u> : <b>(string</b> <b>-&gt;</b> <b>(string</b> <b>list</b> <b>-&gt;</b> <b>mapper)</b> <b>-&gt;</b> <b>unit)</b> <b>ref</b>

       <u>val</u> <u>register</u> : <b>string</b> <b>-&gt;</b> <b>(string</b> <b>list</b> <b>-&gt;</b> <b>mapper)</b> <b>-&gt;</b> <b>unit</b>

       Apply the <b>register_function</b> .  The default behavior is to run the mapper  immediately,  taking  arguments
       from  the  process command line.  This is to support a scenario where a mapper is linked as a stand-alone
       executable.

       It is possible to overwrite the <b>register_function</b> to define "-ppx drivers", which combine several mappers
       in  a  single  process.   Typically,  a  driver  starts  by  defining  <b>register_function</b>  to   a   custom
       implementation,  then lets ppx rewriters (linked statically or dynamically) register themselves, and then
       run all or some of them.  It is also possible to have -ppx drivers apply rewriters to only specific parts
       of an AST.

       The first argument to <b>register</b> is a symbolic name to be used by the ppx driver.

   <b>Convenience</b> <b>functions</b> <b>to</b> <b>write</b> <b>mappers</b>
       <u>val</u> <u>map_opt</u> : <b>('a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>option</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       <u>val</u> <u>extension_of_error</u> : <b>Location.error</b> <b>-&gt;</b> <b>Parsetree.extension</b>

       Encode an error into an 'ocaml.error' extension node which can be inserted in a generated Parsetree.  The
       compiler will be responsible for reporting the error.

       <u>val</u> <u>attribute_of_warning</u> : <b>Location.t</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>Parsetree.attribute</b>

       Encode a warning message into an 'ocaml.ppwarning'  attribute  which  can  be  inserted  in  a  generated
       Parsetree.  The compiler will be responsible for reporting the warning.

   <b>Helper</b> <b>functions</b> <b>to</b> <b>call</b> <b>external</b> <b>mappers</b>
       <u>val</u> <u>add_ppx_context_str</u> : <b>tool_name:string</b> <b>-&gt;</b> <b>Parsetree.structure</b> <b>-&gt;</b> <b>Parsetree.structure</b>

       Extract  information  from  the current environment and encode it into an attribute which is prepended to
       the list of structure items in order to pass the information to an external processor.

       <u>val</u> <u>add_ppx_context_sig</u> : <b>tool_name:string</b> <b>-&gt;</b> <b>Parsetree.signature</b> <b>-&gt;</b> <b>Parsetree.signature</b>

       Same as <b>add_ppx_context_str</b> , but for signatures.

       <u>val</u> <u>drop_ppx_context_str</u> : <b>restore:bool</b> <b>-&gt;</b> <b>Parsetree.structure</b> <b>-&gt;</b> <b>Parsetree.structure</b>

       Drop the ocaml.ppx.context attribute from a structure.  If <b>restore</b> is true, also restore  the  associated
       data in the current process.

       <u>val</u> <u>drop_ppx_context_sig</u> : <b>restore:bool</b> <b>-&gt;</b> <b>Parsetree.signature</b> <b>-&gt;</b> <b>Parsetree.signature</b>

       Same as <b>drop_ppx_context_str</b> , but for signatures.

   <b>Cookies</b>
       Cookies  are used to pass information from a ppx processor to a further invocation of itself, when called
       from the OCaml toplevel (or other tools that support cookies).

       <u>val</u> <u>set_cookie</u> : <b>string</b> <b>-&gt;</b> <b>Parsetree.expression</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>get_cookie</u> : <b>string</b> <b>-&gt;</b> <b>Parsetree.expression</b> <b>option</b>

OCamldoc                                           2025-06-12                                     <u><a href="../man3o/Ast_mapper.3o.html">Ast_mapper</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>