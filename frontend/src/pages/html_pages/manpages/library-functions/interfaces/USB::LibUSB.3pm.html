<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USB::LibUSB - Perl interface to the libusb-1.0 API.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libusb-libusb-perl">libusb-libusb-perl_0.09-3build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       USB::LibUSB - Perl interface to the libusb-1.0 API.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use USB::LibUSB;

        #
        # simple program to list all devices on the USB
        #

        my $ctx = USB::LibUSB-&gt;init();
        my @devices = $ctx-&gt;get_device_list();

        for my $dev (@devices) {
            my $bus_number = $dev-&gt;get_bus_number();
            my $device_address = $dev-&gt;get_device_address();
            my $desc = $dev-&gt;get_device_descriptor();
            my $idVendor = $desc-&gt;{idVendor};
            my $idProduct = $desc-&gt;{idProduct};

            printf("Bus %03d Device %03d: ID %04x:%04x\n", $bus_number,
                   $device_address, $idVendor, $idProduct);
        }

        #
        # Synchronous bulk transfers
        #

        my $ctx = USB::LibUSB-&gt;init();
        my $handle = $ctx-&gt;open_device_with_vid_pid(0x1111, 0x2222);

        $handle-&gt;<a href="../man1/set_auto_detach_kernel_driver.1.html">set_auto_detach_kernel_driver</a>(1); # Linux only

        # We want to use interface 0
        $handle-&gt;<a href="../man0/claim_interface.0.html">claim_interface</a>(0);

        $handle-&gt;bulk_transfer_write($endpoint, $data, $timeout);
        my $data = $handle-&gt;bulk_transfer_read($endpoint, $length, $timeout);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides a Perl interface to the libusb-1.0 API.  It provides access to most basic libusb
       functionality including read-out of device descriptors and synchronous device I/O.

       Staying as close as possible to the libusb-1.0 API, this module adds convenient error handling and
       additional high-level functionality (e.g. device discovery with vid, pid and serial number). Easy to
       build more functionality without knowing about XS.

</pre><h4><b>INSTALLATION</b></h4><pre>
   <b>Prerequisites</b>
       <u>Linux/UNIX</u>

       This requires libusb (&gt;= 1.0.17) development files and pkg-config installed.

       On Debian like <b>Linux</b>:

        $ apt-get install libusb-1.0-0-dev pkg-config

       On Cygwin &lt;https://www.cygwin.com/&gt; you need the pkg-config, libusb1.0-devel and libcrypt-devel packages.

       <u>Windows</u>

       On Windows you have to manually download the libusb binaries from &lt;<a href="http://libusb.info">http://libusb.info</a>&gt; and extract them
       somewhere.

       Assuming that the location of the extracted libusb folder is <u>C:\Users\simon\libusb-1.0</u>, you need to set
       the "USB_LIBUSB_INCLUDE" and "USB_LIBUSB_LIB" environment variables as follows:

        &gt; SET USB_LIBUSB_INCLUDE=-IC:\Users\simon\libusb-1.0\include\libusb-1.0
        &gt; SET USB_LIBUSB_LIB=-lC:\Users\simon\libusb-1.0\MinGW64\dll\libusb-1.0.dll.a

       You will also need to add

        C:\Users\simon\libusb-1.0\MinGW64\dll

       to the <b>Path</b> environment variable.

       For StrawberryPerl, version 5.26 or newer is required (see
       &lt;https://rt.cpan.org/Public/Bug/Display.html?id=121219&gt;).

       Driver Installation

       On Windows you need an additional driver to use a device with libusb. See the Windows
       &lt;https://github.com/libusb/libusb/wiki/Windows&gt; section in the libusb wiki.

   <b>Building</b> <b>USB::LibUSB</b>
       The rest of the installation can be done by a CPAN client like cpanm:

        $ cpanm USB::LibUSB

</pre><h4><b>METHODS/FUNCTIONS</b></h4><pre>
   <b>Library</b> <b>initialization/deinitialization</b>
       <u>set_debug</u>

        $ctx-&gt;set_debug(LIBUSB_LOG_LEVEL_DEBUG);

       <u>init</u>

        my $ctx = USB::LibUSB-&gt;init();

       <u>exit</u>

        $ctx-&gt;exit();

       <u>last_retval</u>

        my $retval = $ctx-&gt;last_retval();

       Get return value of last called libusb function.

   <b>Device</b> <b>handling</b> <b>and</b> <b>enumeration</b>
       <u>get_device_list</u>

        my @device_list = $ctx-&gt;get_device_list();

       Returned elements are USB::LibUSB::Device objects.

       <u>get_bus_number</u>

        my $bus_number = $dev-&gt;get_bus_number();

       <u>get_port_number</u>

        my $port_number = $dev-&gt;get_port_number();

       <u>get_port_numbers</u>

        my @port_numbers = $dev-&gt;get_port_numbers();

       <u>get_parent</u>

        my $parent_dev = $dev-&gt;get_parent();

       <u>get_device_address</u>

        my $address = $dev-&gt;get_device_address();

       <u>get_device_speed</u>

        my $speed = $dev-&gt;get_device_speed();

       <u>get_max_packet_size</u>

        my $size = $dev-&gt;get_max_packet_size($endpoint);

       <u>get_max_iso_packet_size</u>

        my $size = $dev-&gt;get_max_iso_packet_size($endpoint);

       <u>ref_device</u>

        $dev-&gt;ref_device();

       <u>unref_device</u>

        $dev-&gt;unref_device();

       <u>open</u>

        my $handle = $dev-&gt;open();

       Return a USB::LibUSB::Device::Handle object.

       <u>open_device_with_vid_pid</u>

        my $handle = $ctx-&gt;open_device_with_vid_pid(0x1111, 0x2222);

       Return a USB::LibUSB::Device::Handle object. If the vid:pid combination is not unique, return the first
       device which is found.

       <u>open_device_with_vid_pid_unique</u>

        my $handle = $ctx-&gt;open_device_with_vid_pid_unique(0x1111, 0x2222);

       Like "open_device_with_vid_pid", but croak in case of multiple devices with this vid:pid combination.

       <u>open_device_with_vid_pid_serial</u>

        my $handle = $ctx-&gt;open_device_with_vid_pid_serial(0x0957, 0x0607, "MY47000419");

       Like "open_device_with_vid_pid", but also requires a serial number.

       <u>close</u>

        $handle-&gt;close();

       <u>get_device</u>

        my $dev = $handle-&gt;get_device();

       <u>get_configuration</u>

        my $config = $handle-&gt;get_configuration();

       <u>set_configuration</u>

        $handle-&gt;set_configuration($config);

       <u>claim_interface</u>

        $handle-&gt;claim_interface($interface_number);

       <u>release_interface</u>

        $handle-&gt;release_interface($interface_number);

       <u>set_interface_alt_setting</u>

        $handle-&gt;set_interface_alt_setting($interface_number, $alternate_setting);

       <u>clear_halt</u>

        $handle-&gt;clear_halt($endpoint);

       <u>reset_device</u>

        $handle-&gt;reset_device();

       <u>kernel_driver_active</u>

        my $is_active = $handle-&gt;kernelt_driver_active($interface_number);

       <u>detach_kernel_driver</u>

        $handle-&gt;detach_kernel_driver($interface_number);

       <u>attach_kernel_driver</u>

        $handle-&gt;attach_kernel_driver($interface_number);

       <u>set_auto_detach_kernel_driver</u>

        $handle-&gt;set_auto_detach_kernel_driver($enable);

       Throws exception on Windows and Darwin.

   <b>Miscellaneous</b>
       <u>libusb_has_capability</u>

        my $has_cap = libusb_has_capability($capability);

       <u>libusb_error_name</u>

        my $error_name = libusb_error_name($error_code);

       <u>libusb_get_version</u>

        my $version_hash = libusb_get_version();

       Return hashref $version_hash with the following keys:

       major
       minor
       micro
       nano
       rc

       <u>libusb_setlocale</u>

        my $rv = libusb_setlocale($locale);

       <u>libusb_strerror</u>

        my $strerror = libusb_strerror($error_code);

   <b>USB</b> <b>descriptors</b>
       All descriptors are returned as hash references.

       <u>get_device_descriptor</u>

        my $desc = $dev-&gt;get_device_descriptor();

       Return hashref $desc with the following keys

       bLength
       bDescriptorType
       bcdUSB
       bDeviceClass
       bDeviceSubClass
       bDeviceProtocol
       bMaxPacketSize0
       idVendor
       idProduct
       bcdDevice
       iManufacturer
       iProduct
       iSerialNumber
       bNumConfigurations

       All keys hold a scalar value.

       <u>get_active_config_descriptor</u>

        my $config = $dev-&gt;get_active_config_descriptor();

       Return hashref $config with the following keys:

       bLength
       bDescriptorType
       wTotalLength
       bNumInterfaces
       bConfigurationValue
       iConfiguration
       bmAttributes
       MaxPower
       interface
       extra

       With  the  exception of <b>interface</b>, all values are scalars.  <b>interface</b> holds an arrayref of bNumInterfaces
       interface descriptors. Each interface consists of an array of alternate settings. These are hashrefs with
       the following keys:

       bLength
       bDescriptorType
       bInterfaceNumber
       bAlternateSetting
       bNumEndpoints
       bInterfaceClass
       bInterfaceSubClass
       bInterfaceProtocol
       iInterface
       endpoint
       extra

       With the exception of <b>endpoint</b>,  all  values  are  scalars.   <b>endpoint</b>  holds  an  arrayref  of  endpoint
       descriptors. These are hashrefs with the following keys:

       bLength
       bDescriptorType
       bEndpointAddress
       bmAttributes
       wMaxPacketSize
       bInterval
       bRefresh
       bSynchAddress
       extra

       All  values  are  scalars.  If  the  endpoint  supports  USB  3.0 SuperSpeed, the hashref will contain an
       additional key "superspeed" which holds a SuperSpeed Endpoint Companion  descriptor  with  the  following
       keys:

       bLength
       bDescriptorType
       bMaxBurst
       bmAttributes
       wBytesPerInterval

       Example

       Dump $config with YAML::XS:

        use YAML::XS;
        print Dump($config);

       For a <b>Linux</b> <b>Foundation</b> <b>3.0</b> <b>root</b> <b>hub</b>:

        ---
        MaxPower: 0
        bConfigurationValue: 1
        bDescriptorType: 2
        bLength: 9
        bNumInterfaces: 1
        bmAttributes: 224
        extra: ~
        iConfiguration: 0
        interface:
        - - bAlternateSetting: 0
            bDescriptorType: 4
            bInterfaceClass: 9
            bInterfaceNumber: 0
            bInterfaceProtocol: 0
            bInterfaceSubClass: 0
            bLength: 9
            bNumEndpoints: 1
            endpoint:
            - bDescriptorType: 5
              bEndpointAddress: 129
              bInterval: 12
              bLength: 7
              bRefresh: 0
              bSynchAddress: 0
              bmAttributes: 3
              extra: "\x060\0\0\x02\0"
              ss_endpoint_companion:
                bDescriptorType: 48
                bLength: 6
                bMaxBurst: 0
                bmAttributes: 0
                wBytesPerInterval: 2
              wMaxPacketSize: 4
            extra: ~
            iInterface: 0
        wTotalLength: 31

       <u>get_config_descriptor</u>

        my $config = $dev-&gt;get_config_descriptor($config_index);

       Return config descriptor as hashref.

       <u>get_config_descriptor_by_value</u>

        my $config = $dev-&gt;get_config_descriptor_by_value($bConfigurationValue);

       Return config descriptor as hashref.

       <u>get_bos_descriptor</u>

        my $bos = $handle-&gt;get_bos_descriptor();

       Return BOS descriptor as hashref with the following keys:

       bLength
       bDescriptorType
       wTotalLength
       bNumDeviceCaps
       dev_capability

       "dev_capability" holds an arrayref of BOS Device Capability descriptors. They have the following keys:

       bLength
       bDescriptorType
       bDevCapabilityType
       dev_capability_data

       Additional  parsing  of the capability data is performed if "bDevCapabilityType" has one of the following
       values:

       LIBUSB_BT_USB_2_0_EXTENSION
           The hashref will contain a key "usb_2_0_extension".

       LIBUSB_BT_SS_USB_DEVICE_CAPABILITY
           The hashref will contain a key "ss_usb_device_capability".

       LIBUSB_BT_CONTAINER_ID
           The hashref will contain a key "container_id".

       Example

       Dump $bos with YAML::XS:

        use YAML::XS;
        print Dump($bos);

       For a <b>Linux</b> <b>Foundation</b> <b>3.0</b> <b>root</b> <b>hub</b>:

        bDescriptorType: 15
        bLength: 5
        bNumDeviceCaps: 1
        dev_capability:
        - bDescriptorType: 16
          bDevCapabilityType: 3
          bLength: 10
          dev_capability_data: "\x02\b\0\x03\0\0\0"
          ss_usb_device_capability:
            bDescriptorType: 16
            bDevCapabilityType: 3
            bFunctionalitySupport: 3
            bLength: 10
            bU1DevExitLat: 0
            bU2DevExitLat: 0
            bmAttributes: 2
            wSpeedSupported: 8
        wTotalLength: 15

       <u>get_string_descriptor_ascii</u>

        my $data = $handle-&gt;get_string_descriptor_ascii($desc_index, $length);

       <u>get_descriptor</u>

        my $data = $handle-&gt;get_descriptor($desc_type, $desc_index, $length);

       <u>get_string_descriptor</u>

        my $data = $handle-&gt;get_string_descriptor($desc_index, $langid, $length);

   <b>Device</b> <b>hotplug</b> <b>event</b> <b>notification</b>
       To be implemented.

   <b>Asynchronous</b> <b>device</b> <b>I/O</b>
       To be implemented.

   <b>Polling</b> <b>and</b> <b>timing</b>
       To be implemented.

   <b>Synchronous</b> <b>device</b> <b>I/O</b>
       <u>control_transfer_write</u>

        $handle-&gt;control_transfer_write($bmRequestType, $bRequest, $wValue, $wIndex, $data, $timeout);

       <u>control_transfer_read</u>

        my $data = $handle-&gt;control_transfer_read($bmRequestType, $bRequest, $wValue, $wIndex, $length, $timeout);

       <u>bulk_tranfer_write</u>

        my $transferred = $handle-&gt;bulk_transfer_write($endpoint, $data, $timeout);

       <u>bulk_transfer_read</u>

        my $data = $handle-&gt;bulk_transfer_read($endpoint, $length, $timeout);

       <u>interrupt_transfer_write</u>

        my $transferred = $handle-&gt;interrupt_transfer_write($endpoint, $data, $timeout);

       <u>interrupt_transfer_read</u>

        my $data = $handle-&gt;interrupt_transfer_read($endpoint, $length, $timeout);

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Please report bugs at &lt;https://github.com/lab-measurement/USB-LibUSB/issues&gt;.

</pre><h4><b>CONTACT</b></h4><pre>
       Feel free to contact us at the #labmeasurement channel on Freenode IRC.

</pre><h4><b>AUTHOR</b></h4><pre>
       Simon Reinhardt, &lt;<a href="mailto:simon.reinhardt@physik.uni-r.de">simon.reinhardt@physik.uni-r.de</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2017 by Simon Reinhardt

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself,  either  Perl  version  5.24.0  or,  at  your  option,  any  later version of Perl 5 you may have
       available.

perl v5.40.0                                       2024-10-20                                   <u>USB::<a href="../man3pm/LibUSB.3pm.html">LibUSB</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>