<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>snmpm - Interface functions to the SNMP toolkit manager</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       snmpm - Interface functions to the SNMP toolkit manager

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The module <u>snmpm</u> contains interface functions to the SNMP manager.

</pre><h4><b>COMMON</b> <b>DATA</b> <b>TYPES</b></h4><pre>
       The following data types are used in the functions below:

       oid() = [byte()]  -  The oid() type is used to represent an ASN.1 OBJECT IDENTIFIER
       snmp_reply() = {error_status(), error_index(), varbinds()}
       error_status() = noError | atom()
       error_index() = integer()
       varbinds() = [varbind()]
       atl_type() = read | write | read_write
       target_name() = string()  -  Is a unique *non-empty* string
       vars_and_vals() = [var_and_val()]
       var_and_val() = {oid(), value_type(), value()} | {oid(), value()}
       value_type() = o ('OBJECT IDENTIFIER') |
                      i ('INTEGER') |
                      u ('Unsigned32') |
                      g ('Unsigned32') |
                      s ('OCTET SRING') |
                      b ('BITS') |
                      ip ('IpAddress') |
                      op ('Opaque') |
                      c32 ('Counter32') |
                      c64 ('Counter64') |
                      tt ('TimeTicks')
       value() = term()
       community() = string()
       sec_model() = any | v1 | v2c | usm
       sec_name() = string()
       sec_level() = noAuthNoPriv | authNoPriv | authPriv

       See also the  data types in <u>snmpa_conf</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>monitor()</b> <b>-&gt;</b> <b>Ref</b>

              Types:

                 Ref = reference()

              Monitor  the  SNMP manager. In case of a crash, the calling (monitoring) process will get a 'DOWN'
              message (see the erlang module for more info).

       <b>demonitor(Ref)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Ref = reference()

              Turn off monitoring of the SNMP manager.

       <b>notify_started(Timeout)</b> <b>-&gt;</b> <b>Pid</b>

              Types:

                 Timeout = integer()
                 Pid = pid()

              Request a notification (message) when the SNMP manager has started.

              The <u>Timeout</u> is the time the request is valid. The value has to be greater then zero.

              The <u>Pid</u> is the process handling the supervision of the SNMP manager start. When  the  manager  has
              started  a  completion message will be sent to the client from this process: <u>{snmpm_started,</u> <u>Pid}</u>.
              If the SNMP manager was not started in time, a  timeout  message  will  be  sent  to  the  client:
              <u>{snmpm_start_timeout,</u> <u>Pid}</u>.

              A  client  application that is dependent on the SNMP manager will use this function in order to be
              notified of when the manager has started. There are two situations when this is useful:

                * During the start of a system, when a client application <u>could</u> start prior to the SNMP  manager
                  but is dependent upon it, and therefor has to wait for it to start.

                * When  the  SNMP manager has crashed, the dependent client application has to wait for the SNMP
                  manager to be restarted before it can <u>reconnect</u>.

              The function returns the pid() of a handler process, that does the supervision on  behalf  of  the
              client application. Note that the client application is linked to this handler.

              This function is used in conjunction with the monitor function.

       <b>cancel_notify_started(Pid)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Pid = pid()

              Cancel a previous request to be notified of SNMP manager start.

       <b>register_user(Id,</b> <b>Module,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>register_user(Id,</b> <b>Module,</b> <b>Data,</b> <b>DefaultAgentConfig)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Id = term()
                 Module = snmpm_user()
                 Data = term()
                 DefaultAgentConfig = [default_agent_config()]
                 default_agent_config() = {Item, Val}
                 Item = community | timeout | max_message_size | version | sec_model | sec_name | sec_level
                 Val = term()
                 Reason = term()
                 snmpm_user() = Module implementing the snmpm_user behaviour

              Register the manager entity (=user) responsible for specific agent(s).

              <u>Module</u>  is  the  callback  module  (snmpm_user  behaviour) which will be called whenever something
              happens (detected agent, incoming reply or incoming trap/notification). Note that this could  have
              already been done as a consequence of the node config. (see users.conf).

              The argument <u>DefaultAgentConfig</u> is used as default values when this user register agents.

              The type of <u>Val</u> depends on <u>Item</u>:

              community = string()
              timeout = integer() | snmp_timer()
              max_message_size = integer()
              version = v1 | v2 | v3
              sec_model = any | v1 | v2c | usm
              sec_name = string()
              sec_level = noAuthNoPriv | authNoPriv | authPriv

       <b>register_user_monitor(Id,</b> <b>Module,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>register_user_monitor(Id,</b> <b>Module,</b> <b>Data,</b> <b>DefaultAgentConfig)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Id = term()
                 Module = snmpm_user()
                 DefaultAgentConfig = [default_agent_config()]
                 default_agent_config() = {Item, Val}
                 Item = community | timeout | max_message_size | version | sec_model | sec_name | sec_level
                 Val = term()
                 Data = term()
                 Reason = term()
                 snmpm_user() = Module implementing the snmpm_user behaviour

              Register the monitored manager entity (=user) responsible for specific agent(s).

              The process performing the registration will be monitored. Which means that if that process should
              die,  all  agents  registered  by that user process will be unregistered. All outstanding requests
              will be canceled.

              <u>Module</u> is the callback module (snmpm_user behaviour)  which  will  be  called  whenever  something
              happens  (detected agent, incoming reply or incoming trap/notification). Note that this could have
              already been done as a consequence of the node config. (see users.conf).

              The argument <u>DefaultAgentConfig</u> is used as default values when this user register agents.

              The type of <u>Val</u> depends on <u>Item</u>:

              community = string()
              timeout = integer() | snmp_timer()
              max_message_size = integer()
              version = v1 | v2 | v3
              sec_model = any | v1 | v2c | usm
              sec_name = string()
              sec_level = noAuthNoPriv | authNoPriv | authPriv

       <b>unregister_user(Id)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Id = term()

              Unregister the user.

       <b>which_users()</b> <b>-&gt;</b> <b>Users</b>

              Types:

                 Users = [UserId]
                 UserId = term()

              Get a list of the identities of all registered users.

       <b>register_agent(UserId,</b> <b>TargetName,</b> <b>Config)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 TargetName = target_name()
                 Config = [agent_config()]
                 agent_config() = {Item, Val}
                 Item = engine_id | address | port  |  community  |  timeout  |  max_message_size  |  version  |
                 sec_model | sec_name | sec_level | tdomain
                 Val = term()
                 Reason = term()

              Explicitly instruct the manager to handle this agent, with <u>UserId</u> as the responsible user.

              Called  to  instruct  the manager that this agent shall be handled. This function is used when the
              user knows in advance which agents the manager shall handle. Note that there is an  alternate  way
              to do the same thing: Add the agent to the manager config files (see agents.conf).

              <u>TargetName</u> is a non-empty string, uniquely identifying the agent.

              The type of <u>Val</u> depends on <u>Item</u>:

              [mandatory] engine_id = string()
              [mandatory] tadress = transportAddress()  % Depends on tdomain
              [optional]  port = inet:port_number()
              [optional]  tdomain = transportDomain()
              [optional]  community = string()
              [optional]  timeout = integer() | snmp_timer()
              [optional]  max_message_size = integer()
              [optional]  version = v1 | v2 | v3
              [optional]  sec_model = any | v1 | v2c | usm
              [optional]  sec_name = string()
              [optional]  sec_level = noAuthNoPriv | authNoPriv | authPriv

              Note that if no <u>tdomain</u> is given, the default value, <u>transportDomainUdpIpv4</u>, is used.

              Note that if no <u>port</u> is given and if <u>taddress</u> does not contain a port number, the default value is
              used.

       <b>unregister_agent(UserId,</b> <b>TargetName)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 TargetName = target_name()

              Unregister the agent.

       <b>agent_info(TargetName,</b> <b>Item)</b> <b>-&gt;</b> <b>{ok,</b> <b>Val}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 TargetName = target_name()
                 Item = atom()
                 Reason = term()

              Retrieve agent config.

       <b>update_agent_info(UserId,</b> <b>TargetName,</b> <b>Info)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>update_agent_info(UserId,</b> <b>TargetName,</b> <b>Item,</b> <b>Val)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 TargetName = target_name()
                 Info = [{item(), item_value()}]
                 Item = item()
                 item() = atom()
                 Val = item_value()
                 item_value() = term()
                 Reason = term()

              Update  agent config. The function <u>update_agent_info/3</u> should be used when several values needs to
              be updated atomically.

              See function register_agent for more info about what kind of items are allowed.

       <b>which_agents()</b> <b>-&gt;</b> <b>Agents</b>
       <b>which_agents(UserId)</b> <b>-&gt;</b> <b>Agents</b>

              Types:

                 UserId = term()
                 Agents = [TargetName]
                 TargetName = target_name()

              Get a list of all registered agents or all agents registered by a specific user.

       <b>register_usm_user(EngineID,</b> <b>UserName,</b> <b>Conf)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 EngineID = string()
                 UserName = string()
                 Conf = [usm_config()]
                 usm_config() = {Item, Val}
                 Item = sec_name | auth | auth_key | priv | priv_key
                 Val = term()
                 Reason = term()

              Explicitly instruct the manager to handle this USM user. Note that there is an alternate way to do
              the same thing: Add the usm user to the manager config files (see usm.conf).

              The type of <u>Val</u> depends on <u>Item</u>:

              sec_name = string()
              auth = usmNoAuthProtocol | usmHMACMD5AuthProtocol | usmHMACSHAAuthProtocol | usmHMAC128SHA224AuthProtocol | usmHMAC192SH256AuthProtocol | usmHMAC256SHA384AuthProtocol | usmHMAC384SHA512AuthProtocol
              auth_key = [integer()]   (length 16 if auth = usmHMACMD5AuthProtocol,
                                        length 20 if auth = usmHMACSHAAuthProtocol,
                                        length 28 if auth = usmHMAC128SHA224AuthProtocol,
                                        length 32 if auth = usmHMAC192SHA256AuthProtocol,
                                        length 48 if auth = usmHMAC256SHA384AuthProtocol,
                                        length 64 if auth = usmHMAC384SHA512AuthProtocol)
              priv = usmNoPrivProtocol | usmDESPrivProtocol | usmAesCfb128Protocol
              priv_key = [integer()]   (length is 16 if priv = usmDESPrivProtocol | usmAesCfb128Protocol).

       <b>unregister_usm_user(EngineID,</b> <b>UserName)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 EngineID = string()
                 UserName = string()
                 Reason = term()

              Unregister this USM user.

       <b>usm_user_info(EngineID,</b> <b>UserName,</b> <b>Item)</b> <b>-&gt;</b> <b>{ok,</b> <b>Val}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 EngineID = string()
                 UsmName = string()
                 Item = sec_name | auth | auth_key | priv | priv_key
                 Reason = term()

              Retrieve usm user config.

       <b>update_usm_user_info(EngineID,</b> <b>UserName,</b> <b>Item,</b> <b>Val)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 EngineID = string()
                 UsmName = string()
                 Item = sec_name | auth | auth_key | priv | priv_key
                 Val = term()
                 Reason = term()

              Update usm user config.

       <b>which_usm_users()</b> <b>-&gt;</b> <b>UsmUsers</b>

              Types:

                 UsmUsers = [{EngineID,UserName}]
                 EngineID = string()
                 UsmName = string()

              Get a list of all registered usm users.

       <b>which_usm_users(EngineID)</b> <b>-&gt;</b> <b>UsmUsers</b>

              Types:

                 UsmUsers = [UserName]
                 UserName = string()

              Get a list of all registered usm users with engine-id <u>EngineID</u>.

       <b>sync_get2(UserId,</b> <b>TargetName,</b> <b>Oids)</b> <b>-&gt;</b> <b>{ok,</b> <b>SnmpReply,</b> <b>Remaining}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>sync_get2(UserId,</b> <b>TargetName,</b> <b>Oids,</b> <b>SendOpts)</b> <b>-&gt;</b> <b>{ok,</b> <b>SnmpReply,</b> <b>Remaining}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 TargetName = target_name()
                 Oids = [oid()]
                 SendOpts = send_opts()
                 send_opts() = [send_opt()]
                 send_opt() = {context, string()} | {timeout, pos_integer()} |  {extra,  term()}  |  {community,
                 community()}  |  {sec_model,  sec_model()}  | {sec_name, string()} | {sec_level, sec_level()} |
                 {max_message_size, pos_integer()}
                 SnmpReply = snmp_reply()
                 Remaining = integer()
                 Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()
                 ReqId = term()
                 ActualReason = term()
                 SecInfo = [sec_info()]
                 sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}
                 sec_tag() = atom()
                 ExpectedValue = ReceivedValue = term()
                 SnmpInfo = term()

              Synchronous <u>get-request</u>.

              <u>Remaining</u> is the remaining time of the given (or default) timeout time.

              When <u>Reason</u> is <u>{send_failed,</u> <u>...}</u> it means that the net_if process failed  to  send  the  message.
              This  could  happen  because  of  any  number of reasons, i.e. encoding error. <u>ActualReason</u> is the
              actual reason in this case.

              The send option <u>extra</u> specifies an opaque data structure passed on to the net-if process. The net-
              if process included in this application makes, with one exception, no use of  this  info,  so  the
              only  use for it in such a option (when using the built in net-if) would be tracing. The one usage
              exception is: <u>Any</u> tuple with <u>snmpm_extra_info_tag</u> as its first element is  reserved  for  internal
              use.

              Some  of  the  send  options  (<u>community</u>, <u>sec_model</u>, <u>sec_name</u>, <u>sec_level</u> and <u>max_message_size</u>) are
              <u>override</u> <u>options</u>. That is, for <u>this</u> request, they override any configuration done when  the  agent
              was registered.

              For <u>SnmpInfo</u>, see the user callback function handle_report.

       <b>async_get2(UserId,</b> <b>TargetName,</b> <b>Oids)</b> <b>-&gt;</b> <b>{ok,</b> <b>ReqId}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>async_get2(UserId,</b> <b>TargetName,</b> <b>Oids,</b> <b>SendOpts)</b> <b>-&gt;</b> <b>{ok,</b> <b>ReqId}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 TargetName = target_name()
                 Oids = [oid()]
                 SendOpts = send_opts()
                 send_opts() = [send_opt()]
                 send_opt()  =  {context,  string()}  | {timeout, pos_integer()} | {extra, term()} | {community,
                 community()} | {sec_model, sec_model()} | {sec_name, string()}  |  {sec_level,  sec_level()}  |
                 {max_message_size, pos_integer()}
                 ReqId = term()
                 Reason = term()

              Asynchronous <u>get-request</u>.

              The  reply, if it arrives, will be delivered to the user through a call to the snmpm_user callback
              function <u>handle_pdu</u>.

              The send option <u>timeout</u> specifies for how long the request is valid (after which  the  manager  is
              free to delete it).

              The send option <u>extra</u> specifies an opaque data structure passed on to the net-if process. The net-
              if  process  included  in  this application makes, with one exception, no use of this info, so the
              only use for it in such a option (when using the built in net-if) would be tracing. The one  usage
              exception  is:  <u>Any</u>  tuple with <u>snmpm_extra_info_tag</u> as its first element is reserved for internal
              use.

              Some of the send options (<u>community</u>, <u>sec_model</u>,  <u>sec_name</u>,  <u>sec_level</u>  and  <u>max_message_size</u>)  are
              <u>override</u>  <u>options</u>.  That is, for <u>this</u> request, they override any configuration done when the agent
              was registered.

       <b>sync_get_next2(UserId,</b> <b>TargetName,</b> <b>Oids)</b> <b>-&gt;</b> <b>{ok,</b> <b>SnmpReply,</b> <b>Remaining}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>sync_get_next2(UserId,</b> <b>TargetName,</b> <b>Oids,</b> <b>SendOpts)</b> <b>-&gt;</b> <b>{ok,</b> <b>SnmpReply,</b> <b>Remaining}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 TargetName = target_name()
                 Oids = [oid()]
                 SendOpts = send_opts()
                 send_opts() = [send_opt()]
                 send_opt() = {context, string()} | {timeout, pos_integer()} |  {extra,  term()}  |  {community,
                 community()}  |  {sec_model,  sec_model()}  | {sec_name, string()} | {sec_level, sec_level()} |
                 {max_message_size, pos_integer()}
                 SnmpReply = snmp_reply()
                 Remaining = integer()
                 Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()
                 ReqId = term()
                 ActualReason = term()
                 SecInfo = [sec_info()]
                 sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}
                 sec_tag() = atom()
                 ExpectedValue = ReceivedValue = term()
                 SnmpInfo = term()

              Synchronous <u>get-next-request</u>.

              <u>Remaining</u> is the remaining time of the given (or default) timeout time.

              When <u>Reason</u> is <u>{send_failed,</u> <u>...}</u> it means that the net_if process failed  to  send  the  message.
              This  could  happen  because  of  any  number of reasons, i.e. encoding error. <u>ActualReason</u> is the
              actual reason in this case.

              The send option <u>extra</u> specifies an opaque data structure passed on to the net-if process. The net-
              if process included in this application makes, with one exception, no use of  this  info,  so  the
              only  use for it in such a option (when using the built in net-if) would be tracing. The one usage
              exception is: <u>Any</u> tuple with <u>snmpm_extra_info_tag</u> as its first element is  reserved  for  internal
              use.

              Some  of  the  send  options  (<u>community</u>, <u>sec_model</u>, <u>sec_name</u>, <u>sec_level</u> and <u>max_message_size</u>) are
              <u>override</u> <u>options</u>. That is, for <u>this</u> request, they override any configuration done when  the  agent
              was registered.

              For <u>SnmpInfo</u>, see the user callback function handle_report.

       <b>async_get_next2(UserId,</b> <b>TargetName,</b> <b>Oids)</b> <b>-&gt;</b> <b>{ok,</b> <b>ReqId}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>async_get_next2(UserId,</b> <b>TargetName,</b> <b>Oids,</b> <b>SendOpts)</b> <b>-&gt;</b> <b>{ok,</b> <b>ReqId}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 TargetName = target_name()
                 Oids = [oid()]
                 send_opt()  =  {context,  string()}  | {timeout, pos_integer()} | {extra, term()} | {community,
                 community()} | {sec_model, sec_model()} | {sec_name, string()}  |  {sec_level,  sec_level()}  |
                 {max_message_size, pos_integer()}
                 ReqId = integer()
                 Reason = term()

              Asynchronous <u>get-next-request</u>.

              The  reply  will  be  delivered  to  the  user  through a call to the snmpm_user callback function
              <u>handle_pdu</u>.

              The send option <u>timeout</u> specifies for how long the request is valid (after which  the  manager  is
              free to delete it).

              The send option <u>extra</u> specifies an opaque data structure passed on to the net-if process. The net-
              if  process  included  in  this application makes, with one exception, no use of this info, so the
              only use for it in such a option (when using the built in net-if) would be tracing. The one  usage
              exception  is:  <u>Any</u>  tuple with <u>snmpm_extra_info_tag</u> as its first element is reserved for internal
              use.

              Some of the send options (<u>community</u>, <u>sec_model</u>,  <u>sec_name</u>,  <u>sec_level</u>  and  <u>max_message_size</u>)  are
              <u>override</u>  <u>options</u>.  That is, for <u>this</u> request, they override any configuration done when the agent
              was registered.

       <b>sync_set2(UserId,</b> <b>TargetName,</b> <b>VarsAndVals)</b> <b>-&gt;</b> <b>{ok,</b> <b>SnmpReply,</b> <b>Remaining}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>sync_set2(UserId,</b> <b>TargetName,</b> <b>VarsAndVals,</b> <b>SendOpts)</b> <b>-&gt;</b> <b>{ok,</b> <b>SnmpReply,</b> <b>Remaining}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 TargetName = target_name()
                 VarsAndVals = vars_and_vals()
                 SendOpts = send_opts()
                 send_opts() = [send_opt()]
                 send_opt() = {context, string()} | {timeout, pos_integer()} |  {extra,  term()}  |  {community,
                 community()}  |  {sec_model,  sec_model()}  | {sec_name, string()} | {sec_level, sec_level()} |
                 {max_message_size, pos_integer()}
                 SnmpReply = snmp_reply()
                 Remaining = integer()
                 Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()
                 ReqId = term()
                 ActualReason = term()
                 SecInfo = [sec_info()]
                 sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}
                 sec_tag() = atom()
                 ExpectedValue = ReceivedValue = term()
                 SnmpInfo = term()

              Synchronous <u>set-request</u>.

              <u>Remaining</u> is the remaining time of the given (or default) timeout time.

              When <u>Reason</u> is <u>{send_failed,</u> <u>...}</u> it means that the net_if process failed  to  send  the  message.
              This  could  happen  because  of  any  number of reasons, i.e. encoding error. <u>ActualReason</u> is the
              actual reason in this case.

              When <u>var_and_val()</u> is <u>{oid(),</u> <u>value()}</u>, the manager makes an educated guess based  on  the  loaded
              mibs.

              The send option <u>extra</u> specifies an opaque data structure passed on to the net-if process. The net-
              if  process  included  in  this application makes, with one exception, no use of this info, so the
              only use for it in such a option (when using the built in net-if) would be tracing. The one  usage
              exception  is:  <u>Any</u>  tuple with <u>snmpm_extra_info_tag</u> as its first element is reserved for internal
              use.

              Some of the send options (<u>community</u>, <u>sec_model</u>,  <u>sec_name</u>,  <u>sec_level</u>  and  <u>max_message_size</u>)  are
              <u>override</u>  <u>options</u>.  That is, for <u>this</u> request, they override any configuration done when the agent
              was registered.

              For <u>SnmpInfo</u>, see the user callback function handle_report.

       <b>async_set2(UserId,</b> <b>TargetName,</b> <b>VarsAndVals)</b> <b>-&gt;</b> <b>{ok,</b> <b>ReqId}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>async_set2(UserId,</b> <b>TargetName,</b> <b>VarsAndVals,</b> <b>SendOpts)</b> <b>-&gt;</b> <b>{ok,</b> <b>ReqId}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 TargetName = target_name()
                 VarsAndVals = vars_and_vals()
                 SendOpts = send_opts()
                 send_opts() = [send_opt()]
                 send_opt() = {context, string()} | {timeout, pos_integer()} |  {extra,  term()}  |  {community,
                 community()}  |  {sec_model,  sec_model()}  | {sec_name, string()} | {sec_level, sec_level()} |
                 {max_message_size, pos_integer()}
                 ReqId = term()
                 Reason = term()

              Asynchronous <u>set-request</u>.

              The reply will be delivered to the user  through  a  call  to  the  snmpm_user  callback  function
              <u>handle_pdu</u>.

              The  send  option  <u>timeout</u> specifies for how long the request is valid (after which the manager is
              free to delete it).

              When <u>var_and_val()</u> is <u>{oid(),</u> <u>value()}</u>, the manager makes an educated guess based  on  the  loaded
              mibs.

              The send option <u>extra</u> specifies an opaque data structure passed on to the net-if process. The net-
              if  process  included  in  this application makes, with one exception, no use of this info, so the
              only use for it in such a option (when using the built in net-if) would be tracing. The one  usage
              exception  is:  <u>Any</u>  tuple with <u>snmpm_extra_info_tag</u> as its first element is reserved for internal
              use.

              Some of the send options (<u>community</u>, <u>sec_model</u>,  <u>sec_name</u>,  <u>sec_level</u>  and  <u>max_message_size</u>)  are
              <u>override</u>  <u>options</u>.  That is, for <u>this</u> request, they override any configuration done when the agent
              was registered.

       <b>sync_get_bulk2(UserId,</b> <b>TragetName,</b> <b>NonRep,</b> <b>MaxRep,</b> <b>Oids)</b> <b>-&gt;</b> <b>{ok,</b> <b>SnmpReply,</b> <b>Remaining}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>sync_get_bulk2(UserId,</b> <b>TragetName,</b> <b>NonRep,</b> <b>MaxRep,</b>  <b>Oids,</b>  <b>SendOpts)</b>  <b>-&gt;</b>  <b>{ok,</b>  <b>SnmpReply,</b>  <b>Remaining}</b>  <b>|</b>
       <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 TargetName = target_name()
                 NonRep = integer()
                 MaxRep = integer()
                 Oids = [oid()]
                 SendOpts = send_opts()
                 send_opts() = [send_opt()]
                 send_opt()  =  {context,  string()}  | {timeout, pos_integer()} | {extra, term()} | {community,
                 community()} | {sec_model, sec_model()} | {sec_name, string()}  |  {sec_level,  sec_level()}  |
                 {max_message_size, pos_integer()}
                 SnmpReply = snmp_reply()
                 Remaining = integer()
                 Reason = {send_failed, ReqId, ActualReason} | {invalid_sec_info, SecInfo, SnmpInfo} | term()
                 ReqId = term()
                 ActualReason = term()
                 SecInfo = [sec_info()]
                 sec_info() = {sec_tag(), ExpectedValue, ReceivedValue}
                 sec_tag() = atom()
                 ExpectedValue = ReceivedValue = term()
                 SnmpInfo = term()

              Synchronous <u>get-bulk-request</u> (See RFC1905).

              <u>Remaining</u> is the remaining time of the given (or default) timeout time.

              When  <u>Reason</u>  is  <u>{send_failed,</u>  <u>...}</u> it means that the net_if process failed to send the message.
              This could happen because of any number of reasons,  i.e.  encoding  error.  <u>ActualReason</u>  is  the
              actual reason in this case.

              The send option <u>extra</u> specifies an opaque data structure passed on to the net-if process. The net-
              if  process  included  in  this application makes, with one exception, no use of this info, so the
              only use for it in such a option (when using the built in net-if) would be tracing. The one  usage
              exception  is:  <u>Any</u>  tuple with <u>snmpm_extra_info_tag</u> as its first element is reserved for internal
              use.

              Some of the send options (<u>community</u>, <u>sec_model</u>,  <u>sec_name</u>,  <u>sec_level</u>  and  <u>max_message_size</u>)  are
              <u>override</u>  <u>options</u>.  That is, for <u>this</u> request, they override any configuration done when the agent
              was registered.

              For <u>SnmpInfo</u>, see the user callback function handle_report.

       <b>async_get_bulk2(UserId,</b> <b>TargetName,</b> <b>NonRep,</b> <b>MaxRep,</b> <b>Oids)</b> <b>-&gt;</b> <b>{ok,</b> <b>ReqId}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>async_get_bulk2(UserId,</b> <b>TargetName,</b> <b>NonRep,</b> <b>MaxRep,</b> <b>Oids,</b> <b>SendOpts)</b> <b>-&gt;</b> <b>{ok,</b> <b>ReqId}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 TargetName = target_name()
                 NonRep = integer()
                 MaxRep = integer()
                 Oids = [oid()]
                 SendOpts = send_opts()
                 send_opts() = [send_opt()]
                 send_opt() = {context, string()} | {timeout, pos_integer()} |  {extra,  term()}  |  {community,
                 community()}  |  {sec_model,  sec_model()}  | {sec_name, string()} | {sec_level, sec_level()} |
                 {max_message_size, pos_integer()}
                 ReqId = integer()
                 Reason = term()

              Asynchronous <u>get-bulk-request</u> (See RFC1905).

              The reply will be delivered to the user  through  a  call  to  the  snmpm_user  callback  function
              <u>handle_pdu</u>.

              The  send  option  <u>timeout</u> specifies for how long the request is valid (after which the manager is
              free to delete it).

              The send option <u>extra</u> specifies an opaque data structure passed on to the net-if process. The net-
              if process included in this application makes no use of this info, so the only use for it in  such
              a configuration (when using the built in net-if) would be tracing.

              Some  of  the  send  options  (<u>community</u>, <u>sec_model</u>, <u>sec_name</u>, <u>sec_level</u> and <u>max_message_size</u>) are
              <u>override</u> <u>options</u>. That is, for <u>this</u> request, they override any configuration done when  the  agent
              was registered.

       <b>cancel_async_request(UserId,</b> <b>ReqId)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 UserId = term()
                 ReqId = term()
                 Reason = term()

              Cancel a previous asynchronous request.

       <b>log_to_txt(LogDir)</b>
       <b>log_to_txt(LogDir,</b> <b>Block</b> <b>|</b> <b>Mibs)</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>Block</b> <b>|</b> <b>OutFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>OutFile,</b> <b>Block</b> <b>|</b> <b>LogName)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>OutFile,</b> <b>LogName,</b> <b>Block</b> <b>|</b> <b>LogFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>OutFile,</b> <b>LogName,</b> <b>LogFile,</b> <b>Block</b> <b>|</b> <b>Start)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>OutFile,</b> <b>LogName,</b> <b>LogFile,</b> <b>Block,</b> <b>Start)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b> <b>Mibs,</b> <b>OutFile,</b> <b>LogName,</b> <b>LogFile,</b> <b>Start,</b> <b>Stop)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_txt(LogDir,</b>  <b>Mibs,</b>  <b>OutFile,</b>  <b>LogName,</b>  <b>LogFile,</b>  <b>Block,</b>  <b>Start,</b> <b>Stop)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b>
       <b>Reason}</b>

              Types:

                 LogDir = string()
                 Mibs = [MibName]
                 MibName = string()
                 Block = boolean()
                 OutFile = string()
                 LogName = string()
                 LogFile = string()
                 Start  =  Stop  =  null   |   calendar:datetime()   |   {local_time,   calendar:datetime()}   |
                 {universal_time, calendar:datetime()}
                 Cnt = {NumOK, NumERR}
                 NumOK = non_neg_integer()
                 NumERR = pos_integer()
                 Reason = disk_log_open_error() | file_open_error() | term()
                 disk_log_open_error() = {LogName, term()}
                 file_open_error() = {OutFile, term()}

              Converts  an  Audit  Trail  Log  to  a  readable text file. <u>OutFile</u> defaults to "./snmpm_log.txt".
              <u>LogName</u> defaults to "snmpm_log". <u>LogFile</u> defaults to "snmpm.log".

              The <u>Block</u> argument indicates if the log should be blocked during conversion. This could be usefull
              when converting large logs (when otherwise the log could  wrap  during  conversion).  Defaults  to
              <u>true</u>.

              See snmp:log_to_txt for more info.

       <b>log_to_io(LogDir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Block</b> <b>|</b> <b>Mibs)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>Block</b> <b>|</b> <b>LogName)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>LogName,</b> <b>Block</b> <b>|</b> <b>LogFile)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>LogName,</b> <b>LogFile,</b> <b>Block</b> <b>|</b> <b>Start)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>LogName,</b> <b>LogFile,</b> <b>Block,</b> <b>Start)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>LogName,</b> <b>LogFile,</b> <b>Start,</b> <b>Stop)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>log_to_io(LogDir,</b> <b>Mibs,</b> <b>LogName,</b> <b>LogFile,</b> <b>Block,</b> <b>Start,</b> <b>Stop)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Cnt}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 LogDir = string()
                 Mibs = [MibName]
                 MibName = string()
                 Block = boolean()
                 LogName = string()
                 LogFile = string()
                 Start   =   Stop   =   null   |   calendar:datetime()  |  {local_time,  calendar:datetime()}  |
                 {universal_time, calendar:datetime()}
                 Cnt = {NumOK, NumERR}
                 NumOK = non_neg_integer()
                 NumERR = pos_integer()
                 Reason = disk_log_open_error() | file_open_error() | term()
                 disk_log_open_error() = {LogName, term()}
                 file_open_error() = {OutFile, term()}

              Converts an Audit Trail Log to a readable format and prints  it  on  stdio.  <u>LogName</u>  defaults  to
              "snmpm_log". <u>LogFile</u> defaults to "snmpm.log".

              The <u>Block</u> argument indicates if the log should be blocked during conversion. This could be usefull
              when  converting  large  logs  (when  otherwise the log could wrap during conversion). Defaults to
              <u>true</u>.

              See snmp:log_to_io for more info.

       <b>change_log_size(NewSize)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 NewSize = {MaxBytes, MaxFiles}
                 MaxBytes = integer()
                 MaxFiles = integer()
                 Reason = term()

              Changes the log size of the Audit Trail Log. The application must be configured to use  the  audit
              trail log function. Please refer to <a href="../man3erl/disk_log.3erl.html">disk_log</a>(3erl) in Kernel Reference Manual for a description of
              how to change the log size.

              The change is permanent, as long as the log is not deleted. That means, the log size is remembered
              across reboots.

       <b>set_log_type(NewType)</b> <b>-&gt;</b> <b>{ok,</b> <b>OldType}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 NewType = OldType = atl_type()
                 Reason = term()

              Changes the run-time Audit Trail log type.

              Note  that  this has no effect on the application configuration as defined by configuration files,
              so a node restart will revert the config to whatever is in those files.

              This function is primarily useful in testing/debugging scenarios.

       <b>load_mib(Mib)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Mib = MibName
                 MibName = string()
                 Reason = term()

              Load a <u>Mib</u> into the manager. The <u>MibName</u> is the name of the Mib, including the path to  where  the
              compiled mib is found. For example,

                        Dir = code:<a href="../manmy_app/priv_dir.my_app.html">priv_dir</a>(my_app) ++ "/mibs/",
                        snmpm:load_mib(Dir ++ "MY-MIB").

       <b>unload_mib(Mib)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Mib = MibName
                 MibName = string()
                 Reason = term()

              Unload a <u>Mib</u> from the manager. The <u>MibName</u> is the name of the Mib, including the path to where the
              compiled mib is found. For example,

                        Dir = code:<a href="../manmy_app/priv_dir.my_app.html">priv_dir</a>(my_app) ++ "/mibs/",
                        snmpm:unload_mib(Dir ++ "MY-MIB").

       <b>which_mibs()</b> <b>-&gt;</b> <b>Mibs</b>

              Types:

                 Mibs = [{MibName, MibFile}]
                 MibName = atom()
                 MibFile = string()

              Get a list of all the mib's loaded into the manager.

       <b>name_to_oid(Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>Oids}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = atom()
                 Oids = [oid()]

              Transform a alias-name to its oid.

              Note  that  an  alias-name  is  only  unique  within the mib, so when loading several mib's into a
              manager, there might be several instances of the same aliasname.

       <b>oid_to_name(Oid)</b> <b>-&gt;</b> <b>{ok,</b> <b>Name}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Oid = oid()
                 Name = atom()
                 Reason = term()

              Transform a oid to its aliasname.

       <b>oid_to_type(Oid)</b> <b>-&gt;</b> <b>{ok,</b> <b>Type}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Oid = oid()
                 Type = atom()
                 Reason = term()

              Retreive the type (asn1 bertype) of an oid.

       <b>backup(BackupDir)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 BackupDir = string()

              Backup persistent data handled by the manager.

              BackupDir cannot be identical to DbDir.

       <b>info()</b> <b>-&gt;</b> <b>[{Key,</b> <b>Value}]</b>

              Types:

                 Key = atom()
                 Value = term()

              Returns a list (a dictionary) containing  information  about  the  manager.  Information  includes
              statistics counters, miscellaneous info about each process (e.g. memory allocation), and so on.

       <b>verbosity(Ref,</b> <b>Verbosity)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Ref = server | config | net_if | note_store | all
                 Verbosity = verbosity()
                 verbosity() = silence | info | log | debug | trace

              Sets  verbosity  for the designated process. For the lowest verbosity <u>silence</u>, nothing is printed.
              The higher the verbosity, the more is printed.

       <b>restart(Ref)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 Ref = net_if

              Restart the indicated process (<u>Ref</u>). Note that its not without risk  to  restart  a  process,  and
              should therefor be used with care.

       <b>format_reason(Reason)</b> <b>-&gt;</b> <b>string()</b>
       <b>format_reason(Prefix,</b> <b>Reason)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 Reason = term()
                 Prefix = integer() | string()

              This  utility function is used to create a formatted (pretty printable) string of the error reason
              received from either:

                * The <u>Reason</u> returned value if any of the sync/async get/get-next/set/get-bulk functions returns
                  <u>{error,</u> <u>Reason}</u>

                * The <u>Reason</u> parameter in the handle_error user callback function.

              <u>Prefix</u> should either be an indention string (e.g. a list of spaces) or a positive  integer  (which
              will be used to create the indention string of that length).

Ericsson AB                                         snmp 5.11                                        <u><a href="../man3erl/snmpm.3erl.html">snmpm</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>