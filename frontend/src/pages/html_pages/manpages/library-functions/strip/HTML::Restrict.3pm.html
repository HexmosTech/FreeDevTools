<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Restrict - Strip unwanted HTML tags and attributes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-restrict-perl">libhtml-restrict-perl_3.0.2-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Restrict - Strip unwanted HTML tags and attributes

</pre><h4><b>VERSION</b></h4><pre>
       version v3.0.2

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use HTML::Restrict;

           my $hr = HTML::Restrict-&gt;new();

           # use default rules to start with (strip away all HTML)
           my $processed = $hr-&gt;process('  &lt;b&gt;i am bold&lt;/b&gt;  ');

           # $processed now equals: 'i am bold'

           # Now, a less restrictive example:
           $hr = HTML::Restrict-&gt;new(
               rules =&gt; {
                   b   =&gt; [],
                   img =&gt; [qw( src alt / )]
               }
           );

           my $html = q[&lt;body&gt;&lt;b&gt;hello&lt;/b&gt; &lt;img src="pic.jpg" alt="me" id="test" /&gt;&lt;/body&gt;];
           $processed = $hr-&gt;process( $html );

           # $processed now equals: &lt;b&gt;hello&lt;/b&gt; &lt;img src="pic.jpg" alt="me" /&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module uses HTML::Parser to strip HTML from text in a restrictive manner.  By default all HTML is
       restricted.  You may alter the default behaviour by supplying your own tag rules.

</pre><h4><b>CONSTRUCTOR</b> <b>AND</b> <b>STARTUP</b></h4><pre>
   <b>new()</b>
       Creates and returns a new HTML::Restrict object.

           my $hr = HTML::Restrict-&gt;new()

       HTML::Restrict doesn't require any params to be passed to new.  If your goal is to remove all HTML from
       text, then no further setup is required.  Just pass your text to the <b>process()</b> method and you're done:

           my $plain_text = $hr-&gt;process( $html );

       If you need to set up specific rules, have a look at the params which HTML::Restrict recognizes:

       •   "rules =&gt; \%rules"

           Sets  the  rules  which  will be used to process your data.  By default all HTML tags are off limits.
           Use this argument to define the HTML  elements  and  corresponding  attributes  you'd  like  to  use.
           Essentially, consider the default behaviour to be:

               rules =&gt; {}

           Rules  should  be  passed as a HASHREF of allowed tags.  Each hash value should represent the allowed
           attributes for the listed tag.  For example, if you want to allow a fair amount of HTML, you can  try
           something like this:

               my %rules = (
                   a       =&gt; [qw( href target )],
                   b       =&gt; [],
                   caption =&gt; [],
                   center  =&gt; [],
                   em      =&gt; [],
                   i       =&gt; [],
                   img     =&gt; [qw( alt border height width src style )],
                   li      =&gt; [],
                   ol      =&gt; [],
                   p       =&gt; [qw(style)],
                   span    =&gt; [qw(style)],
                   strong  =&gt; [],
                   sub     =&gt; [],
                   sup     =&gt; [],
                   table   =&gt; [qw( style border cellspacing cellpadding align )],
                   tbody   =&gt; [],
                   td      =&gt; [],
                   tr      =&gt; [],
                   u       =&gt; [],
                   ul      =&gt; [],
               );

               my $hr = HTML::Restrict-&gt;new( rules =&gt; \%rules )

           Or, to allow only bolded text:

               my $hr = HTML::Restrict-&gt;new( rules =&gt; { b =&gt; [] } );

           Allow bolded text, images and some (but not all) image attributes:

               my %rules = (
                   b   =&gt; [ ],
                   img =&gt; [qw( src alt width height border / )
               );
               my $hr = HTML::Restrict-&gt;new( rules =&gt; \%rules );

           Since  HTML::Parser  treats  a  closing slash as an attribute, you'll need to add "/" to your list of
           allowed attributes if you'd like your tags to retain closing slashes.  For example:

               my $hr = HTML::Restrict-&gt;new( rules =&gt;{ hr =&gt; [] } );
               $hr-&gt;process( "&lt;hr /&gt;"); # returns: &lt;hr&gt;

               my $hr = HTML::Restrict-&gt;new( rules =&gt;{ hr =&gt; [qw( / )] } );
               $hr-&gt;process( "&lt;hr /&gt;"); # returns: &lt;hr /&gt;

           HTML::Restrict strips away any tags and attributes which are not explicitly allowed. It also rebuilds
           your explicitly allowed tags and places their attributes in the order in which they  appear  in  your
           rules.

           So, if you define the following rules:

               my %rules = (
                   ...
                   img =&gt; [qw( src alt title width height id / )]
                   ...
               );

           then your image tags will all be built like this:

               &lt;img src=".." alt="..." title="..." width="..." height="..." id=".." /&gt;

           This  gives  you  greater  consistency in your tag layout.  If you don't care about element order you
           don't need to pay any attention to this, but you  should  be  aware  that  your  elements  are  being
           reconstructed rather than just stripped down.

           As  of  2.1.0,  you  can  also specify a regex to be tested against the attribute value. This feature
           should be considered experimental for the time being:

               my $hr = HTML::Restrict-&gt;new(
                   rules =&gt; {
                       iframe =&gt; [
                           qw( width height allowfullscreen ),
                           {   src         =&gt; qr{^<a href="http://www">http://www</a>\.youtube\.com},
                               frameborder =&gt; qr{^(0|1)$},
                           }
                       ],
                       img =&gt; [ qw( alt ), { src =&gt; qr{^/my/images/} }, ],
                   },
               );

               my $html = '&lt;img src="<a href="http://www.example.com/image.jpg">http://www.example.com/image.jpg</a>" alt="Alt Text"&gt;';
               my $processed = $hr-&gt;process( $html );

               # $processed now equals: &lt;img alt="Alt Text"&gt;

           As of 2.3.0, the value to be tested against can also be a code reference.  The code reference will be
           passed the value of the attribute, and should return either a string to use for the attribute  value,
           or undef to remove the attribute.

               my $hr = HTML::Restrict-&gt;new(
                   rules =&gt; {
                       span =&gt; [
                           { style     =&gt; sub {
                               my $value = shift;
                               # all colors are orange
                               $value =~ s/\bcolor\s*:\s*[^;]+/color: orange/g;
                               return $value;
                           } }
                       ],
                   },
               );

               my $html = '&lt;span style="color: #0000ff;"&gt;This is blue&lt;/span&gt;';
               my $processed = $hr-&gt;process( $html );

               # $processed now equals: &lt;span style="color: orange;"&gt;

       •   "trim =&gt; [0|1]"

           By default all leading and trailing spaces will be removed when text is processed.  Set this value to
           0 in order to disable this behaviour.

       •   "uri_schemes =&gt; [undef, 'http', 'https', 'irc', ... ]"

           As  of  version  1.0.3,  URI  scheme  checking  is  performed on all href and src tag attributes. The
           following schemes are allowed out of the box.  No action is required on your part:

               [ undef, 'http', 'https' ]

           (undef represents relative URIs). These restrictions have been put in place to  prevent  XSS  in  the
           form of:

               &lt;a href="javascript:alert(document.cookie)"&gt;click for cookie!&lt;/a&gt;

           See  URI  for  more detailed info on scheme parsing.  If, for example, you wanted to filter out every
           scheme barring SSL, you would do it like this:

               uri_schemes =&gt; ['https']

           This feature is new in 1.0.3.  Previous to this,  there  was  no  schema  checking  at  all.   Moving
           forward,  you'll  need  to  whitelist  explicitly all URI schemas which are not supported by default.
           This is in keeping with the whitelisting behaviour of this module and is  also  the  safest  possible
           approach.   Keep  in mind that changes to uri_schemes are not additive, so you'll need to include the
           defaults in any changes you make, should you wish to keep them:

               # defaults + irc + mailto
               uri_schemes =&gt; [ 'undef', 'http', 'https', 'irc', 'mailto' ]

       •   allow_declaration =&gt; [0|1]

           Set this value to true if you'd like to allow/preserve DOCTYPE declarations in your content.   Useful
           when cleaning up your own static files or templates. This feature is off by default.

               my $html = q[&lt;!doctype html&gt;&lt;body&gt;foo&lt;/body&gt;];

               my $hr = HTML::Restrict-&gt;new( allow_declaration =&gt; 1 );
               $html = $hr-&gt;process( $html );
               # $html is now: "&lt;!doctype html&gt;foo"

       •   allow_comments =&gt; [0|1]

           Set  this  value  to true if you'd like to allow/preserve HTML comments in your content.  Useful when
           cleaning up your own static files or templates. This feature is off by default.

               my $html = q[&lt;body&gt;&lt;!-- comments! --&gt;foo&lt;/body&gt;];

               my $hr = HTML::Restrict-&gt;new( allow_comments =&gt; 1 );
               $html = $hr-&gt;process( $html );
               # $html is now: "&lt;!-- comments! --&gt;foo"

       •   create_newlines =&gt; [0|1]

           Set the value to true if you'd like to have each br tag  replaced  by  a  newline  and  every  p  tag
           replaced by two newlines. If a tag is specified in the allowed HTML, it won't be replaced.

       •   replace_img =&gt; [0|1|CodeRef]

           Set  the value to true if you'd like to have img tags replaced with "[IMAGE: ...]" containing the alt
           attribute text.  If you set it to a code reference, you can provide your own replacement  (which  may
           even contain HTML).

               sub replacer {
                   my ($tagname, $attr, $text) = @_; # from HTML::Parser
                   return qq{&lt;a href="$attr-&gt;{src}"&gt;IMAGE: $attr-&gt;{alt}&lt;/a&gt;};
               }

               my $hr = HTML::Restrict-&gt;new( replace_img =&gt; \&amp;replacer );

           This attribute will only take effect if the img tag is not included in the allowed HTML.

       •   strip_enclosed_content =&gt; [0|1]

           The  default  behaviour  up  to 1.0.4 was to preserve the content between script and style tags, even
           when the tags themselves were being deleted.  So, you'd be left with a bunch of  JavaScript  or  CSS,
           just  with  the enclosing tags missing.  This is almost never what you want, so starting at 1.0.5 the
           default will be to remove any script or style info which is enclosed in these tags, unless they  have
           specifically  been  whitelisted  in  the rules.  This will be a sane default when cleaning up content
           submitted via a web form.  However, if you're using HTML::Restrict to purge your own HTML you can  be
           more restrictive.

               # strip the head section, in addition to JS and CSS
               my $html = '&lt;html&gt;&lt;head&gt;...&lt;/head&gt;&lt;body&gt;...&lt;script&gt;JS here&lt;/script&gt;foo';

               my $hr = HTML::Restrict-&gt;new(
                   strip_enclosed_content =&gt; [ 'script', 'style', 'head' ]
               );

               $html = $hr-&gt;process( $html );
               # $html is now '&lt;html&gt;&lt;body&gt;...foo';

           The  caveat here is that HTML::Restrict will not try to fix broken HTML. In the above example, if you
           have any opening script, style or head tags which don't  also  include  matching  closing  tags,  all
           following content will be stripped away, regardless of any parent tags.

           Keep in mind that changes to strip_enclosed_content are not additive, so if you are adding additional
           tags  you'll  need  to  include  the entire list of tags whose enclosed content you'd like to remove.
           This feature strips script and style tags by default.

       •   "filter_text =&gt; [0|1|CodeRef]"

           By default all text will be filtered to fix any encoding problems which may  cause  security  issues.
           You  may  override  the encoding behaviour by providing your own anonymous sub to "filter_text". This
           first and only argument to the sub is the text which needs to be filtered. The sub  should  return  a
           scalar containing the transformed text.

               filter_text =&gt; sub {
                   my $text = shift;
                   ... # transform text
                   return $text;
               },

           You  may also this value to 0 in order to disable this behaviour entirely.  Please be advised this is
           a security risk. Use caution when disabling this parameter or providing your own filter function.

</pre><h4><b>SUBROUTINES/METHODS</b></h4><pre>
   <b>process(</b> <b>$html</b> <b>)</b>
       This is the method which does the real work.  It parses your data, removes any tags and attributes  which
       are not specifically allowed and returns the resulting text.  Requires and returns a SCALAR.

   <b>get_rules</b>
       Accessor which returns a hash ref of the current rule set.

   <b>get_uri_schemes</b>
       Accessor which returns an array ref of the current valid uri schemes.

</pre><h4><b>CAVEATS</b></h4><pre>
       Please note that all tag and attribute names passed via the rules param must be supplied in lower case.

           # correct
           my $hr = HTML::Restrict-&gt;new( rules =&gt; { body =&gt; ['onload'] } );

           # throws a fatal error
           my $hr = HTML::Restrict-&gt;new( rules =&gt; { Body =&gt; ['onLoad'] } );

</pre><h4><b>MOTIVATION</b></h4><pre>
       There  are already several modules on the CPAN which accomplish much of the same thing, but after doing a
       lot of poking around, I was unable to find a solution with a simple setup which I was happy with.

       The most common use case might be stripping HTML from user submitted data completely or allowing  just  a
       few  tags and attributes to be displayed.  With the exception of URI scheme checking, this module doesn't
       do any validation on the actual content of the tags or attributes.  If this is  a  requirement,  you  can
       either  mess  with  the  parser  object, post-process the text yourself or have a look at one of the more
       feature-rich modules in the SEE ALSO section below.

       My aim here is to keep things easy and, hopefully, cover a lot of the less complex use cases with just  a
       few lines of code and some brief documentation.  The idea is to be up and running quickly.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       HTML::TagFilter,  HTML::Defang,  MojoMojo::Declaw, HTML::StripScripts, HTML::Detoxifier, HTML::Sanitizer,
       HTML::Scrubber

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Raybec Communications &lt;<a href="http://www.raybec.com">http://www.raybec.com</a>&gt; for funding  my  work  on  this  module  and  for
       releasing it to the world.

       Thanks            also            to           the           many           other           contributors.
       &lt;https://github.com/oalders/html-restrict/graphs/contributors&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Olaf Alders &lt;<a href="mailto:olaf@wundercounter.com">olaf@wundercounter.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2009 by Olaf Alders.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.36.0                                       2023-09-28                                <u>HTML::<a href="../man3pm/Restrict.3pm.html">Restrict</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>