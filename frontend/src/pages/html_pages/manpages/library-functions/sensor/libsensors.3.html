<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libsensors - publicly accessible functions provided by the sensors library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsensors-dev">libsensors-dev_3.6.2-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libsensors - publicly accessible functions provided by the sensors library

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sensors/sensors.h&gt;</b>

       /* Library initialization and clean-up */
       <b>int</b> <b>sensors_init(FILE</b> <b>*</b><u>input</u><b>);</b>
       <b>void</b> <b>sensors_cleanup(void);</b>
       <b>const</b> <b>char</b> <b>*</b><u>libsensors_version</u><b>;</b>

       /* Chip name handling */
       <b>int</b> <b>sensors_parse_chip_name(const</b> <b>char</b> <b>*</b><u>orig_name</u><b>,</b>
                                   <b>sensors_chip_name</b> <b>*</b><u>res</u><b>);</b>
       <b>void</b> <b>sensors_free_chip_name(sensors_chip_name</b> <b>*</b><u>chip</u><b>);</b>
       <b>int</b> <b>sensors_snprintf_chip_name(char</b> <b>*</b><u>str</u><b>,</b> <b>size_t</b> <u>size</u><b>,</b>
                                      <b>const</b> <b>sensors_chip_name</b> <b>*</b><u>chip</u><b>);</b>
       <b>const</b> <b>char</b> <b>*sensors_get_adapter_name(const</b> <b>sensors_bus_id</b> <b>*</b><u>bus</u><b>);</b>

       /* Chips and features enumeration */
       <b>const</b> <b>sensors_chip_name</b> <b>*</b>
       <b>sensors_get_detected_chips(const</b> <b>sensors_chip_name</b> <b>*</b><u>match</u><b>,</b>
                                  <b>int</b> <b>*</b><u>nr</u><b>);</b>
       <b>const</b> <b>sensors_feature</b> <b>*</b>
       <b>sensors_get_features(const</b> <b>sensors_chip_name</b> <b>*</b><u>name</u><b>,</b>
                            <b>int</b> <b>*</b><u>nr</u><b>);</b>
       <b>const</b> <b>sensors_subfeature</b> <b>*</b>
       <b>sensors_get_all_subfeatures(const</b> <b>sensors_chip_name</b> <b>*</b><u>name</u><b>,</b>
                                   <b>const</b> <b>sensors_feature</b> <b>*</b><u>feature</u><b>,</b>
                                   <b>int</b> <b>*</b><u>nr</u><b>);</b>
       <b>const</b> <b>sensors_subfeature</b> <b>*</b>
       <b>sensors_get_subfeature(const</b> <b>sensors_chip_name</b> <b>*</b><u>name</u><b>,</b>
                              <b>const</b> <b>sensors_feature</b> <b>*</b><u>feature</u><b>,</b>
                              <b>sensors_subfeature_type</b> <u>type</u><b>);</b>

       /* Features access */
       <b>char</b> <b>*sensors_get_label(const</b> <b>sensors_chip_name</b> <b>*</b><u>name</u><b>,</b>
                               <b>const</b> <b>sensors_feature</b> <b>*</b><u>feature</u><b>);</b>
       <b>int</b> <b>sensors_get_value(const</b> <b>sensors_chip_name</b> <b>*</b><u>name</u><b>,</b> <b>int</b> <u>subfeat_nr</u><b>,</b>
                             <b>double</b> <b>*</b><u>value</u><b>);</b>
       <b>int</b> <b>sensors_set_value(const</b> <b>sensors_chip_name</b> <b>*</b><u>name</u><b>,</b> <b>int</b> <u>subfeat_nr</u><b>,</b>
                             <b>double</b> <u>value</u><b>);</b>
       <b>int</b> <b>sensors_do_chip_sets(const</b> <b>sensors_chip_name</b> <b>*</b><u>name</u><b>);</b>

       <b>#include</b> <b>&lt;sensors/error.h&gt;</b>

       /* Error decoding */
       <b>const</b> <b>char</b> <b>*sensors_strerror(int</b> <u>errnum</u><b>);</b>

       /* Error handlers */
       <b>void</b> <b>(*sensors_parse_error)</b> <b>(const</b> <b>char</b> <b>*</b><u>err</u><b>,</b> <b>int</b> <u>lineno</u><b>);</b>
       <b>void</b> <b>(*sensors_parse_error_wfn)</b> <b>(const</b> <b>char</b> <b>*</b><u>err</u><b>,</b>
                                        <b>const</b> <b>char</b> <b>*</b><u>filename</u><b>,</b> <b>int</b> <u>lineno</u><b>);</b>
       <b>void</b> <b>(*sensors_fatal_error)</b> <b>(const</b> <b>char</b> <b>*</b><u>proc</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>err</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sensors_init()</b>  loads the configuration file and the detected chips list. If this returns a value unequal
       to zero, you are in trouble; you can not assume anything will be initialized properly.  If  you  want  to
       reload  the  configuration  file,  or  load  a different configuration file, call sensors_cleanup() below
       before calling sensors_init() again. This means you can't load multiple configuration files  at  once  by
       calling sensors_init() multiple times.

       The configuration file format is described in <a href="../man5/sensors.conf.5.html">sensors.conf</a>(5).

       If  FILE  is  NULL,  the  default  configuration  files  are  used  (see  the  FILES section below). Most
       applications will want to do that.

       <b>sensors_cleanup()</b>  cleans  everything  up:  you  can't  access  anything  after  this,  until  the   next
       sensors_init() call!

       <b>libsensors_version</b> is a string representing the version of libsensors.

       <b>sensors_parse_chip_name()</b>  parses  a chip name to the internal representation. Return 0 on success, &lt;0 on
       error. Make sure to call sensors_free_chip_name() when you're done with the data.

       <b>sensors_free_chip_name()</b> frees the memory that may have been allocated for the internal representation of
       a chip name. You only have to call this for chip names which do  not  originate  from  libsensors  itself
       (that is, chip names which were generated by sensors_parse_chip_name()).

       <b>sensors_snprintf_chip_name()</b>  prints  a chip name from its internal representation. Note that chip should
       not contain wildcard values! Return the number of characters printed on success (same as snprintf), &lt;0 on
       error.

       <b>sensors_get_adapter_name()</b> returns the adapter name of a bus  type,  number  pair,  as  used  within  the
       sensors_chip_name structure. If it could not be found, it returns NULL.

       Adapters  describe  how  a monitoring chip is hooked up to the system.  This is particularly relevant for
       I2C/SMBus sensor chips (bus type "i2c"), which must be accessed over an I2C/SMBus controller.  Each  such
       controller  has  a  different  number, assigned by the system at initialization time, so that they can be
       referenced individually.

       Super-I/O or CPU-embedded sensors, on the other hand, can be accessed directly and technically don't  use
       any  adapter.  They  have only a bus type but no bus number, and sensors_get_adapter_name() will return a
       generic adapter name for them.

       <b>sensors_get_detected_chips()</b> returns all detected chips that match a given chip name, one by one.  If  no
       chip name is provided, all detected chips are returned.  To start at the beginning of the list, use 0 for
       nr;  NULL  is  returned  if we are at the end of the list. Do not try to change these chip names, as they
       point to internal structures!

       <b>sensors_get_features()</b> returns all main features of a specific chip. nr is an internally  used  variable.
       Set it to zero to start at the begin of the list. If no more features are found NULL is returned.  Do not
       try to change the returned structure; you will corrupt internal data structures.

       <b>sensors_get_all_subfeatures()</b>  returns  all subfeatures of a given main feature. nr is an internally used
       variable. Set it to zero to start at the begin of the list. If no more  subfeatures  are  found  NULL  is
       returned.  Do not try to change the returned structure; you will corrupt internal data structures.

       <b>sensors_get_subfeature()</b> returns the subfeature of the given type for a given main feature, if it exists,
       NULL otherwise.  Do not try to change the returned structure; you will corrupt internal data structures.

       <b>sensors_get_label()</b>  looks  up  the  label  which belongs to this chip. Note that chip should not contain
       wildcard values! The returned string is newly allocated (free it yourself). On failure, NULL is returned.
       If no label exists for this feature, its name is returned itself.

       <b>sensors_get_value()</b> Reads the value of a subfeature of a certain chip. Note that chip should not  contain
       wildcard values! This function will return 0 on success, and &lt;0 on failure.

       <b>sensors_set_value()</b>  sets  the value of a subfeature of a certain chip. Note that chip should not contain
       wildcard values! This function will return 0 on success, and &lt;0 on failure.

       <b>sensors_do_chip_sets()</b> executes all set statements  for  this  particular  chip.  The  chip  may  contain
       wildcards!  This function will return 0 on success, and &lt;0 on failure.

       <b>sensors_strerror()</b>  returns a pointer to a string which describes the error.  errnum may be negative (the
       corresponding positive error is returned).  You may not modify the result!

       <b>sensors_parse_error()</b> and <b>sensors_parse_error_wfn()</b> are functions which are called when a parse error  is
       detected.  Give them new values, and your own functions are called instead of the default (which print to
       stderr). These functions may terminate the program, but they usually output  an  error  and  return.  The
       first  function  is  the  original  one,  the  second  one  was  added  later  when  support for multiple
       configuration files was added.  The library code  now  only  calls  the  second  function.  However,  for
       backwards compatibility, if an application provides a custom handling function for the first function but
       not the second, then all parse errors will be reported using the first function (that is, the filename is
       never  reported.)   Note  that filename can be NULL (if filename isn't known) and lineno can be 0 (if the
       error occurs before the actual parsing starts.)

       <b>sensors_fatal_error()</b> Is a function which is called when an immediately fatal error (like no memory left)
       is detected. Give it a new value, and your own function is called instead of the default (which prints to
       stderr and ends the program). Never let it return!

</pre><h4><b>DATA</b> <b>STRUCTURES</b></h4><pre>
       Structure <b>sensors_chip_name</b> contains information related to a specific chip.

       <b>typedef</b> <b>struct</b> <b>sensors_chip_name</b> <b>{</b>
            <b>sensors_bus_id</b> <b>bus;</b>
       <b>}</b> <b>sensors_chip_name;</b>

       There are other members not documented here, which are only meant for libsensors internal use.

       Structure <b>sensors_feature</b> contains information related to a given feature of a specific chip:

       <b>typedef</b> <b>struct</b> <b>sensors_feature</b> <b>{</b>
            <b>const</b> <b>char</b> <b>*name;</b>
            <b>int</b> <b>number;</b>
            <b>sensors_feature_type</b> <b>type;</b>
       <b>}</b> <b>sensors_feature;</b>

       There are other members not documented here, which are only meant for libsensors internal use.

       Structure <b>sensors_subfeature</b> contains information related to  a  given  subfeature  of  a  specific  chip
       feature:

       <b>typedef</b> <b>struct</b> <b>sensors_subfeature</b> <b>{</b>
            <b>const</b> <b>char</b> <b>*name;</b>
            <b>int</b> <b>number;</b>
            <b>sensors_subfeature_type</b> <b>type;</b>
            <b>int</b> <b>mapping;</b>
            <b>unsigned</b> <b>int</b> <b>flags;</b>
       <b>}</b> <b>sensors_subfeature;</b>

       The  flags  field  is a bitfield, its value is a combination of <b>SENSORS_MODE_R</b> (readable), <b>SENSORS_MODE_W</b>
       (writable) and <b>SENSORS_COMPUTE_MAPPING</b> (affected by the computation rules of the main feature).

</pre><h4><b>FILES</b></h4><pre>
       <u><a href="file:/etc/sensors3.conf">/etc/sensors3.conf</a></u>
       <u>/etc/sensors.conf</u>
              The system-wide <b><a href="../man3/libsensors.3.html">libsensors</a></b>(3) configuration file. <a href="file:/etc/sensors3.conf">/etc/sensors3.conf</a> is tried  first,  and  if  it
              doesn't exist, /etc/sensors.conf is used instead.

       <u><a href="file:/etc/sensors.d">/etc/sensors.d</a></u>
              A  directory  where  you  can  put additional libsensors configuration files.  Files found in this
              directory will be processed in alphabetical order after the default configuration file. Files with
              names that start with a dot are ignored.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man5/sensors.conf.5.html">sensors.conf</a>(5)

</pre><h4><b>AUTHOR</b></h4><pre>
       Frodo Looijaard, Jean Delvare and others https://hwmon.wiki.kernel.org/lm_sensors

lm-sensors 3                                     September 2013                                    <u><a href="../man3/libsensors.3.html">libsensors</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>