<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openmpi-doc">openmpi-doc_5.0.7-1build1_all</a> <br><br><pre>
</pre><h4><b>SYNTAX</b></h4><pre>
   <b>C</b> <b>Syntax</b>
          #include &lt;mpi.h&gt;

          int MPI_Comm_split(MPI_Comm comm, int color, int key,
               MPI_Comm *newcomm)

   <b>Fortran</b> <b>Syntax</b>
          USE MPI
          ! or the older form: INCLUDE 'mpif.h'
          MPI_COMM_SPLIT(COMM, COLOR, KEY, NEWCOMM, IERROR)
               INTEGER COMM, COLOR, KEY, NEWCOMM, IERROR

   <b>Fortran</b> <b>2008</b> <b>Syntax</b>
          USE mpi_f08
          MPI_Comm_split(comm, color, key, newcomm, ierror)
               TYPE(MPI_Comm), INTENT(IN) :: comm
               INTEGER, INTENT(IN) :: color, key
               TYPE(MPI_Comm), INTENT(OUT) :: newcomm
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

</pre><h4><b>INPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>comm</b>: Communicator (handle).

       • <b>color</b>: Control of subset assignment (nonnegative integer).

       • <b>key</b>: Control of rank assignment (integer).

</pre><h4><b>OUTPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>newcomm</b>: New communicator (handle).

       • <b>ierror</b>: Fortran only: Error status (integer).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  function  partitions  the group associated with comm into disjoint subgroups, one for each value of
       color. Each subgroup contains all processes of the same color. Within each subgroup,  the  processes  are
       ranked in the order defined by the value of the argument key, with ties broken according to their rank in
       the  old  group.  A  new communicator is created for each subgroup and returned in newcomm. A process may
       supply the color value MPI_UNDEFINED, in which case newcomm returns MPI_COMM_NULL. This is  a  collective
       call, but each process is permitted to provide different values for color and key.

       When  you  call <u>MPI_Comm_split</u> on an inter-communicator, the processes on the left with the same color as
       those on the right combine to create a new inter-communicator. The key argument  describes  the  relative
       rank  of  processes  on each side of the inter-communicator. The function returns MPI_COMM_NULL for those
       colors that are specified on only  one  side  of  the  inter-communicator,  or  for  those  that  specify
       MPI_UNDEFINED as the color.

       A  call  to  MPI_Comm_create(comm,  <u>group</u>,  <u>newcomm</u>)  is  equivalent  to  a  call to MPI_Comm_split(comm,
       <u>color</u>,<u>key</u>, <u>newcomm</u>), where all members of <u>group</u> provide <u>color</u> = 0 and  <u>key</u>  =  rank  in  group,  and  all
       processes that are not members of <u>group</u> provide <u>color</u> = MPI_UNDEFINED. The function <u>MPI_Comm_split</u> allows
       more general partitioning of a group into one or more subgroups with optional reordering.

       The value of <u>color</u> must be nonnegative or MPI_UNDEFINED.

</pre><h4><b>NOTES</b></h4><pre>
       This  is  an  extremely  powerful mechanism for dividing a single communicating group of processes into k
       subgroups, with k chosen implicitly by  the  user  (by  the  number  of  colors  asserted  over  all  the
       processes).  Each  resulting  communicator  will  be  nonoverlapping. Such a division could be useful for
       defining a hierarchy of computations, such as for multigrid or linear algebra.

       Multiple calls to <u>MPI_Comm_split</u> can be used to overcome the requirement that any call have no overlap of
       the resulting communicators (each process is  of  only  one  color  per  call).  In  this  way,  multiple
       overlapping  communication structures can be created. Creative use of the color and key in such splitting
       operations is encouraged.

       Note that, for a fixed color, the keys need not be unique. It is <u>MPI_Comm_split</u>’s responsibility to  sort
       processes  in  ascending  order  according to this key, and to break ties in a consistent way. If all the
       keys are specified in the same way, then all the processes in a given color will have the  relative  rank
       order as they did in their parent group. (In general, they will have different ranks.)

       Essentially,  making  the key value zero for all processes of a given color means that one needn’t really
       pay attention to the rank-order of the processes in the new communicator.

</pre><h4><b>ERRORS</b></h4><pre>
       Almost all MPI routines return an error value; C routines as  the  return  result  of  the  function  and
       Fortran routines in the last argument.

       Before  the  error  value  is  returned,  the current MPI error handler associated with the communication
       object (e.g., communicator, window, file) is called.  If no communication object is associated  with  the
       MPI  call,  then  the call is considered attached to MPI_COMM_SELF and will call the associated MPI error
       handler.  When  MPI_COMM_SELF  is  not  initialized   (i.e.,   before   <u>MPI_Init</u>/<u>MPI_Init_thread</u>,   after
       <u>MPI_Finalize</u>,  or  when using the Sessions Model exclusively) the error raises the initial error handler.
       The initial error handler can be changed by calling <u>MPI_Comm_set_errhandler</u> on MPI_COMM_SELF  when  using
       the  World  model,  or the mpi_initial_errhandler CLI argument to mpiexec or info key to <u>MPI_Comm_spawn</u>/‐
       <u>MPI_Comm_spawn_multiple</u>.  If no other appropriate error handler has been set, then the  MPI_ERRORS_RETURN
       error  handler  is  called for MPI I/O functions and the MPI_ERRORS_ABORT error handler is called for all
       other MPI functions.

       Open MPI includes three predefined error handlers that can be used:

       • <b>MPI_ERRORS_ARE_FATAL</b> Causes the program to abort all connected MPI processes.

       • <b>MPI_ERRORS_ABORT</b> An error handler that can be invoked on a communicator, window, file, or session. When
         called on a communicator, it acts as if <u>MPI_Abort</u> was called on  that  communicator.  If  called  on  a
         window  or file, acts as if <u>MPI_Abort</u> was called on a communicator containing the group of processes in
         the corresponding window or file. If called on a session, aborts only the local process.

       • <b>MPI_ERRORS_RETURN</b> Returns an error code to the application.

       MPI applications can also implement their own error handlers by calling:

       • <u>MPI_Comm_create_errhandler</u> then <u>MPI_Comm_set_errhandler</u>

       • <u>MPI_File_create_errhandler</u> then <u>MPI_File_set_errhandler</u>

       • <u>MPI_Session_create_errhandler</u> then <u>MPI_Session_set_errhandler</u> or at <u>MPI_Session_init</u>

       • <u>MPI_Win_create_errhandler</u> then <u>MPI_Win_set_errhandler</u>

       Note that MPI does not guarantee that an MPI program can continue past an error.

       See the <u>MPI</u> <u>man</u> <u>page</u> for a full list of <u>MPI</u> <u>error</u> <u>codes</u>.

       See the Error Handling section of the MPI-3.1 standard for more information.

       <b>SEE</b> <b>ALSO:</b>

          • <u>MPI_Comm_create</u>

          • <u>MPI_Intercomm_create</u>

          • <u>MPI_Comm_dup</u>

          • <u>MPI_Comm_free</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Jun 07, 2025                                 <u><a href="../man3/MPI_COMM_SPLIT.3.html">MPI_COMM_SPLIT</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>