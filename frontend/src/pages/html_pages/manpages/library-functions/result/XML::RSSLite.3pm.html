<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::RSSLite - lightweight, "relaxed" RSS (and XML-ish) parser</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-rsslite-perl">libxml-rsslite-perl_0.17+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::RSSLite - lightweight, "relaxed" RSS (and XML-ish) parser

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use XML::RSSLite;

         parseRSS(\%result, \$content);

         print "=== Channel ===\n",
               "Title: $result{'title'}\n",
               "Desc:  $result{'description'}\n",
               "Link:  $result{'link'}\n\n";

         foreach $item (@{$result{'items'}}) {
         print "  --- Item ---\n",
               "  Title: $item-&gt;{'title'}\n",
               "  Desc:  $item-&gt;{'description'}\n",
               "  Link:  $item-&gt;{'link'}\n\n";
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module attempts to extract the maximum amount of content from available documents, and is less
       concerned with XML compliance than alternatives. Rather than rely on XML::Parser, it uses heuristics and
       good old-fashioned Perl regular expressions. It stores the data in a simple hash structure, and "aliases"
       certain tags so that when done, you can count on having the minimal data necessary for re-constructing a
       valid RSS file. This means you get the basic title, description, and link for a channel and its items.

       This module extracts more usable links by parsing "scriptingNews" and "weblog" formats in addition to RDF
       &amp; RSS. It also "sanitizes" the output for best results. The munging includes:

       Remove html tags to leave plain text
       Remove leading whitespace from URIs
       By defaul strips characters except 0-9~!@#$%^&amp;*()-+=a-zA-Z[];',.:"&lt;&gt;?\s
       Use &lt;url&gt; tags when &lt;link&gt; is empty
       Use misplaced urls in &lt;title&gt; when &lt;link&gt; is empty
       Exract links from &lt;a href=...&gt; if required
       Limit links to ftp and http(s)
       Join relative item urls (beginning with / or #) to the site base

   <b>EXPORT</b>
       parseRSS($outHashRef, $inScalarRef, [$strip])
           inScalarRef - required
               Reference  to  a scalar containing the document to be parsed. NOTE: The contents will effectively
               be destroyed. Make a deep copy first if you care.

           outHashRef - required
               Reference to the hash within which to store the parsed content.

           strip - optional
               An expression indicating the level of winnowing to be performed on the  characters  permitted  in
               the results.

               1 strip non-printable characters
               0 no characters are removed
               undefined (Default) strip everything but:
                   0-9~!@#$%^&amp;*()-+= a-zA-Z[];',.:"&lt;&gt;?\t\n

   <b>EXPORTABLE</b>
       parseXML(\%parsedTree, \$parseThis, 'topTag', $comments);
           parsedTree - required
               Reference to hash to store the parsed document within.

           parseThis  - required
               Reference to scalar containing the document to parse.

           topTag     - optional
               Tag to consider the root node, leaving this undefined is not recommended.

           comments   - optional
               false will remove contents from parseThis
               true will not remove comments from parseThis
               array reference is true, comments are stored here

   <b>CAVEATS</b>
       This is not a conforming parser. It does not handle the following

       •

             &lt;foo bar="&gt;"&gt;

       •

             &lt;foo&gt;&lt;bar&gt; &lt;bar&gt;&lt;/bar&gt; &lt;bar&gt;&lt;/bar&gt; &lt;/bar&gt;&lt;/foo&gt;

       •

             &lt;![CDATA[ ]]&gt;

       •

             PI

       It's non-validating, without a DTD the following cannot be properly addressed

       entities
       namespaces
           This may or may not be arriving in some future release.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), "XML::RSS", "XML::SAX::PurePerl", "XML::Parser::Lite", &lt;XML::Parser&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Jerrad Pierce &lt;<a href="mailto:jpierce@cpan.org">jpierce@cpan.org</a>&gt;.

       Scott Thomason &lt;<a href="mailto:scott@thomasons.org">scott@thomasons.org</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       Portions  Copyright (c) 2002,2003,2009 Jerrad Pierce, (c) 2000 Scott Thomason.  All rights reserved. This
       program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

perl v5.36.0                                       2022-11-20                                       <u><a href="../man3pm/RSSLite.3pm.html">RSSLite</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>