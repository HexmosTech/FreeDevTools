<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSL_get_error - obtain result code for TLS/SSL I/O operation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SSL_get_error - obtain result code for TLS/SSL I/O operation

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/ssl.h&gt;

        int SSL_get_error(const SSL *ssl, int ret);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>SSL_get_error()</b> returns a result code (suitable for the C "switch" statement) for a preceding call to
       <b>SSL_connect()</b>, <b>SSL_accept()</b>, <b>SSL_do_handshake()</b>, <b>SSL_read_ex()</b>, <b>SSL_read()</b>, <b>SSL_peek_ex()</b>, <b>SSL_peek()</b>,
       <b>SSL_shutdown()</b>, <b>SSL_write_ex()</b> or <b>SSL_write()</b> on <b>ssl</b>.  The value returned by that TLS/SSL I/O function
       must be passed to <b>SSL_get_error()</b> in parameter <b>ret</b>.

       In addition to <b>ssl</b> and <b>ret</b>, <b>SSL_get_error()</b> inspects the current thread's OpenSSL error queue.  Thus,
       <b>SSL_get_error()</b> must be used in the same thread that performed the TLS/SSL I/O operation, and no other
       OpenSSL function calls should appear in between.  The current thread's error queue must be empty before
       the TLS/SSL I/O operation is attempted, or <b>SSL_get_error()</b> will not work reliably.

</pre><h4><b>NOTES</b></h4><pre>
       Some TLS implementations do not send a close_notify alert on shutdown.

       On an unexpected EOF, versions before OpenSSL 3.0 returned <b>SSL_ERROR_SYSCALL</b>, nothing was added to the
       error stack, and errno was 0.  Since OpenSSL 3.0 the returned error is <b>SSL_ERROR_SSL</b> with a meaningful
       error on the error stack (SSL_R_UNEXPECTED_EOF_WHILE_READING). This error reason code may be used for
       control flow decisions (see the man page for <b><a href="../man3/ERR_GET_REASON.3.html">ERR_GET_REASON</a></b>(3) for further details on this).

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The following return values can currently occur:

       SSL_ERROR_NONE
           The TLS/SSL I/O operation completed.  This result code is returned if and only if <b>ret</b> <b>&gt;</b> <b>0</b>.

       SSL_ERROR_ZERO_RETURN
           The  TLS/SSL  peer  has closed the connection for writing by sending the close_notify alert.  No more
           data can be read.  Note that <b>SSL_ERROR_ZERO_RETURN</b> does not necessarily indicate that the  underlying
           transport has been closed.

           This   error   can   also   appear   when   the   option  <b>SSL_OP_IGNORE_UNEXPECTED_EOF</b>  is  set.  See
           <b><a href="../man3/SSL_CTX_set_options.3.html">SSL_CTX_set_options</a></b>(3) for more details.

       SSL_ERROR_WANT_READ, SSL_ERROR_WANT_WRITE
           The operation did not complete and can be retried later.

           For non-QUIC SSL objects, <b>SSL_ERROR_WANT_READ</b>  is  returned  when  the  last  operation  was  a  read
           operation  from  a  nonblocking  <b>BIO</b>.   It  means  that not enough data was available at this time to
           complete the operation.  If at a later time the underlying <b>BIO</b> has data  available  for  reading  the
           same function can be called again.

           <b>SSL_read()</b>  and  <b>SSL_read_ex()</b>  can also set <b>SSL_ERROR_WANT_READ</b> when there is still unprocessed data
           available at either the <b>SSL</b> or the <b>BIO</b> layer, even for a blocking  <b>BIO</b>.   See  <b><a href="../man3/SSL_read.3.html">SSL_read</a></b>(3)  for  more
           information.

           For  non-QUIC  SSL objects, <b>SSL_ERROR_WANT_WRITE</b> is returned when the last operation was a write to a
           nonblocking <b>BIO</b> and it was unable to send all data to the <b>BIO</b>. When the <b>BIO</b> is  writable  again,  the
           same function can be called again.

           Note  that  the  retry  may  again  lead to an <b>SSL_ERROR_WANT_READ</b> or <b>SSL_ERROR_WANT_WRITE</b> condition.
           There is no fixed upper limit for the number of iterations  that  may  be  necessary  until  progress
           becomes visible at application protocol level.

           For  QUIC SSL objects, the meaning of <b>SSL_ERROR_WANT_READ</b> and <b>SSL_ERROR_WANT_WRITE</b> have different but
           largely compatible semantics. Since QUIC implements its own flow  control  and  uses  UDP  datagrams,
           backpressure  conditions  in  terms  of  the  underlying  BIO  providing network I/O are not directly
           relevant to the circumstances in which these errors are produced. In particular, <b>SSL_ERROR_WANT_WRITE</b>
           indicates that the OpenSSL internal send buffer for a given QUIC stream has  been  filled.  Likewise,
           <b>SSL_ERROR_WANT_READ</b>  indicates  that  the  OpenSSL internal receive buffer for a given QUIC stream is
           empty.

           It is safe to call <b>SSL_read()</b> or <b>SSL_read_ex()</b> when more data is available even when  the  call  that
           set  this  error  was  an  <b>SSL_write()</b> or <b>SSL_write_ex()</b>.  However, if the call was an <b>SSL_write()</b> or
           <b>SSL_write_ex()</b>, it should be called again to continue  sending  the  application  data.  If  you  get
           <b>SSL_ERROR_WANT_WRITE</b>  from  <b>SSL_write()</b>  or <b>SSL_write_ex()</b> then you should not do any other operation
           that could trigger <b>IO</b> other than to repeat the previous <b>SSL_write()</b> call.

           For socket <b>BIO</b>s (e.g. when <b>SSL_set_fd()</b> was used), <b>select()</b> or <b>poll()</b> on the underlying socket can be
           used to find out when the TLS/SSL I/O function should be retried.

           Caveat: Any TLS/SSL I/O function can lead to either of <b>SSL_ERROR_WANT_READ</b> and  <b>SSL_ERROR_WANT_WRITE</b>.
           In  particular,  <b>SSL_read_ex()</b>,  <b>SSL_read()</b>,  <b>SSL_peek_ex()</b>, or <b>SSL_peek()</b> may want to write data and
           <b>SSL_write()</b> or <b>SSL_write_ex()</b> may want to read data.  This is mainly because TLS/SSL  handshakes  may
           occur  at any time during the protocol (initiated by either the client or the server); <b>SSL_read_ex()</b>,
           <b>SSL_read()</b>, <b>SSL_peek_ex()</b>, <b>SSL_peek()</b>,  <b>SSL_write_ex()</b>,  and  <b>SSL_write()</b>  will  handle  any  pending
           handshakes.

       SSL_ERROR_WANT_CONNECT, SSL_ERROR_WANT_ACCEPT
           The  operation  did  not  complete;  the  same TLS/SSL I/O function should be called again later. The
           underlying BIO was not connected yet to the peer and the call would block in <b>connect()</b>/<b>accept()</b>.  The
           SSL  function  should  be  called  again  when the connection is established. These messages can only
           appear with a <b>BIO_s_connect()</b> or <b>BIO_s_accept()</b> BIO, respectively.  In order to find  out,  when  the
           connection has been successfully established, on many platforms <b>select()</b> or <b>poll()</b> for writing on the
           socket file descriptor can be used.

       SSL_ERROR_WANT_X509_LOOKUP
           The  operation  did  not complete because an application callback set by <b>SSL_CTX_set_client_cert_cb()</b>
           has asked to be called again.  The TLS/SSL I/O function should be called again later.  Details depend
           on the application.

       SSL_ERROR_WANT_ASYNC
           The operation did not complete because an asynchronous engine is still  processing  data.  This  will
           only  occur  if  the mode has been set to SSL_MODE_ASYNC using <b><a href="../man3/SSL_CTX_set_mode.3.html">SSL_CTX_set_mode</a></b>(3) or <b><a href="../man3/SSL_set_mode.3.html">SSL_set_mode</a></b>(3)
           and an asynchronous capable engine is being used. An application can determine whether the engine has
           completed its processing using <b>select()</b> or <b>poll()</b> on the asynchronous wait file descriptor. This file
           descriptor is available by  calling  <b><a href="../man3/SSL_get_all_async_fds.3.html">SSL_get_all_async_fds</a></b>(3)  or  <b><a href="../man3/SSL_get_changed_async_fds.3.html">SSL_get_changed_async_fds</a></b>(3).  The
           TLS/SSL  I/O  function should be called again later. The function <b>must</b> be called from the same thread
           that the original call was made from.

       SSL_ERROR_WANT_ASYNC_JOB
           The asynchronous job could not be started because there were no async jobs available in the pool (see
           <b><a href="../man3/ASYNC_init_thread.3.html">ASYNC_init_thread</a></b>(3)). This will only occur  if  the  mode  has  been  set  to  SSL_MODE_ASYNC  using
           <b><a href="../man3/SSL_CTX_set_mode.3.html">SSL_CTX_set_mode</a></b>(3) or <b><a href="../man3/SSL_set_mode.3.html">SSL_set_mode</a></b>(3) and a maximum limit has been set on the async job pool through
           a  call  to  <b><a href="../man3/ASYNC_init_thread.3.html">ASYNC_init_thread</a></b>(3).  The  application  should  retry  the  operation after a currently
           executing asynchronous operation for the current thread has completed.

       SSL_ERROR_WANT_CLIENT_HELLO_CB
           The operation did not complete because an application callback set  by  <b>SSL_CTX_set_client_hello_cb()</b>
           has asked to be called again.  The TLS/SSL I/O function should be called again later.  Details depend
           on the application.

       SSL_ERROR_SYSCALL
           Some  non-recoverable, fatal I/O error occurred. The OpenSSL error queue may contain more information
           on the error. For socket I/O on Unix systems, consult <b>errno</b> for details. If this error occurs then no
           further I/O operations should be performed on the connection and <b>SSL_shutdown()</b> must not be called.

           This value can also be returned for other errors, check the error queue for details.

       SSL_ERROR_SSL
           A non-recoverable, fatal error in the SSL library occurred, usually a protocol  error.   The  OpenSSL
           error  queue  contains  more  information  on  the  error.  If  this error occurs then no further I/O
           operations should be performed on the connection and <b>SSL_shutdown()</b> must not be called.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/ssl.7.html">ssl</a></b>(7)

</pre><h4><b>HISTORY</b></h4><pre>
       The SSL_ERROR_WANT_ASYNC error code was added in OpenSSL 1.1.0.  The SSL_ERROR_WANT_CLIENT_HELLO_CB error
       code was added in OpenSSL 1.1.1.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2000-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                <u><a href="../man3SSL/SSL_GET_ERROR.3SSL.html">SSL_GET_ERROR</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>