<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NAME</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmail-dmarc-perl">libmail-dmarc-perl_1.20240314-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>Status</b> <b>Badges</b></h4><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mail::DMARC - Perl implementation of DMARC

</pre><h4><b>VERSION</b></h4><pre>
       version 1.20240314

</pre><h4><b>SYNOPSIS</b></h4><pre>
       DMARC: Domain-based Message Authentication, Reporting and Conformance

         my $dmarc = Mail::DMARC::PurePerl-&gt;new(
           ... # see the documentation for the "new" method for required args
         );

         my $result = $dmarc-&gt;validate();

         if ( $result-&gt;result eq 'pass' ) {
            ...continue normal processing...
            return;
         };

         # any result that did not pass is a fail. Now for disposition

         if ( $result-&gt;evalated-&gt;disposition eq 'reject' ) {
            ...treat the sender to a 550 ...
         };
         if ( $result-&gt;evalated-&gt;disposition eq 'quarantine' ) {
            ...assign a bunch of spam points...
         };
         if ( $result-&gt;evalated-&gt;disposition eq 'none' ) {
            ...continue normal processing...
         };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is a suite of tools for implementing DMARC. It adheres to the 2013 DMARC draft, intending to
       implement every MUST and every SHOULD.

       This module can be used by...

       •   MTAs  and  filtering  tools like SpamAssassin to validate that incoming messages are aligned with the
           purported sender's policy.

       •   email senders, to receive DMARC reports from other mail servers and display  them  via  CLI  and  web
           interfaces.

       •   MTA operators to send DMARC reports to DMARC author domains.

       When  a message arrives via SMTP, the MTA or filtering application can pass in a small amount of metadata
       about the connection (envelope details, SPF and DKIM results) to Mail::DMARC. When the <b>validate</b> method is
       called, Mail::DMARC will determine if:

        a. the header_from domain exists
        b. the header_from domain publishes a DMARC policy
        c. if a policy is published...
        d. does the message conform to the published policy?
        e. did the policy request reporting? If so, save details.

       The validation results are returned as a Mail::DMARC::Result object. If the  author  domain  requested  a
       report,  it  was  saved to the Report Store. The Store class includes a SQL implementation that is tested
       with SQLite, MySQL and PostgreSQL.

       There is more information available in the $result object. See Mail::DMARC::Result for complete details.

       Reports are viewed with the dmarc_view_reports program or with a web browser and the dmarc_httpd program.

       Aggregate reports are sent to their requestors with the dmarc_send_reports program.

       For aggregate reports that you have been sent, the dmarc_receive program will parse  the  email  messages
       (from IMAP, Mbox, or files) and save the report results into the Report Store.

       The report store can use the same database to store reports you have received as well as reports you will
       send. There are several ways to identify the difference, including:

       •   received reports will have a null value for report_policy_published.rua

       •   outgoing reports will have null values for report.uuid and report_record.count

</pre><h4><b>CLASSES</b></h4><pre>
       Mail::DMARC - the perl interface for DMARC

       Mail::DMARC::Policy - a DMARC policy

       Mail::DMARC::PurePerl - Pure Perl implementation of DMARC

       Mail::DMARC::Result - the results of applying policy

       Mail::DMARC::Report - Reporting: the R in DMARC

         Mail::DMARC::Report::Send - send reports via SMTP &amp; HTTP

         Mail::DMARC::Report::Receive - receive and store reports from email, HTTP

         Mail::DMARC::Report::Store - a persistent data store for aggregate reports

         Mail::DMARC::Report::View - CLI and CGI methods for viewing reports

       Mail::DMARC::libopendmarc  &lt;<a href="http://search.cpan.org/~shari/Mail-DMARC-opendmarc">http://search.cpan.org/~shari/Mail-DMARC-opendmarc</a>&gt;  -  an  XS implementation
       using libopendmarc

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       Create a DMARC object.

           my $dmarc = Mail::DMARC::PurePerl-&gt;new;

       Populate it.

           $dmarc-&gt;source_ip('192.0.1.1');
           $dmarc-&gt;envelope_to('recipient.example.com');
           $dmarc-&gt;envelope_from('sender.example.com');
           $dmarc-&gt;header_from('sender.example.com');
           $dmarc-&gt;dkim( $dkim_verifier );
           $dmarc-&gt;spf([
               {   domain =&gt; 'example.com',
                   scope  =&gt; 'mfrom',
                   result =&gt; 'pass',
               },
               {
                   scope  =&gt; 'helo',
                   domain =&gt; 'mta.example.com',
                   result =&gt; 'fail',
               },
           ]);

       Run the request:

           my $result = $dmarc-&gt;validate();

       Alternatively, pass in all the required parameters in one shot:

           my $dmarc = Mail::DMARC::PurePerl-&gt;new(
                   source_ip     =&gt; '192.0.1.1',
                   envelope_to   =&gt; 'example.com',
                   envelope_from =&gt; 'cars4you.info',
                   header_from   =&gt; 'yahoo.com',
                   dkim          =&gt; $dkim_results,  # same format
                   spf           =&gt; $spf_results,   # as previous example
                   );
           my $result = $dmarc-&gt;validate();

   <b>source_ip</b>
       The remote IP that attempted sending the message. DMARC only uses this data for reporting to domains that
       request DMARC reports.

   <b>envelope_to</b>
       The domain portion of the RFC5321.RcptTo, (aka, the envelope recipient), and  the  bold  portion  in  the
       following example:

               RCPT TO:&amp;lt;user@<b>example.com</b>&gt;

   <b>envelope_from</b>
       The  domain  portion of the RFC5321.MailFrom, (aka, the envelope sender). That is the the bold portion in
       the following example:

               MAIL FROM:&amp;lt;user@<b>example.com</b>&gt;

   <b>header_from</b>
       The domain portion of the RFC5322.From, aka, the From message header.

               From: Ultimate Vacation &amp;lt;sweepstakes@<b>example.com</b>&gt;

       You can instead pass in the entire From: header with header_from_raw.

   <b>header_from_raw</b>
       Retrieve the header_from domain by parsing it from  a  raw  From  field/header.  The  domain  portion  is
       extracted  by  get_dom_from_header,  which  is  fast,  generally effective, but also rather crude. It has
       limits, so read the description.

   <b>dkim</b>
       If Mail::DKIM::Verifier was used to validate the message, just pass in  the  Mail::DKIM::Verifier  object
       that processed the message:

           $dmarc-&gt;dkim( $dkim_verifier );

       Otherwise,  pass in an array reference. Each member of the DKIM array results represents a DKIM signature
       in the message and consists of the 4 keys shown in this example:

           $dmarc-&gt;dkim( [
                   {
                       domain      =&gt; 'example.com',
                       selector    =&gt; 'apr2013',
                       result      =&gt; 'fail',
                       human_result=&gt; 'fail (body has been altered)',
                   },
                   {
                       # 2nd signature, if present
                   },
               ] );

       The dkim results can also be build iteratively by passing in key value pairs or hash references for  each
       signature in the message:

           $dmarc-&gt;dkim( domain =&gt; 'sig1.com', result =&gt; 'fail' );
           $dmarc-&gt;dkim( domain =&gt; 'sig2.com', result =&gt; 'pass' );
           $dmarc-&gt;dkim( { domain =&gt; 'example.com', result =&gt; 'neutral' } );

       Each hash or hashref is appended to the dkim array.

       Finally,  you  can  pass  a  coderef which won't be called until the dkim method is used to read the dkim
       results.  It must return an array reference as described above.

       The dkim result is an array reference.

       <u>domain</u>

       The d= parameter in the DKIM signature

       <u>selector</u>

       The s= parameter in the DKIM signature

       <u>result</u>

       The validation results of this signature. One of:  none,  pass,  fail,  policy,  neutral,  temperror,  or
       permerror

       <u>human</u> <u>result</u>

       Additional information about the DKIM result. This is comparable to Mail::DKIM::Verifier-&gt;result_detail.

   <b>spf</b>
       The  spf  method works exactly the same as dkim. It accepts named arguments, a hashref, an arrayref, or a
       coderef:

           $dmarc-&gt;spf(
               domain =&gt; 'example.com',
               scope  =&gt; 'mfrom',
               result =&gt; 'pass',
           );

       The SPF domain and result are required for DMARC validation and the scope is used for reporting.

       <u>domain</u>

       The SPF checked domain

       <u>scope</u>

       The scope of the checked domain: mfrom, helo

       <u>result</u>

       The SPF result code: none, neutral, pass, fail, softfail, temperror, or permerror.

</pre><h4><b>DESIGN</b> <b>&amp;</b> <b>GOALS</b></h4><pre>
   <b>Correct</b>
       The DMARC spec is lengthy and evolving, making correctness a moving target. In cases where correctness is
       ambiguous, options are generally provided.

   <b>Easy</b> <b>to</b> <b>use</b>
       Providing an implementation of DMARC that SMTP utilities can utilize will aid DMARC adoption.

       The list of dependencies appears long because of reporting. If this module is used without reporting, the
       number of dependencies not included with perl is about 5.

   <b>Maintainable</b>
       Since DMARC is evolving, this implementation aims to be straight forward and easy to  alter  and  extend.
       The  programming  style  is  primarily  OO,  which  carries  a small performance penalty but dividends in
       maintainability.

       When multiple options are available, such as when sending reports via SMTP or HTTP, calls should be  made
       to  the  parent Send class to broker the request. When storing reports, calls are made to the Store class
       which dispatches to the SQL class. The idea is that if someone desired a  data  store  other  than  those
       provided  by perl's DBI class, they could easily implement their own. If you do, please fork it on GitHub
       and share.

   <b>Fast</b>
       If you deploy this in an environment where performance is insufficient, please profile the app and submit
       a report and preferably, patches.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mail::DMARC on GitHub &lt;https://github.com/msimerson/mail-dmarc&gt;

       2015-03 RFC 7489 &lt;https://tools.ietf.org/html/rfc7489&gt;

       DMARC Best Current Practices &lt;<a href="http://tools.ietf.org/html/draft-crocker-dmarc-bcp-03">http://tools.ietf.org/html/draft-crocker-dmarc-bcp-03</a>&gt;

</pre><h4><b>HISTORY</b></h4><pre>
       The   daddy   of    this    perl    module    was    a    DMARC    module    for    the    qpsmtpd    MTA
       &lt;https://github.com/smtpd/qpsmtpd/blob/master/plugins/dmarc&gt;.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Matt Simerson &lt;<a href="mailto:msimerson@cpan.org">msimerson@cpan.org</a>&gt;

       •   Davide Migliavacca &lt;<a href="mailto:shari@cpan.org">shari@cpan.org</a>&gt;

       •   Marc Bradshaw &lt;<a href="mailto:marc@marcbradshaw.net">marc@marcbradshaw.net</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Benny Pedersen &lt;<a href="mailto:me@junc.eu">me@junc.eu</a>&gt;

       •   Jean Paul Galea &lt;<a href="mailto:jeanpaul@yubico.com">jeanpaul@yubico.com</a>&gt;

       •   Marisa Clardy &lt;<a href="mailto:marisa@clardy.eu">marisa@clardy.eu</a>&gt;

       •   Priyadi Iman Nurcahyo &lt;<a href="mailto:priyadi@priyadi.net">priyadi@priyadi.net</a>&gt;

       •   Ricardo Signes &lt;<a href="mailto:rjbs@cpan.org">rjbs@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2024 by Matt Simerson.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.38.2                                       2024-08-21                                   <u>Mail::<a href="../man3pm/DMARC.3pm.html">DMARC</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>