<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>"IO::Async::Test" - utility functions for use in test scripts</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-async-perl">libio-async-perl_0.804-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       "IO::Async::Test" - utility functions for use in test scripts

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use Test2::V0;
          use Future::AsyncAwait;
          use IO::Async::Test;

          use IO::Async::Loop;
          my $loop = IO::Async::Loop-&gt;new;
          testing_loop( $loop );

          my $result;

          $loop-&gt;do_something(
             some =&gt; args,

             on_done =&gt; sub {
                $result = the_outcome;
             }
          );

          wait_for { defined $result };

          is( $result, what_we_expected, 'The event happened' );

          ...

          my $buffer = "";
          my $handle = IO::Handle-&gt; ...

          wait_for_stream { length $buffer &gt;= 10 } $handle =&gt; $buffer;

          is( substr( $buffer, 0, 10, "" ), "0123456789", 'Buffer was correct' );

          my $result = await wait_for_future( $stream-&gt;read_until( "\n" ) );

          done_testing;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides utility functions that may be useful when writing test scripts for code which uses
       IO::Async (as well as being used in the IO::Async test scripts themselves).

       Test scripts are often synchronous by nature; they are a linear sequence of actions to perform,
       interspersed with assertions which check for given conditions. This goes against the very nature of
       IO::Async which, being an asynchronisation framework, does not provide a linear stepped way of working.

       In order to write a test, the "wait_for" function provides a way of synchronising the code, so that a
       given condition is known to hold, which would typically signify that some event has occurred, the outcome
       of which can now be tested using the usual testing primitives.

       Because the primary purpose of IO::Async is to provide IO operations on filehandles, a great many tests
       will likely be based around connected pipes or socket handles. The "wait_for_stream" function provides a
       convenient way to wait for some content to be written through such a connected stream.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>testing_loop</b>
          testing_loop( $loop );

       Set the IO::Async::Loop object which the "wait_for" function will loop on.

   <b>wait_for</b>
          wait_for { COND } OPTS;

       Repeatedly call the "loop_once" method on the underlying loop (given to the "testing_loop" function),
       until the given condition function callback returns true.

       To guard against stalled scripts, if the loop indicates a timeout for (a default of) 10 consequentive
       seconds, then an error is thrown.

       Takes the following named options:

       timeout =&gt; NUM
           The time in seconds to wait before giving up the test as being stalled.  Defaults to 10 seconds.

   <b>wait_for_stream</b>
          wait_for_stream { COND } $handle, $buffer;

       As  "wait_for", but will also watch the given IO handle for readability, and whenever it is readable will
       read bytes in from it into the given buffer. The buffer is NOT initialised when the function is  entered,
       in case data remains from a previous call.

       $buffer  can  also  be a CODE reference, in which case it will be invoked being passed data read from the
       handle, whenever it is readable.

   <b>wait_for_future</b>
          $future = wait_for_future $future;

       <u>Since</u> <u>version</u> <u>0.68.</u>

       A handy wrapper around using "wait_for" to wait for a Future to become ready. The future instance  itself
       is returned, allowing neater code.

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Evans &lt;<a href="mailto:leonerd@leonerd.org.uk">leonerd@leonerd.org.uk</a>&gt;

perl v5.40.1                                       2025-05-17                               <u>IO::Async::<a href="../man3pm/Test.3pm.html">Test</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>