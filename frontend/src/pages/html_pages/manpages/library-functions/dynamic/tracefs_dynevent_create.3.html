<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tracefs_dynevent_create, tracefs_dynevent_destroy, tracefs_dynevent_destroy_all, tracefs_dynevent_free,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtracefs-doc">libtracefs-doc_1.8.1-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tracefs_dynevent_create, tracefs_dynevent_destroy, tracefs_dynevent_destroy_all, tracefs_dynevent_free,
       tracefs_dynevent_list_free, tracefs_dynevent_get, tracefs_dynevent_get_all, tracefs_dynevent_info,
       tracefs_dynevent_get_event - Create, destroy, free and get dynamic events.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tracefs.h&gt;</b>

       struct <b>tracefs_dynevent</b>;
       enum <b>tracefs_dynevent_type</b>;
       int <b>tracefs_dynevent_create</b>(struct tracefs_dynevent *<u>devent</u>);
       int <b>tracefs_dynevent_destroy</b>(struct tracefs_dynevent *<u>devent</u>, bool <u>force</u>);
       int <b>tracefs_dynevent_destroy_all</b>(unsigned int <u>types</u>, bool <u>force</u>);
       void <b>tracefs_dynevent_free</b>(struct tracefs_dynevent *<u>devent</u>);
       void <b>tracefs_dynevent_list_free</b>(struct tracefs_dynevent **<u>events</u>);
       struct tracefs_dynevent *<b>tracefs_dynevent_get</b>(enum tracefs_dynevent_type <u>type</u>, const char *<u>system</u>, const char *<u>event</u>);
       struct tracefs_dynevent **<b>tracefs_dynevent_get_all</b>(unsigned int <u>types</u>, const char *<u>system</u>);
       enum tracefs_dynevent_type <b>tracefs_dynevent_info</b>(struct tracefs_dynevent *<u>dynevent</u>, char **<u>system</u>, char **<u>event</u>, char **<u>prefix</u>, char **<u>addr</u>, char **<u>format</u>);
       struct tep_event *<b>tracefs_dynevent_get_event</b>(struct tep_handle *<u>tep</u>, struct tracefs_dynevent *<u>dynevent</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>tracefs_dynevent_create</b>() function creates dynamic event <u>devent</u> in the system.

       The <b>tracefs_dynevent_destroy</b>() function removes dynamic event <u>devent</u> from the system. If <u>force</u> is true,
       the function will attempt to disable all events in all trace instances, before removing the dynamic
       event. The <u>devent</u> context is not freed, use <b>tracefs_dynevent_free</b>() to free it.

       The <b>tracefs_dynevent_destroy_all</b>() function removes all dynamic events of given types from the system.
       The <u>types</u> parameter is a type of specific dynamic event, or a bitmask of dynamic events types
       <b>tracefs_dynevent_type</b>, that will be removed. If <u>types</u> is 0, dynamic events from all types will be
       removed. If <u>force</u> is true, the function will attempt to disable all events in all trace instances, before
       removing the dynamic events.

       The <b>tracefs_dynevent_get</b>() function allocates and returns a single instance of a dynamic event that
       matches the given <b>type</b>, <b>system</b> and <b>event</b> that is passed to it. NULL is returned if there is no match. The
       returned event is what is found in the system, and must be freed with <b>tracefs_dynevent_free</b>(). If <b>system</b>
       is NULL, then the first <b>event</b> of any system of the given type that has the name of <b>event</b> will be
       returned.

       The <b>tracefs_dynevent_get_all</b>() function allocates and returns an array of pointers to dynamic events of
       given types that exist in the system. The last element of the array is a NULL pointer. The array must be
       freed with <b>tracefs_dynevent_list_free</b>(). If there are no events a NULL pointer is returned. The <u>types</u>
       parameter is a type of specific dynamic event, or a bitmask of dynamic events types
       <b>tracefs_dynevent_type</b>, that will be retrieved. If <u>types</u> is 0, dynamic events from all types will be
       retrieved.

       The <b>tracefs_dynevent_free</b>() function frees a dynamic event context <u>devent</u>.

       The <b>tracefs_dynevent_list_free</b>() function frees an array of pointers to dynamic event, returned by
       <b>tracefs_dynevent_get_all()</b> API.

       The <b>tracefs_dynevent_info</b>() function returns the type and information of a given dynamic event <u>dynevent</u>.
       If any of the <u>system</u>, <u>event</u>, <u>prefix</u>, <u>addr</u> or <u>format</u> arguments are not NULL, then strings are allocated
       and returned back via these arguments. The <u>system</u> and <u>event</u> holds the system and the name of the dynamic
       event. If <u>prefix</u> is non NULL, then it will hold an allocated string that holds the prefix portion of the
       dynamic event (the content up to the ":", exluding it). If <u>addr</u> is non NULL, it will hold the address or
       function that the dynamic event is attached to, if relevant for this event type. If <u>format</u> is non NULL,
       it will hold the format string of the dynamic event. Note, that the content in <u>group</u>, <u>event</u>, <u>prefix</u>,
       <u>addr</u>, and <u>format</u> must be freed with <a href="../man3/free.3.html">free</a>(3) if they are set.

       The <b>tracefs_dynevent_get_event</b>() function returns a tep event, describing the given dynamic event. The
       API detects any newly created or removed dynamic events. The returned pointer to tep event is controlled
       by @tep and must not be freed.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>tracefs_dynevent_create</b>() returns 0 on success, or -1 on error. If a parsing error occurs then
       <b><a href="../man3/tracefs_error_last.3.html">tracefs_error_last</a></b>(3) may be used to retrieve the error message explaining the parsing issue.

       <b>tracefs_dynevent_destroy</b>() and <b>tracefs_dynevent_destroy_all</b>() return 0 on success, or -1 on error. If
       <u>force</u> is enabled, the functions may fail on disabling the events.

       <b>tracefs_dynevent_get</b>() function returns an allocated dynamic event from the system that matches the type,
       system and event given.

       <b>tracefs_dynevent_get_all</b>() function returns allocated array of pointers to dynamic events, or NULL in
       case of an error or in case there are no events in the system. That array must be freed by
       <b>tracefs_dynevent_list_free</b>().

       <b>tracefs_dynevent_info</b>() returns the type of the given dynamic event or TRACEFS_DYNEVENT_UNKNOWN on error.
       If <u>system</u>, <u>event</u>, <u>prefix</u>, <u>addr</u>, or <u>format</u> are non NULL, they will contain allocated strings that must be
       freed by <a href="../man3/free.3.html">free</a>(3).

       The <b>tracefs_dynevent_get_event</b>() function returns a pointer to a tep event or NULL in case of an error or
       if the requested dynamic event is missing. The returned pointer to tep event is controlled by @tep and
       must not be freed.

</pre><h4><b>ERRORS</b></h4><pre>
       The following errors are for all the above calls:

       <b>ENODEV</b> dynamic events of requested type are not configured for the running kernel.

       <b>ENOMEM</b> Memory allocation error.

       <b>tracefs_dynevent_create</b>() can fail with the following errors:

       <b>EINVAL</b> Most likely a parsing error occurred (use <b><a href="../man3/tracefs_error_last.3.html">tracefs_error_last</a></b>(3) to possibly see what that error
       was).

       Other errors may also happen caused by internal system calls.

</pre><h4><b>EXAMPLE</b></h4><pre>
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;sys/wait.h&gt;

           #include &lt;tracefs.h&gt;

           static struct tep_event *open_event;
           static struct tep_format_field *file_field;

           static struct tep_event *openret_event;
           static struct tep_format_field *ret_field;

           static int callback(struct tep_event *event, struct tep_record *record,
                               int cpu, void *data)
           {
                   struct trace_seq seq;

                   trace_seq_init(&amp;seq);
                   tep_print_event(event-&gt;tep, &amp;seq, record, "%d-%s: ", TEP_PRINT_PID, TEP_PRINT_COMM);

                   if (event-&gt;id == open_event-&gt;id) {
                           trace_seq_puts(&amp;seq, "open file='");
                           tep_print_field(&amp;seq, record-&gt;data, file_field);
                           trace_seq_puts(&amp;seq, "'\n");
                   } else if (event-&gt;id == openret_event-&gt;id) {
                           unsigned long long ret;
                           tep_read_number_field(ret_field, record-&gt;data, &amp;ret);
                           trace_seq_printf(&amp;seq, "open ret=%lld\n", ret);
                   } else {
                           goto out;
                   }

                   trace_seq_terminate(&amp;seq);
                   trace_seq_do_printf(&amp;seq);
           out:
                   trace_seq_destroy(&amp;seq);

                   return 0;
           }

           static pid_t run_exec(char **argv, char **env)
           {
                   pid_t pid;

                   pid = fork();
                   if (pid)
                           return pid;

                   execve(argv[0], argv, env);
                   perror("exec");
                   exit(-1);
           }

           const char *mykprobe = "my_kprobes";

           int main (int argc, char **argv, char **env)
           {
                   struct tracefs_dynevent *kprobe, *kretprobe;
                   const char *sysnames[] = { mykprobe, NULL };
                   struct tracefs_instance *instance;
                   struct tep_handle *tep;
                   pid_t pid;

                   if (argc &lt; 2) {
                           printf("usage: %s command\n", argv[0]);
                           exit(-1);
                   }

                   instance = tracefs_instance_create("exec_open");
                   if (!instance) {
                           perror("creating instance");
                           exit(-1);
                   }

                   tracefs_dynevent_destroy_all(TRACEFS_DYNEVENT_KPROBE | TRACEFS_DYNEVENT_KRETPROBE, true);

                   kprobe = tracefs_kprobe_alloc(mykprobe, "open", "do_sys_openat2",
                                                 "file=+0($arg2):ustring flags=+0($arg3):x64 mode=+8($arg3):x64\n");
                   kretprobe = tracefs_kretprobe_alloc(mykprobe, "openret", "do_sys_openat2", "ret=%ax", 0);
                   if (!kprobe || !kretprobe) {
                           perror("allocating dynamic events");
                           exit(-1);
                   }

                   if (tracefs_dynevent_create(kprobe) || tracefs_dynevent_create(kretprobe)){
                           char *err = tracefs_error_last(NULL);
                           perror("Failed to create kprobes:");
                           if (err &amp;&amp; strlen(err))
                                   fprintf(stderr, "%s\n", err);
                           exit(-1);
                   }

                   tep = tracefs_local_events_system(NULL, sysnames);
                   if (!tep) {
                           perror("reading events");
                           exit(-1);
                   }
                   open_event = tep_find_event_by_name(tep, mykprobe, "open");
                   file_field = tep_find_field(open_event, "file");

                   openret_event = tep_find_event_by_name(tep, mykprobe, "openret");
                   ret_field = tep_find_field(openret_event, "ret");

                   tracefs_event_enable(instance, mykprobe, NULL);
                   pid = run_exec(&amp;argv[1], env);

                   /* Let the child start to run */
                   sched_yield();

                   do {
                           tracefs_load_cmdlines(NULL, tep);
                           tracefs_iterate_raw_events(tep, instance, NULL, 0, callback, NULL);
                   } while (waitpid(pid, NULL, WNOHANG) != pid);

                   /* Will disable the events */
                   tracefs_dynevent_destroy_all(TRACEFS_DYNEVENT_KPROBE | TRACEFS_DYNEVENT_KRETPROBE, true);
                   tracefs_dynevent_free(kprobe);
                   tracefs_dynevent_free(kretprobe);
                   tracefs_instance_destroy(instance);
                   tep_free(tep);

                   return 0;
           }

</pre><h4><b>FILES</b></h4><pre>
           <b>tracefs.h</b>
                   Header file to include in order to have access to the library APIs.
           <b>-ltracefs</b>
                   Linker switch to add when building a program that uses the library.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/libtracefs.3.html">libtracefs</a></b>(3), <b><a href="../man3/libtraceevent.3.html">libtraceevent</a></b>(3), <b><a href="../man1/trace-cmd.1.html">trace-cmd</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
           <b>Steven</b> <b>Rostedt</b> &lt;<b><a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a></b>[1]&gt;
           <b>Tzvetomir</b> <b>Stoyanov</b> &lt;<b><a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a></b>[2]&gt;
           <b>Yordan</b> <b>Karadzhov</b> &lt;<b><a href="mailto:y.karadz@gmail.com">y.karadz@gmail.com</a></b>[3]&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<b><a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a></b>[4]&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       libtracefs is Free Software licensed under the GNU LGPL 2.1

</pre><h4><b>RESOURCES</b></h4><pre>
       <b>https://git.kernel.org/pub/scm/libs/libtrace/libtracefs.git/</b>

</pre><h4><b>COPYING</b></h4><pre>
       Copyright (C) 2021 VMware, Inc. Free use of this software is granted under the terms of the GNU Public
       License (GPL).

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a>
           <a href="mailto:rostedt@goodmis.org">mailto:rostedt@goodmis.org</a>

        2. <a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a>
           <a href="mailto:tz.stoyanov@gmail.com">mailto:tz.stoyanov@gmail.com</a>

        3. <a href="mailto:y.karadz@gmail.com">y.karadz@gmail.com</a>
           <a href="mailto:y.karadz@gmail.com">mailto:y.karadz@gmail.com</a>

        4. <a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a>
           <a href="mailto:linux-trace-devel@vger.kernel.org">mailto:linux-trace-devel@vger.kernel.org</a>

libtracefs 1.8.1                                   06/05/2025                                      <u><a href="../man3/LIBTRACEFS.3.html">LIBTRACEFS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>