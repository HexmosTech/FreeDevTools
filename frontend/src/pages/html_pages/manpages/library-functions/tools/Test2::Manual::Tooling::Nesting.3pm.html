<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test2::Manual::Tooling::Nesting - Tutorial for using other tools within your own.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest2-suite-perl">libtest2-suite-perl_0.000163-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test2::Manual::Tooling::Nesting - Tutorial for using other tools within your own.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Sometimes you find yourself writing the same test pattern over and over, in such cases you may want to
       encapsulate the logic in a new test function that calls several tools together. This sounds easy enough,
       but can cause headaches if not done correctly.

</pre><h4><b>NAIVE</b> <b>WAY</b></h4><pre>
       Lets say you find yourself writing the same test pattern over and over for multiple objects:

           my $obj1 = $class1-&gt;new;
           is($obj1-&gt;foo, 'foo', "got foo");
           is($obj1-&gt;bar, 'bar', "got bar");

           my $obj2 = $class1-&gt;new;
           is($obj2-&gt;foo, 'foo', "got foo");
           is($obj2-&gt;bar, 'bar', "got bar");

           ... 10x more times for classes 2-12

       The naive way to do this is to write a check_class() function like this:

           sub check_class {
               my $class = shift;
               my $obj = $class-&gt;new;
               is($obj-&gt;foo, 'foo', "got foo");
               is($obj-&gt;bar, 'bar', "got bar");
           }

           check_class($class1);
           check_class($class2);
           check_class($class3);
           ...

       This will appear to work fine, and you might not notice any problems, <u>so</u> <u>long</u> <u>as</u> <u>the</u> <u>tests</u> <u>are</u> <u>passing.</u>

   <b>WHATS</b> <b>WRONG</b> <b>WITH</b> <b>IT?</b>
       The problems with the naive approach become obvious if things start to fail.  The diagnostics that tell
       you what file and line the failure occurred on will be wrong. The failure will be reported to the line
       <u>inside</u> "check_class", not to the line where check_class() was called. This is problem because it leaves
       you with no idea which class is failing.

   <b>HOW</b> <b>TO</b> <b>FIX</b> <b>IT</b>
       Luckily this is extremely easy to fix. You need to acquire a context object at the start of your
       function, and release it at the end... yes it is that simple.

           use Test2::API qw/context/;

           sub check_class {
               my $class = shift;

               my $ctx = context();

               my $obj = $class-&gt;new;
               is($obj-&gt;foo, 'foo', "got foo");
               is($obj-&gt;bar, 'bar', "got bar");

               $ctx-&gt;release;
           }

       See, that was easy. With these 2 additional lines we know have proper file+line reporting. The nested
       tools will find the context we acquired here, and know to use it's file and line numbers.

       <u>THE</u> <u>OLD</u> <u>WAY</u> <u>(DO</u> <u>NOT</u> <u>DO</u> <u>THIS</u> <u>ANYMORE)</u>

       With Test::Builder there was a global variables called $Test::Builder::Level which helped solve this
       problem:

           sub check_class {
               my $class = shift;

               local $Test::Builder::Level = $Test::Builder::Level + 1;

               my $obj = $class-&gt;new;
               is($obj-&gt;foo, 'foo', "got foo");
               is($obj-&gt;bar, 'bar', "got bar");
           }

       This variable worked well enough (and will still work) but was not very discoverable. Another problem
       with this variable is that it becomes cumbersome if you have a more deeply nested code structure called
       the nested tools, you might need to count stack frames, and hope they never change due to a third party
       module. The context solution has no such caveats.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Test2::Manual - Primary index of the manual.

</pre><h4><b>SOURCE</b></h4><pre>
       The source code repository for Test2-Manual can be found at <u>https://github.com/Test-More/Test2-Suite/</u>.

</pre><h4><b>MAINTAINERS</b></h4><pre>
       Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;

</pre><h4><b>AUTHORS</b></h4><pre>
       Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2018 Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

       See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.38.2                                       2024-06-07               <u>Test2::Manual::Tooling::<a href="../man3pm/Nesting.3pm.html">Nesting</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>