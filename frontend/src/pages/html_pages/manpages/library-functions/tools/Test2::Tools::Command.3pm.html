<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test2::Tools::Command - test simple unix commands</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest2-tools-command-perl">libtest2-tools-command-perl_0.20-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test2::Tools::Command - test simple unix commands

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Test2::Tools::Command;

         # test some typical unix tools; implicit checks are that status
         # is 0, and that stdout and stderr are the empty string, unless
         # otherwise specified
         command { args =&gt; [ 'true'        ] };
         command { args =&gt; [ 'false'       ], status =&gt; 1 };
         command { args =&gt; [ 'echo', 'foo' ], stdout =&gt; "foo\n" };

         # subsequent args are prefixed with this
         local @Test2::Tools::Command::command = ( 'perl', '-E' );

         # return values and a variety of the options available
         my ($result, $exit_status, $stdout_ref, $stderr_ref) =
          command { args    =&gt; [ q{say "out";warn "err";kill TERM =&gt; $$} ],
                    chdir   =&gt; '/some/dir',
                    env     =&gt; { API_KEY =&gt; 42 },
                    stdin   =&gt; "printed to program\n",
                    stdout  =&gt; qr/out/,
                    stderr  =&gt; qr/err/,
                    status  =&gt; { code =&gt; 0, signal =&gt; 15, iscore =&gt; 0 },
                    timeout =&gt; 7 };

         # check on a $? exit status word from somewhere
         is_exit $?, 42;
         is_exit $?, { code =&gt; 0, signal =&gt; 9, iscore =&gt; 0 };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module tests that commands given particular arguments result in particular outputs by way of the
       exit status word, standard output, and standard error. Various parameters to the <b>command</b> function alter
       exactly how this is done, in addition to variables that can be set.

       The commands are expected to be simple, for example filters that maybe accept standard input and respond
       with some but not too much output.  Interactive or otherwise complicated commands will need some other
       module such as Expect to test them, as will programs that generate too much output.

       Also, <b>is_exit</b> is provided to check on the 16-bit exit status word from other code.

</pre><h4><b>VARIABLES</b></h4><pre>
       These are not exported.

       <b>@command</b>
           Custom command to prefix any commands run by <b>command</b> with, for example to specify a test program that
           will be used in many subsequent tests

             local @Test2::Tools::Command::command = ($^X, '--', 'bin/foo');
             command { args =&gt; [ 'bar', '-c', 'baz' ] };

           will result in "perl -- bin/foo bar -c baz" being run.

           If  <u>chdir</u>  is  used,  a  command  that uses a relative path may need to be fully qualified, e.g. with
           "rel2abs" of File::Spec::Functions.

       <b>$timeout</b>
           Seconds after which commands will be timed out via "alarm" if a <u>timeout</u> is not given to  <b>command</b>.  30
           by default.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       <b>command</b>  is exported by default; this can be disabled by using this module with an empty import list. The
       test keys are <u>status</u>, <u>stdout</u>, and <u>stderr</u>. The other keys influence how the command is run or change  test
       metadata.

       <b>command</b> <u>hashref</u>
           Runs  a  command and executes one or more tests on the results, depending on the contents of <u>hashref</u>,
           which may contain:

           <u>args</u> =&gt; <u>arrayref</u>
               List of arguments to run the command with. The argument list will be  prefixed  by  the  <b>@command</b>
               variable, if that is set.

           <u>binmode</u> =&gt; <u>layer</u>
               If set, <u>layer</u> will be set on the filehandles wired to the command via the "binmode" function. See
               also open.

           <u>chdir</u> =&gt; <u>directory</u>
               Attempt to "chdir" into <u>directory</u> or failing that will throw an exception, by way of File::chdir.

               A  command  that  uses  a  relative  path may need to be fully qualified, e.g.  with "rel2abs" of
               File::Spec::Functions.

           <u>env</u> =&gt; <u>hashref</u>
               Set the environment for the command to include the keys and values present in  <u>hashref</u>.  This  is
               additive  only;  environment  variables  that  must  not be set must be deleted from %ENV, or the
               command wrapped with a command that can reset the environment, such as <b><a href="../man1/env.1.html">env</a></b>(1).

           <u>name</u> =&gt; <u>string</u>
               Custom name for the tests. Otherwise, the full command executed is used in the test  name,  which
               may not be ideal.

           <u>munge_signal</u> =&gt; <u>boolean</u>
               If  the  signal  number  of the 16-bit exit status word is not zero, the signal will be munged to
               have the value 1.

           <u>munge_status</u> =&gt; <u>boolean</u>
               If the exit code of the 16-bit exit status word is not zero, the code will be munged to have  the
               value  1.  Use this where the program being tested is unpredictable as to what non-zero exit code
               it will use.

           <u>status</u> =&gt; <u>code-or-hashref</u>
               Expect the given value as the 16-bit exit status word. By default 0 for the exit code is assumed.
               This can be specified in two different forms; the following two are equivalent:

                 status =&gt; 42
                 status =&gt; { code =&gt; 42, iscore =&gt; 0, signal =&gt; 0 }

               Obviously the 16-bit exit status word is decomposed into a hash  reference.  If  the  program  is
               instead expected to exit by a SIGPIPE, one might use:

                 status =&gt; { code =&gt; 0, iscore =&gt; 0, signal =&gt; 13 }

               See also <u>munge_signal</u> and <u>munge_status</u>.

           <u>stdin</u> =&gt; <u>data</u>
               If  present,  <u>data</u>  will  be  printed  to  the  command  and  then standard input will be closed.
               Otherwise, nothing is done with standard input.

           <u>stdout</u> =&gt; <u>qr-or-string</u>
               Expect that the standard output of the command exactly matches the given string, or if the string
               is a "qr//" regular expression, that the output matches that expression.

           <u>stderr</u> =&gt; <u>qr-or-string</u>
               Expect that the standard err of the command exactly matches the given string, or if the string is
               a "qr//" regular expression, that the stderr matches that expression.

           <u>timeout</u> =&gt; <u>seconds</u>
               Set a custom timeout for the "alarm" call that wraps the command. The variable <b>$timeout</b>  will  be
               used if this is unset.

           <b>command</b>  returns  a list consisting of the result of the tests, the original 16-bit exit status word,
           and scalar references to strings that contain the standard output and  standard  error  of  the  test
           program, if any.

             my ($result, $status, $out_ref, $err_ref) = command { ...

       <b>is_exit</b> <u>status</u> [ <u>code-or-hashref</u> [ <u>test-name</u> ] ]
           This  routine  checks  that a 16-bit exit status word (usually by way of the $? variable) conforms to
           some code or hash reference. The hash reference may contain <u>mungle_signal</u> and <u>munge_status</u> that  will
           turn non-zero signal or codes into 1.

             is_exit $?, 42;
             is_exit $?, { code =&gt; 0, signal =&gt; 9, iscore =&gt; 0 };

</pre><h4><b>BUGS</b></h4><pre>
       None known. There are probably portability problems if you stray from the unix path.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Test2::Suite

       Expect may be necessary to test complicated programs.

       IPC::Open3 is used to run programs; this may run into portability problems on systems that stray from the
       way of unix?

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2022 Jeremy Mates

       This       program       is       distributed       under       the      (Revised)      BSD      License:
       &lt;https://opensource.org/licenses/BSD-3-Clause&gt;

perl v5.36.0                                       2023-01-15                         <u>Test2::Tools::<a href="../man3pm/Command.3pm.html">Command</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>