<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::Accessor::Lite - a minimalistic variant of Class::Accessor</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-accessor-lite-perl">libclass-accessor-lite-perl_0.08-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::Accessor::Lite - a minimalistic variant of Class::Accessor

</pre><h4><b>SYNOPSIS</b></h4><pre>
           package MyPackage;

           use Class::Accessor::Lite (
               new =&gt; 1,
               rw  =&gt; [ qw(foo bar) ],
               ro  =&gt; [ qw(baz) ],
               wo  =&gt; [ qw(hoge) ],
           );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The module is a variant of "Class::Accessor".  It is fast and requires less typing, has no dependencies
       to other modules, and does not mess up the @ISA.

</pre><h4><b>THE</b> <b>USE</b> <b>STATEMENT</b></h4><pre>
       The use statement (i.e. the "import" function) of the module takes a single hash as an argument that
       specifies the types and the names of the properties.  Recognises the following keys.

       new =&gt; $true_or_false
           the  default  constructor  is  created if the value evaluates to true, otherwise nothing is done (the
           default behaviour)

       rw =&gt; \@name_of_the_properties
           creates a read / write accessor for the name of the properties passed through as an arrayref

       ro =&gt; \@name_of_the_properties
           creates a read-only accessor for the name of the properties passed through as an arrayref

       wo =&gt; \@name_of_the_properties
           creates a write-only accessor for the name of the properties passed through as an arrayref

       For more detailed explanation read the following section describing the behaviour of each  function  that
       actually creates the accessors.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       As  of  version  0.04  the properties can be specified as the arguments to the "use" statement (as can be
       seen in the SYNOPSIS) which is now the recommended way of using the module,  but  for  compatibility  the
       following functions are provided as well.

   <b>Class::Accessor::Lite-&gt;mk_accessors(@name_of_the_properties)</b>
       Creates  an  accessor  in  current  package  under  the  name  specified by the arguments that access the
       properties (of a hashref) with the same name.

   <b>Class::Accessor::Lite-&gt;mk_ro_accessors(@name_of_the_properties)</b>
       Same as <b>mk_accessors()</b> except it will generate read-only accessors (i.e. true accessors).  If you attempt
       to set a value with these accessors it will throw an exception.

   <b>Class::Accessor::Lite-&gt;mk_wo_accessors(@name_of_the_properties)</b>
       Same as <b>mk_accessors()</b> except it will generate write-only accessors (i.e. mutators).  If you  attempt  to
       read a value with these accessors it will throw an exception.

   <b>Class::Accessor::Lite-&gt;mk_new()</b>
       Creates the "new" function that accepts a hash or a hashref as the initial properties of the object.

   <b>Class::Accessor::Lite-&gt;mk_new_and_accessors(@name_of_the_properties)</b>
       DEPRECATED.  Use the new "use Class::Accessor::Lite (...)" style.

</pre><h4><b>FAQ</b></h4><pre>
   <b>Can</b> <b>I</b> <b>use</b> <b>"Class::Accessor::Lite"</b> <b>in</b> <b>an</b> <b>inherited</b> <b>module?</b>
       Yes  in most cases, when the class object in the super class is implemented using a hashref.  However you
       _should_ _not_ create the constructor for the inherited class by calling "&lt;Class::Accessor::Lite-"<b>new()</b>&gt;&gt;
       or by "&lt;use Class::Accessor::Lite (new =" 1)&gt;&gt;.  The only other thing that  "Class::Accessor::Lite"  does
       is to set up the accessor functions for given property names through a blessed hashref.

   <b>What</b> <b>happens</b> <b>when</b> <b>passing</b> <b>more</b> <b>than</b> <b>one</b> <b>arguments</b> <b>to</b> <b>the</b> <b>accessor?</b>
       When  the  accessor  built  by Class::Accessor::Lite is given more than one arguments, a reference to the
       arguments will be saved as an arrayref.  This behaviour might not be necessary but is implemented  as  is
       to maintain compatibility with Class::Accessor::Fast.

           my @data = (1, 2, 3);
           $obj-&gt;someproperty(@data);

           $obj-&gt;someproperty-&gt;[2]++; # $data[3] is incremented

       In general, you should pass an arrayref to set an arrayref to a property.

           my @data = (1, 2, 3);
           $obj-&gt;someproperty([ @data ]); # save a copy using arrayref

           $obj-&gt;someproper-&gt;[2]++; # @data is not modified

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Class::Accessor

       Class::Accessor::Lite

</pre><h4><b>AUTHORS</b></h4><pre>
       Copyright (C) 2008 - 2010 Kazuho Oku

</pre><h4><b>LICENSE</b></h4><pre>
       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself, either Perl version 5.8.6 or, at your option, any later version of Perl 5 you may have available.

perl v5.36.0                                       2022-10-22                         <u>Class::Accessor::<a href="../man3pm/Lite.3pm.html">Lite</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>