<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>accessors - create accessor methods in caller's package.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libaccessors-perl">libaccessors-perl_1.01-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       accessors - create accessor methods in caller's package.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package Foo;
         use accessors qw( foo bar baz );

         my $obj = bless {}, 'Foo';

         # generates chaining accessors
         # that you can set like this:
         $obj-&gt;foo( 'hello ' )
             -&gt;bar( 'world' )
             -&gt;baz( "!\n" );

         # you get the values by passing no params:
         print $obj-&gt;foo, $obj-&gt;bar, $obj-&gt;baz;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>accessors</b> pragma lets you create simple accessors at compile-time.

       This saves you from writing them by hand, which tends to result in <u>cut-n-paste</u> errors and a mess of
       duplicated code.  It can also help you reduce the ammount of unwanted <u>direct-variable</u> <u>access</u> that may
       creep into your codebase when you're feeling lazy.  <b>accessors</b> was designed with laziness in mind.

       Method-chaining accessors are generated by default.  Note that you can still use accessors::chained
       directly for reasons of backwards compatibility.

       See accessors::classic for accessors that always return the current value if you don't like method
       chaining.

</pre><h4><b>GENERATED</b> <b>METHODS</b></h4><pre>
       <b>accessors</b> will generate methods that return the current object on set:

         sub foo {
             my $self = shift;
             if (@_) { $self-&gt;{-foo} = shift; return $self; }
             else    { return $self-&gt;{-foo}; }
         }

       This way they can be <u>chained</u> together.

   <b>Why</b> <b>prepend</b> <b>the</b> <b>dash?</b>
       The dash ("-") is prepended to the property name for a few reasons:

       •   interoperability with Error.

       •   to make it difficult to accidentally access the property directly ala:

             use accessors qw( foo );
             $obj-&gt;{foo};  # prevents this by mistake
             $obj-&gt;foo;    # when you probably meant this

           (this might sound woolly, but it's easy enough to do).

       •   syntactic sugar (this <u>is</u> woolly :).

       You  shouldn't care too much about how the property is stored anyway - if you do, you're likely trying to
       do something special (and should really consider writing the accessors out long hand), or it's  simply  a
       matter of preference in which case you can use accessors::classic, or sub-class this module.

</pre><h4><b>PERFORMANCE</b></h4><pre>
       There  is  <b>little-to-no</b>  <b>performace</b>  <b>hit</b>  when  using  generated  accessors;  in  fact there is <b>usually</b> <b>a</b>
       <b>performance</b> <b>gain</b>.

       •   typically <u>10-30%</u> <u>faster</u> than hard-coded accessors (like the above example).

       •   typically <u>1-15%</u> <u>slower</u> than <u>optimized</u> accessors (less readable).

       •   typically a <u>small</u> performance hit at startup (accessors are created at compile-time).

       •   uses the same anonymous sub to reduce memory consumption (sometimes by 80%).

       See the benchmark tests included with this distribution for more details.

</pre><h4><b>MOTIVATION</b></h4><pre>
       The main difference between the <b>accessors</b> pragma and other accessor generators is <b>simplicity</b>.

       •   interface

           <b>use</b> <b>accessors</b> <b>qw(</b> <b>...</b> <b>)</b> is as easy as it gets.

       •   a pragma

           it fits in nicely with the <b>base</b> pragma:

             use base      qw( Some::Class );
             use accessors qw( foo bar baz );

           and accessors get created at compile-time.

       •   no bells and whistles

           The module is extensible instead.

</pre><h4><b>SUB-CLASSING</b></h4><pre>
       If you prefer a different style of accessor or you need to do something more complicated, there's nothing
       to  stop  you  from  sub-classing.   It  should  be  pretty  easy.   Look   through   accessors::classic,
       accessors::ro, and accessors::rw to see how it's done.

</pre><h4><b>CAVEATS</b></h4><pre>
       Classes  using  blessed  scalarrefs,  arrayrefs,  etc.  are  not  supported for sake of simplicity.  Only
       hashrefs are supported.

</pre><h4><b>THANKS</b></h4><pre>
       Thanks to Michael G. Schwern for indirectly inspiring this module, and for his feedback &amp; suggestions.

       Also to Paul Makepeace and David Wright  for  showing  me  faster  accessors,  to  chocolateboy  for  his
       contributions,  the  CPAN  Testers for their bug reports, and to James Duncan and people on London.pm for
       their feedback.

</pre><h4><b>AUTHOR</b></h4><pre>
       Steve Purkis &lt;<a href="mailto:spurkis@cpan.org">spurkis@cpan.org</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       accessors::classic, accessors::chained

       Similar and related modules:

       base,  fields,  Class::Accessor,  Class::Struct,   Class::Methodmaker,   Class::Generate,   Class::Class,
       Class::Tangram, Object::Tiny

perl v5.36.0                                       2022-10-13                                     <u><a href="../man3pm/accessors.3pm.html">accessors</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>