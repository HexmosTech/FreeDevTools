<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unicode_canonical, unicode_ccc, unicode_decomposition_init, unicode_decomposition_deinit,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcourier-unicode-dev">libcourier-unicode-dev_2.3.2-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unicode_canonical, unicode_ccc, unicode_decomposition_init, unicode_decomposition_deinit,
       unicode_decompose, unicode_decompose_reallocate_size, unicode_compose, unicode_composition_init,
       unicode_composition_deinit, unicode_composition_apply - unicode canonical normalization and
       denormalization

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;courier-unicode.h&gt;</b>

       <b>unicode_canonical_t</b> <b>unicode_canonical(char32_t</b> <u>c</u><b>);</b>

       <b>uint8_t</b> <b>unicode_ccc(char32_t</b> <u>c</u><b>);</b>

       <b>void</b> <b>unicode_decomposition_init(unicode_decomposition_t</b> <b>*</b><u>info</u><b>,</b> <b>char32_t</b> <b>*</b><u>string</u><b>,</b> <b>size_t</b> <b>*</b><u>string_size</u><b>,</b>
                                       <b>void</b> <b>*</b><u>arg</u><b>);</b>

       <b>int</b> <b>unicode_decompose(unicode_decomposition_t</b> <b>*</b><u>info</u><b>);</b>

       <b>void</b> <b>unicode_decomposition_deinit(unicode_decomposition_t</b> <b>*</b><u>info</u><b>);</b>

       <b>size_t</b> <b>unicode_decompose_reallocate_size(unicode_decomposition_t</b> <b>*</b><u>info</u><b>,</b> <b>const</b> <b>size_t</b> <b>*</b><u>sizes</u><b>,</b> <b>size_t</b> <u>n</u><b>);</b>

       <b>int</b> <b>unicode_compose(char32_t</b> <b>*</b><u>string</u><b>,</b> <b>size_t</b> <u>string_size</u><b>,</b> <b>int</b> <u>flags</u><b>,</b> <b>size_t</b> <b>*</b><u>new_size</u><b>);</b>

       <b>int</b> <b>unicode_composition_init(const</b> <b>char32_t</b> <b>*</b><u>string</u><b>,</b> <b>size_t</b> <u>string_size</u><b>,</b> <b>int</b> <u>flags</u><b>,</b>
                                    <b>unicode_composition_t</b> <b>*</b><u>compositions</u><b>);</b>

       <b>void</b> <b>unicode_composition_deinit(unicode_composition_t</b> <b>*</b><u>compositions</u><b>);</b>

       <b>size_t</b> <b>unicode_composition_apply(char32_t</b> <b>*</b><u>string</u><b>,</b> <b>size_t</b> <u>string_size</u><b>,</b>
                                        <b>unicode_composition_t</b> <b>*</b><u>compositions</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions compose or decompose a Unicode string into a canonical or a compatible normalized form.

       <b>unicode_canonical</b>() looks up the character's <b>canonical</b> <b>and</b> <b>compatibility</b> <b>mapping</b>[1].  <b>unicode_canonical</b>()
       returns a structure with the following fields:

       <u>canonical_chars</u>
           A pointer to the canonical or equivalent representation of the character.

       <u>n_canonical_chars</u>
           Number of characters in the <u>canonical_chars</u>.

       <u>format</u>
           A value of UNICODE_CANONICAL_FMT_NONE indicates a canonical mapping, other values indicate a
           compatibility equivalent mapping.

       A NULL <u>canonical_chars</u> (with a 0 <u>n_canonical_chars</u>) indicates that the character has no canonical or
       compatibility equivalence.

       <b>unicode_ccc</b>() returns the character's canonical combining class value.

       <b>unicode_decomposition_init</b>(), <b>unicode_decompose</b>() and <b>unicode_decomposition_deinit</b>() implement a complete
       interface for decomposing a Unicode string:

           unicode_decomposition_t info;

           unicode_decomposition_init(&amp;info, before, (size_t)-1, NULL);
           info.decompose_flags=UNICODE_DECOMPOSE_FLAG_QC;
           unicode_decompose(&amp;info);
           unicode_decomposition_deinit(&amp;info);

       <b>unicode_decomposition_init</b>() initializes a new unicode_decomposition_t structure, that gets passed in as
       its first parameter. The second parameter is a pointer to a Unicode string, with the number of characters
       in the string in the third parameter. A string size of -1 indicates a \0-terminated string and calculates
       its <u>string_size</u> (which does not include the trailing \0. The last parameter is a void *, an opaque
       pointer that gets stored in the initialized unicode_decomposition_t object:
       typedef struct unicode_decomposition {
           char32_t   *<u>string</u>;
           size_t     <u>string_size</u>;
           int        <u>decompose_flags</u>;
           int        (*<u>reallocate)(</u>
                           struct unicode_decomposition   *<u>info</u>,
                           const size_t                   *<u>offsets</u>,
                           const size_t                   *<u>sizes</u>,
                           size_t                         <u>n</u>
                      );
           void       *<u>arg</u>;
       } unicode_decomposition_t;

       <b>unicode_decompose</b>() proceeds and decomposes the <u>string</u> and replaces it with its decomposed <u>string</u>
       version.

       unicode_decomposition_t's <u>string</u>, <u>string_size</u> and <u>arg</u> are copies of <b>unicode_decomposition_init</b>'s
       parameters.  <b>unicode_decomposition_init</b> initializes all other fields to their default values.

       The <u>decompose_flags</u> bitmask gets initialized to 0, and is a bit mask:

       UNICODE_DECOMPOSE_FLAG_QC
           Check each character's appropriate “quick check” property and skip decomposing Unicode characters
           that would get re-composed by <b>unicode_composition_apply</b>().

       UNICODE_DECOMPOSE_FLAG_COMPAT
           Perform a compatibility decomposition instead of a canonical decomposition.

       <u>reallocate</u> is a pointer to a function that gets called to reallocate a larger <u>string</u>.
       <b>unicode_decompose</b>() determines which characters in the <u>string</u> need decomposing and calls the <u>reallocate</u>
       function pointer zero or more times. Each call to <u>reallocate</u> passes information about where new
       characters will get inserted into the <u>string</u>.

       <u>reallocate</u> only needs to grow the size of the buffer where <u>string</u> points so that it's big enough to hold
       a larger, decomposed string; then update <u>string</u> accordingly.  <u>reallocate</u> should not update <u>string_size</u> or
       make any changes to the existing <u>string</u>, that's <b>unicode_decompose</b>()'s job (after <u>reallocate</u> returns).

       The <u>reallocate</u> callback function receives the following parameters.

       •   A pointer to the unicode_decomposition_t and, notably, its <u>arg</u>.

       •   A pointer to the array of offset indexes in the <u>string</u> where new characters will get inserted in
           order to hold the decomposed string.

       •   A pointer to the array that holds the number of characters that get inserted each corresponding
           offset.

       •   The size of the two arrays.

       <u>reallocate</u> must update the <u>string</u> if necessary to hold at least the number of characters that's the sum
       total of the initial <u>string_size</u> and the sum total of al <u>sizes</u>.

       <b>unicode_decomposition_init</b>() initializes the <u>reallocate</u> pointer to a default implementation that uses
       <b><a href="../man3/realloc.3.html">realloc</a></b>(3) and updates <u>string</u> with its return value. The application can use its own <u>reallocate</u> to handle
       this task on its own, and use <b>unicode_decompose_reallocate_size</b> to compute the minimum string size:

           size_t unicode_decompose_reallocate_size(unicode_decomposition_t *info,
                                                    const size_t *sizes,
                                                    size_t n)
           {
               size_t i;
               size_t new_size=info-&gt;string_size;

               for (i=0; i&lt;n; ++i)
                   new_size += sizes[i];

               return new_size;
           }

       The <u>reallocate</u> function returns 0 on success and a non-0 error code to report a failure; and
       <u>unicode_decompose</u>() does the same. The only error condition from <u>unicode_decompose</u>() is a non-0 error
       code from the <u>reallocate</u> function. Otherwise: a successful decomposition results in <u>unicode_decompose</u>()
       returning 0 and <b>unicode_decomposition_init</b>()'s <u>string</u> pointing to the decomposed string and <u>string_size</u>
       giving the number of characters in the decomposed string.

           <b>Note</b>

           <u>string_size</u> does not include the trailing \0 character. The input string also has its <u>string_size</u>
           specified without counting its \0 character. The default implementation of <u>reallocate</u> allocates an
           extra char32_t ands sets it to a \0. Therefore:

           •   If the Unicode string before decomposition has a trailing \0 and no decomposition occurs, and no
               calls to <u>reallocate</u> takes place: the <u>string</u> in the unicode_decomposition_t is unchanged and it's
               still \0-terminated.

           •   The default <u>reallocate</u> allocates an extra char32_t ands sets it to a \0; and it takes care of
               that for the decomposed string.

           •   An application that provides its own replacement <u>reallocate</u> is responsible for doing the same, if
               it wants the decomposed string to be \0 terminated.

           <b>Note</b>

           Multiple calls to the <u>reallocate</u> callback are possible. Each call to <u>reallocate</u> reflect the prior
           calls' decompositions. Example: the original string has five characters and the first call to
           <u>reallocate</u> had two offsets, at position 1 and 3, with a value of 1 for their both <u>sizes</u>. This effects
           transforming an original Unicode string "AAAAA" into "AXAAXAA" (with “A” representing unspecified
           characters in the original string, and “X” showing the two characters added in the first call to
           <b>reallocate</b>.

           A second call to <u>varname</u> with am offset at position 4, and a size of 1, results in the updated string
           of "AXAAYXAA" (with “Y”) marking an unspecified character inserted by the second call.

           <b>Note</b>

           Unicode string decomposition involves replacing a given Unicode character with one or more other
           characters. The sizes given to <u>reallocate</u> reflect the net addition to the Unicode string. For
           example: decomposing one Unicode character into three decomposed characters results in a call to
           <u>reallocate</u> reporting an insert of two more characters.

           <b>Note</b>

           <u>offsets</u> actually report the indices of each Unicode character that's getting decomposed. A 1:1
           decomposition of a Unicode Character gets reported as an additional <u>sizes</u> entry of 0.

       <b>unicode_decomposition_deinit</b>() releases all resources and destroys the unicode_decomposition_t; it is no
       longer valid.

           <b>Note</b>

           <b>unicode_decomposition_deinit</b>() does not <b><a href="../man3/free.3.html">free</a></b>(3) the <u>string</u>. The original string gets passed in to
           <b>unicode_decomposition_init</b>() and the decomposed string is left in the <u>string</u>.

       The default implementation of the <u>reallocate</u> function assumes the <u>string</u> is a <b><a href="../man3/malloc.3.html">malloc</a></b>(3)-ed string, and
       <b>realloc</b>s it.

           <b>Note</b>

           At this time <b>unicode_decomposition_deinit</b>() does nothing. All code should explicitly call it in order
           to remain forward-compatible (at the source level).

       <b>unicode_compose</b>() performs a canonical composition of a decomposed string. Its parameters are:

       •   A pointer to the decomposed Unicode string.

       •   The number of characters in the Unicode string. The Unicode string does not need to be \0-terminated;
           if it is this number does not include it.

       •   A flags bitmask, which can have the following values:

           UNICODE_COMPOSE_FLAG_REMOVEUNUSED
               Remove all combining marks after doing all canonical compositions. Normally any unused combining
               marks are left in place, in the combined text. This option removes them.

           UNICODE_COMPOSE_FLAG_ONESHOT
               Perform canonical composition once per character, and do not attempt to combine any resulting
               combined characters again.

       •   A non-NULL pointer to a size_t.

           A successful composition sets this size_t to the number of characters in the combined string, and
           returns 0. The combined string gets placed back into the <u>string</u> parameter, this string gets combined
           in place and this gives the size of the combined string.

           <b>unicode_compose</b>() returns a non-zero value to indicate an error.

       <b>unicode_composition_init</b>(), <b>unicode_composition_apply</b>() and <b>unicode_composition_deinit</b>() implement a
       detailed interface for canonical composition of a decomposed Unicode string:

           unicode_compositions_t compositions;

           if (unicode_composition_init(str, strsize, flags, &amp;compositions) == 0)
           {
               size_t new_size=unicode_composition_apply(str, strsize, &amp;compositions);

               unicode_composition_deinit(&amp;compositions);
           }

       The first two parameters to both <b>unicode_composition_init</b>() and <b>unicode_composition_apply</b>() are the same:
       the Unicode string and the number of characters (not including any trailing \0 character) in the Unicode
       string.

       <b>unicode_composition_init</b>()'s additional parameters are: any optional flags (see <b>unicode_compose()</b> for a
       list of available flags), and the address of a unicode_composition_t object. A non-0 return from
       <b>unicode_composition_init</b>() indicates an error.  <b>unicode_composition_init</b>() indicates success by returning
       0 and initializing the unicode_composition_t's object which contains a pointer to an array of pointers to
       of unicode_compose_info objects, and the number of pointers.  <b>unicode_composition_init</b>() does not change
       the string; the only thing it does is initialize the unicode_composition_t object.

       <b>unicode_composition_apply</b>() applies the compositions to the <u>string</u>, in place, and returns the new size of
       the <u>string</u> (also not including the \0 byte, however it does append one if the composed string is smaller,
       so the composed string is \0-terminated if the decomposed string was).

       It is necessary to call <b>unicode_composition_deinit</b>() to free all memory that was allocated for the
       unicode_composition_t object:
       struct unicode_compose_info {
           size_t                        <u>index</u>;
           size_t                        <u>n_composed</u>;
           char32_t                      *<u>composition</u>;
           size_t                        <u>n_composition</u>;
       };

       typedef struct {
           struct unicode_compose_info   **<u>compositions</u>;
           size_t                        <u>n_compositions</u>;
       } unicode_composition_t;

       <u>index</u> gives the character index in the <u>string</u> where each composition occurs.  <u>n_composed</u> gives the number
       of characters in the original string that get composed. The composed characters are the <u>composition</u>; and
       <u>n_composition</u> gives the number of composed characters.

       Effectively: at the <u>index</u> position in the original string, #<u>n_composed</u> characters get removed and there
       are #<u>n_composition</u> characters that replace them (always <u>n_composed</u> or less).

           <b>Note</b>

           The UNICODE_COMPOSE_FLAG_REMOVEUNUSED flag has the effect of including the combining marks that did
           not get combined in the <u>n_composed</u> count. It's possible that, in this case, <u>n_composition</u> is 0. This
           indicates complete removal of the combining marks, without anything getting combined in their place.

       <b>unicode_composition_init</b>() sets unicode_composition_t's <u>compositions</u> pointer to an array of pointers to
       unicode_compose_infos that are sorted according to their <u>index</u>.  <u>n_compositions</u> gives the number of
       pointers in the array, and is 0 if there are no compositions, the array is empty. The empty array gets
       interpreted accordingly when it gets passed to <b>unicode_composition_apply</b>() and
       <b>unicode_composition_deinit</b>(): nothing happens.  <b>unicode_composition_apply</b>() simply returns the size of
       the unchanged <u>string</u>, and <b>unicode_composition_deinit</b>() does a pro-forma cleanup.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>TR-15</b>[2], <b><a href="../man7/courier-unicode.7.html">courier-unicode</a></b>(7), <b>unicode::<a href="../man3/canonical.3.html">canonical</a></b>(3).

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>Sam</b> <b>Varshavchik</b>
           Author

</pre><h4><b>NOTES</b></h4><pre>
        1. canonical and compatibility mapping
           https://www.unicode.org/reports/tr15/tr15-54.html

        2. TR-15
           https://www.unicode.org/reports/tr15/tr15-54.html

Courier Unicode Library                            05/18/2024                               <u><a href="../man3/UNICODE_CANONICAL.3.html">UNICODE_CANONICAL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>