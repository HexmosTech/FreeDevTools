<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dbg - The Text Based Trace Facility</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dbg - The Text Based Trace Facility

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  implements  a text based interface to the <u>trace/3</u> and the <u>trace_pattern/2</u> BIFs. It makes it
       possible to trace functions, processes, ports and messages.

       To quickly get started on tracing function calls you can use the following code in the Erlang shell:

       1&gt; dbg:tracer(). %% Start the default trace message receiver
       {ok,&lt;0.36.0&gt;}
       2&gt; dbg:p(all, c). %% Setup call (c) tracing on all processes
       {ok,[{matched,nonode@nohost,26}]}
       3&gt; dbg:tp(lists, seq, x). %% Setup an exception return trace (x) on lists:seq
       {ok,[{matched,nonode@nohost,2},{saved,x}]}
       4&gt; lists:seq(1,10).
       (&lt;0.34.0&gt;) call lists:seq(1,10)
       (&lt;0.34.0&gt;) returned from lists:seq/2 -&gt; [1,2,3,4,5,6,7,8,9,10]
       [1,2,3,4,5,6,7,8,9,10]

       For more examples of how to use <u>dbg</u> from the Erlang shell, see the simple example section.

       The utilities are also suitable to use in system testing on large systems, where  other  tools  have  too
       much  impact  on  the system performance. Some primitive support for sequential tracing is also included,
       see the advanced topics section.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>fun2ms(LiteralFun)</b> <b>-&gt;</b> <b>MatchSpec</b>

              Types:

                 LiteralFun = fun() literal
                 MatchSpec = term()

              Pseudo function that by means of a <u>parse_transform</u> translates the <u>literal</u> <u>fun()</u> typed as parameter
              in the function call to a match specification as described in the <u>match_spec</u> manual of ERTS  users
              guide.  (With  literal I mean that the <u>fun()</u> needs to textually be written as the parameter of the
              function, it cannot be held in a variable which in turn is passed to the function).

              The parse transform is implemented in the module <u>ms_transform</u> and the source <u>must</u> include the file
              <u>ms_transform.hrl</u> in STDLIB for this pseudo function to work. Failing to include the  hrl  file  in
              the  source  will result in a runtime error, not a compile time ditto. The include file is easiest
              included by adding the line <u>-include_lib("stdlib/include/ms_transform.hrl").</u> to the source file.

              The <u>fun()</u> is very restricted, it can take only a single parameter (the parameter list to match), a
              sole variable or a list. It needs to use the <u>is</u><b>_</b>XXX  guard  tests  and  one  cannot  use  language
              constructs  that  have  no representation in a match_spec (like <u>if</u>, <u>case</u>, <u>receive</u> etc). The return
              value from the fun will be the return value of the resulting match_spec.

              Example:

              1&gt; dbg:fun2ms(fun([M,N]) when N &gt; 3 -&gt; return_trace() end).
              [{['$1','$2'],[{'&gt;','$2',3}],[{return_trace}]}]

              Variables from the environment can be imported, so that this works:

              2&gt; X=3.
              3
              3&gt; dbg:fun2ms(fun([M,N]) when N &gt; X -&gt; return_trace() end).
              [{['$1','$2'],[{'&gt;','$2',{const,3}}],[{return_trace}]}]

              The imported variables will be replaced by match_spec <u>const</u> expressions, which is consistent  with
              the  static  scoping  for  Erlang <u>fun()</u>s. Local or global function calls cannot be in the guard or
              body of the fun however. Calls to builtin match_spec functions of course is allowed:

              4&gt; dbg:fun2ms(fun([M,N]) when N &gt; X, is_atomm(M) -&gt; return_trace() end).
              Error: fun containing local erlang function calls ('is_atomm' called in guard)\
               cannot be translated into match_spec
              {error,transform_error}
              5&gt; dbg:fun2ms(fun([M,N]) when N &gt; X, is_atom(M) -&gt; return_trace() end).
              [{['$1','$2'],[{'&gt;','$2',{const,3}},{is_atom,'$1'}],[{return_trace}]}]

              As you can see by the example, the function can be called from the shell too. The <u>fun()</u>  needs  to
              be  literally  in  the call when used from the shell as well. Other means than the parse_transform
              are used in the shell case, but more or less the same  restrictions  apply  (the  exception  being
              records, as they are not handled by the shell).

          <b>Warning:</b>
              If  the parse_transform is not applied to a module which calls this pseudo function, the call will
              fail in runtime (with a <u>badarg</u>). The module <u>dbg</u> actually exports a function with this name, but it
              should never really  be  called  except  for  when  using  the  function  in  the  shell.  If  the
              <u>parse_transform</u>  is  properly applied by including the <u>ms_transform.hrl</u> header file, compiled code
              will never call the function, but the function call is replaced by a literal match_spec.

              More information is provided by the <u>ms_transform</u> manual page in STDLIB.

       <b>h()</b> <b>-&gt;</b> <b>ok</b>

              <u>h</u> stands for <u>h</u>elp. Gives a list of items for brief online help.

       <b>h(Item)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Item = atom()

              <u>h</u> stands for <u>h</u>elp. Gives a brief help text for functions in the dbg module.  The  available  items
              can be listed with <u>dbg:h/0</u>.

       <b>p(Item)</b> <b>-&gt;</b> <b>{ok,</b> <b>MatchDesc}</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Equivalent to <u>p(Item,</u> <u>[m])</u>.

       <b>p(Item,</b> <b>Flags)</b> <b>-&gt;</b> <b>{ok,</b> <b>MatchDesc}</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 MatchDesc = [MatchNum]
                 MatchNum = {matched, node(), integer()} | {matched, node(), 0, RPCError}
                 RPCError = term()

              <u>p</u>  stands for <u>p</u>rocess. Traces <u>Item</u> in accordance to the value specified by <u>Flags</u>. The variation of
              <u>Item</u> is listed below:

                <u>pid()</u> or <u>port()</u>:
                  The corresponding process or port is traced. The process or port may be a  remote  process  or
                  port  (on  another  Erlang  node).  The  node must be in the list of traced nodes (see <u>n/1</u> and
                  <u>tracer/3</u>).

                <u>all</u>:
                  All processes and ports in the system as well as all processes and ports created hereafter are
                  to be traced.

                <u>processes</u>:
                  All processes in the system as well as all processes created hereafter are to be traced.

                <u>ports</u>:
                  All ports in the system as well as all ports created hereafter are to be traced.

                <u>new</u>:
                  All processes and ports created after the call is are to be traced.

                <u>new_processes</u>:
                  All processes created after the call is are to be traced.

                <u>new_ports</u>:
                  All ports created after the call is are to be traced.

                <u>existing</u>:
                  All existing processes and ports are traced.

                <u>existing_processes</u>:
                  All existing processes are traced.

                <u>existing_ports</u>:
                  All existing ports are traced.

                <u>atom()</u>:
                  The process or port with the corresponding registered name is traced. The process or port  may
                  be  a remote process (on another Erlang node). The node must be added with the <u>n/1</u> or <u>tracer/3</u>
                  function.

                <u>integer()</u>:
                  The process <u>&lt;0.Item.0&gt;</u> is traced.

                <u>{X,</u> <u>Y,</u> <u>Z}</u>:
                  The process <u>&lt;X.Y.Z&gt;</u> is traced.

                <u>string()</u>:
                  If the <u>Item</u> is a string "&lt;X.Y.Z&gt;" as returned  from  <u>pid_to_list/1</u>,  the  process  <u>&lt;X.Y.Z&gt;</u>  is
                  traced.

              When enabling an <u>Item</u> that represents a group of processes, the <u>Item</u> is enabled on all nodes added
              with the <u>n/1</u> or <u>tracer/3</u> function.

              <u>Flags</u> can be a single atom, or a list of flags. The available flags are:

                <u>s</u> <u>(send)</u>:
                  Traces the messages the process or port sends.

                <u>r</u> <u>(receive)</u>:
                  Traces the messages the process or port receives.

                <u>m</u> <u>(messages)</u>:
                  Traces the messages the process or port receives and sends.

                <u>c</u> <u>(call)</u>:
                  Traces global function calls for the process according to the trace patterns set in the system
                  (see tp/2).

                <u>p</u> <u>(procs)</u>:
                  Traces process related events to the process.

                <u>ports</u>:
                  Traces port related events to the port.

                <u>sos</u> <u>(set</u> <u>on</u> <u>spawn)</u>:
                  Lets  all  processes  created  by  the  traced  process  inherit the trace flags of the traced
                  process.

                <u>sol</u> <u>(set</u> <u>on</u> <u>link)</u>:
                  Lets another process, <u>P2</u>, inherit the trace flags of the traced process  whenever  the  traced
                  process links to <u>P2</u>.

                <u>sofs</u> <u>(set</u> <u>on</u> <u>first</u> <u>spawn)</u>:
                  This is the same as <u>sos</u>, but only for the first process spawned by the traced process.

                <u>sofl</u> <u>(set</u> <u>on</u> <u>first</u> <u>link)</u>:
                  This is the same as <u>sol</u>, but only for the first call to <u>link/1</u> by the traced process.

                <u>all</u>:
                  Sets all flags except <u>silent</u>.

                <u>clear</u>:
                  Clears all flags.

              The list can also include any of the flags allowed in <u>erlang:trace/3</u>

              The  function  returns  either  an  error  tuple  or  a  tuple  <u>{ok,</u>  <u>List}</u>.  The <u>List</u> consists of
              specifications of how many processes and ports that matched (in the case of a pure  pid()  exactly
              1).  The  specification  of matched processes is <u>{matched,</u> <u>Node,</u> <u>N}</u>. If the remote processor call,
              <u>rpc</u>, to a remote node fails, the <u>rpc</u> error message is delivered  as  a  fourth  argument  and  the
              number  of  matched  processes are 0. Note that the result {ok, List} may contain a list where <u>rpc</u>
              calls to one, several or even all nodes failed.

       <b>c(Mod,</b> <b>Fun,</b> <b>Args)</b>

              Equivalent to <u>c(Mod,</u> <u>Fun,</u> <u>Args,</u> <u>all)</u>.

       <b>c(Mod,</b> <b>Fun,</b> <b>Args,</b> <b>Flags)</b>

              <u>c</u> stands for <u>c</u>all. Evaluates the expression <u>apply(Mod,</u> <u>Fun,</u> <u>Args)</u> with the trace  flags  in  <u>Flags</u>
              set. This is a convenient way to trace processes from the Erlang shell.

       <b>i()</b> <b>-&gt;</b> <b>ok</b>

              <u>i</u> stands for <u>i</u>nformation. Displays information about all traced processes and ports.

       <b>tp(Module,MatchSpec)</b>

              Same as tp({Module, '_', '_'}, MatchSpec)

       <b>tp(Module,Function,MatchSpec)</b>

              Same as tp({Module, Function, '_'}, MatchSpec)

       <b>tp(Module,</b> <b>Function,</b> <b>Arity,</b> <b>MatchSpec)</b>

              Same as tp({Module, Function, Arity}, MatchSpec)

       <b>tp({Module,</b> <b>Function,</b> <b>Arity},</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>{ok,</b> <b>MatchDesc}</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Module = atom() | '_'
                 Function = atom() | '_'
                 Arity = integer() |'_'
                 MatchSpec = integer() | Built-inAlias | [] | match_spec()
                 Built-inAlias = x | c | cx
                 MatchDesc = [MatchInfo]
                 MatchInfo = {saved, integer()} | MatchNum
                 MatchNum = {matched, node(), integer()} | {matched, node(), 0, RPCError}

              <u>tp</u>  stands  for  <u>t</u>race  <u>p</u>attern.  This  function enables call trace for one or more functions. All
              exported functions matching the <u>{Module,</u> <u>Function,</u> <u>Arity}</u> argument  will  be  concerned,  but  the
              <u>match_spec()</u> may further narrow down the set of function calls generating trace messages.

              For  a  description of the <u>match_spec()</u> syntax, please turn to the <u>User's</u> <u>guide</u> part of the online
              documentation for the runtime system (<u>erts</u>). The chapter <u>Match</u> <u>Specifications</u> <u>in</u>  <u>Erlang</u>  explains
              the  general match specification "language". The most common generic match specifications used can
              be found as <u>Built-inAlias</u>', see <u>ltp/0</u> below for details.

              The Module, Function and/or Arity parts of the tuple may be specified as the atom <u>'_'</u> which  is  a
              "wild-card"  matching  all modules/functions/arities. Note, if the Module is specified as <u>'_'</u>, the
              Function and Arity parts have to be specified as  '_'  too.  The  same  holds  for  the  Functions
              relation to the Arity.

              All  nodes  added with <u>n/1</u> or <u>tracer/3</u> will be affected by this call, and if Module is not <u>'_'</u> the
              module will be loaded on all nodes.

              The function returns either  an  error  tuple  or  a  tuple  <u>{ok,</u>  <u>List}</u>.  The  <u>List</u>  consists  of
              specifications  of how many functions that matched, in the same way as the processes and ports are
              presented in the return value of <u>p/2</u>.

              There may be a tuple <u>{saved,</u> <u>N}</u> in the return value, if  the  MatchSpec  is  other  than  [].  The
              integer  <u>N</u>  may then be used in subsequent calls to this function and will stand as an "alias" for
              the given expression. There are also a couple of built-in  aliases  for  common  expressions,  see
              <u>ltp/0</u> below for details.

              If  an  error is returned, it can be due to errors in compilation of the match specification. Such
              errors are presented as a list  of  tuples  <u>{error,</u>  <u>string()}</u>  where  the  string  is  a  textual
              explanation of the compilation error. An example:

              (x@y)4&gt; dbg:tp({dbg,ltp,0},[{[],[],[{message, two, arguments}, {noexist}]}]).
              {error,
               [{error,"Special form 'message' called with wrong number of
                        arguments in {message,two,arguments}."},
                {error,"Function noexist/1 does_not_exist."}]}

       <b>tpl(Module,MatchSpec)</b>

              Same as tpl({Module, '_', '_'}, MatchSpec)

       <b>tpl(Module,Function,MatchSpec)</b>

              Same as tpl({Module, Function, '_'}, MatchSpec)

       <b>tpl(Module,</b> <b>Function,</b> <b>Arity,</b> <b>MatchSpec)</b>

              Same as tpl({Module, Function, Arity}, MatchSpec)

       <b>tpl({Module,</b> <b>Function,</b> <b>Arity},</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>{ok,</b> <b>MatchDesc}</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              <u>tpl</u>  stands  for  <u>t</u>race  <u>p</u>attern <u>l</u>ocal. This function works as <u>tp/2</u>, but enables tracing for local
              calls (and local functions) as well as for global calls (and functions).

       <b>tpe(Event,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>{ok,</b> <b>MatchDesc}</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Event = send | 'receive'
                 MatchSpec = integer() | Built-inAlias | [] | match_spec()
                 Built-inAlias = x | c | cx
                 MatchDesc = [MatchInfo]
                 MatchInfo = {saved, integer()} | MatchNum
                 MatchNum = {matched, node(), 1} | {matched, node(), 0, RPCError}

              <u>tpe</u> stands for <u>t</u>race <u>p</u>attern <u>e</u>vent. This function associates  a  match  specification  with  trace
              event  <u>send</u>  or <u>'receive'</u>. By default all executed <u>send</u> and <u>'receive'</u> events are traced if enabled
              for a process. A match specification can be used to filter traced events based on sender, receiver
              and/or message content.

              For a description of the <u>match_spec()</u> syntax, please turn to the <u>User's</u> <u>guide</u> part of  the  online
              documentation  for  the runtime system (<u>erts</u>). The chapter <u>Match</u> <u>Specifications</u> <u>in</u> <u>Erlang</u> explains
              the general match specification "language".

              For <u>send</u>, the matching is done on the list <u>[Receiver,</u>  <u>Msg]</u>.  <u>Receiver</u>  is  the  process  or  port
              identity  of  the  receiver  and  <u>Msg</u>  is  the message term. The pid of the sending process can be
              accessed with the guard function <u>self/0</u>.

              For <u>'receive'</u>, the matching is done on the list <u>[Node,</u> <u>Sender,</u> <u>Msg]</u>. <u>Node</u> is the node name of  the
              sender.  <u>Sender</u> is the process or port identity of the sender, or the atom <u>undefined</u> if the sender
              is not known (which may be the case for remote senders). <u>Msg</u> is the message term. The pid  of  the
              receiving process can be accessed with the guard function <u>self/0</u>.

              All nodes added with <u>n/1</u> or <u>tracer/3</u> will be affected by this call.

              The  return value is the same as for <u>tp/2</u>. The number of matched events are never larger than 1 as
              <u>tpe/2</u> does not accept any form of wildcards for argument <u>Event</u>.

       <b>ctp()</b>

              Same as ctp({'_', '_', '_'})

       <b>ctp(Module)</b>

              Same as ctp({Module, '_', '_'})

       <b>ctp(Module,</b> <b>Function)</b>

              Same as ctp({Module, Function, '_'})

       <b>ctp(Module,</b> <b>Function,</b> <b>Arity)</b>

              Same as ctp({Module, Function, Arity})

       <b>ctp({Module,</b> <b>Function,</b> <b>Arity})</b> <b>-&gt;</b> <b>{ok,</b> <b>MatchDesc}</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Module = atom() | '_'
                 Function = atom() | '_'
                 Arity = integer() | '_'
                 MatchDesc = [MatchNum]
                 MatchNum = {matched, node(), integer()} | {matched, node(), 0, RPCError}

              <u>ctp</u> stands for <u>c</u>lear  <u>t</u>race  <u>p</u>attern.  This  function  disables  call  tracing  on  the  specified
              functions.  The  semantics  of  the  parameter  is  the  same  as  for  the corresponding function
              specification in <u>tp/2</u> or <u>tpl/2</u>. Both local and global call trace is disabled.

              The return value reflects how many functions that matched, and  is  constructed  as  described  in
              <u>tp/2</u>. No tuple <u>{saved,</u> <u>N}</u> is however ever returned (for obvious reasons).

       <b>ctpl()</b>

              Same as ctpl({'_', '_', '_'})

       <b>ctpl(Module)</b>

              Same as ctpl({Module, '_', '_'})

       <b>ctpl(Module,</b> <b>Function)</b>

              Same as ctpl({Module, Function, '_'})

       <b>ctpl(Module,</b> <b>Function,</b> <b>Arity)</b>

              Same as ctpl({Module, Function, Arity})

       <b>ctpl({Module,</b> <b>Function,</b> <b>Arity})</b> <b>-&gt;</b> <b>{ok,</b> <b>MatchDesc}</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              <u>ctpl</u> stands for <u>c</u>lear <u>t</u>race <u>p</u>attern <u>l</u>ocal. This function works as <u>ctp/1</u>, but only disables tracing
              set up with <u>tpl/2</u> (not with <u>tp/2</u>).

       <b>ctpg()</b>

              Same as ctpg({'_', '_', '_'})

       <b>ctpg(Module)</b>

              Same as ctpg({Module, '_', '_'})

       <b>ctpg(Module,</b> <b>Function)</b>

              Same as ctpg({Module, Function, '_'})

       <b>ctpg(Module,</b> <b>Function,</b> <b>Arity)</b>

              Same as ctpg({Module, Function, Arity})

       <b>ctpg({Module,</b> <b>Function,</b> <b>Arity})</b> <b>-&gt;</b> <b>{ok,</b> <b>MatchDesc}</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              <u>ctpg</u>  stands  for  <u>c</u>lear  <u>t</u>race  <u>p</u>attern  <u>g</u>lobal.  This function works as <u>ctp/1</u>, but only disables
              tracing set up with <u>tp/2</u> (not with <u>tpl/2</u>).

       <b>ctpe(Event)</b> <b>-&gt;</b> <b>{ok,</b> <b>MatchDesc}</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Event = send | 'receive'
                 MatchDesc = [MatchNum]
                 MatchNum = {matched, node(), 1} | {matched, node(), 0, RPCError}

              <u>ctpe</u> stands for <u>c</u>lear <u>t</u>race <u>p</u>attern <u>e</u>vent. This  function  clears  match  specifications  for  the
              specified  trace event (<u>send</u> or <u>'receive'</u>). It will revert back to the default behavior of tracing
              all triggered events.

              The return value follow the same style as for <u>ctp/1</u>.

       <b>ltp()</b> <b>-&gt;</b> <b>ok</b>

              <u>ltp</u> stands for <u>l</u>ist  <u>t</u>race  <u>p</u>atterns.  Use  this  function  to  recall  all  match  specifications
              previously  used  in  the session (i. e. previously saved during calls to <u>tp/2</u>, and built-in match
              specifications. This is very useful, as a complicated match_spec can be quite  awkward  to  write.
              Note that the match specifications are lost if <u>stop/0</u> is called.

              Match  specifications used can be saved in a file (if a read-write file system is present) for use
              in later debugging sessions, see <u>wtp/1</u> and <u>rtp/1</u>

              There are three built-in trace patterns: <u>exception_trace</u>, <u>caller_trace</u> and  <u>caller_exception_trace</u>
              (or  <u>x</u>,  <u>c</u>  and  <u>cx</u>  respectively).  Exception  trace sets a trace which will show function names,
              parameters, return values and exceptions thrown from functions.  Caller  traces  display  function
              names,  parameters  and  information  about  which function called it. An example using a built-in
              alias:

              (x@y)4&gt; dbg:tp(lists,sort,cx).
              {ok,[{matched,nonode@nohost,2},{saved,cx}]}
              (x@y)4&gt; lists:sort([2,1]).
              (&lt;0.32.0&gt;) call lists:sort([2,1]) ({erl_eval,do_apply,5})
              (&lt;0.32.0&gt;) returned from lists:sort/1 -&gt; [1,2]
              [1,2]

       <b>dtp()</b> <b>-&gt;</b> <b>ok</b>

              <u>dtp</u> stands for <u>d</u>elete <u>t</u>race <u>p</u>atterns. Use this function to "forget" all match specifications saved
              during calls to <u>tp/2</u>. This is useful when one wants to restore other match specifications  from  a
              file with <u>rtp/1</u>. Use <u>dtp/1</u> to delete specific saved match specifications.

       <b>dtp(N)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 N = integer()

              <u>dtp</u>  stands for <u>d</u>elete <u>t</u>race <u>p</u>attern. Use this function to "forget" a specific match specification
              saved during calls to <u>tp/2</u>.

       <b>wtp(Name)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>IOError}</b>

              Types:

                 Name = string()
                 IOError = term()

              <u>wtp</u> stands for <u>w</u>rite <u>t</u>race <u>p</u>atterns. This function will save all match specifications saved during
              the session (during calls to <u>tp/2</u>) and built-in match specifications in a text file with the  name
              designated  by <u>Name</u>. The format of the file is textual, why it can be edited with an ordinary text
              editor, and then restored with <u>rtp/1</u>.

              Each match spec in the file ends with a full  stop  (<u>.</u>)  and  new  (syntactically  correct)  match
              specifications can be added to the file manually.

              The  function  returns  <u>ok</u>  or an error tuple where the second element contains the I/O error that
              made the writing impossible.

       <b>rtp(Name)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Error}</b>

              Types:

                 Name = string()
                 Error = term()

              <u>rtp</u> stands for <u>r</u>ead  <u>t</u>race  <u>p</u>atterns.  This  function  reads  match  specifications  from  a  file
              (possibly)  generated  by the <u>wtp/1</u> function. It checks the syntax of all match specifications and
              verifies that they are correct. The error handling principle is "all or nothing", i. e. if some of
              the match specifications are wrong, none of the specifications are added  to  the  list  of  saved
              match specifications for the running system.

              The  match specifications in the file are <u>merged</u> with the current match specifications, so that no
              duplicates are generated. Use <u>ltp/0</u> to see what numbers were assigned to the  specifications  from
              the file.

              The function will return an error, either due to I/O problems (like a non existing or non readable
              file)  or  due  to  file  format problems. The errors from a bad format file are in a more or less
              textual format, which will give a hint to what's causing the problem.

       <b>n(Nodename)</b> <b>-&gt;</b> <b>{ok,</b> <b>Nodename}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Nodename = atom()
                 Reason = term()

              <u>n</u> stands for <u>n</u>ode. The <u>dbg</u> server keeps a  list  of  nodes  where  tracing  should  be  performed.
              Whenever  a  <u>tp/2</u>  call or a <u>p/2</u> call is made, it is executed for all nodes in this list including
              the local node (except for <u>p/2</u> with a specific <u>pid()</u> or <u>port()</u> as first argument,  in  which  case
              the command is executed only on the node where the designated process or port resides).

              This  function  adds  a remote node (<u>Nodename</u>) to the list of nodes where tracing is performed. It
              starts a tracer process on the remote node, which will send  all  trace  messages  to  the  tracer
              process  on  the  local node (via the Erlang distribution). If no tracer process is running on the
              local node, the error reason <u>no_local_tracer</u> is returned. The tracer process  on  the  local  node
              must be started with the <u>tracer/0/2</u> function.

              If <u>Nodename</u> is the local node, the error reason <u>cant_add_local_node</u> is returned.

              If  a  trace  port  (see <u>trace_port/2</u>) is running on the local node, remote nodes cannot be traced
              with a tracer process. The error reason <u>cant_trace_remote_pid_to_local_port</u> is returned.  A  trace
              port can however be started on the remote node with the <u>tracer/3</u> function.

              The function will also return an error if the node <u>Nodename</u> is not reachable.

       <b>cn(Nodename)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Nodename = atom()

              <u>cn</u>  stands  for  <u>c</u>lear <u>n</u>ode. Clears a node from the list of traced nodes. Subsequent calls to <u>tp/2</u>
              and <u>p/2</u> will not consider that node, but tracing already activated on the node will continue to be
              in effect.

              Returns <u>ok</u>, cannot fail.

       <b>ln()</b> <b>-&gt;</b> <b>ok</b>

              <u>ln</u> stands for <u>l</u>ist <u>n</u>odes. Shows the list of traced nodes on the console.

       <b>tracer()</b> <b>-&gt;</b> <b>{ok,</b> <b>pid()}</b> <b>|</b> <b>{error,</b> <b>already_started}</b>

              This function starts a server on the local node that will be the recipient of all trace  messages.
              All subsequent calls to <u>p/2</u> will result in messages sent to the newly started trace server.

              A  trace  server  started in this way will simply display the trace messages in a formatted way in
              the Erlang shell (i. e. use io:format). See <u>tracer/2</u> for a description of how  the  trace  message
              handler can be customized.

              To start a similar tracer on a remote node, use <u>n/1</u>.

       <b>tracer(Type,</b> <b>Data)</b> <b>-&gt;</b> <b>{ok,</b> <b>pid()}</b> <b>|</b> <b>{error,</b> <b>Error}</b>

              Types:

                 Type = port | process | module
                 Data = PortGenerator | HandlerSpec | ModuleSpec
                 PortGenerator = fun() (no arguments)
                 Error = term()
                 HandlerSpec = {HandlerFun, InitialData}
                 HandlerFun = fun() (two arguments)
                 ModuleSpec = fun() (no arguments) | {TracerModule, TracerState}
                 TracerModule = atom()
                 InitialData = TracerState = term()

              This  function  starts  a  tracer  server  with additional parameters on the local node. The first
              parameter, the <u>Type</u>, indicates if  trace  messages  should  be  handled  by  a  receiving  process
              (<u>process</u>),  by a tracer port (<u>port</u>) or by a tracer module (<u>module</u>). For a description about tracer
              ports see <u>trace_port/2</u> and for a tracer modules see <u>erl_tracer</u>.

              If <u>Type</u> is <u>process</u>, a message  handler  function  can  be  specified  (<u>HandlerSpec</u>).  The  handler
              function,  which should be a <u>fun</u> taking two arguments, will be called for each trace message, with
              the first argument containing the message as it is and the second argument containing  the  return
              value  from the last invocation of the fun. The initial value of the second parameter is specified
              in the <u>InitialData</u> part of the <u>HandlerSpec</u>. The <u>HandlerFun</u> may choose any  appropriate  action  to
              take when invoked, and can save a state for the next invocation by returning it.

              If  <u>Type</u> is <u>port</u>, then the second parameter should be a <u>fun</u> which takes no arguments and returns a
              newly opened trace port when called. Such a <u>fun</u> is preferably generated by calling <u>trace_port/2</u>.

              if <u>Type</u> is <u>module</u>, then the second parameter should be either a tuple  describing  the  <u>erl_tracer</u>
              module  to  be used for tracing and the state to be used for that tracer module or a fun returning
              the same tuple.

              If  an  error  is  returned,  it  can  either  be  due  to  a  tracer   server   already   running
              (<u>{error,already_started}</u>) or due to the <u>HandlerFun</u> throwing an exception.

              To start a similar tracer on a remote node, use <u>tracer/3</u>.

       <b>tracer(Nodename,</b> <b>Type,</b> <b>Data)</b> <b>-&gt;</b> <b>{ok,</b> <b>Nodename}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Nodename = atom()

              This  function  is  equivalent to <u>tracer/2</u>, but acts on the given node. A tracer is started on the
              node (<u>Nodename</u>) and the node is added to the list of traced nodes.

          <b>Note:</b>
              This function is not equivalent to <u>n/1</u>. While <u>n/1</u> starts a  process  tracer  which  redirects  all
              trace  information  to  a process tracer on the local node (i.e. the trace control node), <u>tracer/3</u>
              starts a tracer of any type which is independent of the tracer on the trace control node.

              For details, see <u>tracer/2</u>.

       <b>trace_port(Type,</b> <b>Parameters)</b> <b>-&gt;</b> <b>fun()</b>

              Types:

                 Type = ip | file
                 Parameters = Filename | WrapFilesSpec | IPPortSpec
                 Filename = string() | [string()] | atom()
                 WrapFilesSpec = {Filename, wrap, Suffix} | {Filename,  wrap,  Suffix,  WrapSize}  |  {Filename,
                 wrap, Suffix, WrapSize, WrapCnt}
                 Suffix = string()
                 WrapSize = integer() &gt;= 0 | {time, WrapTime}
                 WrapTime = integer() &gt;= 1
                 WrapCnt = integer() &gt;= 1
                 IpPortSpec = PortNumber | {PortNumber, QueSize}
                 PortNumber = integer()
                 QueSize = integer()

              This  function creates a trace port generating <u>fun</u>. The <u>fun</u> takes no arguments and returns a newly
              opened trace port. The return value from this function  is  suitable  as  a  second  parameter  to
              tracer/2, i.e. <u>dbg:tracer(port,</u> <u>dbg:trace_port(ip,</u> <u>4711))</u>.

              A  trace  port  is  an  Erlang  port to a dynamically linked in driver that handles trace messages
              directly, without the overhead of sending them as messages in the Erlang virtual machine.

              Two trace drivers are currently implemented, the <u>file</u> and the <u>ip</u> trace drivers.  The  file  driver
              sends  all  trace  messages into one or several binary files, from where they later can be fetched
              and processed with the <u>trace_client/2</u> function. The ip driver opens a TCP/IP port where it listens
              for connections. When a client (preferably started by calling  <u>trace_client/2</u>  on  another  Erlang
              node)  connects,  all  trace  messages  are sent over the IP network for further processing by the
              remote client.

              Using a trace port significantly lowers the overhead imposed by using tracing.

              The file trace driver expects a filename or a wrap files specification as  parameter.  A  file  is
              written  with a high degree of buffering, why all trace messages are <u>not</u> guaranteed to be saved in
              the file in case of a system crash. That is the price to pay for low tracing overhead.

              A wrap files specification is used to limit the disk space consumed by the  trace.  The  trace  is
              written  to  a limited number of files each with a limited size. The actual filenames are <u>Filename</u>
              <u>++</u> <u>SeqCnt</u> <u>++</u> <u>Suffix</u>, where <u>SeqCnt</u> counts as a decimal string from <u>0</u> to  <u>WrapCnt</u>  and  then  around
              again  from  <u>0</u>.  When a trace term written to the current file makes it longer than <u>WrapSize</u>, that
              file is closed, if the number of files in this wrap trace is as many as <u>WrapCnt</u> the oldest file is
              deleted then a new file is opened to become the current. Thus, when a wrap trace has been stopped,
              there are at most <u>WrapCnt</u> trace files saved with a  size  of  at  least  <u>WrapSize</u>  (but  not  much
              bigger),  except  for  the  last  file that might even be empty. The default values are <u>WrapSize</u> <u>=</u>
              <u>128*1024</u> and <u>WrapCnt</u> <u>=</u> <u>8</u>.

              The <u>SeqCnt</u> values in the filenames are all in the range <u>0</u>  through  <u>WrapCnt</u>  with  a  gap  in  the
              circular sequence. The gap is needed to find the end of the trace.

              If the <u>WrapSize</u> is specified as <u>{time,</u> <u>WrapTime}</u>, the current file is closed when it has been open
              more than <u>WrapTime</u> milliseconds, regardless of it being empty or not.

              The  ip trace driver has a queue of <u>QueSize</u> messages waiting to be delivered. If the driver cannot
              deliver messages as fast as they are produced by the runtime system, a special  message  is  sent,
              which  indicates  how  many  messages  that  are  dropped. That message will arrive at the handler
              function specified in <u>trace_client/3</u> as the tuple <u>{drop,</u> <u>N}</u> where <u>N</u> is the number  of  consecutive
              messages  dropped.  In case of heavy tracing, drop's are likely to occur, and they surely occur if
              no client is reading the trace messages. The default value of <u>QueSize</u> is 200.

       <b>flush_trace_port()</b>

              Equivalent to <u>flush_trace_port(node())</u>.

       <b>flush_trace_port(Nodename)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Equivalent to <u>trace_port_control(Nodename,flush)</u>.

       <b>trace_port_control(Operation)</b>

              Equivalent to <u>trace_port_control(node(),Operation)</u>.

       <b>trace_port_control(Nodename,Operation)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{ok,</b> <b>Result}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Nodename = atom()

              This function is used to do a control operation on the active trace port driver on the given  node
              (<u>Nodename</u>).  Which  operations  are  allowed  as well as their return values depend on which trace
              driver is used.

              Returns either <u>ok</u> or <u>{ok,</u> <u>Result}</u> if the operation was  successful,  or  <u>{error,</u>  <u>Reason}</u>  if  the
              current tracer is a process or if it is a port not supporting the operation.

              The allowed values for <u>Operation</u> are:

                <u>flush</u>:
                  This  function  is  used  to flush the internal buffers held by a trace port driver. Currently
                  only the file trace driver supports this operation. Returns <u>ok</u>.

                <u>get_listen_port</u>:
                  Returns <u>{ok,</u> <u>IpPort}</u> where <u>IpPort</u> is the IP port number used by the driver listen socket. Only
                  the ip trace driver supports this operation.

       <b>trace_client(Type,</b> <b>Parameters)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Type = ip | file | follow_file
                 Parameters = Filename | WrapFilesSpec | IPClientPortSpec
                 Filename = string() | [string()] | atom()
                 WrapFilesSpec = see trace_port/2
                 Suffix = string()
                 IpClientPortSpec = PortNumber | {Hostname, PortNumber}
                 PortNumber = integer()
                 Hostname = string()

              This function starts a trace client that reads the output created  by  a  trace  port  driver  and
              handles it in mostly the same way as a tracer process created by the <u>tracer/0</u> function.

              If  <u>Type</u>  is  <u>file</u>,  the  client  reads  all  trace  messages stored in the file named <u>Filename</u> or
              specified by <u>WrapFilesSpec</u> (must be the same as used when creating the  trace,  see  trace_port/2)
              and  let's  the  default  handler  function format the messages on the console. This is one way to
              interpret the data stored in a file by the file trace port driver.

              If <u>Type</u> is <u>follow_file</u>, the client behaves as in the <u>file</u> case, but  keeps  trying  to  read  (and
              process)  more  data  from  the  file  until  stopped by <u>stop_trace_client/1</u>. <u>WrapFilesSpec</u> is not
              allowed as second argument for this <u>Type</u>.

              If <u>Type</u> is <u>ip</u>, the client connects to the TCP/IP port <u>PortNumber</u> on the host <u>Hostname</u>, from  where
              it  reads  trace  messages until the TCP/IP connection is closed. If no <u>Hostname</u> is specified, the
              local host is assumed.

              As an example, one can let trace messages  be  sent  over  the  network  to  another  Erlang  node
              (preferably <u>not</u> distributed), where the formatting occurs:

              On the node <u>stack</u> there's an Erlang node <u>ant@stack</u>, in the shell, type the following:

              ant@stack&gt; dbg:tracer(port, dbg:trace_port(ip,4711)).
              &lt;0.17.0&gt;
              ant@stack&gt; dbg:p(self(), send).
              {ok,1}

              All trace messages are now sent to the trace port driver, which in turn listens for connections on
              the  TCP/IP port 4711. If we want to see the messages on another node, preferably on another host,
              we do like this:

              -&gt; dbg:trace_client(ip, {"stack", 4711}).
              &lt;0.42.0&gt;

              If we now send a message from the shell on the node <u>ant@stack</u>, where all sends from the shell  are
              traced:

              ant@stack&gt; self() ! hello.
              hello

              The following will appear at the console on the node that started the trace client:

              (&lt;0.23.0&gt;) &lt;0.23.0&gt; ! hello
              (&lt;0.23.0&gt;) &lt;0.22.0&gt; ! {shell_rep,&lt;0.23.0&gt;,{value,hello,[],[]}}

              The  last  line is generated due to internal message passing in the Erlang shell. The process id's
              will vary.

       <b>trace_client(Type,</b> <b>Parameters,</b> <b>HandlerSpec)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Type = ip | file | follow_file
                 Parameters = Filename | WrapFilesSpec | IPClientPortSpec
                 Filename = string() | [string()] | atom()
                 WrapFilesSpec = see trace_port/2
                 Suffix = string()
                 IpClientPortSpec = PortNumber | {Hostname, PortNumber}
                 PortNumber = integer()
                 Hostname = string()
                 HandlerSpec = {HandlerFun, InitialData}
                 HandlerFun = fun() (two arguments)
                 InitialData = term()

              This function works exactly as <u>trace_client/2</u>, but allows you to write your own handler  function.
              The  handler  function  works  mostly  as  the one described in <u>tracer/2</u>, but will also have to be
              prepared to handle trace messages of the form  <u>{drop,</u>  <u>N}</u>,  where  <u>N</u>  is  the  number  of  dropped
              messages. This pseudo trace message will only occur if the ip trace driver is used.

              For  trace  type  <u>file</u>, the pseudo trace message <u>end_of_trace</u> will appear at the end of the trace.
              The return value from the handler function is in this case ignored.

       <b>stop_trace_client(Pid)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Pid = pid()

              This function shuts down a previously started trace client. The <u>Pid</u> argument  is  the  process  id
              returned from the <u>trace_client/2</u> or <u>trace_client/3</u> call.

       <b>get_tracer()</b>

              Equivalent to <u>get_tracer(node())</u>.

       <b>get_tracer(Nodename)</b> <b>-&gt;</b> <b>{ok,</b> <b>Tracer}</b>

              Types:

                 Nodename = atom()
                 Tracer = port() | pid() | {module(), term()}

              Returns the process, port or tracer module to which all trace messages are sent.

       <b>stop()</b> <b>-&gt;</b> <b>ok</b>

              Stops the <u>dbg</u> server and clears all trace flags for all processes and all local trace patterns for
              all functions. Also shuts down all trace clients and closes all trace ports.

              Note that no global trace patterns are affected by this function.

       <b>stop_clear()</b> <b>-&gt;</b> <b>ok</b>

              Same as stop/0, but also clears all trace patterns on global functions calls.

</pre><h4><b>SIMPLE</b> <b>EXAMPLES</b> <b>-</b> <b>TRACING</b> <b>FROM</b> <b>THE</b> <b>SHELL</b></h4><pre>
       The simplest way of tracing from the Erlang shell is to use <u>dbg:c/3</u> or <u>dbg:c/4</u>, e.g. tracing the function
       <u>dbg:get_tracer/0</u>:

       (tiger@durin)84&gt; dbg:c(dbg,get_tracer,[]).
       (&lt;0.154.0&gt;) &lt;0.152.0&gt; ! {&lt;0.154.0&gt;,{get_tracer,tiger@durin}}
       (&lt;0.154.0&gt;) out {dbg,req,1}
       (&lt;0.154.0&gt;) &lt;&lt; {dbg,{ok,&lt;0.153.0&gt;}}
       (&lt;0.154.0&gt;) in {dbg,req,1}
       (&lt;0.154.0&gt;) &lt;&lt; timeout
       {ok,&lt;0.153.0&gt;}
       (tiger@durin)85&gt;

       Another  way  of  tracing  from the shell is to explicitly start a <u>tracer</u> and then set the <u>trace</u> <u>flags</u> of
       your choice on the processes you want to trace, e.g. trace messages and process events:

       (tiger@durin)66&gt; Pid = spawn(fun() -&gt; receive {From,Msg} -&gt; From ! Msg end end).
       &lt;0.126.0&gt;
       (tiger@durin)67&gt; dbg:tracer().
       {ok,&lt;0.128.0&gt;}
       (tiger@durin)68&gt; dbg:p(Pid,[m,procs]).
       {ok,[{matched,tiger@durin,1}]}
       (tiger@durin)69&gt; Pid ! {self(),hello}.
       (&lt;0.126.0&gt;) &lt;&lt; {&lt;0.116.0&gt;,hello}
       {&lt;0.116.0&gt;,hello}
       (&lt;0.126.0&gt;) &lt;&lt; timeout
       (&lt;0.126.0&gt;) &lt;0.116.0&gt; ! hello
       (&lt;0.126.0&gt;) exit normal
       (tiger@durin)70&gt; flush().
       Shell got hello
       ok
       (tiger@durin)71&gt;

       If you set the <u>call</u> trace flag, you also have to set a <u>trace</u> <u>pattern</u> for the functions you want to trace:

       (tiger@durin)77&gt; dbg:tracer().
       {ok,&lt;0.142.0&gt;}
       (tiger@durin)78&gt; dbg:p(all,call).
       {ok,[{matched,tiger@durin,3}]}
       (tiger@durin)79&gt; dbg:tp(dbg,get_tracer,0,[]).
       {ok,[{matched,tiger@durin,1}]}
       (tiger@durin)80&gt; dbg:get_tracer().
       (&lt;0.116.0&gt;) call dbg:get_tracer()
       {ok,&lt;0.143.0&gt;}
       (tiger@durin)81&gt; dbg:tp(dbg,get_tracer,0,[{'_',[],[{return_trace}]}]).
       {ok,[{matched,tiger@durin,1},{saved,1}]}
       (tiger@durin)82&gt; dbg:get_tracer().
       (&lt;0.116.0&gt;) call dbg:get_tracer()
       (&lt;0.116.0&gt;) returned from dbg:get_tracer/0 -&gt; {ok,&lt;0.143.0&gt;}
       {ok,&lt;0.143.0&gt;}
       (tiger@durin)83&gt;

</pre><h4><b>ADVANCED</b> <b>TOPICS</b> <b>-</b> <b>COMBINING</b> <b>WITH</b> <b>SEQ_TRACE</b></h4><pre>
       The <u>dbg</u> module is primarily targeted towards tracing through the <u>erlang:trace/3</u> function. It is sometimes
       desired to trace messages in a more delicate way, which can be  done  with  the  help  of  the  <u>seq_trace</u>
       module.

       <u>seq_trace</u>  implements  sequential  tracing  (known  in  the  AXE10  world,  and sometimes called "forlopp
       tracing"). <u>dbg</u> can interpret messages generated from <u>seq_trace</u> and the  same  tracer  function  for  both
       types  of  tracing  can  be  used.  The  <u>seq_trace</u>  messages can even be sent to a trace port for further
       analysis.

       As a match specification can turn on sequential tracing, the combination of  <u>dbg</u>  and  <u>seq_trace</u>  can  be
       quite powerful. This brief example shows a session where sequential tracing is used:

       1&gt; dbg:tracer().
       {ok,&lt;0.30.0&gt;}
       2&gt; {ok, Tracer} = dbg:get_tracer().
       {ok,&lt;0.31.0&gt;}
       3&gt; seq_trace:set_system_tracer(Tracer).
       false
       4&gt; dbg:tp(dbg, get_tracer, 0, [{[],[],[{set_seq_token, send, true}]}]).
       {ok,[{matched,nonode@nohost,1},{saved,1}]}
       5&gt; dbg:p(all,call).
       {ok,[{matched,nonode@nohost,22}]}
       6&gt; dbg:get_tracer(), seq_trace:set_token([]).
       (&lt;0.25.0&gt;) call dbg:get_tracer()
       SeqTrace [0]: (&lt;0.25.0&gt;) &lt;0.30.0&gt; ! {&lt;0.25.0&gt;,get_tracer} [Serial: {2,4}]
       SeqTrace [0]: (&lt;0.30.0&gt;) &lt;0.25.0&gt; ! {dbg,{ok,&lt;0.31.0&gt;}} [Serial: {4,5}]
       {1,0,5,&lt;0.30.0&gt;,4}

       This  session  sets the system_tracer to the same process as the ordinary tracer process (i. e. &lt;0.31.0&gt;)
       and sets the trace pattern for the function <u>dbg:get_tracer</u> to one  that  has  the  action  of  setting  a
       sequential  token.  When  the  function  is  called by a traced process (all processes are traced in this
       case), the process gets "contaminated" by the token and <u>seq_trace</u> messages are sent both for  the  server
       request  and  the response. The <u>seq_trace:set_token([])</u> after the call clears the <u>seq_trace</u> token, why no
       messages are sent when the answer propagates via  the  shell  to  the  console  port.  The  output  would
       otherwise have been more noisy.

</pre><h4><b>NOTE</b> <b>OF</b> <b>CAUTION</b></h4><pre>
       When  tracing  function  calls  on  a  group  leader  process (an IO process), there is risk of causing a
       deadlock. This will happen if a group leader process generates a trace message and the tracer process, by
       calling the trace handler function, sends an IO request to the same group leader. The  problem  can  only
       occur  if  the  trace  handler  prints  to  tty  using  an  <u>io</u>  function such as <u>format/2</u>. Note that when
       <u>dbg:p(all,call)</u> is called, IO processes are also traced. Here's an example:

       %% Using a default line editing shell
       1&gt; dbg:tracer(process, {fun(Msg,_) -&gt; io:format("~p~n", [Msg]), 0 end, 0}).
       {ok,&lt;0.37.0&gt;}
       2&gt; dbg:p(all, [call]).
       {ok,[{matched,nonode@nohost,25}]}
       3&gt; dbg:tp(mymod,[{'_',[],[]}]).
       {ok,[{matched,nonode@nohost,0},{saved,1}]}
       4&gt; mymod: % TAB pressed here
       %% -- Deadlock --

       Here's another example:

       %% Using a shell without line editing (oldshell)
       1&gt; dbg:tracer(process).
       {ok,&lt;0.31.0&gt;}
       2&gt; dbg:p(all, [call]).
       {ok,[{matched,nonode@nohost,25}]}
       3&gt; dbg:tp(lists,[{'_',[],[]}]).
       {ok,[{matched,nonode@nohost,0},{saved,1}]}
       % -- Deadlock --

       The reason we get a deadlock in the first example is because when TAB is pressed to expand  the  function
       name,  the group leader (which handles character input) calls <u>mymod:module_info()</u>. This generates a trace
       message which, in turn, causes the tracer process to send an IO request to the group leader  (by  calling
       <u>io:format/2</u>). We end up in a deadlock.

       In the second example we use the default trace handler function. This handler prints to tty by sending IO
       requests  to  the <u>user</u> process. When Erlang is started in oldshell mode, the shell process will have <u>user</u>
       as its group leader and so will the tracer process in this example. Since <u>user</u> calls functions  in  <u>lists</u>
       we end up in a deadlock as soon as the first IO request is sent.

       Here are a few suggestions for how to avoid deadlock:

         * Don't  trace  the  group  leader  of  the  tracer  process.  If  tracing has been switched on for all
           processes,  call  <u>dbg:p(TracerGLPid,clear)</u>  to  stop  tracing   the   group   leader   (<u>TracerGLPid</u>).
           <u>process_info(TracerPid,group_leader)</u>  tells  you  which  process  this is (<u>TracerPid</u> is returned from
           <u>dbg:get_tracer/0</u>).

         * Don't trace the <u>user</u> process if using the default trace handler function.

         * In your own trace handler function, call <u>erlang:display/1</u> instead of an <u>io</u> function or,  if  <u>user</u>  is
           not   used   as  group  leader,  print  to  <u>user</u>  instead  of  the  default  group  leader.  Example:
           <u>io:format(user,Str,Args)</u>.

Ericsson AB                                    runtime_tools 1.17                                      <u><a href="../man3erl/dbg.3erl.html">dbg</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>