<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sd_bus_new, sd_bus_ref, sd_bus_unref, sd_bus_unrefp, sd_bus_close_unref, sd_bus_close_unrefp,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsystemd-dev">libsystemd-dev_257.7-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sd_bus_new, sd_bus_ref, sd_bus_unref, sd_bus_unrefp, sd_bus_close_unref, sd_bus_close_unrefp,
       sd_bus_flush_close_unref, sd_bus_flush_close_unrefp - Create a new bus object and create or destroy
       references to it

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;systemd/sd-bus.h&gt;</b>

       <b>int</b> <b>sd_bus_new(sd_bus</b> <b>**</b><u>bus</u><b>);</b>

       <b>sd_bus</b> <b>*sd_bus_ref(sd_bus</b> <b>*</b><u>bus</u><b>);</b>

       <b>sd_bus</b> <b>*sd_bus_unref(sd_bus</b> <b>*</b><u>bus</u><b>);</b>

       <b>sd_bus</b> <b>*sd_bus_close_unref(sd_bus</b> <b>*</b><u>bus</u><b>);</b>

       <b>sd_bus</b> <b>*sd_bus_flush_close_unref(sd_bus</b> <b>*</b><u>bus</u><b>);</b>

       <b>void</b> <b>sd_bus_unrefp(sd_bus</b> <b>**</b><u>busp</u><b>);</b>

       <b>void</b> <b>sd_bus_close_unrefp(sd_bus</b> <b>**</b><u>busp</u><b>);</b>

       <b>void</b> <b>sd_bus_flush_close_unrefp(sd_bus</b> <b>**</b><u>busp</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sd_bus_new()</b> creates a new bus object. This object is reference-counted, and will be destroyed when all
       references are gone. Initially, the caller of this function owns the sole reference and the bus object
       will not be connected to any bus. To connect it to a bus, make sure to set an address with
       <b><a href="../man3/sd_bus_set_address.3.html">sd_bus_set_address</a></b>(3) or a related call, and then start the connection with <b><a href="../man3/sd_bus_start.3.html">sd_bus_start</a></b>(3).

       In most cases, it is better to use <b><a href="../man3/sd_bus_default_user.3.html">sd_bus_default_user</a></b>(3), <b><a href="../man3/sd_bus_default_system.3.html">sd_bus_default_system</a></b>(3) or related calls
       instead of the more low-level <b>sd_bus_new()</b> and <b>sd_bus_start()</b>. The higher-level functions not only
       allocate a bus object but also start the connection to a well-known bus in a single function call.

       <b>sd_bus_ref()</b> increases the reference counter of <u>bus</u> by one.

       <b>sd_bus_unref()</b> decreases the reference counter of <u>bus</u> by one. Once the reference count has dropped to
       zero, <u>bus</u> is destroyed and cannot be used anymore, so further calls to <b>sd_bus_ref()</b> or <b>sd_bus_unref()</b> are
       illegal.

       <b>sd_bus_unrefp()</b> is similar to <b>sd_bus_unref()</b> but takes a pointer to a pointer to an <b>sd_bus</b> object. This
       call is useful in conjunction with GCC's and LLVM's <b>Clean-up</b> <b>Variable</b> <b>Attribute</b>[1]. Note that this
       function is defined as an inline function. Use a declaration like the following, in order to allocate a
       bus object that is freed automatically as the code block is left:

           {
             __attribute__((cleanup(sd_bus_unrefp))) sd_bus *bus = NULL;
             int r;
             ...
             r = sd_bus_default(&amp;bus);
             if (r &lt; 0) {
               errno = -r;
               fprintf(stderr, "Failed to allocate bus: %m\n");
             }
             ...
           }

       <b>sd_bus_ref()</b> and <b>sd_bus_unref()</b> execute no operation if the argument is <b>NULL</b>.  <b>sd_bus_unrefp()</b> will first
       dereference its argument, which must not be <b>NULL</b>, and will execute no operation if <u>that</u> is <b>NULL</b>.

       <b>sd_bus_close_unref()</b> is similar to <b>sd_bus_unref()</b>, but first executes <b><a href="../man3/sd_bus_close.3.html">sd_bus_close</a></b>(3), ensuring that the
       connection is terminated before the reference to the connection is dropped and possibly the object freed.

       <b>sd_bus_flush_close_unref()</b> is similar to <b>sd_bus_unref()</b>, but first executes <b><a href="../man3/sd_bus_flush.3.html">sd_bus_flush</a></b>(3) as well as
       <b><a href="../man3/sd_bus_close.3.html">sd_bus_close</a></b>(3), ensuring that any pending messages are synchronously flushed out before the reference to
       the connection is dropped and possibly the object freed. This call is particularly useful immediately
       before exiting from a program as it ensures that any pending outgoing messages are written out, and
       unprocessed but queued incoming messages released before the connection is terminated and released.

       <b>sd_bus_close_unrefp()</b> is similar to <b>sd_bus_close_unref()</b>, but may be used in GCC's and LLVM's Clean-up
       Variable Attribute, see above. Similarly, <b>sd_bus_flush_close_unrefp()</b> is similar to
       <b>sd_bus_flush_close_unref()</b>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>sd_bus_new()</b> returns 0 or a positive integer. On failure, it returns a negative errno-style
       error code.

       <b>sd_bus_ref()</b> always returns the argument.

       <b>sd_bus_unref()</b> and <b>sd_bus_flush_close_unref()</b> always return <b>NULL</b>.

   <b>Errors</b>
       Returned errors may indicate the following problems:

       <b>-ENOMEM</b>
           Memory allocation failed.

</pre><h4><b>NOTES</b></h4><pre>
       Functions described here are available as a shared library, which can be compiled against and linked to
       with the <b>libsystemd</b> <b><a href="../man1/pkg-config.1.html">pkg-config</a></b>(1) file.

       The code described here uses <b><a href="../man3/getenv.3.html">getenv</a></b>(3), which is declared to be not multi-thread-safe. This means that
       the code calling the functions described here must not call <b><a href="../man3/setenv.3.html">setenv</a></b>(3) from a parallel thread. It is
       recommended to only do calls to <b>setenv()</b> from an early phase of the program when no other threads have
       been started.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>sd_bus_new()</b>, <b>sd_bus_ref()</b>, and <b>sd_bus_unref()</b> were added in version 209.

       <b>sd_bus_unrefp()</b> was added in version 229.

       <b>sd_bus_flush_close_unref()</b> and <b>sd_bus_flush_close_unrefp()</b> were added in version 240.

       <b>sd_bus_close_unref()</b> and <b>sd_bus_close_unrefp()</b> were added in version 241.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1), <b><a href="../man3/sd-bus.3.html">sd-bus</a></b>(3), <b><a href="../man3/sd_bus_default_user.3.html">sd_bus_default_user</a></b>(3), <b><a href="../man3/sd_bus_default_system.3.html">sd_bus_default_system</a></b>(3), <b><a href="../man3/sd_bus_open_user.3.html">sd_bus_open_user</a></b>(3),
       <b><a href="../man3/sd_bus_open_system.3.html">sd_bus_open_system</a></b>(3), <b><a href="../man3/sd_bus_close.3.html">sd_bus_close</a></b>(3)

</pre><h4><b>NOTES</b></h4><pre>
        1. Clean-up Variable Attribute
           https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html

systemd 257.7                                                                                      <u><a href="../man3/SD_BUS_NEW.3.html">SD_BUS_NEW</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>