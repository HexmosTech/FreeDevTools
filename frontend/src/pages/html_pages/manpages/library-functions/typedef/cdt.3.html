<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cdt - container data types</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgraphviz-dev">libgraphviz-dev_2.42.4-3build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>Cdt</b> - container data types

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;cdt.h&gt;

   <b>DICTIONARY</b> <b>TYPES</b>
       Dt_t;
       Dtdisc_t;
       Dtmethod_t;
       Dtlink_t;
       Dtstat_t;

   <b>DICTIONARY</b> <b>CONTROL</b>
       Dt_t*       dtopen(const Dtdisc_t* disc, const Dtmethod_t* meth);
       int         dtclose(Dt_t* dt);
       void        dtclear(dt);
       Dtmethod_t* dtmethod(Dt_t* dt, const Dtmethod_t* meth);
       Dtdisc_t*   dtdisc(Dt_t* dt, const Dtdisc_t* disc, int type);
       Dt_t*       dtview(Dt_t* dt, Dt_t* view);

   <b>STORAGE</b> <b>METHODS</b>
       Dtmethod_t* Dtset;
       Dtmethod_t* Dtbag;
       Dtmethod_t* Dtoset;
       Dtmethod_t* Dtobag;
       Dtmethod_t* Dtlist;
       Dtmethod_t* Dtstack;
       Dtmethod_t* Dtqueue;
       Dtmethod_t* Dtdeque;

   <b>DISCIPLINE</b>
       #define DTOFFSET(struct_s,member)
       #define DTDISC(disc,key,size,link,makef,freef,comparf,hashf,memoryf,eventf)
       typedef void*      (*Dtmake_f)(Dt_t*, void*, Dtdisc_t*);
       typedef void         (*Dtfree_f)(Dt_t*, void*, Dtdisc_t*);
       typedef int          (*Dtcompar_f)(Dt_t*, void*, void*, Dtdisc_t*);
       typedef unsigned int (*Dthash_f)(Dt_t*, void*, Dtdisc_t*);
       typedef void*      (*Dtmemory_f)(Dt_t*, void*, size_t, Dtdisc_t*);
       typedef int          (*Dtevent_f)(Dt_t*, int, void*, Dtdisc_t*);

   <b>OBJECT</b> <b>OPERATIONS</b>
       void*   dtinsert(Dt_t* dt, void* obj);
       void*   dtappend(Dt_t* dt, void* obj);
       void*   dtdelete(Dt_t* dt, void* obj);
       void*   dtattach(Dt_t* dt, void* obj);
       void*   dtdetach(Dt_t* dt, void* obj);
       void*   dtsearch(Dt_t* dt, void* obj);
       void*   dtmatch(Dt_t* dt, void* key);
       void*   dtfirst(Dt_t* dt);
       void*   dtnext(Dt_t* dt, void* obj);
       void*   dtlast(Dt_t* dt);
       void*   dtprev(Dt_t* dt, void* obj);
       void*   dtfinger(Dt_t* dt);
       void*   dtrenew(Dt_t* dt, void* obj);
       int       dtwalk(Dt_t* dt, int (*userf)(Dt_t*, void*, void*), void*);
       Dtlink_t* dtflatten(Dt_t* dt);
       Dtlink_t* dtlink(Dt_t*, Dtlink_t* link);
       void*   dtobj(Dt_t* dt, Dtlink_t* link);
       Dtlink_t* dtextract(Dt_t* dt);
       int       dtrestore(Dt_t* dt, Dtlink_t* link);

       #define   DTTREESEARCH(Dt_t* dt, void* obj, action)
       #define   DTTREEMATCH(Dt_t* dt, void* key, action)

   <b>DICTIONARY</b> <b>STATUS</b>
       Dt_t*     dtvnext(Dt_t* dt);
       int       dtvcount(Dt_t* dt);
       Dt_t*     dtvhere(Dt_t* dt);
       int       dtsize(Dt_t* dt);
       int       dtstat(Dt_t* dt, Dtstat_t*, int all);

   <b>HASH</b> <b>FUNCTIONS</b>
       unsigned int dtstrhash(unsigned int h, char* str, int n);
       unsigned int dtcharhash(unsigned int h, unsigned char c);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Cdt</u>  manages  run-time  dictionaries using standard container data types: unordered set/multiset, ordered
       set/multiset, list, stack, and queue.

   <b>DICTIONARY</b> <b>TYPES</b>
     <b>Dt_t</b>
       This is the type of a dictionary handle.

     <b>Dtdisc_t</b>
       This defines the type  of  a  discipline  structure  which  describes  object  lay-out  and  manipulation
       functions.

     <b>Dtmethod_t</b>
       This defines the type of a container method.

     <b>Dtlink_t</b>
       This is the type of a dictionary object holder (see dtdisc()<b>.)</b>

     <b>Dtstat_t</b>
       This is the type of a structure to return dictionary statistics (see dtstat()<b>.)</b>

   <b>DICTIONARY</b> <b>CONTROL</b>
     <b>Dt_t*</b> <b>dtopen(const</b> <b>Dtdisc_t*</b> <b>disc,</b> <b>const</b> <b>Dtmethod_t*</b> <b>meth)</b>
       This creates a new dictionary.  disc <b>is</b> <b>a</b> <b>discipline</b> <b>structure</b> <b>to</b> <b>describe</b> <b>object</b> <b>format.</b>  <b>meth</b> specifies
       a  manipulation  method.   dtopen()  <b>returns</b>  <b>the</b>  <b>new</b>  <b>dictionary</b> <b>or</b> <b>NULL</b> on error.  See also the events
       DT_OPEN <b>and</b> <b>DT_ENDOPEN</b> below.

     <b>int</b> <b>dtclose(Dt_t*</b> <b>dt)</b>
       This deletes dt <b>and</b> <b>its</b> <b>objects.</b>  <b>Note</b> <b>that</b>  <b>dtclose()</b>  fails  if  dt  <b>is</b>  <b>being</b>  <b>viewed</b>  <b>by</b>  <b>some</b>  <b>other</b>
       <b>dictionaries</b>  <b>(see</b>  <b>dtview()</b>).   dtclose()  <b>returns</b>  <b>0</b>  on  success and -1 <b>on</b> <b>error.</b>  <b>See</b> <b>also</b> <b>the</b> <b>events</b>
       <b>DT_CLOSE</b> and DT_ENDCLOSE <b>below.</b>

     <b>void</b> <b>dtclear(Dt_t*</b> <b>dt)</b>
       This deletes all objects in dt <b>without</b> <b>closing</b> <b>dt</b>.

     <b>Dtmethod_t</b> <b>dtmethod(Dt_t*</b> <b>dt,</b> <b>const</b> <b>Dtmethod_t*</b> <b>meth)</b>
       If meth <b>is</b> <b>NULL</b>, dtmethod() <b>returns</b> <b>the</b> <b>current</b> <b>method.</b>  <b>Otherwise,</b> <b>it</b> <b>changes</b> <b>the</b> <b>storage</b> <b>method</b>  <b>of</b>  <b>dt</b>
       to  meth<b>.</b>   <b>Object</b>  <b>order</b>  <b>remains</b>  <b>the</b>  <b>same</b>  <b>during</b>  <b>a</b> <b>method</b> <b>switch</b> <b>among</b> <b>Dtlist</b>, Dtstack<b>,</b> <b>Dtqueue</b> and
       Dtdeque<b>.</b>  <b>Switching</b> <b>to</b> <b>and</b>  <b>from</b>  <b>Dtset/Dtbag</b>  and  Dtoset/Dtobag  <b>may</b>  <b>cause</b>  <b>objects</b>  <b>to</b>  <b>be</b>  <b>rehashed,</b>
       <b>reordered,</b> <b>or</b> <b>removed</b> <b>as</b> <b>the</b> <b>case</b> <b>requires.</b>  <b>dtmethod()</b> returns the previous method or NULL <b>on</b> <b>error.</b>

     <b>Dtdisc_t*</b> <b>dtdisc(Dt_t*</b> <b>dt,</b> <b>const</b> <b>Dtdisc_t*</b> <b>disc,</b> <b>int</b> <b>type)</b>
       If  disc <b>is</b> <b>NULL</b>, dtdisc() <b>returns</b> <b>the</b> <b>current</b> <b>discipline.</b>  <b>Otherwise,</b> <b>it</b> <b>changes</b> <b>the</b> <b>discipline</b> <b>of</b> <b>dt</b> to
       disc<b>.</b>  <b>Objects</b> <b>may</b> <b>be</b> <b>rehashed,</b> <b>reordered,</b> <b>or</b> <b>removed</b> <b>as</b> <b>appropriate.</b>  <b>type</b> can be any bit combination of
       DT_SAMECMP <b>and</b> <b>DT_SAMEHASH</b>.  DT_SAMECMP <b>means</b> <b>that</b> <b>objects</b> <b>will</b> <b>compare</b> <b>exactly</b> <b>the</b> <b>same</b> <b>as</b>  <b>before</b>  <b>thus</b>
       <b>obviating</b>  <b>the</b>  <b>need</b>  <b>for</b>  <b>reordering</b>  <b>or</b> <b>removing</b> <b>new</b> <b>duplicates.</b>  <b>DT_SAMEHASH</b> means that hash values of
       objects remain the same thus obviating the need to rehash.  dtdisc() <b>returns</b> <b>the</b> <b>previous</b>  <b>discipline</b>  <b>on</b>
       <b>success</b> <b>and</b> <b>NULL</b> on error.

     <b>Dt_t*</b> <b>dtview(Dt_t*</b> <b>dt,</b> <b>Dt_t*</b> <b>view)</b>
       A  viewpath  allows  a  search or walk starting from a dictionary to continue to another.  dtview() <b>first</b>
       <b>terminates</b> <b>any</b> <b>current</b> <b>view</b> <b>from</b> <b>dt</b> to another dictionary.  Then, if view <b>is</b>  <b>NULL</b>,  dtview  <b>returns</b>  <b>the</b>
       <b>terminated</b>  <b>view</b>  <b>dictionary.</b>   <b>If</b> <b>view</b> is not NULL<b>,</b> <b>a</b> <b>viewpath</b> <b>from</b> <b>dt</b> to view <b>is</b> <b>established.</b>  <b>dtview()</b>
       returns dt <b>on</b> <b>success</b> <b>and</b> <b>NULL</b> on error.

       It is an error to have  dictionaries  on  a  viewpath  with  different  storage  methods.   In  addition,
       dictionaries on the same view path should treat objects in a consistent manner with respect to comparison
       or hashing.  If not, undefined behaviors may result.

   <b>STORAGE</b> <b>METHODS</b>
       Storage methods are of type Dtmethod_t*.  <u>Cdt</u> supports the following methods:

     <b>Dtoset</b>
     <b>Dtobag</b>
       Objects are ordered by comparisons.  Dtoset <b>keeps</b> <b>unique</b> <b>objects.</b>  <b>Dtobag</b> allows repeatable objects.

     <b>Dtset</b>
     <b>Dtbag</b>
       Objects  are  unordered.   Dtset  <b>keeps</b> <b>unique</b> <b>objects.</b>  <b>Dtbag</b> allows repeatable objects and always keeps
       them together (note the effect on dictionary walking.)  These methods use a hash table with  chaining  to
       manage  the  objects.   See  also  the  event DT_HASHSIZE <b>below</b> <b>on</b> <b>how</b> <b>to</b> <b>manage</b> <b>hash</b> <b>table</b> <b>resizing</b> <b>when</b>
       <b>objects</b> <b>are</b> <b>inserted.</b>

     <b>Dtlist</b>
       Objects are kept in a list.  The call dtinsert() <b>inserts</b> <b>a</b> <b>new</b> <b>object</b> <b>in</b> <b>front</b> <b>of</b> <u>the</u> <u>current</u> <u>object</u> <b>(see</b>
       <b>dtfinger()</b><u>)</u> <u>if</u> <u>it</u> <u>is</u> <u>defined</u> <u>or</u> <u>at</u> <u>list</u> <u>front</u> <u>if</u> <u>no</u> <u>current</u>  <u>object</u>  <u>is</u>  <u>defined.</u>   <u>Similarly,</u>  <u>the</u>  <u>call</u>
       <u>dtappend()</u> <b>appends</b> <b>a</b> <b>new</b> <b>object</b> <b>after</b> <u>the</u> <u>current</u> <u>object</u> <b>(see</b> <b>dtfinger()</b><u>)</u> <u>if</u> <u>it</u> <u>is</u> <u>defined</u> <u>or</u> <u>at</u> <u>list</u> <u>end</u>
       <u>if</u> <u>no</u> <u>current</u> <u>object</u> <u>is</u> <u>defined.</u>

     <b>Dtdeque</b>
       Objects  are  kept  in  a deque. This is similar to Dtlist <b>except</b> <b>that</b> <b>objects</b> <b>are</b> <b>always</b> <b>inserted</b> <b>at</b> <b>the</b>
       <b>front</b> <b>and</b> <b>appended</b> <b>at</b> <b>the</b> <b>tail</b> <b>of</b> <b>the</b> <b>list.</b>

     <b>Dtstack</b>
       Objects are kept in a stack, i.e., in reverse order of insertion.  Thus, the last object inserted  is  at
       stack top and will be the first to be deleted.

     <b>Dtqueue</b>
       Objects  are  kept  in a queue, i.e., in order of insertion.  Thus, the first object inserted is at queue
       head and will be the first to be deleted.

   <b>DISCIPLINE</b>
       Object format and associated management functions are defined in the type Dtdisc_t:
           typedef struct
           { int        key, size;
             int        link;
             Dtmake_f   makef;
             Dtfree_f   freef;
             Dtcompar_f comparf;
             Dthash_f   hashf;
             Dtmemory_f memoryf;
             Dtevent_f  eventf;
           } Dtdisc_t;

     <b>int</b> <b>key,</b> <b>size</b>
       Each object obj <b>is</b> <b>identified</b> <b>by</b> <b>a</b> <b>key</b> <b>used</b> <b>for</b> <b>object</b> <b>comparison</b> <b>or</b> <b>hashing.</b>  <b>key</b> should be non-negative
       and defines an offset into obj<b>.</b>  <b>If</b> <b>size</b> is negative, the key is a null-terminated string  with  starting
       address  *(void**)((char*)obj+key)<b>.</b>   <b>If</b>  <b>size</b> is zero, the key is a null-terminated string with starting
       address (void*)((char*)obj+key)<b>.</b>  <b>Finally,</b> <b>if</b> <b>size</b> is positive, the key is a byte array  of  length  size
       <b>starting</b> <b>at</b> <b>(void*)((char*)obj+key)</b>.

     <b>int</b> <b>link</b>
       Let  obj  <b>be</b>  <b>an</b>  <b>object</b>  <b>to</b>  <b>be</b> <b>inserted</b> <b>into</b> <b>dt</b> as discussed below.  If link <b>is</b> <b>negative,</b> <b>an</b> <b>internally</b>
       <b>allocated</b> <b>object</b> <b>holder</b> <b>is</b> <b>used</b> <b>to</b> <b>hold</b> <b>obj</b>. Otherwise, obj <b>should</b> <b>have</b>  <b>a</b>  <b>Dtlink_t</b>  structure  embedded
       link <b>bytes</b> <b>into</b> <b>it,</b> <b>i.e.,</b> <b>at</b> <b>address</b> <b>(Dtlink_t*)((char*)obj+link)</b>.

     <b>void*</b> <b>(*makef)(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj,</b> <b>Dtdisc_t*</b> <b>disc)</b>
       If  makef  <b>is</b>  <b>not</b>  <b>NULL</b>,  dtinsert(dt,obj) <b>or</b> <b>dtappend()</b> will call it to make a copy of obj <b>suitable</b> <b>for</b>
       <b>insertion</b> <b>into</b> <b>dt</b>.  If makef <b>is</b> <b>NULL</b>, obj <b>itself</b> <b>will</b> <b>be</b> <b>inserted</b> <b>into</b> <b>dt</b>.

     <b>void</b> <b>(*freef)(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj,</b> <b>Dtdisc_t*</b> <b>disc)</b>
       If not NULL<b>,</b> <b>freef</b> is used to destroy data associated with obj<b>.</b>

   <b>int</b> <b>(*comparf)(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>key1,</b> <b>void*</b> <b>key2,</b> <b>Dtdisc_t*</b> <b>disc)</b>
       If not NULL<b>,</b> <b>comparf</b> is used to compare two keys.  Its return value should be &lt;0<b>,</b> <b>=0</b>, or &gt;0  <b>to</b>  <b>indicate</b>
       <b>whether</b>  <b>key1</b>  is  smaller,  equal  to, or larger than key2<b>.</b>  <b>All</b> <b>three</b> <b>values</b> <b>are</b> <b>significant</b> <b>for</b> <b>method</b>
       <b>Dtoset</b> and Dtobag<b>.</b>  <b>For</b> <b>other</b> <b>methods,</b> <b>a</b> <b>zero</b> <b>value</b> <b>indicates</b> <b>equality</b> <b>and</b>  <b>a</b>  <b>non-zero</b>  <b>value</b>  <b>indicates</b>
       <b>inequality.</b>   <b>If</b> <b>(*comparf)()</b> is NULL<b>,</b> <b>an</b> <b>internal</b> <b>function</b> <b>is</b> <b>used</b> <b>to</b> <b>compare</b> <b>the</b> <b>keys</b> <b>as</b> <b>defined</b> <b>by</b> <b>the</b>
       <b>Dtdisc_t.size</b> field.

     <b>unsigned</b> <b>int</b> <b>(*hashf)(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>key,</b> <b>Dtdisc_t*</b> <b>disc)</b>
       If not NULL<b>,</b> <b>hashf</b> is used to compute the hash value of key<b>.</b>  <b>It</b> <b>is</b> <b>required</b>  <b>that</b>  <b>keys</b>  <b>compared</b>  <b>equal</b>
       <b>will</b>  <b>also</b>  <b>have</b>  <b>same</b>  <b>hash</b>  <b>values.</b>   <b>If</b> <b>hashf</b> is NULL<b>,</b> <b>an</b> <b>internal</b> <b>function</b> <b>is</b> <b>used</b> <b>to</b> <b>hash</b> <b>the</b> <b>key</b> <b>as</b>
       <b>defined</b> <b>by</b> <b>the</b> <b>Dtdisc_t.size</b> field.

     <b>void*</b> <b>(*memoryf)(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>addr,</b> <b>size_t</b> <b>size,</b> <b>Dtdisc_t*</b> <b>disc)</b>
       If not NULL<b>,</b> <b>memoryf</b> is used to allocate and free memory.  When addr <b>is</b> <b>NULL</b>, a memory  segment  of  size
       size  <b>is</b>  <b>requested.</b>  <b>If</b> <b>addr</b> is not NULL <b>and</b> <b>size</b> is zero, addr <b>is</b> <b>to</b> <b>be</b> <b>freed.</b>  <b>If</b> <b>addr</b> is not NULL <b>and</b>
       <b>size</b> is positive, addr <b>is</b> <b>to</b> <b>be</b> <b>resized</b> <b>to</b> <b>the</b> <b>given</b> <b>size.</b>  <b>If</b> <b>memoryf</b> is NULL<b>,</b> <u><a href="../man3/malloc.3.html">malloc</a>(3)</u> <b>is</b> <b>used.</b>

     <b>int</b> <b>(*eventf)(Dt_t*</b> <b>dt,</b> <b>int</b> <b>type,</b> <b>void*</b> <b>data,</b> <b>Dtdisc_t*</b> <b>disc)</b>
       If not NULL<b>,</b> <b>eventf</b> announces various events.  Each event may have  particular  handling  of  the  return
       values from eventf<b>.</b>  <b>But</b> <b>a</b> <b>negative</b> <b>return</b> <b>value</b> <b>typically</b> <b>means</b> <b>failure.</b>  <b>Following</b> <b>are</b> <b>the</b> <b>events:</b>

       DT_OPEN<b>:</b>
              dt  <b>is</b> <b>being</b> <b>opened.</b>  <b>If</b> <b>eventf</b> returns negative, the opening process terminates with failure.  If
              eventf <b>returns</b> <b>zero,</b> <b>the</b> <b>opening</b> <b>process</b> <b>proceeds</b> <b>in</b> <b>a</b> <b>default</b> <b>manner.</b>  <b>A</b>  <b>positive</b>  <b>return</b>  <b>value</b>
              <b>indicates</b> <b>special</b> <b>treatment</b> <b>of</b> <b>memory</b> <b>as</b> <b>follows.</b>  <b>If</b> <b>*(void**)data</b> is set to point to some memory
              segment  as  discussed  in  memoryf<b>,</b>  <b>that</b>  <b>segment</b>  <b>of</b> <b>memory</b> <b>is</b> <b>used</b> <b>to</b> <b>start</b> <b>the</b> <b>dictionary.</b> <b>If</b>
              <b>*(void**)data</b> is NULL<b>,</b> <b>all</b> <b>memory</b> <b>including</b> <b>that</b> <b>of</b> <b>the</b> <b>dictionary</b> <b>handle</b> <b>itself</b> <b>will</b> <b>be</b> <b>allocated</b>
              <b>via</b> <b>memoryf</b>.

       DT_ENDOPEN:
              This event announces that dtopen() has successfully opened a dictionary and is  about  to  return.
              The data argument of eventf should be the new dictionary handle itself.

       DT_CLOSE:
              dt  is  about  to be closed. If eventf returns negative, the closing process stops immediately and
              dtclose() returns -1.  Objects in the dictionary are deleted only if  eventf  returns  zero.   The
              dictionary  handle  itself  is processed as follows.  If it was allocated via malloc(), it will be
              freed.  If it was allocated via memoryf (see dtopen()) and eventf returns 0,  a  call  to  memoryf
              will be issued to attempt freeing the handle.  Otherwise, nothing will be done to its memory.

              As should be clear from their description, the events DT_OPEN and DT_CLOSE are designed to be used
              along  with  memoryf  to  manage  the  allocation and deallocation of dictionary and object memory
              across dictionaries. In fact, they can be used to  manage  dictionaries  based  on  shared  and/or
              persistent memory.

       DT_ENDCLOSE:
              This event announces that dtclose() has successfully closed a dictionary and is about to return.

       DT_DISC:
              The discipline of dt is being changed to a new one given in (Dtdisc_t*)data.

       DT_METH:
              The method of dt is being changed to a new one given in (Dtmethod_t*)data.

       DT_HASHSIZE:
              The  hash table (for Dtset and Dtbag) is being resized.  In this case, *(int*)data has the current
              size of the table.  The application can set the new table size by first  changing  *(int*)data  to
              the  desired  size,  then return a positive value.  The application can also fix the table size at
              the current value forever by setting *(int*)data to a negative value, then again return a positive
              value. A non-positive return value from the  event  handling  function  means  that  Cdt  will  be
              responsible for choosing the hash table size.

   <b>#define</b> <b>DTOFFSET(struct_s,member)</b>
       This  macro function computes the offset of member <b>from</b> <b>the</b> <b>start</b> <b>of</b> <b>structure</b> <b>struct_s</b>. It is useful for
       getting the offset of a Dtlink_t <b>embedded</b> <b>inside</b> <b>an</b> <b>object.</b>

   <b>#define</b> <b>DTDISC(disc,key,size,link,makef,freef,comparf,hashf,memoryf,eventf)</b>
       This macro function initializes the discipline pointed to by disc <b>with</b> <b>the</b> <b>given</b> <b>values.</b>

   <b>OBJECT</b> <b>OPERATIONS</b>
     <b>void*</b> <b>dtinsert(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj)</b>
     <b>void*</b> <b>dtappend(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj)</b>
       These functions add an object prototyped by obj <b>into</b> <b>dt</b>.  dtinsert()  <b>and</b>  <b>dtappend()</b>  perform  the  same
       function for all methods except for Dtlist<b>.</b> <b>See</b> <b>Dtlist</b> for details.  If there is an existing object in dt
       <b>matching</b>  <b>obj</b> and the storage method is Dtset <b>or</b> <b>Dtoset</b>, dtinsert() <b>and</b> <b>dtappend()</b> will simply return the
       matching object.  Otherwise, a new object is inserted according to the method in use.  See Dtdisc_t.makef
       <b>for</b> <b>object</b> <b>construction.</b>  <b>The</b> <b>new</b> <b>object</b> <b>or</b> <b>a</b> <b>matching</b> <b>object</b> <b>as</b> <b>noted</b> <b>will</b> <b>be</b> <b>returned</b> <b>on</b> <b>success</b>  <b>while</b>
       <b>NULL</b> is returned on error.

     <b>void*</b> <b>dtdelete(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj)</b>
       If  obj  <b>is</b>  <b>NULL</b>,  methods  Dtstack  <b>and</b> <b>Dtqueue</b> delete respectively stack top or queue head while other
       methods do nothing.  If obj <b>is</b> <b>not</b> <b>NULL</b>, there are two cases.  If the method  in  use  is  not  Dtbag  <b>or</b>
       <b>Dtobag</b>,  the  first  object matching obj <b>is</b> <b>deleted.</b>  <b>On</b> <b>the</b> <b>other</b> <b>hand,</b> <b>if</b> <b>the</b> <b>method</b> <b>in</b> <b>use</b> <b>is</b> <b>Dtbag</b> or
       Dtobag<b>,</b> <b>the</b> <b>library</b> <b>check</b> <b>to</b> <b>see</b> <b>if</b> <b>obj</b> is in the dictionary and  delete  it.   If  obj  <b>is</b>  <b>not</b>  <b>in</b>  <b>the</b>
       <b>dictionary,</b>  <b>some</b>  <b>object</b>  <b>matching</b>  <b>it</b>  <b>will</b>  <b>be</b>  <b>deleted.</b>   <b>See</b>  <b>Dtdisc_t.freef</b> for object destruction.
       dtdelete() <b>returns</b> <b>the</b> <b>deleted</b> <b>object</b> <b>(even</b> <b>if</b> <b>it</b> <b>was</b> <b>deallocated)</b> <b>or</b> <b>NULL</b> on error.

     <b>void*</b> <b>dtattach(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj)</b>
       This function is similar to dtinsert() <b>but</b> <b>obj</b> itself will be inserted  into  dt  <b>even</b>  <b>if</b>  <b>a</b>  <b>discipline</b>
       <b>function</b> <b>makef</b> is defined.

     <b>void*</b> <b>dtdetach(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj)</b>
       This  function  is  similar to dtdelete() <b>but</b> <b>the</b> <b>object</b> <b>to</b> <b>be</b> <b>deleted</b> <b>from</b> <b>dt</b> will not be freed (via the
       discipline freef <b>function).</b>

     <b>void*</b> <b>dtsearch(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj)</b>
     <b>void*</b> <b>dtmatch(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>key)</b>
       These functions find an object matching obj <b>or</b> <b>key</b> either from dt <b>or</b> <b>from</b> <b>some</b> <b>dictionary</b> <b>accessible</b> <b>from</b>
       <b>dt</b> via a viewpath (see dtview()<b>.)</b>  <b>dtsearch()</b> and  dtmatch()  <b>return</b>  <b>the</b>  <b>matching</b>  <b>object</b>  <b>or</b>  <b>NULL</b>  on
       failure.

     <b>void*</b> <b>dtfirst(Dt_t*</b> <b>dt)</b>
     <b>void*</b> <b>dtnext(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj)</b>
       dtfirst()  <b>returns</b>  <b>the</b>  <b>first</b>  <b>object</b>  <b>in</b>  <b>dt</b>.   dtnext() <b>returns</b> <b>the</b> <b>object</b> <b>following</b> <b>obj</b>.  Objects are
       ordered based on the storage method in use.  For  Dtoset  <b>and</b>  <b>Dtobag</b>,  objects  are  ordered  by  object
       comparisons.   For  Dtstack<b>,</b> <b>objects</b> <b>are</b> <b>ordered</b> <b>in</b> <b>reverse</b> <b>order</b> <b>of</b> <b>insertion.</b>  <b>For</b> <b>Dtqueue</b>, objects are
       ordered in order of insertion.  For Dtlist<b>,</b> <b>objects</b> <b>are</b> <b>ordered</b> <b>by</b> <b>list</b> <b>position.</b>  <b>For</b> <b>Dtset</b>  and  Dtbag<b>,</b>
       <b>objects</b> <b>are</b> <b>ordered</b> <b>by</b> <b>some</b> <b>internal</b> <b>order</b> <b>(more</b> <b>below).</b>  <b>Thus,</b> <b>objects</b> <b>in</b> <b>a</b> <b>dictionary</b> <b>or</b> <b>a</b> <b>viewpath</b> <b>can</b>
       <b>be</b> <b>walked</b> <b>using</b> <b>a</b> <b>for(;;)</b> loop as below.
           for(obj = dtfirst(dt); obj; obj = dtnext(dt,obj))
       When  a dictionary uses Dtset or Dtbag, the object order is determined upon a call to dtfirst()/dtlast().
       This order is frozen until a call dtnext()/dtprev() returns NULL or when these same functions are  called
       with  a  NULL  object  argument.   It  is  important  that  a  dtfirst()/dtlast()  call  be balanced by a
       dtnext()/dtprev() call as described.  Nested loops will require multiple balancing, once  per  loop.   If
       loop balancing is not done carefully, either performance is degraded or unexpected behaviors may result.

     <b>void*</b> <b>dtlast(Dt_t*</b> <b>dt)</b>
     <b>void*</b> <b>dtprev(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj)</b>
       dtlast()  <b>and</b> <b>dtprev()</b> are like dtfirst() <b>and</b> <b>dtnext()</b> but work in reverse order.  Note that dictionaries
       on a viewpath are still walked in order but objects in each dictionary are walked in reverse order.

     <b>void*</b> <b>dtfinger(Dt_t*</b> <b>dt)</b>
       This function returns the <u>current</u> <u>object</u> of dt<u>,</u> <u>if</u> <u>any.</u>  <u>The</u> <u>current</u> <u>object</u> <u>is</u> <u>defined</u> <u>after</u> <u>a</u> <u>successful</u>
       <u>call</u> <u>to</u> <u>one</u> <u>of</u> <u>dtsearch()</u>, dtmatch()<u>,</u> <u>dtinsert()</u>, dtfirst()<u>,</u> <u>dtnext()</u>, dtlast()<u>,</u> <u>or</u> <u>dtprev()</u>.  As a  side
       effect of this implementation of <u>Cdt</u>, when a dictionary is based on Dtoset <u>and</u> <u>Dtobag</u>, the current object
       is always defined and is the root of the tree.

     <b>void*</b> <b>dtrenew(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj)</b>
       This  function  repositions and perhaps rehashes an object obj <b>after</b> <b>its</b> <b>key</b> <b>has</b> <b>been</b> <b>changed.</b>  <b>dtrenew()</b>
       only works if obj <b>is</b> <b>the</b> <b>current</b> <b>object</b> <b>(see</b> <b>dtfinger()</b>).

     <b>dtwalk(Dt_t*</b> <b>dt,</b> <b>int</b> <b>(*userf)(Dt_t*,</b> <b>void*,</b> <b>void*),</b> <b>void*</b> <b>data)</b>
       This function calls (*userf)(walk,obj,data) <b>on</b> <b>each</b> <b>object</b> <b>in</b> <b>dt</b> and other dictionaries viewable from it.
       walk <b>is</b> <b>the</b> <b>dictionary</b> <b>containing</b> <b>obj</b>.  If userf() <b>returns</b> <b>a</b> <b>&lt;0</b> value, dtwalk()  <b>terminates</b>  <b>and</b>  <b>returns</b>
       <b>the</b> <b>same</b> <b>value.</b>  <b>dtwalk()</b> returns 0 <b>on</b> <b>completion.</b>

     <b>Dtlink_t*</b> <b>dtflatten(Dt_t*</b> <b>dt)</b>
     <b>Dtlink_t*</b> <b>dtlink(Dt_t*</b> <b>dt,</b> <b>Dtlink_t*</b> <b>link)</b>
     <b>void*</b> <b>dtobj(Dt_t*</b> <b>dt,</b> <b>Dtlink_t*</b> <b>link)</b>
       Using  dtfirst()/dtnext() <b>or</b> <b>dtlast()/dtprev()</b> to walk a single dictionary can incur significant cost due
       to function calls.  For efficient walking of a single directory (i.e., no viewpathing),  dtflatten()  <b>and</b>
       <b>dtlink()</b> can be used.  Objects in dt <b>are</b> <b>made</b> <b>into</b> <b>a</b> <b>linked</b> <b>list</b> <b>and</b> <b>walked</b> <b>as</b> <b>follows:</b>
           <b>for(link</b> <b>=</b> <b>dtflatten(dt);</b> <b>link;</b> <b>link</b> <b>=</b> <b>dtlink(dt,link)</b> <b>)</b>

       Note  that  dtflatten()  returns  a  list  of type Dtlink_t*, not void*. That is, it returns a dictionary
       holder pointer, not a user object pointer (although both are the same if the  discipline  field  link  is
       zero.)   The  macro  function  dtlink()  returns  the dictionary holder object following link.  The macro
       function dtobj(dt,link) returns the user object associated with link, Beware that  the  flattened  object
       list is unflattened on any dictionary operations other than dtlink().

     <b>Dtlink_t*</b> <b>dtextract(Dt_t*</b> <b>dt)</b>
     <b>int</b> <b>dtrestore(Dt_t*</b> <b>dt,</b> <b>Dtlink_t*</b> <b>link)</b>
       dtextract()  <b>extracts</b>  <b>all</b>  <b>objects</b>  <b>from</b>  <b>dt</b> and makes it appear empty.  dtrestore() <b>repopulates</b> <b>dt</b> with
       objects previously obtained via dtextract()<b>.</b>  <b>dtrestore()</b> will fail if dt <b>is</b> <b>not</b> <b>empty.</b>  <b>These</b>  <b>functions</b>
       <b>can</b>  <b>be</b>  <b>used</b> <b>to</b> <b>share</b> <b>a</b> <b>same</b> <b>dt</b> handle among many sets of objects.  They are useful to reduce dictionary
       overhead in an application that creates many concurrent dictionaries.  It  is  important  that  the  same
       discipline  and  method are in use at both extraction and restoration. Otherwise, undefined behaviors may
       result.

     <b>#define</b>   <b>DTTREESEARCH(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>obj,</b> <b>action)</b>
     <b>#define</b>   <b>DTTREEMATCH(Dt_t*</b> <b>dt,</b> <b>void*</b> <b>key,</b> <b>action)</b>
       These macro functions are analogues of dtsearch() <b>and</b> <b>dtmatch()</b> but they can only be used on a dictionary
       based on a binary search tree, i.e., Dtoset <b>or</b> <b>Dtobag</b>.

       obj or key:
              These are used to find a matching object. If there is no match, the result is NULL.

       action:
              The matching object o (which may be NULL) will be processed as follow:

                  action (o);

              Since action is used verbatim, it can be any C  code  fragment  combinable  with  (o)  to  form  a
              syntactically  correct  C statement.  For example, suppose that the matching object is an integer,
              the below code accumulates the integer value in a variable total:

                  DTTREEMATCH(dt, key, total += (int));

   <b>DICTIONARY</b> <b>INFORMATION</b>
     <b>Dt_t*</b> <b>dtvnext(Dt_t*</b> <b>dt)</b>
       This returns the dictionary that dt <b>is</b> <b>viewing,</b> <b>if</b> <b>any.</b>

     <b>int</b> <b>dtvcount(Dt_t*</b> <b>dt)</b>
       This returns the number of dictionaries that view dt<b>.</b>

     <b>Dt_t*</b> <b>dtvhere(Dt_t*</b> <b>dt)</b>
       This returns the dictionary v <b>viewable</b> <b>from</b> <b>dt</b> where an object was found from the most recent  search  or
       walk operation.

     <b>int</b> <b>dtsize(Dt_t*</b> <b>dt)</b>
       This function returns the number of objects stored in dt<b>.</b>

     <b>int</b> <b>dtstat(Dt_t</b> <b>*dt,</b> <b>Dtstat_t*</b> <b>st,</b> <b>int</b> <b>all)</b>
       This  function  reports  dictionary  statistics.   If  all  <b>is</b>  <b>non-zero,</b>  <b>all</b>  <b>fields</b>  <b>of</b> <b>st</b> are filled.
       Otherwise, only the dt_type <b>and</b> <b>dt_size</b> fields are filled.  It returns 0 <b>on</b> <b>success</b> <b>and</b> <b>-1</b> on error.

       Dtstat_t contains the below fields:

       int dt_type:
              This is one of DT_SET, DT_BAG, DT_OSET, DT_OBAG, DT_LIST, DT_STACK, and DT_QUEUE.

       int dt_size:
              This contains the number of objects in the dictionary.

       int dt_n:
              For Dtset and Dtbag, this is the number of non-empty chains in the hash  table.   For  Dtoset  and
              Dtobag,  this  is  the  deepest  level  in  the tree (counting from zero.)  Each level in the tree
              contains all nodes of equal distance from the root node.   dt_n  and  the  below  two  fields  are
              undefined for other methods.

       int dt_max:
              For Dtbag and Dtset, this is the size of a largest chain.  For Dtoset and Dtobag, this is the size
              of a largest level.

       int* dt_count:
              For  Dtset  and  Dtbag,  this  is the list of counts for chains of particular sizes.  For example,
              dt_count[1] is the number of chains of size 1.  For Dtoset and Dtobag, this is the list  of  sizes
              of the levels.  For example, dt_count[1] is the size of level 1.

   <b>HASH</b> <b>FUNCTIONS</b>
     <b>unsigned</b> <b>int</b> <b>dtcharhash(unsigned</b> <b>int</b> <b>h,</b> <b>char</b> <b>c)</b>
     <b>unsigned</b> <b>int</b> <b>dtstrhash(unsigned</b> <b>int</b> <b>h,</b> <b>char*</b> <b>str,</b> <b>int</b> <b>n)</b>
       These  functions  compute hash values from bytes or strings.  dtcharhash() <b>computes</b> <b>a</b> <b>new</b> <b>hash</b> <b>value</b> <b>from</b>
       <b>byte</b> <b>c</b> and seed value h<b>.</b>  <b>dtstrhash()</b> computes a new hash value from string str <b>and</b> <b>seed</b> <b>value</b> <b>h</b>.   If  n
       <b>is</b> <b>positive,</b> <b>str</b> is a byte array of length n<b>;</b> <b>otherwise,</b> <b>str</b> is a null-terminated string.

</pre><h4><b>IMPLEMENTATION</b> <b>NOTES</b></h4><pre>
       Dtset  <b>and</b>  <b>Dtbag</b>  are  based  on hash tables with move-to-front collision chains.  Dtoset <b>and</b> <b>Dtobag</b> are
       based on top-down splay trees.  Dtlist<b>,</b> <b>Dtstack</b> and Dtqueue <b>are</b> <b>based</b> <b>on</b> <b>doubly</b> <b>linked</b> <b>list.</b>

</pre><h4><b>AUTHOR</b></h4><pre>
       Kiem-Phong Vo, <a href="mailto:kpv@research.att.com">kpv@research.att.com</a>

                                                                                                       <u><a href="../man3/LIBCDT.3.html">LIBCDT</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>