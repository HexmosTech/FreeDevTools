<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type::Tiny::Enum - string enum type constraints</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtype-tiny-perl">libtype-tiny-perl_2.004000-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Type::Tiny::Enum - string enum type constraints

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Using via Types::Standard:

         package Horse {
           use Moo;
           use Types::Standard qw( Str Enum );

           has name    =&gt; ( is =&gt; 'ro', isa =&gt; Str );
           has status  =&gt; ( is =&gt; 'ro', isa =&gt; Enum[ 'alive', 'dead' ] );

           sub neigh {
             my ( $self ) = @_;
             return if $self-&gt;status eq 'dead';
             ...;
           }
         }

       Using Type::Tiny::Enum's export feature:

         package Horse {
           use Moo;
           use Types::Standard qw( Str );
           use Type::Tiny::Enum Status =&gt; [ 'alive', 'dead' ];

           has name    =&gt; ( is =&gt; 'ro', isa =&gt; Str );
           has status  =&gt; ( is =&gt; 'ro', isa =&gt; Status, default =&gt; STATUS_ALIVE );

           sub neigh {
             my ( $self ) = @_;
             return if $self-&gt;status eq STATUS_DEAD;
             ...;
           }
         }

       Using Type::Tiny::Enum's object-oriented interface:

         package Horse {
           use Moo;
           use Types::Standard qw( Str );
           use Type::Tiny::Enum;

           my $Status = Type::Tiny::Enum-&gt;new(
             name   =&gt; 'Status',
             values =&gt; [ 'alive', 'dead' ],
           );

           has name    =&gt; ( is =&gt; 'ro', isa =&gt; Str );
           has status  =&gt; ( is =&gt; 'ro', isa =&gt; $Status, default =&gt; $Status-&gt;[0] );

           sub neigh {
             my ( $self ) = @_;
             return if $self-&gt;status eq $Status-&gt;[0];
             ...;
           }
         }

</pre><h4><b>STATUS</b></h4><pre>
       This module is covered by the Type-Tiny stability policy.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Enum type constraints.

       This package inherits from Type::Tiny; see that for most documentation.  Major differences are listed
       below:

   <b>Constructors</b>
       The "new" constructor from Type::Tiny still works, of course. But there is also:

       "new_union( type_constraints =&gt; \@enums, %opts )"
           Creates a new enum type constraint which is the union of existing enum type constraints.

       "new_intersection( type_constraints =&gt; \@enums, %opts )"
           Creates a new enum type constraint which is the intersection of existing enum type constraints.

   <b>Attributes</b>
       "values"
           Arrayref  of  allowable  value  strings.  Non-string  values  (e.g. objects with overloading) will be
           stringified in the constructor.

       "constraint"
           Unlike Type::Tiny, you <u>cannot</u> pass a constraint coderef to the  constructor.   Instead  rely  on  the
           default.

       "inlined"
           Unlike  Type::Tiny,  you  <u>cannot</u>  pass  an  inlining coderef to the constructor.  Instead rely on the
           default.

       "parent"
           Parent is always <b>Types::Standard::Str</b>, and cannot be passed to the constructor.

       "unique_values"
           The list of "values"  but  sorted  and  with  duplicates  removed.  This  cannot  be  passed  to  the
           constructor.

       "coercion"
           If  "coercion  =&gt;  1"  is  passed  to  the  constructor,  the  type  will  have  a coercion using the
           "closest_match" method.

   <b>Methods</b>
       "as_regexp"
           Returns the enum as a regexp which strings can be checked  against.  If  you're  checking  <u>a</u>  <u>lot</u>  of
           strings, then using this regexp might be faster than checking each string against

             my $enum  = Type::Tiny::Enum-&gt;new(...);
             my $check = $enum-&gt;compiled_check;
             my $re    = $enum-&gt;as_regexp;

             # fast
             my @valid_tokens = grep $enum-&gt;check($_), @all_tokens;

             # faster
             my @valid_tokens = grep $check-&gt;($_), @all_tokens;

             # fastest
             my @valid_tokens = grep /$re/, @all_tokens;

           You can get a case-insensitive regexp using "$enum-&gt;as_regexp('i')".

       "closest_match"
           Returns the closest match in the enum for a string.

             my $enum = Type::Tiny::Enum-&gt;new(
               values =&gt; [ qw( foo bar baz quux ) ],
             );

             say $enum-&gt;closest_match("FO");   # ==&gt; foo

           It  will  try  to find an exact match first, fall back to a case-insensitive match, if it still can't
           find one, will try to find a head substring match, and finally, if given an integer, will use that as
           an index.

             my $enum = Type::Tiny::Enum-&gt;new(
               values =&gt; [ qw( foo bar baz quux ) ],
             );

             say $enum-&gt;closest_match(  0 );  # ==&gt; foo
             say $enum-&gt;closest_match(  1 );  # ==&gt; bar
             say $enum-&gt;closest_match(  2 );  # ==&gt; baz
             say $enum-&gt;closest_match( -1 );  # ==&gt; quux

       "is_word_safe"
           Returns true if none of the values in the enumeration contain a non-word character.  Word  characters
           include letters, numbers, and underscores, but not most punctuation or whitespace.

   <b>Exports</b>
       Type::Tiny::Enum can be used as an exporter.

         use Type::Tiny::Enum Status =&gt; [ 'dead', 'alive' ];

       This will export the following functions into your namespace:

       "Status"
       is_Status( $value )
       assert_Status( $value )
       to_Status( $value )
       "STATUS_DEAD"
       "STATUS_ALIVE"

       Multiple enumerations can be exported at once:

         use Type::Tiny::Enum (
           Status    =&gt; [ 'dead', 'alive' ],
           TaxStatus =&gt; [ 'paid', 'pending' ],
         );

   <b>Overloading</b>
       â€¢   Arrayrefification calls "values".

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs to &lt;https://github.com/tobyink/p5-type-tiny/issues&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Type::Tiny::Manual.

       Type::Tiny.

       Moose::Meta::TypeConstraint::Enum.

</pre><h4><b>AUTHOR</b></h4><pre>
       Toby Inkster &lt;<a href="mailto:tobyink@cpan.org">tobyink@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2013-2014, 2017-2023 by Toby Inkster.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTIES</b></h4><pre>
       THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  WITHOUT
       LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

perl v5.40.1                                       2025-05-06                              <u>Type::Tiny::<a href="../man3pm/Enum.3pm.html">Enum</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>