<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Location::Split - Implementation of a Location on a Sequence which has multiple locations (start/end</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-perl-perl">libbio-perl-perl_1.7.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Location::Split - Implementation of a Location on a Sequence which has multiple locations (start/end
       points)

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Bio::Location::Split;

           my $splitlocation = Bio::Location::Split-&gt;new();
           $splitlocation-&gt;add_sub_Location(Bio::Location::Simple-&gt;new(-start=&gt;1,
                                                                      -end=&gt;30,
                                                                      -strand=&gt;1));
           $splitlocation-&gt;add_sub_Location(Bio::Location::Simple-&gt;new(-start=&gt;50,
                                                                      -end=&gt;61,
                                                                      -strand=&gt;1));
           my @sublocs = $splitlocation-&gt;sub_Location();

           my $count = 1;
           # print the start/end points of the sub locations
           foreach my $location ( sort { $a-&gt;start &lt;=&gt; $b-&gt;start }
                                  @sublocs ) {
               printf "sub feature %d [%d..%d]\n",
                      $count, $location-&gt;start,$location-&gt;end, "\n";
               $count++;
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This implementation handles locations which span more than one start/end location, or and/or lie on
       different sequences, and can work with split locations that depend on the specific order of the
       sublocations ('join') or don't have a specific order but represent a feature spanning noncontiguous
       sublocations ('order', 'bond').

       Note that the order in which sublocations are added may be very important, depending on the specific
       split location type.  For instance, a 'join' must have the sublocations added in the order that one
       expects to join the sublocations, whereas all other types are sorted based on the sequence location.

</pre><h4><b>FEEDBACK</b></h4><pre>
       User feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments
       and suggestions preferably to one of the Bioperl mailing lists.  Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list:

       <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather than to the module maintainer directly. Many experienced and reponsive experts will be able look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>Bugs</b>
       Report bugs to the Bioperl bug tracking system to help us keep track the bugs and their resolution.  Bug
       reports can be submitted via the web:

         https://github.com/bioperl/bioperl-live/issues

</pre><h4><b>AUTHOR</b> <b>-</b> <b>Jason</b> <b>Stajich</b></h4><pre>
       Email jason-AT-bioperl_DOT_org

</pre><h4><b>APPENDIX</b></h4><pre>
       The rest of the documentation details each of the object methods. Internal methods are usually preceded
       with a _

   <b>each_Location</b>
        Title   : each_Location
        Usage   : @locations = $locObject-&gt;each_Location($order);
        Function: Conserved function call across Location:: modules - will
                  return an array containing the component Location(s) in
                  that object, regardless if the calling object is itself a
                  single location or one containing sublocations.
        Returns : an array of Bio::LocationI implementing objects
        Args    : Optional sort order to be passed to sub_Location()

   <b>sub_Location</b>
        Title   : sub_Location
        Usage   : @sublocs = $splitloc-&gt;sub_Location();
        Function: Returns the array of sublocations making up this compound (split)
                  location. Those sublocations referring to the same sequence as
                  the root split location will be sorted by start position (forward
                  sort) or end position (reverse sort) and come first (before
                  those on other sequences).

                  The sort order can be optionally specified or suppressed by the
                  value of the first argument. The default is no sort.

        Returns : an array of Bio::LocationI implementing objects
        Args    : Optionally 1, 0, or -1 for specifying a forward, no, or reverse
                  sort order

   <b>add_sub_Location</b>
        Title   : add_sub_Location
        Usage   : $splitloc-&gt;add_sub_Location(@locationIobjs);
        Function: add an additional sublocation
        Returns : number of current sub locations
        Args    : list of Bio::LocationI implementing object(s) to add

   <b>splittype</b>
         Title   : splittype
         Usage   : $splittype = $location-&gt;splittype();
         Function: get/set the split splittype
         Returns : the splittype of split feature (join, order)
         Args    : splittype to set

   <b>is_single_sequence</b>
         Title   : is_single_sequence
         Usage   : if($splitloc-&gt;is_single_sequence()) {
                       print "Location object $splitloc is split ".
                             "but only across a single sequence\n";
                   }
         Function: Determine whether this location is split across a single or
                   multiple sequences.

                   This implementation ignores (sub-)locations that do not define
                   seq_id(). The same holds true for the root location.

         Returns : TRUE if all sublocations lie on the same sequence as the root
                   location (feature), and FALSE otherwise.
         Args    : none

   <b>guide_strand</b>
         Title   : guide_strand
         Usage   : $str = $loc-&gt;guide_strand();
         Function: Get/Set the guide strand.  Of use only if the split type is
                   a 'join' (this helps determine the order of sublocation
                               retrieval)
         Returns : value of guide strand (1, -1, or undef)
         Args    : new value (-1 or 1, optional)

</pre><h4><b>LocationI</b> <b>methods</b></h4><pre>
   <b>strand</b>
        Title   : strand
        Usage   : $obj-&gt;strand($newval)
        Function: For SplitLocations, setting the strand of the container
                  (this object) is a short-cut for setting the strand of all
                  sublocations.

                  In get-mode, checks if no sub-location is remote, and if
                  all have the same strand. If so, it returns that shared
                  strand value. Otherwise it returns undef.

        Example :
        Returns : on get, value of strand if identical between sublocations
                  (-1, 1, or undef)
        Args    : new value (-1 or 1, optional)

   <b>flip_strand</b>
         Title   : flip_strand
         Usage   : $location-&gt;flip_strand();
         Function: Flip-flop a strand to the opposite.  Also sets Split strand
                   to be consistent with the sublocation strands
                   (1, -1 or undef for mixed strand values)
         Returns : None
         Args    : None

   <b>start</b>
         Title   : start
         Usage   : $start = $location-&gt;start();
         Function: get the starting point of the first (sorted) sublocation
         Returns : integer
         Args    : none

   <b>end</b>
         Title   : end
         Usage   : $end = $location-&gt;end();
         Function: get the ending point of the last (sorted) sublocation
         Returns : integer
         Args    : none

   <b>min_start</b>
         Title   : min_start
         Usage   : $min_start = $location-&gt;min_start();
         Function: get the minimum starting point
         Returns : the minimum starting point from the contained sublocations
         Args    : none

   <b>max_start</b>
         Title   : max_start
         Usage   : my $maxstart = $location-&gt;max_start();
         Function: Get maximum starting location of feature startpoint
         Returns : integer or undef if no maximum starting point.
         Args    : none

   <b>start_pos_type</b>
         Title   : start_pos_type
         Usage   : my $start_pos_type = $location-&gt;start_pos_type();
         Function: Get start position type (ie &lt;,&gt;, ^)
         Returns : type of position coded as text
                   ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
         Args    : none

   <b>min_end</b>
         Title   : min_end
         Usage   : my $minend = $location-&gt;min_end();
         Function: Get minimum ending location of feature endpoint
         Returns : integer or undef if no minimum ending point.
         Args    : none

   <b>max_end</b>
         Title   : max_end
         Usage   : my $maxend = $location-&gt;max_end();
         Function: Get maximum ending location of feature endpoint
         Returns : integer or undef if no maximum ending point.
         Args    : none

   <b>end_pos_type</b>
         Title   : end_pos_type
         Usage   : my $end_pos_type = $location-&gt;end_pos_type();
         Function: Get end position type (ie &lt;,&gt;, ^)
         Returns : type of position coded as text
                   ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
         Args    : none

   <b>length</b>
        Title   : length
        Usage   : $len = $loc-&gt;length();
        Function: get the length in the coordinate space this location spans
        Example :
        Returns : an integer
        Args    : none

   <b>seq_id</b>
         Title   : seq_id
         Usage   : my $seqid = $location-&gt;seq_id();
         Function: Get/Set seq_id that location refers to

                   We override this here in order to propagate to all sublocations
                   which are not remote (provided this root is not remote either)
         Returns : seq_id
         Args    : [optional] seq_id value to set

   <b>coordinate_policy</b>
         Title   : coordinate_policy
         Usage   : $policy = $location-&gt;coordinate_policy();
                   $location-&gt;coordinate_policy($mypolicy); # set may not be possible
         Function: Get the coordinate computing policy employed by this object.

                   See Bio::Location::CoordinatePolicyI for documentation about
                   the policy object and its use.

                   The interface *does not* require implementing classes to accept
                   setting of a different policy. The implementation provided here
                   does, however, allow one to do so.

                   Implementors of this interface are expected to initialize every
                   new instance with a CoordinatePolicyI object. The implementation
                   provided here will return a default policy object if none has
                   been set yet. To change this default policy object call this
                   method as a class method with an appropriate argument. Note that
                   in this case only subsequently created Location objects will be
                   affected.

         Returns : A Bio::Location::CoordinatePolicyI implementing object.
         Args    : On set, a Bio::Location::CoordinatePolicyI implementing object.

   <b>to_FTstring</b>
         Title   : to_FTstring
         Usage   : my $locstr = $location-&gt;to_FTstring()
         Function: returns the FeatureTable string of this location
         Returns : string
         Args    : none

   <b>valid_Location</b>
        Title   : valid_Location
        Usage   : if ($location-&gt;valid_location) {...};
        Function: boolean method to determine whether location is considered valid
                  (has minimum requirements for Simple implementation)
        Returns : Boolean value: true if location is valid, false otherwise
        Args    : none

perl v5.32.1                                       2021-08-15                          <u>Bio::Location::<a href="../man3pm/Split.3pm.html">Split</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>