<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>struct::tree_v1 - Create and manipulate tree objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       struct::tree_v1 - Create and manipulate tree objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>struct::tree</b> <b>?1.2.3?</b>

       <b>treeName</b> <b>option</b> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <u>treeName</u> <b>append</b> <u>node</u> ?-key <u>key</u>? <u>value</u>

       <u>treeName</u> <b>children</b> <u>node</u>

       <u>treeName</u> <b>cut</b> <u>node</u>

       <u>treeName</u> <b>delete</b> <u>node</u> ?<u>node</u> ...?

       <u>treeName</u> <b>depth</b> <u>node</u>

       <u>treeName</u> <b>destroy</b>

       <u>treeName</u> <b>exists</b> <u>node</u>

       <u>treeName</u> <b>get</b> <u>node</u> ?<b>-key</b> <u>key</u>?

       <u>treeName</u> <b>getall</b> <u>node</u>

       <u>treeName</u> <b>keys</b> <u>node</u>

       <u>treeName</u> <b>keyexists</b> <u>node</u> ?-key <u>key</u>?

       <u>treeName</u> <b>index</b> <u>node</u>

       <u>treeName</u> <b>insert</b> <u>parent</u> <u>index</u> ?<u>child</u> ?<u>child</u> ...??

       <u>treeName</u> <b>isleaf</b> <u>node</u>

       <u>treeName</u> <b>lappend</b> <u>node</u> ?-key <u>key</u>? <u>value</u>

       <u>treeName</u> <b>move</b> <u>parent</u> <u>index</u> <u>node</u> ?<u>node</u> ...?

       <u>treeName</u> <b>next</b> <u>node</u>

       <u>treeName</u> <b>numchildren</b> <u>node</u>

       <u>treeName</u> <b>parent</b> <u>node</u>

       <u>treeName</u> <b>previous</b> <u>node</u>

       <u>treeName</u> <b>set</b> <u>node</u> ?<b>-key</b> <u>key</u>? ?<u>value</u>?

       <u>treeName</u> <b>size</b> ?<u>node</u>?

       <u>treeName</u> <b>splice</b> <u>parent</u> <u>from</u> ?<u>to</u>? ?<u>child</u>?

       <u>treeName</u> <b>swap</b> <u>node1</u> <u>node2</u>

       <u>treeName</u> <b>unset</b> <u>node</u> ?<b>-key</b> <u>key</u>?

       <u>treeName</u> <b>walk</b> <u>node</u> ?<b>-order</b> <u>order</u>? ?<b>-type</b> <u>type</u>? <b>-command</b> <u>cmd</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>::struct::tree</b> command creates a new tree object with an associated global Tcl command whose name is
       <u>treeName</u>. This command may be used to invoke various operations on the tree. It has the following general
       form:

       <b>treeName</b> <b>option</b> ?<u>arg</u> <u>arg</u> <u>...</u>?
              <u>Option</u> and the <u>arg</u>s determine the exact behavior of the command.

       A tree is a collection of named elements, called nodes, one of which is distinguished as  a  root,  along
       with  a  relation  ("parenthood") that places a hierarchical structure on the nodes. (Data Structures and
       Algorithms; Aho, Hopcroft and Ullman;  Addison-Wesley,  1987).   In  addition  to  maintaining  the  node
       relationships,  this  tree  implementation  allows  any number of keyed values to be associated with each
       node.

       The element names can be arbitrary strings.

       A tree is thus similar to an array, but with three important differences:

       [1]    Trees are accessed through an object command, whereas arrays  are  accessed  as  variables.  (This
              means trees cannot be local to a procedure.)

       [2]    Trees have a hierarchical structure, whereas an array is just an unordered collection.

       [3]    Each  node  of  a  tree  has a separate collection of attributes and values. This is like an array
              where every value is a dictionary.

       The following commands are possible for tree objects:

       <u>treeName</u> <b>append</b> <u>node</u> ?-key <u>key</u>? <u>value</u>
              Appends a <u>value</u> to one of the keyed values associated with an node. If no <u>key</u>  is  specified,  the
              key <b>data</b> is assumed.

       <u>treeName</u> <b>children</b> <u>node</u>
              Return a list of the children of <u>node</u>.

       <u>treeName</u> <b>cut</b> <u>node</u>
              Removes  the node specified by <u>node</u> from the tree, but not its children.  The children of <u>node</u> are
              made children of the parent of the <u>node</u>, at the index at which <u>node</u> was located.

       <u>treeName</u> <b>delete</b> <u>node</u> ?<u>node</u> ...?
              Removes the specified nodes from the tree.  All of the nodes' children will be removed as well  to
              prevent orphaned nodes.

       <u>treeName</u> <b>depth</b> <u>node</u>
              Return the number of steps from node <u>node</u> to the root node.

       <u>treeName</u> <b>destroy</b>
              Destroy the tree, including its storage space and associated command.

       <u>treeName</u> <b>exists</b> <u>node</u>
              Returns true if the specified node exists in the tree.

       <u>treeName</u> <b>get</b> <u>node</u> ?<b>-key</b> <u>key</u>?
              Return  the  value  associated with the key <u>key</u> for the node <u>node</u>. If no key is specified, the key
              <b>data</b> is assumed.

       <u>treeName</u> <b>getall</b> <u>node</u>
              Returns a serialized list of key/value pairs (suitable for use with [<b>array</b> <b>set</b>]) for the <u>node</u>.

       <u>treeName</u> <b>keys</b> <u>node</u>
              Returns a list of keys for the <u>node</u>.

       <u>treeName</u> <b>keyexists</b> <u>node</u> ?-key <u>key</u>?
              Return true if the specified <u>key</u> exists for the <u>node</u>. If no <u>key</u> is  specified,  the  key  <b>data</b>  is
              assumed.

       <u>treeName</u> <b>index</b> <u>node</u>
              Returns  the  index of <u>node</u> in its parent's list of children.  For example, if a node has <u>nodeFoo</u>,
              <u>nodeBar</u>, and <u>nodeBaz</u> as children, in that order, the index of <u>nodeBar</u> is 1.

       <u>treeName</u> <b>insert</b> <u>parent</u> <u>index</u> ?<u>child</u> ?<u>child</u> ...??
              Insert one or more nodes into the tree as children of the node <u>parent</u>. The nodes will be added  in
              the order they are given. If <u>parent</u> is <b>root</b>, it refers to the root of the tree. The new nodes will
              be  added  to  the  <u>parent</u>  node's child list at the index given by <u>index</u>. The <u>index</u> can be <b>end</b> in
              which case the new nodes will be added after the current last child.

              If any of the specified children already exist in <u>treeName</u>, those nodes will be moved  from  their
              original location to the new location indicated by this command.

              If  no  <u>child</u>  is specified, a single node will be added, and a name will be generated for the new
              node. The generated name is of the form <u>node</u><b>x</b>, where <b>x</b> is a number. If names  are  specified  they
              must neither contain whitespace nor colons (":").

              The return result from this command is a list of nodes added.

       <u>treeName</u> <b>isleaf</b> <u>node</u>
              Returns true if <u>node</u> is a leaf of the tree (if <u>node</u> has no children), false otherwise.

       <u>treeName</u> <b>lappend</b> <u>node</u> ?-key <u>key</u>? <u>value</u>
              Appends  a  <u>value</u>  (as  a  list)  to one of the keyed values associated with an <u>node</u>. If no <u>key</u> is
              specified, the key <b>data</b> is assumed.

       <u>treeName</u> <b>move</b> <u>parent</u> <u>index</u> <u>node</u> ?<u>node</u> ...?
              Make the specified nodes children of <u>parent</u>, inserting them into the parent's child  list  at  the
              index  given  by <u>index</u>. Note that the command will take all nodes out of the tree before inserting
              them under the new parent, and that it determines the  position  to  place  them  into  after  the
              removal,  before the re-insertion. This behaviour is important when it comes to moving one or more
              nodes to a different index without changing their parent node.

       <u>treeName</u> <b>next</b> <u>node</u>
              Return the right sibling of <u>node</u>, or the empty string if <u>node</u> was the last child of its parent.

       <u>treeName</u> <b>numchildren</b> <u>node</u>
              Return the number of immediate children of <u>node</u>.

       <u>treeName</u> <b>parent</b> <u>node</u>
              Return the parent of <u>node</u>.

       <u>treeName</u> <b>previous</b> <u>node</u>
              Return the left sibling of <u>node</u>, or the empty string if <u>node</u> was the first child of its parent.

       <u>treeName</u> <b>set</b> <u>node</u> ?<b>-key</b> <u>key</u>? ?<u>value</u>?
              Set or get one of the keyed values associated with a node. If no key is specified, the key <b>data</b> is
              assumed.  Each node that is  added  to  a  tree  has  the  value  ""  assigned  to  the  key  <b>data</b>
              automatically.   A  node  may have any number of keyed values associated with it.  If <u>value</u> is not
              specified, this command returns the current value assigned to the key; if <u>value</u> is specified, this
              command assigns that value to the key.

       <u>treeName</u> <b>size</b> ?<u>node</u>?
              Return a count of the number of descendants of the node <u>node</u>; if no node  is  specified,  <b>root</b>  is
              assumed.

       <u>treeName</u> <b>splice</b> <u>parent</u> <u>from</u> ?<u>to</u>? ?<u>child</u>?
              Insert  a  node  named  <u>child</u>  into  the tree as a child of the node <u>parent</u>. If <u>parent</u> is <b>root</b>, it
              refers to the root of the tree. The new node will be added to the parent node's child list at  the
              index given by <u>from</u>.  The children of <u>parent</u> which are in the range of the indices <u>from</u> and <u>to</u> are
              made  children  of  <u>child</u>.  If the value of <u>to</u> is not specified it defaults to <b>end</b>.  If no name is
              given for <u>child</u>, a name will be generated for the new node.  The generated name  is  of  the  form
              <u>node</u><b>x</b>, where <b>x</b> is a number.  The return result from this command is the name of the new node.

       <u>treeName</u> <b>swap</b> <u>node1</u> <u>node2</u>
              Swap the position of <u>node1</u> and <u>node2</u> in the tree.

       <u>treeName</u> <b>unset</b> <u>node</u> ?<b>-key</b> <u>key</u>?
              Removes a keyed value from the node <u>node</u>.  If no key is specified, the key <b>data</b> is assumed.

       <u>treeName</u> <b>walk</b> <u>node</u> ?<b>-order</b> <u>order</u>? ?<b>-type</b> <u>type</u>? <b>-command</b> <u>cmd</u>
              Perform  a  breadth-first  or depth-first walk of the tree starting at the node <u>node</u>.  The type of
              walk, breadth-first or depth-first, is determined by the value of  <u>type</u>;  <b>bfs</b>  indicates  breadth-
              first, <b>dfs</b> indicates depth-first.  Depth-first is the default. The order of the walk, pre-, post-,
              both-  or  in-order  is  determined by the value of <u>order</u>; <b>pre</b> indicates pre-order, <b>post</b> indicates
              post-order, <b>both</b> indicates both-order and <b>in</b> indicates in-order. Pre-order is the default.

              Pre-order walking means that a parent node is visited before any of its children.  For example,  a
              breadth-first  search  starting  from  the root will visit the root, followed by all of the root's
              children, followed by all of the root's grandchildren. Post-order walking means that a parent node
              is visited after any of its children. Both-order walking means  that  a  parent  node  is  visited
              before  <u>and</u>  after any of its children. In-order walking means that a parent node is visited after
              its first child and before the second. This is a generalization of  in-order  walking  for  binary
              trees  and  will do the right thing if a binary is walked. The combination of a breadth-first walk
              with in-order is illegal.

              As the walk progresses, the command <u>cmd</u> will be evaluated at each node.  Percent substitution will
              be performed on <u>cmd</u> before evaluation, just as in a <b>bind</b> script.  The following substitutions  are
              recognized:

              <b>%%</b>     Insert the literal % character.

              <b>%t</b>     Name of the tree object.

              <b>%n</b>     Name of the current node.

              <b>%a</b>     Name  of  the  action occurring; one of <b>enter</b>, <b>leave</b>, or <b>visit</b>.  <b>enter</b> actions occur during
                     pre-order walks; <b>leave</b> actions occur during post-order walks; <b>visit</b>  actions  occur  during
                     in-order  walks.   In a both-order walk, the command will be evaluated twice for each node;
                     the action is <b>enter</b> for the first evaluation, and <b>leave</b> for the second.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report such in the category <u>struct</u> <u>::</u> <u>tree</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       tree

</pre><h4><b>CATEGORY</b></h4><pre>
       Data structures

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2002 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                1.2.3                                <u>struct::<a href="../man3tcl/tree_v1.3tcl.html">tree_v1</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>