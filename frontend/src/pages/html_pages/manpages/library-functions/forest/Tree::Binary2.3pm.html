<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree::Binary2 - An implementation of a binary tree</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtree-perl">libtree-perl_1.10-0ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tree::Binary2 - An implementation of a binary tree

</pre><h4><b>SYNOPSIS</b></h4><pre>
         my $tree = Tree::Binary2-&gt;new( 'root' );

         my $left = Tree::Binary2-&gt;new( 'left' );
         $tree-&gt;left( $left );

         my $right = Tree::Binary2-&gt;new( 'left' );
         $tree-&gt;right( $right );

         my $right_child = $tree-&gt;right;

         $tree-&gt;right( undef ); # Unset the right child.

         my @nodes = $tree-&gt;traverse( $tree-&gt;POST_ORDER );

         my $traversal = $tree-&gt;traverse( $tree-&gt;IN_ORDER );
         while ( my $node = $traversal-&gt;() ) {
             # Do something with $node here
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is an implementation of a binary tree. This class inherits from Tree, which is an N-ary tree
       implemenation. Because of this, this class actually provides an implementation of a complete binary tree
       vs. a sparse binary tree.  The empty nodes are instances of Tree::Null, which is described in Tree.  This
       should have no effect on your usage of this class.

</pre><h4><b>METHODS</b></h4><pre>
       In addition to the methods provided by Tree, the following items are provided or overriden.

       •   left([$child]) / right([$child])

           These  access  the  left  and right children, respectively. They are mutators, which means that their
           behavior changes depending on if you pass in a value.

           If you do not pass in any parameters, then it will act as a getter for the specific child, return the
           child (if set) or undef (if not).

           If you pass in a child, it will act as a setter for the specific child,  setting  the  child  to  the
           passed-in value and returning the $tree. (Thus, this method chains.)

           If you wish to unset the child, do "$tree&gt;left( undef );"

       •   children()

           This will return the children of the tree.

           <b>NOTE:</b> There will be two children, always. Tree::Binary2 implements a complete binary tree, filling in
           missing   children  with  Tree::Null  objects.   (Please  see  Tree::Fast  for  more  information  on
           Tree::Null.)

       •   <b>traverse(</b> <b>[$order]</b> <b>)</b>

           When called in list context ("my @traversal = $tree-&gt;traverse()"), this will return  a  list  of  the
           nodes   in   the   given   traversal   order.  When  called  in  scalar  context  ("my  $traversal  =
           $tree-&gt;traverse()"), this will return a closure that will, over successive calls,  iterate  over  the
           nodes in the given traversal order. When finished it will return false.

           The default traversal order is pre-order.

           In addition to the traversal orders provided by Tree, Tree::Binary2 provides in-order traversals.

           •   In-order

               This  will  return  the result of an in-order traversal on the left node (if any), then the node,
               then the result of an in-order traversal on the right node (if any).

       <b>NOTE:</b> You have access to all the methods provided by Tree, but it is not recommended that you use many of
       them, unless you know what you're doing. This list includes add_child() and remove_child().

</pre><h4><b>TODO</b></h4><pre>
       •   Make in-order closure traversal work iteratively

       •   Make post-order closure traversal work iteratively

</pre><h4><b>CODE</b> <b>COVERAGE</b></h4><pre>
       Please see the relevant sections of Tree.

</pre><h4><b>SUPPORT</b></h4><pre>
       Please see the relevant sections of Tree.

</pre><h4><b>AUTHORS</b></h4><pre>
       Rob Kinyon &lt;<a href="mailto:rob.kinyon@iinteractive.com">rob.kinyon@iinteractive.com</a>&gt;

       Stevan Little &lt;<a href="mailto:stevan.little@iinteractive.com">stevan.little@iinteractive.com</a>&gt;

       Thanks to Infinity Interactive for generously donating our time.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2004, 2005 by Infinity Interactive, Inc.

       &lt;<a href="http://www.iinteractive.com">http://www.iinteractive.com</a>&gt;

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.38.2                                       2024-02-17                                 <u>Tree::<a href="../man3pm/Binary2.3pm.html">Binary2</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>