<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forest::Tree::Pure - An n-ary tree</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libforest-perl">libforest-perl_0.10-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Forest::Tree::Pure - An n-ary tree

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Forest::Tree;

         my $t = Forest::Tree::Pure-&gt;new(
             node     =&gt; 1,
             children =&gt; [
                 Forest::Tree::Pure-&gt;new(
                     node     =&gt; 1.1,
                     children =&gt; [
                         Forest::Tree::Pure-&gt;new(node =&gt; 1.1.1),
                         Forest::Tree::Pure-&gt;new(node =&gt; 1.1.2),
                         Forest::Tree::Pure-&gt;new(node =&gt; 1.1.3),
                     ]
                 ),
                 Forest::Tree::Pure-&gt;new(node =&gt; 1.2),
                 Forest::Tree::Pure-&gt;new(
                     node     =&gt; 1.3,
                     children =&gt; [
                         Forest::Tree::Pure-&gt;new(node =&gt; 1.3.1),
                         Forest::Tree::Pure-&gt;new(node =&gt; 1.3.2),
                     ]
                 ),
             ]
         );

         $t-&gt;traverse(sub {
             my $t = shift;
             print(('    ' x $t-&gt;depth) . ($t-&gt;node || '\undef') . "\n");
         });

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is a base class for Forest::Tree providing functionality for immutable trees.

       It can be used independently for trees that require sharing of children between parents.

       There is no single authoritative parent (no upward links at all), and changing of data is not supported.

       This class is appropriate when many tree roots share the same children (e.g. in a versioned tree).

       This class is strictly a DAG, wheras Forest::Tree produces a graph with back references

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       <u>node</u>
       <u>children</u>
           <b>get_child_at</b> <b>($index)</b>
               Return the child at this position. (zero-base index)

           <b>child_count</b>
               Returns the number of children this tree has

       <u>size</u>
           <b>size</b>
           <b>has_size</b>
       <u>height</u>
           <b>height</b>
           <b>has_height</b>

</pre><h4><b>METHODS</b></h4><pre>
       <b>is_leaf</b>
           True if the current tree has no children

       <b>traverse</b> <b>(\&amp;func)</b>
           Takes  a  reference  to  a  subroutine  and  traverses  the  tree  applying  this subroutine to every
           descendant. (But not the root)

       <b>visit</b> <b>(&amp;func)</b>
           Traverse the entire tree, including the root.

       <b>fmap_cont</b> <b>(&amp;func)</b>
           A CPS form of "visit" that lets you control when and how data flows from the children.

           It takes a callback in the form:

               sub {
                   my ( $tree, $cont, @args ) = @_;

                   ...
               }

           and $cont is a code ref that when invoked will apply that same function to the children of $tree.

           This allows you to do things like computing the sum of all the node values in a tree, for instance:

               use List::Util qw(sum);

               my $sum = $tree-&gt;fmap_cont(sub {
                   my ( $tree, $cont ) = @_;

                   return sum( $tree-&gt;node, $cont-&gt;() );
               });

           And also allows one to stop traversal at a given point.

       <b>add_children</b> <b>(@children)</b>
       <b>add_child</b> <b>($child)</b>
           Create a new tree node with the children appended.

           The children must inherit "Forest::Tree::Pure"

           Note that this method does <b>not</b> mutate the tree, instead  it  clones  and  returns  a  tree  with  the
           augmented list of children.

       <b>insert_child_at</b> <b>($index,</b> <b>$child)</b>
           Insert a child at this position. (zero-base index)

           Returns a derived tree with overridden children.

       <b>set_child_at</b> <b>($index,</b> <b>$child)</b>
           Replaces the child at $index with $child.

       <b>remove_child_at</b> <b>($index)</b>
           Remove the child at this position. (zero-base index)

           Returns a derived tree with overridden children.

       <b>locate</b> <b>(@path)</b>
           Find a child using a path of child indexes. These two examples return the same object:

               $tree-&gt;<a href="../man0/get_child_at.0.html">get_child_at</a>(0)-&gt;<a href="../man1/get_child_at.1.html">get_child_at</a>(1)-&gt;<a href="../man0/get_child_at.0.html">get_child_at</a>(0);

               $tree-&gt;locate(0, 1, 0);

       <b>descend</b> <b>(@path)</b>
           Like "lookup" except that it returns every object in the path, not just the leaf.

       "transform (\@path, $method, @args)"
           Performs a lookup on @path, applies the method $method with @args to the located node, and clones the
           path to the parent returning a derived tree.

           This  method  is  also  implemented  in  Forest::Tree by mutating the tree in place and returning the
           original tree, so the same transformations should work on both pure trees and mutable ones.

           This code:

               my $new = $root-&gt;transform([ 1, 3 ], insert_child_at =&gt; 3, $new_child);

           will locate the child at the path "[ 1, 3 ]", call "insert_child_at" on it, creating a new version of
           "[ 1, 3 ]", and then return a cloned version of "[ 1 ]" and the root node recursively, such that $new
           appears to be a mutated $root.

       set_node $new
           Returns a clone of the tree node with the node value changed.

       "replace $arg"
           Returns the argument. This is useful when used with "transform".

       <b>clone</b>
           Provided by MooseX::Clone.

           Deeply clones the entire tree.

           Subclasses should use MooseX::Clone traits to specify the correct  cloning  behavior  for  additional
           attributes if cloning is used.

       <b>reconstruct_with_class</b> <b>$class</b>
           Recursively recreates the tree by passing constructor arguments to $class.

           Does not use "clone".

       <b>to_mutable_tree</b>
           Invokes "reconstruct_with_class" with Forest::Tree as the argument.

       <b>to_pure_tree</b>
           Returns the invocant.

       <b>get_child_index</b> <b>($child)</b>
           Returns the index of $child in "children" or undef if it isn't a child of the current tree.

</pre><h4><b>BUGS</b></h4><pre>
       All  complex  software  has bugs lurking in it, and this module is no exception. If you find a bug please
       either email me, or add the bug to cpan-RT.

</pre><h4><b>AUTHOR</b></h4><pre>
       Yuval Kogman

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2008-2014 Infinity Interactive, Inc.

       &lt;<a href="http://www.iinteractive.com">http://www.iinteractive.com</a>&gt;

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.34.0                                       2022-06-14                            <u>Forest::Tree::<a href="../man3pm/Pure.3pm.html">Pure</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>