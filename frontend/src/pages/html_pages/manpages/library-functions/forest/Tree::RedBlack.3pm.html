<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree::RedBlack - Perl implementation of Red/Black tree, a type of balanced tree.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtree-redblack-perl">libtree-redblack-perl_0.5-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tree::RedBlack - Perl implementation of Red/Black tree, a type of balanced tree.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Tree::RedBlack;

         my $t = new Tree::RedBlack;
         $t-&gt;insert(3, 'cat');
         $t-&gt;insert(4, 'dog');
         my $v = $t-&gt;<a href="../man4/find.4.html">find</a>(4);
         my $min = $t-&gt;min;
         my $max = $t-&gt;max;
         $t-&gt;<a href="../man3/delete.3.html">delete</a>(3);
         $t-&gt;print;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a perl implementation of the Red/Black tree algorithm found in the book "Algorithms", by Cormen,
       Leiserson &amp; Rivest (more commonly known as "CLR" or "The White Book").  A Red/Black tree is a binary tree
       which remains "balanced"- that is, the longest length from root to a node is at most one more than the
       shortest such length.  It is fairly efficient; no operation takes more than O(lg(n)) time.

       A Tree::RedBlack object supports the following methods:

       new ()
           Creates a new RedBlack tree object.

       root ()
           Returns  the  root node of the tree.  Note that this will either be undef if no nodes have been added
           to the tree, or a Tree::RedBlack::Node object.  See the Tree::RedBlack::Node manual page for  details
           on the Node object.

       cmp (&amp;)
           Use  this  method  to  set  a comparator subroutine.  The tree defaults to lexical comparisons.  This
           subroutine should be just like a comparator subroutine to sort, except that it doesn't do the $a,  $b
           trick; the two elements to compare will just be the first two items on the stack.

       insert ($;$)
           Adds a new node to the tree.  The first argument is the key of the node, the second is its value.  If
           a  node with that key already exists, its value is replaced with the given value and the old value is
           returned.  Otherwise, undef is returned.

       delete ($)
           The argument should be either a node object to delete  or  the  key  of  a  node  object  to  delete.
           WARNING!!! THIS STILL HAS BUGS!!!

       find ($)
           Searches the tree to find the node with the given key.  Returns the value of that node, or undef if a
           node  with  that  key  isn't  found.  Note, in particular, that you can't tell the difference between
           finding a node with value undef and not finding a node at all.  If you want to determine  if  a  node
           with a given key exists, use the node method, below.

       node ($)
           Searches  the  tree  to  find  the node with the given key.  Returns that node object if it is found,
           undef otherwise.  The node object is a Tree::RedBlack::Node object.

       min ()
           Returns the node with the minimal key.

       max ()
           Returns the node with the maximal key.

</pre><h4><b>AUTHOR</b></h4><pre>
       Benjamin Holzman &lt;<a href="mailto:bholzman@earthlink.net">bholzman@earthlink.net</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Tree::RedBlack::Node

perl v5.36.0                                       2022-10-22                                      <u><a href="../man3pm/RedBlack.3pm.html">RedBlack</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>