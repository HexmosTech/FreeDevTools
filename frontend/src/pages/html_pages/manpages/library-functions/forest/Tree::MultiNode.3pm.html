<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree::MultiNode -- a multi-node tree object.  Most useful for modeling hierarchical data structures.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtree-multinode-perl">libtree-multinode-perl_1.0.14-0.2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tree::MultiNode -- a multi-node tree object.  Most useful for modeling hierarchical data structures.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Tree::MultiNode;
         use strict;
         use warnings;
         my $tree   = new Tree::MultiNode;
         my $handle = new Tree::MultiNode::Handle($tree);

         $handle-&gt;set_key("top");
         $handle-&gt;set_value("level");

         $handle-&gt;add_child("child","1");
         $handle-&gt;add_child("child","2");

         $handle-&gt;first();
         $handle-&gt;down();

         $handle-&gt;add_child("grandchild","1-1");
         $handle-&gt;up();

         $handle-&gt;last();
         $handle-&gt;down();

         $handle-&gt;add_child("grandchild","2-1");
         $handle-&gt;up();

         $handle-&gt;top();
         &amp;dump_tree($handle);

         my $depth = 0;
         sub dump_tree
         {
           ++$depth;
           my $handle = shift;
           my $lead = ' ' x ($depth*2);
           my($key,$val);

           ($key,$val) = $handle-&gt;get_data();

           print $lead, "key:   $key\n";
           print $lead, "val:   $val\n";
           print $lead, "depth: $depth\n";

           my $i;
           for( $i = 0; $i &lt; scalar($handle-&gt;children); ++$i ) {
             $handle-&gt;down($i);
               &amp;dump_tree($handle);
             $handle-&gt;up();
           }
           --$depth;
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Tree::MultiNode, Tree::MultiNode::Node, and MultiNode::Handle are objects modeled after C++ classes that
       I had written to help me model hierarchical information as data structures (such as the relationships
       between records in an RDBMS).  The tree is basically a list of lists type data structure, where each node
       has a key, a value, and a list of children.  The tree has no internal sorting, though all operations
       preserve the order of the child nodes.

   <b>Creating</b> <b>a</b> <b>Tree</b>
       The concept of creating a handle based on a tree lets you have multiple handles into a single tree
       without having to copy the tree.  You have to use a handle for all operations on the tree (other than
       construction).

       When you first construct a tree, it will have a single empty node.  When you construct a handle into that
       tree, it will set the top node in the tree as it's current node.

         my $tree   = new Tree::MultiNode;
         my $handle = new Tree::MultiNode::Handle($tree);

   <b>Using</b> <b>a</b> <b>Handle</b> <b>to</b> <b>Manipulate</b> <b>the</b> <b>Tree</b>
       At this point, you can set the key/value in the top node, or start adding child nodes.

         $handle-&gt;set_key("blah");
         $handle-&gt;set_value("foo");

         $handle-&gt;add_child("quz","baz");
         # or
         $handle-&gt;add_child();

       add_child can take 3 parameters -- a key, a value, and a position.  The key and value will set the
       key/value of the child on construction.  If pos is passed, the new child will be inserted into the list
       of children.

       To move the handle so it points at a child (so you can start manipulating that child), there are a series
       of methods to call:

         $handle-&gt;first();   # sets the current child to the first in the list
         $handle-&gt;next();    # sets the next, or first if there was no next
         $handle-&gt;prev();    # sets the previous, or last if there was no next
         $handle-&gt;last();    # sets to the last child
         $handle-&gt;down();    # positions the handle's current node to the
                             # current child

       To move back up, you can call the method up:

         $handle-&gt;up();      # moves to this node's parent

       <b>up()</b> will fail if the current node has no parent node.  Most of the member functions return either undef
       to indicate failure, or some other value to indicate success.

   <b>$Tree::MultiNode::debug</b>
       If set to a true value, it enables debugging output in the code.  This will likely be removed in future
       versions as the code becomes more stable.

</pre><h4><b>API</b> <b>REFERENCE</b></h4><pre>
   <b>Tree::MultiNode</b>
       The tree object.

   <b>Tree::MultiNode::new</b>
         @param    package name or tree object [scalar]
         @returns  new tree object

       Creates a new Tree.  The tree will have a single top level node when created.  The first node will have
       no value (undef) in either it's key or it's value.

         my $tree = new Tree::MultiNode;

   <b>Tree::MultiNode::Node</b>
       Please note that the Node object is used internally by the MultiNode object.  Though you have the ability
       to interact with the nodes, it is unlikely that you should need to.  That being said, the interface is
       documented here anyway.

   <b>Tree::MultiNode::Node::new</b>
         new($)
           @param    package name or node object to clone [scalar]
           @returns  new node object

         new($$)
           @param    key   [scalar]
           @param    value [scalar]
           @returns  new node object

       Creates a new Node.  There are three behaviors for new.  A constructor with no arguments creates a new,
       empty node.  A single argument of another node object will create a clone of the node object.  If two
       arguments are passed, the first is stored as the key, and the second is stored as the value.

         # clone an existing node
         my $node = new Tree::MultiNode::Node($oldNode);
         # or
         my $node = $oldNode-&gt;new();

         # create a new node
         my $node = new Tree::MultiNode::Node;
         my $node = new Tree::MultiNode::Node("fname");
         my $node = new Tree::MultiNode::Node("fname","Larry");

   <b>Tree::MultiNode::Node::key</b>
         @param     key [scalar]
         @returns   the key [scalar]

       Used to set, or retrieve the key for a node.  If a parameter is passed, it sets the key for the node.
       The value of the key member is always returned.

         print $node3-&gt;key(), "\n";    # 'fname'

   <b>Tree::MultiNode::Node::value</b>
         @param    the value to set [scalar]
         @returns  the value [scalar]

       Used to set, or retrieve the value for a node.  If a parameter is passed, it sets the value for the node.
       The value of the value member is always returned.

         print $node3-&gt;value(), "\n";   # 'Larry'

   <b>Tree::MultiNode::Node::clear_key</b>
         @returns  the deleted key

       Clears the key member by deleting it.

         $node3-&gt;clear_key();

   <b>Tree::MultiNode::Node::clear_value</b>
         @returns  the deleted value

       Clears the value member by deleting it.

         $node3-&gt;clear_value();

   <b>Tree::MultiNode::Node::children</b>
         @returns  reference to children [array reference]

       Returns a reference to the array that contains the children of the node object.

         $array_ref = $node3-&gt;children();

   <b>Tree::MultiNode::Node::child_keys</b> <b>Tree::MultiNode::Node::child_values</b> <b>Tree::MultiNode::Node::child_kv_pairs</b>
       These functions return arrays consisting of the appropriate data from the child nodes.

         my @keys     = $handle-&gt;child_keys();
         my @vals     = $handle-&gt;child_values();
         my %kv_pairs = $handle-&gt;child_kv_pairs();

   <b>Tree::MultiNode::Node::child_key_positions</b>
       This function returns a hash table that consists of the child keys as the hash keys, and the position in
       the child array as the value.  This allows for a quick and dirty way of looking up the position of a
       given key in the child list.

         my %h = $node-&gt;child_key_positions();

   <b>Tree::MultiNode::Node::parent</b>
       Returns a reference to the parent node of the current node.

         $node_parent = $node3-&gt;parent();

   <b>Tree::MultiNode::Node::dump</b>
       Used for diagnostics, it prints out the members of the node.

         $node3-&gt;dump();

   <b>Tree::MultiNode::Handle</b>
       Handle is used as a 'pointer' into the tree.  It has a few attributes that it keeps track of.  These are:

         1. the top of the tree
         2. the current node
         3. the current child node
         4. the depth of the current node

       The top of the tree never changes, and you can reset the handle to point back at the top of the tree by
       calling the <b>top()</b> method.

       The current node is where the handle is 'pointing' in the tree.  The current node is changed with
       functions like <b>top()</b>, <b>down()</b>, and <b>up()</b>.

       The current child node is used for traversing downward into the tree.  The members <b>first()</b>, <b>next()</b>,
       <b>prev()</b>, <b>last()</b>, and <b>position()</b> can be used to set the current child, and then traverse down into it.

       The depth of the current node is a measure of the length of the path from the top of the tree to the
       current node, i.e., the top of the node has a depth of 0, each of its children has a depth of 1, etc.

   <b>Tree::MultiNode::Handle::New</b>
       Constructs a new handle.  You must pass a tree object to Handle::New.

         my $tree   = new Tree::MultiNode;
         my $handle = new Tree::MultiNode::Handle($tree);

   <b>Tree::MultiNode::Handle::tree</b>
       Returns the tree that was used to construct the node.  Useful if you're trying to create another node
       into the tree.

         my $handle2 = new Tree::MultiNode::Handle($handle-&gt;tree());

   <b>Tree::MultiNode::Handle::get_data</b>
       Retrieves both the key, and value (as an array) for the current node.

         my ($key,$val) = $handle-&gt;get_data();

   <b>Tree::MultiNode::Handle::get_key</b>
       Retrieves the key for the current node.

         $key = $handle-&gt;get_key();

   <b>Tree::MultiNode::Handle::set_key</b>
       Sets the key for the current node.

         $handle-&gt;set_key("lname");

   <b>Tree::MultiNode::Handle::get_value</b>
       Retrieves the value for the current node.

         $val = $handle-&gt;get_value();

   <b>Tree::MultiNode::Handle::set_value</b>
       Sets the value for the current node.

         $handle-&gt;set_value("Wall");

   <b>Tree::MultiNode::Handle::get_child</b>
       get_child takes an optional parameter which is the position of the child that is to be retrieved.  If
       this position is not specified, get_child attempts to return the current child.  get_child returns a Node
       object.

         my $child_node = $handle-&gt;get_child();

   <b>Tree::MultiNode::Handle::add_child</b>
       This member adds a new child node to the end of the array of children for the current node.  There are
       three optional parameters:

         - a key
         - a value
         - a position

       If passed, the key and value will be set in the new child.  If a position is passed, the new child will
       be inserted into the current array of children at the position specified.

         $handle-&gt;add_child();                    # adds a blank child
         $handle-&gt;add_child("language","perl");   # adds a child to the end
         $handle-&gt;add_child("language","C++",0);  # adds a child to the front

   <b>Tree::MultiNode::Handle::add_child_node</b>
       Recently added via RT # 5435 -- Currently in need of proper documentation and test patches

         I've patched Tree::MultiNode 1.0.10 to add a method I'm currently calling add_child_node().
         It works just like add_child() except it takes either a Tree::MultiNode::Node or a
         Tree::MultiNode object instead. I found this extremely useful when using recursion to populate
         a tree. It could also be used to subsume any tree into another tree, so this touches on the
         topic of the other bug item here asking for methods to copy/move trees/nodes.

   <b>Tree::MultiNode::Handle::depth</b>
       Gets the depth for the current node.

         my $depth = $handle-&gt;depth();

   <b>Tree::MultiNode::Handle::select</b>
       Sets the current child via a specified value -- basically it iterates through the array of children,
       looking for a match.  You have to supply the key to look for, and optionally a sub ref to find it.  The
       default for this sub is

         sub { return shift eq shift; }

       Which is sufficient for testing the equality of strings (the most common thing that I think will get
       stored in the tree).  If you're storing multiple data types as keys, you'll have to write a sub that
       figures out how to perform the comparisons in a sane manner.

       The code reference should take two arguments, and compare them -- return false if they don't match, and
       true if they do.

         $handle-&gt;select('lname', sub { return shift eq shift; } );

   <b>Tree::MultiNode::Handle::position</b>
       Sets, or retrieves the current child position.

         print "curr child pos is: ", $handle-&gt;position(), "\n";
         $handle-&gt;<a href="../man5/position.5.html">position</a>(5);    # sets the 6th child as the current child

   <b>Tree::MultiNode::Handle::first</b> <b>Tree::MultiNode::Handle::next</b> <b>Tree::MultiNode::Handle::prev</b>
       <b>Tree::MultiNode::Handle::last</b>
       These functions manipulate the current child member.  <b>first()</b> sets the first child as the current child,
       while <b>last()</b> sets the last.  <b>next()</b>, and <b>prev()</b> will move to the next/prev child respectively.  If there
       is no current child node, <b>next()</b> will have the same effect as <b>first()</b>, and <b>prev()</b> will operate as <b>last()</b>.
       <b>prev()</b> fails if the current child is the first child, and <b>next()</b> fails if the current child is the last
       child -- i.e., they do not wrap around.

       These functions will fail if there are no children for the current node.

         $handle-&gt;first();  # sets to the 0th child
         $handle-&gt;next();   # to the 1st child
         $handle-&gt;prev();   # back to the 0th child
         $handle-&gt;last();   # go straight to the last child.

   <b>Tree::MultiNode::Handle::down</b>
       <b>down()</b> moves the handle to point at the current child node.  It fails if there is no current child node.
       When <b>down()</b> is called, the current child becomes invalid (undef).

         $handle-&gt;down();

   <b>Tree::MultiNode::Handle::up</b>
       <b>down()</b> moves the handle to point at the parent of the current node.  It fails if there is no parent node.
       When <b>up()</b> is called, the current child becomes invalid (undef).

         $handle-&gt;up();

   <b>Tree::MultiNode::Handle::top</b>
       Resets the handle to point back at the top of the tree.  When <b>top()</b> is called, the current child becomes
       invalid (undef).

         $handle-&gt;top();

   <b>Tree::MultiNode::Handle::children</b>
       This returns an array of Node objects that represents the children of the current Node.  Unlike
       <b>Node::children()</b>, the array <b>Handle::children()</b> is not a reference to an array, but an array.  Useful if
       you need to iterate through the children of the current node.

         print "There are: ", scalar($handle-&gt;children()), " children\n";
         foreach $child ($handle-&gt;children()) {
           print $child-&gt;key(), " : ", $child-&gt;value(), "\n";
         }

   <b>Tree::MultiNode::Handle::child_key_positions</b>
       This function returns a hash table that consists of the child keys as the hash keys, and the position in
       the child array as the value.  This allows for a quick and dirty way of looking up the position of a
       given key in the child list.

         my %h = $handle-&gt;child_key_positions();

   <b>Tree::MultiNode::Handle::get_child_key</b>
       Returns the key at the specified position, or from the corresponding child node.

         my $key = $handle-&gt;get_child_key();

   <b>Tree::MultiNode::Handle::get_child_value</b>
       Returns the value at the specified position, or from the corresponding child node.

         my $value = $handle-&gt;get_child_value();

   <b>Tree::MultiNode::Handle::remove_child</b>
       Returns <b>Tree::MultiNode::Node::child_kv_paris()</b> for the current node for this handle.

         my %pairs = $handle-&gt;kv_pairs();

   <b>Tree::MultiNode::Handle::remove_child</b>
   <b>Tree::MultiNode::Handle::child_keys</b>
       Returns the keys from the current node's children.  Returns undef if there is no current node.

   <b>Tree::MultiNode::Handle::traverse</b>
         $handle-&gt;traverse(sub {
           my $h = pop;
           printf "%sk: %s v: %s\n",('  ' x $handle-&gt;depth()),$h-&gt;get_data();
         });

       Traverse takes a subroutine reference, and will visit each node of the tree, starting with the node the
       handle currently points to, recursively down from the current position of the handle.  Each time the
       subroutine is called, it will be passed a handle which points to the node to be visited.  Any additional
       arguments after the sub ref will be passed to the traverse function _before_ the handle is passed.  This
       should allow you to pass constant arguments to the sub ref.

       Modifying the node that the handle points to will cause traverse to work from the new node forward.

   <b>Tree::MultiNode::Handle::traverse</b> <b>or</b> <b>to</b> <b>have</b> <b>the</b> <b>subref</b> <b>to</b> <b>be</b> <b>a</b> <b>method</b> <b>on</b> <b>an</b> <b>object</b> <b>(and</b> <b>still</b> <b>pass</b> <b>the</b>
       <b>object's</b> <b>'self'</b> <b>to</b> <b>the</b> <b>method).</b>
         $handle-&gt;traverse( \&amp;Some::Object::method, $obj, $const1, \%const2 );

         ...
         sub method
         {
           my $handle = pop;
           my $self   = shift;
           my $const1 = shift;
           my $const2 = shift;
           # do something
         }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Algorithms in C++
          Robert Sedgwick
          Addison Wesley 1992
          ISBN 0201510596

       The Art of Computer Programming, Volume 1: Fundamental Algorithms,
          third edition, Donald E. Knuth

</pre><h4><b>AUTHORS</b></h4><pre>
       Kyle R. Burton &lt;<a href="mailto:mortis@voicenet.com">mortis@voicenet.com</a>&gt; (initial version, and maintenence)

       Daniel X. Pape &lt;<a href="mailto:dpape@canis.uiuc.edu">dpape@canis.uiuc.edu</a>&gt; (see Changes file from the source archive)

       Eric Joanis &lt;<a href="mailto:joanis@cs.toronto.edu">joanis@cs.toronto.edu</a>&gt;

       Todd Rinaldo &lt;<a href="mailto:toddr@cpan.org">toddr@cpan.org</a>&gt;

</pre><h4><b>BUGS</b></h4><pre>
       - There is currently no way to remove a child node.

perl v5.40.1                                       2025-02-26                               <u>Tree::<a href="../man3pm/MultiNode.3pm.html">MultiNode</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>