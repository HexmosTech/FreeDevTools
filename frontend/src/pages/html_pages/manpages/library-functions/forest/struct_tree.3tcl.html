<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>struct::tree - Create and manipulate tree objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       struct::tree - Create and manipulate tree objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>struct::tree</b> <b>?2.1.1?</b>

       package require <b>struct::list</b> <b>?1.5?</b>

       <b>::struct::tree</b> ?<u>treeName</u>? ?<b>=</b>|<b>:=</b>|<b>as</b>|<b>deserialize</b> <u>source</u>?

       <b>treeName</b> <b>option</b> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <b>::struct::tree::prune</b>

       <u>treeName</u> <b>=</b> <u>sourcetree</u>

       <u>treeName</u> <b>--&gt;</b> <u>desttree</u>

       <u>treeName</u> <b>ancestors</b> <u>node</u>

       <u>treeName</u> <b>append</b> <u>node</u> <u>key</u> <u>value</u>

       <u>treeName</u> <b>attr</b> <u>key</u>

       <u>treeName</u> <b>attr</b> <u>key</u> <b>-nodes</b> <u>list</u>

       <u>treeName</u> <b>attr</b> <u>key</u> <b>-glob</b> <u>globpattern</u>

       <u>treeName</u> <b>attr</b> <u>key</u> <b>-regexp</b> <u>repattern</u>

       <u>treeName</u> <b>children</b> ?<b>-all</b>? <u>node</u> ?<b>filter</b> <u>cmdprefix</u>?

       <u>treeName</u> <b>cut</b> <u>node</u>

       <u>treeName</u> <b>delete</b> <u>node</u> ?<u>node</u> ...?

       <u>treeName</u> <b>depth</b> <u>node</u>

       <u>treeName</u> <b>descendants</b> <u>node</u> ?<b>filter</b> <u>cmdprefix</u>?

       <u>treeName</u> <b>deserialize</b> <u>serialization</u>

       <u>treeName</u> <b>destroy</b>

       <u>treeName</u> <b>exists</b> <u>node</u>

       <u>treeName</u> <b>get</b> <u>node</u> <u>key</u>

       <u>treeName</u> <b>getall</b> <u>node</u> ?<u>pattern</u>?

       <u>treeName</u> <b>keys</b> <u>node</u> ?<u>pattern</u>?

       <u>treeName</u> <b>keyexists</b> <u>node</u> <u>key</u>

       <u>treeName</u> <b>index</b> <u>node</u>

       <u>treeName</u> <b>insert</b> <u>parent</u> <u>index</u> ?<u>child</u> ?<u>child</u> ...??

       <u>treeName</u> <b>isleaf</b> <u>node</u>

       <u>treeName</u> <b>lappend</b> <u>node</u> <u>key</u> <u>value</u>

       <u>treeName</u> <b>leaves</b>

       <u>treeName</u> <b>move</b> <u>parent</u> <u>index</u> <u>node</u> ?<u>node</u> ...?

       <u>treeName</u> <b>next</b> <u>node</u>

       <u>treeName</u> <b>numchildren</b> <u>node</u>

       <u>treeName</u> <b>nodes</b>

       <u>treeName</u> <b>parent</b> <u>node</u>

       <u>treeName</u> <b>previous</b> <u>node</u>

       <u>treeName</u> <b>rename</b> <u>node</u> <u>newname</u>

       <u>treeName</u> <b>rootname</b>

       <u>treeName</u> <b>serialize</b> ?<u>node</u>?

       <u>treeName</u> <b>set</b> <u>node</u> <u>key</u> ?<u>value</u>?

       <u>treeName</u> <b>size</b> ?<u>node</u>?

       <u>treeName</u> <b>splice</b> <u>parent</u> <u>from</u> ?<u>to</u>? ?<u>child</u>?

       <u>treeName</u> <b>swap</b> <u>node1</u> <u>node2</u>

       <u>treeName</u> <b>unset</b> <u>node</u> <u>key</u>

       <u>treeName</u> <b>walk</b> <u>node</u> ?<b>-order</b> <u>order</u>? ?<b>-type</b> <u>type</u>? <u>loopvar</u> <u>script</u>

       <u>treeName</u> <b>walkproc</b> <u>node</u> ?<b>-order</b> <u>order</u>? ?<b>-type</b> <u>type</u>? <u>cmdprefix</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A  tree  is  a collection of named elements, called nodes, one of which is distinguished as a root, along
       with a relation ("parenthood") that places a hierarchical structure on the nodes.  (Data  Structures  and
       Algorithms;  Aho,  Hopcroft  and  Ullman;  Addison-Wesley,  1987).   In  addition to maintaining the node
       relationships, this tree implementation allows any number of keyed values  to  be  associated  with  each
       node.

       The element names can be arbitrary strings.

       A tree is thus similar to an array, but with three important differences:

       [1]    Trees  are  accessed  through  an  object command, whereas arrays are accessed as variables. (This
              means trees cannot be local to a procedure.)

       [2]    Trees have a hierarchical structure, whereas an array is just an unordered collection.

       [3]    Each node of a tree has a separate collection of attributes and values.  This  is  like  an  array
              where every value is a dictionary.

       <u>Note:</u>  The  major  version  of  the  package  <b>struct</b>  has  been  changed  to version 2.0, due to backward
       incompatible changes in the API of this module. Please read the section <b>Changes</b> <b>for</b> <b>2.0</b> for a  full  list
       of all changes, incompatible and otherwise.

</pre><h4><b>API</b></h4><pre>
   <b>TREE</b> <b>CLASS</b> <b>API</b>
       The main commands of the package are:

       <b>::struct::tree</b> ?<u>treeName</u>? ?<b>=</b>|<b>:=</b>|<b>as</b>|<b>deserialize</b> <u>source</u>?
              The  command  creates  a  new  tree  object  with  an  associated global Tcl command whose name is
              <u>treeName</u>. This command may be used to invoke various operations on the tree.  It has the following
              general form:

              <b>treeName</b> <b>option</b> ?<u>arg</u> <u>arg</u> <u>...</u>?
                     <u>Option</u> and the <u>arg</u>s determine the exact behavior of the command.

       If <u>treeName</u> is not specified a unique name will be generated by  the  package  itself.  If  a  <u>source</u>  is
       specified  the  new tree will be initialized to it. For the operators <b>=</b>, <b>:=</b>, and <b>as</b> <u>source</u> is interpreted
       as the name of another tree object, and the assignment operator <b>=</b> will be executed. For  <b>deserialize</b>  the
       <u>source</u> is a serialized tree object and <b>deserialize</b> will be executed.

       In other words

                  ::struct::tree mytree = b

       is equivalent to

                  ::struct::tree mytree
                  mytree = b

       and

                  ::struct::tree mytree deserialize $b

       is equivalent to

                  ::struct::tree mytree
                  mytree deserialize $b

       <b>::struct::tree::prune</b>
              This  command  is  provided  outside  of  the  tree methods, as it is not a tree method per se. It
              however interacts tightly with the method <b>walk</b>. When  used  in  the  walk  script  it  causes  the
              traversal  to  ignore  the  children of the node we are currently at.  This command cannot be used
              with the traversal modes which look at children before their parent, i.e. <b>post</b> and  <b>in</b>.  The  only
              applicable  orders  of  traversal  are  <b>pre</b> and <b>both</b>. An error is thrown if the command and chosen
              order of traversal do not fit.

   <b>TREE</b> <b>OBJECT</b> <b>API</b>
       Two general observations beforehand:

       [1]    The root node of the tree can be used in most places where a node is asked for. The  default  name
              of  the  rootnode  is "root", but this can be changed with the method <b>rename</b> (see below). Whatever
              the current name for the root node of the tree is, it can  be  retrieved  by  calling  the  method
              <b>rootname</b>.

       [2]    The  method  <b>insert</b>  is  the  only  way to create new nodes, and they are automatically added to a
              parent. A tree object cannot have nodes without a parent, save the root node.

       And now the methods supported by tree objects created by this package:

       <u>treeName</u> <b>=</b> <u>sourcetree</u>
              This is the assignment operator for tree objects. It copies the tree contained in the tree  object
              <u>sourcetree</u>  over  the  tree  data  in  <u>treeName</u>.  The old contents of <u>treeName</u> are deleted by this
              operation.

              This operation is in effect equivalent to

                  <u>treeName</u> <b>deserialize</b> [<u>sourcetree</u> <b>serialize</b>]

       <u>treeName</u> <b>--&gt;</b> <u>desttree</u>
              This is the reverse assignment operator for tree objects. It copies the tree contained in the tree
              object <u>treeName</u> over the tree data in the object  <u>desttree</u>.  The  old  contents  of  <u>desttree</u>  are
              deleted by this operation.

              This operation is in effect equivalent to

                  <u>desttree</u> <b>deserialize</b> [<u>treeName</u> <b>serialize</b>]

       <u>treeName</u> <b>ancestors</b> <u>node</u>
              This  method  extends  the  method  <b>parent</b> and returns a list containing all ancestor nodes to the
              specified <u>node</u>. The immediate ancestor, in other words, parent node, is the first element in  that
              list,  its parent the second element, and so on until the root node is reached, making it the last
              element of the returned list.

       <u>treeName</u> <b>append</b> <u>node</u> <u>key</u> <u>value</u>
              Appends a <u>value</u> to one of the keyed values associated with an node. Returns the new value given to
              the attribute <u>key</u>.

       <u>treeName</u> <b>attr</b> <u>key</u>

       <u>treeName</u> <b>attr</b> <u>key</u> <b>-nodes</b> <u>list</u>

       <u>treeName</u> <b>attr</b> <u>key</u> <b>-glob</b> <u>globpattern</u>

       <u>treeName</u> <b>attr</b> <u>key</u> <b>-regexp</b> <u>repattern</u>
              This method retrieves the value of the attribute named <u>key</u>, for all nodes in  the  tree  (matching
              the restriction specified via one of the possible options) and having the specified attribute.

              The  result  is  a  dictionary mapping from node names to the value of attribute <u>key</u> at that node.
              Nodes not having the attribute <u>key</u>, or not passing a specified restriction, are not listed in  the
              result.

              The possible restrictions are:

              <b>-nodes</b> The  value  is  a list of nodes. Only the nodes mentioned in this list are searched for the
                     attribute.

              <b>-glob</b>  The value is a glob pattern. Only the nodes in the tree whose names match this pattern  are
                     searched for the attribute.

              <b>-regexp</b>
                     The  value  is  a  regular  expression.  Only  the nodes in the tree whose names match this
                     pattern are searched for the attribute.

       <u>treeName</u> <b>children</b> ?<b>-all</b>? <u>node</u> ?<b>filter</b> <u>cmdprefix</u>?
              Return a list of the children of <u>node</u>.  If the option <b>-all</b> is specified, then not only the  direct
              children,  but  their  children,  and  so  on  are returned in the result.  If a filter command is
              specified only those nodes are listed in the final result which pass  the  test.  The  command  in
              <u>cmdprefix</u>  is  called with two arguments, the name of the tree object, and the name of the node in
              question. It is executed in the context of the caller and has to return a boolean value. Nodes for
              which the command returns <b>false</b> are removed from the result list before  it  is  returned  to  the
              caller.

              Some examples:

                  mytree insert root end 0 ; mytree set 0 volume 30
                  mytree insert root end 1
                  mytree insert root end 2
                  mytree insert 0    end 3
                  mytree insert 0    end 4
                  mytree insert 4    end 5 ; mytree set 5 volume 50
                  mytree insert 4    end 6

                  proc vol {t n} {
                $t keyexists $n volume
                  }
                  proc vgt40 {t n} {
                if {![$t keyexists $n volume]} {return 0}
                expr {[$t get $n volume] &gt; 40}
                  }

                  tclsh&gt; lsort [mytree children -all root filter vol]
                  0 5

                  tclsh&gt; lsort [mytree children -all root filter vgt40]
                  5

                  tclsh&gt; lsort [mytree children root filter vol]
                  0

                  tclsh&gt; puts ([lsort [mytree children root filter vgt40]])
                  ()

       <u>treeName</u> <b>cut</b> <u>node</u>
              Removes  the node specified by <u>node</u> from the tree, but not its children.  The children of <u>node</u> are
              made children of the parent of the <u>node</u>, at the index at which <u>node</u> was located.

       <u>treeName</u> <b>delete</b> <u>node</u> ?<u>node</u> ...?
              Removes the specified nodes from the tree.  All of the nodes' children will be removed as well  to
              prevent orphaned nodes.

       <u>treeName</u> <b>depth</b> <u>node</u>
              Return the number of steps from node <u>node</u> to the root node.

       <u>treeName</u> <b>descendants</b> <u>node</u> ?<b>filter</b> <u>cmdprefix</u>?
              This  method  extends  the method <b>children</b> and returns a list containing all nodes descending from
              <u>node</u>, and passing the filter, if such was specified.

              This is actually the same as "<u>treeName</u>  <b>children</b>  <b>-all</b>".   <b>descendants</b>  should  be  prefered,  and
              "children -all" will be deprecated sometime in the future.

       <u>treeName</u> <b>deserialize</b> <u>serialization</u>
              This  is the complement to <b>serialize</b>. It replaces tree data in <u>treeName</u> with the tree described by
              the <u>serialization</u> value. The old contents of <u>treeName</u> are deleted by this operation.

       <u>treeName</u> <b>destroy</b>
              Destroy the tree, including its storage space and associated command.

       <u>treeName</u> <b>exists</b> <u>node</u>
              Returns true if the specified node exists in the tree.

       <u>treeName</u> <b>get</b> <u>node</u> <u>key</u>
              Returns the value associated with the key <u>key</u> for the node <u>node</u>.

       <u>treeName</u> <b>getall</b> <u>node</u> ?<u>pattern</u>?
              Returns a dictionary (suitable for use with [<b>array</b> <b>set</b>]) containing the  attribute  data  for  the
              <u>node</u>.   If the glob <u>pattern</u> is specified only the attributes whose names match the pattern will be
              part of the dictionary.

       <u>treeName</u> <b>keys</b> <u>node</u> ?<u>pattern</u>?
              Returns a list of keys for the <u>node</u>.  If the <u>pattern</u> is specified only the attributes whose  names
              match the pattern will be part of the returned list. The pattern is a <b>glob</b> pattern.

       <u>treeName</u> <b>keyexists</b> <u>node</u> <u>key</u>
              Return true if the specified <u>key</u> exists for the <u>node</u>.

       <u>treeName</u> <b>index</b> <u>node</u>
              Returns  the  index of <u>node</u> in its parent's list of children.  For example, if a node has <u>nodeFoo</u>,
              <u>nodeBar</u>, and <u>nodeBaz</u> as children, in that order, the index of <u>nodeBar</u> is 1.

       <u>treeName</u> <b>insert</b> <u>parent</u> <u>index</u> ?<u>child</u> ?<u>child</u> ...??
              Insert one or more nodes into the tree as children of the node <u>parent</u>. The nodes will be added  in
              the order they are given. If <u>parent</u> is <b>root</b>, it refers to the root of the tree. The new nodes will
              be  added  to  the  <u>parent</u>  node's child list at the index given by <u>index</u>. The <u>index</u> can be <b>end</b> in
              which case the new nodes will be added after the current last child.  Indices of the form  "end-<b>n</b>"
              are accepted as well.

              If  any  of the specified children already exist in <u>treeName</u>, those nodes will be moved from their
              original location to the new location indicated by this command.

              If no <u>child</u> is specified, a single node will be added, and a name will be generated  for  the  new
              node.  The  generated  name is of the form <u>node</u><b>x</b>, where <b>x</b> is a number. If names are specified they
              must neither contain whitespace nor colons (":").

              The return result from this command is a list of nodes added.

       <u>treeName</u> <b>isleaf</b> <u>node</u>
              Returns true if <u>node</u> is a leaf of the tree (if <u>node</u> has no children), false otherwise.

       <u>treeName</u> <b>lappend</b> <u>node</u> <u>key</u> <u>value</u>
              Appends a <u>value</u> (as a list) to one of the keyed values associated with an <u>node</u>.  Returns  the  new
              value given to the attribute <u>key</u>.

       <u>treeName</u> <b>leaves</b>
              Return a list containing all leaf nodes known to the tree.

       <u>treeName</u> <b>move</b> <u>parent</u> <u>index</u> <u>node</u> ?<u>node</u> ...?
              Make  the  specified  nodes children of <u>parent</u>, inserting them into the parent's child list at the
              index given by <u>index</u>. Note that the command will take all nodes out of the tree  before  inserting
              them  under  the  new  parent,  and  that  it determines the position to place them into after the
              removal, before the re-insertion. This behaviour is important when it comes to moving one or  more
              nodes to a different index without changing their parent node.

       <u>treeName</u> <b>next</b> <u>node</u>
              Return the right sibling of <u>node</u>, or the empty string if <u>node</u> was the last child of its parent.

       <u>treeName</u> <b>numchildren</b> <u>node</u>
              Return the number of immediate children of <u>node</u>.

       <u>treeName</u> <b>nodes</b>
              Return a list containing all nodes known to the tree.

       <u>treeName</u> <b>parent</b> <u>node</u>
              Return the parent of <u>node</u>.

       <u>treeName</u> <b>previous</b> <u>node</u>
              Return the left sibling of <u>node</u>, or the empty string if <u>node</u> was the first child of its parent.

       <u>treeName</u> <b>rename</b> <u>node</u> <u>newname</u>
              Renames  the node <u>node</u> to <u>newname</u>. An error is thrown if either the node does not exist, or a node
              with name <u>newname</u> does exist. The result of the command is the new name of the node.

       <u>treeName</u> <b>rootname</b>
              Returns the name of the root node of the tree.

       <u>treeName</u> <b>serialize</b> ?<u>node</u>?
              This method serializes the sub-tree starting at <u>node</u>. In  other  words  it  returns  a  tcl  <u>value</u>
              completely  describing  the tree starting at <u>node</u>.  This allows, for example, the transfer of tree
              objects (or parts thereof) over arbitrary channels, persistence, etc.  This  method  is  also  the
              basis for both the copy constructor and the assignment operator.

              The  result  of  this method has to be semantically identical over all implementations of the tree
              interface. This is what will enable us to copy tree data between different implementations of  the
              same interface.

              The  result  is a list containing containing a multiple of three elements. It is like a serialized
              array except that there are two values following each key. They are the names of the nodes in  the
              serialized tree. The two values are a reference to the parent node and the attribute data, in this
              order.

              The  reference to the parent node is the empty string for the root node of the tree. For all other
              nodes it is the index of the parent node in the list. This means that they are  integers,  greater
              than or equal to zero, less than the length of the list, and multiples of three.  The order of the
              nodes in the list is important insofar as it is used to reconstruct the lists of children for each
              node.  The children of a node have to be listed in the serialization in the same order as they are
              listed in their parent in the tree.

              The attribute data of a node is a dictionary, i.e. a list of even length containing  a  serialized
              array. For a node without attribute data the dictionary is the empty list.

              <u>Note:</u>  While  the  current  implementation returns the root node as the first element of the list,
              followed by its children and their children in a depth-first traversal  this  is  not  necessarily
              true  for other implementations.  The only information a reader of the serialized data can rely on
              for the structure of the tree is that the root node is signaled by the empty string for the parent
              reference, that all other nodes refer to their parent through the index  in  the  list,  and  that
              children occur in the same order as in their parent.

               A possible serialization for the tree structure

                           +- d
                     +- a -+
               root -+- b  +- e
                     +- c
               is

               {root {} {} a 0 {} d 3 {} e 3 {} b 0 {} c 0 {}}

               The above assumes that none of the nodes have attributes.

       <u>treeName</u> <b>set</b> <u>node</u> <u>key</u> ?<u>value</u>?
              Set  or  get  one  of the keyed values associated with a node. A node may have any number of keyed
              values associated with it.  If <u>value</u> is not specified, this  command  returns  the  current  value
              assigned  to  the  key;  if  <u>value</u>  is  specified, this command assigns that value to the key, and
              returns it.

       <u>treeName</u> <b>size</b> ?<u>node</u>?
              Return a count of the number of descendants of the node <u>node</u>; if no node  is  specified,  <b>root</b>  is
              assumed.

       <u>treeName</u> <b>splice</b> <u>parent</u> <u>from</u> ?<u>to</u>? ?<u>child</u>?
              Insert  a  node  named  <u>child</u>  into  the tree as a child of the node <u>parent</u>. If <u>parent</u> is <b>root</b>, it
              refers to the root of the tree. The new node will be added to the parent node's child list at  the
              index given by <u>from</u>.  The children of <u>parent</u> which are in the range of the indices <u>from</u> and <u>to</u> are
              made  children  of  <u>child</u>.  If the value of <u>to</u> is not specified it defaults to <b>end</b>.  If no name is
              given for <u>child</u>, a name will be generated for the new node.  The generated name  is  of  the  form
              <u>node</u><b>x</b>, where <b>x</b> is a number.  The return result from this command is the name of the new node.

              The arguments <u>from</u> and <u>to</u> are regular list indices, i.e.  the form "end-<b>n</b>" is accepted as well.

       <u>treeName</u> <b>swap</b> <u>node1</u> <u>node2</u>
              Swap the position of <u>node1</u> and <u>node2</u> in the tree.

       <u>treeName</u> <b>unset</b> <u>node</u> <u>key</u>
              Removes a keyed value from the node <u>node</u>. The method will do nothing if the <u>key</u> does not exist.

       <u>treeName</u> <b>walk</b> <u>node</u> ?<b>-order</b> <u>order</u>? ?<b>-type</b> <u>type</u>? <u>loopvar</u> <u>script</u>
              Perform  a  breadth-first  or depth-first walk of the tree starting at the node <u>node</u>.  The type of
              walk, breadth-first or depth-first, is determined by the value of  <u>type</u>;  <b>bfs</b>  indicates  breadth-
              first, <b>dfs</b> indicates depth-first.  Depth-first is the default. The order of the walk, pre-, post-,
              both-  or  in-order  is  determined by the value of <u>order</u>; <b>pre</b> indicates pre-order, <b>post</b> indicates
              post-order, <b>both</b> indicates both-order and <b>in</b> indicates in-order. Pre-order is the default.

              Pre-order walking means that a parent node is visited before any of its children.  For example,  a
              breadth-first  search  starting  from  the root will visit the root, followed by all of the root's
              children, followed by all of the root's grandchildren. Post-order walking means that a parent node
              is visited after any of its children. Both-order walking means  that  a  parent  node  is  visited
              before  <u>and</u>  after any of its children. In-order walking means that a parent node is visited after
              its first child and before the second. This is a generalization of  in-order  walking  for  binary
              trees  and  will do the right thing if a binary tree is walked. The combination of a breadth-first
              walk with in-order is illegal.

              As the walk progresses, the <u>script</u> will be evaluated at each node. The evaluation takes  place  in
              the  context  of the caller of the method.  Regarding loop variables, these are listed in <u>loopvar</u>.
              If one only one variable is specified it will be set to the id of the node. When two variables are
              specified, i.e. <u>loopvar</u> is a true list, then  the  first  variable  will  be  set  to  the  action
              performed at the node, and the other to the id of the node itself.  All loop variables are created
              in the context of the caller.

              There  are  three  possible actions: <b>enter</b>, <b>leave</b>, or <b>visit</b>.  <b>enter</b> actions occur during pre-order
              walks; <b>leave</b> actions occur during post-order walks; <b>visit</b> actions occur during in-order walks.  In
              a both-order walk, the command will be evaluated twice for each node; the action is <b>enter</b> for  the
              first evaluation, and <b>leave</b> for the second.

              <u>Note</u>:  The <b>enter</b> action for a node is always performed before the walker will look at the children
              of that node. This means that changes made by  the  <u>script</u>  to  the  children  of  the  node  will
              immediately influence the walker and the steps it will take.

              Any  other  manipulation,  for  example of nodes higher in the tree (i.e already visited), or upon
              leaving will have undefined results. They may succeed,  error  out,  silently  compute  the  wrong
              result, or anything in between.

              At  last  a  small  table  showing  the  relationship between the various options and the possible
              actions.

               order       type    actions         notes
               -----       ----    -----           -----
               pre         dfs     enter           parent before children
               post        dfs     leave           parent after children
               in          dfs     visit           parent between first and second child.
               both        dfs     enter, leave    parent before and after children
               -----       ----    -----           -----
               pre         bfs     enter           parent before children
               post        bfs     leave           parent after children
               in          bfs             -- illegal --
               both        bfs     enter, leave    parent before and after children
               -----       ----    -----           -----

       Note the command <b>::struct::tree::prune</b>. This command can be used in the walk script to force the  command
       to  ignore the children of the node we are currently at. It will throw an error if the order of traversal
       is either <b>post</b> or <b>in</b> as these modes visit the children before their parent, making pruning non-sensical.

       <u>treeName</u> <b>walkproc</b> <u>node</u> ?<b>-order</b> <u>order</u>? ?<b>-type</b> <u>type</u>? <u>cmdprefix</u>
              This method is like method <b>walk</b> in all essentials, except the interface to  the  user  code.  This
              method  invokes a command prefix with three additional arguments (tree, node, and action), instead
              of evaluating a script and passing the node via a loop variable.

   <b>CHANGES</b> <b>FOR</b> <b>2.0</b>
       The following noteworthy changes have occurred:

       [1]    The API for accessing attributes and their values has been simplified.

              All functionality regarding the default attribute "data" has been removed. This default  attribute
              does  not  exist  anymore. All accesses to attributes have to specify the name of the attribute in
              question. This backward <u>incompatible</u> change allowed us to simplify the signature  of  all  methods
              handling attributes.

              Especially the flag <b>-key</b> is not required anymore, even more, its use is now forbidden. Please read
              the documentation for the methods <b>set</b>, <b>get</b>, <b>getall</b>, <b>unset</b>, <b>append</b>, <b>lappend</b>, <b>keyexists</b> and <b>keys</b> for
              a description of the new API's.

       [2]    The  methods  <b>keys</b> and <b>getall</b> now take an optional pattern argument and will return only attribute
              data for keys matching this pattern.

       [3]    Nodes can now be renamed. See the documentation for the method <b>rename</b>.

       [4]    The structure has been extended with API's for  the  serialization  and  deserialization  of  tree
              objects, and a number of operations based on them (tree assignment, copy construction).

              Please  read  the  documentation  for  the  methods  <b>serialize</b>,  <b>deserialize</b>,  <b>=</b>, and <b>--&gt;</b>, and the
              documentation on the construction of tree objects.

              Beyond the copying of whole tree objects these new API's also enable the transfer of tree  objects
              over arbitrary channels and for easy persistence.

       [5]    The walker API has been streamlined and made more similar to the command <b>foreach</b>. In detail:

              •      The superfluous option <b>-command</b> has been removed.

              •      Ditto  for  the  place  holders.  Instead of the placeholders two loop variables have to be
                     specified to contain node and action information.

              •      The old command argument has been documented as a script now, which it was in the past too.

              •      The fact that <b>enter</b> actions are called before the walker looks at the children  of  a  node
                     has been documented now. In other words it is now officially allowed to manipulate the list
                     of children for a node under <u>these</u> circumstances. It has been made clear that changes under
                     any  other  circumstances  will  have  undefined results, from silently computing the wrong
                     result to erroring out.

       [6]    A new method, <b>attr</b>, was added allowing the query and retrieval of attribute data without regard to
              the node relationship.

       [7]    The method <b>children</b> has been extended with the ability to select from the  children  of  the  node
              based  on  an  arbitrary filtering criterium. Another extension is the ability to look not only at
              the immediate children of the node, but the whole tree below it.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following example demonstrates the creation of new nodes:

                  mytree insert root end 0   ; # Create node 0, as child of the root
                  mytree insert root end 1 2 ; # Ditto nodes 1 &amp; 2
                  mytree insert 0    end 3   ; # Now create node 3 as child of node 0
                  mytree insert 0    end     ; # Create another child of 0, with a
                  #                              generated name. The name is returned
                  #                              as the result of the command.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report such in the category <u>struct</u> <u>::</u> <u>tree</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       breadth-first, depth-first, in-order, node, post-order, pre-order, serialization, tree

</pre><h4><b>CATEGORY</b></h4><pre>
       Data structures

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2002-2004,2012 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                2.1.1                                   <u>struct::<a href="../man3tcl/tree.3tcl.html">tree</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>