<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree::Simple::Visitor - Visitor object for Tree::Simple objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtree-simple-perl">libtree-simple-perl_1.34-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tree::Simple::Visitor - Visitor object for Tree::Simple objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Tree::Simple;
         use Tree::Simple::Visitor;

         # create a visitor instance
         my $visitor = Tree::Simple::Visitor-&gt;new();

         # create a tree to visit
         my $tree = Tree::Simple-&gt;new(Tree::Simple-&gt;ROOT)
                                -&gt;addChildren(
                                    Tree::Simple-&gt;new("1.0"),
                                    Tree::Simple-&gt;new("2.0")
                                                -&gt;addChild(
                                                    Tree::Simple-&gt;new("2.1.0")
                                                    ),
                                    Tree::Simple-&gt;new("3.0")
                                    );

         # by default this will collect all the
         # node values in depth-first order into
         # our results
         $tree-&gt;accept($visitor);

         # get our results and print them
         print join ", ", $visitor-&gt;getResults();  # prints "1.0, 2.0, 2.1.0, 3.0"

         # for more complex node objects, you can specify
         # a node filter which will be used to extract the
         # information desired from each node
         $visitor-&gt;setNodeFilter(sub {
                       my ($t) = @_;
                       return $t-&gt;getNodeValue()-&gt;description();
                       });

         # NOTE: this object has changed, but it still remains
         # backwards compatible to the older version, see the
         # DESCRIPTION section below for more details

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This object has been revised into what I think is more intelligent approach to Visitor objects.  This is
       now a more suitable base class for building your own Visitors. It is also the base class for the visitors
       found in the <b>Tree::Simple::VisitorFactory</b> distribution, which includes a number of useful pre-built
       Visitors.

       While I have changed a number of things about this module, I have kept it backwards compatible to the old
       way of using it. So the original example code still works:

         my @accumulator;
         my $visitor = Tree::Simple::Visitor-&gt;new(sub {
                               my ($tree) = @_;
                               push @accumulator, $tree-&gt;getNodeValue();
                               },
                               Tree::Simple::Visitor-&gt;RECURSIVE);

         $tree-&gt;accept($visitor);

         print join ", ", @accumulator;  # prints "1.0, 2.0, 2.1.0, 3.0"

       But is better expressed as this:

         my $visitor = Tree::Simple::Visitor-&gt;new();
         $tree-&gt;accept($visitor);
         print join ", ", $visitor-&gt;getResults();  # prints "1.0, 2.0, 2.1.0, 3.0"

       This object is still pretty much a wrapper around the Tree::Simple "traverse" method, and can be thought
       of as a depth-first traversal Visitor object.

</pre><h4><b>METHODS</b></h4><pre>
       <b>new</b> <b>($func,</b> <b>$depth)</b>
           The  new style interface means that all arguments to the constructor are now optional.  As a means of
           defining the usage of the old and new, when no arguments are sent to the constructor, it  is  assumed
           that  the  new  style  interface  is being used. In the new style, the $depth is always assumed to be
           equivalent to "RECURSIVE" and the $func argument can be set with "setNodeFilter" instead. This is the
           recommended way of doing things now.  If you have been using the old way, it is still  there,  and  I
           will  maintain backwards compatibility for a few more version before removing it entirely. If you are
           using this module (and I do not even know if anyone actually is) you have been warned. Please contact
           me if this will be a problem.

           The old style constructor documentation is retained her for reference:

           The first argument to the constructor is a code reference to a function which expects a  <b>Tree::Simple</b>
           object  as  its  only  argument.  The second argument is optional, it can be used to set the depth to
           which the function is applied.  If  no  depth  is  set,  the  function  is  applied  to  the  current
           <b>Tree::Simple</b>  instance. If $depth is set to "CHILDREN_ONLY", then the function will be applied to the
           current <b>Tree::Simple</b> instance and all its immediate children. If $depth is set to  "RECURSIVE",  then
           the function will be applied to the current <b>Tree::Simple</b> instance and all its immediate children, and
           all  of  their children recursively on down the tree. If no $depth is passed to the constructor, then
           the function will only be applied to the current <b>Tree::Simple</b> object and none
            of its children.

       <b>includeTrunk</b> <b>($boolean)</b>
           Based upon the value of $boolean, this will tell the visitor to collect the  trunk  of  the  tree  as
           well.  It  is  defaulted to false (0) in the new style interface, but is defaulted to true (1) in the
           old style interface.

       <b>getNodeFilter</b>
           This method returns the CODE reference set with "setNodeFilter" argument.

       <b>clearNodeFilter</b>
           This method clears node filter field.

       <b>setNodeFilter</b> <b>($filter_function)</b>
           This method accepts a CODE reference as its $filter_function argument. This code reference is used to
           filter the tree nodes as they are collected. This can be used  to  customize  output,  or  to  gather
           specific  information  from  a  more  complex  tree  node. The filter function should accept a single
           argument, which is the current Tree::Simple object.

       <b>getResults</b>
           This method returns the accumulated results of the application of the node filter to the tree.

       <b>setResults</b>
           This method should not really be used outside of this class, as it just would not make any sense  to.
           It  is  included  in this class and in this documentation to facilitate subclassing of this class for
           your own needs. If you desire to clear the results, then you can simply  call  "setResults"  with  no
           argument.

       <b>visit</b> <b>($tree)</b>
           The  "visit"  method  accepts a <b>Tree::Simple</b> and applies the function set in "new" or "setNodeFilter"
           appropriately. The results of this application can be retrieved with "getResults"

</pre><h4><b>CONSTANTS</b></h4><pre>
       These constants are part of the old-style interface, and therefore will eventually be deprecated.

       <b>RECURSIVE</b>
           If passed this constant in the constructor,  the  function  will  be  applied  recursively  down  the
           hierarchy of <b>Tree::Simple</b> objects.

       <b>CHILDREN_ONLY</b>
           If passed this constant in the constructor, the function will be applied to the immediate children of
           the <b>Tree::Simple</b> object.

</pre><h4><b>BUGS</b></h4><pre>
       None that I am aware of. The code is pretty thoroughly tested (see <b>CODE</b> <b>COVERAGE</b> section in <b>Tree::Simple</b>)
       and  is  based  on  an  (non-publicly released) module which I had used in production systems for about 2
       years without incident. Of course, if you find a bug, let me know, and I will be sure to fix it.

       Bugs should be reported via the CPAN bug tracker at

       &lt;https://github.com/ronsavage/Tree-Simple/issues&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       I have written a set of pre-built Visitor objects, available on CPAN as <b>Tree::Simple::VisitorFactory</b>.

</pre><h4><b>AUTHOR</b></h4><pre>
       stevan little, &lt;<a href="mailto:stevan@iinteractive.com">stevan@iinteractive.com</a>&gt;

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;https://github.com/ronsavage/Tree-Simple&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2004-2006 by Infinity Interactive, Inc.

       &lt;<a href="http://www.iinteractive.com">http://www.iinteractive.com</a>&gt;

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-10-13                         <u>Tree::Simple::<a href="../man3pm/Visitor.3pm.html">Visitor</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>