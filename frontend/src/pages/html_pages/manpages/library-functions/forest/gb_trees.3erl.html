<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gb_trees - General balanced trees.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gb_trees - General balanced trees.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides  Prof.  Arne  Andersson's  General  Balanced Trees. These have no storage overhead
       compared to unbalanced binary trees, and their performance is better than AVL trees.

       This module considers two keys as different if and only if they do not compare equal (<u>==</u>).

</pre><h4><b>DATA</b> <b>STRUCTURE</b></h4><pre>
       Trees and iterators are built using opaque data  structures  that  should  not  be  pattern-matched  from
       outside this module.

       There  is no attempt to balance trees after deletions. As deletions do not increase the height of a tree,
       this should be OK.

       The original balance condition <u>h(T)</u> <u>&lt;=</u> <u>ceil(c</u> <u>*</u> <u>log(|T|))</u> has been changed to the similar (but not  quite
       equivalent) condition <u>2</u> <u>^</u> <u>h(T)</u> <u>&lt;=</u> <u>|T|</u> <u>^</u> <u>c</u>. This should also be OK.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>tree(Key,</b> <b>Value)</b>

              A general balanced tree.

       <b>tree()</b> = tree(term(), term())

       <b>iter(Key,</b> <b>Value)</b>

              A general balanced tree iterator.

       <b>iter()</b> = iter(term(), term())

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>balance(Tree1)</b> <b>-&gt;</b> <b>Tree2</b>

              Types:

                 Tree1 = Tree2 = tree(Key, Value)

              Rebalances  <u>Tree1</u>. Notice that this is rarely necessary, but can be motivated when many nodes have
              been deleted from the tree without further insertions. Rebalancing can then be forced to  minimize
              lookup times, as deletion does not rebalance the tree.

       <b>delete(Key,</b> <b>Tree1)</b> <b>-&gt;</b> <b>Tree2</b>

              Types:

                 Tree1 = Tree2 = tree(Key, Value)

              Removes the node with key <u>Key</u> from <u>Tree1</u> and returns the new tree. Assumes that the key is present
              in the tree, crashes otherwise.

       <b>delete_any(Key,</b> <b>Tree1)</b> <b>-&gt;</b> <b>Tree2</b>

              Types:

                 Tree1 = Tree2 = tree(Key, Value)

              Removes  the  node  with  key  <u>Key</u>  from  <u>Tree1</u>  if the key is present in the tree, otherwise does
              nothing. Returns the new tree.

       <b>take(Key,</b> <b>Tree1)</b> <b>-&gt;</b> <b>{Value,</b> <b>Tree2}</b>

              Types:

                 Tree1 = Tree2 = tree(Key, term())
                 Key = Value = term()

              Returns a value <u>Value</u> from node with key <u>Key</u> and new <u>Tree2</u>  without  the  node  with  this  value.
              Assumes that the node with key is present in the tree, crashes otherwise.

       <b>take_any(Key,</b> <b>Tree1)</b> <b>-&gt;</b> <b>{Value,</b> <b>Tree2}</b> <b>|</b> <b>error</b>

              Types:

                 Tree1 = Tree2 = tree(Key, term())
                 Key = Value = term()

              Returns  a  value  <u>Value</u>  from  node  with key <u>Key</u> and new <u>Tree2</u> without the node with this value.
              Returns <u>error</u> if the node with the key is not present in the tree.

       <b>empty()</b> <b>-&gt;</b> <b>tree()</b>

              Returns a new empty tree.

       <b>enter(Key,</b> <b>Value,</b> <b>Tree1)</b> <b>-&gt;</b> <b>Tree2</b>

              Types:

                 Tree1 = Tree2 = tree(Key, Value)

              Inserts <u>Key</u> with value <u>Value</u> into <u>Tree1</u> if the key is not present in the tree,  otherwise  updates
              <u>Key</u> to value <u>Value</u> in <u>Tree1</u>. Returns the new tree.

       <b>from_orddict(List)</b> <b>-&gt;</b> <b>Tree</b>

              Types:

                 List = [{Key, Value}]
                 Tree = tree(Key, Value)

              Turns  an  ordered  list <u>List</u> of key-value tuples into a tree. The list must not contain duplicate
              keys.

       <b>get(Key,</b> <b>Tree)</b> <b>-&gt;</b> <b>Value</b>

              Types:

                 Tree = tree(Key, Value)

              Retrieves the value stored with <u>Key</u> in <u>Tree</u>. Assumes that the key is present in the tree,  crashes
              otherwise.

       <b>insert(Key,</b> <b>Value,</b> <b>Tree1)</b> <b>-&gt;</b> <b>Tree2</b>

              Types:

                 Tree1 = Tree2 = tree(Key, Value)

              Inserts  <u>Key</u>  with  value  <u>Value</u>  into <u>Tree1</u> and returns the new tree. Assumes that the key is not
              present in the tree, crashes otherwise.

       <b>is_defined(Key,</b> <b>Tree)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Tree = tree(Key, Value :: term())

              Returns <u>true</u> if <u>Key</u> is present in <u>Tree</u>, otherwise <u>false</u>.

       <b>is_empty(Tree)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Tree = tree()

              Returns <u>true</u> if <u>Tree</u> is an empty tree, othwewise <u>false</u>.

       <b>iterator(Tree)</b> <b>-&gt;</b> <b>Iter</b>

              Types:

                 Tree = tree(Key, Value)
                 Iter = iter(Key, Value)

              Returns an iterator that can be  used  for  traversing  the  entries  of  <u>Tree</u>;  see  <u>next/1</u>.  The
              implementation  of this is very efficient; traversing the whole tree using <u>next/1</u> is only slightly
              slower than getting the list of all  elements  using  <u>to_list/1</u>  and  traversing  that.  The  main
              advantage  of  the iterator approach is that it does not require the complete list of all elements
              to be built in memory at one time.

       <b>iterator_from(Key,</b> <b>Tree)</b> <b>-&gt;</b> <b>Iter</b>

              Types:

                 Tree = tree(Key, Value)
                 Iter = iter(Key, Value)

              Returns an iterator that can be  used  for  traversing  the  entries  of  <u>Tree</u>;  see  <u>next/1</u>.  The
              difference  as  compared to the iterator returned by <u>iterator/1</u> is that the first key greater than
              or equal to <u>Key</u> is returned.

       <b>keys(Tree)</b> <b>-&gt;</b> <b>[Key]</b>

              Types:

                 Tree = tree(Key, Value :: term())

              Returns the keys in <u>Tree</u> as an ordered list.

       <b>largest(Tree)</b> <b>-&gt;</b> <b>{Key,</b> <b>Value}</b>

              Types:

                 Tree = tree(Key, Value)

              Returns <u>{Key,</u> <u>Value}</u>, where <u>Key</u> is the largest key in <u>Tree</u>, and <u>Value</u> is the value associated with
              this key. Assumes that the tree is not empty.

       <b>lookup(Key,</b> <b>Tree)</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>{value,</b> <b>Value}</b>

              Types:

                 Tree = tree(Key, Value)

              Looks up <u>Key</u> in <u>Tree</u>. Returns <u>{value,</u> <u>Value}</u>, or <u>none</u> if <u>Key</u> is not present.

       <b>map(Function,</b> <b>Tree1)</b> <b>-&gt;</b> <b>Tree2</b>

              Types:

                 Function = fun((K :: Key, V1 :: Value1) -&gt; V2 :: Value2)
                 Tree1 = tree(Key, Value1)
                 Tree2 = tree(Key, Value2)

              Maps function F(K, V1) -&gt; V2 to all key-value pairs of tree <u>Tree1</u>. Returns a new tree  <u>Tree2</u>  with
              the same set of keys as <u>Tree1</u> and the new set of values <u>V2</u>.

       <b>next(Iter1)</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>{Key,</b> <b>Value,</b> <b>Iter2}</b>

              Types:

                 Iter1 = Iter2 = iter(Key, Value)

              Returns  <u>{Key,</u>  <u>Value,</u>  <u>Iter2}</u>,  where  <u>Key</u> is the smallest key referred to by iterator <u>Iter1</u>, and
              <u>Iter2</u> is the new iterator to be used for traversing the remaining nodes, or the atom  <u>none</u>  if  no
              nodes remain.

       <b>size(Tree)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Tree = tree()

              Returns the number of nodes in <u>Tree</u>.

       <b>smallest(Tree)</b> <b>-&gt;</b> <b>{Key,</b> <b>Value}</b>

              Types:

                 Tree = tree(Key, Value)

              Returns  <u>{Key,</u>  <u>Value}</u>,  where  <u>Key</u> is the smallest key in <u>Tree</u>, and <u>Value</u> is the value associated
              with this key. Assumes that the tree is not empty.

       <b>take_largest(Tree1)</b> <b>-&gt;</b> <b>{Key,</b> <b>Value,</b> <b>Tree2}</b>

              Types:

                 Tree1 = Tree2 = tree(Key, Value)

              Returns <u>{Key,</u> <u>Value,</u> <u>Tree2}</u>, where <u>Key</u> is the largest key in <u>Tree1</u>, <u>Value</u> is the value  associated
              with  this  key, and <u>Tree2</u> is this tree with the corresponding node deleted. Assumes that the tree
              is not empty.

       <b>take_smallest(Tree1)</b> <b>-&gt;</b> <b>{Key,</b> <b>Value,</b> <b>Tree2}</b>

              Types:

                 Tree1 = Tree2 = tree(Key, Value)

              Returns <u>{Key,</u> <u>Value,</u> <u>Tree2}</u>, where <u>Key</u> is the smallest key in <u>Tree1</u>, <u>Value</u> is the value associated
              with this key, and <u>Tree2</u> is this tree with the corresponding node deleted. Assumes that  the  tree
              is not empty.

       <b>to_list(Tree)</b> <b>-&gt;</b> <b>[{Key,</b> <b>Value}]</b>

              Types:

                 Tree = tree(Key, Value)

              Converts a tree into an ordered list of key-value tuples.

       <b>update(Key,</b> <b>Value,</b> <b>Tree1)</b> <b>-&gt;</b> <b>Tree2</b>

              Types:

                 Tree1 = Tree2 = tree(Key, Value)

              Updates  <u>Key</u>  to value <u>Value</u> in <u>Tree1</u> and returns the new tree. Assumes that the key is present in
              the tree.

       <b>values(Tree)</b> <b>-&gt;</b> <b>[Value]</b>

              Types:

                 Tree = tree(Key :: term(), Value)

              Returns the values in <u>Tree</u> as an ordered list, sorted by their corresponding keys. Duplicates  are
              not removed.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/dict.3erl.html">dict</a>(3erl)</u>, <u><a href="../man3erl/gb_sets.3erl.html">gb_sets</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                                    <u><a href="../man3erl/gb_trees.3erl.html">gb_trees</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>