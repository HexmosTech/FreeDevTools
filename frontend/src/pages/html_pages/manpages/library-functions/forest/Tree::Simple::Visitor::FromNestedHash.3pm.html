<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree::Simple::Visitor::FromNestedHash - A Visitor for creating Tree::Simple objects from nested hash</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtree-simple-visitorfactory-perl">libtree-simple-visitorfactory-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tree::Simple::Visitor::FromNestedHash - A Visitor for creating Tree::Simple objects from nested hash
       trees.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Tree::Simple::Visitor::FromNestedHash;

         my $visitor = Tree::Simple::Visitor::FromNestedHash-&gt;new();

         # given this nested hash tree
         my $hash_tree = {
                       Root =&gt; {
                               Child1 =&gt; {
                                       GrandChild1 =&gt; {},
                                       GrandChild2 =&gt; {}
                                       },
                               Child2 =&gt; {}
                               }
                       };

         # set the array tree we
         # are going to convert
         $visitor-&gt;setHashTree($hash_tree);

         $tree-&gt;accept($visitor);

         # this then creates the equivalent Tree::Simple object:
         # Tree::Simple-&gt;new("Root")
         #     -&gt;addChildren(
         #         Tree::Simple-&gt;new("Child1")
         #             -&gt;addChildren(
         #                 Tree::Simple-&gt;new("GrandChild1"),
         #                 Tree::Simple-&gt;new("GrandChild2")
         #             ),
         #         Tree::Simple-&gt;new("Child2"),
         #     );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Given a tree constructed from nested hashes, this Visitor will create the equivalent Tree::Simple
       hierarchy.

</pre><h4><b>METHODS</b></h4><pre>
       <b>new</b> There  are  no  arguments to the constructor the object will be in its default state. You can use the
           "setNodeFilter" methods to customize its behavior.

       <b>setNodeFilter</b> <b>($filter_function)</b>
           This method accepts a CODE reference as its $filter_function argument and throws an exception  if  it
           is  not  a  code reference. This code reference is used to filter the tree nodes as they are created,
           the $filter_function is passed the node value extracted from the hash prior to it being inserted into
           the tree being built. The $filter_function is expected to return the value desired for inclusion into
           the tree.

       <b>setHashTree</b> <b>($hash_tree)</b>
           This method is used to set the $hash_tree that our Tree::Simple hierarchy will be  constructed  from.
           It must be in the following form:

             {
               Root =&gt; {
                     Child1 =&gt; {
                             GrandChild1 =&gt; {},
                             GrandChild2 =&gt; {}
                             },
                     Child2 =&gt; {}
                     }
             }

           Basically each key in the hash is considered a node, values are ignored unless it is a hash reference
           with  at  least one key in it, in which case it is interpreted as containing the children of the node
           created from the key.

           The tree is validated prior being accepted, if it fails validation an exception will be  thrown.  The
           rules are as follows;

           The hash tree must not be empty.
               It  makes  not  sense  to  create  a tree out of nothing, so it is assumed that this is a sign of
               something wrong.

           The hash tree must be a single rooted tree.
               The hash tree should have only one key in the first level. If it has more than one,  then  it  is
               not a single rooted tree.

           <b>NOTE:</b> Hash keys are sorted ascii-betically before being added to the tree, this results in a somewhat
           more predictable hierarchy.

       <b>visit</b> <b>($tree)</b>
           This  is the method that is used by the Tree::Simple "accept" method. It can also be used on its own,
           it requires the $tree argument to be a Tree::Simple object (or derived from a  Tree::Simple  object),
           and will throw and exception otherwise.

</pre><h4><b>Repository</b></h4><pre>
       &lt;https://github.com/ronsavage/Tree-Simple-VisitorFactory&gt;

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs should be reported via the CPAN bug tracker at

       &lt;https://github.com/ronsavage/Tree-Simple-VisitorFactory/issues&gt;

</pre><h4><b>CODE</b> <b>COVERAGE</b></h4><pre>
       See the <b>CODE</b> <b>COVERAGE</b> section in Tree::Simple::VisitorFactory for more information.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       These Visitor classes are all subclasses of <b>Tree::Simple::Visitor</b>, which can be found in the <b>Tree::Simple</b>
       module, you should refer to that module for more information.

</pre><h4><b>AUTHOR</b></h4><pre>
       stevan little, &lt;<a href="mailto:stevan@iinteractive.com">stevan@iinteractive.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2004, 2005 by Infinity Interactive, Inc.

       &lt;<a href="http://www.iinteractive.com">http://www.iinteractive.com</a>&gt;

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-11-19              <u>Tree::Simple::...:<a href="../man3pm/FromNestedHash.3pm.html">FromNestedHash</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>