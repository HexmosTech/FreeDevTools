<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::Tree::Compatible - Testing compatibility of phylogenetic trees with nested taxa.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-perl-perl">libbio-perl-perl_1.7.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::Tree::Compatible - Testing compatibility of phylogenetic trees with nested taxa.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Bio::Tree::Compatible;
         use Bio::TreeIO;
         my $input = Bio::TreeIO-&gt;new('-format' =&gt; 'newick',
                                      '-file'   =&gt; 'input.tre');
         my $t1 = $input-&gt;next_tree;
         my $t2 = $input-&gt;next_tree;

         my ($incompat, $ilabels, $inodes) = Bio::Tree::Compatible::is_compatible($t1,$t2);
         if ($incompat) {
           my %cluster1 = %{ Bio::Tree::Compatible::cluster_representation($t1) };
           my %cluster2 = %{ Bio::Tree::Compatible::cluster_representation($t2) };
           print "incompatible trees\n";
           if (scalar(@$ilabels)) {
             foreach my $label (@$ilabels) {
               my $node1 = $t1-&gt;find_node(-id =&gt; $label);
               my $node2 = $t2-&gt;find_node(-id =&gt; $label);
               my @c1 = sort @{ $cluster1{$node1} };
               my @c2 = sort @{ $cluster2{$node2} };
               print "label $label";
               print " cluster"; map { print " ",$_ } @c1;
               print " cluster"; map { print " ",$_ } @c2; print "\n";
             }
           }
           if (scalar(@$inodes)) {
             while (@$inodes) {
               my $node1 = shift @$inodes;
               my $node2 = shift @$inodes;
               my @c1 = sort @{ $cluster1{$node1} };
               my @c2 = sort @{ $cluster2{$node2} };
               print "cluster"; map { print " ",$_ } @c1;
               print " properly intersects cluster";
               map { print " ",$_ } @c2; print "\n";
             }
           }
         } else {
           print "compatible trees\n";
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       NB: This module has exclusively class methods that work on Bio::Tree::TreeI objects. An instance of
       Bio::Tree::Compatible cannot itself represent a tree, and so typically there is no need to create one.

       Bio::Tree::Compatible is a Perl tool for testing compatibility of phylogenetic trees with nested taxa
       represented as Bio::Tree::Tree objects. It is based on a recent characterization of ancestral
       compatibility of semi-labeled trees in terms of their cluster representations.

       A semi-labeled tree is a phylogenetic tree with some of its internal nodes labeled, and it can represent
       a classification tree as well as a phylogenetic tree with nested taxa, with labeled internal nodes
       corresponding to taxa at a higher level of aggregation or nesting than that of their descendents.

       Two semi-labeled trees are compatible if their topological restrictions to the common labels are such
       that for each node label, the smallest clusters containing it in each of the trees coincide and,
       furthermore, no cluster in one of the trees properly intersects a cluster of the other tree.

       Future extensions of Bio::Tree::Compatible include a Bio::Tree::Supertree module for combining compatible
       phylogenetic trees with nested taxa into a common supertree.

</pre><h4><b>FEEDBACK</b></h4><pre>
   <b>Mailing</b> <b>Lists</b>
       User feedback is an integral part of the evolution of this and other Bioperl modules. Send your comments
       and suggestions preferably to the Bioperl mailing list.  Your participation is much appreciated.

         <a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a>                  - General discussion
         <a href="http://bioperl.org/wiki/Mailing_lists">http://bioperl.org/wiki/Mailing_lists</a>  - About the mailing lists

   <b>Support</b>
       Please direct usage questions or support issues to the mailing list:

       <u><a href="mailto:bioperl-l@bioperl.org">bioperl-l@bioperl.org</a></u>

       rather than to the module maintainer directly. Many experienced and reponsive experts will be able look
       at the problem and quickly address it. Please include a thorough description of the problem with code and
       data examples if at all possible.

   <b>Reporting</b> <b>Bugs</b>
       Report bugs to the Bioperl bug tracking system to help us keep track of the bugs and their resolution.
       Bug reports can be submitted via the web:

         https://github.com/bioperl/bioperl-live/issues

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   Philip Daniel and Charles Semple. Supertree Algorithms for Nested Taxa. In: Olaf R. P. Bininda-Emonds
           (ed.)  Phylogenetic  Supertrees:  Combining  Information  to  Reveal  the Tree of Life, <u>Computational</u>
           <u>Biology</u>, vol. 4, chap. 7, pp. 151-171. Kluwer (2004).

       •   Charles Semple, Philip Daniel, Wim Hordijk, Roderic D. M. Page, and Mike Steel: Supertree  Algorithms
           for Ancestral Divergence Dates and Nested Taxa. Bioinformatics <b><a href="../man15/20.15.html">20</a></b>(15), 2355-2360 (2004).

       •   Merce  Llabres,  Jairo Rocha, Francesc Rossello, and Gabriel Valiente: On the Ancestral Compatibility
           of Two Phylogenetic Trees with Nested Taxa. J. Math. Biol. <b><a href="../man3/53.3.html">53</a></b>(3), 340-364 (2006).

</pre><h4><b>AUTHOR</b> <b>-</b> <b>Gabriel</b> <b>Valiente</b></h4><pre>
       Email <a href="mailto:valiente@lsi.upc.edu">valiente@lsi.upc.edu</a>

</pre><h4><b>APPENDIX</b></h4><pre>
       The rest of the documentation details each of the object methods.

   <b>postorder_traversal</b>
        Title   : postorder_traversal
        Usage   : my @nodes = @{ $tree-&gt;postorder_traversal }
        Function: Return list of nodes in postorder
        Returns : reference to array of Bio::Tree::Node
        Args    : none

       For example, the postorder traversal of the tree "(((A,B)C,D),(E,F,G));" is a reference to  an  array  of
       nodes  with internal_id 0 through 9, because the Newick standard representation for phylogenetic trees is
       based on a postorder traversal.

                 +---A                    +---0
                 |                        |
         +---+---C                +---4---2
         |   |   |                |   |   |
         |   |   +---B            |   |   +---1
         |   |                    |   |
         +   +-------D            9   +-------3
         |                        |
         |     +-----E            |     +-----5
         |     |                  |     |
         +-----+-----F            +-----8-----6
               |                        |
               +-----G                  +-----7

   <b>cluster_representation</b>
        Title   : cluster_representation
        Usage   : my %cluster = %{ $tree-&gt;cluster_representation }
        Function: Compute the cluster representation of a tree
        Returns : reference to hash of array of string indexed by
                  Bio::Tree::Node
        Args    : none

       For example, the cluster representation of the tree "(((A,B)C,D),(E,F,G));" is  a  reference  to  a  hash
       associating an array of string (descendent labels) to each node, as follows:

         0 --&gt; [A]
         1 --&gt; [B]
         2 --&gt; [A,B,C]
         3 --&gt; [D]
         4 --&gt; [A,B,C,D]
         5 --&gt; [E]
         6 --&gt; [F]
         7 --&gt; [G]
         8 --&gt; [E,F,G]
         9 --&gt; [A,B,C,D,E,F,G]

   <b>common_labels</b>
        Title   : common_labels
        Usage   : my $labels = $tree1-&gt;common_labels($tree2);
        Function: Return set of common node labels
        Returns : Set::Scalar
        Args    : Bio::Tree::Tree

       For  example,  the common labels of the tree "(((A,B)C,D),(E,F,G));" and the tree "((A,B)H,E,(J,(K)G)I);"
       are: "[A,B,E,G]".

                 +---A                 +---A
                 |                     |
         +---+---C             +-------H
         |   |   |             |       |
         |   |   +---B         |       +---B
         |   |                 |
         +   +-------D         +-----------E
         |                     |
         |     +-----E         |   +-------J
         |     |               |   |
         +-----+-----F         +---I
               |                   |
               +-----G             +---G---K

   <b>topological_restriction</b>
        Title   : topological_restriction
        Usage   : $tree-&gt;topological_restriction($labels)
        Function: Compute the topological restriction of a tree to a subset
                  of node labels
        Returns : Bio::Tree::Tree
        Args    : Set::Scalar

       For  example,  the  topological  restrictions  of  each  of   the   trees   "(((A,B)C,D),(E,F,G));"   and
       "((A,B)H,E,(J,(K)G)I);" to the labels "[A,B,E,G]" are as follows:

                 +---A             +---A
                 |                 |
         +---+---+             +---+
         |       |             |   |
         |       +---B         |   +---B
         +                     |
         |       +---E         +-------E
         |       |             |
         +-------+             +---+---G
                 |
                 +---G

   <b>is_compatible</b>
        Title   : is_compatible
        Usage   : $tree1-&gt;is_compatible($tree2)
        Function: Test compatibility of two trees
        Returns : boolean
        Args    : Bio::Tree::Tree

       For    example,    the    topological    restrictions    of   the   trees   "(((A,B)C,D),(E,F,G));"   and
       "((A,B)H,E,(J,(K)G)I);" to their common labels,  "[A,B,E,G]",  are  compatible.  The  respective  cluster
       representations are as follows:

         [A]                  [A]
         [B]                  [B]
         [E]                  [E]
         [G]                  [G]
         [A,B]                [A,B]
         [E,G]                [A,B,E,G]
         [A,B,E,G]

       As  a  second  example,  the  trees  "(A,B);"  and  "((B)A);"  are incompatible. Their respective cluster
       representations are as follows:

         [A]                  [B]
         [B]                  [A,B]
         [A,B]

       The reason is, the smallest cluster containing label "A" is "[A]" in the first tree but  "[A,B]"  in  the
       second tree.

        +---A         A---B
        |
        +
        |
        +---B

       As  a  second  example,  the  trees  "(((B,A),C),D);"  and  "((A,(D,B)),C);" are also incompatible. Their
       respective cluster representations are as follows:

         [A]                  [A]
         [B]                  [B]
         [C]                  [C]
         [D]                  [D]
         [A,B]                [B,D]
         [A,B,C]              [A,B,D]
         [A,B,C,D]            [A,B,C,D]

       The reason is, cluster "[A,B]" properly intersects cluster "[B,D]". There are  further  incompatibilities
       between these trees: "[A,B,C]" properly intersects both "[B,D]" and "[A,B,D]".

                 +---B             +-------A
                 |                 |
             +---+             +---+   +---D
             |   |             |   |   |
         +---+   +---A         |   +---+
         |   |                 +       |
         +   +-------C         |       +---B
         |                     |
         +-----------D         +-----------C

perl v5.32.1                                       2021-08-15                         <u>Bio::Tree::<a href="../man3pm/Compatible.3pm.html">Compatible</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>