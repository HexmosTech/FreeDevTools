<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dom - Create an in-memory DOM tree from XML</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tdom">tdom_0.9.5.1-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dom - Create an in-memory DOM tree from XML

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require tdom

       <b>dom</b> <u>method</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
_________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  command  provides  the creation of DOM trees in memory. In the usual case a string containing a XML
       information is parsed and converted into a DOM tree. Other possible parse input may be HTML or JSON.  The
       <u>method</u> indicates a specific subcommand.

       The valid methods are:

       <b>dom</b> <b>parse</b> <b>?</b><u>options</u><b>?</b> <b>?</b><u>data</u><b>?</b>
              Parses the XML information and builds up the DOM tree in memory providing a Tcl object command  to
              this DOM document object. Example:

                     dom parse $xml doc
                     $doc documentElement root

              parses  the  XML  in  the  variable  xml,  creates the DOM tree in memory, make a reference to the
              document object, visible in Tcl as a document object command, and assigns this new object name  to
              the  variable  doc.  When  doc  gets  freed,  the  DOM  tree and the associated Tcl command object
              (document and all node objects) are freed automatically.

                     set document [dom parse $xml]
                     set root     [$document documentElement]

              parses the XML in the variable xml, creates the DOM tree  in  memory,  make  a  reference  to  the
              document  object,  visible  in Tcl as a document object command, and returns this new object name,
              which is then stored in <u>document</u>.  To free the underlying DOM tree and the associative Tcl  object
              commands  (document  +  nodes  +  fragment nodes) the document object command has to be explicitly
              deleted by:

                     $document delete

              or

                     rename $document ""

              The valid options are:

              <b>-simple</b>
                     If <u>-simple</u> is specified, a simple but fast parser  is  used  (conforms  not  fully  to  XML
                     recommendation).  That  should double parsing and DOM generation speed. The encoding of the
                     data is not transformed inside the parser. The simple parser does not respect any  encoding
                     information  in  the XML declaration. It skips over the internal DTD subset and ignores any
                     information in it. Therefore, it doesn't include defaulted attribute values into the  tree,
                     even  if  the  according  attribute  declaration is in the internal subset. It also doesn't
                     expand internal or external entity  references  other  than  the  predefined  entities  and
                     character references

              <b>-html</b>  If  <u>-html</u>  is specified, a fast HTML parser is used, which tries to even parse badly formed
                     HTML into a DOM tree. If the HTML document given to parse  does  not  have  a  single  root
                     element  (as  it  was legal up to HTML 4.01) and the -forest option is not used then a html
                     node will be inserted as document element, with the HTML input data top level  elements  as
                     children.

              <b>-html5</b> This  option  is  only available if tDOM was build with --enable-html5. Use the <u>featureinfo</u>
                     method if you need to know if this feature is build in. If <u>-html5</u> is specified,  the  gumbo
                     lib  html5  parser  (https://github.com/google/gumbo-parser) is used to build the DOM tree.
                     This is, as far as it goes, XML namespace-aware (which means  for  example  that  all  HTML
                     elements  are  in  the html5 namespace). Since this probably isn't wanted by a lot of users
                     and adds only burden for no good in a  lot  of  use  cases  <u>-html5</u>  can  be  combined  with
                     <u>-ignorexmlns</u>,  in  which  case  all  nodes and attributes in the DOM tree are not in an XML
                     namespace. All tag and attribute names in the DOM tree will be lower case, even for foreign
                     elements not in the xhtml, svg or mathml namespace.  The DOM tree may include  nodes,  that
                     the  parser  inserted  because  they are implied by the context (as &lt;head&gt;, &lt;tbody&gt;, etc.).
                     Input longer than 4 GByte byte length is not supported by the underlying gumbo parser.

              <b>-json</b>  If <u>-json</u> is specified, the <u>data</u> is expected to be a valid JSON  string  (according  to  RFC
                     7159). The command returns an ordinary DOM document with nesting token inside the JSON data
                     translated  into  tree  hierarchy.  If a JSON array value is itself an object or array then
                     container element nodes named (in  a  default  build)  arraycontainer  or  objectcontainer,
                     respectively, are inserted into the tree. The JSON serialization of this document (with the
                     domDoc  method <u>asJSON</u>) is the same JSON information as the <u>data</u>, preserving JSON datatypes,
                     allowing non-unique member names of objects while preserving their order and the full range
                     of JSON string  values.  JSON  datatype  handling  is  done  with  an  additional  property
                     "sticking" at the doc and tree nodes. This property isn't contained in an XML serialization
                     of  the  document.  If you need to store the JSON data represented by a document, store the
                     JSON serialization and parse it back from there. Apart from this JSON type information  the
                     returned  doc  command  or  handle  is  an  ordinary  DOM doc, which may be investigated or
                     modified with the full range of the doc and node methods. Please note that the element node
                     names and the text node values within the tree may be outside of what the  appropriate  XML
                     productions allow.

              <b>-jsonroot</b> <b>&lt;document</b> <b>element</b> <b>name&gt;</b>
                     If given makes the given element name the document element of the resulting doc. The parsed
                     content of the JSON string will be the children of this document element node.

              <b>-jsonmaxnesting</b>  <u>integer</u>
                     This  option  only  has  effect  if  used  together  with  the  <u>-json</u>  option.  The current
                     implementation uses a recursive descent JSON parser.  In order to avoid using excess  stack
                     space, any JSON input that has more than a certain levels of nesting is considered invalid.
                     The  default  maximum nesting is 2000. The option -jsonmaxnesting allows the user to adjust
                     that.

              <b>--</b>     The option <u>--</u> marks the end of options.  To give this option isn't strictly necessary  even
                     in the case of JSON parsing, for which valid data may start with a "-". If parsing json and
                     if  the  second  to last or last argument start with a "-" and isn't a known option name it
                     will be treated as JSON data.

              <b>-keepEmpties</b>
                     If <u>-keepEmpties</u> is specified then text nodes which contain only whitespaces will be part of
                     the resulting DOM tree. In default case (<u>-keepEmpties</u> not given) those empty text nodes are
                     removed at parsing time.

              <b>-keepCDATA</b>
                     If <u>-keepCDATA</u> is specified then CDATA sections aren't added to the tree as text nodes (and,
                     if necessary, combined with sibling text nodes into one text node) as without  this  option
                     but are added as CDATA_SECTION_NODEs to the tree. Please note that the resulting tree isn't
                     prepared for XPath selects or to be the source or the stylesheet of an XSLT transformation.
                     If  not combined with <u>-keepEmpties</u> only not whitespace only CDATA sections will be added to
                     the resulting DOM tree.

              <b>-channel</b>  <u>&lt;channel-ID&gt;</u>
                     If <u>-channel</u> <u>&lt;channel-ID&gt;</u> is specified, the input to be parsed is read  from  the  specified
                     channel.  The  encoding  setting of the channel (via fconfigure -encoding) is respected, ie
                     the data read from the channel are converted to UTF-8 according to  the  encoding  settings
                     before the data is parsed.

              <b>-baseurl</b>  <u>&lt;baseURI&gt;</u>
                     If  <u>-baseurl</u>  <u>&lt;baseURI&gt;</u>  is specified, the baseURI is used as the base URI of the document.
                     External entities references in the document are resolved relative to this base  URI.  This
                     base URI is also stored within the DOM tree.

              <b>-feedbackAfter</b>  <u>&lt;#bytes&gt;</u>
                     If <u>-feedbackAfter</u> <u>&lt;#bytes&gt;</u> is specified, the Tcl command given by <u>-feedbackcmd</u> is evaluated
                     at  the  first element start within the document (or an external entity) after the start of
                     the document or  external  entity  or  the  last  such  call  after  #bytes.  For  backward
                     compatibility   if   no   -feedbackcmd   is   given   but   there   is  a  Tcl  proc  named
                     ::dom::domParseFeedback this proc is used as -feedbackcmd. If there isn't such a  proc  and
                     -feedbackAfter  is  used  it is an error to not also use -feedbackcmd. If the called script
                     raises error, then parsing will be aborted, the <u>dom</u> <u>parse</u>  call  returns  error,  with  the
                     script  error  msg as error msg.  If the called script <u>return</u> <u>-code</u> <u>break</u>, the parsing will
                     abort and the <u>dom</u> <u>parse</u> call will return the empty string.

              <b>-feedbackcmd</b>  <u>&lt;script&gt;</u>
                     If <u>-feedbackcmd</u> <u>&lt;script&gt;</u> is specified, the script <u>script</u> is evaluated at the first  element
                     start  within  the  document  (or  an  external  entity) after the start of the document or
                     external entity or the last such call  after  #bytes  value  given  by  the  <u>-feedbackAfter</u>
                     option.  If  <u>-feedbackAfter</u>  isn't  given, using this option doesn't has any effect. If the
                     called script raises error, then parsing will be aborted, the <u>dom</u> <u>parse</u> call returns error,
                     with the script error msg as error msg. If  the  called  script  <u>return</u>  <u>-code</u>  <u>break</u>,  the
                     parsing will abort and the <u>dom</u> <u>parse</u> call will return the empty string.

              <b>-externalentitycommand</b>  <u>&lt;script&gt;</u>
                     If  <u>-externalentitycommand</u>  <u>&lt;script&gt;</u>  is  specified,  the specified Tcl script is called to
                     resolve any external entities of the document. The actual  evaluated  command  consists  of
                     this  option followed by three arguments: the base uri, the system identifier of the entity
                     and the public identifier of the entity. The base uri and the public identifier may be  the
                     empty  list.  The  script  has to return a Tcl list consisting of three elements. The first
                     element of this list signals  how  the  external  entity  is  returned  to  the  processor.
                     Currently  the two allowed types are "string" and "channel". The second element of the list
                     has to be the (absolute) base URI of the external entity to be parsed.  The  third  element
                     of  the list are data, either the already read data out of the external entity as string in
                     the case of type "string", or the name of a Tcl channel, in the  case  of  type  "channel".
                     Note  that if the script returns a Tcl channel, it will not be closed by the processor.  It
                     must be closed separately if it is no longer needed.

              <b>-useForeignDTD</b>  <u>&lt;boolean&gt;</u>
                     If &lt;boolean&gt; is true and the document does not have an external  subset,  the  parser  will
                     call  the  -externalentitycommand  script  with  empty values for the systemId and publicID
                     arguments. Please note that if the document also  doesn't  have  an  internal  subset,  the
                     -startdoctypedeclcommand and -enddoctypedeclcommand scripts, if set, are not called.

              <b>-paramentityparsing</b>  <u>&lt;always|never|notstandalone&gt;</u>
                     The  <u>-paramentityparsing</u>  option  controls,  if  the  parser  tries to resolve the external
                     entities (including the external DTD subset) of the document while building the  DOM  tree.
                     <u>-paramentityparsing</u>  requires  an  argument,  which  must  be  either "always", "never", or
                     "notstandalone".  The value "always" means that the parser tries to resolves  (recursively)
                     all external entities of the XML source. This is the default in case <u>-paramentityparsing</u> is
                     omitted.  The  value "never" means that only the given XML source is parsed and no external
                     entity  (including  the  external  subset)  will  be  resolved  and   parsed.   The   value
                     "notstandalone"  means,  that  all  external entities will be resolved and parsed, with the
                     exception of documents, which explicitly states standalone="yes" in their XML declaration.

              <b>-forest</b>
                     If this option is given, there is no need for a single root; any sequence  of  well-formed,
                     balanced subtrees will be parsed into a DOM tree. This works for the expat DOM builder, the
                     simple  xml  parser enabled with <u>-simple</u> and the simple HTML parser enabled -with <u>-html</u>. If
                     used together with <u>-json</u> or <u>-html5</u> this option is ignored.

              <b>-ignorexmlns</b>
                     It is recommended, that you only use this option with the <u>-html5</u> option. If this option  is
                     given,  no node within the created DOM tree will be internally marked as placed into an XML
                     Namespace, even if there is a default namespace in scope for un-prefixed elements  or  even
                     if  the  element  has  a  defined  namespace  prefix.  One  consequence  is that XPath node
                     expressions on such a DOM tree doesn't work as may  be  expected.  Prefixed  element  nodes
                     can't  be  selected  naively  and  element  nodes  without  prefix  will  be  seen by XPath
                     expressions as if they are not in any namespace (no matter if they are in fact should be in
                     a default namespace). If you need to inject prefixed node names into  an  XPath  expression
                     use the '%' syntax described in the documentation of the of the

              <b>domNode</b>
                      command method <b>&gt;selectNodes</b>.

              <b>-billionLaughsAttackProtectionMaximumAmplification</b>  <u>&lt;float&gt;</u>
                     &lt;URL: https://en.wikipedia.org/wiki/Billion_laughs_attack&gt;   This   option   together  with
                     <u>-billionLaughsAttackProtectionActivationThreshold</u> gives control over the parser limits that
                     protects against billion laugh attacks ().  This option expects a float &gt;= 1.0 as argument.
                     You should never need to use this option, because the default value (100.0) should work for
                     any real data.  If you ever need to increase this  value  for  non-attack  payload,  please
                     report.

              <b>-billionLaughsAttackProtectionActivationThreshold</b>  <u>&lt;long&gt;</u>
                     &lt;URL: https://en.wikipedia.org/wiki/Billion_laughs_attack&gt;   This   option   together  with
                     <u>-billionLaughsAttackProtectionMaximumAmplification</u> gives control  over  the  parser  limits
                     that  protects  against billion laugh attacks ().  This option expects a positiv integer as
                     argument. You should never need to use this option, because  the  default  value  (8388608)
                     should  work  for  any  real  data.  If you ever need to increase this value for non-attack
                     payload, please report.

       <b>dom</b> <b>createDocument</b> <u>docElemName</u> <b>?</b><u>objVar</u><b>?</b>
              Creates a new DOM document object with one element node with node  name  <u>docElemName</u>.  The  <u>objVar</u>
              controls the memory handling as explained above.

       <b>dom</b> <b>createDocumentNS</b> <u>uri</u> <u>docElemName</u> <b>?</b><u>objVar</u><b>?</b>
              Creates  a new DOM document object with one element node with node name <u>docElemName</u>. <u>Uri</u> gives the
              namespace of the document element to create. The <u>objVar</u> controls the memory handling as  explained
              above.

       <b>dom</b> <b>createDocumentNode</b> <b>?</b><u>-jsonType</u> <u>jsonType</u><b>?</b> <b>?</b><u>objVar</u><b>?</b>
              Creates  a  new  'empty'  DOM document object without any element node. <u>objVar</u> controls the memory
              handling as explained above. If the option -jsonType is given the created document node will be of
              the given JSON type.

       <b>dom</b> <b>createFromTypedList</b> <u>typedList</u> <b>?</b><u>objVar</u><b>?</b>

              Creates a new DOM document from the argument <u>typedList</u>.  The <u>objVar</u> argument controls  the  memory
              handling as explained above.

              The <u>typedList</u> argument must be a Tcl list and must follow the format of the output of the document
              command method <u>asTypedList</u>, see there.

       <b>dom</b> <b>createNodeCmd</b> <u>?-returnNodeCmd?</u> <u>?-tagName</u> <u>name?</u> <u>?-jsonType</u> <u>jsonType?</u> <u>?-namespace</u> <u>URI?</u>
       <u>(element|comment|text|cdata|pi)Node</u> <u>commandName</u>
              This  method  creates  Tcl commands, which in turn create tDOM nodes. Tcl commands created by this
              command are only available inside a script  given  to  the  domNode  methods  <u>appendFromScript</u>  or
              <u>insertBeforeFromScript</u>.  If  a command created with <u>createNodeCmd</u> is invoked in any other context,
              it will return error. The created command <u>commandName</u> replaces any existing command  or  procedure
              with  that  name.  If  the <u>commandName</u> includes any Tcl namespace qualifiers, it is created in the
              specified namespace. The <u>-tagName</u> option is only allowed for the elementNode type.  The  <u>-jsonType</u>
              option is only allowed for elementNode and textNode types.

              If   such   command  is  invoked  inside  a  script  given  as  argument  to  the  domNode  method
              <u>appendFromScript</u> or <u>insertBeforeFromScript</u> it creates a new node and appends this node at the  end
              of  the  child  list  of  the  invoking  element node. If the option <u>-returnNodeCmd</u> was given, the
              command returns the created node as Tcl command. If this option was omitted, the  command  returns
              nothing.  Each command creates always the same type of node.  Which type of node is created by the
              command is determined by the first argument to  the  <u>createNodeCmd</u>.  The  syntax  of  the  created
              command depends on the type of the node it creates.

              If  the command type to create is <u>elementNode</u>, the created command will create an element node, if
              called. Without the <u>-tagName</u> option the tag name of the created node is  <u>commandName</u>  without  Tcl
              namespace  qualifiers.  If  the  <u>-tagName</u> option was given then the created elements will have the
              value of this option as tag name. If the <u>-jsonType</u> option was given then the created node elements
              will have the given JSON type. If the <u>-namespace</u> option is given the created element node will  be
              XML  namespaced  and  in  the  namespace given by the option.  The element name will be literal as
              given either by the command name or the <u>-tagname</u> option, if that was  given.  An  appropriate  XML
              namespace  declaration  will  be  automatically added, to bind the prefix (if the element name has
              one) or the default namespace (if the element name hasn't a prefix) to the  namespace  if  such  a
              binding isn't in scope.

              The syntax of the created command is:

                     <b>elementNodeCmd</b> <u>?attributeName</u> <u>attributeValue</u> <u>...?</u> <u>?script?</u>
                     <b>elementNodeCmd</b> <u>?-attributeName</u> <u>attributeValue</u> <u>...?</u> <u>?script?</u>
                     <b>elementNodeCmd</b> <u>name_value_list</u> <u>script</u>

              The command syntax allows three different ways to specify the attributes of the resulting element.
              These  could  be  specified with <u>attributeName</u> <u>attributeValue</u> argument pairs, in an "option style"
              way with <u>-attriubteName</u> <u>attributeValue</u> argument pairs (the '-' character is only syntactical sugar
              and will be stripped off) or as a Tcl list with elements interpreted as  attribute  name  and  the
              corresponding  attribute  value.   The  attribute name elements in the list may have a leading '-'
              character, which will be stripped off.

              Every <u>elementNodeCmd</u> accepts an optional Tcl script as last argument. This script is evaluated  as
              recursive  <u>appendFromScript</u>  script  with  the node created by the <u>elementNodeCmd</u> as parent of all
              nodes created by the script.

              If the first argument of the method is <u>textNode</u>, the command will  create  a  text  node.  If  the
              <u>-jsonType</u>  option was given then the created text node will have that JSON type. The syntax of the
              created command is:

                     <b>textNodeCmd</b> ?-disableOutputEscaping? <u>?data?</u>

              If the json type of the created text node is NULL,  TRUE  or  FALSE  then  the  <u>data</u>  argument  is
              optional, otherwise it this argument must be given.

              If  the optional flag <u>-disableOutputEscaping</u> is given, the escaping of the ampersand character (&amp;)
              and the left angle bracket (&lt;) inside the data is disabled. You should use this flag carefully.

              If the first argument of the method is <u>commentNode</u> or <u>cdataNode</u> the command will create an comment
              node or CDATA section node. The syntax of the created command is:

                     <b>nodeCmd</b> <u>data</u>

              If the first argument of the method is <u>piNode</u>, the command will create  a  processing  instruction
              node. The syntax of the created command is:

                     <b>piNodeCmd</b> <u>target</u> <u>data</u>

              Beside  the  with  <b>dom</b> <b>createNodeCmd</b> calls created node commands there are two more commands which
              automatically insert nodes into the tree inside an <b>appendFromScript</b> script.

                     <b>tdom::fsnewNode</b> <u>?-jsonType</u> <u>&lt;jsonType&gt;?</u> <u>?-namespace</u> <u>&lt;namespace&gt;?</u> <u>tagName</u> <u>?attributes?</u> <u>?script?</u>

              If called inside a fromScript context this command creates a new node <u>tagName</u> in the XML namespace
              <u>namespace</u> if the <u>-namespace</u> option was given and with the JSON  type  <u>jsonType</u>  if  the  <u>-jsonType</u>
              option  was given and appends this node at the end of the child list of the invoking element node.
              The <u>attributes</u> and <u>script</u> arguments will be processed as if given  to  an  element  creating  node
              command. If called outside a fromScript context this command will raise error.

                     <b>tdom::fsinsertNode</b> <u>node</u>

              If  called  inside o fromScript context this comannd instead of creating a new node appends the as
              argument given node at the end of the child list  of  the  invoking  element  node.  The  node  is
              unlinked  from  its previous place. If called outside a fromScript context this command will raise
              error.

       <b>dom</b> <b>setStoreLineColumn</b> <u>?boolean</u><b>?</b>
              If switched on, the DOM nodes will contain line and column position information for  the  original
              XML document after parsing. The default is not to store line and column position information.

       <b>dom</b> <b>setNameCheck</b> <u>?boolean</u><b>?</b>
              If  NameCheck  is  true,  every  method  which  expects  an  XML  Name, a full qualified name or a
              processing instructing target will check, if the given string is valid according to its production
              rule. For  commands  created  with  the  <u>createNodeCmd</u>  method  to  be  used  in  the  context  of
              <u>appendFromScript</u> the status of the flag at creation time decides. If NameCheck is true at creation
              time,  the  command  will  check  its arguments, otherwise not. The <u>setNameCheck</u> set this flag. It
              returns the current NameCheck flag state. The default state for NameCheck is true.

       <b>dom</b> <b>setTextCheck</b> <u>?boolean</u><b>?</b>
              If TextCheck is true, every command which expects XML Chars, a comment, a CDATA section value or a
              processing instructing value will check, if the given string is valid according to its  production
              rule.  For  commands  created  with  the  <u>createNodeCmd</u>  method  to  be  used  in  the  context of
              <u>appendFromScript</u> the status of the flag at creation time decides. If TextCheck is true at creation
              time, the command will check its arguments, otherwise not.The <u>setTextCheck</u> method sets this  flag.
              It returns the current TextCheck flag state. The default state for TextCheck is true.

       <b>dom</b> <b>setObjectCommands</b> <b>?</b><u>(automatic|token|command)</u><b>?</b>
              Controls  if  documents  and  nodes  are  created  as Tcl commands or as token to be used with the
              domNode and domDoc commands. If the mode is 'automatic', then methods used at  Tcl  commands  will
              create  Tcl  commands  and  methods  used  at doc or node tokes will create tokens. If the mode is
              'command' then always Tcl commands will be created. If the mode is 'token', then always token will
              be created. The method returns the current mode. This method is an experimental interface.

       <b>dom</b> <b>isName</b> <u>name</u>
              Returns 1 if <u>name</u> is a valid XML Name according to production 5 of  the  XML  1.0  recommendation.
              This means that <u>name</u> is a valid XML element or attribute name. Otherwise it returns 0.

       <b>dom</b> <b>isPIName</b> <u>name</u>
              Returns  1  if <u>name</u> is a valid XML processing instruction target according to production 17 of the
              XML 1.0 recommendation. Otherwise it returns 0.

       <b>dom</b> <b>isNCName</b> <u>name</u>
              Returns 1 if <u>name</u> is a valid NCName according to production 4 of the  of  the  Namespaces  in  XML
              recommendation. Otherwise it returns 0.

       <b>dom</b> <b>isQName</b> <u>name</u>
              Returns  1  if  <u>name</u>  is  a  valid QName according to production 6 of the of the Namespaces in XML
              recommendation. Otherwise it returns 0.

       <b>dom</b> <b>isCharData</b> <u>string</u>
              Returns 1 if every character in <u>string</u> is a valid XML Char according to production 2  of  the  XML
              1.0 recommendation. Otherwise it returns 0.

       <b>dom</b> <b>isHTML5CustomName</b> <u>string</u>
              Returns    1    if    <u>string</u>    is   a   HTML5   valid   custom   element   name   (according   to
              https://html.spec.whatwg.org/#valid-custom-element-name at 26 June 2024, it's a living  standard).
              Otherwise it returns 0.

       <b>dom</b> <b>clearString</b> <b>?</b><u>-replace</u><b>?</b> <u>string</u>
              Returns  the  string  given  as argument cleared out from any characters not allowed as XML parsed
              character data. If the <u>-replace</u> option is given then  instead  of  removing  such  characters  are
              replaced with \uFFFD.

       <b>dom</b> <b>isBMPCharData</b> <u>string</u>
              Returns  1  if  every character in <u>string</u> is a valid XML Char with a Unicode code point within the
              Basic Multilingual Plane (that means, that every character within the string is at  most  3  bytes
              long). Otherwise it returns 0.

       <b>dom</b> <b>isComment</b> <u>string</u>
              Returns  1  if <u>string</u> is a valid comment according to production 15 of the XML 1.0 recommendation.
              Otherwise it returns 0.

       <b>dom</b> <b>isCDATA</b> <u>string</u>
              Returns 1 if <u>string</u> is valid according to production 20 of the XML 1.0  recommendation.  Otherwise
              it returns 0.

       <b>dom</b> <b>isPIValue</b> <u>string</u>
              Returns  1  if <u>string</u> is valid according to production 16 of the XML 1.0 recommendation. Otherwise
              it returns 0.

       <b>dom</b> <b>featureinfo</b> <u>feature</u>
              This method provides information about the used build options and the  expat  version.  The  valid
              values for the <u>feature</u> argument are:

              <b>expatversion</b>
                     Returns   the   version  of  the  underlyling  expat  version  as  string,  something  like
                     "exapt_2.1.0". This is what the expat API function XML_ExpatVersion() returns.

              <b>expatmajorversion</b>
                     Returns the major version of the at build time used expat version as integer.

              <b>expatminorversion</b>
                     Returns the minor version of the at build time used expat version as integer.

              <b>expatmicroversion</b>
                     Returns the micro version of the at build time used expat version as integer.

              <b>dtd</b>    Returns as boolean if build with <u>--enable-dtd</u>.

              <b>ns</b>     Returns as boolean if build with <u>--enable-ns</u>.

              <b>unknown</b>
                     Returns as boolean if build with <u>--enable-unknown</u>.

              <b>tdomalloc</b>
                     Returns as boolean if build with <u>--enable-tdomalloc</u>.

              <b>lessns</b> Returns as boolean if build with <u>--enable-lessns</u>.

              <b>TCL_UTF_MAX</b>
                     Returns the TCL_UTF_MAX value of the Tcl core, tDOM was build with as integer

              <b>html5</b>  Returns as boolean, if build with <u>--enable-html5</u>.

              <b>versionhash</b>
                     Returns the fossil repository version hash.

              <b>pullparser</b>
                     Returns as boolean if the pullparser command is build in.

              <b>schema</b> Returns as boolean if the tDOM schema features are build in.

</pre><h4><b>KEYWORDS</b></h4><pre>
       XML, DOM, document, node, parsing

Tcl                                                                                                    <u><a href="../man3tcl/dom.3tcl.html">dom</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>