<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree::Fast - the fastest possible implementation of a tree in pure Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtree-perl">libtree-perl_1.10-0ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tree::Fast - the fastest possible implementation of a tree in pure Perl

</pre><h4><b>SYNOPSIS</b></h4><pre>
         my $tree = Tree::Fast-&gt;new( 'root' );
         my $child = Tree::Fast-&gt;new( 'child' );
         $tree-&gt;add_child( {}, $child );

         $tree-&gt;add_child( { at =&gt; 0 }, Tree::Fast-&gt;new( 'first child' ) );
         $tree-&gt;add_child( { at =&gt; -1 }, Tree::Fast-&gt;new( 'last child' ) );

         my @children = $tree-&gt;children;
         my @some_children = $tree-&gt;children( 0, 2 );

         $tree-&gt;remove_child( 0 );

         my @nodes = $tree-&gt;traverse( $tree-&gt;POST_ORDER );

         my $traversal = $tree-&gt;traverse( $tree-&gt;POST_ORDER );
         while ( my $node = $traversal-&gt;() ) {
             # Do something with $node here
         }

         my $clone = $tree-&gt;clone;
         my $mirror = $tree-&gt;clone-&gt;mirror;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is meant to be the core implementation for Tree, stripped down as much as possible. There is no
       error-checking, bounds-checking, event-handling, convenience methods, or anything else of the sort. If
       you want something fuller-featured, please look at Tree, which is a wrapper around Tree::Fast.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Constructors</b>
   <b>new([$value])</b>
       Here, [] indicate an optional parameter.

       This will return a "Tree::Fast" object. It will accept one parameter which, if passed, will become the
       <u>value</u> (accessible by value()). All other parameters will be ignored.

       If you call "$tree-&gt;new([$value])", it will instead call clone(), then set the <u>value</u> of the clone to
       $value.

   <b>clone()</b>
       This will return a clone of $tree. The clone will be a root tree, but all children will be cloned.

       If you call "Tree::Fast-&gt;clone([$value])", it will instead call new().

       <b>NOTE:</b> the value is merely a shallow copy. This means that all references will be kept.

   <b>Behaviors</b>
   <b>add_child($options,</b> <b>@nodes)</b>
       This will add all the @nodes as children of $tree. $options is a required hashref that specifies options
       for add_child(). The optional parameters are:

       •   at

           This  specifies the index to add @nodes at. If specified, this will be passed into <b>splice()</b>. The only
           exceptions are if this is 0, it will act as an <b>unshift()</b>. If it is unset or undefined, it will act as
           a <b>push()</b>.

   <b>remove_child($options,</b> <b>@nodes)</b>
       This will remove all the @nodes from the children of $tree. You can  either  pass  in  the  actual  child
       object you wish to remove, the index of the child you wish to remove, or a combination of both.

       $options  is  a  required hashref that specifies parameters for <b>remove_child()</b>.  Currently, no parameters
       are used.

   <b>mirror()</b>
       This will modify the tree such that it is a mirror of what it was before. This means that  the  order  of
       all children is reversed.

       <b>NOTE</b>:  This  is  a destructive action. It <u>will</u> modify the tree's internal structure. If you wish to get a
       mirror, yet keep the original tree intact, use "my $mirror = $tree-&gt;clone-&gt;mirror".

   <b>traverse(</b> <b>[$order]</b> <b>)</b>
       Here, [] indicate an optional parameter.

       When called in list context ("my @traversal = $tree-&gt;traverse()"), this will return a list of  the  nodes
       in  the  given traversal order. When called in scalar context ("my $traversal = $tree-&gt;traverse()"), this
       will return a closure that will, over successive calls, iterate over the nodes  in  the  given  traversal
       order. When finished it will return false.

       The default traversal order is pre-order.

       The various traversal orders do the following steps:

       •   Pre-order

           This  will  return  the node, then the first sub tree in pre-order traversal, then the next sub tree,
           etc.

           Use "$tree-&gt;PRE_ORDER" as the $order.

       •   Post-order

           This will return the each sub-tree in post-order traversal, then the node.

           Use "$tree-&gt;POST_ORDER" as the $order.

       •   Level-order

           This will return the node, then the all children of the node, then all  grandchildren  of  the  node,
           etc.

           Use "$tree-&gt;LEVEL_ORDER" as the $order.

   <b>Accessors</b>
   <b>parent()</b>
       This will return the parent of $tree.

   <b>children(</b> <b>[</b> <b>$idx,</b> <b>[$idx,</b> <b>..]</b> <b>]</b> <b>)</b>
       Here, [] indicate optional parameters.

       This  will  return  the children of $tree. If called in list context, it will return all the children. If
       called in scalar context, it will return the number of children.

       You may optionally pass in a list of indices to retrieve. This will return the children in the order  you
       asked for them. This is very much like an arrayslice.

   <b>value()</b>
       This will return the value stored in the node.

   <b>set_value([$value])</b>
       Here, [] indicate an optional parameter.

       This will set the <u>value</u> stored in the node to $value, then return $self.

       If $value is not provided, undef is used.

   <b>meta()</b>
       This  will  return  a hashref that can be used to store whatever metadata the client wishes to store. For
       example, Tree::Persist::DB uses this to store database row ids.

       It is recommended that you store your metadata in a subhashref and not in the top-level metadata hashref,
       keyed by your package name. Tree::Persist does this, using  a  unique  key  for  each  persistence  layer
       associated with that tree.  This will help prevent clobbering of metadata.

</pre><h4><b>NULL</b> <b>TREE</b></h4><pre>
       If you call "$self-&gt;parent" on a root node, it will return a Tree::Null object. This is an implementation
       of  the  Null Object pattern optimized for usage with Tree::Fast. It will evaluate as false in every case
       (using <u>overload</u>) and all methods called on it will return a Tree::Null object.

   <b>Notes</b>
       •   Tree::Null does <b>not</b> inherit from anything. This is so that all the methods will go  through  AUTOLOAD
           vs. the actual method.

       •   However, calling <b>isa()</b> on a Tree::Null object will report that it is-a any object that is either Tree
           or in the Tree:: hierarchy.

       •   The Tree::Null object is a singleton.

       •   The  Tree::Null  object  <u>is</u>  defined, though. I couldn't find a way to make it evaluate as undefined.
           That may be a good thing.

</pre><h4><b>CODE</b> <b>COVERAGE</b></h4><pre>
       Please see the relevant sections of Tree.

</pre><h4><b>SUPPORT</b></h4><pre>
       Please see the relevant sections of Tree.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       •   Stevan Little for writing Tree::Simple, upon which Tree is based.

</pre><h4><b>AUTHORS</b></h4><pre>
       Rob Kinyon &lt;<a href="mailto:rob.kinyon@iinteractive.com">rob.kinyon@iinteractive.com</a>&gt;

       Stevan Little &lt;<a href="mailto:stevan.little@iinteractive.com">stevan.little@iinteractive.com</a>&gt;

       Thanks to Infinity Interactive for generously donating our time.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2004, 2005 by Infinity Interactive, Inc.

       &lt;<a href="http://www.iinteractive.com">http://www.iinteractive.com</a>&gt;

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.38.2                                       2024-02-17                                    <u>Tree::<a href="../man3pm/Fast.3pm.html">Fast</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>