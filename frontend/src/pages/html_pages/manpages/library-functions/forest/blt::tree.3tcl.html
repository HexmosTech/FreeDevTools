<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tree -  Create and manage tree data objects.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/blt-dev">blt-dev_2.5.3+dfsg-8_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tree -  Create and manage tree data objects.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>tree</b> <b>create</b>  ?<b>-fixed</b>? ?<b>-dictset</b>? ?<b>-keyhash</b> <u>N</u>? ?<u>treeName</u>?

       <b>tree</b> <b>destroy</b> <u>treeName</u>...

       <b>tree</b> <b>names</b> ?<u>pattern</u>?

       <b>tree</b> <b>op</b> <u>subcmd</u> ?<u>subsubcmd</u> <u>...</u>? <u>treeName</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
_________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>tree</b>  <b>command</b> is used to create, destroy, and provide Tcl access to a <b>tree</b> <b>object</b>.  A <b>tree</b> <b>object</b> is
       an ordered tree of nodes where each node can have data key-values, tags and a label.  The <b>treeview</b> widget
       uses a <b>tree</b> <b>object</b>.

</pre><h4><b>INTRODUCTION</b></h4><pre>
       Tree provides Tcl with a rich API for managing complex data structures.  Here is a simple example.

               set t [tree create]
               set id [$t insert 0]
               $t set $id X 2
               set n [$t get $id X]

               # Create a node with label
               $t insert 0 -label A
               $t set 0-&gt;A    X 1
               set n [$t get 0-&gt;A X]

       Labels provide convenient <b>-&gt;</b> indexing relative a starting node.

       Nodes may also be created with initial data values.

               $t insert 0 -label A -data {X 1   Y "a 1 b 2"}
               $t incr  0-&gt;A X 3
               $t set   0-&gt;A Y(a) 4

       Note round braces are used to access sub-values in a <b>dict-array</b>.  See the section <b>DICT-ARRAYS</b>  below  for
       details.

</pre><h4><b>SYNTAX</b></h4><pre>
       <b>tree</b> <b>create</b> ?<b>-fixed</b>? ?<b>-dictset</b>? ?<b>-keyhash</b> <u>N</u>? ?<u>treeName</u>?
              Creates a new tree object.  The name of the new tree is returned and a Tcl command is created.  If
              no  <u>treeName</u> argument is present, then the name of the tree is automatically generated in the form
              "<b>tree0</b>", "<b>tree1</b>", etc relative to the current namespace.  A tree name (if  given)  can  not  start
              with  a  dash.   Tree  names  containing  the  substring "<b>#auto</b>" will be replaced with a generated
              identifier.  For example, the name <b>data#auto</b> will translate to <b>datatree0</b>.  Note that when the  Tcl
              command is deleted the <b>tree</b> <b>object</b> also gets freed.

              Newly created trees always contain a single root node with id <b>0</b> that can not be deleted.

              Switches for <b>create</b> are listed below:

              <b>-fixed</b>    Make <b>insert</b> automatically set the <b>-fixed</b> flag.  This will disallow later setting of keys
                        not  given  as  <u>-data</u> to the insert.  This includes dict-array keys.  See the <b>fixed</b> sub-
                        command.

              <b>-dictset</b>  Define that any update of an <b>array</b> field will coerce the array object to a dict  object.
                        a dict will preserve order of sub-field keys on update.  See the <b>dictset</b> sub-command.

              <b>-keyhash</b> <u>size</u>
                        Define  the  size  beyond  which node key storage starts using a hash (the default is 21
                        keys).  Normally small numbers of keys are stored as a list.  But once  more  than  <u>size</u>
                        keys are added to a node, key storage converts to a hash.  This affects the order of key
                        iteration  (eg.  for  <b>get</b>/<b>names</b>/<b>values</b>).  A list will iterate in the order in which keys
                        were added, whereas the order of a hash is undetermined.  For large numbers  of  ordered
                        keys, specify a really large <u>size</u> (eg. 1000000).

       <b>tree</b> <b>destroy</b> <u>treeName</u>...
              Releases  one of more trees.  The Tcl command associated with <u>treeName</u> is also removed.  Trees are
              reference counted.  The internal tree data object isn't destroyed until no one else is  using  the
              tree.

       <b>tree</b> <b>names</b> ?<u>pattern</u>?
              Returns  the names of all tree objects.  if a <u>pattern</u> argument is given, then the only those trees
              whose name matches pattern will be listed.

       <b>tree</b> <b>op</b> <u>subcmd</u> ?<u>subsubcmd</u> <u>...</u>? <u>treeName</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
              Provide direct calls to sub-commands, without going through the object command.  Aside  from  self
              documentating, it allows wize to provide support checked tree calls.

</pre><h4><b>NODE</b> <b>IDS</b> <b>AND</b> <b>TAGS</b></h4><pre>
       Nodes  in  a  tree  object may be referenced by id or by tag.  Each node has a unique serial number or id
       that is assigned to it at creation. The id of an node never changes or is reused unless all  nodes  in  a
       tree are delete.

       A node may also have any number of tags associated with it.  A tag is just a string of characters, and it
       may  take  any  form but can not start with an integer.  For example, "<b>x123</b>" is valid, but "<b>123x</b>" is not.
       The same tag may be associated with one or multiple nodes (ranges or <u>tagnode</u>).  Ranges are commonly  used
       to group nodes in various interesting ways.

       Commands that take a <u>tagnode</u> can operate on ranges and will accept either a tag or a list of zero or more
       integer  node  numbers.   A  node-list may contain only integers, and can not have leading spaces.  Node-
       lists simplify the use of iterating commands because it avoids excessive use of <b>eval</b>.

       There are four built-in or psuedo tags:

              <b>all</b>       Applies to every node in the tree.

              <b>nonroot</b>   Applies to every node in the tree except the root node.

              <b>rootchildren</b>
                        Applies to every node in the tree whose parent is the root node.

              <b>root</b>      Managed automatically by the tree object, <b>root</b> specifies the node that is currently  set
                        as the root node for the tree.

       When specifying nodes in tree object commands, if the specifier is an integer then it is assumed to refer
       to  the single node with that id.  If the specifier is not an integer, then it is assumed to refer to all
       of the nodes in the tree that have a tag matching the specifier.   The  symbol  <u>node</u>  is  used  below  to
       indicate  that  an  argument  specifies  either  an id or a tag that selects a single node.  A <u>tagnode</u> is
       either a tag that selects a group of nodes, or it's a list of zero or more integer  node  numbers.   Many
       tree  commands only operate on a single node at a time; if <u>node</u> is specified in a way that names multiple
       items, then an error "refers to more than one node" is generated.

</pre><h4><b>NODE</b> <b>MODIFIERS</b></h4><pre>
       You can also specify node in relation to another node by appending one or more modifiers to the  node  id
       or  tag  after  <b>-&gt;</b>.   A  modifier  refers  to  a  node  in  relation to the specified node.  For example,
       "<b>root-&gt;firstchild</b>" selects the first subtree of the root node.

       The following modifiers are available:

              <b>firstchild</b>
                        Selects the first child of the node.

              <b>lastchild</b> Selects the last child of the node.

              <b>nextnode</b>  Selects the next node in preorder to the node.

              <b>nextsibling</b>
                        Selects the next sibling of the node.

              <b>parentnode</b>
                        Selects the parent of the node.

              <b>prevnode</b>  Selects the previous node in preorder to the node.

              <b>prevsibling</b>
                        Selects the previous sibling of the node.

              <b>maxnode</b>   The maximum node number.

              "<u>label</u>"

              Â´<u>label</u>'

              <u>label</u>     Selects the child node whose label is <u>label</u>.   Enclosing  <u>label</u>  in  quotes  (double  or
                        single) supports labels with embedded spaces and prevents matching reserved words (eg. a
                        node  labeled  "parentnode").   If  mulitiple child nodes have the same label, the first
                        matching node is used.

       It's an error if the node can't be found.  For example, <b>lastchild</b> and <b>firstchild</b> will generate errors  if
       the node has no children.  The exception to this is the <b>index</b> operation which returns -1, allowing you to
       test if a modifier is valid.

</pre><h4><b>TREE</b> <b>OPERATIONS</b></h4><pre>
       Once  you  create  a tree object, you can use its Tcl command to query or modify it.  The general form is
       <u>treeName</u> <u>operation</u> ?<u>arg</u>?...  Both <u>operation</u> and  its  arguments  determine  the  exact  behavior  of  the
       command.  The operations available for trees are listed below.

       <u>treeName</u> <b>ancestor</b> <u>node1</u> <u>node2</u>
              Returns  the mutual ancestor of the two nodes <u>node1</u> and <u>node2</u>.  The ancestor can be one of the two
              nodes.  For example, if <u>node1</u> and <u>node2</u> are the same nodes, their ancestor is <u>node1</u>.

       <u>treeName</u> <b>append</b> <u>node</u> <u>key</u> <u>string</u> ?<u>string</u> <u>...</u>?
              Append one or more strings to node/key value.

       <u>treeName</u> <b>appendi</b> <u>tagnode</u> <u>key</u> <u>string</u> ?<u>string</u> <u>...</u>?
              The same as <b>append</b> but accepts a multi-node tag and an undefined key will be  initialized  to  {}.
              Returns the number of nodes updated.

       <u>treeName</u> <b>apply</b> <u>node</u> ?<u>switches</u>?
              Runs  commands for all nodes matching the criteria given by <u>switches</u> for the subtree designated by
              <u>node</u>.  By default all nodes match, but you can set switches to narrow the match.   This  operation
              differs  from  <b>find</b>  in two ways: 1) Tcl commands can be invoked both pre- and post-traversal of a
              node and 2) the tree is always traversed in depth first order.

              The <b>-exact</b>, <b>-glob</b>, and <b>-regexp</b> switches indicate both what kind of pattern matching to perform and
              the pattern.  By default each pattern will be compared with the node label.  You can set more than
              one of these switches.  If any of the patterns match (logical or), the node matches.  If the  <b>-key</b>
              switch is used, it designates the data field to be matched.

              The valid switches are listed below:

              <b>-depth</b> <u>number</u>
                        Descend  at  most  <u>number</u> (a non-negative integer) levels If <u>number</u> is <b>1</b> this means only
                        apply the tests to the children of <u>node</u>.

              <b>-exact</b> <u>string</u>
                        Matches each node using <u>string</u>.  The node must match <u>string</u> exactly.

              <b>-glob</b> <u>string</u>
                        Test each node to <u>string</u> using global pattern matching.  Matching is done in  a  fashion
                        similar to that used by <b>string</b> <b>match</b>.

              <b>-invert</b>   Invert the results of the pattern matching of <b>-name</b>.

              <b>-isleaf</b>   Only test nodes with no children.

              <b>-istree</b>   Only test nodes with children.

              <b>-key</b> <u>key</u>

              <b>-keyglob</b> <u>key</u>

              <b>-keyregexp</b> <u>key</u>

              <b>-keyexact</b> <u>key</u>
                        If  pattern matching is selected (using the <b>-exact</b>, <b>-glob</b>, or <b>-regexp</b> switches), compare
                        the values of the data field keyed by <u>key</u> instead of the node's label.   If  no  pattern
                        matching switches are set, then any node with this data key will match.  The field names
                        may also be patterns using <b>-keyglob</b>, etc.

              <b>-nocase</b>   Ignore case when matching patterns.

              <b>-precommand</b> <u>command</u>
                        Invoke <u>command</u> for each matching node.  Before <u>command</u> is invoked, the id of the node is
                        appended.   You  can  control  processing  by  the  return value of <u>command</u>.  If <u>command</u>
                        generates an error, processing stops and the <b>find</b> operation returns an  error.   But  if
                        <u>command</u> returns <b>break</b>, then processing stops, no error is generated.  If <u>command</u> returns
                        <b>continue</b>, then processing stops on that subtree and continues on the next.

              <b>-postcommand</b> <u>command</u>
                        Invoke <u>command</u> for each matching node.  Before <u>command</u> is invoked, the id of the node is
                        appended.   You  can  control  processing  by  the  return value of <u>command</u>.  If <u>command</u>
                        generates an error, processing stops and the <b>find</b> operation returns an  error.   But  if
                        <u>command</u> returns <b>break</b>, then processing stops, no error is generated.  If <u>command</u> returns
                        <b>continue</b>, then processing stops on that subtree and continues on the next.

              <b>-regexp</b> <u>string</u>
                        Test each node using <u>string</u> as a regular expression pattern.

              <b>-tag</b> <u>string</u>
                        Only test nodes that have the tag <u>string</u>.

              <b>-usepath</b>  Use  the  node's  full  path  when  comparing  nodes.  The node's full path is a list of
                        labels, starting from the root of each ancestor and the node label.  The default  is  to
                        compare only the node label.

       <u>treeName</u> <b>attach</b> ?<b>-notags</b>? ?<u>treeObject</u>?
              Queries  or  attaches to an existing tree object <u>treeObject</u>.  This is primarly used where the tree
              object was previously created via the C API (eg.  via TreeView).  The current tree associated with
              <u>treeName</u> is discarded.  In addition, the current set of tags,  notifier  events,  and  traces  are
              removed.  If <b>-notags</b> is given, tags will not be shared.

       <u>treeName</u> <b>children</b>  ?<b>-labels</b>? <u>node</u> ?<u>first</u>? ?<u>last</u>?
              Returns  a  list  of  children for <u>node</u>.  If <u>node</u> is a leaf, then an empty string is returned.  If
              <u>first</u> and/or <u>last</u> are given they are the integer index of the children to display.  If the <b>-labels</b>
              option is used, labels are returned instead of the nodes.

       <u>treeName</u> <b>copy</b> <u>srcNode</u> ?<u>destTree</u>? <u>parentNode</u> ?<u>switches</u>?
              Copies <u>srcNode</u> into <u>parentNode</u>. Both nodes <u>srcNode</u> and <u>parentNode</u> must already exist.  The  id  of
              the  new  node  is  returned.  You  can  copy from one tree to another.  If a <u>destTree</u> argument is
              present, it indicates the  name  of  the  destination  tree.   By  default  both  the  source  and
              destination trees are the same. The valid <u>switches</u> are listed below:

              <b>-label</b> <u>string</u>
                     Label <u>destNode</u> as <u>string</u>.  By default, <u>destNode</u> has the same label as <u>srcNode</u>.

              <b>-overwrite</b>
                     Overwrite  nodes  that  already  exist.   Normally  nodes are always created, even if there
                     already exists a node by the same name.  This switch indicates  to  add  or  overwrite  the
                     node's data fields.

              <b>-recurse</b>
                     Recursively  copy  all  the subtrees of <u>srcNode</u> as well.  In this case, <u>srcNode</u> can't be an
                     ancestor of <u>destNode</u> as it would result in a cyclic copy.

              <b>-reverse</b>
                     Reverse the direction of the copy.

              <b>-tags</b>  Copy tag information.  Normally the following node is copied: its label  and  data  fields.
                     This indicates to copy tags as well.

       <u>treeName</u> <b>create</b> ?<u>switches</u>?
              Cause the creation of zero or more nodes.  Exactly one of <b>-num</b>, <b>-nodes</b> or <b>-path</b> is required.  This
              can  create all nodes in a given <b>-path</b> or efficiently populate a tree with large numbers of nodes.
              The return values is the id of the last created node (or <b>-path</b>  element).   The  valid  flags  for
              <u>switches</u> are described below.

              <b>-fixed</b>    Set the fixed flag.

              <b>-data</b> <u>list</u>
                        Data to set in each node.

              <b>-labelstart</b> <u>number</u>
                        The label generated nodes is to use a sequence number starting from <u>number</u>.  The default
                        is to just use the node id.

              <b>-nodes</b> <u>list</u>
                        List of nodes ids to create.  The <b>-offset</b> option can specify a constant to add.

              <b>-num</b> <u>number</u>
                        The number of nodes to create.

              <b>-offset</b> <u>number</u>
                        Number  to  add  to  each  element in <b>-nodes</b>.  For example, if loading sqlite rowids you
                        should use 1.  The default is 0.

              <b>-parent</b> <u>node</u>
                        The <u>node</u> to insert children into.  The default is the root node.

              <b>-path</b> <u>pathList</u>
                        Verify that a path exists and create any missing nodes.   Uses  labels  in  <u>pathList</u>  to
                        lookup  nodes,  creating  them  if  not  found.  The id for the last node in the path is
                        returned (created or not).

              <b>-pos</b> <u>number</u>
                        The position where to insert child nodes.  The default is -1, meaning append.

              <b>-prefix</b> <u>str</u>
                        String prefix to add to each nodes label.

              <b>-start</b> <u>number</u>
                        Node nuber to start from when using <b>-num</b>.  The default is 1.

              <b>-tags</b> <u>tagList</u>
                        List of tags to add to each newly created node.

       <u>treeName</u> <b>degree</b> <u>node</u>
              Returns the number of children of <u>node</u>.

       <u>treeName</u> <b>delete</b> <u>node</u>...
              Recursively deletes one or more nodes from the  tree.   The  node  and  all  its  descendants  are
              removed.    The  one  exception is the root node.  In this case, only its descendants are removed.
              The root node will remain.  Any tags or traces on the nodes are released.

       <u>treeName</u> <b>depth</b> <u>node</u>
              Returns the depth of the node.  The depth is the number of steps from the node to the root of  the
              tree.  The depth of the root node is <b>0</b>.

       <u>treeName</u> <b>dictset</b> ?<u>bool</u>?
              Get  or set the dictset flag for the tree which causes any set of an array sub-fields to force the
              value to type dict.  Unlike array types, dicts preserve the order of elements.   Setting  this  to
              one has the same effect as using the <b>-dictset</b> flag at tree creation time.

       <u>treeName</u> <b>dump</b> <u>node</u> ?<u>switches</u>?
              Save  tree  data  for  <u>node</u>  and  its descendants.  With the <b>-file</b> option, output goes to the file
              <u>fileName</u> (this is unsupported in a safe interp).  With the <b>-channel</b>  option,  data  is  output  to
              channel <u>chan</u>.  If neither option is given, the dump is returned as data.

              The  subtree designated by <u>node</u> is traversed to obtain the following information for each node: 1)
              the node's path relative to <u>node</u>, 2) a sublist  key  value  pairs  representing  the  node's  data
              fields,  and  3) a sublist of tags.  and 4) the label This list returned can be used later to copy
              or restore the tree with the <b>restore</b> operation.

              The valid <u>switches</u> are listed below.

              <b>-channel</b> <u>chan</u>
                     Obtain data from from the given channel <u>chan</u>.  The channel is not closed afterwards.

              <b>-file</b> <u>fileName</u>
                     Obtain data from from the file.  <u>fileName</u>.  This options is unsupported in a safe interp.

              <b>-keys</b> <u>list</u>
                     A list of patterns of matching keys to be dumped.

              <b>-skipkeys</b> <u>list</u>
                     A list of patterns of matching keys not to be dumped.

              <b>-tag</b> <u>pattern</u>
                     A pattern match for tags to include in a node dump.

              <b>-skiptag</b> <u>pattern</u>
                     A pattern match for tags to not include in a node dump.

              <b>-notags</b>
                     Do not restore any tags

              <b>-nopath</b>
                     To save space, do not dump the full path for each node.  Instead output periods for all but
                     the last path element.  Full paths are used only for partial restores.

       <u>treeName</u> <b>exists</b> <u>node</u> ?<u>key</u>?
              Indicates if <u>node</u> exists in the tree.  If  a  <u>key</u>  argument  is  present  then  the  command  also
              indicates if the named data field exists.

       <u>treeName</u> <b>find</b> ?<u>switches</u>?
              Finds for all nodes matching the criteria given by <u>switches</u> for the subtree designated by <u>node</u>.  A
              list  of  the selected nodes is returned.  By default all nodes match, but you can set switches to
              narrow the match.

              The <b>-exact</b>, <b>-glob</b>, and <b>-regexp</b> switches indicate what kind of  pattern  matching  to  perform  for
              <b>-name</b>.   By default the pattern will be compared with the node label.  If the <b>-key</b> switch is used,
              it designates the data field to be matched.

              The order in which the nodes are traversed is controlled by  the   <b>-order</b>  switch.   The  possible
              orderings are <b>preorder</b>, <b>postorder</b>, <b>inorder</b>, and <b>breadthfirst</b>.  The default is <b>preorder</b>.

              The valid switches are listed below:

              <b>-addtag</b> <u>string</u>
                        Add  the tag <u>string</u> to each selected node.  The tag will be created even if no nodes are
                        tagged.

              <b>-column</b> <u>key</u>
                        Use value with field given by <u>key</u>.  Like the <b>treeview</b> <b>find</b> <b>-column</b> option, this key  may
                        contain an array referrence.

              <b>-cmdargs</b> <u>columns</u>
                        Specify columns whose values are to be appended to <b>-command</b>.

              <b>-command</b> <u>command</u>
                        Invoke <u>command</u> for each matching node.  Before <u>command</u> is invoked, the id of the node is
                        appended.   You  can  control  processing  by  the  return value of <u>command</u>.  If <u>command</u>
                        generates an error, processing stops and the <b>find</b> operation returns an  error.   But  if
                        <u>command</u> returns <b>break</b>, then processing stops, no error is generated.  If <u>command</u> returns
                        <b>continue</b>,  then  processing stops on that subtree and continues on the next.  If <u>command</u>
                        returns <b>return</b>, then the returned integer is used to indicate  1  for  match  or  0  for
                        mismatch.

              <b>-count</b>    Just return the number of matches.

              <b>-depth</b> <u>number</u>
                        Include only nodes with level equal to <u>number</u>.

              <b>-exact</b>    Matches each node exactly.

              <b>-exec</b> <u>script</u>
                        Specifies  a  Tcl  script  to  be  evaluated  for  each matching node.  If <b>-var</b> was also
                        specified, that variable is set with the value of the node id  before  each  evaluation.
                        Otherwise,  percent  sustitutions  are  performed: note this is much less efficient than
                        using either <b>-var</b> or <b>-command</b>

                        The result of each eval gets appended to the return list, unless  the  script  issues  a
                        CONTINUE, in which case that node is skipped.

                        The available percent substitutions on <u>string</u> are:

                        <b>%#</b>   The id of the node.

                        <b>%W</b>   The pathname of the tree.

                        <b>%p</b>   The label of the node.

                        <b>%P</b>   The full pathname of the node.

                        <b>%R</b>   The -&gt; delimited path from root, eg. "root-&gt;able-&gt;baker-&gt;charlie"

                        <b>%r</b>   The -&gt; delimited path from 0, eg. "0-&gt;able-&gt;baker-&gt;charlie"

                        <b>%T</b>   The dot delimited tag path eg. ".able.baker.charlie"

                        <b>%V</b>   The value if using <b>-key</b> or the label otherwise.

                        <b>%D</b>   The data for the node, ie. like that returned from <b>get</b>.

                        <b>%%</b>   Translates to a single percent.

              <b>-glob</b>     Test  each node using global pattern matching.  Matching is done in a fashion similar to
                        that used by the <b>string</b> <b>match</b>.

              <b>-invert</b>   Invert the pattern matching of <b>-name</b>.

              <b>-isarray</b>  Only test nodes where the specified <b>-key</b> value is an array.  Can not be used with <b>-name</b>.
                        The <b>-invert</b> flag will invert the meaning of the check.  Note that this will  attempt  to
                        convert the key value in each traversed node into an array type.

              <b>-isempty</b>  Only match nodes where the specified <b>-column</b> key value was unset.

              <b>-isfixed</b>  Only test nodes that have used <b>fixed</b> <b>1</b>.

              <b>-isleaf</b>   Only test nodes with no children.

              <b>-isnotfixed</b>
                        Only test nodes that have not used <b>fixed</b> <b>1</b>.

              <b>-istree</b>   Only test nodes with children.

              <b>-keycount</b> <u>num</u>
                        Only test if number of keys is equal to <u>num</u>.

              <b>-key</b> <u>key</u>

              <b>-keyglob</b> <u>key</u>

              <b>-keyregexp</b> <u>key</u>

              <b>-keyexact</b> <u>key</u>
                        Compare  the  values  of  the data field keyed by <u>key</u> instead of the node's label. If no
                        <b>-name</b> pattern is used then any node with this data key will match.  The  key  names  may
                        also be patterns using <b>-keyglob</b>, etc.

              <b>-limit</b> <u>number</u>
                        Stop processing after <u>number</u> (a positive integer) matches.

              <b>-maxdepth</b> <u>number</u>
                        Include only nodes at level <u>number</u> or less.

              <b>-mindepth</b> <u>number</u>
                        Include only nodes at level <u>number</u> or greater.

              <b>-name</b> <u>string</u>
                        The name to use for pattern matching.

              <b>-nocase</b>   Ignore case when matching patterns.

              <b>-nodes</b> <u>tagnode</u>
                        Search  only  in  <u>tagnode</u>,  which  is  either  a tag or a list of nodes ids.  This makes
                        possible nested searches.  Note this option is incompatible with <b>-top</b> and <b>-notop</b>.

              <b>-notop</b>    Exclude the <b>-top</b> or starting node.

              <b>-order</b> <u>string</u>
                        Traverse the tree and process nodes according to  <u>string</u>.  <u>String</u>  can  be  one  of  the
                        following:

                        <b>breadthfirst</b>
                                  Process  the  node  and  the  subtrees at each sucessive level. Each node on a
                                  level is processed before going to the next level.

                        <b>inorder</b>   Recursively process the nodes of the first subtree, the node itself,  and  any
                                  the remaining subtrees.

                        <b>postorder</b> Recursively process all subtrees before the node.

                        <b>preorder</b>  Recursively process the node first, then any subtrees (default).

              <b>-usepath</b>  Use  the node's full path when doing the comparison.  The default is to compare only the
                        node label.

              <b>-regexp</b>   Test each node using regular expression pattern matching.

              <b>-reldepth</b> Change the meaning of <b>-depth</b>, <b>-mindepth</b> and <b>-maxdepth</b> to be relative to the <b>-top</b> node.

              <b>-return</b> <u>key</u>
                        Return the value of the given <u>key</u>, or the empty string if none.  If the given <u>key</u> is the
                        empty string, the node label will be returned.  If no value was found and the given  <u>key</u>
                        starts  with  a  percent  returns  the  sustitution  as  per <b>-exec</b>.  Note that a percent
                        substitution longer than 2 chars will append values as list elements.

              <b>-strict</b>   Generate an error if a given key value is unset when using <b>-return</b>.

              <b>-top</b> <u>node</u> Search is only at <u>node</u> and it's descendants.  The default is the root node.

              <b>-var</b> <u>variable</u>
                        A variable to set with the node id before each iteration of the <b>-exec</b> script.

              <b>-withouttag</b> <u>string</u>
                        Only test nodes that don't have the tag <u>string</u>.

              <b>-withtag</b> <u>string</u>
                        Only test nodes that have the tag <u>string</u>.

       <u>treeName</u> <b>findchild</b> <u>node</u> <u>label</u>
              Searches for a child node <u>label</u> in <u>node</u>.   The  id  of  the  child  node  is  returned  if  found.
              Otherwise <b>-1</b> is returned.  This is the same as using <b>index</b> <u>node-&gt;label</u>.

       <u>treeName</u> <b>firstchild</b> <u>node</u>
              Returns  the  id  of  the  first  child in the <u>node</u>'s list of subtrees.  If <u>node</u> is a leaf (has no
              children), then <b>-1</b> is returned.

       <u>treeName</u> <b>fixed</b> <u>node</u> ?<u>isfixed</u>?
              Get or set the fixed key-fields flag for a node.  New key-fields can be added to a  node  only  if
              fixed  is  0  (the  default) If <u>node</u> is given as an empty string, operates on the tree flag.  Note
              that copied and restored nodes do not preserve the fixed state.

       <u>treeName</u> <b>foreach</b> <u>var</u> <u>tagnode</u> <u>script</u>
              Provides a <b>foreach</b> loop for tree.  For each node in <u>tagnode</u> the node-id is  assigned  to  <u>var</u>  and
              then  <u>script</u>  is  evaluated.  The  <u>tagnode</u>  is either a tag or a list of nodes as described in the
              section <b>NODE</b> <b>IDS</b> <b>AND</b> <b>TAGS</b> above.

       <u>treeName</u> <b>get</b> <u>node</u> ?<u>key</u>? ?<u>defaultValue</u>?
              Returns a list of key-value pairs of data for <u>node</u>.  If <u>key</u> is present, then only  the  value  for
              that  particular data field is returned.  It's normally an error if <u>node</u> does not contain the data
              field <u>key</u>.  But if you provide a <u>defaultValue</u> argument, this value is returned instead (<u>node</u>  will
              still  not  contain  <u>key</u>).   This feature can be used to access a data field of <u>node</u> without first
              testing if it exists.  This operation may trigger <b>read</b> data traces.

       <u>treeName</u> <b>incr</b> <u>node</u> <u>key</u> ?<u>amount</u>?
              Increment value by 1 or given <u>amount</u> and return the value.  The incr operation normally  tries  to
              use integers, but uses doubles when one of value or <u>amount</u> is a double.

       <u>treeName</u> <b>incri</b> <u>tagnode</u> <u>key</u> ?<u>amount</u>?
              The  same  as  <b>incr</b>  but  accepts  a multi-node tag and an undefined key will be initialized to 0.
              Returns the number of nodes updated.

       <u>treeName</u> <b>index</b> <u>node</u>
              Returns the id of <u>node</u>.  In addition to standard node id form, <u>node</u> can also be a path (a list  of
              labels from the root) as returned by the <b>path</b> command.  If <u>node</u> is invalid, then <b>-1</b> is returned.

       <u>treeName</u> <b>insert</b> <u>parent</u> ?<u>switches</u>?
              Inserts  a  new  node into parent node <u>parent</u>.  The id of the new node is returned.  The following
              switches are available:

              <b>-after</b> <u>child</u>
                        Position <u>node</u> after <u>child</u>.  The node <u>child</u> must be a child of <u>parent</u>.

              <b>-before</b> <u>child</u>
                        Position <u>node</u> before <u>child</u>.  The node <u>child</u> must be a child of <u>parent</u>.

              <b>-data</b> <u>dataList</u>
                        Sets the value for each data field in <u>dataList</u> for the new node. <u>DataList</u> is a  list  of
                        key-value pairs.  May not be used in conjuction with <b>-names</b> or  <b>-values</b>.

              <b>-fixed</b> <u>bool</u>
                        If  <u>bool</u>  is  1, set <b>fixed</b> field mode after initializing the key/value pairs from <b>-data</b>.
                        This disallows creation of new key fields after the node is created.  If not given,  the
                        tree default for fixed is used.

              <b>-label</b> <u>string</u>
                        Designates  the  labels  of  the node as <u>string</u>.  By default, nodes are labeled as <b>0</b>, <b>1</b>,
                        etc.

              <b>-names</b> <u>nameList</u>
                        The names for the data fields.  This must have the same length as <b>-values</b>, and  may  not
                        be used in conjuction with <b>-data</b>.

              <b>-node</b> <u>id</u>  Designates  the  id  for  the node.  Normally new ids are automatically generated.  This
                        allows you to create a node with a specific id.  It is an error if  the  id  is  already
                        used by another node in the tree.

              <b>-pos</b> <u>number</u>
                        Inserts  the  node into <u>parent</u>'s list of children at position <u>number</u>.  The default is to
                        append.

              <b>-pretags</b> <u>tagList</u>
                        Adds each tag in <u>tagList</u> to the new node, before data is added.  Unlike <b>-tags</b>, traces on
                        these tags will fire on key data during the insert.

              <b>-tags</b> <u>tagList</u>
                        Adds each tag in <u>tagList</u> to the new node. <u>TagList</u> is a list of tags, so be careful if  a
                        tag has embedded space.

              <b>-values</b> <u>valueList</u>
                        The  values  for the data fields.  This must have the same length as <b>-names</b>, and may not
                        be used in conjuction with <b>-data</b>.

       <u>treeName</u> <b>is</b> <u>property</u> <u>args</u>
              Indicates the property of a node. Both <u>property</u> and <u>args</u>  determine  the  property  being  tested.
              Returns <b>1</b> if true and <b>0</b> otherwise.  The following <u>property</u> and <u>args</u> are valid:

              <b>ancestor</b> <u>node1</u> <u>node2</u>
                        Indicates if <u>node1</u> is an ancestor of <u>node2</u>.

              <b>before</b> <u>node1</u> <u>node2</u>
                        Indicates if <u>node1</u> is before <u>node2</u> in depth first traversal.

              <b>leaf</b> <u>node</u> Indicates if <u>node</u> is a leaf (it has no subtrees).

              <b>root</b> <u>node</u> Indicates if <u>node</u> is the designated root.  This can be changed by the <b>root</b> operation.

       <u>treeName</u> <b>ismodified</b> ?<u>nodeOrTag</u>? ?<u>isflag</u>?
              Get  or  set  modified state for the tree or nodes.  With no args returns modified state for tree.
              With one args returns modified state for a node.  With two args set modified state for one or more
              nodes.  In the last case, where ?<u>nodeOrTag</u>? is the tag <b>all</b>, the state for the tree is also set.

              Newly created nodes are  always  considered  to  be  modified  until  explicitly  cleared.   After
              clearing, subsequent updates to keys or tags will toggle the node (and tree) modified again.

       <u>treeName</u> <b>isset</b> <u>node</u> <u>key</u>
              Return 1 if key is set in node.

       <u>treeName</u> <b>keys</b> <u>node</u> ?<u>tagnode</u> <u>...</u>?
              Return  list  of  unique  keys  for  all of the given nodes in <u>tagnode</u>.  Keys are in no particular
              order.  Accepts nodes and tags or all.  See also <b>names</b>.

       <u>treeName</u> <b>label</b> <u>node</u> ?<u>newLabel</u>?
              Returns the label of the node designated by <u>node</u>.  If <u>newLabel</u> is present, the node  is  relabeled
              using it as the new label.

       <u>treeName</u> <b>lappend</b> <u>node</u> <u>key</u> <u>value</u> ?<u>value</u> <u>...</u>?
              Append one or more list values to node/key value.

       <u>treeName</u> <b>lappendi</b> <u>tagnode</u> <u>key</u> <u>value</u> ?<u>value</u> <u>...</u>?
              The  same  as <b>lappend</b> but accepts a multi-node tag and an undefined key will be initialized to {}.
              Returns the number of nodes updated.

       <u>treeName</u> <b>lastchild</b> <u>node</u>
              Returns the id of the last child in the <u>node</u>'s list of subtrees.   If  <u>node</u>  is  a  leaf  (has  no
              children), then <b>-1</b> is returned.

       <u>treeName</u> <b>modify</b> <u>tagnode</u> <u>key</u> <u>value</u> ?<u>key</u> <u>value</u>...?
              Update  one  or  more  fields  in  one  or  more nodes in <u>tagnode</u>.  As with <b>set</b>, <u>node</u> can be a tag
              referring to multiple nodes.  This is identical to <b>set</b>, except an error is thrown if  any  of  the
              key  fields do not exist.  Despite the error, all nodes that do have said fields get updated.  For
              modifying a single node, see <b>update</b>.

       <u>treeName</u> <b>move</b> <u>node</u> <u>newParent</u> ?<u>switches</u>?
              Moves <u>node</u> into <u>newParent</u>. <u>Node</u> is appended to the list children of <u>newParent</u>.  <u>Node</u> can not be an
              ancestor of <u>newParent</u>.  The valid flags for <u>switches</u> are described below.

              <b>-after</b> <u>child</u>
                        Position <u>node</u> after <u>child</u>.  The node <u>child</u> must be a child of <u>newParent</u>.

              <b>-before</b> <u>child</u>
                        Position <u>node</u> before <u>child</u>.  The node <u>child</u> must be a child of <u>newParent</u>.

              <b>-pos</b> <u>number</u>
                        Inserts <u>node</u> into <u>parent</u>'s list of children at position <u>number</u>. The  default  is  -1  to
                        append the node.

       <u>treeName</u> <b>names</b> <u>node</u> ?<u>key</u>? ?<u>pattern</u>?
              Return  key  names  for  <u>node</u>, in the order defined (if possible).  If a key is given, attempts to
              return ARRAY fields (see DICT-ARRAYS).  If a pattern is given, the array keys are limited to those
              matching the glob pattern.  An error is thrown if the convert to array fails (ie.  list-length  is
              odd).  The <b>type</b> command can be used to query the type.  See also <b>values</b>.

       <u>treeName</u> <b>next</b> <u>node</u>
              Returns  the  next  node from <u>node</u> in a preorder traversal.  If <u>node</u> is the last node in the tree,
              then <b>-1</b> is returned.

       <u>treeName</u> <b>nextsibling</b> <u>node</u>
              Returns the node representing the next subtree from <u>node</u> in its parent's  list  of  children.   If
              <u>node</u> is the last child, then <b>-1</b> is returned.

       <u>treeName</u> <b>nodeseq</b> ?<u>start</u>?
              Get  or set the <u>start</u> sequence number for subsequent node insertions not using <b>-node</b>.  The default
              is 0.

       <u>treeName</u> <b>notify</b> <u>args</u>
              Manages notification events that indicate that the tree  structure  has  been  changed.   See  the
              <b>NOTIFY</b> <b>OPERATIONS</b> section below.

       <u>treeName</u> <b>oldvalue</b> ?<u>newvalue</u>?
              Return the value from before the last (untraced) change operation.  This is used primarly by write
              traces  wishing  to restore a key to it's pre-write value (eg. read-only variables).  The oldvalue
              is saved internally everytime  a  change  operation  occurs  to  a  key  value  by  deferring  its
              deallocation.  Changes made during node traces do not affect oldvalue.

              If  <u>newvalue</u>  is provided, the current value of oldvalue is discarded and replaced. This is useful
              really only for releasing large objects.

       <u>treeName</u> <b>parent</b> <u>node</u>
              Returns the parent node of <u>node</u>.  If <u>node</u> is the root of the tree, then <b>-1</b> is returned.

       <u>treeName</u> <b>path</b> <u>node</u> ?<u>delim</u>? ?<u>prefix</u>?
              Returns the full path (from root) of <u>node</u> using the node labels.  If <u>delim</u> is not  specified,  the
              result  is a list.  Otherwise, the result is a string starting with <u>prefix</u> and each element of the
              path separated by <u>delim</u>.  This latter form is useful for building tags like: <b>.able.baker</b>

       <u>treeName</u> <b>position</b>  ?<b>-sort</b>? ?<b>-format</b> <u>ftype</u>? <u>node</u> ?<u>node</u> ...?
              Returns the position of the node(s) in its parent's list of children.  Positions are numbered from
              0.  The position of the root node is always 0.  The value of <u>ftype</u> is one of: <b>position</b>  <b>parent-at-</b>
              <b>position</b> <b>id+position</b> <b>id+parent-at-position</b>.

       <u>treeName</u> <b>previous</b> <u>node</u>
              Returns  the  previous  node  from <u>node</u> in a preorder traversal.  If <u>node</u> is the root of the tree,
              then <b>-1</b> is returned.

       <u>treeName</u> <b>prevsibling</b> <u>node</u>
              Returns the node representing the previous subtree from <u>node</u> in its parent's list of children.  If
              <u>node</u> is the first child, then <b>-1</b> is returned.

       <u>treeName</u> <b>restore</b> <u>node</u> <u>switches</u>
              Performs the inverse function of the <b>dump</b> operation, restoring nodes to the tree.  The  format  of
              the  input  data  is  exactly  what  is  returned  by  the <b>dump</b> operation.  It's a list containing
              information for each node to be restored.  The information consists of 1) the relative path of the
              node, 2) a sublist of key value pairs representing the node's data, 3) a  list  of  tags  for  the
              node,  and  4) the label.  Nodes are created starting from <u>node</u>. Nodes can be listed in any order.
              If a node's path describes ancestor nodes that  do  not  already  exist,  they  are  automatically
              created.

              The valid <u>switches</u> are listed below.  Exactly one of <b>-channel</b>,  <b>-file</b> or  <b>-data</b> must be specified.

              <b>-addtags</b>
                     List  of  tags  to add to each node restored node.  Each tag will be created only if a node
                     loaded.

              <b>-channel</b> <u>chan</u>
                     Obtain data from from the given channel <u>chan</u>.  The channel is not closed afterwards.

              <b>-data</b> <u>string</u>
                     Data input is from the given <u>string</u>.

              <b>-file</b> <u>fileName</u>
                     Obtain data from from the file.  <u>fileName</u>.  This options is unsupported in a safe interp.

              <b>-keys</b> <u>list</u>
                     A list of patterns of matching keys to be restored.

              <b>-skipkeys</b> <u>list</u>
                     A list of patterns of matching keys not to be restored.

              <b>-tag</b> <u>pattern</u>
                     A pattern match for tags to include in a node restore.

              <b>-skiptag</b> <u>pattern</u>
                     A pattern match for tags to not include in a node restore.

              <b>-notags</b>
                     Do not restore any tags

              <b>-overwrite</b>
                     Overwrite nodes that already exist.  Normally nodes  are  always  created,  even  if  there
                     already exists a node by the same name.  This switch indicates to overwrite existing node's
                     data fields.

       <u>treeName</u> <b>root</b> ?<u>node</u>?
              Returns  the  id  of  the root node.  Normally this is node <b>0</b>.  If a <u>node</u> argument is provided, it
              will become the new root of the tree. This lets you temporarily work within a subset of the  tree.
              Changing root affects operations such as <b>next</b>, <b>path</b>, <b>previous</b>, etc.

       <u>treeName</u> <b>set</b> <u>tagnode</u> <u>key</u> <u>value</u> ?<u>key</u> <u>value</u>...?
              Sets  one  or  more  data  fields in <u>node</u>. <u>tagode</u> may be a tag that represents several nodes and a
              count of the number of nodes updated is returned.  <u>Key</u> is the name of the data field to be set, or
              an array-like reference such as <b>field(subkey)</b>.  See the <b>DICT-ARRAYS</b> section below.  <u>Value</u>  is  the
              respective keys value.  The  <u>Key</u>  will be created if it does not exists (see <b>modify</b>).

              The set operation triggers <b>write</b> and <b>create</b> data traces.

       <u>treeName</u> <b>size</b> <u>node</u>
              Returns  the  number of nodes in the subtree. This includes the node and all its descendants.  The
              size of a leaf node is 1.

       <u>treeName</u> <b>sort</b> <u>node</u> ?<u>switches</u>?
              Return nodes in sorted order.

              <b>-ascii</b>    Compare strings using the ASCII  collation order.

              <b>-command</b> <u>string</u>
                        Use command <u>string</u> as a comparison command.  To compare two  elements,  evaluate  a  Tcl
                        script  consisting  of  command with the five elements appended as additional arguments:
                        <u>the</u> <u>tree,</u> <u>node1,</u> <u>node1,</u> <u>label1,</u> <u>label2</u>.  The script should return an integer less  than,
                        equal to, or greater than zero if the first element is to be considered less than, equal
                        to, or greater than the second, respectively.

              <b>-decreasing</b>
                        Sort in decreasing order (largest items come first).

              <b>-dictionary</b>
                        Compare  strings using a dictionary-style comparison.  This is the same as <b>-ascii</b> except
                        (a) case is ignored except as a tie-breaker and (b)  if  two  strings  contain  embedded
                        numbers,  the  numbers compare as integers, not characters.  For example, in <b>-dictionary</b>
                        mode, bigBoy sorts between bigbang and bigboy, and x10y sorts between x9y and x11y.

              <b>-integer</b>  Compare the nodes as integers.

              <b>-key</b> <u>string</u>
                        Sort based upon the node's data  field  keyed  by  <u>string</u>.  Normally  nodes  are  sorted
                        according to their label.  label.

              <b>-real</b>     Compare the nodes as real numbers.

              <b>-recurse</b>  Recursively sort the entire subtree rooted at <u>node</u>.

              <b>-reorder</b>  Recursively sort subtrees for each node.  <b>Warning</b>.  Unlike the normal flat sort, where a
                        list of nodes is returned, this will reorder the tree.

              <b>-usepath</b>  Compare the full path of each node.  The default is to compare only the node label.

       <u>treeName</u> <b>sqlload</b> ?<u>switches</u>? <u>dbhfile</u> <u>sqlstmt</u>
              Load tree with the results of evaling the SQL in <u>sqlstmt</u> using <u>dbhfile</u>.  The evaluated SQL creates
              one tree-node per row result.  The returned value is the number of rows loaded.  <u>Dbhfile</u> is either
              an <b>sqlite3</b> database handle, or an <b>sqlite3</b> file.

              The <b>sqlload</b> command can populate a tree with 10k nodes about 7 times faster than <b>sqlite3</b> <b>eval</b>.  It
              also  preserves  NULL values and object types (eg. int or double) used internally by sqlite.  This
              eliminates later reconversion within tree.  See the <b>SQLLOAD</b> <b>EXAMPLE</b> below.

              The following switches are available:

              <b>-addtags</b> <u>taglist</u>
                        The tags in <u>taglist</u> to add to each inserted node.  Each tag will be created  only  if  a
                        node loaded.

              <b>-fixed</b>    Set the <b>fixed</b> flag to disallow new keys after creation.

              <b>-key</b> <u>name</u> Store  the  entire result in the key <u>name</u> instead of creating one key per column.  Array
                        notation can be used to then access  column  results.   This  is  more  efficent  as  it
                        initially  stores just one object per row.  Conversion to an array is at the first array
                        access (if that occurs).

              <b>-labelcol</b> <u>column</u>
                        The value of <u>column</u> is used as the label.  By default the label is the node id.

              <b>-maprowid</b> <u>num</u>
                        This option maps the node id to the rowid plus the constant <u>num</u>.  The key for <b>rowid</b> will
                        also not be created.  This is applicable only if <b>rowid</b> is returned in the result-set  of
                        <u>sqlstmt</u>.   If  <b>rowid</b> is not in the result set, this option is ignored.  If mapping fails
                        (because the tree already contains a requested node) the load will abort at  that  point
                        with  an  error.   Note  that <u>num</u> must be &gt;= 1 since sqlite rowids start from 0, but the
                        root node of the tree uses the node-id 0.

              <b>-max</b> <u>num</u>  The maximum number of rows to return.  The default is 100,000.  Note that SQL queries on
                        large tables should probably always use LIMIT.

              <b>-nullvalue</b> <u>string</u>
                        Define value to use for null values.  The default is no value, meaning do not set key if
                        value is null.  Note this is different from the sqlite Tcl extension which uses an empty
                        string for NULL.

              <b>-parent</b> <u>string</u>
                        The node where results are inserted as child nodes.  The default is the tree root.

              <b>-pathcol</b> <u>column</u>
                        Name of column containing the full path where node is to be created.   This  works  like
                        <b>-treecols</b>, but uses a singl columns.

              <b>-skipcols</b> <u>columns</u>
                        The given <u>columns</u> are not to be added as keys.  This is useful mostly in conjuction with
                        <b>-tagcol</b>, <b>-labelcol</b>, <b>-pathcol</b>.

              <b>-pos</b> <u>num</u>  Where to insert into parents list of children.  Default is -1, meaning to append.

              <b>-tagcol</b> <u>column</u>
                        The value of <u>column</u> is added as a tag.

              <b>-treecols</b> <u>columns</u>
                        Columns  whose  values  concatenated give the path of where node is to be created.  This
                        works like <b>-pathcol</b>, but uses multiple columns.

       <u>treeName</u> <b>sum</b> ?<u>switches</u>? <u>tagnode</u> <u>key</u> ?<u>key</u> <u>...</u>?
              Add values in key fields for all <u>tagnode</u> and return the sum.  Values  that  are  not  doubles  (or
              integer) are ignored.

              <b>-diff</b> <u>value</u>
                        Double  value difference to ignore and not do update for <b>-runtotal</b>.  This is unused when
                        using <b>-int</b>.

              <b>-force</b>    Force update <b>-runtotal</b> even if value was unchanged.  Normally, a check is made to  avoid
                        updating unchanged values.

              <b>-int</b>      Use and accept only integer values.

              <b>-runtotal</b> <u>key</u>
                        Place running total in the given key field (if changed).

              <b>-start</b> <u>num</u>
                        The start value for the sum: default is 0.

       <u>treeName</u> <b>supdate</b> <u>node</u> <u>key</u> <u>value</u> ?<u>key</u> <u>value</u>...?
              Like  <b>update</b>, but uses a string comparison to avoid writes if the value will not be changed.  This
              is useful primarily for avoiding unnecessary write traces.

       <u>treeName</u> <b>tag</b> <u>args</u>
              Manages tags for the tree object.  See the <b>TAG</b> <b>OPERATIONS</b> section below.

       <u>treeName</u> <b>trace</b> <u>args</u>
              Manages traces for data fields in the tree object.  Traces  cause  Tcl  commands  to  be  executed
              whenever  a  data  field  of  a node is created, read, written, or unset.  Traces can be set for a
              specific node or a tag, representing possibly many nodes.  See the <b>TRACE</b> <b>OPERATIONS</b> section below.

       <u>treeName</u> <b>type</b> <u>node</u> <u>key</u>
              Return type of value.  This is the introspected type from the Tcl_Obj value passed to set.

       <u>treeName</u> <b>update</b> <u>node</u> <u>key</u> <u>value</u> ?<u>key</u> <u>value</u>...?
              Like <b>modify</b>, except an error is generated if a tag is used that applies to more than one node.

       <u>treeName</u> <b>unset</b> <u>node</u> <u>key</u>...
              Removes one or more data fields from <u>node</u>. <u>Node</u> may be a tag that represents several  nodes.   <u>Key</u>
              is  the  name of the data field to be removed.  It's not an error is <u>node</u> does not contain <u>key</u>.  A
              count of the number of nodes unset is returned.  This operation may trigger <b>unset</b> data traces.

       <u>treeName</u> <b>values</b> <u>node</u> ?<u>key</u>? ?<u>withnames</u>?
              Return values for <u>node</u>.  The values are returned in the same  order  as  the  keys  returned  from
              <b>names</b>.

              If  a  <u>key</u>  is  given, array values get returned for the <u>key</u> value.  If <u>withname</u> is <b>True</b>, then key
              names are also returned with the values.  This differs from <b>get</b> in that the result is a  true  Tcl
              list  object,  not  an array object.  If subsequently using an array value in a list context, this
              can be more efficient by avoiding a split on string representations.

       <u>treeName</u> <b>vecdump</b> <u>vector</u> <u>key</u> ?<u>tagnode</u>?
              Dump key field to a vector.  With no <u>tagnode</u>, dumps every node to  the  1-1  corresponding  vector
              index.  With <u>tag</u> dumps nodes to consequetive vector elements.

       <u>treeName</u> <b>vecload</b> <u>vector</u> <u>key</u> ?<u>tagnode</u>?
              Loads  key  field  from  a  vector.   With no <u>tagnode</u>, loads every node from the 1-1 corresponding
              vector index.  With <u>tag</u> loads nodes from consequetive vector elements.

       <u>treeName</u> <b>with</b> <u>variable</u> ?<u>switch</u>? <u>tagnode</u> <u>script</u>
              For each node in <u>tagnode</u>, evaluate the <u>script</u> after assigning key values to elements of the  array
              <u>variable</u>.   The <b>-keys</b> limits which keys may be assigned.  If <u>script</u> completes normally, and any of
              the key values change in the <u>variable</u>, then the updates are reflected back  into  the  key  values
              (unless  <b>-noupdate</b>  is used).  Unsetting a variable key will cause that change to be ignored.  New
              elements added to the array variable are ignored.

              Doing a <b>return</b>, <b>break</b>, or <b>continue</b> inside <u>script</u> will  still  cause  updates  to  copy  back,  but
              processing  will  stop  and (unless <b>-break</b> is used) the return code will become the return code to
              the caller.  This means that a <b>break</b>, <b>continue</b>, and <b>return</b>  will  propagate  up  through  multiple
              nested  <b>with</b>  statements  to  the  to an enclosing <b>foreach</b>, <b>while</b>, etc.  But <b>-break</b> can be used to
              change this, making <b>with</b> behave more like a <b>foreach</b> loop.

              If <b>-keys</b> is not used, the list of key names will be stored in <u>variable(*)</u> and the node  id  stored
              in  <u>variable(#)</u> (which could then be overwritten by a key of that name).  By default, the array is
              not cleaned up before or after each execution.  However, if <b>-unset</b> is used, the array is unset  at
              the start of each iteration, and <b>-init</b> can be used to specify a default value.  Also, long running
              queries can speed up by initializing variables prior to the call to <b>with</b>.

              If  the <u>variable</u> name string is zero length, an simple variables are used instead of an array, and
              * and # do not  get  set.   Note,  when  not  using  -keys,  arbitrary  local  variables  can  get
              overwritten.

              If  <b>-array</b>  is  used,  <b>with</b>  operates on the keys of an tree array/dict instead of the keys of the
              node.

              Upon normal completion, the number of times <u>script</u> was evaluated is returned.

              The valid switches are listed below:

              <b>-array</b> <u>key</u>
                        Specifies a single key that is to be treated as an array-dict.  The fields of the  array
                        for  that one key are then used (instead of keys from the whole node).  This changes the
                        meaning of <b>-keys</b> and <b>-glob</b> to be the keys of the array rather than the keys of the node.
                        Nodes missing the given array key will be skipped.  If a key value can not be  converted
                        to an array, an error will occur.

              <b>-break</b>    Treat  <b>break</b>  and  <b>continue</b>  like  <b>foreach</b>  does rather than just passing them up to the
                        enclosing script body.

              <b>-init</b> <u>value</u>
                        Variables specified by <b>-keys</b> are to be initialized to <u>value</u> for each node where  key  is
                        missing.

              <b>-keys</b> <u>keylist</u>
                        Copy only the named keys and does not set (*).

              <b>-glob</b> <u>pattern</u>
                        Pattern to limit matching keys.  Can not be used with <b>-keys</b>.

              <b>-noupdate</b> Ignore  changes  to  array  variables. This do not copy changed variables back into tree
                        nodes.

              <b>-unset</b>    Unset the array variable at the begin of each evaluation.

</pre><h4><b>DICT-ARRAYS</b></h4><pre>
       Round braces can be used to access sub-values of a key value.  In effect, this means each key  value  can
       be an array (or dict), eg.

               set t [tree create]
               set n [$t insert 0 -data {a 1   b 2   c "x 9 y 8 z 7"}]
               $t get $n;          #  a 1 b 2 c {x 9 y 8 z 7}
               $t get $n c;        #  x 9 y 8 z 7
               $t get $n c(y);     # 8
               $t update $n c(y) 8.6
               $t get $n c;        # x 9 y 8.6 z 7
               $t unset $n c(y)
               $t get $n c;        # x 9 z 7
               $t set $n d 10
               $t incr $n d

       If  a  key value is a dict object tree will make use of it.  If not, on access it converts the value to a
       pure <b>array</b> hash object.  The following example shows the type in a comment after each operation.

               set t [tree create]
               $t insert 0 -label A;
               $t set   0-&gt;A  X [dict create a 1 b 2 c 3];   # dict
               array set q { x 1 y 2 };
               $t set   0-&gt;A  Y [array get q];               # dict
               $t set   0-&gt;A  Z {m 0 n 1};                   # string
               $t incr  0-&gt;A  <a href="../manm/Z.m.html">Z</a>(m);                          # array
               dict size [$t get 0-&gt;A Z];                    # dict

       One advantage of using a dict is that it preserves order.  See <b>dictset</b>.

</pre><h4><b>TAG</b> <b>OPERATIONS</b></h4><pre>
       Tags are a general means of selecting and marking nodes  in  the  tree.   A  tag  is  just  a  string  of
       characters, and it may take any form except that of an integer.  The same tag may be associated with many
       different nodes.

       Most  tree  operations  use tags.  And several operations let you operate on multiple nodes at once.  For
       example, you can use the <b>set</b> operation with the tag <b>all</b> to set a data field in for all nodes in the tree.

       Tags are invoked by the <b>tag</b> operation.  The  general  form  is  <u>treeName</u>  <b>tag</b>  <u>operation</u>  ?<u>arg</u>?...   Both
       <u>operation</u>  and  its  arguments determine the exact behavior of the command.  The operations available for
       tags are listed below.

       <u>treeName</u> <b>tag</b> <b>add</b> <u>string</u> ?<u>node</u>?...
              Adds the tag <u>string</u> to zero or more nodes.  If no nodes are given, just creates the tag.  A  count
              of the number of nodes tagged is returned.

       <u>treeName</u> <b>tag</b> <b>delete</b> <u>string</u> <u>node</u>...
              Remove the tag <u>string</u> from one or more nodes.  A count of the number of nodes visited is returned.
              Calling <b>tag</b> <b>delete</b> with a builtin tag is ignore.

       <u>treeName</u> <b>tag</b> <b>dump</b> <u>tagnode</u> ?<u>switches</u>?
              Dump the nodes specified by the tag <u>tagnode</u>.

              The valid <u>switches</u> are listed below.

              <b>-keys</b> <u>list</u>
                     A list of patterns of matching keys to be dumped.

              <b>-skipkeys</b> <u>list</u>
                     A list of patterns of matching keys not to be dumped.

              <b>-tag</b> <u>pattern</u>
                     A pattern match for tags to include in a node dump.

              <b>-skiptag</b> <u>pattern</u>
                     A pattern match for tags to not include in a node dump.

              <b>-notags</b>
                     Do not dump the tags.

              <b>-nopath</b>
                     To save space, do not dump the full path for each node.  Instead output periods for all but
                     the last path element.  Full paths are used only for partial restores.

       <u>treeName</u> <b>tag</b> <b>exists</b> <u>string</u> ?<u>id</u>?
              If  an  <u>id</u> is given, return 1 (or 0)  if node has (or hasn't) the tag.  Otherwise, returns 1 if at
              least one nodes has tag <u>string</u>.

       <u>treeName</u> <b>tag</b> <b>forget</b> <u>string</u> ?<u>string</u> ...?
              Removes the tag definition for one or more of <u>string</u>.  It's not an error if the  tag  <u>string</u>  does
              not exist.

       <u>treeName</u> <b>tag</b> <b>lookups</b> ?<u>pattern</u>?
              Dump  a lookup table (dictionary) of nodes-to-tags, or tags-to-nodes if <u>pattern</u> is given.  With no
              arguments, returns a pair list of nodes/tags, for nodes that have tags.  With an argument, returns
              a pair list of tags/nodes.  <b>lookups</b> provides efficient bulk processing  when  dealing  with  large
              numbers of nodes and/or tags.

       <u>treeName</u> <b>tag</b> <b>names</b> ?<b>-glob</b>? ?<b>-regexp</b>? ?<b>-nocase</b>?  ?<u>node</u>? ?<u>node</u> <u>...</u>?
              Returns  a  list  of  tags  used by the tree.  If no <u>node</u> argument is given, returns a list of all
              known tags.  Otherwise, returns the union of the tags used by all given  <u>node</u>  numbers.   Patterns
              can  be  used  via  <b>-glob</b> or <b>-regexp</b>.  If <b>-nocase</b> is used, the pattern is expected to be all lower
              case.

       <u>treeName</u> <b>tag</b> <b>nodes</b> <u>string</u> ?<u>string</u> <u>...</u>?
              Returns a list of any nodes that have any of given <u>string</u> tag.  If no node is tagged with  any  of
              the <u>string</u>, then an empty string is returned.

</pre><h4><b>TRACE</b> <b>OPERATIONS</b></h4><pre>
       Data  fields  can  be  traced  much  like  tracing  Tcl variables.  Data traces cause a Tcl command to be
       executed whenever data fields are created, read, written, or unset.  A trace can apply  to  one  or  more
       nodes.   You  can  trace  a  specific  node  by  using its id, or a group of nodes by a their tag.  Note:
       operations on arrays trigger on the whole key value, not the individual array element.

       The tree's <b>get</b>, <b>set</b>, and <b>unset</b> operations can trigger various traces.  The <b>get</b> operation can cause a <u>read</u>
       trace to fire.  The <b>set</b> operation causes a <u>write</u> trace to fire.  And if the data field is written for the
       first time, you will also get a <u>create</u> trace.  The <b>unset</b> operation triggers <u>unset</u> traces.

       Data traces are invoked by the <b>trace</b> operation.  The general form is <u>treeName</u>  <b>trace</b>  <u>operation</u>  ?<u>arg</u>?...
       Both  <u>operation</u>  and its arguments determine the exact behavior of the command.  The operations available
       for traces are listed below.

       <u>treeName</u> <b>trace</b> <b>create</b> <u>node</u> <u>key</u> <u>ops</u> <u>command</u> ?-bgerror?
              Create a trace on data fields (or tags for tag traces) given by the  pattern  in  <u>key</u>.   The  <u>node</u>
              argument  can  be  a  nodeid, or a tag to refer to multiple nodes eg. <u>all</u>.  The return value is an
              identifier that can be used with "<b>trace</b> <b>info</b>" or "<b>trace</b> <b>delete</b>".  Traces are temporarily  disabled
              while executing <u>command</u> within the trace.

              <u>Command</u>  is  a  command  prefix, to which four arguments are appended before invocation: <u>treeName</u>,
              <u>nodeid</u>, <u>key</u> and, <u>ops</u>.  If an error occurs in <u>command</u> (and <u>-bgerror</u>  was  not  used)  the  invoking
              operation will also abort.

              <u>Ops</u>  indicates  which  operations  are  of  interest.  It consists of one or more of the following
              letters:

              <b>r</b>      Invoke <u>command</u> whenever <u>key</u> is read.

              <b>w</b>      Invoke <u>command</u> whenever <u>key</u> is written.

              <b>c</b>      Invoke <u>command</u> whenever <u>key</u> is created.

              <b>u</b>      Invoke <u>command</u> whenever <u>key</u> is unset, typically with the <b>unset</b> command.  to that.

              <b>e</b>      Invoke <u>command</u> whenever <b>exists</b> is used on  an  non-existant  key.   This  can  be  used  to
                     populate node key data on demand.

              <b>t</b>      Invoke <u>command</u> whenever tag <u>key</u> is added to a node.

              <b>m</b>      Invoke  <u>command</u>  when  tag <u>key</u> gets added to more than one node.  This trace can be used to
                     enforce tags that should be on at most one node.  It can avoid later errors with tags  used
                     in <b>get</b> or other commands not accepting non-unique tags.

              <b>d</b>      Invoke  <u>command</u>  whenever  tag  <u>key</u>  is  <u>deleted</u> from a node using either <b>tag</b> <b>delete</b> or <b>tag</b>
                     <b>forget</b>.  Node deletion will not trigger this trace.

       <u>treeName</u> <b>trace</b> <b>delete</b> <u>traceId</u>...
              Deletes one of more traces.  <u>TraceId</u>  is  the  trace  identifier  returned  by  the  <b>trace</b>  <b>create</b>
              operation.

       <u>treeName</u> <b>trace</b> <b>info</b> <u>traceId</u>
              Returns information about the trace <u>traceId</u>.  <u>TraceId</u> is a trace identifier previously returned by
              the  <b>trace</b>  <b>create</b> operation.  It's the same information specified for the <b>trace</b> <b>create</b> operation.
              It consists of the node id or tag, data field key, a string of letters indicating  the  operations
              that are traced (it's in the same form as <u>ops</u>) and, the command prefix.

       <u>treeName</u> <b>trace</b> <b>names</b>
              Returns a list of identifers for all the current traces.

</pre><h4><b>NOTIFY</b> <b>OPERATIONS</b></h4><pre>
       The  purpose  of  <b>notify</b>  is  to  get  control  when structural operations occur on a tree.  This is used
       internally by <b>treeview</b> or example when a tree object is shared.  A client may create nodes, sort a  tree,
       move a node, etc.  Notifier can cause such operations to generate events, resulting in Tcl commands being
       executed.

       The general form of <b>notify</b> is:

              <u>treeName</u> <b>notify</b> <u>operation</u> ?<u>arg</u>?...

       The available <u>operation</u> are as follows:

       <u>treeName</u> <b>notify</b> <b>create</b> ?<u>switches</u>? <u>command</u> ?<u>args</u>?...
              Creates  a  notifier for the tree.  A notify identifier in the form "<b>notify0</b>", "<b>notify1</b>", etc.  is
              returned.

              <u>Command</u> and <u>args</u> are saved and invoked whenever the  tree  structure  is  changed  (controlled  by
              <u>switches</u>).  Two arguments are appended to <u>command</u> and <u>args</u> before it's invoked: the id of the node
              and a string representing the type of event that occured.  If an error is returned by <u>command</u>  the
              invoking  operation  returns  an  error  (when not using <u>-whenidle</u>).  One or more of the following
              switches are used to indicate the events that are of interest:

              <b>-bgerror</b>  Generate a background error if an error occurs.

              <b>-create</b>   Invoke <u>command</u> whenever a new node  is  added.   This  is  called  after  the  creation.
                        Returning an error will delete the node.

              <b>-delete</b>   Invoke  <u>command</u>  whenever  a  node  has  been deleted.  This is called before the delete
                        starts to allow aborting it with an error.  Deletes resulting from  failed  inserts  are
                        ignored.

              <b>-disabletrace</b>
                        Disable traces from firing during a notify event.

              <b>-get</b>      Invoke  <u>command</u>  whenever  a node with no keys is accessed (via <b>get</b> or <b>with</b>).  If a node
                        has at least one key, this will not trigger.  The invocation  occurs  before  the  read,
                        meaning  it  can  be used to implement demand loading of data keys into empty nodes (eg.
                        loading database row data on read).

              <b>-insert</b>   Invoke <u>command</u> when an <b>insert</b> completes.  This differs from <b>-create</b>  in  that  the  call
                        occurs  after  the  label,  tags  and data are added (but before <b>-fixed</b> gets set).  This
                        trace applies to the subcommands <b>create</b>, <b>copy</b>, <b>restore</b>, <b>sqlload</b>, and <b>insert</b>  (both  tree
                        and  treeview).   It  is  useful  for verifying key-data, tags and labels.  Returning an
                        error will delete the node and cause the originating command to generate an error.

              <b>-move</b>     Invoke <u>command</u> at the start of a node move.

              <b>-movepost</b> Invoke <u>command</u> after a node has been moved.

              <b>-sort</b>     Invoke <u>command</u> whenever the tree has been sorted and reordered.

              <b>-relabel</b>  Invoke <u>command</u> at the start of a node relabel.

              <b>-relabelpost</b>
                        Invoke <u>command</u> after a node has been relabeled.

              <b>-allevents</b>
                        Invoke <u>command</u> whenever any of the above events occur.

              <b>-whenidle</b> When an event occurs don't invoke <u>command</u> immediately, but queue it to be run  the  next
                        time the event loop is entered and there are no events to process.  If subsequent events
                        occur before the event loop is entered, <u>command</u> will still be invoked only once.

       <u>treeName</u> <b>notify</b> <b>delete</b> <u>notifyId</u>
              Deletes  one or more notifiers from the tree.  <u>NotifyId</u> is the notifier identifier returned by the
              <b>notify</b> <b>create</b> operation.

       <u>treeName</u> <b>notify</b> <b>info</b> <u>notifyId</u>
              Returns information about the notify event <u>notifyId</u>.  <u>NotifyId</u> is a notify  identifier  previously
              returned  by  the  <b>notify</b>  <b>create</b>  operation.   It's the same information specified for the <b>notify</b>
              <b>create</b> operation.  It consists of the notify id, a sublist of event flags (it's in the  same  form
              as <u>flags</u>) and, the command prefix.

       <u>treeName</u> <b>notify</b> <b>names</b>
              Returns a list of identifers for all the current notifiers.

</pre><h4><b>TABLE</b> <b>EXAMPLE</b></h4><pre>
       The following is a simple example.

               variable Users {
                   tom  { Name "Tom Brown"  Sex M Age 19  Class {4 5} Rate {A 1 B 2}}
                   mary { Name "Mary Brown" Sex F Age 16  Class {5}   Rate {A 2}}
                   sam  { Name "Sam Spade"  Sex M Age 19  Class {3 4} Rate {B 3}}
               }
               set t [tree create]
               foreach {i d} $Users {
                  # Use name in -tags so we don't have to do "0-&gt;mary" etc.
                  $t insert 0 -tags $i -data $d -label $i
               }

               $t update   tom       Sex F   Name "Tomi Brown"
               $t append   sam       Name " Jr"
               $t lappend  sam       Class 5
               $t incr     mary      Age
               $t update   tom       Rate(A) 2
               $t incr     0-&gt;mary   Age

               # Set a trace.
               proc ::Aupd {t id key op} { tclLog "AA: $t $id $key $op" }
               $t trace create all Age w ::Aupd
               $t incr     mary Age

               # Display it.
               pack [treeview .t -tree $t] -fill both -expand y
               eval .t column insert end [$t keys all]

</pre><h4><b>TREE</b> <b>EXAMPLE</b></h4><pre>
       The following is a nested tree example with updates.

               variable Info {
                 system {
                    sol  { OS Linux Version 3.4 }
                    bing { OS Win Version 7 }
                    gui  { OS Mac Version 8 }
                 }
                 network {
                    intra { Address 192.168.1  Netmask 255.255.255.0 }
                    dmz   { Address 192.168.10 Netmask 255.255.255.0 }
                    wan   { Address 0.0.0.0 Netmask 0.0.0.0 Class {A 1 B 4}}
                 }
                 admins {
                    sully { Name "Sully Van Damme" Level 3 }
                    maverick { Name "Maverick Gump" Level 1 }
                 }
               }

               set s [tree create]
               foreach {n vals} $Info {
                 set ind [$s insert 0 -label $n]
                 foreach {i d} $vals {
                    $s insert $ind -label $i -data $d
                 }
               }

               set old [$s get  0-&gt;system-&gt;bing]
               $s update   0-&gt;system-&gt;bing   OS Linux Version 3.4
               $s update   0-&gt;network-&gt;dmz   Address 192.168.11
               $s update   0-&gt;network-&gt;wan   Class(A) 2
               eval $s set 0-&gt;system-&gt;bing   $old
               $s insert   0-&gt;admins -label linus -data { Name "Linus Torvalds" Level 9 }

               pack [treeview .s -tree $s -width 600] -fill both -expand y
               eval .s column insert end [$s keys all]

</pre><h4><b>SQLLOAD</b> <b>EXAMPLE</b></h4><pre>
       Here is an example using <b>sqlload</b> on table <u>cust</u> from a database file, and displaying it in a treeview:

                set t [tree create]
                $t sqlload mydb.dat "select rowid,* from cust"
                pack [treeview .t -tree $t -width 500] -fill both -expand y
                eval .t column insert end [lsort [$t keys all]]

       Although there is no corresponding <b>sqldump</b> command, scripting it is easy.  Following is one approach.

                proc sqldump {t db table {ids {}}} {
                    # Dump nodes from tree t into table in open sqlite database db.
                    if {$ids == {}} { set ids [$t children root] }
                    set keys [$t keys $ids]
                    catch { $db eval "CREATE TABLE $table ( [join $keys ,] )" }
                    $t with s $ids {
                        set nams {}
                        set vals {}
                        foreach nam $s(*) {
                            lappend vals $s($nam)
                            lappend nams $nam
                        }
                        set vals [join $vals ,]
                        set nams [join $nams ,]
                        set q [format {INSERT INTO %s (%s) VALUES (%s)} $table $nams $vals]
                        $db eval $q
                    }
                }
                sqlite3 [set db dbhandle] mydb.dat
                sqldump $t $db cust2

</pre><h4><b>TREE</b> <b>KEY</b> <b>STRING</b> <b>STORAGE</b></h4><pre>
       Key  name  strings  are  stored  by  default  in  a  global  hash  table.  However, sometimes this can be
       undesirable (eg. with threading), and so the behavior may be changed (at  tree  create  time  only).   To
       enable  per-interp storage of keys, set <b>blt::treeKeysLocal</b> to 1 before tree creation.  To enable per-tree
       storage of keys, set <b>blt::treeKeysLocal</b> to 2 before tree creation.  The  above  is  unavailable  in  safe
       interps.

</pre><h4><b>C</b> <b>LANGUAGE</b> <b>API</b></h4><pre>
       Blt_TreeApply,      Blt_TreeApplyBFS,      Blt_TreeApplyDFS,      Blt_TreeChangeRoot,     Blt_TreeCreate,
       Blt_TreeCreateEventHandler,    Blt_TreeCreateNode,    Blt_TreeCreateTrace,    Blt_TreeDeleteEventHandler,
       Blt_TreeDeleteNode,    Blt_TreeDeleteTrace,    Blt_TreeExists,   Blt_TreeFindChild,   Blt_TreeFirstChild,
       Blt_TreeFirstKey,    Blt_TreeGetNode,     Blt_TreeGetToken,     Blt_TreeGetValue,     Blt_TreeIsAncestor,
       Blt_TreeIsBefore,  Blt_TreeIsLeaf,  Blt_TreeLastChild,  Blt_TreeMoveNode,  Blt_TreeName, Blt_TreeNextKey,
       Blt_TreeNextNode,    Blt_TreeNextSibling,    Blt_TreeNodeDegree,    Blt_TreeNodeDepth,    Blt_TreeNodeId,
       Blt_TreeNodeLabel,   Blt_TreeNodeParent,   Blt_TreePrevNode,   Blt_TreePrevSibling,  Blt_TreeRelabelNode,
       Blt_TreeReleaseToken,   Blt_TreeRootNode,   Blt_TreeSetValue,   Blt_TreeSize,    Blt_TreeSortNode,    and
       Blt_TreeUnsetValue.

</pre><h4><b>KEYWORDS</b></h4><pre>
       tree, treeview, widget

BLT                                                    2.5                                       <u>blt::<a href="../man3tcl/tree.3tcl.html">tree</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>