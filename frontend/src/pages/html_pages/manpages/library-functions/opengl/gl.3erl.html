<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gl - Erlang wrapper functions for OpenGL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gl - Erlang wrapper functions for OpenGL

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Standard OpenGL API

       This documents the functions as a brief version of the complete OpenGL reference pages.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>clamp()</b> = float()

       <b>offset()</b> = integer() &gt;= 0

       <b>i()</b> = integer()

       <b>f()</b> = float()

       <b>enum()</b> = integer() &gt;= 0

       <b>matrix()</b> = m12() | m16()

       <b>m12()</b> =
           {f(), f(), f(), f(), f(), f(), f(), f(), f(), f(), f(), f()}

       <b>m16()</b> =
           {f(),
            f(),
            f(),
            f(),
            f(),
            f(),
            f(),
            f(),
            f(),
            f(),
            f(),
            f(),
            f(),
            f(),
            f(),
            f()}

       <b>mem()</b> = binary() | tuple()

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>accum(Op</b> <b>::</b> <b>enum(),</b> <b>Value</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              The  accumulation  buffer  is  an  extended-range  color  buffer. Images are not rendered into it.
              Rather, images rendered into  one  of  the  color  buffers  are  added  to  the  contents  of  the
              accumulation  buffer  after  rendering.  Effects  such  as  antialiasing  (of  points,  lines, and
              polygons), motion blur, and depth of field can be created by accumulating  images  generated  with
              different transformation matrices.

              External documentation.

       <b>activeShaderProgram(Pipeline</b> <b>::</b> <b>i(),</b> <b>Program</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:activeShaderProgram/2</u> sets the linked program named by <u>Program</u> to be the active program for the
              program  pipeline object <u>Pipeline</u>. The active program in the active program pipeline object is the
              target of calls to <u>gl:uniform()</u>  when  no  program  has  been  made  current  through  a  call  to
              <u>gl:useProgram/1</u>.

              External documentation.

       <b>activeTexture(Texture</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:activeTexture/1</u>  selects  which  texture  unit  subsequent texture state calls will affect. The
              number of texture units an implementation supports is implementation dependent,  but  must  be  at
              least 80.

              External documentation.

       <b>alphaFunc(Func</b> <b>::</b> <b>enum(),</b> <b>Ref</b> <b>::</b> <b>clamp())</b> <b>-&gt;</b> <b>ok</b>

              The  alpha  test  discards  fragments depending on the outcome of a comparison between an incoming
              fragment's alpha value and a constant reference  value.  <u>gl:alphaFunc/2</u>  specifies  the  reference
              value  and  the comparison function. The comparison is performed only if alpha testing is enabled.
              By default, it is not enabled. (See <u>gl:enable/1</u> and <u>gl:disable/1</u> of <u>?GL_ALPHA_TEST</u>.)

              External documentation.

       <b>areTexturesResident(Textures</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b>
                              {0 | 1, Residences :: [0 | 1]}

              GL establishes a ``working set'' of textures that are resident in texture memory.  These  textures
              can be bound to a texture target much more efficiently than textures that are not resident.

              External documentation.

       <b>arrayElement(I</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:arrayElement/1</u>  commands  are  used  within <u>gl:'begin'/1</u>/<u>gl:'end'/0</u> pairs to specify vertex and
              attribute data for point, line, and  polygon  primitives.  If  <u>?GL_VERTEX_ARRAY</u>  is  enabled  when
              <u>gl:arrayElement/1</u>  is called, a single vertex is drawn, using vertex and attribute data taken from
              location <u>I</u> of the enabled arrays. If <u>?GL_VERTEX_ARRAY</u> is not enabled, no drawing  occurs  but  the
              attributes corresponding to the enabled arrays are modified.

              External documentation.

       <b>attachShader(Program</b> <b>::</b> <b>i(),</b> <b>Shader</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              In  order  to  create a complete shader program, there must be a way to specify the list of things
              that will be linked together. Program objects provide this  mechanism.  Shaders  that  are  to  be
              linked   together   in   a  program  object  must  first  be  attached  to  that  program  object.
              <u>gl:attachShader/2</u> attaches the shader object specified by <u>Shader</u> to the program  object  specified
              by  <u>Program</u>. This indicates that <u>Shader</u> will be included in link operations that will be performed
              on <u>Program</u>.

              External documentation.

       <b>'begin'(Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

       <b>'end'()</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:'begin'/1</u> and <u>gl:'end'/0</u> delimit the vertices that define  a  primitive  or  a  group  of  like
              primitives.  <u>gl:'begin'/1</u>  accepts  a  single  argument  that  specifies  in which of ten ways the
              vertices are interpreted. Taking n as an integer count starting at one, and N as the total  number
              of vertices specified, the interpretations are as follows:

              External documentation.

       <b>beginConditionalRender(Id</b> <b>::</b> <b>i(),</b> <b>Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

       <b>endConditionalRender()</b> <b>-&gt;</b> <b>ok</b>

              Conditional   rendering   is   started   using   <u>gl:beginConditionalRender/2</u>   and   ended   using
              <u>gl:endConditionalRender/0</u>. During conditional rendering, all vertex array  commands,  as  well  as
              <u>gl:clear/1</u>  and  <u>gl:clearBuffer()</u>  have  no effect if the (<u>?GL_SAMPLES_PASSED</u>) result of the query
              object <u>Id</u> is zero, or if the (<u>?GL_ANY_SAMPLES_PASSED</u>) result is <u>?GL_FALSE</u>. The results of commands
              setting  the  current  vertex  state,  such   as   <u>gl:vertexAttrib()</u>   are   undefined.   If   the
              (<u>?GL_SAMPLES_PASSED</u>)  result  is  non-zero  or if the (<u>?GL_ANY_SAMPLES_PASSED</u>) result is <u>?GL_TRUE</u>,
              such commands are not discarded. The <u>Id</u> parameter to <u>gl:beginConditionalRender/2</u> must be the  name
              of  a  query  object  previously  returned  from a call to <u>gl:genQueries/1</u>. <u>Mode</u> specifies how the
              results of the query object are to be interpreted. If <u>Mode</u> is <u>?GL_QUERY_WAIT</u>, the GL waits for the
              results of the query to be available  and  then  uses  the  results  to  determine  if  subsequent
              rendering   commands   are  discarded.  If  <u>Mode</u>  is  <u>?GL_QUERY_NO_WAIT</u>,  the  GL  may  choose  to
              unconditionally execute the subsequent  rendering  commands  without  waiting  for  the  query  to
              complete.

              External documentation.

       <b>beginQuery(Target</b> <b>::</b> <b>enum(),</b> <b>Id</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>endQuery(Target</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:beginQuery/2</u>  and  <u>gl:endQuery/1</u> delimit the boundaries of a query object. <u>Query</u> must be a name
              previously returned from a call to <u>gl:genQueries/1</u>. If a query object with name <u>Id</u>  does  not  yet
              exist  it is created with the type determined by <u>Target</u>. <u>Target</u> must be one of <u>?GL_SAMPLES_PASSED</u>,
              <u>?GL_ANY_SAMPLES_PASSED</u>,  <u>?GL_PRIMITIVES_GENERATED</u>,  <u>?GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</u>,  or
              <u>?GL_TIME_ELAPSED</u>. The behavior of the query object depends on its type and is as follows.

              External documentation.

       <b>beginQueryIndexed(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i(),</b> <b>Id</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>endQueryIndexed(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:beginQueryIndexed/3</u>  and  <u>gl:endQueryIndexed/2</u>  delimit the boundaries of a query object. <u>Query</u>
              must be a name previously returned from a call to <u>gl:genQueries/1</u>. If a query object with name  <u>Id</u>
              does  not  yet  exist  it  is  created  with  the type determined by <u>Target</u>. <u>Target</u> must be one of
              <u>?GL_SAMPLES_PASSED</u>,               <u>?GL_ANY_SAMPLES_PASSED</u>,                <u>?GL_PRIMITIVES_GENERATED</u>,
              <u>?GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN</u>,  or  <u>?GL_TIME_ELAPSED</u>. The behavior of the query object
              depends on its type and is as follows.

              External documentation.

       <b>beginTransformFeedback(PrimitiveMode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

       <b>endTransformFeedback()</b> <b>-&gt;</b> <b>ok</b>

              Transform feedback mode captures the values of varying variables written by the vertex shader (or,
              if active, the geometry shader). Transform  feedback  is  said  to  be  active  after  a  call  to
              <u>gl:beginTransformFeedback/1</u>  until  a  subsequent  call  to  <u>gl:endTransformFeedback/0</u>.  Transform
              feedback commands must be paired.

              External documentation.

       <b>bindAttribLocation(Program</b> <b>::</b> <b>i(),</b> <b>Index</b> <b>::</b> <b>i(),</b> <b>Name</b> <b>::</b> <b>string())</b> <b>-&gt;</b>
                             ok

              <u>gl:bindAttribLocation/3</u> is used to associate a user-defined  attribute  variable  in  the  program
              object  specified  by  <u>Program</u> with a generic vertex attribute index. The name of the user-defined
              attribute variable is passed as a null terminated string in <u>Name</u>.  The  generic  vertex  attribute
              index  to  be  bound  to this variable is specified by <u>Index</u>. When <u>Program</u> is made part of current
              state, values provided via the generic vertex attribute <u>Index</u> will modify the value of  the  user-
              defined attribute variable specified by <u>Name</u>.

              External documentation.

       <b>bindBuffer(Target</b> <b>::</b> <b>enum(),</b> <b>Buffer</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindBuffer/2</u>   binds   a   buffer  object  to  the  specified  buffer  binding  point.  Calling
              <u>gl:bindBuffer/2</u> with <u>Target</u> set to one of the accepted symbolic constants and <u>Buffer</u>  set  to  the
              name of a buffer object binds that buffer object name to the target. If no buffer object with name
              <u>Buffer</u>  exists,  one  is  created  with  that name. When a buffer object is bound to a target, the
              previous binding for that target is automatically broken.

              External documentation.

       <b>bindBufferBase(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i(),</b> <b>Buffer</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                         ok

              <u>gl:bindBufferBase/3</u> binds the buffer object <u>Buffer</u> to the binding point  at  index  <u>Index</u>  of  the
              array  of  targets  specified by <u>Target</u>. Each <u>Target</u> represents an indexed array of buffer binding
              points, as well as a single general binding point that can be used by  other  buffer  manipulation
              functions  such  as  <u>gl:bindBuffer/2</u>  or <u>glMapBuffer</u>. In addition to binding <u>Buffer</u> to the indexed
              buffer binding target, <u>gl:bindBufferBase/3</u> also binds <u>Buffer</u> to the generic buffer  binding  point
              specified by <u>Target</u>.

              External documentation.

       <b>bindBufferRange(Target</b> <b>::</b> <b>enum(),</b>
                       Index :: i(),
                       Buffer :: i(),
                       Offset :: i(),
                       Size :: i()) -&gt;
                          ok

              <u>gl:bindBufferRange/5</u>  binds a range the buffer object <u>Buffer</u> represented by <u>Offset</u> and <u>Size</u> to the
              binding point at index <u>Index</u> of the array of targets specified by <u>Target</u>. Each  <u>Target</u>  represents
              an  indexed  array of buffer binding points, as well as a single general binding point that can be
              used by other buffer manipulation functions such as <u>gl:bindBuffer/2</u> or <u>glMapBuffer</u>. In addition to
              binding a range of <u>Buffer</u> to the indexed buffer binding target,  <u>gl:bindBufferRange/5</u>  also  binds
              the range to the generic buffer binding point specified by <u>Target</u>.

              External documentation.

       <b>bindBuffersBase(Target</b> <b>::</b> <b>enum(),</b> <b>First</b> <b>::</b> <b>i(),</b> <b>Buffers</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b>
                          ok

              <u>gl:bindBuffersBase/3</u>  binds  a  set  of  <u>Count</u>  buffer  objects whose names are given in the array
              <u>Buffers</u> to the <u>Count</u> consecutive binding points starting from index <u>First</u> of the array of  targets
              specified  by  <u>Target</u>.  If <u>Buffers</u> is <u>?NULL</u> then <u>gl:bindBuffersBase/3</u> unbinds any buffers that are
              currently bound to the referenced  binding  points.  Assuming  no  errors  are  generated,  it  is
              equivalent  to the following pseudo-code, which calls <u>gl:bindBufferBase/3</u>, with the exception that
              the non-indexed <u>Target</u> is not changed by <u>gl:bindBuffersBase/3</u>:

              External documentation.

       <b>bindBuffersRange(Target</b> <b>::</b> <b>enum(),</b>
                        First :: i(),
                        Buffers :: [i()],
                        Offsets :: [i()],
                        Sizes :: [i()]) -&gt;
                           ok

              <u>gl:bindBuffersRange/5</u> binds a set of <u>Count</u> ranges from buffer objects whose names are given in the
              array <u>Buffers</u> to the <u>Count</u> consecutive binding points starting from index <u>First</u> of  the  array  of
              targets  specified  by <u>Target</u>. <u>Offsets</u> specifies the address of an array containing <u>Count</u> starting
              offsets within the buffers, and <u>Sizes</u> specifies the address of an array  of  <u>Count</u>  sizes  of  the
              ranges.  If  <u>Buffers</u> is <u>?NULL</u> then <u>Offsets</u> and <u>Sizes</u> are ignored and <u>gl:bindBuffersRange/5</u> unbinds
              any buffers that are currently bound to the referenced binding  points.  Assuming  no  errors  are
              generated,  it  is equivalent to the following pseudo-code, which calls <u>gl:bindBufferRange/5</u>, with
              the exception that the non-indexed <u>Target</u> is not changed by <u>gl:bindBuffersRange/5</u>:

              External documentation.

       <b>bindFragDataLocation(Program</b> <b>::</b> <b>i(),</b>
                            Color :: i(),
                            Name :: string()) -&gt;
                               ok

              <u>gl:bindFragDataLocation/3</u> explicitly  specifies  the  binding  of  the  user-defined  varying  out
              variable  <u>Name</u>  to fragment shader color number <u>ColorNumber</u> for program <u>Program</u>. If <u>Name</u> was bound
              previously, its assigned binding is replaced with <u>ColorNumber</u>.  <u>Name</u>  must  be  a  null-terminated
              string. <u>ColorNumber</u> must be less than <u>?GL_MAX_DRAW_BUFFERS</u>.

              External documentation.

       <b>bindFragDataLocationIndexed(Program</b> <b>::</b> <b>i(),</b>
                                   ColorNumber :: i(),
                                   Index :: i(),
                                   Name :: string()) -&gt;
                                      ok

              <u>gl:bindFragDataLocationIndexed/4</u> specifies that the varying out variable <u>Name</u> in <u>Program</u> should be
              bound  to  fragment color <u>ColorNumber</u> when the program is next linked. <u>Index</u> may be zero or one to
              specify that the color be used as either the first or second color input to  the  blend  equation,
              respectively.

              External documentation.

       <b>bindFramebuffer(Target</b> <b>::</b> <b>enum(),</b> <b>Framebuffer</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindFramebuffer/2</u>  binds the framebuffer object with name <u>Framebuffer</u> to the framebuffer target
              specified  by  <u>Target</u>.  <u>Target</u>  must  be  either  <u>?GL_DRAW_FRAMEBUFFER</u>,  <u>?GL_READ_FRAMEBUFFER</u>   or
              <u>?GL_FRAMEBUFFER</u>. If a framebuffer object is bound to <u>?GL_DRAW_FRAMEBUFFER</u> or <u>?GL_READ_FRAMEBUFFER</u>,
              it  becomes  the target for rendering or readback operations, respectively, until it is deleted or
              another framebuffer is bound to the corresponding bind point.  Calling  <u>gl:bindFramebuffer/2</u>  with
              <u>Target</u>  set  to  <u>?GL_FRAMEBUFFER</u>  binds <u>Framebuffer</u> to both the read and draw framebuffer targets.
              <u>Framebuffer</u>  is  the  name  of  a  framebuffer  object  previously  returned  from   a   call   to
              <u>gl:genFramebuffers/1</u>, or zero to break the existing binding of a framebuffer object to <u>Target</u>.

              External documentation.

       <b>bindImageTexture(Unit,</b> <b>Texture,</b> <b>Level,</b> <b>Layered,</b> <b>Layer,</b> <b>Access,</b>
                        Format) -&gt;
                           ok

              Types:

                 Unit = Texture = Level = i()
                 Layered = 0 | 1
                 Layer = i()
                 Access = Format = enum()

              <u>gl:bindImageTexture/7</u>  binds  a  single  level  of  a  texture to an image unit for the purpose of
              reading and writing it from shaders. <u>Unit</u> specifies the zero-based index  of  the  image  unit  to
              which  to bind the texture level. <u>Texture</u> specifies the name of an existing texture object to bind
              to the image unit. If <u>Texture</u> is zero, then any existing binding to  the  image  unit  is  broken.
              <u>Level</u> specifies the level of the texture to bind to the image unit.

              External documentation.

       <b>bindImageTextures(First</b> <b>::</b> <b>i(),</b> <b>Textures</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindImageTextures/2</u>  binds  images  from  an  array  of existing texture objects to a specified
              number of consecutive image units. <u>Count</u> specifies the number of texture objects whose  names  are
              stored  in  the  array <u>Textures</u>. That number of texture names are read from the array and bound to
              the <u>Count</u> consecutive texture units starting from <u>First</u>. If the name zero appears in the  <u>Textures</u>
              array, any existing binding to the image unit is reset. Any non-zero entry in <u>Textures</u> must be the
              name  of  an  existing  texture object. When a non-zero entry in <u>Textures</u> is present, the image at
              level zero is bound, the binding is considered layered, with the first layer set to zero, and  the
              image  is  bound for read-write access. The image unit format parameter is taken from the internal
              format of the image at level zero of the texture object.  For  cube  map  textures,  the  internal
              format  of  the  positive  X image of level zero is used. If <u>Textures</u> is <u>?NULL</u> then it is as if an
              appropriately sized array containing only zeros had been specified.

              External documentation.

       <b>bindProgramPipeline(Pipeline</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindProgramPipeline/1</u> binds a program pipeline object to the current context. <u>Pipeline</u> must  be
              a  name previously returned from a call to <u>gl:genProgramPipelines/1</u>. If no program pipeline exists
              with name <u>Pipeline</u> then a new pipeline object is created with that name  and  initialized  to  the
              default state vector.

              External documentation.

       <b>bindRenderbuffer(Target</b> <b>::</b> <b>enum(),</b> <b>Renderbuffer</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindRenderbuffer/2</u>  binds  the  renderbuffer  object with name <u>Renderbuffer</u> to the renderbuffer
              target specified by <u>Target</u>. <u>Target</u> must  be  <u>?GL_RENDERBUFFER</u>.  <u>Renderbuffer</u>  is  the  name  of  a
              renderbuffer object previously returned from a call to <u>gl:genRenderbuffers/1</u>, or zero to break the
              existing binding of a renderbuffer object to <u>Target</u>.

              External documentation.

       <b>bindSampler(Unit</b> <b>::</b> <b>i(),</b> <b>Sampler</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindSampler/2</u> binds <u>Sampler</u> to the texture unit at index <u>Unit</u>. <u>Sampler</u> must be zero or the name
              of  a  sampler  object previously returned from a call to <u>gl:genSamplers/1</u>. <u>Unit</u> must be less than
              the value of <u>?GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</u>.

              External documentation.

       <b>bindSamplers(First</b> <b>::</b> <b>i(),</b> <b>Samplers</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindSamplers/2</u> binds samplers from an array of existing sampler objects to a  specified  number
              of consecutive sampler units. <u>Count</u> specifies the number of sampler objects whose names are stored
              in  the array <u>Samplers</u>. That number of sampler names is read from the array and bound to the <u>Count</u>
              consecutive sampler units starting from <u>First</u>.

              External documentation.

       <b>bindTexture(Target</b> <b>::</b> <b>enum(),</b> <b>Texture</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindTexture/2</u> lets you create or use a named texture. Calling <u>gl:bindTexture/2</u> with <u>Target</u>  set
              to  <u>?GL_TEXTURE_1D</u>,  <u>?GL_TEXTURE_2D</u>,  <u>?GL_TEXTURE_3D</u>,  <u>?GL_TEXTURE_1D_ARRAY</u>, <u>?GL_TEXTURE_2D_ARRAY</u>,
              <u>?GL_TEXTURE_RECTANGLE</u>,   <u>?GL_TEXTURE_CUBE_MAP</u>,   <u>?GL_TEXTURE_CUBE_MAP_ARRAY</u>,   <u>?GL_TEXTURE_BUFFER</u>,
              <u>?GL_TEXTURE_2D_MULTISAMPLE</u>  or <u>?GL_TEXTURE_2D_MULTISAMPLE_ARRAY</u> and <u>Texture</u> set to the name of the
              new texture binds the texture name to the target. When  a  texture  is  bound  to  a  target,  the
              previous binding for that target is automatically broken.

              External documentation.

       <b>bindTextureUnit(Unit</b> <b>::</b> <b>i(),</b> <b>Texture</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindTextureUnit/2</u> binds an existing texture object to the texture unit numbered <u>Unit</u>.

              External documentation.

       <b>bindTextures(First</b> <b>::</b> <b>i(),</b> <b>Textures</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindTextures/2</u>  binds an array of existing texture objects to a specified number of consecutive
              texture units. <u>Count</u> specifies the number of texture objects whose names are stored in  the  array
              <u>Textures</u>.  That number of texture names are read from the array and bound to the <u>Count</u> consecutive
              texture units starting from <u>First</u>. The target, or type of texture  is  deduced  from  the  texture
              object and each texture is bound to the corresponding target of the texture unit. If the name zero
              appears in the <u>Textures</u> array, any existing binding to any target of the texture unit is reset and
              the  default texture for that target is bound in its place. Any non-zero entry in <u>Textures</u> must be
              the name of an existing texture object. If <u>Textures</u> is <u>?NULL</u> then it is  as  if  an  appropriately
              sized array containing only zeros had been specified.

              External documentation.

       <b>bindTransformFeedback(Target</b> <b>::</b> <b>enum(),</b> <b>Id</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindTransformFeedback/2</u>  binds  the  transform  feedback  object with name <u>Id</u> to the current GL
              state. <u>Id</u> must be a name previously returned from a call to <u>gl:genTransformFeedbacks/1</u>. If <u>Id</u>  has
              not  previously  been bound, a new transform feedback object with name <u>Id</u> and initialized with the
              default transform state vector is created.

              External documentation.

       <b>bindVertexArray(Array</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:bindVertexArray/1</u> binds the vertex array object with name <u>Array</u>. <u>Array</u> is the name of a  vertex
              array  object  previously  returned  from  a  call  to  <u>gl:genVertexArrays/1</u>, or zero to break the
              existing vertex array object binding.

              External documentation.

       <b>bindVertexBuffer(Bindingindex</b> <b>::</b> <b>i(),</b>
                        Buffer :: i(),
                        Offset :: i(),
                        Stride :: i()) -&gt;
                           ok

       <b>vertexArrayVertexBuffer(Vaobj</b> <b>::</b> <b>i(),</b>
                               Bindingindex :: i(),
                               Buffer :: i(),
                               Offset :: i(),
                               Stride :: i()) -&gt;
                                  ok

              <u>gl:bindVertexBuffer/4</u> and <u>gl:vertexArrayVertexBuffer/5</u> bind the buffer named <u>Buffer</u> to the  vertex
              buffer  binding  point  whose  index  is given by <u>Bindingindex</u>. <u>gl:bindVertexBuffer/4</u> modifies the
              binding of the currently bound vertex array object,  whereas  <u>gl:vertexArrayVertexBuffer/5</u>  allows
              the  caller  to  specify ID of the vertex array object with an argument named <u>Vaobj</u>, for which the
              binding should be modified. <u>Offset</u> and <u>Stride</u> specify the offset of the first element  within  the
              buffer and the distance between elements within the buffer, respectively, and are both measured in
              basic  machine  units. <u>Bindingindex</u> must be less than the value of <u>?GL_MAX_VERTEX_ATTRIB_BINDINGS</u>.
              <u>Offset</u> and <u>Stride</u> must be greater than or equal to zero.  If  <u>Buffer</u>  is  zero,  then  any  buffer
              currently bound to the specified binding point is unbound.

              External documentation.

       <b>bindVertexBuffers(First</b> <b>::</b> <b>i(),</b>
                         Buffers :: [i()],
                         Offsets :: [i()],
                         Strides :: [i()]) -&gt;
                            ok

       <b>vertexArrayVertexBuffers(Vaobj</b> <b>::</b> <b>i(),</b>
                                First :: i(),
                                Buffers :: [i()],
                                Offsets :: [i()],
                                Strides :: [i()]) -&gt;
                                   ok

              <u>gl:bindVertexBuffers/4</u>  and  <u>gl:vertexArrayVertexBuffers/5</u>  bind storage from an array of existing
              buffer objects to a specified number of consecutive vertex buffer binding points units in a vertex
              array object. For <u>gl:bindVertexBuffers/4</u>, the vertex array object is the  currently  bound  vertex
              array object. For <u>gl:vertexArrayVertexBuffers/5</u>, <u>Vaobj</u> is the name of the vertex array object.

              External documentation.

       <b>bitmap(Width,</b> <b>Height,</b> <b>Xorig,</b> <b>Yorig,</b> <b>Xmove,</b> <b>Ymove,</b> <b>Bitmap)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Width = Height = i()
                 Xorig = Yorig = Xmove = Ymove = f()
                 Bitmap = offset() | mem()

              A  bitmap  is  a binary image. When drawn, the bitmap is positioned relative to the current raster
              position, and frame buffer pixels corresponding to 1's in the bitmap are written using the current
              raster color or index. Frame buffer pixels corresponding to 0's in the bitmap are not modified.

              External documentation.

       <b>blendColor(Red</b> <b>::</b> <b>clamp(),</b>
                  Green :: clamp(),
                  Blue :: clamp(),
                  Alpha :: clamp()) -&gt;
                     ok

              The <u>?GL_BLEND_COLOR</u> may be used to calculate the source  and  destination  blending  factors.  The
              color  components  are  clamped  to  the range [0 1] before being stored. See <u>gl:blendFunc/2</u> for a
              complete description of the blending operations. Initially the <u>?GL_BLEND_COLOR</u> is set to (0, 0, 0,
              0).

              External documentation.

       <b>blendEquation(Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

       <b>blendEquationi(Buf</b> <b>::</b> <b>i(),</b> <b>Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              The blend equations determine how a new pixel (the ''source'' color)  is  combined  with  a  pixel
              already  in  the  framebuffer  (the  ''destination'' color). This function sets both the RGB blend
              equation and the alpha blend equation to a  single  equation.  <u>gl:blendEquationi/2</u>  specifies  the
              blend equation for a single draw buffer whereas <u>gl:blendEquation/1</u> sets the blend equation for all
              draw buffers.

              External documentation.

       <b>blendEquationSeparate(ModeRGB</b> <b>::</b> <b>enum(),</b> <b>ModeAlpha</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                                ok

       <b>blendEquationSeparatei(Buf</b> <b>::</b> <b>i(),</b>
                              ModeRGB :: enum(),
                              ModeAlpha :: enum()) -&gt;
                                 ok

              The  blend  equations  determines  how a new pixel (the ''source'' color) is combined with a pixel
              already in the framebuffer (the ''destination'' color). These functions specify one blend equation
              for   the   RGB-color   components   and   one   blend   equation   for   the   alpha   component.
              <u>gl:blendEquationSeparatei/3</u>  specifies  the  blend  equations  for  a  single  draw buffer whereas
              <u>gl:blendEquationSeparate/2</u> sets the blend equations for all draw buffers.

              External documentation.

       <b>blendFunc(Sfactor</b> <b>::</b> <b>enum(),</b> <b>Dfactor</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

       <b>blendFunci(Buf</b> <b>::</b> <b>i(),</b> <b>Src</b> <b>::</b> <b>enum(),</b> <b>Dst</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              Pixels can be drawn using a function that blends the incoming (source) RGBA values with  the  RGBA
              values  that  are  already  in  the  frame  buffer (the destination values). Blending is initially
              disabled. Use <u>gl:enable/1</u> and <u>gl:disable/1</u> with argument <u>?GL_BLEND</u> to enable and disable blending.

              External documentation.

       <b>blendFuncSeparate(SfactorRGB,</b> <b>DfactorRGB,</b> <b>SfactorAlpha,</b>
                         DfactorAlpha) -&gt;
                            ok

       <b>blendFuncSeparatei(Buf</b> <b>::</b> <b>i(),</b>
                          SrcRGB :: enum(),
                          DstRGB :: enum(),
                          SrcAlpha :: enum(),
                          DstAlpha :: enum()) -&gt;
                             ok

              Pixels can be drawn using a function that blends the incoming (source) RGBA values with  the  RGBA
              values  that  are  already  in  the  frame  buffer (the destination values). Blending is initially
              disabled. Use <u>gl:enable/1</u> and <u>gl:disable/1</u> with argument <u>?GL_BLEND</u> to enable and disable blending.

              External documentation.

       <b>blitFramebuffer(SrcX0,</b> <b>SrcY0,</b> <b>SrcX1,</b> <b>SrcY1,</b> <b>DstX0,</b> <b>DstY0,</b> <b>DstX1,</b>
                       DstY1, Mask, Filter) -&gt;
                          ok

              Types:

                 SrcX0 = SrcY0 = SrcX1 = SrcY1 = DstX0 = DstY0 = DstX1 = DstY1 = Mask = i()
                 Filter = enum()

              <u>gl:blitFramebuffer/10</u> and <u>glBlitNamedFramebuffer</u> transfer a rectangle of  pixel  values  from  one
              region of a read framebuffer to another region of a draw framebuffer.

              External documentation.

       <b>bufferData(Target</b> <b>::</b> <b>enum(),</b>
                  Size :: i(),
                  Data :: offset() | mem(),
                  Usage :: enum()) -&gt;
                     ok

              <u>gl:bufferData/4</u>  and  <u>glNamedBufferData</u>  create  a  new data store for a buffer object. In case of
              <u>gl:bufferData/4</u>, the buffer object currently bound to <u>Target</u> is  used.  For  <u>glNamedBufferData</u>,  a
              buffer object associated with ID specified by the caller in <u>Buffer</u> will be used instead.

              External documentation.

       <b>bufferStorage(Target</b> <b>::</b> <b>enum(),</b>
                     Size :: i(),
                     Data :: offset() | mem(),
                     Flags :: i()) -&gt;
                        ok

              <u>gl:bufferStorage/4</u>   and   <u>glNamedBufferStorage</u>   create   a   new   immutable   data  store.  For
              <u>gl:bufferStorage/4</u>, the  buffer  object  currently  bound  to  <u>Target</u>  will  be  initialized.  For
              <u>glNamedBufferStorage</u>, <u>Buffer</u> is the name of the buffer object that will be configured. The size of
              the  data store is specified by <u>Size</u>. If an initial data is available, its address may be supplied
              in <u>Data</u>. Otherwise, to create an uninitialized data store, <u>Data</u> should be <u>?NULL</u>.

              External documentation.

       <b>bufferSubData(Target</b> <b>::</b> <b>enum(),</b>
                     Offset :: i(),
                     Size :: i(),
                     Data :: offset() | mem()) -&gt;
                        ok

              <u>gl:bufferSubData/4</u> and <u>glNamedBufferSubData</u> redefine some  or  all  of  the  data  store  for  the
              specified  buffer  object.  Data  starting  at  byte offset <u>Offset</u> and extending for <u>Size</u> bytes is
              copied to the data store from the memory pointed to by <u>Data</u>. <u>Offset</u> and <u>Size</u> must define  a  range
              lying entirely within the buffer object's data store.

              External documentation.

       <b>callList(List</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:callList/1</u> causes the named display list to be executed. The commands saved in the display list
              are  executed  in order, just as if they were called without using a display list. If <u>List</u> has not
              been defined as a display list, <u>gl:callList/1</u> is ignored.

              External documentation.

       <b>callLists(Lists</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:callLists/1</u> causes each display list in the list of names passed as <u>Lists</u> to be executed. As  a
              result, the commands saved in each display list are executed in order, just as if they were called
              without using a display list. Names of display lists that have not been defined are ignored.

              External documentation.

       <b>checkFramebufferStatus(Target</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>enum()</b>

              <u>gl:checkFramebufferStatus/1</u>  and <u>glCheckNamedFramebufferStatus</u> return the completeness status of a
              framebuffer object when treated as a read or draw framebuffer, depending on the value of <u>Target</u>.

              External documentation.

       <b>clampColor(Target</b> <b>::</b> <b>enum(),</b> <b>Clamp</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:clampColor/2</u> controls color clamping that is performed during <u>gl:readPixels/7</u>. <u>Target</u>  must  be
              <u>?GL_CLAMP_READ_COLOR</u>. If <u>Clamp</u> is <u>?GL_TRUE</u>, read color clamping is enabled; if <u>Clamp</u> is <u>?GL_FALSE</u>,
              read  color  clamping is disabled. If <u>Clamp</u> is <u>?GL_FIXED_ONLY</u>, read color clamping is enabled only
              if the selected read buffer has fixed point components and disabled otherwise.

              External documentation.

       <b>clear(Mask</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:clear/1</u> sets the bitplane area of the window to values previously selected by  <u>gl:clearColor/4</u>,
              <u>gl:clearDepth/1</u>,  and  <u>gl:clearStencil/1</u>.  Multiple color buffers can be cleared simultaneously by
              selecting more than one buffer at a time using <u>gl:drawBuffer/1</u>.

              External documentation.

       <b>clearAccum(Red</b> <b>::</b> <b>f(),</b> <b>Green</b> <b>::</b> <b>f(),</b> <b>Blue</b> <b>::</b> <b>f(),</b> <b>Alpha</b> <b>::</b> <b>f())</b> <b>-&gt;</b>
                     ok

              <u>gl:clearAccum/4</u> specifies the red, green, blue, and alpha values used by <u>gl:clear/1</u> to  clear  the
              accumulation buffer.

              External documentation.

       <b>clearBufferData(Target,</b> <b>Internalformat,</b> <b>Format,</b> <b>Type,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b>

       <b>clearBufferSubData(Target,</b> <b>Internalformat,</b> <b>Offset,</b> <b>Size,</b> <b>Format,</b>
                          Type, Data) -&gt;
                             ok

       <b>clearBufferfi(Buffer</b> <b>::</b> <b>enum(),</b>
                     Drawbuffer :: i(),
                     Depth :: f(),
                     Stencil :: i()) -&gt;
                        ok

       <b>clearBufferfv(Buffer</b> <b>::</b> <b>enum(),</b>
                     Drawbuffer :: i(),
                     Value :: tuple()) -&gt;
                        ok

       <b>clearBufferiv(Buffer</b> <b>::</b> <b>enum(),</b>
                     Drawbuffer :: i(),
                     Value :: tuple()) -&gt;
                        ok

       <b>clearBufferuiv(Buffer</b> <b>::</b> <b>enum(),</b>
                      Drawbuffer :: i(),
                      Value :: tuple()) -&gt;
                         ok

              These   commands   clear   a  specified  buffer  of  a  framebuffer  to  specified  value(s).  For
              <u>gl:clearBuffer*()</u>,  the  framebuffer  is  the  currently  bound  draw  framebuffer   object.   For
              <u>glClearNamedFramebuffer*</u>,  <u>Framebuffer</u>  is  zero,  indicating the default draw framebuffer, or the
              name of a framebuffer object.

              External documentation.

       <b>clearColor(Red</b> <b>::</b> <b>clamp(),</b>
                  Green :: clamp(),
                  Blue :: clamp(),
                  Alpha :: clamp()) -&gt;
                     ok

              <u>gl:clearColor/4</u> specifies the red, green, blue, and alpha values used by <u>gl:clear/1</u> to  clear  the
              color buffers. Values specified by <u>gl:clearColor/4</u> are clamped to the range [0 1].

              External documentation.

       <b>clearDepth(Depth</b> <b>::</b> <b>clamp())</b> <b>-&gt;</b> <b>ok</b>

       <b>clearDepthf(D</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:clearDepth/1</u>  specifies  the  depth  value used by <u>gl:clear/1</u> to clear the depth buffer. Values
              specified by <u>gl:clearDepth/1</u> are clamped to the range [0 1].

              External documentation.

       <b>clearIndex(C</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:clearIndex/1</u> specifies the index used by <u>gl:clear/1</u> to clear the color index buffers. <u>C</u> is  not
              clamped.  Rather, <u>C</u> is converted to a fixed-point value with unspecified precision to the right of
              the binary point. The integer part of this value is then masked with 2 m-1, where m is the  number
              of bits in a color index stored in the frame buffer.

              External documentation.

       <b>clearStencil(S</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:clearStencil/1</u>  specifies the index used by <u>gl:clear/1</u> to clear the stencil buffer. <u>S</u> is masked
              with 2 m-1, where m is the number of bits in the stencil buffer.

              External documentation.

       <b>clearTexImage(Texture</b> <b>::</b> <b>i(),</b>
                     Level :: i(),
                     Format :: enum(),
                     Type :: enum(),
                     Data :: offset() | mem()) -&gt;
                        ok

              <u>gl:clearTexImage/5</u> fills all an image contained in a texture with an application  supplied  value.
              <u>Texture</u>  must be the name of an existing texture. Further, <u>Texture</u> may not be the name of a buffer
              texture, nor may its internal format be compressed.

              External documentation.

       <b>clearTexSubImage(Texture,</b> <b>Level,</b> <b>Xoffset,</b> <b>Yoffset,</b> <b>Zoffset,</b> <b>Width,</b>
                        Height, Depth, Format, Type, Data) -&gt;
                           ok

              Types:

                 Texture = Level = Xoffset = Yoffset = Zoffset = Width = Height = Depth = i()
                 Format = Type = enum()
                 Data = offset() | mem()

              <u>gl:clearTexSubImage/11</u> fills all or part of an image contained in a texture  with  an  application
              supplied  value.  <u>Texture</u> must be the name of an existing texture. Further, <u>Texture</u> may not be the
              name of a buffer texture, nor may its internal format be compressed.

              External documentation.

       <b>clientActiveTexture(Texture</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:clientActiveTexture/1</u> selects the vertex array  client  state  parameters  to  be  modified  by
              <u>gl:texCoordPointer/4</u>,     and    enabled    or    disabled    with    <u>gl:enableClientState/1</u>    or
              <u>gl:disableClientState/1</u>, respectively, when called with a parameter of <u>?GL_TEXTURE_COORD_ARRAY</u>.

              External documentation.

       <b>clientWaitSync(Sync</b> <b>::</b> <b>i(),</b> <b>Flags</b> <b>::</b> <b>i(),</b> <b>Timeout</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                         enum()

              <u>gl:clientWaitSync/3</u> causes the client to block and wait for the sync object specified by  <u>Sync</u>  to
              become  signaled.  If  <u>Sync</u>  is  signaled  when <u>gl:clientWaitSync/3</u> is called, <u>gl:clientWaitSync/3</u>
              returns immediately, otherwise it will block and wait for up to <u>Timeout</u> nanoseconds  for  <u>Sync</u>  to
              become signaled.

              External documentation.

       <b>clipControl(Origin</b> <b>::</b> <b>enum(),</b> <b>Depth</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:clipControl/2</u>  controls  the  clipping  volume  behavior  and  the  clip  coordinate  to window
              coordinate transformation behavior.

              External documentation.

       <b>clipPlane(Plane</b> <b>::</b> <b>enum(),</b> <b>Equation</b> <b>::</b> <b>{f(),</b> <b>f(),</b> <b>f(),</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

              Geometry is always clipped against the  boundaries  of  a  six-plane  frustum  in  <u>x</u>,  <u>y</u>,  and  <u>z</u>.
              <u>gl:clipPlane/2</u> allows the specification of additional planes, not necessarily perpendicular to the
              <u>x</u>,  <u>y</u>,  or  <u>z</u>  axis,  against  which  all  geometry is clipped. To determine the maximum number of
              additional  clipping  planes,  call  <u>gl:getIntegerv/1</u>  with  argument   <u>?GL_MAX_CLIP_PLANES</u>.   All
              implementations  support  at least six such clipping planes. Because the resulting clipping region
              is the intersection of the defined half-spaces, it is always convex.

              External documentation.

       <b>color3b(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>color3bv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>color3d(Red</b> <b>::</b> <b>f(),</b> <b>Green</b> <b>::</b> <b>f(),</b> <b>Blue</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>color3dv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>f(),</b> <b>Green</b> <b>::</b> <b>f(),</b> <b>Blue</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>color3f(Red</b> <b>::</b> <b>f(),</b> <b>Green</b> <b>::</b> <b>f(),</b> <b>Blue</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>color3fv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>f(),</b> <b>Green</b> <b>::</b> <b>f(),</b> <b>Blue</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>color3i(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>color3iv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>color3s(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>color3sv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>color3ub(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>color3ubv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>color3ui(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>color3uiv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>color3us(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>color3usv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>color4b(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i(),</b> <b>Alpha</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>color4bv(X1</b> <b>::</b>
                    {Red :: i(), Green :: i(), Blue :: i(), Alpha :: i()}) -&gt;
                   ok

       <b>color4d(Red</b> <b>::</b> <b>f(),</b> <b>Green</b> <b>::</b> <b>f(),</b> <b>Blue</b> <b>::</b> <b>f(),</b> <b>Alpha</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>color4dv(X1</b> <b>::</b>
                    {Red :: f(), Green :: f(), Blue :: f(), Alpha :: f()}) -&gt;
                   ok

       <b>color4f(Red</b> <b>::</b> <b>f(),</b> <b>Green</b> <b>::</b> <b>f(),</b> <b>Blue</b> <b>::</b> <b>f(),</b> <b>Alpha</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>color4fv(X1</b> <b>::</b>
                    {Red :: f(), Green :: f(), Blue :: f(), Alpha :: f()}) -&gt;
                   ok

       <b>color4i(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i(),</b> <b>Alpha</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>color4iv(X1</b> <b>::</b>
                    {Red :: i(), Green :: i(), Blue :: i(), Alpha :: i()}) -&gt;
                   ok

       <b>color4s(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i(),</b> <b>Alpha</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>color4sv(X1</b> <b>::</b>
                    {Red :: i(), Green :: i(), Blue :: i(), Alpha :: i()}) -&gt;
                   ok

       <b>color4ub(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i(),</b> <b>Alpha</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                   ok

       <b>color4ubv(X1</b> <b>::</b>
                     {Red :: i(),
                      Green :: i(),
                      Blue :: i(),
                      Alpha :: i()}) -&gt;
                    ok

       <b>color4ui(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i(),</b> <b>Alpha</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                   ok

       <b>color4uiv(X1</b> <b>::</b>
                     {Red :: i(),
                      Green :: i(),
                      Blue :: i(),
                      Alpha :: i()}) -&gt;
                    ok

       <b>color4us(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i(),</b> <b>Alpha</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                   ok

       <b>color4usv(X1</b> <b>::</b>
                     {Red :: i(),
                      Green :: i(),
                      Blue :: i(),
                      Alpha :: i()}) -&gt;
                    ok

              The GL stores both a current single-valued color index  and  a  current  four-valued  RGBA  color.
              <u>gl:color()</u>  sets  a new four-valued RGBA color. <u>gl:color()</u> has two major variants: <u>gl:color3()</u> and
              <u>gl:color4()</u>. <u>gl:color3()</u> variants specify new red, green, and blue values explicitly and  set  the
              current  alpha  value  to  1.0  (full intensity) implicitly. <u>gl:color4()</u> variants specify all four
              color components explicitly.

              External documentation.

       <b>colorMask(Red</b> <b>::</b> <b>0</b> <b>|</b> <b>1,</b>
                 Green :: 0 | 1,
                 Blue :: 0 | 1,
                 Alpha :: 0 | 1) -&gt;
                    ok

       <b>colorMaski(Index</b> <b>::</b> <b>i(),</b>
                  R :: 0 | 1,
                  G :: 0 | 1,
                  B :: 0 | 1,
                  A :: 0 | 1) -&gt;
                     ok

              <u>gl:colorMask/4</u> and <u>gl:colorMaski/5</u> specify whether the individual color components  in  the  frame
              buffer can or cannot be written. <u>gl:colorMaski/5</u> sets the mask for a specific draw buffer, whereas
              <u>gl:colorMask/4</u>  sets the mask for all draw buffers. If <u>Red</u> is <u>?GL_FALSE</u>, for example, no change is
              made to the red component of any pixel in any of the color  buffers,  regardless  of  the  drawing
              operation attempted.

              External documentation.

       <b>colorMaterial(Face</b> <b>::</b> <b>enum(),</b> <b>Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:colorMaterial/2</u>   specifies   which   material   parameters   track  the  current  color.  When
              <u>?GL_COLOR_MATERIAL</u> is enabled, the material parameter or parameters  specified  by  <u>Mode</u>,  of  the
              material or materials specified by <u>Face</u>, track the current color at all times.

              External documentation.

       <b>colorPointer(Size</b> <b>::</b> <b>i(),</b>
                    Type :: enum(),
                    Stride :: i(),
                    Ptr :: offset() | mem()) -&gt;
                       ok

              <u>gl:colorPointer/4</u>  specifies  the  location and data format of an array of color components to use
              when rendering. <u>Size</u> specifies the number of components per color,  and  must  be  3  or  4.  <u>Type</u>
              specifies  the  data  type  of each color component, and <u>Stride</u> specifies the byte stride from one
              color to the next, allowing vertices and attributes to be packed into a single array or stored  in
              separate  arrays.  (Single-array  storage  may  be  more  efficient  on  some implementations; see
              <u>gl:interleavedArrays/3</u>.)

              External documentation.

       <b>colorSubTable(Target,</b> <b>Start,</b> <b>Count,</b> <b>Format,</b> <b>Type,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Target = enum()
                 Start = Count = i()
                 Format = Type = enum()
                 Data = offset() | mem()

              <u>gl:colorSubTable/6</u> is used to respecify a contiguous portion of a color table  previously  defined
              using  <u>gl:colorTable/6</u>.  The  pixels  referenced by <u>Data</u> replace the portion of the existing table
              from indices <u>Start</u> to start+count-1, inclusive. This region may not include  any  entries  outside
              the  range  of  the  color  table  as it was originally specified. It is not an error to specify a
              subtexture with width of 0, but such a specification has no effect.

              External documentation.

       <b>colorTable(Target,</b> <b>Internalformat,</b> <b>Width,</b> <b>Format,</b> <b>Type,</b> <b>Table)</b> <b>-&gt;</b>
                     ok

              Types:

                 Target = Internalformat = enum()
                 Width = i()
                 Format = Type = enum()
                 Table = offset() | mem()

              <u>gl:colorTable/6</u> may be used in two ways: to test the actual size and color resolution of a  lookup
              table  given  a particular set of parameters, or to load the contents of a color lookup table. Use
              the targets <u>?GL_PROXY_*</u> for the first case and the other targets for the second case.

              External documentation.

       <b>colorTableParameterfv(Target</b> <b>::</b> <b>enum(),</b>
                             Pname :: enum(),
                             Params :: {f(), f(), f(), f()}) -&gt;
                                ok

       <b>colorTableParameteriv(Target</b> <b>::</b> <b>enum(),</b>
                             Pname :: enum(),
                             Params :: {i(), i(), i(), i()}) -&gt;
                                ok

              <u>gl:colorTableParameter()</u> is used to specify the scale factors and  bias  terms  applied  to  color
              components  when  they are loaded into a color table. <u>Target</u> indicates which color table the scale
              and bias terms apply to; it must be set to <u>?GL_COLOR_TABLE</u>,  <u>?GL_POST_CONVOLUTION_COLOR_TABLE</u>,  or
              <u>?GL_POST_COLOR_MATRIX_COLOR_TABLE</u>.

              External documentation.

       <b>compileShader(Shader</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:compileShader/1</u>  compiles  the  source  code strings that have been stored in the shader object
              specified by <u>Shader</u>.

              External documentation.

       <b>compressedTexImage1D(Target,</b> <b>Level,</b> <b>Internalformat,</b> <b>Width,</b> <b>Border,</b>
                            ImageSize, Data) -&gt;
                               ok

              Types:

                 Target = enum()
                 Level = i()
                 Internalformat = enum()
                 Width = Border = ImageSize = i()
                 Data = offset() | mem()

              Texturing allows elements of an image array to be read by shaders.

              External documentation.

       <b>compressedTexImage2D(Target,</b> <b>Level,</b> <b>Internalformat,</b> <b>Width,</b> <b>Height,</b>
                            Border, ImageSize, Data) -&gt;
                               ok

              Types:

                 Target = enum()
                 Level = i()
                 Internalformat = enum()
                 Width = Height = Border = ImageSize = i()
                 Data = offset() | mem()

              Texturing allows elements of an image array to be read by shaders.

              External documentation.

       <b>compressedTexImage3D(Target,</b> <b>Level,</b> <b>Internalformat,</b> <b>Width,</b> <b>Height,</b>
                            Depth, Border, ImageSize, Data) -&gt;
                               ok

              Types:

                 Target = enum()
                 Level = i()
                 Internalformat = enum()
                 Width = Height = Depth = Border = ImageSize = i()
                 Data = offset() | mem()

              Texturing allows elements of an image array to be read by shaders.

              External documentation.

       <b>compressedTexSubImage1D(Target,</b> <b>Level,</b> <b>Xoffset,</b> <b>Width,</b> <b>Format,</b>
                               ImageSize, Data) -&gt;
                                  ok

       <b>compressedTextureSubImage1D(Texture,</b> <b>Level,</b> <b>Xoffset,</b> <b>Width,</b>
                                   Format, ImageSize, Data) -&gt;
                                      ok

              Types:

                 Texture = Level = Xoffset = Width = i()
                 Format = enum()
                 ImageSize = i()
                 Data = offset() | mem()

              Texturing allows elements of an image array to be read by shaders.

              External documentation.

       <b>compressedTexSubImage2D(Target,</b> <b>Level,</b> <b>Xoffset,</b> <b>Yoffset,</b> <b>Width,</b>
                               Height, Format, ImageSize, Data) -&gt;
                                  ok

       <b>compressedTextureSubImage2D(Texture,</b> <b>Level,</b> <b>Xoffset,</b> <b>Yoffset,</b>
                                   Width, Height, Format, ImageSize,
                                   Data) -&gt;
                                      ok

              Types:

                 Texture = Level = Xoffset = Yoffset = Width = Height = i()
                 Format = enum()
                 ImageSize = i()
                 Data = offset() | mem()

              Texturing allows elements of an image array to be read by shaders.

              External documentation.

       <b>compressedTexSubImage3D(Target,</b> <b>Level,</b> <b>Xoffset,</b> <b>Yoffset,</b> <b>Zoffset,</b>
                               Width, Height, Depth, Format, ImageSize,
                               Data) -&gt;
                                  ok

       <b>compressedTextureSubImage3D(Texture,</b> <b>Level,</b> <b>Xoffset,</b> <b>Yoffset,</b>
                                   Zoffset, Width, Height, Depth, Format,
                                   ImageSize, Data) -&gt;
                                      ok

              Types:

                 Texture = Level = Xoffset = Yoffset = Zoffset = Width = Height = Depth = i()
                 Format = enum()
                 ImageSize = i()
                 Data = offset() | mem()

              Texturing allows elements of an image array to be read by shaders.

              External documentation.

       <b>convolutionFilter1D(Target,</b> <b>Internalformat,</b> <b>Width,</b> <b>Format,</b> <b>Type,</b>
                           Image) -&gt;
                              ok

              Types:

                 Target = Internalformat = enum()
                 Width = i()
                 Format = Type = enum()
                 Image = offset() | mem()

              <u>gl:convolutionFilter1D/6</u> builds a one-dimensional convolution  filter  kernel  from  an  array  of
              pixels.

              External documentation.

       <b>convolutionFilter2D(Target,</b> <b>Internalformat,</b> <b>Width,</b> <b>Height,</b> <b>Format,</b>
                           Type, Image) -&gt;
                              ok

              Types:

                 Target = Internalformat = enum()
                 Width = Height = i()
                 Format = Type = enum()
                 Image = offset() | mem()

              <u>gl:convolutionFilter2D/7</u>  builds  a  two-dimensional  convolution  filter  kernel from an array of
              pixels.

              External documentation.

       <b>convolutionParameterf(Target</b> <b>::</b> <b>enum(),</b>
                             Pname :: enum(),
                             Params :: tuple()) -&gt;
                                ok

       <b>convolutionParameterfv(Target</b> <b>::</b> <b>enum(),</b>
                              Pname :: enum(),
                              Params :: tuple()) -&gt;
                                 ok

       <b>convolutionParameteri(Target</b> <b>::</b> <b>enum(),</b>
                             Pname :: enum(),
                             Params :: tuple()) -&gt;
                                ok

       <b>convolutionParameteriv(Target</b> <b>::</b> <b>enum(),</b>
                              Pname :: enum(),
                              Params :: tuple()) -&gt;
                                 ok

              <u>gl:convolutionParameter()</u> sets the value of a convolution parameter.

              External documentation.

       <b>copyBufferSubData(ReadTarget,</b> <b>WriteTarget,</b> <b>ReadOffset,</b>
                         WriteOffset, Size) -&gt;
                            ok

              Types:

                 ReadTarget = WriteTarget = enum()
                 ReadOffset = WriteOffset = Size = i()

              <u>gl:copyBufferSubData/5</u> and <u>glCopyNamedBufferSubData</u> copy part of the  data  store  attached  to  a
              source  buffer  object  to  the  data store attached to a destination buffer object. The number of
              basic machine units indicated by <u>Size</u> is copied from  the  source  at  offset  <u>ReadOffset</u>  to  the
              destination at <u>WriteOffset</u>. <u>ReadOffset</u>, <u>WriteOffset</u> and <u>Size</u> are in terms of basic machine units.

              External documentation.

       <b>copyColorSubTable(Target</b> <b>::</b> <b>enum(),</b>
                         Start :: i(),
                         X :: i(),
                         Y :: i(),
                         Width :: i()) -&gt;
                            ok

              <u>gl:copyColorSubTable/5</u>  is  used  to  respecify  a  contiguous portion of a color table previously
              defined using <u>gl:colorTable/6</u>. The pixels copied from the framebuffer replace the portion  of  the
              existing table from indices <u>Start</u> to start+x-1, inclusive. This region may not include any entries
              outside the range of the color table, as was originally specified. It is not an error to specify a
              subtexture with width of 0, but such a specification has no effect.

              External documentation.

       <b>copyColorTable(Target</b> <b>::</b> <b>enum(),</b>
                      Internalformat :: enum(),
                      X :: i(),
                      Y :: i(),
                      Width :: i()) -&gt;
                         ok

              <u>gl:copyColorTable/5</u>  loads a color table with pixels from the current <u>?GL_READ_BUFFER</u> (rather than
              from main memory, as is the case for <u>gl:colorTable/6</u>).

              External documentation.

       <b>copyConvolutionFilter1D(Target</b> <b>::</b> <b>enum(),</b>
                               Internalformat :: enum(),
                               X :: i(),
                               Y :: i(),
                               Width :: i()) -&gt;
                                  ok

              <u>gl:copyConvolutionFilter1D/5</u> defines a one-dimensional convolution filter kernel with pixels  from
              the   current   <u>?GL_READ_BUFFER</u>   (rather   than   from   main   memory,   as   is  the  case  for
              <u>gl:convolutionFilter1D/6</u>).

              External documentation.

       <b>copyConvolutionFilter2D(Target</b> <b>::</b> <b>enum(),</b>
                               Internalformat :: enum(),
                               X :: i(),
                               Y :: i(),
                               Width :: i(),
                               Height :: i()) -&gt;
                                  ok

              <u>gl:copyConvolutionFilter2D/6</u> defines a two-dimensional convolution filter kernel with pixels  from
              the   current   <u>?GL_READ_BUFFER</u>   (rather   than   from   main   memory,   as   is  the  case  for
              <u>gl:convolutionFilter2D/7</u>).

              External documentation.

       <b>copyImageSubData(SrcName,</b> <b>SrcTarget,</b> <b>SrcLevel,</b> <b>SrcX,</b> <b>SrcY,</b> <b>SrcZ,</b>
                        DstName, DstTarget, DstLevel, DstX, DstY, DstZ,
                        SrcWidth, SrcHeight, SrcDepth) -&gt;
                           ok

              Types:

                 SrcName = i()
                 SrcTarget = enum()
                 SrcLevel = SrcX = SrcY = SrcZ = DstName = i()
                 DstTarget = enum()
                 DstLevel = DstX = DstY = DstZ = SrcWidth = SrcHeight = SrcDepth = i()

              <u>gl:copyImageSubData/15</u> may be used to copy data from one image (i.e. texture or  renderbuffer)  to
              another.  <u>gl:copyImageSubData/15</u>  does  not  perform  general-purpose conversions such as scaling,
              resizing, blending, color-space, or format conversions. It should be considered to  operate  in  a
              manner  similar  to a CPU memcpy. CopyImageSubData can copy between images with different internal
              formats, provided the formats are compatible.

              External documentation.

       <b>copyPixels(X</b> <b>::</b> <b>i(),</b>
                  Y :: i(),
                  Width :: i(),
                  Height :: i(),
                  Type :: enum()) -&gt;
                     ok

              <u>gl:copyPixels/5</u> copies a screen-aligned rectangle  of  pixels  from  the  specified  frame  buffer
              location  to  a region relative to the current raster position. Its operation is well defined only
              if the entire pixel source region is within the exposed portion of the window. Results  of  copies
              from  outside  the  window,  or  from  regions  of  the  window that are not exposed, are hardware
              dependent and undefined.

              External documentation.

       <b>copyTexImage1D(Target,</b> <b>Level,</b> <b>Internalformat,</b> <b>X,</b> <b>Y,</b> <b>Width,</b> <b>Border)</b> <b>-&gt;</b>
                         ok

              Types:

                 Target = enum()
                 Level = i()
                 Internalformat = enum()
                 X = Y = Width = Border = i()

              <u>gl:copyTexImage1D/7</u>  defines  a  one-dimensional  texture  image  with  pixels  from  the  current
              <u>?GL_READ_BUFFER</u>.

              External documentation.

       <b>copyTexImage2D(Target,</b> <b>Level,</b> <b>Internalformat,</b> <b>X,</b> <b>Y,</b> <b>Width,</b> <b>Height,</b>
                      Border) -&gt;
                         ok

              Types:

                 Target = enum()
                 Level = i()
                 Internalformat = enum()
                 X = Y = Width = Height = Border = i()

              <u>gl:copyTexImage2D/8</u> defines a two-dimensional texture image, or cube-map texture image with pixels
              from the current <u>?GL_READ_BUFFER</u>.

              External documentation.

       <b>copyTexSubImage1D(Target</b> <b>::</b> <b>enum(),</b>
                         Level :: i(),
                         Xoffset :: i(),
                         X :: i(),
                         Y :: i(),
                         Width :: i()) -&gt;
                            ok

              <u>gl:copyTexSubImage1D/6</u>  and <u>glCopyTextureSubImage1D</u> replace a portion of a one-dimensional texture
              image with pixels from the current <u>?GL_READ_BUFFER</u> (rather than from main memory, as is  the  case
              for  <u>gl:texSubImage1D/7</u>).  For  <u>gl:copyTexSubImage1D/6</u>, the texture object that is bound to <u>Target</u>
              will be used for the process. For <u>glCopyTextureSubImage1D</u>,  <u>Texture</u>  tells  which  texture  object
              should be used for the purpose of the call.

              External documentation.

       <b>copyTexSubImage2D(Target,</b> <b>Level,</b> <b>Xoffset,</b> <b>Yoffset,</b> <b>X,</b> <b>Y,</b> <b>Width,</b>
                         Height) -&gt;
                            ok

              Types:

                 Target = enum()
                 Level = Xoffset = Yoffset = X = Y = Width = Height = i()

              <u>gl:copyTexSubImage2D/8</u>  and  <u>glCopyTextureSubImage2D</u>  replace  a  rectangular  portion  of  a two-
              dimensional texture image, cube-map texture image, rectangular image, or a  linear  portion  of  a
              number  of  slices of a one-dimensional array texture with pixels from the current <u>?GL_READ_BUFFER</u>
              (rather than from main memory, as is the case for <u>gl:texSubImage2D/9</u>).

              External documentation.

       <b>copyTexSubImage3D(Target,</b> <b>Level,</b> <b>Xoffset,</b> <b>Yoffset,</b> <b>Zoffset,</b> <b>X,</b> <b>Y,</b>
                         Width, Height) -&gt;
                            ok

              Types:

                 Target = enum()
                 Level = Xoffset = Yoffset = Zoffset = X = Y = Width = Height = i()

              <u>gl:copyTexSubImage3D/9</u> and <u>glCopyTextureSubImage3D</u> functions replace a rectangular  portion  of  a
              three-dimensional   or   two-dimensional   array  texture  image  with  pixels  from  the  current
              <u>?GL_READ_BUFFER</u> (rather than from main memory, as is the case for <u>gl:texSubImage3D/11</u>).

              External documentation.

       <b>createBuffers(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:createBuffers/1</u> returns <u>N</u> previously unused buffer names in <u>Buffers</u>, each  representing  a  new
              buffer object initialized as if it had been bound to an unspecified target.

              External documentation.

       <b>createFramebuffers(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:createFramebuffers/1</u>  returns  <u>N</u>  previously  unused  framebuffer  names  in <u>Framebuffers</u>, each
              representing a new framebuffer object initialized to the default state.

              External documentation.

       <b>createProgram()</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:createProgram/0</u> creates an empty program object and returns a non-zero value by which it can be
              referenced. A program object is an object to which shader objects can be attached. This provides a
              mechanism to specify the shader objects that will be linked to create a program. It also  provides
              a  means  for checking the compatibility of the shaders that will be used to create a program (for
              instance, checking the compatibility between a vertex shader  and  a  fragment  shader).  When  no
              longer needed as part of a program object, shader objects can be detached.

              External documentation.

       <b>createProgramPipelines(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:createProgramPipelines/1</u>  returns <u>N</u> previously unused program pipeline names in <u>Pipelines</u>, each
              representing a new program pipeline object initialized to the default state.

              External documentation.

       <b>createQueries(Target</b> <b>::</b> <b>enum(),</b> <b>N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:createQueries/2</u> returns <u>N</u> previously unused query object names in <u>Ids</u>, each representing a  new
              query object with the specified <u>Target</u>.

              External documentation.

       <b>createRenderbuffers(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:createRenderbuffers/1</u>  returns  <u>N</u> previously unused renderbuffer object names in <u>Renderbuffers</u>,
              each representing a new renderbuffer object initialized to the default state.

              External documentation.

       <b>createSamplers(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:createSamplers/1</u> returns <u>N</u> previously unused sampler names in <u>Samplers</u>, each representing a new
              sampler object initialized to the default state.

              External documentation.

       <b>createShader(Type</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:createShader/1</u> creates an empty shader object and returns a non-zero value by which it  can  be
              referenced.  A  shader  object  is  used to maintain the source code strings that define a shader.
              <u>ShaderType</u> indicates the type of shader to be created. Five  types  of  shader  are  supported.  A
              shader  of type <u>?GL_COMPUTE_SHADER</u> is a shader that is intended to run on the programmable compute
              processor. A shader of type <u>?GL_VERTEX_SHADER</u>  is  a  shader  that  is  intended  to  run  on  the
              programmable  vertex  processor.  A  shader  of  type  <u>?GL_TESS_CONTROL_SHADER</u> is a shader that is
              intended to run on the programmable tessellation processor in the control stage. A shader of  type
              <u>?GL_TESS_EVALUATION_SHADER</u>  is  a  shader that is intended to run on the programmable tessellation
              processor in the evaluation stage. A shader of  type  <u>?GL_GEOMETRY_SHADER</u>  is  a  shader  that  is
              intended  to run on the programmable geometry processor. A shader of type <u>?GL_FRAGMENT_SHADER</u> is a
              shader that is intended to run on the programmable fragment processor.

              External documentation.

       <b>createShaderProgramv(Type</b> <b>::</b> <b>enum(),</b>
                            Strings :: [unicode:chardata()]) -&gt;
                               i()

              <u>gl:createShaderProgram()</u> creates a program object containing compiled and  linked  shaders  for  a
              single  stage  specified by <u>Type</u>. <u>Strings</u> refers to an array of <u>Count</u> strings from which to create
              the shader executables.

              External documentation.

       <b>createTextures(Target</b> <b>::</b> <b>enum(),</b> <b>N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:createTextures/2</u> returns <u>N</u> previously unused texture names in <u>Textures</u>, each representing a new
              texture object of the dimensionality and type specified by <u>Target</u> and initialized to  the  default
              values for that texture type.

              External documentation.

       <b>createTransformFeedbacks(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:createTransformFeedbacks/1</u>  returns <u>N</u> previously unused transform feedback object names in <u>Ids</u>,
              each representing a new transform feedback object initialized to the default state.

              External documentation.

       <b>createVertexArrays(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:createVertexArrays/1</u> returns <u>N</u> previously unused vertex array  object  names  in  <u>Arrays</u>,  each
              representing a new vertex array object initialized to the default state.

              External documentation.

       <b>cullFace(Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:cullFace/1</u>  specifies  whether  front-  or back-facing facets are culled (as specified by <u>mode</u>)
              when facet culling is enabled. Facet culling is initially disabled. To enable  and  disable  facet
              culling,  call  the  <u>gl:enable/1</u> and <u>gl:disable/1</u> commands with the argument <u>?GL_CULL_FACE</u>. Facets
              include triangles, quadrilaterals, polygons, and rectangles.

              External documentation.

       <b>debugMessageControl(Source</b> <b>::</b> <b>enum(),</b>
                           Type :: enum(),
                           Severity :: enum(),
                           Ids :: [i()],
                           Enabled :: 0 | 1) -&gt;
                              ok

              <u>gl:debugMessageControl/5</u> controls the reporting of debug messages generated by  a  debug  context.
              The  parameters  <u>Source</u>,  <u>Type</u>  and  <u>Severity</u>  form  a  filter to select messages from the pool of
              potential messages generated by the GL.

              External documentation.

       <b>debugMessageInsert(Source,</b> <b>Type,</b> <b>Id,</b> <b>Severity,</b> <b>Length,</b> <b>Buf)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Source = Type = enum()
                 Id = i()
                 Severity = enum()
                 Length = i()
                 Buf = string()

              <u>gl:debugMessageInsert/6</u> inserts a user-supplied  message  into  the  debug  output  queue.  <u>Source</u>
              specifies   the   source   that   will   be   used   to   classify   the   message   and  must  be
              <u>?GL_DEBUG_SOURCE_APPLICATION</u> or <u>?GL_DEBUG_SOURCE_THIRD_PARTY</u>. All other sources are  reserved  for
              use by the GL implementation. <u>Type</u> indicates the type of the message to be inserted and may be one
              of  <u>?GL_DEBUG_TYPE_ERROR</u>,  <u>?GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR</u>,  <u>?GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR</u>,
              <u>?GL_DEBUG_TYPE_PORTABILITY</u>,           <u>?GL_DEBUG_TYPE_PERFORMANCE</u>,           <u>?GL_DEBUG_TYPE_MARKER</u>,
              <u>?GL_DEBUG_TYPE_PUSH_GROUP</u>,  <u>?GL_DEBUG_TYPE_POP_GROUP</u>,  or <u>?GL_DEBUG_TYPE_OTHER</u>. <u>Severity</u> indicates
              the  severity  of  the  message  and  may  be  <u>?GL_DEBUG_SEVERITY_LOW</u>,  <u>?GL_DEBUG_SEVERITY_MEDIUM</u>,
              <u>?GL_DEBUG_SEVERITY_HIGH</u>  or  <u>?GL_DEBUG_SEVERITY_NOTIFICATION</u>.  <u>Id</u>  is  available  for  application
              defined use and may be any value. This value will be recorded and used to identify the message.

              External documentation.

       <b>deleteBuffers(Buffers</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteBuffers/1</u> deletes <u>N</u> buffer objects named by the elements of the array  <u>Buffers</u>.  After  a
              buffer  object  is  deleted,  it  has  no contents, and its name is free for reuse (for example by
              <u>gl:genBuffers/1</u>). If a buffer object that is currently bound is deleted, the binding reverts to  0
              (the absence of any buffer object).

              External documentation.

       <b>deleteFramebuffers(Framebuffers</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteFramebuffers/1</u>  deletes  the  <u>N</u>  framebuffer  objects whose names are stored in the array
              addressed by <u>Framebuffers</u>. The name zero is reserved by the GL and is silently ignored, should  it
              occur  in  <u>Framebuffers</u>, as are other unused names. Once a framebuffer object is deleted, its name
              is again unused and it has no attachments. If a framebuffer that is currently bound to one or more
              of  the  targets  <u>?GL_DRAW_FRAMEBUFFER</u>  or  <u>?GL_READ_FRAMEBUFFER</u>  is  deleted,  it  is  as  though
              <u>gl:bindFramebuffer/2</u> had been executed with the corresponding <u>Target</u> and <u>Framebuffer</u> zero.

              External documentation.

       <b>deleteLists(List</b> <b>::</b> <b>i(),</b> <b>Range</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteLists/2</u> causes a contiguous group of display lists to be deleted. <u>List</u> is the name of the
              first  display list to be deleted, and <u>Range</u> is the number of display lists to delete. All display
              lists d with list&amp;lt;= d&amp;lt;= list+range-1 are deleted.

              External documentation.

       <b>deleteProgram(Program</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteProgram/1</u> frees the memory and invalidates the name associated with  the  program  object
              specified by <u>Program.</u> This command effectively undoes the effects of a call to <u>gl:createProgram/0</u>.

              External documentation.

       <b>deleteProgramPipelines(Pipelines</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteProgramPipelines/1</u>  deletes  the <u>N</u> program pipeline objects whose names are stored in the
              array <u>Pipelines</u>. Unused names in <u>Pipelines</u> are ignored, as is  the  name  zero.  After  a  program
              pipeline  object  is deleted, its name is again unused and it has no contents. If program pipeline
              object that is currently bound is deleted, the binding for that object  reverts  to  zero  and  no
              program pipeline object becomes current.

              External documentation.

       <b>deleteQueries(Ids</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteQueries/1</u>  deletes  <u>N</u> query objects named by the elements of the array <u>Ids</u>. After a query
              object is deleted, it  has  no  contents,  and  its  name  is  free  for  reuse  (for  example  by
              <u>gl:genQueries/1</u>).

              External documentation.

       <b>deleteRenderbuffers(Renderbuffers</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteRenderbuffers/1</u>  deletes  the  <u>N</u> renderbuffer objects whose names are stored in the array
              addressed by <u>Renderbuffers</u>. The name zero is reserved by the GL and is silently ignored, should it
              occur in <u>Renderbuffers</u>, as are other unused names. Once a renderbuffer object is deleted, its name
              is again unused and it has no contents. If a renderbuffer that is currently bound  to  the  target
              <u>?GL_RENDERBUFFER</u> is deleted, it is as though <u>gl:bindRenderbuffer/2</u> had been executed with a <u>Target</u>
              of <u>?GL_RENDERBUFFER</u> and a <u>Name</u> of zero.

              External documentation.

       <b>deleteSamplers(Samplers</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteSamplers/1</u> deletes <u>N</u> sampler objects named by the elements of the array <u>Samplers</u>. After a
              sampler  object  is deleted, its name is again unused. If a sampler object that is currently bound
              to a sampler unit is deleted, it is as though <u>gl:bindSampler/2</u> is called with unit set to the unit
              the sampler is bound to and sampler zero. Unused names in samplers are silently ignored, as is the
              reserved name zero.

              External documentation.

       <b>deleteShader(Shader</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteShader/1</u> frees the memory and invalidates the name  associated  with  the  shader  object
              specified by <u>Shader</u>. This command effectively undoes the effects of a call to <u>gl:createShader/1</u>.

              External documentation.

       <b>deleteSync(Sync</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteSync/1</u>  deletes  the sync object specified by <u>Sync</u>. If the fence command corresponding to
              the specified sync object has completed, or if no <u>gl:waitSync/3</u>  or  <u>gl:clientWaitSync/3</u>  commands
              are  blocking  on <u>Sync</u>, the object is deleted immediately. Otherwise, <u>Sync</u> is flagged for deletion
              and will be deleted when it is no longer associated with  any  fence  command  and  is  no  longer
              blocking  any  <u>gl:waitSync/3</u> or <u>gl:clientWaitSync/3</u> command. In either case, after <u>gl:deleteSync/1</u>
              returns, the name <u>Sync</u> is invalid and can no longer be used to refer to the sync object.

              External documentation.

       <b>deleteTextures(Textures</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteTextures/1</u> deletes <u>N</u> textures named by the  elements  of  the  array  <u>Textures</u>.  After  a
              texture  is  deleted,  it  has  no contents or dimensionality, and its name is free for reuse (for
              example by <u>gl:genTextures/1</u>). If a texture that is currently bound is deleted, the binding reverts
              to 0 (the default texture).

              External documentation.

       <b>deleteTransformFeedbacks(Ids</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteTransformFeedbacks/1</u> deletes the <u>N</u> transform feedback objects whose names are  stored  in
              the  array  <u>Ids</u>.  Unused names in <u>Ids</u> are ignored, as is the name zero. After a transform feedback
              object is deleted, its name is again unused and  it  has  no  contents.  If  an  active  transform
              feedback  object is deleted, its name immediately becomes unused, but the underlying object is not
              deleted until it is no longer active.

              External documentation.

       <b>deleteVertexArrays(Arrays</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:deleteVertexArrays/1</u> deletes <u>N</u> vertex array  objects  whose  names  are  stored  in  the  array
              addressed  by  <u>Arrays</u>.  Once  a  vertex array object is deleted it has no contents and its name is
              again unused. If a vertex array object that is currently bound is deleted, the  binding  for  that
              object  reverts  to  zero and the default vertex array becomes current. Unused names in <u>Arrays</u> are
              silently ignored, as is the value zero.

              External documentation.

       <b>depthFunc(Func</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:depthFunc/1</u> specifies the function used to compare each incoming pixel  depth  value  with  the
              depth  value  present  in  the  depth buffer. The comparison is performed only if depth testing is
              enabled. (See <u>gl:enable/1</u> and <u>gl:disable/1</u> of <u>?GL_DEPTH_TEST</u>.)

              External documentation.

       <b>depthMask(Flag</b> <b>::</b> <b>0</b> <b>|</b> <b>1)</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:depthMask/1</u> specifies whether the depth buffer is enabled for writing. If  <u>Flag</u>  is  <u>?GL_FALSE</u>,
              depth  buffer  writing  is  disabled. Otherwise, it is enabled. Initially, depth buffer writing is
              enabled.

              External documentation.

       <b>depthRange(Near_val</b> <b>::</b> <b>clamp(),</b> <b>Far_val</b> <b>::</b> <b>clamp())</b> <b>-&gt;</b> <b>ok</b>

       <b>depthRangef(N</b> <b>::</b> <b>f(),</b> <b>F</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              After clipping and division by <u>w</u>, depth coordinates range from -1 to 1, corresponding to the  near
              and  far  clipping  planes.  <u>gl:depthRange/2</u>  specifies  a  linear mapping of the normalized depth
              coordinates in this range to window depth coordinates.  Regardless  of  the  actual  depth  buffer
              implementation,  window  coordinate depth values are treated as though they range from 0 through 1
              (like color components). Thus, the values accepted by <u>gl:depthRange/2</u> are  both  clamped  to  this
              range before they are accepted.

              External documentation.

       <b>depthRangeArrayv(First</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>[{f(),</b> <b>f()}])</b> <b>-&gt;</b> <b>ok</b>

              After  clipping and division by <u>w</u>, depth coordinates range from -1 to 1, corresponding to the near
              and far clipping planes. Each viewport has an  independent  depth  range  specified  as  a  linear
              mapping  of the normalized depth coordinates in this range to window depth coordinates. Regardless
              of the actual depth buffer implementation, window coordinate depth values are  treated  as  though
              they  range  from  0  through  1  (like color components). <u>gl:depthRangeArray()</u> specifies a linear
              mapping of the normalized depth coordinates in this range to window  depth  coordinates  for  each
              viewport  in  the  range [<u>First</u>, <u>First</u> + <u>Count</u>). Thus, the values accepted by <u>gl:depthRangeArray()</u>
              are both clamped to this range before they are accepted.

              External documentation.

       <b>depthRangeIndexed(Index</b> <b>::</b> <b>i(),</b> <b>N</b> <b>::</b> <b>f(),</b> <b>F</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              After clipping and division by <u>w</u>, depth coordinates range from -1 to 1, corresponding to the  near
              and  far  clipping  planes.  Each  viewport  has  an independent depth range specified as a linear
              mapping of the normalized depth coordinates in this range to window depth coordinates.  Regardless
              of  the  actual  depth buffer implementation, window coordinate depth values are treated as though
              they range from 0 through 1 (like color components).  <u>gl:depthRangeIndexed/3</u>  specifies  a  linear
              mapping  of  the  normalized  depth  coordinates  in  this range to window depth coordinates for a
              specified viewport. Thus, the values accepted by <u>gl:depthRangeIndexed/3</u> are both clamped  to  this
              range before they are accepted.

              External documentation.

       <b>detachShader(Program</b> <b>::</b> <b>i(),</b> <b>Shader</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:detachShader/2</u> detaches the shader object specified by <u>Shader</u> from the program object specified
              by <u>Program</u>. This command can be used to undo the effect of the command <u>gl:attachShader/2</u>.

              External documentation.

       <b>dispatchCompute(Num_groups_x</b> <b>::</b> <b>i(),</b>
                       Num_groups_y :: i(),
                       Num_groups_z :: i()) -&gt;
                          ok

              <u>gl:dispatchCompute/3</u> launches one or more compute work groups. Each work group is processed by the
              active program object for the compute shader stage. While the individual shader invocations within
              a  work  group  are  executed  as a unit, work groups are executed completely independently and in
              unspecified order. <u>Num_groups_x</u>, <u>Num_groups_y</u> and <u>Num_groups_z</u> specify the number  of  local  work
              groups that will be dispatched in the X, Y and Z dimensions, respectively.

              External documentation.

       <b>dispatchComputeIndirect(Indirect</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:dispatchComputeIndirect/1</u>  launches  one or more compute work groups using parameters stored in
              the buffer object currently bound to the <u>?GL_DISPATCH_INDIRECT_BUFFER</u> target. Each work  group  is
              processed  by  the active program object for the compute shader stage. While the individual shader
              invocations within a work group are executed as  a  unit,  work  groups  are  executed  completely
              independently  and  in  unspecified order. <u>Indirect</u> contains the offset into the data store of the
              buffer object bound to the <u>?GL_DISPATCH_INDIRECT_BUFFER</u> target at which the parameters are stored.

              External documentation.

       <b>drawArrays(Mode</b> <b>::</b> <b>enum(),</b> <b>First</b> <b>::</b> <b>i(),</b> <b>Count</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:drawArrays/3</u> specifies multiple geometric primitives with very few subroutine calls. Instead of
              calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge  flag,  or
              color,  you  can  prespecify  separate  arrays  of  vertices,  normals, and colors and use them to
              construct a sequence of primitives with a single call to <u>gl:drawArrays/3</u>.

              External documentation.

       <b>drawArraysIndirect(Mode</b> <b>::</b> <b>enum(),</b> <b>Indirect</b> <b>::</b> <b>offset()</b> <b>|</b> <b>mem())</b> <b>-&gt;</b>
                             ok

              <u>gl:drawArraysIndirect/2</u> specifies multiple geometric primitives with very  few  subroutine  calls.
              <u>gl:drawArraysIndirect/2</u>  behaves  similarly  to <u>gl:drawArraysInstancedBaseInstance/5</u>, execept that
              the parameters to <u>gl:drawArraysInstancedBaseInstance/5</u> are stored in memory at the  address  given
              by <u>Indirect</u>.

              External documentation.

       <b>drawArraysInstanced(Mode</b> <b>::</b> <b>enum(),</b>
                           First :: i(),
                           Count :: i(),
                           Instancecount :: i()) -&gt;
                              ok

              <u>gl:drawArraysInstanced/4</u>   behaves   identically  to  <u>gl:drawArrays/3</u>  except  that  <u>Instancecount</u>
              instances of the range of elements are executed and the value of the internal  counter  <u>InstanceID</u>
              advances  for each iteration. <u>InstanceID</u> is an internal 32-bit integer counter that may be read by
              a vertex shader as <u>?gl_InstanceID</u>.

              External documentation.

       <b>drawArraysInstancedBaseInstance(Mode</b> <b>::</b> <b>enum(),</b>
                                       First :: i(),
                                       Count :: i(),
                                       Instancecount :: i(),
                                       Baseinstance :: i()) -&gt;
                                          ok

              <u>gl:drawArraysInstancedBaseInstance/5</u>  behaves   identically   to   <u>gl:drawArrays/3</u>   except   that
              <u>Instancecount</u>  instances  of  the  range  of  elements  are executed and the value of the internal
              counter <u>InstanceID</u> advances for each iteration. <u>InstanceID</u> is an internal 32-bit  integer  counter
              that may be read by a vertex shader as <u>?gl_InstanceID</u>.

              External documentation.

       <b>drawBuffer(Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              When  colors are written to the frame buffer, they are written into the color buffers specified by
              <u>gl:drawBuffer/1</u>. One of the following values can be used for default framebuffer:

              External documentation.

       <b>drawBuffers(Bufs</b> <b>::</b> <b>[enum()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:drawBuffers/1</u> and <u>glNamedFramebufferDrawBuffers</u> define an array of buffers into  which  outputs
              from  the fragment shader data will be written. If a fragment shader writes a value to one or more
              user defined output variables, then the value of each variable will be  written  into  the  buffer
              specified  at  a  location within <u>Bufs</u> corresponding to the location assigned to that user defined
              output. The draw buffer used for user defined outputs assigned to locations greater than or  equal
              to <u>N</u> is implicitly set to <u>?GL_NONE</u> and any data written to such an output is discarded.

              External documentation.

       <b>drawElements(Mode</b> <b>::</b> <b>enum(),</b>
                    Count :: i(),
                    Type :: enum(),
                    Indices :: offset() | mem()) -&gt;
                       ok

              <u>gl:drawElements/4</u>  specifies multiple geometric primitives with very few subroutine calls. Instead
              of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or
              color, you can prespecify separate arrays of vertices,  normals,  and  so  on,  and  use  them  to
              construct a sequence of primitives with a single call to <u>gl:drawElements/4</u>.

              External documentation.

       <b>drawElementsBaseVertex(Mode,</b> <b>Count,</b> <b>Type,</b> <b>Indices,</b> <b>Basevertex)</b> <b>-&gt;</b>
                                 ok

              Types:

                 Mode = enum()
                 Count = i()
                 Type = enum()
                 Indices = offset() | mem()
                 Basevertex = i()

              <u>gl:drawElementsBaseVertex/5</u>  behaves  identically to <u>gl:drawElements/4</u> except that the <u>i</u>th element
              transferred by the corresponding draw call will be taken from element <u>Indices</u>[i] +  <u>Basevertex</u>  of
              each enabled array. If the resulting value is larger than the maximum value representable by <u>Type</u>,
              it  is  as  if  the  calculation  were  upconverted  to 32-bit unsigned integers (with wrapping on
              overflow conditions). The operation is undefined if the sum would be negative.

              External documentation.

       <b>drawElementsIndirect(Mode</b> <b>::</b> <b>enum(),</b>
                            Type :: enum(),
                            Indirect :: offset() | mem()) -&gt;
                               ok

              <u>gl:drawElementsIndirect/3</u> specifies multiple indexed geometric primitives with very few subroutine
              calls.            <u>gl:drawElementsIndirect/3</u>            behaves            similarly             to
              <u>gl:drawElementsInstancedBaseVertexBaseInstance/7</u>,     execpt     that     the     parameters    to
              <u>gl:drawElementsInstancedBaseVertexBaseInstance/7</u> are stored in memory  at  the  address  given  by
              <u>Indirect</u>.

              External documentation.

       <b>drawElementsInstanced(Mode,</b> <b>Count,</b> <b>Type,</b> <b>Indices,</b> <b>Instancecount)</b> <b>-&gt;</b>
                                ok

              Types:

                 Mode = enum()
                 Count = i()
                 Type = enum()
                 Indices = offset() | mem()
                 Instancecount = i()

              <u>gl:drawElementsInstanced/5</u>  behaves  identically  to  <u>gl:drawElements/4</u>  except that <u>Instancecount</u>
              instances of the set of elements are executed and the value of  the  internal  counter  <u>InstanceID</u>
              advances  for each iteration. <u>InstanceID</u> is an internal 32-bit integer counter that may be read by
              a vertex shader as <u>?gl_InstanceID</u>.

              External documentation.

       <b>drawElementsInstancedBaseInstance(Mode,</b> <b>Count,</b> <b>Type,</b> <b>Indices,</b>
                                         Instancecount, Baseinstance) -&gt;
                                            ok

              Types:

                 Mode = enum()
                 Count = i()
                 Type = enum()
                 Indices = offset() | mem()
                 Instancecount = Baseinstance = i()

              <u>gl:drawElementsInstancedBaseInstance/6</u>  behaves  identically  to  <u>gl:drawElements/4</u>  except   that
              <u>Instancecount</u>  instances of the set of elements are executed and the value of the internal counter
              <u>InstanceID</u> advances for each iteration. <u>InstanceID</u> is an internal 32-bit integer counter that  may
              be read by a vertex shader as <u>?gl_InstanceID</u>.

              External documentation.

       <b>drawElementsInstancedBaseVertex(Mode,</b> <b>Count,</b> <b>Type,</b> <b>Indices,</b>
                                       Instancecount, Basevertex) -&gt;
                                          ok

              Types:

                 Mode = enum()
                 Count = i()
                 Type = enum()
                 Indices = offset() | mem()
                 Instancecount = Basevertex = i()

              <u>gl:drawElementsInstancedBaseVertex/6</u> behaves identically to <u>gl:drawElementsInstanced/5</u> except that
              the <u>i</u>th element transferred by the corresponding draw call will be taken from element <u>Indices</u>[i] +
              <u>Basevertex</u>  of  each  enabled  array.  If  the  resulting  value  is larger than the maximum value
              representable by <u>Type</u>, it is as if the calculation were upconverted to  32-bit  unsigned  integers
              (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.

              External documentation.

       <b>drawElementsInstancedBaseVertexBaseInstance(Mode,</b> <b>Count,</b> <b>Type,</b>
                                                   Indices,
                                                   Instancecount,
                                                   Basevertex,
                                                   Baseinstance) -&gt;
                                                      ok

              Types:

                 Mode = enum()
                 Count = i()
                 Type = enum()
                 Indices = offset() | mem()
                 Instancecount = Basevertex = Baseinstance = i()

              <u>gl:drawElementsInstancedBaseVertexBaseInstance/7</u> behaves identically to <u>gl:drawElementsInstanced/5</u>
              except  that the <u>i</u>th element transferred by the corresponding draw call will be taken from element
              <u>Indices</u>[i] + <u>Basevertex</u> of each enabled array. If the resulting value is larger than  the  maximum
              value  representable  by  <u>Type</u>,  it  is  as if the calculation were upconverted to 32-bit unsigned
              integers (with wrapping on overflow conditions). The operation is undefined if the  sum  would  be
              negative.

              External documentation.

       <b>drawPixels(Width</b> <b>::</b> <b>i(),</b>
                  Height :: i(),
                  Format :: enum(),
                  Type :: enum(),
                  Pixels :: offset() | mem()) -&gt;
                     ok

              <u>gl:drawPixels/5</u>  reads  pixel data from memory and writes it into the frame buffer relative to the
              current raster position, provided that  the  raster  position  is  valid.  Use  <u>gl:rasterPos()</u>  or
              <u>gl:windowPos()</u>    to   set   the   current   raster   position;   use   <u>gl:get()</u>   with   argument
              <u>?GL_CURRENT_RASTER_POSITION_VALID</u> to determine if the specified  raster  position  is  valid,  and
              <u>gl:get()</u> with argument <u>?GL_CURRENT_RASTER_POSITION</u> to query the raster position.

              External documentation.

       <b>drawRangeElements(Mode,</b> <b>Start,</b> <b>End,</b> <b>Count,</b> <b>Type,</b> <b>Indices)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Mode = enum()
                 Start = End = Count = i()
                 Type = enum()
                 Indices = offset() | mem()

              <u>gl:drawRangeElements/6</u>  is  a  restricted  form  of  <u>gl:drawElements/4</u>.  <u>Mode</u>, and <u>Count</u> match the
              corresponding arguments to <u>gl:drawElements/4</u>, with the additional constraint that  all  values  in
              the arrays <u>Count</u> must lie between <u>Start</u> and <u>End</u>, inclusive.

              External documentation.

       <b>drawRangeElementsBaseVertex(Mode,</b> <b>Start,</b> <b>End,</b> <b>Count,</b> <b>Type,</b>
                                   Indices, Basevertex) -&gt;
                                      ok

              Types:

                 Mode = enum()
                 Start = End = Count = i()
                 Type = enum()
                 Indices = offset() | mem()
                 Basevertex = i()

              <u>gl:drawRangeElementsBaseVertex/7</u>  is a restricted form of <u>gl:drawElementsBaseVertex/5</u>. <u>Mode</u>, <u>Count</u>
              and  <u>Basevertex</u>  match  the  corresponding  arguments  to  <u>gl:drawElementsBaseVertex/5</u>,  with  the
              additional  constraint  that  all  values  in  the  array  <u>Indices</u> must lie between <u>Start</u> and <u>End</u>,
              inclusive, prior to adding <u>Basevertex</u>. Index values lying  outside  the  range  [<u>Start</u>,  <u>End</u>]  are
              treated  in  the  same  way  as  <u>gl:drawElementsBaseVertex/5</u>.  The  <u>i</u>th element transferred by the
              corresponding draw call will be taken from element <u>Indices</u>[i] + <u>Basevertex</u> of each enabled  array.
              If  the  resulting  value  is larger than the maximum value representable by <u>Type</u>, it is as if the
              calculation were upconverted to 32-bit unsigned integers (with wrapping on  overflow  conditions).
              The operation is undefined if the sum would be negative.

              External documentation.

       <b>drawTransformFeedback(Mode</b> <b>::</b> <b>enum(),</b> <b>Id</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:drawTransformFeedback/2</u>  draws  primitives  of a type specified by <u>Mode</u> using a count retrieved
              from the transform feedback specified by <u>Id</u>. Calling <u>gl:drawTransformFeedback/2</u> is  equivalent  to
              calling  <u>gl:drawArrays/3</u> with <u>Mode</u> as specified, <u>First</u> set to zero, and <u>Count</u> set to the number of
              vertices captured on vertex stream zero the  last  time  transform  feedback  was  active  on  the
              transform feedback object named by <u>Id</u>.

              External documentation.

       <b>drawTransformFeedbackInstanced(Mode</b> <b>::</b> <b>enum(),</b>
                                      Id :: i(),
                                      Instancecount :: i()) -&gt;
                                         ok

              <u>gl:drawTransformFeedbackInstanced/3</u>  draws  multiple  copies  of  a  range of primitives of a type
              specified by <u>Mode</u> using a count retrieved from the transform feedback stream specified  by  <u>Stream</u>
              of  the  transform feedback object specified by <u>Id</u>. Calling <u>gl:drawTransformFeedbackInstanced/3</u> is
              equivalent to calling <u>gl:drawArraysInstanced/4</u> with <u>Mode</u> and <u>Instancecount</u> as specified, <u>First</u> set
              to zero, and <u>Count</u> set to the number of vertices captured on vertex  stream  zero  the  last  time
              transform feedback was active on the transform feedback object named by <u>Id</u>.

              External documentation.

       <b>drawTransformFeedbackStream(Mode</b> <b>::</b> <b>enum(),</b>
                                   Id :: i(),
                                   Stream :: i()) -&gt;
                                      ok

              <u>gl:drawTransformFeedbackStream/3</u>  draws  primitives  of  a  type  specified  by <u>Mode</u> using a count
              retrieved from the transform feedback stream specified by <u>Stream</u> of the transform feedback  object
              specified by <u>Id</u>. Calling <u>gl:drawTransformFeedbackStream/3</u> is equivalent to calling <u>gl:drawArrays/3</u>
              with  <u>Mode</u>  as  specified,  <u>First</u> set to zero, and <u>Count</u> set to the number of vertices captured on
              vertex stream <u>Stream</u> the last time transform feedback was active on the transform feedback  object
              named by <u>Id</u>.

              External documentation.

       <b>drawTransformFeedbackStreamInstanced(Mode</b> <b>::</b> <b>enum(),</b>
                                            Id :: i(),
                                            Stream :: i(),
                                            Instancecount :: i()) -&gt;
                                               ok

              <u>gl:drawTransformFeedbackStreamInstanced/4</u> draws multiple copies of a range of primitives of a type
              specified  by  <u>Mode</u> using a count retrieved from the transform feedback stream specified by <u>Stream</u>
              of      the      transform      feedback      object      specified      by      <u>Id</u>.       Calling
              <u>gl:drawTransformFeedbackStreamInstanced/4</u>  is  equivalent to calling <u>gl:drawArraysInstanced/4</u> with
              <u>Mode</u> and <u>Instancecount</u> as specified, <u>First</u> set to zero, and <u>Count</u> set to the  number  of  vertices
              captured  on  vertex  stream  <u>Stream</u>  the last time transform feedback was active on the transform
              feedback object named by <u>Id</u>.

              External documentation.

       <b>edgeFlag(Flag</b> <b>::</b> <b>0</b> <b>|</b> <b>1)</b> <b>-&gt;</b> <b>ok</b>

       <b>edgeFlagv(X1</b> <b>::</b> <b>{Flag</b> <b>::</b> <b>0</b> <b>|</b> <b>1})</b> <b>-&gt;</b> <b>ok</b>

              Each vertex of a polygon,  separate  triangle,  or  separate  quadrilateral  specified  between  a
              <u>gl:'begin'/1</u>/<u>gl:'end'/0</u>  pair  is marked as the start of either a boundary or nonboundary edge. If
              the current edge flag is true when the vertex is specified, the vertex is marked as the start of a
              boundary edge. Otherwise, the vertex is marked as the start of a nonboundary  edge.  <u>gl:edgeFlag/1</u>
              sets the edge flag bit to <u>?GL_TRUE</u> if <u>Flag</u> is <u>?GL_TRUE</u> and to <u>?GL_FALSE</u> otherwise.

              External documentation.

       <b>edgeFlagPointer(Stride</b> <b>::</b> <b>i(),</b> <b>Ptr</b> <b>::</b> <b>offset()</b> <b>|</b> <b>mem())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:edgeFlagPointer/2</u>  specifies  the location and data format of an array of boolean edge flags to
              use when rendering. <u>Stride</u> specifies the byte stride from one edge  flag  to  the  next,  allowing
              vertices and attributes to be packed into a single array or stored in separate arrays.

              External documentation.

       <b>disable(Cap</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

       <b>disablei(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>enable(Cap</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

       <b>enablei(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:enable/1</u>  and  <u>gl:disable/1</u>  enable  and  disable  various  capabilities. Use <u>gl:isEnabled/1</u> or
              <u>gl:get()</u> to determine the current setting of any capability. The initial value for each capability
              with the exception  of  <u>?GL_DITHER</u>  and  <u>?GL_MULTISAMPLE</u>  is  <u>?GL_FALSE</u>.  The  initial  value  for
              <u>?GL_DITHER</u> and <u>?GL_MULTISAMPLE</u> is <u>?GL_TRUE</u>.

              External documentation.

       <b>disableClientState(Cap</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

       <b>enableClientState(Cap</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:enableClientState/1</u>  and  <u>gl:disableClientState/1</u>  enable  or  disable  individual  client-side
              capabilities. By default, all client-side capabilities are disabled.  Both  <u>gl:enableClientState/1</u>
              and  <u>gl:disableClientState/1</u>  take  a  single argument, <u>Cap</u>, which can assume one of the following
              values:

              External documentation.

       <b>disableVertexArrayAttrib(Vaobj</b> <b>::</b> <b>i(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>disableVertexAttribArray(Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>enableVertexArrayAttrib(Vaobj</b> <b>::</b> <b>i(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>enableVertexAttribArray(Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:enableVertexAttribArray/1</u> and <u>gl:enableVertexArrayAttrib/2</u> enable the generic vertex  attribute
              array  specified  by  <u>Index</u>. <u>gl:enableVertexAttribArray/1</u> uses currently bound vertex array object
              for the operation, whereas <u>gl:enableVertexArrayAttrib/2</u> updates state of the vertex  array  object
              with ID <u>Vaobj</u>.

              External documentation.

       <b>evalCoord1d(U</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>evalCoord1dv(X1</b> <b>::</b> <b>{U</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>evalCoord1f(U</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>evalCoord1fv(X1</b> <b>::</b> <b>{U</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>evalCoord2d(U</b> <b>::</b> <b>f(),</b> <b>V</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>evalCoord2dv(X1</b> <b>::</b> <b>{U</b> <b>::</b> <b>f(),</b> <b>V</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>evalCoord2f(U</b> <b>::</b> <b>f(),</b> <b>V</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>evalCoord2fv(X1</b> <b>::</b> <b>{U</b> <b>::</b> <b>f(),</b> <b>V</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:evalCoord1()</u>  evaluates  enabled  one-dimensional  maps at argument <u>U</u>. <u>gl:evalCoord2()</u> does the
              same for two-dimensional maps using two domain values, <u>U</u> and <u>V</u>. To define a map, call  <u>glMap1</u>  and
              <u>glMap2</u>; to enable and disable it, call <u>gl:enable/1</u> and <u>gl:disable/1</u>.

              External documentation.

       <b>evalMesh1(Mode</b> <b>::</b> <b>enum(),</b> <b>I1</b> <b>::</b> <b>i(),</b> <b>I2</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>evalMesh2(Mode</b> <b>::</b> <b>enum(),</b>
                 I1 :: i(),
                 I2 :: i(),
                 J1 :: i(),
                 J2 :: i()) -&gt;
                    ok

              <u>gl:mapGrid()</u> and <u>gl:evalMesh()</u> are used in tandem to efficiently generate and evaluate a series of
              evenly-spaced  map domain values. <u>gl:evalMesh()</u> steps through the integer domain of a one- or two-
              dimensional grid, whose range is the domain of the evaluation maps specified by <u>glMap1</u> and <u>glMap2</u>.
              <u>Mode</u> determines whether the resulting vertices are connected as points, lines, or filled polygons.

              External documentation.

       <b>evalPoint1(I</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>evalPoint2(I</b> <b>::</b> <b>i(),</b> <b>J</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:mapGrid()</u> and <u>gl:evalMesh()</u> are used in tandem to efficiently generate and evaluate a series of
              evenly spaced map domain values. <u>gl:evalPoint()</u> can be used to evaluate a single grid point in the
              same gridspace that is traversed  by  <u>gl:evalMesh()</u>.  Calling  <u>gl:evalPoint1/1</u>  is  equivalent  to
              calling glEvalCoord1( i. u+u 1 ); where  u=(u 2-u 1)/n

              External documentation.

       <b>feedbackBuffer(Size</b> <b>::</b> <b>i(),</b> <b>Type</b> <b>::</b> <b>enum(),</b> <b>Buffer</b> <b>::</b> <b>mem())</b> <b>-&gt;</b> <b>ok</b>

              The  <u>gl:feedbackBuffer/3</u>  function  controls feedback. Feedback, like selection, is a GL mode. The
              mode is selected by calling <u>gl:renderMode/1</u> with <u>?GL_FEEDBACK</u>. When the GL is in feedback mode, no
              pixels are produced by rasterization. Instead, information about primitives that would  have  been
              rasterized is fed back to the application using the GL.

              External documentation.

       <b>fenceSync(Condition</b> <b>::</b> <b>enum(),</b> <b>Flags</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:fenceSync/2</u> creates a new fence sync object, inserts a fence command into the GL command stream
              and  associates  it  with  that sync object, and returns a non-zero name corresponding to the sync
              object.

              External documentation.

       <b>finish()</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:finish/0</u> does not return until the effects of all previously called GL commands  are  complete.
              Such  effects include all changes to GL state, all changes to connection state, and all changes to
              the frame buffer contents.

              External documentation.

       <b>flush()</b> <b>-&gt;</b> <b>ok</b>

              Different GL implementations buffer commands in several  different  locations,  including  network
              buffers  and the graphics accelerator itself. <u>gl:flush/0</u> empties all of these buffers, causing all
              issued commands to be executed as quickly as they are accepted by  the  actual  rendering  engine.
              Though  this  execution  may  not  be completed in any particular time period, it does complete in
              finite time.

              External documentation.

       <b>flushMappedBufferRange(Target</b> <b>::</b> <b>enum(),</b>
                              Offset :: i(),
                              Length :: i()) -&gt;
                                 ok

       <b>flushMappedNamedBufferRange(Buffer</b> <b>::</b> <b>i(),</b>
                                   Offset :: i(),
                                   Length :: i()) -&gt;
                                      ok

              <u>gl:flushMappedBufferRange/3</u> indicates that modifications have been made to a  range  of  a  mapped
              buffer    object.    The   buffer   object   must   previously   have   been   mapped   with   the
              <u>?GL_MAP_FLUSH_EXPLICIT_BIT</u> flag.

              External documentation.

       <b>fogf(Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>fogfv(Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b> <b>ok</b>

       <b>fogi(Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>fogiv(Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b> <b>ok</b>

              Fog is initially disabled. While enabled, fog affects  rasterized  geometry,  bitmaps,  and  pixel
              blocks,  but  not  buffer  clear  operations.  To  enable  and  disable  fog, call <u>gl:enable/1</u> and
              <u>gl:disable/1</u> with argument <u>?GL_FOG</u>.

              External documentation.

       <b>fogCoordd(Coord</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>fogCoorddv(X1</b> <b>::</b> <b>{Coord</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>fogCoordf(Coord</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>fogCoordfv(X1</b> <b>::</b> <b>{Coord</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:fogCoord()</u> specifies the fog coordinate that is associated with each  vertex  and  the  current
              raster  position.  The  value  specified  is interpolated and used in computing the fog color (see
              <u>gl:fog()</u>).

              External documentation.

       <b>fogCoordPointer(Type</b> <b>::</b> <b>enum(),</b>
                       Stride :: i(),
                       Pointer :: offset() | mem()) -&gt;
                          ok

              <u>gl:fogCoordPointer/3</u> specifies the location and data format of an array of fog coordinates to  use
              when rendering. <u>Type</u> specifies the data type of each fog coordinate, and <u>Stride</u> specifies the byte
              stride  from  one fog coordinate to the next, allowing vertices and attributes to be packed into a
              single array or stored in separate arrays.

              External documentation.

       <b>framebufferParameteri(Target</b> <b>::</b> <b>enum(),</b>
                             Pname :: enum(),
                             Param :: i()) -&gt;
                                ok

              <u>gl:framebufferParameteri/3</u> and <u>glNamedFramebufferParameteri</u> modify  the  value  of  the  parameter
              named <u>Pname</u> in the specified framebuffer object. There are no modifiable parameters of the default
              draw and read framebuffer, so they are not valid targets of these commands.

              External documentation.

       <b>framebufferRenderbuffer(Target,</b> <b>Attachment,</b> <b>Renderbuffertarget,</b>
                               Renderbuffer) -&gt;
                                  ok

              Types:

                 Target = Attachment = Renderbuffertarget = enum()
                 Renderbuffer = i()

              <u>gl:framebufferRenderbuffer/4</u>  and <u>glNamedFramebufferRenderbuffer</u> attaches a renderbuffer as one of
              the logical buffers of the specified framebuffer object. Renderbuffers cannot be attached  to  the
              default draw and read framebuffer, so they are not valid targets of these commands.

              External documentation.

       <b>framebufferTexture(Target</b> <b>::</b> <b>enum(),</b>
                          Attachment :: enum(),
                          Texture :: i(),
                          Level :: i()) -&gt;
                             ok

       <b>framebufferTexture1D(Target</b> <b>::</b> <b>enum(),</b>
                            Attachment :: enum(),
                            Textarget :: enum(),
                            Texture :: i(),
                            Level :: i()) -&gt;
                               ok

       <b>framebufferTexture2D(Target</b> <b>::</b> <b>enum(),</b>
                            Attachment :: enum(),
                            Textarget :: enum(),
                            Texture :: i(),
                            Level :: i()) -&gt;
                               ok

       <b>framebufferTexture3D(Target,</b> <b>Attachment,</b> <b>Textarget,</b> <b>Texture,</b>
                            Level, Zoffset) -&gt;
                               ok

       <b>framebufferTextureFaceARB(Target</b> <b>::</b> <b>enum(),</b>
                                 Attachment :: enum(),
                                 Texture :: i(),
                                 Level :: i(),
                                 Face :: enum()) -&gt;
                                    ok

       <b>framebufferTextureLayer(Target</b> <b>::</b> <b>enum(),</b>
                               Attachment :: enum(),
                               Texture :: i(),
                               Level :: i(),
                               Layer :: i()) -&gt;
                                  ok

              These  commands  attach a selected mipmap level or image of a texture object as one of the logical
              buffers of the specified framebuffer object. Textures cannot be attached to the default  draw  and
              read framebuffer, so they are not valid targets of these commands.

              External documentation.

       <b>frontFace(Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              In  a  scene  composed entirely of opaque closed surfaces, back-facing polygons are never visible.
              Eliminating these invisible polygons has the obvious benefit of speeding up the rendering  of  the
              image.   To  enable  and  disable  elimination  of  back-facing  polygons,  call  <u>gl:enable/1</u>  and
              <u>gl:disable/1</u> with argument <u>?GL_CULL_FACE</u>.

              External documentation.

       <b>frustum(Left</b> <b>::</b> <b>f(),</b>
               Right :: f(),
               Bottom :: f(),
               Top :: f(),
               Near_val :: f(),
               Far_val :: f()) -&gt;
                  ok

              <u>gl:frustum/6</u> describes a perspective matrix that produces a perspective  projection.  The  current
              matrix  (see  <u>gl:matrixMode/1</u>)  is  multiplied  by this matrix and the result replaces the current
              matrix, as if <u>gl:multMatrix()</u> were called with the following matrix as its argument:

              External documentation.

       <b>genBuffers(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:genBuffers/1</u> returns <u>N</u> buffer object names in <u>Buffers</u>. There is no  guarantee  that  the  names
              form  a  contiguous set of integers; however, it is guaranteed that none of the returned names was
              in use immediately before the call to <u>gl:genBuffers/1</u>.

              External documentation.

       <b>genFramebuffers(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:genFramebuffers/1</u> returns <u>N</u> framebuffer object names in <u>Ids</u>. There is  no  guarantee  that  the
              names form a contiguous set of integers; however, it is guaranteed that none of the returned names
              was in use immediately before the call to <u>gl:genFramebuffers/1</u>.

              External documentation.

       <b>genLists(Range</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:genLists/1</u>  has  one  argument, <u>Range</u>. It returns an integer <u>n</u> such that <u>Range</u> contiguous empty
              display lists, named n, n+1, ..., n+range-1, are created. If <u>Range</u> is 0, if there is no  group  of
              <u>Range</u>  contiguous  names  available, or if any error is generated, no display lists are generated,
              and 0 is returned.

              External documentation.

       <b>genProgramPipelines(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:genProgramPipelines/1</u> returns <u>N</u> previously unused program pipeline object names  in  <u>Pipelines</u>.
              These  names  are  marked  as  used,  for  the purposes of <u>gl:genProgramPipelines/1</u> only, but they
              acquire program pipeline state only when they are first bound.

              External documentation.

       <b>genQueries(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:genQueries/1</u> returns <u>N</u> query object names in <u>Ids</u>. There is no guarantee that the names  form  a
              contiguous  set  of integers; however, it is guaranteed that none of the returned names was in use
              immediately before the call to <u>gl:genQueries/1</u>.

              External documentation.

       <b>genRenderbuffers(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:genRenderbuffers/1</u> returns <u>N</u> renderbuffer object names in <u>Renderbuffers</u>. There is no  guarantee
              that  the  names  form  a  contiguous  set of integers; however, it is guaranteed that none of the
              returned names was in use immediately before the call to <u>gl:genRenderbuffers/1</u>.

              External documentation.

       <b>genSamplers(Count</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:genSamplers/1</u> returns <u>N</u> sampler object names in <u>Samplers</u>. There is no guarantee that the  names
              form  a  contiguous set of integers; however, it is guaranteed that none of the returned names was
              in use immediately before the call to <u>gl:genSamplers/1</u>.

              External documentation.

       <b>genTextures(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:genTextures/1</u> returns <u>N</u> texture names in <u>Textures</u>. There is no guarantee that the names form  a
              contiguous  set  of integers; however, it is guaranteed that none of the returned names was in use
              immediately before the call to <u>gl:genTextures/1</u>.

              External documentation.

       <b>genTransformFeedbacks(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:genTransformFeedbacks/1</u> returns <u>N</u> previously unused transform feedback  object  names  in  <u>Ids</u>.
              These  names  are  marked  as  used, for the purposes of <u>gl:genTransformFeedbacks/1</u> only, but they
              acquire transform feedback state only when they are first bound.

              External documentation.

       <b>genVertexArrays(N</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:genVertexArrays/1</u> returns <u>N</u> vertex array object names in <u>Arrays</u>. There is no guarantee that the
              names form a contiguous set of integers; however, it is guaranteed that none of the returned names
              was in use immediately before the call to <u>gl:genVertexArrays/1</u>.

              External documentation.

       <b>generateMipmap(Target</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

       <b>generateTextureMipmap(Texture</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:generateMipmap/1</u> and <u>gl:generateTextureMipmap/1</u> generates mipmaps  for  the  specified  texture
              object.   For   <u>gl:generateMipmap/1</u>,   the   texture   object   that   is  bound  to  <u>Target</u>.  For
              <u>gl:generateTextureMipmap/1</u>, <u>Texture</u> is the name of the texture object.

              External documentation.

       <b>getBooleani_v(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[0</b> <b>|</b> <b>1]</b>

       <b>getBooleanv(Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>[0</b> <b>|</b> <b>1]</b>

       <b>getDoublei_v(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[f()]</b>

       <b>getDoublev(Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>[f()]</b>

       <b>getFloati_v(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[f()]</b>

       <b>getFloatv(Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>[f()]</b>

       <b>getInteger64i_v(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

       <b>getInteger64v(Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>[i()]</b>

       <b>getIntegeri_v(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

       <b>getIntegerv(Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>[i()]</b>

              These commands return values for simple state variables  in  GL.  <u>Pname</u>  is  a  symbolic  constant
              indicating  the  state variable to be returned, and <u>Data</u> is a pointer to an array of the indicated
              type in which to place the returned data.

              External documentation.

       <b>getActiveAttrib(Program</b> <b>::</b> <b>i(),</b> <b>Index</b> <b>::</b> <b>i(),</b> <b>BufSize</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                          {Size :: i(), Type :: enum(), Name :: string()}

              <u>gl:getActiveAttrib/3</u> returns information about an active attribute variable in the program  object
              specified  by  <u>Program</u>. The number of active attributes can be obtained by calling <u>gl:getProgram()</u>
              with the value <u>?GL_ACTIVE_ATTRIBUTES</u>. A value of 0 for <u>Index</u> selects the  first  active  attribute
              variable. Permissible values for <u>Index</u> range from zero to the number of active attribute variables
              minus one.

              External documentation.

       <b>getActiveSubroutineName(Program</b> <b>::</b> <b>i(),</b>
                               Shadertype :: enum(),
                               Index :: i(),
                               Bufsize :: i()) -&gt;
                                  string()

              <u>gl:getActiveSubroutineName/4</u>  queries  the  name  of  an active shader subroutine uniform from the
              program object given in <u>Program</u>. <u>Index</u> specifies the index of the shader subroutine uniform within
              the shader stage given by <u>Stage</u>, and must between zero and  the  value  of  <u>?GL_ACTIVE_SUBROUTINES</u>
              minus one for the shader stage.

              External documentation.

       <b>getActiveSubroutineUniformName(Program</b> <b>::</b> <b>i(),</b>
                                      Shadertype :: enum(),
                                      Index :: i(),
                                      Bufsize :: i()) -&gt;
                                         string()

              <u>gl:getActiveSubroutineUniformName/4</u>  retrieves  the  name  of an active shader subroutine uniform.
              <u>Program</u> contains the name of the program containing the uniform. <u>Shadertype</u>  specifies  the  stage
              for which the uniform location, given by <u>Index</u>, is valid. <u>Index</u> must be between zero and the value
              of <u>?GL_ACTIVE_SUBROUTINE_UNIFORMS</u> minus one for the shader stage.

              External documentation.

       <b>getActiveUniform(Program</b> <b>::</b> <b>i(),</b> <b>Index</b> <b>::</b> <b>i(),</b> <b>BufSize</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                           {Size :: i(),
                            Type :: enum(),
                            Name :: string()}

              <u>gl:getActiveUniform/3</u>  returns  information about an active uniform variable in the program object
              specified by <u>Program</u>.  The  number  of  active  uniform  variables  can  be  obtained  by  calling
              <u>gl:getProgram()</u>  with  the  value  <u>?GL_ACTIVE_UNIFORMS</u>.  A  value of 0 for <u>Index</u> selects the first
              active uniform variable. Permissible values for <u>Index</u> range from zero  to  the  number  of  active
              uniform variables minus one.

              External documentation.

       <b>getActiveUniformBlockiv(Program</b> <b>::</b> <b>i(),</b>
                               UniformBlockIndex :: i(),
                               Pname :: enum(),
                               Params :: mem()) -&gt;
                                  ok

              <u>gl:getActiveUniformBlockiv/4</u> retrieves information about an active uniform block within <u>Program</u>.

              External documentation.

       <b>getActiveUniformBlockName(Program</b> <b>::</b> <b>i(),</b>
                                 UniformBlockIndex :: i(),
                                 BufSize :: i()) -&gt;
                                    string()

              <u>gl:getActiveUniformBlockName/3</u> retrieves the name of the active uniform block at <u>UniformBlockIndex</u>
              within <u>Program</u>.

              External documentation.

       <b>getActiveUniformName(Program</b> <b>::</b> <b>i(),</b>
                            UniformIndex :: i(),
                            BufSize :: i()) -&gt;
                               string()

              <u>gl:getActiveUniformName/3</u>  returns  the name of the active uniform at <u>UniformIndex</u> within <u>Program</u>.
              If <u>UniformName</u> is not NULL, up to <u>BufSize</u> characters (including a nul-terminator) will be  written
              into  the  array  whose  address is specified by <u>UniformName</u>. If <u>Length</u> is not NULL, the number of
              characters that were (or would have  been)  written  into  <u>UniformName</u>  (not  including  the  nul-
              terminator)  will  be  placed  in  the variable whose address is specified in <u>Length</u>. If <u>Length</u> is
              NULL, no length is returned. The length of the longest uniform name in <u>Program</u>  is  given  by  the
              value of <u>?GL_ACTIVE_UNIFORM_MAX_LENGTH</u>, which can be queried with <u>gl:getProgram()</u>.

              External documentation.

       <b>getActiveUniformsiv(Program</b> <b>::</b> <b>i(),</b>
                           UniformIndices :: [i()],
                           Pname :: enum()) -&gt;
                              [i()]

              <u>gl:getActiveUniformsiv/3</u>  queries  the value of the parameter named <u>Pname</u> for each of the uniforms
              within <u>Program</u> whose indices  are  specified  in  the  array  of  <u>UniformCount</u>  unsigned  integers
              <u>UniformIndices</u>.  Upon  success,  the  value  of the parameter for each uniform is written into the
              corresponding entry in the array whose address is given in  <u>Params</u>.  If  an  error  is  generated,
              nothing is written into <u>Params</u>.

              External documentation.

       <b>getAttachedShaders(Program</b> <b>::</b> <b>i(),</b> <b>MaxCount</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:getAttachedShaders/2</u>  returns the names of the shader objects attached to <u>Program</u>. The names of
              shader objects that are attached to <u>Program</u> will be returned in  <u>Shaders.</u>  The  actual  number  of
              shader  names  written  into  <u>Shaders</u>  is  returned in <u>Count.</u> If no shader objects are attached to
              <u>Program</u>, <u>Count</u> is set to 0. The maximum number of shader names that may be returned in <u>Shaders</u>  is
              specified by <u>MaxCount</u>.

              External documentation.

       <b>getAttribLocation(Program</b> <b>::</b> <b>i(),</b> <b>Name</b> <b>::</b> <b>string())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:getAttribLocation/2</u>  queries  the previously linked program object specified by <u>Program</u> for the
              attribute variable specified by <u>Name</u> and returns the index of the generic vertex attribute that is
              bound to that attribute variable. If <u>Name</u> is a matrix attribute variable, the index of  the  first
              column  of  the  matrix is returned. If the named attribute variable is not an active attribute in
              the specified program object or if <u>Name</u> starts with the reserved prefix "gl_", a value  of  -1  is
              returned.

              External documentation.

       <b>getBufferParameteri64v(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>[i()]</b>

       <b>getBufferParameterivARB(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                                  [i()]

              These functions return in <u>Data</u> a selected parameter of the specified buffer object.

              External documentation.

       <b>getBufferParameteriv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:getBufferParameteriv/2</u>  returns  in <u>Data</u> a selected parameter of the buffer object specified by
              <u>Target</u>.

              External documentation.

       <b>getBufferSubData(Target</b> <b>::</b> <b>enum(),</b>
                        Offset :: i(),
                        Size :: i(),
                        Data :: mem()) -&gt;
                           ok

              <u>gl:getBufferSubData/4</u> and <u>glGetNamedBufferSubData</u> return some or all of the data contents  of  the
              data  store  of the specified buffer object. Data starting at byte offset <u>Offset</u> and extending for
              <u>Size</u> bytes is copied from the buffer object's data store to the memory  pointed  to  by  <u>Data</u>.  An
              error  is thrown if the buffer object is currently mapped, or if <u>Offset</u> and <u>Size</u> together define a
              range beyond the bounds of the buffer object's data store.

              External documentation.

       <b>getClipPlane(Plane</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>{f(),</b> <b>f(),</b> <b>f(),</b> <b>f()}</b>

              <u>gl:getClipPlane/1</u> returns in <u>Equation</u> the four coefficients of the plane equation for <u>Plane</u>.

              External documentation.

       <b>getColorTable(Target</b> <b>::</b> <b>enum(),</b>
                     Format :: enum(),
                     Type :: enum(),
                     Table :: mem()) -&gt;
                        ok

              <u>gl:getColorTable/4</u> returns in <u>Table</u> the contents of the color table specified by <u>Target</u>. No  pixel
              transfer  operations are performed, but pixel storage modes that are applicable to <u>gl:readPixels/7</u>
              are performed.

              External documentation.

       <b>getColorTableParameterfv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                                   {f(), f(), f(), f()}

       <b>getColorTableParameteriv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                                   {i(), i(), i(), i()}

              Returns parameters specific to color table <u>Target</u>.

              External documentation.

       <b>getCompressedTexImage(Target</b> <b>::</b> <b>enum(),</b> <b>Lod</b> <b>::</b> <b>i(),</b> <b>Img</b> <b>::</b> <b>mem())</b> <b>-&gt;</b>
                                ok

              <u>gl:getCompressedTexImage/3</u>  and  <u>glGetnCompressedTexImage</u>  return  the  compressed  texture  image
              associated  with  <u>Target</u> and <u>Lod</u> into <u>Pixels</u>. <u>glGetCompressedTextureImage</u> serves the same purpose,
              but instead of taking a texture target, it takes the ID of the texture object. <u>Pixels</u> should be an
              array of <u>BufSize</u> bytes for <u>glGetnCompresedTexImage</u> and <u>glGetCompressedTextureImage</u> functions,  and
              of  <u>?GL_TEXTURE_COMPRESSED_IMAGE_SIZE</u>  bytes  in case of <u>gl:getCompressedTexImage/3</u>. If the actual
              data takes less space than <u>BufSize</u>, the remaining bytes will not be touched. <u>Target</u> specifies  the
              texture  target,  to which the texture the data the function should extract the data from is bound
              to. <u>Lod</u> specifies the level-of-detail number of the desired image.

              External documentation.

       <b>getConvolutionFilter(Target</b> <b>::</b> <b>enum(),</b>
                            Format :: enum(),
                            Type :: enum(),
                            Image :: mem()) -&gt;
                               ok

              <u>gl:getConvolutionFilter/4</u> returns the current 1D or 2D convolution filter kernel as an image.  The
              one-  or  two-dimensional  image  is placed in <u>Image</u> according to the specifications in <u>Format</u> and
              <u>Type</u>. No pixel transfer operations are performed on this image, but  the  relevant  pixel  storage
              modes are applied.

              External documentation.

       <b>getConvolutionParameterfv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                                    {f(), f(), f(), f()}

       <b>getConvolutionParameteriv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                                    {i(), i(), i(), i()}

              <u>gl:getConvolutionParameter()</u> retrieves convolution parameters. <u>Target</u> determines which convolution
              filter is queried. <u>Pname</u> determines which parameter is returned:

              External documentation.

       <b>getDebugMessageLog(Count</b> <b>::</b> <b>i(),</b> <b>BufSize</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                             {i(),
                              Sources :: [enum()],
                              Types :: [enum()],
                              Ids :: [i()],
                              Severities :: [enum()],
                              MessageLog :: string()}

              <u>gl:getDebugMessageLog/2</u> retrieves messages from the debug message log. A maximum of <u>Count</u> messages
              are retrieved from the log. If <u>Sources</u> is not NULL then the source of each message is written into
              up  to  <u>Count</u> elements of the array. If <u>Types</u> is not NULL then the type of each message is written
              into up to <u>Count</u> elements of the array. If <u>Id</u> is not NULL then the identifier of each  message  is
              written  into  up  to  <u>Count</u> elements of the array. If <u>Severities</u> is not NULL then the severity of
              each message is written into up to <u>Count</u> elements of the array. If <u>Lengths</u> is not  NULL  then  the
              length of each message is written into up to <u>Count</u> elements of the array.

              External documentation.

       <b>getError()</b> <b>-&gt;</b> <b>enum()</b>

              <u>gl:getError/0</u>  returns  the  value  of the error flag. Each detectable error is assigned a numeric
              code and symbolic name. When an error occurs, the error flag is set to the appropriate error  code
              value. No other errors are recorded until <u>gl:getError/0</u> is called, the error code is returned, and
              the flag is reset to <u>?GL_NO_ERROR</u>. If a call to <u>gl:getError/0</u> returns <u>?GL_NO_ERROR</u>, there has been
              no detectable error since the last call to <u>gl:getError/0</u>, or since the GL was initialized.

              External documentation.

       <b>getFragDataIndex(Program</b> <b>::</b> <b>i(),</b> <b>Name</b> <b>::</b> <b>string())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:getFragDataIndex/2</u> returns the index of the fragment color to which the variable <u>Name</u> was bound
              when the program object <u>Program</u> was last linked. If <u>Name</u> is not a varying out variable of <u>Program</u>,
              or if an error occurs, -1 will be returned.

              External documentation.

       <b>getFragDataLocation(Program</b> <b>::</b> <b>i(),</b> <b>Name</b> <b>::</b> <b>string())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:getFragDataLocation/2</u>  retrieves the assigned color number binding for the user-defined varying
              out variable <u>Name</u> for program <u>Program</u>. <u>Program</u> must have previously been linked. <u>Name</u>  must  be  a
              null-terminated  string.  If  <u>Name</u>  is not the name of an active user-defined varying out fragment
              shader variable within <u>Program</u>, -1 will be returned.

              External documentation.

       <b>getFramebufferAttachmentParameteriv(Target</b> <b>::</b> <b>enum(),</b>
                                           Attachment :: enum(),
                                           Pname :: enum()) -&gt;
                                              i()

              <u>gl:getFramebufferAttachmentParameteriv/3</u>  and  <u>glGetNamedFramebufferAttachmentParameteriv</u>   return
              parameters of attachments of a specified framebuffer object.

              External documentation.

       <b>getFramebufferParameteriv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                                    i()

              <u>gl:getFramebufferParameteriv/2</u>   and   <u>glGetNamedFramebufferParameteriv</u>   query  parameters  of  a
              specified framebuffer object.

              External documentation.

       <b>getGraphicsResetStatus()</b> <b>-&gt;</b> <b>enum()</b>

              Certain events can result in a reset of the GL context. Such a reset causes all context  state  to
              be lost and requires the application to recreate all objects in the affected context.

              External documentation.

       <b>getHistogram(Target</b> <b>::</b> <b>enum(),</b>
                    Reset :: 0 | 1,
                    Format :: enum(),
                    Type :: enum(),
                    Values :: mem()) -&gt;
                       ok

              <u>gl:getHistogram/5</u>  returns  the  current  histogram table as a one-dimensional image with the same
              width as the histogram. No pixel transfer operations  are  performed  on  this  image,  but  pixel
              storage modes that are applicable to 1D images are honored.

              External documentation.

       <b>getHistogramParameterfv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                                  {f()}

       <b>getHistogramParameteriv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                                  {i()}

              <u>gl:getHistogramParameter()</u>  is  used  to query parameter values for the current histogram or for a
              proxy. The histogram state information may be queried by calling <u>gl:getHistogramParameter()</u> with a
              <u>Target</u>  of  <u>?GL_HISTOGRAM</u>  (to  obtain  information  for   the   current   histogram   table)   or
              <u>?GL_PROXY_HISTOGRAM</u>  (to  obtain  information  from  the most recent proxy request) and one of the
              following values for the <u>Pname</u> argument:

              External documentation.

       <b>getInternalformati64v(Target</b> <b>::</b> <b>enum(),</b>
                             Internalformat :: enum(),
                             Pname :: enum(),
                             BufSize :: i()) -&gt;
                                [i()]

       <b>getInternalformativ(Target</b> <b>::</b> <b>enum(),</b>
                           Internalformat :: enum(),
                           Pname :: enum(),
                           BufSize :: i()) -&gt;
                              [i()]

              <u>gl:getInternalformativ/4</u> and <u>gl:getInternalformati64v/4</u> retrieve information about implementation-
              dependent support for internal formats. <u>Target</u> indicates the target with which the internal format
              will  be  used   and   must   be   one   of   <u>?GL_RENDERBUFFER</u>,   <u>?GL_TEXTURE_2D_MULTISAMPLE</u>,   or
              <u>?GL_TEXTURE_2D_MULTISAMPLE_ARRAY</u>,  corresponding  to  usage  as  a  renderbuffer,  two-dimensional
              multisample texture or two-dimensional multisample array texture, respectively.

              External documentation.

       <b>getLightfv(Light</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                     {f(), f(), f(), f()}

       <b>getLightiv(Light</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                     {i(), i(), i(), i()}

              <u>gl:getLight()</u> returns in <u>Params</u> the value or values of a light source parameter. <u>Light</u>  names  the
              light  and  is  a  symbolic  name  of  the  form <u>?GL_LIGHT</u> i where i ranges from 0 to the value of
              <u>?GL_MAX_LIGHTS</u> - 1. <u>?GL_MAX_LIGHTS</u> is an implementation dependent constant that is greater than or
              equal to eight. <u>Pname</u> specifies one of ten light source parameters, again by symbolic name.

              External documentation.

       <b>getMapdv(Target</b> <b>::</b> <b>enum(),</b> <b>Query</b> <b>::</b> <b>enum(),</b> <b>V</b> <b>::</b> <b>mem())</b> <b>-&gt;</b> <b>ok</b>

       <b>getMapfv(Target</b> <b>::</b> <b>enum(),</b> <b>Query</b> <b>::</b> <b>enum(),</b> <b>V</b> <b>::</b> <b>mem())</b> <b>-&gt;</b> <b>ok</b>

       <b>getMapiv(Target</b> <b>::</b> <b>enum(),</b> <b>Query</b> <b>::</b> <b>enum(),</b> <b>V</b> <b>::</b> <b>mem())</b> <b>-&gt;</b> <b>ok</b>

              <u>glMap1</u> and <u>glMap2</u> define evaluators. <u>gl:getMap()</u> returns evaluator parameters.  <u>Target</u>  chooses  a
              map,  <u>Query</u>  selects  a  specific  parameter,  and  <u>V</u>  points  to storage where the values will be
              returned.

              External documentation.

       <b>getMaterialfv(Face</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                        {f(), f(), f(), f()}

       <b>getMaterialiv(Face</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                        {i(), i(), i(), i()}

              <u>gl:getMaterial()</u> returns in <u>Params</u> the value or values of parameter <u>Pname</u> of  material  <u>Face</u>.  Six
              parameters are defined:

              External documentation.

       <b>getMinmax(Target</b> <b>::</b> <b>enum(),</b>
                 Reset :: 0 | 1,
                 Format :: enum(),
                 Types :: enum(),
                 Values :: mem()) -&gt;
                    ok

              <u>gl:getMinmax/5</u>  returns  the  accumulated  minimum  and  maximum  pixel values (computed on a per-
              component basis) in a one-dimensional image of width 2. The first set of  return  values  are  the
              minima,  and  the  second  set of return values are the maxima. The format of the return values is
              determined by <u>Format</u>, and their type is determined by <u>Types</u>.

              External documentation.

       <b>getMinmaxParameterfv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>{f()}</b>

       <b>getMinmaxParameteriv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>{i()}</b>

              <u>gl:getMinmaxParameter()</u> retrieves parameters for the current minmax table by setting <u>Pname</u> to  one
              of the following values:

              External documentation.

       <b>getMultisamplefv(Pname</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>{f(),</b> <b>f()}</b>

              <u>gl:getMultisamplefv/2</u> queries the location of a given sample. <u>Pname</u> specifies the sample parameter
              to  retrieve  and  must  be  <u>?GL_SAMPLE_POSITION</u>.  <u>Index</u>  corresponds  to the sample for which the
              location should be returned. The sample location is  returned  as  two  floating-point  values  in
              <u>Val[0]</u>  and  <u>Val[1]</u>,  each between 0 and 1, corresponding to the <u>X</u> and <u>Y</u> locations respectively in
              the GL pixel space of that sample. (0.5, 0.5) this corresponds to the pixel center. <u>Index</u> must  be
              between zero and the value of <u>?GL_SAMPLES</u> minus one.

              External documentation.

       <b>getPixelMapfv(Map</b> <b>::</b> <b>enum(),</b> <b>Values</b> <b>::</b> <b>mem())</b> <b>-&gt;</b> <b>ok</b>

       <b>getPixelMapuiv(Map</b> <b>::</b> <b>enum(),</b> <b>Values</b> <b>::</b> <b>mem())</b> <b>-&gt;</b> <b>ok</b>

       <b>getPixelMapusv(Map</b> <b>::</b> <b>enum(),</b> <b>Values</b> <b>::</b> <b>mem())</b> <b>-&gt;</b> <b>ok</b>

              See  the  <u>gl:pixelMap()</u>  reference  page  for  a  description of the acceptable values for the <u>Map</u>
              parameter. <u>gl:getPixelMap()</u> returns in <u>Data</u> the contents of the pixel map specified in <u>Map</u>.  Pixel
              maps   are  used  during  the  execution  of  <u>gl:readPixels/7</u>,  <u>gl:drawPixels/5</u>,  <u>gl:copyPixels/5</u>,
              <u>gl:texImage1D/8</u>,  <u>gl:texImage2D/9</u>,   <u>gl:texImage3D/10</u>,   <u>gl:texSubImage1D/7</u>,   <u>gl:texSubImage2D/9</u>,
              <u>gl:texSubImage3D/11</u>,     <u>gl:copyTexImage1D/7</u>,     <u>gl:copyTexImage2D/8</u>,     <u>gl:copyTexSubImage1D/6</u>,
              <u>gl:copyTexSubImage2D/8</u>, and <u>gl:copyTexSubImage3D/9</u>. to map color indices, stencil  indices,  color
              components, and depth components to other values.

              External documentation.

       <b>getPolygonStipple()</b> <b>-&gt;</b> <b>binary()</b>

              <u>gl:getPolygonStipple/0</u>  returns  to <u>Pattern</u> a 3232 polygon stipple pattern. The pattern is packed
              into memory as if <u>gl:readPixels/7</u> with both <u>height</u> and <u>width</u> of 32, <u>type</u> of <u>?GL_BITMAP</u>, and <u>format</u>
              of <u>?GL_COLOR_INDEX</u> were called, and the stipple pattern were stored in  an  internal  3232  color
              index  buffer.  Unlike  <u>gl:readPixels/7</u>,  however, pixel transfer operations (shift, offset, pixel
              map) are not applied to the returned stipple image.

              External documentation.

       <b>getProgramiv(Program</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:getProgram()</u> returns in <u>Params</u> the value of a parameter for  a  specific  program  object.  The
              following parameters are defined:

              External documentation.

       <b>getProgramBinary(Program</b> <b>::</b> <b>i(),</b> <b>BufSize</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                           {BinaryFormat :: enum(), Binary :: binary()}

              <u>gl:getProgramBinary/2</u>  returns  a  binary representation of the compiled and linked executable for
              <u>Program</u> into the array of bytes whose address is specified in <u>Binary</u>. The maximum number of  bytes
              that  may be written into <u>Binary</u> is specified by <u>BufSize</u>. If the program binary is greater in size
              than <u>BufSize</u> bytes, then an error is generated, otherwise the actual number of bytes written  into
              <u>Binary</u>  is  returned in the variable whose address is given by <u>Length</u>. If <u>Length</u> is <u>?NULL</u>, then no
              length is returned.

              External documentation.

       <b>getProgramInfoLog(Program</b> <b>::</b> <b>i(),</b> <b>BufSize</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>string()</b>

              <u>gl:getProgramInfoLog/2</u>  returns  the  information  log  for  the  specified  program  object.  The
              information  log  for a program object is modified when the program object is linked or validated.
              The string that is returned will be null terminated.

              External documentation.

       <b>getProgramInterfaceiv(Program</b> <b>::</b> <b>i(),</b>
                             ProgramInterface :: enum(),
                             Pname :: enum()) -&gt;
                                i()

              <u>gl:getProgramInterfaceiv/3</u> queries the property of the interface identifed by <u>ProgramInterface</u>  in
              <u>Program</u>, the property name of which is given by <u>Pname</u>.

              External documentation.

       <b>getProgramPipelineiv(Pipeline</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:getProgramPipelineiv/2</u>  retrieves  the  value  of  a  property  of  the program pipeline object
              <u>Pipeline</u>. <u>Pname</u> specifies the name of the parameter whose value to  retrieve.  The  value  of  the
              parameter is written to the variable whose address is given by <u>Params</u>.

              External documentation.

       <b>getProgramPipelineInfoLog(Pipeline</b> <b>::</b> <b>i(),</b> <b>BufSize</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                                    string()

              <u>gl:getProgramPipelineInfoLog/2</u>  retrieves  the  info log for the program pipeline object <u>Pipeline</u>.
              The info log, including its null terminator, is written into the array of characters whose address
              is given by <u>InfoLog</u>. The maximum number of characters that may be written into <u>InfoLog</u> is given by
              <u>BufSize</u>, and the actual number of characters written into <u>InfoLog</u> is returned in the integer whose
              address is given by <u>Length</u>. If <u>Length</u> is <u>?NULL</u>, no length is returned.

              External documentation.

       <b>getProgramResourceIndex(Program</b> <b>::</b> <b>i(),</b>
                               ProgramInterface :: enum(),
                               Name :: string()) -&gt;
                                  i()

              <u>gl:getProgramResourceIndex/3</u> returns the unsigned integer index assigned to a resource named  <u>Name</u>
              in the interface type <u>ProgramInterface</u> of program object <u>Program</u>.

              External documentation.

       <b>getProgramResourceLocation(Program</b> <b>::</b> <b>i(),</b>
                                  ProgramInterface :: enum(),
                                  Name :: string()) -&gt;
                                     i()

              <u>gl:getProgramResourceLocation/3</u>  returns  the  location  assigned  to  the  variable named <u>Name</u> in
              interface <u>ProgramInterface</u> of program object <u>Program</u>. <u>Program</u> must be the name of a  program  that
              has  been  linked  successfully.  <u>ProgramInterface</u>  must be one of <u>?GL_UNIFORM</u>, <u>?GL_PROGRAM_INPUT</u>,
              <u>?GL_PROGRAM_OUTPUT</u>,      <u>?GL_VERTEX_SUBROUTINE_UNIFORM</u>,       <u>?GL_TESS_CONTROL_SUBROUTINE_UNIFORM</u>,
              <u>?GL_TESS_EVALUATION_SUBROUTINE_UNIFORM</u>,                           <u>?GL_GEOMETRY_SUBROUTINE_UNIFORM</u>,
              <u>?GL_FRAGMENT_SUBROUTINE_UNIFORM</u>, <u>?GL_COMPUTE_SUBROUTINE_UNIFORM</u>, or <u>?GL_TRANSFORM_FEEDBACK_BUFFER</u>.

              External documentation.

       <b>getProgramResourceLocationIndex(Program</b> <b>::</b> <b>i(),</b>
                                       ProgramInterface :: enum(),
                                       Name :: string()) -&gt;
                                          i()

              <u>gl:getProgramResourceLocationIndex/3</u> returns the fragment color index  assigned  to  the  variable
              named  <u>Name</u> in interface <u>ProgramInterface</u> of program object <u>Program</u>. <u>Program</u> must be the name of a
              program that has been linked successfully. <u>ProgramInterface</u> must be <u>?GL_PROGRAM_OUTPUT</u>.

              External documentation.

       <b>getProgramResourceName(Program</b> <b>::</b> <b>i(),</b>
                              ProgramInterface :: enum(),
                              Index :: i(),
                              BufSize :: i()) -&gt;
                                 string()

              <u>gl:getProgramResourceName/4</u> retrieves the name string assigned to the single active resource  with
              an  index of <u>Index</u> in the interface <u>ProgramInterface</u> of program object <u>Program</u>. <u>Index</u> must be less
              than the number of entries in the active resource list for <u>ProgramInterface</u>.

              External documentation.

       <b>getProgramStageiv(Program</b> <b>::</b> <b>i(),</b>
                         Shadertype :: enum(),
                         Pname :: enum()) -&gt;
                            i()

              <u>gl:getProgramStage()</u> queries a parameter of a shader stage attached to a program  object.  <u>Program</u>
              contains  the  name of the program to which the shader is attached. <u>Shadertype</u> specifies the stage
              from which to query the parameter. <u>Pname</u> specifies which parameter should be queried. The value or
              values of the parameter to be queried is returned in  the  variable  whose  address  is  given  in
              <u>Values</u>.

              External documentation.

       <b>getQueryIndexediv(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                            i()

              <u>gl:getQueryIndexediv/3</u>  returns  in <u>Params</u> a selected parameter of the indexed query object target
              specified by <u>Target</u> and <u>Index</u>. <u>Index</u> specifies the index of the query object target  and  must  be
              between zero and a target-specific maxiumum.

              External documentation.

       <b>getQueryBufferObjecti64v(Id</b> <b>::</b> <b>i(),</b>
                                Buffer :: i(),
                                Pname :: enum(),
                                Offset :: i()) -&gt;
                                   ok

       <b>getQueryBufferObjectiv(Id</b> <b>::</b> <b>i(),</b>
                              Buffer :: i(),
                              Pname :: enum(),
                              Offset :: i()) -&gt;
                                 ok

       <b>getQueryBufferObjectui64v(Id</b> <b>::</b> <b>i(),</b>
                                 Buffer :: i(),
                                 Pname :: enum(),
                                 Offset :: i()) -&gt;
                                    ok

       <b>getQueryBufferObjectuiv(Id</b> <b>::</b> <b>i(),</b>
                               Buffer :: i(),
                               Pname :: enum(),
                               Offset :: i()) -&gt;
                                  ok

       <b>getQueryObjecti64v(Id</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>i()</b>

       <b>getQueryObjectiv(Id</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>i()</b>

       <b>getQueryObjectui64v(Id</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>i()</b>

       <b>getQueryObjectuiv(Id</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>i()</b>

              These   commands   return   a   selected   parameter   of   the  query  object  specified  by  <u>Id</u>.
              <u>gl:getQueryObject()</u> returns in <u>Params</u> a selected parameter of the query object  specified  by  <u>Id</u>.
              <u>gl:getQueryBufferObject()</u>  returns in <u>Buffer</u> a selected parameter of the query object specified by
              <u>Id</u>, by writing it to <u>Buffer</u>'s data store at the byte offset specified by <u>Offset</u>.

              External documentation.

       <b>getQueryiv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:getQueryiv/2</u> returns in <u>Params</u> a selected parameter of the query  object  target  specified  by
              <u>Target</u>.

              External documentation.

       <b>getRenderbufferParameteriv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                                     i()

              <u>gl:getRenderbufferParameteriv/2</u>   and  <u>glGetNamedRenderbufferParameteriv</u>  query  parameters  of  a
              specified renderbuffer object.

              External documentation.

       <b>getSamplerParameterIiv(Sampler</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>[i()]</b>

       <b>getSamplerParameterIuiv(Sampler</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>[i()]</b>

       <b>getSamplerParameterfv(Sampler</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>[f()]</b>

       <b>getSamplerParameteriv(Sampler</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:getSamplerParameter()</u> returns in <u>Params</u> the value or values of the sampler parameter  specified
              as  <u>Pname</u>. <u>Sampler</u> defines the target sampler, and must be the name of an existing sampler object,
              returned  from  a  previous  call  to  <u>gl:genSamplers/1</u>.  <u>Pname</u>  accepts  the  same   symbols   as
              <u>gl:samplerParameter()</u>, with the same interpretations:

              External documentation.

       <b>getShaderiv(Shader</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:getShader()</u>  returns  in  <u>Params</u>  the  value  of  a parameter for a specific shader object. The
              following parameters are defined:

              External documentation.

       <b>getShaderInfoLog(Shader</b> <b>::</b> <b>i(),</b> <b>BufSize</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>string()</b>

              <u>gl:getShaderInfoLog/2</u> returns the information log for the specified shader object. The information
              log for a shader object is modified when the shader is compiled. The string that is returned  will
              be null terminated.

              External documentation.

       <b>getShaderPrecisionFormat(Shadertype</b> <b>::</b> <b>enum(),</b>
                                Precisiontype :: enum()) -&gt;
                                   {Range :: {i(), i()},
                                    Precision :: i()}

              <u>gl:getShaderPrecisionFormat/2</u>  retrieves  the numeric range and precision for the implementation's
              representation of quantities in different numeric formats in  specified  shader  type.  <u>ShaderType</u>
              specifies the type of shader for which the numeric precision and range is to be retrieved and must
              be  one of <u>?GL_VERTEX_SHADER</u> or <u>?GL_FRAGMENT_SHADER</u>. <u>PrecisionType</u> specifies the numeric format to
              query  and  must   be   one   of   <u>?GL_LOW_FLOAT</u>,   <u>?GL_MEDIUM_FLOAT?GL_HIGH_FLOAT</u>,   <u>?GL_LOW_INT</u>,
              <u>?GL_MEDIUM_INT</u>, or <u>?GL_HIGH_INT</u>.

              External documentation.

       <b>getShaderSource(Shader</b> <b>::</b> <b>i(),</b> <b>BufSize</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>string()</b>

              <u>gl:getShaderSource/2</u>  returns  the concatenation of the source code strings from the shader object
              specified by <u>Shader</u>. The source code strings for a shader object are the result of a previous call
              to <u>gl:shaderSource/2</u>. The string returned by the function will be null terminated.

              External documentation.

       <b>getString(Name</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>string()</b>

       <b>getStringi(Name</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>string()</b>

              <u>gl:getString/1</u> returns a pointer to a static string describing  some  aspect  of  the  current  GL
              connection. <u>Name</u> can be one of the following:

              External documentation.

       <b>getSubroutineIndex(Program</b> <b>::</b> <b>i(),</b>
                          Shadertype :: enum(),
                          Name :: string()) -&gt;
                             i()

              <u>gl:getSubroutineIndex/3</u>  returns  the index of a subroutine uniform within a shader stage attached
              to a program object. <u>Program</u> contains the name of the program to which  the  shader  is  attached.
              <u>Shadertype</u>  specifies  the  stage  from  which to query shader subroutine index. <u>Name</u> contains the
              null-terminated name of the subroutine uniform whose name to query.

              External documentation.

       <b>getSubroutineUniformLocation(Program</b> <b>::</b> <b>i(),</b>
                                    Shadertype :: enum(),
                                    Name :: string()) -&gt;
                                       i()

              <u>gl:getSubroutineUniformLocation/3</u> returns the location of the subroutine uniform variable <u>Name</u>  in
              the  shader  stage  of  type  <u>Shadertype</u> attached to <u>Program</u>, with behavior otherwise identical to
              <u>gl:getUniformLocation/2</u>.

              External documentation.

       <b>getSynciv(Sync</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>BufSize</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>[i()]</b>

              <u>gl:getSynciv/3</u> retrieves properties of a sync object. <u>Sync</u> specifies the name of the  sync  object
              whose properties to retrieve.

              External documentation.

       <b>getTexEnvfv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                      {f(), f(), f(), f()}

       <b>getTexEnviv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                      {i(), i(), i(), i()}

              <u>gl:getTexEnv()</u>  returns in <u>Params</u> selected values of a texture environment that was specified with
              <u>gl:texEnv()</u>. <u>Target</u> specifies a texture environment.

              External documentation.

       <b>getTexGendv(Coord</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                      {f(), f(), f(), f()}

       <b>getTexGenfv(Coord</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                      {f(), f(), f(), f()}

       <b>getTexGeniv(Coord</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                      {i(), i(), i(), i()}

              <u>gl:getTexGen()</u> returns in <u>Params</u> selected parameters of a texture coordinate  generation  function
              that  was  specified  using  <u>gl:texGen()</u>. <u>Coord</u> names one of the (<u>s</u>, <u>t</u>, <u>r</u>, <u>q</u>) texture coordinates,
              using the symbolic constant <u>?GL_S</u>, <u>?GL_T</u>, <u>?GL_R</u>, or <u>?GL_Q</u>.

              External documentation.

       <b>getTexImage(Target</b> <b>::</b> <b>enum(),</b>
                   Level :: i(),
                   Format :: enum(),
                   Type :: enum(),
                   Pixels :: mem()) -&gt;
                      ok

              <u>gl:getTexImage/5</u>, <u>glGetnTexImage</u> and <u>glGetTextureImage</u>  functions  return  a  texture  image  into
              <u>Pixels</u>.  For  <u>gl:getTexImage/5</u>  and  <u>glGetnTexImage</u>,  <u>Target</u> specifies whether the desired texture
              image is one specified by <u>gl:texImage1D/8</u> (<u>?GL_TEXTURE_1D</u>), <u>gl:texImage2D/9</u> (<u>?GL_TEXTURE_1D_ARRAY</u>,
              <u>?GL_TEXTURE_RECTANGLE</u>, <u>?GL_TEXTURE_2D</u>  or  any  of  <u>?GL_TEXTURE_CUBE_MAP_*</u>),  or  <u>gl:texImage3D/10</u>
              (<u>?GL_TEXTURE_2D_ARRAY</u>, <u>?GL_TEXTURE_3D</u>, <u>?GL_TEXTURE_CUBE_MAP_ARRAY</u>). For <u>glGetTextureImage</u>, <u>Texture</u>
              specifies  the  texture object name. In addition to types of textures accepted by <u>gl:getTexImage/5</u>
              and <u>glGetnTexImage</u>, the function also accepts cube map  texture  objects  (with  effective  target
              <u>?GL_TEXTURE_CUBE_MAP</u>). <u>Level</u> specifies the level-of-detail number of the desired image. <u>Format</u> and
              <u>Type</u>  specify  the  format  and  type  of  the  desired  image  array.  See the reference page for
              <u>gl:texImage1D/8</u> for a description of the acceptable values for the  <u>Format</u>  and  <u>Type</u>  parameters,
              respectively.  For  glGetnTexImage  and glGetTextureImage functions, bufSize tells the size of the
              buffer to receive the retrieved pixel data. <u>glGetnTexImage</u> and <u>glGetTextureImage</u> do not write more
              than <u>BufSize</u> bytes into <u>Pixels</u>.

              External documentation.

       <b>getTexLevelParameterfv(Target</b> <b>::</b> <b>enum(),</b>
                              Level :: i(),
                              Pname :: enum()) -&gt;
                                 {f()}

       <b>getTexLevelParameteriv(Target</b> <b>::</b> <b>enum(),</b>
                              Level :: i(),
                              Pname :: enum()) -&gt;
                                 {i()}

              <u>gl:getTexLevelParameterfv/3</u>,   <u>gl:getTexLevelParameteriv/3</u>,    <u>glGetTextureLevelParameterfv</u>    and
              <u>glGetTextureLevelParameteriv</u>  return  in  <u>Params</u> texture parameter values for a specific level-of-
              detail value, specified as <u>Level</u>. For the first two functions, <u>Target</u> defines the target  texture,
              either <u>?GL_TEXTURE_1D</u>, <u>?GL_TEXTURE_2D</u>, <u>?GL_TEXTURE_3D</u>, <u>?GL_PROXY_TEXTURE_1D</u>, <u>?GL_PROXY_TEXTURE_2D</u>,
              <u>?GL_PROXY_TEXTURE_3D</u>,       <u>?GL_TEXTURE_CUBE_MAP_POSITIVE_X</u>,      <u>?GL_TEXTURE_CUBE_MAP_NEGATIVE_X</u>,
              <u>?GL_TEXTURE_CUBE_MAP_POSITIVE_Y</u>, <u>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</u>, <u>?GL_TEXTURE_CUBE_MAP_POSITIVE_Z</u>,
              <u>?GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</u>, or <u>?GL_PROXY_TEXTURE_CUBE_MAP</u>. The remaining two take  a  <u>Texture</u>
              argument which specifies the name of the texture object.

              External documentation.

       <b>getTexParameterIiv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                             {i(), i(), i(), i()}

       <b>getTexParameterIuiv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                              {i(), i(), i(), i()}

       <b>getTexParameterfv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                            {f(), f(), f(), f()}

       <b>getTexParameteriv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                            {i(), i(), i(), i()}

              <u>gl:getTexParameter()</u> and <u>glGetTextureParameter</u> return in <u>Params</u> the value or values of the texture
              parameter  specified  as <u>Pname</u>. <u>Target</u> defines the target texture. <u>?GL_TEXTURE_1D</u>, <u>?GL_TEXTURE_2D</u>,
              <u>?GL_TEXTURE_3D</u>,      <u>?GL_TEXTURE_1D_ARRAY</u>,      <u>?GL_TEXTURE_2D_ARRAY</u>,       <u>?GL_TEXTURE_RECTANGLE</u>,
              <u>?GL_TEXTURE_CUBE_MAP</u>,       <u>?GL_TEXTURE_CUBE_MAP_ARRAY</u>,       <u>?GL_TEXTURE_2D_MULTISAMPLE</u>,       or
              <u>?GL_TEXTURE_2D_MULTISAMPLE_ARRAY</u> specify one-, two-, or three-dimensional, one-dimensional  array,
              two-dimensional  array,  rectangle, cube-mapped or cube-mapped array, two-dimensional multisample,
              or two-dimensional multisample array texturing, respectively. <u>Pname</u> accepts the  same  symbols  as
              <u>gl:texParameter()</u>, with the same interpretations:

              External documentation.

       <b>getTransformFeedbackVarying(Program</b> <b>::</b> <b>i(),</b>
                                   Index :: i(),
                                   BufSize :: i()) -&gt;
                                      {Size :: i(),
                                       Type :: enum(),
                                       Name :: string()}

              Information  about  the  set of varying variables in a linked program that will be captured during
              transform   feedback   may   be    retrieved    by    calling    <u>gl:getTransformFeedbackVarying/3</u>.
              <u>gl:getTransformFeedbackVarying/3</u>  provides  information  about  the  varying  variable selected by
              <u>Index</u>. An <u>Index</u> of 0 selects the first varying variable specified in the <u>Varyings</u> array passed  to
              <u>gl:transformFeedbackVaryings/3</u>, and an <u>Index</u> of the value of <u>?GL_TRANSFORM_FEEDBACK_VARYINGS</u> minus
              one selects the last such variable.

              External documentation.

       <b>getUniformdv(Program</b> <b>::</b> <b>i(),</b> <b>Location</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>matrix()</b>

       <b>getUniformfv(Program</b> <b>::</b> <b>i(),</b> <b>Location</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>matrix()</b>

       <b>getUniformiv(Program</b> <b>::</b> <b>i(),</b> <b>Location</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                       {i(),
                        i(),
                        i(),
                        i(),
                        i(),
                        i(),
                        i(),
                        i(),
                        i(),
                        i(),
                        i(),
                        i(),
                        i(),
                        i(),
                        i(),
                        i()}

       <b>getUniformuiv(Program</b> <b>::</b> <b>i(),</b> <b>Location</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                        {i(),
                         i(),
                         i(),
                         i(),
                         i(),
                         i(),
                         i(),
                         i(),
                         i(),
                         i(),
                         i(),
                         i(),
                         i(),
                         i(),
                         i(),
                         i()}

              <u>gl:getUniform()</u> and <u>glGetnUniform</u> return in <u>Params</u> the value(s) of the specified uniform variable.
              The  type  of the uniform variable specified by <u>Location</u> determines the number of values returned.
              If the uniform variable is defined in the shader as a boolean, int, or float, a single value  will
              be  returned.  If  it is defined as a vec2, ivec2, or bvec2, two values will be returned. If it is
              defined as a vec3, ivec3, or bvec3, three values will be returned, and  so  on.  To  query  values
              stored  in  uniform  variables  declared  as  arrays, call <u>gl:getUniform()</u> for each element of the
              array. To query values stored in uniform variables declared as  structures,  call  <u>gl:getUniform()</u>
              for  each  field  in  the structure. The values for uniform variables declared as a matrix will be
              returned in column major order.

              External documentation.

       <b>getUniformBlockIndex(Program</b> <b>::</b> <b>i(),</b> <b>UniformBlockName</b> <b>::</b> <b>string())</b> <b>-&gt;</b>
                               i()

              <u>gl:getUniformBlockIndex/2</u> retrieves the index of a uniform block within <u>Program</u>.

              External documentation.

       <b>getUniformIndices(Program</b> <b>::</b> <b>i(),</b>
                         UniformNames :: [unicode:chardata()]) -&gt;
                            [i()]

              <u>gl:getUniformIndices/2</u> retrieves the indices of a number of uniforms within <u>Program</u>.

              External documentation.

       <b>getUniformLocation(Program</b> <b>::</b> <b>i(),</b> <b>Name</b> <b>::</b> <b>string())</b> <b>-&gt;</b> <b>i()</b>

              <u>glGetUniformLocation</u>  returns an integer that  represents  the  location  of  a  specific  uniform
              variable  within  a  program  object. <u>Name</u> must be a null terminated string that contains no white
              space. <u>Name</u> must be an active uniform variable name in <u>Program</u> that is not a structure,  an  array
              of  structures,  or  a subcomponent of a vector or a matrix. This function returns -1 if <u>Name</u> does
              not correspond to an active uniform variable in <u>Program</u>, if <u>Name</u> starts with the  reserved  prefix
              "gl_", or if <u>Name</u> is associated with an atomic counter or a named uniform block.

              External documentation.

       <b>getUniformSubroutineuiv(Shadertype</b> <b>::</b> <b>enum(),</b> <b>Location</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                                  {i(),
                                   i(),
                                   i(),
                                   i(),
                                   i(),
                                   i(),
                                   i(),
                                   i(),
                                   i(),
                                   i(),
                                   i(),
                                   i(),
                                   i(),
                                   i(),
                                   i(),
                                   i()}

              <u>gl:getUniformSubroutine()</u>  retrieves  the value of the subroutine uniform at location <u>Location</u> for
              shader stage <u>Shadertype</u> of  the  current  program.  <u>Location</u>  must  be  less  than  the  value  of
              <u>?GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS</u>   for   the  shader  currently  in  use  at  shader  stage
              <u>Shadertype</u>. The value of the subroutine uniform is returned in <u>Values</u>.

              External documentation.

       <b>getVertexAttribIiv(Index</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                             {i(), i(), i(), i()}

       <b>getVertexAttribIuiv(Index</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                              {i(), i(), i(), i()}

       <b>getVertexAttribLdv(Index</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                             {f(), f(), f(), f()}

       <b>getVertexAttribdv(Index</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                            {f(), f(), f(), f()}

       <b>getVertexAttribfv(Index</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                            {f(), f(), f(), f()}

       <b>getVertexAttribiv(Index</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum())</b> <b>-&gt;</b>
                            {i(), i(), i(), i()}

              <u>gl:getVertexAttrib()</u> returns in <u>Params</u> the value of a  generic  vertex  attribute  parameter.  The
              generic  vertex  attribute to be queried is specified by <u>Index</u>, and the parameter to be queried is
              specified by <u>Pname</u>.

              External documentation.

       <b>hint(Target</b> <b>::</b> <b>enum(),</b> <b>Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              Certain aspects of GL behavior, when there is room for  interpretation,  can  be  controlled  with
              hints.  A  hint  is  specified  with  two  arguments. <u>Target</u> is a symbolic constant indicating the
              behavior to be controlled, and <u>Mode</u> is another symbolic constant indicating the desired  behavior.
              The initial value for each <u>Target</u> is <u>?GL_DONT_CARE</u>. <u>Mode</u> can be one of the following:

              External documentation.

       <b>histogram(Target</b> <b>::</b> <b>enum(),</b>
                 Width :: i(),
                 Internalformat :: enum(),
                 Sink :: 0 | 1) -&gt;
                    ok

              When  <u>?GL_HISTOGRAM</u>  is enabled, RGBA color components are converted to histogram table indices by
              clamping to the range [0,1], multiplying by the width of the histogram table, and rounding to  the
              nearest  integer.  The  table  entries  selected by the RGBA indices are then incremented. (If the
              internal format of the histogram table includes luminance, then the index derived from the R color
              component determines the luminance table entry to be incremented.) If a histogram table  entry  is
              incremented beyond its maximum value, then its value becomes undefined. (This is not an error.)

              External documentation.

       <b>indexd(C</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>indexdv(X1</b> <b>::</b> <b>{C</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>indexf(C</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>indexfv(X1</b> <b>::</b> <b>{C</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>indexi(C</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>indexiv(X1</b> <b>::</b> <b>{C</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>indexs(C</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>indexsv(X1</b> <b>::</b> <b>{C</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>indexub(C</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>indexubv(X1</b> <b>::</b> <b>{C</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:index()</u>  updates  the current (single-valued) color index. It takes one argument, the new value
              for the current color index.

              External documentation.

       <b>indexMask(Mask</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:indexMask/1</u> controls the writing of individual bits in  the  color  index  buffers.  The  least
              significant n bits of <u>Mask</u>, where n is the number of bits in a color index buffer, specify a mask.
              Where  a 1 (one) appears in the mask, it's possible to write to the corresponding bit in the color
              index buffer (or buffers). Where a 0 (zero) appears, the corresponding bit is write-protected.

              External documentation.

       <b>indexPointer(Type</b> <b>::</b> <b>enum(),</b>
                    Stride :: i(),
                    Ptr :: offset() | mem()) -&gt;
                       ok

              <u>gl:indexPointer/3</u> specifies the location and data format of an array of color indexes to use  when
              rendering.  <u>Type</u>  specifies the data type of each color index and <u>Stride</u> specifies the byte stride
              from one color index to the next, allowing vertices and attributes to  be  packed  into  a  single
              array or stored in separate arrays.

              External documentation.

       <b>initNames()</b> <b>-&gt;</b> <b>ok</b>

              The  name  stack  is used during selection mode to allow sets of rendering commands to be uniquely
              identified. It consists of an ordered set of unsigned integers.  <u>gl:initNames/0</u>  causes  the  name
              stack to be initialized to its default empty state.

              External documentation.

       <b>interleavedArrays(Format</b> <b>::</b> <b>enum(),</b>
                         Stride :: i(),
                         Pointer :: offset() | mem()) -&gt;
                            ok

              <u>gl:interleavedArrays/3</u>  lets  you  specify and enable individual color, normal, texture and vertex
              arrays whose elements are part of a larger aggregate array element. For some implementations, this
              is more efficient than specifying the arrays separately.

              External documentation.

       <b>invalidateBufferData(Buffer</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:invalidateBufferData/1</u> invalidates all of the content of the data store  of  a  buffer  object.
              After invalidation, the content of the buffer's data store becomes undefined.

              External documentation.

       <b>invalidateBufferSubData(Buffer</b> <b>::</b> <b>i(),</b>
                               Offset :: i(),
                               Length :: i()) -&gt;
                                  ok

              <u>gl:invalidateBufferSubData/3</u>  invalidates all or part of the content of the data store of a buffer
              object. After invalidation, the content of the specified range of the buffer's data store  becomes
              undefined.  The  start  of  the  range  is  given  by <u>Offset</u> and its size is given by <u>Length</u>, both
              measured in basic machine units.

              External documentation.

       <b>invalidateFramebuffer(Target</b> <b>::</b> <b>enum(),</b> <b>Attachments</b> <b>::</b> <b>[enum()])</b> <b>-&gt;</b>
                                ok

              <u>gl:invalidateFramebuffer/2</u> and <u>glInvalidateNamedFramebufferData</u> invalidate the entire contents  of
              a specified set of attachments of a framebuffer.

              External documentation.

       <b>invalidateSubFramebuffer(Target</b> <b>::</b> <b>enum(),</b>
                                Attachments :: [enum()],
                                X :: i(),
                                Y :: i(),
                                Width :: i(),
                                Height :: i()) -&gt;
                                   ok

              <u>gl:invalidateSubFramebuffer/6</u> and <u>glInvalidateNamedFramebufferSubData</u> invalidate the contents of a
              specified region of a specified set of attachments of a framebuffer.

              External documentation.

       <b>invalidateTexImage(Texture</b> <b>::</b> <b>i(),</b> <b>Level</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:invalidateTexSubImage/8</u>  invalidates  all of a texture image. <u>Texture</u> and <u>Level</u> indicated which
              texture image is being invalidated. After this command, data in the texture  image  has  undefined
              values.

              External documentation.

       <b>invalidateTexSubImage(Texture,</b> <b>Level,</b> <b>Xoffset,</b> <b>Yoffset,</b> <b>Zoffset,</b>
                             Width, Height, Depth) -&gt;
                                ok

              Types:

                 Texture = Level = Xoffset = Yoffset = Zoffset = Width = Height = Depth = i()

              <u>gl:invalidateTexSubImage/8</u> invalidates all or part of a texture image. <u>Texture</u> and <u>Level</u> indicated
              which  texture  image  is  being  invalidated.  After  this  command,  data in that subregion have
              undefined values. <u>Xoffset</u>, <u>Yoffset</u>, <u>Zoffset</u>, <u>Width</u>, <u>Height</u>, and <u>Depth</u> are interpreted as they  are
              in  <u>gl:texSubImage3D/11</u>.  For  texture  targets  that  don't have certain dimensions, this command
              treats those dimensions as having a size of 1. For example, to invalidate  a  portion  of  a  two-
              dimensional  texture, the application would use <u>Zoffset</u> equal to zero and <u>Depth</u> equal to one. Cube
              map textures are treated as an array of six slices in the z-dimension, where a value of <u>Zoffset</u> is
              interpreted as specifying face <u>?GL_TEXTURE_CUBE_MAP_POSITIVE_X</u> + <u>Zoffset</u>.

              External documentation.

       <b>isBuffer(Buffer</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isBuffer/1</u> returns <u>?GL_TRUE</u> if <u>Buffer</u> is currently the name of a buffer object.  If  <u>Buffer</u>  is
              zero,  or  is  a  non-zero value that is not currently the name of a buffer object, or if an error
              occurs, <u>gl:isBuffer/1</u> returns <u>?GL_FALSE</u>.

              External documentation.

       <b>isEnabled(Cap</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

       <b>isEnabledi(Target</b> <b>::</b> <b>enum(),</b> <b>Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isEnabled/1</u> returns <u>?GL_TRUE</u> if <u>Cap</u> is an enabled capability and returns  <u>?GL_FALSE</u>  otherwise.
              Boolean  states  that  are  indexed may be tested with <u>gl:isEnabledi/2</u>. For <u>gl:isEnabledi/2</u>, <u>Index</u>
              specifies the index of the capability to test. <u>Index</u> must be between zero and the count of indexed
              capabilities for <u>Cap</u>. Initially all capabilities except <u>?GL_DITHER</u>  are  disabled;  <u>?GL_DITHER</u>  is
              initially enabled.

              External documentation.

       <b>isFramebuffer(Framebuffer</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isFramebuffer/1</u>  returns <u>?GL_TRUE</u> if <u>Framebuffer</u> is currently the name of a framebuffer object.
              If <u>Framebuffer</u> is zero, or if <u>?framebuffer</u> is not the name of a framebuffer object, or if an error
              occurs,  <u>gl:isFramebuffer/1</u>  returns  <u>?GL_FALSE</u>.  If   <u>Framebuffer</u>   is   a   name   returned   by
              <u>gl:genFramebuffers/1</u>,  by that has not yet been bound through a call to <u>gl:bindFramebuffer/2</u>, then
              the name is not a framebuffer object and <u>gl:isFramebuffer/1</u> returns <u>?GL_FALSE</u>.

              External documentation.

       <b>isList(List</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isList/1</u> returns <u>?GL_TRUE</u> if <u>List</u> is the name of a display list and returns <u>?GL_FALSE</u> if it  is
              not, or if an error occurs.

              External documentation.

       <b>isProgram(Program</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isProgram/1</u> returns <u>?GL_TRUE</u> if <u>Program</u> is the name of a program object previously created with
              <u>gl:createProgram/0</u>  and  not yet deleted with <u>gl:deleteProgram/1</u>. If <u>Program</u> is zero or a non-zero
              value that is not the name of a program object, or if  an  error  occurs,  <u>gl:isProgram/1</u>  returns
              <u>?GL_FALSE</u>.

              External documentation.

       <b>isProgramPipeline(Pipeline</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isProgramPipeline/1</u>  returns  <u>?GL_TRUE</u>  if <u>Pipeline</u> is currently the name of a program pipeline
              object. If <u>Pipeline</u> is zero, or if <u>?pipeline</u> is not the name of a program pipeline object,  or  if
              an  error  occurs,  <u>gl:isProgramPipeline/1</u>  returns  <u>?GL_FALSE</u>.  If <u>Pipeline</u> is a name returned by
              <u>gl:genProgramPipelines/1</u>,   but   that   has   not   yet   been   bound   through   a   call    to
              <u>gl:bindProgramPipeline/1</u>,    then    the   name   is   not   a   program   pipeline   object   and
              <u>gl:isProgramPipeline/1</u> returns <u>?GL_FALSE</u>.

              External documentation.

       <b>isQuery(Id</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isQuery/1</u> returns <u>?GL_TRUE</u> if <u>Id</u> is currently the name of a query object. If <u>Id</u> is zero, or  is
              a  non-zero  value  that  is  not  currently  the  name  of a query object, or if an error occurs,
              <u>gl:isQuery/1</u> returns <u>?GL_FALSE</u>.

              External documentation.

       <b>isRenderbuffer(Renderbuffer</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isRenderbuffer/1</u> returns <u>?GL_TRUE</u> if <u>Renderbuffer</u> is  currently  the  name  of  a  renderbuffer
              object.  If  <u>Renderbuffer</u> is zero, or if <u>Renderbuffer</u> is not the name of a renderbuffer object, or
              if an error occurs, <u>gl:isRenderbuffer/1</u> returns <u>?GL_FALSE</u>. If <u>Renderbuffer</u> is a name  returned  by
              <u>gl:genRenderbuffers/1</u>,  by  that has not yet been bound through a call to <u>gl:bindRenderbuffer/2</u> or
              <u>gl:framebufferRenderbuffer/4</u>, then the name is not a renderbuffer object  and  <u>gl:isRenderbuffer/1</u>
              returns <u>?GL_FALSE</u>.

              External documentation.

       <b>isSampler(Sampler</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isSampler/1</u> returns <u>?GL_TRUE</u> if <u>Id</u> is currently the name of a sampler object. If <u>Id</u> is zero, or
              is  a  non-zero  value  that is not currently the name of a sampler object, or if an error occurs,
              <u>gl:isSampler/1</u> returns <u>?GL_FALSE</u>.

              External documentation.

       <b>isShader(Shader</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isShader/1</u> returns <u>?GL_TRUE</u> if <u>Shader</u> is the name of a shader object  previously  created  with
              <u>gl:createShader/1</u>  and  not  yet  deleted  with <u>gl:deleteShader/1</u>. If <u>Shader</u> is zero or a non-zero
              value that is not the name of a shader  object,  or  if  an  error  occurs,  <u>glIsShader</u>    returns
              <u>?GL_FALSE</u>.

              External documentation.

       <b>isSync(Sync</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isSync/1</u>  returns  <u>?GL_TRUE</u>  if <u>Sync</u> is currently the name of a sync object. If <u>Sync</u> is not the
              name of a sync object, or if an error occurs, <u>gl:isSync/1</u> returns <u>?GL_FALSE</u>. Note that zero is not
              the name of a sync object.

              External documentation.

       <b>isTexture(Texture</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isTexture/1</u> returns <u>?GL_TRUE</u> if <u>Texture</u> is currently the name of a texture. If <u>Texture</u> is zero,
              or is a non-zero value that is not currently the name  of  a  texture,  or  if  an  error  occurs,
              <u>gl:isTexture/1</u> returns <u>?GL_FALSE</u>.

              External documentation.

       <b>isTransformFeedback(Id</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isTransformFeedback/1</u>  returns  <u>?GL_TRUE</u>  if  <u>Id</u>  is currently the name of a transform feedback
              object. If <u>Id</u> is zero, or if <u>?id</u> is not the name of a transform feedback object, or  if  an  error
              occurs,   <u>gl:isTransformFeedback/1</u>   returns   <u>?GL_FALSE</u>.   If   <u>Id</u>   is   a   name   returned  by
              <u>gl:genTransformFeedbacks/1</u>,  but   that   has   not   yet   been   bound   through   a   call   to
              <u>gl:bindTransformFeedback/2</u>,   then   the   name   is   not   a   transform   feedback  object  and
              <u>gl:isTransformFeedback/1</u> returns <u>?GL_FALSE</u>.

              External documentation.

       <b>isVertexArray(Array</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>1</b>

              <u>gl:isVertexArray/1</u> returns <u>?GL_TRUE</u> if <u>Array</u> is currently the name of a vertex  array  object.  If
              <u>Array</u>  is  zero,  or  if  <u>Array</u>  is  not the name of a vertex array object, or if an error occurs,
              <u>gl:isVertexArray/1</u> returns <u>?GL_FALSE</u>. If <u>Array</u> is a name returned by <u>gl:genVertexArrays/1</u>, by that
              has not yet been bound through a call to <u>gl:bindVertexArray/1</u>, then the name is not a vertex array
              object and <u>gl:isVertexArray/1</u> returns <u>?GL_FALSE</u>.

              External documentation.

       <b>lightf(Light</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>lightfv(Light</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b> <b>ok</b>

       <b>lighti(Light</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>lightiv(Light</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:light()</u> sets the values of individual light source parameters. <u>Light</u> names the light and  is  a
              symbolic  name  of the form <u>?GL_LIGHT</u> i, where i ranges from 0 to the value of <u>?GL_MAX_LIGHTS</u> - 1.
              <u>Pname</u> specifies one of ten light source parameters, again by symbolic name.  <u>Params</u>  is  either  a
              single value or a pointer to an array that contains the new values.

              External documentation.

       <b>lightModelf(Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>lightModelfv(Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b> <b>ok</b>

       <b>lightModeli(Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>lightModeliv(Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:lightModel()</u>  sets  the  lighting model parameter. <u>Pname</u> names a parameter and <u>Params</u> gives the
              new value. There are three lighting model parameters:

              External documentation.

       <b>lineStipple(Factor</b> <b>::</b> <b>i(),</b> <b>Pattern</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              Line stippling masks out certain fragments produced by rasterization; those fragments will not  be
              drawn. The masking is achieved by using three parameters: the 16-bit line stipple pattern <u>Pattern</u>,
              the repeat count <u>Factor</u>, and an integer stipple counter s.

              External documentation.

       <b>lineWidth(Width</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:lineWidth/1</u>  specifies the rasterized width of both aliased and antialiased lines. Using a line
              width other than 1 has different effects, depending on whether line antialiasing  is  enabled.  To
              enable   and   disable   line  antialiasing,  call  <u>gl:enable/1</u>  and  <u>gl:disable/1</u>  with  argument
              <u>?GL_LINE_SMOOTH</u>. Line antialiasing is initially disabled.

              External documentation.

       <b>linkProgram(Program</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:linkProgram/1</u> links the program object specified by <u>Program</u>. If  any  shader  objects  of  type
              <u>?GL_VERTEX_SHADER</u> are attached to <u>Program</u>, they will be used to create an executable that will run
              on  the  programmable  vertex  processor.  If  any  shader objects of type <u>?GL_GEOMETRY_SHADER</u> are
              attached to <u>Program</u>, they will be used to create an executable that will run on  the  programmable
              geometry  processor.  If  any  shader objects of type <u>?GL_FRAGMENT_SHADER</u> are attached to <u>Program</u>,
              they will be used to create an executable that will run on the programmable fragment processor.

              External documentation.

       <b>listBase(Base</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:callLists/1</u> specifies an array of offsets. Display-list names are generated by adding  <u>Base</u>  to
              each offset. Names that reference valid display lists are executed; the others are ignored.

              External documentation.

       <b>loadIdentity()</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:loadIdentity/0</u>  replaces  the  current  matrix  with  the  identity  matrix. It is semantically
              equivalent to calling <u>gl:loadMatrix()</u> with the identity matrix

              External documentation.

       <b>loadMatrixd(M</b> <b>::</b> <b>matrix())</b> <b>-&gt;</b> <b>ok</b>

       <b>loadMatrixf(M</b> <b>::</b> <b>matrix())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:loadMatrix()</u> replaces the current matrix with the one whose elements are specified  by  <u>M</u>.  The
              current  matrix  is  the  projection matrix, modelview matrix, or texture matrix, depending on the
              current matrix mode (see <u>gl:matrixMode/1</u>).

              External documentation.

       <b>loadName(Name</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              The name stack is used during selection mode to allow sets of rendering commands  to  be  uniquely
              identified. It consists of an ordered set of unsigned integers and is initially empty.

              External documentation.

       <b>loadTransposeMatrixd(M</b> <b>::</b> <b>matrix())</b> <b>-&gt;</b> <b>ok</b>

       <b>loadTransposeMatrixf(M</b> <b>::</b> <b>matrix())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:loadTransposeMatrix()</u>  replaces the current matrix with the one whose elements are specified by
              <u>M</u>. The current matrix is the projection matrix, modelview matrix, or texture matrix, depending  on
              the current matrix mode (see <u>gl:matrixMode/1</u>).

              External documentation.

       <b>logicOp(Opcode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:logicOp/1</u>  specifies  a  logical  operation that, when enabled, is applied between the incoming
              RGBA color and the RGBA color at the corresponding location in the  frame  buffer.  To  enable  or
              disable  the  logical  operation,  call  <u>gl:enable/1</u>  and <u>gl:disable/1</u> using the symbolic constant
              <u>?GL_COLOR_LOGIC_OP</u>. The initial value is disabled.

              External documentation.

       <b>map1d(Target</b> <b>::</b> <b>enum(),</b>
             U1 :: f(),
             U2 :: f(),
             Stride :: i(),
             Order :: i(),
             Points :: binary()) -&gt;
                ok

       <b>map1f(Target</b> <b>::</b> <b>enum(),</b>
             U1 :: f(),
             U2 :: f(),
             Stride :: i(),
             Order :: i(),
             Points :: binary()) -&gt;
                ok

              Evaluators provide a way to use polynomial or rational polynomial  mapping  to  produce  vertices,
              normals,  texture coordinates, and colors. The values produced by an evaluator are sent to further
              stages of GL processing just as  if  they  had  been  presented  using  <u>gl:vertex()</u>,  <u>gl:normal()</u>,
              <u>gl:texCoord()</u>, and <u>gl:color()</u> commands, except that the generated values do not update the current
              normal, texture coordinates, or color.

              External documentation.

       <b>map2d(Target,</b> <b>U1,</b> <b>U2,</b> <b>Ustride,</b> <b>Uorder,</b> <b>V1,</b> <b>V2,</b> <b>Vstride,</b> <b>Vorder,</b>
             Points) -&gt;
                ok

       <b>map2f(Target,</b> <b>U1,</b> <b>U2,</b> <b>Ustride,</b> <b>Uorder,</b> <b>V1,</b> <b>V2,</b> <b>Vstride,</b> <b>Vorder,</b>
             Points) -&gt;
                ok

              Types:

                 Target = enum()
                 U1 = U2 = f()
                 Ustride = Uorder = i()
                 V1 = V2 = f()
                 Vstride = Vorder = i()
                 Points = binary()

              Evaluators  provide  a  way  to use polynomial or rational polynomial mapping to produce vertices,
              normals, texture coordinates, and colors. The values produced by  an  evaluator  are  sent  on  to
              further stages of GL processing just as if they had been presented using <u>gl:vertex()</u>, <u>gl:normal()</u>,
              <u>gl:texCoord()</u>, and <u>gl:color()</u> commands, except that the generated values do not update the current
              normal, texture coordinates, or color.

              External documentation.

       <b>mapGrid1d(Un</b> <b>::</b> <b>i(),</b> <b>U1</b> <b>::</b> <b>f(),</b> <b>U2</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>mapGrid1f(Un</b> <b>::</b> <b>i(),</b> <b>U1</b> <b>::</b> <b>f(),</b> <b>U2</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>mapGrid2d(Un</b> <b>::</b> <b>i(),</b>
                 U1 :: f(),
                 U2 :: f(),
                 Vn :: i(),
                 V1 :: f(),
                 V2 :: f()) -&gt;
                    ok

       <b>mapGrid2f(Un</b> <b>::</b> <b>i(),</b>
                 U1 :: f(),
                 U2 :: f(),
                 Vn :: i(),
                 V1 :: f(),
                 V2 :: f()) -&gt;
                    ok

              <u>gl:mapGrid()</u>  and <u>gl:evalMesh()</u> are used together to efficiently generate and evaluate a series of
              evenly-spaced map domain values. <u>gl:evalMesh()</u> steps through the integer domain of a one- or  two-
              dimensional grid, whose range is the domain of the evaluation maps specified by <u>glMap1</u> and <u>glMap2</u>.

              External documentation.

       <b>materialf(Face</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>materialfv(Face</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b>
                     ok

       <b>materiali(Face</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>materialiv(Face</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b>
                     ok

              <u>gl:material()</u>  assigns  values  to  material  parameters.  There  are two matched sets of material
              parameters. One, the <u>front-facing</u> set, is used to shade points, lines, bitmaps, and  all  polygons
              (when  two-sided  lighting is disabled), or just front-facing polygons (when two-sided lighting is
              enabled). The other set, <u>back-facing</u>, is used to shade back-facing polygons  only  when  two-sided
              lighting  is  enabled. Refer to the <u>gl:lightModel()</u> reference page for details concerning one- and
              two-sided lighting calculations.

              External documentation.

       <b>matrixMode(Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:matrixMode/1</u> sets the current matrix mode. <u>Mode</u> can assume one of four values:

              External documentation.

       <b>memoryBarrier(Barriers</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>memoryBarrierByRegion(Barriers</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:memoryBarrier/1</u> defines a barrier ordering the memory transactions issued prior to the  command
              relative to those issued after the barrier. For the purposes of this ordering, memory transactions
              performed  by  shaders  are  considered  to  be issued by the rendering command that triggered the
              execution of the shader. <u>Barriers</u> is  a  bitfield  indicating  the  set  of  operations  that  are
              synchronized with shader stores; the bits used in <u>Barriers</u> are as follows:

              External documentation.

       <b>minSampleShading(Value</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:minSampleShading/1</u>  specifies  the  rate  at  which  samples are shaded within a covered pixel.
              Sample-rate shading is enabled by calling <u>gl:enable/1</u> with the  parameter  <u>?GL_SAMPLE_SHADING</u>.  If
              <u>?GL_MULTISAMPLE</u>  or  <u>?GL_SAMPLE_SHADING</u>  is  disabled, sample shading has no effect. Otherwise, an
              implementation must provide at least as many unique color values  for  each  covered  fragment  as
              specified  by  <u>Value</u>  times  <u>Samples</u>  where  <u>Samples</u>  is  the value of <u>?GL_SAMPLES</u> for the current
              framebuffer. At least 1 sample for each covered fragment is generated.

              External documentation.

       <b>minmax(Target</b> <b>::</b> <b>enum(),</b> <b>Internalformat</b> <b>::</b> <b>enum(),</b> <b>Sink</b> <b>::</b> <b>0</b> <b>|</b> <b>1)</b> <b>-&gt;</b>
                 ok

              When <u>?GL_MINMAX</u> is enabled, the RGBA components of incoming pixels are compared to the minimum and
              maximum values for each component, which are stored in the two-element minmax  table.  (The  first
              element  stores  the  minima,  and  the second element stores the maxima.) If a pixel component is
              greater than the corresponding component in the maximum  element,  then  the  maximum  element  is
              updated  with  the  pixel  component  value.  If  a pixel component is less than the corresponding
              component in the minimum element, then the minimum element is updated  with  the  pixel  component
              value.  (In  both cases, if the internal format of the minmax table includes luminance, then the R
              color component of incoming pixels is used for comparison.) The contents of the minmax  table  may
              be  retrieved  at  a  later  time  by  calling  <u>gl:getMinmax/5</u>. The minmax operation is enabled or
              disabled by calling <u>gl:enable/1</u> or <u>gl:disable/1</u>, respectively, with an argument of <u>?GL_MINMAX</u>.

              External documentation.

       <b>multMatrixd(M</b> <b>::</b> <b>matrix())</b> <b>-&gt;</b> <b>ok</b>

       <b>multMatrixf(M</b> <b>::</b> <b>matrix())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:multMatrix()</u> multiplies the current matrix with the one specified using  <u>M</u>,  and  replaces  the
              current matrix with the product.

              External documentation.

       <b>multTransposeMatrixd(M</b> <b>::</b> <b>matrix())</b> <b>-&gt;</b> <b>ok</b>

       <b>multTransposeMatrixf(M</b> <b>::</b> <b>matrix())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:multTransposeMatrix()</u>  multiplies  the  current  matrix  with  the  one  specified using <u>M</u>, and
              replaces the current matrix with the product.

              External documentation.

       <b>multiDrawArrays(Mode</b> <b>::</b> <b>enum(),</b>
                       First :: [integer()] | mem(),
                       Count :: [integer()] | mem()) -&gt;
                          ok

              <u>gl:multiDrawArrays/3</u> specifies multiple sets of geometric  primitives  with  very  few  subroutine
              calls.  Instead  of  calling  a  GL  procedure  to  pass  each  individual vertex, normal, texture
              coordinate, edge flag, or color, you can prespecify separate  arrays  of  vertices,  normals,  and
              colors   and   use   them   to   construct  a  sequence  of  primitives  with  a  single  call  to
              <u>gl:multiDrawArrays/3</u>.

              External documentation.

       <b>multiDrawArraysIndirect(Mode</b> <b>::</b> <b>enum(),</b>
                               Indirect :: offset() | mem(),
                               Drawcount :: i(),
                               Stride :: i()) -&gt;
                                  ok

              <u>gl:multiDrawArraysIndirect/4</u> specifies multiple geometric  primitives  with  very  few  subroutine
              calls.   <u>gl:multiDrawArraysIndirect/4</u>   behaves   similarly   to   a   multitude   of   calls   to
              <u>gl:drawArraysInstancedBaseInstance/5</u>,   execept   that   the   parameters   to   each   call    to
              <u>gl:drawArraysInstancedBaseInstance/5</u>  are  stored  in  an  array in memory at the address given by
              <u>Indirect</u>, separated by the stride, in basic machine units, specified by <u>Stride</u>. If <u>Stride</u> is zero,
              then the array is assumed to be tightly packed in memory.

              External documentation.

       <b>multiDrawArraysIndirectCount(Mode,</b> <b>Indirect,</b> <b>Drawcount,</b>
                                    Maxdrawcount, Stride) -&gt;
                                       ok

              Types:

                 Mode = enum()
                 Indirect = offset() | mem()
                 Drawcount = Maxdrawcount = Stride = i()

              No documentation available.

       <b>multiTexCoord1d(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord1dv(Target</b> <b>::</b> <b>enum(),</b> <b>X2</b> <b>::</b> <b>{S</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord1f(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord1fv(Target</b> <b>::</b> <b>enum(),</b> <b>X2</b> <b>::</b> <b>{S</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord1i(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord1iv(Target</b> <b>::</b> <b>enum(),</b> <b>X2</b> <b>::</b> <b>{S</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord1s(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord1sv(Target</b> <b>::</b> <b>enum(),</b> <b>X2</b> <b>::</b> <b>{S</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord2d(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord2dv(Target</b> <b>::</b> <b>enum(),</b> <b>X2</b> <b>::</b> <b>{S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f()})</b> <b>-&gt;</b>
                           ok

       <b>multiTexCoord2f(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord2fv(Target</b> <b>::</b> <b>enum(),</b> <b>X2</b> <b>::</b> <b>{S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f()})</b> <b>-&gt;</b>
                           ok

       <b>multiTexCoord2i(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord2iv(Target</b> <b>::</b> <b>enum(),</b> <b>X2</b> <b>::</b> <b>{S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i()})</b> <b>-&gt;</b>
                           ok

       <b>multiTexCoord2s(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>multiTexCoord2sv(Target</b> <b>::</b> <b>enum(),</b> <b>X2</b> <b>::</b> <b>{S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i()})</b> <b>-&gt;</b>
                           ok

       <b>multiTexCoord3d(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f(),</b> <b>R</b> <b>::</b> <b>f())</b> <b>-&gt;</b>
                          ok

       <b>multiTexCoord3dv(Target</b> <b>::</b> <b>enum(),</b>
                        X2 :: {S :: f(), T :: f(), R :: f()}) -&gt;
                           ok

       <b>multiTexCoord3f(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f(),</b> <b>R</b> <b>::</b> <b>f())</b> <b>-&gt;</b>
                          ok

       <b>multiTexCoord3fv(Target</b> <b>::</b> <b>enum(),</b>
                        X2 :: {S :: f(), T :: f(), R :: f()}) -&gt;
                           ok

       <b>multiTexCoord3i(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i(),</b> <b>R</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                          ok

       <b>multiTexCoord3iv(Target</b> <b>::</b> <b>enum(),</b>
                        X2 :: {S :: i(), T :: i(), R :: i()}) -&gt;
                           ok

       <b>multiTexCoord3s(Target</b> <b>::</b> <b>enum(),</b> <b>S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i(),</b> <b>R</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                          ok

       <b>multiTexCoord3sv(Target</b> <b>::</b> <b>enum(),</b>
                        X2 :: {S :: i(), T :: i(), R :: i()}) -&gt;
                           ok

       <b>multiTexCoord4d(Target</b> <b>::</b> <b>enum(),</b>
                       S :: f(),
                       T :: f(),
                       R :: f(),
                       Q :: f()) -&gt;
                          ok

       <b>multiTexCoord4dv(Target</b> <b>::</b> <b>enum(),</b>
                        X2 :: {S :: f(), T :: f(), R :: f(), Q :: f()}) -&gt;
                           ok

       <b>multiTexCoord4f(Target</b> <b>::</b> <b>enum(),</b>
                       S :: f(),
                       T :: f(),
                       R :: f(),
                       Q :: f()) -&gt;
                          ok

       <b>multiTexCoord4fv(Target</b> <b>::</b> <b>enum(),</b>
                        X2 :: {S :: f(), T :: f(), R :: f(), Q :: f()}) -&gt;
                           ok

       <b>multiTexCoord4i(Target</b> <b>::</b> <b>enum(),</b>
                       S :: i(),
                       T :: i(),
                       R :: i(),
                       Q :: i()) -&gt;
                          ok

       <b>multiTexCoord4iv(Target</b> <b>::</b> <b>enum(),</b>
                        X2 :: {S :: i(), T :: i(), R :: i(), Q :: i()}) -&gt;
                           ok

       <b>multiTexCoord4s(Target</b> <b>::</b> <b>enum(),</b>
                       S :: i(),
                       T :: i(),
                       R :: i(),
                       Q :: i()) -&gt;
                          ok

       <b>multiTexCoord4sv(Target</b> <b>::</b> <b>enum(),</b>
                        X2 :: {S :: i(), T :: i(), R :: i(), Q :: i()}) -&gt;
                           ok

              <u>gl:multiTexCoord()</u>  specifies  texture  coordinates  in  one,  two,  three,  or  four  dimensions.
              <u>gl:multiTexCoord1()</u>   sets   the   current   texture   coordinates  to  (s  0  0  1);  a  call  to
              <u>gl:multiTexCoord2()</u> sets them to (s t 0 1). Similarly, <u>gl:multiTexCoord3()</u> specifies  the  texture
              coordinates as (s t r 1), and <u>gl:multiTexCoord4()</u> defines all four components explicitly as (s t r
              q).

              External documentation.

       <b>endList()</b> <b>-&gt;</b> <b>ok</b>

       <b>newList(List</b> <b>::</b> <b>i(),</b> <b>Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              Display  lists  are  groups of GL commands that have been stored for subsequent execution. Display
              lists are created with <u>gl:newList/2</u>. All subsequent commands are placed in the  display  list,  in
              the order issued, until <u>gl:endList/0</u> is called.

              External documentation.

       <b>normal3b(Nx</b> <b>::</b> <b>i(),</b> <b>Ny</b> <b>::</b> <b>i(),</b> <b>Nz</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>normal3bv(X1</b> <b>::</b> <b>{Nx</b> <b>::</b> <b>i(),</b> <b>Ny</b> <b>::</b> <b>i(),</b> <b>Nz</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>normal3d(Nx</b> <b>::</b> <b>f(),</b> <b>Ny</b> <b>::</b> <b>f(),</b> <b>Nz</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>normal3dv(X1</b> <b>::</b> <b>{Nx</b> <b>::</b> <b>f(),</b> <b>Ny</b> <b>::</b> <b>f(),</b> <b>Nz</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>normal3f(Nx</b> <b>::</b> <b>f(),</b> <b>Ny</b> <b>::</b> <b>f(),</b> <b>Nz</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>normal3fv(X1</b> <b>::</b> <b>{Nx</b> <b>::</b> <b>f(),</b> <b>Ny</b> <b>::</b> <b>f(),</b> <b>Nz</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>normal3i(Nx</b> <b>::</b> <b>i(),</b> <b>Ny</b> <b>::</b> <b>i(),</b> <b>Nz</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>normal3iv(X1</b> <b>::</b> <b>{Nx</b> <b>::</b> <b>i(),</b> <b>Ny</b> <b>::</b> <b>i(),</b> <b>Nz</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>normal3s(Nx</b> <b>::</b> <b>i(),</b> <b>Ny</b> <b>::</b> <b>i(),</b> <b>Nz</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>normal3sv(X1</b> <b>::</b> <b>{Nx</b> <b>::</b> <b>i(),</b> <b>Ny</b> <b>::</b> <b>i(),</b> <b>Nz</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

              The current normal is set to the given coordinates whenever <u>gl:normal()</u> is issued. Byte, short, or
              integer  arguments are converted to floating-point format with a linear mapping that maps the most
              positive representable integer value to 1.0 and the most negative representable integer  value  to
              -1.0.

              External documentation.

       <b>normalPointer(Type</b> <b>::</b> <b>enum(),</b>
                     Stride :: i(),
                     Ptr :: offset() | mem()) -&gt;
                        ok

              <u>gl:normalPointer/3</u>  specifies  the  location  and  data  format of an array of normals to use when
              rendering. <u>Type</u> specifies the data type of each normal coordinate, and <u>Stride</u> specifies  the  byte
              stride  from  one  normal to the next, allowing vertices and attributes to be packed into a single
              array or stored  in  separate  arrays.  (Single-array  storage  may  be  more  efficient  on  some
              implementations; see <u>gl:interleavedArrays/3</u>.)

              External documentation.

       <b>objectPtrLabel(Ptr</b> <b>::</b> <b>offset()</b> <b>|</b> <b>mem(),</b>
                      Length :: i(),
                      Label :: string()) -&gt;
                         ok

              <u>gl:objectPtrLabel/3</u> labels the sync object identified by <u>Ptr</u>.

              External documentation.

       <b>ortho(Left</b> <b>::</b> <b>f(),</b>
             Right :: f(),
             Bottom :: f(),
             Top :: f(),
             Near_val :: f(),
             Far_val :: f()) -&gt;
                ok

              <u>gl:ortho/6</u> describes a transformation that produces a parallel projection. The current matrix (see
              <u>gl:matrixMode/1</u>)  is  multiplied  by this matrix and the result replaces the current matrix, as if
              <u>gl:multMatrix()</u> were called with the following matrix as its argument:

              External documentation.

       <b>passThrough(Token</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              External documentation.

       <b>patchParameterfv(Pname</b> <b>::</b> <b>enum(),</b> <b>Values</b> <b>::</b> <b>[f()])</b> <b>-&gt;</b> <b>ok</b>

       <b>patchParameteri(Pname</b> <b>::</b> <b>enum(),</b> <b>Value</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:patchParameter()</u> specifies the parameters  that  will  be  used  for  patch  primitives.  <u>Pname</u>
              specifies    the    parameter    to    modify    and    must    be    either   <u>?GL_PATCH_VERTICES</u>,
              <u>?GL_PATCH_DEFAULT_OUTER_LEVEL</u> or <u>?GL_PATCH_DEFAULT_INNER_LEVEL</u>.  For  <u>gl:patchParameteri/2</u>,  <u>Value</u>
              specifies  the  new  value for the parameter specified by <u>Pname</u>. For <u>gl:patchParameterfv/2</u>, <u>Values</u>
              specifies the address of an array containing the new values for the parameter specified by <u>Pname</u>.

              External documentation.

       <b>pauseTransformFeedback()</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:pauseTransformFeedback/0</u> pauses transform feedback operations on the currently active transform
              feedback object. When transform feedback  operations  are  paused,  transform  feedback  is  still
              considered  active  and changing most transform feedback state related to the object results in an
              error. However, a new transform feedback object may be bound while transform feedback is paused.

              External documentation.

       <b>pixelMapfv(Map</b> <b>::</b> <b>enum(),</b> <b>Mapsize</b> <b>::</b> <b>i(),</b> <b>Values</b> <b>::</b> <b>binary())</b> <b>-&gt;</b>
                     ok

       <b>pixelMapuiv(Map</b> <b>::</b> <b>enum(),</b> <b>Mapsize</b> <b>::</b> <b>i(),</b> <b>Values</b> <b>::</b> <b>binary())</b> <b>-&gt;</b>
                      ok

       <b>pixelMapusv(Map</b> <b>::</b> <b>enum(),</b> <b>Mapsize</b> <b>::</b> <b>i(),</b> <b>Values</b> <b>::</b> <b>binary())</b> <b>-&gt;</b>
                      ok

              <u>gl:pixelMap()</u> sets up translation tables, or <u>maps</u>, used by  <u>gl:copyPixels/5</u>,  <u>gl:copyTexImage1D/7</u>,
              <u>gl:copyTexImage2D/8</u>,   <u>gl:copyTexSubImage1D/6</u>,   <u>gl:copyTexSubImage2D/8</u>,   <u>gl:copyTexSubImage3D/9</u>,
              <u>gl:drawPixels/5</u>,    <u>gl:readPixels/7</u>,    <u>gl:texImage1D/8</u>,    <u>gl:texImage2D/9</u>,     <u>gl:texImage3D/10</u>,
              <u>gl:texSubImage1D/7</u>,  <u>gl:texSubImage2D/9</u>, and <u>gl:texSubImage3D/11</u>. Additionally, if the ARB_imaging
              subset is supported, the routines <u>gl:colorTable/6</u>,  <u>gl:colorSubTable/6</u>,  <u>gl:convolutionFilter1D/6</u>,
              <u>gl:convolutionFilter2D/7</u>,  <u>gl:histogram/4</u>,  <u>gl:minmax/3</u>,  and <u>gl:separableFilter2D/8</u>. Use of these
              maps is described completely in the <u>gl:pixelTransfer()</u> reference page, and partly in the reference
              pages for the pixel and texture image commands. Only the specification of the maps is described in
              this reference page.

              External documentation.

       <b>pixelStoref(Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>pixelStorei(Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:pixelStore()</u> sets pixel storage modes that affect the operation of  subsequent  <u>gl:readPixels/7</u>
              as   well   as   the   unpacking   of  texture  patterns  (see  <u>gl:texImage1D/8</u>,  <u>gl:texImage2D/9</u>,
              <u>gl:texImage3D/10</u>,       <u>gl:texSubImage1D/7</u>,       <u>gl:texSubImage2D/9</u>,        <u>gl:texSubImage3D/11</u>),
              <u>gl:compressedTexImage1D/7</u>,          <u>gl:compressedTexImage2D/8</u>,          <u>gl:compressedTexImage3D/9</u>,
              <u>gl:compressedTexSubImage1D/7</u>, <u>gl:compressedTexSubImage2D/9</u> or <u>gl:compressedTexSubImage1D/7</u>.

              External documentation.

       <b>pixelTransferf(Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>pixelTransferi(Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:pixelTransfer()</u>  sets  pixel  transfer  modes  that  affect   the   operation   of   subsequent
              <u>gl:copyPixels/5</u>,       <u>gl:copyTexImage1D/7</u>,      <u>gl:copyTexImage2D/8</u>,      <u>gl:copyTexSubImage1D/6</u>,
              <u>gl:copyTexSubImage2D/8</u>, <u>gl:copyTexSubImage3D/9</u>, <u>gl:drawPixels/5</u>, <u>gl:readPixels/7</u>, <u>gl:texImage1D/8</u>,
              <u>gl:texImage2D/9</u>, <u>gl:texImage3D/10</u>, <u>gl:texSubImage1D/7</u>, <u>gl:texSubImage2D/9</u>, and <u>gl:texSubImage3D/11</u>
              commands. Additionally, if the ARB_imaging subset  is  supported,  the  routines  <u>gl:colorTable/6</u>,
              <u>gl:colorSubTable/6</u>,     <u>gl:convolutionFilter1D/6</u>,     <u>gl:convolutionFilter2D/7</u>,    <u>gl:histogram/4</u>,
              <u>gl:minmax/3</u>, and <u>gl:separableFilter2D/8</u> are also affected. The algorithms that  are  specified  by
              pixel   transfer   modes   operate   on   pixels  after  they  are  read  from  the  frame  buffer
              (<u>gl:copyPixels/5gl:copyTexImage1D/7</u>,         <u>gl:copyTexImage2D/8</u>,          <u>gl:copyTexSubImage1D/6</u>,
              <u>gl:copyTexSubImage2D/8</u>,  <u>gl:copyTexSubImage3D/9</u>,  and  <u>gl:readPixels/7</u>),  or  unpacked from client
              memory (<u>gl:drawPixels/5</u>, <u>gl:texImage1D/8</u>, <u>gl:texImage2D/9</u>,  <u>gl:texImage3D/10</u>,  <u>gl:texSubImage1D/7</u>,
              <u>gl:texSubImage2D/9</u>,  and <u>gl:texSubImage3D/11</u>). Pixel transfer operations happen in the same order,
              and in the same manner, regardless of the command that resulted  in  the  pixel  operation.  Pixel
              storage  modes (see <u>gl:pixelStore()</u>) control the unpacking of pixels being read from client memory
              and the packing of pixels being written back into client memory.

              External documentation.

       <b>pixelZoom(Xfactor</b> <b>::</b> <b>f(),</b> <b>Yfactor</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:pixelZoom/2</u>  specifies  values  for  the  x  and  y  zoom  factors.  During  the  execution  of
              <u>gl:drawPixels/5</u>  or  <u>gl:copyPixels/5</u>,  if  (  xr,  yr) is the current raster position, and a given
              element is in the mth row and nth column of the pixel rectangle, then pixels whose centers are  in
              the rectangle with corners at

              External documentation.

       <b>pointParameterf(Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>pointParameterfv(Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b> <b>ok</b>

       <b>pointParameteri(Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>pointParameteriv(Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b> <b>ok</b>

              The following values are accepted for <u>Pname</u>:

              External documentation.

       <b>pointSize(Size</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:pointSize/1</u>  specifies  the  rasterized diameter of points. If point size mode is disabled (see
              <u>gl:enable/1</u> with parameter <u>?GL_PROGRAM_POINT_SIZE</u>), this value will be used to  rasterize  points.
              Otherwise, the value written to the shading language built-in variable gl_PointSize will be used.

              External documentation.

       <b>polygonMode(Face</b> <b>::</b> <b>enum(),</b> <b>Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:polygonMode/2</u>  controls  the interpretation of polygons for rasterization. <u>Face</u> describes which
              polygons <u>Mode</u> applies to: both front and back-facing polygons  (<u>?GL_FRONT_AND_BACK</u>).  The  polygon
              mode affects only the final rasterization of polygons. In particular, a polygon's vertices are lit
              and the polygon is clipped and possibly culled before these modes are applied.

              External documentation.

       <b>polygonOffset(Factor</b> <b>::</b> <b>f(),</b> <b>Units</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              When  <u>?GL_POLYGON_OFFSET_FILL</u>,  <u>?GL_POLYGON_OFFSET_LINE</u>,  or  <u>?GL_POLYGON_OFFSET_POINT</u> is enabled,
              each fragment's <u>depth</u> value will be offset after it is interpolated from the <u>depth</u> values  of  the
              appropriate  vertices.  The value of the offset is factorDZ+runits, where DZ is a measurement of
              the change in depth relative to the screen area of the polygon, and r is the smallest  value  that
              is  guaranteed  to  produce  a  resolvable  offset for a given implementation. The offset is added
              before the depth test is performed and before the value is written into the depth buffer.

              External documentation.

       <b>polygonOffsetClamp(Factor</b> <b>::</b> <b>f(),</b> <b>Units</b> <b>::</b> <b>f(),</b> <b>Clamp</b> <b>::</b> <b>f())</b> <b>-&gt;</b>
                             ok

              No documentation available.

       <b>polygonStipple(Mask</b> <b>::</b> <b>binary())</b> <b>-&gt;</b> <b>ok</b>

              Polygon stippling, like  line  stippling  (see  <u>gl:lineStipple/2</u>),  masks  out  certain  fragments
              produced by rasterization, creating a pattern. Stippling is independent of polygon antialiasing.

              External documentation.

       <b>primitiveRestartIndex(Index</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:primitiveRestartIndex/1</u>  specifies  a  vertex  array  element  that  is  treated specially when
              primitive restarting is enabled. This is known as the primitive restart index.

              External documentation.

       <b>prioritizeTextures(Textures</b> <b>::</b> <b>[i()],</b> <b>Priorities</b> <b>::</b> <b>[clamp()])</b> <b>-&gt;</b>
                             ok

              <u>gl:prioritizeTextures/2</u> assigns the <u>N</u> texture priorities given in <u>Priorities</u>  to  the  <u>N</u>  textures
              named in <u>Textures</u>.

              External documentation.

       <b>programBinary(Program</b> <b>::</b> <b>i(),</b>
                     BinaryFormat :: enum(),
                     Binary :: binary()) -&gt;
                        ok

              <u>gl:programBinary/3</u>  loads  a  program  object  with  a  program  binary  previously  returned from
              <u>gl:getProgramBinary/2</u>. <u>BinaryFormat</u> and <u>Binary</u> must be  those  returned  by  a  previous  call  to
              <u>gl:getProgramBinary/2</u>,  and  <u>Length</u>  must  be  the length returned by <u>gl:getProgramBinary/2</u>, or by
              <u>gl:getProgram()</u> when called with <u>Pname</u> set to <u>?GL_PROGRAM_BINARY_LENGTH</u>. If these  conditions  are
              not  met,  loading  the  program  binary  will  fail  and <u>Program</u>'s <u>?GL_LINK_STATUS</u> will be set to
              <u>?GL_FALSE</u>.

              External documentation.

       <b>programParameteri(Program</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Value</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                            ok

              <u>gl:programParameter()</u> specifies a new value for the parameter nameed  by  <u>Pname</u>  for  the  program
              object <u>Program</u>.

              External documentation.

       <b>programUniform1d(Program</b> <b>::</b> <b>i(),</b> <b>Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>programUniform1dv(Program</b> <b>::</b> <b>i(),</b> <b>Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[f()])</b> <b>-&gt;</b>
                            ok

       <b>programUniform1f(Program</b> <b>::</b> <b>i(),</b> <b>Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>programUniform1fv(Program</b> <b>::</b> <b>i(),</b> <b>Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[f()])</b> <b>-&gt;</b>
                            ok

       <b>programUniform1i(Program</b> <b>::</b> <b>i(),</b> <b>Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>programUniform1iv(Program</b> <b>::</b> <b>i(),</b> <b>Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b>
                            ok

       <b>programUniform1ui(Program</b> <b>::</b> <b>i(),</b> <b>Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                            ok

       <b>programUniform1uiv(Program</b> <b>::</b> <b>i(),</b>
                          Location :: i(),
                          Value :: [i()]) -&gt;
                             ok

       <b>programUniform2d(Program</b> <b>::</b> <b>i(),</b>
                        Location :: i(),
                        V0 :: f(),
                        V1 :: f()) -&gt;
                           ok

       <b>programUniform2dv(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         Value :: [{f(), f()}]) -&gt;
                            ok

       <b>programUniform2f(Program</b> <b>::</b> <b>i(),</b>
                        Location :: i(),
                        V0 :: f(),
                        V1 :: f()) -&gt;
                           ok

       <b>programUniform2fv(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         Value :: [{f(), f()}]) -&gt;
                            ok

       <b>programUniform2i(Program</b> <b>::</b> <b>i(),</b>
                        Location :: i(),
                        V0 :: i(),
                        V1 :: i()) -&gt;
                           ok

       <b>programUniform2iv(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         Value :: [{i(), i()}]) -&gt;
                            ok

       <b>programUniform2ui(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         V0 :: i(),
                         V1 :: i()) -&gt;
                            ok

       <b>programUniform2uiv(Program</b> <b>::</b> <b>i(),</b>
                          Location :: i(),
                          Value :: [{i(), i()}]) -&gt;
                             ok

       <b>programUniform3d(Program</b> <b>::</b> <b>i(),</b>
                        Location :: i(),
                        V0 :: f(),
                        V1 :: f(),
                        V2 :: f()) -&gt;
                           ok

       <b>programUniform3dv(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         Value :: [{f(), f(), f()}]) -&gt;
                            ok

       <b>programUniform3f(Program</b> <b>::</b> <b>i(),</b>
                        Location :: i(),
                        V0 :: f(),
                        V1 :: f(),
                        V2 :: f()) -&gt;
                           ok

       <b>programUniform3fv(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         Value :: [{f(), f(), f()}]) -&gt;
                            ok

       <b>programUniform3i(Program</b> <b>::</b> <b>i(),</b>
                        Location :: i(),
                        V0 :: i(),
                        V1 :: i(),
                        V2 :: i()) -&gt;
                           ok

       <b>programUniform3iv(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         Value :: [{i(), i(), i()}]) -&gt;
                            ok

       <b>programUniform3ui(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         V0 :: i(),
                         V1 :: i(),
                         V2 :: i()) -&gt;
                            ok

       <b>programUniform3uiv(Program</b> <b>::</b> <b>i(),</b>
                          Location :: i(),
                          Value :: [{i(), i(), i()}]) -&gt;
                             ok

       <b>programUniform4d(Program</b> <b>::</b> <b>i(),</b>
                        Location :: i(),
                        V0 :: f(),
                        V1 :: f(),
                        V2 :: f(),
                        V3 :: f()) -&gt;
                           ok

       <b>programUniform4dv(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         Value :: [{f(), f(), f(), f()}]) -&gt;
                            ok

       <b>programUniform4f(Program</b> <b>::</b> <b>i(),</b>
                        Location :: i(),
                        V0 :: f(),
                        V1 :: f(),
                        V2 :: f(),
                        V3 :: f()) -&gt;
                           ok

       <b>programUniform4fv(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         Value :: [{f(), f(), f(), f()}]) -&gt;
                            ok

       <b>programUniform4i(Program</b> <b>::</b> <b>i(),</b>
                        Location :: i(),
                        V0 :: i(),
                        V1 :: i(),
                        V2 :: i(),
                        V3 :: i()) -&gt;
                           ok

       <b>programUniform4iv(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         Value :: [{i(), i(), i(), i()}]) -&gt;
                            ok

       <b>programUniform4ui(Program</b> <b>::</b> <b>i(),</b>
                         Location :: i(),
                         V0 :: i(),
                         V1 :: i(),
                         V2 :: i(),
                         V3 :: i()) -&gt;
                            ok

       <b>programUniform4uiv(Program</b> <b>::</b> <b>i(),</b>
                          Location :: i(),
                          Value :: [{i(), i(), i(), i()}]) -&gt;
                             ok

       <b>programUniformMatrix2dv(Program</b> <b>::</b> <b>i(),</b>
                               Location :: i(),
                               Transpose :: 0 | 1,
                               Value :: [{f(), f(), f(), f()}]) -&gt;
                                  ok

       <b>programUniformMatrix2fv(Program</b> <b>::</b> <b>i(),</b>
                               Location :: i(),
                               Transpose :: 0 | 1,
                               Value :: [{f(), f(), f(), f()}]) -&gt;
                                  ok

       <b>programUniformMatrix2x3dv(Program</b> <b>::</b> <b>i(),</b>
                                 Location :: i(),
                                 Transpose :: 0 | 1,
                                 Value ::
                                     [{f(), f(), f(), f(), f(), f()}]) -&gt;
                                    ok

       <b>programUniformMatrix2x3fv(Program</b> <b>::</b> <b>i(),</b>
                                 Location :: i(),
                                 Transpose :: 0 | 1,
                                 Value ::
                                     [{f(), f(), f(), f(), f(), f()}]) -&gt;
                                    ok

       <b>programUniformMatrix2x4dv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b>
                                    ok

       <b>programUniformMatrix2x4fv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b>
                                    ok

       <b>programUniformMatrix3dv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b> <b>ok</b>

       <b>programUniformMatrix3fv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b> <b>ok</b>

       <b>programUniformMatrix3x2dv(Program</b> <b>::</b> <b>i(),</b>
                                 Location :: i(),
                                 Transpose :: 0 | 1,
                                 Value ::
                                     [{f(), f(), f(), f(), f(), f()}]) -&gt;
                                    ok

       <b>programUniformMatrix3x2fv(Program</b> <b>::</b> <b>i(),</b>
                                 Location :: i(),
                                 Transpose :: 0 | 1,
                                 Value ::
                                     [{f(), f(), f(), f(), f(), f()}]) -&gt;
                                    ok

       <b>programUniformMatrix3x4dv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b>
                                    ok

       <b>programUniformMatrix3x4fv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b>
                                    ok

       <b>programUniformMatrix4dv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b> <b>ok</b>

       <b>programUniformMatrix4fv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b> <b>ok</b>

       <b>programUniformMatrix4x2dv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b>
                                    ok

       <b>programUniformMatrix4x2fv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b>
                                    ok

       <b>programUniformMatrix4x3dv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b>
                                    ok

       <b>programUniformMatrix4x3fv(Program,</b> <b>Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b>
                                    ok

              Types:

                 Program = Location = i()
                 Transpose = 0 | 1
                 Value =
                     [{f(), f(), f(), f(), f(), f(), f(), f(), f(), f(), f(), f()}]

              <u>gl:programUniform()</u>  modifies  the  value  of  a uniform variable or a uniform variable array. The
              location of the uniform variable to be modified is specified by <u>Location</u>, which should be a  value
              returned  by <u>gl:getUniformLocation/2</u>. <u>gl:programUniform()</u> operates on the program object specified
              by <u>Program</u>.

              External documentation.

       <b>provokingVertex(Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>Flatshading</u> a vertex shader varying output means to assign all vetices of the primitive  the  same
              value  for  that  output.  The vertex from which these values is derived is known as the <u>provoking</u>
              <u>vertex</u> and <u>gl:provokingVertex/1</u> specifies which vertex is to be used as the  source  of  data  for
              flat shaded varyings.

              External documentation.

       <b>popAttrib()</b> <b>-&gt;</b> <b>ok</b>

       <b>pushAttrib(Mask</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:pushAttrib/1</u>  takes one argument, a mask that indicates which groups of state variables to save
              on the attribute stack. Symbolic constants are used to set bits in the  mask.  <u>Mask</u>  is  typically
              constructed  by specifying the bitwise-or of several of these constants together. The special mask
              <u>?GL_ALL_ATTRIB_BITS</u> can be used to save all stackable states.

              External documentation.

       <b>popClientAttrib()</b> <b>-&gt;</b> <b>ok</b>

       <b>pushClientAttrib(Mask</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:pushClientAttrib/1</u> takes one argument, a mask  that  indicates  which  groups  of  client-state
              variables  to  save  on the client attribute stack. Symbolic constants are used to set bits in the
              mask. <u>Mask</u> is typically constructed by specifying the bitwise-or of  several  of  these  constants
              together.  The  special  mask  <u>?GL_CLIENT_ALL_ATTRIB_BITS</u> can be used to save all stackable client
              state.

              External documentation.

       <b>popDebugGroup()</b> <b>-&gt;</b> <b>ok</b>

       <b>pushDebugGroup(Source</b> <b>::</b> <b>enum(),</b>
                      Id :: i(),
                      Length :: i(),
                      Message :: string()) -&gt;
                         ok

              <u>gl:pushDebugGroup/4</u> pushes a debug group described by the string <u>Message</u> into the command  stream.
              The  value  of <u>Id</u> specifies the ID of messages generated. The parameter <u>Length</u> contains the number
              of characters in <u>Message</u>. If <u>Length</u> is negative, it  is  implied  that  <u>Message</u>  contains  a  null
              terminated string. The message has the specified <u>Source</u> and <u>Id</u>, the <u>Type?GL_DEBUG_TYPE_PUSH_GROUP</u>,
              and <u>Severity?GL_DEBUG_SEVERITY_NOTIFICATION</u>. The GL will put a new debug group on top of the debug
              group stack which inherits the control of the volume of debug output of the debug group previously
              residing  on the top of the debug group stack. Because debug groups are strictly hierarchical, any
              additional control of the debug output volume will only apply within the active  debug  group  and
              the debug groups pushed on top of the active debug group.

              External documentation.

       <b>popMatrix()</b> <b>-&gt;</b> <b>ok</b>

       <b>pushMatrix()</b> <b>-&gt;</b> <b>ok</b>

              There  is a stack of matrices for each of the matrix modes. In <u>?GL_MODELVIEW</u> mode, the stack depth
              is at least 32. In the other modes, <u>?GL_COLOR</u>, <u>?GL_PROJECTION</u>, and <u>?GL_TEXTURE</u>, the  depth  is  at
              least 2. The current matrix in any mode is the matrix on the top of the stack for that mode.

              External documentation.

       <b>popName()</b> <b>-&gt;</b> <b>ok</b>

       <b>pushName(Name</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              The  name  stack  is used during selection mode to allow sets of rendering commands to be uniquely
              identified. It consists of an ordered set of unsigned integers and is initially empty.

              External documentation.

       <b>queryCounter(Id</b> <b>::</b> <b>i(),</b> <b>Target</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:queryCounter/2</u> causes the GL to record the current time into the query object named <u>Id</u>.  <u>Target</u>
              must  be  <u>?GL_TIMESTAMP</u>.  The  time  is  recorded after all previous commands on the GL client and
              server state and the framebuffer have been fully realized. When the time is  recorded,  the  query
              result  for  that object is marked available. <u>gl:queryCounter/2</u> timer queries can be used within a
              <u>gl:beginQuery/2</u> / <u>gl:endQuery/1</u> block where the target is <u>?GL_TIME_ELAPSED</u> and it does not  affect
              the result of that query object.

              External documentation.

       <b>rasterPos2d(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos2dv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos2f(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos2fv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos2i(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos2iv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos2s(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos2sv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos3d(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos3dv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos3f(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos3fv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos3i(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos3iv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos3s(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos3sv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos4d(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f(),</b> <b>W</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos4dv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f(),</b> <b>W</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos4f(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f(),</b> <b>W</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos4fv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f(),</b> <b>W</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos4i(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i(),</b> <b>W</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos4iv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i(),</b> <b>W</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos4s(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i(),</b> <b>W</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>rasterPos4sv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i(),</b> <b>W</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

              The  GL  maintains a 3D position in window coordinates. This position, called the raster position,
              is used to position pixel and bitmap write operations. It is maintained  with  subpixel  accuracy.
              See <u>gl:bitmap/7</u>, <u>gl:drawPixels/5</u>, and <u>gl:copyPixels/5</u>.

              External documentation.

       <b>readBuffer(Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:readBuffer/1</u>   specifies   a  color  buffer  as  the  source  for  subsequent  <u>gl:readPixels/7</u>,
              <u>gl:copyTexImage1D/7</u>,  <u>gl:copyTexImage2D/8</u>,  <u>gl:copyTexSubImage1D/6</u>,  <u>gl:copyTexSubImage2D/8</u>,   and
              <u>gl:copyTexSubImage3D/9</u>  commands. <u>Mode</u> accepts one of twelve or more predefined values. In a fully
              configured system, <u>?GL_FRONT</u>, <u>?GL_LEFT</u>,  and  <u>?GL_FRONT_LEFT</u>  all  name  the  front  left  buffer,
              <u>?GL_FRONT_RIGHT</u> and <u>?GL_RIGHT</u> name the front right buffer, and <u>?GL_BACK_LEFT</u> and <u>?GL_BACK</u> name the
              back  left  buffer.  Further more, the constants <u>?GL_COLOR_ATTACHMENTi</u> may be used to indicate the
              <u>i</u>th color attachment where <u>i</u> ranges from zero to the value of <u>?GL_MAX_COLOR_ATTACHMENTS</u> minus one.

              External documentation.

       <b>readPixels(X,</b> <b>Y,</b> <b>Width,</b> <b>Height,</b> <b>Format,</b> <b>Type,</b> <b>Pixels)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 X = Y = Width = Height = i()
                 Format = Type = enum()
                 Pixels = mem()

              <u>gl:readPixels/7</u> and <u>glReadnPixels</u> return pixel data from the frame buffer, starting with the pixel
              whose lower left corner is at location (<u>X</u>, <u>Y</u>), into  client  memory  starting  at  location  <u>Data</u>.
              Several  parameters  control  the  processing  of  the  pixel data before it is placed into client
              memory. These parameters are set with <u>gl:pixelStore()</u>. This reference page describes  the  effects
              on  <u>gl:readPixels/7</u>  and  <u>glReadnPixels</u>  of most, but not all of the parameters specified by these
              three commands.

              External documentation.

       <b>rectd(X1</b> <b>::</b> <b>f(),</b> <b>Y1</b> <b>::</b> <b>f(),</b> <b>X2</b> <b>::</b> <b>f(),</b> <b>Y2</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>rectdv(V1</b> <b>::</b> <b>{f(),</b> <b>f()},</b> <b>V2</b> <b>::</b> <b>{f(),</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rectf(X1</b> <b>::</b> <b>f(),</b> <b>Y1</b> <b>::</b> <b>f(),</b> <b>X2</b> <b>::</b> <b>f(),</b> <b>Y2</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>rectfv(V1</b> <b>::</b> <b>{f(),</b> <b>f()},</b> <b>V2</b> <b>::</b> <b>{f(),</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>recti(X1</b> <b>::</b> <b>i(),</b> <b>Y1</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>i(),</b> <b>Y2</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>rectiv(V1</b> <b>::</b> <b>{i(),</b> <b>i()},</b> <b>V2</b> <b>::</b> <b>{i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>rects(X1</b> <b>::</b> <b>i(),</b> <b>Y1</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>i(),</b> <b>Y2</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>rectsv(V1</b> <b>::</b> <b>{i(),</b> <b>i()},</b> <b>V2</b> <b>::</b> <b>{i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:rect()</u> supports efficient specification of rectangles as  two  corner  points.  Each  rectangle
              command takes four arguments, organized either as two consecutive pairs of (x y) coordinates or as
              two  pointers  to arrays, each containing an (x y) pair. The resulting rectangle is defined in the
              z=0 plane.

              External documentation.

       <b>releaseShaderCompiler()</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:releaseShaderCompiler/0</u> provides a hint  to  the  implementation  that  it  may  free  internal
              resources  associated  with its shader compiler. <u>gl:compileShader/1</u> may subsequently be called and
              the implementation may at  that  time  reallocate  resources  previously  freed  by  the  call  to
              <u>gl:releaseShaderCompiler/0</u>.

              External documentation.

       <b>renderMode(Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>i()</b>

              <u>gl:renderMode/1</u>  sets the rasterization mode. It takes one argument, <u>Mode</u>, which can assume one of
              three predefined values:

              External documentation.

       <b>renderbufferStorage(Target</b> <b>::</b> <b>enum(),</b>
                           Internalformat :: enum(),
                           Width :: i(),
                           Height :: i()) -&gt;
                              ok

              <u>gl:renderbufferStorage/4</u> is equivalent to  calling  <u>gl:renderbufferStorageMultisample/5</u>  with  the
              <u>Samples</u>    set    to    zero,    and   <u>glNamedRenderbufferStorage</u>   is   equivalent   to   calling
              <u>glNamedRenderbufferStorageMultisample</u> with the samples set to zero.

              External documentation.

       <b>renderbufferStorageMultisample(Target</b> <b>::</b> <b>enum(),</b>
                                      Samples :: i(),
                                      Internalformat :: enum(),
                                      Width :: i(),
                                      Height :: i()) -&gt;
                                         ok

              <u>gl:renderbufferStorageMultisample/5</u> and <u>glNamedRenderbufferStorageMultisample</u> establish  the  data
              storage, format, dimensions and number of samples of a renderbuffer object's image.

              External documentation.

       <b>resetHistogram(Target</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:resetHistogram/1</u> resets all the elements of the current histogram table to zero.

              External documentation.

       <b>resetMinmax(Target</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:resetMinmax/1</u>  resets  the  elements  of  the current minmax table to their initial values: the
              ``maximum'' element receives the minimum possible component values, and  the  ``minimum''  element
              receives the maximum possible component values.

              External documentation.

       <b>resumeTransformFeedback()</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:resumeTransformFeedback/0</u>  resumes  transform  feedback  operations  on  the  currently  active
              transform feedback object. When transform feedback operations are paused,  transform  feedback  is
              still  considered  active and changing most transform feedback state related to the object results
              in an error. However, a new transform feedback object may be bound  while  transform  feedback  is
              paused.

              External documentation.

       <b>rotated(Angle</b> <b>::</b> <b>f(),</b> <b>X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>rotatef(Angle</b> <b>::</b> <b>f(),</b> <b>X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:rotate()</u>  produces  a  rotation  of <u>Angle</u> degrees around the vector (x y z). The current matrix
              (see <u>gl:matrixMode/1</u>) is multiplied by a rotation matrix with the product  replacing  the  current
              matrix, as if <u>gl:multMatrix()</u> were called with the following matrix as its argument:

              External documentation.

       <b>sampleCoverage(Value</b> <b>::</b> <b>clamp(),</b> <b>Invert</b> <b>::</b> <b>0</b> <b>|</b> <b>1)</b> <b>-&gt;</b> <b>ok</b>

              Multisampling  samples  a  pixel  multiple  times  at  various  implementation-dependent  subpixel
              locations to generate antialiasing effects. Multisampling transparently antialiases points, lines,
              polygons, and images if it is enabled.

              External documentation.

       <b>sampleMaski(MaskNumber</b> <b>::</b> <b>i(),</b> <b>Mask</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:sampleMaski/2</u> sets one 32-bit sub-word of the multi-word sample mask, <u>?GL_SAMPLE_MASK_VALUE</u>.

              External documentation.

       <b>samplerParameterIiv(Sampler</b> <b>::</b> <b>i(),</b>
                           Pname :: enum(),
                           Param :: [i()]) -&gt;
                              ok

       <b>samplerParameterIuiv(Sampler</b> <b>::</b> <b>i(),</b>
                            Pname :: enum(),
                            Param :: [i()]) -&gt;
                               ok

       <b>samplerParameterf(Sampler</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b>
                            ok

       <b>samplerParameterfv(Sampler</b> <b>::</b> <b>i(),</b>
                          Pname :: enum(),
                          Param :: [f()]) -&gt;
                             ok

       <b>samplerParameteri(Sampler</b> <b>::</b> <b>i(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                            ok

       <b>samplerParameteriv(Sampler</b> <b>::</b> <b>i(),</b>
                          Pname :: enum(),
                          Param :: [i()]) -&gt;
                             ok

              <u>gl:samplerParameter()</u> assigns the value or values in <u>Params</u> to the sampler parameter specified  as
              <u>Pname</u>.  <u>Sampler</u>  specifies  the  sampler  object to be modified, and must be the name of a sampler
              object previously returned from a call to <u>gl:genSamplers/1</u>. The following symbols are accepted  in
              <u>Pname</u>:

              External documentation.

       <b>scaled(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>scalef(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:scale()</u> produces a nonuniform scaling along the <u>x</u>, <u>y</u>, and <u>z</u> axes. The three parameters indicate
              the desired scale factor along each of the three axes.

              External documentation.

       <b>scissor(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Width</b> <b>::</b> <b>i(),</b> <b>Height</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:scissor/4</u>  defines  a  rectangle,  called the scissor box, in window coordinates. The first two
              arguments, <u>X</u> and <u>Y</u>, specify the lower left corner of the box. <u>Width</u> and <u>Height</u> specify  the  width
              and height of the box.

              External documentation.

       <b>scissorArrayv(First</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>[{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()}])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:scissorArrayv/2</u>  defines  rectangles,  called  scissor  boxes,  in  window coordinates for each
              viewport. <u>First</u> specifies the index of the first scissor box to modify  and  <u>Count</u>  specifies  the
              number  of  scissor  boxes  to modify. <u>First</u> must be less than the value of <u>?GL_MAX_VIEWPORTS</u>, and
              <u>First</u> + <u>Count</u> must be less than or equal to  the  value  of  <u>?GL_MAX_VIEWPORTS</u>.  <u>V</u>  specifies  the
              address of an array containing integers specifying the lower left corner of the scissor boxes, and
              the width and height of the scissor boxes, in that order.

              External documentation.

       <b>scissorIndexed(Index</b> <b>::</b> <b>i(),</b>
                      Left :: i(),
                      Bottom :: i(),
                      Width :: i(),
                      Height :: i()) -&gt;
                         ok

       <b>scissorIndexedv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:scissorIndexed/5</u> defines the scissor box for a specified viewport. <u>Index</u> specifies the index of
              scissor   box   to   modify.  <u>Index</u>  must  be  less  than  the  value  of  <u>?GL_MAX_VIEWPORTS</u>.  For
              <u>gl:scissorIndexed/5</u>, <u>Left</u>, <u>Bottom</u>, <u>Width</u> and <u>Height</u> specify the left, bottom, width and height  of
              the  scissor box, in pixels, respectively. For <u>gl:scissorIndexedv/2</u>, <u>V</u> specifies the address of an
              array containing integers specifying the lower left corner of the scissor box, and the  width  and
              height of the scissor box, in that order.

              External documentation.

       <b>secondaryColor3b(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>secondaryColor3bv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b>
                            ok

       <b>secondaryColor3d(Red</b> <b>::</b> <b>f(),</b> <b>Green</b> <b>::</b> <b>f(),</b> <b>Blue</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>secondaryColor3dv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>f(),</b> <b>Green</b> <b>::</b> <b>f(),</b> <b>Blue</b> <b>::</b> <b>f()})</b> <b>-&gt;</b>
                            ok

       <b>secondaryColor3f(Red</b> <b>::</b> <b>f(),</b> <b>Green</b> <b>::</b> <b>f(),</b> <b>Blue</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>secondaryColor3fv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>f(),</b> <b>Green</b> <b>::</b> <b>f(),</b> <b>Blue</b> <b>::</b> <b>f()})</b> <b>-&gt;</b>
                            ok

       <b>secondaryColor3i(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>secondaryColor3iv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b>
                            ok

       <b>secondaryColor3s(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>secondaryColor3sv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b>
                            ok

       <b>secondaryColor3ub(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>secondaryColor3ubv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b>
                             ok

       <b>secondaryColor3ui(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>secondaryColor3uiv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b>
                             ok

       <b>secondaryColor3us(Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>secondaryColor3usv(X1</b> <b>::</b> <b>{Red</b> <b>::</b> <b>i(),</b> <b>Green</b> <b>::</b> <b>i(),</b> <b>Blue</b> <b>::</b> <b>i()})</b> <b>-&gt;</b>
                             ok

              The  GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
              alpha is always set to 0.0) that is associated with every vertex.

              External documentation.

       <b>secondaryColorPointer(Size</b> <b>::</b> <b>i(),</b>
                             Type :: enum(),
                             Stride :: i(),
                             Pointer :: offset() | mem()) -&gt;
                                ok

              <u>gl:secondaryColorPointer/4</u> specifies the location and data format of an array of color  components
              to  use  when  rendering.  <u>Size</u>  specifies the number of components per color, and must be 3. <u>Type</u>
              specifies the data type of each color component, and <u>Stride</u> specifies the  byte  stride  from  one
              color  to the next, allowing vertices and attributes to be packed into a single array or stored in
              separate arrays.

              External documentation.

       <b>selectBuffer(Size</b> <b>::</b> <b>i(),</b> <b>Buffer</b> <b>::</b> <b>mem())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:selectBuffer/2</u> has two arguments: <u>Buffer</u> is a pointer to an array  of  unsigned  integers,  and
              <u>Size</u>  indicates  the  size  of  the  array.  <u>Buffer</u>  returns  values  from  the  name  stack  (see
              <u>gl:initNames/0</u>,  <u>gl:loadName/1</u>,  <u>gl:pushName/1</u>)  when  the  rendering  mode  is  <u>?GL_SELECT</u>   (see
              <u>gl:renderMode/1</u>).  <u>gl:selectBuffer/2</u>  must be issued before selection mode is enabled, and it must
              not be issued while the rendering mode is <u>?GL_SELECT</u>.

              External documentation.

       <b>separableFilter2D(Target,</b> <b>Internalformat,</b> <b>Width,</b> <b>Height,</b> <b>Format,</b>
                         Type, Row, Column) -&gt;
                            ok

              Types:

                 Target = Internalformat = enum()
                 Width = Height = i()
                 Format = Type = enum()
                 Row = Column = offset() | mem()

              <u>gl:separableFilter2D/8</u> builds a two-dimensional  separable  convolution  filter  kernel  from  two
              arrays of pixels.

              External documentation.

       <b>shadeModel(Mode</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              GL  primitives  can  have  either  flat or smooth shading. Smooth shading, the default, causes the
              computed colors of vertices to be interpolated as the primitive is rasterized, typically assigning
              different colors to each resulting pixel fragment. Flat shading selects the computed color of just
              one vertex and assigns it to all the pixel fragments generated by rasterizing a single  primitive.
              In  either  case, the computed color of a vertex is the result of lighting if lighting is enabled,
              or it is the current color at the time the vertex was specified if lighting is disabled.

              External documentation.

       <b>shaderBinary(Shaders</b> <b>::</b> <b>[i()],</b>
                    Binaryformat :: enum(),
                    Binary :: binary()) -&gt;
                       ok

              <u>gl:shaderBinary/3</u> loads pre-compiled shader binary  code  into  the  <u>Count</u>  shader  objects  whose
              handles are given in <u>Shaders</u>. <u>Binary</u> points to <u>Length</u> bytes of binary shader code stored in client
              memory. <u>BinaryFormat</u> specifies the format of the pre-compiled code.

              External documentation.

       <b>shaderSource(Shader</b> <b>::</b> <b>i(),</b> <b>String</b> <b>::</b> <b>[unicode:chardata()])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:shaderSource/2</u>  sets  the  source  code  in  <u>Shader</u>  to the source code in the array of strings
              specified by <u>String</u>. Any source  code  previously  stored  in  the  shader  object  is  completely
              replaced.  The  number  of  strings  in  the array is specified by <u>Count</u>. If <u>Length</u> is <u>?NULL</u>, each
              string is assumed to be null terminated. If <u>Length</u> is a value other than <u>?NULL</u>, it  points  to  an
              array containing a string length for each of the corresponding elements of <u>String</u>. Each element in
              the  <u>Length</u>  array  may  contain the length of the corresponding string (the null character is not
              counted as part of the string length) or a value less than 0 to indicate that the string  is  null
              terminated. The source code strings are not scanned or parsed at this time; they are simply copied
              into the specified shader object.

              External documentation.

       <b>shaderStorageBlockBinding(Program</b> <b>::</b> <b>i(),</b>
                                 StorageBlockIndex :: i(),
                                 StorageBlockBinding :: i()) -&gt;
                                    ok

              <u>gl:shaderStorageBlockBinding/3</u>,  changes the active shader storage block with an assigned index of
              <u>StorageBlockIndex</u> in program object <u>Program</u>. <u>StorageBlockIndex</u> must be an  active  shader  storage
              block    index    in   <u>Program</u>.   <u>StorageBlockBinding</u>   must   be   less   than   the   value   of
              <u>?GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS</u>. If  successful,  <u>gl:shaderStorageBlockBinding/3</u>  specifies
              that  <u>Program</u>  will  use  the  data  store  of  the  buffer  object  bound  to  the  binding point
              <u>StorageBlockBinding</u> to read and write the values of the buffer variables  in  the  shader  storage
              block identified by <u>StorageBlockIndex</u>.

              External documentation.

       <b>stencilFunc(Func</b> <b>::</b> <b>enum(),</b> <b>Ref</b> <b>::</b> <b>i(),</b> <b>Mask</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              Stenciling,  like  depth-buffering,  enables  and  disables  drawing on a per-pixel basis. Stencil
              planes are first drawn into using GL drawing primitives, then geometry  and  images  are  rendered
              using  the  stencil  planes  to  mask  out portions of the screen. Stenciling is typically used in
              multipass rendering algorithms  to  achieve  special  effects,  such  as  decals,  outlining,  and
              constructive solid geometry rendering.

              External documentation.

       <b>stencilFuncSeparate(Face</b> <b>::</b> <b>enum(),</b>
                           Func :: enum(),
                           Ref :: i(),
                           Mask :: i()) -&gt;
                              ok

              Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into
              the stencil planes using GL drawing primitives, then render geometry and images, using the stencil
              planes  to  mask  out  portions of the screen. Stenciling is typically used in multipass rendering
              algorithms to achieve special effects, such as decals, outlining, and constructive solid  geometry
              rendering.

              External documentation.

       <b>stencilMask(Mask</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:stencilMask/1</u>  controls  the  writing  of  individual  bits  in  the  stencil planes. The least
              significant n bits of <u>Mask</u>, where n is the number of bits in the stencil buffer, specify  a  mask.
              Where  a  1  appears  in  the mask, it's possible to write to the corresponding bit in the stencil
              buffer. Where a 0 appears, the corresponding bit  is  write-protected.  Initially,  all  bits  are
              enabled for writing.

              External documentation.

       <b>stencilMaskSeparate(Face</b> <b>::</b> <b>enum(),</b> <b>Mask</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:stencilMaskSeparate/2</u>  controls the writing of individual bits in the stencil planes. The least
              significant n bits of <u>Mask</u>, where n is the number of bits in the stencil buffer, specify  a  mask.
              Where  a  1  appears  in  the mask, it's possible to write to the corresponding bit in the stencil
              buffer. Where a 0 appears, the corresponding bit  is  write-protected.  Initially,  all  bits  are
              enabled for writing.

              External documentation.

       <b>stencilOp(Fail</b> <b>::</b> <b>enum(),</b> <b>Zfail</b> <b>::</b> <b>enum(),</b> <b>Zpass</b> <b>::</b> <b>enum())</b> <b>-&gt;</b> <b>ok</b>

              Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into
              the stencil planes using GL drawing primitives, then render geometry and images, using the stencil
              planes  to  mask  out  portions of the screen. Stenciling is typically used in multipass rendering
              algorithms to achieve special effects, such as decals, outlining, and constructive solid  geometry
              rendering.

              External documentation.

       <b>stencilOpSeparate(Face</b> <b>::</b> <b>enum(),</b>
                         Sfail :: enum(),
                         Dpfail :: enum(),
                         Dppass :: enum()) -&gt;
                            ok

              Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into
              the stencil planes using GL drawing primitives, then render geometry and images, using the stencil
              planes  to  mask  out  portions of the screen. Stenciling is typically used in multipass rendering
              algorithms to achieve special effects, such as decals, outlining, and constructive solid  geometry
              rendering.

              External documentation.

       <b>texBuffer(Target</b> <b>::</b> <b>enum(),</b>
                 Internalformat :: enum(),
                 Buffer :: i()) -&gt;
                    ok

       <b>textureBuffer(Texture</b> <b>::</b> <b>i(),</b>
                     Internalformat :: enum(),
                     Buffer :: i()) -&gt;
                        ok

              <u>gl:texBuffer/3</u>  and  <u>gl:textureBuffer/3</u>  attaches the data store of a specified buffer object to a
              specified texture object, and specify the storage format for the texture image found in the buffer
              object. The texture object must be a buffer texture.

              External documentation.

       <b>texBufferRange(Target</b> <b>::</b> <b>enum(),</b>
                      Internalformat :: enum(),
                      Buffer :: i(),
                      Offset :: i(),
                      Size :: i()) -&gt;
                         ok

       <b>textureBufferRange(Texture</b> <b>::</b> <b>i(),</b>
                          Internalformat :: enum(),
                          Buffer :: i(),
                          Offset :: i(),
                          Size :: i()) -&gt;
                             ok

              <u>gl:texBufferRange/5</u> and <u>gl:textureBufferRange/5</u> attach a range of the data store  of  a  specified
              buffer  object to a specified texture object, and specify the storage format for the texture image
              found in the buffer object. The texture object must be a buffer texture.

              External documentation.

       <b>texCoord1d(S</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord1dv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord1f(S</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord1fv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord1i(S</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord1iv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord1s(S</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord1sv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord2d(S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord2dv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord2f(S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord2fv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord2i(S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord2iv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord2s(S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord2sv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord3d(S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f(),</b> <b>R</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord3dv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f(),</b> <b>R</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord3f(S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f(),</b> <b>R</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord3fv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f(),</b> <b>R</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord3i(S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i(),</b> <b>R</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord3iv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i(),</b> <b>R</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord3s(S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i(),</b> <b>R</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord3sv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i(),</b> <b>R</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord4d(S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f(),</b> <b>R</b> <b>::</b> <b>f(),</b> <b>Q</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord4dv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f(),</b> <b>R</b> <b>::</b> <b>f(),</b> <b>Q</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord4f(S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f(),</b> <b>R</b> <b>::</b> <b>f(),</b> <b>Q</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord4fv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>f(),</b> <b>T</b> <b>::</b> <b>f(),</b> <b>R</b> <b>::</b> <b>f(),</b> <b>Q</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord4i(S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i(),</b> <b>R</b> <b>::</b> <b>i(),</b> <b>Q</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord4iv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i(),</b> <b>R</b> <b>::</b> <b>i(),</b> <b>Q</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord4s(S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i(),</b> <b>R</b> <b>::</b> <b>i(),</b> <b>Q</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>texCoord4sv(X1</b> <b>::</b> <b>{S</b> <b>::</b> <b>i(),</b> <b>T</b> <b>::</b> <b>i(),</b> <b>R</b> <b>::</b> <b>i(),</b> <b>Q</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:texCoord()</u> specifies texture coordinates in one, two, three, or four dimensions. <u>gl:texCoord1()</u>
              sets the current texture coordinates to (s 0 0 1); a call to <u>gl:texCoord2()</u> sets them to  (s  t  0
              1).  Similarly,  <u>gl:texCoord3()</u> specifies the texture coordinates as (s t r 1), and <u>gl:texCoord4()</u>
              defines all four components explicitly as (s t r q).

              External documentation.

       <b>texCoordPointer(Size</b> <b>::</b> <b>i(),</b>
                       Type :: enum(),
                       Stride :: i(),
                       Ptr :: offset() | mem()) -&gt;
                          ok

              <u>gl:texCoordPointer/4</u> specifies the location and data format of an array of texture coordinates  to
              use  when rendering. <u>Size</u> specifies the number of coordinates per texture coordinate set, and must
              be 1, 2, 3, or 4. <u>Type</u> specifies the data type of each texture coordinate,  and  <u>Stride</u>  specifies
              the  byte  stride from one texture coordinate set to the next, allowing vertices and attributes to
              be packed into a single array or stored in separate arrays.  (Single-array  storage  may  be  more
              efficient on some implementations; see <u>gl:interleavedArrays/3</u>.)

              External documentation.

       <b>texEnvf(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>texEnvfv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b>
                   ok

       <b>texEnvi(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>texEnviv(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b>
                   ok

              A  texture  environment  specifies how texture values are interpreted when a fragment is textured.
              When <u>Target</u> is <u>?GL_TEXTURE_FILTER_CONTROL</u>, <u>Pname</u> must  be  <u>?GL_TEXTURE_LOD_BIAS</u>.  When  <u>Target</u>  is
              <u>?GL_TEXTURE_ENV</u>,   <u>Pname</u>  can  be  <u>?GL_TEXTURE_ENV_MODE</u>,  <u>?GL_TEXTURE_ENV_COLOR</u>,  <u>?GL_COMBINE_RGB</u>,
              <u>?GL_COMBINE_ALPHA</u>,  <u>?GL_RGB_SCALE</u>,  <u>?GL_ALPHA_SCALE</u>,  <u>?GL_SRC0_RGB</u>,  <u>?GL_SRC1_RGB</u>,   <u>?GL_SRC2_RGB</u>,
              <u>?GL_SRC0_ALPHA</u>, <u>?GL_SRC1_ALPHA</u>, or <u>?GL_SRC2_ALPHA</u>.

              External documentation.

       <b>texGend(Coord</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>texGendv(Coord</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b>
                   ok

       <b>texGenf(Coord</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>texGenfv(Coord</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b>
                   ok

       <b>texGeni(Coord</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>texGeniv(Coord</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Params</b> <b>::</b> <b>tuple())</b> <b>-&gt;</b>
                   ok

              <u>gl:texGen()</u>  selects  a texture-coordinate generation function or supplies coefficients for one of
              the functions. <u>Coord</u> names one of the (<u>s</u>, <u>t</u>, <u>r</u>, <u>q</u>) texture coordinates; it  must  be  one  of  the
              symbols  <u>?GL_S</u>,  <u>?GL_T</u>,  <u>?GL_R</u>,  or  <u>?GL_Q</u>.  <u>Pname</u>  must  be  one  of  three  symbolic  constants:
              <u>?GL_TEXTURE_GEN_MODE</u>, <u>?GL_OBJECT_PLANE</u>, or <u>?GL_EYE_PLANE</u>. If <u>Pname</u> is  <u>?GL_TEXTURE_GEN_MODE</u>,  then
              <u>Params</u>  chooses  a mode, one of <u>?GL_OBJECT_LINEAR</u>, <u>?GL_EYE_LINEAR</u>, <u>?GL_SPHERE_MAP</u>, <u>?GL_NORMAL_MAP</u>,
              or <u>?GL_REFLECTION_MAP</u>. If <u>Pname</u> is  either  <u>?GL_OBJECT_PLANE</u>  or  <u>?GL_EYE_PLANE</u>,  <u>Params</u>  contains
              coefficients for the corresponding texture generation function.

              External documentation.

       <b>texImage1D(Target,</b> <b>Level,</b> <b>InternalFormat,</b> <b>Width,</b> <b>Border,</b> <b>Format,</b>
                  Type, Pixels) -&gt;
                     ok

              Types:

                 Target = enum()
                 Level = InternalFormat = Width = Border = i()
                 Format = Type = enum()
                 Pixels = offset() | mem()

              Texturing  maps  a  portion  of  a specified texture image onto each graphical primitive for which
              texturing is enabled. To enable  and  disable  one-dimensional  texturing,  call  <u>gl:enable/1</u>  and
              <u>gl:disable/1</u> with argument <u>?GL_TEXTURE_1D</u>.

              External documentation.

       <b>texImage2D(Target,</b> <b>Level,</b> <b>InternalFormat,</b> <b>Width,</b> <b>Height,</b> <b>Border,</b>
                  Format, Type, Pixels) -&gt;
                     ok

              Types:

                 Target = enum()
                 Level = InternalFormat = Width = Height = Border = i()
                 Format = Type = enum()
                 Pixels = offset() | mem()

              Texturing allows elements of an image array to be read by shaders.

              External documentation.

       <b>texImage2DMultisample(Target,</b> <b>Samples,</b> <b>Internalformat,</b> <b>Width,</b>
                             Height, Fixedsamplelocations) -&gt;
                                ok

              Types:

                 Target = enum()
                 Samples = i()
                 Internalformat = enum()
                 Width = Height = i()
                 Fixedsamplelocations = 0 | 1

              <u>gl:texImage2DMultisample/6</u>  establishes the data storage, format, dimensions and number of samples
              of a multisample texture's image.

              External documentation.

       <b>texImage3D(Target,</b> <b>Level,</b> <b>InternalFormat,</b> <b>Width,</b> <b>Height,</b> <b>Depth,</b>
                  Border, Format, Type, Pixels) -&gt;
                     ok

              Types:

                 Target = enum()
                 Level = InternalFormat = Width = Height = Depth = Border = i()
                 Format = Type = enum()
                 Pixels = offset() | mem()

              Texturing maps a portion of a specified texture image onto  each  graphical  primitive  for  which
              texturing  is  enabled.  To  enable  and disable three-dimensional texturing, call <u>gl:enable/1</u> and
              <u>gl:disable/1</u> with argument <u>?GL_TEXTURE_3D</u>.

              External documentation.

       <b>texImage3DMultisample(Target,</b> <b>Samples,</b> <b>Internalformat,</b> <b>Width,</b>
                             Height, Depth, Fixedsamplelocations) -&gt;
                                ok

              Types:

                 Target = enum()
                 Samples = i()
                 Internalformat = enum()
                 Width = Height = Depth = i()
                 Fixedsamplelocations = 0 | 1

              <u>gl:texImage3DMultisample/7</u> establishes the data storage, format, dimensions and number of  samples
              of a multisample texture's image.

              External documentation.

       <b>texParameterIiv(Target</b> <b>::</b> <b>enum(),</b>
                       Pname :: enum(),
                       Params :: tuple()) -&gt;
                          ok

       <b>texParameterIuiv(Target</b> <b>::</b> <b>enum(),</b>
                        Pname :: enum(),
                        Params :: tuple()) -&gt;
                           ok

       <b>texParameterf(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>f())</b> <b>-&gt;</b>
                        ok

       <b>texParameterfv(Target</b> <b>::</b> <b>enum(),</b>
                      Pname :: enum(),
                      Params :: tuple()) -&gt;
                         ok

       <b>texParameteri(Target</b> <b>::</b> <b>enum(),</b> <b>Pname</b> <b>::</b> <b>enum(),</b> <b>Param</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                        ok

       <b>texParameteriv(Target</b> <b>::</b> <b>enum(),</b>
                      Pname :: enum(),
                      Params :: tuple()) -&gt;
                         ok

              <u>gl:texParameter()</u>  and  <u>gl:textureParameter()</u>  assign the value or values in <u>Params</u> to the texture
              parameter specified as <u>Pname</u>. For <u>gl:texParameter()</u>, <u>Target</u> defines  the  target  texture,  either
              <u>?GL_TEXTURE_1D</u>,         <u>?GL_TEXTURE_1D_ARRAY</u>,         <u>?GL_TEXTURE_2D</u>,        <u>?GL_TEXTURE_2D_ARRAY</u>,
              <u>?GL_TEXTURE_2D_MULTISAMPLE</u>,           <u>?GL_TEXTURE_2D_MULTISAMPLE_ARRAY</u>,            <u>?GL_TEXTURE_3D</u>,
              <u>?GL_TEXTURE_CUBE_MAP</u>,  <u>?GL_TEXTURE_CUBE_MAP_ARRAY</u>, or <u>?GL_TEXTURE_RECTANGLE</u>. The following symbols
              are accepted in <u>Pname</u>:

              External documentation.

       <b>texStorage1D(Target</b> <b>::</b> <b>enum(),</b>
                    Levels :: i(),
                    Internalformat :: enum(),
                    Width :: i()) -&gt;
                       ok

              <u>gl:texStorage1D/4</u> and <u>gl:textureStorage1D()</u> specify the storage requirements for all levels  of  a
              one-dimensional  texture simultaneously. Once a texture is specified with this command, the format
              and dimensions of all levels become immutable unless it is a proxy texture. The  contents  of  the
              image  may  still be modified, however, its storage requirements may not change. Such a texture is
              referred to as an <u>immutable-format</u> texture.

              External documentation.

       <b>texStorage2D(Target</b> <b>::</b> <b>enum(),</b>
                    Levels :: i(),
                    Internalformat :: enum(),
                    Width :: i(),
                    Height :: i()) -&gt;
                       ok

              <u>gl:texStorage2D/5</u> and <u>gl:textureStorage2D()</u> specify the storage requirements for all levels  of  a
              two-dimensional  texture  or  one-dimensional  texture  array  simultaneously.  Once  a texture is
              specified with this command, the format and dimensions of all levels become immutable unless it is
              a proxy texture.  The  contents  of  the  image  may  still  be  modified,  however,  its  storage
              requirements may not change. Such a texture is referred to as an <u>immutable-format</u> texture.

              External documentation.

       <b>texStorage2DMultisample(Target,</b> <b>Samples,</b> <b>Internalformat,</b> <b>Width,</b>
                               Height, Fixedsamplelocations) -&gt;
                                  ok

              Types:

                 Target = enum()
                 Samples = i()
                 Internalformat = enum()
                 Width = Height = i()
                 Fixedsamplelocations = 0 | 1

              <u>gl:texStorage2DMultisample/6</u> and <u>gl:textureStorage2DMultisample()</u> specify the storage requirements
              for  a  two-dimensional  multisample  texture.  Once a texture is specified with this command, its
              format and dimensions become immutable unless it is a proxy texture. The contents of the image may
              still be modified, however, its storage requirements may not change. Such a texture is referred to
              as an <u>immutable-format</u> texture.

              External documentation.

       <b>texStorage3D(Target,</b> <b>Levels,</b> <b>Internalformat,</b> <b>Width,</b> <b>Height,</b> <b>Depth)</b> <b>-&gt;</b>
                       ok

              Types:

                 Target = enum()
                 Levels = i()
                 Internalformat = enum()
                 Width = Height = Depth = i()

              <u>gl:texStorage3D/6</u> and <u>gl:textureStorage3D()</u> specify the storage requirements for all levels  of  a
              three-dimensional,  two-dimensional array or cube-map array texture simultaneously. Once a texture
              is specified with this command, the format and dimensions of all levels become immutable unless it
              is a proxy texture. The contents of  the  image  may  still  be  modified,  however,  its  storage
              requirements may not change. Such a texture is referred to as an <u>immutable-format</u> texture.

              External documentation.

       <b>texStorage3DMultisample(Target,</b> <b>Samples,</b> <b>Internalformat,</b> <b>Width,</b>
                               Height, Depth, Fixedsamplelocations) -&gt;
                                  ok

              Types:

                 Target = enum()
                 Samples = i()
                 Internalformat = enum()
                 Width = Height = Depth = i()
                 Fixedsamplelocations = 0 | 1

              <u>gl:texStorage3DMultisample/7</u> and <u>gl:textureStorage3DMultisample()</u> specify the storage requirements
              for  a  two-dimensional  multisample array texture. Once a texture is specified with this command,
              its format and dimensions become immutable unless it is a proxy texture. The contents of the image
              may still be modified, however, its storage  requirements  may  not  change.  Such  a  texture  is
              referred to as an <u>immutable-format</u> texture.

              External documentation.

       <b>texSubImage1D(Target,</b> <b>Level,</b> <b>Xoffset,</b> <b>Width,</b> <b>Format,</b> <b>Type,</b> <b>Pixels)</b> <b>-&gt;</b>
                        ok

              Types:

                 Target = enum()
                 Level = Xoffset = Width = i()
                 Format = Type = enum()
                 Pixels = offset() | mem()

              Texturing  maps  a  portion  of  a specified texture image onto each graphical primitive for which
              texturing is enabled. To  enable  or  disable  one-dimensional  texturing,  call  <u>gl:enable/1</u>  and
              <u>gl:disable/1</u> with argument <u>?GL_TEXTURE_1D</u>.

              External documentation.

       <b>texSubImage2D(Target,</b> <b>Level,</b> <b>Xoffset,</b> <b>Yoffset,</b> <b>Width,</b> <b>Height,</b>
                     Format, Type, Pixels) -&gt;
                        ok

              Types:

                 Target = enum()
                 Level = Xoffset = Yoffset = Width = Height = i()
                 Format = Type = enum()
                 Pixels = offset() | mem()

              Texturing  maps  a  portion  of  a specified texture image onto each graphical primitive for which
              texturing is enabled.

              External documentation.

       <b>texSubImage3D(Target,</b> <b>Level,</b> <b>Xoffset,</b> <b>Yoffset,</b> <b>Zoffset,</b> <b>Width,</b>
                     Height, Depth, Format, Type, Pixels) -&gt;
                        ok

              Types:

                 Target = enum()
                 Level = Xoffset = Yoffset = Zoffset = Width = Height = Depth = i()
                 Format = Type = enum()
                 Pixels = offset() | mem()

              Texturing maps a portion of a specified texture image onto  each  graphical  primitive  for  which
              texturing is enabled.

              External documentation.

       <b>textureBarrier()</b> <b>-&gt;</b> <b>ok</b>

              The  values  of  rendered  fragments are undefined when a shader stage fetches texels and the same
              texels are written via fragment shader outputs, even if the reads and writes are not in  the  same
              drawing  command.  To  safely read the result of a written texel via a texel fetch in a subsequent
              drawing command, call <u>gl:textureBarrier/0</u> between the  two  drawing  commands  to  guarantee  that
              writes  have  completed  and  caches  have been invalidated before subsequent drawing commands are
              executed.

              External documentation.

       <b>textureView(Texture,</b> <b>Target,</b> <b>Origtexture,</b> <b>Internalformat,</b>
                   Minlevel, Numlevels, Minlayer, Numlayers) -&gt;
                      ok

              Types:

                 Texture = i()
                 Target = enum()
                 Origtexture = i()
                 Internalformat = enum()
                 Minlevel = Numlevels = Minlayer = Numlayers = i()

              <u>gl:textureView/8</u> initializes a texture object as an alias, or  view  of  another  texture  object,
              sharing  some  or  all  of  the  parent texture's data store with the initialized texture. <u>Texture</u>
              specifies a name previously reserved by a successful call to <u>gl:genTextures/1</u> but that has not yet
              been bound or given a target. <u>Target</u> specifies the target for the newly  initialized  texture  and
              must be compatible with the target of the parent texture, given in <u>Origtexture</u> as specified in the
              following table:

              External documentation.

       <b>transformFeedbackBufferBase(Xfb</b> <b>::</b> <b>i(),</b>
                                   Index :: i(),
                                   Buffer :: i()) -&gt;
                                      ok

              <u>gl:transformFeedbackBufferBase/3</u>  binds  the  buffer  object  <u>Buffer</u> to the binding point at index
              <u>Index</u> of the transform feedback object <u>Xfb</u>.

              External documentation.

       <b>transformFeedbackBufferRange(Xfb</b> <b>::</b> <b>i(),</b>
                                    Index :: i(),
                                    Buffer :: i(),
                                    Offset :: i(),
                                    Size :: i()) -&gt;
                                       ok

              <u>gl:transformFeedbackBufferRange/5</u> binds a range of the buffer object <u>Buffer</u> represented by  <u>Offset</u>
              and <u>Size</u> to the binding point at index <u>Index</u> of the transform feedback object <u>Xfb</u>.

              External documentation.

       <b>transformFeedbackVaryings(Program</b> <b>::</b> <b>i(),</b>
                                 Varyings :: [unicode:chardata()],
                                 BufferMode :: enum()) -&gt;
                                    ok

              The  names  of the vertex or geometry shader outputs to be recorded in transform feedback mode are
              specified using <u>gl:transformFeedbackVaryings/3</u>.  When  a  geometry  shader  is  active,  transform
              feedback  records  the  values  of  selected  geometry  shader  output  variables from the emitted
              vertices. Otherwise, the values of the selected vertex shader outputs are recorded.

              External documentation.

       <b>translated(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>translatef(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:translate()</u> produces a translation by (x y z). The  current  matrix  (see  <u>gl:matrixMode/1</u>)  is
              multiplied  by  this  translation  matrix,  with  the  product replacing the current matrix, as if
              <u>gl:multMatrix()</u> were called with the following matrix for its argument:

              External documentation.

       <b>uniform1d(Location</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform1dv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[f()])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform1f(Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform1fv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[f()])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform1i(Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform1iv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform1ui(Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform1uiv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform2d(Location</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform2dv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{f(),</b> <b>f()}])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform2f(Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>f(),</b> <b>V1</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform2fv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{f(),</b> <b>f()}])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform2i(Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>i(),</b> <b>V1</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform2iv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{i(),</b> <b>i()}])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform2ui(Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>i(),</b> <b>V1</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform2uiv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{i(),</b> <b>i()}])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform3d(Location</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform3dv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{f(),</b> <b>f(),</b> <b>f()}])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform3f(Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>f(),</b> <b>V1</b> <b>::</b> <b>f(),</b> <b>V2</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform3fv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{f(),</b> <b>f(),</b> <b>f()}])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform3i(Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>i(),</b> <b>V1</b> <b>::</b> <b>i(),</b> <b>V2</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform3iv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{i(),</b> <b>i(),</b> <b>i()}])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform3ui(Location</b> <b>::</b> <b>i(),</b> <b>V0</b> <b>::</b> <b>i(),</b> <b>V1</b> <b>::</b> <b>i(),</b> <b>V2</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform3uiv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{i(),</b> <b>i(),</b> <b>i()}])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform4d(Location</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f(),</b> <b>W</b> <b>::</b> <b>f())</b> <b>-&gt;</b>
                    ok

       <b>uniform4dv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{f(),</b> <b>f(),</b> <b>f(),</b> <b>f()}])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform4f(Location</b> <b>::</b> <b>i(),</b>
                 V0 :: f(),
                 V1 :: f(),
                 V2 :: f(),
                 V3 :: f()) -&gt;
                    ok

       <b>uniform4fv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{f(),</b> <b>f(),</b> <b>f(),</b> <b>f()}])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform4i(Location</b> <b>::</b> <b>i(),</b>
                 V0 :: i(),
                 V1 :: i(),
                 V2 :: i(),
                 V3 :: i()) -&gt;
                    ok

       <b>uniform4iv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()}])</b> <b>-&gt;</b> <b>ok</b>

       <b>uniform4ui(Location</b> <b>::</b> <b>i(),</b>
                  V0 :: i(),
                  V1 :: i(),
                  V2 :: i(),
                  V3 :: i()) -&gt;
                     ok

       <b>uniform4uiv(Location</b> <b>::</b> <b>i(),</b> <b>Value</b> <b>::</b> <b>[{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()}])</b> <b>-&gt;</b>
                      ok

       <b>uniformMatrix2dv(Location</b> <b>::</b> <b>i(),</b>
                        Transpose :: 0 | 1,
                        Value :: [{f(), f(), f(), f()}]) -&gt;
                           ok

       <b>uniformMatrix2fv(Location</b> <b>::</b> <b>i(),</b>
                        Transpose :: 0 | 1,
                        Value :: [{f(), f(), f(), f()}]) -&gt;
                           ok

       <b>uniformMatrix2x3dv(Location</b> <b>::</b> <b>i(),</b>
                          Transpose :: 0 | 1,
                          Value :: [{f(), f(), f(), f(), f(), f()}]) -&gt;
                             ok

       <b>uniformMatrix2x3fv(Location</b> <b>::</b> <b>i(),</b>
                          Transpose :: 0 | 1,
                          Value :: [{f(), f(), f(), f(), f(), f()}]) -&gt;
                             ok

       <b>uniformMatrix2x4dv(Location</b> <b>::</b> <b>i(),</b>
                          Transpose :: 0 | 1,
                          Value ::
                              [{f(), f(), f(), f(), f(), f(), f(), f()}]) -&gt;
                             ok

       <b>uniformMatrix2x4fv(Location</b> <b>::</b> <b>i(),</b>
                          Transpose :: 0 | 1,
                          Value ::
                              [{f(), f(), f(), f(), f(), f(), f(), f()}]) -&gt;
                             ok

       <b>uniformMatrix3dv(Location</b> <b>::</b> <b>i(),</b>
                        Transpose :: 0 | 1,
                        Value ::
                            [{f(),
                              f(),
                              f(),
                              f(),
                              f(),
                              f(),
                              f(),
                              f(),
                              f()}]) -&gt;
                           ok

       <b>uniformMatrix3fv(Location</b> <b>::</b> <b>i(),</b>
                        Transpose :: 0 | 1,
                        Value ::
                            [{f(),
                              f(),
                              f(),
                              f(),
                              f(),
                              f(),
                              f(),
                              f(),
                              f()}]) -&gt;
                           ok

       <b>uniformMatrix3x2dv(Location</b> <b>::</b> <b>i(),</b>
                          Transpose :: 0 | 1,
                          Value :: [{f(), f(), f(), f(), f(), f()}]) -&gt;
                             ok

       <b>uniformMatrix3x2fv(Location</b> <b>::</b> <b>i(),</b>
                          Transpose :: 0 | 1,
                          Value :: [{f(), f(), f(), f(), f(), f()}]) -&gt;
                             ok

       <b>uniformMatrix3x4dv(Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b> <b>ok</b>

       <b>uniformMatrix3x4fv(Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b> <b>ok</b>

       <b>uniformMatrix4dv(Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b> <b>ok</b>

       <b>uniformMatrix4fv(Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b> <b>ok</b>

       <b>uniformMatrix4x2dv(Location</b> <b>::</b> <b>i(),</b>
                          Transpose :: 0 | 1,
                          Value ::
                              [{f(), f(), f(), f(), f(), f(), f(), f()}]) -&gt;
                             ok

       <b>uniformMatrix4x2fv(Location</b> <b>::</b> <b>i(),</b>
                          Transpose :: 0 | 1,
                          Value ::
                              [{f(), f(), f(), f(), f(), f(), f(), f()}]) -&gt;
                             ok

       <b>uniformMatrix4x3dv(Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b> <b>ok</b>

       <b>uniformMatrix4x3fv(Location,</b> <b>Transpose,</b> <b>Value)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Location = i()
                 Transpose = 0 | 1
                 Value =
                     [{f(), f(), f(), f(), f(), f(), f(), f(), f(), f(), f(), f()}]

              <u>gl:uniform()</u> modifies the value of a uniform variable or a uniform variable array. The location of
              the uniform variable to be modified is specified by <u>Location</u>, which should be a value returned  by
              <u>gl:getUniformLocation/2</u>. <u>gl:uniform()</u> operates on the program object that was made part of current
              state by calling <u>gl:useProgram/1</u>.

              External documentation.

       <b>uniformBlockBinding(Program</b> <b>::</b> <b>i(),</b>
                           UniformBlockIndex :: i(),
                           UniformBlockBinding :: i()) -&gt;
                              ok

              Binding  points  for  active uniform blocks are assigned using <u>gl:uniformBlockBinding/3</u>. Each of a
              program's active uniform blocks has a corresponding uniform buffer binding point. <u>Program</u>  is  the
              name of a program object for which the command <u>gl:linkProgram/1</u> has been issued in the past.

              External documentation.

       <b>uniformSubroutinesuiv(Shadertype</b> <b>::</b> <b>enum(),</b> <b>Indices</b> <b>::</b> <b>[i()])</b> <b>-&gt;</b>
                                ok

              <u>gl:uniformSubroutines()</u>  loads  all  active subroutine uniforms for shader stage <u>Shadertype</u> of the
              current program with subroutine indices from <u>Indices</u>,  storing  <u>Indices[i]</u>  into  the  uniform  at
              location  <u>I</u>.  <u>Count</u>  must be equal to the value of <u>?GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS</u> for the
              program currently in use at shader stage <u>Shadertype</u>. Furthermore, all values in  <u>Indices</u>  must  be
              less than the value of <u>?GL_ACTIVE_SUBROUTINES</u> for the shader stage.

              External documentation.

       <b>useProgram(Program</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:useProgram/1</u>  installs  the  program  object  specified by <u>Program</u> as part of current rendering
              state. One or more executables are created in a program object by  successfully  attaching  shader
              objects   to   it   with   <u>gl:attachShader/2</u>,  successfully  compiling  the  shader  objects  with
              <u>gl:compileShader/1</u>, and successfully linking the program object with <u>gl:linkProgram/1</u>.

              External documentation.

       <b>useProgramStages(Pipeline</b> <b>::</b> <b>i(),</b> <b>Stages</b> <b>::</b> <b>i(),</b> <b>Program</b> <b>::</b> <b>i())</b> <b>-&gt;</b>
                           ok

              <u>gl:useProgramStages/3</u> binds executables from a program object associated with a specified  set  of
              shader  stages  to  the  program pipeline object given by <u>Pipeline</u>. <u>Pipeline</u> specifies the program
              pipeline object to which to bind the executables. <u>Stages</u> contains a logical  combination  of  bits
              indicating  the  shader  stages  to  use within <u>Program</u> with the program pipeline object <u>Pipeline</u>.
              <u>Stages</u> must  be  a  logical  combination  of  <u>?GL_VERTEX_SHADER_BIT</u>,  <u>?GL_TESS_CONTROL_SHADER_BIT</u>,
              <u>?GL_TESS_EVALUATION_SHADER_BIT</u>,      <u>?GL_GEOMETRY_SHADER_BIT</u>,      <u>?GL_FRAGMENT_SHADER_BIT</u>     and
              <u>?GL_COMPUTE_SHADER_BIT</u>. Additionally, the special value <u>?GL_ALL_SHADER_BITS</u> may  be  specified  to
              indicate that all executables contained in <u>Program</u> should be installed in <u>Pipeline</u>.

              External documentation.

       <b>validateProgram(Program</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:validateProgram/1</u>  checks to see whether the executables contained in <u>Program</u> can execute given
              the current OpenGL state. The information generated by the validation process will  be  stored  in
              <u>Program</u>'s information log. The validation information may consist of an empty string, or it may be
              a  string  containing  information about how the current program object interacts with the rest of
              current OpenGL state. This provides a way for OpenGL implementers to convey more information about
              why the current program is inefficient, suboptimal, failing to execute, and so on.

              External documentation.

       <b>validateProgramPipeline(Pipeline</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:validateProgramPipeline/1</u> instructs the  implementation  to  validate  the  shader  executables
              contained  in  <u>Pipeline</u>  against  the  current  GL  state.  The  implementation may use this as an
              opportunity to perform any internal shader modifications that may be required  to  ensure  correct
              operation of the installed shaders given the current GL state.

              External documentation.

       <b>vertex2d(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex2dv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex2f(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex2fv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex2i(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex2iv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex2s(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex2sv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex3d(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex3dv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex3f(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex3fv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex3i(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex3iv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex3s(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex3sv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex4d(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f(),</b> <b>W</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex4dv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f(),</b> <b>W</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex4f(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f(),</b> <b>W</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex4fv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f(),</b> <b>W</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex4i(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i(),</b> <b>W</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex4iv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i(),</b> <b>W</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex4s(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i(),</b> <b>W</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertex4sv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i(),</b> <b>W</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:vertex()</u>  commands  are  used  within <u>gl:'begin'/1</u>/<u>gl:'end'/0</u> pairs to specify point, line, and
              polygon vertices.  The  current  color,  normal,  texture  coordinates,  and  fog  coordinate  are
              associated with the vertex when <u>gl:vertex()</u> is called.

              External documentation.

       <b>vertexArrayElementBuffer(Vaobj</b> <b>::</b> <b>i(),</b> <b>Buffer</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:vertexArrayElementBuffer/2</u>  binds  a  buffer  object with id <u>Buffer</u> to the element array buffer
              bind point of a vertex array object with id <u>Vaobj</u>. If <u>Buffer</u> is zero, any existing  element  array
              buffer binding to <u>Vaobj</u> is removed.

              External documentation.

       <b>vertexAttrib1d(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib1dv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib1f(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib1fv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib1s(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib1sv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib2d(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib2dv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib2f(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib2fv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib2s(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib2sv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib3d(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib3dv(Index</b> <b>::</b> <b>i(),</b>
                       X2 :: {X :: f(), Y :: f(), Z :: f()}) -&gt;
                          ok

       <b>vertexAttrib3f(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib3fv(Index</b> <b>::</b> <b>i(),</b>
                       X2 :: {X :: f(), Y :: f(), Z :: f()}) -&gt;
                          ok

       <b>vertexAttrib3s(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib3sv(Index</b> <b>::</b> <b>i(),</b>
                       X2 :: {X :: i(), Y :: i(), Z :: i()}) -&gt;
                          ok

       <b>vertexAttrib4Nbv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib4Niv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib4Nsv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib4Nub(Index</b> <b>::</b> <b>i(),</b>
                        X :: i(),
                        Y :: i(),
                        Z :: i(),
                        W :: i()) -&gt;
                           ok

       <b>vertexAttrib4Nubv(Index</b> <b>::</b> <b>i(),</b>
                         X2 :: {X :: i(), Y :: i(), Z :: i(), W :: i()}) -&gt;
                            ok

       <b>vertexAttrib4Nuiv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib4Nusv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib4bv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib4d(Index</b> <b>::</b> <b>i(),</b>
                      X :: f(),
                      Y :: f(),
                      Z :: f(),
                      W :: f()) -&gt;
                         ok

       <b>vertexAttrib4dv(Index</b> <b>::</b> <b>i(),</b>
                       X2 :: {X :: f(), Y :: f(), Z :: f(), W :: f()}) -&gt;
                          ok

       <b>vertexAttrib4f(Index</b> <b>::</b> <b>i(),</b>
                      X :: f(),
                      Y :: f(),
                      Z :: f(),
                      W :: f()) -&gt;
                         ok

       <b>vertexAttrib4fv(Index</b> <b>::</b> <b>i(),</b>
                       X2 :: {X :: f(), Y :: f(), Z :: f(), W :: f()}) -&gt;
                          ok

       <b>vertexAttrib4iv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib4s(Index</b> <b>::</b> <b>i(),</b>
                      X :: i(),
                      Y :: i(),
                      Z :: i(),
                      W :: i()) -&gt;
                         ok

       <b>vertexAttrib4sv(Index</b> <b>::</b> <b>i(),</b>
                       X2 :: {X :: i(), Y :: i(), Z :: i(), W :: i()}) -&gt;
                          ok

       <b>vertexAttrib4ubv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib4uiv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttrib4usv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI1i(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI1iv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI1ui(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI1uiv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI2i(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI2iv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI2ui(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI2uiv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI3i(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI3iv(Index</b> <b>::</b> <b>i(),</b>
                        X2 :: {X :: i(), Y :: i(), Z :: i()}) -&gt;
                           ok

       <b>vertexAttribI3ui(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI3uiv(Index</b> <b>::</b> <b>i(),</b>
                         X2 :: {X :: i(), Y :: i(), Z :: i()}) -&gt;
                            ok

       <b>vertexAttribI4bv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI4i(Index</b> <b>::</b> <b>i(),</b>
                       X :: i(),
                       Y :: i(),
                       Z :: i(),
                       W :: i()) -&gt;
                          ok

       <b>vertexAttribI4iv(Index</b> <b>::</b> <b>i(),</b>
                        X2 :: {X :: i(), Y :: i(), Z :: i(), W :: i()}) -&gt;
                           ok

       <b>vertexAttribI4sv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI4ubv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribI4ui(Index</b> <b>::</b> <b>i(),</b>
                        X :: i(),
                        Y :: i(),
                        Z :: i(),
                        W :: i()) -&gt;
                           ok

       <b>vertexAttribI4uiv(Index</b> <b>::</b> <b>i(),</b>
                         X2 :: {X :: i(), Y :: i(), Z :: i(), W :: i()}) -&gt;
                            ok

       <b>vertexAttribI4usv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{i(),</b> <b>i(),</b> <b>i(),</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribL1d(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribL1dv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribL2d(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribL2dv(Index</b> <b>::</b> <b>i(),</b> <b>X2</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribL3d(Index</b> <b>::</b> <b>i(),</b> <b>X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>vertexAttribL3dv(Index</b> <b>::</b> <b>i(),</b>
                        X2 :: {X :: f(), Y :: f(), Z :: f()}) -&gt;
                           ok

       <b>vertexAttribL4d(Index</b> <b>::</b> <b>i(),</b>
                       X :: f(),
                       Y :: f(),
                       Z :: f(),
                       W :: f()) -&gt;
                          ok

       <b>vertexAttribL4dv(Index</b> <b>::</b> <b>i(),</b>
                        X2 :: {X :: f(), Y :: f(), Z :: f(), W :: f()}) -&gt;
                           ok

              The  <u>gl:vertexAttrib()</u>  family  of  entry  points  allows  an  application  to pass generic vertex
              attributes in numbered locations.

              External documentation.

       <b>vertexArrayAttribBinding(Vaobj</b> <b>::</b> <b>i(),</b>
                                Attribindex :: i(),
                                Bindingindex :: i()) -&gt;
                                   ok

       <b>vertexAttribBinding(Attribindex</b> <b>::</b> <b>i(),</b> <b>Bindingindex</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:vertexAttribBinding/2</u> and <u>gl:vertexArrayAttribBinding/3</u> establishes an association between  the
              generic  vertex  attribute  of  a  vertex  array object whose index is given by <u>Attribindex</u>, and a
              vertex buffer binding whose index is given  by  <u>Bindingindex</u>.  For  <u>gl:vertexAttribBinding/2</u>,  the
              vertex  array object affected is that currently bound. For <u>gl:vertexArrayAttribBinding/3</u>, <u>Vaobj</u> is
              the name of the vertex array object.

              External documentation.

       <b>vertexAttribDivisor(Index</b> <b>::</b> <b>i(),</b> <b>Divisor</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:vertexAttribDivisor/2</u> modifies the  rate  at  which  generic  vertex  attributes  advance  when
              rendering  multiple  instances  of  primitives  in  a  single  draw  call. If <u>Divisor</u> is zero, the
              attribute at slot <u>Index</u> advances once per vertex. If <u>Divisor</u> is non-zero, the  attribute  advances
              once  per  <u>Divisor</u> instances of the set(s) of vertices being rendered. An attribute is referred to
              as instanced if its <u>?GL_VERTEX_ATTRIB_ARRAY_DIVISOR</u> value is non-zero.

              External documentation.

       <b>vertexArrayAttribFormat(Vaobj,</b> <b>Attribindex,</b> <b>Size,</b> <b>Type,</b>
                               Normalized, Relativeoffset) -&gt;
                                  ok

       <b>vertexArrayAttribIFormat(Vaobj</b> <b>::</b> <b>i(),</b>
                                Attribindex :: i(),
                                Size :: i(),
                                Type :: enum(),
                                Relativeoffset :: i()) -&gt;
                                   ok

       <b>vertexArrayAttribLFormat(Vaobj</b> <b>::</b> <b>i(),</b>
                                Attribindex :: i(),
                                Size :: i(),
                                Type :: enum(),
                                Relativeoffset :: i()) -&gt;
                                   ok

       <b>vertexAttribFormat(Attribindex</b> <b>::</b> <b>i(),</b>
                          Size :: i(),
                          Type :: enum(),
                          Normalized :: 0 | 1,
                          Relativeoffset :: i()) -&gt;
                             ok

       <b>vertexAttribIFormat(Attribindex</b> <b>::</b> <b>i(),</b>
                           Size :: i(),
                           Type :: enum(),
                           Relativeoffset :: i()) -&gt;
                              ok

       <b>vertexAttribIPointer(Index</b> <b>::</b> <b>i(),</b>
                            Size :: i(),
                            Type :: enum(),
                            Stride :: i(),
                            Pointer :: offset() | mem()) -&gt;
                               ok

       <b>vertexAttribLFormat(Attribindex</b> <b>::</b> <b>i(),</b>
                           Size :: i(),
                           Type :: enum(),
                           Relativeoffset :: i()) -&gt;
                              ok

       <b>vertexAttribLPointer(Index</b> <b>::</b> <b>i(),</b>
                            Size :: i(),
                            Type :: enum(),
                            Stride :: i(),
                            Pointer :: offset() | mem()) -&gt;
                               ok

              <u>gl:vertexAttribFormat/5</u>,  <u>gl:vertexAttribIFormat/4</u>  and  <u>gl:vertexAttribLFormat/4</u>,  as   well   as
              <u>gl:vertexArrayAttribFormat/6</u>,   <u>gl:vertexArrayAttribIFormat/5</u>   and  <u>gl:vertexArrayAttribLFormat/5</u>
              specify the organization of data in vertex arrays. The first three  calls  operate  on  the  bound
              vertex array object, whereas the last three ones modify the state of a vertex array object with ID
              <u>Vaobj</u>.  <u>Attribindex</u> specifies the index of the generic vertex attribute array whose data layout is
              being described, and must be less than the value of <u>?GL_MAX_VERTEX_ATTRIBS</u>.

              External documentation.

       <b>vertexAttribPointer(Index,</b> <b>Size,</b> <b>Type,</b> <b>Normalized,</b> <b>Stride,</b>
                           Pointer) -&gt;
                              ok

              Types:

                 Index = Size = i()
                 Type = enum()
                 Normalized = 0 | 1
                 Stride = i()
                 Pointer = offset() | mem()

              <u>gl:vertexAttribPointer/6</u>,  <u>gl:vertexAttribIPointer/5</u>  and  <u>gl:vertexAttribLPointer/5</u>  specify  the
              location  and  data  format  of  the array of generic vertex attributes at index <u>Index</u> to use when
              rendering. <u>Size</u> specifies the number of components per attribute and  must  be  1,  2,  3,  4,  or
              <u>?GL_BGRA</u>.  <u>Type</u>  specifies  the  data type of each component, and <u>Stride</u> specifies the byte stride
              from one attribute to the next, allowing vertices and attributes to be packed into a single  array
              or stored in separate arrays.

              External documentation.

       <b>vertexArrayBindingDivisor(Vaobj</b> <b>::</b> <b>i(),</b>
                                 Bindingindex :: i(),
                                 Divisor :: i()) -&gt;
                                    ok

       <b>vertexBindingDivisor(Bindingindex</b> <b>::</b> <b>i(),</b> <b>Divisor</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:vertexBindingDivisor/2</u>  and  <u>gl:vertexArrayBindingDivisor/3</u>  modify  the  rate at which generic
              vertex attributes advance when rendering  multiple  instances  of  primitives  in  a  single  draw
              command.  If  <u>Divisor</u>  is zero, the attributes using the buffer bound to <u>Bindingindex</u> advance once
              per vertex. If <u>Divisor</u> is non-zero, the attributes advance  once  per  <u>Divisor</u>  instances  of  the
              set(s)  of  vertices being rendered. An attribute is referred to as <u>instanced</u> if the corresponding
              <u>Divisor</u> value is non-zero.

              External documentation.

       <b>vertexPointer(Size</b> <b>::</b> <b>i(),</b>
                     Type :: enum(),
                     Stride :: i(),
                     Ptr :: offset() | mem()) -&gt;
                        ok

              <u>gl:vertexPointer/4</u> specifies the location and data format of an array of vertex coordinates to use
              when rendering. <u>Size</u> specifies the number of coordinates per vertex, and must be 2, 3, or 4.  <u>Type</u>
              specifies  the  data type of each coordinate, and <u>Stride</u> specifies the byte stride from one vertex
              to the next, allowing vertices and attributes to be packed  into  a  single  array  or  stored  in
              separate  arrays.  (Single-array  storage  may  be  more  efficient  on  some implementations; see
              <u>gl:interleavedArrays/3</u>.)

              External documentation.

       <b>viewport(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Width</b> <b>::</b> <b>i(),</b> <b>Height</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:viewport/4</u> specifies the affine transformation of x and y from normalized device coordinates to
              window coordinates. Let (x nd y nd) be normalized device coordinates. Then the window  coordinates
              (x w y w) are computed as follows:

              External documentation.

       <b>viewportArrayv(First</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>[{f(),</b> <b>f(),</b> <b>f(),</b> <b>f()}])</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:viewportArrayv/2</u>  specifies  the  parameters  for  multiple  viewports  simulataneously.  <u>First</u>
              specifies the index of the first viewport to modify and <u>Count</u> specifies the number of viewports to
              modify. <u>First</u> must be less than the value of <u>?GL_MAX_VIEWPORTS</u>, and <u>First</u> +  <u>Count</u>  must  be  less
              than  or  equal  to  the value of <u>?GL_MAX_VIEWPORTS</u>. Viewports whose indices lie outside the range
              [<u>First</u>, <u>First</u> + <u>Count</u>) are not modified. <u>V</u> contains the address of  an  array  of  floating  point
              values  specifying  the  left  ( x), bottom ( y), width ( w), and height ( h) of each viewport, in
              that order. x and y give the location of the viewport's lower left corner, and w and  h  give  the
              width  and  height of the viewport, respectively. The viewport specifies the affine transformation
              of x and y from normalized device coordinates to window coordinates. Let (x nd y nd) be normalized
              device coordinates. Then the window coordinates (x w y w) are computed as follows:

              External documentation.

       <b>viewportIndexedf(Index</b> <b>::</b> <b>i(),</b>
                        X :: f(),
                        Y :: f(),
                        W :: f(),
                        H :: f()) -&gt;
                           ok

       <b>viewportIndexedfv(Index</b> <b>::</b> <b>i(),</b> <b>V</b> <b>::</b> <b>{f(),</b> <b>f(),</b> <b>f(),</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:viewportIndexedf/5</u> and <u>gl:viewportIndexedfv/2</u> specify the parameters  for  a  single  viewport.
              <u>Index</u>  specifies  the  index  of  the  viewport  to  modify.  <u>Index</u> must be less than the value of
              <u>?GL_MAX_VIEWPORTS</u>. For <u>gl:viewportIndexedf/5</u>, <u>X</u>, <u>Y</u>, <u>W</u>, and <u>H</u> specify the left, bottom,  width  and
              height of the viewport in pixels, respectively. For <u>gl:viewportIndexedfv/2</u>, <u>V</u> contains the address
              of an array of floating point values specifying the left ( x), bottom ( y), width ( w), and height
              (  h)  of  each  viewport,  in  that order. x and y give the location of the viewport's lower left
              corner, and w and h give the  width  and  height  of  the  viewport,  respectively.  The  viewport
              specifies  the  affine  transformation  of  x  and  y from normalized device coordinates to window
              coordinates. Let (x nd y nd) be normalized device coordinates. Then the window coordinates (x w  y
              w) are computed as follows:

              External documentation.

       <b>waitSync(Sync</b> <b>::</b> <b>i(),</b> <b>Flags</b> <b>::</b> <b>i(),</b> <b>Timeout</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

              <u>gl:waitSync/3</u> causes the GL server to block and wait until <u>Sync</u> becomes signaled. <u>Sync</u> is the name
              of  an  existing sync object upon which to wait. <u>Flags</u> and <u>Timeout</u> are currently not used and must
              be set to zero and the special value <u>?GL_TIMEOUT_IGNORED</u>, respectively

              <u>Flags</u> and <u>Timeout</u> are placeholders for anticipated future extensions of sync object  capabilities.
              They  must  have  these  reserved values in order that existing code calling <u>gl:waitSync/3</u> operate
              properly in the presence of such extensions.

              External documentation.

       <b>windowPos2d(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos2dv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos2f(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos2fv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos2i(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos2iv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos2s(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos2sv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos3d(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos3dv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos3f(X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f())</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos3fv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>f(),</b> <b>Y</b> <b>::</b> <b>f(),</b> <b>Z</b> <b>::</b> <b>f()})</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos3i(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos3iv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos3s(X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i())</b> <b>-&gt;</b> <b>ok</b>

       <b>windowPos3sv(X1</b> <b>::</b> <b>{X</b> <b>::</b> <b>i(),</b> <b>Y</b> <b>::</b> <b>i(),</b> <b>Z</b> <b>::</b> <b>i()})</b> <b>-&gt;</b> <b>ok</b>

              The GL maintains a 3D position in window coordinates. This position, called the  raster  position,
              is  used  to  position pixel and bitmap write operations. It is maintained with subpixel accuracy.
              See <u>gl:bitmap/7</u>, <u>gl:drawPixels/5</u>, and <u>gl:copyPixels/5</u>.

              External documentation.

Ericsson AB                                         wx 2.1.1                                            <u><a href="../man3erl/gl.3erl.html">gl</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>