<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mason::Manual::FAQ - Frequently asked questions about Mason</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmason-perl">libmason-perl_2.24-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mason::Manual::FAQ - Frequently asked questions about Mason

</pre><h4><b>COMPONENTS</b></h4><pre>
   <b>Can</b> <b>I</b> <b>create</b> <b>global</b> <b>variable(s)</b> <b>that</b> <b>can</b> <b>be</b> <b>seen</b> <b>from</b> <b>all</b> <b>components?</b>
       Mason components each run in their own packages, so if you set a regular global in one you won't be able
       to see it in the others.

       But you can use allow_globals and set_global to create globals accessible from all components.

   <b>Why</b> <b>does</b> <b>my</b> <b>output</b> <b>have</b> <b>extra</b> <b>newlines/whitespace</b> <b>and</b> <b>how</b> <b>can</b> <b>I</b> <b>get</b> <b>rid</b> <b>of</b> <b>it?</b>
       See Whitespace And Newlines in the syntax manual. To suppress extra newlines you can use a backslash at
       the end of each line, or you can use the NoBlankLines filter.

       To emit binary data without the risk of inserting extra whitespace, surround your code with
       $m-&gt;clear_buffer and $m-&gt;abort:

           &lt;%init&gt;
           $m-&gt;clear_buffer;
           open(my $fh, '&lt;', 'binary-file') or die $!;
           my $buffer;
           while (read $fh, $buffer, 8192) {
               $m-&gt;print($buffer);
           }
           $m-&gt;abort;
           &lt;/%init&gt;

   <b>I'm</b> <b>trying</b> <b>to</b> <b>generate</b> <b>an</b> <b>image</b> <b>or</b> <b>other</b> <b>binary</b> <b>file,</b> <b>but</b> <b>it</b> <b>seems</b> <b>to</b> <b>be</b> <b>getting</b> <b>corrupted.</b>
       This is almost always caused by unwanted whitespace or other output at the beginning or end of your
       binary data. Use $m-&gt;clear_buffer and $m-&gt;abort as in previous answer.

   <b>How</b> <b>do</b> <b>I</b> <b>put</b> <b>comments</b> <b>in</b> <b>components?</b>
       See Comments section in the syntax manual for reference.

       •   Put general comments in the "&lt;%doc&gt;" section.

       •   Within code blocks ("&lt;%class&gt;", "&lt;%init&gt;", "&lt;%perl&gt;", etc.), use standard Perl comments ('#').

       •   Use "&lt;% # %&gt;" for single or multi-line comments anywhere outside of Perl sections.

       •   If  you  are producing HTML, you can use standard HTML comments delimited by &lt;!-- --&gt;. The difference
           is that these comments will appear in the final output.

   <b>What's</b> <b>a</b> <b>good</b> <b>way</b> <b>to</b> <b>temporarily</b> <b>comment</b> <b>out</b> <b>code</b> <b>in</b> <b>a</b> <b>component?</b>
       For HTML, you might be tempted to surround the section with "&lt;!-- --&gt;".  But be careful! Any code  inside
       the section will still execute. Here's a example of commenting out a call to an ad server:

           &lt;!-- temporarily comment out
           &lt;&amp; /shared/fetch_ad.mi &amp;&gt;
           --&gt;

       The ad will still be fetched and counted, but not displayed!

       A better way to block out a section is "if (0)":

           % if (0) {
             ...
           % }

       Code  blocked out in this way will neither be executed nor displayed, and multiple "if (0)" blocks can be
       nested inside each other (unlike HTML comments).

       Another way to block out code is with a "&lt;%doc&gt;" tag, although this not cannot be nested.

   <b>How</b> <b>can</b> <b>I</b> <b>capture</b> <b>the</b> <b>output</b> <b>of</b> <b>a</b> <b>component</b> <b>(and</b> <b>modify</b> <b>it,</b> <b>etc.)</b> <b>instead</b> <b>of</b> <b>having</b> <b>it</b> <b>automatically</b>  <b>output?</b>

       Use $m-&gt;scomp.

   <b>How</b> <b>can</b> <b>I</b> <b>capture</b> <b>the</b> <b>output</b> <b>from</b> <b>arbitrary</b> <b>code</b> <b>that</b> <b>calls</b> <b>components,</b> <b>etc.?</b>
       Use $m-&gt;capture.

   <b>How</b> <b>can</b> <b>I</b> <b>get</b> <b>a</b> <b>list</b> <b>of</b> <b>components</b> <b>matching</b> <b>a</b> <b>path</b> <b>pattern?</b>
       Use $m-&gt;glob_paths, e.g.

           my @paths = $m-&gt;glob_paths('/some/comp/path/*');

       This  will  work even with multiple component roots; you'll get a combined list of all matching component
       paths in all component roots.

   <b>How</b> <b>can</b> <b>I</b> <b>access</b> <b>$m</b> <b>(the</b> <b>request</b> <b>object)</b> <b>from</b> <b>outside</b> <b>a</b> <b>component,</b> <b>e.g.</b> <b>inside</b> <b>a</b> <b>regular</b> <b>class?</b>
       Use Mason::Request-&gt;current_request:

           package Foo;

           sub bar {
               my $m = Mason::Request-&gt;current_request;
           }

   <b>When</b> <b>using</b> <b>multiple</b> <b>component</b> <b>roots,</b> <b>is</b> <b>there</b> <b>a</b> <b>way</b> <b>to</b> <b>explicitly</b> <b>call</b> <b>a</b> <b>component</b> <b>in</b> <b>a</b> <b>specific</b> <b>root?</b>
       Multiple component roots were designed to work just like Perl's @INC.  A  given  component  path  matches
       exactly  one  file,  the  first  file  found  in  an ordered search through the roots. There is no way to
       explicitly ask for a file in a specific root.

</pre><h4><b>HTTP</b> <b>and</b> <b>HTML</b></h4><pre>
   <b>How</b> <b>do</b> <b>I</b> <b>use</b> <b>Mason</b> <b>to</b> <b>process</b> <b>web</b> <b>requests?</b>
       You need to use Mason in conjunction with a web framework. Poet is a web framework designed specially for
       Mason.  Catalyst and Dancer can also use Mason for their templating layer. See Mason::Manual::Setup.

   <b>How</b> <b>can</b> <b>I</b> <b>HTML-escape</b> <b>the</b> <b>output</b> <b>of</b> <b>"&lt;%</b> <b>%&gt;"</b> <b>tags?</b>
       See the "H" filter in Mason::Plugin::HTMLFilters. If you want to do this automatically for  all  "&lt;%  %&gt;"
       tags, see Mason::Plugin::DefaultFilter.

   <b>Why</b> <b>is</b> <b>Mason</b> <b>so</b> <b>slow</b> <b>with</b> <b>standard</b> <b>CGI?</b>
       Under  standard CGI you must load all modules and initialize your environment with every request. Mason's
       startup cost (mostly due to Moose) will make this particularly  sub-optimal.  Ask  yourself  whether  you
       absolutely  have  to  use  CGI,  and if not, switch to a persistent solution like mod_perl or Fast CGI or
       Starman.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mason

</pre><h4><b>AUTHOR</b></h4><pre>
       Jonathan Swartz &lt;<a href="mailto:swartz@pobox.com">swartz@pobox.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2012 by Jonathan Swartz.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.34.0                                       2022-05-27                            <u>Mason::Manual::<a href="../man3pm/FAQ.3pm.html">FAQ</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>