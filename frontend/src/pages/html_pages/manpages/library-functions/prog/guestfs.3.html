<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>guestfs - Library for accessing and modifying virtual machine images</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libguestfs-dev">libguestfs-dev_1.54.1-2ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       guestfs - Library for accessing and modifying virtual machine images

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;guestfs.h&gt;

        guestfs_h *g = guestfs_create ();
        guestfs_add_drive (g, "guest.img");
        guestfs_launch (g);
        guestfs_mount (g, "/dev/sda1", "/");
        guestfs_touch (g, "/hello");
        guestfs_umount (g, "/");
        guestfs_shutdown (g);
        guestfs_close (g);

        cc prog.c -o prog -lguestfs
       or:
        cc prog.c -o prog `pkg-config libguestfs --cflags --libs`

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Libguestfs is a library for accessing and modifying disk images and virtual machines.

       This manual page documents the C API.

       If you are looking for an introduction to libguestfs, see the web site: <a href="http://libguestfs.org/">http://libguestfs.org/</a>

       Each virt tool has its own man page (for a full list, go to "SEE ALSO" at the end of this file).

       Other libguestfs manual pages:

       <b><a href="../man1/guestfs-faq.1.html">guestfs-faq</a></b>(1)
           Frequently Asked Questions (FAQ).

       <b><a href="../man3/guestfs-examples.3.html">guestfs-examples</a></b>(3)
           Examples  of using the API from C.  For examples in other languages, see "USING LIBGUESTFS WITH OTHER
           PROGRAMMING LANGUAGES" below.

       <b><a href="../man1/guestfs-recipes.1.html">guestfs-recipes</a></b>(1)
           Tips and recipes.

       <b><a href="../man1/guestfs-performance.1.html">guestfs-performance</a></b>(1)
           Performance tips and solutions.

       <b><a href="../man1/libguestfs-test-tool.1.html">libguestfs-test-tool</a></b>(1)
       <b><a href="../man1/guestfs-testing.1.html">guestfs-testing</a></b>(1)
           Help testing libguestfs.

       <b><a href="../man1/guestfs-building.1.html">guestfs-building</a></b>(1)
           How to build libguestfs from source.

       <b><a href="../man1/guestfs-hacking.1.html">guestfs-hacking</a></b>(1)
           Contribute code to libguestfs.

       <b><a href="../man1/guestfs-internals.1.html">guestfs-internals</a></b>(1)
           How libguestfs works.

       <b><a href="../man1/guestfs-security.1.html">guestfs-security</a></b>(1)
           Security information, including CVEs affecting libguestfs.

</pre><h4><b>API</b> <b>OVERVIEW</b></h4><pre>
       This section provides a gentler overview of the libguestfs API.  We also try to group API calls together,
       where that may not be obvious from reading about the individual calls in the main section of this manual.

   <b>HANDLES</b>
       Before you can use libguestfs calls, you have to create a handle.  Then you must add at  least  one  disk
       image  to the handle, followed by launching the handle, then performing whatever operations you want, and
       finally closing the handle.  By convention we use the single letter  "g"  for  the  name  of  the  handle
       variable, although of course you can use any name you want.

       The general structure of all libguestfs-using programs looks like this:

        guestfs_h *g = guestfs_create ();

        /* Call guestfs_add_drive additional times if there are
         * multiple disk images.
         */
        guestfs_add_drive (g, "guest.img");

        /* Most manipulation calls won't work until you've launched
         * the handle 'g'.  You have to do this _after_ adding drives
         * and _before_ other commands.
         */
        guestfs_launch (g);

        /* Either: examine what partitions, LVs etc are available: */
        char **partitions = guestfs_list_partitions (g);
        char **logvols = guestfs_lvs (g);

        /* Or: ask libguestfs to find filesystems for you: */
        char **filesystems = guestfs_list_filesystems (g);

        /* Or: use inspection (see INSPECTION section below). */

        /* To access a filesystem in the image, you must mount it. */
        guestfs_mount (g, "/dev/sda1", "/");

        /* Now you can perform filesystem actions on the guest
         * disk image.
         */
        guestfs_touch (g, "/hello");

        /* Synchronize the disk.  This is the opposite of guestfs_launch. */
        guestfs_shutdown (g);

        /* Close and free the handle 'g'. */
        guestfs_close (g);

       The code above doesn't include any error checking.  In real code you should check return values carefully
       for  errors.   In  general  all functions that return integers return -1 on error, and all functions that
       return pointers return "NULL" on error.  See section "ERROR HANDLING" below for how to handle errors, and
       consult the documentation  for  each  function  call  below  to  see  precisely  how  they  return  error
       indications.

       The  code  above  does  not  <b><a href="../man3/free.3.html">free</a></b>(3)  the  strings  and  arrays  returned  from  functions.   Consult the
       documentation for each function to find out how to free the return value.

       See <b><a href="../man3/guestfs-examples.3.html">guestfs-examples</a></b>(3) for fully worked examples.

   <b>DISK</b> <b>IMAGES</b>
       The image filename ("guest.img" in the example above) could be a disk image from  a  virtual  machine,  a
       <b><a href="../man1/dd.1.html">dd</a></b>(1)  copy  of  a physical hard disk, an actual block device, or simply an empty file of zeroes that you
       have created through <b><a href="../man3/posix_fallocate.3.html">posix_fallocate</a></b>(3).  Libguestfs lets you do useful things to all of these.

       The call you should use in modern code for adding drives is  "guestfs_add_drive_opts".   To  add  a  disk
       image, allowing writes, and specifying that the format is raw, do:

        guestfs_add_drive_opts (g, filename,
                                GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
                                -1);

       You can add a disk read-only using:

        guestfs_add_drive_opts (g, filename,
                                GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
                                GUESTFS_ADD_DRIVE_OPTS_READONLY, 1,
                                -1);

       or  by calling the older function "guestfs_add_drive_ro".  If you use the readonly flag, libguestfs won't
       modify the file.  (See also "DISK IMAGE FORMATS" below).

       Be extremely cautious if the disk image is in use, eg. if it is being used by a virtual machine.   Adding
       it read-write will almost certainly cause disk corruption, but adding it read-only is safe.

       You should usually add at least one disk image, and you may add multiple disk images.  If adding multiple
       disk images, they usually have to be "related", ie. from the same guest.  In the API, the disk images are
       usually  referred  to as <u>/dev/sda</u> (for the first one you added), <u>/dev/sdb</u> (for the second one you added),
       etc.

       Once  "guestfs_launch"  has  been  called   you   cannot   add   any   more   images.    You   can   call
       "guestfs_list_devices"  to  get  a  list of the device names, in the order that you added them.  See also
       "BLOCK DEVICE NAMING" below.

   <b>MOUNTING</b>
       Before you can read or write files,  create  directories  and  so  on  in  a  disk  image  that  contains
       filesystems,  you  have  to  mount those filesystems using "guestfs_mount" or "guestfs_mount_ro".  If you
       already know that a disk image contains (for example) one partition with a filesystem on that  partition,
       then you can mount it directly:

        guestfs_mount (g, "/dev/sda1", "/");

       where <u>/dev/sda1</u> means literally the first partition (1) of the first disk image that we added (<u>/dev/sda</u>).
       If  the disk contains Linux LVM2 logical volumes you could refer to those instead (eg. <u>/dev/VG/LV</u>).  Note
       that these are libguestfs virtual devices, and are nothing to do with host devices.

       If you are given a disk image and you don’t know what it contains then you have to find out.   Libguestfs
       can do that too: use "guestfs_list_partitions" and "guestfs_lvs" to list possible partitions and LVs, and
       either  try  mounting  each  to  see  what  is mountable, or else examine them with "guestfs_vfs_type" or
       "guestfs_file".  To list just filesystems, use "guestfs_list_filesystems".

       Libguestfs also has a set of APIs for inspection of unknown disk images (see  "INSPECTION"  below).   You
       might  also  want  to  look  at  higher  level  programs  built  on  top  of  libguestfs,  in  particular
       <b><a href="../man1/virt-inspector.1.html">virt-inspector</a></b>(1).

       To mount a filesystem read-only, use "guestfs_mount_ro".  There  are  several  other  variations  of  the
       "guestfs_mount_*" call.

   <b>FILESYSTEM</b> <b>ACCESS</b> <b>AND</b> <b>MODIFICATION</b>
       The  majority  of  the  libguestfs API consists of fairly low-level calls for accessing and modifying the
       files, directories, symlinks etc on mounted filesystems.  There are over a hundred such calls  which  you
       can  find  listed  in  detail below in this man page, and we don't even pretend to cover them all in this
       overview.

       Specify filenames as full paths, starting with "/" and including the mount point.

       For example, if you mounted a filesystem at "/" and you want to read the file  called  "etc/passwd"  then
       you could do:

        char *data = guestfs_cat (g, "<a href="file:/etc/passwd">/etc/passwd</a>");

       This  would return "data" as a newly allocated buffer containing the full content of that file (with some
       conditions: see also "DOWNLOADING" below), or "NULL" if there was an error.

       As another example, to create a top-level directory on that filesystem called "var" you would do:

        guestfs_mkdir (g, "<a href="file:/var">/var</a>");

       To create a symlink you could do:

        guestfs_ln_s (g, "/etc/init.d/portmap",
                      "/etc/rc3.d/S30portmap");

       Libguestfs will reject attempts to use relative paths and there  is  no  concept  of  a  current  working
       directory.

       Libguestfs  can  return  errors in many situations: for example if the filesystem isn't writable, or if a
       file or directory that you requested doesn't exist.  If you are using the C  API  (documented  here)  you
       have  to  check  for  those error conditions after each call.  (Other language bindings turn these errors
       into exceptions).

       File writes are affected by the per-handle umask, set by calling "guestfs_umask" and defaulting  to  022.
       See "UMASK".

       Since libguestfs 1.18, it is possible to mount the libguestfs filesystem on a local directory, subject to
       some restrictions.  See "MOUNT LOCAL" below.

   <b>PARTITIONING</b>
       Libguestfs contains API calls to read, create and modify partition tables on disk images.

       In  the  common  case where you want to create a single partition covering the whole disk, you should use
       the "guestfs_part_disk" call:

        const char *parttype = "mbr";
        if (disk_is_larger_than_2TB)
          parttype = "gpt";
        guestfs_part_disk (g, "/dev/sda", parttype);

       Obviously this effectively wipes anything that was on that disk image before.

   <b>LVM2</b>
       Libguestfs  provides  access  to  a  large  part  of  the  LVM2  API,  such  as  "guestfs_lvcreate"   and
       "guestfs_vgremove".   It  won't  make  much  sense  unless  you familiarize yourself with the concepts of
       physical volumes, volume groups and logical volumes.

       This author strongly recommends reading the LVM HOWTO, online at <a href="http://tldp.org/HOWTO/LVM-HOWTO/">http://tldp.org/HOWTO/LVM-HOWTO/</a>.

   <b>DOWNLOADING</b>
       Use "guestfs_cat" to download small, text only files.  This call cannot handle files containing any ASCII
       NUL ("\0") characters.  However the API is very simple to use.

       "guestfs_read_file" can be used to read files which contain arbitrary 8 bit  data,  since  it  returns  a
       (pointer, size) pair.

       "guestfs_download" can be used to download any file, with no limits on content or size.

       To download multiple files, see "guestfs_tar_out" and "guestfs_tgz_out".

   <b>UPLOADING</b>
       To  write  a  small  file  with  fixed content, use "guestfs_write".  To create a file of all zeroes, use
       "guestfs_truncate_size" (sparse) or "guestfs_fallocate64" (with all disk blocks allocated).  There are  a
       variety    of   other   functions   for   creating   test   files,   for   example   "guestfs_fill"   and
       "guestfs_fill_pattern".

       To upload a single file, use "guestfs_upload".  This call has no limits on file content or size.

       To upload multiple files, see "guestfs_tar_in" and "guestfs_tgz_in".

       However the fastest way to upload <u>large</u> <u>numbers</u> <u>of</u> <u>arbitrary</u> <u>files</u> is to turn them into a squashfs or  CD
       ISO  (see  <b><a href="../man8/mksquashfs.8.html">mksquashfs</a></b>(8)  and <b><a href="../man8/mkisofs.8.html">mkisofs</a></b>(8)), then attach this using "guestfs_add_drive_ro".  If you add the
       drive in a predictable way (eg. adding it last after all other drives) then you can get the  device  name
       from  "guestfs_list_devices"  and  mount it directly using "guestfs_mount_ro".  Note that squashfs images
       are sometimes non-portable between kernel versions, and they don't support labels or UUIDs.  If you  want
       to pre-build an image or you need to mount it using a label or UUID, use an ISO image instead.

   <b>COPYING</b>
       There  are  various  different commands for copying between files and devices and in and out of the guest
       filesystem.  These are summarised in the table below.

       <b>file</b> to <b>file</b>
           Use "guestfs_cp" to copy a single file, or "guestfs_cp_a" to copy directories recursively.

           To copy part of a file (offset and size) use "guestfs_copy_file_to_file".

       <b>file</b> to <b>device</b>
       <b>device</b> to <b>file</b>
       <b>device</b> to <b>device</b>
           Use "guestfs_copy_file_to_device", "guestfs_copy_device_to_file", or "guestfs_copy_device_to_device".

           Example: duplicate the contents of an LV:

            guestfs_copy_device_to_device (g,
                    "/dev/VG/Original", "/dev/VG/Copy",
                    /* -1 marks the end of the list of optional parameters */
                    -1);

           The destination (<u>/dev/VG/Copy</u>) must be at least as large as the source (<u>/dev/VG/Original</u>).   To  copy
           less than the whole source device, use the optional "size" parameter:

            guestfs_copy_device_to_device (g,
                    "/dev/VG/Original", "/dev/VG/Copy",
                    GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE, 10000,
                    -1);

       <b>file</b> <b>on</b> <b>the</b> <b>host</b> to <b>file</b> <b>or</b> <b>device</b>
           Use "guestfs_upload".  See "UPLOADING" above.

       <b>file</b> <b>or</b> <b>device</b> to <b>file</b> <b>on</b> <b>the</b> <b>host</b>
           Use "guestfs_download".  See "DOWNLOADING" above.

   <b>UPLOADING</b> <b>AND</b> <b>DOWNLOADING</b> <b>TO</b> <b>PIPES</b> <b>AND</b> <b>FILE</b> <b>DESCRIPTORS</b>
       Calls  like  "guestfs_upload", "guestfs_download", "guestfs_tar_in", "guestfs_tar_out" etc appear to only
       take filenames as arguments, so it appears you can only upload  and  download  to  files.   However  many
       Un*x-like  hosts  let you use the special device files <u><a href="file:/dev/stdin">/dev/stdin</a></u>, <u>/dev/stdout</u>, <u>/dev/stderr</u> and <u>/dev/fd/N</u>
       to read and write from stdin, stdout, stderr, and arbitrary file descriptor N.

       For example, <b><a href="../man1/virt-cat.1.html">virt-cat</a></b>(1) writes its output to stdout by doing:

        guestfs_download (g, filename, "/dev/stdout");

       and you can write tar output to a file descriptor "fd" by doing:

        char devfd[64];
        snprintf (devfd, sizeof devfd, "<a href="file:/dev/fd/">/dev/fd/</a>%d", fd);
        guestfs_tar_out (g, "/", devfd);

   <b>LISTING</b> <b>FILES</b>
       "guestfs_ll" is just designed for humans to read (mainly when using the  <b><a href="../man1/guestfish.1.html">guestfish</a></b>(1)-equivalent  command
       "ll").

       "guestfs_ls"  is  a  quick  way  to  get  a list of files in a directory from programs, as a flat list of
       strings.

       "guestfs_readdir" is a programmatic way  to  get  a  list  of  files  in  a  directory,  plus  additional
       information about each one.  It is more equivalent to using the <b><a href="../man3/readdir.3.html">readdir</a></b>(3) call on a local filesystem.

       "guestfs_find" and "guestfs_find0" can be used to recursively list files.

   <b>RUNNING</b> <b>COMMANDS</b>
       Although  libguestfs is primarily an API for manipulating files inside guest images, we also provide some
       limited facilities for running commands inside guests.

       There are many limitations to this:

       •   The kernel version that the command runs under will be different from what it expects.

       •   If the command needs to communicate with daemons, then most likely they won't be running.

       •   The command will be running in limited memory.

       •   The network may not be available unless you enable it (see "guestfs_set_network").

       •   Only supports Linux guests (not Windows, BSD, etc).

       •   Architecture limitations (eg. won’t work for a PPC guest on an X86 host).

       •   For SELinux guests, you may need to relabel the guest after creating new files.  See "SELINUX" below.

       •   <u>Security:</u> It is not safe to run commands from untrusted, possibly malicious guests.   These  commands
           may attempt to exploit your program by sending unexpected output.  They could also try to exploit the
           Linux  kernel  or  qemu provided by the libguestfs appliance.  They could use the network provided by
           the libguestfs appliance to bypass ordinary network partitions and firewalls.   They  could  use  the
           elevated privileges or different SELinux context of your program to their advantage.

           A  secure  alternative is to use libguestfs to install a "firstboot" script (a script which runs when
           the guest next boots normally), and to have this script run the  commands  you  want  in  the  normal
           context  of  the  running  guest,  network  security and so on.  For information about other security
           issues, see <b><a href="../man1/guestfs-security.1.html">guestfs-security</a></b>(1).

       The two main  API  calls  to  run  commands  are  "guestfs_command"  and  "guestfs_sh"  (there  are  also
       variations).

       The  difference is that "guestfs_sh" runs commands using the shell, so any shell globs, redirections, etc
       will work.

   <b>CONFIGURATION</b> <b>FILES</b>
       To read and write configuration files in Linux guest filesystems, we  strongly  recommend  using  Augeas.
       For  example,  Augeas  understands  how  to  read  and  write, say, a Linux shadow password file or X.org
       configuration file, and so avoids you having to write that code.

       The main Augeas calls are bound through the "guestfs_aug_*" APIs.  We don't document Augeas  itself  here
       because there is excellent documentation on the <a href="http://augeas.net/">http://augeas.net/</a> website.

       If  you  don’t  want to use Augeas (you fool!) then try calling "guestfs_read_lines" to get the file as a
       list of lines which you can iterate over.

   <b>SYSTEMD</b> <b>JOURNAL</b> <b>FILES</b>
       To read the systemd  journal  from  a  Linux  guest,  use  the  "guestfs_journal_*"  APIs  starting  with
       "guestfs_journal_open".

       Consult the journal documentation here: <b><a href="../man3/sd-journal.3.html">sd-journal</a></b>(3), <b><a href="../man3/sd_journal_open.3.html">sd_journal_open</a></b>(3).

   <b>SELINUX</b>
       We  support  SELinux guests.  However it is not possible to load the SELinux policy of the guest into the
       appliance kernel.  Therefore the strategy for dealing with SELinux guests is to relabel them after making
       changes.

       In libguestfs ≥ 1.34 there is a new API, "guestfs_setfiles", which can be used for this.  To properly use
       this API  you  have  to  parse  the  guest  SELinux  configuration.   See  the  <b><a href="../man1/virt-customize.1.html">virt-customize</a></b>(1)  module
       <u>customize/SELinux_relabel.ml</u> for how to do this.

       A  simpler but slower alternative is to touch <u>/.autorelabel</u> in the guest, which means that the guest will
       relabel itself at next boot.

       Libguestfs  ≤  1.32  had  APIs   "guestfs_set_selinux",   "guestfs_get_selinux",   "guestfs_setcon"   and
       "guestfs_getcon".  These did not work properly, are deprecated, and should not be used in new code.

   <b>UMASK</b>
       Certain  calls  are  affected  by  the current file mode creation mask (the "umask").  In particular ones
       which create files or directories, such as "guestfs_touch",  "guestfs_mknod"  or  "guestfs_mkdir".   This
       affects either the default mode that the file is created with or modifies the mode that you supply.

       The default umask is 022, so files are created with modes such as 0644 and directories with 0755.

       There  are two ways to avoid being affected by umask.  Either set umask to 0 (call "guestfs_umask (g, 0)"
       early after launching).  Or call "guestfs_chmod" after creating each file or directory.

       For more information about umask, see <b><a href="../man2/umask.2.html">umask</a></b>(2).

   <b>LABELS</b> <b>AND</b> <b>UUIDS</b>
       Many filesystems, devices and logical volumes support either labels  (short  strings  like  "BOOT"  which
       might not be unique) and/or UUIDs (globally unique IDs).

       For  filesystems,  use  "guestfs_vfs_label"  or  "guestfs_vfs_uuid"  to  read  the  label  or UUID.  Some
       filesystems let you call "guestfs_set_label" or "guestfs_set_uuid" to change the label or UUID.

       You can locate a filesystem by its label or UUID using "guestfs_findfs_label" or "guestfs_findfs_uuid".

       For LVM2 (which supports only UUIDs), there is a rich set of APIs for fetching UUIDs, fetching  UUIDs  of
       the  contained  objects,  and changing UUIDs.  See: "guestfs_lvuuid", "guestfs_vguuid", "guestfs_pvuuid",
       "guestfs_vglvuuids",    "guestfs_vgpvuuids",    "guestfs_vgchange_uuid",     "guestfs_vgchange_uuid_all",
       "guestfs_pvchange_uuid", "guestfs_pvchange_uuid_all".

       Note  when  cloning  a filesystem, device or whole guest, it is a good idea to set new randomly generated
       UUIDs on the copy.

   <b>ENCRYPTED</b> <b>DISKS</b>
       Libguestfs allows you to access Linux guests which have been encrypted using whole disk  encryption  that
       conforms  to the Linux Unified Key Setup (LUKS) standard.  This includes nearly all whole disk encryption
       systems used by modern Linux guests.  Windows BitLocker is also supported.

       Use  "guestfs_vfs_type"  to  identify  encrypted  block  devices.   For  LUKS  it  returns   the   string
       "crypto_LUKS".  For Windows BitLocker it returns "BitLocker".

       Then open these devices by calling "guestfs_cryptsetup_open".  Obviously you will require the passphrase!

       Passphrase-less  unlocking  is  supported for LUKS (not BitLocker) block devices that have been encrypted
       with network-bound disk encryption (NBDE), using Clevis on the Linux guest side, and Tang on  a  separate
       Linux  server.   Open such devices with "guestfs_clevis_luks_unlock".  The appliance will need networking
       enabled (refer to "guestfs_set_network") and actual connectivity to the Tang servers noted in the  "tang"
       Clevis  pins  that  are bound to the LUKS header.  (This includes the ability to resolve the names of the
       Tang servers.)

       Opening an encrypted device  creates  a  new  device  mapper  device  called  <u>/dev/mapper/mapname</u>  (where
       "mapname"  is  the string you supply to "guestfs_cryptsetup_open" or "guestfs_clevis_luks_unlock"). Reads
       and writes to this mapper device are  decrypted  from  and  encrypted  to  the  underlying  block  device
       respectively.

       LVM  volume  groups  on  the  device  can  be  made  visible  by  calling  "guestfs_vgscan"  followed  by
       "guestfs_vg_activate_all".  The logical volume(s) can now be mounted in the usual way.

       Use the reverse process to close an encrypted device.  Unmount any logical volumes on it, deactivate  the
       volume  groups  by  calling  "guestfs_vg_activate  (g, 0, ["/dev/VG"])".  Then close the mapper device by
       calling "guestfs_cryptsetup_close" on the <u>/dev/mapper/mapname</u> device (<u>not</u> the underlying encrypted  block
       device).

   <b>MOUNT</b> <b>LOCAL</b>
       In  libguestfs  ≥ 1.18, it is possible to mount the libguestfs filesystem on a local directory and access
       it using ordinary POSIX calls and programs.

       Availability of this is subject to a  number  of  restrictions:  it  requires  FUSE  (the  Filesystem  in
       USErspace),  and  libfuse  must  also have been available when libguestfs was compiled.  FUSE may require
       that a kernel module is loaded, and it may be necessary to add the  current  user  to  a  special  "fuse"
       group.  See the documentation for your distribution and <a href="http://fuse.sf.net">http://fuse.sf.net</a> for further information.

       The call to mount the libguestfs filesystem on a local directory is "guestfs_mount_local" (q.v.) followed
       by  "guestfs_mount_local_run".   The latter does not return until you unmount the filesystem.  The reason
       is that the call enters the FUSE main loop and processes kernel requests, turning  them  into  libguestfs
       calls.   An  alternative  design would have been to create a background thread to do this, but libguestfs
       doesn't require pthreads.  This way is also more flexible: for example the user can create another thread
       for "guestfs_mount_local_run".

       "guestfs_mount_local" needs a certain amount of time to set up the mountpoint.   The  mountpoint  is  not
       ready to use until the call returns.  At this point, accesses to the filesystem will block until the main
       loop  is  entered (ie. "guestfs_mount_local_run").  So if you need to start another process to access the
       filesystem, put the fork between "guestfs_mount_local" and "guestfs_mount_local_run".

       <u>MOUNT</u> <u>LOCAL</u> <u>COMPATIBILITY</u>

       Since local mounting was only added in libguestfs 1.18, and may not be available even  in  these  builds,
       you  should  consider  writing code so that it doesn't depend on this feature, and can fall back to using
       libguestfs file system calls.

       If libguestfs was compiled without support for "guestfs_mount_local" then calling it will return an error
       with errno set to "ENOTSUP" (see "guestfs_last_errno").

       <u>MOUNT</u> <u>LOCAL</u> <u>PERFORMANCE</u>

       Libguestfs on top of FUSE performs quite poorly.  For best performance  do  not  use  it.   Use  ordinary
       libguestfs filesystem calls, upload, download etc. instead.

   <b>REMOTE</b> <b>STORAGE</b>
       <u>CEPH</u>

       Libguestfs can access Ceph (librbd/RBD) disks.

       To do this, set the optional "protocol" and "server" parameters of "guestfs_add_drive_opts" like this:

        char **servers = { "ceph1.example.org:3000", /* ... */, NULL };
        guestfs_add_drive_opts (g, "pool/image",
                                GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
                                GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "rbd",
                                GUESTFS_ADD_DRIVE_OPTS_SERVER, servers,
                                GUESTFS_ADD_DRIVE_OPTS_USERNAME, "rbduser",
                                GUESTFS_ADD_DRIVE_OPTS_SECRET, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                                -1);

       "servers"  (the  "server"  parameter)  is  a  list  of  one  or  more Ceph servers.  The server string is
       documented in "guestfs_add_drive_opts". The "username" and "secret" parameters are also optional, and  if
       not given, then no authentication will be used.

       An  encrypted  RBD disk -- <u>directly</u> opening which would require the "username" and "secret" parameters --
       cannot be accessed if the following conditions all hold:

       •   the backend is libvirt,

       •   the image specified by the "filename" parameter is different from the encrypted RBD disk,

       •   the image specified by the "filename" parameter has qcow2 format,

       •   the encrypted RBD disk is specified as a backing file at some level in the qcow2 backing chain.

       This limitation is due to libvirt's (justified) separate handling of disks vs.  secrets.   When  the  RBD
       username and secret are provided inside a qcow2 backing file specification, libvirt does not construct an
       ephemeral     secret     object     from     those,     for     Ceph     authentication.      Refer    to
       https://bugzilla.redhat.com/2033247.

       <u>FTP</u> <u>AND</u> <u>HTTP</u>

       Libguestfs can access remote disks over FTP, FTPS, HTTP or HTTPS protocols.

       To do this, set the optional "protocol" and "server" parameters of "guestfs_add_drive_opts" like this:

        char **servers = { "www.example.org", NULL };
        guestfs_add_drive_opts (g, "/disk.img",
                                GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
                                GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "http",
                                GUESTFS_ADD_DRIVE_OPTS_SERVER, servers,
                                -1);

       The "protocol" can be one of "ftp", "ftps", "http", or "https".

       "servers" (the "server" parameter) is a list which must have a single element.  The single element  is  a
       string   defining   the   web   or   FTP   server.    The   format   of  this  string  is  documented  in
       "guestfs_add_drive_opts".

       <u>GLUSTER</u>

       Glusterfs support was removed in libguestfs 1.54 (2024).

       <u>ISCSI</u>

       Libguestfs can access iSCSI disks remotely.

       To do this, set the optional "protocol" and "server" parameters like this:

        char **server = { "iscsi.example.org:3000", NULL };
        guestfs_add_drive_opts (g, "target-iqn-name/lun",
                                GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
                                GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "iscsi",
                                GUESTFS_ADD_DRIVE_OPTS_SERVER, server,
                                -1);

       The "server" parameter is a list which must have a single  element.   The  single  element  is  a  string
       defining the iSCSI server.  The format of this string is documented in "guestfs_add_drive_opts".

       <u>NETWORK</u> <u>BLOCK</u> <u>DEVICE</u>

       Libguestfs can access Network Block Device (NBD) disks remotely.

       To do this, set the optional "protocol" and "server" parameters of "guestfs_add_drive_opts" like this:

        char **server = { "nbd.example.org:3000", NULL };
        guestfs_add_drive_opts (g, "" /* export name - see below */,
                                GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
                                GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "nbd",
                                GUESTFS_ADD_DRIVE_OPTS_SERVER, server,
                                -1);

       Notes:

       •   "server"  is in fact a list of servers.  For NBD you must always supply a list with a single element.
           (Other remote protocols require zero or  more  than  one  server,  hence  the  requirement  for  this
           parameter to be a list).

       •   The  "server"  string  is  documented  in  "guestfs_add_drive_opts".   To connect to a local qemu-nbd
           instance over a Unix domain socket, use "unix:/path/to/socket".

       •   The "filename" parameter is the NBD export name.  Use an empty string to  mean  the  default  export.
           Many NBD servers, including qemu-nbd, do not support export names.

       •   If  using  qemu-nbd  as  your  server, you should always specify the "-t" option.  The reason is that
           libguestfs may open several connections to the server.

       •   The libvirt backend  requires  that  you  set  the  "format"  parameter  of  "guestfs_add_drive_opts"
           accurately when you use writable NBD disks.

       •   The   libvirt   backend   has  a  bug  that  stops  Unix  domain  socket  connections  from  working:
           https://bugzilla.redhat.com/show_bug.cgi?id=922888

       •   The  direct  backend  does  not  support  readonly  connections   because   of   a   bug   in   qemu:
           https://bugs.launchpad.net/qemu/+bug/1155677

       <u>SHEEPDOG</u>

       Sheepdog support was removed in libguestfs 1.54 (2024).

       <u>SSH</u>

       Libguestfs can access disks over a Secure Shell (SSH) connection.

       To   do   this,   set   the   "protocol"   and   "server"   and  (optionally)  "username"  parameters  of
       "guestfs_add_drive_opts" like this:

        char **server = { "remote.example.com", NULL };
        guestfs_add_drive_opts (g, "/path/to/disk.img",
                                GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
                                GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "ssh",
                                GUESTFS_ADD_DRIVE_OPTS_SERVER, server,
                                GUESTFS_ADD_DRIVE_OPTS_USERNAME, "remoteuser",
                                -1);

       The format of the server string is documented in "guestfs_add_drive_opts".

   <b>INSPECTION</b>
       Libguestfs has APIs for inspecting an unknown disk image to find out if it contains operating systems, an
       install CD or a live CD.

       Add all disks belonging to the unknown virtual machine and call "guestfs_launch" in the usual way.

       Then call "guestfs_inspect_os".  This function uses other libguestfs calls and  certain  heuristics,  and
       returns  a  list  of  operating  systems that were found.  An empty list means none were found.  A single
       element is the root filesystem of the operating system.  For dual- or multi-boot guests,  multiple  roots
       can be returned, each one corresponding to a separate operating system.  (Multi-boot virtual machines are
       extremely  rare  in  the  world  of  virtualization,  but  since  this scenario can happen, we have built
       libguestfs to deal with it.)

       For each root, you can then call various "guestfs_inspect_get_*"  functions  to  get  additional  details
       about that operating system.  For example, call "guestfs_inspect_get_type" to return the string "windows"
       or "linux" for Windows and Linux-based operating systems respectively.

       Un*x-like  and  Linux-based operating systems usually consist of several filesystems which are mounted at
       boot time (for example, a separate boot partition mounted on <u><a href="file:/boot">/boot</a></u>).  The inspection rules  are  able  to
       detect  how  filesystems  correspond to mount points.  Call "guestfs_inspect_get_mountpoints" to get this
       mapping.  It might return a hash table like this example:

        <a href="file:/boot">/boot</a> =&gt; /dev/sda1
        /     =&gt; /dev/vg_guest/lv_root
        <a href="file:/usr">/usr</a>  =&gt; /dev/vg_guest/lv_usr

       The caller can then make calls to "guestfs_mount" to mount the filesystems as suggested.

       Be careful to mount filesystems in the right order (eg. <u>/</u> before <u><a href="file:/usr">/usr</a></u>).  Sorting the keys of the hash  by
       length, shortest first, should work.

       Inspection  currently  only  works  for  some common operating systems.  Contributors are welcome to send
       patches for other operating systems that we currently cannot detect.

       Encrypted disks must be  opened  before  inspection.   See  "ENCRYPTED  DISKS"  for  more  details.   The
       "guestfs_inspect_os" function just ignores any encrypted devices.

       A note on the implementation: The call "guestfs_inspect_os" performs inspection and caches the results in
       the guest handle.  Subsequent calls to "guestfs_inspect_get_*" return this cached information, but <u>do</u> <u>not</u>
       re-read  the  disks.   If  you  change the content of the guest disks, you can redo inspection by calling
       "guestfs_inspect_os" again.  ("guestfs_inspect_list_applications2" works a little  differently  from  the
       other calls and does read the disks.  See documentation for that function for details).

       <u>INSPECTING</u> <u>INSTALL</u> <u>DISKS</u>

       Libguestfs (since 1.9.4) can detect some install disks, install CDs, live CDs and more.

       Further  information  is  available  about  the  operating system that can be installed using the regular
       inspection APIs like "guestfs_inspect_get_product_name", "guestfs_inspect_get_major_version" etc.

   <b>SPECIAL</b> <b>CONSIDERATIONS</b> <b>FOR</b> <b>WINDOWS</b> <b>GUESTS</b>
       Libguestfs can mount NTFS partitions.  It does this using the <a href="http://www.ntfs-3g.org/">http://www.ntfs-3g.org/</a> driver.

       <u>DRIVE</u> <u>LETTERS</u> <u>AND</u> <u>PATHS</u>

       DOS and Windows still use drive letters, and the filesystems are always treated as  case  insensitive  by
       Windows  itself,  and  therefore  you  might  find  a Windows configuration file referring to a path like
       "c:\windows\system32".  When the filesystem is mounted in libguestfs, that directory might be referred to
       as <u>/WINDOWS/System32</u>.

       Drive    letter    mappings    can    be    found    using    inspection    (see     "INSPECTION"     and
       "guestfs_inspect_get_drive_mappings")

       Dealing  with  separator  characters (backslash vs forward slash) is outside the scope of libguestfs, but
       usually a simple character replacement will work.

       To resolve the case insensitivity of paths, call "guestfs_case_sensitive_path".

       <u>LONG</u> <u>FILENAMES</u> <u>ON</u> <u>NTFS</u>

       NTFS supports filenames up to 255 characters long.  "Character" means a 2 byte UTF-16 codepoint which can
       encode the most common Unicode codepoints.

       Most Linux filesystems support filenames up to 255 <u>bytes</u>.  This means you may get an error:

        File name too long

       when you copy a file from NTFS to a Linux filesystem if the name, when reencoded as UTF-8,  would  exceed
       255 bytes in length.

       This  will  most often happen when using non-ASCII names that are longer than ~127 characters (eg. Greek,
       Cyrillic) or longer than ~85 characters (Asian languages).

       A workaround is not to try to store such long filenames on Linux native filesystems.   Since  the  <b><a href="../man1/tar.1.html">tar</a></b>(1)
       format can store unlimited length filenames, keep the files in a tarball.

       <u>ACCESSING</u> <u>THE</u> <u>WINDOWS</u> <u>REGISTRY</u>

       Libguestfs  also  provides  some  help  for  decoding Windows Registry "hive" files, through a separate C
       library called <b><a href="../man3/hivex.3.html">hivex</a></b>(3).

       Before libguestfs 1.19.35 you had to download the hive file, operate  on  it  locally  using  hivex,  and
       upload  it  again.   Since this version, we have included the major hivex APIs directly in the libguestfs
       API (see "guestfs_hivex_open").  This means that if you have opened a Windows guest,  you  can  read  and
       write the registry directly.

       See also <b><a href="../man1/virt-win-reg.1.html">virt-win-reg</a></b>(1).

       <u>SYMLINKS</u> <u>ON</u> <u>NTFS-3G</u> <u>FILESYSTEMS</u>

       Ntfs-3g  tries  to  rewrite  "Junction Points" and NTFS "symbolic links" to provide something which looks
       like a Linux symlink.  The way it tries to do the rewriting is described here:

       <a href="http://www.tuxera.com/community/ntfs-3g-advanced/junction-points-and-symbolic-links/">http://www.tuxera.com/community/ntfs-3g-advanced/junction-points-and-symbolic-links/</a>

       The essential problem is that ntfs-3g simply does not have enough information to do a correct job.   NTFS
       links  can  contain  drive  letters  and  references  to external device GUIDs that ntfs-3g has no way of
       resolving.  It is almost certainly the case that libguestfs callers should ignore what ntfs-3g does  (ie.
       don't use "guestfs_readlink" on NTFS volumes).

       Instead  if  you  encounter a symbolic link on an ntfs-3g filesystem, use "guestfs_lgetxattr" to read the
       "system.ntfs_reparse_data" extended attribute, and read the raw reparse data from that (you can find  the
       format documented in various places around the web).

       <u>EXTENDED</u> <u>ATTRIBUTES</u> <u>ON</u> <u>NTFS-3G</u> <u>FILESYSTEMS</u>

       There   are  other  useful  extended  attributes  that  can  be  read  from  ntfs-3g  filesystems  (using
       "guestfs_getxattr").  See:

       <a href="http://www.tuxera.com/community/ntfs-3g-advanced/extended-attributes/">http://www.tuxera.com/community/ntfs-3g-advanced/extended-attributes/</a>

       <u>WINDOWS</u> <u>HIBERNATION</u> <u>AND</u> <u>WINDOWS</u> <u>8</u> <u>FAST</u> <u>STARTUP</u>

       Windows guests which have been hibernated (instead of fully shut down) cannot  be  mounted.   This  is  a
       limitation of ntfs-3g.  You will see an error like this:

        The disk contains an unclean file system (0, 0).
        Metadata kept in Windows cache, refused to mount.
        Failed to mount '/dev/sda2': Operation not permitted
        The NTFS partition is in an unsafe state. Please resume
        and shutdown Windows fully (no hibernation or fast
        restarting), or mount the volume read-only with the
        'ro' mount option.

       In Windows 8, the shutdown button does not shut down the guest at all.  Instead it usually hibernates the
       guest.  This is known as "fast startup".

       Some suggested workarounds are:

       •   Mount read-only (eg. "guestfs_mount_ro").

       •   On  Windows  8,  turn off fast startup.  It is in the Control Panel → Power Options → Choose what the
           power buttons do → Change settings that are currently unavailable → Turn on fast startup.

       •   On Windows 7 and earlier, shut the guest off properly instead of hibernating it.

   <b>RESIZE2FS</b> <b>ERRORS</b>
       The "guestfs_resize2fs", "guestfs_resize2fs_size" and "guestfs_resize2fs_M"  calls  are  used  to  resize
       ext2/3/4 filesystems.

       The  underlying  program  (<b><a href="../man8/resize2fs.8.html">resize2fs</a></b>(8)) requires that the filesystem is clean and recently fsck'd before
       you can resize it.  Also, if the resize operation fails for some reason, then you had to  call  fsck  the
       filesystem again to fix it.

       In  libguestfs  "lt"  1.17.14, you usually had to call "guestfs_e2fsck_f" before the resize.  However, in
       "ge" 1.17.14, <b><a href="../man8/e2fsck.8.html">e2fsck</a></b>(8) is called automatically before the resize, so you no longer need to do this.

       The <b><a href="../man8/resize2fs.8.html">resize2fs</a></b>(8) program can still fail, in which case it prints an error message similar to:

        Please run 'e2fsck -fy &lt;device&gt;' to fix the filesystem
        after the aborted resize operation.

       You can do this by calling "guestfs_e2fsck" with the "forceall" option.  However in the context  of  disk
       images,  it  is usually better to avoid this situation, eg. by rolling back to an earlier snapshot, or by
       copying and resizing and on failure going back to the original.

   <b>USING</b> <b>LIBGUESTFS</b> <b>WITH</b> <b>OTHER</b> <b>PROGRAMMING</b> <b>LANGUAGES</b>
       Although we don’t want to discourage you from using the C API, we will mention here that the same API  is
       also available in other languages.

       The   API   is   broadly   identical   in   all   supported  languages.   This  means  that  the  C  call
       "guestfs_add_drive_ro(g,file)" is "$g-&gt;add_drive_ro($file)" in Perl,  "g.add_drive_ro(file)"  in  Python,
       and  "g#add_drive_ro  file" in OCaml.  In other words, a straightforward, predictable isomorphism between
       each language.

       Error messages are automatically transformed into exceptions if the language supports it.

       We don’t try to "object orientify" parts of the API in OO languages, although contributors are welcome to
       write higher level APIs above what we provide in their favourite languages if they wish.

       <b>C++</b> You can use the <u>guestfs.h</u> header file from C++ programs.  The C++ API is identical to the C API.  C++
           classes and exceptions are not used.

       <b>C#</b>  The  C#  bindings  are  highly  experimental.    Please   read   the   warnings   at   the   top   of
           <u>csharp/Libguestfs.cs</u>.

       <b>Erlang</b>
           See <b><a href="../man3/guestfs-erlang.3.html">guestfs-erlang</a></b>(3).

       <b>GObject</b>
           Experimental GObject bindings (with GObject Introspection support) are available.

           See <b><a href="../man3/guestfs-gobject.3.html">guestfs-gobject</a></b>(3).

       <b>Go</b>  See <b><a href="../man3/guestfs-golang.3.html">guestfs-golang</a></b>(3).

       <b>Haskell</b>
           This language binding is working but incomplete:

           •   Functions  with  optional  arguments  are  not bound.  Implementing optional arguments in Haskell
               seems to be very complex.

           •   Events are not bound.

           •   Functions with the following return types are not bound:

               •   Any function returning a struct.

               •   Any function returning a list of structs.

               •   A few functions that return fixed length buffers (specifically ones declared "RBufferOut"  in
                   the generator).

               •   A  tiny  number of obscure functions that return constant strings (specifically ones declared
                   "RConstOptString" in the generator).

       <b>Java</b>
           Full documentation is contained in the Javadoc which is distributed with libguestfs.   For  examples,
           see <b><a href="../man3/guestfs-java.3.html">guestfs-java</a></b>(3).

       <b>Lua</b> See <b><a href="../man3/guestfs-lua.3.html">guestfs-lua</a></b>(3).

       <b>OCaml</b>
           See <b><a href="../man3/guestfs-ocaml.3.html">guestfs-ocaml</a></b>(3).

       <b>Perl</b>
           See <b><a href="../man3/guestfs-perl.3.html">guestfs-perl</a></b>(3) and <b>Sys::<a href="../man3/Guestfs.3.html">Guestfs</a></b>(3).

       <b>PHP</b> For  documentation see "README-PHP" supplied with libguestfs sources or in the php-libguestfs package
           for your distribution.

           The PHP binding only works correctly on 64 bit machines.

       <b>Python</b>
           See <b><a href="../man3/guestfs-python.3.html">guestfs-python</a></b>(3).

       <b>Ruby</b>
           See <b><a href="../man3/guestfs-ruby.3.html">guestfs-ruby</a></b>(3).

           For JRuby, use the Java bindings.

       <b>shell</b> <b>scripts</b>
           See <b><a href="../man1/guestfish.1.html">guestfish</a></b>(1).

   <b>LIBGUESTFS</b> <b>GOTCHAS</b>
       <a href="http://en.wikipedia.org/wiki/Gotcha_">http://en.wikipedia.org/wiki/Gotcha_</a>(programming): "A feature of a system [...] that works in the way  it
       is documented but is counterintuitive and almost invites mistakes."

       Since  we  developed libguestfs and the associated tools, there are several things we would have designed
       differently, but are now stuck with for backwards compatibility or other reasons.  If  there  is  ever  a
       libguestfs 2.0 release, you can expect these to change.  Beware of them.

       Read-only should be the default.
           In  <b><a href="../man3/guestfish.3.html">guestfish</a></b>(3), <u>--ro</u> should be the default, and you should have to specify <u>--rw</u> if you want to make
           changes to the image.

           This would reduce the potential to corrupt live VM images.

           Note that many filesystems change the disk when you just  mount  and  unmount,  even  if  you  didn't
           perform  any  writes.   You  need  to  use  "guestfs_add_drive_ro"  to guarantee that the disk is not
           changed.

       guestfish command line is hard to use.
           <u>guestfish</u> <u>disk.img</u> doesn't do what people expect (open <u>disk.img</u> for examination).  It tries to run  a
           guestfish  command  <u>disk.img</u>  which doesn't exist, so it fails.  In earlier versions of guestfish the
           error message was also unintuitive, but we have corrected this since.   Like  the  Bourne  shell,  we
           should have used "guestfish -c command" to run commands.

       guestfish megabyte modifiers don’t work right on all commands
           In  recent  guestfish  you can use "1M" to mean 1 megabyte (and similarly for other modifiers).  What
           guestfish actually does is to multiply the number part by the modifier part and pass  the  result  to
           the  C  API.   However this doesn't work for a few APIs which aren't expecting bytes, but are already
           expecting some other unit (eg. megabytes).

           The most common is "guestfs_lvcreate".  The guestfish command:

            lvcreate LV VG 100M

           does not do  what  you  might  expect.   Instead  because  "guestfs_lvcreate"  is  already  expecting
           megabytes, this tries to create a 100 <u>terabyte</u> (100 megabytes * megabytes) logical volume.  The error
           message you get from this is also a little obscure.

           This  could  be  fixed  in the generator by specially marking parameters and return values which take
           bytes or other units.

       Ambiguity between devices and paths
           There is a subtle ambiguity in the API between a device name (eg. <u>/dev/sdb2</u>) and a similar  pathname.
           A file might just happen to be called "sdb2" in the directory <u><a href="file:/dev">/dev</a></u> (consider some non-Unix VM image).

           In  the  current  API  we  usually  resolve  this ambiguity by having two separate calls, for example
           "guestfs_checksum" and "guestfs_checksum_device".  Some API calls  are  ambiguous  and  (incorrectly)
           resolve the problem by detecting if the path supplied begins with <u><a href="file:/dev/">/dev/</a></u>.

           To  avoid  both  the ambiguity and the need to duplicate some calls, we could make paths/devices into
           structured names.  One way to do this would be to use a  notation  like  grub  ("hd(0,0)"),  although
           nobody  really  likes this aspect of grub.  Another way would be to use a structured type, equivalent
           to this OCaml type:

            type path = Path of string | Device of int | Partition of int * int

           which would allow you to pass arguments like:

            Path "/foo/bar"
            Device 1            (* /dev/sdb, or perhaps /dev/sda *)
            Partition (1, 2)    (* /dev/sdb2 (or is it /dev/sda2 or /dev/sdb3?) *)
            Path "/dev/sdb2"    (* not a device *)

           As you can see there are still problems to resolve even with this representation.  Also consider  how
           it might work in guestfish.

   <b>KEYS</b> <b>AND</b> <b>PASSPHRASES</b>
       Certain libguestfs calls take a parameter that contains sensitive key material, passed in as a C string.

       In  the  future  we  would hope to change the libguestfs implementation so that keys are <b><a href="../man2/mlock.2.html">mlock</a></b>(2)-ed into
       physical RAM, and thus can never end up in swap.  However this is <u>not</u> done at the moment, because of  the
       complexity of such an implementation.

       Therefore  you  should  be aware that any key parameter you pass to libguestfs might end up being written
       out to the swap partition.  If this is a concern, scrub the swap partition or  don't  use  libguestfs  on
       encrypted devices.

   <b>MULTIPLE</b> <b>HANDLES</b> <b>AND</b> <b>MULTIPLE</b> <b>THREADS</b>
       All high-level libguestfs actions are synchronous.  If you want to use libguestfs asynchronously then you
       must create a thread.

       <u>Threads</u> <u>in</u> <u>libguestfs</u> <u>≥</u> <u>1.38</u>

       In  libguestfs ≥ 1.38, each handle ("guestfs_h") contains a lock which is acquired automatically when you
       call a libguestfs function.  The practical effect of this is you can call libguestfs functions  with  the
       same handle from multiple threads without needing to do any locking.

       Also  in  libguestfs ≥ 1.38, the last error on the handle ("guestfs_last_error", "guestfs_last_errno") is
       stored in thread-local storage, so it is safe to write code like:

        if (guestfs_add_drive_ro (g, drive) == -1)
          fprintf (stderr, "error was: %s\n", guestfs_last_error (g));

       even when other threads may be concurrently using the same handle "g".

       <u>Threads</u> <u>in</u> <u>libguestfs</u> <u>&lt;</u> <u>1.38</u>

       In libguestfs &lt; 1.38, you must use the  handle  only  from  a  single  thread.   Either  use  the  handle
       exclusively from one thread, or provide your own mutex so that two threads cannot issue calls on the same
       handle  at the same time.  Even apparently innocent functions like "guestfs_get_trace" are <u>not</u> safe to be
       called from multiple threads without a mutex in libguestfs &lt; 1.38.

       Use "guestfs_set_identifier" to make it simpler to identify threads in trace output.

   <b>PATH</b>
       Libguestfs needs a supermin appliance, which it finds by looking along an internal path.

       By default it  looks  for  these  in  the  directory  "$libdir/guestfs"  (eg.  <u>/usr/local/lib/guestfs</u>  or
       <u>/usr/lib64/guestfs</u>).

       Use  "guestfs_set_path"  or set the environment variable "LIBGUESTFS_PATH" to change the directories that
       libguestfs will search in.  The value is a colon-separated list of paths.  The current directory  is  <u>not</u>
       searched     unless    the    path    contains    an    empty    element    or    ".".     For    example
       "LIBGUESTFS_PATH=:/usr/lib/guestfs" would search the current directory and then <u>/usr/lib/guestfs</u>.

   <b>QEMU</b> <b>WRAPPERS</b>
       If you want to compile your own qemu, run qemu from a non-standard location, or pass extra  arguments  to
       qemu, then you can write a shell-script wrapper around qemu.

       There is one important rule to remember: you <u>must</u> <u>"exec</u> <u>qemu"</u> as the last command in the shell script (so
       that qemu replaces the shell and becomes the direct child of the libguestfs-using program).  If you don't
       do this, then the qemu process won't be cleaned up correctly.

       Here is an example of a wrapper, where I have built my own copy of qemu from source:

        #!<a href="file:/bin/sh">/bin/sh</a> -
        qemudir=/home/rjones/d/qemu
        exec $qemudir/x86_64-softmmu/qemu-system-x86_64 -L $qemudir/pc-bios "$@"

       Save  this  script  as  <u>/tmp/qemu.wrapper</u>  (or  wherever),  "chmod  +x",  and  then use it by setting the
       LIBGUESTFS_HV environment variable.  For example:

        LIBGUESTFS_HV=/tmp/qemu.wrapper guestfish

       Note that libguestfs also calls qemu with the -help and -version options in order to determine features.

       Wrappers can also be used to edit the options passed to qemu.  In the following  example,  the  "-machine
       ..."  option  ("-machine" and the following argument) are removed from the command line and replaced with
       "-machine pc,accel=tcg".  The while loop iterates over the options  until  it  finds  the  right  one  to
       remove, putting the remaining options into the "args" array.

        #!<a href="file:/bin/bash">/bin/bash</a> -

        i=0
        while [ $# -gt 0 ]; do
            case "$1" in
            -machine)
                shift 2;;
            *)
                args[i]="$1"
                (( i++ ))
                shift ;;
            esac
        done

        exec qemu-kvm -machine pc,accel=tcg "${args[@]}"

   <b>BACKEND</b>
       The  backend (previously known as the "attach method") controls how libguestfs creates and/or connects to
       the backend daemon, eg. by starting qemu directly, or using libvirt to manage an appliance, running User-
       Mode Linux, or connecting to an already running daemon.

       You can set the backend  by  calling  "guestfs_set_backend",  or  by  setting  the  environment  variable
       "LIBGUESTFS_BACKEND".

       Possible backends are described below:

       "direct"
       "appliance"
           Run qemu directly to launch an appliance.

           "direct" and "appliance" are synonyms.

           This is the ordinary method and normally the default, but see the note below.

       "libvirt"
       "libvirt:null"
       "libvirt:<u>URI</u>"
           Use libvirt to launch and manage the appliance.

           "libvirt"  causes  libguestfs  to  choose  a  suitable URI for creating session guests.  If using the
           libvirt backend, you almost always should use this.

           "libvirt:null" causes libguestfs to use the "NULL" connection URI, which causes  libvirt  to  try  to
           guess what the user meant.  You probably don't want to use this.

           "libvirt:<u>URI</u>"  uses <u>URI</u> as the libvirt connection URI (see <a href="http://libvirt.org/uri.html">http://libvirt.org/uri.html</a>).  The typical
           libvirt backend with a URI would be "libvirt:qemu:///session"

           The libvirt backend supports more features, including sVirt.

       "direct" is usually the default backend.  However since libguestfs ≥ 1.19.24,  libguestfs  can  be  built
       with a different default by doing:

        ./configure --with-default-backend=...

       To find out if libguestfs was compiled with a different default backend, do:

        unset LIBGUESTFS_BACKEND
        guestfish get-backend

   <b>BACKEND</b> <b>SETTINGS</b>
       Each   backend   can   be   configured   by   passing   a   list   of   strings.   You  can  either  call
       "guestfs_set_backend_settings"  with  a  list  of  strings,  or  set  the   "LIBGUESTFS_BACKEND_SETTINGS"
       environment variable to a colon-separated list of strings (before creating the handle).

       <u>force_tcg</u>

       Using:

        export LIBGUESTFS_BACKEND_SETTINGS=force_tcg

       will  force  the  direct  and  libvirt  backends to use TCG (software emulation) instead of KVM (hardware
       accelerated virtualization).

       <u>force_kvm</u>

       Using:

        export LIBGUESTFS_BACKEND_SETTINGS=force_kvm

       will force the direct and libvirt backends to use KVM (hardware accelerated  virtualization)  instead  of
       TCG (software emulation).

       <u>gdb</u>

       The direct backend supports:

        export LIBGUESTFS_BACKEND_SETTINGS=gdb

       When this is set, qemu will not start running the appliance immediately.  It will wait for you to connect
       to it using gdb:

        $ gdb
        (gdb) symbol-file /path/to/vmlinux
        (gdb) target remote tcp::1234
        (gdb) cont

       You  can  then  debug the appliance kernel, which is useful to debug boot failures (especially ones where
       there are no debug messages printed - tip: look in the kernel "log_buf").

       On Fedora, install "kernel-debuginfo" for the "vmlinux" file (containing symbols).  Make sure the symbols
       precisely match the kernel being used.

   <b>ABI</b> <b>GUARANTEE</b>
       We guarantee the libguestfs ABI (binary interface), for public, high-level actions as  outlined  in  this
       section.   Although  we  will deprecate some actions, for example if they get replaced by newer calls, we
       will keep the old actions forever.  This allows you the developer to program in  confidence  against  the
       libguestfs API.

   <b>BLOCK</b> <b>DEVICE</b> <b>NAMING</b>
       Libguestfs  defines  <u>/dev/sd*</u> as the <u>standard</u> <u>naming</u> <u>scheme</u> for devices passed to API calls.  So <u>/dev/sda</u>
       means "the first device added by "guestfs_add_drive_opts"", and <u>/dev/sdb3</u> means "the third  partition  on
       the second device".

       Internally device names are sometimes translated, but this should not be visible at the API level.

       <u>DISK</u> <u>LABELS</u>

       In  libguestfs  ≥  1.20,  you  can  give  a  label  to a disk when you add it, using the optional "label"
       parameter to "guestfs_add_drive_opts".  (Note that disk labels are different  from  and  not  related  to
       filesystem labels).

       Not  all  versions of libguestfs support setting a disk label, and when it is supported, it is limited to
       20 ASCII characters "[a-zA-Z]".

       When  you  add  a  disk  with  a  label,  it  can  either  be  addressed   using   <u>/dev/sd*</u>,   or   using
       <u>/dev/disk/guestfs/label</u>.  Partitions on the disk can be addressed using <u>/dev/disk/guestfs/labelpartnum</u>.

       Listing  devices  ("guestfs_list_devices")  and  partitions ("guestfs_list_partitions") returns the block
       device names.  However you can use "guestfs_list_disk_labels" to map disk  labels  to  block  device  and
       partition names.

   <b>NULL</b> <b>DISKS</b>
       When adding a disk using, eg., "guestfs_add_drive", you can set the filename to "/dev/null".  This string
       is treated specially by libguestfs, causing it to add a "null disk".

       A null disk has the following properties:

       •   A null disk will appear as a normal device, eg. in calls to "guestfs_list_devices".

       •   You may add "/dev/null" multiple times.

       •   You  should  not  try to access a null disk in any way.  For example, you shouldn't try to read it or
           mount it.

       Null disks are used for three main purposes:

       1.  Performance testing of libguestfs (see <b><a href="../man1/guestfs-performance.1.html">guestfs-performance</a></b>(1)).

       2.  The internal test suite.

       3.  If you want to use libguestfs APIs that don’t refer to disks, since libguestfs requires that at least
           one disk is added, you should add a null disk.

           For example, to test if a feature is available, use code like this:

            guestfs_h *g;
            char **groups = [ "btrfs", NULL ];

            g = guestfs_create ();
            guestfs_add_drive (g, "/dev/null");
            guestfs_launch (g);
            if (guestfs_available (g, groups) == 0) {
              // group(s) are available
            } else {
              // group(s) are not available
            }
            guestfs_close (g);

   <b>DISK</b> <b>IMAGE</b> <b>FORMATS</b>
       Virtual disks come in a variety of formats.  Some common formats are listed below.

       Note that libguestfs itself is not responsible for handling the disk format: this is done using  <b><a href="../man1/qemu.1.html">qemu</a></b>(1).
       If support for a particular format is missing or broken, this has to be fixed in qemu.

       <u>COMMON</u> <u>VIRTUAL</u> <u>DISK</u> <u>IMAGE</u> <u>FORMATS</u>

       <u>raw</u> Raw  format  is  simply a dump of the sequential bytes of the virtual hard disk.  There is no header,
           container, compression or processing of any sort.

           Since raw format requires no translation to read or write, it is both fast and very well supported by
           qemu and all other hypervisors.  You can consider it to be a universal format that any hypervisor can
           access.

           Raw format files are not compressed and so take up the full space of the  original  disk  image  even
           when  they  are empty.  A variation (on Linux/Unix at least) is to not store ranges of all-zero bytes
           by storing the file as a sparse file.  This "variant format" is sometimes called  <u>raw</u>  <u>sparse</u>.   Many
           utilities, including <b><a href="../man1/virt-sparsify.1.html">virt-sparsify</a></b>(1), can make raw disk images sparse.

       <u>qcow2</u>
           Qcow2  is  the  native  disk  image  format  used  by qemu.  Internally it uses a two-level directory
           structure so that only blocks containing data are stored  in  the  file.   It  also  has  many  other
           features such as compression, snapshots and backing files.

           There are at least two distinct variants of this format, although qemu (and hence libguestfs) handles
           both transparently to the user.

       <u>vmdk</u>
           VMDK  is  VMware’s  native  disk  image  format.   There  are  many  variations.   Modern qemu (hence
           libguestfs) supports most variations, but you should be aware that older versions of  qemu  had  some
           very bad data-corrupting bugs in this area.

           Note  that VMware ESX exposes files with the name <u>guest-flat.vmdk</u>.  These are not VMDK.  They are raw
           format files which happen to have a ".vmdk" extension.

       <u>vdi</u> VDI is VirtualBox’s native disk image format.  Qemu (hence libguestfs) has generally good support for
           this.

       <u>vpc</u>
       <u>vhd</u> VPC (old) and VHD (modern) are the native disk image format of Microsoft (and previously,  Connectix)
           Virtual PC and Hyper-V.

       Obsolete formats
           The following formats are obsolete and should not be used: <u>qcow</u> (aka <u>qcow1</u>), <u>cow</u>, <u>bochs</u>.

       <u>DETECTING</u> <u>THE</u> <u>FORMAT</u> <u>OF</u> <u>A</u> <u>DISK</u> <u>IMAGE</u>

       Firstly note there is a security issue with auto-detecting the format of a disk image.  It may or may not
       apply in your use case.  Read "CVE-2010-3851" below.

       Libguestfs  offers  an API to get the format of a disk image ("guestfs_disk_format"), and it is safest to
       use this.

       <u>Don’t</u> be tempted to try parsing the text / human-readable output of "qemu-img" since it cannot be  parsed
       reliably and securely.  Also do not use the "file" command since the output of that changes over time.

</pre><h4><b>CONNECTION</b> <b>MANAGEMENT</b></h4><pre>
   <b>guestfs_h</b> <b>*</b>
       "guestfs_h"  is  the  opaque  type  representing  a  connection  handle.   Create  a  handle  by  calling
       "guestfs_create" or "guestfs_create_flags".  Call "guestfs_close" to free  the  handle  and  release  all
       resources used.

       For  information  on  using  multiple handles and threads, see the section "MULTIPLE HANDLES AND MULTIPLE
       THREADS" above.

   <b>guestfs_create</b>
        guestfs_h *guestfs_create (void);

       Create a connection handle.

       On success this returns a non-NULL pointer to a handle.  On error it returns NULL.

       You have to "configure" the handle after creating it.  This includes calling "guestfs_add_drive_opts" (or
       one of the equivalent calls) on the handle at least once.

       After configuring the handle, you have to call "guestfs_launch".

       You may also want to configure error handling for the handle.  See the "ERROR HANDLING" section below.

   <b>guestfs_create_flags</b>
        guestfs_h *guestfs_create_flags (unsigned flags [, ...]);

       Create a connection handle, supplying extra flags and extra  arguments  to  control  how  the  handle  is
       created.

       On success this returns a non-NULL pointer to a handle.  On error it returns NULL.

       "guestfs_create" is equivalent to calling <a href="../man0/guestfs_create_flags.0.html">guestfs_create_flags</a>(0).

       The following flags may be logically ORed together.  (Currently no extra arguments are used).

       "GUESTFS_CREATE_NO_ENVIRONMENT"
           Don’t parse any environment variables (such as "LIBGUESTFS_DEBUG" etc).

           You  can  call  "guestfs_parse_environment"  or  "guestfs_parse_environment_list" afterwards to parse
           environment variables.  Alternately, <u>don't</u> call  these  functions  if  you  want  the  handle  to  be
           unaffected by environment variables.  See the example below.

           The default (if this flag is not given) is to implicitly call "guestfs_parse_environment".

       "GUESTFS_CREATE_NO_CLOSE_ON_EXIT"
           Don’t try to close the handle in an <b><a href="../man3/atexit.3.html">atexit</a></b>(3) handler if the program exits without explicitly closing
           the handle.

           The default (if this flag is not given) is to install such an atexit handler.

       <u>USING</u> <u>"GUESTFS_CREATE_NO_ENVIRONMENT"</u>

       You  might  use  "GUESTFS_CREATE_NO_ENVIRONMENT" and an explicit call to "guestfs_parse_environment" like
       this:

        guestfs_h *g;
        int r;

        g = guestfs_create_flags (GUESTFS_CREATE_NO_ENVIRONMENT);
        if (!g) {
          perror ("guestfs_create_flags");
          exit (EXIT_FAILURE);
        }
        r = guestfs_parse_environment (g);
        if (r == -1)
          exit (EXIT_FAILURE);

       Or  to  create  a  handle  which  is  unaffected   by   environment   variables,   omit   the   call   to
       "guestfs_parse_environment" from the above code.

       The  above  code  has  another advantage which is that any errors from parsing the environment are passed
       through the error handler, whereas "guestfs_create" prints errors on stderr and ignores them.

   <b>guestfs_close</b>
        void guestfs_close (guestfs_h *g);

       This closes the connection handle and frees up all resources used.  If a close callback was  set  on  the
       handle, then it is called.

       The correct way to close the handle is:

        if (guestfs_shutdown (g) == -1) {
          /* handle write errors here */
        }
        guestfs_close (g);

       "guestfs_shutdown" is only needed if <b>all</b> of the following are true:

       1.  one or more disks were added in read-write mode, <u>and</u>

       2.  guestfs_launch was called, <u>and</u>

       3.  you made some changes, <u>and</u>

       4.  you  have  a  way to handle write errors (eg. by exiting with an error code or reporting something to
           the user).

</pre><h4><b>ERROR</b> <b>HANDLING</b></h4><pre>
       API functions can return errors.  For example, almost all functions that return "int" will return  -1  to
       indicate an error.

       Additional  information  is  available for errors: an error message string and optionally an error number
       (errno) if the thing that failed was a system call.

       You  can  get  at  the  additional  information  about  the  last  error  on  the   handle   by   calling
       "guestfs_last_error",    "guestfs_last_errno",   and/or   by   setting   up   an   error   handler   with
       "guestfs_set_error_handler".

       When the handle is created, a default error handler is installed which prints the error message string to
       "stderr".  For small short-running command line programs it is sufficient to do:

        if (guestfs_launch (g) == -1)
          exit (EXIT_FAILURE);

       since the default error handler will ensure that an error message has been printed to "stderr" before the
       program exits.

       For other programs the caller will almost certainly want to install an  alternate  error  handler  or  do
       error  handling  in-line  as  in  the  example below.  The non-C language bindings all install NULL error
       handlers and turn errors into exceptions using code similar to this:

        const char *msg;
        int errnum;

        /* This disables the default behaviour of printing errors
           on stderr. */
        guestfs_set_error_handler (g, NULL, NULL);

        if (guestfs_launch (g) == -1) {
          /* Examine the error message and print it, throw it,
             etc. */
          msg = guestfs_last_error (g);
          errnum = guestfs_last_errno (g);

          fprintf (stderr, "%s", msg);
          if (errnum != 0)
            fprintf (stderr, ": %s", strerror (errnum));
          fprintf (stderr, "\n");

          /* ... */
        }

       "guestfs_create" returns "NULL" if the handle cannot be created, and because there is no handle  if  this
       happens  there  is  no  way  to  get  additional error information.  Since libguestfs ≥ 1.20, you can use
       "guestfs_create_flags" to properly deal with errors during handle creation, although the vast majority of
       programs can continue to use "guestfs_create" and not worry about this situation.

       Out of memory errors are handled differently.  The default action  is  to  call  <b><a href="../man3/abort.3.html">abort</a></b>(3).   If  this  is
       undesirable, then you can set a handler using "guestfs_set_out_of_memory_handler".

   <b>guestfs_last_error</b>
        const char *guestfs_last_error (guestfs_h *g);

       This  returns  the  last  error  message  that happened on "g".  If there has not been an error since the
       handle was created, then this returns "NULL".

       Note the returned string does <u>not</u> have a newline character at the end.  Most error  messages  are  single
       lines.   Some  are split over multiple lines and contain "\n" characters within the string but not at the
       end.

       The lifetime of the returned string is until the next error occurs on the same handle, or "guestfs_close"
       is called.  If you need to keep it longer, copy it.

   <b>guestfs_last_errno</b>
        int guestfs_last_errno (guestfs_h *g);

       This returns the last error number (errno) that happened on "g".

       If successful, an errno integer not equal to zero is returned.

       In many cases the special errno "ENOTSUP" is returned if you tried to call a function or  use  a  feature
       which is not supported.

       If no error number is available, this returns 0.  This call can return 0 in three situations:

       1.  There has not been any error on the handle.

       2.  There  has been an error but the errno was meaningless.  This corresponds to the case where the error
           did not come from a failed system call, but for some other reason.

       3.  There was an error from a failed system call, but for some reason the  errno  was  not  captured  and
           returned.  This usually indicates a bug in libguestfs.

       Libguestfs tries to convert the errno from inside the appliance into a corresponding errno for the caller
       (not  entirely  trivial:  the appliance might be running a completely different operating system from the
       library and error numbers are not standardized across Un*xen).  If this could not be done, then the error
       is translated to "EINVAL".  In practice this should only happen in very rare circumstances.

   <b>guestfs_set_error_handler</b>
        typedef void (*guestfs_error_handler_cb) (guestfs_h *g,
                                                  void *opaque,
                                                  const char *msg);
        void guestfs_set_error_handler (guestfs_h *g,
                                        guestfs_error_handler_cb cb,
                                        void *opaque);

       The callback "cb" will be called if there is an error.  The parameters passed  to  the  callback  are  an
       opaque data pointer and the error message string.

       "errno" is not passed to the callback.  To get that the callback must call "guestfs_last_errno".

       Note  that  the message string "msg" is freed as soon as the callback function returns, so if you want to
       stash it somewhere you must make your own copy.

       The default handler prints messages on "stderr".

       If you set "cb" to "NULL" then <u>no</u> handler is called.

   <b>guestfs_get_error_handler</b>
        guestfs_error_handler_cb guestfs_get_error_handler (guestfs_h *g,
                                                            void **opaque_rtn);

       Returns the current error handler callback.

   <b>guestfs_push_error_handler</b>
        void guestfs_push_error_handler (guestfs_h *g,
                                         guestfs_error_handler_cb cb,
                                         void *opaque);

       This is the same as "guestfs_set_error_handler", except that the old error handler is stashed away  in  a
       stack    inside    the   handle.    You   can   restore   the   previous   error   handler   by   calling
       "guestfs_pop_error_handler".

       Use the following code to temporarily disable errors around a function:

        guestfs_push_error_handler (g, NULL, NULL);
        guestfs_mkdir (g, "/foo"); /* We don't care if this fails. */
        guestfs_pop_error_handler (g);

   <b>guestfs_pop_error_handler</b>
        void guestfs_pop_error_handler (guestfs_h *g);

       Restore the previous error handler (see "guestfs_push_error_handler").

       If you pop the stack too many times, then the default error handler is restored.

   <b>guestfs_set_out_of_memory_handler</b>
        typedef void (*guestfs_abort_cb) (void);
        void guestfs_set_out_of_memory_handler (guestfs_h *g,
                                                guestfs_abort_cb);

       The callback "cb" will be called if there is an out of memory situation.  <u>Note</u>  <u>this</u>  <u>callback</u>  <u>must</u>  <u>not</u>
       <u>return</u>.

       The default is to call <b><a href="../man3/abort.3.html">abort</a></b>(3).

       You cannot set "cb" to "NULL".  You can’t ignore out of memory situations.

   <b>guestfs_get_out_of_memory_handler</b>
        guestfs_abort_fn guestfs_get_out_of_memory_handler (guestfs_h *g);

       This returns the current out of memory handler.

</pre><h4><b>API</b> <b>CALLS</b></h4><pre>
   <b>guestfs_acl_delete_def_file</b>
        int
        guestfs_acl_delete_def_file (guestfs_h *g,
                                     const char *dir);

       This function deletes the default POSIX Access Control List (ACL) attached to directory "dir".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "acl".  See also "guestfs_feature_available".

       (Added in 1.19.63)

   <b>guestfs_acl_get_file</b>
        char *
        guestfs_acl_get_file (guestfs_h *g,
                              const char *path,
                              const char *acltype);

       This  function  returns  the  POSIX Access Control List (ACL) attached to "path".  The ACL is returned in
       "long text form" (see <b><a href="../man5/acl.5.html">acl</a></b>(5)).

       The "acltype" parameter may be:

       "access"
           Return the ordinary (access) ACL for any file, directory or other filesystem object.

       "default"
           Return the default ACL.  Normally this only makes sense if "path" is a directory.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       This function depends on the feature "acl".  See also "guestfs_feature_available".

       (Added in 1.19.63)

   <b>guestfs_acl_set_file</b>
        int
        guestfs_acl_set_file (guestfs_h *g,
                              const char *path,
                              const char *acltype,
                              const char *acl);

       This function sets the POSIX Access Control List (ACL) attached to "path".

       The "acltype" parameter may be:

       "access"
           Set the ordinary (access) ACL for any file, directory or other filesystem object.

       "default"
           Set the default ACL.  Normally this only makes sense if "path" is a directory.

       The "acl" parameter is the new ACL in either "long text form" or "short text form" (see <b><a href="../man5/acl.5.html">acl</a></b>(5)).  The new
       ACL completely replaces any previous ACL on the file.  The ACL must contain  the  full  Unix  permissions
       (eg. "u::rwx,g::rx,o::rx").

       If  you  are  specifying individual users or groups, then the mask field is also required (eg. "m::rwx"),
       followed by the "u:<u>ID</u>:..." and/or "g:<u>ID</u>:..." field(s).  A full ACL string might therefore look like this:

        u::rwx,g::rwx,o::rwx,m::rwx,u:500:rwx,g:500:rwx
        \ Unix permissions / \mask/ \      ACL        /

       You should use numeric UIDs and GIDs.  To map usernames and groupnames to the correct numeric ID  in  the
       context of the guest, use the Augeas functions (see "guestfs_aug_init").

       This function returns 0 on success or -1 on error.

       This function depends on the feature "acl".  See also "guestfs_feature_available".

       (Added in 1.19.63)

   <b>guestfs_add_cdrom</b>
        int
        guestfs_add_cdrom (guestfs_h *g,
                           const char *filename);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_add_drive_ro" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This function adds a virtual CD-ROM disk image to the guest.

       The image is added as read-only drive, so this function is equivalent of "guestfs_add_drive_ro".

       This function returns 0 on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_add_domain</b>
        int
        guestfs_add_domain (guestfs_h *g,
                            const char *dom,
                            ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_ADD_DOMAIN_LIBVIRTURI, const char *libvirturi,
        GUESTFS_ADD_DOMAIN_READONLY, int readonly,
        GUESTFS_ADD_DOMAIN_IFACE, const char *iface,
        GUESTFS_ADD_DOMAIN_LIVE, int live,
        GUESTFS_ADD_DOMAIN_ALLOWUUID, int allowuuid,
        GUESTFS_ADD_DOMAIN_READONLYDISK, const char *readonlydisk,
        GUESTFS_ADD_DOMAIN_CACHEMODE, const char *cachemode,
        GUESTFS_ADD_DOMAIN_DISCARD, const char *discard,
        GUESTFS_ADD_DOMAIN_COPYONREAD, int copyonread,

       This  function  adds  the  disk(s) attached to the named libvirt domain "dom".  It works by connecting to
       libvirt, requesting the  domain  and  domain  XML  from  libvirt,  parsing  it  for  disks,  and  calling
       "guestfs_add_drive_opts" on each one.

       The  number of disks added is returned.  This operation is atomic: if an error is returned, then no disks
       are added.

       This function does some minimal checks to make sure the libvirt domain is not running (unless  "readonly"
       is true).  In a future version we will try to acquire the libvirt lock on each disk.

       Disks  must  be  accessible locally.  This often means that adding disks from a remote libvirt connection
       (see https://libvirt.org/remote.html) will fail unless those disks are accessible  via  the  same  device
       path locally too.

       The  optional "libvirturi" parameter sets the libvirt URI (see https://libvirt.org/uri.html).  If this is
       not set then we connect to the default libvirt URI (or one set through an environment variable,  see  the
       libvirt documentation for full details).

       The optional "live" flag is ignored in libguestfs ≥ 1.48.

       If  the "allowuuid" flag is true (default is false) then a UUID <u>may</u> be passed instead of the domain name.
       The "dom" string is treated as a UUID first and looked up, and if that lookup fails then we  treat  "dom"
       as a name as usual.

       The  optional  "readonlydisk" parameter controls what we do for disks which are marked &lt;readonly/&gt; in the
       libvirt XML.  Possible values are:

       readonlydisk = "error"
           If "readonly" is false:

           The whole call is aborted with an error if any disk with the &lt;readonly/&gt; flag is found.

           If "readonly" is true:

           Disks with the &lt;readonly/&gt; flag are added read-only.

       readonlydisk = "read"
           If "readonly" is false:

           Disks with the &lt;readonly/&gt; flag are added read-only.  Other disks are added read/write.

           If "readonly" is true:

           Disks with the &lt;readonly/&gt; flag are added read-only.

       readonlydisk = "write" (default)
           If "readonly" is false:

           Disks with the &lt;readonly/&gt; flag are added read/write.

           If "readonly" is true:

           Disks with the &lt;readonly/&gt; flag are added read-only.

       readonlydisk = "ignore"
           If "readonly" is true or false:

           Disks with the &lt;readonly/&gt; flag are skipped.

       If present, the value of "logical_block_size" attribute of &lt;blockio/&gt; tag in libvirt XML will  be  passed
       as "blocksize" parameter to "guestfs_add_drive_opts".

       The other optional parameters are passed directly through to "guestfs_add_drive_opts".

       On error this function returns -1.

       (Added in 1.7.4)

   <b>guestfs_add_domain_va</b>
        int
        guestfs_add_domain_va (guestfs_h *g,
                               const char *dom,
                               va_list args);

       This is the "va_list variant" of "guestfs_add_domain".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_add_domain_argv</b>
        int
        guestfs_add_domain_argv (guestfs_h *g,
                                 const char *dom,
                                 const struct guestfs_add_domain_argv *optargs);

       This is the "argv variant" of "guestfs_add_domain".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_add_drive</b>
        int
        guestfs_add_drive (guestfs_h *g,
                           const char *filename);

       This  function  is  provided  for backwards compatibility with earlier versions of libguestfs.  It simply
       calls "guestfs_add_drive_opts" with no optional arguments.

       (Added in 0.3)

   <b>guestfs_add_drive_opts</b>
        int
        guestfs_add_drive_opts (guestfs_h *g,
                                const char *filename,
                                ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_ADD_DRIVE_OPTS_READONLY, int readonly,
        GUESTFS_ADD_DRIVE_OPTS_FORMAT, const char *format,
        GUESTFS_ADD_DRIVE_OPTS_IFACE, const char *iface,
        GUESTFS_ADD_DRIVE_OPTS_NAME, const char *name,
        GUESTFS_ADD_DRIVE_OPTS_LABEL, const char *label,
        GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, const char *protocol,
        GUESTFS_ADD_DRIVE_OPTS_SERVER, char *const *server,
        GUESTFS_ADD_DRIVE_OPTS_USERNAME, const char *username,
        GUESTFS_ADD_DRIVE_OPTS_SECRET, const char *secret,
        GUESTFS_ADD_DRIVE_OPTS_CACHEMODE, const char *cachemode,
        GUESTFS_ADD_DRIVE_OPTS_DISCARD, const char *discard,
        GUESTFS_ADD_DRIVE_OPTS_COPYONREAD, int copyonread,
        GUESTFS_ADD_DRIVE_OPTS_BLOCKSIZE, int blocksize,

       This  function adds a disk image called <u>filename</u> to the handle.  <u>filename</u> may be a regular host file or a
       host device.

       When this function is called before "guestfs_launch" (the usual case) then the first time you  call  this
       function, the disk appears in the API as <u>/dev/sda</u>, the second time as <u>/dev/sdb</u>, and so on.

       You  don't  necessarily  need to be root when using libguestfs.  However you obviously do need sufficient
       permissions to access the filename for whatever operations you want to perform (ie. read  access  if  you
       just want to read the image or write access if you want to modify the image).

       This call checks that <u>filename</u> exists.

       <u>filename</u> may be the special string "/dev/null".  See "NULL DISKS".

       The optional arguments are:

       "readonly"
           If  true  then the image is treated as read-only.  Writes are still allowed, but they are stored in a
           temporary snapshot overlay which is discarded at the end.  The disk that you add is not modified.

       "format"
           This  forces   the   image   format.    If   you   omit   this   (or   use   "guestfs_add_drive"   or
           "guestfs_add_drive_ro")  then  the  format is automatically detected.  Possible formats include "raw"
           and "qcow2".

           Automatic detection of the format opens you up  to  a  potential  security  hole  when  dealing  with
           untrusted  raw-format  images.  See CVE-2010-3851 and RHBZ#642934.  Specifying the format closes this
           security hole.

       "iface"
           This rarely-used option lets you emulate the behaviour of the deprecated  "guestfs_add_drive_with_if"
           call (q.v.)

       "name"
           This field used to be passed as a hint for guest inspection, but it is no longer used.

       "label"
           Give  the  disk  a  label.   The  label  should be a unique, short string using <u>only</u> ASCII characters
           "[a-zA-Z]".  As well as its usual name in the API (such as <u>/dev/sda</u>), the drive will  also  be  named
           <u>/dev/disk/guestfs/label</u>.

           See "DISK LABELS".

       "protocol"
           The optional protocol argument can be used to select an alternate source protocol.

           See also: "REMOTE STORAGE".

           "protocol = "file""
               <u>filename</u>  is interpreted as a local file or device.  This is the default if the optional protocol
               parameter is omitted.

           "protocol = "ftp"|"ftps"|"http"|"https""
               Connect to a remote FTP or HTTP server.  The "server" parameter  must  also  be  supplied  -  see
               below.

               See also: "FTP AND HTTP"

           "protocol = "iscsi""
               Connect  to  the  iSCSI  server.   The "server" parameter must also be supplied - see below.  The
               "username" parameter may be supplied.  See below.  The "secret" parameter may be  supplied.   See
               below.

               See also: "ISCSI".

           "protocol = "nbd""
               Connect  to  the Network Block Device server.  The "server" parameter must also be supplied - see
               below.

               See also: "NETWORK BLOCK DEVICE".

           "protocol = "rbd""
               Connect to the Ceph (librbd/RBD) server.  The "server" parameter must  also  be  supplied  -  see
               below.   The  "username"  parameter  may  be supplied.  See below.  The "secret" parameter may be
               supplied.  See below.

               See also: "CEPH".

           "protocol = "ssh""
               Connect to the Secure Shell (ssh) server.

               The "server" parameter must be supplied.  The "username" parameter may be supplied.  See below.

               See also: "SSH".

       "server"
           For protocols which require access to a remote server, this is a list of server(s).

            Protocol       Number of servers required
            --------       --------------------------
            file           List must be empty or param not used at all
            ftp|ftps|http|https  Exactly one
            iscsi          Exactly one
            nbd            Exactly one
            rbd            Zero or more
            ssh            Exactly one

           Each list element is a string specifying a server.  The string  must  be  in  one  of  the  following
           formats:

            hostname
            hostname:port
            tcp:hostname
            tcp:hostname:port
            unix:/path/to/socket

           If  the  port  number  is  omitted,  then  the  standard  port  number  for the protocol is used (see
           <u><a href="file:/etc/services">/etc/services</a></u>).

       "username"
           For the "ftp", "ftps", "http", "https", "iscsi", "rbd" and "ssh" protocols, this specifies the remote
           username.

           If not given, then the local username is used for "ssh", and no authentication is attempted for ceph.
           But note this sometimes may give unexpected results, for example if using the libvirt backend and  if
           the  libvirt backend is configured to start the qemu appliance as a special user such as "qemu.qemu".
           If in doubt, specify the remote username you want.

       "secret"
           For the "rbd" protocol only, this specifies the ‘secret’ to use when connecting to the remote device.
           It must be base64 encoded.

           If not given, then a secret matching the given username will be looked up  in  the  default  keychain
           locations, or if no username is given, then no authentication will be used.

       "cachemode"
           Choose  whether or not libguestfs will obey sync operations (safe but slow) or not (unsafe but fast).
           The possible values for this string are:

           "cachemode = "writeback""
               This is the default.

               Write operations in the API do not return until a <b><a href="../man2/write.2.html">write</a></b>(2) call has completed in  the  host  [but
               note this does not imply that anything gets written to disk].

               Sync  operations  in the API, including implicit syncs caused by filesystem journalling, will not
               return until an <b><a href="../man2/fdatasync.2.html">fdatasync</a></b>(2) call has completed in  the  host,  indicating  that  data  has  been
               committed to disk.

           "cachemode = "unsafe""
               In  this  mode, there are no guarantees.  Libguestfs may cache anything and ignore sync requests.
               This is suitable only for scratch or temporary disks.

       "discard"
           Enable or disable discard (a.k.a. trim or unmap) support on this drive.  If enabled, operations  such
           as  "guestfs_fstrim" will be able to discard / make thin / punch holes in the underlying host file or
           device.

           Possible discard settings are:

           "discard = "disable""
               Disable discard support.  This is the default.

           "discard = "enable""
               Enable discard support.  Fail if discard is not possible.

           "discard = "besteffort""
               Enable discard support if possible, but don't fail if it is not supported.

               Since not all backends and not all underlying systems support discard, this is a good  choice  if
               you want to use discard if possible, but don't mind if it doesn't work.

       "copyonread"
           The  boolean  parameter  "copyonread"  enables  copy-on-read support.  This only affects disk formats
           which have backing files, and causes reads to be stored in the overlay layer,  speeding  up  multiple
           reads of the same area of disk.

           The default is false.

       "blocksize"
           This  parameter  sets  the  sector  size  of  the  disk.  Possible values are 512 (the default if the
           parameter is omitted) or 4096.  Use 4096 when handling an "Advanced Format" disk that uses 4K  sector
           size (https://en.wikipedia.org/wiki/Advanced_Format).

           Only  a subset of the backends support this parameter (currently only the libvirt and direct backends
           do).

       This function returns 0 on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_add_drive_opts_va</b>
        int
        guestfs_add_drive_opts_va (guestfs_h *g,
                                   const char *filename,
                                   va_list args);

       This is the "va_list variant" of "guestfs_add_drive_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_add_drive_opts_argv</b>
        int
        guestfs_add_drive_opts_argv (guestfs_h *g,
                                     const char *filename,
                                     const struct guestfs_add_drive_opts_argv *optargs);

       This is the "argv variant" of "guestfs_add_drive_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_add_drive_ro</b>
        int
        guestfs_add_drive_ro (guestfs_h *g,
                              const char *filename);

       This function  is  the  equivalent  of  calling  "guestfs_add_drive_opts"  with  the  optional  parameter
       "GUESTFS_ADD_DRIVE_OPTS_READONLY"  set  to  1,  so  the  disk  is  added read-only, with the format being
       detected automatically.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.38)

   <b>guestfs_add_drive_ro_with_if</b>
        int
        guestfs_add_drive_ro_with_if (guestfs_h *g,
                                      const char *filename,
                                      const char *iface);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_add_drive" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This  is  the same as "guestfs_add_drive_ro" but it allows you to specify the QEMU interface emulation to
       use at run time.  Both the direct and the libvirt backends ignore "iface".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.84)

   <b>guestfs_add_drive_scratch</b>
        int
        guestfs_add_drive_scratch (guestfs_h *g,
                                   int64_t size,
                                   ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_ADD_DRIVE_SCRATCH_NAME, const char *name,
        GUESTFS_ADD_DRIVE_SCRATCH_LABEL, const char *label,
        GUESTFS_ADD_DRIVE_SCRATCH_BLOCKSIZE, int blocksize,

       This  command adds a temporary scratch drive to the handle.  The "size" parameter is the virtual size (in
       bytes).  The scratch drive is blank initially (all reads return zeroes until you start  writing  to  it).
       The drive is deleted when the handle is closed.

       The optional arguments "name", "label" and "blocksize" are passed through to "guestfs_add_drive_opts".

       This function returns 0 on success or -1 on error.

       (Added in 1.23.10)

   <b>guestfs_add_drive_scratch_va</b>
        int
        guestfs_add_drive_scratch_va (guestfs_h *g,
                                      int64_t size,
                                      va_list args);

       This is the "va_list variant" of "guestfs_add_drive_scratch".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_add_drive_scratch_argv</b>
        int
        guestfs_add_drive_scratch_argv (guestfs_h *g,
                                        int64_t size,
                                        const struct guestfs_add_drive_scratch_argv *optargs);

       This is the "argv variant" of "guestfs_add_drive_scratch".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_add_drive_with_if</b>
        int
        guestfs_add_drive_with_if (guestfs_h *g,
                                   const char *filename,
                                   const char *iface);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_add_drive" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This is the same as "guestfs_add_drive" but it allows you to specify the QEMU interface emulation to  use
       at run time.  Both the direct and the libvirt backends ignore "iface".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.84)

   <b>guestfs_add_libvirt_dom</b>
        int
        guestfs_add_libvirt_dom (guestfs_h *g,
                                 void * /* really virDomainPtr */ dom,
                                 ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_ADD_LIBVIRT_DOM_READONLY, int readonly,
        GUESTFS_ADD_LIBVIRT_DOM_IFACE, const char *iface,
        GUESTFS_ADD_LIBVIRT_DOM_LIVE, int live,
        GUESTFS_ADD_LIBVIRT_DOM_READONLYDISK, const char *readonlydisk,
        GUESTFS_ADD_LIBVIRT_DOM_CACHEMODE, const char *cachemode,
        GUESTFS_ADD_LIBVIRT_DOM_DISCARD, const char *discard,
        GUESTFS_ADD_LIBVIRT_DOM_COPYONREAD, int copyonread,

       This function adds the disk(s) attached to the libvirt domain "dom".  It works by requesting  the  domain
       XML from libvirt, parsing it for disks, and calling "guestfs_add_drive_opts" on each one.

       In the C API we declare "void *dom", but really it has type "virDomainPtr dom".  This is so we don't need
       &lt;libvirt.h&gt;.

       The  number of disks added is returned.  This operation is atomic: if an error is returned, then no disks
       are added.

       This function does some minimal checks to make sure the libvirt domain is not running (unless  "readonly"
       is true).  In a future version we will try to acquire the libvirt lock on each disk.

       Disks  must  be  accessible locally.  This often means that adding disks from a remote libvirt connection
       (see https://libvirt.org/remote.html) will fail unless those disks are accessible  via  the  same  device
       path locally too.

       The optional "live" flag is ignored in libguestfs ≥ 1.48.

       The  optional  "readonlydisk" parameter controls what we do for disks which are marked &lt;readonly/&gt; in the
       libvirt XML.  See "guestfs_add_domain" for possible values.

       If present, the value of "logical_block_size" attribute of &lt;blockio/&gt; tag in libvirt XML will  be  passed
       as "blocksize" parameter to "guestfs_add_drive_opts".

       The other optional parameters are passed directly through to "guestfs_add_drive_opts".

       On error this function returns -1.

       (Added in 1.29.14)

   <b>guestfs_add_libvirt_dom_va</b>
        int
        guestfs_add_libvirt_dom_va (guestfs_h *g,
                                    void * /* really virDomainPtr */ dom,
                                    va_list args);

       This is the "va_list variant" of "guestfs_add_libvirt_dom".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_add_libvirt_dom_argv</b>
        int
        guestfs_add_libvirt_dom_argv (guestfs_h *g,
                                      void * /* really virDomainPtr */ dom,
                                      const struct guestfs_add_libvirt_dom_argv *optargs);

       This is the "argv variant" of "guestfs_add_libvirt_dom".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_aug_clear</b>
        int
        guestfs_aug_clear (guestfs_h *g,
                           const char *augpath);

       Set the value associated with "path" to "NULL".  This is the same as the <b><a href="../man1/augtool.1.html">augtool</a></b>(1) "clear" command.

       This function returns 0 on success or -1 on error.

       (Added in 1.3.4)

   <b>guestfs_aug_close</b>
        int
        guestfs_aug_close (guestfs_h *g);

       Close  the  current  Augeas handle and free up any resources used by it.  After calling this, you have to
       call "guestfs_aug_init" again before you can use any other Augeas functions.

       This function returns 0 on success or -1 on error.

       (Added in 0.7)

   <b>guestfs_aug_defnode</b>
        struct guestfs_int_bool *
        guestfs_aug_defnode (guestfs_h *g,
                             const char *name,
                             const char *expr,
                             const char *val);

       Defines a variable "name" whose value is the result of evaluating "expr".

       If "expr" evaluates to an empty nodeset, a node  is  created,  equivalent  to  calling  "guestfs_aug_set"
       "expr", "val".  "name" will be the nodeset containing that single node.

       On  success  this  returns  a pair containing the number of nodes in the nodeset, and a boolean flag if a
       node was created.

       This function returns a "struct guestfs_int_bool *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u> <u>call</u>
       <u>"guestfs_free_int_bool"</u> <u>after</u> <u>use</u>.

       (Added in 0.7)

   <b>guestfs_aug_defvar</b>
        int
        guestfs_aug_defvar (guestfs_h *g,
                            const char *name,
                            const char *expr);

       Defines an Augeas variable "name" whose value is the result of evaluating "expr".   If  "expr"  is  NULL,
       then "name" is undefined.

       On success this returns the number of nodes in "expr", or 0 if "expr" evaluates to something which is not
       a nodeset.

       On error this function returns -1.

       (Added in 0.7)

   <b>guestfs_aug_get</b>
        char *
        guestfs_aug_get (guestfs_h *g,
                         const char *augpath);

       Look up the value associated with "path".  If "path" matches exactly one node, the "value" is returned.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 0.7)

   <b>guestfs_aug_init</b>
        int
        guestfs_aug_init (guestfs_h *g,
                          const char *root,
                          int flags);

       Create  a  new  Augeas  handle  for editing configuration files.  If there was any previous Augeas handle
       associated with this guestfs session, then it is closed.

       You must call this before using any other "guestfs_aug_*" commands.

       "root" is the filesystem root.  "root" must not be NULL, use <u>/</u> instead.

       The flags are the same as the flags defined in &lt;augeas.h&gt;, the logical <u>or</u> of the following integers:

       "AUG_SAVE_BACKUP" = 1
           Keep the original file with a ".augsave" extension.

       "AUG_SAVE_NEWFILE" = 2
           Save changes into a file  with  extension  ".augnew",  and  do  not  overwrite  original.   Overrides
           "AUG_SAVE_BACKUP".

       "AUG_TYPE_CHECK" = 4
           Typecheck lenses.

           This  option  is only useful when debugging Augeas lenses.  Use of this option may require additional
           memory for the libguestfs appliance.  You  may  need  to  set  the  "LIBGUESTFS_MEMSIZE"  environment
           variable or call "guestfs_set_memsize".

       "AUG_NO_STDINC" = 8
           Do not use standard load path for modules.

       "AUG_SAVE_NOOP" = 16
           Make save a no-op, just record what would have been changed.

       "AUG_NO_LOAD" = 32
           Do not load the tree in "guestfs_aug_init".

       To close the handle, you can call "guestfs_aug_close".

       To find out more about Augeas, see <a href="http://augeas.net/">http://augeas.net/</a>.

       This function returns 0 on success or -1 on error.

       (Added in 0.7)

   <b>guestfs_aug_insert</b>
        int
        guestfs_aug_insert (guestfs_h *g,
                            const char *augpath,
                            const char *label,
                            int before);

       Create  a new sibling "label" for "path", inserting it into the tree before or after "path" (depending on
       the boolean flag "before").

       "path" must match exactly one existing node in the tree, and "label" must be a label, ie. not contain  <u>/</u>,
       "*" or end with a bracketed index "[N]".

       This function returns 0 on success or -1 on error.

       (Added in 0.7)

   <b>guestfs_aug_label</b>
        char *
        guestfs_aug_label (guestfs_h *g,
                           const char *augpath);

       The label (name of the last element) of the Augeas path expression "augpath" is returned.  "augpath" must
       match exactly one node, else this function returns an error.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.23.14)

   <b>guestfs_aug_load</b>
        int
        guestfs_aug_load (guestfs_h *g);

       Load files into the tree.

       See "aug_load" in the Augeas documentation for the full gory details.

       This function returns 0 on success or -1 on error.

       (Added in 0.7)

   <b>guestfs_aug_ls</b>
        char **
        guestfs_aug_ls (guestfs_h *g,
                        const char *augpath);

       This  is  just  a  shortcut for listing "guestfs_aug_match" "path/*" and sorting the resulting nodes into
       alphabetical order.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 0.8)

   <b>guestfs_aug_match</b>
        char **
        guestfs_aug_match (guestfs_h *g,
                           const char *augpath);

       Returns  a  list  of  paths  which match the path expression "path".  The returned paths are sufficiently
       qualified so that they match exactly one node in the current tree.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 0.7)

   <b>guestfs_aug_mv</b>
        int
        guestfs_aug_mv (guestfs_h *g,
                        const char *src,
                        const char *dest);

       Move the node "src" to "dest".  "src" must match exactly one node.  "dest" is overwritten if it exists.

       This function returns 0 on success or -1 on error.

       (Added in 0.7)

   <b>guestfs_aug_rm</b>
        int
        guestfs_aug_rm (guestfs_h *g,
                        const char *augpath);

       Remove "path" and all of its children.

       On success this returns the number of entries which were removed.

       On error this function returns -1.

       (Added in 0.7)

   <b>guestfs_aug_save</b>
        int
        guestfs_aug_save (guestfs_h *g);

       This writes all pending changes to disk.

       The flags which were passed to "guestfs_aug_init" affect exactly how files are saved.

       This function returns 0 on success or -1 on error.

       (Added in 0.7)

   <b>guestfs_aug_set</b>
        int
        guestfs_aug_set (guestfs_h *g,
                         const char *augpath,
                         const char *val);

       Set the value associated with "augpath" to "val".

       In  the  Augeas API, it is possible to clear a node by setting the value to NULL.  Due to an oversight in
       the libguestfs API you cannot do that with this call.  Instead you must use the "guestfs_aug_clear" call.

       This function returns 0 on success or -1 on error.

       (Added in 0.7)

   <b>guestfs_aug_setm</b>
        int
        guestfs_aug_setm (guestfs_h *g,
                          const char *base,
                          const char *sub,
                          const char *val);

       Change multiple Augeas nodes in a single operation.  "base" is an  expression  matching  multiple  nodes.
       "sub"  is  a  path expression relative to "base".  All nodes matching "base" are found, and then for each
       node, "sub" is changed to "val".  "sub" may also be "NULL" in which case the "base" nodes are modified.

       This returns the number of nodes modified.

       On error this function returns -1.

       (Added in 1.23.14)

   <b>guestfs_aug_transform</b>
        int
        guestfs_aug_transform (guestfs_h *g,
                               const char *lens,
                               const char *file,
                               ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_AUG_TRANSFORM_REMOVE, int remove,

       Add an Augeas transformation for the specified "lens" so it can handle "file".

       If "remove" is true ("false" by default), then the transformation is removed.

       This function returns 0 on success or -1 on error.

       (Added in 1.35.2)

   <b>guestfs_aug_transform_va</b>
        int
        guestfs_aug_transform_va (guestfs_h *g,
                                  const char *lens,
                                  const char *file,
                                  va_list args);

       This is the "va_list variant" of "guestfs_aug_transform".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_aug_transform_argv</b>
        int
        guestfs_aug_transform_argv (guestfs_h *g,
                                    const char *lens,
                                    const char *file,
                                    const struct guestfs_aug_transform_argv *optargs);

       This is the "argv variant" of "guestfs_aug_transform".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_available</b>
        int
        guestfs_available (guestfs_h *g,
                           char *const *groups);

       This  command  is  used to check the availability of some groups of functionality in the appliance, which
       not all builds of the libguestfs appliance will be able to provide.

       The libguestfs groups, and the functions that those groups correspond to, are listed  in  "AVAILABILITY".
       You can also fetch this list at runtime by calling "guestfs_available_all_groups".

       The  argument  "groups"  is  a  list  of  group  names,  eg:  "["inotify", "augeas"]" would check for the
       availability of the Linux inotify functions and Augeas (configuration file editing) functions.

       The command returns no error if <u>all</u> requested groups are available.

       It fails with an error if one or more of the requested groups is unavailable in the appliance.

       If an unknown group name is included in the list of groups then an error is always returned.

       <u>Notes:</u>

       •   "guestfs_feature_available" is the same as this call, but with a slightly simpler to  use  API:  that
           call returns a boolean true/false instead of throwing an error.

       •   You must call "guestfs_launch" before calling this function.

           The  reason  is  because  we don't know what groups are supported by the appliance/daemon until it is
           running and can be queried.

       •   If a group of functions is available, this does not necessarily mean that they will work.  You  still
           have to check for errors when calling individual API functions even if they are available.

       •   It  is  usually  the  job  of  distro  packagers  to build complete functionality into the libguestfs
           appliance.  Upstream libguestfs, if built from source with all requirements satisfied,  will  support
           everything.

       •   This  call was added in version 1.0.80.  In previous versions of libguestfs all you could do would be
           to  speculatively  execute  a  command  to  find  out  if  the  daemon  implemented  it.   See   also
           "guestfs_version".

       See also "guestfs_filesystem_available".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.80)

   <b>guestfs_available_all_groups</b>
        char **
        guestfs_available_all_groups (guestfs_h *g);

       This  command returns a list of all optional groups that this daemon knows about.  Note this returns both
       supported and unsupported groups.  To find out which ones the daemon can actually  support  you  have  to
       call "guestfs_available" / "guestfs_feature_available" on each member of the returned list.

       See also "guestfs_available", "guestfs_feature_available" and "AVAILABILITY".

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.3.15)

   <b>guestfs_base64_in</b>
        int
        guestfs_base64_in (guestfs_h *g,
                           const char *base64file,
                           const char *filename);

       This command uploads base64-encoded data from "base64file" to <u>filename</u>.

       This function returns 0 on success or -1 on error.

       (Added in 1.3.5)

   <b>guestfs_base64_out</b>
        int
        guestfs_base64_out (guestfs_h *g,
                            const char *filename,
                            const char *base64file);

       This command downloads the contents of <u>filename</u>, writing it out to local  file  "base64file"  encoded  as
       base64.

       This function returns 0 on success or -1 on error.

       (Added in 1.3.5)

   <b>guestfs_blkdiscard</b>
        int
        guestfs_blkdiscard (guestfs_h *g,
                            const char *device);

       This discards all blocks on the block device "device", giving the free space back to the host.

       This  operation  requires  support in libguestfs, the host filesystem, qemu and the host kernel.  If this
       support isn't present it may give an error or even appear to run but do nothing.  You must also  set  the
       "discard" attribute on the underlying drive (see "guestfs_add_drive_opts").

       This function returns 0 on success or -1 on error.

       This function depends on the feature "blkdiscard".  See also "guestfs_feature_available".

       (Added in 1.25.44)

   <b>guestfs_blkdiscardzeroes</b>
        int
        guestfs_blkdiscardzeroes (guestfs_h *g,
                                  const char *device);

       This  call  returns true if blocks on "device" that have been discarded by a call to "guestfs_blkdiscard"
       are returned as blocks of zero bytes when read the next time.

       If it returns false, then it may be that discarded blocks are read as stale or random data.

       This function returns a C truth value on success or -1 on error.

       This function depends on the feature "blkdiscardzeroes".  See also "guestfs_feature_available".

       (Added in 1.25.44)

   <b>guestfs_blkid</b>
        char **
        guestfs_blkid (guestfs_h *g,
                       const char *device);

       This command returns block device attributes for "device". The following fields are  usually  present  in
       the returned hash. Other fields may also be present.

       "UUID"
           The uuid of this device.

       "LABEL"
           The label of this device.

       "VERSION"
           The version of blkid command.

       "TYPE"
           The filesystem type or RAID of this device.

       "USAGE"
           The usage of this device, for example "filesystem" or "raid".

       This  function  returns  a NULL-terminated array of strings, or NULL if there was an error.  The array of
       strings will always have length "2n+1", where "n" keys and values alternate,  followed  by  the  trailing
       NULL entry.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.15.9)

   <b>guestfs_blockdev_flushbufs</b>
        int
        guestfs_blockdev_flushbufs (guestfs_h *g,
                                    const char *device);

       This tells the kernel to flush internal buffers associated with "device".

       This uses the <b><a href="../man8/blockdev.8.html">blockdev</a></b>(8) command.

       This function returns 0 on success or -1 on error.

       (Added in 1.9.3)

   <b>guestfs_blockdev_getbsz</b>
        int
        guestfs_blockdev_getbsz (guestfs_h *g,
                                 const char *device);

       This returns the block size of a device.

       Note:  this  is  different  from both <u>size</u> <u>in</u> <u>blocks</u> and <u>filesystem</u> <u>block</u> <u>size</u>.  Also this setting is not
       really used by anything.  You should probably not use it for anything.  Filesystems have their  own  idea
       about what block size to choose.

       This uses the <b><a href="../man8/blockdev.8.html">blockdev</a></b>(8) command.

       On error this function returns -1.

       (Added in 1.9.3)

   <b>guestfs_blockdev_getro</b>
        int
        guestfs_blockdev_getro (guestfs_h *g,
                                const char *device);

       Returns a boolean indicating if the block device is read-only (true if read-only, false if not).

       This uses the <b><a href="../man8/blockdev.8.html">blockdev</a></b>(8) command.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.9.3)

   <b>guestfs_blockdev_getsize64</b>
        int64_t
        guestfs_blockdev_getsize64 (guestfs_h *g,
                                    const char *device);

       This returns the size of the device in bytes.

       See also "guestfs_blockdev_getsz".

       This uses the <b><a href="../man8/blockdev.8.html">blockdev</a></b>(8) command.

       On error this function returns -1.

       (Added in 1.9.3)

   <b>guestfs_blockdev_getss</b>
        int
        guestfs_blockdev_getss (guestfs_h *g,
                                const char *device);

       This returns the size of sectors on a block device.  Usually 512, but can be larger for modern devices.

       (Note, this is not the size in sectors, use "guestfs_blockdev_getsz" for that).

       This uses the <b><a href="../man8/blockdev.8.html">blockdev</a></b>(8) command.

       On error this function returns -1.

       (Added in 1.9.3)

   <b>guestfs_blockdev_getsz</b>
        int64_t
        guestfs_blockdev_getsz (guestfs_h *g,
                                const char *device);

       This  returns the size of the device in units of 512-byte sectors (even if the sectorsize isn't 512 bytes
       ... weird).

       See   also   "guestfs_blockdev_getss"   for   the   real    sector    size    of    the    device,    and
       "guestfs_blockdev_getsize64" for the more useful <u>size</u> <u>in</u> <u>bytes</u>.

       This uses the <b><a href="../man8/blockdev.8.html">blockdev</a></b>(8) command.

       On error this function returns -1.

       (Added in 1.9.3)

   <b>guestfs_blockdev_rereadpt</b>
        int
        guestfs_blockdev_rereadpt (guestfs_h *g,
                                   const char *device);

       Reread the partition table on "device".

       This uses the <b><a href="../man8/blockdev.8.html">blockdev</a></b>(8) command.

       This function returns 0 on success or -1 on error.

       (Added in 1.9.3)

   <b>guestfs_blockdev_setbsz</b>
        int
        guestfs_blockdev_setbsz (guestfs_h *g,
                                 const char *device,
                                 int blocksize);

       <u>This</u>  <u>function</u>  <u>is</u> <u>deprecated.</u>  There is no replacement.  Consult the API documentation in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3) for
       further information.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This call does nothing and has never done anything because of a bug in blockdev.  <b>Do</b> <b>not</b> <b>use</b> <b>it.</b>

       If you need to set the filesystem block size, use the "blocksize" option of "guestfs_mkfs".

       This function returns 0 on success or -1 on error.

       (Added in 1.9.3)

   <b>guestfs_blockdev_setra</b>
        int
        guestfs_blockdev_setra (guestfs_h *g,
                                const char *device,
                                int sectors);

       Set readahead (in 512-byte sectors) for the device.

       This uses the <b><a href="../man8/blockdev.8.html">blockdev</a></b>(8) command.

       This function returns 0 on success or -1 on error.

       (Added in 1.29.10)

   <b>guestfs_blockdev_setro</b>
        int
        guestfs_blockdev_setro (guestfs_h *g,
                                const char *device);

       Sets the block device named "device" to read-only.

       This uses the <b><a href="../man8/blockdev.8.html">blockdev</a></b>(8) command.

       This function returns 0 on success or -1 on error.

       (Added in 1.9.3)

   <b>guestfs_blockdev_setrw</b>
        int
        guestfs_blockdev_setrw (guestfs_h *g,
                                const char *device);

       Sets the block device named "device" to read-write.

       This uses the <b><a href="../man8/blockdev.8.html">blockdev</a></b>(8) command.

       This function returns 0 on success or -1 on error.

       (Added in 1.9.3)

   <b>guestfs_btrfs_balance_cancel</b>
        int
        guestfs_btrfs_balance_cancel (guestfs_h *g,
                                      const char *path);

       Cancel a running balance on a btrfs filesystem.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.22)

   <b>guestfs_btrfs_balance_pause</b>
        int
        guestfs_btrfs_balance_pause (guestfs_h *g,
                                     const char *path);

       Pause a running balance on a btrfs filesystem.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.22)

   <b>guestfs_btrfs_balance_resume</b>
        int
        guestfs_btrfs_balance_resume (guestfs_h *g,
                                      const char *path);

       Resume a paused balance on a btrfs filesystem.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.22)

   <b>guestfs_btrfs_balance_status</b>
        struct guestfs_btrfsbalance *
        guestfs_btrfs_balance_status (guestfs_h *g,
                                      const char *path);

       Show the status of a running or paused balance on a btrfs filesystem.

       This  function returns a "struct guestfs_btrfsbalance *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>
       <u>call</u> <u>"guestfs_free_btrfsbalance"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.26)

   <b>guestfs_btrfs_device_add</b>
        int
        guestfs_btrfs_device_add (guestfs_h *g,
                                  char *const *devices,
                                  const char *fs);

       Add the list of device(s) in "devices" to the btrfs filesystem mounted at "fs".  If "devices" is an empty
       list, this does nothing.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.35)

   <b>guestfs_btrfs_device_delete</b>
        int
        guestfs_btrfs_device_delete (guestfs_h *g,
                                     char *const *devices,
                                     const char *fs);

       Remove the "devices" from the btrfs filesystem mounted at "fs".  If "devices" is an empty list, this does
       nothing.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.35)

   <b>guestfs_btrfs_filesystem_balance</b>
        int
        guestfs_btrfs_filesystem_balance (guestfs_h *g,
                                          const char *fs);

       Balance the chunks in the btrfs filesystem mounted at "fs" across the underlying devices.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.35)

   <b>guestfs_btrfs_filesystem_defragment</b>
        int
        guestfs_btrfs_filesystem_defragment (guestfs_h *g,
                                             const char *path,
                                             ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_FLUSH, int flush,
        GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_COMPRESS, const char *compress,

       Defragment a file or directory on a btrfs filesystem. compress is one of zlib or lzo.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.22)

   <b>guestfs_btrfs_filesystem_defragment_va</b>
        int
        guestfs_btrfs_filesystem_defragment_va (guestfs_h *g,
                                                const char *path,
                                                va_list args);

       This is the "va_list variant" of "guestfs_btrfs_filesystem_defragment".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfs_filesystem_defragment_argv</b>
        int
        guestfs_btrfs_filesystem_defragment_argv (guestfs_h *g,
                                                  const char *path,
                                                  const struct guestfs_btrfs_filesystem_defragment_argv *optargs);

       This is the "argv variant" of "guestfs_btrfs_filesystem_defragment".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfs_filesystem_resize</b>
        int
        guestfs_btrfs_filesystem_resize (guestfs_h *g,
                                         const char *mountpoint,
                                         ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_BTRFS_FILESYSTEM_RESIZE_SIZE, int64_t size,

       This command resizes a btrfs filesystem.

       Note that unlike other resize calls, the filesystem has to be mounted and the parameter is the mountpoint
       not the device (this is a requirement of btrfs itself).

       The optional parameters are:

       "size"
           The new size (in bytes) of the filesystem.  If omitted, the filesystem  is  resized  to  the  maximum
           size.

       See also <b><a href="../man8/btrfs.8.html">btrfs</a></b>(8).

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.11.17)

   <b>guestfs_btrfs_filesystem_resize_va</b>
        int
        guestfs_btrfs_filesystem_resize_va (guestfs_h *g,
                                            const char *mountpoint,
                                            va_list args);

       This is the "va_list variant" of "guestfs_btrfs_filesystem_resize".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfs_filesystem_resize_argv</b>
        int
        guestfs_btrfs_filesystem_resize_argv (guestfs_h *g,
                                              const char *mountpoint,
                                              const struct guestfs_btrfs_filesystem_resize_argv *optargs);

       This is the "argv variant" of "guestfs_btrfs_filesystem_resize".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfs_filesystem_show</b>
        char **
        guestfs_btrfs_filesystem_show (guestfs_h *g,
                                       const char *device);

       Show all the devices where the filesystems in "device" is spanned over.

       If  not  all the devices for the filesystems are present, then this function fails and the "errno" is set
       to "ENODEV".

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.33.29)

   <b>guestfs_btrfs_filesystem_sync</b>
        int
        guestfs_btrfs_filesystem_sync (guestfs_h *g,
                                       const char *fs);

       Force sync on the btrfs filesystem mounted at "fs".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.35)

   <b>guestfs_btrfs_fsck</b>
        int
        guestfs_btrfs_fsck (guestfs_h *g,
                            const char *device,
                            ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_BTRFS_FSCK_SUPERBLOCK, int64_t superblock,
        GUESTFS_BTRFS_FSCK_REPAIR, int repair,

       Used to check a btrfs filesystem, "device" is the device file where the filesystem is stored.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.43)

   <b>guestfs_btrfs_fsck_va</b>
        int
        guestfs_btrfs_fsck_va (guestfs_h *g,
                               const char *device,
                               va_list args);

       This is the "va_list variant" of "guestfs_btrfs_fsck".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfs_fsck_argv</b>
        int
        guestfs_btrfs_fsck_argv (guestfs_h *g,
                                 const char *device,
                                 const struct guestfs_btrfs_fsck_argv *optargs);

       This is the "argv variant" of "guestfs_btrfs_fsck".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfs_image</b>
        int
        guestfs_btrfs_image (guestfs_h *g,
                             char *const *source,
                             const char *image,
                             ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_BTRFS_IMAGE_COMPRESSLEVEL, int compresslevel,

       This  is  used  to  create an image of a btrfs filesystem.  All data will be zeroed, but metadata and the
       like is preserved.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.32)

   <b>guestfs_btrfs_image_va</b>
        int
        guestfs_btrfs_image_va (guestfs_h *g,
                                char *const *source,
                                const char *image,
                                va_list args);

       This is the "va_list variant" of "guestfs_btrfs_image".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfs_image_argv</b>
        int
        guestfs_btrfs_image_argv (guestfs_h *g,
                                  char *const *source,
                                  const char *image,
                                  const struct guestfs_btrfs_image_argv *optargs);

       This is the "argv variant" of "guestfs_btrfs_image".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfs_qgroup_assign</b>
        int
        guestfs_btrfs_qgroup_assign (guestfs_h *g,
                                     const char *src,
                                     const char *dst,
                                     const char *path);

       Add qgroup "src" to parent qgroup "dst". This command can group several qgroups into a parent  qgroup  to
       share common limit.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.17)

   <b>guestfs_btrfs_qgroup_create</b>
        int
        guestfs_btrfs_qgroup_create (guestfs_h *g,
                                     const char *qgroupid,
                                     const char *subvolume);

       Create a quota group (qgroup) for subvolume at "subvolume".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.17)

   <b>guestfs_btrfs_qgroup_destroy</b>
        int
        guestfs_btrfs_qgroup_destroy (guestfs_h *g,
                                      const char *qgroupid,
                                      const char *subvolume);

       Destroy a quota group.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.17)

   <b>guestfs_btrfs_qgroup_limit</b>
        int
        guestfs_btrfs_qgroup_limit (guestfs_h *g,
                                    const char *subvolume,
                                    int64_t size);

       Limit the size of the subvolume with path "subvolume".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.17)

   <b>guestfs_btrfs_qgroup_remove</b>
        int
        guestfs_btrfs_qgroup_remove (guestfs_h *g,
                                     const char *src,
                                     const char *dst,
                                     const char *path);

       Remove qgroup "src" from the parent qgroup "dst".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.17)

   <b>guestfs_btrfs_qgroup_show</b>
        struct guestfs_btrfsqgroup_list *
        guestfs_btrfs_qgroup_show (guestfs_h *g,
                                   const char *path);

       Show all subvolume quota groups in a btrfs filesystem, including their usages.

       This  function  returns a "struct guestfs_btrfsqgroup_list *", or NULL if there was an error.  <u>The</u> <u>caller</u>
       <u>must</u> <u>call</u> <u>"guestfs_free_btrfsqgroup_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.17)

   <b>guestfs_btrfs_quota_enable</b>
        int
        guestfs_btrfs_quota_enable (guestfs_h *g,
                                    const char *fs,
                                    int enable);

       Enable or disable subvolume quota support for filesystem which contains "path".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.17)

   <b>guestfs_btrfs_quota_rescan</b>
        int
        guestfs_btrfs_quota_rescan (guestfs_h *g,
                                    const char *fs);

       Trash all qgroup numbers and scan the metadata again with the current config.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.17)

   <b>guestfs_btrfs_replace</b>
        int
        guestfs_btrfs_replace (guestfs_h *g,
                               const char *srcdev,
                               const char *targetdev,
                               const char *mntpoint);

       Replace device of a btrfs filesystem. On a live filesystem, duplicate the data to the target device which
       is currently stored on the source device.  After completion of the operation, the source device is  wiped
       out and removed from the filesystem.

       The  "targetdev"  needs  to be same size or larger than the "srcdev". Devices which are currently mounted
       are never allowed to be used as the "targetdev".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.48)

   <b>guestfs_btrfs_rescue_chunk_recover</b>
        int
        guestfs_btrfs_rescue_chunk_recover (guestfs_h *g,
                                            const char *device);

       Recover the chunk tree of btrfs filesystem by scanning the devices one by one.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.22)

   <b>guestfs_btrfs_rescue_super_recover</b>
        int
        guestfs_btrfs_rescue_super_recover (guestfs_h *g,
                                            const char *device);

       Recover bad superblocks from good copies.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.22)

   <b>guestfs_btrfs_scrub_cancel</b>
        int
        guestfs_btrfs_scrub_cancel (guestfs_h *g,
                                    const char *path);

       Cancel a running scrub on a btrfs filesystem.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.22)

   <b>guestfs_btrfs_scrub_resume</b>
        int
        guestfs_btrfs_scrub_resume (guestfs_h *g,
                                    const char *path);

       Resume a previously canceled or interrupted scrub on a btrfs filesystem.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.22)

   <b>guestfs_btrfs_scrub_start</b>
        int
        guestfs_btrfs_scrub_start (guestfs_h *g,
                                   const char *path);

       Reads all the data and metadata on the filesystem, and uses checksums and the duplicate copies from  RAID
       storage to identify and repair any corrupt data.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.22)

   <b>guestfs_btrfs_scrub_status</b>
        struct guestfs_btrfsscrub *
        guestfs_btrfs_scrub_status (guestfs_h *g,
                                    const char *path);

       Show status of running or finished scrub on a btrfs filesystem.

       This  function  returns  a "struct guestfs_btrfsscrub *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>
       <u>call</u> <u>"guestfs_free_btrfsscrub"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.26)

   <b>guestfs_btrfs_set_seeding</b>
        int
        guestfs_btrfs_set_seeding (guestfs_h *g,
                                   const char *device,
                                   int seeding);

       Enable or disable the seeding feature of a device that contains a btrfs filesystem.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.43)

   <b>guestfs_btrfs_subvolume_create</b>
        int
        guestfs_btrfs_subvolume_create (guestfs_h *g,
                                        const char *dest);

       This function is provided for backwards compatibility with earlier versions  of  libguestfs.   It  simply
       calls "guestfs_btrfs_subvolume_create_opts" with no optional arguments.

       (Added in 1.17.35)

   <b>guestfs_btrfs_subvolume_create_opts</b>
        int
        guestfs_btrfs_subvolume_create_opts (guestfs_h *g,
                                             const char *dest,
                                             ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_BTRFS_SUBVOLUME_CREATE_OPTS_QGROUPID, const char *qgroupid,

       Create a btrfs subvolume.  The "dest"  argument  is  the  destination  directory  and  the  name  of  the
       subvolume, in the form <u>/path/to/dest/name</u>.  The optional parameter "qgroupid" represents the qgroup which
       the newly created subvolume will be added to.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.35)

   <b>guestfs_btrfs_subvolume_create_opts_va</b>
        int
        guestfs_btrfs_subvolume_create_opts_va (guestfs_h *g,
                                                const char *dest,
                                                va_list args);

       This is the "va_list variant" of "guestfs_btrfs_subvolume_create_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfs_subvolume_create_opts_argv</b>
        int
        guestfs_btrfs_subvolume_create_opts_argv (guestfs_h *g,
                                                  const char *dest,
                                                  const struct guestfs_btrfs_subvolume_create_opts_argv *optargs);

       This is the "argv variant" of "guestfs_btrfs_subvolume_create_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfs_subvolume_delete</b>
        int
        guestfs_btrfs_subvolume_delete (guestfs_h *g,
                                        const char *subvolume);

       Delete the named btrfs subvolume or snapshot.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.35)

   <b>guestfs_btrfs_subvolume_get_default</b>
        int64_t
        guestfs_btrfs_subvolume_get_default (guestfs_h *g,
                                             const char *fs);

       Get the default subvolume or snapshot of a filesystem mounted at "mountpoint".

       On error this function returns -1.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.17)

   <b>guestfs_btrfs_subvolume_list</b>
        struct guestfs_btrfssubvolume_list *
        guestfs_btrfs_subvolume_list (guestfs_h *g,
                                      const char *fs);

       List the btrfs snapshots and subvolumes of the btrfs filesystem which is mounted at "fs".

       This  function  returns  a  "struct  guestfs_btrfssubvolume_list  *", or NULL if there was an error.  <u>The</u>
       <u>caller</u> <u>must</u> <u>call</u> <u>"guestfs_free_btrfssubvolume_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.35)

   <b>guestfs_btrfs_subvolume_set_default</b>
        int
        guestfs_btrfs_subvolume_set_default (guestfs_h *g,
                                             int64_t id,
                                             const char *fs);

       Set  the  subvolume  of  the  btrfs  filesystem  "fs"  which   will   be   mounted   by   default.    See
       "guestfs_btrfs_subvolume_list" to get a list of subvolumes.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.35)

   <b>guestfs_btrfs_subvolume_show</b>
        char **
        guestfs_btrfs_subvolume_show (guestfs_h *g,
                                      const char *subvolume);

       Return detailed information of the subvolume.

       This  function  returns  a NULL-terminated array of strings, or NULL if there was an error.  The array of
       strings will always have length "2n+1", where "n" keys and values alternate,  followed  by  the  trailing
       NULL entry.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.17)

   <b>guestfs_btrfs_subvolume_snapshot</b>
        int
        guestfs_btrfs_subvolume_snapshot (guestfs_h *g,
                                          const char *source,
                                          const char *dest);

       This  function  is  provided  for backwards compatibility with earlier versions of libguestfs.  It simply
       calls "guestfs_btrfs_subvolume_snapshot_opts" with no optional arguments.

       (Added in 1.17.35)

   <b>guestfs_btrfs_subvolume_snapshot_opts</b>
        int
        guestfs_btrfs_subvolume_snapshot_opts (guestfs_h *g,
                                               const char *source,
                                               const char *dest,
                                               ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_RO, int ro,
        GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_QGROUPID, const char *qgroupid,

       Create  a snapshot of the btrfs subvolume "source".  The "dest" argument is the destination directory and
       the name of the snapshot, in the form <u>/path/to/dest/name</u>.  By  default  the  newly  created  snapshot  is
       writable,  if  the  value  of  optional  parameter "ro" is true, then a readonly snapshot is created. The
       optional parameter "qgroupid" represents the qgroup which the newly created snapshot will be added to.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.35)

   <b>guestfs_btrfs_subvolume_snapshot_opts_va</b>
        int
        guestfs_btrfs_subvolume_snapshot_opts_va (guestfs_h *g,
                                                  const char *source,
                                                  const char *dest,
                                                  va_list args);

       This is the "va_list variant" of "guestfs_btrfs_subvolume_snapshot_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfs_subvolume_snapshot_opts_argv</b>
        int
        guestfs_btrfs_subvolume_snapshot_opts_argv (guestfs_h *g,
                                                    const char *source,
                                                    const char *dest,
                                                    const struct guestfs_btrfs_subvolume_snapshot_opts_argv *optargs);

       This is the "argv variant" of "guestfs_btrfs_subvolume_snapshot_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_btrfstune_enable_extended_inode_refs</b>
        int
        guestfs_btrfstune_enable_extended_inode_refs (guestfs_h *g,
                                                      const char *device);

       This will Enable extended inode refs.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.29)

   <b>guestfs_btrfstune_enable_skinny_metadata_extent_refs</b>
        int
        guestfs_btrfstune_enable_skinny_metadata_extent_refs (guestfs_h *g,
                                                              const char *device);

       This enable skinny metadata extent refs.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.29)

   <b>guestfs_btrfstune_seeding</b>
        int
        guestfs_btrfstune_seeding (guestfs_h *g,
                                   const char *device,
                                   int seeding);

       Enable seeding of a btrfs device, this will force a fs readonly so that you can use  it  to  build  other
       filesystems.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.29.29)

   <b>guestfs_c_pointer</b>
        int64_t
        guestfs_c_pointer (guestfs_h *g);

       In  non-C  language  bindings,  this  allows  you to retrieve the underlying C pointer to the handle (ie.
       "guestfs_h *").  The purpose of this is to allow other libraries to interwork with libguestfs.

       On error this function returns -1.

       (Added in 1.29.17)

   <b>guestfs_canonical_device_name</b>
        char *
        guestfs_canonical_device_name (guestfs_h *g,
                                       const char *device);

       This utility function is useful when displaying device names to the user.  It takes a number of irregular
       device names and returns them in a consistent format:

       <u>/dev/hdX</u>
       <u>/dev/vdX</u>
           These are returned as <u>/dev/sdX</u>.  Note this works for device  names  and  partition  names.   This  is
           approximately the reverse of the algorithm described in "BLOCK DEVICE NAMING".

       <u>/dev/mapper/VG-LV</u>
       <u>/dev/dm-N</u>
           Converted to <u>/dev/VG/LV</u> form using "guestfs_lvm_canonical_lv_name".

       Other strings are returned unmodified.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.19.7)

   <b>guestfs_cap_get_file</b>
        char *
        guestfs_cap_get_file (guestfs_h *g,
                              const char *path);

       This  function  returns  the  Linux capabilities attached to "path".  The capabilities set is returned in
       text form (see <b><a href="../man3/cap_to_text.3.html">cap_to_text</a></b>(3)).

       If no capabilities are attached to a file, an empty string is returned.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       This function depends on the feature "linuxcaps".  See also "guestfs_feature_available".

       (Added in 1.19.63)

   <b>guestfs_cap_set_file</b>
        int
        guestfs_cap_set_file (guestfs_h *g,
                              const char *path,
                              const char *cap);

       This function sets the Linux capabilities attached to "path".   The  capabilities  set  "cap"  should  be
       passed in text form (see <b><a href="../man3/cap_from_text.3.html">cap_from_text</a></b>(3)).

       This function returns 0 on success or -1 on error.

       This function depends on the feature "linuxcaps".  See also "guestfs_feature_available".

       (Added in 1.19.63)

   <b>guestfs_case_sensitive_path</b>
        char *
        guestfs_case_sensitive_path (guestfs_h *g,
                                     const char *path);

       This can be used to resolve case insensitive paths on a filesystem which is case sensitive.  The use case
       is  to resolve paths which you have read from Windows configuration files or the Windows Registry, to the
       true path.

       The command handles a peculiarity of the Linux ntfs-3g filesystem driver (and probably others), which  is
       that  although  the underlying filesystem is case-insensitive, the driver exports the filesystem to Linux
       as case-sensitive.

       One consequence of this is that special directories such as <u>C:\windows</u> may appear as <u>/WINDOWS</u> or <u>/windows</u>
       (or other things) depending on the precise details of how they were  created.   In  Windows  itself  this
       would not be a problem.

       Bug or feature?  You decide: https://www.tuxera.com/community/ntfs-3g-faq/#posixfilenames1

       "guestfs_case_sensitive_path"  attempts  to  resolve  the  true case of each element in the path. It will
       return a resolved path if either the full path or its parent directory exists. If  the  parent  directory
       exists  but  the full path does not, the case of the parent directory will be correctly resolved, and the
       remainder appended unmodified. For example, if the file "/Windows/System32/netkvm.sys" exists:

       "guestfs_case_sensitive_path" ("/windows/system32/netkvm.sys")
           "Windows/System32/netkvm.sys"

       "guestfs_case_sensitive_path" ("/windows/system32/NoSuchFile")
           "Windows/System32/NoSuchFile"

       "guestfs_case_sensitive_path" ("/windows/system33/netkvm.sys")
           <u>ERROR</u>

       <u>Note</u>: Because of the above behaviour, "guestfs_case_sensitive_path" cannot  be  used  to  check  for  the
       existence of a file.

       <u>Note</u>: This function does not handle drive names, backslashes etc.

       See also "guestfs_realpath".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.75)

   <b>guestfs_cat</b>
        char *
        guestfs_cat (guestfs_h *g,
                     const char *path);

       Return the contents of the file named "path".

       Because,  in  C,  this  function  returns  a  "char  *",  there is no way to differentiate between a "\0"
       character in a file and  end  of  string.   To  handle  binary  files,  use  the  "guestfs_read_file"  or
       "guestfs_download" functions.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 0.4)

   <b>guestfs_checksum</b>
        char *
        guestfs_checksum (guestfs_h *g,
                          const char *csumtype,
                          const char *path);

       This call computes the MD5, SHAx or CRC checksum of the file named "path".

       The type of checksum to compute is given by the "csumtype" parameter which must have one of the following
       values:

       "crc"
           Compute the cyclic redundancy check (CRC) specified by POSIX for the "cksum" command.

       "gost"
       "gost12"
           Compute the checksum using GOST R34.11-94 or GOST R34.11-2012 message digest.

       "md5"
           Compute the MD5 hash (using the <b><a href="../man1/md5sum.1.html">md5sum</a></b>(1) program).

       "sha1"
           Compute the SHA1 hash (using the <b><a href="../man1/sha1sum.1.html">sha1sum</a></b>(1) program).

       "sha224"
           Compute the SHA224 hash (using the <b><a href="../man1/sha224sum.1.html">sha224sum</a></b>(1) program).

       "sha256"
           Compute the SHA256 hash (using the <b><a href="../man1/sha256sum.1.html">sha256sum</a></b>(1) program).

       "sha384"
           Compute the SHA384 hash (using the <b><a href="../man1/sha384sum.1.html">sha384sum</a></b>(1) program).

       "sha512"
           Compute the SHA512 hash (using the <b><a href="../man1/sha512sum.1.html">sha512sum</a></b>(1) program).

       The checksum is returned as a printable string.

       To get the checksum for a device, use "guestfs_checksum_device".

       To get the checksums for many files, use "guestfs_checksums_out".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.2)

   <b>guestfs_checksum_device</b>
        char *
        guestfs_checksum_device (guestfs_h *g,
                                 const char *csumtype,
                                 const char *device);

       This  call  computes the MD5, SHAx or CRC checksum of the contents of the device named "device".  For the
       types of checksums supported see the "guestfs_checksum" command.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.3.2)

   <b>guestfs_checksums_out</b>
        int
        guestfs_checksums_out (guestfs_h *g,
                               const char *csumtype,
                               const char *directory,
                               const char *sumsfile);

       This command computes the checksums of all regular files in <u>directory</u> and then  emits  a  list  of  those
       checksums to the local output file "sumsfile".

       This  can  be  used  for verifying the integrity of a virtual machine.  However to be properly secure you
       should pay attention to the output of the checksum command (it uses the ones  from  GNU  coreutils).   In
       particular  when  the  filename  is  not  printable, coreutils uses a special backslash syntax.  For more
       information, see the GNU coreutils info file.

       This function returns 0 on success or -1 on error.

       (Added in 1.3.7)

   <b>guestfs_chmod</b>
        int
        guestfs_chmod (guestfs_h *g,
                       int mode,
                       const char *path);

       Change the mode (permissions) of "path" to "mode".  Only numeric modes are supported.

       <u>Note</u>: When using this command from guestfish, "mode" by default would be decimal, unless  you  prefix  it
       with 0 to get octal, ie. use 0700 not 700.

       The mode actually set is affected by the umask.

       This function returns 0 on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_chown</b>
        int
        guestfs_chown (guestfs_h *g,
                       int owner,
                       int group,
                       const char *path);

       Change the file owner to "owner" and group to "group".

       Only  numeric uid and gid are supported.  If you want to use names, you will need to locate and parse the
       password file yourself (Augeas support makes this relatively easy).

       This function returns 0 on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_clear_backend_setting</b>
        int
        guestfs_clear_backend_setting (guestfs_h *g,
                                       const char *name);

       If there is a backend setting string matching "name" or beginning  with  "name=",  then  that  string  is
       removed from the backend settings.

       This call returns the number of strings which were removed (which may be 0, 1 or greater than 1).

       See "BACKEND", "BACKEND SETTINGS".

       On error this function returns -1.

       (Added in 1.27.2)

   <b>guestfs_clevis_luks_unlock</b>
        int
        guestfs_clevis_luks_unlock (guestfs_h *g,
                                    const char *device,
                                    const char *mapname);

       This command opens a block device that has been encrypted according to the Linux Unified Key Setup (LUKS)
       standard, using network-bound disk encryption (NBDE).

       "device" is the encrypted block device.

       The  appliance  will  connect  to  the  Tang  servers noted in the tree of Clevis pins that is bound to a
       keyslot of the LUKS header.  The Clevis pin tree may comprise "sss" (redudancy) pins  as  internal  nodes
       (optionally),  and  "tang"  pins  as  leaves.   "tpm2" pins are not supported.  The appliance unlocks the
       encrypted block device by combining responses from the Tang servers with metadata from the  LUKS  header;
       there is no "key" parameter.

       This   command   will   fail   if   networking   has  not  been  enabled  for  the  appliance.  Refer  to
       "guestfs_set_network".

       The command creates a new block device called <u>/dev/mapper/mapname</u>.  Reads and writes to this block device
       are decrypted from and encrypted to the underlying "device"  respectively.   Close  the  decrypted  block
       device with "guestfs_cryptsetup_close".

       "mapname" cannot be "control" because that name is reserved by device-mapper.

       If  this  block  device  contains  LVM volume groups, then calling "guestfs_lvm_scan" with the "activate"
       parameter "true" will make them visible.

       Use "guestfs_list_dm_devices" to list all device mapper devices.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "clevisluks".  See also "guestfs_feature_available".

       (Added in 1.49.3)

   <b>guestfs_command</b>
        char *
        guestfs_command (guestfs_h *g,
                         char *const *arguments);

       This call runs a command from the guest filesystem.  The filesystem must be mounted, and must  contain  a
       compatible operating system (ie. something Linux, with the same or compatible processor architecture).

       The single parameter is an argv-style list of arguments.  The first element is the name of the program to
       run.   Subsequent elements are parameters.  The list must be non-empty (ie. must contain a program name).
       Note that the command runs directly, and is <u>not</u> invoked via the shell (see "guestfs_sh").

       The return value is anything printed to <u>stdout</u> by the command.

       If the command returns a non-zero exit status, then this function returns an error  message.   The  error
       message string is the content of <u>stderr</u> from the command.

       The  $PATH  environment  variable will contain at least <u><a href="file:/usr/bin">/usr/bin</a></u> and <u><a href="file:/bin">/bin</a></u>.  If you require a program from
       another location, you should provide the full path in the first parameter.

       Shared libraries and data files required by the program  must  be  available  on  filesystems  which  are
       mounted  in  the  correct  places.   It is the caller’s responsibility to ensure all filesystems that are
       needed are mounted at the right locations.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       Because of the message protocol, there is a transfer  limit  of  somewhere  between  2MB  and  4MB.   See
       "PROTOCOL LIMITS".

       (Added in 1.9.1)

   <b>guestfs_command_lines</b>
        char **
        guestfs_command_lines (guestfs_h *g,
                               char *const *arguments);

       This is the same as "guestfs_command", but splits the result into a list of lines.

       See also: "guestfs_sh_lines"

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because of the message protocol, there is a transfer  limit  of  somewhere  between  2MB  and  4MB.   See
       "PROTOCOL LIMITS".

       (Added in 1.9.1)

   <b>guestfs_compress_device_out</b>
        int
        guestfs_compress_device_out (guestfs_h *g,
                                     const char *ctype,
                                     const char *device,
                                     const char *zdevice,
                                     ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_COMPRESS_DEVICE_OUT_LEVEL, int level,

       This command compresses "device" and writes it out to the local file "zdevice".

       The "ctype" and optional "level" parameters have the same meaning as in "guestfs_compress_out".

       This function returns 0 on success or -1 on error.

       (Added in 1.13.15)

   <b>guestfs_compress_device_out_va</b>
        int
        guestfs_compress_device_out_va (guestfs_h *g,
                                        const char *ctype,
                                        const char *device,
                                        const char *zdevice,
                                        va_list args);

       This is the "va_list variant" of "guestfs_compress_device_out".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_compress_device_out_argv</b>
        int
        guestfs_compress_device_out_argv (guestfs_h *g,
                                          const char *ctype,
                                          const char *device,
                                          const char *zdevice,
                                          const struct guestfs_compress_device_out_argv *optargs);

       This is the "argv variant" of "guestfs_compress_device_out".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_compress_out</b>
        int
        guestfs_compress_out (guestfs_h *g,
                              const char *ctype,
                              const char *file,
                              const char *zfile,
                              ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_COMPRESS_OUT_LEVEL, int level,

       This command compresses <u>file</u> and writes it out to the local file <u>zfile</u>.

       The  compression  program  used  is  controlled  by  the  "ctype"  parameter.   Currently  this includes:
       "compress", "gzip", "bzip2", "xz" or "lzop".  Some compression types may not be supported  by  particular
       builds of libguestfs, in which case you will get an error containing the substring "not supported".

       The  optional  "level"  parameter controls compression level.  The meaning and default for this parameter
       depends on the compression program being used.

       This function returns 0 on success or -1 on error.

       (Added in 1.13.15)

   <b>guestfs_compress_out_va</b>
        int
        guestfs_compress_out_va (guestfs_h *g,
                                 const char *ctype,
                                 const char *file,
                                 const char *zfile,
                                 va_list args);

       This is the "va_list variant" of "guestfs_compress_out".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_compress_out_argv</b>
        int
        guestfs_compress_out_argv (guestfs_h *g,
                                   const char *ctype,
                                   const char *file,
                                   const char *zfile,
                                   const struct guestfs_compress_out_argv *optargs);

       This is the "argv variant" of "guestfs_compress_out".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_config</b>
        int
        guestfs_config (guestfs_h *g,
                        const char *hvparam,
                        const char *hvvalue);

       This can be used to add arbitrary hypervisor parameters of the form  <u>-param</u>  <u>value</u>.   Actually  it’s  not
       quite  arbitrary - we prevent you from setting some parameters which would interfere with parameters that
       we use.

       The first character of "hvparam" string must be a "-" (dash).

       "hvvalue" can be NULL.

       This function returns 0 on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_copy_attributes</b>
        int
        guestfs_copy_attributes (guestfs_h *g,
                                 const char *src,
                                 const char *dest,
                                 ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_COPY_ATTRIBUTES_ALL, int all,
        GUESTFS_COPY_ATTRIBUTES_MODE, int mode,
        GUESTFS_COPY_ATTRIBUTES_XATTRIBUTES, int xattributes,
        GUESTFS_COPY_ATTRIBUTES_OWNERSHIP, int ownership,

       Copy the attributes of a path (which can be a file or a directory) to another path.

       By default <b>no</b> attribute is copied, so make sure to specify any (or "all" to copy everything).

       The optional arguments specify which attributes can be copied:

       "mode"
           Copy  part  of  the  file  mode  from  "source"  to  "destination". Only the UNIX permissions and the
           sticky/setuid/setgid bits can be copied.

       "xattributes"
           Copy the Linux extended attributes (xattrs) from "source" to "destination".  This flag  does  nothing
           if the <u>linuxxattrs</u> feature is not available (see "guestfs_feature_available").

       "ownership"
           Copy the owner uid and the group gid of "source" to "destination".

       "all"
           Copy  <b>all</b>  the attributes from "source" to "destination". Enabling it enables all the other flags, if
           they are not specified already.

       This function returns 0 on success or -1 on error.

       (Added in 1.25.21)

   <b>guestfs_copy_attributes_va</b>
        int
        guestfs_copy_attributes_va (guestfs_h *g,
                                    const char *src,
                                    const char *dest,
                                    va_list args);

       This is the "va_list variant" of "guestfs_copy_attributes".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_copy_attributes_argv</b>
        int
        guestfs_copy_attributes_argv (guestfs_h *g,
                                      const char *src,
                                      const char *dest,
                                      const struct guestfs_copy_attributes_argv *optargs);

       This is the "argv variant" of "guestfs_copy_attributes".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_copy_device_to_device</b>
        int
        guestfs_copy_device_to_device (guestfs_h *g,
                                       const char *src,
                                       const char *dest,
                                       ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_COPY_DEVICE_TO_DEVICE_SRCOFFSET, int64_t srcoffset,
        GUESTFS_COPY_DEVICE_TO_DEVICE_DESTOFFSET, int64_t destoffset,
        GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE, int64_t size,
        GUESTFS_COPY_DEVICE_TO_DEVICE_SPARSE, int sparse,
        GUESTFS_COPY_DEVICE_TO_DEVICE_APPEND, int append,

       The        four        calls        "guestfs_copy_device_to_device",       "guestfs_copy_device_to_file",
       "guestfs_copy_file_to_device", and "guestfs_copy_file_to_file" let you copy from a  source  (device|file)
       to a destination (device|file).

       Partial  copies  can  be  made since you can specify optionally the source offset, destination offset and
       size to copy.  These values are all specified in bytes.  If not given, the offsets both default to  zero,
       and the size defaults to copying as much as possible until we hit the end of the source.

       The  source  and  destination  may  be  the  same  object.  However overlapping regions may not be copied
       correctly.

       If the destination is a file, it is created if required.  If the destination file is not large enough, it
       is extended.

       If the destination is a file and the "append" flag is not set, then the destination  file  is  truncated.
       If  the "append" flag is set, then the copy appends to the destination file.  The "append" flag currently
       cannot be set for devices.

       If the "sparse" flag is true then the call avoids writing blocks that contain only zeroes, which can help
       in some situations where the backing disk is thin-provisioned.  Note that unless the  target  is  already
       zeroed, using this option will result in incorrect copying.

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.13.25)

   <b>guestfs_copy_device_to_device_va</b>
        int
        guestfs_copy_device_to_device_va (guestfs_h *g,
                                          const char *src,
                                          const char *dest,
                                          va_list args);

       This is the "va_list variant" of "guestfs_copy_device_to_device".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_copy_device_to_device_argv</b>
        int
        guestfs_copy_device_to_device_argv (guestfs_h *g,
                                            const char *src,
                                            const char *dest,
                                            const struct guestfs_copy_device_to_device_argv *optargs);

       This is the "argv variant" of "guestfs_copy_device_to_device".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_copy_device_to_file</b>
        int
        guestfs_copy_device_to_file (guestfs_h *g,
                                     const char *src,
                                     const char *dest,
                                     ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_COPY_DEVICE_TO_FILE_SRCOFFSET, int64_t srcoffset,
        GUESTFS_COPY_DEVICE_TO_FILE_DESTOFFSET, int64_t destoffset,
        GUESTFS_COPY_DEVICE_TO_FILE_SIZE, int64_t size,
        GUESTFS_COPY_DEVICE_TO_FILE_SPARSE, int sparse,
        GUESTFS_COPY_DEVICE_TO_FILE_APPEND, int append,

       See "guestfs_copy_device_to_device" for a general overview of this call.

       This function returns 0 on success or -1 on error.

       This long-running command can generate progress notification messages so that the caller  can  display  a
       progress  bar  or  indicator.   To  receive  these  messages,  the  caller must register a progress event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.13.25)

   <b>guestfs_copy_device_to_file_va</b>
        int
        guestfs_copy_device_to_file_va (guestfs_h *g,
                                        const char *src,
                                        const char *dest,
                                        va_list args);

       This is the "va_list variant" of "guestfs_copy_device_to_file".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_copy_device_to_file_argv</b>
        int
        guestfs_copy_device_to_file_argv (guestfs_h *g,
                                          const char *src,
                                          const char *dest,
                                          const struct guestfs_copy_device_to_file_argv *optargs);

       This is the "argv variant" of "guestfs_copy_device_to_file".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_copy_file_to_device</b>
        int
        guestfs_copy_file_to_device (guestfs_h *g,
                                     const char *src,
                                     const char *dest,
                                     ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_COPY_FILE_TO_DEVICE_SRCOFFSET, int64_t srcoffset,
        GUESTFS_COPY_FILE_TO_DEVICE_DESTOFFSET, int64_t destoffset,
        GUESTFS_COPY_FILE_TO_DEVICE_SIZE, int64_t size,
        GUESTFS_COPY_FILE_TO_DEVICE_SPARSE, int sparse,
        GUESTFS_COPY_FILE_TO_DEVICE_APPEND, int append,

       See "guestfs_copy_device_to_device" for a general overview of this call.

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.13.25)

   <b>guestfs_copy_file_to_device_va</b>
        int
        guestfs_copy_file_to_device_va (guestfs_h *g,
                                        const char *src,
                                        const char *dest,
                                        va_list args);

       This is the "va_list variant" of "guestfs_copy_file_to_device".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_copy_file_to_device_argv</b>
        int
        guestfs_copy_file_to_device_argv (guestfs_h *g,
                                          const char *src,
                                          const char *dest,
                                          const struct guestfs_copy_file_to_device_argv *optargs);

       This is the "argv variant" of "guestfs_copy_file_to_device".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_copy_file_to_file</b>
        int
        guestfs_copy_file_to_file (guestfs_h *g,
                                   const char *src,
                                   const char *dest,
                                   ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_COPY_FILE_TO_FILE_SRCOFFSET, int64_t srcoffset,
        GUESTFS_COPY_FILE_TO_FILE_DESTOFFSET, int64_t destoffset,
        GUESTFS_COPY_FILE_TO_FILE_SIZE, int64_t size,
        GUESTFS_COPY_FILE_TO_FILE_SPARSE, int sparse,
        GUESTFS_COPY_FILE_TO_FILE_APPEND, int append,

       See "guestfs_copy_device_to_device" for a general overview of this call.

       This is <b>not</b> the function you want for copying files.  This is for copying blocks within  existing  files.
       See "guestfs_cp", "guestfs_cp_a" and "guestfs_mv" for general file copying and moving functions.

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.13.25)

   <b>guestfs_copy_file_to_file_va</b>
        int
        guestfs_copy_file_to_file_va (guestfs_h *g,
                                      const char *src,
                                      const char *dest,
                                      va_list args);

       This is the "va_list variant" of "guestfs_copy_file_to_file".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_copy_file_to_file_argv</b>
        int
        guestfs_copy_file_to_file_argv (guestfs_h *g,
                                        const char *src,
                                        const char *dest,
                                        const struct guestfs_copy_file_to_file_argv *optargs);

       This is the "argv variant" of "guestfs_copy_file_to_file".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_copy_in</b>
        int
        guestfs_copy_in (guestfs_h *g,
                         const char *localpath,
                         const char *remotedir);

       "guestfs_copy_in"  copies local files or directories recursively into the disk image, placing them in the
       directory called "remotedir" (which must exist).

       Wildcards cannot be used.

       This function returns 0 on success or -1 on error.

       (Added in 1.29.24)

   <b>guestfs_copy_out</b>
        int
        guestfs_copy_out (guestfs_h *g,
                          const char *remotepath,
                          const char *localdir);

       "guestfs_copy_out" copies remote files or directories recursively out of the disk image, placing them  on
       the host disk in a local directory called "localdir" (which must exist).

       To download to the current directory, use "." as in:

        C&lt;guestfs_copy_out&gt; <a href="file:/home">/home</a> .

       Wildcards cannot be used.

       This function returns 0 on success or -1 on error.

       (Added in 1.29.24)

   <b>guestfs_copy_size</b>
        int
        guestfs_copy_size (guestfs_h *g,
                           const char *src,
                           const char *dest,
                           int64_t size);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_copy_device_to_device" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This command copies exactly "size" bytes from one source device or  file  "src"  to  another  destination
       device or file "dest".

       Note this will fail if the source is too short or if the destination is not large enough.

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.0.87)

   <b>guestfs_cp</b>
        int
        guestfs_cp (guestfs_h *g,
                    const char *src,
                    const char *dest);

       This  copies  a  file  from  "src" to "dest" where "dest" is either a destination filename or destination
       directory.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.18)

   <b>guestfs_cp_a</b>
        int
        guestfs_cp_a (guestfs_h *g,
                      const char *src,
                      const char *dest);

       This copies a file or directory from "src" to "dest" recursively using the "cp -a" command.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.18)

   <b>guestfs_cp_r</b>
        int
        guestfs_cp_r (guestfs_h *g,
                      const char *src,
                      const char *dest);

       This copies a file or directory from "src" to "dest" recursively using the "cp -rP" command.

       Most users should use "guestfs_cp_a" instead.  This command is useful when you  don't  want  to  preserve
       permissions,  because  the  target  filesystem  does  not  support  it (primarily when writing to DOS FAT
       filesystems).

       This function returns 0 on success or -1 on error.

       (Added in 1.21.38)

   <b>guestfs_cpio_out</b>
        int
        guestfs_cpio_out (guestfs_h *g,
                          const char *directory,
                          const char *cpiofile,
                          ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_CPIO_OUT_FORMAT, const char *format,

       This command packs the contents of <u>directory</u> and downloads it to local file "cpiofile".

       The  optional  "format"  parameter  can  be  used  to  select the format.  Only the following formats are
       currently permitted:

       "newc"
           New (SVR4) portable format.  This format happens to be compatible with the cpio-like format  used  by
           the Linux kernel for initramfs.

           This is the default format.

       "crc"
           New (SVR4) portable format with a checksum.

       This function returns 0 on success or -1 on error.

       (Added in 1.27.9)

   <b>guestfs_cpio_out_va</b>
        int
        guestfs_cpio_out_va (guestfs_h *g,
                             const char *directory,
                             const char *cpiofile,
                             va_list args);

       This is the "va_list variant" of "guestfs_cpio_out".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_cpio_out_argv</b>
        int
        guestfs_cpio_out_argv (guestfs_h *g,
                               const char *directory,
                               const char *cpiofile,
                               const struct guestfs_cpio_out_argv *optargs);

       This is the "argv variant" of "guestfs_cpio_out".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_cryptsetup_close</b>
        int
        guestfs_cryptsetup_close (guestfs_h *g,
                                  const char *device);

       This  closes  an  encrypted  device  that was created earlier by "guestfs_cryptsetup_open".  The "device"
       parameter must be the name of the mapping device (ie.  <u>/dev/mapper/mapname</u>)  and  <u>not</u>  the  name  of  the
       underlying block device.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "luks".  See also "guestfs_feature_available".

       (Added in 1.43.2)

   <b>guestfs_cryptsetup_open</b>
        int
        guestfs_cryptsetup_open (guestfs_h *g,
                                 const char *device,
                                 const char *key,
                                 const char *mapname,
                                 ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_CRYPTSETUP_OPEN_READONLY, int readonly,
        GUESTFS_CRYPTSETUP_OPEN_CRYPTTYPE, const char *crypttype,
        GUESTFS_CRYPTSETUP_OPEN_CIPHER, const char *cipher,

       This command opens a block device which has been encrypted according  to  the  Linux  Unified  Key  Setup
       (LUKS) standard, Windows BitLocker, or some other types.

       "device" is the encrypted block device or partition.

       The  caller  must  supply  one  of  the  keys  associated  with  the encrypted block device, in the "key"
       parameter.

       This creates a new block device called <u>/dev/mapper/mapname</u>.  Reads and writes to this  block  device  are
       decrypted from and encrypted to the underlying "device" respectively.

       "mapname" cannot be "control" because that name is reserved by device-mapper.

       If the optional "crypttype" parameter is not present then libguestfs tries to guess the correct type (for
       example LUKS or BitLocker).  However you can override this by specifying one of the following types:

       "luks"
           A Linux LUKS device.

       "bitlk"
           A Windows BitLocker device.

       The optional "readonly" flag, if set to true, creates a read-only mapping.

       The optional "cipher" parameter allows specifying which cipher to use.

       If  this  block  device  contains  LVM volume groups, then calling "guestfs_lvm_scan" with the "activate"
       parameter "true" will make them visible.

       Use "guestfs_list_dm_devices" to list all device mapper devices.

       This function returns 0 on success or -1 on error.

       This function takes a key or passphrase parameter which  could  contain  sensitive  material.   Read  the
       section "KEYS AND PASSPHRASES" for more information.

       This function depends on the feature "luks".  See also "guestfs_feature_available".

       (Added in 1.43.2)

   <b>guestfs_cryptsetup_open_va</b>
        int
        guestfs_cryptsetup_open_va (guestfs_h *g,
                                    const char *device,
                                    const char *key,
                                    const char *mapname,
                                    va_list args);

       This is the "va_list variant" of "guestfs_cryptsetup_open".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_cryptsetup_open_argv</b>
        int
        guestfs_cryptsetup_open_argv (guestfs_h *g,
                                      const char *device,
                                      const char *key,
                                      const char *mapname,
                                      const struct guestfs_cryptsetup_open_argv *optargs);

       This is the "argv variant" of "guestfs_cryptsetup_open".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_dd</b>
        int
        guestfs_dd (guestfs_h *g,
                    const char *src,
                    const char *dest);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_copy_device_to_device" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This command copies from one source device or file "src" to another destination device  or  file  "dest".
       Normally  you  would  use  this  to  copy  to  or  from a device or partition, for example to duplicate a
       filesystem.

       If the destination is a device, it must be as large or larger than the source file or  device,  otherwise
       the copy will fail.  This command cannot do partial copies (see "guestfs_copy_device_to_device").

       This function returns 0 on success or -1 on error.

       (Added in 1.0.80)

   <b>guestfs_device_index</b>
        int
        guestfs_device_index (guestfs_h *g,
                              const char *device);

       This  function  takes  a  device name (eg. "/dev/sdb") and returns the index of the device in the list of
       devices.

       Index numbers start from 0.  The named  device  must  exist,  for  example  as  a  string  returned  from
       "guestfs_list_devices".

       See also "guestfs_list_devices", "guestfs_part_to_dev", "guestfs_device_name".

       On error this function returns -1.

       (Added in 1.19.7)

   <b>guestfs_device_name</b>
        char *
        guestfs_device_name (guestfs_h *g,
                             int index);

       This  function  takes  a  device  index and returns the device name.  For example index 0 will return the
       string "/dev/sda".

       The drive index must have been added to the handle.

       See also "guestfs_list_devices", "guestfs_part_to_dev", "guestfs_device_index".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.49.1)

   <b>guestfs_df</b>
        char *
        guestfs_df (guestfs_h *g);

       This command runs the <b><a href="../man1/df.1.html">df</a></b>(1) command to report disk space used.

       This command is mostly useful for interactive sessions.  It is <u>not</u> intended that you  try  to  parse  the
       output string.  Use "guestfs_statvfs" from programs.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.54)

   <b>guestfs_df_h</b>
        char *
        guestfs_df_h (guestfs_h *g);

       This command runs the "df -h" command to report disk space used in human-readable format.

       This  command  is  mostly  useful for interactive sessions.  It is <u>not</u> intended that you try to parse the
       output string.  Use "guestfs_statvfs" from programs.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.54)

   <b>guestfs_disk_create</b>
        int
        guestfs_disk_create (guestfs_h *g,
                             const char *filename,
                             const char *format,
                             int64_t size,
                             ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_DISK_CREATE_BACKINGFILE, const char *backingfile,
        GUESTFS_DISK_CREATE_BACKINGFORMAT, const char *backingformat,
        GUESTFS_DISK_CREATE_PREALLOCATION, const char *preallocation,
        GUESTFS_DISK_CREATE_COMPAT, const char *compat,
        GUESTFS_DISK_CREATE_CLUSTERSIZE, int clustersize,

       Create  a blank disk image called <u>filename</u> (a host file) with format "format" (usually "raw" or "qcow2").
       The size is "size" bytes.

       If used with the optional "backingfile" parameter, then a snapshot is created on top of the backing file.
       In this case, "size" must be passed as -1.  The size of the snapshot is the  same  as  the  size  of  the
       backing  file,  which  is  discovered  automatically.  You are encouraged to also pass "backingformat" to
       describe the format of "backingfile".

       If <u>filename</u> refers to a block device, then the device is formatted.  The "size" is  ignored  since  block
       devices have an intrinsic size.

       The other optional parameters are:

       "preallocation"
           If format is "raw", then this can be either "off" (or "sparse") or "full" to create a sparse or fully
           allocated file respectively.  The default is "off".

           If  format  is  "qcow2",  then  this can be "off" (or "sparse"), "metadata" or "full".  Preallocating
           metadata can be faster when doing lots of writes, but uses more space.  The default is "off".

       "compat"
           "qcow2" only: Pass the string 1.1 to use the advanced qcow2 format supported by qemu ≥ 1.1.

       "clustersize"
           "qcow2" only: Change the qcow2 cluster size.  The default is 65536 (bytes) and this  setting  may  be
           any power of two between 512 and 2097152.

       Note   that   this   call   does   not   add  the  new  disk  to  the  handle.   You  may  need  to  call
       "guestfs_add_drive_opts" separately.

       This function returns 0 on success or -1 on error.

       (Added in 1.25.31)

   <b>guestfs_disk_create_va</b>
        int
        guestfs_disk_create_va (guestfs_h *g,
                                const char *filename,
                                const char *format,
                                int64_t size,
                                va_list args);

       This is the "va_list variant" of "guestfs_disk_create".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_disk_create_argv</b>
        int
        guestfs_disk_create_argv (guestfs_h *g,
                                  const char *filename,
                                  const char *format,
                                  int64_t size,
                                  const struct guestfs_disk_create_argv *optargs);

       This is the "argv variant" of "guestfs_disk_create".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_disk_format</b>
        char *
        guestfs_disk_format (guestfs_h *g,
                             const char *filename);

       Detect and return the format of the disk image called <u>filename</u>.  <u>filename</u> can also be a host device, etc.
       If the format of the image could not be detected, then "unknown" is returned.

       Note that detecting the disk format can be insecure under some circumstances.  See "CVE-2010-3851".

       See also: "DISK IMAGE FORMATS"

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.19.38)

   <b>guestfs_disk_has_backing_file</b>
        int
        guestfs_disk_has_backing_file (guestfs_h *g,
                                       const char *filename);

       Detect and return whether the disk image <u>filename</u> has a backing file.

       Note that detecting disk features can be insecure under some circumstances.  See "CVE-2010-3851".

       This function returns a C truth value on success or -1 on error.

       (Added in 1.19.39)

   <b>guestfs_disk_virtual_size</b>
        int64_t
        guestfs_disk_virtual_size (guestfs_h *g,
                                   const char *filename);

       Detect and return the virtual size in bytes of the disk image called <u>filename</u>.

       Note that detecting disk features can be insecure under some circumstances.  See "CVE-2010-3851".

       On error this function returns -1.

       (Added in 1.19.39)

   <b>guestfs_dmesg</b>
        char *
        guestfs_dmesg (guestfs_h *g);

       This returns the kernel messages (<b><a href="../man1/dmesg.1.html">dmesg</a></b>(1) output) from the guest kernel.  This is sometimes  useful  for
       extended debugging of problems.

       Another  way  to  get the same information is to enable verbose messages with "guestfs_set_verbose" or by
       setting the environment variable "LIBGUESTFS_DEBUG=1" before running the program.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.18)

   <b>guestfs_download</b>
        int
        guestfs_download (guestfs_h *g,
                          const char *remotefilename,
                          const char *filename);

       Download file <u>remotefilename</u> and save it as <u>filename</u> on the local machine.

       <u>filename</u> can also be a named pipe.

       See also "guestfs_upload", "guestfs_cat".

       This function returns 0 on success or -1 on error.

       This long-running command can generate progress notification messages so that the caller  can  display  a
       progress  bar  or  indicator.   To  receive  these  messages,  the  caller must register a progress event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.0.2)

   <b>guestfs_download_blocks</b>
        int
        guestfs_download_blocks (guestfs_h *g,
                                 const char *device,
                                 int64_t start,
                                 int64_t stop,
                                 const char *filename,
                                 ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_DOWNLOAD_BLOCKS_UNALLOCATED, int unallocated,

       Download  the data units from <u>start</u> address to <u>stop</u> from the disk partition (eg. <u>/dev/sda1</u>) and save them
       as <u>filename</u> on the local machine.

       The use of this API on sparse disk image formats such as QCOW, may  result  in  large  zero-filled  files
       downloaded on the host.

       The  size  of  a  data unit varies across filesystem implementations.  On NTFS filesystems data units are
       referred as clusters while on ExtX ones they are referred as fragments.

       If the optional "unallocated" flag is true (default is  false),  only  the  unallocated  blocks  will  be
       extracted.   This  is useful to detect hidden data or to retrieve deleted files which data units have not
       been overwritten yet.

       This function returns 0 on success or -1 on error.

       This long-running command can generate progress notification messages so that the caller  can  display  a
       progress  bar  or  indicator.   To  receive  these  messages,  the  caller must register a progress event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       This function depends on the feature "sleuthkit".  See also "guestfs_feature_available".

       (Added in 1.33.45)

   <b>guestfs_download_blocks_va</b>
        int
        guestfs_download_blocks_va (guestfs_h *g,
                                    const char *device,
                                    int64_t start,
                                    int64_t stop,
                                    const char *filename,
                                    va_list args);

       This is the "va_list variant" of "guestfs_download_blocks".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_download_blocks_argv</b>
        int
        guestfs_download_blocks_argv (guestfs_h *g,
                                      const char *device,
                                      int64_t start,
                                      int64_t stop,
                                      const char *filename,
                                      const struct guestfs_download_blocks_argv *optargs);

       This is the "argv variant" of "guestfs_download_blocks".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_download_inode</b>
        int
        guestfs_download_inode (guestfs_h *g,
                                const char *device,
                                int64_t inode,
                                const char *filename);

       Download a file given its inode from the disk partition (eg. <u>/dev/sda1</u>) and save it as  <u>filename</u>  on  the
       local machine.

       It is not required to mount the disk to run this command.

       The command is capable of downloading deleted or inaccessible files.

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       This function depends on the feature "sleuthkit".  See also "guestfs_feature_available".

       (Added in 1.33.14)

   <b>guestfs_download_offset</b>
        int
        guestfs_download_offset (guestfs_h *g,
                                 const char *remotefilename,
                                 const char *filename,
                                 int64_t offset,
                                 int64_t size);

       Download file <u>remotefilename</u> and save it as <u>filename</u> on the local machine.

       <u>remotefilename</u>  is  read  for  "size"  bytes starting at "offset" (this region must be within the file or
       device).

       Note that there is no limit on the amount of data that can be downloaded  with  this  call,  unlike  with
       "guestfs_pread", and this call always reads the full amount unless an error occurs.

       See also "guestfs_download", "guestfs_pread".

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.5.17)

   <b>guestfs_drop_caches</b>
        int
        guestfs_drop_caches (guestfs_h *g,
                             int whattodrop);

       This  instructs the guest kernel to drop its page cache, and/or dentries and inode caches.  The parameter
       "whattodrop" tells the kernel what precisely to drop, see https://linux-mm.org/Drop_Caches

       Setting "whattodrop" to 3 should drop everything.

       This automatically calls <b><a href="../man2/sync.2.html">sync</a></b>(2) before the operation, so that the maximum guest memory is freed.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.18)

   <b>guestfs_du</b>
        int64_t
        guestfs_du (guestfs_h *g,
                    const char *path);

       This command runs the "du -s" command to estimate file space usage for "path".

       "path" can be a file or a directory.  If "path" is a directory then the estimate includes the contents of
       the directory and all subdirectories (recursively).

       The result is the estimated size in <u>kilobytes</u> (ie. units of 1024 bytes).

       On error this function returns -1.

       This long-running command can generate progress notification messages so that the caller  can  display  a
       progress  bar  or  indicator.   To  receive  these  messages,  the  caller must register a progress event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.0.54)

   <b>guestfs_e2fsck</b>
        int
        guestfs_e2fsck (guestfs_h *g,
                        const char *device,
                        ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_E2FSCK_CORRECT, int correct,
        GUESTFS_E2FSCK_FORCEALL, int forceall,

       This runs the ext2/ext3 filesystem checker on "device".  It can take the following optional arguments:

       "correct"
           Automatically  repair  the  file  system.  This  option  will  cause  e2fsck to automatically fix any
           filesystem problems that can be safely fixed without human intervention.

           This option may not be specified at the same time as the "forceall" option.

       "forceall"
           Assume an answer of ‘yes’ to all questions; allows e2fsck to be used non-interactively.

           This option may not be specified at the same time as the "correct" option.

       This function returns 0 on success or -1 on error.

       (Added in 1.15.17)

   <b>guestfs_e2fsck_va</b>
        int
        guestfs_e2fsck_va (guestfs_h *g,
                           const char *device,
                           va_list args);

       This is the "va_list variant" of "guestfs_e2fsck".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_e2fsck_argv</b>
        int
        guestfs_e2fsck_argv (guestfs_h *g,
                             const char *device,
                             const struct guestfs_e2fsck_argv *optargs);

       This is the "argv variant" of "guestfs_e2fsck".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_e2fsck_f</b>
        int
        guestfs_e2fsck_f (guestfs_h *g,
                          const char *device);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_e2fsck" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This  runs "e2fsck -p -f device", ie. runs the ext2/ext3 filesystem checker on "device", noninteractively
       (<u>-p</u>), even if the filesystem appears to be clean (<u>-f</u>).

       This function returns 0 on success or -1 on error.

       (Added in 1.0.29)

   <b>guestfs_echo_daemon</b>
        char *
        guestfs_echo_daemon (guestfs_h *g,
                             char *const *words);

       This command concatenates the list of "words" passed with single spaces  between  them  and  returns  the
       resulting string.

       You can use this command to test the connection through to the daemon.

       See also "guestfs_ping_daemon".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.69)

   <b>guestfs_egrep</b>
        char **
        guestfs_egrep (guestfs_h *g,
                       const char *regex,
                       const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_grep" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This calls the external <b><a href="../man1/egrep.1.html">egrep</a></b>(1) program and returns the matching lines.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

   <b>guestfs_egrepi</b>
        char **
        guestfs_egrepi (guestfs_h *g,
                        const char *regex,
                        const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_grep" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This calls the external "egrep -i" program and returns the matching lines.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because of the message protocol, there is a transfer  limit  of  somewhere  between  2MB  and  4MB.   See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

   <b>guestfs_equal</b>
        int
        guestfs_equal (guestfs_h *g,
                       const char *file1,
                       const char *file2);

       This  compares the two files <u>file1</u> and <u>file2</u> and returns true if their content is exactly equal, or false
       otherwise.

       The external <b><a href="../man1/cmp.1.html">cmp</a></b>(1) program is used for the comparison.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.0.18)

   <b>guestfs_exists</b>
        int
        guestfs_exists (guestfs_h *g,
                        const char *path);

       This returns "true" if and only if there is a file, directory (or anything) with the given "path" name.

       See also "guestfs_is_file", "guestfs_is_dir", "guestfs_stat".

       This function returns a C truth value on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_extlinux</b>
        int
        guestfs_extlinux (guestfs_h *g,
                          const char *directory);

       Install the SYSLINUX bootloader on the device mounted  at  <u>directory</u>.   Unlike  "guestfs_syslinux"  which
       requires a FAT filesystem, this can be used on an ext2/3/4 or btrfs filesystem.

       The <u>directory</u> parameter can be either a mountpoint, or a directory within the mountpoint.

       You  also  have  to mark the partition as "active" ("guestfs_part_set_bootable") and a Master Boot Record
       must be installed (eg. using "guestfs_pwrite_device") on  the  first  sector  of  the  whole  disk.   The
       SYSLINUX  package comes with some suitable Master Boot Records.  See the <b><a href="../man1/extlinux.1.html">extlinux</a></b>(1) man page for further
       information.

       Additional configuration can be supplied to SYSLINUX by  placing  a  file  called  <u>extlinux.conf</u>  on  the
       filesystem under <u>directory</u>.  For further information about the contents of this file, see <b><a href="../man1/extlinux.1.html">extlinux</a></b>(1).

       See also "guestfs_syslinux".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "extlinux".  See also "guestfs_feature_available".

       (Added in 1.21.27)

   <b>guestfs_f2fs_expand</b>
        int
        guestfs_f2fs_expand (guestfs_h *g,
                             const char *device);

       This expands a f2fs filesystem to match the size of the underlying device.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "f2fs".  See also "guestfs_feature_available".

       (Added in 1.39.3)

   <b>guestfs_fallocate</b>
        int
        guestfs_fallocate (guestfs_h *g,
                           const char *path,
                           int len);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_fallocate64" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This command preallocates a file (containing zero bytes) named "path" of size "len" bytes.  If  the  file
       exists already, it is overwritten.

       Do  not  confuse  this with the guestfish-specific "alloc" command which allocates a file in the host and
       attaches it as a device.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_fallocate64</b>
        int
        guestfs_fallocate64 (guestfs_h *g,
                             const char *path,
                             int64_t len);

       This command preallocates a file (containing zero bytes) named "path" of size "len" bytes.  If  the  file
       exists already, it is overwritten.

       Note   that   this   call   allocates   disk   blocks  for  the  file.   To  create  a  sparse  file  use
       "guestfs_truncate_size" instead.

       The deprecated call "guestfs_fallocate" does the same, but owing to an oversight it only allowed  30  bit
       lengths to be specified, effectively limiting the maximum size of files created through that call to 1GB.

       Do  not confuse this with the guestfish-specific "alloc" and "sparse" commands which create a file in the
       host and attach it as a device.

       This function returns 0 on success or -1 on error.

       (Added in 1.3.17)

   <b>guestfs_feature_available</b>
        int
        guestfs_feature_available (guestfs_h *g,
                                   char *const *groups);

       This is the same as "guestfs_available", but unlike that call it  returns  a  simple  true/false  boolean
       result,  instead  of  throwing  an  exception  if  a  feature  is not found.  For other documentation see
       "guestfs_available".

       This function returns a C truth value on success or -1 on error.

       (Added in 1.21.26)

   <b>guestfs_fgrep</b>
        char **
        guestfs_fgrep (guestfs_h *g,
                       const char *pattern,
                       const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_grep" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This calls the external <b><a href="../man1/fgrep.1.html">fgrep</a></b>(1) program and returns the matching lines.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because of the message protocol, there is a transfer  limit  of  somewhere  between  2MB  and  4MB.   See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

   <b>guestfs_fgrepi</b>
        char **
        guestfs_fgrepi (guestfs_h *g,
                        const char *pattern,
                        const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_grep" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This calls the external "fgrep -i" program and returns the matching lines.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

   <b>guestfs_file</b>
        char *
        guestfs_file (guestfs_h *g,
                      const char *path);

       This call uses the standard <b><a href="../man1/file.1.html">file</a></b>(1) command to determine the type or contents of the file.

       This call will also transparently look inside various types of compressed file.

       The filename is not prepended to the output (like the file command <u>-b</u> option).

       The output depends on the output of the underlying <b><a href="../man1/file.1.html">file</a></b>(1) command and it can change in  future  in  ways
       beyond our control.  In other words, the output is not guaranteed by the ABI.

       See  also:  <b><a href="../man1/file.1.html">file</a></b>(1), "guestfs_vfs_type", "guestfs_lstat", "guestfs_is_file", "guestfs_is_blockdev" (etc),
       "guestfs_is_zero".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.9.1)

   <b>guestfs_file_architecture</b>
        char *
        guestfs_file_architecture (guestfs_h *g,
                                   const char *filename);

       This detects the architecture of the binary <u>filename</u>, and returns it if known.

       Currently defined architectures are:

       "aarch64"
           64 bit ARM.

       "arm"
           32 bit ARM.

       "i386"
           This string is returned for all 32 bit i386, i486, i586, i686 binaries irrespective  of  the  precise
           processor requirements of the binary.

       "ia64"
           Intel Itanium.

       "ppc"
           32 bit Power PC.

       "ppc64"
           64 bit Power PC (big endian).

       "ppc64le"
           64 bit Power PC (little endian).

       "loongarch64"
           64 bit LoongArch64 (little endian).

       "riscv32"
       "riscv64"
       "riscv128"
           RISC-V 32-, 64- or 128-bit variants.

       "s390"
           31 bit IBM S/390.

       "s390x"
           64 bit IBM S/390.

       "sparc"
           32 bit SPARC.

       "sparc64"
           64 bit SPARC V9 and above.

       "x86_64"
           64 bit x86-64.

       Libguestfs may return other architecture strings in future.

       The function works on at least the following types of files:

       •   many types of Un*x and Linux binary

       •   many types of Un*x and Linux shared library

       •   Windows Win32 and Win64 binaries

       •   Windows Win32 and Win64 DLLs

           Win32 binaries and DLLs return "i386".

           Win64 binaries and DLLs return "x86_64".

       •   Linux kernel modules

       •   Linux new-style initrd images

       •   some non-x86 Linux vmlinuz kernels

       What it can't do currently:

       •   static libraries (libfoo.a)

       •   Linux old-style initrd as compressed ext2 filesystem (RHEL 3)

       •   x86 Linux vmlinuz kernels

           x86  vmlinuz  images  (bzImage  format)  consist  of  a  mix of 16-, 32- and compressed code, and are
           horribly hard to unpack.  If you want to find the architecture of a kernel, use the  architecture  of
           the associated initrd or kernel module(s) instead.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.5.3)

   <b>guestfs_filesize</b>
        int64_t
        guestfs_filesize (guestfs_h *g,
                          const char *file);

       This command returns the size of <u>file</u> in bytes.

       To get other stats about a file, use "guestfs_stat", "guestfs_lstat", "guestfs_is_dir", "guestfs_is_file"
       etc.  To get the size of block devices, use "guestfs_blockdev_getsize64".

       On error this function returns -1.

       (Added in 1.0.82)

   <b>guestfs_filesystem_available</b>
        int
        guestfs_filesystem_available (guestfs_h *g,
                                      const char *filesystem);

       Check  whether libguestfs supports the named filesystem.  The argument "filesystem" is a filesystem name,
       such as "ext3".

       You must call "guestfs_launch" before using this command.

       This is mainly useful as a negative test.  If this returns  true,  it  doesn't  mean  that  a  particular
       filesystem  can  be  created  or mounted, since filesystems can fail for other reasons such as it being a
       later version of the filesystem, or having incompatible features, or lacking the right mkfs.&lt;<u>fs</u>&gt; tool.

       See also "guestfs_available", "guestfs_feature_available", "AVAILABILITY".

       This function returns a C truth value on success or -1 on error.

       (Added in 1.19.5)

   <b>guestfs_filesystem_walk</b>
        struct guestfs_tsk_dirent_list *
        guestfs_filesystem_walk (guestfs_h *g,
                                 const char *device);

       Walk through the internal structures of a disk partition (eg. <u>/dev/sda1</u>) in order to return a list of all
       the files and directories stored within.

       It is not necessary to mount the disk partition to run this command.

       All entries in the filesystem are returned. This function can list deleted  or  unaccessible  files.  The
       entries are <u>not</u> sorted.

       The "tsk_dirent" structure contains the following fields.

       "tsk_inode"
           Filesystem reference number of the node. It might be 0 if the node has been deleted.

       "tsk_type"
           Basic file type information.  See below for a detailed list of values.

       "tsk_size"
           File size in bytes. It might be -1 if the node has been deleted.

       "tsk_name"
           The file path relative to its directory.

       "tsk_flags"
           Bitfield  containing  extra  information  regarding  the  entry.   It  contains the logical OR of the
           following values:

           0x0001
               If set to 1, the file is allocated and visible within the filesystem.  Otherwise,  the  file  has
               been  deleted.  Under certain circumstances, the function "download_inode" can be used to recover
               deleted files.

           0x0002
               Filesystem such as NTFS and Ext2 or greater, separate the file name from the metadata  structure.
               The  bit  is set to 1 when the file name is in an unallocated state and the metadata structure is
               in an allocated one.  This generally implies the metadata has been reallocated  to  a  new  file.
               Therefore,  information  such  as  file  type, file size, timestamps, number of links and symlink
               target might not correspond with the ones of the original deleted entry.

           0x0004
               The bit is set to 1 when the file is  compressed  using  filesystem  native  compression  support
               (NTFS). The API is not able to detect application level compression.

       "tsk_atime_sec"
       "tsk_atime_nsec"
       "tsk_mtime_sec"
       "tsk_mtime_nsec"
       "tsk_ctime_sec"
       "tsk_ctime_nsec"
       "tsk_crtime_sec"
       "tsk_crtime_nsec"
           Respectively,  access,  modification,  last status change and creation time in Unix format in seconds
           and nanoseconds.

       "tsk_nlink"
           Number of file names pointing to this entry.

       "tsk_link"
           If the entry is a symbolic link, this field will contain the path to the target file.

       The "tsk_type" field will contain one of the following characters:

       'b' Block special

       'c' Char special

       'd' Directory

       'f' FIFO (named pipe)

       'l' Symbolic link

       'r' Regular file

       's' Socket

       'h' Shadow inode (Solaris)

       'w' Whiteout inode (BSD)

       'u' Unknown file type

       This function returns a "struct guestfs_tsk_dirent_list *", or NULL if there was an  error.   <u>The</u>  <u>caller</u>
       <u>must</u> <u>call</u> <u>"guestfs_free_tsk_dirent_list"</u> <u>after</u> <u>use</u>.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       This function depends on the feature "libtsk".  See also "guestfs_feature_available".

       (Added in 1.33.39)

   <b>guestfs_fill</b>
        int
        guestfs_fill (guestfs_h *g,
                      int c,
                      int len,
                      const char *path);

       This  command  creates a new file called "path".  The initial content of the file is "len" octets of "c",
       where "c" must be a number in the range "[0..255]".

       To fill a file with zero bytes (sparsely), it is much more efficient to use "guestfs_truncate_size".   To
       create a file with a pattern of repeating bytes use "guestfs_fill_pattern".

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.0.79)

   <b>guestfs_fill_dir</b>
        int
        guestfs_fill_dir (guestfs_h *g,
                          const char *dir,
                          int nr);

       This function, useful for testing filesystems, creates "nr" empty files in the directory "dir" with names
       00000000 through "nr-1" (ie. each file name is 8 digits long padded with zeroes).

       This function returns 0 on success or -1 on error.

       (Added in 1.19.32)

   <b>guestfs_fill_pattern</b>
        int
        guestfs_fill_pattern (guestfs_h *g,
                              const char *pattern,
                              int len,
                              const char *path);

       This  function  is  like  "guestfs_fill" except that it creates a new file of length "len" containing the
       repeating pattern of bytes in "pattern".  The pattern is truncated if necessary to ensure the  length  of
       the file is exactly "len" bytes.

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.3.12)

   <b>guestfs_find</b>
        char **
        guestfs_find (guestfs_h *g,
                      const char *directory);

       This  command lists out all files and directories, recursively, starting at <u>directory</u>.  It is essentially
       equivalent to running the shell command "find directory -print" but some post-processing happens  on  the
       output, described below.

       This returns a list of strings <u>without</u> <u>any</u> <u>prefix</u>.  Thus if the directory structure was:

        /tmp/a
        /tmp/b
        /tmp/c/d

       then the returned list from "guestfs_find" <u><a href="file:/tmp">/tmp</a></u> would be 4 elements:

        a
        b
        c
        c/d

       If <u>directory</u> is not a directory, then this command returns an error.

       The returned list is sorted.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.0.27)

   <b>guestfs_find0</b>
        int
        guestfs_find0 (guestfs_h *g,
                       const char *directory,
                       const char *files);

       This command lists out all files  and  directories,  recursively,  starting  at  <u>directory</u>,  placing  the
       resulting list in the external file called <u>files</u>.

       This command works the same way as "guestfs_find" with the following exceptions:

       •   The resulting list is written to an external file.

       •   Items (filenames) in the result are separated by "\0" characters.  See <b><a href="../man1/find.1.html">find</a></b>(1) option <u>-print0</u>.

       •   The result list is not sorted.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.74)

   <b>guestfs_find_inode</b>
        struct guestfs_tsk_dirent_list *
        guestfs_find_inode (guestfs_h *g,
                            const char *device,
                            int64_t inode);

       Searches all the entries associated with the given inode.

       For  each  entry, a "tsk_dirent" structure is returned.  See "filesystem_walk" for more information about
       "tsk_dirent" structures.

       This function returns a "struct guestfs_tsk_dirent_list *", or NULL if there was an  error.   <u>The</u>  <u>caller</u>
       <u>must</u> <u>call</u> <u>"guestfs_free_tsk_dirent_list"</u> <u>after</u> <u>use</u>.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       This function depends on the feature "libtsk".  See also "guestfs_feature_available".

       (Added in 1.35.6)

   <b>guestfs_findfs_label</b>
        char *
        guestfs_findfs_label (guestfs_h *g,
                              const char *label);

       This  command  searches  the  filesystems  and  returns  the  one which has the given label.  An error is
       returned if no such filesystem can be found.

       To find the label of a filesystem, use "guestfs_vfs_label".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.5.3)

   <b>guestfs_findfs_partlabel</b>
        char *
        guestfs_findfs_partlabel (guestfs_h *g,
                                  const char *label);

       This command searches the partitions and returns the one which has the given label.  An error is returned
       if no such partition can be found.

       To find the label of a partition, use "guestfs_blkid" ("PART_ENTRY_NAME").

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.53.5)

   <b>guestfs_findfs_partuuid</b>
        char *
        guestfs_findfs_partuuid (guestfs_h *g,
                                 const char *uuid);

       This command searches the partitions and returns the one which has the given partition UUID.  An error is
       returned if no such partition can be found.

       To find the UUID of a partition, use "guestfs_blkid" ("PART_ENTRY_UUID").

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.53.5)

   <b>guestfs_findfs_uuid</b>
        char *
        guestfs_findfs_uuid (guestfs_h *g,
                             const char *uuid);

       This command searches the filesystems and returns the one which has the given UUID.  An error is returned
       if no such filesystem can be found.

       To find the UUID of a filesystem, use "guestfs_vfs_uuid".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.5.3)

   <b>guestfs_fsck</b>
        int
        guestfs_fsck (guestfs_h *g,
                      const char *fstype,
                      const char *device);

       This runs the filesystem checker (fsck) on "device" which should have filesystem type "fstype".

       The returned integer is the status.  See <b><a href="../man8/fsck.8.html">fsck</a></b>(8) for the list of status codes from "fsck".

       Notes:

       •   Multiple status codes can be summed together.

       •   A non-zero return code can mean  "success",  for  example  if  errors  have  been  corrected  on  the
           filesystem.

       •   Checking or repairing NTFS volumes is not supported (by linux-ntfs).

       This command is entirely equivalent to running "fsck -a -t fstype device".

       On error this function returns -1.

       (Added in 1.0.16)

   <b>guestfs_fstrim</b>
        int
        guestfs_fstrim (guestfs_h *g,
                        const char *mountpoint,
                        ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_FSTRIM_OFFSET, int64_t offset,
        GUESTFS_FSTRIM_LENGTH, int64_t length,
        GUESTFS_FSTRIM_MINIMUMFREEEXTENT, int64_t minimumfreeextent,

       Trim the free space in the filesystem mounted on "mountpoint".  The  filesystem  must  be  mounted  read-
       write.

       The  filesystem  contents  are  not affected, but any free space in the filesystem is "trimmed", that is,
       given back to the host device, thus making disk images more sparse, allowing unused space in qcow2  files
       to be reused, etc.

       This  operation requires support in libguestfs, the mounted filesystem, the host filesystem, qemu and the
       host kernel.  If this support isn't present it may give an error or even appear to run but do nothing.

       In the case where the kernel vfs driver does not support trimming, this call will fail with errno set  to
       "ENOTSUP".  Currently this happens when trying to trim FAT filesystems.

       See  also "guestfs_zero_free_space".  That is a slightly different operation that turns free space in the
       filesystem into zeroes.  It is valid to  call  "guestfs_fstrim"  either  instead  of,  or  after  calling
       "guestfs_zero_free_space".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "fstrim".  See also "guestfs_feature_available".

       (Added in 1.19.6)

   <b>guestfs_fstrim_va</b>
        int
        guestfs_fstrim_va (guestfs_h *g,
                           const char *mountpoint,
                           va_list args);

       This is the "va_list variant" of "guestfs_fstrim".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_fstrim_argv</b>
        int
        guestfs_fstrim_argv (guestfs_h *g,
                             const char *mountpoint,
                             const struct guestfs_fstrim_argv *optargs);

       This is the "argv variant" of "guestfs_fstrim".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_get_append</b>
        const char *
        guestfs_get_append (guestfs_h *g);

       Return the additional kernel options which are added to the libguestfs appliance kernel command line.

       If "NULL" then no options are added.

       This function returns a string which may be NULL.  There is no way to return an error from this function.
       The string is owned by the guest handle and must <u>not</u> be freed.

       (Added in 1.0.26)

   <b>guestfs_get_attach_method</b>
        char *
        guestfs_get_attach_method (guestfs_h *g);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_get_backend" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       Return the current backend.

       See "guestfs_set_backend" and "BACKEND".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.9.8)

   <b>guestfs_get_autosync</b>
        int
        guestfs_get_autosync (guestfs_h *g);

       Get the autosync flag.

       This function returns a C truth value on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_get_backend</b>
        char *
        guestfs_get_backend (guestfs_h *g);

       Return the current backend.

       This handle property was previously called the "attach method".

       See "guestfs_set_backend" and "BACKEND".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.21.26)

   <b>guestfs_get_backend_setting</b>
        char *
        guestfs_get_backend_setting (guestfs_h *g,
                                     const char *name);

       Find a backend setting string which is either "name" or begins with "name=".  If "name", this returns the
       string "1".  If "name=", this returns the part after the equals sign (which may be an empty string).

       If no such setting is found, this function throws an error.  The errno (see "guestfs_last_errno") will be
       "ESRCH" in this case.

       See "BACKEND", "BACKEND SETTINGS".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.27.2)

   <b>guestfs_get_backend_settings</b>
        char **
        guestfs_get_backend_settings (guestfs_h *g);

       Return the current backend settings.

       This call returns all backend settings strings.  If you want  to  find  a  single  backend  setting,  see
       "guestfs_get_backend_setting".

       See "BACKEND", "BACKEND SETTINGS".

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.25.24)

   <b>guestfs_get_cachedir</b>
        char *
        guestfs_get_cachedir (guestfs_h *g);

       Get the directory used by the handle to store the appliance cache.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.19.58)

   <b>guestfs_get_direct</b>
        int
        guestfs_get_direct (guestfs_h *g);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_internal_get_console_socket" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       Return the direct appliance mode flag.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.0.72)

   <b>guestfs_get_e2attrs</b>
        char *
        guestfs_get_e2attrs (guestfs_h *g,
                             const char *file);

       This returns the file attributes associated with <u>file</u>.

       The  attributes are a set of bits associated with each inode which affect the behaviour of the file.  The
       attributes are returned as a string of letters (described below).  The string may  be  empty,  indicating
       that no file attributes are set for this file.

       These attributes are only present when the file is located on an ext2/3/4 filesystem.  Using this call on
       other filesystem types will result in an error.

       The characters (file attributes) in the returned string are currently:

       'A' When the file is accessed, its atime is not modified.

       'a' The file is append-only.

       'c' The file is compressed on-disk.

       'D' (Directories only.)  Changes to this directory are written synchronously to disk.

       'd' The file is not a candidate for backup (see <b><a href="../man8/dump.8.html">dump</a></b>(8)).

       'E' The file has compression errors.

       'e' The file is using extents.

       'h' The file is storing its blocks in units of the filesystem blocksize instead of sectors.

       'I' (Directories only.)  The directory is using hashed trees.

       'i' The  file  is  immutable.  It cannot be modified, deleted or renamed.  No link can be created to this
           file.

       'j' The file is data-journaled.

       's' When the file is deleted, all its blocks will be zeroed.

       'S' Changes to this file are written synchronously to disk.

       'T' (Directories only.)  This is a hint to the block allocator  that  subdirectories  contained  in  this
           directory  should  be  spread  across  blocks.  If not present, the block allocator will try to group
           subdirectories together.

       't' For a file, this disables tail-merging.  (Not used by upstream implementations of ext2.)

       'u' When the file is deleted, its blocks will be saved, allowing the file to be undeleted.

       'X' The raw contents of the compressed file may be accessed.

       'Z' The compressed file is dirty.

       More file attributes may be added to this list later.  Not all file attributes may be set for  all  kinds
       of files.  For detailed information, consult the <b><a href="../man1/chattr.1.html">chattr</a></b>(1) man page.

       See also "guestfs_set_e2attrs".

       Don't confuse these attributes with extended attributes (see "guestfs_getxattr").

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.17.31)

   <b>guestfs_get_e2generation</b>
        int64_t
        guestfs_get_e2generation (guestfs_h *g,
                                  const char *file);

       This  returns the ext2 file generation of a file.  The generation (which used to be called the "version")
       is a number associated with an inode.  This is most commonly used by NFS servers.

       The generation is only present when the file is located on an ext2/3/4 filesystem.  Using  this  call  on
       other filesystem types will result in an error.

       See "guestfs_set_e2generation".

       On error this function returns -1.

       (Added in 1.17.31)

   <b>guestfs_get_e2label</b>
        char *
        guestfs_get_e2label (guestfs_h *g,
                             const char *device);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_vfs_label" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This returns the ext2/3/4 filesystem label of the filesystem on "device".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.15)

   <b>guestfs_get_e2uuid</b>
        char *
        guestfs_get_e2uuid (guestfs_h *g,
                            const char *device);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_vfs_uuid" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This returns the ext2/3/4 filesystem UUID of the filesystem on "device".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.15)

   <b>guestfs_get_hv</b>
        char *
        guestfs_get_hv (guestfs_h *g);

       Return the current hypervisor binary.

       This is always non-NULL.  If it wasn't set already, then this will return the default qemu binary name.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.23.17)

   <b>guestfs_get_identifier</b>
        const char *
        guestfs_get_identifier (guestfs_h *g);

       Get the handle identifier.  See "guestfs_set_identifier".

       This  function  returns a string, or NULL on error.  The string is owned by the guest handle and must <u>not</u>
       be freed.

       (Added in 1.31.14)

   <b>guestfs_get_libvirt_requested_credential_challenge</b>
        char *
        guestfs_get_libvirt_requested_credential_challenge (guestfs_h *g,
                                                            int index);

       Get the challenge (provided by libvirt) for the "index"'th requested  credential.   If  libvirt  did  not
       provide a challenge, this returns the empty string "".

       See "LIBVIRT AUTHENTICATION" for documentation and example code.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.19.52)

   <b>guestfs_get_libvirt_requested_credential_defresult</b>
        char *
        guestfs_get_libvirt_requested_credential_defresult (guestfs_h *g,
                                                            int index);

       Get the default result (provided by libvirt) for the "index"'th requested credential.  If libvirt did not
       provide a default result, this returns the empty string "".

       See "LIBVIRT AUTHENTICATION" for documentation and example code.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.19.52)

   <b>guestfs_get_libvirt_requested_credential_prompt</b>
        char *
        guestfs_get_libvirt_requested_credential_prompt (guestfs_h *g,
                                                         int index);

       Get the prompt (provided by libvirt) for the "index"'th requested credential.  If libvirt did not provide
       a prompt, this returns the empty string "".

       See "LIBVIRT AUTHENTICATION" for documentation and example code.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.19.52)

   <b>guestfs_get_libvirt_requested_credentials</b>
        char **
        guestfs_get_libvirt_requested_credentials (guestfs_h *g);

       This should only be called during the event callback for events of type "GUESTFS_EVENT_LIBVIRT_AUTH".

       Return  the  list  of  credentials  requested  by  libvirt.   Possible values are a subset of the strings
       provided when you called "guestfs_set_libvirt_supported_credentials".

       See "LIBVIRT AUTHENTICATION" for documentation and example code.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.19.52)

   <b>guestfs_get_memsize</b>
        int
        guestfs_get_memsize (guestfs_h *g);

       This gets the memory size in megabytes allocated to the hypervisor.

       If  "guestfs_set_memsize"  was  not  called on this handle, and if "LIBGUESTFS_MEMSIZE" was not set, then
       this returns the compiled-in default value for memsize.

       For more information on the architecture of libguestfs, see <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

       On error this function returns -1.

       (Added in 1.0.55)

   <b>guestfs_get_network</b>
        int
        guestfs_get_network (guestfs_h *g);

       This returns the enable network flag.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.5.4)

   <b>guestfs_get_path</b>
        const char *
        guestfs_get_path (guestfs_h *g);

       Return the current search path.

       This is always non-NULL.  If it wasn't set already, then this will return the default path.

       This function returns a string, or NULL on error.  The string is owned by the guest handle and  must  <u>not</u>
       be freed.

       (Added in 0.3)

   <b>guestfs_get_pgroup</b>
        int
        guestfs_get_pgroup (guestfs_h *g);

       This returns the process group flag.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.11.18)

   <b>guestfs_get_pid</b>
        int
        guestfs_get_pid (guestfs_h *g);

       Return  the  process  ID  of the hypervisor.  If there is no hypervisor running, then this will return an
       error.

       This is an internal call used for debugging and testing.

       On error this function returns -1.

       (Added in 1.0.56)

   <b>guestfs_get_program</b>
        const char *
        guestfs_get_program (guestfs_h *g);

       Get the program name.  See "guestfs_set_program".

       This function returns a string, or NULL on error.  The string is owned by the guest handle and  must  <u>not</u>
       be freed.

       (Added in 1.21.29)

   <b>guestfs_get_qemu</b>
        const char *
        guestfs_get_qemu (guestfs_h *g);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_get_hv" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       Return the current hypervisor binary (usually qemu).

       This is always non-NULL.  If it wasn't set already, then this will return the default qemu binary name.

       This function returns a string, or NULL on error.  The string is owned by the guest handle and  must  <u>not</u>
       be freed.

       (Added in 1.0.6)

   <b>guestfs_get_recovery_proc</b>
        int
        guestfs_get_recovery_proc (guestfs_h *g);

       Return the recovery process enabled flag.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.0.77)

   <b>guestfs_get_selinux</b>
        int
        guestfs_get_selinux (guestfs_h *g);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_selinux_relabel" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This returns the current setting of the selinux flag which is passed to the appliance at boot time.   See
       "guestfs_set_selinux".

       For more information on the architecture of libguestfs, see <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

       This function returns a C truth value on success or -1 on error.

       (Added in 1.0.67)

   <b>guestfs_get_smp</b>
        int
        guestfs_get_smp (guestfs_h *g);

       This returns the number of virtual CPUs assigned to the appliance.

       On error this function returns -1.

       (Added in 1.13.15)

   <b>guestfs_get_sockdir</b>
        char *
        guestfs_get_sockdir (guestfs_h *g);

       Get the directory used by the handle to store temporary socket and PID files.

       This  is  different  from  "guestfs_get_tmpdir", as we need shorter paths for sockets (due to the limited
       buffers of filenames for UNIX sockets), and "guestfs_get_tmpdir" may be too long for them.   Furthermore,
       sockets  and  PID files must be accessible to such background services started by libguestfs that may not
       have permission to access the temporary directory returned by "guestfs_get_tmpdir".

       The environment variable "XDG_RUNTIME_DIR" controls the default value: If "XDG_RUNTIME_DIR" is set,  then
       that is the default.  Else <u><a href="file:/tmp">/tmp</a></u> is the default.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.33.8)

   <b>guestfs_get_state</b>
        int
        guestfs_get_state (guestfs_h *g);

       This returns the current state as an opaque integer.  This is only useful for printing debug and internal
       error messages.

       For more information on states, see <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

       On error this function returns -1.

       (Added in 1.0.2)

   <b>guestfs_get_tmpdir</b>
        char *
        guestfs_get_tmpdir (guestfs_h *g);

       Get the directory used by the handle to store temporary files.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.19.58)

   <b>guestfs_get_trace</b>
        int
        guestfs_get_trace (guestfs_h *g);

       Return the command trace flag.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.0.69)

   <b>guestfs_get_umask</b>
        int
        guestfs_get_umask (guestfs_h *g);

       Return the current umask.  By default the umask is 022 unless it has been set by calling "guestfs_umask".

       On error this function returns -1.

       (Added in 1.3.4)

   <b>guestfs_get_verbose</b>
        int
        guestfs_get_verbose (guestfs_h *g);

       This returns the verbose messages flag.

       This function returns a C truth value on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_getcon</b>
        char *
        guestfs_getcon (guestfs_h *g);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_selinux_relabel" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This gets the SELinux security context of the daemon.

       See the documentation about SELINUX in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3), and "guestfs_setcon"

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       This function depends on the feature "selinux".  See also "guestfs_feature_available".

       (Added in 1.0.67)

   <b>guestfs_getxattr</b>
        char *
        guestfs_getxattr (guestfs_h *g,
                          const char *path,
                          const char *name,
                          size_t *size_r);

       Get a single extended attribute from file "path" named "name".  This call follows symlinks.  If you  want
       to lookup an extended attribute for the symlink itself, use "guestfs_lgetxattr".

       Normally   it   is   better   to  get  all  extended  attributes  from  a  file  in  one  go  by  calling
       "guestfs_getxattrs".  However some Linux filesystem implementations are buggy and do not provide a way to
       list out attributes.  For these filesystems (notably ntfs-3g) you have to know the names of the  extended
       attributes you want in advance and call this function.

       Extended attribute values are blobs of binary data.  If there is no extended attribute named "name", this
       returns an error.

       See also: "guestfs_getxattrs", "guestfs_lgetxattr", <b><a href="../man5/attr.5.html">attr</a></b>(5).

       This function returns a buffer, or NULL on error.  The size of the returned buffer is written to *size_r.
       <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>buffer</u> <u>after</u> <u>use</u>.

       This function depends on the feature "linuxxattrs".  See also "guestfs_feature_available".

       (Added in 1.7.24)

   <b>guestfs_getxattrs</b>
        struct guestfs_xattr_list *
        guestfs_getxattrs (guestfs_h *g,
                           const char *path);

       This call lists the extended attributes of the file or directory "path".

       At the system call level, this is a combination of the <b><a href="../man2/listxattr.2.html">listxattr</a></b>(2) and <b><a href="../man2/getxattr.2.html">getxattr</a></b>(2) calls.

       See also: "guestfs_lgetxattrs", <b><a href="../man5/attr.5.html">attr</a></b>(5).

       This  function  returns  a "struct guestfs_xattr_list *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>
       <u>call</u> <u>"guestfs_free_xattr_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "linuxxattrs".  See also "guestfs_feature_available".

       (Added in 1.0.59)

   <b>guestfs_glob_expand</b>
        char **
        guestfs_glob_expand (guestfs_h *g,
                             const char *pattern);

       This function is provided for backwards compatibility with earlier versions  of  libguestfs.   It  simply
       calls "guestfs_glob_expand_opts" with no optional arguments.

       (Added in 1.0.50)

   <b>guestfs_glob_expand_opts</b>
        char **
        guestfs_glob_expand_opts (guestfs_h *g,
                                  const char *pattern,
                                  ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_GLOB_EXPAND_OPTS_DIRECTORYSLASH, int directoryslash,

       This command searches for all the pathnames matching "pattern" according to the wildcard expansion  rules
       used by the shell.

       If no paths match, then this returns an empty list (note: not an error).

       It  is  just  a wrapper around the C <b><a href="../man3/glob.3.html">glob</a></b>(3) function with flags "GLOB_MARK|GLOB_BRACE".  See that manual
       page for more details.

       "directoryslash" controls whether use the "GLOB_MARK" flag for <b><a href="../man3/glob.3.html">glob</a></b>(3), and it defaults to true.  It  can
       be explicitly set as off to return no trailing slashes in filenames of directories.

       Notice  that  there  is  no  equivalent  command  for  expanding  a  device  name  (eg.  <u>/dev/sd*</u>).   Use
       "guestfs_list_devices", "guestfs_list_partitions" etc functions instead.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.0.50)

   <b>guestfs_glob_expand_opts_va</b>
        char **
        guestfs_glob_expand_opts_va (guestfs_h *g,
                                     const char *pattern,
                                     va_list args);

       This is the "va_list variant" of "guestfs_glob_expand_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_glob_expand_opts_argv</b>
        char **
        guestfs_glob_expand_opts_argv (guestfs_h *g,
                                       const char *pattern,
                                       const struct guestfs_glob_expand_opts_argv *optargs);

       This is the "argv variant" of "guestfs_glob_expand_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_grep</b>
        char **
        guestfs_grep (guestfs_h *g,
                      const char *regex,
                      const char *path);

       This  function  is  provided  for backwards compatibility with earlier versions of libguestfs.  It simply
       calls "guestfs_grep_opts" with no optional arguments.

       (Added in 1.0.66)

   <b>guestfs_grep_opts</b>
        char **
        guestfs_grep_opts (guestfs_h *g,
                           const char *regex,
                           const char *path,
                           ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_GREP_OPTS_EXTENDED, int extended,
        GUESTFS_GREP_OPTS_FIXED, int fixed,
        GUESTFS_GREP_OPTS_INSENSITIVE, int insensitive,
        GUESTFS_GREP_OPTS_COMPRESSED, int compressed,

       This calls the external <b><a href="../man1/grep.1.html">grep</a></b>(1) program and returns the matching lines.

       The optional flags are:

       "extended"
           Use extended regular expressions.  This is the same as using the <u>-E</u> flag.

       "fixed"
           Match fixed (don't use regular expressions).  This is the same as using the <u>-F</u> flag.

       "insensitive"
           Match case-insensitive.  This is the same as using the <u>-i</u> flag.

       "compressed"
           Use <b><a href="../man1/zgrep.1.html">zgrep</a></b>(1) instead of <b><a href="../man1/grep.1.html">grep</a></b>(1).  This allows the input to be compress- or gzip-compressed.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because of the message protocol, there is a transfer  limit  of  somewhere  between  2MB  and  4MB.   See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

   <b>guestfs_grep_opts_va</b>
        char **
        guestfs_grep_opts_va (guestfs_h *g,
                              const char *regex,
                              const char *path,
                              va_list args);

       This is the "va_list variant" of "guestfs_grep_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_grep_opts_argv</b>
        char **
        guestfs_grep_opts_argv (guestfs_h *g,
                                const char *regex,
                                const char *path,
                                const struct guestfs_grep_opts_argv *optargs);

       This is the "argv variant" of "guestfs_grep_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_grepi</b>
        char **
        guestfs_grepi (guestfs_h *g,
                       const char *regex,
                       const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_grep" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This calls the external "grep -i" program and returns the matching lines.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

   <b>guestfs_grub_install</b>
        int
        guestfs_grub_install (guestfs_h *g,
                              const char *root,
                              const char *device);

       This command installs GRUB 1 (the Grand Unified Bootloader) on "device", with the  root  directory  being
       "root".

       Notes:

       •   There is currently no way in the API to install grub2, which is used by most modern Linux guests.  It
           is possible to run the grub2 command from the guest, although see the caveats in "RUNNING COMMANDS".

       •   This uses <b><a href="../man8/grub-install.8.html">grub-install</a></b>(8) from the host.  Unfortunately grub is not always compatible with itself, so
           this  only  works  in  rather  narrow  circumstances.   Careful  testing  with  each guest version is
           advisable.

       •   If grub-install reports the error "No suitable drive was found in the generated device map."  it  may
           be  that you need to create a <u>/boot/grub/device.map</u> file first that contains the mapping between grub
           device names and Linux device names.  It is usually sufficient to create a file containing:

            (hd0) /dev/vda

           replacing <u>/dev/vda</u> with the name of the installation device.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "grub".  See also "guestfs_feature_available".

       (Added in 1.0.17)

   <b>guestfs_head</b>
        char **
        guestfs_head (guestfs_h *g,
                      const char *path);

       This command returns up to the first 10 lines of a file as a list of strings.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.54)

   <b>guestfs_head_n</b>
        char **
        guestfs_head_n (guestfs_h *g,
                        int nrlines,
                        const char *path);

       If the parameter "nrlines" is a positive number, this returns the  first  "nrlines"  lines  of  the  file
       "path".

       If  the  parameter "nrlines" is a negative number, this returns lines from the file "path", excluding the
       last "nrlines" lines.

       If the parameter "nrlines" is zero, this returns an empty list.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.54)

   <b>guestfs_hexdump</b>
        char *
        guestfs_hexdump (guestfs_h *g,
                         const char *path);

       This runs "hexdump -C" on the given "path".  The result is the human-readable, canonical hex dump of  the
       file.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.22)

   <b>guestfs_hivex_close</b>
        int
        guestfs_hivex_close (guestfs_h *g);

       Close the current hivex handle.

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_commit</b>
        int
        guestfs_hivex_commit (guestfs_h *g,
                              const char *filename);

       Commit (write) changes to the hive.

       If the optional <u>filename</u> parameter is null, then the changes are written back to the same hive  that  was
       opened.   If this is not null then they are written to the alternate filename given and the original hive
       is left untouched.

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_node_add_child</b>
        int64_t
        guestfs_hivex_node_add_child (guestfs_h *g,
                                      int64_t parent,
                                      const char *name);

       Add a child node to "parent" named "name".

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       On error this function returns -1.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_node_children</b>
        struct guestfs_hivex_node_list *
        guestfs_hivex_node_children (guestfs_h *g,
                                     int64_t nodeh);

       Return the list of nodes which are subkeys of "nodeh".

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       This function returns a "struct guestfs_hivex_node_list *", or NULL if there was an  error.   <u>The</u>  <u>caller</u>
       <u>must</u> <u>call</u> <u>"guestfs_free_hivex_node_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_node_delete_child</b>
        int
        guestfs_hivex_node_delete_child (guestfs_h *g,
                                         int64_t nodeh);

       Delete "nodeh", recursively if necessary.

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_node_get_child</b>
        int64_t
        guestfs_hivex_node_get_child (guestfs_h *g,
                                      int64_t nodeh,
                                      const char *name);

       Return  the  child of "nodeh" with the name "name", if it exists.  This can return 0 meaning the name was
       not found.

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       On error this function returns -1.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_node_get_value</b>
        int64_t
        guestfs_hivex_node_get_value (guestfs_h *g,
                                      int64_t nodeh,
                                      const char *key);

       Return the value attached to "nodeh" which has the name "key", if it exists.  This can return  0  meaning
       the key was not found.

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       On error this function returns -1.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_node_name</b>
        char *
        guestfs_hivex_node_name (guestfs_h *g,
                                 int64_t nodeh);

       Return the name of "nodeh".

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_node_parent</b>
        int64_t
        guestfs_hivex_node_parent (guestfs_h *g,
                                   int64_t nodeh);

       Return the parent node of "nodeh".

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       On error this function returns -1.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_node_set_value</b>
        int
        guestfs_hivex_node_set_value (guestfs_h *g,
                                      int64_t nodeh,
                                      const char *key,
                                      int64_t t,
                                      const char *val,
                                      size_t val_size);

       Set  or replace a single value under the node "nodeh".  The "key" is the name, "t" is the type, and "val"
       is the data.

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_node_values</b>
        struct guestfs_hivex_value_list *
        guestfs_hivex_node_values (guestfs_h *g,
                                   int64_t nodeh);

       Return the array of (key, datatype, data) tuples attached to "nodeh".

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       This function returns a "struct guestfs_hivex_value_list *", or NULL if there was an error.   <u>The</u>  <u>caller</u>
       <u>must</u> <u>call</u> <u>"guestfs_free_hivex_value_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_open</b>
        int
        guestfs_hivex_open (guestfs_h *g,
                            const char *filename,
                            ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_HIVEX_OPEN_VERBOSE, int verbose,
        GUESTFS_HIVEX_OPEN_DEBUG, int debug,
        GUESTFS_HIVEX_OPEN_WRITE, int write,
        GUESTFS_HIVEX_OPEN_UNSAFE, int unsafe,

       Open the Windows Registry hive file named <u>filename</u>.  If there was any previous  hivex  handle  associated
       with this guestfs session, then it is closed.

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_open_va</b>
        int
        guestfs_hivex_open_va (guestfs_h *g,
                               const char *filename,
                               va_list args);

       This is the "va_list variant" of "guestfs_hivex_open".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_hivex_open_argv</b>
        int
        guestfs_hivex_open_argv (guestfs_h *g,
                                 const char *filename,
                                 const struct guestfs_hivex_open_argv *optargs);

       This is the "argv variant" of "guestfs_hivex_open".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_hivex_root</b>
        int64_t
        guestfs_hivex_root (guestfs_h *g);

       Return the root node of the hive.

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       On error this function returns -1.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_value_key</b>
        char *
        guestfs_hivex_value_key (guestfs_h *g,
                                 int64_t valueh);

       Return the key (name) field of a (key, datatype, data) tuple.

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_value_string</b>
        char *
        guestfs_hivex_value_string (guestfs_h *g,
                                    int64_t valueh);

       This  calls "guestfs_hivex_value_value" (which returns the data field from a hivex value tuple).  It then
       assumes that the field is a UTF-16LE string and converts the result to UTF-8 (or if this is not possible,
       it returns an error).

       This is useful for reading strings out of the Windows registry.  However it is not foolproof because  the
       registry is not strongly-typed and fields can contain arbitrary or unexpected data.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.37.22)

   <b>guestfs_hivex_value_type</b>
        int64_t
        guestfs_hivex_value_type (guestfs_h *g,
                                  int64_t valueh);

       Return the data type field from a (key, datatype, data) tuple.

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       On error this function returns -1.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_value_utf8</b>
        char *
        guestfs_hivex_value_utf8 (guestfs_h *g,
                                  int64_t valueh);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_hivex_value_string" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This calls "guestfs_hivex_value_value" (which returns the data field from a hivex value tuple).  It  then
       assumes that the field is a UTF-16LE string and converts the result to UTF-8 (or if this is not possible,
       it returns an error).

       This  is useful for reading strings out of the Windows registry.  However it is not foolproof because the
       registry is not strongly-typed and fields can contain arbitrary or unexpected data.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_hivex_value_value</b>
        char *
        guestfs_hivex_value_value (guestfs_h *g,
                                   int64_t valueh,
                                   size_t *size_r);

       Return the data field of a (key, datatype, data) tuple.

       This is a wrapper around the <b><a href="../man3/hivex.3.html">hivex</a></b>(3) call of the same name.

       See also: "guestfs_hivex_value_utf8".

       This function returns a buffer, or NULL on error.  The size of the returned buffer is written to *size_r.
       <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>buffer</u> <u>after</u> <u>use</u>.

       This function depends on the feature "hivex".  See also "guestfs_feature_available".

       (Added in 1.19.35)

   <b>guestfs_initrd_cat</b>
        char *
        guestfs_initrd_cat (guestfs_h *g,
                            const char *initrdpath,
                            const char *filename,
                            size_t *size_r);

       This command unpacks the file <u>filename</u> from the initrd file called  <u>initrdpath</u>.   The  filename  must  be
       given <u>without</u> the initial <u>/</u> character.

       For  example, in guestfish you could use the following command to examine the boot script (usually called
       <u>/init</u>) contained in a Linux initrd or initramfs image:

        initrd-cat /boot/initrd-&lt;version&gt;.img init

       See also "guestfs_initrd_list".

       This function returns a buffer, or NULL on error.  The size of the returned buffer is written to *size_r.
       <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>buffer</u> <u>after</u> <u>use</u>.

       Because of the message protocol, there is a transfer  limit  of  somewhere  between  2MB  and  4MB.   See
       "PROTOCOL LIMITS".

       (Added in 1.0.84)

   <b>guestfs_initrd_list</b>
        char **
        guestfs_initrd_list (guestfs_h *g,
                             const char *path);

       This command lists out files contained in an initrd.

       The files are listed without any initial <u>/</u> character.  The files are listed in the order they appear (not
       necessarily alphabetical).  Directory names are listed as separate items.

       Old  Linux  kernels  (2.4  and earlier) used a compressed ext2 filesystem as initrd.  We <u>only</u> support the
       newer initramfs format (compressed cpio files).

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.0.54)

   <b>guestfs_inotify_add_watch</b>
        int64_t
        guestfs_inotify_add_watch (guestfs_h *g,
                                   const char *path,
                                   int mask);

       Watch "path" for the events listed in "mask".

       Note  that  if  "path"  is  a  directory then events within that directory are watched, but this does <u>not</u>
       happen recursively (in subdirectories).

       Note for non-C or non-Linux callers: the inotify events are defined by  the  Linux  kernel  ABI  and  are
       listed in <u>/usr/include/sys/inotify.h</u>.

       On error this function returns -1.

       This function depends on the feature "inotify".  See also "guestfs_feature_available".

       (Added in 1.0.66)

   <b>guestfs_inotify_close</b>
        int
        guestfs_inotify_close (guestfs_h *g);

       This  closes  the  inotify  handle  which was previously opened by inotify_init.  It removes all watches,
       throws away any pending events, and deallocates all resources.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "inotify".  See also "guestfs_feature_available".

       (Added in 1.0.66)

   <b>guestfs_inotify_files</b>
        char **
        guestfs_inotify_files (guestfs_h *g);

       This function is a helpful wrapper around "guestfs_inotify_read" which just returns a list  of  pathnames
       of objects that were touched.  The returned pathnames are sorted and deduplicated.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "inotify".  See also "guestfs_feature_available".

       (Added in 1.0.66)

   <b>guestfs_inotify_init</b>
        int
        guestfs_inotify_init (guestfs_h *g,
                              int maxevents);

       This command creates a new inotify handle.  The inotify subsystem can be  used  to  notify  events  which
       happen to objects in the guest filesystem.

       "maxevents"   is   the   maximum   number   of   events   which  will  be  queued  up  between  calls  to
       "guestfs_inotify_read" or "guestfs_inotify_files".   If  this  is  passed  as  0,  then  the  kernel  (or
       previously  set) default is used.  For Linux 2.6.29 the default was 16384 events.  Beyond this limit, the
       kernel throws away events, but records the fact that it threw them away by setting a flag "IN_Q_OVERFLOW"
       in the returned structure list (see "guestfs_inotify_read").

       Before any events are generated, you have  to  add  some  watches  to  the  internal  watch  list.   See:
       "guestfs_inotify_add_watch" and "guestfs_inotify_rm_watch".

       Queued    up    events    should   be   read   periodically   by   calling   "guestfs_inotify_read"   (or
       "guestfs_inotify_files" which is just a helpful wrapper around  "guestfs_inotify_read").   If  you  don't
       read the events out often enough then you risk the internal queue overflowing.

       The  handle should be closed after use by calling "guestfs_inotify_close".  This also removes any watches
       automatically.

       See also <b><a href="../man7/inotify.7.html">inotify</a></b>(7) for an overview of the inotify interface as exposed by the  Linux  kernel,  which  is
       roughly  what  we  expose  via  libguestfs.   Note that there is one global inotify handle per libguestfs
       instance.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "inotify".  See also "guestfs_feature_available".

       (Added in 1.0.66)

   <b>guestfs_inotify_read</b>
        struct guestfs_inotify_event_list *
        guestfs_inotify_read (guestfs_h *g);

       Return the complete queue of events that have happened since the previous read call.

       If no events have happened, this returns an empty list.

       <u>Note</u>: In order to make sure that all events have been read, you must call this function repeatedly  until
       it  returns  an empty list.  The reason is that the call will read events up to the maximum appliance-to-
       host message size and leave remaining events in the queue.

       This function returns a "struct guestfs_inotify_event_list *", or NULL if there was an error.  <u>The</u> <u>caller</u>
       <u>must</u> <u>call</u> <u>"guestfs_free_inotify_event_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "inotify".  See also "guestfs_feature_available".

       (Added in 1.0.66)

   <b>guestfs_inotify_rm_watch</b>
        int
        guestfs_inotify_rm_watch (guestfs_h *g,
                                  int wd);

       Remove a previously defined inotify watch.  See "guestfs_inotify_add_watch".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "inotify".  See also "guestfs_feature_available".

       (Added in 1.0.66)

   <b>guestfs_inspect_get_arch</b>
        char *
        guestfs_inspect_get_arch (guestfs_h *g,
                                  const char *root);

       This returns the architecture of the inspected operating system.  The possible return values  are  listed
       under "guestfs_file_architecture".

       If the architecture could not be determined, then the string "unknown" is returned.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.5.3)

   <b>guestfs_inspect_get_build_id</b>
        char *
        guestfs_inspect_get_build_id (guestfs_h *g,
                                      const char *root);

       This returns the build ID of the system, or the string "unknown" if the system does not have a build ID.

       For  Windows,  this  gets the build number.  Although it is returned as a string, it is (so far) always a
       number.  See https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions for some possible values.

       For Linux, this returns the "BUILD_ID" string from <u><a href="file:/etc/os-release">/etc/os-release</a></u>, although this is not often used.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.49.8)

   <b>guestfs_inspect_get_distro</b>
        char *
        guestfs_inspect_get_distro (guestfs_h *g,
                                    const char *root);

       This returns the distro (distribution) of the inspected operating system.

       Currently defined distros are:

       "alpinelinux"
           Alpine Linux.

       "altlinux"
           ALT Linux.

       "archlinux"
           Arch Linux.

       "buildroot"
           Buildroot-derived distro, but not one we specifically recognize.

       "centos"
           CentOS.

       "circle"
           Circle Linux.

       "cirros"
           Cirros.

       "coreos"
           CoreOS.

       "debian"
           Debian.

       "fedora"
           Fedora.

       "freebsd"
           FreeBSD.

       "freedos"
           FreeDOS.

       "frugalware"
           Frugalware.

       "gentoo"
           Gentoo.

       "kalilinux"
           Kali Linux.

       "kylin"
           Kylin.

       "linuxmint"
           Linux Mint.

       "mageia"
           Mageia.

       "mandriva"
           Mandriva.

       "meego"
           MeeGo.

       "msdos"
           Microsoft DOS.

       "neokylin"
           NeoKylin.

       "netbsd"
           NetBSD.

       "openbsd"
           OpenBSD.

       "openeuler"
           openEuler.

       "openmandriva"
           OpenMandriva Lx.

       "opensuse"
           OpenSUSE.

       "oraclelinux"
           Oracle Linux.

       "pardus"
           Pardus.

       "pldlinux"
           PLD Linux.

       "redhat-based"
           Some Red Hat-derived distro.

       "rhel"
           Red Hat Enterprise Linux.

       "rocky"
           Rocky Linux.

       "scientificlinux"
           Scientific Linux.

       "slackware"
           Slackware.

       "sles"
           SuSE Linux Enterprise Server or Desktop.

       "suse-based"
           Some openSuSE-derived distro.

       "ttylinux"
           ttylinux.

       "ubuntu"
           Ubuntu.

       "unknown"
           The distro could not be determined.

       "voidlinux"
           Void Linux.

       "windows"
           Windows does not have distributions.  This string is returned if the OS type is Windows.

       Future versions of libguestfs may return other strings here.  The caller should be prepared to handle any
       string.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.5.3)

   <b>guestfs_inspect_get_drive_mappings</b>
        char **
        guestfs_inspect_get_drive_mappings (guestfs_h *g,
                                            const char *root);

       This call is useful for Windows which uses a primitive system of assigning drive letters  (like  <u>C:\</u>)  to
       partitions.   This  inspection  API  examines  the  Windows Registry to find out how disks/partitions are
       mapped to drive letters, and returns a hash table as in the example below:

        C      =&gt;     /dev/vda2
        E      =&gt;     /dev/vdb1
        F      =&gt;     /dev/vdc1

       Note that keys are drive letters.  For Windows, the key is case insensitive and just contains  the  drive
       letter, without the customary colon separator character.

       In  future  we  may  support other operating systems that also used drive letters, but the keys for those
       might not be case insensitive and might be longer than 1 character.  For example  in  OS-9,  hard  drives
       were named "h0", "h1" etc.

       For  Windows guests, currently only hard drive mappings are returned.  Removable disks (eg. DVD-ROMs) are
       ignored.

       For guests that do not use drive mappings, or if the drive mappings could not be determined, this returns
       an empty hash table.

       Please   read   "INSPECTION"   for   more   details.    See    also    "guestfs_inspect_get_mountpoints",
       "guestfs_inspect_get_filesystems".

       This  function  returns  a NULL-terminated array of strings, or NULL if there was an error.  The array of
       strings will always have length "2n+1", where "n" keys and values alternate,  followed  by  the  trailing
       NULL entry.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.9.17)

   <b>guestfs_inspect_get_filesystems</b>
        char **
        guestfs_inspect_get_filesystems (guestfs_h *g,
                                         const char *root);

       This returns a list of all the filesystems that we think are associated with this operating system.  This
       includes the root filesystem, other ordinary filesystems, and non-mounted devices like swap partitions.

       In  the  case  of  a  multi-boot  virtual  machine,  it is possible for a filesystem to be shared between
       operating systems.

       Please read "INSPECTION" for more details.  See also "guestfs_inspect_get_mountpoints".

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.5.3)

   <b>guestfs_inspect_get_format</b>
        char *
        guestfs_inspect_get_format (guestfs_h *g,
                                    const char *root);

       <u>This</u>  <u>function</u>  <u>is</u> <u>deprecated.</u>  There is no replacement.  Consult the API documentation in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3) for
       further information.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       Before  libguestfs  1.38,  there was some unreliable support for detecting installer CDs.  This API would
       return:

       "installed"
           This is an installed operating system.

       "installer"
           The disk image being inspected is not an installed operating system, but  a  <u>bootable</u>  install  disk,
           live CD, or similar.

       "unknown"
           The format of this disk image is not known.

       In libguestfs ≥ 1.38, this only returns "installed".  Use libosinfo directly to detect installer CDs.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.9.4)

   <b>guestfs_inspect_get_hostname</b>
        char *
        guestfs_inspect_get_hostname (guestfs_h *g,
                                      const char *root);

       This  function  returns  the  hostname  of  the  operating  system  as found by inspection of the guest’s
       configuration files.

       If the hostname could not be determined, then the string "unknown" is returned.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.7.9)

   <b>guestfs_inspect_get_icon</b>
        char *
        guestfs_inspect_get_icon (guestfs_h *g,
                                  const char *root,
                                  size_t *size_r,
                                  ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_INSPECT_GET_ICON_FAVICON, int favicon,
        GUESTFS_INSPECT_GET_ICON_HIGHQUALITY, int highquality,

       This function returns an icon corresponding to the inspected operating system.  The icon is returned as a
       buffer containing a PNG image (re-encoded to PNG if necessary).

       If  it  was  not  possible to get an icon this function returns a zero-length (non-NULL) buffer.  <u>Callers</u>
       <u>must</u> <u>check</u> <u>for</u> <u>this</u> <u>case</u>.

       Libguestfs will start by looking for a file called <u>/etc/favicon.png</u> or <u>C:\etc\favicon.png</u> and if  it  has
       the  correct format, the contents of this file will be returned.  You can disable favicons by passing the
       optional "favicon" boolean as false (default is true).

       If finding the favicon fails, then we look in other places in the guest for a suitable icon.

       If the optional "highquality" boolean is true then only high quality icons are returned, which means only
       icons of high resolution with an alpha channel.  The default (false) is to return any icon we  can,  even
       if it is of substandard quality.

       Notes:

       •   Unlike  most  other  inspection API calls, the guest’s disks must be mounted up before you call this,
           since it needs to read information from the guest filesystem during the call.

       •   <b>Security:</b> The icon data comes from the untrusted guest, and should  be  treated  with  caution.   PNG
           files  have  been  known  to  contain exploits.  Ensure that libpng (or other relevant libraries) are
           fully up to date before trying to process or display the icon.

       •   The PNG image returned can be any size.  It might not be square.   Libguestfs  tries  to  return  the
           largest, highest quality icon available.  The application must scale the icon to the required size.

       •   Extracting  icons  from  Windows guests requires the external <b><a href="../man1/wrestool.1.html">wrestool</a></b>(1) program from the "icoutils"
           package, and several programs (<b><a href="../man1/bmptopnm.1.html">bmptopnm</a></b>(1), <b><a href="../man1/pnmtopng.1.html">pnmtopng</a></b>(1), <b><a href="../man1/pamcut.1.html">pamcut</a></b>(1)) from the "netpbm" package.  These
           must be installed separately.

       •   Operating system icons are  usually  trademarks.   Seek  legal  advice  before  using  trademarks  in
           applications.

       This function returns a buffer, or NULL on error.  The size of the returned buffer is written to *size_r.
       <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>buffer</u> <u>after</u> <u>use</u>.

       (Added in 1.11.12)

   <b>guestfs_inspect_get_icon_va</b>
        char *
        guestfs_inspect_get_icon_va (guestfs_h *g,
                                     const char *root,
                                     size_t *size_r,
                                     va_list args);

       This is the "va_list variant" of "guestfs_inspect_get_icon".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_inspect_get_icon_argv</b>
        char *
        guestfs_inspect_get_icon_argv (guestfs_h *g,
                                       const char *root,
                                       size_t *size_r,
                                       const struct guestfs_inspect_get_icon_argv *optargs);

       This is the "argv variant" of "guestfs_inspect_get_icon".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_inspect_get_major_version</b>
        int
        guestfs_inspect_get_major_version (guestfs_h *g,
                                           const char *root);

       This returns the major version number of the inspected operating system.

       Windows  uses  a  consistent versioning scheme which is <u>not</u> reflected in the popular public names used by
       the operating system.  Notably the operating system known as "Windows 7" is really version 6.1 (ie. major
       = 6, minor = 1).  You can find out the real versions corresponding to releases of Windows  by  consulting
       Wikipedia or MSDN.

       If the version could not be determined, then 0 is returned.

       Please read "INSPECTION" for more details.

       On error this function returns -1.

       (Added in 1.5.3)

   <b>guestfs_inspect_get_minor_version</b>
        int
        guestfs_inspect_get_minor_version (guestfs_h *g,
                                           const char *root);

       This returns the minor version number of the inspected operating system.

       If the version could not be determined, then 0 is returned.

       Please read "INSPECTION" for more details.  See also "guestfs_inspect_get_major_version".

       On error this function returns -1.

       (Added in 1.5.3)

   <b>guestfs_inspect_get_mountpoints</b>
        char **
        guestfs_inspect_get_mountpoints (guestfs_h *g,
                                         const char *root);

       This  returns  a  hash  of where we think the filesystems associated with this operating system should be
       mounted.  Callers should note that this is at best an educated guess made by reading configuration  files
       such  as  <u><a href="file:/etc/fstab">/etc/fstab</a></u>.   <u>In</u> <u>particular</u> <u>note</u> that this may return filesystems which are non-existent or not
       mountable and callers should be prepared to handle or ignore failures if they try to mount them.

       Each element in the returned hashtable has a key which is the path of the mountpoint (eg.  <u><a href="file:/boot">/boot</a></u>)  and  a
       value which is the filesystem that would be mounted there (eg. <u>/dev/sda1</u>).

       Non-mounted devices such as swap devices are <u>not</u> returned in this list.

       For operating systems like Windows which still use drive letters, this call will only return an entry for
       the  first  drive  "mounted on" <u>/</u>.  For information about the mapping of drive letters to partitions, see
       "guestfs_inspect_get_drive_mappings".

       Please read "INSPECTION" for more details.  See also "guestfs_inspect_get_filesystems".

       This function returns a NULL-terminated array of strings, or NULL if there was an error.   The  array  of
       strings  will  always  have  length "2n+1", where "n" keys and values alternate, followed by the trailing
       NULL entry.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.5.3)

   <b>guestfs_inspect_get_osinfo</b>
        char *
        guestfs_inspect_get_osinfo (guestfs_h *g,
                                    const char *root);

       This function returns a possible short ID for libosinfo corresponding to the guest.

       <u>Note:</u> The returned ID is only a guess by libguestfs, and nothing  ensures  that  it  actually  exists  in
       osinfo-db.

       If no ID could not be determined, then the string "unknown" is returned.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.39.1)

   <b>guestfs_inspect_get_package_format</b>
        char *
        guestfs_inspect_get_package_format (guestfs_h *g,
                                            const char *root);

       This  function  and  "guestfs_inspect_get_package_management"  return  the  package  format  and  package
       management tool used by the inspected operating system.  For example for  Fedora  these  functions  would
       return "rpm" (package format), and "yum" or "dnf" (package management).

       This returns the string "unknown" if we could not determine the package format <u>or</u> if the operating system
       does not have a real packaging system (eg. Windows).

       Possible  strings  include:  "rpm",  "deb",  "ebuild", "pisi", "pacman", "pkgsrc", "apk", "xbps".  Future
       versions of libguestfs may return other strings.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.7.5)

   <b>guestfs_inspect_get_package_management</b>
        char *
        guestfs_inspect_get_package_management (guestfs_h *g,
                                                const char *root);

       "guestfs_inspect_get_package_format" and this function return the package format and  package  management
       tool  used  by the inspected operating system.  For example for Fedora these functions would return "rpm"
       (package format), and "yum" or "dnf" (package management).

       This returns the string "unknown" if we could not  determine  the  package  management  tool  <u>or</u>  if  the
       operating system does not have a real packaging system (eg. Windows).

       Possible strings include: "yum", "dnf", "up2date", "apt" (for all Debian derivatives), "portage", "pisi",
       "pacman", "urpmi", "zypper", "apk", "xbps".  Future versions of libguestfs may return other strings.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.7.5)

   <b>guestfs_inspect_get_product_name</b>
        char *
        guestfs_inspect_get_product_name (guestfs_h *g,
                                          const char *root);

       This  returns  the  product  name  of the inspected operating system.  The product name is generally some
       freeform string which can be displayed to the user, but should not be parsed by programs.

       If the product name could not be determined, then the string "unknown" is returned.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.5.3)

   <b>guestfs_inspect_get_product_variant</b>
        char *
        guestfs_inspect_get_product_variant (guestfs_h *g,
                                             const char *root);

       This returns the product variant of the inspected operating system.

       For Windows guests, this returns  the  contents  of  the  Registry  key  "HKLM\Software\Microsoft\Windows
       NT\CurrentVersion"  "InstallationType"  which  is  usually  a  string such as "Client" or "Server" (other
       values are possible).  This can be used to distinguish consumer and enterprise versions of  Windows  that
       have  the  same  version number (for example, Windows 7 and Windows 2008 Server are both version 6.1, but
       the former is "Client" and the latter is "Server").

       For enterprise Linux guests, in future we intend this to return the product variant  such  as  "Desktop",
       "Server" and so on.  But this is not implemented at present.

       If the product variant could not be determined, then the string "unknown" is returned.

       Please    read   "INSPECTION"   for   more   details.    See   also   "guestfs_inspect_get_product_name",
       "guestfs_inspect_get_major_version".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.9.13)

   <b>guestfs_inspect_get_roots</b>
        char **
        guestfs_inspect_get_roots (guestfs_h *g);

       This function is a convenient way to get the list of root devices, as returned from a  previous  call  to
       "guestfs_inspect_os", but without redoing the whole inspection process.

       This  returns  an  empty  list  if  either  no  root  devices  were  found  or  the caller has not called
       "guestfs_inspect_os".

       Please read "INSPECTION" for more details.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.7.3)

   <b>guestfs_inspect_get_type</b>
        char *
        guestfs_inspect_get_type (guestfs_h *g,
                                  const char *root);

       This returns the type of the inspected operating system.  Currently defined types are:

       "linux"
           Any Linux-based operating system.

       "windows"
           Any Microsoft Windows operating system.

       "freebsd"
           FreeBSD.

       "netbsd"
           NetBSD.

       "openbsd"
           OpenBSD.

       "hurd"
           GNU/Hurd.

       "dos"
           MS-DOS, FreeDOS and others.

       "minix"
           MINIX.

       "unknown"
           The operating system type could not be determined.

       Future versions of libguestfs may return other strings here.  The caller should be prepared to handle any
       string.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.5.3)

   <b>guestfs_inspect_get_windows_current_control_set</b>
        char *
        guestfs_inspect_get_windows_current_control_set (guestfs_h *g,
                                                         const char *root);

       This  returns  the Windows CurrentControlSet of the inspected guest.  The CurrentControlSet is a registry
       key name such as "ControlSet001".

       This call assumes that the guest is Windows and that the Registry could be examined  by  inspection.   If
       this is not the case then an error is returned.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.9.17)

   <b>guestfs_inspect_get_windows_software_hive</b>
        char *
        guestfs_inspect_get_windows_software_hive (guestfs_h *g,
                                                   const char *root);

       This returns the path to the hive (binary Windows Registry file) corresponding to HKLM\SOFTWARE.

       This  call  assumes  that the guest is Windows and that the guest has a software hive file with the right
       name.  If this is not the case then an error is returned.  This call does not check that the  hive  is  a
       valid Windows Registry hive.

       You can use "guestfs_hivex_open" to read or write to the hive.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.35.26)

   <b>guestfs_inspect_get_windows_system_hive</b>
        char *
        guestfs_inspect_get_windows_system_hive (guestfs_h *g,
                                                 const char *root);

       This returns the path to the hive (binary Windows Registry file) corresponding to HKLM\SYSTEM.

       This  call  assumes  that  the  guest is Windows and that the guest has a system hive file with the right
       name.  If this is not the case then an error is returned.  This call does not check that the  hive  is  a
       valid Windows Registry hive.

       You can use "guestfs_hivex_open" to read or write to the hive.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.35.26)

   <b>guestfs_inspect_get_windows_systemroot</b>
        char *
        guestfs_inspect_get_windows_systemroot (guestfs_h *g,
                                                const char *root);

       This  returns  the Windows systemroot of the inspected guest.  The systemroot is a directory path such as
       <u>/WINDOWS</u>.

       This call assumes that the guest is Windows and that the systemroot could be  determined  by  inspection.
       If this is not the case then an error is returned.

       Please read "INSPECTION" for more details.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.5.25)

   <b>guestfs_inspect_is_live</b>
        int
        guestfs_inspect_is_live (guestfs_h *g,
                                 const char *root);

       <u>This</u>  <u>function</u>  <u>is</u> <u>deprecated.</u>  There is no replacement.  Consult the API documentation in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3) for
       further information.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This is deprecated and always returns "false".

       Please read "INSPECTION" for more details.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.9.4)

   <b>guestfs_inspect_is_multipart</b>
        int
        guestfs_inspect_is_multipart (guestfs_h *g,
                                      const char *root);

       <u>This</u>  <u>function</u>  <u>is</u> <u>deprecated.</u>  There is no replacement.  Consult the API documentation in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3) for
       further information.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This is deprecated and always returns "false".

       Please read "INSPECTION" for more details.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.9.4)

   <b>guestfs_inspect_is_netinst</b>
        int
        guestfs_inspect_is_netinst (guestfs_h *g,
                                    const char *root);

       <u>This</u>  <u>function</u>  <u>is</u> <u>deprecated.</u>  There is no replacement.  Consult the API documentation in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3) for
       further information.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This is deprecated and always returns "false".

       Please read "INSPECTION" for more details.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.9.4)

   <b>guestfs_inspect_list_applications</b>
        struct guestfs_application_list *
        guestfs_inspect_list_applications (guestfs_h *g,
                                           const char *root);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_inspect_list_applications2" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       Return the list of applications installed in the operating system.

       <u>Note:</u> This  call  works  differently  from  other  parts  of  the  inspection  API.   You  have  to  call
       "guestfs_inspect_os",  then  "guestfs_inspect_get_mountpoints",  then  mount up the disks, before calling
       this.  Listing applications is a significantly more difficult operation which requires access to the full
       filesystem.  Also note that unlike the other "guestfs_inspect_get_*" calls which are just returning  data
       cached  in  the  libguestfs  handle, this call actually reads parts of the mounted filesystems during the
       call.

       This returns an empty list if the inspection code was not able to determine the list of applications.

       The application structure contains the following fields:

       "app_name"
           The name of the application.  For Linux guests, this is the package name.

       "app_display_name"
           The display name of the application, sometimes  localized  to  the  install  language  of  the  guest
           operating system.

           If  unavailable this is returned as an empty string "".  Callers needing to display something can use
           "app_name" instead.

       "app_epoch"
           For package managers which use epochs, this contains the epoch  of  the  package  (an  integer).   If
           unavailable, this is returned as 0.

       "app_version"
           The version string of the application or package.  If unavailable this is returned as an empty string
           "".

       "app_release"
           The release string of the application or package, for package managers that use this.  If unavailable
           this is returned as an empty string "".

       "app_install_path"
           The installation path of the application (on operating systems such as Windows which use installation
           paths).  This path is in the format used by the guest operating system, it is not a libguestfs path.

           If unavailable this is returned as an empty string "".

       "app_trans_path"
           The  install  path  translated  into  a libguestfs path.  If unavailable this is returned as an empty
           string "".

       "app_publisher"
           The name of the publisher of the application, for package managers that  use  this.   If  unavailable
           this is returned as an empty string "".

       "app_url"
           The  URL  (eg.  upstream URL) of the application.  If unavailable this is returned as an empty string
           "".

       "app_source_package"
           For packaging systems which support this, the name of the source package.   If  unavailable  this  is
           returned as an empty string "".

       "app_summary"
           A  short  (usually  one  line)  description  of  the  application or package.  If unavailable this is
           returned as an empty string "".

       "app_description"
           A longer description of the application or package.  If unavailable this  is  returned  as  an  empty
           string "".

       Please read "INSPECTION" for more details.

       This  function  returns a "struct guestfs_application_list *", or NULL if there was an error.  <u>The</u> <u>caller</u>
       <u>must</u> <u>call</u> <u>"guestfs_free_application_list"</u> <u>after</u> <u>use</u>.

       (Added in 1.7.8)

   <b>guestfs_inspect_list_applications2</b>
        struct guestfs_application2_list *
        guestfs_inspect_list_applications2 (guestfs_h *g,
                                            const char *root);

       Return the list of applications installed in the operating system.

       <u>Note:</u> This  call  works  differently  from  other  parts  of  the  inspection  API.   You  have  to  call
       "guestfs_inspect_os",  then  "guestfs_inspect_get_mountpoints",  then  mount up the disks, before calling
       this.  Listing applications is a significantly more difficult operation which requires access to the full
       filesystem.  Also note that unlike the other "guestfs_inspect_get_*" calls which are just returning  data
       cached  in  the  libguestfs  handle, this call actually reads parts of the mounted filesystems during the
       call.

       This returns an empty list if the inspection code was not able to determine the list of applications.

       The application structure contains the following fields:

       "app2_name"
           The name of the application.  For Linux guests, this is the package name.

       "app2_display_name"
           The display name of the application, sometimes  localized  to  the  install  language  of  the  guest
           operating system.

           If  unavailable this is returned as an empty string "".  Callers needing to display something can use
           "app2_name" instead.

       "app2_epoch"
           For package managers which use epochs, this contains the epoch  of  the  package  (an  integer).   If
           unavailable, this is returned as 0.

       "app2_version"
           The version string of the application or package.  If unavailable this is returned as an empty string
           "".

       "app2_release"
           The release string of the application or package, for package managers that use this.  If unavailable
           this is returned as an empty string "".

       "app2_arch"
           The  architecture  string  of  the  application  or  package, for package managers that use this.  If
           unavailable this is returned as an empty string "".

       "app2_install_path"
           The installation path of the application (on operating systems such as Windows which use installation
           paths).  This path is in the format used by the guest operating system, it is not a libguestfs path.

           If unavailable this is returned as an empty string "".

       "app2_trans_path"
           The install path translated into a libguestfs path.  If unavailable this  is  returned  as  an  empty
           string "".

       "app2_publisher"
           The  name  of  the  publisher of the application, for package managers that use this.  If unavailable
           this is returned as an empty string "".

       "app2_url"
           The URL (eg. upstream URL) of the application.  If unavailable this is returned as  an  empty  string
           "".

       "app2_source_package"
           For  packaging  systems  which  support this, the name of the source package.  If unavailable this is
           returned as an empty string "".

       "app2_summary"
           A short (usually one line) description of  the  application  or  package.   If  unavailable  this  is
           returned as an empty string "".

       "app2_description"
           A  longer  description  of  the  application or package.  If unavailable this is returned as an empty
           string "".

       Please read "INSPECTION" for more details.

       This function returns a "struct guestfs_application2_list *", or NULL if there was an error.  <u>The</u>  <u>caller</u>
       <u>must</u> <u>call</u> <u>"guestfs_free_application2_list"</u> <u>after</u> <u>use</u>.

       (Added in 1.19.56)

   <b>guestfs_inspect_os</b>
        char **
        guestfs_inspect_os (guestfs_h *g);

       This  function  uses  other  libguestfs  functions and certain heuristics to inspect the disk(s) (usually
       disks belonging to a virtual machine), looking for operating systems.

       The list returned is empty if no operating systems were found.

       If one operating system was found, then this returns a list with a single element, which is the  name  of
       the  root  filesystem  of  this operating system.  It is also possible for this function to return a list
       containing more than one element, indicating a dual-boot or multi-boot virtual machine, with each element
       being the root filesystem of one of the operating systems.

       You can pass the root string(s) returned to other "guestfs_inspect_get_*" functions  in  order  to  query
       further information about each operating system, such as the name and version.

       This function uses other libguestfs features such as "guestfs_mount_ro" and "guestfs_umount_all" in order
       to mount and unmount filesystems and look at the contents.  This should be called with no disks currently
       mounted.  The function may also use Augeas, so any existing Augeas handle will be closed.

       This  function  cannot  decrypt  encrypted disks.  The caller must do that first (supplying the necessary
       keys) if the disk is encrypted.

       Please read "INSPECTION" for more details.

       See also "guestfs_list_filesystems".

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.5.3)

   <b>guestfs_is_blockdev</b>
        int
        guestfs_is_blockdev (guestfs_h *g,
                             const char *path);

       This  function  is  provided  for backwards compatibility with earlier versions of libguestfs.  It simply
       calls "guestfs_is_blockdev_opts" with no optional arguments.

       (Added in 1.5.10)

   <b>guestfs_is_blockdev_opts</b>
        int
        guestfs_is_blockdev_opts (guestfs_h *g,
                                  const char *path,
                                  ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_IS_BLOCKDEV_OPTS_FOLLOWSYMLINKS, int followsymlinks,

       This returns "true" if and only if there is a block device with the given "path" name.

       If  the  optional  flag  "followsymlinks" is true, then a symlink (or chain of symlinks) that ends with a
       block device also causes the function to return true.

       This call only looks at files within the guest filesystem.  Libguestfs partitions and block devices  (eg.
       <u>/dev/sda</u>) cannot be used as the "path" parameter of this call.

       See also "guestfs_stat".

       This function returns a C truth value on success or -1 on error.

       (Added in 1.5.10)

   <b>guestfs_is_blockdev_opts_va</b>
        int
        guestfs_is_blockdev_opts_va (guestfs_h *g,
                                     const char *path,
                                     va_list args);

       This is the "va_list variant" of "guestfs_is_blockdev_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_blockdev_opts_argv</b>
        int
        guestfs_is_blockdev_opts_argv (guestfs_h *g,
                                       const char *path,
                                       const struct guestfs_is_blockdev_opts_argv *optargs);

       This is the "argv variant" of "guestfs_is_blockdev_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_busy</b>
        int
        guestfs_is_busy (guestfs_h *g);

       This always returns false.  This function is deprecated with no replacement.  Do not use this function.

       For more information on states, see <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

       This function returns a C truth value on success or -1 on error.

       (Added in 1.0.2)

   <b>guestfs_is_chardev</b>
        int
        guestfs_is_chardev (guestfs_h *g,
                            const char *path);

       This  function  is  provided  for backwards compatibility with earlier versions of libguestfs.  It simply
       calls "guestfs_is_chardev_opts" with no optional arguments.

       (Added in 1.5.10)

   <b>guestfs_is_chardev_opts</b>
        int
        guestfs_is_chardev_opts (guestfs_h *g,
                                 const char *path,
                                 ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_IS_CHARDEV_OPTS_FOLLOWSYMLINKS, int followsymlinks,

       This returns "true" if and only if there is a character device with the given "path" name.

       If  the  optional  flag  "followsymlinks" is true, then a symlink (or chain of symlinks) that ends with a
       chardev also causes the function to return true.

       See also "guestfs_stat".

       This function returns a C truth value on success or -1 on error.

       (Added in 1.5.10)

   <b>guestfs_is_chardev_opts_va</b>
        int
        guestfs_is_chardev_opts_va (guestfs_h *g,
                                    const char *path,
                                    va_list args);

       This is the "va_list variant" of "guestfs_is_chardev_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_chardev_opts_argv</b>
        int
        guestfs_is_chardev_opts_argv (guestfs_h *g,
                                      const char *path,
                                      const struct guestfs_is_chardev_opts_argv *optargs);

       This is the "argv variant" of "guestfs_is_chardev_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_config</b>
        int
        guestfs_is_config (guestfs_h *g);

       This returns true iff this handle is being configured (in the "CONFIG" state).

       For more information on states, see <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

       This function returns a C truth value on success or -1 on error.

       (Added in 1.0.2)

   <b>guestfs_is_dir</b>
        int
        guestfs_is_dir (guestfs_h *g,
                        const char *path);

       This function is provided for backwards compatibility with earlier versions  of  libguestfs.   It  simply
       calls "guestfs_is_dir_opts" with no optional arguments.

       (Added in 0.8)

   <b>guestfs_is_dir_opts</b>
        int
        guestfs_is_dir_opts (guestfs_h *g,
                             const char *path,
                             ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_IS_DIR_OPTS_FOLLOWSYMLINKS, int followsymlinks,

       This returns "true" if and only if there is a directory with the given "path" name.  Note that it returns
       false for other objects like files.

       If the optional flag "followsymlinks" is true, then a symlink (or chain of symlinks)  that  ends  with  a
       directory also causes the function to return true.

       See also "guestfs_stat".

       This function returns a C truth value on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_is_dir_opts_va</b>
        int
        guestfs_is_dir_opts_va (guestfs_h *g,
                                const char *path,
                                va_list args);

       This is the "va_list variant" of "guestfs_is_dir_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_dir_opts_argv</b>
        int
        guestfs_is_dir_opts_argv (guestfs_h *g,
                                  const char *path,
                                  const struct guestfs_is_dir_opts_argv *optargs);

       This is the "argv variant" of "guestfs_is_dir_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_fifo</b>
        int
        guestfs_is_fifo (guestfs_h *g,
                         const char *path);

       This  function  is  provided  for backwards compatibility with earlier versions of libguestfs.  It simply
       calls "guestfs_is_fifo_opts" with no optional arguments.

       (Added in 1.5.10)

   <b>guestfs_is_fifo_opts</b>
        int
        guestfs_is_fifo_opts (guestfs_h *g,
                              const char *path,
                              ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_IS_FIFO_OPTS_FOLLOWSYMLINKS, int followsymlinks,

       This returns "true" if and only if there is a FIFO (named pipe) with the given "path" name.

       If  the  optional  flag  "followsymlinks" is true, then a symlink (or chain of symlinks) that ends with a
       FIFO also causes the function to return true.

       See also "guestfs_stat".

       This function returns a C truth value on success or -1 on error.

       (Added in 1.5.10)

   <b>guestfs_is_fifo_opts_va</b>
        int
        guestfs_is_fifo_opts_va (guestfs_h *g,
                                 const char *path,
                                 va_list args);

       This is the "va_list variant" of "guestfs_is_fifo_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_fifo_opts_argv</b>
        int
        guestfs_is_fifo_opts_argv (guestfs_h *g,
                                   const char *path,
                                   const struct guestfs_is_fifo_opts_argv *optargs);

       This is the "argv variant" of "guestfs_is_fifo_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_file</b>
        int
        guestfs_is_file (guestfs_h *g,
                         const char *path);

       This function is provided for backwards compatibility with earlier versions  of  libguestfs.   It  simply
       calls "guestfs_is_file_opts" with no optional arguments.

       (Added in 0.8)

   <b>guestfs_is_file_opts</b>
        int
        guestfs_is_file_opts (guestfs_h *g,
                              const char *path,
                              ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_IS_FILE_OPTS_FOLLOWSYMLINKS, int followsymlinks,

       This returns "true" if and only if there is a regular file with the given  "path"  name.   Note  that  it
       returns false for other objects like directories.

       If  the  optional  flag  "followsymlinks" is true, then a symlink (or chain of symlinks) that ends with a
       file also causes the function to return true.

       See also "guestfs_stat".

       This function returns a C truth value on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_is_file_opts_va</b>
        int
        guestfs_is_file_opts_va (guestfs_h *g,
                                 const char *path,
                                 va_list args);

       This is the "va_list variant" of "guestfs_is_file_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_file_opts_argv</b>
        int
        guestfs_is_file_opts_argv (guestfs_h *g,
                                   const char *path,
                                   const struct guestfs_is_file_opts_argv *optargs);

       This is the "argv variant" of "guestfs_is_file_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_launching</b>
        int
        guestfs_is_launching (guestfs_h *g);

       This returns true iff this handle is launching the subprocess (in the "LAUNCHING" state).

       For more information on states, see <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

       This function returns a C truth value on success or -1 on error.

       (Added in 1.0.2)

   <b>guestfs_is_lv</b>
        int
        guestfs_is_lv (guestfs_h *g,
                       const char *mountable);

       This command tests whether "mountable" is a logical volume, and returns true iff this is the case.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.5.3)

   <b>guestfs_is_ready</b>
        int
        guestfs_is_ready (guestfs_h *g);

       This returns true iff this handle is ready to accept commands (in the "READY" state).

       For more information on states, see <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

       This function returns a C truth value on success or -1 on error.

       (Added in 1.0.2)

   <b>guestfs_is_socket</b>
        int
        guestfs_is_socket (guestfs_h *g,
                           const char *path);

       This function is provided for backwards compatibility with earlier versions  of  libguestfs.   It  simply
       calls "guestfs_is_socket_opts" with no optional arguments.

       (Added in 1.5.10)

   <b>guestfs_is_socket_opts</b>
        int
        guestfs_is_socket_opts (guestfs_h *g,
                                const char *path,
                                ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_IS_SOCKET_OPTS_FOLLOWSYMLINKS, int followsymlinks,

       This returns "true" if and only if there is a Unix domain socket with the given "path" name.

       If the optional flag "followsymlinks" is true, then a symlink (or chain of symlinks)  that  ends  with  a
       socket also causes the function to return true.

       See also "guestfs_stat".

       This function returns a C truth value on success or -1 on error.

       (Added in 1.5.10)

   <b>guestfs_is_socket_opts_va</b>
        int
        guestfs_is_socket_opts_va (guestfs_h *g,
                                   const char *path,
                                   va_list args);

       This is the "va_list variant" of "guestfs_is_socket_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_socket_opts_argv</b>
        int
        guestfs_is_socket_opts_argv (guestfs_h *g,
                                     const char *path,
                                     const struct guestfs_is_socket_opts_argv *optargs);

       This is the "argv variant" of "guestfs_is_socket_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_is_symlink</b>
        int
        guestfs_is_symlink (guestfs_h *g,
                            const char *path);

       This returns "true" if and only if there is a symbolic link with the given "path" name.

       See also "guestfs_stat".

       This function returns a C truth value on success or -1 on error.

       (Added in 1.5.10)

   <b>guestfs_is_whole_device</b>
        int
        guestfs_is_whole_device (guestfs_h *g,
                                 const char *device);

       This returns "true" if and only if "device" refers to a whole block device. That is, not a partition or a
       logical device.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.21.9)

   <b>guestfs_is_zero</b>
        int
        guestfs_is_zero (guestfs_h *g,
                         const char *path);

       This returns true iff the file exists and the file is empty or it contains all zero bytes.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.11.8)

   <b>guestfs_is_zero_device</b>
        int
        guestfs_is_zero_device (guestfs_h *g,
                                const char *device);

       This returns true iff the device exists and contains all zero bytes.

       Note that for large devices this can take a long time to run.

       This function returns a C truth value on success or -1 on error.

       (Added in 1.11.8)

   <b>guestfs_isoinfo</b>
        struct guestfs_isoinfo *
        guestfs_isoinfo (guestfs_h *g,
                         const char *isofile);

       This  is  the  same  as "guestfs_isoinfo_device" except that it works for an ISO file located inside some
       other mounted filesystem.  Note that in the common case where you have added an ISO file as a  libguestfs
       device, you would <u>not</u> call this.  Instead you would call "guestfs_isoinfo_device".

       This  function returns a "struct guestfs_isoinfo *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u> <u>call</u>
       <u>"guestfs_free_isoinfo"</u> <u>after</u> <u>use</u>.

       (Added in 1.17.19)

   <b>guestfs_isoinfo_device</b>
        struct guestfs_isoinfo *
        guestfs_isoinfo_device (guestfs_h *g,
                                const char *device);

       "device" is an ISO device.  This returns a struct of information read from the primary volume  descriptor
       (the ISO equivalent of the superblock) of the device.

       Usually  it is more efficient to use the <b><a href="../man1/isoinfo.1.html">isoinfo</a></b>(1) command with the <u>-d</u> option on the host to analyze ISO
       files, instead of going through libguestfs.

       For      information      on      the       primary       volume       descriptor       fields,       see
       https://wiki.osdev.org/ISO_9660#The_Primary_Volume_Descriptor

       This  function returns a "struct guestfs_isoinfo *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u> <u>call</u>
       <u>"guestfs_free_isoinfo"</u> <u>after</u> <u>use</u>.

       (Added in 1.17.19)

   <b>guestfs_journal_close</b>
        int
        guestfs_journal_close (guestfs_h *g);

       Close the journal handle.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "journal".  See also "guestfs_feature_available".

       (Added in 1.23.11)

   <b>guestfs_journal_get</b>
        struct guestfs_xattr_list *
        guestfs_journal_get (guestfs_h *g);

       Read the current journal entry.  This returns all the fields in the  journal  as  a  set  of  "(attrname,
       attrval)" pairs.  The "attrname" is the field name (a string).

       The  "attrval"  is  the  field  value  (a  binary blob, often but not always a string).  Please note that
       "attrval" is a byte array, <u>not</u> a \0-terminated C string.

       The length of data may be truncated to the  data  threshold  (see:  "guestfs_journal_set_data_threshold",
       "guestfs_journal_get_data_threshold").

       If  you  set the data threshold to unlimited (0) then this call can read a journal entry of any size, ie.
       it is not limited by the libguestfs protocol.

       This function returns a "struct guestfs_xattr_list *", or NULL if there was an error.   <u>The</u>  <u>caller</u>  <u>must</u>
       <u>call</u> <u>"guestfs_free_xattr_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "journal".  See also "guestfs_feature_available".

       (Added in 1.23.11)

   <b>guestfs_journal_get_data_threshold</b>
        int64_t
        guestfs_journal_get_data_threshold (guestfs_h *g);

       Get  the  current  data threshold for reading journal entries.  This is a hint to the journal that it may
       truncate data fields to this size when reading them (note also that it may not truncate them).   If  this
       returns 0, then the threshold is unlimited.

       See also "guestfs_journal_set_data_threshold".

       On error this function returns -1.

       This function depends on the feature "journal".  See also "guestfs_feature_available".

       (Added in 1.23.11)

   <b>guestfs_journal_get_realtime_usec</b>
        int64_t
        guestfs_journal_get_realtime_usec (guestfs_h *g);

       Get the realtime (wallclock) timestamp of the current journal entry.

       On error this function returns -1.

       This function depends on the feature "journal".  See also "guestfs_feature_available".

       (Added in 1.27.18)

   <b>guestfs_journal_next</b>
        int
        guestfs_journal_next (guestfs_h *g);

       Move  to the next journal entry.  You have to call this at least once after opening the handle before you
       are able to read data.

       The returned boolean tells you if there are any more journal records to read.  "true" means you can  read
       the  next  record  (eg.  using  "guestfs_journal_get"), and "false" means you have reached the end of the
       journal.

       This function returns a C truth value on success or -1 on error.

       This function depends on the feature "journal".  See also "guestfs_feature_available".

       (Added in 1.23.11)

   <b>guestfs_journal_open</b>
        int
        guestfs_journal_open (guestfs_h *g,
                              const char *directory);

       Open the systemd journal located in <u>directory</u>.  Any previously opened journal handle is closed.

       The contents of the journal can be read using "guestfs_journal_next" and "guestfs_journal_get".

       After  you  have   finished   using   the   journal,   you   should   close   the   handle   by   calling
       "guestfs_journal_close".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "journal".  See also "guestfs_feature_available".

       (Added in 1.23.11)

   <b>guestfs_journal_set_data_threshold</b>
        int
        guestfs_journal_set_data_threshold (guestfs_h *g,
                                            int64_t threshold);

       Set  the  data threshold for reading journal entries.  This is a hint to the journal that it may truncate
       data fields to this size when reading them (note also that it may not truncate them).  If you set this to
       0, then the threshold is unlimited.

       See also "guestfs_journal_get_data_threshold".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "journal".  See also "guestfs_feature_available".

       (Added in 1.23.11)

   <b>guestfs_journal_skip</b>
        int64_t
        guestfs_journal_skip (guestfs_h *g,
                              int64_t skip);

       Skip forwards ("skip ≥ 0") or backwards ("skip &lt; 0") in the journal.

       The number of entries actually skipped is returned (note "rskip ≥ 0").  If this is not the  same  as  the
       absolute  value  of the skip parameter ("|skip|") you passed in then it means you have reached the end or
       the start of the journal.

       On error this function returns -1.

       This function depends on the feature "journal".  See also "guestfs_feature_available".

       (Added in 1.23.11)

   <b>guestfs_kill_subprocess</b>
        int
        guestfs_kill_subprocess (guestfs_h *g);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_shutdown" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This kills the hypervisor.

       Do not call this.  See: "guestfs_shutdown" instead.

       This function returns 0 on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_launch</b>
        int
        guestfs_launch (guestfs_h *g);

       You should call this after configuring the handle (eg. adding drives) but before performing any actions.

       Do  not  call  "guestfs_launch"  twice  on  the  same  handle.   Although  it will not give an error (for
       historical reasons), the precise behaviour when you do this is not well defined.  Handles are very  cheap
       to create, so create a new one for each launch.

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 0.3)

   <b>guestfs_lchown</b>
        int
        guestfs_lchown (guestfs_h *g,
                        int owner,
                        int group,
                        const char *path);

       Change  the  file owner to "owner" and group to "group".  This is like "guestfs_chown" but if "path" is a
       symlink then the link itself is changed, not the target.

       Only numeric uid and gid are supported.  If you want to use names, you will need to locate and parse  the
       password file yourself (Augeas support makes this relatively easy).

       This function returns 0 on success or -1 on error.

       (Added in 1.0.77)

   <b>guestfs_ldmtool_create_all</b>
        int
        guestfs_ldmtool_create_all (guestfs_h *g);

       This  function  scans  all  block  devices  looking  for Windows dynamic disk volumes and partitions, and
       creates devices for any that were found.

       Call "guestfs_list_ldm_volumes" and "guestfs_list_ldm_partitions" to return all devices.

       Note that you  <b>don't</b>  normally  need  to  call  this  explicitly,  since  it  is  done  automatically  at
       "guestfs_launch" time.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_ldmtool_diskgroup_disks</b>
        char **
        guestfs_ldmtool_diskgroup_disks (guestfs_h *g,
                                         const char *diskgroup);

       Return the disks in a Windows dynamic disk group.  The "diskgroup" parameter should be the GUID of a disk
       group, one element from the list returned by "guestfs_ldmtool_scan".

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_ldmtool_diskgroup_name</b>
        char *
        guestfs_ldmtool_diskgroup_name (guestfs_h *g,
                                        const char *diskgroup);

       Return the name of a Windows dynamic disk group.  The "diskgroup" parameter should be the GUID of a  disk
       group, one element from the list returned by "guestfs_ldmtool_scan".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_ldmtool_diskgroup_volumes</b>
        char **
        guestfs_ldmtool_diskgroup_volumes (guestfs_h *g,
                                           const char *diskgroup);

       Return  the  volumes  in a Windows dynamic disk group.  The "diskgroup" parameter should be the GUID of a
       disk group, one element from the list returned by "guestfs_ldmtool_scan".

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_ldmtool_remove_all</b>
        int
        guestfs_ldmtool_remove_all (guestfs_h *g);

       This  is essentially the opposite of "guestfs_ldmtool_create_all".  It removes the device mapper mappings
       for all Windows dynamic disk volumes

       This function returns 0 on success or -1 on error.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_ldmtool_scan</b>
        char **
        guestfs_ldmtool_scan (guestfs_h *g);

       This function scans for Windows dynamic disks.  It returns a list of identifiers  (GUIDs)  for  all  disk
       groups that were found.  These identifiers can be passed to other "guestfs_ldmtool_*" functions.

       This   function   scans   all   block   devices.    To   scan   a   subset   of   block   devices,   call
       "guestfs_ldmtool_scan_devices" instead.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_ldmtool_scan_devices</b>
        char **
        guestfs_ldmtool_scan_devices (guestfs_h *g,
                                      char *const *devices);

       This  function  scans  for  Windows dynamic disks.  It returns a list of identifiers (GUIDs) for all disk
       groups that were found.  These identifiers can be passed to other "guestfs_ldmtool_*" functions.

       The parameter "devices" is a list of block devices which are scanned.  If this list is empty,  all  block
       devices are scanned.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_ldmtool_volume_hint</b>
        char *
        guestfs_ldmtool_volume_hint (guestfs_h *g,
                                     const char *diskgroup,
                                     const char *volume);

       Return the hint field of the volume named "volume" in the disk group with GUID "diskgroup".  This may not
       be defined, in which case the empty string is returned.  The hint field is often, though not always,  the
       name of a Windows drive, eg. "E:".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_ldmtool_volume_partitions</b>
        char **
        guestfs_ldmtool_volume_partitions (guestfs_h *g,
                                           const char *diskgroup,
                                           const char *volume);

       Return the list of partitions in the volume named "volume" in the disk group with GUID "diskgroup".

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_ldmtool_volume_type</b>
        char *
        guestfs_ldmtool_volume_type (guestfs_h *g,
                                     const char *diskgroup,
                                     const char *volume);

       Return the type of the volume named "volume" in the disk group with GUID "diskgroup".

       Possible volume types that can be returned here  include:  "simple",  "spanned",  "striped",  "mirrored",
       "raid5".  Other types may also be returned.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_lgetxattr</b>
        char *
        guestfs_lgetxattr (guestfs_h *g,
                           const char *path,
                           const char *name,
                           size_t *size_r);

       Get  a  single  extended attribute from file "path" named "name".  If "path" is a symlink, then this call
       returns an extended attribute from the symlink.

       Normally  it  is  better  to  get  all  extended  attributes  from  a  file  in   one   go   by   calling
       "guestfs_getxattrs".  However some Linux filesystem implementations are buggy and do not provide a way to
       list  out attributes.  For these filesystems (notably ntfs-3g) you have to know the names of the extended
       attributes you want in advance and call this function.

       Extended attribute values are blobs of binary data.  If there is no extended attribute named "name", this
       returns an error.

       See also: "guestfs_lgetxattrs", "guestfs_getxattr", <b><a href="../man5/attr.5.html">attr</a></b>(5).

       This function returns a buffer, or NULL on error.  The size of the returned buffer is written to *size_r.
       <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>buffer</u> <u>after</u> <u>use</u>.

       This function depends on the feature "linuxxattrs".  See also "guestfs_feature_available".

       (Added in 1.7.24)

   <b>guestfs_lgetxattrs</b>
        struct guestfs_xattr_list *
        guestfs_lgetxattrs (guestfs_h *g,
                            const char *path);

       This is the same as "guestfs_getxattrs", but if "path" is a symbolic link, then it returns  the  extended
       attributes of the link itself.

       This  function  returns  a "struct guestfs_xattr_list *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>
       <u>call</u> <u>"guestfs_free_xattr_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "linuxxattrs".  See also "guestfs_feature_available".

       (Added in 1.0.59)

   <b>guestfs_list_9p</b>
        char **
        guestfs_list_9p (guestfs_h *g);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  There is no replacement.  Consult the API documentation in  <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3)  for
       further information.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This call does nothing and returns an error.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.11.12)

   <b>guestfs_list_devices</b>
        char **
        guestfs_list_devices (guestfs_h *g);

       List all the block devices.

       The full block device names are returned, eg. <u>/dev/sda</u>.

       See also "guestfs_list_filesystems".

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 0.4)

   <b>guestfs_list_disk_labels</b>
        char **
        guestfs_list_disk_labels (guestfs_h *g);

       If you add drives using the optional "label" parameter of "guestfs_add_drive_opts", you can use this call
       to map between disk labels, and raw block device and partition names (like <u>/dev/sda</u> and <u>/dev/sda1</u>).

       This returns a hashtable, where keys are the disk labels (<u>without</u> the <u>/dev/disk/guestfs</u> prefix), and  the
       values are the full raw block device and partition names (eg. <u>/dev/sda</u> and <u>/dev/sda1</u>).

       This  function  returns  a NULL-terminated array of strings, or NULL if there was an error.  The array of
       strings will always have length "2n+1", where "n" keys and values alternate,  followed  by  the  trailing
       NULL entry.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.19.49)

   <b>guestfs_list_dm_devices</b>
        char **
        guestfs_list_dm_devices (guestfs_h *g);

       List all device mapper devices.

       The   returned   list   contains   <u><a href="file:/dev/mapper/">/dev/mapper/</a>*</u>  devices,  eg.  ones  created  by  a  previous  call  to
       "guestfs_luks_open".

       Device mapper devices which  correspond  to  logical  volumes  are  <u>not</u>  returned  in  this  list.   Call
       "guestfs_lvs" if you want to list logical volumes.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.11.15)

   <b>guestfs_list_filesystems</b>
        char **
        guestfs_list_filesystems (guestfs_h *g);

       This inspection command looks for filesystems on partitions, block devices and logical volumes, returning
       a list of "mountables" containing filesystems and their type.

       The return value is a hash, where the keys are the devices containing filesystems, and the values are the
       filesystem types.  For example:

        "/dev/sda1" =&gt; "ntfs"
        "/dev/sda2" =&gt; "ext2"
        "/dev/vg_guest/lv_root" =&gt; "ext4"
        "/dev/vg_guest/lv_swap" =&gt; "swap"

       The key is not necessarily a block device. It may also be an  opaque  ‘mountable’  string  which  can  be
       passed to "guestfs_mount".

       The  value  can  have  the  special value "unknown", meaning the content of the device is undetermined or
       empty.  "swap" means a Linux swap partition.

       In  libguestfs  ≤  1.36  this  command  ran  other  libguestfs  commands,  which  might   have   included
       "guestfs_mount"  and  "guestfs_umount", and therefore you had to use this soon after launch and only when
       nothing else was mounted.  This restriction is removed in libguestfs ≥ 1.38.

       Not all of the filesystems returned will be mountable.  In particular, swap partitions  are  returned  in
       the  list.   Also this command does not check that each filesystem found is valid and mountable, and some
       filesystems might be mountable but require special options.  Filesystems may not all belong to  a  single
       logical operating system (use "guestfs_inspect_os" to look for OSes).

       This  function  returns  a NULL-terminated array of strings, or NULL if there was an error.  The array of
       strings will always have length "2n+1", where "n" keys and values alternate,  followed  by  the  trailing
       NULL entry.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.5.15)

   <b>guestfs_list_ldm_partitions</b>
        char **
        guestfs_list_ldm_partitions (guestfs_h *g);

       This  function  returns all Windows dynamic disk partitions that were found at launch time.  It returns a
       list of device names.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_list_ldm_volumes</b>
        char **
        guestfs_list_ldm_volumes (guestfs_h *g);

       This function returns all Windows dynamic disk volumes that were found at launch time.  It returns a list
       of device names.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "ldm".  See also "guestfs_feature_available".

       (Added in 1.20.0)

   <b>guestfs_list_md_devices</b>
        char **
        guestfs_list_md_devices (guestfs_h *g);

       List all Linux md devices.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.15.4)

   <b>guestfs_list_partitions</b>
        char **
        guestfs_list_partitions (guestfs_h *g);

       List all the partitions detected on all block devices.

       The full partition device names are returned, eg. <u>/dev/sda1</u>

       This does not return logical volumes.  For that you will need to call "guestfs_lvs".

       See also "guestfs_list_filesystems".

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 0.4)

   <b>guestfs_ll</b>
        char *
        guestfs_ll (guestfs_h *g,
                    const char *directory);

       List the files in <u>directory</u> (relative to the root directory, there is no cwd) in the format of "ls -la".

       This command is mostly useful for interactive sessions.  It is <u>not</u> intended that you  try  to  parse  the
       output string.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 0.4)

   <b>guestfs_llz</b>
        char *
        guestfs_llz (guestfs_h *g,
                     const char *directory);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_lgetxattrs" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       List the files in <u>directory</u> in the format of "ls -laZ".

       This command is mostly useful for interactive sessions.  It is <u>not</u> intended that you  try  to  parse  the
       output string.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.17.6)

   <b>guestfs_ln</b>
        int
        guestfs_ln (guestfs_h *g,
                    const char *target,
                    const char *linkname);

       This command creates a hard link.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_ln_f</b>
        int
        guestfs_ln_f (guestfs_h *g,
                      const char *target,
                      const char *linkname);

       This command creates a hard link, removing the link "linkname" if it exists already.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_ln_s</b>
        int
        guestfs_ln_s (guestfs_h *g,
                      const char *target,
                      const char *linkname);

       This command creates a symbolic link using the "ln -s" command.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_ln_sf</b>
        int
        guestfs_ln_sf (guestfs_h *g,
                       const char *target,
                       const char *linkname);

       This  command  creates  a  symbolic  link  using  the  "ln  -sf"  command, The <u>-f</u> option removes the link
       ("linkname") if it exists already.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_lremovexattr</b>
        int
        guestfs_lremovexattr (guestfs_h *g,
                              const char *xattr,
                              const char *path);

       This is the same as "guestfs_removexattr", but if "path" is a symbolic link, then it removes an  extended
       attribute of the link itself.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "linuxxattrs".  See also "guestfs_feature_available".

       (Added in 1.0.59)

   <b>guestfs_ls</b>
        char **
        guestfs_ls (guestfs_h *g,
                    const char *directory);

       List  the files in <u>directory</u> (relative to the root directory, there is no cwd).  The "." and ".." entries
       are not returned, but hidden files are shown.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 0.4)

   <b>guestfs_ls0</b>
        int
        guestfs_ls0 (guestfs_h *g,
                     const char *dir,
                     const char *filenames);

       This  specialized  command is used to get a listing of the filenames in the directory "dir".  The list of
       filenames is written to the local file <u>filenames</u> (on the host).

       In the output file, the filenames are separated by "\0" characters.

       "." and ".." are not returned.  The filenames are not sorted.

       This function returns 0 on success or -1 on error.

       (Added in 1.19.32)

   <b>guestfs_lsetxattr</b>
        int
        guestfs_lsetxattr (guestfs_h *g,
                           const char *xattr,
                           const char *val,
                           int vallen,
                           const char *path);

       This is the same as "guestfs_setxattr", but if "path" is a  symbolic  link,  then  it  sets  an  extended
       attribute of the link itself.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "linuxxattrs".  See also "guestfs_feature_available".

       (Added in 1.0.59)

   <b>guestfs_lstat</b>
        struct guestfs_stat *
        guestfs_lstat (guestfs_h *g,
                       const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_lstatns" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       Returns file information for the given "path".

       This is the same as "guestfs_stat" except that if "path" is a symbolic link, then the  link  is  stat-ed,
       not the file it refers to.

       This is the same as the <b><a href="../man2/lstat.2.html">lstat</a></b>(2) system call.

       This  function  returns  a  "struct guestfs_stat *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u> <u>call</u>
       <u>"guestfs_free_stat"</u> <u>after</u> <u>use</u>.

       (Added in 1.9.2)

   <b>guestfs_lstatlist</b>
        struct guestfs_stat_list *
        guestfs_lstatlist (guestfs_h *g,
                           const char *path,
                           char *const *names);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_lstatnslist" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This  call  allows you to perform the "guestfs_lstat" operation on multiple files, where all files are in
       the directory "path".  "names" is the list of files from this directory.

       On return you get a list of stat structs, with a one-to-one correspondence to the "names" list.   If  any
       name did not exist or could not be lstat'd, then the "st_ino" field of that structure is set to -1.

       This call is intended for programs that want to efficiently list a directory contents without making many
       round-trips.   See  also  "guestfs_lxattrlist"  for  a  similarly  efficient  call  for  getting extended
       attributes.

       This function returns a "struct guestfs_stat_list *", or NULL if there was an  error.   <u>The</u>  <u>caller</u>  <u>must</u>
       <u>call</u> <u>"guestfs_free_stat_list"</u> <u>after</u> <u>use</u>.

       (Added in 1.0.77)

   <b>guestfs_lstatns</b>
        struct guestfs_statns *
        guestfs_lstatns (guestfs_h *g,
                         const char *path);

       Returns file information for the given "path".

       This  is the same as "guestfs_statns" except that if "path" is a symbolic link, then the link is stat-ed,
       not the file it refers to.

       This is the same as the <b><a href="../man2/lstat.2.html">lstat</a></b>(2) system call.

       This function returns a "struct guestfs_statns *", or NULL if there was an error.  <u>The</u> <u>caller</u>  <u>must</u>  <u>call</u>
       <u>"guestfs_free_statns"</u> <u>after</u> <u>use</u>.

       (Added in 1.27.53)

   <b>guestfs_lstatnslist</b>
        struct guestfs_statns_list *
        guestfs_lstatnslist (guestfs_h *g,
                             const char *path,
                             char *const *names);

       This call allows you to perform the "guestfs_lstatns" operation on multiple files, where all files are in
       the directory "path".  "names" is the list of files from this directory.

       On  return  you get a list of stat structs, with a one-to-one correspondence to the "names" list.  If any
       name did not exist or could not be lstat'd, then the "st_ino" field of that structure is set to -1.

       This call is intended for programs that want to efficiently list a directory contents without making many
       round-trips.  See  also  "guestfs_lxattrlist"  for  a  similarly  efficient  call  for  getting  extended
       attributes.

       This  function  returns a "struct guestfs_statns_list *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>
       <u>call</u> <u>"guestfs_free_statns_list"</u> <u>after</u> <u>use</u>.

       (Added in 1.27.53)

   <b>guestfs_luks_add_key</b>
        int
        guestfs_luks_add_key (guestfs_h *g,
                              const char *device,
                              const char *key,
                              const char *newkey,
                              int keyslot);

       This command adds a new key on LUKS device "device".  "key" is any existing key, and is  used  to  access
       the device.  "newkey" is the new key to add.  "keyslot" is the key slot that will be replaced.

       Note  that  if  "keyslot"  already  contains  a  key,  then  this  command  will  fail.   You have to use
       "guestfs_luks_kill_slot" first to remove that key.

       This function returns 0 on success or -1 on error.

       This function takes a key or passphrase parameter which  could  contain  sensitive  material.   Read  the
       section "KEYS AND PASSPHRASES" for more information.

       This function depends on the feature "luks".  See also "guestfs_feature_available".

       (Added in 1.5.2)

   <b>guestfs_luks_close</b>
        int
        guestfs_luks_close (guestfs_h *g,
                            const char *device);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_cryptsetup_close" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This closes a LUKS device that was created earlier by "guestfs_luks_open" or "guestfs_luks_open_ro".  The
       "device" parameter must be the name of the LUKS mapping device (ie. <u>/dev/mapper/mapname</u>) and <u>not</u> the name
       of the underlying block device.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "luks".  See also "guestfs_feature_available".

       (Added in 1.5.1)

   <b>guestfs_luks_format</b>
        int
        guestfs_luks_format (guestfs_h *g,
                             const char *device,
                             const char *key,
                             int keyslot);

       This command erases existing data on "device" and formats the device as a LUKS encrypted  device.   "key"
       is the initial key, which is added to key slot "keyslot".  (LUKS supports 8 key slots, numbered 0-7).

       This function returns 0 on success or -1 on error.

       This  function  takes  a  key  or  passphrase parameter which could contain sensitive material.  Read the
       section "KEYS AND PASSPHRASES" for more information.

       This function depends on the feature "luks".  See also "guestfs_feature_available".

       (Added in 1.5.2)

   <b>guestfs_luks_format_cipher</b>
        int
        guestfs_luks_format_cipher (guestfs_h *g,
                                    const char *device,
                                    const char *key,
                                    int keyslot,
                                    const char *cipher);

       This command is the same as "guestfs_luks_format" but it also allows you to set the "cipher" used.

       This function returns 0 on success or -1 on error.

       This function takes a key or passphrase parameter which  could  contain  sensitive  material.   Read  the
       section "KEYS AND PASSPHRASES" for more information.

       This function depends on the feature "luks".  See also "guestfs_feature_available".

       (Added in 1.5.2)

   <b>guestfs_luks_kill_slot</b>
        int
        guestfs_luks_kill_slot (guestfs_h *g,
                                const char *device,
                                const char *key,
                                int keyslot);

       This  command  deletes the key in key slot "keyslot" from the encrypted LUKS device "device".  "key" must
       be one of the <u>other</u> keys.

       This function returns 0 on success or -1 on error.

       This function takes a key or passphrase parameter which  could  contain  sensitive  material.   Read  the
       section "KEYS AND PASSPHRASES" for more information.

       This function depends on the feature "luks".  See also "guestfs_feature_available".

       (Added in 1.5.2)

   <b>guestfs_luks_open</b>
        int
        guestfs_luks_open (guestfs_h *g,
                           const char *device,
                           const char *key,
                           const char *mapname);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_cryptsetup_open" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This command opens a block device which has been encrypted according  to  the  Linux  Unified  Key  Setup
       (LUKS) standard.

       "device" is the encrypted block device or partition.

       The caller must supply one of the keys associated with the LUKS block device, in the "key" parameter.

       This  creates  a  new block device called <u>/dev/mapper/mapname</u>.  Reads and writes to this block device are
       decrypted from and encrypted to the underlying "device" respectively.

       If this block device contains LVM volume groups, then  calling  "guestfs_lvm_scan"  with  the  "activate"
       parameter "true" will make them visible.

       Use "guestfs_list_dm_devices" to list all device mapper devices.

       This function returns 0 on success or -1 on error.

       This  function  takes  a  key  or  passphrase parameter which could contain sensitive material.  Read the
       section "KEYS AND PASSPHRASES" for more information.

       This function depends on the feature "luks".  See also "guestfs_feature_available".

       (Added in 1.5.1)

   <b>guestfs_luks_open_ro</b>
        int
        guestfs_luks_open_ro (guestfs_h *g,
                              const char *device,
                              const char *key,
                              const char *mapname);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_cryptsetup_open" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This is the same as "guestfs_luks_open" except that a read-only mapping is created.

       This function returns 0 on success or -1 on error.

       This  function  takes  a  key  or  passphrase parameter which could contain sensitive material.  Read the
       section "KEYS AND PASSPHRASES" for more information.

       This function depends on the feature "luks".  See also "guestfs_feature_available".

       (Added in 1.5.1)

   <b>guestfs_luks_uuid</b>
        char *
        guestfs_luks_uuid (guestfs_h *g,
                           const char *device);

       This returns the UUID of the LUKS device "device".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       This function depends on the feature "luks".  See also "guestfs_feature_available".

       (Added in 1.41.9)

   <b>guestfs_lvcreate</b>
        int
        guestfs_lvcreate (guestfs_h *g,
                          const char *logvol,
                          const char *volgroup,
                          int mbytes);

       This creates an LVM logical volume called "logvol" on the volume group "volgroup", with "size" megabytes.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 0.8)

   <b>guestfs_lvcreate_free</b>
        int
        guestfs_lvcreate_free (guestfs_h *g,
                               const char *logvol,
                               const char *volgroup,
                               int percent);

       Create an LVM logical volume called <u>/dev/volgroup/logvol</u>, using approximately "percent"  %  of  the  free
       space  remaining  in the volume group.  Most usefully, when "percent" is 100 this will create the largest
       possible LV.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.17.18)

   <b>guestfs_lvm_canonical_lv_name</b>
        char *
        guestfs_lvm_canonical_lv_name (guestfs_h *g,
                                       const char *lvname);

       This converts alternative naming schemes for LVs that you might find to the canonical name.  For example,
       <u>/dev/mapper/VG-LV</u> is converted to <u>/dev/VG/LV</u>.

       This command returns an error if the "lvname" parameter does not refer to a logical volume.  In this case
       errno will be set to "EINVAL".

       See also "guestfs_is_lv", "guestfs_canonical_device_name".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.5.24)

   <b>guestfs_lvm_clear_filter</b>
        int
        guestfs_lvm_clear_filter (guestfs_h *g);

       This undoes the effect of "guestfs_lvm_set_filter".  LVM will be able to see every block device.

       This command also clears the LVM cache and performs a volume group scan.

       This function returns 0 on success or -1 on error.

       (Added in 1.5.1)

   <b>guestfs_lvm_remove_all</b>
        int
        guestfs_lvm_remove_all (guestfs_h *g);

       This command removes all LVM logical volumes, volume groups and physical volumes.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 0.8)

   <b>guestfs_lvm_scan</b>
        int
        guestfs_lvm_scan (guestfs_h *g,
                          int activate);

       This scans all block devices and rebuilds the list of LVM physical volumes,  volume  groups  and  logical
       volumes.

       If  the  "activate" parameter is "true" then newly found volume groups and logical volumes are activated,
       meaning the LV <u>/dev/VG/LV</u> devices become visible.

       When a libguestfs handle is launched it scans for existing devices, so you do not normally  need  to  use
       this  API.   However it is useful when you have added a new device or deleted an existing device (such as
       when the "guestfs_luks_open" API is used).

       This function returns 0 on success or -1 on error.

       (Added in 1.39.8)

   <b>guestfs_lvm_set_filter</b>
        int
        guestfs_lvm_set_filter (guestfs_h *g,
                                char *const *devices);

       This sets the LVM device filter so that LVM will only be able to "see" the  block  devices  in  the  list
       "devices", and will ignore all other attached block devices.

       Where  disk  image(s)  contain  duplicate  PVs  or  VGs,  this command is useful to get LVM to ignore the
       duplicates, otherwise LVM can get confused.  Note also there  are  two  types  of  duplication  possible:
       either  cloned PVs/VGs which have identical UUIDs; or VGs that are not cloned but just happen to have the
       same name.  In normal operation you cannot create this situation, but you can do it outside LVM, eg.   by
       cloning disk images or by bit twiddling inside the LVM metadata.

       This command also clears the LVM cache and performs a volume group scan.

       You can filter whole block devices or individual partitions.

       You  cannot  use this if any VG is currently in use (eg.  contains a mounted filesystem), even if you are
       not filtering out that VG.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.5.1)

   <b>guestfs_lvremove</b>
        int
        guestfs_lvremove (guestfs_h *g,
                          const char *device);

       Remove an LVM logical volume "device", where "device" is the path to the LV, such as <u>/dev/VG/LV</u>.

       You can also remove all LVs in a volume group by specifying the VG name, <u>/dev/VG</u>.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.0.13)

   <b>guestfs_lvrename</b>
        int
        guestfs_lvrename (guestfs_h *g,
                          const char *logvol,
                          const char *newlogvol);

       Rename a logical volume "logvol" with the new name "newlogvol".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.83)

   <b>guestfs_lvresize</b>
        int
        guestfs_lvresize (guestfs_h *g,
                          const char *device,
                          int mbytes);

       This resizes (expands or shrinks) an existing LVM logical volume to "mbytes".  When reducing, data in the
       reduced part is lost.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.0.27)

   <b>guestfs_lvresize_free</b>
        int
        guestfs_lvresize_free (guestfs_h *g,
                               const char *lv,
                               int percent);

       This expands an existing logical volume "lv" so that it fills "pc" % of the remaining free space  in  the
       volume  group.   Commonly  you  would call this with pc = 100 which expands the logical volume as much as
       possible, using all remaining free space in the volume group.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.3.3)

   <b>guestfs_lvs</b>
        char **
        guestfs_lvs (guestfs_h *g);

       List all the logical volumes detected.  This is the equivalent of the <b><a href="../man8/lvs.8.html">lvs</a></b>(8) command.

       This returns a list of the logical volume device names (eg. <u>/dev/VolGroup00/LogVol00</u>).

       See also "guestfs_lvs_full", "guestfs_list_filesystems".

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 0.4)

   <b>guestfs_lvs_full</b>
        struct guestfs_lvm_lv_list *
        guestfs_lvs_full (guestfs_h *g);

       List all the logical volumes detected.  This is the equivalent of the <b><a href="../man8/lvs.8.html">lvs</a></b>(8) command.  The "full" version
       includes all fields.

       This  function  returns a "struct guestfs_lvm_lv_list *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>
       <u>call</u> <u>"guestfs_free_lvm_lv_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 0.4)

   <b>guestfs_lvuuid</b>
        char *
        guestfs_lvuuid (guestfs_h *g,
                        const char *device);

       This command returns the UUID of the LVM LV "device".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.87)

   <b>guestfs_lxattrlist</b>
        struct guestfs_xattr_list *
        guestfs_lxattrlist (guestfs_h *g,
                            const char *path,
                            char *const *names);

       This call allows you to get the extended attributes of  multiple  files,  where  all  files  are  in  the
       directory "path".  "names" is the list of files from this directory.

       On  return  you get a flat list of xattr structs which must be interpreted sequentially.  The first xattr
       struct always has a zero-length "attrname".  "attrval" in this struct is zero-length  to  indicate  there
       was  an  error  doing  "guestfs_lgetxattr" for this file, <u>or</u> is a C string which is a decimal number (the
       number of following attributes for this file, which could be "0").  Then after the first xattr struct are
       the zero or more attributes for the first named file.  This repeats for the second and subsequent files.

       This call is intended for programs that want to efficiently list a directory contents without making many
       round-trips.  See also "guestfs_lstatlist" for a similarly efficient call for getting standard stats.

       This function returns a "struct guestfs_xattr_list *", or NULL if there was an error.   <u>The</u>  <u>caller</u>  <u>must</u>
       <u>call</u> <u>"guestfs_free_xattr_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "linuxxattrs".  See also "guestfs_feature_available".

       (Added in 1.0.77)

   <b>guestfs_max_disks</b>
        int
        guestfs_max_disks (guestfs_h *g);

       Return  the  maximum  number  of disks that may be added to a handle (eg. by "guestfs_add_drive_opts" and
       similar calls).

       This function was added in libguestfs 1.19.7.  In previous versions of libguestfs the limit was 25.

       See "MAXIMUM NUMBER OF DISKS" for additional information on this topic.

       On error this function returns -1.

       (Added in 1.19.7)

   <b>guestfs_md_create</b>
        int
        guestfs_md_create (guestfs_h *g,
                           const char *name,
                           char *const *devices,
                           ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_MD_CREATE_MISSINGBITMAP, int64_t missingbitmap,
        GUESTFS_MD_CREATE_NRDEVICES, int nrdevices,
        GUESTFS_MD_CREATE_SPARE, int spare,
        GUESTFS_MD_CREATE_CHUNK, int64_t chunk,
        GUESTFS_MD_CREATE_LEVEL, const char *level,

       Create a Linux md (RAID) device named "name" on the devices in the list "devices".

       The optional parameters are:

       "missingbitmap"
           A  bitmap  of missing devices.  If a bit is set it means that a missing device is added to the array.
           The least significant bit corresponds to the first device in the array.

           As examples:

           If "devices = ["/dev/sda"]" and "missingbitmap = 0x1" then the resulting array would be  "[&lt;missing&gt;,
           "/dev/sda"]".

           If "devices = ["/dev/sda"]" and "missingbitmap = 0x2" then the resulting array would be "["/dev/sda",
           &lt;missing&gt;]".

           This defaults to 0 (no missing devices).

           The length of "devices" + the number of bits set in "missingbitmap" must equal "nrdevices" + "spare".

       "nrdevices"
           The number of active RAID devices.

           If not set, this defaults to the length of "devices" plus the number of bits set in "missingbitmap".

       "spare"
           The number of spare devices.

           If not set, this defaults to 0.

       "chunk"
           The chunk size in bytes.

           The  "chunk"  parameter  does  not  make  sense, and should not be specified, when "level" is "raid1"
           (which is the default; see below).

       "level"
           The RAID level, which can be one of: "linear", "raid0", 0, "stripe", "raid1", 1,  "mirror",  "raid4",
           4,  "raid5", 5, "raid6", 6, "raid10", 10.  Some of these are synonymous, and more levels may be added
           in future.

           If not set, this defaults to "raid1".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "mdadm".  See also "guestfs_feature_available".

       (Added in 1.15.6)

   <b>guestfs_md_create_va</b>
        int
        guestfs_md_create_va (guestfs_h *g,
                              const char *name,
                              char *const *devices,
                              va_list args);

       This is the "va_list variant" of "guestfs_md_create".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_md_create_argv</b>
        int
        guestfs_md_create_argv (guestfs_h *g,
                                const char *name,
                                char *const *devices,
                                const struct guestfs_md_create_argv *optargs);

       This is the "argv variant" of "guestfs_md_create".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_md_detail</b>
        char **
        guestfs_md_detail (guestfs_h *g,
                           const char *md);

       This command exposes the output of "mdadm -DY &lt;md&gt;".  The following fields are  usually  present  in  the
       returned hash.  Other fields may also be present.

       "level"
           The raid level of the MD device.

       "devices"
           The number of underlying devices in the MD device.

       "metadata"
           The metadata version used.

       "uuid"
           The UUID of the MD device.

       "name"
           The name of the MD device.

       This  function  returns  a NULL-terminated array of strings, or NULL if there was an error.  The array of
       strings will always have length "2n+1", where "n" keys and values alternate,  followed  by  the  trailing
       NULL entry.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "mdadm".  See also "guestfs_feature_available".

       (Added in 1.15.6)

   <b>guestfs_md_stat</b>
        struct guestfs_mdstat_list *
        guestfs_md_stat (guestfs_h *g,
                         const char *md);

       This  call  returns  a list of the underlying devices which make up the single software RAID array device
       "md".

       To get a list of software RAID devices, call "guestfs_list_md_devices".

       Each structure returned corresponds to one device along with additional status information:

       "mdstat_device"
           The name of the underlying device.

       "mdstat_index"
           The index of this device within the array.

       "mdstat_flags"
           Flags associated with this device.  This is a string containing (in no specific order) zero  or  more
           of the following flags:

           "W" write-mostly

           "F" device is faulty

           "S" device is a RAID spare

           "R" replacement

       This  function  returns a "struct guestfs_mdstat_list *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>
       <u>call</u> <u>"guestfs_free_mdstat_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "mdadm".  See also "guestfs_feature_available".

       (Added in 1.17.21)

   <b>guestfs_md_stop</b>
        int
        guestfs_md_stop (guestfs_h *g,
                         const char *md);

       This command deactivates the MD array named "md".  The device is stopped, but  it  is  not  destroyed  or
       zeroed.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "mdadm".  See also "guestfs_feature_available".

       (Added in 1.15.6)

   <b>guestfs_mkdir</b>
        int
        guestfs_mkdir (guestfs_h *g,
                       const char *path);

       Create a directory named "path".

       This function returns 0 on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_mkdir_mode</b>
        int
        guestfs_mkdir_mode (guestfs_h *g,
                            const char *path,
                            int mode);

       This command creates a directory, setting the initial permissions of the directory to "mode".

       For  common Linux filesystems, the actual mode which is set will be "mode &amp; ~umask &amp; 01777".  Non-native-
       Linux filesystems may interpret the mode in other ways.

       See also "guestfs_mkdir", "guestfs_umask"

       This function returns 0 on success or -1 on error.

       (Added in 1.0.77)

   <b>guestfs_mkdir_p</b>
        int
        guestfs_mkdir_p (guestfs_h *g,
                         const char *path);

       Create a directory named "path", creating any parent directories as necessary.  This is like  the  "mkdir
       -p" shell command.

       This function returns 0 on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_mkdtemp</b>
        char *
        guestfs_mkdtemp (guestfs_h *g,
                         const char *tmpl);

       This  command  creates  a  temporary  directory.   The "tmpl" parameter should be a full pathname for the
       temporary directory name with the final six characters being "XXXXXX".

       For example: "/tmp/myprogXXXXXX" or "/Temp/myprogXXXXXX", the  second  one  being  suitable  for  Windows
       filesystems.

       The name of the temporary directory that was created is returned.

       The temporary directory is created with mode 0700 and is owned by root.

       The caller is responsible for deleting the temporary directory and its contents after use.

       See also: <b><a href="../man3/mkdtemp.3.html">mkdtemp</a></b>(3)

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.54)

   <b>guestfs_mke2fs</b>
        int
        guestfs_mke2fs (guestfs_h *g,
                        const char *device,
                        ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_MKE2FS_BLOCKSCOUNT, int64_t blockscount,
        GUESTFS_MKE2FS_BLOCKSIZE, int64_t blocksize,
        GUESTFS_MKE2FS_FRAGSIZE, int64_t fragsize,
        GUESTFS_MKE2FS_BLOCKSPERGROUP, int64_t blockspergroup,
        GUESTFS_MKE2FS_NUMBEROFGROUPS, int64_t numberofgroups,
        GUESTFS_MKE2FS_BYTESPERINODE, int64_t bytesperinode,
        GUESTFS_MKE2FS_INODESIZE, int64_t inodesize,
        GUESTFS_MKE2FS_JOURNALSIZE, int64_t journalsize,
        GUESTFS_MKE2FS_NUMBEROFINODES, int64_t numberofinodes,
        GUESTFS_MKE2FS_STRIDESIZE, int64_t stridesize,
        GUESTFS_MKE2FS_STRIPEWIDTH, int64_t stripewidth,
        GUESTFS_MKE2FS_MAXONLINERESIZE, int64_t maxonlineresize,
        GUESTFS_MKE2FS_RESERVEDBLOCKSPERCENTAGE, int reservedblockspercentage,
        GUESTFS_MKE2FS_MMPUPDATEINTERVAL, int mmpupdateinterval,
        GUESTFS_MKE2FS_JOURNALDEVICE, const char *journaldevice,
        GUESTFS_MKE2FS_LABEL, const char *label,
        GUESTFS_MKE2FS_LASTMOUNTEDDIR, const char *lastmounteddir,
        GUESTFS_MKE2FS_CREATOROS, const char *creatoros,
        GUESTFS_MKE2FS_FSTYPE, const char *fstype,
        GUESTFS_MKE2FS_USAGETYPE, const char *usagetype,
        GUESTFS_MKE2FS_UUID, const char *uuid,
        GUESTFS_MKE2FS_FORCECREATE, int forcecreate,
        GUESTFS_MKE2FS_WRITESBANDGROUPONLY, int writesbandgrouponly,
        GUESTFS_MKE2FS_LAZYITABLEINIT, int lazyitableinit,
        GUESTFS_MKE2FS_LAZYJOURNALINIT, int lazyjournalinit,
        GUESTFS_MKE2FS_TESTFS, int testfs,
        GUESTFS_MKE2FS_DISCARD, int discard,
        GUESTFS_MKE2FS_QUOTATYPE, int quotatype,
        GUESTFS_MKE2FS_EXTENT, int extent,
        GUESTFS_MKE2FS_FILETYPE, int filetype,
        GUESTFS_MKE2FS_FLEXBG, int flexbg,
        GUESTFS_MKE2FS_HASJOURNAL, int hasjournal,
        GUESTFS_MKE2FS_JOURNALDEV, int journaldev,
        GUESTFS_MKE2FS_LARGEFILE, int largefile,
        GUESTFS_MKE2FS_QUOTA, int quota,
        GUESTFS_MKE2FS_RESIZEINODE, int resizeinode,
        GUESTFS_MKE2FS_SPARSESUPER, int sparsesuper,
        GUESTFS_MKE2FS_UNINITBG, int uninitbg,

       "mke2fs" is used to create an ext2, ext3, or ext4 filesystem on "device".

       The optional "blockscount" is the size of the filesystem in blocks.  If omitted it defaults to  the  size
       of  "device".  Note if the filesystem is too small to contain a journal, "mke2fs" will silently create an
       ext2 filesystem instead.

       This function returns 0 on success or -1 on error.

       (Added in 1.19.44)

   <b>guestfs_mke2fs_va</b>
        int
        guestfs_mke2fs_va (guestfs_h *g,
                           const char *device,
                           va_list args);

       This is the "va_list variant" of "guestfs_mke2fs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mke2fs_argv</b>
        int
        guestfs_mke2fs_argv (guestfs_h *g,
                             const char *device,
                             const struct guestfs_mke2fs_argv *optargs);

       This is the "argv variant" of "guestfs_mke2fs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mke2fs_J</b>
        int
        guestfs_mke2fs_J (guestfs_h *g,
                          const char *fstype,
                          int blocksize,
                          const char *device,
                          const char *journal);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_mke2fs" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This  creates an ext2/3/4 filesystem on "device" with an external journal on "journal".  It is equivalent
       to the command:

        mke2fs -t fstype -b blocksize -J device=&lt;journal&gt; &lt;device&gt;

       See also "guestfs_mke2journal".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.68)

   <b>guestfs_mke2fs_JL</b>
        int
        guestfs_mke2fs_JL (guestfs_h *g,
                           const char *fstype,
                           int blocksize,
                           const char *device,
                           const char *label);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_mke2fs" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This creates an ext2/3/4 filesystem on "device" with an external journal on the journal labeled "label".

       See also "guestfs_mke2journal_L".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.68)

   <b>guestfs_mke2fs_JU</b>
        int
        guestfs_mke2fs_JU (guestfs_h *g,
                           const char *fstype,
                           int blocksize,
                           const char *device,
                           const char *uuid);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_mke2fs" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This creates an ext2/3/4 filesystem on "device" with an external journal on the journal with UUID "uuid".

       See also "guestfs_mke2journal_U".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "linuxfsuuid".  See also "guestfs_feature_available".

       (Added in 1.0.68)

   <b>guestfs_mke2journal</b>
        int
        guestfs_mke2journal (guestfs_h *g,
                             int blocksize,
                             const char *device);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_mke2fs" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This creates an ext2 external journal on "device".  It is equivalent to the command:

        mke2fs -O journal_dev -b blocksize device

       This function returns 0 on success or -1 on error.

       (Added in 1.0.68)

   <b>guestfs_mke2journal_L</b>
        int
        guestfs_mke2journal_L (guestfs_h *g,
                               int blocksize,
                               const char *label,
                               const char *device);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_mke2fs" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This creates an ext2 external journal on "device" with label "label".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.68)

   <b>guestfs_mke2journal_U</b>
        int
        guestfs_mke2journal_U (guestfs_h *g,
                               int blocksize,
                               const char *uuid,
                               const char *device);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_mke2fs" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This creates an ext2 external journal on "device" with UUID "uuid".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "linuxfsuuid".  See also "guestfs_feature_available".

       (Added in 1.0.68)

   <b>guestfs_mkfifo</b>
        int
        guestfs_mkfifo (guestfs_h *g,
                        int mode,
                        const char *path);

       This  call  creates  a FIFO (named pipe) called "path" with mode "mode".  It is just a convenient wrapper
       around "guestfs_mknod".

       Unlike with "guestfs_mknod", "mode" <b>must</b> contain only permissions bits.

       The mode actually set is affected by the umask.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "mknod".  See also "guestfs_feature_available".

       (Added in 1.0.55)

   <b>guestfs_mkfs</b>
        int
        guestfs_mkfs (guestfs_h *g,
                      const char *fstype,
                      const char *device);

       This function is provided for backwards compatibility with earlier versions  of  libguestfs.   It  simply
       calls "guestfs_mkfs_opts" with no optional arguments.

       (Added in 0.8)

   <b>guestfs_mkfs_opts</b>
        int
        guestfs_mkfs_opts (guestfs_h *g,
                           const char *fstype,
                           const char *device,
                           ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_MKFS_OPTS_BLOCKSIZE, int blocksize,
        GUESTFS_MKFS_OPTS_FEATURES, const char *features,
        GUESTFS_MKFS_OPTS_INODE, int inode,
        GUESTFS_MKFS_OPTS_SECTORSIZE, int sectorsize,
        GUESTFS_MKFS_OPTS_LABEL, const char *label,

       This function creates a filesystem on "device".  The filesystem type is "fstype", for example "ext3".

       The optional arguments are:

       "blocksize"
           The filesystem block size.  Supported block sizes depend on the filesystem type, but  typically  they
           are 1024, 2048 or 4096 for Linux ext2/3 filesystems.

           For VFAT and NTFS the "blocksize" parameter is treated as the requested cluster size.

           For UFS block sizes, please see <b><a href="../man8/mkfs.ufs.8.html">mkfs.ufs</a></b>(8).

       "features"
           This passes the <u>-O</u> parameter to the external mkfs program.

           For  certain  filesystem  types, this allows extra filesystem features to be selected.  See <b><a href="../man8/mke2fs.8.html">mke2fs</a></b>(8)
           and <b><a href="../man8/mkfs.ufs.8.html">mkfs.ufs</a></b>(8) for more details.

           You cannot use this optional parameter with the "gfs" or "gfs2" filesystem type.

       "inode"
           This passes the <u>-I</u> parameter to the external <b><a href="../man8/mke2fs.8.html">mke2fs</a></b>(8) program which sets the inode  size  (only  for
           ext2/3/4 filesystems at present).

       "sectorsize"
           This  passes  the  <u>-S</u>  parameter  to  external  <b><a href="../man8/mkfs.ufs.8.html">mkfs.ufs</a></b>(8)  program,  which sets sector size for ufs
           filesystem.

       This function returns 0 on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_mkfs_opts_va</b>
        int
        guestfs_mkfs_opts_va (guestfs_h *g,
                              const char *fstype,
                              const char *device,
                              va_list args);

       This is the "va_list variant" of "guestfs_mkfs_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mkfs_opts_argv</b>
        int
        guestfs_mkfs_opts_argv (guestfs_h *g,
                                const char *fstype,
                                const char *device,
                                const struct guestfs_mkfs_opts_argv *optargs);

       This is the "argv variant" of "guestfs_mkfs_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mkfs_b</b>
        int
        guestfs_mkfs_b (guestfs_h *g,
                        const char *fstype,
                        int blocksize,
                        const char *device);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_mkfs" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This  call  is  similar  to  "guestfs_mkfs", but it allows you to control the block size of the resulting
       filesystem.  Supported block sizes depend on the filesystem type, but typically they are  1024,  2048  or
       4096 only.

       For VFAT and NTFS the "blocksize" parameter is treated as the requested cluster size.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.68)

   <b>guestfs_mkfs_btrfs</b>
        int
        guestfs_mkfs_btrfs (guestfs_h *g,
                            char *const *devices,
                            ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_MKFS_BTRFS_ALLOCSTART, int64_t allocstart,
        GUESTFS_MKFS_BTRFS_BYTECOUNT, int64_t bytecount,
        GUESTFS_MKFS_BTRFS_DATATYPE, const char *datatype,
        GUESTFS_MKFS_BTRFS_LEAFSIZE, int leafsize,
        GUESTFS_MKFS_BTRFS_LABEL, const char *label,
        GUESTFS_MKFS_BTRFS_METADATA, const char *metadata,
        GUESTFS_MKFS_BTRFS_NODESIZE, int nodesize,
        GUESTFS_MKFS_BTRFS_SECTORSIZE, int sectorsize,

       Create a btrfs filesystem, allowing all configurables to be set.  For more information  on  the  optional
       arguments, see <b><a href="../man8/mkfs.btrfs.8.html">mkfs.btrfs</a></b>(8).

       Since btrfs filesystems can span multiple devices, this takes a non-empty list of devices.

       To create general filesystems, use "guestfs_mkfs".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "btrfs".  See also "guestfs_feature_available".

       (Added in 1.17.25)

   <b>guestfs_mkfs_btrfs_va</b>
        int
        guestfs_mkfs_btrfs_va (guestfs_h *g,
                               char *const *devices,
                               va_list args);

       This is the "va_list variant" of "guestfs_mkfs_btrfs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mkfs_btrfs_argv</b>
        int
        guestfs_mkfs_btrfs_argv (guestfs_h *g,
                                 char *const *devices,
                                 const struct guestfs_mkfs_btrfs_argv *optargs);

       This is the "argv variant" of "guestfs_mkfs_btrfs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mklost_and_found</b>
        int
        guestfs_mklost_and_found (guestfs_h *g,
                                  const char *mountpoint);

       Make  the "lost+found" directory, normally in the root directory of an ext2/3/4 filesystem.  "mountpoint"
       is the directory under which we try to create the "lost+found" directory.

       This function returns 0 on success or -1 on error.

       (Added in 1.19.56)

   <b>guestfs_mkmountpoint</b>
        int
        guestfs_mkmountpoint (guestfs_h *g,
                              const char *exemptpath);

       "guestfs_mkmountpoint" and "guestfs_rmmountpoint" are specialized calls that can be used to create  extra
       mountpoints before mounting the first filesystem.

       These  calls  are  <u>only</u>  necessary  in some very limited circumstances, mainly the case where you want to
       mount a mix of unrelated and/or read-only filesystems together.

       For example, live CDs often contain a "Russian doll" nest of filesystems, an  ISO  outer  layer,  with  a
       squashfs image inside, with an ext2/3 image inside that.  You can unpack this as follows in guestfish:

        add-ro Fedora-11-i686-Live.iso
        run
        mkmountpoint /cd
        mkmountpoint /sqsh
        mkmountpoint /ext3fs
        mount /dev/sda /cd
        mount-loop /cd/LiveOS/squashfs.img /sqsh
        mount-loop /sqsh/LiveOS/ext3fs.img /ext3fs

       The inner filesystem is now unpacked under the /ext3fs mountpoint.

       "guestfs_mkmountpoint" is not compatible with "guestfs_umount_all".  You may get unexpected errors if you
       try to mix these calls.  It is safest to manually unmount filesystems and remove mountpoints after use.

       "guestfs_umount_all"  unmounts  filesystems  by  sorting the paths longest first, so for this to work for
       manual mountpoints, you must ensure that the innermost mountpoints have the longest pathnames, as in  the
       example code above.

       For more details see https://bugzilla.redhat.com/show_bug.cgi?id=599503

       Autosync  [see  "guestfs_set_autosync", this is set by default on handles] can cause "guestfs_umount_all"
       to be called when the handle is closed which can also trigger these issues.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.62)

   <b>guestfs_mknod</b>
        int
        guestfs_mknod (guestfs_h *g,
                       int mode,
                       int devmajor,
                       int devminor,
                       const char *path);

       This call creates block or character special devices, or named pipes (FIFOs).

       The "mode" parameter should be the mode, using the standard constants.  "devmajor" and "devminor" are the
       device major and minor numbers, only used when creating block and character special devices.

       Note that, just like <b><a href="../man2/mknod.2.html">mknod</a></b>(2), the mode must be bitwise OR'd with S_IFBLK, S_IFCHR, S_IFIFO  or  S_IFSOCK
       (otherwise  this  call just creates a regular file).  These constants are available in the standard Linux
       header files, or you can use "guestfs_mknod_b", "guestfs_mknod_c" or "guestfs_mkfifo" which are  wrappers
       around this command which bitwise OR in the appropriate constant for you.

       The mode actually set is affected by the umask.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "mknod".  See also "guestfs_feature_available".

       (Added in 1.0.55)

   <b>guestfs_mknod_b</b>
        int
        guestfs_mknod_b (guestfs_h *g,
                         int mode,
                         int devmajor,
                         int devminor,
                         const char *path);

       This  call  creates  a block device node called "path" with mode "mode" and device major/minor "devmajor"
       and "devminor".  It is just a convenient wrapper around "guestfs_mknod".

       Unlike with "guestfs_mknod", "mode" <b>must</b> contain only permissions bits.

       The mode actually set is affected by the umask.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "mknod".  See also "guestfs_feature_available".

       (Added in 1.0.55)

   <b>guestfs_mknod_c</b>
        int
        guestfs_mknod_c (guestfs_h *g,
                         int mode,
                         int devmajor,
                         int devminor,
                         const char *path);

       This call creates a char device node called "path" with mode "mode" and device major/minor "devmajor" and
       "devminor".  It is just a convenient wrapper around "guestfs_mknod".

       Unlike with "guestfs_mknod", "mode" <b>must</b> contain only permissions bits.

       The mode actually set is affected by the umask.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "mknod".  See also "guestfs_feature_available".

       (Added in 1.0.55)

   <b>guestfs_mksquashfs</b>
        int
        guestfs_mksquashfs (guestfs_h *g,
                            const char *path,
                            const char *filename,
                            ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_MKSQUASHFS_COMPRESS, const char *compress,
        GUESTFS_MKSQUASHFS_EXCLUDES, char *const *excludes,

       Create a squashfs filesystem for the specified "path".

       The  optional  "compress"  flag  controls  compression.   If  not given, then the output compressed using
       "gzip".  Otherwise one of the following strings may be given  to  select  the  compression  type  of  the
       squashfs: "gzip", "lzma", "lzo", "lz4", "xz".

       The other optional arguments are:

       "excludes"
           A list of wildcards.  Files are excluded if they match any of the wildcards.

       Please  note  that  this  API  may  fail  when used to compress directories with large files, such as the
       resulting squashfs will be over 3GB big.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "squashfs".  See also "guestfs_feature_available".

       (Added in 1.35.25)

   <b>guestfs_mksquashfs_va</b>
        int
        guestfs_mksquashfs_va (guestfs_h *g,
                               const char *path,
                               const char *filename,
                               va_list args);

       This is the "va_list variant" of "guestfs_mksquashfs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mksquashfs_argv</b>
        int
        guestfs_mksquashfs_argv (guestfs_h *g,
                                 const char *path,
                                 const char *filename,
                                 const struct guestfs_mksquashfs_argv *optargs);

       This is the "argv variant" of "guestfs_mksquashfs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mkswap</b>
        int
        guestfs_mkswap (guestfs_h *g,
                        const char *device);

       This function is provided for backwards compatibility with earlier versions  of  libguestfs.   It  simply
       calls "guestfs_mkswap_opts" with no optional arguments.

       (Added in 1.0.55)

   <b>guestfs_mkswap_opts</b>
        int
        guestfs_mkswap_opts (guestfs_h *g,
                             const char *device,
                             ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_MKSWAP_OPTS_LABEL, const char *label,
        GUESTFS_MKSWAP_OPTS_UUID, const char *uuid,

       Create a Linux swap partition on "device".

       The option arguments "label" and "uuid" allow you to set the label and/or UUID of the new swap partition.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.55)

   <b>guestfs_mkswap_opts_va</b>
        int
        guestfs_mkswap_opts_va (guestfs_h *g,
                                const char *device,
                                va_list args);

       This is the "va_list variant" of "guestfs_mkswap_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mkswap_opts_argv</b>
        int
        guestfs_mkswap_opts_argv (guestfs_h *g,
                                  const char *device,
                                  const struct guestfs_mkswap_opts_argv *optargs);

       This is the "argv variant" of "guestfs_mkswap_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mkswap_L</b>
        int
        guestfs_mkswap_L (guestfs_h *g,
                          const char *label,
                          const char *device);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_mkswap" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       Create a swap partition on "device" with label "label".

       Note  that  you  cannot  attach a swap label to a block device (eg. <u>/dev/sda</u>), just to a partition.  This
       appears to be a limitation of the kernel or swap tools.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.55)

   <b>guestfs_mkswap_U</b>
        int
        guestfs_mkswap_U (guestfs_h *g,
                          const char *uuid,
                          const char *device);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_mkswap" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       Create a swap partition on "device" with UUID "uuid".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "linuxfsuuid".  See also "guestfs_feature_available".

       (Added in 1.0.55)

   <b>guestfs_mkswap_file</b>
        int
        guestfs_mkswap_file (guestfs_h *g,
                             const char *path);

       Create a swap file.

       This  command  just  writes  a  swap  file signature to an existing file.  To create the file itself, use
       something like "guestfs_fallocate".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_mktemp</b>
        char *
        guestfs_mktemp (guestfs_h *g,
                        const char *tmpl,
                        ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_MKTEMP_SUFFIX, const char *suffix,

       This  command creates a temporary file.  The "tmpl" parameter should be a full pathname for the temporary
       directory name with the final six characters being "XXXXXX".

       For example: "/tmp/myprogXXXXXX" or "/Temp/myprogXXXXXX", the  second  one  being  suitable  for  Windows
       filesystems.

       The name of the temporary file that was created is returned.

       The temporary file is created with mode 0600 and is owned by root.

       The caller is responsible for deleting the temporary file after use.

       If  the  optional  "suffix" parameter is given, then the suffix (eg. ".txt") is appended to the temporary
       name.

       See also: "guestfs_mkdtemp".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.19.53)

   <b>guestfs_mktemp_va</b>
        char *
        guestfs_mktemp_va (guestfs_h *g,
                           const char *tmpl,
                           va_list args);

       This is the "va_list variant" of "guestfs_mktemp".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mktemp_argv</b>
        char *
        guestfs_mktemp_argv (guestfs_h *g,
                             const char *tmpl,
                             const struct guestfs_mktemp_argv *optargs);

       This is the "argv variant" of "guestfs_mktemp".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_modprobe</b>
        int
        guestfs_modprobe (guestfs_h *g,
                          const char *modulename);

       This loads a kernel module in the appliance.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "linuxmodules".  See also "guestfs_feature_available".

       (Added in 1.0.68)

   <b>guestfs_mount</b>
        int
        guestfs_mount (guestfs_h *g,
                       const char *mountable,
                       const char *mountpoint);

       Mount a guest disk at a position in the filesystem.  Block devices are named <u>/dev/sda</u>,  <u>/dev/sdb</u>  and  so
       on, as they were added to the guest.  If those block devices contain partitions, they will have the usual
       names  (eg.  <u>/dev/sda1</u>).  Also LVM <u>/dev/VG/LV</u>-style names can be used, or ‘mountable’ strings returned by
       "guestfs_list_filesystems" or "guestfs_inspect_get_mountpoints".

       The rules are the same as for <b><a href="../man2/mount.2.html">mount</a></b>(2):  A filesystem must first be mounted on <u>/</u>  before  others  can  be
       mounted.  Other filesystems can only be mounted on directories which already exist.

       The mounted filesystem is writable, if we have sufficient permissions on the underlying device.

       Before  libguestfs  1.13.16,  this  call  implicitly  added the options "sync" and "noatime".  The "sync"
       option greatly slowed writes and caused many problems for users.  If your program might need to work with
       older versions of libguestfs, use "guestfs_mount_options" instead (using an empty string  for  the  first
       parameter if you don't want any options).

       This function returns 0 on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_mount_9p</b>
        int
        guestfs_mount_9p (guestfs_h *g,
                          const char *mounttag,
                          const char *mountpoint,
                          ...);

       <u>This</u>  <u>function</u>  <u>is</u> <u>deprecated.</u>  There is no replacement.  Consult the API documentation in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3) for
       further information.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_MOUNT_9P_OPTIONS, const char *options,

       This call does nothing and returns an error.

       This function returns 0 on success or -1 on error.

       (Added in 1.11.12)

   <b>guestfs_mount_9p_va</b>
        int
        guestfs_mount_9p_va (guestfs_h *g,
                             const char *mounttag,
                             const char *mountpoint,
                             va_list args);

       This is the "va_list variant" of "guestfs_mount_9p".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mount_9p_argv</b>
        int
        guestfs_mount_9p_argv (guestfs_h *g,
                               const char *mounttag,
                               const char *mountpoint,
                               const struct guestfs_mount_9p_argv *optargs);

       This is the "argv variant" of "guestfs_mount_9p".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mount_local</b>
        int
        guestfs_mount_local (guestfs_h *g,
                             const char *localmountpoint,
                             ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_MOUNT_LOCAL_READONLY, int readonly,
        GUESTFS_MOUNT_LOCAL_OPTIONS, const char *options,
        GUESTFS_MOUNT_LOCAL_CACHETIMEOUT, int cachetimeout,
        GUESTFS_MOUNT_LOCAL_DEBUGCALLS, int debugcalls,

       This  call  exports  the  libguestfs-accessible  filesystem  to  a  local  mountpoint  (directory) called
       "localmountpoint".  Ordinary reads and writes  to  files  and  directories  under  "localmountpoint"  are
       redirected through libguestfs.

       If the optional "readonly" flag is set to true, then writes to the filesystem return error "EROFS".

       "options" is a comma-separated list of mount options.  See <b><a href="../man1/guestmount.1.html">guestmount</a></b>(1) for some useful options.

       "cachetimeout"  sets  the  timeout (in seconds) for cached directory entries.  The default is 60 seconds.
       See <b><a href="../man1/guestmount.1.html">guestmount</a></b>(1) for further information.

       If "debugcalls" is set to true, then additional debugging information is generated for every FUSE call.

       When "guestfs_mount_local" returns, the filesystem is ready, but is not processing requests (access to it
       will block).  You have to call "guestfs_mount_local_run" to run the main loop.

       See "MOUNT LOCAL" for full documentation.

       This function returns 0 on success or -1 on error.

       (Added in 1.17.22)

   <b>guestfs_mount_local_va</b>
        int
        guestfs_mount_local_va (guestfs_h *g,
                                const char *localmountpoint,
                                va_list args);

       This is the "va_list variant" of "guestfs_mount_local".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mount_local_argv</b>
        int
        guestfs_mount_local_argv (guestfs_h *g,
                                  const char *localmountpoint,
                                  const struct guestfs_mount_local_argv *optargs);

       This is the "argv variant" of "guestfs_mount_local".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_mount_local_run</b>
        int
        guestfs_mount_local_run (guestfs_h *g);

       Run the main loop which translates kernel calls to libguestfs calls.

       This should only be called after "guestfs_mount_local" returns successfully.  The call  will  not  return
       until the filesystem is unmounted.

       <b>Note</b> you must <u>not</u> make concurrent libguestfs calls on the same handle from another thread.

       You may call this from a different thread than the one which called "guestfs_mount_local", subject to the
       usual rules for threads and libguestfs (see "MULTIPLE HANDLES AND MULTIPLE THREADS").

       See "MOUNT LOCAL" for full documentation.

       This function returns 0 on success or -1 on error.

       (Added in 1.17.22)

   <b>guestfs_mount_loop</b>
        int
        guestfs_mount_loop (guestfs_h *g,
                            const char *file,
                            const char *mountpoint);

       This  command  lets  you  mount  <u>file</u>  (a  filesystem  image in a file) on a mount point.  It is entirely
       equivalent to the command "mount -o loop file mountpoint".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.54)

   <b>guestfs_mount_options</b>
        int
        guestfs_mount_options (guestfs_h *g,
                               const char *options,
                               const char *mountable,
                               const char *mountpoint);

       This is the same as the "guestfs_mount" command, but it allows you to set the mount options  as  for  the
       <b><a href="../man8/mount.8.html">mount</a></b>(8) <u>-o</u> flag.

       If  the  "options"  parameter  is  an  empty  string,  then no options are passed (all options default to
       whatever the filesystem uses).

       This function returns 0 on success or -1 on error.

       (Added in 1.0.10)

   <b>guestfs_mount_ro</b>
        int
        guestfs_mount_ro (guestfs_h *g,
                          const char *mountable,
                          const char *mountpoint);

       This is the same as the "guestfs_mount" command, but it mounts the filesystem with the read-only (<u>-o</u>  <u>ro</u>)
       flag.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.10)

   <b>guestfs_mount_vfs</b>
        int
        guestfs_mount_vfs (guestfs_h *g,
                           const char *options,
                           const char *vfstype,
                           const char *mountable,
                           const char *mountpoint);

       This  is the same as the "guestfs_mount" command, but it allows you to set both the mount options and the
       vfstype as for the <b><a href="../man8/mount.8.html">mount</a></b>(8) <u>-o</u> and <u>-t</u> flags.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.10)

   <b>guestfs_mountable_device</b>
        char *
        guestfs_mountable_device (guestfs_h *g,
                                  const char *mountable);

       Returns the device name of a mountable. In quite a lot of cases, the mountable is the device name.

       However this doesn't apply for btrfs subvolumes, where the mountable is a combination of both the  device
       name  and the subvolume path (see also "guestfs_mountable_subvolume" to extract the subvolume path of the
       mountable if any).

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.33.15)

   <b>guestfs_mountable_subvolume</b>
        char *
        guestfs_mountable_subvolume (guestfs_h *g,
                                     const char *mountable);

       Returns the subvolume path of a mountable. Btrfs subvolumes mountables are  a  combination  of  both  the
       device  name  and  the  subvolume  path (see also "guestfs_mountable_device" to extract the device of the
       mountable).

       If the mountable does not represent a btrfs subvolume, then this function fails and the "errno" is set to
       "EINVAL".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.33.15)

   <b>guestfs_mountpoints</b>
        char **
        guestfs_mountpoints (guestfs_h *g);

       This call is similar to "guestfs_mounts".  That call returns a list of devices.  This one returns a  hash
       table (map) of device name to directory where the device is mounted.

       This  function  returns  a NULL-terminated array of strings, or NULL if there was an error.  The array of
       strings will always have length "2n+1", where "n" keys and values alternate,  followed  by  the  trailing
       NULL entry.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.0.62)

   <b>guestfs_mounts</b>
        char **
        guestfs_mounts (guestfs_h *g);

       This  returns  the list of currently mounted filesystems.  It returns the list of devices (eg. <u>/dev/sda1</u>,
       <u>/dev/VG/LV</u>).

       Some internal mounts are not shown.

       See also: "guestfs_mountpoints"

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 0.8)

   <b>guestfs_mv</b>
        int
        guestfs_mv (guestfs_h *g,
                    const char *src,
                    const char *dest);

       This  moves  a  file  from  "src"  to "dest" where "dest" is either a destination filename or destination
       directory.

       See also: "guestfs_rename".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.18)

   <b>guestfs_nr_devices</b>
        int
        guestfs_nr_devices (guestfs_h *g);

       This returns the number of whole block devices that were added.  This  is  the  same  as  the  number  of
       devices that would be returned if you called "guestfs_list_devices".

       To find out the maximum number of devices that could be added, call "guestfs_max_disks".

       On error this function returns -1.

       (Added in 1.19.15)

   <b>guestfs_ntfs_3g_probe</b>
        int
        guestfs_ntfs_3g_probe (guestfs_h *g,
                               int rw,
                               const char *device);

       This  command runs the <b><a href="../man8/ntfs-3g.probe.8.html">ntfs-3g.probe</a></b>(8) command which probes an NTFS "device" for mountability.  (Not all
       NTFS volumes can be mounted read-write, and some cannot be mounted at all).

       "rw" is a boolean flag.  Set it to true if you want to test if the volume can be mounted read-write.  Set
       it to false if you want to test if the volume can be mounted read-only.

       The return value is an integer which 0 if the operation would succeed, or some non-zero value  documented
       in the <b><a href="../man8/ntfs-3g.probe.8.html">ntfs-3g.probe</a></b>(8) manual page.

       On error this function returns -1.

       This function depends on the feature "ntfs3g".  See also "guestfs_feature_available".

       (Added in 1.0.43)

   <b>guestfs_ntfscat_i</b>
        int
        guestfs_ntfscat_i (guestfs_h *g,
                           const char *device,
                           int64_t inode,
                           const char *filename);

       Download a file given its inode from a NTFS filesystem and save it as <u>filename</u> on the local machine.

       This allows to download some otherwise inaccessible files such as the ones within the $Extend folder.

       The filesystem from which to extract the file must be unmounted, otherwise the call will fail.

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.33.14)

   <b>guestfs_ntfsclone_in</b>
        int
        guestfs_ntfsclone_in (guestfs_h *g,
                              const char *backupfile,
                              const char *device);

       Restore  the  "backupfile" (from a previous call to "guestfs_ntfsclone_out") to "device", overwriting any
       existing contents of this device.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "ntfs3g".  See also "guestfs_feature_available".

       (Added in 1.17.9)

   <b>guestfs_ntfsclone_out</b>
        int
        guestfs_ntfsclone_out (guestfs_h *g,
                               const char *device,
                               const char *backupfile,
                               ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_NTFSCLONE_OUT_METADATAONLY, int metadataonly,
        GUESTFS_NTFSCLONE_OUT_RESCUE, int rescue,
        GUESTFS_NTFSCLONE_OUT_IGNOREFSCHECK, int ignorefscheck,
        GUESTFS_NTFSCLONE_OUT_PRESERVETIMESTAMPS, int preservetimestamps,
        GUESTFS_NTFSCLONE_OUT_FORCE, int force,

       Stream  the NTFS filesystem "device" to the local file "backupfile".  The format used for the backup file
       is a special format used by the <b><a href="../man8/ntfsclone.8.html">ntfsclone</a></b>(8) tool.

       If the optional "metadataonly" flag is true, then <u>only</u> the metadata is saved, losing all  the  user  data
       (this is useful for diagnosing some filesystem problems).

       The  optional  "rescue",  "ignorefscheck",  "preservetimestamps"  and "force" flags have precise meanings
       detailed in the <b><a href="../man8/ntfsclone.8.html">ntfsclone</a></b>(8) man page.

       Use "guestfs_ntfsclone_in" to restore the file back to a libguestfs device.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "ntfs3g".  See also "guestfs_feature_available".

       (Added in 1.17.9)

   <b>guestfs_ntfsclone_out_va</b>
        int
        guestfs_ntfsclone_out_va (guestfs_h *g,
                                  const char *device,
                                  const char *backupfile,
                                  va_list args);

       This is the "va_list variant" of "guestfs_ntfsclone_out".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_ntfsclone_out_argv</b>
        int
        guestfs_ntfsclone_out_argv (guestfs_h *g,
                                    const char *device,
                                    const char *backupfile,
                                    const struct guestfs_ntfsclone_out_argv *optargs);

       This is the "argv variant" of "guestfs_ntfsclone_out".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_ntfsfix</b>
        int
        guestfs_ntfsfix (guestfs_h *g,
                         const char *device,
                         ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_NTFSFIX_CLEARBADSECTORS, int clearbadsectors,

       This  command  repairs some fundamental NTFS inconsistencies, resets the NTFS journal file, and schedules
       an NTFS consistency check for the first boot into Windows.

       This is <u>not</u> an equivalent of Windows "chkdsk".  It does <u>not</u> scan the filesystem for inconsistencies.

       The optional "clearbadsectors" flag clears the list of bad sectors.  This is useful after cloning a  disk
       with bad sectors to a new disk.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "ntfs3g".  See also "guestfs_feature_available".

       (Added in 1.17.9)

   <b>guestfs_ntfsfix_va</b>
        int
        guestfs_ntfsfix_va (guestfs_h *g,
                            const char *device,
                            va_list args);

       This is the "va_list variant" of "guestfs_ntfsfix".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_ntfsfix_argv</b>
        int
        guestfs_ntfsfix_argv (guestfs_h *g,
                              const char *device,
                              const struct guestfs_ntfsfix_argv *optargs);

       This is the "argv variant" of "guestfs_ntfsfix".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_ntfsresize</b>
        int
        guestfs_ntfsresize (guestfs_h *g,
                            const char *device);

       This  function  is  provided  for backwards compatibility with earlier versions of libguestfs.  It simply
       calls "guestfs_ntfsresize_opts" with no optional arguments.

       (Added in 1.3.2)

   <b>guestfs_ntfsresize_opts</b>
        int
        guestfs_ntfsresize_opts (guestfs_h *g,
                                 const char *device,
                                 ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_NTFSRESIZE_OPTS_SIZE, int64_t size,
        GUESTFS_NTFSRESIZE_OPTS_FORCE, int force,

       This command resizes an NTFS filesystem, expanding or shrinking it to the size of the underlying device.

       The optional parameters are:

       "size"
           The  new  size  (in  bytes)  of  the  filesystem.   If  omitted, the filesystem is resized to fit the
           container (eg. partition).

       "force"
           If this option is true, then force the resize of the filesystem even if the filesystem is  marked  as
           requiring a consistency check.

           After  the  resize  operation,  the filesystem is always marked as requiring a consistency check (for
           safety).  You have to boot into Windows to perform this check and clear this condition.  If you <u>don't</u>
           set the "force" option then it is not possible to  call  "guestfs_ntfsresize"  multiple  times  on  a
           single filesystem without booting into Windows between each resize.

       See also <b><a href="../man8/ntfsresize.8.html">ntfsresize</a></b>(8).

       This function returns 0 on success or -1 on error.

       This function depends on the feature "ntfsprogs".  See also "guestfs_feature_available".

       (Added in 1.3.2)

   <b>guestfs_ntfsresize_opts_va</b>
        int
        guestfs_ntfsresize_opts_va (guestfs_h *g,
                                    const char *device,
                                    va_list args);

       This is the "va_list variant" of "guestfs_ntfsresize_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_ntfsresize_opts_argv</b>
        int
        guestfs_ntfsresize_opts_argv (guestfs_h *g,
                                      const char *device,
                                      const struct guestfs_ntfsresize_opts_argv *optargs);

       This is the "argv variant" of "guestfs_ntfsresize_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_ntfsresize_size</b>
        int
        guestfs_ntfsresize_size (guestfs_h *g,
                                 const char *device,
                                 int64_t size);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_ntfsresize" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This command is the same as "guestfs_ntfsresize" except that it allows you to specify the  new  size  (in
       bytes) explicitly.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "ntfsprogs".  See also "guestfs_feature_available".

       (Added in 1.3.14)

   <b>guestfs_parse_environment</b>
        int
        guestfs_parse_environment (guestfs_h *g);

       Parse   the   program’s   environment   and  set  flags  in  the  handle  accordingly.   For  example  if
       "LIBGUESTFS_DEBUG=1" then the ‘verbose’ flag is set in the handle.

       <u>Most</u> <u>programs</u> <u>do</u> <u>not</u> <u>need</u> <u>to</u> <u>call</u> <u>this</u>.  It is done implicitly when you call "guestfs_create".

       See "ENVIRONMENT VARIABLES" for a list of environment variables that can affect libguestfs handles.   See
       also "guestfs_create_flags", and "guestfs_parse_environment_list".

       This function returns 0 on success or -1 on error.

       (Added in 1.19.53)

   <b>guestfs_parse_environment_list</b>
        int
        guestfs_parse_environment_list (guestfs_h *g,
                                        char *const *environment);

       Parse  the  list  of  strings in the argument "environment" and set flags in the handle accordingly.  For
       example if "LIBGUESTFS_DEBUG=1" is a string in the list, then the ‘verbose’ flag is set in the handle.

       This is the same as "guestfs_parse_environment" except that it parses an explicit list of strings instead
       of the program's environment.

       This function returns 0 on success or -1 on error.

       (Added in 1.19.53)

   <b>guestfs_part_add</b>
        int
        guestfs_part_add (guestfs_h *g,
                          const char *device,
                          const char *prlogex,
                          int64_t startsect,
                          int64_t endsect);

       This command adds a partition to  "device".   If  there  is  no  partition  table  on  the  device,  call
       "guestfs_part_init" first.

       The  "prlogex"  parameter  is the type of partition.  Normally you should pass "p" or "primary" here, but
       MBR partition tables also support "l" (or "logical") and "e" (or "extended") partition types.

       "startsect" and "endsect" are the start and end of the partition in <u>sectors</u>.  "endsect" may be  negative,
       which means it counts backwards from the end of the disk (-1 is the last sector).

       Creating a partition which covers the whole disk is not so easy.  Use "guestfs_part_disk" to do that.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.78)

   <b>guestfs_part_del</b>
        int
        guestfs_part_del (guestfs_h *g,
                          const char *device,
                          int partnum);

       This command deletes the partition numbered "partnum" on "device".

       Note  that  in  the  case  of  MBR  partitioning, deleting an extended partition also deletes any logical
       partitions it contains.

       This function returns 0 on success or -1 on error.

       (Added in 1.3.2)

   <b>guestfs_part_disk</b>
        int
        guestfs_part_disk (guestfs_h *g,
                           const char *device,
                           const char *parttype);

       This command is simply a combination of "guestfs_part_init" followed by "guestfs_part_add"  to  create  a
       single primary partition covering the whole disk.

       "parttype"  is  the partition table type, usually "mbr" or "gpt", but other possible values are described
       in "guestfs_part_init".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.78)

   <b>guestfs_part_expand_gpt</b>
        int
        guestfs_part_expand_gpt (guestfs_h *g,
                                 const char *device);

       Move backup GPT data structures to the end of the disk.  This is useful in case of in-place image  expand
       since disk space after backup GPT header is not usable.  This is equivalent to "sgdisk -e".

       See also <b><a href="../man8/sgdisk.8.html">sgdisk</a></b>(8).

       This function returns 0 on success or -1 on error.

       This function depends on the feature "gdisk".  See also "guestfs_feature_available".

       (Added in 1.33.2)

   <b>guestfs_part_get_bootable</b>
        int
        guestfs_part_get_bootable (guestfs_h *g,
                                   const char *device,
                                   int partnum);

       This command returns true if the partition "partnum" on "device" has the bootable flag set.

       See also "guestfs_part_set_bootable".

       This function returns a C truth value on success or -1 on error.

       (Added in 1.3.2)

   <b>guestfs_part_get_disk_guid</b>
        char *
        guestfs_part_get_disk_guid (guestfs_h *g,
                                    const char *device);

       Return  the  disk  identifier  (GUID)  of  a  GPT-partitioned "device".  Behaviour is undefined for other
       partition types.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.33.2)

   <b>guestfs_part_get_gpt_attributes</b>
        int64_t
        guestfs_part_get_gpt_attributes (guestfs_h *g,
                                         const char *device,
                                         int partnum);

       Return the attribute flags of numbered GPT partition "partnum".  An error is returned for MBR partitions.

       On error this function returns -1.

       (Added in 1.21.1)

   <b>guestfs_part_get_gpt_guid</b>
        char *
        guestfs_part_get_gpt_guid (guestfs_h *g,
                                   const char *device,
                                   int partnum);

       Return the GUID of numbered GPT partition "partnum".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.29.25)

   <b>guestfs_part_get_gpt_type</b>
        char *
        guestfs_part_get_gpt_type (guestfs_h *g,
                                   const char *device,
                                   int partnum);

       Return the type GUID of numbered GPT partition "partnum".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.21.1)

   <b>guestfs_part_get_mbr_id</b>
        int
        guestfs_part_get_mbr_id (guestfs_h *g,
                                 const char *device,
                                 int partnum);

       Returns the MBR type byte (also known as the ID byte) from the numbered partition "partnum".

       Note that only MBR (old DOS-style) partitions have type bytes.  You will get undefined results for  other
       partition table types (see "guestfs_part_get_parttype").

       On error this function returns -1.

       (Added in 1.3.2)

   <b>guestfs_part_get_mbr_part_type</b>
        char *
        guestfs_part_get_mbr_part_type (guestfs_h *g,
                                        const char *device,
                                        int partnum);

       This returns the partition type of an MBR partition numbered "partnum" on device "device".

       It returns "primary", "logical", or "extended".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.29.32)

   <b>guestfs_part_get_name</b>
        char *
        guestfs_part_get_name (guestfs_h *g,
                               const char *device,
                               int partnum);

       This  gets  the  partition name on partition numbered "partnum" on device "device".  Note that partitions
       are numbered from 1.

       The partition name can only be read on certain types of partition table.  This works on "gpt" but not  on
       "mbr" partitions.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.25.33)

   <b>guestfs_part_get_parttype</b>
        char *
        guestfs_part_get_parttype (guestfs_h *g,
                                   const char *device);

       This command examines the partition table on "device" and returns the partition table type (format) being
       used.

       Common  return  values include: "msdos" (a DOS/Windows style MBR partition table), "gpt" (a GPT/EFI-style
       partition table).  Other values are possible, although unusual.  See "guestfs_part_init" for a full list.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.78)

   <b>guestfs_part_init</b>
        int
        guestfs_part_init (guestfs_h *g,
                           const char *device,
                           const char *parttype);

       This creates an empty partition table on "device" of one of the partition types  listed  below.   Usually
       "parttype" should be either "msdos" or "gpt" (for large disks).

       Initially there are no partitions.  Following this, you should call "guestfs_part_add" for each partition
       required.

       Possible values for "parttype" are:

       "efi"
       "gpt"
           Intel EFI / GPT partition table.

           This is recommended for &gt;= 2 TB partitions that will be accessed from Linux and Intel-based Mac OS X.
           It also has limited backwards compatibility with the "mbr" format.

       "mbr"
       "msdos"
           The  standard  PC  "Master Boot Record" (MBR) format used by MS-DOS and Windows.  This partition type
           will <b>only</b> work for device sizes up to 2 TB.  For large disks we recommend using "gpt".

       Other partition table types that may work but are not supported include:

       "aix"
           AIX disk labels.

       "amiga"
       "rdb"
           Amiga "Rigid Disk Block" format.

       "bsd"
           BSD disk labels.

       "dasd"
           DASD, used on IBM mainframes.

       "dvh"
           MIPS/SGI volumes.

       "mac"
           Old Mac partition format.  Modern Macs use "gpt".

       "pc98"
           NEC PC-98 format, common in Japan apparently.

       "sun"
           Sun disk labels.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.78)

   <b>guestfs_part_list</b>
        struct guestfs_partition_list *
        guestfs_part_list (guestfs_h *g,
                           const char *device);

       This command parses the partition table on "device" and returns the list of partitions found.

       The fields in the returned structure are:

       "part_num"
           Partition number, counting from 1.

       "part_start"
           Start of the partition <u>in</u> <u>bytes</u>.  To get sectors you have to divide by the device’s sector size,  see
           "guestfs_blockdev_getss".

       "part_end"
           End of the partition in bytes.

       "part_size"
           Size of the partition in bytes.

       This  function  returns  a  "struct guestfs_partition_list *", or NULL if there was an error.  <u>The</u> <u>caller</u>
       <u>must</u> <u>call</u> <u>"guestfs_free_partition_list"</u> <u>after</u> <u>use</u>.

       (Added in 1.0.78)

   <b>guestfs_part_resize</b>
        int
        guestfs_part_resize (guestfs_h *g,
                             const char *device,
                             int partnum,
                             int64_t endsect);

       This command resizes the partition numbered "partnum" on "device" by moving the end position.

       Note that this does not modify any filesystem present in the partition.  If you wish to do this, you will
       need to use filesystem resizing commands like "guestfs_resize2fs".

       When growing a partition you will want to grow the filesystem afterwards, but when shrinking, you need to
       shrink the filesystem before the partition.

       This function returns 0 on success or -1 on error.

       (Added in 1.37.20)

   <b>guestfs_part_set_bootable</b>
        int
        guestfs_part_set_bootable (guestfs_h *g,
                                   const char *device,
                                   int partnum,
                                   int bootable);

       This sets the bootable flag on partition numbered "partnum" on device "device".  Note that partitions are
       numbered from 1.

       The bootable flag is used by some operating systems (notably Windows) to  determine  which  partition  to
       boot from.  It is by no means universally recognized.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.78)

   <b>guestfs_part_set_disk_guid</b>
        int
        guestfs_part_set_disk_guid (guestfs_h *g,
                                    const char *device,
                                    const char *guid);

       Set the disk identifier (GUID) of a GPT-partitioned "device" to "guid".  Return an error if the partition
       table of "device" isn't GPT, or if "guid" is not a valid GUID.

       This function returns 0 on success or -1 on error.

       (Added in 1.33.2)

   <b>guestfs_part_set_disk_guid_random</b>
        int
        guestfs_part_set_disk_guid_random (guestfs_h *g,
                                           const char *device);

       Set  the  disk  identifier (GUID) of a GPT-partitioned "device" to a randomly generated value.  Return an
       error if the partition table of "device" isn't GPT.

       This function returns 0 on success or -1 on error.

       (Added in 1.33.2)

   <b>guestfs_part_set_gpt_attributes</b>
        int
        guestfs_part_set_gpt_attributes (guestfs_h *g,
                                         const char *device,
                                         int partnum,
                                         int64_t attributes);

       Set the attribute flags of numbered GPT partition "partnum" to  "attributes".  Return  an  error  if  the
       partition table of "device" isn't GPT.

       See  https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries  for a useful list of partition
       attributes.

       This function returns 0 on success or -1 on error.

       (Added in 1.21.1)

   <b>guestfs_part_set_gpt_guid</b>
        int
        guestfs_part_set_gpt_guid (guestfs_h *g,
                                   const char *device,
                                   int partnum,
                                   const char *guid);

       Set the GUID of numbered GPT partition "partnum" to "guid".  Return an error if the  partition  table  of
       "device" isn't GPT, or if "guid" is not a valid GUID.

       This function returns 0 on success or -1 on error.

       (Added in 1.29.25)

   <b>guestfs_part_set_gpt_type</b>
        int
        guestfs_part_set_gpt_type (guestfs_h *g,
                                   const char *device,
                                   int partnum,
                                   const char *guid);

       Set  the  type GUID of numbered GPT partition "partnum" to "guid". Return an error if the partition table
       of "device" isn't GPT, or if "guid" is not a valid GUID.

       See https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs for a  useful  list  of  type
       GUIDs.

       This function returns 0 on success or -1 on error.

       (Added in 1.21.1)

   <b>guestfs_part_set_mbr_id</b>
        int
        guestfs_part_set_mbr_id (guestfs_h *g,
                                 const char *device,
                                 int partnum,
                                 int idbyte);

       Sets the MBR type byte (also known as the ID byte) of the numbered partition "partnum" to "idbyte".  Note
       that  the type bytes quoted in most documentation are in fact hexadecimal numbers, but usually documented
       without any leading "0x" which might be confusing.

       Note that only MBR (old DOS-style) partitions have type bytes.  You will get undefined results for  other
       partition table types (see "guestfs_part_get_parttype").

       This function returns 0 on success or -1 on error.

       (Added in 1.3.2)

   <b>guestfs_part_set_name</b>
        int
        guestfs_part_set_name (guestfs_h *g,
                               const char *device,
                               int partnum,
                               const char *name);

       This  sets  the  partition name on partition numbered "partnum" on device "device".  Note that partitions
       are numbered from 1.

       The partition name can only be set on certain types of partition table.  This works on "gpt" but  not  on
       "mbr" partitions.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.78)

   <b>guestfs_part_to_dev</b>
        char *
        guestfs_part_to_dev (guestfs_h *g,
                             const char *partition);

       This  function  takes  a partition name (eg. "/dev/sdb1") and removes the partition number, returning the
       device name (eg. "/dev/sdb").

       The named partition must exist, for example as a string returned from "guestfs_list_partitions".

       See also "guestfs_part_to_partnum", "guestfs_device_index".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.5.15)

   <b>guestfs_part_to_partnum</b>
        int
        guestfs_part_to_partnum (guestfs_h *g,
                                 const char *partition);

       This function takes a partition name (eg. "/dev/sdb1") and returns the partition number (eg. 1).

       The named partition must exist, for example as a string returned from "guestfs_list_partitions".

       See also "guestfs_part_to_dev".

       On error this function returns -1.

       (Added in 1.13.25)

   <b>guestfs_ping_daemon</b>
        int
        guestfs_ping_daemon (guestfs_h *g);

       This is a test probe into the guestfs daemon running  inside  the  libguestfs  appliance.   Calling  this
       function  checks  that  the daemon responds to the ping message, without affecting the daemon or attached
       block device(s) in any other way.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.18)

   <b>guestfs_pread</b>
        char *
        guestfs_pread (guestfs_h *g,
                       const char *path,
                       int count,
                       int64_t offset,
                       size_t *size_r);

       This command lets you read part of a file.  It reads "count" bytes of the  file,  starting  at  "offset",
       from file "path".

       This may read fewer bytes than requested.  For further details see the <b><a href="../man2/pread.2.html">pread</a></b>(2) system call.

       See also "guestfs_pwrite", "guestfs_pread_device".

       This function returns a buffer, or NULL on error.  The size of the returned buffer is written to *size_r.
       <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>buffer</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.77)

   <b>guestfs_pread_device</b>
        char *
        guestfs_pread_device (guestfs_h *g,
                              const char *device,
                              int count,
                              int64_t offset,
                              size_t *size_r);

       This command lets you read part of a block device.  It reads  "count"  bytes  of  "device",  starting  at
       "offset".

       This may read fewer bytes than requested.  For further details see the <b><a href="../man2/pread.2.html">pread</a></b>(2) system call.

       See also "guestfs_pread".

       This function returns a buffer, or NULL on error.  The size of the returned buffer is written to *size_r.
       <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>buffer</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.5.21)

   <b>guestfs_pvchange_uuid</b>
        int
        guestfs_pvchange_uuid (guestfs_h *g,
                               const char *device);

       Generate a new random UUID for the physical volume "device".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.19.26)

   <b>guestfs_pvchange_uuid_all</b>
        int
        guestfs_pvchange_uuid_all (guestfs_h *g);

       Generate new random UUIDs for all physical volumes.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.19.26)

   <b>guestfs_pvcreate</b>
        int
        guestfs_pvcreate (guestfs_h *g,
                          const char *device);

       This creates an LVM physical volume on the named "device", where "device" should usually be  a  partition
       name such as <u>/dev/sda1</u>.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 0.8)

   <b>guestfs_pvremove</b>
        int
        guestfs_pvremove (guestfs_h *g,
                          const char *device);

       This wipes a physical volume "device" so that LVM will no longer recognise it.

       The  implementation  uses the <b><a href="../man8/pvremove.8.html">pvremove</a></b>(8) command which refuses to wipe physical volumes that contain any
       volume groups, so you have to remove those first.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.0.13)

   <b>guestfs_pvresize</b>
        int
        guestfs_pvresize (guestfs_h *g,
                          const char *device);

       This resizes (expands or shrinks) an existing LVM physical volume to match the new size of the underlying
       device.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.0.26)

   <b>guestfs_pvresize_size</b>
        int
        guestfs_pvresize_size (guestfs_h *g,
                               const char *device,
                               int64_t size);

       This command is the same as "guestfs_pvresize" except that it allows you to  specify  the  new  size  (in
       bytes) explicitly.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.3.14)

   <b>guestfs_pvs</b>
        char **
        guestfs_pvs (guestfs_h *g);

       List all the physical volumes detected.  This is the equivalent of the <b><a href="../man8/pvs.8.html">pvs</a></b>(8) command.

       This returns a list of just the device names that contain PVs (eg. <u>/dev/sda2</u>).

       See also "guestfs_pvs_full".

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 0.4)

   <b>guestfs_pvs_full</b>
        struct guestfs_lvm_pv_list *
        guestfs_pvs_full (guestfs_h *g);

       List all the physical volumes detected.  This is the  equivalent  of  the  <b><a href="../man8/pvs.8.html">pvs</a></b>(8)  command.   The  "full"
       version includes all fields.

       This  function  returns a "struct guestfs_lvm_pv_list *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>
       <u>call</u> <u>"guestfs_free_lvm_pv_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 0.4)

   <b>guestfs_pvuuid</b>
        char *
        guestfs_pvuuid (guestfs_h *g,
                        const char *device);

       This command returns the UUID of the LVM PV "device".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.87)

   <b>guestfs_pwrite</b>
        int
        guestfs_pwrite (guestfs_h *g,
                        const char *path,
                        const char *content,
                        size_t content_size,
                        int64_t offset);

       This command writes to part of a file.  It writes the data buffer "content" to the file  "path"  starting
       at offset "offset".

       This  command  implements  the <b><a href="../man2/pwrite.2.html">pwrite</a></b>(2) system call, and like that system call it may not write the full
       data requested.  The return value is the number of bytes that were actually written to  the  file.   This
       could even be 0, although short writes are unlikely for regular files in ordinary circumstances.

       See also "guestfs_pread", "guestfs_pwrite_device".

       On error this function returns -1.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.3.14)

   <b>guestfs_pwrite_device</b>
        int
        guestfs_pwrite_device (guestfs_h *g,
                               const char *device,
                               const char *content,
                               size_t content_size,
                               int64_t offset);

       This command writes to part of a device.  It writes the data buffer "content"  to  "device"  starting  at
       offset "offset".

       This  command  implements  the <b><a href="../man2/pwrite.2.html">pwrite</a></b>(2) system call, and like that system call it may not write the full
       data requested (although short writes to  disk  devices  and  partitions  are  probably  impossible  with
       standard Linux kernels).

       See also "guestfs_pwrite".

       On error this function returns -1.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.5.20)

   <b>guestfs_read_file</b>
        char *
        guestfs_read_file (guestfs_h *g,
                           const char *path,
                           size_t *size_r);

       This calls returns the contents of the file "path" as a buffer.

       Unlike "guestfs_cat",  this  function  can  correctly  handle  files  that  contain  embedded  ASCII  NUL
       characters.

       This function returns a buffer, or NULL on error.  The size of the returned buffer is written to *size_r.
       <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>buffer</u> <u>after</u> <u>use</u>.

       (Added in 1.0.63)

   <b>guestfs_read_lines</b>
        char **
        guestfs_read_lines (guestfs_h *g,
                            const char *path);

       Return the contents of the file named "path".

       The  file contents are returned as a list of lines.  Trailing "LF" and "CRLF" character sequences are <u>not</u>
       returned.

       Note that this function cannot  correctly  handle  binary  files  (specifically,  files  containing  "\0"
       character which is treated as end of string).  For those you need to use the "guestfs_read_file" function
       and split the buffer into lines yourself.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 0.7)

   <b>guestfs_readdir</b>
        struct guestfs_dirent_list *
        guestfs_readdir (guestfs_h *g,
                         const char *dir);

       This returns the list of directory entries in directory "dir".

       All entries in the directory are returned, including "." and "..".   The  entries  are  <u>not</u>  sorted,  but
       returned in the same order as the underlying filesystem.

       Also this call returns basic file type information about each file.  The "ftyp" field will contain one of
       the following characters:

       'b' Block special

       'c' Char special

       'd' Directory

       'f' FIFO (named pipe)

       'l' Symbolic link

       'r' Regular file

       's' Socket

       'u' Unknown file type

       '?' The <b><a href="../man3/readdir.3.html">readdir</a></b>(3) call returned a "d_type" field with an unexpected value

       This  function  is  primarily  intended  for  use  by  programs.   To  get  a  simple  list of names, use
       "guestfs_ls".  To get a printable directory for human consumption, use "guestfs_ll".

       This function returns a "struct guestfs_dirent_list *", or NULL if there was an error.  <u>The</u>  <u>caller</u>  <u>must</u>
       <u>call</u> <u>"guestfs_free_dirent_list"</u> <u>after</u> <u>use</u>.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.0.55)

   <b>guestfs_readlink</b>
        char *
        guestfs_readlink (guestfs_h *g,
                          const char *path);

       This command reads the target of a symbolic link.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.66)

   <b>guestfs_readlinklist</b>
        char **
        guestfs_readlinklist (guestfs_h *g,
                              const char *path,
                              char *const *names);

       This call allows you to do a "readlink" operation on multiple files, where all files are in the directory
       "path".  "names" is the list of files from this directory.

       On  return  you get a list of strings, with a one-to-one correspondence to the "names" list.  Each string
       is the value of the symbolic link.

       If the <b><a href="../man2/readlink.2.html">readlink</a></b>(2) operation fails on any name, then the corresponding result string is the empty  string
       "".   However the whole operation is completed even if there were <b><a href="../man2/readlink.2.html">readlink</a></b>(2) errors, and so you can call
       this function with names where you don't know if they are symbolic links already  (albeit  slightly  less
       efficient).

       This call is intended for programs that want to efficiently list a directory contents without making many
       round-trips.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.0.77)

   <b>guestfs_realpath</b>
        char *
        guestfs_realpath (guestfs_h *g,
                          const char *path);

       Return the canonicalized absolute pathname of "path".  The returned path has no  ".",  ".."  or  symbolic
       link path elements.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.66)

   <b>guestfs_remount</b>
        int
        guestfs_remount (guestfs_h *g,
                         const char *mountpoint,
                         ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_REMOUNT_RW, int rw,

       This call allows you to change the "rw" (readonly/read-write) flag on an already  mounted  filesystem  at
       "mountpoint", converting a readonly filesystem to be read-write, or vice-versa.

       Note  that  at  the  moment  you must supply the "optional" "rw" parameter.  In future we may allow other
       flags to be adjusted.

       This function returns 0 on success or -1 on error.

       (Added in 1.23.2)

   <b>guestfs_remount_va</b>
        int
        guestfs_remount_va (guestfs_h *g,
                            const char *mountpoint,
                            va_list args);

       This is the "va_list variant" of "guestfs_remount".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_remount_argv</b>
        int
        guestfs_remount_argv (guestfs_h *g,
                              const char *mountpoint,
                              const struct guestfs_remount_argv *optargs);

       This is the "argv variant" of "guestfs_remount".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_remove_drive</b>
        int
        guestfs_remove_drive (guestfs_h *g,
                              const char *label);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  There is no replacement.  Consult the API documentation in  <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3)  for
       further information.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This call does nothing and returns an error.

       This function returns 0 on success or -1 on error.

       (Added in 1.19.49)

   <b>guestfs_removexattr</b>
        int
        guestfs_removexattr (guestfs_h *g,
                             const char *xattr,
                             const char *path);

       This call removes the extended attribute named "xattr" of the file "path".

       See also: "guestfs_lremovexattr", <b><a href="../man5/attr.5.html">attr</a></b>(5).

       This function returns 0 on success or -1 on error.

       This function depends on the feature "linuxxattrs".  See also "guestfs_feature_available".

       (Added in 1.0.59)

   <b>guestfs_rename</b>
        int
        guestfs_rename (guestfs_h *g,
                        const char *oldpath,
                        const char *newpath);

       Rename a file to a new place on the same filesystem.  This is the same  as  the  Linux  <b><a href="../man2/rename.2.html">rename</a></b>(2)  system
       call.  In most cases you are better to use "guestfs_mv" instead.

       This function returns 0 on success or -1 on error.

       (Added in 1.21.5)

   <b>guestfs_resize2fs</b>
        int
        guestfs_resize2fs (guestfs_h *g,
                           const char *device);

       This resizes an ext2, ext3 or ext4 filesystem to match the size of the underlying device.

       See also "RESIZE2FS ERRORS".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.27)

   <b>guestfs_resize2fs_M</b>
        int
        guestfs_resize2fs_M (guestfs_h *g,
                             const char *device);

       This command is the same as "guestfs_resize2fs", but the filesystem is resized to its minimum size.  This
       works like the <u>-M</u> option to the <b><a href="../man8/resize2fs.8.html">resize2fs</a></b>(8) command.

       To get the resulting size of the filesystem you should call "guestfs_tune2fs_l" and read the "Block size"
       and "Block count" values.  These two numbers, multiplied together, give the resulting size of the minimal
       filesystem in bytes.

       See also "RESIZE2FS ERRORS".

       This function returns 0 on success or -1 on error.

       (Added in 1.9.4)

   <b>guestfs_resize2fs_size</b>
        int
        guestfs_resize2fs_size (guestfs_h *g,
                                const char *device,
                                int64_t size);

       This  command  is  the  same as "guestfs_resize2fs" except that it allows you to specify the new size (in
       bytes) explicitly.

       See also "RESIZE2FS ERRORS".

       This function returns 0 on success or -1 on error.

       (Added in 1.3.14)

   <b>guestfs_rm</b>
        int
        guestfs_rm (guestfs_h *g,
                    const char *path);

       Remove the single file "path".

       This function returns 0 on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_rm_f</b>
        int
        guestfs_rm_f (guestfs_h *g,
                      const char *path);

       Remove the file "path".

       If the file doesn't exist, that error is ignored.  (Other errors, eg. I/O errors or bad  paths,  are  not
       ignored)

       This   call   cannot   remove  directories.   Use  "guestfs_rmdir"  to  remove  an  empty  directory,  or
       "guestfs_rm_rf" to remove directories recursively.

       This function returns 0 on success or -1 on error.

       (Added in 1.19.42)

   <b>guestfs_rm_rf</b>
        int
        guestfs_rm_rf (guestfs_h *g,
                       const char *path);

       Remove the file or directory "path", recursively removing the contents if its a directory.  This is  like
       the "rm -rf" shell command.

       This function returns 0 on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_rmdir</b>
        int
        guestfs_rmdir (guestfs_h *g,
                       const char *path);

       Remove the single directory "path".

       This function returns 0 on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_rmmountpoint</b>
        int
        guestfs_rmmountpoint (guestfs_h *g,
                              const char *exemptpath);

       This   call   removes  a  mountpoint  that  was  previously  created  with  "guestfs_mkmountpoint".   See
       "guestfs_mkmountpoint" for full details.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.62)

   <b>guestfs_rsync</b>
        int
        guestfs_rsync (guestfs_h *g,
                       const char *src,
                       const char *dest,
                       ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_RSYNC_ARCHIVE, int archive,
        GUESTFS_RSYNC_DELETEDEST, int deletedest,

       This call may be used to copy or synchronize two directories under the same libguestfs handle.  This uses
       the <b><a href="../man1/rsync.1.html">rsync</a></b>(1) program which uses a fast algorithm that avoids copying files unnecessarily.

       "src" and "dest" are the source and destination directories.  Files are copied from "src" to "dest".

       The optional arguments are:

       "archive"
           Turns on archive mode.  This is the same as passing the <u>--archive</u> flag to "rsync".

       "deletedest"
           Delete files at the destination that do not exist at the source.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "rsync".  See also "guestfs_feature_available".

       (Added in 1.19.29)

   <b>guestfs_rsync_va</b>
        int
        guestfs_rsync_va (guestfs_h *g,
                          const char *src,
                          const char *dest,
                          va_list args);

       This is the "va_list variant" of "guestfs_rsync".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_rsync_argv</b>
        int
        guestfs_rsync_argv (guestfs_h *g,
                            const char *src,
                            const char *dest,
                            const struct guestfs_rsync_argv *optargs);

       This is the "argv variant" of "guestfs_rsync".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_rsync_in</b>
        int
        guestfs_rsync_in (guestfs_h *g,
                          const char *remote,
                          const char *dest,
                          ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_RSYNC_IN_ARCHIVE, int archive,
        GUESTFS_RSYNC_IN_DELETEDEST, int deletedest,

       This call may be used to copy or synchronize the filesystem on the host or on a remote computer with  the
       filesystem  within  libguestfs.   This  uses the <b><a href="../man1/rsync.1.html">rsync</a></b>(1) program which uses a fast algorithm that avoids
       copying files unnecessarily.

       This call only works if the network is enabled.  See "guestfs_set_network" or  the  <u>--network</u>  option  to
       various tools like <b><a href="../man1/guestfish.1.html">guestfish</a></b>(1).

       Files  are copied from the remote server and directory specified by "remote" to the destination directory
       "dest".

       The format of the remote server string is defined by <b><a href="../man1/rsync.1.html">rsync</a></b>(1).  Note that there is no  way  to  supply  a
       password or passphrase so the target must be set up not to require one.

       The optional arguments are the same as those of "guestfs_rsync".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "rsync".  See also "guestfs_feature_available".

       (Added in 1.19.29)

   <b>guestfs_rsync_in_va</b>
        int
        guestfs_rsync_in_va (guestfs_h *g,
                             const char *remote,
                             const char *dest,
                             va_list args);

       This is the "va_list variant" of "guestfs_rsync_in".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_rsync_in_argv</b>
        int
        guestfs_rsync_in_argv (guestfs_h *g,
                               const char *remote,
                               const char *dest,
                               const struct guestfs_rsync_in_argv *optargs);

       This is the "argv variant" of "guestfs_rsync_in".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_rsync_out</b>
        int
        guestfs_rsync_out (guestfs_h *g,
                           const char *src,
                           const char *remote,
                           ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_RSYNC_OUT_ARCHIVE, int archive,
        GUESTFS_RSYNC_OUT_DELETEDEST, int deletedest,

       This call may be used to copy or synchronize the filesystem within libguestfs with a  filesystem  on  the
       host  or  on  a  remote computer.  This uses the <b><a href="../man1/rsync.1.html">rsync</a></b>(1) program which uses a fast algorithm that avoids
       copying files unnecessarily.

       This call only works if the network is enabled.  See "guestfs_set_network" or  the  <u>--network</u>  option  to
       various tools like <b><a href="../man1/guestfish.1.html">guestfish</a></b>(1).

       Files  are  copied  from  the  source  directory  "src"  to  the remote server and directory specified by
       "remote".

       The format of the remote server string is defined by <b><a href="../man1/rsync.1.html">rsync</a></b>(1).  Note that there is no  way  to  supply  a
       password or passphrase so the target must be set up not to require one.

       The optional arguments are the same as those of "guestfs_rsync".

       Globbing  does  not  happen  on  the "src" parameter.  In programs which use the API directly you have to
       expand wildcards yourself (see "guestfs_glob_expand").  In guestfish you can use the "glob" command  (see
       "glob" in <b><a href="../man1/guestfish.1.html">guestfish</a></b>(1)), for example:

        &gt;&lt;fs&gt; glob rsync-out /* rsync://remote/

       This function returns 0 on success or -1 on error.

       This function depends on the feature "rsync".  See also "guestfs_feature_available".

       (Added in 1.19.29)

   <b>guestfs_rsync_out_va</b>
        int
        guestfs_rsync_out_va (guestfs_h *g,
                              const char *src,
                              const char *remote,
                              va_list args);

       This is the "va_list variant" of "guestfs_rsync_out".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_rsync_out_argv</b>
        int
        guestfs_rsync_out_argv (guestfs_h *g,
                                const char *src,
                                const char *remote,
                                const struct guestfs_rsync_out_argv *optargs);

       This is the "argv variant" of "guestfs_rsync_out".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_scrub_device</b>
        int
        guestfs_scrub_device (guestfs_h *g,
                              const char *device);

       This command writes patterns over "device" to make data retrieval more difficult.

       It is an interface to the <b><a href="../man1/scrub.1.html">scrub</a></b>(1) program.  See that manual page for more details.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "scrub".  See also "guestfs_feature_available".

       (Added in 1.0.52)

   <b>guestfs_scrub_file</b>
        int
        guestfs_scrub_file (guestfs_h *g,
                            const char *file);

       This command writes patterns over a file to make data retrieval more difficult.

       The file is <u>removed</u> after scrubbing.

       It is an interface to the <b><a href="../man1/scrub.1.html">scrub</a></b>(1) program.  See that manual page for more details.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "scrub".  See also "guestfs_feature_available".

       (Added in 1.0.52)

   <b>guestfs_scrub_freespace</b>
        int
        guestfs_scrub_freespace (guestfs_h *g,
                                 const char *dir);

       This  command  creates the directory "dir" and then fills it with files until the filesystem is full, and
       scrubs the files as for "guestfs_scrub_file", and deletes them.  The intention is to scrub any free space
       on the partition containing "dir".

       It is an interface to the <b><a href="../man1/scrub.1.html">scrub</a></b>(1) program.  See that manual page for more details.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "scrub".  See also "guestfs_feature_available".

       (Added in 1.0.52)

   <b>guestfs_selinux_relabel</b>
        int
        guestfs_selinux_relabel (guestfs_h *g,
                                 const char *specfile,
                                 const char *path,
                                 ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_SELINUX_RELABEL_FORCE, int force,

       SELinux relabel parts of the filesystem.

       The  "specfile" parameter controls the policy spec file used.  You have to parse "/etc/selinux/config" to
       find the correct SELinux policy and then pass the spec file, usually:  "<a href="file:/etc/selinux/">/etc/selinux/</a>"  +  <u>selinuxtype</u>  +
       "/contexts/files/file_contexts".

       The  required  "path" parameter is the top level directory where relabelling starts.  Normally you should
       pass "path" as "/" to relabel the whole guest filesystem.

       The optional "force" boolean controls whether the context is  reset  for  customizable  files,  and  also
       whether the user, role and range parts of the file context is changed.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "selinuxrelabel".  See also "guestfs_feature_available".

       (Added in 1.33.43)

   <b>guestfs_selinux_relabel_va</b>
        int
        guestfs_selinux_relabel_va (guestfs_h *g,
                                    const char *specfile,
                                    const char *path,
                                    va_list args);

       This is the "va_list variant" of "guestfs_selinux_relabel".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_selinux_relabel_argv</b>
        int
        guestfs_selinux_relabel_argv (guestfs_h *g,
                                      const char *specfile,
                                      const char *path,
                                      const struct guestfs_selinux_relabel_argv *optargs);

       This is the "argv variant" of "guestfs_selinux_relabel".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_set_append</b>
        int
        guestfs_set_append (guestfs_h *g,
                            const char *append);

       This function is used to add additional options to the libguestfs appliance kernel command line.

       The default is "NULL" unless overridden by setting "LIBGUESTFS_APPEND" environment variable.

       Setting  "append"  to  "NULL" means <u>no</u> additional options are passed (libguestfs always adds a few of its
       own).

       This function returns 0 on success or -1 on error.

       (Added in 1.0.26)

   <b>guestfs_set_attach_method</b>
        int
        guestfs_set_attach_method (guestfs_h *g,
                                   const char *backend);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_set_backend" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       Set the method that libguestfs uses to connect to the backend guestfsd daemon.

       See "BACKEND".

       This function returns 0 on success or -1 on error.

       (Added in 1.9.8)

   <b>guestfs_set_autosync</b>
        int
        guestfs_set_autosync (guestfs_h *g,
                              int autosync);

       If  "autosync"  is  true,  this  enables  autosync.   Libguestfs  will make a best effort attempt to make
       filesystems consistent and synchronized when the handle is closed (also  if  the  program  exits  without
       closing handles).

       This is enabled by default (since libguestfs 1.5.24, previously it was disabled by default).

       This function returns 0 on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_set_backend</b>
        int
        guestfs_set_backend (guestfs_h *g,
                             const char *backend);

       Set the method that libguestfs uses to connect to the backend guestfsd daemon.

       This handle property was previously called the "attach method".

       See "BACKEND".

       This function returns 0 on success or -1 on error.

       (Added in 1.21.26)

   <b>guestfs_set_backend_setting</b>
        int
        guestfs_set_backend_setting (guestfs_h *g,
                                     const char *name,
                                     const char *val);

       Append  "name=value"  to  the  backend settings string list.  However if a string already exists matching
       "name" or beginning with "name=", then that setting is replaced.

       See "BACKEND", "BACKEND SETTINGS".

       This function returns 0 on success or -1 on error.

       (Added in 1.27.2)

   <b>guestfs_set_backend_settings</b>
        int
        guestfs_set_backend_settings (guestfs_h *g,
                                      char *const *settings);

       Set a list of zero or more settings which are passed through to the current backend.  Each setting  is  a
       string which is interpreted in a backend-specific way, or ignored if not understood by the backend.

       The default value is an empty list, unless the environment variable "LIBGUESTFS_BACKEND_SETTINGS" was set
       when the handle was created.  This environment variable contains a colon-separated list of settings.

       This  call  replaces  all  backend  settings.   If  you  want  to  replace  a single backend setting, see
       "guestfs_set_backend_setting".    If   you   want   to   clear   a   single    backend    setting,    see
       "guestfs_clear_backend_setting".

       See "BACKEND", "BACKEND SETTINGS".

       This function returns 0 on success or -1 on error.

       (Added in 1.25.24)

   <b>guestfs_set_cachedir</b>
        int
        guestfs_set_cachedir (guestfs_h *g,
                              const char *cachedir);

       Set  the directory used by the handle to store the appliance cache, when using a supermin appliance.  The
       appliance is cached and shared between all handles which have the same effective user ID.

       The  environment  variables  "LIBGUESTFS_CACHEDIR"  and  "TMPDIR"   control   the   default   value:   If
       "LIBGUESTFS_CACHEDIR"  is  set,  then  that  is  the  default.  Else if "TMPDIR" is set, then that is the
       default.  Else <u><a href="file:/var/tmp">/var/tmp</a></u> is the default.

       This function returns 0 on success or -1 on error.

       (Added in 1.19.58)

   <b>guestfs_set_direct</b>
        int
        guestfs_set_direct (guestfs_h *g,
                            int direct);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_internal_get_console_socket" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       If  the  direct  appliance mode flag is enabled, then stdin and stdout are passed directly through to the
       appliance once it is launched.

       One  consequence  of  this  is  that  log  messages  aren't  caught  by  the  library  and   handled   by
       "guestfs_set_log_message_callback", but go straight to stdout.

       You probably don't want to use this unless you know what you are doing.

       The default is disabled.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.72)

   <b>guestfs_set_e2attrs</b>
        int
        guestfs_set_e2attrs (guestfs_h *g,
                             const char *file,
                             const char *attrs,
                             ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_SET_E2ATTRS_CLEAR, int clear,

       This sets or clears the file attributes "attrs" associated with the inode <u>file</u>.

       "attrs" is a string of characters representing file attributes.  See "guestfs_get_e2attrs" for a list  of
       possible attributes.  Not all attributes can be changed.

       If optional boolean "clear" is not present or false, then the "attrs" listed are set in the inode.

       If "clear" is true, then the "attrs" listed are cleared in the inode.

       In both cases, other attributes not present in the "attrs" string are left unchanged.

       These attributes are only present when the file is located on an ext2/3/4 filesystem.  Using this call on
       other filesystem types will result in an error.

       This function returns 0 on success or -1 on error.

       (Added in 1.17.31)

   <b>guestfs_set_e2attrs_va</b>
        int
        guestfs_set_e2attrs_va (guestfs_h *g,
                                const char *file,
                                const char *attrs,
                                va_list args);

       This is the "va_list variant" of "guestfs_set_e2attrs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_set_e2attrs_argv</b>
        int
        guestfs_set_e2attrs_argv (guestfs_h *g,
                                  const char *file,
                                  const char *attrs,
                                  const struct guestfs_set_e2attrs_argv *optargs);

       This is the "argv variant" of "guestfs_set_e2attrs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_set_e2generation</b>
        int
        guestfs_set_e2generation (guestfs_h *g,
                                  const char *file,
                                  int64_t generation);

       This sets the ext2 file generation of a file.

       See "guestfs_get_e2generation".

       This function returns 0 on success or -1 on error.

       (Added in 1.17.31)

   <b>guestfs_set_e2label</b>
        int
        guestfs_set_e2label (guestfs_h *g,
                             const char *device,
                             const char *label);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_set_label" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This sets the ext2/3/4 filesystem label of the filesystem on "device" to "label".  Filesystem labels  are
       limited to 16 characters.

       You  can  use  either  "guestfs_tune2fs_l"  or  "guestfs_get_e2label"  to  return the existing label on a
       filesystem.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.15)

   <b>guestfs_set_e2uuid</b>
        int
        guestfs_set_e2uuid (guestfs_h *g,
                            const char *device,
                            const char *uuid);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_set_uuid" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This  sets  the ext2/3/4 filesystem UUID of the filesystem on "device" to "uuid".  The format of the UUID
       and alternatives such as "clear", "random" and "time" are described in the <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8) manpage.

       You can use "guestfs_vfs_uuid" to return the existing UUID of a filesystem.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.15)

   <b>guestfs_set_hv</b>
        int
        guestfs_set_hv (guestfs_h *g,
                        const char *hv);

       Set the hypervisor binary that we will use.  The hypervisor depends on the backend, but  is  usually  the
       location of the qemu/KVM hypervisor.

       The default is chosen when the library was compiled by the configure script.

       You can also override this by setting the "LIBGUESTFS_HV" environment variable.

       Note  that you should call this function as early as possible after creating the handle.  This is because
       some pre-launch operations depend on testing qemu features (by running "qemu -help").  If the qemu binary
       changes, we don't retest features, and so you might see  inconsistent  results.   Using  the  environment
       variable "LIBGUESTFS_HV" is safest of all since that picks the qemu binary at the same time as the handle
       is created.

       This function returns 0 on success or -1 on error.

       (Added in 1.23.17)

   <b>guestfs_set_identifier</b>
        int
        guestfs_set_identifier (guestfs_h *g,
                                const char *identifier);

       This  is  an  informative  string  which  the  caller may optionally set in the handle.  It is printed in
       various places, allowing the current handle to be identified in debugging output.

       One important place is when tracing is enabled.  If the identifier string is not an  empty  string,  then
       trace messages change from this:

        libguestfs: trace: get_tmpdir
        libguestfs: trace: get_tmpdir = "<a href="file:/tmp">/tmp</a>"

       to this:

        libguestfs: trace: ID: get_tmpdir
        libguestfs: trace: ID: get_tmpdir = "<a href="file:/tmp">/tmp</a>"

       where "ID" is the identifier string set by this call.

       The  identifier  must only contain alphanumeric ASCII characters, underscore and minus sign.  The default
       is the empty string.

       See also "guestfs_set_program", "guestfs_set_trace", "guestfs_get_identifier".

       This function returns 0 on success or -1 on error.

       (Added in 1.31.14)

   <b>guestfs_set_label</b>
        int
        guestfs_set_label (guestfs_h *g,
                           const char *mountable,
                           const char *label);

       Set the filesystem label on "mountable" to "label".

       Only some filesystem types support labels, and libguestfs supports setting labels on  only  a  subset  of
       these.

       ext2, ext3, ext4
           Labels are limited to 16 bytes.

       NTFS
           Labels are limited to 128 unicode characters.

       XFS The label is limited to 12 bytes.  The filesystem must not be mounted when trying to set the label.

       btrfs
           The  label is limited to 255 bytes and some characters are not allowed.  Setting the label on a btrfs
           subvolume will set the label on its parent filesystem.  The  filesystem  must  not  be  mounted  when
           trying to set the label.

       fat The label is limited to 11 bytes.

       swap
           The label is limited to 16 bytes.

       If  there  is  no support for changing the label for the type of the specified filesystem, set_label will
       fail and set errno as ENOTSUP.

       To read the label on a filesystem, call "guestfs_vfs_label".

       This function returns 0 on success or -1 on error.

       (Added in 1.17.9)

   <b>guestfs_set_libvirt_requested_credential</b>
        int
        guestfs_set_libvirt_requested_credential (guestfs_h *g,
                                                  int index,
                                                  const char *cred,
                                                  size_t cred_size);

       After requesting the "index"'th credential from the user, call this function to pass the answer  back  to
       libvirt.

       See "LIBVIRT AUTHENTICATION" for documentation and example code.

       This function returns 0 on success or -1 on error.

       (Added in 1.19.52)

   <b>guestfs_set_libvirt_supported_credentials</b>
        int
        guestfs_set_libvirt_supported_credentials (guestfs_h *g,
                                                   char *const *creds);

       Call  this  function before setting an event handler for "GUESTFS_EVENT_LIBVIRT_AUTH", to supply the list
       of credential types that the program knows how to process.

       The "creds" list must be a non-empty list of strings.  Possible strings are:

       "username"
       "authname"
       "language"
       "cnonce"
       "passphrase"
       "echoprompt"
       "noechoprompt"
       "realm"
       "external"

       See libvirt documentation for the meaning of these credential types.

       See "LIBVIRT AUTHENTICATION" for documentation and example code.

       This function returns 0 on success or -1 on error.

       (Added in 1.19.52)

   <b>guestfs_set_memsize</b>
        int
        guestfs_set_memsize (guestfs_h *g,
                             int memsize);

       This sets the memory size in megabytes allocated to the hypervisor.  This only has any effect  if  called
       before "guestfs_launch".

       You  can  also  change this by setting the environment variable "LIBGUESTFS_MEMSIZE" before the handle is
       created.

       For more information on the architecture of libguestfs, see <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

       This function returns 0 on success or -1 on error.

       (Added in 1.0.55)

   <b>guestfs_set_network</b>
        int
        guestfs_set_network (guestfs_h *g,
                             int network);

       If "network" is true, then the network is enabled in the libguestfs appliance.  The default is false.

       This affects whether commands are able to access the network (see "RUNNING COMMANDS").

       You must call this before calling "guestfs_launch", otherwise it has no effect.

       This function returns 0 on success or -1 on error.

       (Added in 1.5.4)

   <b>guestfs_set_path</b>
        int
        guestfs_set_path (guestfs_h *g,
                          const char *searchpath);

       Set the path that libguestfs searches for kernel and initrd.img.

       The default is "$libdir/guestfs" unless overridden by setting "LIBGUESTFS_PATH" environment variable.

       Setting "path" to "NULL" restores the default path.

       This function returns 0 on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_set_pgroup</b>
        int
        guestfs_set_pgroup (guestfs_h *g,
                            int pgroup);

       If "pgroup" is true, child processes are placed into their own process group.

       The practical upshot of this is that signals like "SIGINT" (from users pressing "^C") won't  be  received
       by the child process.

       The default for this flag is false, because usually you want "^C" to kill the subprocess.  Guestfish sets
       this  flag to true when used interactively, so that "^C" can cancel long-running commands gracefully (see
       "guestfs_user_cancel").

       This function returns 0 on success or -1 on error.

       (Added in 1.11.18)

   <b>guestfs_set_program</b>
        int
        guestfs_set_program (guestfs_h *g,
                             const char *program);

       Set the program name.  This is an informative string which the main program may  optionally  set  in  the
       handle.

       When  the  handle  is created, the program name in the handle is set to the basename from "argv[0]".  The
       program name can never be "NULL".

       This function returns 0 on success or -1 on error.

       (Added in 1.21.29)

   <b>guestfs_set_qemu</b>
        int
        guestfs_set_qemu (guestfs_h *g,
                          const char *hv);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_set_hv" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       Set the hypervisor binary (usually qemu) that we will use.

       The default is chosen when the library was compiled by the configure script.

       You can also override this by setting the "LIBGUESTFS_HV" environment variable.

       Setting "hv" to "NULL" restores the default qemu binary.

       Note  that you should call this function as early as possible after creating the handle.  This is because
       some pre-launch operations depend on testing qemu features (by running "qemu -help").  If the qemu binary
       changes, we don't retest features, and so you might see  inconsistent  results.   Using  the  environment
       variable "LIBGUESTFS_HV" is safest of all since that picks the qemu binary at the same time as the handle
       is created.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.6)

   <b>guestfs_set_recovery_proc</b>
        int
        guestfs_set_recovery_proc (guestfs_h *g,
                                   int recoveryproc);

       If  this  is  called with the parameter "false" then "guestfs_launch" does not create a recovery process.
       The purpose of the recovery process is to stop runaway hypervisor processes in the case  where  the  main
       program aborts abruptly.

       This only has any effect if called before "guestfs_launch", and the default is true.

       About  the only time when you would want to disable this is if the main process will fork itself into the
       background ("daemonize" itself).  In this case the recovery process thinks  that  the  main  program  has
       disappeared and so kills the hypervisor, which is not very helpful.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.77)

   <b>guestfs_set_selinux</b>
        int
        guestfs_set_selinux (guestfs_h *g,
                             int selinux);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_selinux_relabel" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This sets the selinux flag that is passed to the appliance at boot  time.   The  default  is  "selinux=0"
       (disabled).

       Note that if SELinux is enabled, it is always in Permissive mode ("enforcing=0").

       For more information on the architecture of libguestfs, see <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

       This function returns 0 on success or -1 on error.

       (Added in 1.0.67)

   <b>guestfs_set_smp</b>
        int
        guestfs_set_smp (guestfs_h *g,
                         int smp);

       Change  the  number  of  virtual  CPUs assigned to the appliance.  The default is 1.  Increasing this may
       improve performance, though often it has no effect.

       This function must be called before "guestfs_launch".

       This function returns 0 on success or -1 on error.

       (Added in 1.13.15)

   <b>guestfs_set_tmpdir</b>
        int
        guestfs_set_tmpdir (guestfs_h *g,
                            const char *tmpdir);

       Set the directory used by the handle to store temporary files.

       The  environment  variables  "LIBGUESTFS_TMPDIR"   and   "TMPDIR"   control   the   default   value:   If
       "LIBGUESTFS_TMPDIR" is set, then that is the default.  Else if "TMPDIR" is set, then that is the default.
       Else <u><a href="file:/tmp">/tmp</a></u> is the default.

       This function returns 0 on success or -1 on error.

       (Added in 1.19.58)

   <b>guestfs_set_trace</b>
        int
        guestfs_set_trace (guestfs_h *g,
                           int trace);

       If the command trace flag is set to 1, then libguestfs calls, parameters and return values are traced.

       If  you  want to trace C API calls into libguestfs (and other libraries) then possibly a better way is to
       use the external <b><a href="../man1/ltrace.1.html">ltrace</a></b>(1) command.

       Command traces are disabled unless the environment variable "LIBGUESTFS_TRACE" is defined and set to 1.

       Trace messages are normally sent to "stderr", unless you register a callback to send them somewhere  else
       (see "guestfs_set_event_callback").

       This function returns 0 on success or -1 on error.

       (Added in 1.0.69)

   <b>guestfs_set_uuid</b>
        int
        guestfs_set_uuid (guestfs_h *g,
                          const char *device,
                          const char *uuid);

       Set  the filesystem UUID on "device" to "uuid".  If this fails and the errno is ENOTSUP, means that there
       is no support for changing the UUID for the type of the specified filesystem.

       Only some filesystem types support setting UUIDs.

       To read the UUID on a filesystem, call "guestfs_vfs_uuid".

       This function returns 0 on success or -1 on error.

       (Added in 1.23.10)

   <b>guestfs_set_uuid_random</b>
        int
        guestfs_set_uuid_random (guestfs_h *g,
                                 const char *device);

       Set the filesystem UUID on "device" to a random UUID.  If this fails and the errno is ENOTSUP, means that
       there is no support for changing the UUID for the type of the specified filesystem.

       Only some filesystem types support setting UUIDs.

       To read the UUID on a filesystem, call "guestfs_vfs_uuid".

       This function returns 0 on success or -1 on error.

       (Added in 1.29.50)

   <b>guestfs_set_verbose</b>
        int
        guestfs_set_verbose (guestfs_h *g,
                             int verbose);

       If "verbose" is true, this turns on verbose messages.

       Verbose messages are disabled unless the environment variable "LIBGUESTFS_DEBUG" is defined and set to 1.

       Verbose messages are normally sent to "stderr", unless you register a callback  to  send  them  somewhere
       else (see "guestfs_set_event_callback").

       This function returns 0 on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_setcon</b>
        int
        guestfs_setcon (guestfs_h *g,
                        const char *context);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_selinux_relabel" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This sets the SELinux security context of the daemon to the string "context".

       See the documentation about SELINUX in <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3).

       This function returns 0 on success or -1 on error.

       This function depends on the feature "selinux".  See also "guestfs_feature_available".

       (Added in 1.0.67)

   <b>guestfs_setxattr</b>
        int
        guestfs_setxattr (guestfs_h *g,
                          const char *xattr,
                          const char *val,
                          int vallen,
                          const char *path);

       This call sets the extended attribute named "xattr" of the file "path" to  the  value  "val"  (of  length
       "vallen").  The value is arbitrary 8 bit data.

       See also: "guestfs_lsetxattr", <b><a href="../man5/attr.5.html">attr</a></b>(5).

       This function returns 0 on success or -1 on error.

       This function depends on the feature "linuxxattrs".  See also "guestfs_feature_available".

       (Added in 1.0.59)

   <b>guestfs_sfdisk</b>
        int
        guestfs_sfdisk (guestfs_h *g,
                        const char *device,
                        int cyls,
                        int heads,
                        int sectors,
                        char *const *lines);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_part_add" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This is a direct interface to the <b><a href="../man8/sfdisk.8.html">sfdisk</a></b>(8) program for creating partitions on block devices.

       "device" should be a block device, for example <u>/dev/sda</u>.

       "cyls", "heads" and "sectors" are the number of cylinders, heads and sectors on  the  device,  which  are
       passed  directly  to <b><a href="../man8/sfdisk.8.html">sfdisk</a></b>(8) as the <u>-C</u>, <u>-H</u> and <u>-S</u> parameters.  If you pass 0 for any of these, then the
       corresponding parameter is omitted.  Usually for ‘large’ disks, you can just pass 0 for  these,  but  for
       small  (floppy-sized) disks, <b><a href="../man8/sfdisk.8.html">sfdisk</a></b>(8) (or rather, the kernel) cannot work out the right geometry and you
       will need to tell it.

       "lines" is a list of lines that we feed to <b><a href="../man8/sfdisk.8.html">sfdisk</a></b>(8).   For  more  information  refer  to  the  <b><a href="../man8/sfdisk.8.html">sfdisk</a></b>(8)
       manpage.

       To  create  a single partition occupying the whole disk, you would pass "lines" as a single element list,
       when the single element being the string "," (comma).

       See also: "guestfs_sfdisk_l", "guestfs_sfdisk_N", "guestfs_part_init"

       This function returns 0 on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_sfdiskM</b>
        int
        guestfs_sfdiskM (guestfs_h *g,
                         const char *device,
                         char *const *lines);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_part_add" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This  is  a  simplified interface to the "guestfs_sfdisk" command, where partition sizes are specified in
       megabytes only (rounded to the nearest cylinder) and you don't  need  to  specify  the  cyls,  heads  and
       sectors parameters which were rarely if ever used anyway.

       See also: "guestfs_sfdisk", the <b><a href="../man8/sfdisk.8.html">sfdisk</a></b>(8) manpage and "guestfs_part_disk"

       This function returns 0 on success or -1 on error.

       (Added in 1.0.55)

   <b>guestfs_sfdisk_N</b>
        int
        guestfs_sfdisk_N (guestfs_h *g,
                          const char *device,
                          int partnum,
                          int cyls,
                          int heads,
                          int sectors,
                          const char *line);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_part_add" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This runs <b><a href="../man8/sfdisk.8.html">sfdisk</a></b>(8) option to modify just the single partition "n" (note: "n" counts from 1).

       For other parameters, see "guestfs_sfdisk".   You  should  usually  pass  0  for  the  cyls/heads/sectors
       parameters.

       See also: "guestfs_part_add"

       This function returns 0 on success or -1 on error.

       (Added in 1.0.26)

   <b>guestfs_sfdisk_disk_geometry</b>
        char *
        guestfs_sfdisk_disk_geometry (guestfs_h *g,
                                      const char *device);

       This  displays the disk geometry of "device" read from the partition table.  Especially in the case where
       the underlying block device has been resized, this can  be  different  from  the  kernel’s  idea  of  the
       geometry (see "guestfs_sfdisk_kernel_geometry").

       The result is in human-readable format, and not designed to be parsed.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.26)

   <b>guestfs_sfdisk_kernel_geometry</b>
        char *
        guestfs_sfdisk_kernel_geometry (guestfs_h *g,
                                        const char *device);

       This displays the kernel’s idea of the geometry of "device".

       The result is in human-readable format, and not designed to be parsed.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.26)

   <b>guestfs_sfdisk_l</b>
        char *
        guestfs_sfdisk_l (guestfs_h *g,
                          const char *device);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_part_list" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This displays the partition table on "device", in the human-readable output of the <b><a href="../man8/sfdisk.8.html">sfdisk</a></b>(8) command.  It
       is not intended to be parsed.

       See also: "guestfs_part_list"

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.26)

   <b>guestfs_sh</b>
        char *
        guestfs_sh (guestfs_h *g,
                    const char *command);

       This call runs a command from the guest filesystem via the guest’s <u><a href="file:/bin/sh">/bin/sh</a></u>.

       This is like "guestfs_command", but passes the command to:

        <a href="file:/bin/sh">/bin/sh</a> -c "command"

       Depending on the guest’s shell, this usually results in wildcards being expanded, shell expressions being
       interpolated and so on.

       All the provisos about "guestfs_command" apply to this call.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.50)

   <b>guestfs_sh_lines</b>
        char **
        guestfs_sh_lines (guestfs_h *g,
                          const char *command);

       This is the same as "guestfs_sh", but splits the result into a list of lines.

       See also: "guestfs_command_lines"

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.0.50)

   <b>guestfs_shutdown</b>
        int
        guestfs_shutdown (guestfs_h *g);

       This  is  the  opposite of "guestfs_launch".  It performs an orderly shutdown of the backend process(es).
       If the autosync flag is set (which is the default) then the disk image is synchronized.

       If the subprocess exits with an error then this function will  return  an  error,  which  should  <u>not</u>  be
       ignored (it may indicate that the disk image could not be written out properly).

       It is safe to call this multiple times.  Extra calls are ignored.

       This call does <u>not</u> close or free up the handle.  You still need to call "guestfs_close" afterwards.

       "guestfs_close"  will  call  this  if you don't do it explicitly, but note that any errors are ignored in
       that case.

       This function returns 0 on success or -1 on error.

       (Added in 1.19.16)

   <b>guestfs_sleep</b>
        int
        guestfs_sleep (guestfs_h *g,
                       int secs);

       Sleep for "secs" seconds.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.41)

   <b>guestfs_stat</b>
        struct guestfs_stat *
        guestfs_stat (guestfs_h *g,
                      const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_statns" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       Returns file information for the given "path".

       This is the same as the <b><a href="../man2/stat.2.html">stat</a></b>(2) system call.

       This  function  returns  a  "struct guestfs_stat *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u> <u>call</u>
       <u>"guestfs_free_stat"</u> <u>after</u> <u>use</u>.

       (Added in 1.9.2)

   <b>guestfs_statns</b>
        struct guestfs_statns *
        guestfs_statns (guestfs_h *g,
                        const char *path);

       Returns file information for the given "path".

       This is the same as the <b><a href="../man2/stat.2.html">stat</a></b>(2) system call.

       This function returns a "struct guestfs_statns *", or NULL if there was an error.  <u>The</u> <u>caller</u>  <u>must</u>  <u>call</u>
       <u>"guestfs_free_statns"</u> <u>after</u> <u>use</u>.

       (Added in 1.27.53)

   <b>guestfs_statvfs</b>
        struct guestfs_statvfs *
        guestfs_statvfs (guestfs_h *g,
                         const char *path);

       Returns  file system statistics for any mounted file system.  "path" should be a file or directory in the
       mounted file system (typically it is the mount point itself, but it doesn't need to be).

       This is the same as the <b><a href="../man2/statvfs.2.html">statvfs</a></b>(2) system call.

       This function returns a "struct guestfs_statvfs *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>  <u>call</u>
       <u>"guestfs_free_statvfs"</u> <u>after</u> <u>use</u>.

       (Added in 1.9.2)

   <b>guestfs_strings</b>
        char **
        guestfs_strings (guestfs_h *g,
                         const char *path);

       This runs the <b><a href="../man1/strings.1.html">strings</a></b>(1) command on a file and returns the list of printable strings found.

       The  "strings"  command has, in the past, had problems with parsing untrusted files.  These are mitigated
       in the current version of libguestfs, but see "CVE-2014-8484".

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.22)

   <b>guestfs_strings_e</b>
        char **
        guestfs_strings_e (guestfs_h *g,
                           const char *encoding,
                           const char *path);

       This is like the "guestfs_strings" command, but allows you to specify the encoding of  strings  that  are
       looked for in the source file "path".

       Allowed encodings are:

       s   Single  7-bit-byte  characters  like ASCII and the ASCII-compatible parts of ISO-8859-X (this is what
           "guestfs_strings" uses).

       S   Single 8-bit-byte characters.

       b   16-bit big endian strings such as those encoded in UTF-16BE or UCS-2BE.

       l (lower case letter L)
           16-bit little endian such as UTF-16LE and UCS-2LE.  This is useful for examining binaries in  Windows
           guests.

       B   32-bit big endian such as UCS-4BE.

       L   32-bit little endian such as UCS-4LE.

       The returned strings are transcoded to UTF-8.

       The  "strings"  command has, in the past, had problems with parsing untrusted files.  These are mitigated
       in the current version of libguestfs, but see "CVE-2014-8484".

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.22)

   <b>guestfs_swapoff_device</b>
        int
        guestfs_swapoff_device (guestfs_h *g,
                                const char *device);

       This  command  disables  the  libguestfs  appliance  swap  device  or  partition  named  "device".    See
       "guestfs_swapon_device".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_swapoff_file</b>
        int
        guestfs_swapoff_file (guestfs_h *g,
                              const char *file);

       This command disables the libguestfs appliance swap on file.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_swapoff_label</b>
        int
        guestfs_swapoff_label (guestfs_h *g,
                               const char *label);

       This command disables the libguestfs appliance swap on labeled swap partition.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_swapoff_uuid</b>
        int
        guestfs_swapoff_uuid (guestfs_h *g,
                              const char *uuid);

       This command disables the libguestfs appliance swap partition with the given UUID.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "linuxfsuuid".  See also "guestfs_feature_available".

       (Added in 1.0.66)

   <b>guestfs_swapon_device</b>
        int
        guestfs_swapon_device (guestfs_h *g,
                               const char *device);

       This  command  enables  the libguestfs appliance to use the swap device or partition named "device".  The
       increased memory is made available for all commands, for example those  run  using  "guestfs_command"  or
       "guestfs_sh".

       Note that you should not swap to existing guest swap partitions unless you know what you are doing.  They
       may  contain hibernation information, or other information that the guest doesn't want you to trash.  You
       also risk leaking information about the host to the guest this way.  Instead, attach a new host device to
       the guest and swap on that.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_swapon_file</b>
        int
        guestfs_swapon_file (guestfs_h *g,
                             const char *file);

       This command enables swap to a file.  See "guestfs_swapon_device" for other notes.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_swapon_label</b>
        int
        guestfs_swapon_label (guestfs_h *g,
                              const char *label);

       This command enables swap to a labeled swap partition.  See "guestfs_swapon_device" for other notes.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.66)

   <b>guestfs_swapon_uuid</b>
        int
        guestfs_swapon_uuid (guestfs_h *g,
                             const char *uuid);

       This command enables swap to a swap partition with the given UUID.  See "guestfs_swapon_device" for other
       notes.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "linuxfsuuid".  See also "guestfs_feature_available".

       (Added in 1.0.66)

   <b>guestfs_sync</b>
        int
        guestfs_sync (guestfs_h *g);

       This syncs the disk, so that any writes are flushed through to the underlying disk image.

       You should always call this if you have modified a disk image, before closing the handle.

       This function returns 0 on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_syslinux</b>
        int
        guestfs_syslinux (guestfs_h *g,
                          const char *device,
                          ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_SYSLINUX_DIRECTORY, const char *directory,

       Install the SYSLINUX bootloader on "device".

       The  device parameter must be either a whole disk formatted as a FAT filesystem, or a partition formatted
       as  a  FAT  filesystem.   In  the  latter  case,   the   partition   should   be   marked   as   "active"
       ("guestfs_part_set_bootable")    and    a   Master   Boot   Record   must   be   installed   (eg.   using
       "guestfs_pwrite_device") on the first sector of the whole disk.  The SYSLINUX  package  comes  with  some
       suitable Master Boot Records.  See the <b><a href="../man1/syslinux.1.html">syslinux</a></b>(1) man page for further information.

       The optional arguments are:

       <u>directory</u>
           Install SYSLINUX in the named subdirectory, instead of in the root directory of the FAT filesystem.

       Additional  configuration  can  be  supplied to SYSLINUX by placing a file called <u>syslinux.cfg</u> on the FAT
       filesystem, either in the root directory, or under <u>directory</u> if that optional  argument  is  being  used.
       For further information about the contents of this file, see <b><a href="../man1/syslinux.1.html">syslinux</a></b>(1).

       See also "guestfs_extlinux".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "syslinux".  See also "guestfs_feature_available".

       (Added in 1.21.27)

   <b>guestfs_syslinux_va</b>
        int
        guestfs_syslinux_va (guestfs_h *g,
                             const char *device,
                             va_list args);

       This is the "va_list variant" of "guestfs_syslinux".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_syslinux_argv</b>
        int
        guestfs_syslinux_argv (guestfs_h *g,
                               const char *device,
                               const struct guestfs_syslinux_argv *optargs);

       This is the "argv variant" of "guestfs_syslinux".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_tail</b>
        char **
        guestfs_tail (guestfs_h *g,
                      const char *path);

       This command returns up to the last 10 lines of a file as a list of strings.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because of the message protocol, there is a transfer  limit  of  somewhere  between  2MB  and  4MB.   See
       "PROTOCOL LIMITS".

       (Added in 1.0.54)

   <b>guestfs_tail_n</b>
        char **
        guestfs_tail_n (guestfs_h *g,
                        int nrlines,
                        const char *path);

       If  the  parameter  "nrlines"  is  a  positive  number, this returns the last "nrlines" lines of the file
       "path".

       If the parameter "nrlines" is a negative number, this returns lines from the file "path",  starting  with
       the "-nrlines"'th line.

       If the parameter "nrlines" is zero, this returns an empty list.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because of the message protocol, there is a transfer  limit  of  somewhere  between  2MB  and  4MB.   See
       "PROTOCOL LIMITS".

       (Added in 1.0.54)

   <b>guestfs_tar_in</b>
        int
        guestfs_tar_in (guestfs_h *g,
                        const char *tarfile,
                        const char *directory);

       This  function  is  provided  for backwards compatibility with earlier versions of libguestfs.  It simply
       calls "guestfs_tar_in_opts" with no optional arguments.

       (Added in 1.0.3)

   <b>guestfs_tar_in_opts</b>
        int
        guestfs_tar_in_opts (guestfs_h *g,
                             const char *tarfile,
                             const char *directory,
                             ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_TAR_IN_OPTS_COMPRESS, const char *compress,
        GUESTFS_TAR_IN_OPTS_XATTRS, int xattrs,
        GUESTFS_TAR_IN_OPTS_SELINUX, int selinux,
        GUESTFS_TAR_IN_OPTS_ACLS, int acls,

       This command uploads and unpacks local file "tarfile" into <u>directory</u>.

       The  optional  "compress"  flag  controls  compression.   If  not  given,  then  the  input  should be an
       uncompressed tar file.  Otherwise one of the following strings may be given  to  select  the  compression
       type  of  the  input file: "compress", "gzip", "bzip2", "xz", "lzop", "lzma", "zstd".  (Note that not all
       builds of libguestfs will support all of these compression types).

       The other optional arguments are:

       "xattrs"
           If set to true, extended attributes are restored from the tar file.

       "selinux"
           If set to true, SELinux contexts are restored from the tar file.

       "acls"
           If set to true, POSIX ACLs are restored from the tar file.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.3)

   <b>guestfs_tar_in_opts_va</b>
        int
        guestfs_tar_in_opts_va (guestfs_h *g,
                                const char *tarfile,
                                const char *directory,
                                va_list args);

       This is the "va_list variant" of "guestfs_tar_in_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_tar_in_opts_argv</b>
        int
        guestfs_tar_in_opts_argv (guestfs_h *g,
                                  const char *tarfile,
                                  const char *directory,
                                  const struct guestfs_tar_in_opts_argv *optargs);

       This is the "argv variant" of "guestfs_tar_in_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_tar_out</b>
        int
        guestfs_tar_out (guestfs_h *g,
                         const char *directory,
                         const char *tarfile);

       This function is provided for backwards compatibility with earlier versions  of  libguestfs.   It  simply
       calls "guestfs_tar_out_opts" with no optional arguments.

       (Added in 1.0.3)

   <b>guestfs_tar_out_opts</b>
        int
        guestfs_tar_out_opts (guestfs_h *g,
                              const char *directory,
                              const char *tarfile,
                              ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_TAR_OUT_OPTS_COMPRESS, const char *compress,
        GUESTFS_TAR_OUT_OPTS_NUMERICOWNER, int numericowner,
        GUESTFS_TAR_OUT_OPTS_EXCLUDES, char *const *excludes,
        GUESTFS_TAR_OUT_OPTS_XATTRS, int xattrs,
        GUESTFS_TAR_OUT_OPTS_SELINUX, int selinux,
        GUESTFS_TAR_OUT_OPTS_ACLS, int acls,

       This command packs the contents of <u>directory</u> and downloads it to local file "tarfile".

       The optional "compress" flag controls compression.  If not given, then the output will be an uncompressed
       tar file.  Otherwise one of the following strings may be given to select  the  compression  type  of  the
       output  file:  "compress",  "gzip",  "bzip2", "xz", "lzop", "lzma", "zstd".  (Note that not all builds of
       libguestfs will support all of these compression types).

       The other optional arguments are:

       "excludes"
           A list of wildcards.  Files are excluded if they match any of the wildcards.

       "numericowner"
           If set to true, the output tar file will contain UID/GID numbers instead of user/group names.

       "xattrs"
           If set to true, extended attributes are saved in the output tar.

       "selinux"
           If set to true, SELinux contexts are saved in the output tar.

       "acls"
           If set to true, POSIX ACLs are saved in the output tar.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.3)

   <b>guestfs_tar_out_opts_va</b>
        int
        guestfs_tar_out_opts_va (guestfs_h *g,
                                 const char *directory,
                                 const char *tarfile,
                                 va_list args);

       This is the "va_list variant" of "guestfs_tar_out_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_tar_out_opts_argv</b>
        int
        guestfs_tar_out_opts_argv (guestfs_h *g,
                                   const char *directory,
                                   const char *tarfile,
                                   const struct guestfs_tar_out_opts_argv *optargs);

       This is the "argv variant" of "guestfs_tar_out_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_tgz_in</b>
        int
        guestfs_tgz_in (guestfs_h *g,
                        const char *tarball,
                        const char *directory);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_tar_in" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This command uploads and unpacks local file "tarball" (a <u>gzip</u> <u>compressed</u> tar file) into <u>directory</u>.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.3)

   <b>guestfs_tgz_out</b>
        int
        guestfs_tgz_out (guestfs_h *g,
                         const char *directory,
                         const char *tarball);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_tar_out" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This command packs the contents of <u>directory</u> and downloads it to local file "tarball".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.3)

   <b>guestfs_touch</b>
        int
        guestfs_touch (guestfs_h *g,
                       const char *path);

       Touch acts like the <b><a href="../man1/touch.1.html">touch</a></b>(1) command.  It can be used to update the timestamps on a file, or, if the file
       does not exist, to create a new zero-length file.

       This command only works on regular files, and will fail on other file types such as directories, symbolic
       links, block special etc.

       This function returns 0 on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_truncate</b>
        int
        guestfs_truncate (guestfs_h *g,
                          const char *path);

       This command truncates "path" to a zero-length file.  The file must exist already.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.77)

   <b>guestfs_truncate_size</b>
        int
        guestfs_truncate_size (guestfs_h *g,
                               const char *path,
                               int64_t size);

       This command truncates "path" to size "size" bytes.  The file must exist already.

       If the current file size is less than "size" then the file is extended to the  required  size  with  zero
       bytes.   This  creates  a  sparse file (ie. disk blocks are not allocated for the file until you write to
       it).  To create a non-sparse file of zeroes, use "guestfs_fallocate64" instead.

       This function returns 0 on success or -1 on error.

       (Added in 1.0.77)

   <b>guestfs_tune2fs</b>
        int
        guestfs_tune2fs (guestfs_h *g,
                         const char *device,
                         ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_TUNE2FS_FORCE, int force,
        GUESTFS_TUNE2FS_MAXMOUNTCOUNT, int maxmountcount,
        GUESTFS_TUNE2FS_MOUNTCOUNT, int mountcount,
        GUESTFS_TUNE2FS_ERRORBEHAVIOR, const char *errorbehavior,
        GUESTFS_TUNE2FS_GROUP, int64_t group,
        GUESTFS_TUNE2FS_INTERVALBETWEENCHECKS, int intervalbetweenchecks,
        GUESTFS_TUNE2FS_RESERVEDBLOCKSPERCENTAGE, int reservedblockspercentage,
        GUESTFS_TUNE2FS_LASTMOUNTEDDIRECTORY, const char *lastmounteddirectory,
        GUESTFS_TUNE2FS_RESERVEDBLOCKSCOUNT, int64_t reservedblockscount,
        GUESTFS_TUNE2FS_USER, int64_t user,

       This  call  allows  you  to  adjust  various filesystem parameters of an ext2/ext3/ext4 filesystem called
       "device".

       The optional parameters are:

       "force"
           Force tune2fs to complete the operation even in the  face  of  errors.   This  is  the  same  as  the
           <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8) "-f" option.

       "maxmountcount"
           Set  the  number of mounts after which the filesystem is checked by <b><a href="../man8/e2fsck.8.html">e2fsck</a></b>(8).  If this is 0 then the
           number of mounts is disregarded.  This is the same as the <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8) "-c" option.

       "mountcount"
           Set the number of times the filesystem has been mounted.  This is the same  as  the  <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8)  "-C"
           option.

       "errorbehavior"
           Change  the  behavior  of  the  kernel code when errors are detected.  Possible values currently are:
           "continue", "remount-ro", "panic".  In practice these  options  don't  really  make  any  difference,
           particularly for write errors.

           This is the same as the <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8) "-e" option.

       "group"
           Set  the  group  which  can  use reserved filesystem blocks.  This is the same as the <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8) "-g"
           option except that it can only be specified as a number.

       "intervalbetweenchecks"
           Adjust the maximal time between two filesystem checks (in seconds).  If the option  is  passed  as  0
           then time-dependent checking is disabled.

           This is the same as the <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8) "-i" option.

       "reservedblockspercentage"
           Set  the  percentage  of the filesystem which may only be allocated by privileged processes.  This is
           the same as the <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8) "-m" option.

       "lastmounteddirectory"
           Set the last mounted directory.  This is the same as the <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8) "-M" option.

       "reservedblockscount" Set the number of reserved filesystem blocks. This is the same as the <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8)
       "-r" option.
       "user"
           Set the user who can use the reserved filesystem blocks.  This is the same  as  the  <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8)  "-u"
           option except that it can only be specified as a number.

       To  get the current values of filesystem parameters, see "guestfs_tune2fs_l".  For precise details of how
       tune2fs works, see the <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8) man page.

       This function returns 0 on success or -1 on error.

       (Added in 1.15.4)

   <b>guestfs_tune2fs_va</b>
        int
        guestfs_tune2fs_va (guestfs_h *g,
                            const char *device,
                            va_list args);

       This is the "va_list variant" of "guestfs_tune2fs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_tune2fs_argv</b>
        int
        guestfs_tune2fs_argv (guestfs_h *g,
                              const char *device,
                              const struct guestfs_tune2fs_argv *optargs);

       This is the "argv variant" of "guestfs_tune2fs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_tune2fs_l</b>
        char **
        guestfs_tune2fs_l (guestfs_h *g,
                           const char *device);

       This returns the contents of the ext2, ext3 or ext4 filesystem superblock on "device".

       It is the same as running "tune2fs -l device".  See <b><a href="../man8/tune2fs.8.html">tune2fs</a></b>(8) manpage for more  details.   The  list  of
       fields  returned  isn't clearly defined, and depends on both the version of "tune2fs" that libguestfs was
       built against, and the filesystem itself.

       This function returns a NULL-terminated array of strings, or NULL if there was an error.   The  array  of
       strings  will  always  have  length "2n+1", where "n" keys and values alternate, followed by the trailing
       NULL entry.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.9.2)

   <b>guestfs_txz_in</b>
        int
        guestfs_txz_in (guestfs_h *g,
                        const char *tarball,
                        const char *directory);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_tar_in" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This command uploads and unpacks local file "tarball" (an <u>xz</u> <u>compressed</u> tar file) into <u>directory</u>.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "xz".  See also "guestfs_feature_available".

       (Added in 1.3.2)

   <b>guestfs_txz_out</b>
        int
        guestfs_txz_out (guestfs_h *g,
                         const char *directory,
                         const char *tarball);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_tar_out" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This command packs the contents of <u>directory</u>  and  downloads  it  to  local  file  "tarball"  (as  an  xz
       compressed tar archive).

       This function returns 0 on success or -1 on error.

       This function depends on the feature "xz".  See also "guestfs_feature_available".

       (Added in 1.3.2)

   <b>guestfs_umask</b>
        int
        guestfs_umask (guestfs_h *g,
                       int mask);

       This function sets the mask used for creating new files and device nodes to "mask &amp; 0777".

       Typical  umask  values  would  be  022  which  creates  new  files  with permissions like "-rw-r--r--" or
       "-rwxr-xr-x", and 002 which creates new files with permissions like "-rw-rw-r--" or "-rwxrwxr-x".

       The default umask is 022.  This is important because it means that directories and device nodes  will  be
       created with 0644 or 0755 mode even if you specify 0777.

       See also "guestfs_get_umask", <b><a href="../man2/umask.2.html">umask</a></b>(2), "guestfs_mknod", "guestfs_mkdir".

       This call returns the previous umask.

       On error this function returns -1.

       (Added in 1.0.55)

   <b>guestfs_umount</b>
        int
        guestfs_umount (guestfs_h *g,
                        const char *pathordevice);

       This  function  is  provided  for backwards compatibility with earlier versions of libguestfs.  It simply
       calls "guestfs_umount_opts" with no optional arguments.

       (Added in 0.8)

   <b>guestfs_umount_opts</b>
        int
        guestfs_umount_opts (guestfs_h *g,
                             const char *pathordevice,
                             ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_UMOUNT_OPTS_FORCE, int force,
        GUESTFS_UMOUNT_OPTS_LAZYUNMOUNT, int lazyunmount,

       This  unmounts  the given filesystem.  The filesystem may be specified either by its mountpoint (path) or
       the device which contains the filesystem.

       This function returns 0 on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_umount_opts_va</b>
        int
        guestfs_umount_opts_va (guestfs_h *g,
                                const char *pathordevice,
                                va_list args);

       This is the "va_list variant" of "guestfs_umount_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_umount_opts_argv</b>
        int
        guestfs_umount_opts_argv (guestfs_h *g,
                                  const char *pathordevice,
                                  const struct guestfs_umount_opts_argv *optargs);

       This is the "argv variant" of "guestfs_umount_opts".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_umount_all</b>
        int
        guestfs_umount_all (guestfs_h *g);

       This unmounts all mounted filesystems.

       Some internal mounts are not unmounted by this call.

       This function returns 0 on success or -1 on error.

       (Added in 0.8)

   <b>guestfs_umount_local</b>
        int
        guestfs_umount_local (guestfs_h *g,
                              ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_UMOUNT_LOCAL_RETRY, int retry,

       If libguestfs is exporting the filesystem on a local mountpoint, then this unmounts it.

       See "MOUNT LOCAL" for full documentation.

       This function returns 0 on success or -1 on error.

       (Added in 1.17.22)

   <b>guestfs_umount_local_va</b>
        int
        guestfs_umount_local_va (guestfs_h *g,
                                 va_list args);

       This is the "va_list variant" of "guestfs_umount_local".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_umount_local_argv</b>
        int
        guestfs_umount_local_argv (guestfs_h *g,
                                   const struct guestfs_umount_local_argv *optargs);

       This is the "argv variant" of "guestfs_umount_local".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_upload</b>
        int
        guestfs_upload (guestfs_h *g,
                        const char *filename,
                        const char *remotefilename);

       Upload local file <u>filename</u> to <u>remotefilename</u> on the filesystem.

       <u>filename</u> can also be a named pipe.

       See also "guestfs_download".

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.0.2)

   <b>guestfs_upload_offset</b>
        int
        guestfs_upload_offset (guestfs_h *g,
                               const char *filename,
                               const char *remotefilename,
                               int64_t offset);

       Upload local file <u>filename</u> to <u>remotefilename</u> on the filesystem.

       <u>remotefilename</u>  is  overwritten  starting  at the byte "offset" specified.  The intention is to overwrite
       parts of existing files or devices, although if a non-existent file is specified then it is created  with
       a "hole" before "offset".  The size of the data written is implicit in the size of the source <u>filename</u>.

       Note  that  there  is  no  limit  on  the amount of data that can be uploaded with this call, unlike with
       "guestfs_pwrite", and this call always writes the full amount unless an error occurs.

       See also "guestfs_upload", "guestfs_pwrite".

       This function returns 0 on success or -1 on error.

       This long-running command can generate progress notification messages so that the caller  can  display  a
       progress  bar  or  indicator.   To  receive  these  messages,  the  caller must register a progress event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.5.17)

   <b>guestfs_user_cancel</b>
        int
        guestfs_user_cancel (guestfs_h *g);

       This function cancels the current upload or download operation.

       Unlike most other libguestfs calls, this function is signal safe and thread safe.  You can call it from a
       signal handler or from another thread, without needing to do any locking.

       The transfer that was in progress (if there is one) will stop shortly  afterwards,  and  will  return  an
       error.   The  errno (see "guestfs_last_errno") is set to "EINTR", so you can test for this to find out if
       the operation was cancelled or failed because of another error.

       No cleanup is performed: for example, if a file was being uploaded then after cancellation there may be a
       partially uploaded file.  It is the caller’s responsibility to clean up if necessary.

       There are two common places that you might call "guestfs_user_cancel":

       In an interactive text-based program, you might call it from a "SIGINT" signal handler so  that  pressing
       "^C"  cancels the current operation.  (You also need to call "guestfs_set_pgroup" so that child processes
       don't receive the "^C" signal).

       In a graphical program, when the main thread is displaying a progress bar with a cancel button,  wire  up
       the cancel button to call this function.

       This function returns 0 on success or -1 on error.

       (Added in 1.11.18)

   <b>guestfs_utimens</b>
        int
        guestfs_utimens (guestfs_h *g,
                         const char *path,
                         int64_t atsecs,
                         int64_t atnsecs,
                         int64_t mtsecs,
                         int64_t mtnsecs);

       This command sets the timestamps of a file with nanosecond precision.

       "atsecs", "atnsecs" are the last access time (atime) in secs and nanoseconds from the epoch.

       "mtsecs", "mtnsecs" are the last modification time (mtime) in secs and nanoseconds from the epoch.

       If  the *nsecs field contains the special value -1 then the corresponding timestamp is set to the current
       time.  (The *secs field is ignored in this case).

       If the *nsecs field contains the special value -2 then the corresponding  timestamp  is  left  unchanged.
       (The *secs field is ignored in this case).

       This function returns 0 on success or -1 on error.

       (Added in 1.0.77)

   <b>guestfs_utsname</b>
        struct guestfs_utsname *
        guestfs_utsname (guestfs_h *g);

       This  returns  the  kernel  version  of the appliance, where this is available.  This information is only
       useful for debugging.  Nothing in the returned structure is defined by the API.

       This function returns a "struct guestfs_utsname *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>  <u>call</u>
       <u>"guestfs_free_utsname"</u> <u>after</u> <u>use</u>.

       (Added in 1.19.27)

   <b>guestfs_version</b>
        struct guestfs_version *
        guestfs_version (guestfs_h *g);

       Return the libguestfs version number that the program is linked against.

       Note  that because of dynamic linking this is not necessarily the version of libguestfs that you compiled
       against.  You can compile the program,  and  then  at  runtime  dynamically  link  against  a  completely
       different <u>libguestfs.so</u> library.

       This  call  was  added in version 1.0.58.  In previous versions of libguestfs there was no way to get the
       version number.  From C code you can use dynamic linker functions to find out if this symbol  exists  (if
       it doesn't, then it’s an earlier version).

       The  call  returns  a structure with four elements.  The first three ("major", "minor" and "release") are
       numbers and correspond to the usual version triplet.  The fourth element ("extra") is  a  string  and  is
       normally empty, but may be used for distro-specific information.

       To construct the original version string: "$major.$minor.$release$extra"

       See also: "LIBGUESTFS VERSION NUMBERS".

       <u>Note:</u>  Don't use this call to test for availability of features.  In enterprise distributions we backport
       features from later versions into earlier versions, making this an unreliable way to test  for  features.
       Use "guestfs_available" or "guestfs_feature_available" instead.

       This  function returns a "struct guestfs_version *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u> <u>call</u>
       <u>"guestfs_free_version"</u> <u>after</u> <u>use</u>.

       (Added in 1.0.58)

   <b>guestfs_vfs_label</b>
        char *
        guestfs_vfs_label (guestfs_h *g,
                           const char *mountable);

       This returns the label of the filesystem on "mountable".

       If the filesystem is unlabeled, this returns the empty string.

       To find a filesystem from the label, use "guestfs_findfs_label".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.3.18)

   <b>guestfs_vfs_minimum_size</b>
        int64_t
        guestfs_vfs_minimum_size (guestfs_h *g,
                                  const char *mountable);

       Get the minimum size of filesystem in bytes.  This is the minimum possible size for filesystem shrinking.

       If getting minimum size of specified filesystem is not  supported,  this  will  fail  and  set  errno  as
       ENOTSUP.

       See also <b><a href="../man8/ntfsresize.8.html">ntfsresize</a></b>(8), <b><a href="../man8/resize2fs.8.html">resize2fs</a></b>(8), <b><a href="../man8/btrfs.8.html">btrfs</a></b>(8), <b><a href="../man8/xfs_info.8.html">xfs_info</a></b>(8).

       On error this function returns -1.

       (Added in 1.31.18)

   <b>guestfs_vfs_type</b>
        char *
        guestfs_vfs_type (guestfs_h *g,
                          const char *mountable);

       This command gets the filesystem type corresponding to the filesystem on "mountable".

       For  most  filesystems,  the result is the name of the Linux VFS module which would be used to mount this
       filesystem if you mounted it without specifying the filesystem type.  For example a string such as "ext3"
       or "ntfs".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.75)

   <b>guestfs_vfs_uuid</b>
        char *
        guestfs_vfs_uuid (guestfs_h *g,
                          const char *mountable);

       This returns the filesystem UUID of the filesystem on "mountable".

       If the filesystem does not have a UUID, this returns the empty string.

       To find a filesystem from the UUID, use "guestfs_findfs_uuid".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.3.18)

   <b>guestfs_vg_activate</b>
        int
        guestfs_vg_activate (guestfs_h *g,
                             int activate,
                             char *const *volgroups);

       This command activates or (if "activate" is false) deactivates all logical volumes in the  listed  volume
       groups "volgroups".

       This command is the same as running "vgchange -a y|n volgroups..."

       Note that if "volgroups" is an empty list then <b>all</b> volume groups are activated or deactivated.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.0.26)

   <b>guestfs_vg_activate_all</b>
        int
        guestfs_vg_activate_all (guestfs_h *g,
                                 int activate);

       This command activates or (if "activate" is false) deactivates all logical volumes in all volume groups.

       This command is the same as running "vgchange -a y|n"

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.0.26)

   <b>guestfs_vgchange_uuid</b>
        int
        guestfs_vgchange_uuid (guestfs_h *g,
                               const char *vg);

       Generate a new random UUID for the volume group "vg".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.19.26)

   <b>guestfs_vgchange_uuid_all</b>
        int
        guestfs_vgchange_uuid_all (guestfs_h *g);

       Generate new random UUIDs for all volume groups.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.19.26)

   <b>guestfs_vgcreate</b>
        int
        guestfs_vgcreate (guestfs_h *g,
                          const char *volgroup,
                          char *const *physvols);

       This  creates  an  LVM  volume  group  called  "volgroup"  from  the  non-empty  list of physical volumes
       "physvols".

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 0.8)

   <b>guestfs_vglvuuids</b>
        char **
        guestfs_vglvuuids (guestfs_h *g,
                           const char *vgname);

       Given a VG called "vgname", this returns the UUIDs of all the logical  volumes  created  in  this  volume
       group.

       You  can  use  this  along with "guestfs_lvs" and "guestfs_lvuuid" calls to associate logical volumes and
       volume groups.

       See also "guestfs_vgpvuuids".

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.0.87)

   <b>guestfs_vgmeta</b>
        char *
        guestfs_vgmeta (guestfs_h *g,
                        const char *vgname,
                        size_t *size_r);

       "vgname" is an LVM volume group.  This command examines the volume group and returns its metadata.

       Note  that  the  metadata  is  an  internal  structure used by LVM, subject to change at any time, and is
       provided for information only.

       This function returns a buffer, or NULL on error.  The size of the returned buffer is written to *size_r.
       <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>buffer</u> <u>after</u> <u>use</u>.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.17.20)

   <b>guestfs_vgpvuuids</b>
        char **
        guestfs_vgpvuuids (guestfs_h *g,
                           const char *vgname);

       Given a VG called "vgname", this returns the UUIDs of all the physical volumes  that  this  volume  group
       resides on.

       You  can  use  this along with "guestfs_pvs" and "guestfs_pvuuid" calls to associate physical volumes and
       volume groups.

       See also "guestfs_vglvuuids".

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       (Added in 1.0.87)

   <b>guestfs_vgremove</b>
        int
        guestfs_vgremove (guestfs_h *g,
                          const char *vgname);

       Remove an LVM volume group "vgname", (for example "VG").

       This also forcibly removes all logical volumes in the volume group (if any).

       This function returns 0 on success or -1 on error.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 1.0.13)

   <b>guestfs_vgrename</b>
        int
        guestfs_vgrename (guestfs_h *g,
                          const char *volgroup,
                          const char *newvolgroup);

       Rename a volume group "volgroup" with the new name "newvolgroup".

       This function returns 0 on success or -1 on error.

       (Added in 1.0.83)

   <b>guestfs_vgs</b>
        char **
        guestfs_vgs (guestfs_h *g);

       List all the volumes groups detected.  This is the equivalent of the <b><a href="../man8/vgs.8.html">vgs</a></b>(8) command.

       This returns a list of just the volume group names that were detected (eg. "VolGroup00").

       See also "guestfs_vgs_full".

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 0.4)

   <b>guestfs_vgs_full</b>
        struct guestfs_lvm_vg_list *
        guestfs_vgs_full (guestfs_h *g);

       List all the volumes groups detected.  This is the equivalent of the <b><a href="../man8/vgs.8.html">vgs</a></b>(8) command.  The "full"  version
       includes all fields.

       This  function  returns a "struct guestfs_lvm_vg_list *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>
       <u>call</u> <u>"guestfs_free_lvm_vg_list"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "lvm2".  See also "guestfs_feature_available".

       (Added in 0.4)

   <b>guestfs_vgscan</b>
        int
        guestfs_vgscan (guestfs_h *g);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_lvm_scan" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This  rescans  all block devices and rebuilds the list of LVM physical volumes, volume groups and logical
       volumes.

       This function returns 0 on success or -1 on error.

       (Added in 1.3.2)

   <b>guestfs_vguuid</b>
        char *
        guestfs_vguuid (guestfs_h *g,
                        const char *vgname);

       This command returns the UUID of the LVM VG named "vgname".

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.87)

   <b>guestfs_wait_ready</b>
        int
        guestfs_wait_ready (guestfs_h *g);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  There is no replacement.  Consult the API documentation in  <b><a href="../man3/guestfs.3.html">guestfs</a></b>(3)  for
       further information.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This function is a no op.

       In versions of the API &lt; 1.0.71 you had to call this function just after calling "guestfs_launch" to wait
       for the launch to complete.  However this is no longer necessary because "guestfs_launch"  now  does  the
       waiting.

       If  you  see  any calls to this function in code then you can just remove them, unless you want to retain
       compatibility with older versions of the API.

       This function returns 0 on success or -1 on error.

       (Added in 0.3)

   <b>guestfs_wc_c</b>
        int
        guestfs_wc_c (guestfs_h *g,
                      const char *path);

       This command counts the characters in a file, using the "wc -c" external command.

       On error this function returns -1.

       (Added in 1.0.54)

   <b>guestfs_wc_l</b>
        int
        guestfs_wc_l (guestfs_h *g,
                      const char *path);

       This command counts the lines in a file, using the "wc -l" external command.

       On error this function returns -1.

       (Added in 1.0.54)

   <b>guestfs_wc_w</b>
        int
        guestfs_wc_w (guestfs_h *g,
                      const char *path);

       This command counts the words in a file, using the "wc -w" external command.

       On error this function returns -1.

       (Added in 1.0.54)

   <b>guestfs_wipefs</b>
        int
        guestfs_wipefs (guestfs_h *g,
                        const char *device);

       This command erases filesystem or RAID signatures from the specified  "device"  to  make  the  filesystem
       invisible to libblkid.

       This does not erase the filesystem itself nor any other data from the "device".

       Compare with "guestfs_zero" which zeroes the first few blocks of a device.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "wipefs".  See also "guestfs_feature_available".

       (Added in 1.17.6)

   <b>guestfs_write</b>
        int
        guestfs_write (guestfs_h *g,
                       const char *path,
                       const char *content,
                       size_t content_size);

       This  call  creates  a  file  called  "path".  The content of the file is the string "content" (which can
       contain any 8 bit data).

       See also "guestfs_write_append".

       This function returns 0 on success or -1 on error.

       (Added in 1.3.14)

   <b>guestfs_write_append</b>
        int
        guestfs_write_append (guestfs_h *g,
                              const char *path,
                              const char *content,
                              size_t content_size);

       This call appends "content" to the end of file "path".  If "path" does not exist,  then  a  new  file  is
       created.

       See also "guestfs_write".

       This function returns 0 on success or -1 on error.

       (Added in 1.11.18)

   <b>guestfs_write_file</b>
        int
        guestfs_write_file (guestfs_h *g,
                            const char *path,
                            const char *content,
                            int size);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_write" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This call creates a file called "path".  The contents of the file is  the  string  "content"  (which  can
       contain any 8 bit data), with length "size".

       As  a  special  case,  if  "size"  is 0 then the length is calculated using "strlen" (so in this case the
       content cannot contain embedded ASCII NULs).

       <u>NB.</u> Owing to a bug, writing content containing ASCII NUL characters does <u>not</u> work, even if the length  is
       specified.

       This function returns 0 on success or -1 on error.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 0.8)

   <b>guestfs_xfs_admin</b>
        int
        guestfs_xfs_admin (guestfs_h *g,
                           const char *device,
                           ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_XFS_ADMIN_EXTUNWRITTEN, int extunwritten,
        GUESTFS_XFS_ADMIN_IMGFILE, int imgfile,
        GUESTFS_XFS_ADMIN_V2LOG, int v2log,
        GUESTFS_XFS_ADMIN_PROJID32BIT, int projid32bit,
        GUESTFS_XFS_ADMIN_LAZYCOUNTER, int lazycounter,
        GUESTFS_XFS_ADMIN_LABEL, const char *label,
        GUESTFS_XFS_ADMIN_UUID, const char *uuid,

       Change the parameters of the XFS filesystem on "device".

       Devices  that  are  mounted cannot be modified.  Administrators must unmount filesystems before this call
       can modify parameters.

       Some of the parameters of a mounted filesystem can be examined and modified using the  "guestfs_xfs_info"
       and "guestfs_xfs_growfs" calls.

       Beginning  with  XFS  version  5,  it  is  no  longer  possible  to modify the lazy-counters setting (ie.
       "lazycounter" parameter has no effect).

       This function returns 0 on success or -1 on error.

       This function depends on the feature "xfs".  See also "guestfs_feature_available".

       (Added in 1.19.33)

   <b>guestfs_xfs_admin_va</b>
        int
        guestfs_xfs_admin_va (guestfs_h *g,
                              const char *device,
                              va_list args);

       This is the "va_list variant" of "guestfs_xfs_admin".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_xfs_admin_argv</b>
        int
        guestfs_xfs_admin_argv (guestfs_h *g,
                                const char *device,
                                const struct guestfs_xfs_admin_argv *optargs);

       This is the "argv variant" of "guestfs_xfs_admin".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_xfs_growfs</b>
        int
        guestfs_xfs_growfs (guestfs_h *g,
                            const char *path,
                            ...);

       You may supply a list of optional arguments to this call.  Use zero or more of  the  following  pairs  of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_XFS_GROWFS_DATASEC, int datasec,
        GUESTFS_XFS_GROWFS_LOGSEC, int logsec,
        GUESTFS_XFS_GROWFS_RTSEC, int rtsec,
        GUESTFS_XFS_GROWFS_DATASIZE, int64_t datasize,
        GUESTFS_XFS_GROWFS_LOGSIZE, int64_t logsize,
        GUESTFS_XFS_GROWFS_RTSIZE, int64_t rtsize,
        GUESTFS_XFS_GROWFS_RTEXTSIZE, int64_t rtextsize,
        GUESTFS_XFS_GROWFS_MAXPCT, int maxpct,

       Grow the XFS filesystem mounted at "path".

       The  returned  struct  contains  geometry  information.   Missing  fields are returned as -1 (for numeric
       fields) or empty string.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "xfs".  See also "guestfs_feature_available".

       (Added in 1.19.28)

   <b>guestfs_xfs_growfs_va</b>
        int
        guestfs_xfs_growfs_va (guestfs_h *g,
                               const char *path,
                               va_list args);

       This is the "va_list variant" of "guestfs_xfs_growfs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_xfs_growfs_argv</b>
        int
        guestfs_xfs_growfs_argv (guestfs_h *g,
                                 const char *path,
                                 const struct guestfs_xfs_growfs_argv *optargs);

       This is the "argv variant" of "guestfs_xfs_growfs".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_xfs_info</b>
        struct guestfs_xfsinfo *
        guestfs_xfs_info (guestfs_h *g,
                          const char *pathordevice);

       "pathordevice" is a mounted XFS filesystem or a  device  containing  an  XFS  filesystem.   This  command
       returns the geometry of the filesystem.

       The  returned  struct  contains  geometry  information.   Missing  fields are returned as -1 (for numeric
       fields) or empty string.

       This function returns a "struct guestfs_xfsinfo *", or NULL if there was an error.  <u>The</u> <u>caller</u> <u>must</u>  <u>call</u>
       <u>"guestfs_free_xfsinfo"</u> <u>after</u> <u>use</u>.

       This function depends on the feature "xfs".  See also "guestfs_feature_available".

       (Added in 1.19.21)

   <b>guestfs_xfs_repair</b>
        int
        guestfs_xfs_repair (guestfs_h *g,
                            const char *device,
                            ...);

       You  may  supply  a  list of optional arguments to this call.  Use zero or more of the following pairs of
       parameters, and terminate the list with -1 on its own.  See "CALLS WITH OPTIONAL ARGUMENTS".

        GUESTFS_XFS_REPAIR_FORCELOGZERO, int forcelogzero,
        GUESTFS_XFS_REPAIR_NOMODIFY, int nomodify,
        GUESTFS_XFS_REPAIR_NOPREFETCH, int noprefetch,
        GUESTFS_XFS_REPAIR_FORCEGEOMETRY, int forcegeometry,
        GUESTFS_XFS_REPAIR_MAXMEM, int64_t maxmem,
        GUESTFS_XFS_REPAIR_IHASHSIZE, int64_t ihashsize,
        GUESTFS_XFS_REPAIR_BHASHSIZE, int64_t bhashsize,
        GUESTFS_XFS_REPAIR_AGSTRIDE, int64_t agstride,
        GUESTFS_XFS_REPAIR_LOGDEV, const char *logdev,
        GUESTFS_XFS_REPAIR_RTDEV, const char *rtdev,

       Repair corrupt or damaged XFS filesystem on "device".

       The filesystem is specified using the "device" argument which should be  the  device  name  of  the  disk
       partition  or  volume  containing the filesystem.  If given the name of a block device, "xfs_repair" will
       attempt to find the raw device associated with the specified block device and will  use  the  raw  device
       instead.

       Regardless,  the  filesystem to be repaired must be unmounted, otherwise, the resulting filesystem may be
       inconsistent or corrupt.

       The returned status indicates whether filesystem corruption was detected (returns 1) or was not  detected
       (returns 0).

       On error this function returns -1.

       This function depends on the feature "xfs".  See also "guestfs_feature_available".

       (Added in 1.19.36)

   <b>guestfs_xfs_repair_va</b>
        int
        guestfs_xfs_repair_va (guestfs_h *g,
                               const char *device,
                               va_list args);

       This is the "va_list variant" of "guestfs_xfs_repair".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_xfs_repair_argv</b>
        int
        guestfs_xfs_repair_argv (guestfs_h *g,
                                 const char *device,
                                 const struct guestfs_xfs_repair_argv *optargs);

       This is the "argv variant" of "guestfs_xfs_repair".

       See "CALLS WITH OPTIONAL ARGUMENTS".

   <b>guestfs_yara_destroy</b>
        int
        guestfs_yara_destroy (guestfs_h *g);

       Destroy previously loaded Yara rules in order to free libguestfs resources.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "libyara".  See also "guestfs_feature_available".

       (Added in 1.37.13)

   <b>guestfs_yara_load</b>
        int
        guestfs_yara_load (guestfs_h *g,
                           const char *filename);

       Upload a set of Yara rules from local file <u>filename</u>.

       Yara  rules  allow  to  categorize  files  based on textual or binary patterns within their content.  See
       "guestfs_yara_scan" to see how to scan files with the loaded rules.

       Rules can be in binary format, as when compiled with yarac command, or in  source  code  format.  In  the
       latter case, the rules will be first compiled and then loaded.

       Rules  in  source  code format cannot include external files. In such cases, it is recommended to compile
       them first.

       Previously loaded rules will be destroyed.

       This function returns 0 on success or -1 on error.

       This long-running command can generate progress notification messages so that the caller  can  display  a
       progress  bar  or  indicator.   To  receive  these  messages,  the  caller must register a progress event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       This function depends on the feature "libyara".  See also "guestfs_feature_available".

       (Added in 1.37.13)

   <b>guestfs_yara_scan</b>
        struct guestfs_yara_detection_list *
        guestfs_yara_scan (guestfs_h *g,
                           const char *path);

       Scan a file with the previously loaded Yara rules.

       For each matching rule, a "yara_detection" structure is returned.

       The "yara_detection" structure contains the following fields.

       "yara_name"
           Path of the file matching a Yara rule.

       "yara_rule"
           Identifier of the Yara rule which matched against the given file.

       This function returns a "struct guestfs_yara_detection_list *", or NULL  if  there  was  an  error.   <u>The</u>
       <u>caller</u> <u>must</u> <u>call</u> <u>"guestfs_free_yara_detection_list"</u> <u>after</u> <u>use</u>.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       This function depends on the feature "libyara".  See also "guestfs_feature_available".

       (Added in 1.37.13)

   <b>guestfs_zegrep</b>
        char **
        guestfs_zegrep (guestfs_h *g,
                        const char *regex,
                        const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_grep" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This calls the external "zegrep" program and returns the matching lines.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

   <b>guestfs_zegrepi</b>
        char **
        guestfs_zegrepi (guestfs_h *g,
                         const char *regex,
                         const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_grep" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This calls the external "zegrep -i" program and returns the matching lines.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because of the message protocol, there is a transfer  limit  of  somewhere  between  2MB  and  4MB.   See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

   <b>guestfs_zero</b>
        int
        guestfs_zero (guestfs_h *g,
                      const char *device);

       This command writes zeroes over the first few blocks of "device".

       How  many blocks are zeroed isn't specified (but it’s <u>not</u> enough to securely wipe the device).  It should
       be sufficient to remove any partition tables, filesystem superblocks and so on.

       If blocks are already zero, then this command avoids writing zeroes.  This prevents the underlying device
       from becoming non-sparse or growing unnecessarily.

       See also: "guestfs_zero_device", "guestfs_scrub_device", "guestfs_is_zero_device"

       This function returns 0 on success or -1 on error.

       This long-running command can generate progress notification messages so that the caller  can  display  a
       progress  bar  or  indicator.   To  receive  these  messages,  the  caller must register a progress event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.0.16)

   <b>guestfs_zero_device</b>
        int
        guestfs_zero_device (guestfs_h *g,
                             const char *device);

       This command writes zeroes over the entire "device".  Compare with "guestfs_zero" which just  zeroes  the
       first few blocks of a device.

       If blocks are already zero, then this command avoids writing zeroes.  This prevents the underlying device
       from becoming non-sparse or growing unnecessarily.

       This function returns 0 on success or -1 on error.

       This  long-running  command  can generate progress notification messages so that the caller can display a
       progress bar or indicator.  To receive  these  messages,  the  caller  must  register  a  progress  event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.3.1)

   <b>guestfs_zero_free_space</b>
        int
        guestfs_zero_free_space (guestfs_h *g,
                                 const char *directory);

       Zero the free space in the filesystem mounted on <u>directory</u>.  The filesystem must be mounted read-write.

       The filesystem contents are not affected, but any free space in the filesystem is freed.

       Free  space is not "trimmed".  You may want to call "guestfs_fstrim" either as an alternative to this, or
       after calling this, depending on your requirements.

       This function returns 0 on success or -1 on error.

       This long-running command can generate progress notification messages so that the caller  can  display  a
       progress  bar  or  indicator.   To  receive  these  messages,  the  caller must register a progress event
       callback.  See "GUESTFS_EVENT_PROGRESS".

       (Added in 1.17.18)

   <b>guestfs_zerofree</b>
        int
        guestfs_zerofree (guestfs_h *g,
                          const char *device);

       This runs the <u>zerofree</u> program on "device".  This program claims to zero unused inodes and disk blocks on
       an ext2/3 filesystem, thus making it possible to compress the filesystem more effectively.

       You should <b>not</b> run this program if the filesystem is mounted.

       It is possible that using this program can damage the filesystem or data on the filesystem.

       This function returns 0 on success or -1 on error.

       This function depends on the feature "zerofree".  See also "guestfs_feature_available".

       (Added in 1.0.26)

   <b>guestfs_zfgrep</b>
        char **
        guestfs_zfgrep (guestfs_h *g,
                        const char *pattern,
                        const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_grep" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This calls the external "zfgrep" program and returns the matching lines.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because of the message protocol, there is a transfer  limit  of  somewhere  between  2MB  and  4MB.   See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

   <b>guestfs_zfgrepi</b>
        char **
        guestfs_zfgrepi (guestfs_h *g,
                         const char *pattern,
                         const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_grep" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This calls the external "zfgrep -i" program and returns the matching lines.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

   <b>guestfs_zfile</b>
        char *
        guestfs_zfile (guestfs_h *g,
                       const char *meth,
                       const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_file" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This command runs <b><a href="../man1/file.1.html">file</a></b>(1) after first decompressing "path" using "meth".

       "meth" must be one of "gzip", "compress" or "bzip2".

       Since 1.0.63, use "guestfs_file" instead which can now process compressed files.

       This function returns a string, or NULL on error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>returned</u> <u>string</u> <u>after</u> <u>use</u>.

       (Added in 1.0.59)

   <b>guestfs_zgrep</b>
        char **
        guestfs_zgrep (guestfs_h *g,
                       const char *regex,
                       const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_grep" call instead.

       Deprecated  functions  will  not be removed from the API, but the fact that they are deprecated indicates
       that there are problems with correct use of these functions.

       This calls the external <b><a href="../man1/zgrep.1.html">zgrep</a></b>(1) program and returns the matching lines.

       This function returns a NULL-terminated array of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)),  or  NULL  if  there  was  an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because  of  the  message  protocol,  there  is  a  transfer limit of somewhere between 2MB and 4MB.  See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

   <b>guestfs_zgrepi</b>
        char **
        guestfs_zgrepi (guestfs_h *g,
                        const char *regex,
                        const char *path);

       <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>  In new code, use the "guestfs_grep" call instead.

       Deprecated functions will not be removed from the API, but the fact that they  are  deprecated  indicates
       that there are problems with correct use of these functions.

       This calls the external "zgrep -i" program and returns the matching lines.

       This  function  returns  a  NULL-terminated  array  of strings (like <b><a href="../man3/environ.3.html">environ</a></b>(3)), or NULL if there was an
       error.  <u>The</u> <u>caller</u> <u>must</u> <u>free</u> <u>the</u> <u>strings</u> <u>and</u> <u>the</u> <u>array</u> <u>after</u> <u>use</u>.

       Because of the message protocol, there is a transfer  limit  of  somewhere  between  2MB  and  4MB.   See
       "PROTOCOL LIMITS".

       (Added in 1.0.66)

</pre><h4><b>STRUCTURES</b></h4><pre>
   <b>guestfs_int_bool</b>
        struct guestfs_int_bool {
          int32_t i;
          int32_t b;
        };

        struct guestfs_int_bool_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_int_bool *val; /* Elements. */
        };

        int guestfs_compare_int_bool (const struct guestfs_int_bool *, const struct guestfs_int_bool *);
        int guestfs_compare_int_bool_list (const struct guestfs_int_bool_list *, const struct guestfs_int_bool_list *);

        struct guestfs_int_bool *guestfs_copy_int_bool (const struct guestfs_int_bool *);
        struct guestfs_int_bool_list *guestfs_copy_int_bool_list (const struct guestfs_int_bool_list *);

        void guestfs_free_int_bool (struct guestfs_int_bool *);
        void guestfs_free_int_bool_list (struct guestfs_int_bool_list *);

   <b>guestfs_lvm_pv</b>
        struct guestfs_lvm_pv {
          char *pv_name;
          /* The next field is NOT nul-terminated, be careful when printing it: */
          char pv_uuid[32];
          char *pv_fmt;
          uint64_t pv_size;
          uint64_t dev_size;
          uint64_t pv_free;
          uint64_t pv_used;
          char *pv_attr;
          int64_t pv_pe_count;
          int64_t pv_pe_alloc_count;
          char *pv_tags;
          uint64_t pe_start;
          int64_t pv_mda_count;
          uint64_t pv_mda_free;
        };

        struct guestfs_lvm_pv_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_lvm_pv *val; /* Elements. */
        };

        int guestfs_compare_lvm_pv (const struct guestfs_lvm_pv *, const struct guestfs_lvm_pv *);
        int guestfs_compare_lvm_pv_list (const struct guestfs_lvm_pv_list *, const struct guestfs_lvm_pv_list *);

        struct guestfs_lvm_pv *guestfs_copy_lvm_pv (const struct guestfs_lvm_pv *);
        struct guestfs_lvm_pv_list *guestfs_copy_lvm_pv_list (const struct guestfs_lvm_pv_list *);

        void guestfs_free_lvm_pv (struct guestfs_lvm_pv *);
        void guestfs_free_lvm_pv_list (struct guestfs_lvm_pv_list *);

   <b>guestfs_lvm_vg</b>
        struct guestfs_lvm_vg {
          char *vg_name;
          /* The next field is NOT nul-terminated, be careful when printing it: */
          char vg_uuid[32];
          char *vg_fmt;
          char *vg_attr;
          uint64_t vg_size;
          uint64_t vg_free;
          char *vg_sysid;
          uint64_t vg_extent_size;
          int64_t vg_extent_count;
          int64_t vg_free_count;
          int64_t max_lv;
          int64_t max_pv;
          int64_t pv_count;
          int64_t lv_count;
          int64_t snap_count;
          int64_t vg_seqno;
          char *vg_tags;
          int64_t vg_mda_count;
          uint64_t vg_mda_free;
        };

        struct guestfs_lvm_vg_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_lvm_vg *val; /* Elements. */
        };

        int guestfs_compare_lvm_vg (const struct guestfs_lvm_vg *, const struct guestfs_lvm_vg *);
        int guestfs_compare_lvm_vg_list (const struct guestfs_lvm_vg_list *, const struct guestfs_lvm_vg_list *);

        struct guestfs_lvm_vg *guestfs_copy_lvm_vg (const struct guestfs_lvm_vg *);
        struct guestfs_lvm_vg_list *guestfs_copy_lvm_vg_list (const struct guestfs_lvm_vg_list *);

        void guestfs_free_lvm_vg (struct guestfs_lvm_vg *);
        void guestfs_free_lvm_vg_list (struct guestfs_lvm_vg_list *);

   <b>guestfs_lvm_lv</b>
        struct guestfs_lvm_lv {
          char *lv_name;
          /* The next field is NOT nul-terminated, be careful when printing it: */
          char lv_uuid[32];
          char *lv_attr;
          int64_t lv_major;
          int64_t lv_minor;
          int64_t lv_kernel_major;
          int64_t lv_kernel_minor;
          uint64_t lv_size;
          int64_t seg_count;
          char *origin;
          /* The next field is [0..100] or -1 meaning 'not present': */
          float snap_percent;
          /* The next field is [0..100] or -1 meaning 'not present': */
          float copy_percent;
          char *move_pv;
          char *lv_tags;
          char *mirror_log;
          char *modules;
        };

        struct guestfs_lvm_lv_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_lvm_lv *val; /* Elements. */
        };

        int guestfs_compare_lvm_lv (const struct guestfs_lvm_lv *, const struct guestfs_lvm_lv *);
        int guestfs_compare_lvm_lv_list (const struct guestfs_lvm_lv_list *, const struct guestfs_lvm_lv_list *);

        struct guestfs_lvm_lv *guestfs_copy_lvm_lv (const struct guestfs_lvm_lv *);
        struct guestfs_lvm_lv_list *guestfs_copy_lvm_lv_list (const struct guestfs_lvm_lv_list *);

        void guestfs_free_lvm_lv (struct guestfs_lvm_lv *);
        void guestfs_free_lvm_lv_list (struct guestfs_lvm_lv_list *);

   <b>guestfs_stat</b>
        struct guestfs_stat {
          int64_t dev;
          int64_t ino;
          int64_t mode;
          int64_t nlink;
          int64_t uid;
          int64_t gid;
          int64_t rdev;
          int64_t size;
          int64_t blksize;
          int64_t blocks;
          int64_t atime;
          int64_t mtime;
          int64_t ctime;
        };

        struct guestfs_stat_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_stat *val; /* Elements. */
        };

        int guestfs_compare_stat (const struct guestfs_stat *, const struct guestfs_stat *);
        int guestfs_compare_stat_list (const struct guestfs_stat_list *, const struct guestfs_stat_list *);

        struct guestfs_stat *guestfs_copy_stat (const struct guestfs_stat *);
        struct guestfs_stat_list *guestfs_copy_stat_list (const struct guestfs_stat_list *);

        void guestfs_free_stat (struct guestfs_stat *);
        void guestfs_free_stat_list (struct guestfs_stat_list *);

   <b>guestfs_statns</b>
        struct guestfs_statns {
          int64_t st_dev;
          int64_t st_ino;
          int64_t st_mode;
          int64_t st_nlink;
          int64_t st_uid;
          int64_t st_gid;
          int64_t st_rdev;
          int64_t st_size;
          int64_t st_blksize;
          int64_t st_blocks;
          int64_t st_atime_sec;
          int64_t st_atime_nsec;
          int64_t st_mtime_sec;
          int64_t st_mtime_nsec;
          int64_t st_ctime_sec;
          int64_t st_ctime_nsec;
          int64_t st_spare1;
          int64_t st_spare2;
          int64_t st_spare3;
          int64_t st_spare4;
          int64_t st_spare5;
          int64_t st_spare6;
        };

        struct guestfs_statns_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_statns *val; /* Elements. */
        };

        int guestfs_compare_statns (const struct guestfs_statns *, const struct guestfs_statns *);
        int guestfs_compare_statns_list (const struct guestfs_statns_list *, const struct guestfs_statns_list *);

        struct guestfs_statns *guestfs_copy_statns (const struct guestfs_statns *);
        struct guestfs_statns_list *guestfs_copy_statns_list (const struct guestfs_statns_list *);

        void guestfs_free_statns (struct guestfs_statns *);
        void guestfs_free_statns_list (struct guestfs_statns_list *);

   <b>guestfs_statvfs</b>
        struct guestfs_statvfs {
          int64_t bsize;
          int64_t frsize;
          int64_t blocks;
          int64_t bfree;
          int64_t bavail;
          int64_t files;
          int64_t ffree;
          int64_t favail;
          int64_t fsid;
          int64_t flag;
          int64_t namemax;
        };

        struct guestfs_statvfs_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_statvfs *val; /* Elements. */
        };

        int guestfs_compare_statvfs (const struct guestfs_statvfs *, const struct guestfs_statvfs *);
        int guestfs_compare_statvfs_list (const struct guestfs_statvfs_list *, const struct guestfs_statvfs_list *);

        struct guestfs_statvfs *guestfs_copy_statvfs (const struct guestfs_statvfs *);
        struct guestfs_statvfs_list *guestfs_copy_statvfs_list (const struct guestfs_statvfs_list *);

        void guestfs_free_statvfs (struct guestfs_statvfs *);
        void guestfs_free_statvfs_list (struct guestfs_statvfs_list *);

   <b>guestfs_dirent</b>
        struct guestfs_dirent {
          int64_t ino;
          char ftyp;
          char *name;
        };

        struct guestfs_dirent_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_dirent *val; /* Elements. */
        };

        int guestfs_compare_dirent (const struct guestfs_dirent *, const struct guestfs_dirent *);
        int guestfs_compare_dirent_list (const struct guestfs_dirent_list *, const struct guestfs_dirent_list *);

        struct guestfs_dirent *guestfs_copy_dirent (const struct guestfs_dirent *);
        struct guestfs_dirent_list *guestfs_copy_dirent_list (const struct guestfs_dirent_list *);

        void guestfs_free_dirent (struct guestfs_dirent *);
        void guestfs_free_dirent_list (struct guestfs_dirent_list *);

   <b>guestfs_version</b>
        struct guestfs_version {
          int64_t major;
          int64_t minor;
          int64_t release;
          char *extra;
        };

        struct guestfs_version_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_version *val; /* Elements. */
        };

        int guestfs_compare_version (const struct guestfs_version *, const struct guestfs_version *);
        int guestfs_compare_version_list (const struct guestfs_version_list *, const struct guestfs_version_list *);

        struct guestfs_version *guestfs_copy_version (const struct guestfs_version *);
        struct guestfs_version_list *guestfs_copy_version_list (const struct guestfs_version_list *);

        void guestfs_free_version (struct guestfs_version *);
        void guestfs_free_version_list (struct guestfs_version_list *);

   <b>guestfs_xattr</b>
        struct guestfs_xattr {
          char *attrname;
          /* The next two fields describe a byte array. */
          uint32_t attrval_len;
          char *attrval;
        };

        struct guestfs_xattr_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_xattr *val; /* Elements. */
        };

        int guestfs_compare_xattr (const struct guestfs_xattr *, const struct guestfs_xattr *);
        int guestfs_compare_xattr_list (const struct guestfs_xattr_list *, const struct guestfs_xattr_list *);

        struct guestfs_xattr *guestfs_copy_xattr (const struct guestfs_xattr *);
        struct guestfs_xattr_list *guestfs_copy_xattr_list (const struct guestfs_xattr_list *);

        void guestfs_free_xattr (struct guestfs_xattr *);
        void guestfs_free_xattr_list (struct guestfs_xattr_list *);

   <b>guestfs_inotify_event</b>
        struct guestfs_inotify_event {
          int64_t in_wd;
          uint32_t in_mask;
          uint32_t in_cookie;
          char *in_name;
        };

        struct guestfs_inotify_event_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_inotify_event *val; /* Elements. */
        };

        int guestfs_compare_inotify_event (const struct guestfs_inotify_event *, const struct guestfs_inotify_event *);
        int guestfs_compare_inotify_event_list (const struct guestfs_inotify_event_list *, const struct guestfs_inotify_event_list *);

        struct guestfs_inotify_event *guestfs_copy_inotify_event (const struct guestfs_inotify_event *);
        struct guestfs_inotify_event_list *guestfs_copy_inotify_event_list (const struct guestfs_inotify_event_list *);

        void guestfs_free_inotify_event (struct guestfs_inotify_event *);
        void guestfs_free_inotify_event_list (struct guestfs_inotify_event_list *);

   <b>guestfs_partition</b>
        struct guestfs_partition {
          int32_t part_num;
          uint64_t part_start;
          uint64_t part_end;
          uint64_t part_size;
        };

        struct guestfs_partition_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_partition *val; /* Elements. */
        };

        int guestfs_compare_partition (const struct guestfs_partition *, const struct guestfs_partition *);
        int guestfs_compare_partition_list (const struct guestfs_partition_list *, const struct guestfs_partition_list *);

        struct guestfs_partition *guestfs_copy_partition (const struct guestfs_partition *);
        struct guestfs_partition_list *guestfs_copy_partition_list (const struct guestfs_partition_list *);

        void guestfs_free_partition (struct guestfs_partition *);
        void guestfs_free_partition_list (struct guestfs_partition_list *);

   <b>guestfs_application</b>
        struct guestfs_application {
          char *app_name;
          char *app_display_name;
          int32_t app_epoch;
          char *app_version;
          char *app_release;
          char *app_install_path;
          char *app_trans_path;
          char *app_publisher;
          char *app_url;
          char *app_source_package;
          char *app_summary;
          char *app_description;
        };

        struct guestfs_application_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_application *val; /* Elements. */
        };

        int guestfs_compare_application (const struct guestfs_application *, const struct guestfs_application *);
        int guestfs_compare_application_list (const struct guestfs_application_list *, const struct guestfs_application_list *);

        struct guestfs_application *guestfs_copy_application (const struct guestfs_application *);
        struct guestfs_application_list *guestfs_copy_application_list (const struct guestfs_application_list *);

        void guestfs_free_application (struct guestfs_application *);
        void guestfs_free_application_list (struct guestfs_application_list *);

   <b>guestfs_application2</b>
        struct guestfs_application2 {
          char *app2_name;
          char *app2_display_name;
          int32_t app2_epoch;
          char *app2_version;
          char *app2_release;
          char *app2_arch;
          char *app2_install_path;
          char *app2_trans_path;
          char *app2_publisher;
          char *app2_url;
          char *app2_source_package;
          char *app2_summary;
          char *app2_description;
          char *app2_spare1;
          char *app2_spare2;
          char *app2_spare3;
          char *app2_spare4;
        };

        struct guestfs_application2_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_application2 *val; /* Elements. */
        };

        int guestfs_compare_application2 (const struct guestfs_application2 *, const struct guestfs_application2 *);
        int guestfs_compare_application2_list (const struct guestfs_application2_list *, const struct guestfs_application2_list *);

        struct guestfs_application2 *guestfs_copy_application2 (const struct guestfs_application2 *);
        struct guestfs_application2_list *guestfs_copy_application2_list (const struct guestfs_application2_list *);

        void guestfs_free_application2 (struct guestfs_application2 *);
        void guestfs_free_application2_list (struct guestfs_application2_list *);

   <b>guestfs_isoinfo</b>
        struct guestfs_isoinfo {
          char *iso_system_id;
          char *iso_volume_id;
          uint32_t iso_volume_space_size;
          uint32_t iso_volume_set_size;
          uint32_t iso_volume_sequence_number;
          uint32_t iso_logical_block_size;
          char *iso_volume_set_id;
          char *iso_publisher_id;
          char *iso_data_preparer_id;
          char *iso_application_id;
          char *iso_copyright_file_id;
          char *iso_abstract_file_id;
          char *iso_bibliographic_file_id;
          int64_t iso_volume_creation_t;
          int64_t iso_volume_modification_t;
          int64_t iso_volume_expiration_t;
          int64_t iso_volume_effective_t;
        };

        struct guestfs_isoinfo_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_isoinfo *val; /* Elements. */
        };

        int guestfs_compare_isoinfo (const struct guestfs_isoinfo *, const struct guestfs_isoinfo *);
        int guestfs_compare_isoinfo_list (const struct guestfs_isoinfo_list *, const struct guestfs_isoinfo_list *);

        struct guestfs_isoinfo *guestfs_copy_isoinfo (const struct guestfs_isoinfo *);
        struct guestfs_isoinfo_list *guestfs_copy_isoinfo_list (const struct guestfs_isoinfo_list *);

        void guestfs_free_isoinfo (struct guestfs_isoinfo *);
        void guestfs_free_isoinfo_list (struct guestfs_isoinfo_list *);

   <b>guestfs_mdstat</b>
        struct guestfs_mdstat {
          char *mdstat_device;
          int32_t mdstat_index;
          char *mdstat_flags;
        };

        struct guestfs_mdstat_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_mdstat *val; /* Elements. */
        };

        int guestfs_compare_mdstat (const struct guestfs_mdstat *, const struct guestfs_mdstat *);
        int guestfs_compare_mdstat_list (const struct guestfs_mdstat_list *, const struct guestfs_mdstat_list *);

        struct guestfs_mdstat *guestfs_copy_mdstat (const struct guestfs_mdstat *);
        struct guestfs_mdstat_list *guestfs_copy_mdstat_list (const struct guestfs_mdstat_list *);

        void guestfs_free_mdstat (struct guestfs_mdstat *);
        void guestfs_free_mdstat_list (struct guestfs_mdstat_list *);

   <b>guestfs_btrfssubvolume</b>
        struct guestfs_btrfssubvolume {
          uint64_t btrfssubvolume_id;
          uint64_t btrfssubvolume_top_level_id;
          char *btrfssubvolume_path;
        };

        struct guestfs_btrfssubvolume_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_btrfssubvolume *val; /* Elements. */
        };

        int guestfs_compare_btrfssubvolume (const struct guestfs_btrfssubvolume *, const struct guestfs_btrfssubvolume *);
        int guestfs_compare_btrfssubvolume_list (const struct guestfs_btrfssubvolume_list *, const struct guestfs_btrfssubvolume_list *);

        struct guestfs_btrfssubvolume *guestfs_copy_btrfssubvolume (const struct guestfs_btrfssubvolume *);
        struct guestfs_btrfssubvolume_list *guestfs_copy_btrfssubvolume_list (const struct guestfs_btrfssubvolume_list *);

        void guestfs_free_btrfssubvolume (struct guestfs_btrfssubvolume *);
        void guestfs_free_btrfssubvolume_list (struct guestfs_btrfssubvolume_list *);

   <b>guestfs_btrfsqgroup</b>
        struct guestfs_btrfsqgroup {
          char *btrfsqgroup_id;
          uint64_t btrfsqgroup_rfer;
          uint64_t btrfsqgroup_excl;
        };

        struct guestfs_btrfsqgroup_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_btrfsqgroup *val; /* Elements. */
        };

        int guestfs_compare_btrfsqgroup (const struct guestfs_btrfsqgroup *, const struct guestfs_btrfsqgroup *);
        int guestfs_compare_btrfsqgroup_list (const struct guestfs_btrfsqgroup_list *, const struct guestfs_btrfsqgroup_list *);

        struct guestfs_btrfsqgroup *guestfs_copy_btrfsqgroup (const struct guestfs_btrfsqgroup *);
        struct guestfs_btrfsqgroup_list *guestfs_copy_btrfsqgroup_list (const struct guestfs_btrfsqgroup_list *);

        void guestfs_free_btrfsqgroup (struct guestfs_btrfsqgroup *);
        void guestfs_free_btrfsqgroup_list (struct guestfs_btrfsqgroup_list *);

   <b>guestfs_btrfsbalance</b>
        struct guestfs_btrfsbalance {
          char *btrfsbalance_status;
          uint64_t btrfsbalance_total;
          uint64_t btrfsbalance_balanced;
          uint64_t btrfsbalance_considered;
          uint64_t btrfsbalance_left;
        };

        struct guestfs_btrfsbalance_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_btrfsbalance *val; /* Elements. */
        };

        int guestfs_compare_btrfsbalance (const struct guestfs_btrfsbalance *, const struct guestfs_btrfsbalance *);
        int guestfs_compare_btrfsbalance_list (const struct guestfs_btrfsbalance_list *, const struct guestfs_btrfsbalance_list *);

        struct guestfs_btrfsbalance *guestfs_copy_btrfsbalance (const struct guestfs_btrfsbalance *);
        struct guestfs_btrfsbalance_list *guestfs_copy_btrfsbalance_list (const struct guestfs_btrfsbalance_list *);

        void guestfs_free_btrfsbalance (struct guestfs_btrfsbalance *);
        void guestfs_free_btrfsbalance_list (struct guestfs_btrfsbalance_list *);

   <b>guestfs_btrfsscrub</b>
        struct guestfs_btrfsscrub {
          uint64_t btrfsscrub_data_extents_scrubbed;
          uint64_t btrfsscrub_tree_extents_scrubbed;
          uint64_t btrfsscrub_data_bytes_scrubbed;
          uint64_t btrfsscrub_tree_bytes_scrubbed;
          uint64_t btrfsscrub_read_errors;
          uint64_t btrfsscrub_csum_errors;
          uint64_t btrfsscrub_verify_errors;
          uint64_t btrfsscrub_no_csum;
          uint64_t btrfsscrub_csum_discards;
          uint64_t btrfsscrub_super_errors;
          uint64_t btrfsscrub_malloc_errors;
          uint64_t btrfsscrub_uncorrectable_errors;
          uint64_t btrfsscrub_unverified_errors;
          uint64_t btrfsscrub_corrected_errors;
          uint64_t btrfsscrub_last_physical;
        };

        struct guestfs_btrfsscrub_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_btrfsscrub *val; /* Elements. */
        };

        int guestfs_compare_btrfsscrub (const struct guestfs_btrfsscrub *, const struct guestfs_btrfsscrub *);
        int guestfs_compare_btrfsscrub_list (const struct guestfs_btrfsscrub_list *, const struct guestfs_btrfsscrub_list *);

        struct guestfs_btrfsscrub *guestfs_copy_btrfsscrub (const struct guestfs_btrfsscrub *);
        struct guestfs_btrfsscrub_list *guestfs_copy_btrfsscrub_list (const struct guestfs_btrfsscrub_list *);

        void guestfs_free_btrfsscrub (struct guestfs_btrfsscrub *);
        void guestfs_free_btrfsscrub_list (struct guestfs_btrfsscrub_list *);

   <b>guestfs_xfsinfo</b>
        struct guestfs_xfsinfo {
          char *xfs_mntpoint;
          uint32_t xfs_inodesize;
          uint32_t xfs_agcount;
          uint32_t xfs_agsize;
          uint32_t xfs_sectsize;
          uint32_t xfs_attr;
          uint32_t xfs_blocksize;
          uint64_t xfs_datablocks;
          uint32_t xfs_imaxpct;
          uint32_t xfs_sunit;
          uint32_t xfs_swidth;
          uint32_t xfs_dirversion;
          uint32_t xfs_dirblocksize;
          uint32_t xfs_cimode;
          char *xfs_logname;
          uint32_t xfs_logblocksize;
          uint32_t xfs_logblocks;
          uint32_t xfs_logversion;
          uint32_t xfs_logsectsize;
          uint32_t xfs_logsunit;
          uint32_t xfs_lazycount;
          char *xfs_rtname;
          uint32_t xfs_rtextsize;
          uint64_t xfs_rtblocks;
          uint64_t xfs_rtextents;
        };

        struct guestfs_xfsinfo_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_xfsinfo *val; /* Elements. */
        };

        int guestfs_compare_xfsinfo (const struct guestfs_xfsinfo *, const struct guestfs_xfsinfo *);
        int guestfs_compare_xfsinfo_list (const struct guestfs_xfsinfo_list *, const struct guestfs_xfsinfo_list *);

        struct guestfs_xfsinfo *guestfs_copy_xfsinfo (const struct guestfs_xfsinfo *);
        struct guestfs_xfsinfo_list *guestfs_copy_xfsinfo_list (const struct guestfs_xfsinfo_list *);

        void guestfs_free_xfsinfo (struct guestfs_xfsinfo *);
        void guestfs_free_xfsinfo_list (struct guestfs_xfsinfo_list *);

   <b>guestfs_utsname</b>
        struct guestfs_utsname {
          char *uts_sysname;
          char *uts_release;
          char *uts_version;
          char *uts_machine;
        };

        struct guestfs_utsname_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_utsname *val; /* Elements. */
        };

        int guestfs_compare_utsname (const struct guestfs_utsname *, const struct guestfs_utsname *);
        int guestfs_compare_utsname_list (const struct guestfs_utsname_list *, const struct guestfs_utsname_list *);

        struct guestfs_utsname *guestfs_copy_utsname (const struct guestfs_utsname *);
        struct guestfs_utsname_list *guestfs_copy_utsname_list (const struct guestfs_utsname_list *);

        void guestfs_free_utsname (struct guestfs_utsname *);
        void guestfs_free_utsname_list (struct guestfs_utsname_list *);

   <b>guestfs_hivex_node</b>
        struct guestfs_hivex_node {
          int64_t hivex_node_h;
        };

        struct guestfs_hivex_node_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_hivex_node *val; /* Elements. */
        };

        int guestfs_compare_hivex_node (const struct guestfs_hivex_node *, const struct guestfs_hivex_node *);
        int guestfs_compare_hivex_node_list (const struct guestfs_hivex_node_list *, const struct guestfs_hivex_node_list *);

        struct guestfs_hivex_node *guestfs_copy_hivex_node (const struct guestfs_hivex_node *);
        struct guestfs_hivex_node_list *guestfs_copy_hivex_node_list (const struct guestfs_hivex_node_list *);

        void guestfs_free_hivex_node (struct guestfs_hivex_node *);
        void guestfs_free_hivex_node_list (struct guestfs_hivex_node_list *);

   <b>guestfs_hivex_value</b>
        struct guestfs_hivex_value {
          int64_t hivex_value_h;
        };

        struct guestfs_hivex_value_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_hivex_value *val; /* Elements. */
        };

        int guestfs_compare_hivex_value (const struct guestfs_hivex_value *, const struct guestfs_hivex_value *);
        int guestfs_compare_hivex_value_list (const struct guestfs_hivex_value_list *, const struct guestfs_hivex_value_list *);

        struct guestfs_hivex_value *guestfs_copy_hivex_value (const struct guestfs_hivex_value *);
        struct guestfs_hivex_value_list *guestfs_copy_hivex_value_list (const struct guestfs_hivex_value_list *);

        void guestfs_free_hivex_value (struct guestfs_hivex_value *);
        void guestfs_free_hivex_value_list (struct guestfs_hivex_value_list *);

   <b>guestfs_internal_mountable</b>
        struct guestfs_internal_mountable {
          int32_t im_type;
          char *im_device;
          char *im_volume;
        };

        struct guestfs_internal_mountable_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_internal_mountable *val; /* Elements. */
        };

        int guestfs_compare_internal_mountable (const struct guestfs_internal_mountable *, const struct guestfs_internal_mountable *);
        int guestfs_compare_internal_mountable_list (const struct guestfs_internal_mountable_list *, const struct guestfs_internal_mountable_list *);

        struct guestfs_internal_mountable *guestfs_copy_internal_mountable (const struct guestfs_internal_mountable *);
        struct guestfs_internal_mountable_list *guestfs_copy_internal_mountable_list (const struct guestfs_internal_mountable_list *);

        void guestfs_free_internal_mountable (struct guestfs_internal_mountable *);
        void guestfs_free_internal_mountable_list (struct guestfs_internal_mountable_list *);

   <b>guestfs_tsk_dirent</b>
        struct guestfs_tsk_dirent {
          uint64_t tsk_inode;
          char tsk_type;
          int64_t tsk_size;
          char *tsk_name;
          uint32_t tsk_flags;
          int64_t tsk_atime_sec;
          int64_t tsk_atime_nsec;
          int64_t tsk_mtime_sec;
          int64_t tsk_mtime_nsec;
          int64_t tsk_ctime_sec;
          int64_t tsk_ctime_nsec;
          int64_t tsk_crtime_sec;
          int64_t tsk_crtime_nsec;
          int64_t tsk_nlink;
          char *tsk_link;
          int64_t tsk_spare1;
        };

        struct guestfs_tsk_dirent_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_tsk_dirent *val; /* Elements. */
        };

        int guestfs_compare_tsk_dirent (const struct guestfs_tsk_dirent *, const struct guestfs_tsk_dirent *);
        int guestfs_compare_tsk_dirent_list (const struct guestfs_tsk_dirent_list *, const struct guestfs_tsk_dirent_list *);

        struct guestfs_tsk_dirent *guestfs_copy_tsk_dirent (const struct guestfs_tsk_dirent *);
        struct guestfs_tsk_dirent_list *guestfs_copy_tsk_dirent_list (const struct guestfs_tsk_dirent_list *);

        void guestfs_free_tsk_dirent (struct guestfs_tsk_dirent *);
        void guestfs_free_tsk_dirent_list (struct guestfs_tsk_dirent_list *);

   <b>guestfs_yara_detection</b>
        struct guestfs_yara_detection {
          char *yara_name;
          char *yara_rule;
        };

        struct guestfs_yara_detection_list {
          uint32_t len; /* Number of elements in list. */
          struct guestfs_yara_detection *val; /* Elements. */
        };

        int guestfs_compare_yara_detection (const struct guestfs_yara_detection *, const struct guestfs_yara_detection *);
        int guestfs_compare_yara_detection_list (const struct guestfs_yara_detection_list *, const struct guestfs_yara_detection_list *);

        struct guestfs_yara_detection *guestfs_copy_yara_detection (const struct guestfs_yara_detection *);
        struct guestfs_yara_detection_list *guestfs_copy_yara_detection_list (const struct guestfs_yara_detection_list *);

        void guestfs_free_yara_detection (struct guestfs_yara_detection *);
        void guestfs_free_yara_detection_list (struct guestfs_yara_detection_list *);

</pre><h4><b>AVAILABILITY</b></h4><pre>
   <b>GROUPS</b> <b>OF</b> <b>FUNCTIONALITY</b> <b>IN</b> <b>THE</b> <b>APPLIANCE</b>
       Using  "guestfs_available"  you  can  test  availability of the following groups of functions.  This test
       queries the appliance to see if the appliance you are currently using supports the functionality.

       <b>acl</b> The following functions: "guestfs_acl_delete_def_file" "guestfs_acl_get_file" "guestfs_acl_set_file"

       <b>blkdiscard</b>
           The following functions: "guestfs_blkdiscard"

       <b>blkdiscardzeroes</b>
           The following functions: "guestfs_blkdiscardzeroes"

       <b>btrfs</b>
           The     following     functions:     "guestfs_btrfs_balance_cancel"     "guestfs_btrfs_balance_pause"
           "guestfs_btrfs_balance_resume"        "guestfs_btrfs_balance_status"       "guestfs_btrfs_device_add"
           "guestfs_btrfs_device_delete"                                      "guestfs_btrfs_filesystem_balance"
           "guestfs_btrfs_filesystem_defragment"                               "guestfs_btrfs_filesystem_resize"
           "guestfs_btrfs_filesystem_show"         "guestfs_btrfs_filesystem_sync"          "guestfs_btrfs_fsck"
           "guestfs_btrfs_image"           "guestfs_btrfs_qgroup_assign"           "guestfs_btrfs_qgroup_create"
           "guestfs_btrfs_qgroup_destroy"       "guestfs_btrfs_qgroup_limit"       "guestfs_btrfs_qgroup_remove"
           "guestfs_btrfs_qgroup_show"         "guestfs_btrfs_quota_enable"         "guestfs_btrfs_quota_rescan"
           "guestfs_btrfs_replace"   "guestfs_btrfs_rescue_chunk_recover"   "guestfs_btrfs_rescue_super_recover"
           "guestfs_btrfs_scrub_cancel"         "guestfs_btrfs_scrub_resume"         "guestfs_btrfs_scrub_start"
           "guestfs_btrfs_scrub_status"       "guestfs_btrfs_set_seeding"       "guestfs_btrfs_subvolume_create"
           "guestfs_btrfs_subvolume_delete" "guestfs_btrfs_subvolume_get_default" "guestfs_btrfs_subvolume_list"
           "guestfs_btrfs_subvolume_set_default"                                  "guestfs_btrfs_subvolume_show"
           "guestfs_btrfs_subvolume_snapshot"                     "guestfs_btrfstune_enable_extended_inode_refs"
           "guestfs_btrfstune_enable_skinny_metadata_extent_refs"                    "guestfs_btrfstune_seeding"
           "guestfs_mkfs_btrfs"

       <b>clevisluks</b>
           The following functions: "guestfs_clevis_luks_unlock"

       <b>extlinux</b>
           The following functions: "guestfs_extlinux"

       <b>f2fs</b>
           The following functions: "guestfs_f2fs_expand"

       <b>fstrim</b>
           The following functions: "guestfs_fstrim"

       <b>gdisk</b>
           The following functions: "guestfs_part_expand_gpt"

       <b>grub</b>
           The following functions: "guestfs_grub_install"

       <b>hivex</b>
           The following functions: "guestfs_hivex_close" "guestfs_hivex_commit"  "guestfs_hivex_node_add_child"
           "guestfs_hivex_node_children"     "guestfs_hivex_node_delete_child"    "guestfs_hivex_node_get_child"
           "guestfs_hivex_node_get_value"         "guestfs_hivex_node_name"          "guestfs_hivex_node_parent"
           "guestfs_hivex_node_set_value"  "guestfs_hivex_node_values" "guestfs_hivex_open" "guestfs_hivex_root"
           "guestfs_hivex_value_key"           "guestfs_hivex_value_string"           "guestfs_hivex_value_type"
           "guestfs_hivex_value_utf8" "guestfs_hivex_value_value"

       <b>inotify</b>
           The  following functions: "guestfs_inotify_add_watch" "guestfs_inotify_close" "guestfs_inotify_files"
           "guestfs_inotify_init" "guestfs_inotify_read" "guestfs_inotify_rm_watch"

       <b>journal</b>
           The      following      functions:       "guestfs_internal_journal_get"       "guestfs_journal_close"
           "guestfs_journal_get_data_threshold"    "guestfs_journal_get_realtime_usec"    "guestfs_journal_next"
           "guestfs_journal_open" "guestfs_journal_set_data_threshold" "guestfs_journal_skip"

       <b>ldm</b> The    following    functions:     "guestfs_ldmtool_create_all"     "guestfs_ldmtool_diskgroup_disks"
           "guestfs_ldmtool_diskgroup_name"   "guestfs_ldmtool_diskgroup_volumes"   "guestfs_ldmtool_remove_all"
           "guestfs_ldmtool_scan"          "guestfs_ldmtool_scan_devices"          "guestfs_ldmtool_volume_hint"
           "guestfs_ldmtool_volume_partitions"    "guestfs_ldmtool_volume_type"    "guestfs_list_ldm_partitions"
           "guestfs_list_ldm_volumes"

       <b>libtsk</b>
           The following functions: "guestfs_internal_filesystem_walk" "guestfs_internal_find_inode"

       <b>libyara</b>
           The following functions: "guestfs_internal_yara_scan" "guestfs_yara_destroy" "guestfs_yara_load"

       <b>linuxcaps</b>
           The following functions: "guestfs_cap_get_file" "guestfs_cap_set_file"

       <b>linuxfsuuid</b>
           The   following    functions:    "guestfs_mke2fs_JU"    "guestfs_mke2journal_U"    "guestfs_mkswap_U"
           "guestfs_swapoff_uuid" "guestfs_swapon_uuid"

       <b>linuxmodules</b>
           The following functions: "guestfs_modprobe"

       <b>linuxxattrs</b>
           The   following   functions:   "guestfs_getxattr"  "guestfs_getxattrs"  "guestfs_internal_lxattrlist"
           "guestfs_lgetxattr"       "guestfs_lgetxattrs"       "guestfs_lremovexattr"       "guestfs_lsetxattr"
           "guestfs_removexattr" "guestfs_setxattr"

       <b>luks</b>
           The  following functions: "guestfs_cryptsetup_close" "guestfs_cryptsetup_open" "guestfs_luks_add_key"
           "guestfs_luks_close"  "guestfs_luks_format"   "guestfs_luks_format_cipher"   "guestfs_luks_kill_slot"
           "guestfs_luks_open" "guestfs_luks_open_ro" "guestfs_luks_uuid"

       <b>lvm2</b>
           The   following   functions:   "guestfs_lvcreate"   "guestfs_lvcreate_free"  "guestfs_lvm_remove_all"
           "guestfs_lvm_set_filter" "guestfs_lvremove" "guestfs_lvresize" "guestfs_lvresize_free"  "guestfs_lvs"
           "guestfs_lvs_full"     "guestfs_pvchange_uuid"     "guestfs_pvchange_uuid_all"     "guestfs_pvcreate"
           "guestfs_pvremove"  "guestfs_pvresize"   "guestfs_pvresize_size"   "guestfs_pvs"   "guestfs_pvs_full"
           "guestfs_vg_activate"  "guestfs_vg_activate_all"  "guestfs_vgchange_uuid" "guestfs_vgchange_uuid_all"
           "guestfs_vgcreate" "guestfs_vgmeta" "guestfs_vgremove" "guestfs_vgs" "guestfs_vgs_full"

       <b>mdadm</b>
           The following functions: "guestfs_md_create" "guestfs_md_detail" "guestfs_md_stat" "guestfs_md_stop"

       <b>mknod</b>
           The following functions: "guestfs_mkfifo" "guestfs_mknod" "guestfs_mknod_b" "guestfs_mknod_c"

       <b>ntfs3g</b>
           The  following  functions:  "guestfs_ntfs_3g_probe"  "guestfs_ntfsclone_in"   "guestfs_ntfsclone_out"
           "guestfs_ntfsfix"

       <b>ntfsprogs</b>
           The following functions: "guestfs_ntfsresize" "guestfs_ntfsresize_size"

       <b>rsync</b>
           The following functions: "guestfs_rsync" "guestfs_rsync_in" "guestfs_rsync_out"

       <b>scrub</b>
           The following functions: "guestfs_scrub_device" "guestfs_scrub_file" "guestfs_scrub_freespace"

       <b>selinux</b>
           The following functions: "guestfs_getcon" "guestfs_setcon"

       <b>selinuxrelabel</b>
           The following functions: "guestfs_selinux_relabel"

       <b>sleuthkit</b>
           The following functions: "guestfs_download_blocks" "guestfs_download_inode"

       <b>squashfs</b>
           The following functions: "guestfs_mksquashfs"

       <b>syslinux</b>
           The following functions: "guestfs_syslinux"

       <b>wipefs</b>
           The following functions: "guestfs_wipefs"

       <b>xfs</b> The     following     functions:    "guestfs_xfs_admin"    "guestfs_xfs_growfs"    "guestfs_xfs_info"
           "guestfs_xfs_repair"

       <b>xz</b>  The following functions: "guestfs_txz_in" "guestfs_txz_out"

       <b>zerofree</b>
           The following functions: "guestfs_zerofree"

   <b>FILESYSTEM</b> <b>AVAILABLE</b>
       The "guestfs_filesystem_available" call tests whether a filesystem type is  supported  by  the  appliance
       kernel.

       This  is  mainly  useful  as  a  negative  test.  If this returns true, it doesn't mean that a particular
       filesystem can be mounted, since filesystems can fail for other reasons such as it being a later  version
       of the filesystem, or having incompatible features.

   <b>GUESTFISH</b> <b>supported</b> <b>COMMAND</b>
       In  <b><a href="../man3/guestfish.3.html">guestfish</a></b>(3)  there  is a handy interactive command "supported" which prints out the available groups
       and whether they are supported by this build of libguestfs.  Note however  that  you  have  to  do  "run"
       first.

   <b>SINGLE</b> <b>CALLS</b> <b>AT</b> <b>COMPILE</b> <b>TIME</b>
       Since version 1.5.8, "&lt;guestfs.h&gt;" defines symbols for each C API function, such as:

        #define GUESTFS_HAVE_DD 1

       if "guestfs_dd" is available.

       Before  version 1.5.8, if you needed to test whether a single libguestfs function is available at compile
       time, we recommended using build tools such as autoconf or cmake.  For example  in  autotools  you  could
       use:

        AC_CHECK_LIB([guestfs],[guestfs_create])
        AC_CHECK_FUNCS([guestfs_dd])

       which would result in "HAVE_GUESTFS_DD" being either defined or not defined in your program.

   <b>SINGLE</b> <b>CALLS</b> <b>AT</b> <b>RUN</b> <b>TIME</b>
       Testing  at  compile  time doesn't guarantee that a function really exists in the library.  The reason is
       that you might be dynamically linked against a previous <u>libguestfs.so</u>  (dynamic  library)  which  doesn't
       have  the  call.  This situation unfortunately results in a segmentation fault, which is a shortcoming of
       the C dynamic linking system itself.

       You can use <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3) to test if a function is available at run time, as in this  example  program  (note
       that you still need the compile time check as well):

        #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
        #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
        #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
        #include &lt;<a href="file:/usr/include/dlfcn.h">dlfcn.h</a>&gt;
        #include &lt;guestfs.h&gt;

        main ()
        {
        #ifdef GUESTFS_HAVE_DD
          void *dl;
          int has_function;

          /* Test if the function guestfs_dd is really available. */
          dl = dlopen (NULL, RTLD_LAZY);
          if (!dl) {
            fprintf (stderr, "dlopen: %s\n", dlerror ());
            exit (EXIT_FAILURE);
          }
          has_function = dlsym (dl, "guestfs_dd") != NULL;
          dlclose (dl);

          if (!has_function)
            printf ("this libguestfs.so does NOT have guestfs_dd function\n");
          else {
            printf ("this libguestfs.so has guestfs_dd function\n");
            /* Now it's safe to call
            guestfs_dd (g, "foo", "bar");
            */
          }
        #else
          printf ("guestfs_dd function was not found at compile time\n");
        #endif
         }

       You  may  think  the  above  is an awful lot of hassle, and it is.  There are other ways outside of the C
       linking system to ensure  that  this  kind  of  incompatibility  never  arises,  such  as  using  package
       versioning:

        Requires: libguestfs &gt;= 1.0.80

</pre><h4><b>CALLS</b> <b>WITH</b> <b>OPTIONAL</b> <b>ARGUMENTS</b></h4><pre>
       A  recent  feature of the API is the introduction of calls which take optional arguments.  In C these are
       declared 3 ways.  The main way is as a call which takes  variable  arguments  (ie.  "..."),  as  in  this
       example:

        int guestfs_add_drive_opts (guestfs_h *g, const char *filename, ...);

       Call  this  with  a  list of optional arguments, terminated by -1.  So to call with no optional arguments
       specified:

        guestfs_add_drive_opts (g, filename, -1);

       With a single optional argument:

        guestfs_add_drive_opts (g, filename,
                                GUESTFS_ADD_DRIVE_OPTS_FORMAT, "qcow2",
                                -1);

       With two:

        guestfs_add_drive_opts (g, filename,
                                GUESTFS_ADD_DRIVE_OPTS_FORMAT, "qcow2",
                                GUESTFS_ADD_DRIVE_OPTS_READONLY, 1,
                                -1);

       and so forth.  Don’t forget the terminating -1 otherwise Bad Things will happen!

   <b>USING</b> <b>va_list</b> <b>FOR</b> <b>OPTIONAL</b> <b>ARGUMENTS</b>
       The second variant has the same name with the suffix  "_va",  which  works  the  same  way  but  takes  a
       "va_list".  See the C manual for details.  For the example function, this is declared:

        int guestfs_add_drive_opts_va (guestfs_h *g, const char *filename,
                                       va_list args);

   <b>CONSTRUCTING</b> <b>OPTIONAL</b> <b>ARGUMENTS</b>
       The  third  variant is useful where you need to construct these calls.  You pass in a structure where you
       fill in the optional fields.  The structure has a bitmask as the first element  which  you  must  set  to
       indicate which fields you have filled in.  For our example function the structure and call are declared:

        struct guestfs_add_drive_opts_argv {
          uint64_t bitmask;
          int readonly;
          const char *format;
          /* ... */
        };
        int guestfs_add_drive_opts_argv (guestfs_h *g, const char *filename,
                     const struct guestfs_add_drive_opts_argv *optargs);

       You could call it like this:

        struct guestfs_add_drive_opts_argv optargs = {
          .bitmask = GUESTFS_ADD_DRIVE_OPTS_READONLY_BITMASK |
                     GUESTFS_ADD_DRIVE_OPTS_FORMAT_BITMASK,
          .readonly = 1,
          .format = "qcow2"
        };

        guestfs_add_drive_opts_argv (g, filename, &amp;optargs);

       Notes:

       •   The "_BITMASK" suffix on each option name when specifying the bitmask.

       •   You do not need to fill in all fields of the structure.

       •   There  must  be  a  one-to-one correspondence between fields of the structure that are filled in, and
           bits set in the bitmask.

   <b>OPTIONAL</b> <b>ARGUMENTS</b> <b>IN</b> <b>OTHER</b> <b>LANGUAGES</b>
       In other languages, optional arguments are expressed in the way that is natural for  that  language.   We
       refer you to the language-specific documentation for more details on that.

       For guestfish, see "OPTIONAL ARGUMENTS" in <b><a href="../man1/guestfish.1.html">guestfish</a></b>(1).

</pre><h4><b>EVENTS</b></h4><pre>
   <b>SETTING</b> <b>CALLBACKS</b> <b>TO</b> <b>HANDLE</b> <b>EVENTS</b>
       <b>Note:</b>  This section documents the generic event mechanism introduced in libguestfs 1.10, which you should
       use   in   new   code   if   possible.     The    old    functions    "guestfs_set_log_message_callback",
       "guestfs_set_subprocess_quit_callback",  "guestfs_set_launch_done_callback", "guestfs_set_close_callback"
       and "guestfs_set_progress_callback" are no longer documented in this manual page.   Because  of  the  ABI
       guarantee, the old functions continue to work.

       Handles  generate  events  when  certain  things  happen,  such as log messages being generated, progress
       messages during long-running operations, or the handle being closed.  The API calls described  below  let
       you  register  a  callback to be called when events happen.  You can register multiple callbacks (for the
       same, different or overlapping sets of events), and individually remove callbacks.  If callbacks are  not
       removed, then they remain in force until the handle is closed.

       In the current implementation, events are only generated synchronously: that means that events (and hence
       callbacks)  can  only happen while you are in the middle of making another libguestfs call.  The callback
       is called in the same thread.

       Events may contain a payload, usually nothing (void), an array of 64 bit unsigned integers, or a  message
       buffer.  Payloads are discussed later on.

   <b>CLASSES</b> <b>OF</b> <b>EVENTS</b>
       GUESTFS_EVENT_CLOSE (payload type: void)
           The  callback  function  will  be  called  while  the  handle  is  being  closed  (synchronously from
           "guestfs_close").

           Note that libguestfs installs an <b><a href="../man3/atexit.3.html">atexit</a></b>(3) handler to try to clean up handles that are open when  the
           program  exits.   This  means  that  this callback might be called indirectly from <b><a href="../man3/exit.3.html">exit</a></b>(3), which can
           cause unexpected problems in higher-level languages (eg. if your HLL  interpreter  has  already  been
           cleaned up by the time this is called, and if your callback then jumps into some HLL function).

           If no callback is registered: the handle is closed without any callback being invoked.

       GUESTFS_EVENT_SUBPROCESS_QUIT (payload type: void)
           The callback function will be called when the child process quits, either asynchronously or if killed
           by "guestfs_kill_subprocess".  (This corresponds to a transition from any state to the CONFIG state).

           If no callback is registered: the event is ignored.

       GUESTFS_EVENT_LAUNCH_DONE (payload type: void)
           The  callback  function  will  be called when the child process becomes ready first time after it has
           been launched.  (This corresponds to a transition from LAUNCHING to the READY state).

           If no callback is registered: the event is ignored.

       GUESTFS_EVENT_PROGRESS (payload type: array of 4 x uint64_t)
           Some long-running operations can generate progress messages.  If this callback is registered, then it
           will be called each time a progress message is generated (usually two  seconds  after  the  operation
           started,  and three times per second thereafter until it completes, although the frequency may change
           in future versions).

           The callback receives in the payload four unsigned 64 bit numbers which are  (in  order):  "proc_nr",
           "serial", "position", "total".

           The  units of "total" are not defined, although for some operations "total" may relate in some way to
           the amount of data to be transferred (eg. in bytes or megabytes), and "position" may be  the  portion
           which has been transferred.

           The only defined and stable parts of the API are:

           •   The callback can display to the user some type of progress bar or indicator which shows the ratio
               of "position":"total".

           •   0 &lt;= "position" &lt;= "total"

           •   If  any progress notification is sent during a call, then a final progress notification is always
               sent when "position" = "total" (<u>unless</u> the call fails with an error).

               This is to simplify caller code, so callers can easily set the progress indicator  to  "100%"  at
               the end of the operation, without requiring special code to detect this case.

           •   For  some  calls  we  are  unable to estimate the progress of the call, but we can still generate
               progress messages to indicate activity.  This is known as "pulse mode", and is directly supported
               by certain progress bar implementations (eg. GtkProgressBar).

               For these calls, zero or more progress messages are generated with "position = 0"  and  "total  =
               1", followed by a final message with "position = total = 1".

               As noted above, if the call fails with an error then the final message may not be generated.

           The callback also receives the procedure number ("proc_nr") and serial number ("serial") of the call.
           These  are only useful for debugging protocol issues, and the callback can normally ignore them.  The
           callback may want to print these numbers in error messages or debugging messages.

           If no callback is registered: progress messages are discarded.

       GUESTFS_EVENT_APPLIANCE (payload type: message buffer)
           The callback function is called whenever a log message is generated by qemu,  the  appliance  kernel,
           guestfsd (daemon), or utility programs.

           If  the  verbose flag ("guestfs_set_verbose") is set before launch ("guestfs_launch") then additional
           debug messages are generated.

           If no callback is registered: the messages are discarded unless the verbose flag is set in which case
           they are sent to stderr.  You can override the printing of verbose messages to stderr by setting up a
           callback.

       GUESTFS_EVENT_LIBRARY (payload type: message buffer)
           The callback function is called  whenever  a  log  message  is  generated  by  the  library  part  of
           libguestfs.

           If the verbose flag ("guestfs_set_verbose") is set then additional debug messages are generated.

           If no callback is registered: the messages are discarded unless the verbose flag is set in which case
           they are sent to stderr.  You can override the printing of verbose messages to stderr by setting up a
           callback.

       GUESTFS_EVENT_WARNING (payload type: message buffer)
           The  callback  function  is  called  whenever  a  warning message is generated by the library part of
           libguestfs.

           If no callback is registered: the messages are printed to stderr.  You can override the  printing  of
           warning messages to stderr by setting up a callback.

       GUESTFS_EVENT_TRACE (payload type: message buffer)
           The  callback  function  is  called  whenever a trace message is generated.  This only applies if the
           trace flag ("guestfs_set_trace") is set.

           If no callback is registered: the messages are sent to stderr.  You  can  override  the  printing  of
           trace messages to stderr by setting up a callback.

       GUESTFS_EVENT_ENTER (payload type: function name)
           The callback function is called whenever a libguestfs function is entered.

           The  payload  is a string which contains the name of the function that we are entering (not including
           "guestfs_" prefix).

           Note that libguestfs functions can call themselves, so you may see many events from a single call.  A
           few libguestfs functions do not generate this event.

           If no callback is registered: the event is ignored.

       GUESTFS_EVENT_LIBVIRT_AUTH (payload type: libvirt URI)
           For any API function that opens a libvirt connection, this event may be generated  to  indicate  that
           libvirt demands authentication information.  See "LIBVIRT AUTHENTICATION" below.

           If  no callback is registered: "virConnectAuthPtrDefault" is used (suitable for command-line programs
           only).

   <b>EVENT</b> <b>API</b>
       <u>guestfs_set_event_callback</u>

        int guestfs_set_event_callback (guestfs_h *g,
                                        guestfs_event_callback cb,
                                        uint64_t event_bitmask,
                                        int flags,
                                        void *opaque);

       This function registers a callback ("cb") for all event classes in the "event_bitmask".

       For example, to register for all log message events, you  could  call  this  function  with  the  bitmask
       "GUESTFS_EVENT_APPLIANCE|GUESTFS_EVENT_LIBRARY|GUESTFS_EVENT_WARNING".  To register a single callback for
       all possible classes of events, use "GUESTFS_EVENT_ALL".

       "flags" should always be passed as 0.

       "opaque" is an opaque pointer which is passed to the callback.  You can use it for any purpose.

       The return value is the event handle (an integer) which you can use to delete the callback (see below).

       If  there  is  an error, this function returns -1, and sets the error in the handle in the usual way (see
       "guestfs_last_error" etc.)

       Callbacks remain in effect until they are deleted, or until the handle is closed.

       In the case where multiple callbacks are registered for a particular event class, all  of  the  callbacks
       are called.  The order in which multiple callbacks are called is not defined.

       <u>guestfs_delete_event_callback</u>

        void guestfs_delete_event_callback (guestfs_h *g, int event_handle);

       Delete a callback that was previously registered.  "event_handle" should be the integer that was returned
       by a previous call to "guestfs_set_event_callback" on the same handle.

       <u>guestfs_event_to_string</u>

        char *guestfs_event_to_string (uint64_t event);

       "event"  is  either  a single event or a bitmask of events.  This returns a string representation (useful
       for debugging or printing events).

       A single event is returned as the name in lower case, eg. "close".

       A bitmask of several events is returned as a comma-separated list, eg. "close,progress".

       If zero is passed, then the empty string "" is returned.

       On success this returns a string.  On error it returns NULL and sets "errno".

       The returned string must be freed by the caller.

       <u>guestfs_event_callback</u>

        typedef void (*guestfs_event_callback) (
                         guestfs_h *g,
                         void *opaque,
                         uint64_t event,
                         int event_handle,
                         int flags,
                         const char *buf, size_t buf_len,
                         const uint64_t *array, size_t array_len);

       This is the type of the event callback function that you have to provide.

       The basic parameters are: the handle ("g"), the opaque user pointer  ("opaque"),  the  event  class  (eg.
       "GUESTFS_EVENT_PROGRESS"), the event handle, and "flags" which in the current API you should ignore.

       The  remaining  parameters  contain  the event payload (if any).  Each event may contain a payload, which
       usually relates to the event class, but for future proofing your code should be  written  to  handle  any
       payload for any event class.

       "buf"  and "buf_len" contain a message buffer (if "buf_len == 0", then there is no message buffer).  Note
       that this message buffer can contain arbitrary 8 bit data, including NUL bytes.

       "array" and "array_len" is an array of 64 bit unsigned integers.  At the moment this  is  only  used  for
       progress messages.

   <b>EXAMPLE:</b> <b>CAPTURING</b> <b>LOG</b> <b>MESSAGES</b>
       A  working  program  demonstrating  this  can  be  found  in  <u>examples/debug-logging.c</u>  in  the source of
       libguestfs.

       One motivation for the generic event API was to allow GUI programs to capture debug and  other  messages.
       In libguestfs ≤ 1.8 these were sent unconditionally to "stderr".

       Events   associated   with   log   messages   are:   "GUESTFS_EVENT_LIBRARY",  "GUESTFS_EVENT_APPLIANCE",
       "GUESTFS_EVENT_WARNING" and "GUESTFS_EVENT_TRACE".  (Note that error messages are not  events;  you  must
       capture error messages separately).

       Programs have to set up a callback to capture the classes of events of interest:

        int eh =
          guestfs_set_event_callback
            (g, message_callback,
             GUESTFS_EVENT_LIBRARY | GUESTFS_EVENT_APPLIANCE |
             GUESTFS_EVENT_WARNING | GUESTFS_EVENT_TRACE,
             0, NULL) == -1)
        if (eh == -1) {
          // handle error in the usual way
        }

       The  callback  can then direct messages to the appropriate place.  In this example, messages are directed
       to syslog:

        static void
        message_callback (
                guestfs_h *g,
                void *opaque,
                uint64_t event,
                int event_handle,
                int flags,
                const char *buf, size_t buf_len,
                const uint64_t *array, size_t array_len)
        {
          const int priority = LOG_USER|LOG_INFO;
          if (buf_len &gt; 0)
            syslog (priority, "event 0x%lx: %s", event, buf);
        }

   <b>LIBVIRT</b> <b>AUTHENTICATION</b>
       Some  libguestfs  API  calls   can   open   libvirt   connections.    Currently   the   only   ones   are
       "guestfs_add_domain"; and "guestfs_launch" if the libvirt backend has been selected.  Libvirt connections
       may require authentication, for example if they need to access a remote server or to access root services
       from     non-root.      Libvirt    authentication    happens    via    a    callback    mechanism,    see
       <a href="http://libvirt.org/guide/html/Application_Development_Guide-Connections.html">http://libvirt.org/guide/html/Application_Development_Guide-Connections.html</a>

       You  may  provide  libvirt  authentication  data  by  registering  a  callback   for   events   of   type
       "GUESTFS_EVENT_LIBVIRT_AUTH".

       If  no  such  event  is  registered,  then  libguestfs uses a libvirt function that provides command-line
       prompts ("virConnectAuthPtrDefault").  This is only suitable for command-line libguestfs programs.

       To provide authentication,  first  call  "guestfs_set_libvirt_supported_credentials"  with  the  list  of
       credentials   your   program   knows   how   to   provide.    Second,   register   a   callback  for  the
       "GUESTFS_EVENT_LIBVIRT_AUTH" event.  The  event  handler  will  be  called  when  libvirt  is  requesting
       authentication information.

       In  the  event handler, call "guestfs_get_libvirt_requested_credentials" to get a list of the credentials
       that libvirt is asking for.  You then  need  to  ask  (eg.  the  user)  for  each  credential,  and  call
       "guestfs_set_libvirt_requested_credential"  with  the  answer.  Note that for each credential, additional
       information  may  be   available   via   the   calls   "guestfs_get_libvirt_requested_credential_prompt",
       "guestfs_get_libvirt_requested_credential_challenge"                                                   or
       "guestfs_get_libvirt_requested_credential_defresult".

       The example program below should make this clearer.

       There is also a more substantial working example program supplied with  the  libguestfs  sources,  called
       <u>libvirt-auth.c</u>.

        main ()
        {
          guestfs_h *g;
          char *creds[] = { "authname", "passphrase", NULL };
          int r, eh;

          g = guestfs_create ();
          if (!g) exit (EXIT_FAILURE);

          /* Tell libvirt what credentials the program supports. */
          r = guestfs_set_libvirt_supported_credentials (g, creds);
          if (r == -1)
            exit (EXIT_FAILURE);

          /* Set up the event handler. */
          eh = guestfs_set_event_callback (
              g, do_auth,
              GUESTFS_EVENT_LIBVIRT_AUTH, 0, NULL);
          if (eh == -1)
            exit (EXIT_FAILURE);

          /* An example of a call that may ask for credentials. */
          r = guestfs_add_domain (
              g, "dom",
              GUESTFS_ADD_DOMAIN_LIBVIRTURI, "qemu:///system",
              -1);
          if (r == -1)
            exit (EXIT_FAILURE);

          exit (EXIT_SUCCESS);
        }

        static void
        do_auth (guestfs_h *g,
                 void *opaque,
                 uint64_t event,
                 int event_handle,
                 int flags,
                 const char *buf, size_t buf_len,
                 const uint64_t *array, size_t array_len)
        {
          char **creds;
          size_t i;
          char *prompt;
          char *reply;
          size_t replylen;
          int r;

          // buf will be the libvirt URI.  buf_len may be ignored.
          printf ("Authentication required for libvirt conn '%s'\n",
                  buf);

          // Ask libguestfs what credentials libvirt is demanding.
          creds = guestfs_get_libvirt_requested_credentials (g);
          if (creds == NULL)
            exit (EXIT_FAILURE);

          // Now ask the user for answers.
          for (i = 0; creds[i] != NULL; ++i)
          {
            if (strcmp (creds[i], "authname") == 0 ||
                strcmp (creds[i], "passphrase") == 0)
            {
              prompt =
                guestfs_get_libvirt_requested_credential_prompt (g, i);
              if (prompt &amp;&amp; strcmp (prompt, "") != 0)
                printf ("%s: ", prompt);
              free (prompt);

              // Some code here to ask for the credential.
              // ...
              // Put the reply in 'reply', length 'replylen' (bytes).

             r = guestfs_set_libvirt_requested_credential (g, i,
                 reply, replylen);
             if (r == -1)
               exit (EXIT_FAILURE);
            }

            free (creds[i]);
          }

          free (creds);
        }

</pre><h4><b>CANCELLING</b> <b>LONG</b> <b>TRANSFERS</b></h4><pre>
       Some  operations  can  be  cancelled by the caller while they are in progress.  Currently only operations
       that involve uploading or downloading data can be cancelled (technically: operations that  have  "FileIn"
       or "FileOut" parameters in the generator).

       To  cancel  the  transfer,  call  "guestfs_user_cancel".   For  more information, read the description of
       "guestfs_user_cancel".

</pre><h4><b>PRIVATE</b> <b>DATA</b> <b>AREA</b></h4><pre>
       You can attach named pieces of private data to the libguestfs handle, fetch them by name, and  walk  over
       them,  for  the  lifetime of the handle.  This is called the private data area and is only available from
       the C API.

       To attach a named piece of data, use the following call:

        void guestfs_set_private (guestfs_h *g, const char *key, void *data);

       "key" is the name to associate with this data, and "data" is an arbitrary pointer (which can be  "NULL").
       Any previous item with the same key is overwritten.

       You  can use any "key" string you want, but avoid keys beginning with an underscore character (libguestfs
       uses those for its own internal purposes, such as implementing language  bindings).   It  is  recommended
       that you prefix the key with some unique string to avoid collisions with other users.

       To retrieve the pointer, use:

        void *guestfs_get_private (guestfs_h *g, const char *key);

       This  function returns "NULL" if either no data is found associated with "key", or if the user previously
       set the "key"’s "data" pointer to "NULL".

       Libguestfs does not try to look at or interpret the "data" pointer in any way.  As far as  libguestfs  is
       concerned,  it  need  not  be a valid pointer at all.  In particular, libguestfs does <u>not</u> try to free the
       data when the handle is closed.  If the data must be freed, then the caller must either  free  it  before
       calling "guestfs_close" or must set up a close callback to do it (see "GUESTFS_EVENT_CLOSE").

       To walk over all entries, use these two functions:

        void *guestfs_first_private (guestfs_h *g, const char **key_rtn);

        void *guestfs_next_private (guestfs_h *g, const char **key_rtn);

       "guestfs_first_private" returns the first key, pointer pair ("first" does not have any particular meaning
       --  keys  are  not  returned in any defined order).  A pointer to the key is returned in *key_rtn and the
       corresponding data pointer is returned from the function.  "NULL" is returned if there are no keys stored
       in the handle.

       "guestfs_next_private" returns the next key, pointer pair.  The return value of this function  is  "NULL"
       if there are no further entries to return.

       Notes about walking over entries:

       •   You must not call "guestfs_set_private" while walking over the entries.

       •   The handle maintains an internal iterator which is reset when you call "guestfs_first_private".  This
           internal iterator is invalidated when you call "guestfs_set_private".

       •   If you have set the data pointer associated with a key to "NULL", ie:

            guestfs_set_private (g, key, NULL);

           then that "key" is not returned when walking.

       •   *key_rtn  is  only  valid  until  the next call to "guestfs_first_private", "guestfs_next_private" or
           "guestfs_set_private".

       The following example code shows how to print all keys and data pointers that  are  associated  with  the
       handle "g":

        const char *key;
        void *data = guestfs_first_private (g, &amp;key);
        while (data != NULL)
          {
            printf ("key = %s, data = %p\n", key, data);
            data = guestfs_next_private (g, &amp;key);
          }

       More  commonly  you  are  only  interested in keys that begin with an application-specific prefix "foo_".
       Modify the loop like so:

        const char *key;
        void *data = guestfs_first_private (g, &amp;key);
        while (data != NULL)
          {
            if (strncmp (key, "foo_", strlen ("foo_")) == 0)
              printf ("key = %s, data = %p\n", key, data);
            data = guestfs_next_private (g, &amp;key);
          }

       If you need to modify keys while walking, then you have to jump back to the beginning of the  loop.   For
       example, to delete all keys prefixed with "foo_":

         const char *key;
         void *data;
        again:
         data = guestfs_first_private (g, &amp;key);
         while (data != NULL)
           {
             if (strncmp (key, "foo_", strlen ("foo_")) == 0)
               {
                 guestfs_set_private (g, key, NULL);
                 /* note that 'key' pointer is now invalid, and so is
                    the internal iterator */
                 goto again;
               }
             data = guestfs_next_private (g, &amp;key);
           }

       Note  that  the  above  loop  is  guaranteed  to  terminate because the keys are being deleted, but other
       manipulations of keys within the loop might not terminate unless you also maintain an indication of which
       keys have been visited.

</pre><h4><b>LIBGUESTFS</b> <b>VERSION</b> <b>NUMBERS</b></h4><pre>
       Since April 2010, libguestfs has started to make separate development and  stable  releases,  along  with
       corresponding  branches  in  our  git  repository.   These separate releases can be identified by version
       number:

                        even numbers for stable: 1.2.x, 1.4.x, ...
              .-------- odd numbers for development: 1.3.x, 1.5.x, ...
              |
              v
        1  .  3  .  5
        ^           ^
        |           |
        |           `-------- sub-version
        |
        `------ always '1' because we don't change the ABI

       Thus "1.3.5" is the 5th update to the development branch "1.3".

       As time passes we cherry pick fixes from the development  branch  and  backport  those  into  the  stable
       branch,  the effect being that the stable branch should get more stable and less buggy over time.  So the
       stable releases are ideal for people who don't need new features but would  just  like  the  software  to
       work.

       Our criteria for backporting changes are:

       •   Documentation changes which don’t affect any code are backported unless the documentation refers to a
           future feature which is not in stable.

       •   Bug  fixes  which  are  not  controversial,  fix  obvious  problems,  and  have  been well tested are
           backported.

       •   Simple rearrangements of code which shouldn't affect how it works get backported.  This  is  so  that
           the  code  in  the two branches doesn't get too far out of step, allowing us to backport future fixes
           more easily.

       •   We <u>don’t</u> backport new features, new APIs, new tools etc, except in  one  exceptional  case:  the  new
           feature is required in order to implement an important bug fix.

       A  new  stable branch starts when we think the new features in development are substantial and compelling
       enough over the current stable branch to warrant  it.   When  that  happens  we  create  new  stable  and
       development  versions  1.N.0  and  1.(N+1).0 [N is even].  The new dot-oh release won't necessarily be so
       stable at this point, but by backporting fixes from development, that branch will stabilize over time.

</pre><h4><b>LIMITS</b></h4><pre>
   <b>PROTOCOL</b> <b>LIMITS</b>
       Internally libguestfs uses a message-based protocol to pass API calls and their responses to and  from  a
       small "appliance" (see <b><a href="../man1/guestfs-internals.1.html">guestfs-internals</a></b>(1) for plenty more detail about this).  The maximum message size
       used  by  the  protocol  is slightly less than 4 MB.  For some API calls you may need to be aware of this
       limit.  The API calls which may be affected are individually documented, with a link back to this section
       of the documentation.

       In libguestfs &lt; 1.19.32, several calls had to encode either their entire argument list  or  their  entire
       return value (or sometimes both) in a single protocol message, and this gave them an arbitrary limitation
       on how much data they could handle.  For example, "guestfs_cat" could only download a file if it was less
       than  around 4 MB in size.  In later versions of libguestfs, some of these limits have been removed.  The
       APIs which were previously limited but are now unlimited (except perhaps by available memory) are  listed
       below.   To  find  out  if a specific API is subject to protocol limits, check for the warning in the API
       documentation which links to this section, and remember to check the version of  the  documentation  that
       matches the version of libguestfs you are using.

       "guestfs_cat",     "guestfs_find",     "guestfs_read_file",     "guestfs_read_lines",    "guestfs_write",
       "guestfs_write_append", "guestfs_lstatlist", "guestfs_lxattrlist", "guestfs_readlinklist", "guestfs_ls".

       See also "UPLOADING" and "DOWNLOADING" for further information about copying large amounts of  data  into
       or out of a filesystem.

   <b>MAXIMUM</b> <b>NUMBER</b> <b>OF</b> <b>DISKS</b>
       In  libguestfs  ≥  1.19.7,  you  can  query  the  maximum  number  of  disks that may be added by calling
       "guestfs_max_disks".  In earlier versions of libguestfs (ie. where this call is not available) you should
       assume the maximum is 25.

       The rest of this section covers implementation details, which could change in future.

       When using virtio-scsi disks (the default if available in qemu) the current limit  is  <b>255</b>  disks.   When
       using virtio-blk (the old default) the limit is around <b>27</b> disks, but may vary according to implementation
       details and whether the network is enabled.

       Virtio-scsi  as  used  by  libguestfs  is  configured  to  use  one  target per disk, and 256 targets are
       available.

       Virtio-blk consumes 1 virtual PCI slot per disk, and PCI is limited to 31 slots, but some  of  these  are
       used for other purposes.

       One virtual disk is used by libguestfs internally.

       Before  libguestfs  1.19.7,  disk names had to be a single character (eg. <u>/dev/sda</u> through <u>/dev/sdz</u>), and
       since one disk is reserved, that meant the limit was 25.  This has been fixed in more recent versions.

   <b>MAXIMUM</b> <b>NUMBER</b> <b>OF</b> <b>PARTITIONS</b> <b>PER</b> <b>DISK</b>
       Virtio limits the maximum number of partitions per disk to <b>15</b>.

       This is because it reserves 4 bits for the minor device number  (thus  <u>/dev/vda</u>,  and  <u>/dev/vda1</u>  through
       <u>/dev/vda15</u>).

       If you attach a disk with more than 15 partitions, the extra partitions are ignored by libguestfs.

   <b>MAXIMUM</b> <b>SIZE</b> <b>OF</b> <b>A</b> <b>DISK</b>
       Probably the limit is between 2**63-1 and 2**64-1 bytes.

       We  have  tested  block  devices  up to 1 exabyte (2**60 or 1,152,921,504,606,846,976 bytes) using sparse
       files backed by an XFS host filesystem.

       Although libguestfs probably does not impose any limit, the underlying host storage will.  If  you  store
       disk  images  on  a  host ext4 filesystem, then the maximum size will be limited by the maximum ext4 file
       size (currently 16 TB).  If you store disk images as host logical volumes then you  are  limited  by  the
       maximum size of an LV.

       For the hugest disk image files, we recommend using XFS on the host for storage.

   <b>MAXIMUM</b> <b>SIZE</b> <b>OF</b> <b>A</b> <b>PARTITION</b>
       The  MBR (ie. classic MS-DOS) partitioning scheme uses 32 bit sector numbers.  Assuming a 512 byte sector
       size, this means that MBR cannot address a partition located beyond 2 TB on the disk.

       It is recommended that you use GPT partitions on disks which are larger than this size.  GPT uses 64  bit
       sector  numbers  and  so  can  address partitions which are theoretically larger than the largest disk we
       could support.

   <b>MAXIMUM</b> <b>SIZE</b> <b>OF</b> <b>A</b> <b>FILESYSTEM,</b> <b>FILES,</b> <b>DIRECTORIES</b>
       This depends on the filesystem type.  libguestfs  itself  does  not  impose  any  known  limit.   Consult
       Wikipedia or the filesystem documentation to find out what these limits are.

   <b>MAXIMUM</b> <b>UPLOAD</b> <b>AND</b> <b>DOWNLOAD</b>
       The  API functions "guestfs_upload", "guestfs_download", "guestfs_tar_in", "guestfs_tar_out" and the like
       allow unlimited sized uploads and downloads.

   <b>INSPECTION</b> <b>LIMITS</b>
       The inspection code has several arbitrary limits on things like the size of Windows Registry hive it will
       read, and the length of product name.  These are intended  to  stop  a  malicious  guest  from  consuming
       arbitrary  amounts  of memory and disk space on the host, and should not be reached in practice.  See the
       source code for more information.

</pre><h4><b>ADVANCED</b> <b>MACHINE</b> <b>READABLE</b> <b>OUTPUT</b></h4><pre>
       Some of the tools support a <u>--machine-readable</u> option, which is generally used to make  the  output  more
       machine friendly, for easier parsing for example.  By default, this output goes to stdout.

       When using the <u>--machine-readable</u> option, the progress, information, warning, and error messages are also
       printed  in JSON format for easier log tracking.  Thus, it is highly recommended to redirect the machine-
       readable output to a different stream.  The format of these JSON messages is like the following (actually
       printed within a single line, below it is indented for readability):

        {
          "message": "Finishing off",
          "timestamp": "2019-03-22T14:46:49.067294446+01:00",
          "type": "message"
        }

       "type" can be: "message" for progress messages, "info" for information messages,  "warning"  for  warning
       messages, and "error" for error message.  "timestamp" is the RFC 3339 timestamp of the message.

       In  addition  to  that,  a subset of these tools support an extra string passed to the <u>--machine-readable</u>
       option: this string specifies where the machine-readable output will go.

       The possible values are:

       <b>fd:</b><u>fd</u>
           The output goes to the specified <u>fd</u>, which is a file descriptor already opened for writing.

       <b>file:</b><u>filename</u>
           The output goes to the specified <u>filename</u>.

       <b>stream:stdout</b>
           The output goes to stdout.  This is basically the same as the default behaviour of <u>--machine-readable</u>
           with no parameter, although stdout as output is specified explicitly.

       <b>stream:stderr</b>
           The output goes to stderr.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       LIBGUESTFS_APPEND
           Pass additional options to the guest kernel.

       LIBGUESTFS_ATTACH_METHOD
           This is the old way to set "LIBGUESTFS_BACKEND".

       LIBGUESTFS_BACKEND
           Choose the default way to create the appliance.  See "guestfs_set_backend" and "BACKEND".

       LIBGUESTFS_BACKEND_SETTINGS
           A colon-separated list of backend-specific settings.  See "BACKEND", "BACKEND SETTINGS".

       LIBGUESTFS_CACHEDIR
           The location where libguestfs will cache  its  appliance,  when  using  a  supermin  appliance.   The
           appliance is cached and shared between all handles which have the same effective user ID.

           If "LIBGUESTFS_CACHEDIR" is not set, then "TMPDIR" is used.  If "TMPDIR" is not set, then <u><a href="file:/var/tmp">/var/tmp</a></u> is
           used.

           See also "LIBGUESTFS_TMPDIR", "guestfs_set_cachedir".

       LIBGUESTFS_DEBUG
           Set  "LIBGUESTFS_DEBUG=1"  to  enable  verbose  messages.   This  has  the  same  effect  as  calling
           "guestfs_set_verbose (g, 1)".

       LIBGUESTFS_HV
           Set the default hypervisor (usually qemu) binary that libguestfs uses.  If not  set,  then  the  qemu
           which was found at compile time by the configure script is used.

           See also "QEMU WRAPPERS" above.

       LIBGUESTFS_MEMSIZE
           Set the memory allocated to the qemu process, in megabytes.  For example:

            LIBGUESTFS_MEMSIZE=700

       LIBGUESTFS_PATH
           Set the path that libguestfs uses to search for a supermin appliance.  See the discussion of paths in
           section "PATH" above.

       LIBGUESTFS_QEMU
           This is the old way to set "LIBGUESTFS_HV".

       LIBGUESTFS_TMPDIR
           The location where libguestfs will store temporary files used by each handle.

           If "LIBGUESTFS_TMPDIR" is not set, then "TMPDIR" is used.  If "TMPDIR" is not set, then <u><a href="file:/tmp">/tmp</a></u> is used.

           See also "LIBGUESTFS_CACHEDIR", "guestfs_set_tmpdir".

       LIBGUESTFS_TRACE
           Set   "LIBGUESTFS_TRACE=1"   to  enable  command  traces.   This  has  the  same  effect  as  calling
           "guestfs_set_trace (g, 1)".

       PATH
           Libguestfs may run some external programs, and relies on $PATH being set to a reasonable  value.   If
           using  the  libvirt backend, libvirt will not work at all unless $PATH contains the path of qemu/KVM.
           Note that PHP by default removes $PATH from the environment which tends to break everything.

       SUPERMIN_KERNEL
       SUPERMIN_KERNEL_VERSION
       SUPERMIN_MODULES
           These three environment variables allow the kernel that  libguestfs  uses  in  the  appliance  to  be
           selected.   If  $SUPERMIN_KERNEL  is  not  set, then the most recent host kernel is chosen.  For more
           information about kernel selection, see <b><a href="../man1/supermin.1.html">supermin</a></b>(1).

       TMPDIR
           See "LIBGUESTFS_CACHEDIR", "LIBGUESTFS_TMPDIR".

       XDG_RUNTIME_DIR
           This directory represents a user-specific directory for storing non-essential runtime files.

           If it is set, then is used to store temporary sockets and PID files.  Otherwise, <u><a href="file:/tmp">/tmp</a></u> is used.

           See also "guestfs_get_sockdir", <a href="http://www.freedesktop.org/wiki/Specifications/basedir-spec/">http://www.freedesktop.org/wiki/Specifications/basedir-spec/</a>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Examples written in C: <b><a href="../man3/guestfs-examples.3.html">guestfs-examples</a></b>(3).

       Language   bindings:   <b><a href="../man3/guestfs-erlang.3.html">guestfs-erlang</a></b>(3),   <b><a href="../man3/guestfs-gobject.3.html">guestfs-gobject</a></b>(3),    <b><a href="../man3/guestfs-golang.3.html">guestfs-golang</a></b>(3),    <b><a href="../man3/guestfs-java.3.html">guestfs-java</a></b>(3),
       <b><a href="../man3/guestfs-lua.3.html">guestfs-lua</a></b>(3), <b><a href="../man3/guestfs-ocaml.3.html">guestfs-ocaml</a></b>(3), <b><a href="../man3/guestfs-perl.3.html">guestfs-perl</a></b>(3), <b><a href="../man3/guestfs-python.3.html">guestfs-python</a></b>(3), <b><a href="../man3/guestfs-ruby.3.html">guestfs-ruby</a></b>(3).

       Tools:  <b><a href="../man1/guestfish.1.html">guestfish</a></b>(1), <b><a href="../man1/guestmount.1.html">guestmount</a></b>(1), <b><a href="../man1/virt-alignment-scan.1.html">virt-alignment-scan</a></b>(1), <b><a href="../man1/virt-builder.1.html">virt-builder</a></b>(1), <b><a href="../man1/virt-builder-repository.1.html">virt-builder-repository</a></b>(1),
       <b><a href="../man1/virt-cat.1.html">virt-cat</a></b>(1),   <b><a href="../man1/virt-copy-in.1.html">virt-copy-in</a></b>(1),   <b><a href="../man1/virt-copy-out.1.html">virt-copy-out</a></b>(1),    <b><a href="../man1/virt-customize.1.html">virt-customize</a></b>(1),    <b><a href="../man1/virt-df.1.html">virt-df</a></b>(1),    <b><a href="../man1/virt-diff.1.html">virt-diff</a></b>(1),
       <b><a href="../man1/virt-edit.1.html">virt-edit</a></b>(1),    <b><a href="../man1/virt-filesystems.1.html">virt-filesystems</a></b>(1),    <b><a href="../man1/virt-format.1.html">virt-format</a></b>(1),   <b><a href="../man1/virt-inspector.1.html">virt-inspector</a></b>(1),   <b><a href="../man1/virt-list-filesystems.1.html">virt-list-filesystems</a></b>(1),
       <b><a href="../man1/virt-list-partitions.1.html">virt-list-partitions</a></b>(1),   <b><a href="../man1/virt-log.1.html">virt-log</a></b>(1),   <b><a href="../man1/virt-ls.1.html">virt-ls</a></b>(1),   <b><a href="../man1/virt-make-fs.1.html">virt-make-fs</a></b>(1),   <b><a href="../man1/virt-p2v.1.html">virt-p2v</a></b>(1),   <b><a href="../man1/virt-rescue.1.html">virt-rescue</a></b>(1),
       <b><a href="../man1/virt-resize.1.html">virt-resize</a></b>(1),    <b><a href="../man1/virt-sparsify.1.html">virt-sparsify</a></b>(1),    <b><a href="../man1/virt-sysprep.1.html">virt-sysprep</a></b>(1),   <b><a href="../man1/virt-tail.1.html">virt-tail</a></b>(1),   <b><a href="../man1/virt-tar.1.html">virt-tar</a></b>(1),   <b><a href="../man1/virt-tar-in.1.html">virt-tar-in</a></b>(1),
       <b><a href="../man1/virt-tar-out.1.html">virt-tar-out</a></b>(1), <b><a href="../man1/virt-v2v.1.html">virt-v2v</a></b>(1), <b><a href="../man1/virt-win-reg.1.html">virt-win-reg</a></b>(1).

       Other libguestfs topics: <b><a href="../man1/guestfs-building.1.html">guestfs-building</a></b>(1), <b><a href="../man1/guestfs-faq.1.html">guestfs-faq</a></b>(1),  <b><a href="../man1/guestfs-hacking.1.html">guestfs-hacking</a></b>(1),  <b><a href="../man1/guestfs-internals.1.html">guestfs-internals</a></b>(1),
       <b><a href="../man1/guestfs-performance.1.html">guestfs-performance</a></b>(1),      <b><a href="../man1/guestfs-release-notes.1.html">guestfs-release-notes</a></b>(1),      <b><a href="../man1/guestfs-security.1.html">guestfs-security</a></b>(1),      <b><a href="../man1/guestfs-testing.1.html">guestfs-testing</a></b>(1),
       <b><a href="../man1/libguestfs-test-tool.1.html">libguestfs-test-tool</a></b>(1), <b><a href="../man1/libguestfs-make-fixed-appliance.1.html">libguestfs-make-fixed-appliance</a></b>(1).

       Related manual pages: <b><a href="../man1/supermin.1.html">supermin</a></b>(1), <b><a href="../man1/qemu.1.html">qemu</a></b>(1), <b><a href="../man3/hivex.3.html">hivex</a></b>(3), <b><a href="../man1/stap.1.html">stap</a></b>(1), <b><a href="../man3/sd-journal.3.html">sd-journal</a></b>(3).

       Website: <a href="http://libguestfs.org/">http://libguestfs.org/</a>

       Tools with a similar purpose: <b><a href="../man8/fdisk.8.html">fdisk</a></b>(8), <b><a href="../man8/parted.8.html">parted</a></b>(8), <b><a href="../man8/kpartx.8.html">kpartx</a></b>(8), <b><a href="../man8/lvm.8.html">lvm</a></b>(8), <b><a href="../man1/disktype.1.html">disktype</a></b>(1).

</pre><h4><b>AUTHORS</b></h4><pre>
       Richard W.M. Jones ("rjones at redhat dot com")

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2009-2023 Red Hat Inc.

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser
       General Public License as published by the Free Software Foundation; either version 2 of the License,  or
       (at your option) any later version.

       This  library  is  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
       the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser  General
       Public License for more details.

       You should have received a copy of the GNU Lesser General Public License along with this library; if not,
       write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

</pre><h4><b>BUGS</b></h4><pre>
       To      get      a      list      of      bugs      against      libguestfs,      use      this     link:
       https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools

       To      report      a      new       bug       against       libguestfs,       use       this       link:
       https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools

       When reporting a bug, please supply:

       •   The version of libguestfs.

       •   Where you got libguestfs (eg. which Linux distro, compiled from source, etc)

       •   Describe the bug accurately and give a way to reproduce it.

       •   Run <b><a href="../man1/libguestfs-test-tool.1.html">libguestfs-test-tool</a></b>(1) and paste the <b>complete,</b> <b>unedited</b> output into the bug report.

libguestfs-1.54.1                                  2025-02-18                                         <u><a href="../man3/guestfs.3.html">guestfs</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>