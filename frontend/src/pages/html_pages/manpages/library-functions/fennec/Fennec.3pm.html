<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fennec - A testers toolbox, and best friend</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfennec-perl">libfennec-perl_2.018-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Fennec - A testers toolbox, and best friend

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Fennec ties together several testing related modules and enhances their functionality in ways you don't
       get loading them individually. Fennec makes testing easier, and more useful.

   <b>CAVEAT</b> <b>EMPTOR</b>
       This module is deprecated in favor of Test2::Suite, specifically Test2::Tools::Spec and
       Test2::Bundle::SpecDeclare.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       There are 2 ways to use Fennec. You can use Fennec directly, or you can use the shiny sugar-coated
       interface provided by the add-on module Fennec::Declare.

   <b>VANILLA</b> <b>SYNTAX</b>
       If Devel::Declare and its awesome power of syntax specification scares you, you can always write your
       Fennec tests in the stone age like this... just don't miss any semicolons.

       t/some_test.t:

           package TEST::SomeTest;
           use strict;
           use warnings;

           use Fennec(
               parallel  =&gt; 3,
               test_sort =&gt; 'random',
           );

           # This is optional, there is a default 'new' if you do not override it.
           sub new { ... }

           # Test blocks are called as methods on an instance of your test package.
           tests group_1 =&gt; sub {
               my $self = shift;
               ok( 1, "1 is true" );
           };

           test group_2 =&gt; (
               todo =&gt; 'This is not ready yet',
               code =&gt; sub {
                   my $self = shift;
                   ok( 0, "Not ready" );
               }
           );

           # It is important to always end a Fennec test with this function call.
           done_testing();

   <b>DECLARE</b> <b>SYNTAX</b>
       <b>Note:</b> In order to use this you <b>MUST</b> install Fennec::Declare which is a separate distribution on cpan.
       This module is separate because it uses the controversial Devel::Declare module.

       t/some_test.t:

           package TEST::SomeTest;
           use strict;
           use warnings;

           use Fennec::Declare(
               parallel  =&gt; 3,
               test_sort =&gt; 'random',
           );

           # This is optional, there is a default 'new' if you do not override it.
           sub new { ... }

           # Test blocks are called as methods on an instance of your test package.
           tests group_1 {
               # Note: $self is automatically shifted for you.
               ok( $self, "Got self automatically" );
           };

           test group_2 ( todo =&gt; 'This is not ready yet' ) {
               # Note: $self is automatically shifted for you.
               ok( 0, "Not ready" );
           }

           # It is important to always end a Fennec test with this function call.
           done_testing;

</pre><h4><b>FEATURES</b></h4><pre>
   <b>PROVIDED</b> <b>DIRECTLY</b> <b>BY</b> <b>FENNEC</b>
       Forking just works
           Forking   in   perl   tests  that  use  Test::Builder  is  perilous  at  best.  Fennec  initiates  an
           Fennec::Collector class which sets up Test::Builder to funnel all test results to the main thread for
           rendering. A result of this is that forking just works.

       Concurrency, test blocks can run in parallel
           By default all "test" blocks are run in parallel with a cap of 3 concurrent  processes.  The  process
           cap can be set with the "parallel" import argument.

       No need to maintain a test count
           The  test  count  traditionally  was  used  to  ensure  your file finished running instead of exiting
           silently too early.  With  Test::Builder  and  friends  this  has  largely  been  replaced  with  the
           "done_testing()" function typically called at the end of tests. Fennec shares this concept, but takes
           it  further,  you  MUST call "done_testing()" at the end of your test files. This is safer because it
           can be used to ensure your test script ran completely.

       Can be decoupled from Test::Builder
           Fennec is built with the assumption that Test::Builder and tools built from it will be used.  However
           custom  Fennec::Collector  and  Fennec::Runner  classes  can replace this assumption with any testing
           framework you want to use.

       Can run specific test blocks, excluding others
           Have you ever had a huge test that took a long time to run? Have you ever needed to debug  a  failing
           test at the end of the file? How many times did you need to sit through tests that didn't matter?

           With  Fennec you can specify the "FENNEC_TEST" environment variable with either a line number or test
           block name. Only tests defined on that line, or with that name will be run.

       Predictability: Rand is always seeded with the date
           Randomizing the order in which test blocks are run can help find subtle interaction bugs. At the same
           time if tests are always in random order you cannot reliably reproduce a failure.

           Fennec always seeds rand with the current date. This means that on any given date the test run  order
           will  always  be  the  same. However different days test different orders. You can always specify the
           "FENNEC_SEED" environment variable to override the value used to seed rand.

       Diag output is coupled with test output
           When you run a Fennec test with a verbose harness (prove -v) the diagnostic output  will  be  coupled
           with  the  TAP  output.  This  is done by sending both output to STDOUT. In a non-verbose harness the
           diagnostics will be sent to STDERR per usual.

       Works with Moose
           All your test classes are instantiated objects. You can use Moose to define these test  classes.  But
           you do not have to, you are not forced to use OOP in your tests.

   <b>PROVIDED</b> <b>BY</b> <b>MODULES</b> <b>LOADED</b> <b>BY</b> <b>FENNEC</b>
       The 3 most common and useful Test::* modules
           Test::More, Test::Warn, Test::Exception

       RSPEC support
           Those  familiar with Ruby may already know about the RSPEC testing process. In general you "describe"
           something that  is  to  be  tested,  then  you  define  setup  and  teardown  methods  ("before_all",
           "before_each",  "after_all", "after_each") and then finally you test "it". See the "EXAMPLES" section
           or Test::Workflow for more details.

       Test re-ordering, tests can run in random, sorted, or defined order.
           When you load Fennec you can specify a test order. The default is random. You can also use the  order
           in  which  they are defined, or sorted (alphabetically) order. If necessary you can pass in a sorting
           function that takes a list of all test-objects as arguments.

           <u>Provided</u> <u>by</u> <u>Test::Workflow</u>

       Reusable test modules
           You can write tests in modules using Test::Workflow and then import those tests  into  Fennec  tests.
           This is useful if you have tests that you want run in several, or even all test files.

           <u>Provided</u> <u>by</u> <u>Test::Workflow</u>

       Incredibly powerful mocking with a simple API
           You  can  create  classless object instances from a specification on the fly, define new packages, or
           override existing packages.

           <u>Provided</u> <u>by</u> <u>Mock::Quick</u>

</pre><h4><b>DEFAULT</b> <b>IMPORTED</b> <b>MODULES</b></h4><pre>
       <b>Note:</b> These can be overridden either on import, or by subclassing Fennec.

       Child - Forking for dummies
           Child is an OO interface to forking that removes all the boilderplate such as  checking  if  the  pid
           changed, and making sure you exit the child process.

       Mock::Quick - Mocking without the eye gouging
           Mock::Quick  is  a  mocking  library that makes mocking easy. In addition it uses a declarative style
           interface. Unlike most other mocking libraries on CPAN, it does not make people want to  gouge  their
           eyes out and curl up in the fetal position.

       Test::Workflow - RSPEC for perl.
           Test::Workflow  is  a  testing  library  written specifically for Fennec. This library provides RSPEC
           workflow functions and structure. It can be useful on its own,  but  combined  with  Fennec  it  gets
           concurrency.

       Test::More
           Tried and True testing module that everyone uses.

       Test::Warn
           Test::Warn - Test code that issues warnings.

       Test::Exception
           Test::Exception - Test code that throws exceptions

</pre><h4><b>IMPORT</b> <b>ARGUMENTS</b></h4><pre>
       base =&gt; 'Some::Base'
           Load the specified module and make it the base class for your test class.

       class =&gt; 'What::To::Test'
           Used  to  specify  the  name  of  the  package  your  test file is validating. When this parameter is
           specified 3 things are done for you: The class  is  automatically  loaded,  the  $CLASS  variable  is
           imported and contains the module name, and the <b>class()</b> subroutine is defined and returns the name.

               use Fennec class =&gt; 'Foo::Bar';

               ok( $INC{'Foo/Bar.pm'}, "Loaded 'Foo::Bar'" );
               is( $CLASS, 'Foo::Bar', "We have \$CLASS" );
               is( class(), 'Foo::Bar', "We have class()" );

               tests method =&gt; sub {
                   my $self = shift;
                   is( $self-&gt;class(), 'Foo::Bar', "We have class() method" );
               };

               done_testing;

       parallel =&gt; $PROC_LIMIT
           How  many  test blocks can be run in parallel. Default is 3. Set to 1 to fork for each test, but only
           run one at a time. Set to 0 to prevent forking.

           You can also set this using the $FENNEC_PARALLEL environment variable.

       debug =&gt; 1
           Enable tracking debugging information. At the end of the Fennec run it will present you  with  a  CSV
           temp  file.  This file lists all blocks that are run, and mocks that are made in sequence from top to
           bottom. The actions are split into columns by PID. This is  usedul  when  debugging  potential  race-
           conditions when using parallel testing.

           Example:

               26150,26151,26152,26153,26154
               0 26150 BLOCK 54-&gt;78 child: outer_wrap, , , , ,
                ,1 26151 BLOCK 47-&gt;52 test: class_store, , , ,
               0 26150 MOCK Foo =&gt; (outer), , , , ,
               0 26150 BLOCK 58-&gt;61 before_all: ba, , , , ,
                , ,2 26152 MOCK Foo =&gt; (outer), , ,
                , ,2 26152 BLOCK 63-&gt;66 before_each: be, , ,
                , ,2 26152 BLOCK 68-&gt;72 test: the_check, , ,
                , , ,3 26153 BLOCK 16-&gt;31 test: object, ,
                , , , ,4 26154 BLOCK 33-&gt;45 test: class,

           You can use this in a spreadsheet program, or use this command to look at it in a more friendly way.

               column -s, -t &lt; '/path/to/tempfile' | less -#2 -S

       collector_class =&gt; 'Fennec::Collector::TB::TempFiles'
           Specify  which  collector to use. Defaults to a Test::Builder based collector that uses temp files to
           funnel tests from child procs to the parent.

           You generally won't need to specify this, unless you use a test infrastructure that  is  neither  TAP
           nore Test::Builder based.

       runner_class =&gt; 'Fennec::Runner'
           Specify the runner class. You probably don't need this.

       runner_params =&gt; { ... }
           Lets you specify arguments used when Fennec::Runner is initialized.

       skip_without =&gt; [ 'Need::This', 'And::This' ]
           Tell Fennec to skip the test file if any of the specified modules are missing.

       test_sort =&gt; $SORT
           Options: 'random', 'sorted', 'ordered', or a code block.

           Code block accepts a list of Test::Workflow::Test objects.

       utils =&gt; [ 'Test::Foo', ... ]
           Load these modules instead of the default list.

           If  you  need  to specify import arguments for any specific util class, you can use the class name as
           the key with an arrayref containing the arguments.

               use Fennec(
                   utils          =&gt; [ 'Some::Module' ],
                   'Some::Module' =&gt; [ arg =&gt; $val, ... ],
               );

       with_tests =&gt; [ 'Reusable::Tests', 'Common::Tests' ]
           Load these modules that have reusable tests. Reusable tests are tests that  are  common  to  multiple
           test files.

       seed =&gt; '...'
           Set  the  random  seed  to  be  used.  Defaults to current date, can be overridden by the FENNEC_SEED
           environment variable.

</pre><h4><b>ENVIRONMENT</b> <b>VARIABLES</b></h4><pre>
       FENNEC_SEED
           Can be used to set a specific random seed

       FENNEC_TEST
           Can be used to tell Fennec to only run specific tests (can be given a line number or a block name).

       FENNEC_DEBUG
           When true internal debugging is turned on.

</pre><h4><b>EXPORTED</b> <b>FUNCTIONS</b></h4><pre>
   <b>FROM</b> <b>FENNEC</b>
       <b>done_testing()</b>
       done_testing(sub { ... })
           Should be called at the end of your test file to kick off the RSPEC tests.  Always returns 1, so  you
           can use it as the last statement of your module. You must only ever call this once per test file.

           <b>Never</b>  put  tests  below  the  done_testing  call.  If you want tests to run AFTER the RSPEC workflow
           completes, you can pass done_testing a coderef with the tests.

               done_testing( sub {
                   ok( 1, "This runs after the RSPEC workflow" );
               });

   <b>FROM</b> <b>Test::Workflow</b>
       See Test::Workflow or "EXAMPLES" for more details.

       with_tests 'Module::Name';
           Import tests from a module

       tests $name =&gt; sub { ... };
       tests $name =&gt; ( %params );
       it $name =&gt; sub { ... };
       it $name =&gt; ( %params );
           Define a test block

       describe $name =&gt; sub { ... };
           Describe a set of tests (group tests and setup/teardown functions)

       case $name =&gt; sub { ... };
           Used to run a set of tests against multiple conditions

       before_all $name =&gt; sub { ... };
           Setup, run once before any tests in the describe scope run.

       before_case $name =&gt; sub { ... };
           Setup, run before any case blocks are run.

       before_each $name =&gt; sub { ... };
       after_case $name =&gt; sub { ... };
           Setup, run once per test, just before it runs. Both run after the case block (if there is one).

       around_each $name =&gt; sub { ... };
           Setup and/or teardown.

       after_each $name =&gt; sub { ... };
           Teardown, run once per test, after it finishes.

       after_all $name =&gt; sub { ... };
           Teardown, run once, after all tests in the describe scope complete.

   <b>FROM</b> <b>Mock::Quick</b>
       See Mock::Quick or "EXAMPLES" for more details.

       my $control = qclass $CLASS =&gt; ( %PARAMS, %OVERRIDES );
       my $control = qtakeover $CLASS =&gt; ( %PARAMS, %OVERRIDES );
       my $control = qimplement $CLASS =&gt; ( %PARAMS, %OVERRIDES );
       my $control = qcontrol $CLASS =&gt; ( %PARAMS, %OVERRIDES );
           Used to define, takeover, or override parts of other packages.

       my $obj = qobj( %PARAMS );
       my ( $obj, $control ) = qobjc( %PARAMS );
       my $obj = qstrict( %PARAMS );
       my ( $obj, $control ) = qstrictc( %PARAMS );
           Define an object specification, quickly.

       my $clear = <b>qclear()</b>;
           Used to clear a field in a quick object.

       my $meth = qmeth { ... };
       my $meth = qmeth( sub { ... } );
           Used to define a method for a quick object.

   <b>OTHER</b>
       See Test::More, Test::Warn, and Test::Exception

</pre><h4><b>EXAMPLES</b></h4><pre>
       Examples can be the best form of documentation.

   <b>SIMPLE</b>
       <u>VANILLA</u> <u>SYNTAX</u>

       t/simple.t

           use strict;
           use warnings;

           use Fennec;

           use_ok 'Data::Dumper';

           tests dumper =&gt; sub {
               my $VAR1;
               is_deeply(
                   eval Dumper({ a =&gt; 1 }),
                   { a =&gt; 1 },
                   "Serialize and De-Serialize"
               );
           };

           tests future =&gt; (
               todo =&gt; "Not ready yet",
               code =&gt; sub {
                   ok( 0, "I still have to write these" );
               },
           );

           done_testing;

       <u>DECLARE</u> <u>SYNTAX</u>

       t/simple.t

           use strict;
           use warnings;

           use Fennec::Declare;

           use_ok 'Data::Dumper';

           tests dumper {
               my $VAR1;
               is_deeply(
                   eval Dumper({ a =&gt; 1 }),
                   { a =&gt; 1 },
                   "Serialize and De-Serialize"
               );

               is(
                   eval { no strict; Dumper( { a =&gt; 1 } ) },
                   { a =&gt; 1 },
                   "Serialize and De-Serialize"
               );
           }

           tests future( todo =&gt; "Not ready yet" ) {
               ok( 0, "I still have to write these" );
           }

           done_testing;

   <b>RUN</b> <b>TESTS</b> <b>UNDER</b> <b>DIFFERENT</b> <b>CONDITIONS</b>
       This example shows 4 conditions ($letter as 'a', 'b', 'c', and 'd'). It also has 2 test blocks, one  that
       verifies  $letter  is  a letter, the other verifies it is lowercase. Each test block will be run once for
       each condition, 2*4=8, so in total 8 tests will be run.

       <u>VANILLA</u>

       sample.t:

           use strict;
           use warnings;

           use Fennec;

           my $letter;
           case a =&gt; sub { $letter = 'a' };
           case b =&gt; sub { $letter = 'b' };
           case c =&gt; sub { $letter = 'c' };
           case d =&gt; sub { $letter = 'd' };

           tests is_letter =&gt; sub {
               like( $letter, qr/^[a-z]$/i, "Got a letter" );
           };

           tests is_lowercase =&gt; sub {
               is( $letter, lc( $letter ), "Letter is lowercase" );
           };

           done_testing;

       <u>OBJECT</u> <u>ORIENTED</u>

       sample.t

           use strict;
           use warnings;

           use Fennec;

           sub letter {
               my $self = shift;
               ( $self-&gt;{letter} ) = @_ if @_;
               return $self-&gt;{letter};
           }

           describe letters =&gt; sub {
               case a =&gt; sub { shift-&gt;letter('a') };
               case b =&gt; sub { shift-&gt;letter('b') };
               case c =&gt; sub { shift-&gt;letter('c') };
               case d =&gt; sub { shift-&gt;letter('d') };

               tests is_letter =&gt; sub {
                   my $self = shift;
                   like( $self-&gt;letter, qr/^[a-z]$/i, "Got a letter" );
               };

               tests is_lowercase =&gt; sub {
                   my $self = shift;
                   is( $self-&gt;letter, lc( $self-&gt;letter ), "Letter is lowercase" );
               };
           };

           done_testing;

       <u>DECLARE</u>

       <b>Note:</b> no need to shift $self, it is done for you!

       sample.t

           use strict;
           use warnings;

           use Fennec::Declare;

           sub letter {
               my $self = shift;
               ( $self-&gt;{letter} ) = @_ if @_;
               return $self-&gt;{letter};
           }

           describe letters {
               case a { $self-&gt;letter('a') }

               case b { $self-&gt;letter('b') }

               case c { $self-&gt;letter('c') }

               case d { $self-&gt;letter('d') }

               tests is_letter {
                   like( $self-&gt;letter, qr/^[a-z]$/i, "Got a letter" );
               }

               tests is_lowercase {
                   is( $self-&gt;letter, lc( $self-&gt;letter ), "Letter is lowercase" );
               }
           }

           done_testing;

   <b>MOCKING</b>
       See Mock::Quick for more details

       <u>OBJECT</u> <u>ON</u> <u>THE</u> <u>FLY</u>

           my $obj = qobj(
               foo =&gt; 'foo',
               bar =&gt; qmeth { 'bar' },
               baz =&gt; sub { 'baz' },
           );

           is( $obj-&gt;foo, 'foo' );
           is( $obj-&gt;bar, 'bar' );
           is( ref $obj-&gt;baz, 'CODE', "baz is a method that returns a coderef" );

           # All methods autovivify as read/write accessors:
           lives_ok { $obj-&gt;blah( 'x' ) };

           # use qstrict() to make an object that does not autovivify accessors.

       <u>SCOPE</u> <u>OF</u> <u>MOCKS</u> <u>IN</u> <u>FENNEC</u>

       With vanilla Mock::Quick a mock is destroyed when the control object is destroyed.

           my $control = qtakeover Foo =&gt; (blah =&gt; 'blah');
           is( Foo-&gt;blah, 'blah', "got mock" );
           $control = undef;
           ok( !Foo-&gt;can('blah'), "Mock destroyed" );

           # WITHOUT FENNEC This issues a warning, the $control object is ignored so
           # the mock is destroyed before it can be used.
           qtakover Foo =&gt; (blah =&gt; 'blah');
           ok( !Foo-&gt;can('blah'), "Mock destroyed before it could be used" );

       With the workflow support provided by Fennec, you can omit the control object and let the mock be  scoped
       implicitly.

           tests implicit_mock_scope =&gt; sub {
               my $self = shift;
               can_ok( $self, 'QINTERCEPT' );
               qtakeover Foo =&gt; (blah =&gt; sub { 'blah' });
               is( Foo-&gt;blah, 'blah', "Mock not auto-destroyed" );
           };

           describe detailed_implicit_mock_scope =&gt; sub {
               qtakeover Foo =&gt; ( outer =&gt; 'outer' );
               ok( !Foo-&gt;can( 'outer' ), "No Leak" );

               before_all ba =&gt; sub {
                   qtakeover Foo =&gt; ( ba =&gt; 'ba' );
                   can_ok( 'Foo', qw/outer ba/ );
               };

               before_each be =&gt; sub {
                   qtakeover Foo =&gt; ( be =&gt; 'be' );
                   can_ok( 'Foo', qw/outer ba be/ );
               };

               tests the_check =&gt; sub {
                   qtakeover Foo =&gt; ( inner =&gt; 'inner' );

                   can_ok( 'Foo', qw/outer ba be inner/ );
               };

               ok( !Foo-&gt;can( 'outer' ), "No Leak" );
               ok( !Foo-&gt;can( 'ba' ), "No Leak" );
               ok( !Foo-&gt;can( 'be' ), "No Leak" );
               ok( !Foo-&gt;can( 'inner' ), "No Leak" );
           };

       <u>TAKEOVER</u> <u>AN</u> <u>EXISTING</u> <u>CLASS</u>

           require Some::Class;
           my $control = qtakeover 'Some::Class' =&gt; (
               # Override some methods:
               foo =&gt; sub { 'foo' },
               bar =&gt; sub { 'bar' },

               # For methods that return a simple value you don't actually need to
               # wrap them in a sub.
               baz =&gt; 'bat',
           );

           is( Some::Class-&gt;foo, 'foo' );
           is( Some::Class-&gt;bar, 'bar' );

           # Use the control object to make another override
           $control-&gt;override( foo =&gt; 'FOO' );
           is( Some::Class-&gt;foo, 'FOO' );

           # Original class is restored when $control falls out of scope.
           $control = undef;

       <u>MOCK</u> <u>A</u> <u>CLASS</u> <u>INSTEAD</u> <u>OF</u> <u>LOADING</u> <u>THE</u> <u>REAL</u> <u>ONE</u>

       This  will  prevent  the real class from loading if code tries to "require" or "use" it. However when the
       control object falls out of scope you will be able to load the real one again.

           my $control = qimplement 'Some::Class' =&gt; (
               my_method =&gt; sub { ... }
               simple    =&gt; 'foo',
           );

       <u>MOCK</u> <u>AN</u> <u>ANONYMOUS</u> <u>CLASS</u>

           my $control = qclass(
               -with_new =&gt; 1, # Make a constructor for us
               method =&gt; sub { ... },
               simple =&gt; 'foo',
           );

           my $obj = $control-&gt;package-&gt;new;

   <b>REUSABLE</b> <b>TEST</b> <b>LIBRARIES</b>
       This is a test library that verifies your test file uses strict in the first 3 lines.  You can also  pass
       "with_tests  =&gt;  [  'Some::Test::Lib'  ]"  as  an import argument to Fennec. This matters because you can
       subclass Fennec to always include this library.

       t/test.t

           use strict;
           use warnings;
           use Fennec;

           with_tests 'Some::Test::Lib';

           done_testing;

       lib/Some/Test/Lib.pm

           package Some::Test::Lib;
           use Test::Workflow;
           use Test::More;
           use Scalar::Util qw/blessed/;

           tests check_use_strict =&gt; sub {
               my $self  = shift;
               my $class = blessed $self;

               my $file = $class;
               $file =~ s{::}{/}g;
               $file .= '.pm';

               my $full = $INC{$file};
               ok( -e $full, "Found path and filename for $class" );
               open( my $fh, '&lt;', $full ) || die $!;
               my $found = 0;

               for ( 1 .. 3 ) {
                   $found = &lt;$fh&gt; =~ m/^\s*use strict;\s*$/;
                   last if $found;
               }
               close($fh);
               ok( $found, "'use strict;' is in the first 3 lines of the test file" );
           }

           1;

   <b>POST</b> <b>TESTS</b>
       You cannot put any tests under "done_testing()" Doing so will cause problems.  However you can put  tests
       IN done_testing.

           use strict;
           use warnings;

           use Fennec;

           my $foo = 1;

           is( $foo, 1, "foo is 1" );

           done_testing(
               sub {
                   is( $foo, 1, "foo is still 1" );
               }
           );

   <b>RSPEC</b>
       The  following test will produce output similar to the following. Keep in mind that the concurrent nature
       of Fennec means that the lines for each process may appear out of order  relative  to  lines  from  other
       processes. Lines for any given process will always be in the correct order though.

       Spacing  has  been  added,  and  process output has been grouped together, except for the main process to
       demonstrate that after_all really does come last.

           # PID          OUTPUT
           #---------------------------------------------
           7253 describe runs long before everything else
           7253 before_all runs first

           7254 case runs between before_all and before_each
           7254 before_each runs just before tests
           7254 tests run in the middle
           7254 after_each runs just after tests

           7255 before_each runs just before tests
           7255 This test inherits the before and after blocks from the parent describe.
           7255 after_each runs just after tests

           7253 after_all runs last.

       sample.t

           use strict;
           use warnings;

           use Fennec;

           describe order =&gt; sub {
               print "$$ describe runs long before everything else\n";

               before_all setup_a =&gt; sub {
                   print "$$ before_all runs first\n";
               };

               case a_case =&gt; sub {
                   print "$$ case runs between before_all and before_each\n";
               };

               before_each setup_b =&gt; sub {
                   print "$$ before_each runs just before tests\n";
               };

               tests a_test =&gt; sub {
                   print "$$ tests run in the middle\n";
               };

               after_each teardown_b =&gt; sub {
                   print "$$ after_each runs just after tests\n";
               };

               after_all teardown_a =&gt; sub {
                   print "$$ after_all runs last.\n";
               };

               describe nested =&gt; sub {
                   tests b_test =&gt; sub {
                       print "$$ This test inherits the before/after/case blocks from the parent describe.\n";
                   };
               };
           };

           done_testing;

</pre><h4><b>MANUAL</b></h4><pre>
       The manual can be found here: Fennec::Manual it is a sort of  Nexus  for  documentation,  including  this
       document.

</pre><h4><b>VIM</b> <b>INTEGRATION</b></h4><pre>
       Insert  this  into  your  .vimrc  file  to  bind the F8 key to running the test block directly under your
       cursor. You can be on any line of the test block (except in some cases the first or last line.

           function! RunFennecLine()
               let cur_line = line(".")
               exe "!FENNEC_TEST='" . cur_line . "' prove -v -I lib %"
           endfunction

           " Go to command mode, save the file, run the current test
           :map &lt;F8&gt; &lt;ESC&gt;:w&lt;cr&gt;:call RunFennecLine()&lt;cr&gt;
           :imap &lt;F8&gt; &lt;ESC&gt;:w&lt;cr&gt;:call RunFennecLine()&lt;cr&gt;

</pre><h4><b>RUNNING</b> <b>FENNEC</b> <b>TEST</b> <b>FILES</b> <b>IN</b> <b>PARALLEL</b></h4><pre>
       The best option is to use prove with the -j flag.

       <b>Note:</b> <b>The</b> <b>following</b> <b>is</b> <b>no</b> <b>longer</b> <b>a</b> <b>recommended</b> <b>practice,</b> <b>it</b> <b>is</b> <b>however</b> <b>still</b> <b>supported</b>

       You can also create a custom runner using a single .t file to run all your Fennec tests. This has caveats
       though, such as not knowing which test file had problems without checking the failure messages.

       This will find all *.ft and/or *.pm modules under the t/ directory. It will load and run any found. These
       will be run in parallel

       t/runner.t
           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
           use strict;
           use warnings;

           # Paths are optional, if none are specified it defaults to 't/'
           use Fennec::Finder( 't/' );

           # The next lines are optional, if you have no custom configuration to apply
           # you can jump right to 'done_testing'.

           # Get the runner (singleton)
           my $runner = Fennec::Finder-&gt;new;
           $runner-&gt;parallel( 3 );

           # You must call this.
           run();

</pre><h4><b>AUTHORS</b></h4><pre>
       Chad Granum <a href="mailto:exodist7@gmail.com">exodist7@gmail.com</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2013 Chad Granum

       Fennec is free software; Standard perl license (GPL and Artistic).

       Fennec is distributed in the hope that it will be useful, but WITHOUT  ANY  WARRANTY;  without  even  the
       implied  warranty  of  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR PURPOSE. See the license for more
       details.

perl v5.36.0                                       2022-12-02                                        <u><a href="../man3pm/Fennec.3pm.html">Fennec</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>