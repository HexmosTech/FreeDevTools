<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scriptalicious - Make scripts more delicious to SysAdmins</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libscriptalicious-perl">libscriptalicious-perl_1.17-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Scriptalicious - Make scripts more delicious to SysAdmins

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Scriptalicious
             -progname =&gt; "pu";

        our $VERSION = "1.00";

        my $url = ".";
        getopt getconf("u|url" =&gt; \$url);

        run("echo", "doing something with $url");
        my $output = capture("svn", "info", $url);

        __END__

        =head1 NAME

        pu - an uncarved block of wood

        =head1 SYNOPSIS

        pu [options] arguments

        =head1 DESCRIPTION

        This script's function is to be a blank example that many
        great and simple scripts may be built upon.

        Remember, you cannot carve rotten wood.

        =head1 COMMAND LINE OPTIONS

        =over

        =item B&lt;-h, --help&gt;

        Display a program usage screen and exit.

        =item B&lt;-V, --version&gt;

        Display program version and exit.

        =item B&lt;-v, --verbose&gt;

        Verbose command execution, displaying things like the
        commands run, their output, etc.

        =item B&lt;-q, --quiet&gt;

        Suppress all normal program output; only display errors and
        warnings.

        =item B&lt;-d, --debug&gt;

        Display output to help someone debug this script, not the
        process going on.

        =back

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module helps you write scripts that conform to best common practices, quickly.  Just include the
       above as a template, and your script will accept all of the options that are included in the manual page,
       as well as summarising them when you use the "-h" option.

       (Unfortunately, it is not possible to have a `use' dependency automatically add structure to your POD
       yet, so you have to include the above manually.  If you want your help message and Perldoc to be
       meaningful, that is.)

       Shortcuts are provided to help you abort or die with various error conditions; all of which print the
       name of the program running (taken from $0 if not passed).  The motive for this is that "small" scripts
       tend to just get written and forgotten; so, when you have a larger system that is built out of lots of
       these pieces it is sometimes guesswork figuring out which script a printed message comes from!

       For instance, if your program is called with invalid arguments, you may simply call "abort" with a one-
       line message saying what the particular problem was.  When the script is run, it will invite the person
       running the script to try to use the "--help" option, which gives them a summary and in turn invites them
       to read the Perldoc.  So, it reads well in the source;

         @ARGV and abort "unexpected arguments: @ARGV";
         $file or abort "no filename supplied";

       And in the output;

         somescript: no filename supplied!
         Try `somescript --help' for a summary of options

       On the other hand, if you call "barf", then it is considered to be a hard run-time failure, and the
       invitation to read the "--help" page to get usage not given.  Also, the messages are much tidier than you
       get with "die" et al.

         open FOO, "&lt;$file" or barf "failed to open $file; $!";

       Which will print:

         somescript: failed to open somefile; Permission denied

       Scriptalicious has no <u>hard</u> dependencies; all the methods, save reading passwords from the user, will work
       in the absence of extra installed modules on all versions of Perl from 5.6.0 onwards.

       To avoid unnecessary explicit importing of symbols, the following symbols and functions are exported into
       the caller's namespace:

       $VERBOSE
           Set  to  0  by  default, and 1 if "-v" or "--verbose" was found during the call to "getopt()".  Extra
           "-v"'s or "--debug" will push this variable higher.  If "-q" or "--quiet" is specified, this will  be
           less than one.

       $PROGNAME
           It  is recommended that you only ever read this variable, and pass it in via the import.  This is not
           automatically extracted from the POD for performance reasons.

       $CONFIG
           Name of the configuration file.  Set before a call to "getconf", or  read  afterwards  to  see  if  a
           config file was used.  New in Scriptalicious 1.16

       <b>getopt(@getopt_args)</b>
           Fetch  arguments via "Getopt::Long::GetOptions".  The "bundling" option is enabled by default - which
           differs from the standard configuration of <b>Getopt::Long</b>.  To alter  the  configuration,  simply  call
           "Getopt::Long::config".  See Getopt::Long for more information.

       <b>getopt_lenient(@getopt_args)</b>
           Just like "getopt()", but doesn't cause a fatal error if there are any unknown options.

       <b>getconf(@getopt_args)</b>
           Fetches configuration, takes arguments in the same form as <b>getopt()</b>..

           The   configuration   file   is   expected   to  be  in  <u><a href="file:~/.PROGNAMErc">~/.PROGNAMErc</a></u>,  <u>/etc/perl/PROGNAME.conf</u>,  or
           <u>/etc/PROGNAME.conf</u>.  Only the first found file is read, and unknown options are ignored for the  time
           being.

           The file is expected to be in YAML format, with the top entity being a hash, and the keys of the hash
           being  the  same  as  specifying  options  on  the  command line.  Using YAML as a format allows some
           simplificiations to getopt-style processing - "=s%" and "=s@" style options are expected to be  in  a
           real hash or list format in the config file, and boolean options must be set to "true" or "false" (or
           some common equivalents).

           Returns  the  configuration  file as <b>Load()</b>'ed by YAML in scalar context, or the argument list it was
           passed in list context.

           For example, this minimal script (missing the documentation, but hey at least it's a start);

             getopt getconf
                 ( "something|s" =&gt; \$foo,
                   "invertable|I!" =&gt; \$invertable,
                   "integer|i=i" =&gt; \$bar,
                   "string|s=s" =&gt; \$cheese,
                   "list|l=s@" =&gt; \@list,
                   "hash|H=s%" =&gt; \%hash, );

           Will accept the following invocation styles;

             foo.pl --help
             foo.pl --version
             foo.pl --verbose
             foo.pl --debug
             foo.pl --quiet

             foo.pl --something
             foo.pl --invertable
             foo.pl --no-invertable    &lt;=== FORM DIFFERS IN CONFIG FILE
             foo.pl --integer=7
             foo.pl --string=anything
             foo.pl --list one --list two --list three
             foo.pl --hash foo=bar --hash baz=cheese

           Equivalent config files:

             something: 1

             invertable: on

             invertable: off

             integer: 7

             string: anything

             list:
               - one
               - two
               - three

             list: [ one, two, three ]

             hash:
               foo: bar
               baz: cheese

           Note that more complex and possibly arcane usages of Getopt::Long features may not work with  getconf
           (patches welcome).

           This  can  be handy for things like database connection strings; all you have to do is make an option
           for them, and then the user of the script, or a SysAdmin can set up their own  config  file  for  the
           script to automatically set the options.

       <b>getconf_f($filename,</b> <b>@getopt_args)</b>
           As <b>getconf()</b>, but specify a filename.

       <b>say</b> <b>"something"</b>
           Prints a message to standard output, unless quiet mode ("-q" or "--quiet") was specified.  For normal
           program messages.

       <b>mutter</b> <b>"progress"</b>
           Prints  a  message to standard output, if verbose mode ("-v") or debug mode ("-d") is enabled (ie, if
           "$VERBOSE &gt; 0").  For messages designed to help a <u>user</u> <u>of</u> <u>the</u> <u>script</u> to see  more  information  about
           what is going on.

       <b>whisper</b> <b>"detail"</b>
           Prints a message to standard output, if debug mode ("-d") is enabled or multiple verbose options were
           passed  (ie,  if "$VERBOSE &gt; 1").  For messages designed to help a <u>person</u> <u>debugging</u> <u>the</u> <u>script</u> to see
           more information about what is going on internally to the script.

       <b>abort</b> <b>"won't</b> <b>go</b> <b>to</b> <b>sea</b> <b>in</b> <b>a</b> <b>storm"</b>
           Prints a short program usage message (extracted from the POD synopsis) and exits with an error code.

       <b>moan</b> <b>"weather</b> <b>is</b> <b>miserable"</b>
           Prints a warning to standard error.  It is preceded with the text "warning:".  The program  does  not
           exit.

       <b>protest</b> <b>"don't</b> <b>know</b> <b>the</b> <b>weather</b> <b>report"</b>
           Prints  an error message to standard error.  It is preceded with the text "error:".  The program does
           not exit.

       <b>barf</b> <b>"hit</b> <b>an</b> <b>iceberg"</b>
           Prints a warning to standard error.  It is preceded with the text "warning:".  The program  does  not
           exit.

       <b>run("command",</b> <b>"arg1",</b> <b>"arg2")</b>
           Runs  a  command  or  closure,  barf's  with a relevant error message if there is a problem.  Program
           output is suppressed unless running in verbose mode.

           "run()" and the three alternatives listed below may perform arbitrary filehandle  redirection  before
           executing the command.  This can be a very convenient way to do shell-like filehandle plumbing.

           For example;

             run( -in =&gt; sub { print "Hello, world!\n" },
                  -out =&gt; "/tmp/outfile",
                  -out2 =&gt; "/dev/null",
                  @command );

           This  will  connect  the child process' standard input ("-in") to a closure that is printing ""Hello,
           world!\n"".  The output from the closure will appear on standard input of the run command.  Note that
           the closure is run in a sub-process and so will not be able to set variables in the calling program.

           It will also connect the program's standard output ("-out") to "/tmp/outfile", and its standard error
           (filehandle 2) to "/dev/null" (the traditional way of junking error output).

           If you wanted to connect two filehandles to the same place,  you  could  pass  in  "GLOB"  references
           instead;

             run( -out =&gt; \*MYOUT,
                  -out2 =&gt; \*MYOUT,
                  @command );

           Any  filehandle  can  be  opened  in  any  mode;  "-in" merely defaults to meaning "-in0", and "-out"
           defaults to meaning "-out1".  There is no "-err"; use "-out2".  "-rw" exists (defaulting to  "-rw0"),
           but is probably of limited use.

           Here is an example of using "prompt_passwd()" to hijack "gpg"'s password grabbing;

             my $password = prompt_passwd("Encryption password: ");
             my $encrypted = run( -in4 =&gt; sub { print "$password\n" },
                                  "gpg", "--passphrase-fd", "4", "-c", $file )

       <b>run_err("command",</b> <b>"arg2",</b> <b>"arg1")</b>
           Same  as  run,  but  returns  the  error code rather than assuming that the command will successfully
           complete.  Again, output it suppressed.

       <b>capture("command",</b> <b>"1gra",</b> <b>"2gra")</b>
           runs a command, capturing its output, barfs if there is a problem.  Returns the output of the command
           as a list or a scalar.

       <b>capture_err("command",</b> <b>"foo")</b>
           Works as <b>capture</b>, but the first returned item is the error code of the command ($?) rather  than  the
           first line of its output.  Also, it only ever returns the output as a list.

           Usage:

              my ($rc, @output) = capture_err("somecommand", @args);

       <b>hush_exec()</b>
       <b>unhush_exec()</b>
           "hush_exec"  is  used  to  indicate that the programs you are running are only of interest to someone
           debugging the script.  So, the messages showing commands run and giving execution timings will not be
           printed without "-vv" (double verbose) or "-d" (debug, which is the same thing).

       <b>start_timer()</b>
       <b>show_delta()</b>
       <b>show_elapsed()</b>
           These three little functions are for printing run times in your scripts.   Times  are  displayed  for
           running external programs with verbose mode normally, but this will let you display running times for
           your main program easily.

       <b>sci_unit($num,</b> <b>[$unit,</b> <b>$precision])</b>
           Returns  a  number, scaled using normal scientific prefixes (from atto to exa).  Optionally specify a
           precision which is passed to <b>sprintf()</b> (see "sprintf" in perldoc).  The default is three  significant
           figures.

           From  Scriptalicious  1.08,  the  "u"  character  is  used in place of the Greek "mu" due to encoding
           compatibility issues.

       <b>time_unit($num,</b> <b>[$precision])</b>
           Converts a floating point number of seconds to a human-readable time,  the  precision  specifies  the
           number of significant decimal digits, which is used to compute a "quanta" for the value given, values
           below which are not displayed.  $precision defaults to 4.

           examples:

            time_unit(10.1) =&gt; "10.10s"
            <a href="../man1/time_unit.1.html">time_unit</a>(1) =&gt; "1.000s"
            time_unit(0.1) =&gt; "100ms"
            time_unit(86401,2) =&gt; "1d 0h"
            time_unit(86401,3) =&gt; "1d 0h"
            <a href="../man86401/time_unit.86401.html">time_unit</a>(86401) =&gt; "1d 0h:0m"
            time_unit(86400+3600/2) =&gt; "1d 0h:30m"
            time_unit(86401,5) =&gt; "1d 0h:0m:1s"
            time_unit(7*86400) =&gt; "1w0d 0h"
            time_unit(-0.0002) =&gt; "-200us"

       <b>prompt_regex($prompt,</b> <b>qr/(.*)/)</b>
           Prompts  for  something,  using  the  prompt  "$prompt",  matching  the  entered value (sans trailing
           linefeed) against the passed regex.

           Note that this differs from the previous behaviour of prompt_regex, which took a sub.

       <b>prompt_sub($prompt,</b> <b>sub</b> <b>{</b> <b>/(.*)/</b> <b>&amp;&amp;</b> <b>$1</b> <b>})</b>
           Prompts for something, using the prompt "$prompt", feeding the  sub  with  the  entered  value  (sans
           trailing linefeed), to use a default, the passed sub should simply return it with empty input.

       <b>prompt_passwd([$prompt])</b>
           Same as "prompt_regex", but turns off echo.  $prompt defaults to ""Password: "" for this function.

       <b>prompt_string([$prompt])</b>
           Prompt for a string.

       <b>prompt_int([$prompt])</b>
           get an integer

       <b>prompt_for([</b> <b>[$type</b> <b>=</b>] $what])&gt;
           Prompts for a value for $what.  This constructs a prompt saying, eg ""Enter value for $what"".  Calls
           the equivalent "prompt_foo()" method.

       <b>prompt_yn([$prompt])</b>
           prompts for yes or no, presuming neither

       <b>prompt_Yn([$prompt])</b>
       <b>prompt_yN([$prompt])</b>
           prompts for yes or no, presuming yes and no, respectively.

           You can also spell these as "prompt_nY" and "prompt_Ny".

       <b>anydump($ref)</b>
           Dump $ref via "YAML", falling back to "Data::Dumper" if YAML fails to load (or dies during the dump).
           Returns a string.

       <b>tsay($template,</b> <b>$vars)</b>
           Prints the template $template with $vars.  $template may be included at the end of the file as a data
           section, for instance:

            use Scriptalicious;

            tsay hello =&gt; { name =&gt; "Bernie" };

            __END__

            __hello__
            Hello, [% name %]
            [% INCLUDE yomomma %]
            __yomomma__
            Yo momma's so fat your family portrait has stretchmarks.

           This will print:

            Hello, Bernie
            Yo momma's so fat your family portrait has stretchmarks.

           Note  that  the script goes to lengths to make sure that the information is always printed whether or
           not Template Toolkit is installed.  This gets pretty verbose, but at least solves  the  "argh!   that
           script failed, but I don't know why because it needed this huge dependency to tell me" problem.

           For example, the above would be printed as:

            scriptname:

       <b>foo()</b>
           If  you've got a short little Perl function that implements something useful for people writing Shell
           scripts in Perl, then please feel free to contribute it.  And if it really is scriptalicious, you can
           bet your momma on it getting into this module!

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Simon Cozen's Getopt::Auto module does a very similar thing to this module, in  a  quite  different  way.
       However,  it  is  missing  "say", "run", etc.  So you'll need to use some other module for those.  But it
       does have some other features you might like and is probably engineered better.

       There's a template script at "Documentation and help  texts"  in  Getopt::Long  that  contains  a  script
       template  that  demonstrates  what is necessary to get the basic man page / usage things working with the
       traditional Getopt::Long and Pod::Usage combination.

       Getopt::Plus is a swiss army chainsaw of Getopt::* style modules, contrasting to this  module's  approach
       of elegant simplicity (quiet in the cheap seats!).

       Getopt::EUCLID is Damian Conway's take on this.

       Finally,   if   you   don't   mind  the  dependencies  of  Moose  (or  Mouse),  then  MooseX::Getopt  and
       MooseX::SimpleConfig are much more elegant approaches to getopt  handling  and  configuration  than  this
       module.

       If  you  have solved this problem in a new and interesting way, or even rehashed it in an old, boring and
       inelegant way and want your module to be listed here, please contact the

</pre><h4><b>AUTHOR</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Sam Vilain, <a href="mailto:samv@cpan.org">samv@cpan.org</a>

       Copyright 2005-2008, Sam Vilain.  All rights reserved.  This program is free software;  you  can  use  it
       and/or  distribute  it under the same terms as Perl itself; either the latest stable release of Perl when
       the module was written, or any subsequent stable release.

       Please note that this applies retrospectively to all Scriptalicious releases; apologies for the  lack  of
       an explicit license.

perl v5.36.0                                       2022-10-16                                <u><a href="../man3pm/Scriptalicious.3pm.html">Scriptalicious</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>