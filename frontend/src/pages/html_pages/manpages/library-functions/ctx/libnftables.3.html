<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libnftables - nftables frontend library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnftables1">libnftables1_1.1.3-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libnftables - nftables frontend library

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;nftables/libnftables.h&gt;</b>

       <b>struct</b> <b>nft_ctx</b> <b>*nft_ctx_new(uint32_t</b> <u>flags</u><b>);</b>
       <b>void</b> <b>nft_ctx_free(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>

       <b>bool</b> <b>nft_ctx_get_dry_run(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>
       <b>void</b> <b>nft_ctx_set_dry_run(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>,</b> <b>bool</b> <u>dry</u><b>);</b>

       <b>unsigned</b> <b>int</b> <b>nft_ctx_input_get_flags(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>
       <b>unsigned</b> <b>int</b> <b>nft_ctx_input_set_flags(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>,</b> <b>unsigned</b> <b>int</b> <u>flags</u><b>);</b>

       <b>unsigned</b> <b>int</b> <b>nft_ctx_output_get_flags(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>
       <b>void</b> <b>nft_ctx_output_set_flags(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>,</b> <b>unsigned</b> <b>int</b> <u>flags</u><b>);</b>

       <b>unsigned</b> <b>int</b> <b>nft_ctx_output_get_debug(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>
       <b>void</b> <b>nft_ctx_output_set_debug(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>,</b> <b>unsigned</b> <b>int</b> <u>mask</u><b>);</b>

       <b>FILE</b> <b>*nft_ctx_set_output(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>,</b> <b>FILE</b> <u>*fp</u><b>);</b>
       <b>int</b> <b>nft_ctx_buffer_output(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>
       <b>int</b> <b>nft_ctx_unbuffer_output(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>
       <b>const</b> <b>char</b> <b>*nft_ctx_get_output_buffer(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>

       <b>FILE</b> <b>*nft_ctx_set_error(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>,</b> <b>FILE</b> <u>*fp</u><b>);</b>
       <b>int</b> <b>nft_ctx_buffer_error(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>
       <b>int</b> <b>nft_ctx_unbuffer_error(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>
       <b>const</b> <b>char</b> <b>*nft_ctx_get_error_buffer(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>

       <b>int</b> <b>nft_ctx_add_include_path(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>,</b> <b>const</b> <b>char</b> <u>*path</u><b>);</b>
       <b>void</b> <b>nft_ctx_clear_include_paths(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>);</b>

       <b>int</b> <b>nft_ctx_add_var(struct</b> <b>nft_ctx</b> <u>*ctx</u><b>,</b> <b>const</b> <b>char</b> <u>*var</u><b>);</b>
       <b>void</b> <b>nft_ctx_clear_vars(struct</b> <b>nft_ctx</b> <u>\*ctx</u>);

       int nft_run_cmd_from_buffer(struct nft_ctx* <u>*nft</u><b>,</b> <b>const</b> <b>char</b> <u>*buf</u><b>);</b>
       <b>int</b> <b>nft_run_cmd_from_filename(struct</b> <b>nft_ctx</b> <u>*nft</u><b>,</b>
                                     <b>const</b> <b>char</b> <u>*filename</u><b>);</b>

       Link with <u>-lnftables</u>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This library was designed with nftables integration into applications in mind. Its API is therefore kept
       as simple as possible, which somewhat limits its flexibility. Due to support for JSON markup of input and
       output though, convenience in constructing and parsing of input and output data may be achieved by using
       a third-party library such as <b>libjansson</b>.

       At the very basic level, one has to allocate a new object of type <b>struct</b> <b>nft_ctx</b> using <b>nft_ctx_new</b>()
       function, then pass commands via <b>nft_run_cmd_from_buffer</b>() or <b>nft_run_cmd_from_filename</b>() functions. By
       default, any output is written to <b>stdout</b> (or <b>stderr</b> for error messages). These file pointers may be
       changed using <b>nft_ctx_set_output</b>() and <b>nft_ctx_set_error</b>() functions. On top of that, it is possible to
       have any output buffered by the library for later retrieval as a static buffer. See
       <b>nft_ctx_buffer_output</b>() and <b>nft_ctx_buffer_error</b>() functions for details.

   <b>nft_ctx_new()</b> <b>and</b> <b>nft_ctx_free()</b>
       These functions aid in nft context management. In order to make use of the library, at least one context
       object has to be allocated. The context holds temporary data such as caches, library configuration and
       (if enabled) output and error buffers.

       The <b>nft_ctx_new</b>() function allocates and returns a new context object. The parameter <u>flags</u> is unused at
       this point and should be set to zero. For convenience, the macro <b>NFT_CTX_DEFAULT</b> is defined to that
       value.

       The <b>nft_ctx_free</b>() function frees the context object pointed to by <u>ctx</u>, including any caches or buffers
       it may hold.

   <b>nft_ctx_get_dry_run()</b> <b>and</b> <b>nft_ctx_set_dry_run()</b>
       Dry-run setting controls whether ruleset changes are actually committed on kernel side or not. It allows
       one to check whether a given operation would succeed without making actual changes to the ruleset. The
       default setting is <b>false</b>.

       The <b>nft_ctx_get_dry_run</b>() function returns the dry-run setting’s value contained in <u>ctx</u>.

       The <b>nft_ctx_set_dry_run</b>() function sets the dry-run setting in <u>ctx</u> to the value of <u>dry</u>.

   <b>nft_ctx_input_get_flags()</b> <b>and</b> <b>nft_ctx_input_set_flags()</b>
       The flags setting controls the input format.

           enum {
                   NFT_CTX_INPUT_NO_DNS = (1 &lt;&lt; 0),
                   NFT_CTX_INPUT_JSON   = (1 &lt;&lt; 1),
           };

       NFT_CTX_INPUT_NO_DNS
           Avoid resolving IP addresses with blocking getaddrinfo(). In that case, only plain IP addresses are
           accepted.

       NFT_CTX_INPUT_JSON: When parsing the input, first try to interpret the input as JSON before falling back
       to the nftables format. This behavior is implied when setting the NFT_CTX_OUTPUT_JSON flag.

       The <b>nft_ctx_input_get_flags</b>() function returns the input flags setting’s value in <u>ctx</u>.

       The <b>nft_ctx_input_set_flags</b>() function sets the input flags setting in <u>ctx</u> to the value of <u>val</u> and
       returns the previous flags.

   <b>nft_ctx_output_get_flags()</b> <b>and</b> <b>nft_ctx_output_set_flags()</b>
       The flags setting controls the output format.

           enum {
                   NFT_CTX_OUTPUT_REVERSEDNS     = (1 &lt;&lt; 0),
                   NFT_CTX_OUTPUT_SERVICE        = (1 &lt;&lt; 1),
                   NFT_CTX_OUTPUT_STATELESS      = (1 &lt;&lt; 2),
                   NFT_CTX_OUTPUT_HANDLE         = (1 &lt;&lt; 3),
                   NFT_CTX_OUTPUT_JSON           = (1 &lt;&lt; 4),
                   NFT_CTX_OUTPUT_ECHO           = (1 &lt;&lt; 5),
                   NFT_CTX_OUTPUT_GUID           = (1 &lt;&lt; 6),
                   NFT_CTX_OUTPUT_NUMERIC_PROTO  = (1 &lt;&lt; 7),
                   NFT_CTX_OUTPUT_NUMERIC_PRIO   = (1 &lt;&lt; 8),
                   NFT_CTX_OUTPUT_NUMERIC_SYMBOL = (1 &lt;&lt; 9),
                   NFT_CTX_OUTPUT_NUMERIC_TIME   = (1 &lt;&lt; 10),
                   NFT_CTX_OUTPUT_NUMERIC_ALL    = (NFT_CTX_OUTPUT_NUMERIC_PROTO |
                                                    NFT_CTX_OUTPUT_NUMERIC_PRIO  |
                                                    NFT_CTX_OUTPUT_NUMERIC_SYMBOL |
                                                    NFT_CTX_OUTPUT_NUMERIC_TIME),
                   NFT_CTX_OUTPUT_TERSE          = (1 &lt;&lt; 11),
           };

       NFT_CTX_OUTPUT_REVERSEDNS
           Reverse DNS lookups are performed for IP addresses when printing. Note that this may add significant
           delay to <b>list</b> commands depending on DNS resolver speed.

       NFT_CTX_OUTPUT_SERVICE
           Print port numbers as services as described in the <a href="file:/etc/services">/etc/services</a> file.

       NFT_CTX_OUTPUT_STATELESS
           If stateless output has been requested, then stateful data is not printed. Stateful data refers to
           those objects that carry run-time data, e.g. the <b>counter</b> statement holds packet and byte counter
           values, making it stateful.

       NFT_CTX_OUTPUT_HANDLE
           Upon insertion into the ruleset, some elements are assigned a unique handle for identification
           purposes. For example, when deleting a table or chain, it may be identified either by name or handle.
           Rules on the other hand must be deleted by handle, because there is no other way to uniquely identify
           them. This flag makes ruleset listings include handle values.

       NFT_CTX_OUTPUT_JSON
           If enabled at compile-time, libnftables accepts input in JSON format and is able to print output in
           JSON format as well. See <b><a href="../man5/libnftables-json.5.html">libnftables-json</a></b>(5) for a description of the supported schema. This flag
           enables JSON output format. If the flag is set, the input will first be tried as JSON format, before
           falling back to nftables format. This flag implies NFT_CTX_INPUT_JSON.

       NFT_CTX_OUTPUT_ECHO
           The echo setting makes libnftables print the changes once they are committed to the kernel, just like
           a running instance of <b>nft</b> <b>monitor</b> would. Amongst other things, this allows one to retrieve an added
           rule’s handle atomically.

       NFT_CTX_OUTPUT_GUID
           Display UID and GID as described in the <a href="file:/etc/passwd">/etc/passwd</a> and <a href="file:/etc/group">/etc/group</a> files.

       NFT_CTX_OUTPUT_NUMERIC_PROTO
           Display layer 4 protocol numerically.

       NFT_CTX_OUTPUT_NUMERIC_PRIO
           Display base chain priority numerically.

       NFT_CTX_OUTPUT_NUMERIC_SYMBOL
           Display expression datatype as numeric value.

       NFT_CTX_OUTPUT_NUMERIC_TIME
           Display time, day and hour values in numeric format.

       NFT_CTX_OUTPUT_NUMERIC_ALL
           Display all numerically.

       NFT_CTX_OUTPUT_TERSE
           If terse output has been requested, then the contents of sets are not printed.

       The <b>nft_ctx_output_get_flags</b>() function returns the output flags setting’s value in <u>ctx</u>.

       The <b>nft_ctx_output_set_flags</b>() function sets the output flags setting in <u>ctx</u> to the value of <u>val</u>.

   <b>nft_ctx_output_get_debug()</b> <b>and</b> <b>nft_ctx_output_set_debug()</b>
       Libnftables supports separate debugging of different parts of its internals. To facilitate this,
       debugging output is controlled via a bit mask. The bits are defined as such:

           enum nft_debug_level {
                   NFT_DEBUG_SCANNER               = 0x1,
                   NFT_DEBUG_PARSER                = 0x2,
                   NFT_DEBUG_EVALUATION            = 0x4,
                   NFT_DEBUG_NETLINK               = 0x8,
                   NFT_DEBUG_MNL                   = 0x10,
                   NFT_DEBUG_PROTO_CTX             = 0x20,
                   NFT_DEBUG_SEGTREE               = 0x40,
           };

       NFT_DEBUG_SCANNER
           Print LEX debug output.

       NFT_DEBUG_PARSER
           Print YACC debug output.

       NFT_DEBUG_EVALUATION
           Print debug information about evaluation phase.

       NFT_DEBUG_NETLINK
           Print netlink debug output.

       NFT_DEBUG_MNL
           Print libmnl debug output.

       NFT_DEBUG_PROTO_CTX
           Print protocol context debug output.

       NFT_DEBUG_SEGTREE
           Print segtree (i.e. interval sets) debug output.

       The <b>nft_ctx_output_get_debug</b>() function returns the debug output setting’s value in <u>ctx</u>.

       The <b>nft_ctx_output_set_debug</b>() function sets the debug output setting in <u>ctx</u> to the value of <u>mask</u>.

   <b>Controlling</b> <b>library</b> <b>standard</b> <b>and</b> <b>error</b> <b>output</b>
       By default, any output from the library (e.g., after a <b>list</b> command) is written to <u>stdout</u> and any error
       messages are written to <u>stderr</u>. To give applications control over them, there are functions to assign
       custom file pointers as well as having the library buffer what would be written for later retrieval in a
       static buffer. This buffer is guaranteed to be null-terminated and must not be freed. Note that the
       retrieval functions rewind the buffer position indicator. Further library output will probably overwrite
       the buffer content and potentially render it invalid (due to reallocation).

       The <b>nft_ctx_set_output</b>() and <b>nft_ctx_set_error</b>() functions set the output or error file pointer in <u>ctx</u> to
       the value of <u>fp</u>. They return the previous value to aid in temporary file pointer overrides. On error,
       these functions return NULL. This happens only if <u>fp</u> is NULL or invalid (tested using <b>ferror</b>() function).

       The <b>nft_ctx_buffer_output</b>() and <b>nft_ctx_buffer_error</b>() functions enable library standard or error output
       buffering. The functions return zero on success, non-zero otherwise. This may happen if the internal call
       to <b>fopencookie</b>() failed.

       The <b>nft_ctx_unbuffer_output</b>() and <b>nft_ctx_unbuffer_error</b>() functions disable library standard or error
       output buffering. On failure, the functions return non-zero which may only happen if buffering was not
       enabled at the time the function was called.

       The <b>nft_ctx_get_output_buffer</b>() and <b>nft_ctx_get_error_buffer</b>() functions return a pointer to the buffered
       output (which may be empty).

   <b>nft_ctx_add_include_path()</b> <b>and</b> <b>nft_ctx_clear_include_path()</b>
       The <b>include</b> command in nftables rulesets allows one to outsource parts of the ruleset into a different
       file. The include path defines where these files are searched for. Libnftables allows one to have a list
       of those paths which are searched in order. The default include path list contains a single compile-time
       defined entry (typically <u><a href="file:/etc/">/etc/</a></u>).

       The <b>nft_ctx_add_include_path</b>() function extends the list of include paths in <u>ctx</u> by the one given in
       <u>path</u>. The function returns zero on success or non-zero if memory allocation failed.

       The <b>nft_ctx_clear_include_paths</b>() function removes all include paths, even the built-in default one.

   <b>nft_ctx_add_var()</b> <b>and</b> <b>nft_ctx_clear_vars()</b>
       The <b>define</b> command in nftables ruleset allows one to define variables.

       The <b>nft_ctx_add_var</b>() function extends the list of variables in <u>ctx</u>. The variable must be given in the
       format <u>key=value</u>. The function returns zero on success or non-zero if the variable is malformed.

       The <b>nft_ctx_clear_vars</b>() function removes all variables.

   <b>nft_run_cmd_from_buffer()</b> <b>and</b> <b>nft_run_cmd_from_filename()</b>
       These functions perform the actual work of parsing user input into nftables commands and executing them.

       The <b>nft_run_cmd_from_buffer</b>() function passes the command(s) contained in <u>buf</u> (which must be
       null-terminated) to the library, respecting settings and state in <u>nft</u>.

       The <b>nft_run_cmd_from_filename</b>() function passes the content of <u>filename</u> to the library, respecting
       settings and state in <u>nft</u>.

       Both functions return zero on success. A non-zero return code indicates an error while parsing or
       executing the command. This event should be accompanied by an error message written to library error
       output.

</pre><h4><b>EXAMPLE</b></h4><pre>
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
           #include &lt;nftables/libnftables.h&gt;

           int main(void)
           {
                   char *list_cmd = "list ruleset";
                   struct nft_ctx *nft;
                   const char *output, *p;
                   char buf[256];
                   int rc = 0;

                   nft = nft_ctx_new(NFT_CTX_DEFAULT);
                   if (!nft)
                           return 1;

                   while (1) {
                           if (nft_ctx_buffer_output(nft) ||
                               nft_run_cmd_from_buffer(nft, list_cmd)) {
                                   rc = 1;
                                   break;
                           }
                           output = nft_ctx_get_output_buffer(nft);
                           if (strlen(output)) {
                                   printf("\nThis is the current ruleset:\n| ");
                                   for (p = output; *(p + 1); p++) {
                                           if (*p == '\n')
                                                   printf("\n| ");
                                           else
                                                   putchar(*p);
                                   }
                                   putchar('\n');
                           } else {
                                   printf("\nCurrent ruleset is empty.\n");
                           }
                           nft_ctx_unbuffer_output(nft);

                           printf("\nEnter command ('q' to quit): ");
                           fflush(stdout);
                           fgets(buf, 256, stdin);
                           if (strlen(buf))
                                   buf[strlen(buf) - 1] = '\0';

                           if (buf[0] == 'q' &amp;&amp; buf[1] == '\0')
                                   break;

                           if (nft_run_cmd_from_buffer(nft, buf)) {
                                   rc = 1;
                                   break;
                           }
                   }

                   nft_ctx_free(nft);
                   return rc;
           }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man5/libnftables-json.5.html">libnftables-json</a></b>(5), <b><a href="../man8/nft.8.html">nft</a></b>(8)

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>Phil</b> <b>Sutter</b> &lt;<a href="mailto:phil@nwl.cc">phil@nwl.cc</a>&gt;
           Author.

                                                   04/22/2025                                     <u><a href="../man3/LIBNFTABLES.3.html">LIBNFTABLES</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>