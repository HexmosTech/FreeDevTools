<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POE::Component::DBIAgent - POE Component for running asynchronous DBI calls.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpoe-component-dbiagent-perl">libpoe-component-dbiagent-perl_0.26-3.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       POE::Component::DBIAgent - POE Component for running asynchronous DBI calls.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        sub _start {
           my ($self, $kernel, $heap) = @_[OBJECT, KERNEL, HEAP];

           $heap-&gt;{helper} = POE::Component::DBIAgent-&gt;new( DSN =&gt; [$dsn,
                                                      $username,
                                                      $password
                                                     ],
                                              Queries =&gt; $self-&gt;make_queries,
                                              Count =&gt; 3,
                                              Debug =&gt; 1,
                                            );

               # Queries takes a hashref of the form:
               # { query_name =&gt; 'select blah from table where x = ?',
               #   other_query =&gt; 'select blah_blah from big_view',
               #   etc.
               # }

           $heap-&gt;{helper}-&gt;query(query_name =&gt;
                                  { cookie =&gt; 'starting_query' },
                                  session =&gt; 'get_row_from_dbiagent');

        }

        sub get_row_from_dbiagent {
           my ($kernel, $self, $heap, $row, $cookie) = @_[KERNEL, OBJECT, HEAP, ARG0, ARG1];
           if ($row ne 'EOF') {

        # {{{ PROCESS A ROW

               #row is a listref of columns

        # }}} PROCESS A ROW

           } else {

        # {{{ NO MORE ROWS

               #cleanup code here

        # }}} NO MORE ROWS

           }

        }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       DBIAgent is your answer to non-blocking DBI in POE.

       It fires off a configurable number child processes (defaults to 3) and feeds database queries to it via
       two-way pipe (or sockets ... however POE::Component::Wheel::Run is able to manage it).  The primary
       method is "query".

   <b>Usage</b>
       After initializing a DBIAgent and storing it in a session's heap, one executes a "query" (or
       "query_slow") with the query name, destination session (name or id) and destination state (as well as any
       query parameters, optionally) as arguments.  As each row of data comes back from the query, the
       destination state (in the destination session) is invoked with that row of data in its $_[ARG0] slot.
       When there are no more rows to return, the data in $_[ARG0] is the string 'EOF'.

       Not EVERY query should run through the DBIAgent.  If you need to run a short lookup from within a state,
       sometimes it can be a hassle to have to define a whole separate state to receive its value, and resume
       processing from there..  The determining factor, of course, is how long your query will take to execute.
       If you are trying to retrieve one row from a properly indexed table, use "$dbh-&gt;selectrow_array()".  If
       there's a join involved, or multiple rows, or a view, you probably want to use DBIAgent.  If it's a
       longish query and startup costs (time) don't matter to you, go ahead and do it inline.. but remember the
       whole of your program suspends waiting for the result.  If startup costs DO matter, use DBIAgent.

   <b>Return</b> <b>Values</b>
       The destination state in the destination session (specified in the call to "query()") will receive the
       return values from the query in its $_[ARG0] parameter.  DBIAgent invokes DBI's "fetch" method
       internally, so the value will be a reference to an array.  If your query returns multiple rows, then your
       state will be invoked multiple times, once per row.  <b>ADDITIONALLY</b>, your state will be called one time
       with $_[ARG0] containing the string 'EOF'. 'EOF' is returned <u>even</u> <u>if</u> <u>the</u> <u>query</u> <u>doesn't</u> <u>return</u> <u>any</u> <u>other</u>
       <u>rows</u>.  This is also what to expect for DML (INSERT, UPDATE, DELETE) queries.  A way to utilise this might
       be as follows:

        sub some_state {
            #...
            if ($enough_values_to_begin_updating) {

                $heap-&gt;{dbiagent}-&gt;query(update_values_query =&gt;
                                         this_session =&gt;
                                         update_next_value =&gt;
                                         shift @{$heap-&gt;{values_to_be_updated}}
                                        );
            }
        }

        sub update_next_value {
            my ($self, $heap) = @_[OBJECT, HEAP];
            # we got 'EOF' in ARG0 here but we don't care... we know that an
            # update has been executed.

            for (1..3) {               # Do three at a time!
                my $value;
                last unless defined ($value = shift @{$heap-&gt;{values_to_be_updated}});
                $heap-&gt;{dbiagent}-&gt;query(update_values =&gt;
                                         this_session =&gt;
                                         update_next_value =&gt;
                                         $value
                                        );
            }

        }

   <b>new()</b>
       Creating an instance creates a POE::Session to manage communication with the Helper processes.  Queue
       management is transparent and automatic.  The constructor is named "new()" (surprised, eh?  Yeah, me
       too).  The parameters are as follows:

       DSN An arrayref of parameters to pass to DBI-&gt;connect (usually a dsn, username, and password).

       Queries
           A hashref of the form Query_Name =&gt; "$SQL".  For example:

            {
              sysdate =&gt; "select sysdate from dual",
              employee_record =&gt; "select * from emp where id = ?",
              increase_inventory =&gt; "update inventory
                                     set count = count + ?
                                     where item_id = ?",
            }

           As the example indicates, DBI placeholders are supported, as are DML statements.

       Count
           The  number  of helper processes to spawn.  Defaults to 3.  The optimal value for this parameter will
           depend on several factors, such as: how many different queries your program will be running, how much
           RAM you have, how often you run queries, and most importantly, how many queries  you  intend  to  run
           <u>simultaneously</u>.

       ErrorState
           An  listref  containing a session and event name to receive error messages from the DBI.  The message
           arrives in ARG0.

   <b>query(</b><u>$query_name</u><b>,</b> <b>[</b> <b>\%args,</b> <b>]</b> <u>$session</u><b>,</b> <u>$state</u><b>,</b> <b>[</b> <u>@parameters</u> <b>])</b>
       The "query()" method takes at least three parameters, plus any bind values for the specific query you are
       executing.

       $query_name
           This parameter must be one of the keys to the Queries hashref you passed to the constructor.   It  is
           used to indicate which query you wish to execute.

       \%args
           This is an OPTIONAL hashref of arguments to pass to the query.

           Currently supported arguments:

           hash
               Return rows hash references instead of array references.

           cookie
               A  cookie  to  pass  to  this  query.   This is passed back unchanged to the destination state in
               $_[ARG1].  Can be any scalar (including references, and even POE postbacks, so be careful!).  You
               can use this as an identifier if you have  one  destination  state  handling  multiple  different
               queries or sessions.

           delay
               Insert a 1ms delay between each row of output.

               I know what you're thinking: "WHY would you want to slow down query responses?!?!?"  It has to do
               with  CONCURRENCY.  When a response (finally) comes in from the agent after running the query, it
               floods the input channel  with  response  data.   This  has  the  effect  of  monopolizing  POE's
               attention,  so  that  any  other  handles (network sockets, pipes, file descriptors) keep getting
               pushed further back on the queue, and to all other processes EXCEPT the agent, your  POE  program
               looks hung for the amount of time it takes to process all of the incoming query data.

               So,  we  insert  1ms  of  time  via  Time::HiRes's  "usleep"  function.   In human terms, this is
               essentially negligible.  But it is just enough time to allow competing handles  (sockets,  files)
               to  trigger  "select()",  and get handled by the POE::Kernel, in situations where concurrency has
               priority over transfer rate.

               Naturally, the Time::HiRes module is required for this  functionality.   If  Time::HiRes  is  not
               installed, the delay is ignored.

           group
               Sends  the  return  event  back when "group" rows are retrieved from the database, to avoid event
               spam when selecting lots of rows. NB: using group means that $row will be an  arrayref  of  rows,
               not just a single row.

       $session, $state
           These  parameters indicate the POE state that is to receive the data returned from the database.  The
           state indicated will receive the data in its $_[ARG0] parameter.  <u>PLEASE</u> make sure this  is  a  valid
           state, otherwise you will spend a LOT of time banging your head against the wall wondering where your
           query data is.

       @parameters
           These are any parameters your query requires.  <b>WARNING:</b> You must supply exactly as many parameters as
           your query has placeholders!  This means that if your query has NO placeholders, then you should pass
           NO extra parameters to "query".

           Suggestions to improve this syntax are welcome.

   <b>finish()</b>
       The  "finish()"  method  tells DBIAgent that the program is finished sending queries.  DBIAgent will shut
       its helpers down gracefully after they complete any pending queries.  If there are  no  pending  queries,
       the DBIAgent will shut down immediately.

</pre><h4><b>NOTES</b></h4><pre>
       •   Error handling is practically non-existent.

       •   The  calling  syntax  is  still  pretty  weak...  but  improving.   We may eventually add an optional
           attributes hash so that each query can be called with its own individual characteristics.

       •   I might eventually want to support returning hashrefs, if there is any demand.

       •   Every query is prepared at Helper startup.  This could potentially be pretty  expensive.   Perhaps  a
           cached  or  deferred  loading might be better?  This is considering that not every helper is going to
           run every query, especially if you have a lot of miscellaneous queries.

       Suggestions welcome!  Diffs <u>more</u> welcome! :-)

</pre><h4><b>AUTHOR</b></h4><pre>
       This module has been fine-tuned and packaged by Rob Bloodgood &lt;<a href="mailto:robb@empire2.com">robb@empire2.com</a>&gt;.  However, most  of  the
       queuing  code  originated with Fletch &lt;<a href="mailto:fletch@phydeaux.org">fletch@phydeaux.org</a>&gt;, either directly or via his ideas.  Thank you
       for making this module a reality, Fletch!

       However, I own all of the bugs.

       This module is free software; you may redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself.

perl v5.32.0                                       2021-01-08                                      <u><a href="../man3pm/DBIAgent.3pm.html">DBIAgent</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>