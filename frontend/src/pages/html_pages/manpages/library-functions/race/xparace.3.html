<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XPARace - Race Conditions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxpa-dev">libxpa-dev_2.1.20-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XPARace - Race Conditions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Potential XPA race conditions and how to avoid them.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Currently, there is only one known circumstance in which XPA can get (temporarily) deadlocked in a race
       condition: if two or more XPA servers send messages to one another using an XPA client routine such as
       <u>XPASet()</u>, they can deadlock while each waits for the other server to respond.  (This can happen if the
       servers call <u>XPAPoll()</u> with a time limit, and send messages in between the polling call.)  The reason
       this happens is that both client routines send a string to the other server to establish the handshake
       and then wait for the server response. Since each client is waiting for a response, neither is able to
       enter its event-handling loop and respond to the other's request. This deadlock will continue until one
       of the timeout periods expire, at which point an error condition will be triggered and the timed-out
       server will return to its event loop.

       Starting with version 2.1.6, this rare race condition can be avoided by setting the XPA_IOCALLSXPA
       environment variable for servers that will make client calls. Setting this variable causes all XPA socket
       IO calls to process outstanding XPA requests whenever the primary socket is not ready for IO. This means
       that a server making a client call will (recursively) process incoming server requests while waiting for
       client completion. It also means that a server callback routine can handle incoming XPA messages if it
       makes its own XPA call.  The semi-public routine oldvalue=XPAIOCallsXPA(newvalue) can be used to turn
       this behavior off and on temporarily. Passing a 0 will turn off IO processing, 1 will turn it back on.
       The old value is returned by the call.

       By default, the XPA_IOCALLSXPA option is turned off, because we judge that the added code complication
       and overhead involved will not be justified by the amount of its use.  Moreover, processing XPA requests
       within socket IO can lead to non-intuitive results, since incoming server requests will not necessarily
       be processed to completion in the order in which they are received.

       Aside from setting XPA_IOCALLSXPA, the simplest way to avoid this race condition is to multi-process:
       when you want to send a client message, simply start a separate process to call the client routine, so
       that the server is not stopped. It probably is fastest and easiest to use <u>fork()</u> and then have the child
       call the client routine and exit. But you also can use either the <u>system()</u> or <u>popen()</u> routine to start
       one of the command line programs and do the same thing. Alternatively, you can use XPA's internal
       <u>launch()</u> routine instead of <u>system()</u>. Based on <u>fork()</u> and <u>exec()</u>, this routine is more secure than
       <u>system()</u> because it does not call /bin/sh.

       Starting with version 2.1.5, you also can send an <u>XPAInfo()</u> message with the mode string "ack=false".
       This will cause the client to send a message to the server and then exit without waiting for any return
       message from the server. This UDP-like behavior will avoid the server deadlock when sending short XPAInfo
       messages.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See xpa(n) for a list of XPA help pages

version 2.1.15                                    July 23, 2013                                       <u><a href="../man3/xparace.3.html">xparace</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>