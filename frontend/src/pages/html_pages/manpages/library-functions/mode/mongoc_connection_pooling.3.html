<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mongoc_connection_pooling - Connection Pooling</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libmongoc-doc">libmongoc-doc_1.21.0-1build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mongoc_connection_pooling - Connection Pooling

       The  MongoDB  C  driver  has  two  connection  modes: single-threaded and pooled. Single-threaded mode is
       optimized for embedding the driver within languages like PHP. Multi-threaded programs should  use  pooled
       mode:  this  mode minimizes the total connection count, and in pooled mode background threads monitor the
       MongoDB server topology, so the program need not block to scan it.

</pre><h4><b>SINGLE</b> <b>MODE</b></h4><pre>
       In single mode, your program creates a <b>mongoc_client_t</b> directly:

          mongoc_client_t *client = mongoc_client_new (
             "mongodb://hostA,hostB/?replicaSet=my_rs");

       The client connects on demand when  your  program  first  uses  it  for  a  MongoDB  operation.  Using  a
       non-blocking  socket per server, it begins a check on each server concurrently, and uses the asynchronous
       <b>poll</b> or <b>select</b> function to receive events from the sockets, until all have responded or  timed  out.  Put
       another way, in single-threaded mode the C Driver fans out to begin all checks concurrently, then fans in
       once  all checks have completed or timed out. Once the scan completes, the client executes your program's
       operation and returns.

       In single mode, the client re-scans the server topology roughly once per minute. If more  than  a  minute
       has  elapsed  since  the  previous  scan,  the  next  operation on the client will block while the client
       completes its scan. This interval is configurable with <b>heartbeatFrequencyMS</b>  in  the  connection  string.
       (See <b>mongoc_uri_t</b>.)

       A  single  client  opens  one connection per server in your topology: these connections are used both for
       scanning the topology and performing normal operations.

</pre><h4><b>POOLED</b> <b>MODE</b></h4><pre>
       To activate pooled mode, create a <b>mongoc_client_pool_t</b>:

          mongoc_uri_t *uri = mongoc_uri_new (
             "mongodb://hostA,hostB/?replicaSet=my_rs");

          mongoc_client_pool_t *pool = mongoc_client_pool_new (uri);

       When your program first calls  <b>mongoc_client_pool_pop</b>,  the  pool  launches  monitoring  threads  in  the
       background.  Monitoring  threads  independently  connect  to  all  servers  in  the connection string. As
       monitoring threads receive hello responses from the servers, they update the shared view  of  the  server
       topology.  Additional  monitoring  threads  and  connections  are  created as new servers are discovered.
       Monitoring threads are terminated when servers are removed from the shared view of the server topology.

       Each thread that executes MongoDB operations must check out a client from the pool:

          mongoc_client_t *client = mongoc_client_pool_pop (pool);

          /* use the client for operations ... */

          mongoc_client_pool_push (pool, client);

       The <b>mongoc_client_t</b> object is not thread-safe, only the <b>mongoc_client_pool_t</b> is.

       When the driver is in pooled mode,  your  program's  operations  are  unblocked  as  soon  as  monitoring
       discovers  a usable server. For example, if a thread in your program is waiting to execute an "insert" on
       the primary, it is unblocked as  soon  as  the  primary  is  discovered,  rather  than  waiting  for  all
       secondaries to be checked as well.

       The pool opens one connection per server for monitoring, and each client opens its own connection to each
       server  it  uses  for application operations. Background monitoring threads re-scan servers independently
       roughly every 10 seconds. This interval is  configurable  with  <b>heartbeatFrequencyMS</b>  in  the  connection
       string. (See <b>mongoc_uri_t</b>.)

       The  connection  string can also specify <b>waitQueueTimeoutMS</b> to limit the time that <b>mongoc_client_pool_pop</b>
       will wait for a client from the pool.  (See <b>mongoc_uri_t</b>.)  If <b>waitQueueTimeoutMS</b> is specified,  then  it
       is necessary to confirm that a client was actually returned:

          mongoc_uri_t *uri = mongoc_uri_new (
             "mongodb://hostA,hostB/?replicaSet=my_rs&amp;waitQueueTimeoutMS=1000");

          mongoc_client_pool_t *pool = mongoc_client_pool_new (uri);

          mongoc_client_t *client = mongoc_client_pool_pop (pool);

          if (client) {
             /* use the client for operations ... */

             mongoc_client_pool_push (pool, client);
          } else {
             /* take appropriate action for a timeout */
          }

       See  connection_pool_options  to  configure  pool  size and behavior, and see <b>mongoc_client_pool_t</b> for an
       extended example of a multi-threaded program that uses the driver in pooled mode.

</pre><h4><b>AUTHOR</b></h4><pre>
       MongoDB, Inc

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2017-present, MongoDB, Inc

1.21.0                                            Feb 09, 2022                      <u><a href="../man3/MONGOC_CONNECTION_POOLING.3.html">MONGOC_CONNECTION_POOLING</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>