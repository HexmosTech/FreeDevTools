<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Term::ReadLine::Zoid::ViCommand - a readline command mode</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libterm-readline-zoid-perl">libterm-readline-zoid-perl_0.07-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Term::ReadLine::Zoid::ViCommand - a readline command mode

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This class is used as a mode under Term::ReadLine::Zoid, see there for usage details.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This mode provides a "vi command mode" as specified by the posix spec for the <b><a href="../man1/sh.1.html">sh</a></b>(1) utility. It intends
       to include at least all key-bindings mentioned by the posix spec for the vi mode in <b><a href="../man1/sh.1.html">sh</a></b>(1).  It also
       contains some extensions borrowed from <b><a href="../man1/vim.1.html">vim</a></b>(1) and some private extensions.

       This mode has a "kill buffer" that stores the last killed text so it can be yanked again. This buffer has
       only one value, it isn't a "kill ring".

</pre><h4><b>KEY</b> <b>MAPPING</b></h4><pre>
       Since ViCommand inherits from MultiLine, which in turn inherits from Term::ReadLine::Zoid, key bindings
       are also inherited unless explicitly overloaded.

       Control-d is ignored in this mode.

       escape
           Reset the command mode.

       return
       ^J  Return the current edit line to the application for execution.

       ^Z  Send  a SIGSTOP to the process of the application. Might not work when the application ignores those,
           which is something shells tend to do.

       i   Switch back to insert mode.

       I   Switch back to insert mode at the begin of the edit line.

       a   Enter insert mode after the current cursor position.

       A   Enter insert mode at the end of the edit line.

       m   Switch to multiline insert mode, see Term::ReadLine::Zoid::MultiLine.  (private extension)

       M   Switch to multiline insert mode at the end of the edit buffer.  (private extension)

       R   Enter insert mode with replace toggled on.  (vim extension)

       #   Makes current edit line a comment that will be listed in the history, but won't be executed.

           Only works if the 'comment_begin' option is set.

       =   Display possible shell word completions, does not modify the edit line.

       \   Do pathname completion (using File::Glob) and insert the largest matching part in the edit line.

       *   Do pathname completion but inserts <b>all</b> matches.

       [<u>count</u>] @ <u>char</u>
           Regard the contents of the alias _char as a  macro  with  editing  commands.   This  seems  a  rather
           obfuscated feature of the posix spec to me. See also below for the alias command.

           Note that the <u>count</u> argument is not posix compliant, but it seems silly not to use it.

       [<u>count</u>] ~
           Reverse case for <u>count</u> characters.

       [<u>count</u>] .
           Repeat  the  last  non-motion command.  If no count is specified the original count of the command is
           used.

       v   Edit the buffer with the editor specified by the "EDITOR" environment variable or the editor  option,
           defaults to 'vi'.

           This  function  requires  the  File::Temp  module from cpan, which in turn needs File::Spec and other
           packages. If these are not available this functions is disabled.

       [<u>count</u>] l
       [<u>count</u>] <u>space</u>
           Move the cursor to the right.

       [<u>count</u>] h
           Move the cursor to the left.

       [<u>count</u>] w
       [<u>count</u>] W
           Move the cursor to the begin of the next word or bigword.

           (A bigword exists of non-whitespace chars, while a word exists of alphanumeric chars only.)

       [<u>count</u>] e
       [<u>count</u>] E
           Move the cursor to the end of the current word or bigword.

       [<u>count</u>] b
       [<u>count</u>] B
           Move the cursor to the begin of the current word or bigword.

       ^   Move the cursor to the first non-whitespace on the edit line.

       $   Move the cursor to the end of the edit line.

       0   Move the cursor to the begin of the edit line.

       [<u>count</u>] |
           Set the cursor to position <u>count</u> (1-based).

       [<u>count</u>] f <u>char</u>
           Set cursor to <u>count</u>'th occurrence of <u>char</u> to the right.  The cursor is placed on <u>char</u>.

       [<u>count</u>] F <u>char</u>
           Set cursor to <u>count</u>'th occurrence of <u>char</u> to the left.  The cursor is placed on <u>char</u>.

       [<u>count</u>] t <u>char</u>
           Set cursor to <u>count</u>'th occurrence of <u>char</u> to the right.  The cursor is placed before <u>char</u>.

       [<u>count</u>] T <u>char</u>
           Set cursor to <u>count</u>'th occurrence of <u>char</u> to the left.  The cursor is placed after <u>char</u>.

       [<u>count</u>] ;
           Repeat the last 'f', 'F', 't', or 'T' command. Count of last command is ignored.

       [<u>count</u>] ,
           Like ';' but with direction reversed.

       [<u>count</u>] c <u>motion</u>
           Delete characters between the current position and the position after the <u>motion</u>,  <u>count</u>  applies  to
           <u>motion</u>.  After the deletion enter insert mode.

           The "motion" 'c' deletes the current edit line.

       C   Delete from cursor to end of line and enter insert mode.

       S   Delete current line and enter insert mode.

       [<u>count</u>] r <u>char</u>
           Replace the character under the cursor (and the <u>count</u> characters next to it) with <u>char</u>.

       [<u>count</u>] _
           Insert  a  white space followed by the last (or <u>count</u>'th) bigword from the previous history entry ans
           enter insert mode.

           Quotes are not respected by this function.

       [<u>count</u>] x
           Delete <u>count</u> characters and place them in the save buffer.

       [<u>count</u>] X
           Delete <u>count</u> characters before the cursor position and place them in the save buffer.

           ('x' is like 'delete', 'X' like backspace)

       [<u>count</u>] d <u>motion</u>
           Delete from the current cursor position to the  position  resulting  from  <u>count</u>  times  <u>motion</u>.  The
           deleted part will be placed in the save buffer.

           The "motion" 'd' deletes the current line.

       D   Delete  from  the  cursor  position  until  the  end of the line and put the deleted part in the save
           buffer.

       [<u>count</u>] y <u>motion</u>
           Yank (copy) characters from the current cursor position to the position resulting  from  <u>count</u>  times
           <u>motion</u> to the save buffer.

           the "motion" 'y' yanks the current line.

       Y   Like y but from cursor till end of line.

       [<u>count</u>] p
           Insert <u>count</u> copies of the the save buffer after the cursor.

       [<u>count</u>] P
           Insert <u>count</u> copies of the the save buffer before the cursor.

       u   Undo the last command that changed the edit line.

       U   Undo all changes.

           TODO all changes since when ? since entering the command mode ?

       [<u>count</u>] k
       [<u>count</u>] -
           Go <u>count</u> lines backward in history.

       [<u>count</u>] j
       [<u>count</u>] +
           Go <u>count</u> lines forward in history.

       [<u>number</u>] G
           Go to history entry number <u>number</u>, or to the first history entry.

       n   Repeat the last history search by either the '/' or '?' minibuffers or the incremental search mode.

       N   Repeat the last history search in the oposite direction.

       :   Opens  a command mini buffer. This is a very minimalistic execution environment that can for instance
           be used to modify options if the application doesn't provide a method to do so. Also it is  used  for
           quick hacks ;)

           The execution of this buffer happens entirely without returning to the application.

           (This is a vim extension)

       /   Opens a mini buffer where you can type a pattern to search backward through the history.

           The search patterns are not globs (as posix would have them), but are evaluated as perl regexes.

           An empty pattern repeats the previous search.

       ?   Like '/' but searches in the forward direction.

       ^A  If cursor is on a number, increment it. (This is a vim extension)

           FIXME bit buggy

       ^X  If cursor is on a number, decrement it. (This is a vim extension)

           FIXME bit buggy

</pre><h4><b>COMMANDS</b></h4><pre>
       These can be used from the ":" mini buffer. Some commands are borrowed from vim, but no guarantee what so
       ever.

       <b>quit</b>
           Return undef to the application (like '^D' in insert mode).

       <b>set</b> [<u>+o</u>|<u>-o</u>] [<u>option</u>=<u>value</u>]
           Set  a  key-value  pair  in the options hash When the arg '+o' is given (or the option is preceded by
           'no') the option is deleted.

           Can be used to change the ReadLine behaviour independent from the application.

       <b>ascii</b>
           Output ascii values for the char in the edit line on the cursor position.

       <b>testchr</b>
           Wait for a character input and output ascii values for it.

       <b>bindchr</b> <u>chr</u>=<u>keyname</u>
           Map a char (or char sequence) to a key name.

       <b>bindkey</b> <u>chr</u>=sub { <u>code</u> }
           Map a char (or char sequence) to a key name.

       <b>!</b>, <b>shell</b> <u>shellcode</u>
           Eval a system command.  The '%' character in this string will be replace with the name of a tmp  file
           containing  the  edit  buffer.  After execution this tmp file will be read back into the edit buffer.
           Of course you can use an backslash to escape a literal '%'.

           Note that this tmp file feature only works if you have File::Temp installed.

       <b>eval</b> <u>perlcode</u>
           Eval some perlcode for the most evil instant hacks.  The ReadLine object can be called as $self.

       <b>alias</b> <u>char</u>=<u>macro</u>
           Define a macro in an alias with a one character name.  These can be executed with  the  '@'  command.
           Non alphanumeric keys like "\n" and "\e" can be inserted with the standard perl escape sequences. You
           need to use "\\" for a literal '\'.

</pre><h4><b>ATTRIBS</b></h4><pre>
       These can be accessed through the "Attribs" method (defined by the parent class).

       aliases
           This  option  is  refers  to  a  hash  with aliases, used for the key binding for '@'.  Note that all
           aliases have a one character name prefixed with a "_", this is due to historic implementations  where
           the  same  hash  is used for system aliases.  We <b>don't</b> support aliases for the shell command, to have
           that you should define your own shell subroutine (see below).

       editor
           Editor command used for the 'v' binding. The string  is  run  by  the  shell  command.   This  option
           defaults to the EDITOR environment variable or to "vi %".

       shell
           The  value  can be set to a CODE ref to handle the shell command from the mini-buffer and the 'v' key
           binding. It should return the exit status of the command (like the perlfunc "system()").

</pre><h4><b>AUTHOR</b></h4><pre>
       Jaap Karssenberg || Pardus [Larus] &lt;<a href="mailto:pardus@cpan.org">pardus@cpan.org</a>&gt;

       Copyright (c) 2004 Jaap G Karssenberg. All rights reserved.  This  program  is  free  software;  you  can
       redistribute it and/or modify it under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Term::ReadLine::Zoid

perl v5.34.0                                       2022-06-17               <u>Term::ReadLine::Zoid::<a href="../man3pm/ViCommand.3pm.html">ViCommand</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>