<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inline::C - C Language Support for Inline</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libinline-c-perl">libinline-c-perl_0.82-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Inline::C - C Language Support for Inline

</pre><h4><b>VERSION</b></h4><pre>
       This document describes Inline::C version <b>0.82</b>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Inline::C" is a module that allows you to write Perl subroutines in C. Since version 0.30 the Inline
       module supports multiple programming languages and each language has its own support module. This
       document describes how to use Inline with the C programming language. It also goes a bit into Perl C
       internals.

       If you want to start working with programming examples right away, check out Inline::C::Cookbook. For
       more information on Inline in general, see Inline.

</pre><h4><b>USAGE</b></h4><pre>
       You never actually use "Inline::C" directly. It is just a support module for using "Inline.pm" with C. So
       the usage is always:

           use Inline C =&gt; ...;

       or

           bind Inline C =&gt; ...;

</pre><h4><b>FUNCTION</b> <b>DEFINITIONS</b></h4><pre>
       The Inline grammar for C recognizes certain function definitions (or signatures) in your C code. If a
       signature is recognized by Inline, then it will be available in Perl-space. That is, Inline will generate
       the "glue" necessary to call that function as if it were a Perl subroutine. If the signature is not
       recognized, Inline will simply ignore it, with no complaints.  It will not be available from Perl-space,
       although it <u>will</u> be available from C-space.

       Inline looks for ANSI/prototype style function definitions. They must be of the form:

           return-type function-name ( type-name-pairs ) { ... }

       The most common types are: "int", "long", "double", "char*", and "SV*".  But you can use any type for
       which Inline can find a typemap. Inline uses the "typemap" file distributed with Perl as the default. You
       can specify more typemaps with the "typemaps" configuration option.

       A return type of "void" may also be used. The following are examples of valid function definitions.

           int Foo(double num, char* str) {
           void Foo(double num, char* str) {
           void Foo(SV*, ...) {
           long Foo(int i, int j, ...) {
           SV* Foo(void) { # 'void' arg invalid with the ParseRecDescent parser.
                           # Works only with the ParseRegExp parser.
                           # See the section on `using` (below).
           SV* Foo() {  # Alternative to specifying 'void' arg. Is valid with
                        # both the ParseRecDescent and ParseRegExp parsers.

       The following definitions would not be recognized:

           Foo(int i) {               # no return type
           int Foo(float f) {         # no (default) typemap for float
           int Foo(num, str) double num; char* str; {

       Notice that Inline only looks for function <u>definitions</u>, not function <u>prototypes</u>. Definitions are the
       syntax directly preceding a function body.  Also Inline does not scan external files, like headers. Only
       the code passed to Inline is used to create bindings; although other libraries can linked in, and called
       from C-space.

</pre><h4><b>C</b> <b>CONFIGURATION</b> <b>OPTIONS</b></h4><pre>
       For information on how to specify Inline configuration options, see Inline.  This section describes each
       of the configuration options available for C. Most of the options correspond either to MakeMaker or XS
       options of the same name.  See ExtUtils::MakeMaker and perlxs.

       "auto_include"
           Specifies extra statements to automatically included. They will be added onto the defaults. A newline
           char will be automatically added.

               use Inline C =&gt; config =&gt; auto_include =&gt; '#include "yourheader.h"';

       "autowrap"
           If  you  "enable  =&gt;  autowrap", Inline::C will parse function declarations (prototype statements) in
           your C code. For each declaration it can bind to, it will create a dummy wrapper that will  call  the
           real  function  which  may  be  in an external library. This is a nice convenience for functions that
           would otherwise just require an empty wrapper function.

           This is similar to the base functionality you get from "h2xs". It can be very useful for  binding  to
           external libraries.

       "boot"
           Specifies C code to be executed in the XS "BOOT" section. Corresponds to the XS parameter.

       "cc"
           Specify which compiler to use.

       "ccflags"
           Specify  compiler  flags  -  same as ExtUtils::MakeMaker's "CCFLAGS" option.  Whatever gets specified
           here replaces the default $Config{ccflags}. Often, you'll want to add an extra flag  or  two  without
           clobbering  the  default  flags  in  which  case you could instead use "ccflagsex" (see below) or, if
           Config.pm has already been loaded:

               use Inline C =&gt; Config =&gt; ccflags =&gt; $Config{ccflags} . " -DXTRA -DTOO";

       "ccflagsex"
           Extend compiler flags. Sets "CCFLAGS" to $Config{ccflags}  followed  by  a  space,  followed  by  the
           specified value:

               use Inline C =&gt; config =&gt; ccflagsex =&gt; "-DXTRA -DTOO";

       "cppflags"

       Specify preprocessor flags. Passed to "cpp" C preprocessor by Preprocess() in Inline::Filters.

           use Inline C =&gt; &lt;&lt;'END',
               CPPFLAGS =&gt; ' -DPREPROCESSOR_DEFINE',
               FILTERS =&gt; 'Preprocess';
           use Inline C =&gt; &lt;&lt;'END',
               CPPFLAGS =&gt; ' -DPREPROCESSOR_DEFINE=4321',
               FILTERS =&gt; 'Preprocess';

       "filters"
           Allows  you to specify a list of source code filters. If more than one is requested, be sure to group
           them with an array ref. The filters can either be subroutine references or names of filters  provided
           by the supplementary Inline::Filters module.

           Your  source  code  will  be  filtered  just  before  it  is parsed by Inline. The MD5 fingerprint is
           generated before filtering. Source code filters can be used to  do  things  like  stripping  out  POD
           documentation, pre-expanding "#include" statements or whatever else you please. For example:

               use Inline C =&gt; DATA =&gt;
                          filters =&gt; [Strip_POD =&gt; \&amp;MyFilter =&gt; Preprocess ];

           Filters are invoked in the order specified. See Inline::Filters for more information.

           If  a  filter  is  an  array reference, it is assumed to be a usage of a filter plug- in named by the
           first element of that array reference. The rest of the elements of the array reference  are  used  as
           arguments to the filter. For example, consider a "filters" parameter like this:

               use Inline C =&gt; DATA =&gt; filters =&gt; [ [ Ragel =&gt; '-G2' ] ];

           In   order   for   Inline::C  to  process  this  filter,  it  will  attempt  to  require  the  module
           Inline::Filters::Ragel and will then call the "filter" function in that  package  with  the  argument
           '-G2'. This function will return the actual filtering function.

       "inc"
           Specifies  an include path to use. Corresponds to the MakeMaker parameter.  Expects a fully qualified
           path.

               use Inline C =&gt; config =&gt; inc =&gt; '-I/inc/path';

       "ld"
           Specify which linker to use.

       "lddlflags"
           Specify which linker flags to use.

           NOTE: These flags will completely override the existing flags, instead of
                 just adding to them. So if you need to use those too, you must
                 respecify them here.

       "libs"
           Specifies external libraries that should be linked into  your  code.  Corresponds  to  the  MakeMaker
           parameter.  Provide a fully qualified path with the "-L" switch if the library is in a location where
           it won't be found automatically.

               use Inline C =&gt; config =&gt; libs =&gt; '-lyourlib';

           or

               use Inline C =&gt; config =&gt; libs =&gt; '-L/your/path -lyourlib';

       "make"
           Specify the name of the 'make' utility to use.

       "myextlib"
           Specifies a user compiled object that should be linked in. Corresponds to  the  MakeMaker  parameter.
           Expects a fully qualified path.

               use Inline C =&gt; config =&gt; myextlib =&gt; '/your/path/yourmodule.so';

       "optimize"
           This  controls  the  MakeMaker  "OPTIMIZE"  setting.  By  setting this value to '-g', you can turn on
           debugging support for your Inline extensions. This will allow you to be able to  set  breakpoints  in
           your C code using a debugger like gdb.

       "prefix"
           Specifies  a prefix that will be automatically stripped from C functions when they are bound to Perl.
           Useful for creating wrappers for shared library API-s, and binding to the  original  names  in  Perl.
           Also useful when names conflict with Perl internals. Corresponds to the XS parameter.

               use Inline C =&gt; config =&gt; prefix =&gt; 'ZLIB_';

       "pre_head"
           Specifies  code  that  will  precede  the  inclusion  of  all  files  specified in "auto_include" (ie
           "EXTERN.h", "perl.h",  "XSUB.h",  "INLINE.h"  and  anything  else  that  might  have  been  added  to
           "auto_include" by the user). If the specified value identifies a file, the contents of that file will
           be inserted, otherwise the specified value is inserted.

               use Inline C =&gt; config =&gt; pre_head =&gt; $code_or_filename;

       "prototype"
           Corresponds  to  the  XS  keyword 'PROTOTYPE'. See the perlxs documentation for both 'PROTOTYPES' and
           'PROTOTYPE'. As an example, the following will set the PROTOTYPE of the 'foo' function  to  '$',  and
           disable prototyping for the 'bar' function.

               use Inline C =&gt; config =&gt; prototype =&gt; {foo =&gt; '$', bar =&gt; 'DISABLE'}

       "prototypes"
           Corresponds  to the XS keyword 'PROTOTYPES'. Can take only values of 'ENABLE' or 'DISABLE'. (Contrary
           to XS, default  value  is  'DISABLE').  See  the  perlxs  documentation  for  both  'PROTOTYPES'  and
           'PROTOTYPE'.

               use Inline C =&gt; config =&gt; prototypes =&gt; 'ENABLE';

       "typemaps"
           Specifies  extra  typemap  files  to  use.  These  types  will modify the behaviour of the C parsing.
           Corresponds to the MakeMaker parameter. Specify either a fully qualified path or a path  relative  to
           the cwd (ie relative to what the cwd is at the time the script is loaded).

               use Inline C =&gt; config =&gt; typemaps =&gt; '/your/path/typemap';

       "using"
           Specifies  which  parser  to  use.  The  default  is  Inline::C::Parser::RecDescent,  which  uses the
           Parse::RecDescent module.

           The   other   options   are   "::Parser::Pegex"    and    "::Parser::RegExp",    which    uses    the
           Inline::C::Parser::Pegex and Inline::C::Parser::RegExp modules that ship with Inline::C.

               use Inline C =&gt; config =&gt; using =&gt; '::Parser::Pegex';

           Note that the following old options are deprecated, but still work at this time:

           •   "ParseRecDescent"

           •   "ParseRegExp"

           •   "ParsePegex"

</pre><h4><b>C-PERL</b> <b>BINDINGS</b></h4><pre>
       This section describes how the "Perl" variables get mapped to "C" variables and back again.

       First,  you  need  to know how "Perl" passes arguments back and forth to subroutines. Basically it uses a
       stack (also known as the <b>Stack</b>). When a sub is called, all of the parenthesized  arguments  get  expanded
       into  a  list of scalars and pushed onto the <b>Stack</b>. The subroutine then pops all of its parameters off of
       the <b>Stack</b>. When the sub is done, it pushes all of its return values back onto the <b>Stack</b>.

       The <b>Stack</b> is an array of scalars known internally as "SV"'s. The <b>Stack</b> is actually an array  of  <b>pointers</b>
       <b>to</b>  <b>SV</b>  or "SV*"; therefore every element of the <b>Stack</b> is natively a "SV*". For <u>FMTYEWTK</u> about this, read
       "perldoc perlguts".

       So back to variable mapping. XS uses a thing known as "typemaps" to turn each "SV*" into a "C"  type  and
       back  again.  This is done through various XS macro calls, casts and the Perl API. See "perldoc perlapi".
       XS allows you to define your own typemaps as well for fancier non-standard types such  as  "typedef"-  ed
       structs.

       Inline   uses   the   default   Perl   typemap   file   for  its  default  types.  This  file  is  called
       "/usr/local/lib/perl5/5.6.1/ExtUtils/typemap", or something similar, depending on your Perl installation.
       It has definitions for over 40 types, which are automatically used by Inline. (You should probably browse
       this file at least once, just to get an idea of the possibilities.)

       Inline parses your code for these types and generates the XS code to map them.  The  most  commonly  used
       types are:

       •   "int"

       •   "long"

       •   "double"

       •   "char*"

       •   "void"

       •   "SV*"

       If  you  need  to  deal  with  a type that is not in the defaults, just use the generic "SV*" type in the
       function definition. Then inside your code, do the mapping yourself. Alternatively, you can  create  your
       own typemap files and specify them using the "typemaps" configuration option.

       A  return  type of "void" has a special meaning to Inline. It means that you plan to push the values back
       onto the <b>Stack</b> yourself. This is what you need to do to return a list of values. If you really don't want
       to return anything (the traditional meaning of "void") then simply don't push anything back.

       If ellipsis or "..." is used at the end of an argument list, it means  that  any  number  of  "SV*"s  may
       follow. Again you will need to pop the values off of the "Stack" yourself.

       See "EXAMPLES" below.

</pre><h4><b>THE</b> <b>INLINE</b> <b>STACK</b> <b>MACROS</b></h4><pre>
       When you write Inline C, the following lines are automatically prepended to your code (by default):

           #include "EXTERN.h"
           #include "perl.h"
           #include "XSUB.h"
           #include "INLINE.h"

       The  file  "INLINE.h"  defines  a  set  of macros that are useful for handling the Perl Stack from your C
       functions.

       "Inline_Stack_Vars"
           You'll need to use this one, if you want to use the others. It sets up a few local  variables:  "sp",
           "items", "ax" and "mark", for use by the other macros. It's not important to know what they do, but I
           mention them to avoid possible name conflicts.

           NOTE: Since this macro declares variables, you'll need to put it with your
                 other variable declarations at the top of your function. It must
                 come before any executable statements and before any other
                 "Inline_Stack" macros.

       "Inline_Stack_Items"
           Returns the number of arguments passed in on the Stack.

       Inline_Stack_Item(i)
           Refers  to  a  particular "SV*" in the Stack, where "i" is an index number starting from zero. Can be
           used to get or set the value.

       "Inline_Stack_Reset"
           Use this before pushing anything back onto the Stack. It resets the internal  Stack  pointer  to  the
           beginning of the Stack.

       Inline_Stack_Push(sv)
           Push a return value back onto the Stack. The value must be of type "SV*".

       "Inline_Stack_Done"
           After you have pushed all of your return values, you must call this macro.

       Inline_Stack_Return(n)
           Return "n" items on the Stack.

       "Inline_Stack_Void"
           A special macro to indicate that you really don't want to return anything. Same as:

               <a href="../man0/Inline_Stack_Return.0.html">Inline_Stack_Return</a>(0);

           Please note that this macro actually <b>returns</b> from your function.

       Each  of these macros is available in 3 different styles to suit your coding tastes. The following macros
       are equivalent.

           Inline_Stack_Vars
           inline_stack_vars
           INLINE_STACK_VARS

       All of  this  functionality  is  available  through  XS  macro  calls  as  well.  So  why  duplicate  the
       functionality?  There are a few reasons why I decided to offer this set of macros. First, as a convenient
       way to access the Stack.  Second, for consistent, self documenting, non-cryptic coding. Third, for future
       compatibility. It occurred to me that if a lot of people started using XS macros for their  C  code,  the
       interface  might  break  under  Perl6.  By  using  this  set,  hopefully  I will be able to insure future
       compatibility of argument handling.

       Of course, if you use the rest of the Perl API, your code will most likely break under Perl6. So this  is
       not  a  100% guarantee. But since argument handling is the most common interface you're likely to use, it
       seemed like a wise thing to do.

</pre><h4><b>WRITING</b> <b>C</b> <b>SUBROUTINES</b></h4><pre>
       The definitions of your C functions will fall into  one  of  the  following  four  categories.  For  each
       category there are special considerations.

       "int Foo(int arg1, char* arg2, SV* arg3) {"
           This  is  the  simplest case. You have a non "void" return type and a fixed length argument list. You
           don't need to worry about much. All the conversions will happen automatically.

       "void Foo(int arg1, char* arg2, SV* arg3) {"
           In this category you have a "void" return type. This means that either you want to return nothing, or
           that you want to return a list. In the latter  case  you'll  need  to  push  values  onto  the  <b>Stack</b>
           yourself. There are a few Inline macros that make this easy. Code something like this:

               int i, max; SV* my_sv[10];
               Inline_Stack_Vars;
               Inline_Stack_Reset;
               for (i = 0; i &lt; max; i++)
                 Inline_Stack_Push(my_sv[i]);
               Inline_Stack_Done;

           After  resetting  the  Stack pointer, this code pushes a series of return values.  At the end it uses
           "Inline_Stack_Done" to mark the end of the return stack.

           If you really want to return nothing, then don't use the "Inline_Stack_"  macros.  If  you  must  use
           them, then set use "Inline_Stack_Void" at the end of your function.

       "char* Foo(SV* arg1, ...) {"
           In  this  category you have an unfixed number of arguments. This means that you'll have to pop values
           off the <b>Stack</b> yourself. Do it like this:

               int i;
               Inline_Stack_Vars;
               for (i = 0; i &lt; Inline_Stack_Items; i++)
                 handle_sv(Inline_Stack_Item(i));

           The return type of Inline_Stack_Item(i) is "SV*".

       "void* Foo(SV* arg1, ...) {"
           In this category you have both a "void" return type and an unfixed number of arguments. Just  combine
           the techniques from Categories 3 and 4.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Here  are a few examples. Each one is a complete program that you can try running yourself. For many more
       examples see Inline::C::Cookbook.

   <b>Example</b> <b>#1</b> <b>-</b> <b>Greetings</b>
       This example will take one string argument (a name) and print a greeting. The function is called  with  a
       string and with a number. In the second case the number is forced to a string.

       Notice  that  you  do  not  need to "#include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>"&gt;. The "perl.h" header file which gets included by
       default, automatically loads the standard C header files for you.

           use Inline 'C';
           greet('Ingy');
           <a href="../man42/greet.42.html">greet</a>(42);
           __END__
           __C__
           void greet(char* name) {
             printf("Hello %s!\n", name);
           }

   <b>Example</b> <b>#2</b> <b>-</b> <b>and</b> <b>Salutations</b>
       This is similar to the last example except that the name is passed in  as  a  "SV*"  (pointer  to  Scalar
       Value) rather than a string ("char*"). That means we need to convert the "SV" to a string ourselves. This
       is accomplished using the "SvPVX" function which is part of the "Perl" internal API. See "perldocperlapi"
       for more info.

       One problem is that "SvPVX" doesn't automatically convert strings to numbers, so we get a little surprise
       when we try to greet 42. The program segfaults, a common occurrence when delving into the guts of Perl.

           use Inline 'C';
           greet('Ingy');
           <a href="../man42/greet.42.html">greet</a>(42);
           __END__
           __C__
           void greet(SV* sv_name) {
             printf("Hello %s!\n", SvPVX(sv_name));
           }

   <b>Example</b> <b>#3</b> <b>-</b> <b>Fixing</b> <b>the</b> <b>problem</b>
       We  can fix the problem in Example #2 by using the "SvPV" function instead.  This function will stringify
       the "SV" if it does not contain a string.  "SvPV" returns  the  length  of  the  string  as  it's  second
       parameter.  Since  we  don't  care  about  the  length, we can just put "PL_na" there, which is a special
       variable designed for that purpose.

           use Inline 'C';
           greet('Ingy');
           <a href="../man42/greet.42.html">greet</a>(42);
           __END__
           __C__
           void greet(SV* sv_name) {
             printf("Hello %s!\n", SvPV(sv_name, PL_na));
           }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       For general information about Inline see Inline.

       For sample programs using Inline with C see Inline::C::Cookbook.

       For information on supported languages and platforms see Inline-Support.

       For information on writing your own Inline Language Support Module, see Inline-API.

       Inline's mailing list is <a href="mailto:inline@perl.org">inline@perl.org</a>

       To subscribe, send email to <a href="mailto:inline-subscribe@perl.org">inline-subscribe@perl.org</a>

</pre><h4><b>BUGS</b> <b>AND</b> <b>DEFICIENCIES</b></h4><pre>
       If you use C function names that happen to be used internally by Perl, you will get a load error  at  run
       time.  There  is  currently  no  functionality  to prevent this or to warn you. For now, a list of Perl's
       internal symbols is packaged in the Inline module distribution under the filename  'symbols.perl'.  Avoid
       using these in your code.

</pre><h4><b>AUTHORS</b></h4><pre>
       Ingy döt Net &lt;<a href="mailto:ingy@cpan.org">ingy@cpan.org</a>&gt;

       Sisyphus &lt;<a href="mailto:sisyphus@cpan.org">sisyphus@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2000-2022. Ingy döt Net.

       Copyright 2008, 2010-2014. Sisyphus.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

       See &lt;<a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>&gt;

perl v5.40.1                                       2025-04-13                                     <u>Inline::<a href="../man3pm/C.3pm.html">C</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>