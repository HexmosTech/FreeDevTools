<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARC::Record - Perl extension for handling MARC records</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmarc-record-perl">libmarc-record-perl_2.0.7-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MARC::Record - Perl extension for handling MARC records

</pre><h4><b>VERSION</b></h4><pre>
       Version 2.0.7

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Module for handling MARC records as objects.  The file-handling stuff is in MARC::File::*.

</pre><h4><b>ERROR</b> <b>HANDLING</b></h4><pre>
       Any errors generated are stored in $MARC::Record::ERROR.  Warnings are kept with the record and
       accessible in the "warnings()" method.

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
   <b>new()</b>
       Base constructor for the class.  It just returns a completely empty record.  To get real data, you'll
       need to populate it with fields, or use one of the MARC::File::* modules to read from a file.

   <b>new_from_usmarc(</b> <b>$marcblob</b> <b>[,</b> <b>\&amp;filter_func($tagno,$tagdata)]</b> <b>)</b>
       This is a wrapper around "MARC::File::USMARC::decode()" for compatibility with older versions of
       MARC::Record.

       The "wanted_func()" is optional.  See MARC::File::USMARC::decode for details.

</pre><h4><b>COMMON</b> <b>FIELD</b> <b>RETRIEVAL</b> <b>METHODS</b></h4><pre>
       Following are a number of convenience methods for commonly-retrieved data fields.  Please note that they
       each return strings, not MARC::Field objects.  They return empty strings if the appropriate field or
       subfield is not found.  This is as opposed to the "field()"/"subfield()" methods which return "undef" if
       something's not found.  My assumption is that these methods are used for quick &amp; dirty reports and you
       don't want to mess around with noting if something is undef.

       Also note that no punctuation cleanup is done.  If the 245a is "Programming Perl / ", then that's what
       you'll get back, rather than "Programming Perl".

   <b>title()</b>
       Returns the title from the 245 tag.

   <b>title_proper()</b>
       Returns the title proper from the 245 tag, subfields a, n and p.

   <b>author()</b>
       Returns the author from the 100, 110 or 111 tag.

   <b>edition()</b>
       Returns the edition from the 250 tag, subfield a.

   <b>publication_date()</b>
       Returns the publication date from the 260 tag, subfield c.

</pre><h4><b>FIELD</b> <b>&amp;</b> <b>SUBFIELD</b> <b>ACCESS</b> <b>METHODS</b></h4><pre>
   <b>fields()</b>
       Returns a list of all the fields in the record. The list contains a MARC::Field object for each field in
       the record.

   <b>field(</b> <u><b>tagspec(s)</b></u> <b>)</b>
       Returns a list of tags that match the field specifier, or an empty list if nothing matched.  In scalar
       context, returns the first matching tag, or undef if nothing matched.

       The field specifier can be a simple number (i.e. "245"), or use the "."  notation of wildcarding (i.e.
       subject tags are "6..").

   <b>subfield(</b> <b>$tag,</b> <b>$subfield</b> <b>)</b>
       Shortcut method for getting just a subfield for a tag.  These are equivalent:

         my $title = $marc-&gt;field('245')-&gt;subfield("a");
         my $title = $marc-&gt;subfield('245',"a");

       If either the field or subfield can't be found, "undef" is returned.

   <b>append_fields(</b> <b>@fields</b> <b>)</b>
       Appends the field specified by $field to the end of the record.  @fields need to be MARC::Field objects.

           my $field = MARC::Field-&gt;new('590','','','a' =&gt; 'My local note.');
           $record-&gt;append_fields($field);

       Returns the number of fields appended.

   <b>insert_fields_before(</b> <b>$before_field,</b> <b>@new_fields</b> <b>)</b>
       Inserts the field specified by $new_field before the field $before_field.  Returns the number of fields
       inserted, or undef on failures.  Both $before_field and all @new_fields need to be MARC::Field objects.
       If they are not an exception will be thrown.

           my $before_field = $record-&gt;field('260');
           my $new_field = MARC::Field-&gt;new('250','','','a' =&gt; '2nd ed.');
           $record-&gt;insert_fields_before($before_field,$new_field);

   <b>insert_fields_after(</b> <b>$after_field,</b> <b>@new_fields</b> <b>)</b>
       Identical to "insert_fields_before()", but fields are added after $after_field. Remember, $after_field
       and any new fields must be valid MARC::Field objects or else an exception will be thrown.

   <b>insert_fields_ordered(</b> <b>@new_fields</b> <b>)</b>
       Will insert fields in strictly numerical order. So a 008 will be filed after a 001 field. See
       "insert_grouped_field()" for an additional ordering.

   <b>insert_grouped_field(</b> <b>$field</b> <b>)</b>
       Will insert the specified MARC::Field object into the record in grouped order and return true (1) on
       success, and false (undef) on failure.

           my $field = MARC::Field-&gt;new( '510', 'Indexed by Google.' );
           $record-&gt;insert_grouped_field( $field );

       For example, if a '650' field is inserted with "insert_grouped_field()" it will be inserted at the end of
       the 6XX group of tags. After discussion most people wanted the ability to add a new field to the end of
       the hundred group where it belonged. The reason is that according to the MARC format, fields within a
       record are supposed to be grouped by block (hundred groups). This means that fields may not necessarily
       be in tag order.

   <b>delete_fields(</b> <b>$field</b> <b>)</b>
       Deletes a given list of MARC::Field objects from the the record.

           # delete all note fields
           my @notes = $record-&gt;field('5..');
           $record-&gt;delete_fields(@notes);

       <b>delete_fields()</b> will return the number of fields that were deleted.

   <b>delete_field()</b>
       Same thing as <b>delete_fields()</b> but only expects a single MARC::Field to be passed in. Mainly here for
       backwards compatibility.

   <b>as_usmarc()</b>
       This is a wrapper around "MARC::File::USMARC::encode()" for compatibility with older versions of
       MARC::Record.

   <b>as_formatted()</b>
       Returns a pretty string for printing in a MARC dump.

   <b>leader()</b>
       Returns the leader for the record.  Sets the leader if <u>text</u> is defined.  No error checking is done on the
       validity of the leader.

   <b>encoding()</b>
       A method for getting/setting the encoding for a record. The encoding for a record is determined by
       position 09 in the leader, which is blank for MARC-8 encoding, and 'a' for UCS/Unicode. <b>encoding()</b> will
       return a string, either 'MARC-8' or 'UTF-8' appropriately.

       If you want to set the encoding for a MARC::Record object you can use the string values:

           $record-&gt;encoding( 'UTF-8' );

       NOTE: MARC::Record objects created from scratch have an a default encoding of MARC-8, which has been the
       standard for years...but many online catlogs and record vendors are migrating to UTF-8.

       WARNING: you should be sure your record really does contain valid UTF-8 data when you manually set the
       encoding.

   <b>set_leader_lengths(</b> <b>$reclen,</b> <b>$baseaddr</b> <b>)</b>
       Internal function for updating the leader's length and base address.

   <b>clone()</b>
       The "clone()" method makes a copy of an existing MARC record and returns the new version.  Note that you
       cannot just say:

           my $newmarc = $oldmarc;

       This just makes a copy of the reference, not a new object.  You must use the "clone()" method like so:

           my $newmarc = $oldmarc-&gt;clone;

       You can also specify field specs to filter down only a certain subset of fields.  For instance, if you
       only wanted the title and ISBN tags from a record, you could do this:

           my $small_marc = $marc-&gt;clone( 245, '020' );

       The order of the fields is preserved as it was in the original record.

   <b>warnings()</b>
       Returns the warnings (as a list) that were created when the record was read.  These are things like
       "Invalid indicators converted to blanks".

           my @warnings = $record-&gt;warnings();

       The warnings are items that you might be interested in, or might not.  It depends on how stringently
       you're checking data.  If you're doing some grunt data analysis, you probably don't care.

       A side effect of calling <b>warnings()</b> is that the warning buffer will be cleared.

   <b>add_fields()</b>
       "add_fields()" is now deprecated, and users are encouraged to use "append_fields()",
       "insert_fields_after()", and "insert_fields_before()" since they do what you want probably. It is still
       here though, for backwards compatibility.

       "add_fields()" adds MARC::Field objects to the end of the list.  Returns the number of fields added, or
       "undef" if there was an error.

       There are three ways of calling "add_fields()" to add data to the record.

       1 Create a MARC::Field object and add it
             my $author = MARC::Field-&gt;new(
                           100, "1", " ", a =&gt; "Arnosky, Jim."
                           );
             $marc-&gt;add_fields( $author );

       2 Add the data fields directly, and let "add_fields()" take care of the objectifying.
             $marc-&gt;add_fields(
                   245, "1", "0",
                           a =&gt; "Raccoons and ripe corn /",
                           c =&gt; "Jim Arnosky.",
                           );

       3 Same as #2 above, but pass multiple fields of data in anonymous lists
             $marc-&gt;add_fields(
                   [ 250, " ", " ", a =&gt; "1st ed." ],
                   [ 650, "1", " ", a =&gt; "Raccoons." ],
                   );

</pre><h4><b>DESIGN</b> <b>NOTES</b></h4><pre>
       A brief discussion of why MARC::Record is done the way it is:

       •   It's built for quick prototyping

           One  of  the  areas  Perl  excels  is  in  allowing  the programmer to create easy solutions quickly.
           MARC::Record is designed along those same lines.  You want a program to dump all the 6XX  tags  in  a
           file?  MARC::Record is your friend.

       •   It's built for extensibility

           Currently,  I'm  using MARC::Record for analyzing bibliographic data, but who knows what might happen
           in the future?  MARC::Record needs to be just as adept at authority data, too.

       •   It's designed around accessor methods

           I use method calls everywhere, and I expect calling programs to do the same,  rather  than  accessing
           internal data directly.  If you access an object's hash fields on your own, future releases may break
           your code.

       •   It's not built for speed

           One  of  the tradeoffs in using accessor methods is some overhead in the method calls.  Is this slow?
           I don't know, I haven't measured.  I would suggest that  if  you're  a  cycle  junkie  that  you  use
           Benchmark.pm to check to see where your bottlenecks are, and then decide if MARC::Record is for you.

</pre><h4><b>RELATED</b> <b>MODULES</b></h4><pre>
       MARC::Field, MARC::Batch, MARC::File::XML, MARC::Charset, MARC::Lint

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   perl4lib (&lt;<a href="http://perl4lib.perl.org/">http://perl4lib.perl.org/</a>&gt;)

           A mailing list devoted to the use of Perl in libraries.

       •   Library Of Congress MARC pages (&lt;<a href="http://www.loc.gov/marc/">http://www.loc.gov/marc/</a>&gt;)

           The definitive source for all things MARC.

       •   <u>Understanding</u> <u>MARC</u> <u>Bibliographic</u> (&lt;<a href="http://lcweb.loc.gov/marc/umb/">http://lcweb.loc.gov/marc/umb/</a>&gt;)

           Online version of the free booklet.  An excellent overview of the MARC format.  Essential.

       •   Tag Of The Month (&lt;<a href="http://www.follettsoftware.com/sub/tag_of_the_month/">http://www.follettsoftware.com/sub/tag_of_the_month/</a>&gt;)

           Follett Software Company's (&lt;<a href="http://www.fsc.follett.com/">http://www.fsc.follett.com/</a>&gt;) monthly discussion of various MARC tags.

</pre><h4><b>TODO</b></h4><pre>
       •   Incorporate MARC.pm in the distribution.

           Combine MARC.pm and MARC::* into one distribution.

       •   Podify MARC.pm

       •   Allow regexes across the entire tag

           Imagine something like this:

             my @sears_headings = $marc-&gt;tag_grep( qr/Sears/ );

           (from Mike O'Regan)

       •   Insert a field in an arbitrary place in the record

       •   Modifying an existing field

</pre><h4><b>BUGS,</b> <b>WISHES</b> <b>AND</b> <b>CORRESPONDENCE</b></h4><pre>
       Please  feel free to email me at "&lt;<a href="mailto:mrylander@gmail.com">mrylander@gmail.com</a>&gt;".  I'm glad to help as best I can, and I'm always
       interested in bugs, suggestions and patches.

       An excellent place to look for information, and get quick help, is from the perl4lib mailing  list.   See
       &lt;<a href="http://perl4lib.perl.org">http://perl4lib.perl.org</a>&gt; for more information about this list, and other helpful MARC information.

       The MARC::Record development team uses the RT bug tracking system at &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt;.  If your email
       is  about a bug or suggestion, please report it through the RT system.  This is a huge help for the team,
       and you'll be notified of progress as things get fixed or updated.  If you prefer not to use the website,
       you can send your bug to "&lt;<a href="mailto:bug-MARC-Record@rt.cpan.org">bug-MARC-Record@rt.cpan.org</a>&gt;"

</pre><h4><b>IDEAS</b></h4><pre>
       Ideas are things that have been considered, but nobody's actually asked for.

       •   Create multiple output formats.

           These could be ASCII or MarcMaker.

</pre><h4><b>LICENSE</b></h4><pre>
       This code may be distributed under the same terms as Perl itself.

       Please note that these modules are not  products  of  or  supported  by  the  employers  of  the  various
       contributors to the code.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Andy Lester

       •   Mike O'Regan

       •   Ed Summers

       •   Mike Rylander

       •   Galen Charlton

perl v5.36.0                                       2022-10-13                                  <u>MARC::<a href="../man3pm/Record.3pm.html">Record</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>