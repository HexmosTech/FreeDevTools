<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jifty::DBI::Record - Superclass for records loaded by Jifty::DBI::Collection</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libjifty-dbi-perl">libjifty-dbi-perl_0.78-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Jifty::DBI::Record - Superclass for records loaded by Jifty::DBI::Collection

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package MyRecord;
         use base qw/Jifty::DBI::Record/;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Jifty::DBI::Record encapsulates records and tables as part of the Jifty::DBI object-relational mapper.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b> <b>ARGS</b>
       Instantiate a new, empty record object.

       ARGS is a hash used to pass parameters to the "_init()" function.

       Unless it is overloaded, the <b>_init()</b> function expects one key of 'handle' with a value containing a
       reference to a Jifty::DBI::Handle object.

   <b>id</b>
       Returns this row's primary key.

   <b>primary_keys</b>
       Return a hash of the values of our primary keys for this function.

   <b>_accessible</b> <b>COLUMN</b> <b>ATTRIBUTE</b>
       Private method.

       DEPRECATED

       Returns undef unless "COLUMN" has a true value for "ATTRIBUTE".

       Otherwise returns "COLUMN"'s value for that attribute.

   <b>_primary_keys</b>
       Return our primary keys. (Subclasses should override this, but our default is that we have one primary
       key, named 'id'.)

   <b>_init_columns</b>
       Sets up the primary key columns.

   <b>_init_methods_for_columns</b>
       This is an internal method responsible for calling "_init_methods_for_column" for each column that has
       been configured.

   <b>schema_version</b>
       If present, this method must return a string in '1.2.3' format to be used to determine which columns are
       currently active in the schema. That is, this value is used to determine which columns are defined, based
       upon comparison to values set in "till" and "since".

       If no implementation is present, the "latest" schema version is assumed, meaning that any column defining
       a "till" is not active and all others are.

   <b>_init_methods_for_column</b> <b>COLUMN</b>
       This method is used internally to update the symbol table for the record class to include an accessor and
       mutator for each column based upon the column's name.

       In addition, if your record class defines the method "schema_version", it will automatically generate
       methods according to whether the column currently exists for the current application schema version
       returned by that method. The "schema_version" method must return a value in the same form used by "since"
       and "till".

       If the column doesn't currently exist, it will create the methods, but they will die with an error
       message stating that the column does not exist for the current version of the application. If it does
       exist, a normal accessor and mutator will be created.

       See also "active" in Jifty::DBI::Column, "since" in Jifty::DBI::Schema, "till" in Jifty::DBI::Schema for
       more information.

   <b>null_reference</b>
       By default, Jifty::DBI::Record will return "undef" for non-existent foreign references which don't exist.
       That is, if each Employee "refers_to" a Department, but isn't required to, "&lt;$model-"department&gt;&gt; will
       return "undef" for employees not in a department.

       Overriding this method to return 0 will cause it to return a record with no id.  That is,
       "&lt;$model-"department&gt;&gt; will return a Department object, but "&lt;$model-"department-&gt;id&gt;&gt; will be "undef".

   <b>_to_record</b> <b>COLUMN</b> <b>VALUE</b>
       This <b>PRIVATE</b> method takes a column name and a value for that column.

       It returns "undef" unless "COLUMN" is a valid column for this record that refers to another record class.

       If it is valid, this method returns a new record object with an id of "VALUE".

   <b>prefetched</b> <b>NAME</b>
       Returns the prefetched value for column of property "NAME", if it exists.

   <b>add_column</b>
   <b>column</b>
           my $column = $self-&gt;column($column_name);

       Returns the Jifty::DBI::Column object of the specified column name.

   <b>columns</b>
           my @columns = $record-&gt;columns;

       Returns a sorted list of a $record's @columns.

   <b>all_columns</b>
         my @all_columns = $record-&gt;all_columns;

       Returns all the columns for the table, even those that are inactive.

   <b>readable_attributes</b>
       Returns the list of this table's readable columns. They are first sorted so that primary keys come first,
       and then they are sorted in alphabetical order.

   <b>serialize_metadata</b>
       Returns a hash which describes how this class is stored in the database.  Right now, the keys are
       "class", "table", and "columns". "class" and "table" return simple scalars, but "columns" returns a hash
       of "name =&amp;gt; value" pairs for all the columns in this model. See
       "Jifty::DBI::Column/serialize_metadata" for the format of that hash.

   <b>writable_attributes</b>
       Returns a list of this table's writable columns

   <b>record</b> <b>values</b>
       As you've probably already noticed, "Jifty::DBI::Record" automatically creates methods for your standard
       get/set accessors. It also provides you with some hooks to massage the values being loaded or stored.

       When you fetch a record value by calling "$my_record-&gt;some_field", "Jifty::DBI::Record" provides the
       following hook

       after_<u>column_name</u>
           This  hook  is  called  with  a  reference  to  the value returned by Jifty::DBI. Its return value is
           discarded.

       When you set a value, "Jifty::DBI" provides the following hooks

       before_set_<u>column_name</u> PARAMHASH
           "Jifty::DBI::Record" passes this function a reference to a paramhash composed of:

           column
               The name of the column we're updating.

           value
               The new value for <u>column</u>.

           is_sql_function
               A boolean that, if true, indicates that <u>value</u> is an SQL function, not just a value.

           If before_set_<u>column_name</u> returns false, the new value isn't set.

       before_set PARAMHASH
           This is identical to the "before_set_<u>column_name</u>", but is called for every column set.

       after_set_<u>column_name</u> PARAMHASH
           This hook will be called after a value is successfully set in the database. It will be called with  a
           reference  to a paramhash that contains "column", "value", and "old_value" keys. If "value" was a SQL
           function, it will now contain the actual value that was set. If "column" has filters on  it,  "value"
           will be the result of going through an encode and decode cycle.

           This hook's return value is ignored.

       after_set PARAMHASH
           This is identical to the "after_set_<u>column_name</u>", but is called for every column set.

       validate_<u>column_name</u> VALUE
           This  hook is called just before updating the database. It expects the actual new value you're trying
           to set <u>column_name</u> to. It returns two values.  The first is a boolean with truth indicating  success.
           The  second  is an optional message. Note that validate_<u>column_name</u> may be called outside the context
           of a <u>set</u> operation to validate a potential value. (The Jifty application framework uses this as  part
           of its AJAX validation system.)

   <b>_value</b>
       _value  takes a single column name and returns that column's value for this row.  Subclasses can override
       _value to insert custom access control.

   <b>__raw_value</b>
       Takes a column name and returns that column's raw value.  Subclasses should never override __raw_value.

   <b>resolve_column</b>
       given a column name, resolve it, even if it's actually an alias return the column object.

   <b>__value</b>
       Takes a column name and returns that column's value. Subclasses should never override __value.

   <b>as_hash</b>
       Returns a version of this record's readable columns rendered as a hash of key =&gt; value pairs

   <b>_set</b>
       _set takes a single column name and a single unquoted value.  It updates both the in-memory value of this
       column and the in-database copy.  Subclasses can override _set to insert custom access control.

   <b>load</b>
       "load" can be called as a class or object method.

       Takes a single argument, $id. Calls load_by_cols to retrieve the row whose primary key is $id.

   <b>load_by_cols</b>
       "load_by_cols" can be called as a class or object method.

       Takes a hash of columns and values. Loads the first record that matches all keys.

       The hash's keys are the columns to look at.

       The hash's values are either: scalar values to look for OR  hash  references  which  contain  'operator',
       'value', 'case_sensitive' or 'function'

       To load something case sensitively on a case insensitive database, you can do:

         $record-&gt;load_by_cols( column =&gt; { operator =&gt; '=',
                                            value =&gt; 'Foo',
                                            case_sensitive =&gt; 1 } );

   <b>load_by_primary_keys</b>
       Loads records with a given set of primary keys.

   <b>load_from_hash</b>
       Takes a hashref, such as created by Jifty::DBI and populates this record's loaded values hash.

   <b>_load_from_sql</b> <b>QUERYSTRING</b> <b>@BIND_VALUES</b>
       Load a record as the result of an SQL statement

   <b>create</b> <b>PARAMHASH</b>
       "create" can be called as either a class or object method

       This method creates a new record with the values specified in the PARAMHASH.

       This method calls two hooks in your subclass:

       before_create
           When  adding the "before_create" trigger, you can determine whether the trigger may cause an abort or
           not by passing the "abortable" parameter to the "add_trigger" method. If this is not  set,  then  the
           return value is ignored regardless.

             sub before_create {
                 my $self = shift;
                 my $args = shift;

                 # Do any checks and changes on $args here.
                 $args-&gt;{first_name} = ucfirst $args-&gt;{first_name};

                 return;      # false return vallue will abort the create
                 return 1;    # true return value will allow create to continue
             }

           This  method  is  called  before trying to create our row in the database. It's handed a reference to
           your paramhash. (That means it can modify your parameters on the  fly).   "before_create"  returns  a
           true  or false value. If it returns "undef" and the trigger has been added as "abortable", the create
           is aborted.

       after_create
           When adding the "after_create" trigger, you can determine whether the trigger may cause an  abort  or
           not  by  passing  the "abortable" parameter to the "add_trigger" method. If this is not set, then the
           return value is ignored regardless.

             sub after_create {
                 my $self                    = shift;
                 my $insert_return_value_ref = shift;

                 return unless $$insert_return_value_ref;    # bail if insert failed
                 $self-&gt;load($$insert_return_value_ref);     # load ourselves from db

                 # Do whatever needs to be done here

                 return;   # aborts the create, possibly preventing a load
                 return 1; # continue normally
             }

           This method is called after attempting to insert the record into  the  database.  It  gets  handed  a
           reference   to   the   return  value  of  the  insert.  That  will  either  be  a  true  value  or  a
           Class::ReturnValue.

           Aborting the trigger merely causes "create" to return a  false  (undefined)  value  even  thought  he
           create may have succeeded. This prevents the loading of the record that would normally be returned.

   <b>delete</b>
       Delete  this record from the database. On failure return a Class::ReturnValue with the error. On success,
       return 1;

       This method has two hooks:

       before_delete
           This method  is  called  before  the  record  deletion,  if  it  exists.  On  failure  it  returns  a
           Class::ReturnValue with the error.  On success it returns 1.

           If  this method returns an error, it causes the delete to abort and return the return value from this
           hook.

       after_delete
           This method is called after deletion, with a reference to the return value from the delete operation.

   <b>table</b>
       This method returns this class's default table name. It uses Lingua::EN::Inflect to pluralize the class's
       name as we believe that class names for records should be in the  singular  and  table  names  should  be
       plural.

       If  your  class name is "My::App::Rhino", your table name will default to "rhinos". If your class name is
       "My::App::RhinoOctopus", your default table name will be "rhino_octopuses".  Not  perfect,  but  arguably
       correct.

   <b>collection_class</b>
       Returns  the  collection  class  which this record belongs to; override this to subclass.  If you haven't
       specified a collection class, this returns a best guess at the name of  the  collection  class  for  this
       collection.

       It  uses  a simple heuristic to determine the collection class name -- It appends "Collection" to its own
       name. If you want to name your records and collections differently, go right  ahead,  but  don't  say  we
       didn't warn you.

   <b>_guess_table_name</b>
       Guesses a table name based on the class's last part.

   <b>_handle</b>
       Returns or sets the current Jifty::DBI::Handle object

   <b>PRIVATE</b> <b>refers_to</b>
       used for the declarative syntax

   <b>is_distinct</b> <b>COLUMN_NAME,</b> <b>VALUE</b>
       Checks  to  see  if there is already a record in the database where COLUMN_NAME equals VALUE.  If no such
       record exists then the COLUMN_NAME and VALUE pair is considered distinct and it returns 1.  If a value is
       already present the test is considered to have failed and it returns a Class::ReturnValue with the error.

   <b>run_canonicalization_for_column</b> <b>column</b> <b>=&gt;</b> <b>'COLUMN',</b> <b>value</b> <b>=&gt;</b> <b>'VALUE'</b>
       Runs all canonicalizers for the specified column.

   <b>has_canonicalizer_for_column</b> <b>COLUMN</b>
       Returns true if COLUMN has a canonicalizer, otherwise returns undef.

   <b>run_validation_for_column</b> <b>column</b> <b>=&gt;</b> <b>'COLUMN',</b> <b>value</b> <b>=&gt;</b> <b>'VALUE'</b> <b>[extra</b> <b>=&gt;</b> <b>\@ARGS]</b>
       Runs all validators for the specified column.

   <b>has_validator_for_column</b> <b>COLUMN</b>
       Returns true if COLUMN has a validator, otherwise returns undef.

   <b>unload_value</b> <b>COLUMN</b>
       Purges the cached value of COLUMN from the object, forcing it to be fetched from the database  next  time
       it is queried.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jesse   Vincent   &lt;<a href="mailto:jesse@bestpractical.com">jesse@bestpractical.com</a>&gt;,  Alex  Vandiver  &lt;<a href="mailto:alexmv@bestpractical.com">alexmv@bestpractical.com</a>&gt;,  David  Glasser
       &lt;<a href="mailto:glasser@bestpractical.com">glasser@bestpractical.com</a>&gt;, Ruslan Zakirov &lt;<a href="mailto:ruslan.zakirov@gmail.com">ruslan.zakirov@gmail.com</a>&gt;

       Based on DBIx::SearchBuilder::Record, whose credits read:

        Jesse Vincent, &lt;<a href="mailto:jesse@fsck.com">jesse@fsck.com</a>&gt;
        Enhancements by Ivan Kohler, &lt;<a href="mailto:ivan-rt@420.am">ivan-rt@420.am</a>&gt;
        Docs by Matt Knopp &lt;<a href="mailto:mhat@netlag.com">mhat@netlag.com</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Jifty::DBI, Jifty::DBI::Handle, Jifty::DBI::Collection.

perl v5.34.0                                       2022-06-15                            <u>Jifty::DBI::<a href="../man3pm/Record.3pm.html">Record</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>