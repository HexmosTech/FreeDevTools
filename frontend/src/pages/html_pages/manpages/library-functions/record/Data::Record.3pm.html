<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Record - "split" on steroids</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-record-perl">libdata-record-perl_0.02-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Record - "split" on steroids

</pre><h4><b>VERSION</b></h4><pre>
       Version 0.02

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Regexp::Common;
         use Data::Record;
         my $record = Data::Record-&gt;new({
           split  =&gt; "\n",
           unless =&gt; $RE{quoted},
         });
         my @data = $record-&gt;records($data);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Sometimes we need data split into records and a simple split on the input record separator ($/) or some
       other value fails because the values we're splitting on may allowed in other parts of the data.  Perhaps
       they're quoted.  Perhaps they're embedded in other data which should not be split up.

       This module allows you to specify what you wish to split the data on, but also speficy an "unless"
       regular expression.  If the text in question matches the "unless" regex, it will not be split there.
       This allows us to do things like split on newlines unless newlines are embedded in quotes.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       Common usage:

        my $record = Data::Record-&gt;new({
           split  =&gt; qr/$split/,
           unless =&gt; qr/$unless/,
        });

       Advanced usage:

        my $record = Data::Record-&gt;new({
           split  =&gt; qr/$split/,
           unless =&gt; qr/$unless/,  # optional
           token  =&gt; $token,       # optional
           chomp  =&gt; 0,            # optional
           limit  =&gt; $limit,       # optional (do not use with trim)
           trim   =&gt; 1,            # optional (do not use with limit)
           fields =&gt; {
               split  =&gt; ',',
               unless =&gt; $RE{quoted}, # from Regexp::Common
           }
        });

       The constructor takes a hashref of key/value pairs to set the behavior of data records to be created.

       •   split

           This is the value to split the data on.  It may be either a regular expression or a string.

           Defaults to the current input record separator ($/).

       •   unless

           Data  will  be  split  into  records  matching the split value <u>unless</u> they also match this value.  No
           default.

           If you do not have an "unless" value, use of this module is overkill.

       •   token

           You will probably never need to set this value.

           Internally, this module attempts to find a token which does not match any text found in the  data  to
           be  split  and  also  does  not match the split value.  This is necessary because we mask the data we
           don't want to split using this token.  This allows us to split the resulting text.

           In the unlikely event that the module cannot find a token which is not in the text, you may  set  the
           token value yourself to some string value.  Do not set it to a regular expression.

       •   chomp

           By  default,  the  split  value is discarded (chomped) from each record.  Set this to a true value to
           keep the split value on each record.  This differs  slightly  from  how  it's  done  with  split  and
           capturing parentheses:

             split /(\,)/, '3,4,5';

           Ordinarily, this results in the following list:

            ( 3, ',', 4, ',', 5 )

           This  module assumes you want those values <u>with</u> the preceding record.  By setting chomp to false, you
           get the following list:

            ( '3,', '4,' 5 )

       •   limit

           The default split behavior is similar to this:

            split $split_regex, $data;

           Setting "limit" will cause the behavior to act like this:

            split $split_regex, $data, $limit

           See "perldoc -f split" for more information about the behavior of "limit".

           You may not set both "limit" and "trim" in the constructor.

       •   trim

           By default, we return all records.  This means that due to the nature of split and  how  we're  doing
           things,  we  sometimes  get a trailing null record.  However, setting this value causes the module to
           behave as if we had done this:

            split $split_regex, $data, 0;

           When "split" is called with a zero as the third argument, trailing null values  are  discarded.   See
           "perldoc -f split" for more information.

           You may not set both "limit" and "trim" in the constructor.

           <b>Note</b>:  This does <u>not</u> trim white space around returned records.

       •   fields

           By  default,  individual records are returned as strings.  If you set "fields", you pass in a hashref
           of arguments that are identical to what "new" would take and resulting records are returned as  array
           references processed by a new "Data::Record" instance.

           Example:  a quick CSV parser which assumes that commas and newlines may both be in quotes:

            # four lines, but there are only three records! (newline in quotes)
            $data = &lt;&lt;'END_DATA';
            1,2,"programmer, perl",4,5
            1,2,"programmer,
            perl",4,5
            1,2,3,4,5
            END_DATA

            $record = $RECORD-&gt;new({
                split  =&gt; "\n",
                unless =&gt; $quoted,
                trim   =&gt; 1,
                fields =&gt; {
                    split  =&gt; ",",
                    unless =&gt; $quoted,
                }
            });
            my @records = $record-&gt;records($data);
            foreach my $fields (@records) {
              foreach my $field = (@$fields);
                # do something
              }
            }

           Note that above example will not remove the quotes from individual fields.

   <b>split</b>
         my $split = $record-&gt;split;
         $record-&gt;split($on_value);

       Getter/setter for split value.  May be a regular expression or a scalar value.

   <b>unless</b>
        my $unless = $self-&gt;unless;
        $self-&gt;unless($is_value);

       Getter/setter for unless value.  May be a regular expression or a scalar value.

   <b>chomp</b>
         my $chomp = $record-&gt;chomp;
         $record-&gt;<a href="../man0/chomp.0.html">chomp</a>(0);

       Getter/setter for boolean chomp value.

   <b>limit</b>
         my $limit = $record-&gt;limit;
         $record-&gt;<a href="../man3/limit.3.html">limit</a>(3);

       Getter/setter for integer limit value.

   <b>trim</b>
         my $trim = $record-&gt;trim;
         $record-&gt;<a href="../man1/trim.1.html">trim</a>(1);

       Getter/setter  for  boolean  limit value.  Setting this value will cause any previous "limit" value to be
       overwritten.

   <b>token</b>
         my $token = $record-&gt;token;
         $record-&gt;token($string_not_found_in_text);

       Getter/setter for token value.  Token must be a string that does not match the split  value  and  is  not
       found in the text.

       You  can  return  the current token value if you have set it in your code.  If you rely on this module to
       create a token (this is the normal behavior), it is not available via  this  method  until  "records"  is
       called.

       Setting the token to an undefined value causes Data::Record to try and find a token itself.

       If the token matches the split value, this method will croak when you attempt to set the token.

       If the token is found in the data, the "records" method will croak when it is called.

   <b>records</b>
         my @records = $record-&gt;records($data);

       Returns @records for $data based upon current split criteria.

</pre><h4><b>BUGS</b></h4><pre>
       It's  possible  to  get erroneous results if the split value is "/\d+/".  I've tried to work around this.
       Please let me know if there is a problem.

</pre><h4><b>CAVEATS</b></h4><pre>
       This module must read <u>all</u> of the data at once.  This can make it slow for larger data sets.

</pre><h4><b>AUTHOR</b></h4><pre>
       Curtis "Ovid" Poe, "&lt;ovid [at] cpan [dot] org&gt;"

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to "<a href="mailto:bug-data-record@rt.cpan.org">bug-data-record@rt.cpan.org</a>", or through the web interface
       at &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=Data-Record&gt;.  I will be  notified,  and  then  you'll
       automatically be notified of progress on your bug as I make changes.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to the Monks for inspiration from &lt;<a href="http://perlmonks.org/index.pl">http://perlmonks.org/index.pl</a>?node_id=492002&gt;.

       0.02 Thanks to Smylers and Stefano Rodighiero for catching POD errors.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2005 Curtis "Ovid" Poe, all rights reserved.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-11-19                                  <u>Data::<a href="../man3pm/Record.3pm.html">Record</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>