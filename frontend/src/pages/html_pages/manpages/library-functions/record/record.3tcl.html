<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>struct::record - Define and create records (similar to 'C' structures)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       struct::record - Define and create records (similar to 'C' structures)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>struct::record</b> <b>?1.2.4?</b>

       <b>record</b> <b>define</b> <u>recordName</u> <u>recordMembers</u> ?<u>instanceName1</u> <u>instanceName2</u> <u>...</u>?

       <b>record</b> <b>show</b> <u>record</u>

       <b>record</b> <b>show</b> <u>instances</u> <u>recordName</u>

       <b>record</b> <b>show</b> <u>members</u> <u>recordName</u>

       <b>record</b> <b>show</b> <u>values</u> <u>instanceName</u>

       <b>record</b> <b>exists</b> <u>record</u> <u>recordName</u>

       <b>record</b> <b>exists</b> <u>instance</u> <u>instanceName</u>

       <b>record</b> <b>delete</b> <u>record</u> <u>recordName</u>

       <b>record</b> <b>delete</b> <u>instance</u> <u>instanceName</u>

       <u>instanceName</u> <b>cget</b> -<u>member</u>

       <u>instanceName</u> <b>cget</b> -<u>member1</u> -<u>member2</u>

       <u>instanceName</u> <b>cget</b>

       <u>instanceName</u> <b>configure</b>

       <u>instanceName</u>

       <u>instanceName</u> <b>configure</b> -<u>member</u> <u>value</u>

       <u>instanceName</u> <b>configure</b> -<u>member1</u> <u>value1</u> -<u>member2</u> <u>value2</u>

       <u>recordName</u> <u>instanceName</u>|<b>#auto</b> ?<u>-member1</u> <u>value1</u> <u>-member2</u> <u>value2</u> <u>...</u>?

       <u>instanceName</u> <b>cget</b> ?<u>-member1</u> <u>-member2</u> <u>...</u>?

       <u>instanceName</u> <b>configure</b> ?<u>-member1</u> <u>value1</u> <u>-member2</u> <u>value2</u> <u>...</u>?

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>::struct::record</b>  package  provides  a  mechanism to group variables together as one data structure,
       similar to a <u>C</u> structure. The members of a record can be variables or other records.  However,  a  record
       can not contain circular records, i.e. records that contain the same record as a member.

       This  package  was  structured  so that it is very similar to how Tk objects work. Each record definition
       creates a record object that encompasses that definition. Subsequently, that  record  object  can  create
       instances of that record. These instances can then be manipulated with the <b>cget</b> and <b>configure</b> methods.

       The  package only contains one top level command, but several sub commands (see below). It also obeys the
       namespace in which the record was defined, hence the objects returned are fully qualified.

       <b>record</b> <b>define</b> <u>recordName</u> <u>recordMembers</u> ?<u>instanceName1</u> <u>instanceName2</u> <u>...</u>?
              Defines a record. <u>recordName</u> is the name of the record, and is also used  as  an  object  command.
              This  object  command  is used to create instances of the record definition. The <u>recordMembers</u> are
              the members of the record that make up the  record  definition.  These  are  variables  and  other
              records.  If  optional  <u>instanceName</u>  args  are specified, then an instance is generated after the
              definition is created for each <u>instanceName</u>.

       <b>record</b> <b>show</b> <u>record</u>
              Returns a list of records that have been defined.

       <b>record</b> <b>show</b> <u>instances</u> <u>recordName</u>
              Returns the instances that have been instantiated by <u>recordName</u>.

       <b>record</b> <b>show</b> <u>members</u> <u>recordName</u>
              Returns the members that are defined for record <u>recordName</u>.  It returns the same format as how the
              records were defined.

       <b>record</b> <b>show</b> <u>values</u> <u>instanceName</u>
              Returns a list of values that are set for the instance <u>instanceName</u>.  The  output  is  a  list  of
              key/value pairs. If there are nested records, then the values of the nested records will itself be
              a list.

       <b>record</b> <b>exists</b> <u>record</u> <u>recordName</u>
              Tests for the existence of a <u>record</u> with the name <u>recordName</u>.

       <b>record</b> <b>exists</b> <u>instance</u> <u>instanceName</u>
              Tests for the existence of a <u>instance</u> with the name <u>instanceName</u>.

       <b>record</b> <b>delete</b> <u>record</u> <u>recordName</u>
              Deletes  <u>recordName</u>,  and all instances of <u>recordName</u>.  It will return an error if the record does
              not exist.

       <b>record</b> <b>delete</b> <u>instance</u> <u>instanceName</u>
              Deletes <u>instance</u> with the name of <u>instanceName</u>. It will return an error if the instance  does  not
              exist. Note that this recursively deletes any nested instances as well.

</pre><h4><b>RECORD</b> <b>MEMBERS</b></h4><pre>
       Record  members  can  either  be  variables, or other records, However, the same record can not be nested
       witin itself (circular). To define a nested record, you need to specify the  <b>record</b>  keyword,  along  the
       with  name  of the record, and the name of the instance of that nested record (within the container). For
       example, it would look like this:

              # this is the nested record
              record define mynestedrecord {
                  nest1
                  nest2
              }

              # This is the main record
              record define myrecord {
                  mem1
                  mem2
                  {record mynestedrecord mem3}
              }

       You can also assign default or initial values to the members of a record, by enclosing the  member  entry
       in braces:

              record define myrecord {
                  mem1
                  {mem2 5}
              }

       All  instances created from this record definition will initially have <b>5</b> as the value for member <u>mem2</u>. If
       no default is given, then the value will be the empty string.

   <b>GETTING</b> <b>VALUES</b>
       To get a value of a member, there are several ways to do this.

       <u>instanceName</u> <b>cget</b> -<u>member</u>
              In this form the built-in <b>cget</b> instance method returns the value of the specified <u>member</u>. Note the
              leading dash.

              To reach a nested member use <u>dot</u> <u>notation</u>:

              <u>instanceName</u> <b>cget</b> -mem3.nest1

       <u>instanceName</u> <b>cget</b> -<u>member1</u> -<u>member2</u>
              In this form the built-in <b>cget</b> instance method returns  a  list  containing  the  values  of  both
              specified members, in the order of specification.

       <u>instanceName</u> <b>cget</b>

       <u>instanceName</u> <b>configure</b>

       <u>instanceName</u>
              These forms are all equivalent. They return a dictionary of all members and the associated values.

   <b>SETTING</b> <b>VALUES</b>
       To set a value of a member, there are several ways to do this.

       <u>instanceName</u> <b>configure</b> -<u>member</u> <u>value</u>
              In  this form the built-in <b>configure</b> instance method sets the specified <u>member</u> to the given <u>value</u>.
              Note the leading dash.

              To reach a nested member use <u>dot</u> <u>notation</u>:

              <u>instanceName</u> <b>configure</b> -mem3.nest1 value

       <u>instanceName</u> <b>configure</b> -<u>member1</u> <u>value1</u> -<u>member2</u> <u>value2</u>
              In this form the built-in <b>configure</b> instance method sets all specified members to  the  associated
              values.

   <b>ALIAS</b> <b>ACCESS</b>
       In  the  original  implementation,  access was done by using dot notation similar to how <u>C</u> structures are
       accessed. However, there was a concensus to make the interface more Tcl like, which made sense.  However,
       the original alias access still exists. It might prove to be helpful to some.

       Basically, for every member of every instance, an alias is created. This alias is used  to  get  and  set
       values for that member.  An example will illustrate the point, using the above defined records:

              % # Create an instance first
              % myrecord inst1
              ::inst1

              % # To get a member of an instance, just use the alias. It behaves
              % # like a Tcl command:
              % inst1.mem1

              % # To set a member via the alias, just include a value. And optionally
              % # the equal sign - syntactic sugar.
              % inst1.mem1 = 5
              5

              % inst1.mem1
              5

              % # For nested records, just continue with the dot notation.
              % # note, no equal sign.
              % inst1.mem3.nest1 10
              10

              % inst1.mem3.nest1
              10

              % # just the instance by itself gives all member/values pairs for that
              % # instance
              % inst1
              -mem1 5 -mem2 {} -mem3 {-nest1 10 -nest2 {}}

              % # and to get all members within the nested record
              % inst1.mem3
              -nest1 10 -nest2 {}

</pre><h4><b>RECORD</b> <b>COMMAND</b></h4><pre>
       The following subcommands and corresponding arguments are available to any record command:

       <u>recordName</u> <u>instanceName</u>|<b>#auto</b> ?<u>-member1</u> <u>value1</u> <u>-member2</u> <u>value2</u> <u>...</u>?
              Using  the <u>recordName</u> object command that was created from the record definition, instances of the
              record definition can be created.  Once an instance is created, it inherits  the  members  of  the
              record  definition,  very  similar  to  how  objects  work.  During instance generation, an object
              command for the instance is created as well, using <u>instanceName</u>.

              This object command is used to access the data members of the instance.  During the instantiation,
              while values for that instance may be given, when done, <u>all</u> values must be given, and be given  as
              key/value pairs, like for method <b>configure</b>. Nested records have to be in list format.

              Optionally, <b>#auto</b> can be used in place of <u>instanceName</u>. When <b>#auto</b> is used, the instance name will
              be  automatically generated, and of the form <b>recordNameN</b>, where <b>N</b> is a unique integer (starting at
              0) that is generated.

</pre><h4><b>INSTANCE</b> <b>COMMAND</b></h4><pre>
       The following subcommands and corresponding arguments are available to any record instance command:

       <u>instanceName</u> <b>cget</b> ?<u>-member1</u> <u>-member2</u> <u>...</u>?
              Each instance has the method <b>cget</b>. This is very similar to how Tk widget's <b>cget</b> command works.  It
              queries  the values of the members for that particular instance. If no arguments are given, then a
              dictionary is returned.

       <u>instanceName</u> <b>configure</b> ?<u>-member1</u> <u>value1</u> <u>-member2</u> <u>value2</u> <u>...</u>?
              Each instance has the method <b>configure</b>. This is very similar to how Tk widget's <b>configure</b>  command
              works.  It sets the values of the particular members for that particular instance. If no arguments
              are given, then a dictionary list is returned.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Two examples are provided to give a good illustration on how to use this package.

   <b>EXAMPLE</b> <b>1</b> <b>-</b> <b>CONTACT</b> <b>INFORMATION</b>
       Probably the most obvious example would be to hold contact information, such as addresses, phone numbers,
       comments, etc. Since a person can have multiple phone numbers, multiple email addresses, etc, we will use
       nested records to define these. So, the first thing we do is define the nested records:

              ##
              ##  This is an interactive example, to see what is returned by
              ##  each command as well.
              ##

              % namespace import ::struct::record::*

              % # define a nested record. Notice that country has default 'USA'.
              % record define locations {
                  street
                  street2
                  city
                  state
                  zipcode
                  {country USA}
                  phone
              }
              ::locations
              % # Define the main record. Notice that it uses the location record twice.
              % record define contacts {
                  first
                  middle
                  last
                  {record locations home}
                  {record locations work}
              }
              ::contacts
              % # Create an instance for the contacts record.
              % contacts cont1
              ::cont1
              % # Display some introspection values
              % record show records
              ::contacts ::locations
              % #
              % record show values cont1
              -first {} -middle {} -last {} -home {-street {} -street2 {} -city {} -state {} -zipcode {} -country USA -phone {}} -work {-street {} -street2 {} -city {} -state {} -zipcode {} -country USA -phone {}}
              % #
              % record show instances contacts
              ::cont1
              % #
              % cont1 config
              -first {} -middle {} -last {} -home {-street {} -street2 {} -city {} -state {} -zipcode {} -country USA -phone {}} -work {-street {} -street2 {} -city {} -state {} -zipcode {} -country USA -phone {}}
              % #
              % cont1 cget
              -first {} -middle {} -last {} -home {-street {} -street2 {} -city {} -state {} -zipcode {} -country USA -phone {}} -work {-street {} -street2 {} -city {} -state {} -zipcode {} -country USA -phone {}}
              % # copy one record to another record
              % record define contacts2 [record show members contacts]
              ::contacts2
              % record show members contacts2
              first middle last {record locations home} {record locations work}
              % record show members contacts
              first middle last {record locations home} {record locations work}
              %

   <b>EXAMPLE</b> <b>2</b> <b>-</b> <b>LINKED</b> <b>LIST</b>
       This next example just illustrates a simple linked list

              % # define a very simple record for linked list
              % record define linkedlist {
                  value
                  next
              }
              ::linkedlist
              % linkedlist lstart
              ::lstart
              % lstart config -value 1 -next [linkedlist #auto]
              % [lstart cget -next] config -value 2 -next [linkedlist #auto]
              % [[lstart cget -next] cget -next] config -value 3 -next "end"
              % set next lstart
              lstart
              % while 1 {
                  lappend values [$next cget -value]
                  set next [$next cget -next]
                  if {[string match "end" $next]} break
              }
              % puts "$values"
              1 2 3
              % # cleanup linked list
              % # We could just use delete record linkedlist also
              % foreach I [record show instances linkedlist] {
                  record delete instance $I
              }
              % record show instances linkedlist
              %

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report     such     in     the     category     <u>struct</u>    <u>::</u>    <u>record</u>    of    the    <u>Tcllib</u>    <u>Trackers</u>
       [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please also report any ideas for enhancements you may  have  for
       either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       data structures, record, struct

</pre><h4><b>CATEGORY</b></h4><pre>
       Data structures

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2002, Brett Schwarz &lt;<a href="mailto:brett_schwarz@yahoo.com">brett_schwarz@yahoo.com</a>&gt;

tcllib                                                1.2.4                                 <u>struct::<a href="../man3tcl/record.3tcl.html">record</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>