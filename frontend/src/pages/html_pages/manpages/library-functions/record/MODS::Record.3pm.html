<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MODS::Record - Perl extension for handling MODS records</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmods-record-perl">libmods-record-perl_0.13-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MODS::Record - Perl extension for handling MODS records

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use MODS::Record qw(xml_string);
        use open qw(:utf8);

        my $mods = MODS::Record-&gt;new;

        my $collection = MODS::Collection-&gt;new;

        my $mods = $collection-&gt;add_mods(ID =&gt; '1234');

        $mods-&gt;add_abstract("Hello", lang =&gt; 'eng');
        $mods-&gt;add_abstract("Bonjour", lang =&gt; 'fra');

        # Set a deeply nested field...
        $mods-&gt;add_language()-&gt;add_languageTerm('eng');

        # Set a list of deeply nested fields...
        $mods-&gt;add_location(sub {
           $_[0]-&gt;add_physicalLocation('here');
           $_[0]-&gt;add_shelfLocator('here too');
           $_[0]-&gt;add_url('<a href="http://here.org/there">http://here.org/there</a>');
        });

        # Set an inline XML extension...
        $mods-&gt;add_accessCondition(xml_string("&lt;x:foo&gt;&lt;x:bar&gt;21212&lt;/x:bar&gt;&lt;/x:foo&gt;"));

        # Retrieve a field by a filter...
        $mods-&gt;get_abstract(lang =&gt; 'fra')-&gt;body("Bonjour :)");
        $mods-&gt;get_abstract(lang =&gt; 'fra')-&gt;contentType('text/plain');

        for ($mods-&gt;get_abstract(lang =&gt; 'fra')) {
           printf "%s\n" , $_-&gt;body;
        }

        # Set a field to a new value
        my @newabstract;
        for ($mods-&gt;get_abstract) {
           push @newabstract, $_ unless $_-&gt;lang eq 'fra';
        }
        $mods-&gt;set_abstract(@newabstract);

        # Clear all abstracts;
        $mods-&gt;set_abstract(undef);

        # Serialize
        print $mods-&gt;as_json(pretty =&gt; 1);
        print $mods-&gt;as_xml;

        # Deserialize
        my $mods = MODS::Record-&gt;from_xml(IO::File-&gt;new('mods.xml'));
        my $mods = MODS::Record-&gt;from_json(IO::File-&gt;new('mods.js'));

        my $count = MODS::Record-&gt;from_xml(IO::File-&gt;new('mods.xml'), sub {
           my $mods = shift;
           ...
        });

        my $count = MODS::Record-&gt;from_json(IO::File-&gt;new('mods.js'), sub {
           my $mods = shift;
           ...
        });

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides MODS (<a href="http://www.loc.gov/standards/mods/">http://www.loc.gov/standards/mods/</a>) parsing and creation for MODS Schema 3.5.

</pre><h4><b>METHODS</b></h4><pre>
   <b>MODS::Record-&gt;new(%attribs)</b>
   <b>MODS::Collection-&gt;new(%attribs)</b>
       Create a new MODS record or collection. Optionally attributes can be provided as defined by the MODS
       specification. E.g.

        $mods = MODS::Record-&gt;new(ID='123');

   <b>add_xxx()</b>
       Add a new element to the record where 'xxx' is the name of a MODS element (e.g. titleInfo, name, genre,
       etc).  This method returns an instance of the added MODS element. E.g.

        $titleInfo = $mods-&gt;add_titleInfo; # $titleInfo is a 'MODS::Element::TitleInfo'

   <b>add_xxx($text,%attribs)</b>
       Add a new element to the record where 'xxx' is the name of a MODS element. Set the text content of the
       element to $text and optionally provide further attributes. This method returns an instance of the added
       MODS element. E.g.

        $mods-&gt;add_abstract("My abstract", lang=&gt;'eng');

   <b>add_xxx(sub</b> <b>{</b> <b>})</b>
       Add a new element to the record where 'xxx' is the name of a MODS element. The provided coderef gets as
       input an instance of the added MODS element. This method returns an instance of the added MODS element.
       E.g.

        $mods-&gt;add_abstract(sub {
           my $o = shift;
           $o-&gt;body("My abstract");
           $o-&gt;lang("eng");
        })

   <b>add_xxx($obj)</b>
       Add a new element to the record where 'xxx' is the name of a MODS element. The $obj is an instance of a
       MODS::Element::Xxx class (where Xxx is the corresponding MODS element). This method returns an instance
       of the added MODS element. E.g.

        $mods-&gt;add_abstract(
            MODS::Element::Abstract-&gt;new(_body=&gt;'My abstract', lang=&gt;'eng')
        );

   <b>get_xxx()</b>
   <b>get_xxx(%filter)</b>
   <b>get_xxx(sub</b> <b>{</b> <b>})</b>
       Retrieve an element from the record where 'xxx' is the name of a MODS element. This methods return in
       array context all the matching elements or the first match in scalar context. Optionally provide a
       %filter or a coderef filter function.  E.g.

        @titles = $mods-&gt;get_titleInfo();
        $alt    = $mods-&gt;get_titleInfo(type=&gt;'alternate');
        $alt    = $mods-&gt;get_titleInfo(sub { shift-&gt;type eq 'alternate'});

   <b>set_xxxx()</b>
   <b>set_xxx(undef)</b>
   <b>set_xxx($array_ref)</b>
   <b>set_xxx($xxx1,$xxx2,...)</b>
       Set an element of the record to a new value where 'xxx' is the name of a MODS element. When no arguments
       are provided, then this is a null operation. When undef als argument is provided, then the element is
       deleted. To overwrite the existing content of the element an ARRAY (ref) of MODS::Element::Xxx can be
       provided (where 'Xxx' is the corresponding MODS element). E.g.

        # Delete all abstracts
        $mods-&gt;set_abstract(undef);

        # Set all abstracts
        $mods-&gt;set_abstract(MODS::Element::Abstract-&gt;new(), MODS::Element::Abstract-&gt;new(), ...);
        $mods-&gt;set_abstract([ MODS::Element::Abstract-&gt;new(), MODS::Element::Abstract-&gt;new(), ... ]);

   <b>as_xml()</b>
   <b>as_xml(xml_prolog=&gt;1)</b>
       Return the record as XML.

   <b>from_xml($string</b> <b>[,</b> <b>$callback])</b>
   <b>from_xml(IO::Handle</b> <b>[,</b> <b>$callback])</b>
       Parse an XML string or IO::Handle into a MODS::Record. This method return the parsed JSON.

       If a callback function is provided then for each MODS element in the XML stream the callback will be
       called.  The method returns the number of parsed MODS elements.

        E.g.
           my $mods = MODS::Record-&gt;from_xml( IO::File-&gt;new(...) );

           my $count = MODS::Record-&gt;from_xml( IO::File-&gt;new(...) , sub {
               my $mods = shift;
           } );

   <b>as_json()</b>
   <b>as_json(pretty=&gt;1)</b>
       Return the record as JSON string.

   <b>from_json($string</b> <b>[,</b> <b>$callback])</b>
   <b>from_json(IO::Handle</b> <b>[,</b> <b>$callback])</b>
       Parse and JSON string or JSON::Handle into a MODS::Record. This method return the parsed JSON.

       If a callback function is provided then we expect as input a stream of JSON strings (each line one JSON
       string). For each MODS object in the JSON stream the callback will be called.  The method returns the
       number of parsed strings.

        E.g.
           my $mods = MODS::Record-&gt;from_json( IO::File-&gt;new(...) );

           my $count = MODS::Record-&gt;from_json( IO::File-&gt;new(...) , sub {
               my $mods = shift;
           } );

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   Library Of Congress MODS pages (<a href="http://www.loc.gov/standards/mods/">http://www.loc.gov/standards/mods/</a>)

</pre><h4><b>DESIGN</b> <b>NOTES</b></h4><pre>
       •   I'm not a MODS expert

       •   I needed a MODS module to parse and create MODS records for our institutional repository

       •   This module is part of the LibreCat/Catmandu project <a href="http://librecat.org">http://librecat.org</a>

       •   This module is not created for speed

       •   This  module doesn't have any notion of ordering of MODS elements themselves (e.g. first 'titleInfo',
           then 'name').  But each sub-element keeps its original order (e.g. each 'title' in 'titleInfo').

       •   Heiko Jansen provides at GitHub a Moose-based MODS parser https://github.com/heikojansen/MODS--Record

</pre><h4><b>AUTHOR</b></h4><pre>
       Patrick Hochstenbach &lt;Patrick.Hochstenbach at UGent.be&gt;

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       This program is free software; you can redistribute it and/or modify it under the terms  of  either:  the
       GNU General Public License as published by the Free Software Foundation; or the Artistic License.

       See &lt;<a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a>&gt; for more information.

perl v5.36.0                                       2022-11-29                                  <u>MODS::<a href="../man3pm/Record.3pm.html">Record</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>