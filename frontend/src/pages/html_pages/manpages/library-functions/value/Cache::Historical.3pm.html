<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cache::Historical - Cache historical values</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcache-historical-perl">libcache-historical-perl_0.05-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Cache::Historical - Cache historical values

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Cache::Historical;

           my $cache = Cache::Historical-&gt;new();

              # Set a key's value on a specific date
           $cache-&gt;set( $dt, $key, $value );

              # Get a key's value on a specific date
           my $value = $cache-&gt;get( $dt, $key );

              # Same as 'get', but if we don't have a value at $dt, but we
              # do have values for dates &lt; $dt, return the previous
              # historic value.
           $cache-&gt;get_interpolated( $dt, $key );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Cache::Historical caches historical values by key and date. If you have something like historical stock
       quotes, for example

           2008-01-02 msft 35.22
           2008-01-03 msft 35.37
           2008-01-04 msft 34.38
           2008-01-07 msft 34.61

       then you can store them in Cache::Historical like

           my $cache = Cache::Historical-&gt;new();

           my $fmt = DateTime::Format::Strptime-&gt;new(
                         pattern =&gt; "%Y-%m-%d");

           $cache-&gt;set( $fmt-&gt;parse_datetime("2008-01-02"), "msft", 35.22 );
           $cache-&gt;set( $fmt-&gt;parse_datetime("2008-01-03"), "msft", 35.37 );
           $cache-&gt;set( $fmt-&gt;parse_datetime("2008-01-04"), "msft", 34.38 );
           $cache-&gt;set( $fmt-&gt;parse_datetime("2008-01-07"), "msft", 34.61 );

       and retrieve them later by date:

           my $dt = $fmt-&gt;parse_datetime("2008-01-03");

             # Returns 35.37
           my $value = $cache-&gt;get( $dt, "msft" );

       Even if there's no value available for a given date, but there are historical values that predate the
       requested date, "get_interpolated()" will return the next best historical value:

           my $dt = $fmt-&gt;parse_datetime("2008-01-06");

             # Returns undef, no value available for 2008-01-06
           my $value = $cache-&gt;get( $dt, "msft" );

             # Returns 34.48, the value for 2008-01-04, instead.
           $value = $cache-&gt;get_interpolated( $dt, "msft" );

   <b>Methods</b>
       <b>new()</b>
           Creates the object. Takes the SQLite file to put the date into as an additional parameter:

               my $cache = Cache::Historical-&gt;new(
                   sqlite_file =&gt; "/tmp/mydata.dat",
               );

           The SQLite file defaults to

               $HOME/.cache-historical/cache-historical.dat

           so if you have multiple caches, you need to use different SQLite files.

       <b>time_range()</b>
                  # List the time range for which we have values for $key
               my($from, $to) = $cache-&gt;time_range( $key );

       <b>keys()</b>
                  # List all keys
               my @keys = $cache-&gt;keys();

       <b>values()</b>
                  # List all the values we have for $key, sorted by date
                  # ([$dt, $value], [$dt, $value], ...)
               my @results = $cache-&gt;values( $key );

       <b>clear()</b>
                  # Remove all values for a specific key
               $cache-&gt;clear( $key );

                  # Clear the entire cache
               $cache-&gt;clear();

       <b>last_update()</b>
                  # Return a DateTime object of the last update of a given key
               my $when = $cache-&gt;last_update( $key );

       <b>since_last_update()</b>
                  # Return a DateTime::Duration object since the time of the last
                  # update of a given key.
               my $since = $cache-&gt;since_last_update( $key );

</pre><h4><b>LEGALESE</b></h4><pre>
       Copyright  2007-2011  by  Mike  Schilli,  all  rights  reserved.   This program is free software, you can
       redistribute it and/or modify it under the same terms as Perl itself.

</pre><h4><b>AUTHOR</b></h4><pre>
       2007, Mike Schilli &lt;<a href="mailto:cpan@perlmeister.com">cpan@perlmeister.com</a>&gt;

perl v5.36.0                                       2022-12-10                                    <u><a href="../man3pm/Historical.3pm.html">Historical</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>