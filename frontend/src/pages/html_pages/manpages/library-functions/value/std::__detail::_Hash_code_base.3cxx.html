<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::__detail::_Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache_hash_code ></title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libstdc++-9-doc">libstdc++-9-doc_9.5.0-1ubuntu1~22.04_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::__detail::_Hash_code_base&lt; _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache_hash_code &gt;

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Inherited by <b>std::__detail::_Hashtable_base&lt;</b> <b>_Value,</b> <b>hash&lt;</b> <b>_Value</b> <b>&gt;,</b> <b>allocator&lt;</b> <b>_Value</b> <b>&gt;,</b> <b>_Equal,</b> <b>_H1,</b>
       <b>_H2,</b> <b>_Hash,</b> <b>_Traits</b> <b>&gt;</b>.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Key,</b> <b>typename</b> <b>_Value,</b> <b>typename</b> <b>_ExtractKey,</b> <b>typename</b> <b>_H1,</b> <b>typename</b> <b>_H2,</b> <b>typename</b> <b>_Hash,</b>
       <b>bool</b> <b>__cache_hash_code&gt;</b>
       struct std::__detail::_Hash_code_base&lt; _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache_hash_code &gt;"
       Primary class template _Hash_code_base.

       Encapsulates two policy issues that aren't quite orthogonal. (1) the difference between using a ranged
       hash function and using the combination of a hash function and a range-hashing function. In the former
       case we don't have such things as hash codes, so we have a dummy type as placeholder. (2) Whether or not
       we cache hash codes. Caching hash codes is meaningless if we have a ranged hash function.

       We also put the key extraction objects here, for convenience. Each specialization derives from one or
       more of the template parameters to benefit from Ebo. This is important as this type is inherited in some
       cases by the _Local_iterator_base type used to implement local_iterator and const_local_iterator. As with
       any iterator type we prefer to make it as small as possible.

       Primary template is unused except as a hook for specializations.

       Definition at line 1169 of file hashtable_policy.h.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

libstdc++                                        Tue Jul 1<u>std::</u><b>__</b><u>detail::_Hash_c...sh,</u> <b>__</b><u>cache_hash_code</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>