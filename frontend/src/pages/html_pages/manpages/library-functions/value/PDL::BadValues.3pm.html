<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::BadValues - Discussion of bad value support in PDL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/pdl">pdl_2.100-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::BadValues - Discussion of bad value support in PDL

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>What</b> <b>are</b> <b>bad</b> <b>values</b> <b>and</b> <b>why</b> <b>should</b> <b>I</b> <b>bother</b> <b>with</b> <b>them?</b>
       Sometimes it's useful to be able to specify a certain value is 'bad' or 'missing'; for example CCDs used
       in astronomy produce 2D images which are not perfect since certain areas contain invalid data due to
       imperfections in the detector.  Whilst PDL's powerful index routines and all the complicated business
       with dataflow, slices, etc etc mean that these regions can be ignored in processing, it's awkward to do.
       It would be much easier to be able to say "$c = $x + $y" and leave all the hassle to the computer.

       If you're not interested in this, then you may (rightly) be concerned with how this affects the speed of
       PDL, since the overhead of checking for a bad value at each operation can be large.  Because of this, the
       code has been written to be as fast as possible - particularly when operating on ndarrays which do not
       contain bad values.  In fact, you should notice essentially no speed difference when working with
       ndarrays which do not contain bad values.

       You may also ask 'well, my computer supports IEEE NaN, so I already have this'.  They are different
       things; a bad value signifies "leave this out of processing", whereas NaN is the result of a
       mathematically-invalid operation.

       Many routines, such as "y=sin(x)", will propagate NaN's without the user having to code differently, but
       routines such as "qsort", or finding the median of an array, need to be re-coded to handle bad values.
       For floating-point datatypes, "NaN" and "Inf" can be used to flag bad values, but by default special
       values are used (Default bad values).

       There is one default bad value for each datatype, but as of PDL 2.040, you can have different bad values
       for separate ndarrays of the same type.

       You can use "NaN" as the bad value for any floating-point type, including complex.

   <b>A</b> <b>quick</b> <b>overview</b>
        pdl&gt; $x = sequence(4,3);
        pdl&gt; p $x
        [
         [ 0  1  2  3]
         [ 4  5  6  7]
         [ 8  9 10 11]
        ]
        pdl&gt; $x = $x-&gt;setbadif( $x % 3 == 2 )
        pdl&gt; p $x
        [
         [  0   1 BAD   3]
         [  4 BAD   6   7]
         [BAD   9  10 BAD]
        ]
        pdl&gt; $x *= 3
        pdl&gt; p $x
        [
         [  0   3 BAD   9]
         [ 12 BAD  18  21]
         [BAD  27  30 BAD]
        ]
        pdl&gt; p $x-&gt;sum
        120

       "demo bad" within perldl gives a demonstration of some of the things possible with bad values.  These are
       also available on PDL's web-site, at <u><a href="http://pdl.perl.org/demos/">http://pdl.perl.org/demos/</a></u>.  See PDL::Bad for useful routines for
       working with bad values and <u>t/bad.t</u> to see them in action.

       To find out if a routine supports bad values, use the "badinfo" command in perldl or the "-b" option to
       pdldoc.

       Each ndarray contains a flag - accessible via "$pdl-&gt;badflag" - to say whether there's any bad data
       present:

       •   If  <b>false/0</b>, which means there's no bad data here, the code supplied by the "Code" option to pp_def()
           is executed.

       •   If <b>true/1</b>, then this says there <u>MAY</u> be bad data in the ndarray, so use  the  code  in  the  "BadCode"
           option (assuming that the pp_def() for this routine has been updated to have a BadCode key).  You get
           all  the  advantages of broadcasting, as with the "Code" option, but it will run slower since you are
           going to have to handle the presence of bad values.

       If  you  create  an  ndarray,  it  will  have  its  bad-value  flag  set  to  0.  To  change  this,   use
       "$pdl-&gt;badflag($new_bad_status)",  where  $new_bad_status  can  be  0  or  1.   When a routine creates an
       ndarray, its bad-value flag will depend on the input ndarrays: the bad-value flag will be set true if any
       of the input ndarrays have the bad-value flag.  To check that an ndarray really contains  bad  data,  use
       the "check_badflag" method.

       <u>NOTE</u>: propagation of the badflag

       If you change the badflag of an ndarray, this change is propagated to all the <u>children</u> of an ndarray, so

          pdl&gt; $x = zeroes(20,30);
          pdl&gt; $y = $x-&gt;slice('0:10,0:10');
          pdl&gt; $c = $y-&gt;slice(',(2)');
          pdl&gt; print "&gt;&gt;c: ", $c-&gt;badflag, "\n";
          &gt;&gt;c: 0
          pdl&gt; $x-&gt;<a href="../man1/badflag.1.html">badflag</a>(1);
          pdl&gt; print "&gt;&gt;c: ", $c-&gt;badflag, "\n";
          &gt;&gt;c: 1

       This is also propagated to the parents of an ndarray, so

          pdl&gt; print "&gt;&gt;a: ", $x-&gt;badflag, "\n";
          &gt;&gt;a: 1
          pdl&gt; $c-&gt;<a href="../man0/badflag.0.html">badflag</a>(0);
          pdl&gt; print "&gt;&gt;a: ", $x-&gt;badflag, "\n";
          &gt;&gt;a: 0

       There's  also the issue of what happens if you change the badvalue of an ndarray - should these propagate
       to children/parents (yes) or whether you should only be able to change the badvalue at the 'top' level  -
       i.e. those ndarrays which do not have parents.

       The  orig_badvalue()  method  returns  the compile-time value for a given datatype. It works on ndarrays,
       PDL::Type objects, and numbers - eg

         $pdl-&gt;orig_badvalue(), byte-&gt;orig_badvalue(), and <a href="../man4/orig_badvalue.4.html">orig_badvalue</a>(4).

       To get the current bad value, use the badvalue() method - it has the same syntax as orig_badvalue().

       To change the current bad value, supply the new number to badvalue - eg

         $pdl-&gt;badvalue(2.3), byte-&gt;<a href="../man2/badvalue.2.html">badvalue</a>(2), badvalue(5,-3e34).

       <u>Note</u>: the value is silently converted to the correct C type, and returned  -  i.e.  "byte-&gt;badvalue(-26)"
       returns 230 on my Linux machine.

       Note  that  changes  to the bad value are <u>NOT</u> propagated to previously-created ndarrays - they will still
       have the bad flag set, but suddenly the elements that were bad will become 'good', but containing the old
       bad value.  See discussion below.

   <b>Bad</b> <b>values</b> <b>and</b> <b>boolean</b> <b>operators</b>
       For those boolean operators in PDL::Ops, evaluation on a bad value returns the bad value. This:

        $mask = $img &gt; $thresh;

       correctly propagates bad values. This will omit any bad values, but return a bad value if  there  are  no
       good ones:

        $bool = any( $img &gt; $thresh );

       As of 2.077, a bad value used as a boolean will throw an exception.

       When using one of the 'projection' functions in PDL::Ufunc - such as orover - bad values are skipped over
       (see  the  documentation  of  these  functions for the current handling of the case when all elements are
       bad).

</pre><h4><b>IMPLEMENTATION</b> <b>DETAILS</b></h4><pre>
       A new flag has been added to the state of an ndarray - "PDL_BADVAL". If unset, then the ndarray does  not
       contain  bad  values,  and so all the support code can be ignored. If set, it does not guarantee that bad
       values are present, just that they should be checked for.

       The "pdl_trans" structure has been extended to include an integer value,  "bvalflag",  which  acts  as  a
       switch  to  tell  the  code  whether  to  handle bad values or not. This value is set if any of the input
       ndarrays  have  their  "PDL_BADVAL"  flag  set  (although  this  code  can   be   replaced   by   setting
       "FindBadStateCode" in pp_def).

       The per-ndarray badvalue is a "PDL_Anyval", a struct with an integer-valued type (like an ndarray), and a
       union-value  that can hold one of any value that PDL can handle. As of 2.086, this value must always have
       the same type as the ndarray, and this is enforced in the PDL core.

   <b>Default</b> <b>bad</b> <b>values</b>
       The default bad values are now stored in a structure within the Core  PDL  structure  -  "PDL.bvals"  (eg
       <u>lib/PDL/Core/pdlcore.h</u>);  see  also  "typedef  pdl_badvals" in <u>lib/PDL/Core/pdl.h.PL</u> and the BOOT code of
       <u>lib/PDL/Core.xs</u> where the values are initialised to  (hopefully)  sensible  values.   See  "badvalue"  in
       PDL::Bad and "orig_badvalue" in PDL::Bad for read/write routines to the values.

       The  default/original  bad  values  are  set  to  the C type's maximum (unsigned integers) or the minimum
       (floating-point and signed integers).

   <b>How</b> <b>do</b> <b>I</b> <b>change</b> <b>a</b> <b>routine</b> <b>to</b> <b>handle</b> <b>bad</b> <b>values?</b>
       See "BadCode" in PDL::PP and "HandleBad" in PDL::PP.

       If you have a routine that you want to be able to use as in-place, look at the  routines  in  <u>bad.pd</u>  (or
       <u>ops.pd</u>)  which  use  the  "in-place"  option  to see how the bad flag is propagated to children using the
       "xxxBadStatusCode" options.  I decided not to automate this as rules would be a little complex, since not
       every in-place op will need to propagate the badflag (eg unary functions).

       This all means that you can change (as of 2.073)

          Code =&gt; '$a() = $b() + $c();'

       to

          Code =&gt; 'PDL_IF_BAD(if ( $ISBAD(b()) || $ISBAD(c()) ) {
                        $SETBAD(a());
                      } else,) {
                        $a() = $b() + $c();
                      }'

       which means you only need to maintain the logic in one place, rather than having  a  separate  "BadCode".
       "PDL_IF_BAD"  evaluates  to  its  first  argument  if  the "badvalue" flag is true, or its second if not.
       PDL::PP::PDLCode will then create code something like

          if ( __trans-&gt;bvalflag ) {
               broadcastloop over Code with PDL_IF_BAD set appropriately
          } else {
               broadcastloop over Code with PDL_IF_BAD set appropriately
          }

</pre><h4><b>WHAT</b> <b>ABOUT</b> <b>DOCUMENTATION?</b></h4><pre>
       One of the strengths of PDL is its on-line documentation. The aim  is  to  use  this  system  to  provide
       information  on how/if a routine supports bad values: in many cases pp_def() contains all the information
       anyway, so the function-writer doesn't need to do anything at  all!  For  the  cases  when  this  is  not
       sufficient,  there's  the  "BadDoc" option. For code written at the Perl level - i.e. in a .pm file - use
       the "=for bad" pod directive.

       This information will be available via man/pod2man/html documentation.  It's  also  accessible  from  the
       "perldl" shell - using the "badinfo" command - and the "pdldoc" shell command - using the "-b" option.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) Doug Burke (<a href="mailto:djburke@cpan.org">djburke@cpan.org</a>), 2000, 2006.

       The per-ndarray bad value support is by Heiko Klein (2006).

perl v5.40.1                                       2025-03-27                                <u>PDL::<a href="../man3pm/BadValues.3pm.html">BadValues</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>