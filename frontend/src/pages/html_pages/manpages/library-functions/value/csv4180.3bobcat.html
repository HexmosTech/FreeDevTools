<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::CSV4180 - Converter for comma separated values</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::CSV4180 - Converter for comma separated values

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/csv&gt;</b>

       Linking option: <u>-lbobcat</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Objects  of  the  class <b>CSV4180</b> can be used to convert series of comma separated values to the individual
       separated   values   (also   called   `fields’   below).   The   class   implements   RFC    4180    (cf.
       https://www.ietf.org/rfc/rfc4180.txt, section 2).

       According  to  RFC  4180  lines  contain  comma  separated values: comma separated values on one line are
       processed together, as a series of values. The final comma separated value on a line is not  ended  by  a
       comma.

       Comma  separated  values  may  be surrounded by double quotes. However, they <u>must</u> be surrounded by double
       quotes in these cases:

       o      if the values contain commas;

       o      if the values contain double quotes (in which case the double quote is `escaped’ by  doubling  it,
              e.g., <u>"a</u> <u>""</u> <u>double</u> <u>quote"</u>);

       o      if the values extend over multiple lines. E.g.,

              "First line
              second line"

       Comma separated values may be empty: the following line defines three empty comma separated values:

       ,,

       The  first  empty  value  starts  at  the beginning of the line, and continues up to the first comma; the
       second empty value starts beyond the first comma and continues up to the second comma;  the  third  empty
       value  starts beyond the second comma, and continues up to the end of the line. If the line ends in blank
       space characters then the third value isn’t empty, but contains those blank space characters.

       By default, values are interpreted as strings.  The  <b>CSV4180</b>  class  also  offers  facilities  to  ignore
       specific fields, or to ensure that they can be converted to integral or floating point values. The second
       constructor (below) expects a <u>std::string</u> argument defining how to interpret fields. Options are:

       o      <u>I</u>:  the field must be convertible to an integral value;

       o      <u>D</u>:  the field must be convertible to a floating point value;

       o      <u>S</u>:  the field is a string: it is used as-is;

       o      <u>X</u>:   the  field  is omitted from the final set of comma separated values. I.e., if a line contains
              three comma separated values, and the specification <u>"SXS"</u> is used then this results in  two  comma
              separated values: the first and third value of three comma separated values encountered on lines.

       o      <u>-</u>:  synonym of <u>X</u>.

       In addition, field specifications may contain blank spaces, which are ignored. The values must consist of
       standard ascii characters (e.g., UTF-8 formatted values are not recognized).

       When  processing  comma separated values the first line may be considered a <u>header</u> line. <u>X</u> specifications
       also apply to header lines, but otherwise they  merely  consist  of  <u>S</u>-type  fields.  In  addition,  when
       processing multiple input lines all non-header lines are made available in a vector of vectors of fields,
       whereas the header line itself can be accessed via a dedicated member (<u>header()</u>).

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All  constructors,  members,  operators  and manipulators, mentioned in this man-page, are defined in the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       -

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       o      <b>explicit</b> <b>CSV4180(size_t</b> <b>nFields</b> <b>=</b> <b>0,</b> <b>bool</b> <b>header</b> <b>=</b> <b>false,</b> <b>char</b> <b>fieldSep</b> <b>=</b> <b>’,’)</b>:
              The first parameter specifies the number of fields that must be present on input lines. When using
              the default value the number of fields encountered on the first  line  determines  the  number  of
              fields  that  must  be present on subsequent lines. If the second parameter is <u>true</u> then the first
              line is interpreted as the header line. The third parameter specifies the character separating the
              fields. By default it’s a comma, but sometimes (not part of the  RFC)  a  semicolon  is  used.  By
              specifying <u>fieldSep</u> any character other than a comma can be used as field separator.

       o      <b>explicit</b> <b>CSV4180(std::string</b> <b>const</b> <b>&amp;specs,</b> <b>bool</b> <b>header</b> <b>=</b> <b>false,</b> <b>char</b> <b>fieldSep</b> <b>=</b> <b>’,’)</b>:
              The  first  parameter  defines  the number and types of the comma separated values on input lines.
              Specifications can be

              o      <u>D</u>: the field must be convertible to a floating point value;

              o      <u>I</u>: the field must be convertible to an integral value;

              o      <u>S</u>: the field is left as-is, and can be retrieved as a <u>std::string</u>.

              o      <u>X</u> or <u>-</u>: the field is ignored and is not stored inside the <b>CSV4180</b> object.

              o      blank space characters are ignored.
       An exception is thrown when encountering other than the abovementioned characters are encountered.

              If <u>I</u> or <u>D</u> fields cannot be properly converted, or if a line contains too few  or  too  many  comma
              separated values the input stream’s fail status is set.

              The last two parameters are interpreted as the last two parameters of the previous constructor.

              Copy and move constructors (and assignment operators) are available.

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
       o      <b>std::istream</b> <b>&amp;operator&gt;&gt;(std::istream</b> <b>&amp;in,</b> <b>CSV4180</b> <b>&amp;csv)</b>:
              One  line  of text is extracted from <u>in</u> and processed by the <u>csv</u> object. The <u>csv</u> object may or may
              not already contain converted comma separated values. When empty,  the  first  line  is  processed
              according  to  the  specifications provided to the <u>csv</u> object at construction time. Otherwise, the
              comma separated values on extracted lines must match the  number  and  types  of  the  fields,  as
              specified  by  the <u>csv</u> object. When input lines do not match these specifications <u>in’s</u> fail status
              is set.

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       o      <b>void</b> <b>clear(size_t</b> <b>nFields</b> <b>=</b> <b>0)</b>:
              The internally stored data (referred to by the <u>data,</u> <u>header,</u> and <u>lastLine</u> members) are erased.  By
              default,  the  required  number of CSV fields is reset to 0, but can be set to a specific value by
              specifying a value for its <u>nFields</u> parameter.

       o      <b>std::vector&lt;std::vector&lt;std::string&gt;&gt;</b> <b>const</b> <b>&amp;data()</b> <b>const</b>:
              A reference to the vector of vectors of fields stored inside the <b>CSV4180</b> object is  returned.  The
              vector returned by <u>data</u> does not contain the header line. If a header line was requested it can be
              retrieved from the <u>header()</u> member.

       o      <b>std::vector&lt;std::string&gt;</b> <b>const</b> <b>&amp;header()</b> <b>const</b>:
              If  the  constructor’s  <u>header</u> parameter was specified as <u>true</u> then this member returns the fields
              encountered on the first line that was processed by the <u>read1</u> member. Otherwise, <u>header</u> returns  a
              reference to an empty vector.

       o      <b>std::string</b> <b>const</b> <b>&amp;lastLine()</b> <b>const</b>:
              A  reference  to  the last line that was successfully extracted from the input stream by the <u>read1</u>
              member is returned. So once the lines containing the comma separated values have  been  processed,
              the next line on the input stream can be obtained from this member.

       o      <b>size_t</b> <b>nValues()</b> <b>const</b>:
              After  successfully  calling  <u>read1</u>  for the first time this member returns the required number of
              comma separated values that must be encountered on subsequent input lines.

       o      <b>size_t</b> <b>read(std::istream</b> <b>&amp;in,</b> <b>size_t</b> <b>nLines</b> <b>=</b> <b>0)</b>:
              By default, all lines of <u>in</u> are read and are processed  by  the  <u>read1</u>  member.  By  specifying  a
              non-zero  value  for  the <u>nLines</u> parameter the specified number of lines is read from <u>in</u>.  Reading
              stops once <u>in’s</u> status is not <u>good</u>. When <u>nLines</u> is specified as zero, then <u>in’s</u> status  flags  are
              cleared. The number of successfully processed lines is returned.

       o      <b>std::istream</b> <b>&amp;read1(std::istream</b> <b>&amp;in)</b>:
              One line is read from <u>in</u> and is parsed for its comma separated values. If parsing fails, <u>in’s</u> <u>fail</u>
              status  is  set.  After successfully calling <u>read1</u> for the first time all subsequent lines read by
              <u>read1</u> must have the same number of comma separated values as encountered when  calling  <u>read1</u>  for
              the  first  time. The parsed fields are stored in a vector of <u>std::string</u> objects, and that vector
              is added to the vector of vectors of strings that is returned by the <u>data</u> member.

       o      <b>std::vector&lt;std::vector&lt;std::string&gt;&gt;</b> <b>release()</b>:
              The vector of vectors of fields stored inside  the  <b>CSV4180</b>  object  is  returned.  After  calling
              <u>release</u>  the  internally  stored  vector of fields is empty.  The vector returned by <u>data</u> does not
              contain the header line. If a header line was requested it can  be  retrieved  from  the  <u>header()</u>
              member.  Note  that  this  member  does  not  reset the number of expected fields for subsequently
              processed CSV-lines. If that’s what you want, call <u>clear</u> after calling <u>release</u>.

</pre><h4><b>EXAMPLE</b></h4><pre>
       #include &lt;iostream&gt;

       #include &lt;bobcat/csv4180&gt;

       using namespace std;
       using namespace FBB;

       int main(int argc, char **argv)
       {

           CSV4180 csv;                    // this processes ’input’

           size_t nLines = csv.read(cin);

           cerr &lt;&lt; nLines &lt;&lt; " lines were read\n";
           if (not csv.header().empty())
           {
               cerr &lt;&lt; "header: " &lt;&lt; ’\n’;
               for (auto const &amp;field: csv.header())
                   cerr &lt;&lt; "   `" &lt;&lt; field &lt;&lt; "’\n";
           }

           cerr &lt;&lt; "# CSV values: " &lt;&lt; csv.nValues() &lt;&lt; ’\n’;
           for (auto const &amp;line: csv.data())
           {
               cerr &lt;&lt; "Line:\n";
               for (auto const &amp;entry: line)
                   cerr &lt;&lt; "   `" &lt;&lt; entry &lt;&lt; "’\n";
           }
       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/csv</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7)

</pre><h4><b>BUGS</b></h4><pre>
       None Reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>: debian package containing the static library, headers, manual pages, and  developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                              <u>FBB::<a href="../man3bobcat/CSV4180.3bobcat.html">CSV4180</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>