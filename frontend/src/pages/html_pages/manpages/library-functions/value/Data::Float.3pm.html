<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Float - details of the floating point data type</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-float-perl">libdata-float-perl_0.015-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Float - details of the floating point data type

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Data::Float qw(have_signed_zero);

           if(have_signed_zero) { ...

           # and many other constants; see text

           use Data::Float qw(
               float_class float_is_normal float_is_subnormal
               float_is_nzfinite float_is_zero float_is_finite
               float_is_infinite float_is_nan);

           $class = float_class($value);

           if(float_is_normal($value)) { ...
           if(float_is_subnormal($value)) { ...
           if(float_is_nzfinite($value)) { ...
           if(float_is_zero($value)) { ...
           if(float_is_finite($value)) { ...
           if(float_is_infinite($value)) { ...
           if(float_is_nan($value)) { ...

           use Data::Float qw(float_sign signbit float_parts);

           $sign = float_sign($value);
           $sign_bit = signbit($value);
           ($sign, $exponent, $significand) = float_parts($value);

           use Data::Float qw(float_hex hex_float);

           print float_hex($value);
           $value = hex_float($string);

           use Data::Float qw(float_id_cmp totalorder);

           @sorted_floats = sort { float_id_cmp($a, $b) } @floats;
           if(totalorder($a, $b)) { ...

           use Data::Float qw(
               pow2 mult_pow2 copysign nextup nextdown nextafter);

           $x = pow2($exp);
           $x = mult_pow2($value, $exp);
           $x = copysign($magnitude, $sign_from);
           $x = nextup($x);
           $x = nextdown($x);
           $x = nextafter($x, $direction);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is about the native floating point numerical data type.  A floating point number is one of
       the types of datum that can appear in the numeric part of a Perl scalar.  This module supplies constants
       describing the native floating point type, classification functions, and functions to manipulate floating
       point values at a low level.

</pre><h4><b>FLOATING</b> <b>POINT</b></h4><pre>
   <b>Classification</b>
       Floating point values are divided into five subtypes:

       normalised
           The  value  is  made  up  of  a  sign bit (making the value positive or negative), a significand, and
           exponent.  The significand is a number in the range [1, 2), expressed  as  a  binary  fraction  of  a
           certain  fixed  length.   (Significands  requiring a longer binary fraction, or lacking a terminating
           binary representation, cannot be obtained.)  The exponent is an integer in  a  certain  fixed  range.
           The  magnitude of the value represented is the product of the significand and two to the power of the
           exponent.

       subnormal
           The value is made up of a sign bit, significand, and exponent, as for  normalised  values.   However,
           the  exponent  is fixed at the minimum possible for a normalised value, and the significand is in the
           range (0, 1).  The length of the  significand  is  the  same  as  for  normalised  values.   This  is
           essentially  a fixed-point format, used to provide gradual underflow.  Not all floating point formats
           support this subtype.  Where it is not supported, underflow is sudden, and the difference between two
           minimum-exponent normalised values cannot be exactly represented.

       zero
           Depending on the floating point type, there may be either one or two zero values: zeroes may carry  a
           sign  bit.   Where zeroes are signed, it is primarily in order to indicate the direction from which a
           value underflowed (was rounded) to zero.  Positive and negative zero compare  as  numerically  equal,
           and  they  give  identical results in most arithmetic operations.  They are on opposite sides of some
           branch cuts in complex arithmetic.

       infinite
           Some floating point formats include special infinite values.  These are generated by overflow, and by
           some arithmetic cases that mathematically  generate  infinities.   There  are  two  infinite  values:
           positive infinity and negative infinity.

           Perl does not always generate infinite values when normal floating point behaviour calls for it.  For
           example, the division "1.0/0.0" causes an exception rather than returning an infinity.

       not-a-number (NaN)
           This   type   of  value  exists  in  some  floating  point  formats  to  indicate  error  conditions.
           Mathematically undefined operations may generate NaNs, and  NaNs  propagate  through  all  arithmetic
           operations.   A  NaN  has  the  distinctive property of comparing numerically unequal to all floating
           point values, including itself.

           Perl does not always generate NaNs when normal floating point behaviour calls for it.   For  example,
           the division "0.0/0.0" causes an exception rather than returning a NaN.

           Perl  has only (at most) one NaN value, even if the underlying system supports different NaNs.  (IEEE
           754 arithmetic has NaNs which carry a quiet/signal bit, a sign bit (yes, a sign on a not-number), and
           many bits of implementation-defined data.)

   <b>Mixing</b> <b>floating</b> <b>point</b> <b>and</b> <b>integer</b> <b>values</b>
       Perl does not draw a strong type distinction  between  native  integer  (see  Data::Integer)  and  native
       floating point values.  Both types of value can be stored in the numeric part of a plain (string) scalar.
       No  distinction  is  made  between the integer representation and the floating point representation where
       they encode identical values.  Thus, for floating point arithmetic, native integer  values  that  can  be
       represented exactly in floating point may be freely used as floating point values.

       Native integer arithmetic has exactly one zero value, which has no sign.  If the floating point type does
       not  have  signed  zeroes  then  the  floating  point  and integer zeroes are exactly equivalent.  If the
       floating point type does have signed zeroes then the integer zero can still be  used  in  floating  point
       arithmetic, and it behaves as an unsigned floating point zero.  On such systems there are therefore three
       types  of  zero available.  There is a bug in Perl which sometimes causes floating point zeroes to change
       into integer zeroes; see "BUGS" for details.

       Where a native integer value is used that is too large to exactly represent in floating point, it will be
       rounded as necessary to a floating point value.  This rounding will occur whenever an operation has to be
       performed in floating point because the result could not be exactly represented as an integer.  This  may
       be confusing to functions that expect a floating point argument.

       Similarly,  some  operations  on floating point numbers will actually be performed in integer arithmetic,
       and may result in values that cannot be exactly represented in floating point.  This happens whenever the
       arguments have integer values that fit into the native integer type and the mathematical  result  can  be
       exactly  represented  as a native integer.  This may be confusing in cases where floating point semantics
       are expected.

       See <b><a href="../man1/perlnumber.1.html">perlnumber</a></b>(1) for discussion of Perl's numeric semantics.

</pre><h4><b>CONSTANTS</b></h4><pre>
   <b>Features</b>
       have_signed_zero
           Truth value indicating whether floating point zeroes carry a  sign.   If  yes,  then  there  are  two
           floating point zero values: +0.0 and -0.0.  (Perl scalars can nevertheless also hold an integer zero,
           which is unsigned.)  If no, then there is only one zero value, which is unsigned.

       have_subnormal
           Truth value indicating whether there are subnormal floating point values.

       have_infinite
           Truth value indicating whether there are infinite floating point values.

       have_nan
           Truth value indicating whether there are NaN floating point values.

           It  is difficult to reliably generate a NaN in Perl, so in some unlikely circumstances it is possible
           that there might be NaNs that this module failed to detect.  In that  case  this  constant  would  be
           false  but  a  NaN  might  still  turn  up  somewhere.   What this constant reliably indicates is the
           availability of the "nan" constant below.

   <b>Extrema</b>
       significand_bits
           The number of fractional bits in the significand of finite floating point  values.   The  significand
           also  has  an  implicit  integer  bit,  not counted in this constant; the integer bit is always 1 for
           normalised values and always 0 for subnormal values.

       significand_step
           The difference between adjacent representable values in the range  [1,  2]  (where  the  exponent  is
           zero).  This is equal to 2^-significand_bits.

       max_finite_exp
           The maximum exponent permitted for finite floating point values.

       max_finite_pow2
           The maximum representable power of two.  This is 2^max_finite_exp.

       max_finite
           The     maximum     representable     finite     value.      This     is    2^(max_finite_exp+1)    -
           2^(max_finite_exp-significand_bits).

       max_number
           The maximum representable number.  This is  positive  infinity  if  there  are  infinite  values,  or
           max_finite if there are not.

       max_integer
           The  maximum  integral  value  for  which  all  integers  from  zero  to  that  value  inclusive  are
           representable.  Equivalently: the minimum positive integral value N for which the value  N+1  is  not
           representable.  This is 2^(significand_bits+1).  The name is somewhat misleading.

       min_normal_exp
           The minimum exponent permitted for normalised floating point values.

       min_normal
           The   minimum   positive  value  representable  as  a  normalised  floating  point  value.   This  is
           2^min_normal_exp.

       min_finite_exp
           The base two logarithm of the minimum representable positive finite value.  If there  are  subnormals
           then  this  is  min_normal_exp  -  significand_bits.   If  there  are  no  subnormals  then  this  is
           min_normal_exp.

       min_finite
           The minimum representable positive finite value.  This is 2^min_finite_exp.

   <b>Special</b> <b>Values</b>
       pos_zero
           The positive zero value.  (Exists only if zeroes are signed, as indicated by  the  "have_signed_zero"
           constant.)

           If  Perl is at risk of transforming floating point zeroes into integer zeroes (see "BUGS"), then this
           is actually a non-constant function that always returns a fresh floating point zero.  Thus the return
           value is always a true floating  point  zero,  regardless  of  what  happened  to  zeroes  previously
           returned.

       neg_zero
           The  negative  zero value.  (Exists only if zeroes are signed, as indicated by the "have_signed_zero"
           constant.)

           If Perl is at risk of transforming floating point zeroes into integer zeroes (see "BUGS"), then  this
           is actually a non-constant function that always returns a fresh floating point zero.  Thus the return
           value  is  always  a  true  floating  point  zero,  regardless  of what happened to zeroes previously
           returned.

       pos_infinity
           The positive infinite value.  (Exists only  if  there  are  infinite  values,  as  indicated  by  the
           "have_infinite" constant.)

       neg_infinity
           The  negative  infinite  value.   (Exists  only  if  there  are  infinite values, as indicated by the
           "have_infinite" constant.)

       nan Not-a-number.  (Exists only if NaN values were detected, as indicated by the "have_nan" constant.)

</pre><h4><b>FUNCTIONS</b></h4><pre>
       Each "float_" function takes a floating point argument to operate on.  The  argument  must  be  a  native
       floating point value, or a native integer with a value that can be represented in floating point.  Giving
       a  non-numeric  argument  will  cause mayhem.  See "is_number" in Params::Classify for a way to check for
       numericness.  Only the numeric value of the scalar is used; the string value is  completely  ignored,  so
       dualvars are not a problem.

   <b>Classification</b>
       Each "float_is_" function returns a simple truth value result.

       float_class(VALUE)
           Determines which of the five classes described above VALUE falls into. Returns "NORMAL", "SUBNORMAL",
           "ZERO", "INFINITE", or "NAN" accordingly.

       float_is_normal(VALUE)
           Returns true iff VALUE is a normalised floating point value.

       float_is_subnormal(VALUE)
           Returns true iff VALUE is a subnormal floating point value.

       float_is_nzfinite(VALUE)
           Returns true iff VALUE is a non-zero finite value (either normal or subnormal; not zero, infinite, or
           NaN).

       float_is_zero(VALUE)
           Returns true iff VALUE is a zero.  If zeroes are signed then the sign is irrelevant.

       float_is_finite(VALUE)
           Returns true iff VALUE is a finite value (either normal, subnormal, or zero; not infinite or NaN).

       float_is_infinite(VALUE)
           Returns true iff VALUE is an infinity (either positive infinity or negative infinity).

       float_is_nan(VALUE)
           Returns true iff VALUE is a NaN.

   <b>Examination</b>
       float_sign(VALUE)
           Returns  "<b>+</b>" or "<b>-</b>" to indicate the sign of VALUE.  An unsigned zero returns the sign "<b>+</b>".  "die"s if
           VALUE is a NaN.

       signbit(VALUE)
           VALUE must be a floating point value.  Returns the sign bit of VALUE: 0 if VALUE  is  positive  or  a
           positive  or  unsigned  zero, or 1 if VALUE is negative or a negative zero.  Returns an unpredictable
           value if VALUE is a NaN.

           This is an IEEE 754 standard function.  According to the standard NaNs have a well-behaved sign  bit,
           but Perl can't see that bit.

       float_parts(VALUE)
           Divides  up  a  non-zero  finite floating point value into sign, exponent, and significand, returning
           these as a three-element list in that order.  The significand is returned as a floating point  value,
           in  the  range [1, 2) for normalised values, and in the range (0, 1) for subnormals.  "die"s if VALUE
           is not finite and non-zero.

   <b>String</b> <b>conversion</b>
       float_hex(VALUE[, OPTIONS])
           Encodes the exact value of VALUE as a hexadecimal fraction,  returning  the  fraction  as  a  string.
           Specifically,  for  finite  values the output is of the form "<u>s</u><b>0x</b><u>m</u><b>.</b><u>mmmmm</u><b>p</b><u>eee</u>", where "<u>s</u>" is the sign,
           "<u>m</u><b>.</b><u>mmmm</u>" is the significand in hexadecimal, and "<u>eee</u>" is the exponent in decimal with a sign.

           The details of the output format are very configurable.   If  OPTIONS  is  supplied,  it  must  be  a
           reference to a hash, in which these keys may be present:

           <b>exp_digits</b>
               The number of digits of exponent to show, unless this is modified by <b>exp_digits_range_mod</b> or more
               are  required  to show the exponent exactly.  (The exponent is always shown in full.)  Default 0,
               so the minimum possible number of digits is used.

           <b>exp_digits_range_mod</b>
               Modifies the number of exponent digits to show, based on the number of digits  required  to  show
               the  full  range  of  exponents for normalised and subnormal values.  If "<b>IGNORE</b>" then nothing is
               done.  If "<b>ATLEAST</b>" then at least this many digits are shown.  Default "<b>IGNORE</b>".

           <b>exp_neg_sign</b>
               The string that is prepended to a negative exponent.  Default "<b>-</b>".

           <b>exp_pos_sign</b>
               The string that is prepended to a non-negative exponent.  Default "<b>+</b>".  Make it the empty  string
               to suppress the positive sign.

           <b>frac_digits</b>
               The  number  of  fractional  digits  to  show, unless this is modified by <b>frac_digits_bits_mod</b> or
               <b>frac_digits_value_mod</b>.  Default 0, but by default this gets modified.

           <b>frac_digits_bits_mod</b>
               Modifies the number of fractional digits to show, based on the length of the significand.   There
               is  a certain number of digits that is the minimum required to explicitly state every bit that is
               stored, and the number of digits to show might get set to that number depending on  this  option.
               If  "<b>IGNORE</b>"  then  nothing  is done.  If "<b>ATLEAST</b>" then at least this many digits are shown.  If
               "<b>ATMOST</b>" then at most this many digits are shown.  If "<b>EXACTLY</b>" then exactly this many digits are
               shown.  Default "<b>ATLEAST</b>".

           <b>frac_digits_value_mod</b>
               Modifies the number of fractional digits to show, based on the number of digits required to  show
               the actual value exactly.  Works the same way as <b>frac_digits_bits_mod</b>.  Default "<b>ATLEAST</b>".

           <b>hex_prefix_string</b>
               The  string  that  is prefixed to hexadecimal digits.  Default "<b>0x</b>".  Make it the empty string to
               suppress the prefix.

           <b>infinite_string</b>
               The string that is returned for an infinite magnitude.  Default "<b>inf</b>".

           <b>nan_string</b>
               The string that is returned for a NaN value.  Default "<b>nan</b>".

           <b>neg_sign</b>
               The string that is prepended to a negative value (including negative zero).  Default "<b>-</b>".

           <b>pos_sign</b>
               The string that is prepended to a positive value (including positive or unsigned zero).   Default
               "<b>+</b>".  Make it the empty string to suppress the positive sign.

           <b>subnormal_strategy</b>
               The  manner  in  which  subnormal  values are displayed.  If "<b>SUBNORMAL</b>", they are shown with the
               minimum exponent for normalised values and a significand in the range (0, 1).  This  matches  how
               they  are  stored internally.  If "<b>NORMAL</b>", they are shown with a significand in the range [1, 2)
               and a lower exponent, as if they  were  normalised.   This  gives  a  consistent  appearance  for
               magnitudes regardless of normalisation.  Default "<b>SUBNORMAL</b>".

           <b>zero_strategy</b>
               The manner in which zero values are displayed.  If "<b>STRING=</b><u>str</u>", the string <u>str</u> is used, preceded
               by  a  sign.   If  "<b>SUBNORMAL</b>",  it  is  shown  with  significand zero and the minimum normalised
               exponent.  If "<b>EXPONENT=</b><u>exp</u>", it is shown  with  significand  zero  and  exponent  <u>exp</u>.   Default
               "<b>STRING=0.0</b>".  An unsigned zero is treated as having a positive sign.

       hex_float(STRING)
           Generates  and returns a floating point value from a string encoding it in hexadecimal.  The standard
           input form is  "[<u>s</u>][<b>0x</b>]<u>m</u>[<b>.</b><u>mmmmm</u>][<b>p</b><u>eee</u>]",  where  "<u>s</u>"  is  the  sign,  "<u>m</u>[<b>.</b><u>mmmm</u>]"  is  a  (fractional)
           hexadecimal  number,  and  "<u>eee</u>"  an optionally-signed exponent in decimal.  If present, the exponent
           identifies a power of two (not sixteen) by which the given fraction will be multiplied.

           If the value given in the string cannot be exactly represented in the floating point type because  it
           has  too  many fraction bits, the nearest representable value is returned, with ties broken in favour
           of the value with a zero low-order bit.  If the value given is too large to exactly represent then an
           infinity is returned, or the largest finite value if there are no infinities.

           Additional input formats are accepted for special values.  "[<u>s</u>]<b>inf</b>[<b>inity</b>]" returns  an  infinity,  or
           "die"s  if  there  are  no  infinities.   "[<u>s</u>][<b>s</b>]<b>nan</b>"  returns  a NaN, or "die"s if there are no NaNs
           available.

           All input formats are understood case insensitively.  The function correctly interprets all  possible
           outputs from "float_hex" with default settings.

   <b>Comparison</b>
       float_id_cmp(A, B)
           This is a comparison function supplying a total ordering of floating point values.  A and B must both
           be  floating  point  values.   Returns -1, 0, or +1, indicating whether A is to be sorted before, the
           same as, or after B.

           The ordering is of the identities of floating point values, not their numerical  values.   If  zeroes
           are  signed, then the two types are considered to be distinct.  NaNs compare equal to each other, but
           different from all numeric values.  The exact ordering provided is mostly numerical order: NaNs  come
           first,  followed by negative infinity, then negative finite values, then negative zero, then positive
           (or unsigned) zero, then positive finite values, then positive infinity.

           In addition to sorting, this function can be useful to check for a zero of a particular sign.

       totalorder(A, B)
           This is a comparison function supplying a total ordering of floating point values.  A and B must both
           be floating point values.  Returns a truth value indicating whether A is to be sorted  before-or-the-
           same-as  B.   That  is, it is a &lt;= predicate on the total ordering.  The ordering is the same as that
           provided by "float_id_cmp": NaNs come first, followed by  negative  infinity,  then  negative  finite
           values,  then  negative  zero,  then  positive  (or unsigned) zero, then positive finite values, then
           positive infinity.

           This is an IEEE 754r standard function.  According  to  the  standard  it  is  meant  to  distinguish
           different kinds of NaNs, based on their sign bit, quietness, and payload, but this function (like the
           rest of Perl) perceives only one NaN.

   <b>Manipulation</b>
       pow2(EXP)
           EXP  must  be  an  integer.  Returns the value two the the power EXP.  "die"s if that value cannot be
           represented exactly as a floating point  value.   The  return  value  may  be  either  normalised  or
           subnormal.

       mult_pow2(VALUE, EXP)
           EXP  must be an integer, and VALUE a floating point value.  Multiplies VALUE by two to the power EXP.
           This gives exact results, except in cases of underflow  and  overflow.   The  range  of  EXP  is  not
           constrained.  All normal floating point multiplication behaviour applies.

       copysign(VALUE, SIGN_FROM)
           VALUE  and  SIGN_FROM  must  both  be floating point values.  Returns a floating point value with the
           magnitude of VALUE and the sign of SIGN_FROM.  If SIGN_FROM is an unsigned zero then it is treated as
           positive.  If VALUE is an unsigned zero then it is returned unchanged.  If VALUE is a NaN then it  is
           returned unchanged.  If SIGN_FROM is a NaN then the sign copied to VALUE is unpredictable.

           This  is an IEEE 754 standard function.  According to the standard NaNs have a well-behaved sign bit,
           which can be read and modified by this function, but Perl only perceives one NaN and  can't  see  its
           sign bit, so behaviour on NaNs is not standard-conforming.

       nextup(VALUE)
           VALUE  must  be a floating point value.  Returns the next representable floating point value adjacent
           to VALUE with a numerical value that is strictly greater than VALUE, or returns  VALUE  unchanged  if
           there  is no such value.  Infinite values are regarded as being adjacent to the largest representable
           finite values.  Zero counts as one value, even if it is signed, and it is adjacent  to  the  smallest
           representable  positive  and  negative  finite  values.   If a zero is returned, because VALUE is the
           smallest representable negative value, and zeroes are signed, it is a negative zero that is returned.
           Returns NaN if VALUE is a NaN.

           This is an IEEE 754r standard function.

       nextdown(VALUE)
           VALUE must be a floating point value.  Returns the next representable floating point  value  adjacent
           to VALUE with a numerical value that is strictly less than VALUE, or returns VALUE unchanged if there
           is no such value.  Infinite values are regarded as being adjacent to the largest representable finite
           values.   Zero  counts  as  one  value,  even  if  it  is  signed, and it is adjacent to the smallest
           representable positive and negative finite values.  If a zero  is  returned,  because  VALUE  is  the
           smallest representable positive value, and zeroes are signed, it is a positive zero that is returned.
           Returns NaN if VALUE is a NaN.

           This is an IEEE 754r standard function.

       nextafter(VALUE, DIRECTION)
           VALUE  and  DIRECTION  must  both  be floating point values.  Returns the next representable floating
           point value adjacent to VALUE  in  the  direction  of  DIRECTION,  or  returns  DIRECTION  if  it  is
           numerically  equal  to  VALUE.   Infinite  values  are  regarded  as  being  adjacent  to the largest
           representable finite values.  Zero counts as one value, even if it is signed, and it is  adjacent  to
           the positive and negative smallest representable finite values.  If a zero is returned and zeroes are
           signed then it has the same sign as VALUE.  Returns NaN if either argument is a NaN.

           This is an IEEE 754 standard function.

</pre><h4><b>BUGS</b></h4><pre>
       As  of  Perl  5.8.7  floating  point  zeroes will be partially transformed into integer zeroes if used in
       almost any arithmetic, including numerical comparisons.  Such a transformed zero appears  as  a  floating
       point zero (with its original sign) for some purposes, but behaves as an integer zero for other purposes.
       Where this happens to a positive zero the result is indistinguishable from a true integer zero.  Where it
       happens  to a negative zero the result is a fourth type of zero, the existence of which is a bug in Perl.
       This fourth type of zero will  give  confusing  results,  and  in  particular  will  elicit  inconsistent
       behaviour from the functions in this module.

       Because  of  this  transforming  behaviour,  it  is  best to avoid relying on the sign of zeroes.  If you
       require signed-zero semantics then take special care to maintain signedness.  Avoid using a zero directly
       in arithmetic and handle it as a special case.  Any flavour of zero can be  accurately  copied  from  one
       scalar to another without affecting the original.  The functions in this module all avoid modifying their
       arguments, and where they are meant to return signed zeroes they always return a pristine one.

       As  of Perl 5.8.7 stringification of a floating point zero does not preserve its signedness.  The number-
       to-string-to-number round trip turns a positive floating point zero into an integer zero, but  accurately
       maintains  negative  and  integer  zeroes.  If a negative zero gets partially transformed into an integer
       zero, as described above, the stringification that it gets is based on its state at the first occasion on
       which the scalar was stringified.

       NaN handling is generally not well defined in Perl.  Arithmetic with a  mathematically  undefined  result
       may  either "die" or generate a NaN.  Avoid relying on any particular behaviour for such operations, even
       if your hardware's behaviour is known.

       As of Perl 5.8.7 the <b>%</b> operator truncates its arguments to integers, if the divisor is within  the  range
       of  the native integer type.  It therefore operates correctly on non-integer values only when the divisor
       is very large.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Data::Integer, Scalar::Number, <b><a href="../man1/perlnumber.1.html">perlnumber</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
       Andrew Main (Zefram) &lt;<a href="mailto:zefram@fysh.org">zefram@fysh.org</a>&gt;

       Currently maintained by Robert Rothenberg &lt;<a href="mailto:rrwo@cpan.org">rrwo@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2006, 2007, 2008, 2010, 2012, 2017, 2025 Andrew Main (Zefram) &lt;<a href="mailto:zefram@fysh.org">zefram@fysh.org</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself.

perl v5.40.1                                       2025-04-12                                   <u>Data::<a href="../man3pm/Float.3pm.html">Float</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>