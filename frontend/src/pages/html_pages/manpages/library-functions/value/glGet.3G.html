<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>glGet - return the value or values of a selected parameter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/opengl-4-man-doc">opengl-4-man-doc_1.0~svn33624-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       glGet - return the value or values of a selected parameter

</pre><h4><b>C</b> <b>SPECIFICATION</b></h4><pre>

       <b>void</b> <b>glGetBooleanv(GLenum</b> <u>pname</u><b>,</b> <b>GLboolean</b> <b>*</b> <u>data</u><b>);</b>

       <b>void</b> <b>glGetDoublev(GLenum</b> <u>pname</u><b>,</b> <b>GLdouble</b> <b>*</b> <u>data</u><b>);</b>

       <b>void</b> <b>glGetFloatv(GLenum</b> <u>pname</u><b>,</b> <b>GLfloat</b> <b>*</b> <u>data</u><b>);</b>

       <b>void</b> <b>glGetIntegerv(GLenum</b> <u>pname</u><b>,</b> <b>GLint</b> <b>*</b> <u>data</u><b>);</b>

       <b>void</b> <b>glGetInteger64v(GLenum</b> <u>pname</u><b>,</b> <b>GLint64</b> <b>*</b> <u>data</u><b>);</b>

       <b>void</b> <b>glGetBooleani_v(GLenum</b> <u>target</u><b>,</b> <b>GLuint</b> <u>index</u><b>,</b> <b>GLboolean</b> <b>*</b> <u>data</u><b>);</b>

       <b>void</b> <b>glGetIntegeri_v(GLenum</b> <u>target</u><b>,</b> <b>GLuint</b> <u>index</u><b>,</b> <b>GLint</b> <b>*</b> <u>data</u><b>);</b>

       <b>void</b> <b>glGetFloati_v(GLenum</b> <u>target</u><b>,</b> <b>GLuint</b> <u>index</u><b>,</b> <b>GLfloat</b> <b>*</b> <u>data</u><b>);</b>

       <b>void</b> <b>glGetDoublei_v(GLenum</b> <u>target</u><b>,</b> <b>GLuint</b> <u>index</u><b>,</b> <b>GLdouble</b> <b>*</b> <u>data</u><b>);</b>

       <b>void</b> <b>glGetInteger64i_v(GLenum</b> <u>target</u><b>,</b> <b>GLuint</b> <u>index</u><b>,</b> <b>GLint64</b> <b>*</b> <u>data</u><b>);</b>

</pre><h4><b>PARAMETERS</b></h4><pre>
       <u>pname</u>
           Specifies the parameter value to be returned for non-indexed versions of <b>glGet</b>. The symbolic
           constants in the list below are accepted.

       <u>target</u>
           Specifies the parameter value to be returned for indexed versions of <b>glGet</b>. The symbolic constants in
           the list below are accepted.

       <u>index</u>
           Specifies the index of the particular element being queried.

       <u>data</u>
           Returns the value or values of the specified parameter.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These commands return values for simple state variables in GL.  <u>pname</u> is a symbolic constant indicating
       the state variable to be returned, and <u>data</u> is a pointer to an array of the indicated type in which to
       place the returned data.

       Type conversion is performed if <u>data</u> has a different type than the state variable value being requested.
       If <b>glGetBooleanv</b> is called, a floating-point (or integer) value is converted to <b>GL_FALSE</b> if and only if
       it is 0.0 (or 0). Otherwise, it is converted to <b>GL_TRUE</b>. If <b>glGetIntegerv</b> is called, boolean values are
       returned as <b>GL_TRUE</b> or <b>GL_FALSE</b>, and most floating-point values are rounded to the nearest integer value.
       Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most
       positive representable integer value and -1.0 to the most negative representable integer value. If
       <b>glGetFloatv</b> or <b>glGetDoublev</b> is called, boolean values are returned as <b>GL_TRUE</b> or <b>GL_FALSE</b>, and integer
       values are converted to floating-point values.

       The following symbolic constants are accepted by <u>pname</u>:

       <b>GL_ACTIVE_TEXTURE</b>
           <u>data</u> returns a single value indicating the active multitexture unit. The initial value is
           <b>GL_TEXTURE0</b>. See <b>glActiveTexture</b>().

       <b>GL_ALIASED_LINE_WIDTH_RANGE</b>
           <u>data</u> returns a pair of values indicating the range of widths supported for aliased lines. See
           <b>glLineWidth</b>().

       <b>GL_ARRAY_BUFFER_BINDING</b>
           <u>data</u> returns a single value, the name of the buffer object currently bound to the target
           <b>GL_ARRAY_BUFFER</b>. If no buffer object is bound to this target, 0 is returned. The initial value is 0.
           See <b>glBindBuffer</b>().

       <b>GL_BLEND</b>
           <u>data</u> returns a single boolean value indicating whether blending is enabled. The initial value is
           <b>GL_FALSE</b>. See <b>glBlendFunc</b>().

       <b>GL_BLEND_COLOR</b>
           <u>data</u> returns four values, the red, green, blue, and alpha values which are the components of the
           blend color. See <b>glBlendColor</b>().

       <b>GL_BLEND_DST_ALPHA</b>
           <u>data</u> returns one value, the symbolic constant identifying the alpha destination blend function. The
           initial value is <b>GL_ZERO</b>. See <b>glBlendFunc</b>() and <b>glBlendFuncSeparate</b>().

       <b>GL_BLEND_DST_RGB</b>
           <u>data</u> returns one value, the symbolic constant identifying the RGB destination blend function. The
           initial value is <b>GL_ZERO</b>. See <b>glBlendFunc</b>() and <b>glBlendFuncSeparate</b>().

       <b>GL_BLEND_EQUATION_RGB</b>
           <u>data</u> returns one value, a symbolic constant indicating whether the RGB blend equation is <b>GL_FUNC_ADD</b>,
           <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>, <b>GL_MIN</b> or <b>GL_MAX</b>. See <b>glBlendEquationSeparate</b>().

       <b>GL_BLEND_EQUATION_ALPHA</b>
           <u>data</u> returns one value, a symbolic constant indicating whether the Alpha blend equation is
           <b>GL_FUNC_ADD</b>, <b>GL_FUNC_SUBTRACT</b>, <b>GL_FUNC_REVERSE_SUBTRACT</b>, <b>GL_MIN</b> or <b>GL_MAX</b>. See
           <b>glBlendEquationSeparate</b>().

       <b>GL_BLEND_SRC_ALPHA</b>
           <u>data</u> returns one value, the symbolic constant identifying the alpha source blend function. The
           initial value is <b>GL_ONE</b>. See <b>glBlendFunc</b>() and <b>glBlendFuncSeparate</b>().

       <b>GL_BLEND_SRC_RGB</b>
           <u>data</u> returns one value, the symbolic constant identifying the RGB source blend function. The initial
           value is <b>GL_ONE</b>. See <b>glBlendFunc</b>() and <b>glBlendFuncSeparate</b>().

       <b>GL_COLOR_CLEAR_VALUE</b>
           <u>data</u> returns four values: the red, green, blue, and alpha values used to clear the color buffers.
           Integer values, if requested, are linearly mapped from the internal floating-point representation
           such that 1.0 returns the most positive representable integer value, and -1.0 returns the most
           negative representable integer value. The initial value is (0, 0, 0, 0). See <b>glClearColor</b>().

       <b>GL_COLOR_LOGIC_OP</b>
           <u>data</u> returns a single boolean value indicating whether a fragment's RGBA color values are merged into
           the framebuffer using a logical operation. The initial value is <b>GL_FALSE</b>. See <b>glLogicOp</b>().

       <b>GL_COLOR_WRITEMASK</b>
           <u>data</u> returns four boolean values: the red, green, blue, and alpha write enables for the color
           buffers. The initial value is (<b>GL_TRUE</b>, <b>GL_TRUE</b>, <b>GL_TRUE</b>, <b>GL_TRUE</b>). See <b>glColorMask</b>().

       <b>GL_COMPRESSED_TEXTURE_FORMATS</b>
           <u>data</u> returns a list of symbolic constants of length <b>GL_NUM_COMPRESSED_TEXTURE_FORMATS</b> indicating
           which compressed texture formats are available. See <b>glCompressedTexImage2D</b>().

       <b>GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS</b>
           <u>data</u> returns one value, the maximum number of active shader storage blocks that may be accessed by a
           compute shader.

       <b>GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS</b>
           <u>data</u> returns one value, the maximum total number of active shader storage blocks that may be accessed
           by all active shaders.

       <b>GL_MAX_COMPUTE_UNIFORM_BLOCKS</b>
           <u>data</u> returns one value, the maximum number of uniform blocks per compute shader. The value must be at
           least 14. See <b>glUniformBlockBinding</b>().

       <b>GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS</b>
           <u>data</u> returns one value, the maximum supported texture image units that can be used to access texture
           maps from the compute shader. The value may be at least 16. See <b>glActiveTexture</b>().

       <b>GL_MAX_COMPUTE_UNIFORM_COMPONENTS</b>
           <u>data</u> returns one value, the maximum number of individual floating-point, integer, or boolean values
           that can be held in uniform variable storage for a compute shader. The value must be at least 1024.
           See <b>glUniform</b>().

       <b>GL_MAX_COMPUTE_ATOMIC_COUNTERS</b>
           <u>data</u> returns a single value, the maximum number of atomic counters available to compute shaders.

       <b>GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS</b>
           <u>data</u> returns a single value, the maximum number of atomic counter buffers that may be accessed by a
           compute shader.

       <b>GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS</b>
           <u>data</u> returns one value, the number of words for compute shader uniform variables in all uniform
           blocks (including default). The value must be at least 1. See <b>glUniform</b>().

       <b>GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS</b>
           <u>data</u> returns one value, the number of invocations in a single local work group (i.e., the product of
           the three dimensions) that may be dispatched to a compute shader.

       <b>GL_MAX_COMPUTE_WORK_GROUP_COUNT</b>
           Accepted by the indexed versions of <b>glGet</b>.  <u>data</u> the maximum number of work groups that may be
           dispatched to a compute shader. Indices 0, 1, and 2 correspond to the X, Y and Z dimensions,
           respectively.

       <b>GL_MAX_COMPUTE_WORK_GROUP_SIZE</b>
           Accepted by the indexed versions of <b>glGet</b>.  <u>data</u> the maximum size of a work groups that may be used
           during compilation of a compute shader. Indices 0, 1, and 2 correspond to the X, Y and Z dimensions,
           respectively.

       <b>GL_DISPATCH_INDIRECT_BUFFER_BINDING</b>
           <u>data</u> returns a single value, the name of the buffer object currently bound to the target
           <b>GL_DISPATCH_INDIRECT_BUFFER</b>. If no buffer object is bound to this target, 0 is returned. The initial
           value is 0. See <b>glBindBuffer</b>().

       <b>GL_MAX_DEBUG_GROUP_STACK_DEPTH</b>
           <u>data</u> returns a single value, the maximum depth of the debug message group stack.

       <b>GL_DEBUG_GROUP_STACK_DEPTH</b>
           <u>data</u> returns a single value, the current depth of the debug message group stack.

       <b>GL_CONTEXT_FLAGS</b>
           <u>data</u> returns one value, the flags with which the context was created (such as debugging
           functionality).

       <b>GL_CULL_FACE</b>
           <u>data</u> returns a single boolean value indicating whether polygon culling is enabled. The initial value
           is <b>GL_FALSE</b>. See <b>glCullFace</b>().

       <b>GL_CURRENT_PROGRAM</b>
           <u>data</u> returns one value, the name of the program object that is currently active, or 0 if no program
           object is active. See <b>glUseProgram</b>().

       <b>GL_DEPTH_CLEAR_VALUE</b>
           <u>data</u> returns one value, the value that is used to clear the depth buffer. Integer values, if
           requested, are linearly mapped from the internal floating-point representation such that 1.0 returns
           the most positive representable integer value, and -1.0 returns the most negative representable
           integer value. The initial value is 1. See <b>glClearDepth</b>().

       <b>GL_DEPTH_FUNC</b>
           <u>data</u> returns one value, the symbolic constant that indicates the depth comparison function. The
           initial value is <b>GL_LESS</b>. See <b>glDepthFunc</b>().

       <b>GL_DEPTH_RANGE</b>
           <u>data</u> returns two values: the near and far mapping limits for the depth buffer. Integer values, if
           requested, are linearly mapped from the internal floating-point representation such that 1.0 returns
           the most positive representable integer value, and -1.0 returns the most negative representable
           integer value. The initial value is (0, 1). See <b>glDepthRange</b>().

       <b>GL_DEPTH_TEST</b>
           <u>data</u> returns a single boolean value indicating whether depth testing of fragments is enabled. The
           initial value is <b>GL_FALSE</b>. See <b>glDepthFunc</b>() and <b>glDepthRange</b>().

       <b>GL_DEPTH_WRITEMASK</b>
           <u>data</u> returns a single boolean value indicating if the depth buffer is enabled for writing. The
           initial value is <b>GL_TRUE</b>. See <b>glDepthMask</b>().

       <b>GL_DITHER</b>
           <u>data</u> returns a single boolean value indicating whether dithering of fragment colors and indices is
           enabled. The initial value is <b>GL_TRUE</b>.

       <b>GL_DOUBLEBUFFER</b>
           <u>data</u> returns a single boolean value indicating whether double buffering is supported.

       <b>GL_DRAW_BUFFER</b>
           <u>data</u> returns one value, a symbolic constant indicating which buffers are being drawn to. See
           <b>glDrawBuffer</b>(). The initial value is <b>GL_BACK</b> if there are back buffers, otherwise it is <b>GL_FRONT</b>.

       <b>GL_DRAW_BUFFER</b><u>i</u>
           <u>data</u> returns one value, a symbolic constant indicating which buffers are being drawn to by the
           corresponding output color. See <b>glDrawBuffers</b>(). The initial value of <b>GL_DRAW_BUFFER0</b> is <b>GL_BACK</b> if
           there are back buffers, otherwise it is <b>GL_FRONT</b>. The initial values of draw buffers for all other
           output colors is <b>GL_NONE</b>.

       <b>GL_DRAW_FRAMEBUFFER_BINDING</b>
           <u>data</u> returns one value, the name of the framebuffer object currently bound to the <b>GL_DRAW_FRAMEBUFFER</b>
           target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See
           <b>glBindFramebuffer</b>().

       <b>GL_READ_FRAMEBUFFER_BINDING</b>
           <u>data</u> returns one value, the name of the framebuffer object currently bound to the <b>GL_READ_FRAMEBUFFER</b>
           target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See
           <b>glBindFramebuffer</b>().

       <b>GL_ELEMENT_ARRAY_BUFFER_BINDING</b>
           <u>data</u> returns a single value, the name of the buffer object currently bound to the target
           <b>GL_ELEMENT_ARRAY_BUFFER</b>. If no buffer object is bound to this target, 0 is returned. The initial
           value is 0. See <b>glBindBuffer</b>().

       <b>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</b>
           <u>data</u> returns one value, a symbolic constant indicating the mode of the derivative accuracy hint for
           fragment shaders. The initial value is <b>GL_DONT_CARE</b>. See <b>glHint</b>().

       <b>GL_IMPLEMENTATION_COLOR_READ_FORMAT</b>
           <u>data</u> returns a single GLenum value indicating the implementation's preferred pixel data format. See
           <b>glReadPixels</b>().

       <b>GL_IMPLEMENTATION_COLOR_READ_TYPE</b>
           <u>data</u> returns a single GLenum value indicating the implementation's preferred pixel data type. See
           <b>glReadPixels</b>().

       <b>GL_LINE_SMOOTH</b>
           <u>data</u> returns a single boolean value indicating whether antialiasing of lines is enabled. The initial
           value is <b>GL_FALSE</b>. See <b>glLineWidth</b>().

       <b>GL_LINE_SMOOTH_HINT</b>
           <u>data</u> returns one value, a symbolic constant indicating the mode of the line antialiasing hint. The
           initial value is <b>GL_DONT_CARE</b>. See <b>glHint</b>().

       <b>GL_LINE_WIDTH</b>
           <u>data</u> returns one value, the line width as specified with <b>glLineWidth</b>(). The initial value is 1.

       <b>GL_LAYER_PROVOKING_VERTEX</b>
           <u>data</u> returns one value, the implementation dependent specifc vertex of a primitive that is used to
           select the rendering layer. If the value returned is equivalent to <b>GL_PROVOKING_VERTEX</b>, then the
           vertex selection follows the convention specified by <b>glProvokingVertex</b>(). If the value returned is
           equivalent to <b>GL_FIRST_VERTEX_CONVENTION</b>, then the selection is always taken from the first vertex in
           the primitive. If the value returned is equivalent to <b>GL_LAST_VERTEX_CONVENTION</b>, then the selection
           is always taken from the last vertex in the primitive. If the value returned is equivalent to
           <b>GL_UNDEFINED_VERTEX</b>, then the selection is not guaranteed to be taken from any specific vertex in the
           primitive.

       <b>GL_LOGIC_OP_MODE</b>
           <u>data</u> returns one value, a symbolic constant indicating the selected logic operation mode. The initial
           value is <b>GL_COPY</b>. See <b>glLogicOp</b>().

       <b>GL_MAJOR_VERSION</b>
           <u>data</u> returns one value, the major version number of the OpenGL API supported by the current context.

       <b>GL_MAX_3D_TEXTURE_SIZE</b>
           <u>data</u> returns one value, a rough estimate of the largest 3D texture that the GL can handle. The value
           must be at least 64. Use <b>GL_PROXY_TEXTURE_3D</b> to determine if a texture is too large. See
           <b>glTexImage3D</b>().

       <b>GL_MAX_ARRAY_TEXTURE_LAYERS</b>
           <u>data</u> returns one value. The value indicates the maximum number of layers allowed in an array texture,
           and must be at least 256. See <b>glTexImage2D</b>().

       <b>GL_MAX_CLIP_DISTANCES</b>
           <u>data</u> returns one value, the maximum number of application-defined clipping distances. The value must
           be at least 8.

       <b>GL_MAX_COLOR_TEXTURE_SAMPLES</b>
           <u>data</u> returns one value, the maximum number of samples in a color multisample texture.

       <b>GL_MAX_COMBINED_ATOMIC_COUNTERS</b>
           <u>data</u> returns a single value, the maximum number of atomic counters available to all active shaders.

       <b>GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS</b>
           <u>data</u> returns one value, the number of words for fragment shader uniform variables in all uniform
           blocks (including default). The value must be at least 1. See <b>glUniform</b>().

       <b>GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS</b>
           <u>data</u> returns one value, the number of words for geometry shader uniform variables in all uniform
           blocks (including default). The value must be at least 1. See <b>glUniform</b>().

       <b>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</b>
           <u>data</u> returns one value, the maximum supported texture image units that can be used to access texture
           maps from the vertex shader and the fragment processor combined. If both the vertex shader and the
           fragment processing stage access the same texture image unit, then that counts as using two texture
           image units against this limit. The value must be at least 48. See <b>glActiveTexture</b>().

       <b>GL_MAX_COMBINED_UNIFORM_BLOCKS</b>
           <u>data</u> returns one value, the maximum number of uniform blocks per program. The value must be at least
           70. See <b>glUniformBlockBinding</b>().

       <b>GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS</b>
           <u>data</u> returns one value, the number of words for vertex shader uniform variables in all uniform blocks
           (including default). The value must be at least 1. See <b>glUniform</b>().

       <b>GL_MAX_CUBE_MAP_TEXTURE_SIZE</b>
           <u>data</u> returns one value. The value gives a rough estimate of the largest cube-map texture that the GL
           can handle. The value must be at least 1024. Use <b>GL_PROXY_TEXTURE_CUBE_MAP</b> to determine if a texture
           is too large. See <b>glTexImage2D</b>().

       <b>GL_MAX_DEPTH_TEXTURE_SAMPLES</b>
           <u>data</u> returns one value, the maximum number of samples in a multisample depth or depth-stencil
           texture.

       <b>GL_MAX_DRAW_BUFFERS</b>
           <u>data</u> returns one value, the maximum number of simultaneous outputs that may be written in a fragment
           shader. The value must be at least 8. See <b>glDrawBuffers</b>().

       <b>GL_MAX_DUAL_SOURCE_DRAW_BUFFERS</b>
           <u>data</u> returns one value, the maximum number of active draw buffers when using dual-source blending.
           The value must be at least 1. See <b>glBlendFunc</b>() and <b>glBlendFuncSeparate</b>().

       <b>GL_MAX_ELEMENTS_INDICES</b>
           <u>data</u> returns one value, the recommended maximum number of vertex array indices. See
           <b>glDrawRangeElements</b>().

       <b>GL_MAX_ELEMENTS_VERTICES</b>
           <u>data</u> returns one value, the recommended maximum number of vertex array vertices. See
           <b>glDrawRangeElements</b>().

       <b>GL_MAX_FRAGMENT_ATOMIC_COUNTERS</b>
           <u>data</u> returns a single value, the maximum number of atomic counters available to fragment shaders.

       <b>GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS</b>
           <u>data</u> returns one value, the maximum number of active shader storage blocks that may be accessed by a
           fragment shader.

       <b>GL_MAX_FRAGMENT_INPUT_COMPONENTS</b>
           <u>data</u> returns one value, the maximum number of components of the inputs read by the fragment shader,
           which must be at least 128.

       <b>GL_MAX_FRAGMENT_UNIFORM_COMPONENTS</b>
           <u>data</u> returns one value, the maximum number of individual floating-point, integer, or boolean values
           that can be held in uniform variable storage for a fragment shader. The value must be at least 1024.
           See <b>glUniform</b>().

       <b>GL_MAX_FRAGMENT_UNIFORM_VECTORS</b>
           <u>data</u> returns one value, the maximum number of individual 4-vectors of floating-point, integer, or
           boolean values that can be held in uniform variable storage for a fragment shader. The value is equal
           to the value of <b>GL_MAX_FRAGMENT_UNIFORM_COMPONENTS</b> divided by 4 and must be at least 256. See
           <b>glUniform</b>().

       <b>GL_MAX_FRAGMENT_UNIFORM_BLOCKS</b>
           <u>data</u> returns one value, the maximum number of uniform blocks per fragment shader. The value must be
           at least 12. See <b>glUniformBlockBinding</b>().

       <b>GL_MAX_FRAMEBUFFER_WIDTH</b>
           <u>data</u> returns one value, the maximum width for a framebuffer that has no attachments, which must be at
           least 16384. See

           <b>glFramebufferParameter</b>.

       <b>GL_MAX_FRAMEBUFFER_HEIGHT</b>
           <u>data</u> returns one value, the maximum height for a framebuffer that has no attachments, which must be
           at least 16384. See

           <b>glFramebufferParameter</b>.

       <b>GL_MAX_FRAMEBUFFER_LAYERS</b>
           <u>data</u> returns one value, the maximum number of layers for a framebuffer that has no attachments, which
           must be at least 2048. See

           <b>glFramebufferParameter</b>.

       <b>GL_MAX_FRAMEBUFFER_SAMPLES</b>
           <u>data</u> returns one value, the maximum samples in a framebuffer that has no attachments, which must be
           at least 4. See

           <b>glFramebufferParameter</b>.

       <b>GL_MAX_GEOMETRY_ATOMIC_COUNTERS</b>
           <u>data</u> returns a single value, the maximum number of atomic counters available to geometry shaders.

       <b>GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS</b>
           <u>data</u> returns one value, the maximum number of active shader storage blocks that may be accessed by a
           geometry shader.

       <b>GL_MAX_GEOMETRY_INPUT_COMPONENTS</b>
           <u>data</u> returns one value, the maximum number of components of inputs read by a geometry shader, which
           must be at least 64.

       <b>GL_MAX_GEOMETRY_OUTPUT_COMPONENTS</b>
           <u>data</u> returns one value, the maximum number of components of outputs written by a geometry shader,
           which must be at least 128.

       <b>GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS</b>
           <u>data</u> returns one value, the maximum supported texture image units that can be used to access texture
           maps from the geometry shader. The value must be at least 16. See <b>glActiveTexture</b>().

       <b>GL_MAX_GEOMETRY_UNIFORM_BLOCKS</b>
           <u>data</u> returns one value, the maximum number of uniform blocks per geometry shader. The value must be
           at least 12. See <b>glUniformBlockBinding</b>().

       <b>GL_MAX_GEOMETRY_UNIFORM_COMPONENTS</b>
           <u>data</u> returns one value, the maximum number of individual floating-point, integer, or boolean values
           that can be held in uniform variable storage for a geometry shader. The value must be at least 1024.
           See <b>glUniform</b>().

       <b>GL_MAX_INTEGER_SAMPLES</b>
           <u>data</u> returns one value, the maximum number of samples supported in integer format multisample
           buffers.

       <b>GL_MIN_MAP_BUFFER_ALIGNMENT</b>
           <u>data</u> returns one value, the minimum alignment in basic machine units of pointers returned
           from<b>glMapBuffer</b>() and <b>glMapBufferRange</b>(). This value must be a power of two and must be at least 64.

       <b>GL_MAX_LABEL_LENGTH</b>
           <u>data</u> returns one value, the maximum length of a label that may be assigned to an object. See
           <b>glObjectLabel</b>() and <b>glObjectPtrLabel</b>().

       <b>GL_MAX_PROGRAM_TEXEL_OFFSET</b>
           <u>data</u> returns one value, the maximum texel offset allowed in a texture lookup, which must be at least
           7.

       <b>GL_MIN_PROGRAM_TEXEL_OFFSET</b>
           <u>data</u> returns one value, the minimum texel offset allowed in a texture lookup, which must be at most
           -8.

       <b>GL_MAX_RECTANGLE_TEXTURE_SIZE</b>
           <u>data</u> returns one value. The value gives a rough estimate of the largest rectangular texture that the
           GL can handle. The value must be at least 1024. Use <b>GL_PROXY_TEXTURE_RECTANGLE</b> to determine if a
           texture is too large. See <b>glTexImage2D</b>().

       <b>GL_MAX_RENDERBUFFER_SIZE</b>
           <u>data</u> returns one value. The value indicates the maximum supported size for renderbuffers. See
           <b>glFramebufferRenderbuffer</b>().

       <b>GL_MAX_SAMPLE_MASK_WORDS</b>
           <u>data</u> returns one value, the maximum number of sample mask words.

       <b>GL_MAX_SERVER_WAIT_TIMEOUT</b>
           <u>data</u> returns one value, the maximum <b>glWaitSync</b>() timeout interval.

       <b>GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS</b>
           <u>data</u> returns one value, the maximum number of shader storage buffer binding points on the context,
           which must be at least 8.

       <b>GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS</b>
           <u>data</u> returns a single value, the maximum number of atomic counters available to tessellation control
           shaders.

       <b>GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS</b>
           <u>data</u> returns a single value, the maximum number of atomic counters available to tessellation
           evaluation shaders.

       <b>GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS</b>
           <u>data</u> returns one value, the maximum number of active shader storage blocks that may be accessed by a
           tessellation control shader.

       <b>GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS</b>
           <u>data</u> returns one value, the maximum number of active shader storage blocks that may be accessed by a
           tessellation evaluation shader.

       <b>GL_MAX_TEXTURE_BUFFER_SIZE</b>
           <u>data</u> returns one value. The value gives the maximum number of texels allowed in the texel array of a
           texture buffer object. Value must be at least 65536.

       <b>GL_MAX_TEXTURE_IMAGE_UNITS</b>
           <u>data</u> returns one value, the maximum supported texture image units that can be used to access texture
           maps from the fragment shader. The value must be at least 16. See <b>glActiveTexture</b>().

       <b>GL_MAX_TEXTURE_LOD_BIAS</b>
           <u>data</u> returns one value, the maximum, absolute value of the texture level-of-detail bias. The value
           must be at least 2.0.

       <b>GL_MAX_TEXTURE_SIZE</b>
           <u>data</u> returns one value. The value gives a rough estimate of the largest texture that the GL can
           handle. The value must be at least 1024. Use a proxy texture target such as <b>GL_PROXY_TEXTURE_1D</b> or
           <b>GL_PROXY_TEXTURE_2D</b> to determine if a texture is too large. See <b>glTexImage1D</b>() and <b>glTexImage2D</b>().

       <b>GL_MAX_UNIFORM_BUFFER_BINDINGS</b>
           <u>data</u> returns one value, the maximum number of uniform buffer binding points on the context, which
           must be at least 36.

       <b>GL_MAX_UNIFORM_BLOCK_SIZE</b>
           <u>data</u> returns one value, the maximum size in basic machine units of a uniform block, which must be at
           least 16384.

       <b>GL_MAX_UNIFORM_LOCATIONS</b>
           <u>data</u> returns one value, the maximum number of explicitly assignable uniform locations, which must be
           at least 1024.

       <b>GL_MAX_VARYING_COMPONENTS</b>
           <u>data</u> returns one value, the number components for varying variables, which must be at least 60.

       <b>GL_MAX_VARYING_VECTORS</b>
           <u>data</u> returns one value, the number 4-vectors for varying variables, which is equal to the value of
           <b>GL_MAX_VARYING_COMPONENTS</b> and must be at least 15.

       <b>GL_MAX_VARYING_FLOATS</b>
           <u>data</u> returns one value, the maximum number of interpolators available for processing varying
           variables used by vertex and fragment shaders. This value represents the number of individual
           floating-point values that can be interpolated; varying variables declared as vectors, matrices, and
           arrays will all consume multiple interpolators. The value must be at least 32.

       <b>GL_MAX_VERTEX_ATOMIC_COUNTERS</b>
           <u>data</u> returns a single value, the maximum number of atomic counters available to vertex shaders.

       <b>GL_MAX_VERTEX_ATTRIBS</b>
           <u>data</u> returns one value, the maximum number of 4-component generic vertex attributes accessible to a
           vertex shader. The value must be at least 16. See <b>glVertexAttrib</b>().

       <b>GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS</b>
           <u>data</u> returns one value, the maximum number of active shader storage blocks that may be accessed by a
           vertex shader.

       <b>GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</b>
           <u>data</u> returns one value, the maximum supported texture image units that can be used to access texture
           maps from the vertex shader. The value may be at least 16. See <b>glActiveTexture</b>().

       <b>GL_MAX_VERTEX_UNIFORM_COMPONENTS</b>
           <u>data</u> returns one value, the maximum number of individual floating-point, integer, or boolean values
           that can be held in uniform variable storage for a vertex shader. The value must be at least 1024.
           See <b>glUniform</b>().

       <b>GL_MAX_VERTEX_UNIFORM_VECTORS</b>
           <u>data</u> returns one value, the maximum number of 4-vectors that may be held in uniform variable storage
           for the vertex shader. The value of <b>GL_MAX_VERTEX_UNIFORM_VECTORS</b> is equal to the value of
           <b>GL_MAX_VERTEX_UNIFORM_COMPONENTS</b> and must be at least 256.

       <b>GL_MAX_VERTEX_OUTPUT_COMPONENTS</b>
           <u>data</u> returns one value, the maximum number of components of output written by a vertex shader, which
           must be at least 64.

       <b>GL_MAX_VERTEX_UNIFORM_BLOCKS</b>
           <u>data</u> returns one value, the maximum number of uniform blocks per vertex shader. The value must be at
           least 12. See <b>glUniformBlockBinding</b>().

       <b>GL_MAX_VIEWPORT_DIMS</b>
           <u>data</u> returns two values: the maximum supported width and height of the viewport. These must be at
           least as large as the visible dimensions of the display being rendered to. See <b>glViewport</b>().

       <b>GL_MAX_VIEWPORTS</b>
           <u>data</u> returns one value, the maximum number of simultaneous viewports that are supported. The value
           must be at least 16. See <b>glViewportIndexed</b>().

       <b>GL_MINOR_VERSION</b>
           <u>data</u> returns one value, the minor version number of the OpenGL API supported by the current context.

       <b>GL_NUM_COMPRESSED_TEXTURE_FORMATS</b>
           <u>data</u> returns a single integer value indicating the number of available compressed texture formats.
           The minimum value is 4. See <b>glCompressedTexImage2D</b>().

       <b>GL_NUM_EXTENSIONS</b>
           <u>data</u> returns one value, the number of extensions supported by the GL implementation for the current
           context. See <b>glGetString</b>().

       <b>GL_NUM_PROGRAM_BINARY_FORMATS</b>
           <u>data</u> returns one value, the number of program binary formats supported by the implementation.

       <b>GL_NUM_SHADER_BINARY_FORMATS</b>
           <u>data</u> returns one value, the number of binary shader formats supported by the implementation. If this
           value is greater than zero, then the implementation supports loading binary shaders. If it is zero,
           then the loading of binary shaders by the implementation is not supported.

       <b>GL_PACK_ALIGNMENT</b>
           <u>data</u> returns one value, the byte alignment used for writing pixel data to memory. The initial value
           is 4. See <b>glPixelStore</b>().

       <b>GL_PACK_IMAGE_HEIGHT</b>
           <u>data</u> returns one value, the image height used for writing pixel data to memory. The initial value is
           0. See <b>glPixelStore</b>().

       <b>GL_PACK_LSB_FIRST</b>
           <u>data</u> returns a single boolean value indicating whether single-bit pixels being written to memory are
           written first to the least significant bit of each unsigned byte. The initial value is <b>GL_FALSE</b>. See
           <b>glPixelStore</b>().

       <b>GL_PACK_ROW_LENGTH</b>
           <u>data</u> returns one value, the row length used for writing pixel data to memory. The initial value is 0.
           See <b>glPixelStore</b>().

       <b>GL_PACK_SKIP_IMAGES</b>
           <u>data</u> returns one value, the number of pixel images skipped before the first pixel is written into
           memory. The initial value is 0. See <b>glPixelStore</b>().

       <b>GL_PACK_SKIP_PIXELS</b>
           <u>data</u> returns one value, the number of pixel locations skipped before the first pixel is written into
           memory. The initial value is 0. See <b>glPixelStore</b>().

       <b>GL_PACK_SKIP_ROWS</b>
           <u>data</u> returns one value, the number of rows of pixel locations skipped before the first pixel is
           written into memory. The initial value is 0. See <b>glPixelStore</b>().

       <b>GL_PACK_SWAP_BYTES</b>
           <u>data</u> returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel
           indices and components are swapped before being written to memory. The initial value is <b>GL_FALSE</b>. See
           <b>glPixelStore</b>().

       <b>GL_PIXEL_PACK_BUFFER_BINDING</b>
           <u>data</u> returns a single value, the name of the buffer object currently bound to the target
           <b>GL_PIXEL_PACK_BUFFER</b>. If no buffer object is bound to this target, 0 is returned. The initial value
           is 0. See <b>glBindBuffer</b>().

       <b>GL_PIXEL_UNPACK_BUFFER_BINDING</b>
           <u>data</u> returns a single value, the name of the buffer object currently bound to the target
           <b>GL_PIXEL_UNPACK_BUFFER</b>. If no buffer object is bound to this target, 0 is returned. The initial value
           is 0. See <b>glBindBuffer</b>().

       <b>GL_POINT_FADE_THRESHOLD_SIZE</b>
           <u>data</u> returns one value, the point size threshold for determining the point size. See
           <b>glPointParameter</b>().

       <b>GL_PRIMITIVE_RESTART_INDEX</b>
           <u>data</u> returns one value, the current primitive restart index. The initial value is 0. See
           <b>glPrimitiveRestartIndex</b>().

       <b>GL_PROGRAM_BINARY_FORMATS</b>
           <u>data</u> an array of <b>GL_NUM_PROGRAM_BINARY_FORMATS</b> values, indicating the proram binary formats supported
           by the implementation.

       <b>GL_PROGRAM_PIPELINE_BINDING</b>
           <u>data</u> a single value, the name of the currently bound program pipeline object, or zero if no program
           pipeline object is bound. See <b>glBindProgramPipeline</b>().

       <b>GL_PROGRAM_POINT_SIZE</b>
           <u>data</u> returns a single boolean value indicating whether vertex program point size mode is enabled. If
           enabled, then the point size is taken from the shader built-in gl_PointSize. If disabled, then the
           point size is taken from the point state as specified by <b>glPointSize</b>(). The initial value is
           <b>GL_FALSE</b>.

       <b>GL_PROVOKING_VERTEX</b>
           <u>data</u> returns one value, the currently selected provoking vertex convention. The initial value is
           <b>GL_LAST_VERTEX_CONVENTION</b>. See <b>glProvokingVertex</b>().

       <b>GL_POINT_SIZE</b>
           <u>data</u> returns one value, the point size as specified by <b>glPointSize</b>(). The initial value is 1.

       <b>GL_POINT_SIZE_GRANULARITY</b>
           <u>data</u> returns one value, the size difference between adjacent supported sizes for antialiased points.
           See <b>glPointSize</b>().

       <b>GL_POINT_SIZE_RANGE</b>
           <u>data</u> returns two values: the smallest and largest supported sizes for antialiased points. The
           smallest size must be at most 1, and the largest size must be at least 1. See <b>glPointSize</b>().

       <b>GL_POLYGON_OFFSET_FACTOR</b>
           <u>data</u> returns one value, the scaling factor used to determine the variable offset that is added to the
           depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See
           <b>glPolygonOffset</b>().

       <b>GL_POLYGON_OFFSET_UNITS</b>
           <u>data</u> returns one value. This value is multiplied by an implementation-specific value and then added
           to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0.
           See <b>glPolygonOffset</b>().

       <b>GL_POLYGON_OFFSET_FILL</b>
           <u>data</u> returns a single boolean value indicating whether polygon offset is enabled for polygons in fill
           mode. The initial value is <b>GL_FALSE</b>. See <b>glPolygonOffset</b>().

       <b>GL_POLYGON_OFFSET_LINE</b>
           <u>data</u> returns a single boolean value indicating whether polygon offset is enabled for polygons in line
           mode. The initial value is <b>GL_FALSE</b>. See <b>glPolygonOffset</b>().

       <b>GL_POLYGON_OFFSET_POINT</b>
           <u>data</u> returns a single boolean value indicating whether polygon offset is enabled for polygons in
           point mode. The initial value is <b>GL_FALSE</b>. See <b>glPolygonOffset</b>().

       <b>GL_POLYGON_SMOOTH</b>
           <u>data</u> returns a single boolean value indicating whether antialiasing of polygons is enabled. The
           initial value is <b>GL_FALSE</b>. See <b>glPolygonMode</b>().

       <b>GL_POLYGON_SMOOTH_HINT</b>
           <u>data</u> returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint. The
           initial value is <b>GL_DONT_CARE</b>. See <b>glHint</b>().

       <b>GL_READ_BUFFER</b>
           <u>data</u> returns one value, a symbolic constant indicating which color buffer is selected for reading.
           The initial value is <b>GL_BACK</b> if there is a back buffer, otherwise it is <b>GL_FRONT</b>. See <b>glReadPixels</b>().

       <b>GL_RENDERBUFFER_BINDING</b>
           <u>data</u> returns a single value, the name of the renderbuffer object currently bound to the target
           <b>GL_RENDERBUFFER</b>. If no renderbuffer object is bound to this target, 0 is returned. The initial value
           is 0. See <b>glBindRenderbuffer</b>().

       <b>GL_SAMPLE_BUFFERS</b>
           <u>data</u> returns a single integer value indicating the number of sample buffers associated with the
           framebuffer. See <b>glSampleCoverage</b>().

       <b>GL_SAMPLE_COVERAGE_VALUE</b>
           <u>data</u> returns a single positive floating-point value indicating the current sample coverage value. See
           <b>glSampleCoverage</b>().

       <b>GL_SAMPLE_COVERAGE_INVERT</b>
           <u>data</u> returns a single boolean value indicating if the temporary coverage value should be inverted.
           See <b>glSampleCoverage</b>().

       <b>GL_SAMPLER_BINDING</b>
           <u>data</u> returns a single value, the name of the sampler object currently bound to the active texture
           unit. The initial value is 0. See <b>glBindSampler</b>().

       <b>GL_SAMPLES</b>
           <u>data</u> returns a single integer value indicating the coverage mask size. See <b>glSampleCoverage</b>().

       <b>GL_SCISSOR_BOX</b>
           <u>data</u> returns four values: the x and y window coordinates of the scissor box, followed by its width
           and height. Initially the x and y window coordinates are both 0 and the width and height are set to
           the size of the window. See <b>glScissor</b>().

       <b>GL_SCISSOR_TEST</b>
           <u>data</u> returns a single boolean value indicating whether scissoring is enabled. The initial value is
           <b>GL_FALSE</b>. See <b>glScissor</b>().

       <b>GL_SHADER_COMPILER</b>
           <u>data</u> returns a single boolean value indicating whether an online shader compiler is present in the
           implementation. All desktop OpenGL implementations must support online shader compilations, and
           therefore the value of <b>GL_SHADER_COMPILER</b> will always be <b>GL_TRUE</b>.

       <b>GL_SHADER_STORAGE_BUFFER_BINDING</b>
           When used with non-indexed variants of <b>glGet</b> (such as <b>glGetIntegerv</b>), <u>data</u> returns a single value,
           the name of the buffer object currently bound to the target <b>GL_SHADER_STORAGE_BUFFER</b>. If no buffer
           object is bound to this target, 0 is returned. When used with indexed variants of <b>glGet</b> (such as
           <b>glGetIntegeri_v</b>), <u>data</u> returns a single value, the name of the buffer object bound to the indexed
           shader storage buffer binding points. The initial value is 0 for all targets. See <b>glBindBuffer</b>(),
           <b>glBindBufferBase</b>(), and <b>glBindBufferRange</b>().

       <b>GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT</b>
           <u>data</u> returns a single value, the minimum required alignment for shader storage buffer sizes and
           offset. The initial value is 1. See <b>glShaderStorageBlockBinding</b>().

       <b>GL_SHADER_STORAGE_BUFFER_START</b>
           When used with indexed variants of <b>glGet</b> (such as <b>glGetInteger64i_v</b>), <u>data</u> returns a single value,
           the start offset of the binding range for each indexed shader storage buffer binding. The initial
           value is 0 for all bindings. See <b>glBindBufferRange</b>().

       <b>GL_SHADER_STORAGE_BUFFER_SIZE</b>
           When used with indexed variants of <b>glGet</b> (such as <b>glGetInteger64i_v</b>), <u>data</u> returns a single value,
           the size of the binding range for each indexed shader storage buffer binding. The initial value is 0
           for all bindings. See <b>glBindBufferRange</b>().

       <b>GL_SMOOTH_LINE_WIDTH_RANGE</b>
           <u>data</u> returns a pair of values indicating the range of widths supported for smooth (antialiased)
           lines. See <b>glLineWidth</b>().

       <b>GL_SMOOTH_LINE_WIDTH_GRANULARITY</b>
           <u>data</u> returns a single value indicating the level of quantization applied to smooth line width
           parameters.

       <b>GL_STENCIL_BACK_FAIL</b>
           <u>data</u> returns one value, a symbolic constant indicating what action is taken for back-facing polygons
           when the stencil test fails. The initial value is <b>GL_KEEP</b>. See <b>glStencilOpSeparate</b>().

       <b>GL_STENCIL_BACK_FUNC</b>
           <u>data</u> returns one value, a symbolic constant indicating what function is used for back-facing polygons
           to compare the stencil reference value with the stencil buffer value. The initial value is <b>GL_ALWAYS</b>.
           See <b>glStencilFuncSeparate</b>().

       <b>GL_STENCIL_BACK_PASS_DEPTH_FAIL</b>
           <u>data</u> returns one value, a symbolic constant indicating what action is taken for back-facing polygons
           when the stencil test passes, but the depth test fails. The initial value is <b>GL_KEEP</b>. See
           <b>glStencilOpSeparate</b>().

       <b>GL_STENCIL_BACK_PASS_DEPTH_PASS</b>
           <u>data</u> returns one value, a symbolic constant indicating what action is taken for back-facing polygons
           when the stencil test passes and the depth test passes. The initial value is <b>GL_KEEP</b>. See
           <b>glStencilOpSeparate</b>().

       <b>GL_STENCIL_BACK_REF</b>
           <u>data</u> returns one value, the reference value that is compared with the contents of the stencil buffer
           for back-facing polygons. The initial value is 0. See <b>glStencilFuncSeparate</b>().

       <b>GL_STENCIL_BACK_VALUE_MASK</b>
           <u>data</u> returns one value, the mask that is used for back-facing polygons to mask both the stencil
           reference value and the stencil buffer value before they are compared. The initial value is all 1's.
           See <b>glStencilFuncSeparate</b>().

       <b>GL_STENCIL_BACK_WRITEMASK</b>
           <u>data</u> returns one value, the mask that controls writing of the stencil bitplanes for back-facing
           polygons. The initial value is all 1's. See <b>glStencilMaskSeparate</b>().

       <b>GL_STENCIL_CLEAR_VALUE</b>
           <u>data</u> returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0.
           See <b>glClearStencil</b>().

       <b>GL_STENCIL_FAIL</b>
           <u>data</u> returns one value, a symbolic constant indicating what action is taken when the stencil test
           fails. The initial value is <b>GL_KEEP</b>. See <b>glStencilOp</b>(). This stencil state only affects non-polygons
           and front-facing polygons. Back-facing polygons use separate stencil state. See
           <b>glStencilOpSeparate</b>().

       <b>GL_STENCIL_FUNC</b>
           <u>data</u> returns one value, a symbolic constant indicating what function is used to compare the stencil
           reference value with the stencil buffer value. The initial value is <b>GL_ALWAYS</b>. See <b>glStencilFunc</b>().
           This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use
           separate stencil state. See <b>glStencilFuncSeparate</b>().

       <b>GL_STENCIL_PASS_DEPTH_FAIL</b>
           <u>data</u> returns one value, a symbolic constant indicating what action is taken when the stencil test
           passes, but the depth test fails. The initial value is <b>GL_KEEP</b>. See <b>glStencilOp</b>(). This stencil state
           only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state.
           See <b>glStencilOpSeparate</b>().

       <b>GL_STENCIL_PASS_DEPTH_PASS</b>
           <u>data</u> returns one value, a symbolic constant indicating what action is taken when the stencil test
           passes and the depth test passes. The initial value is <b>GL_KEEP</b>. See <b>glStencilOp</b>(). This stencil state
           only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state.
           See <b>glStencilOpSeparate</b>().

       <b>GL_STENCIL_REF</b>
           <u>data</u> returns one value, the reference value that is compared with the contents of the stencil buffer.
           The initial value is 0. See <b>glStencilFunc</b>(). This stencil state only affects non-polygons and
           front-facing polygons. Back-facing polygons use separate stencil state. See <b>glStencilFuncSeparate</b>().

       <b>GL_STENCIL_TEST</b>
           <u>data</u> returns a single boolean value indicating whether stencil testing of fragments is enabled. The
           initial value is <b>GL_FALSE</b>. See <b>glStencilFunc</b>() and <b>glStencilOp</b>().

       <b>GL_STENCIL_VALUE_MASK</b>
           <u>data</u> returns one value, the mask that is used to mask both the stencil reference value and the
           stencil buffer value before they are compared. The initial value is all 1's. See <b>glStencilFunc</b>().
           This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use
           separate stencil state. See <b>glStencilFuncSeparate</b>().

       <b>GL_STENCIL_WRITEMASK</b>
           <u>data</u> returns one value, the mask that controls writing of the stencil bitplanes. The initial value is
           all 1's. See <b>glStencilMask</b>(). This stencil state only affects non-polygons and front-facing polygons.
           Back-facing polygons use separate stencil state. See <b>glStencilMaskSeparate</b>().

       <b>GL_STEREO</b>
           <u>data</u> returns a single boolean value indicating whether stereo buffers (left and right) are supported.

       <b>GL_SUBPIXEL_BITS</b>
           <u>data</u> returns one value, an estimate of the number of bits of subpixel resolution that are used to
           position rasterized geometry in window coordinates. The value must be at least 4.

       <b>GL_TEXTURE_BINDING_1D</b>
           <u>data</u> returns a single value, the name of the texture currently bound to the target <b>GL_TEXTURE_1D</b>. The
           initial value is 0. See <b>glBindTexture</b>().

       <b>GL_TEXTURE_BINDING_1D_ARRAY</b>
           <u>data</u> returns a single value, the name of the texture currently bound to the target
           <b>GL_TEXTURE_1D_ARRAY</b>. The initial value is 0. See <b>glBindTexture</b>().

       <b>GL_TEXTURE_BINDING_2D</b>
           <u>data</u> returns a single value, the name of the texture currently bound to the target <b>GL_TEXTURE_2D</b>. The
           initial value is 0. See <b>glBindTexture</b>().

       <b>GL_TEXTURE_BINDING_2D_ARRAY</b>
           <u>data</u> returns a single value, the name of the texture currently bound to the target
           <b>GL_TEXTURE_2D_ARRAY</b>. The initial value is 0. See <b>glBindTexture</b>().

       <b>GL_TEXTURE_BINDING_2D_MULTISAMPLE</b>
           <u>data</u> returns a single value, the name of the texture currently bound to the target
           <b>GL_TEXTURE_2D_MULTISAMPLE</b>. The initial value is 0. See <b>glBindTexture</b>().

       <b>GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY</b>
           <u>data</u> returns a single value, the name of the texture currently bound to the target
           <b>GL_TEXTURE_2D_MULTISAMPLE_ARRAY</b>. The initial value is 0. See <b>glBindTexture</b>().

       <b>GL_TEXTURE_BINDING_3D</b>
           <u>data</u> returns a single value, the name of the texture currently bound to the target <b>GL_TEXTURE_3D</b>. The
           initial value is 0. See <b>glBindTexture</b>().

       <b>GL_TEXTURE_BINDING_BUFFER</b>
           <u>data</u> returns a single value, the name of the texture currently bound to the target <b>GL_TEXTURE_BUFFER</b>.
           The initial value is 0. See <b>glBindTexture</b>().

       <b>GL_TEXTURE_BINDING_CUBE_MAP</b>
           <u>data</u> returns a single value, the name of the texture currently bound to the target
           <b>GL_TEXTURE_CUBE_MAP</b>. The initial value is 0. See <b>glBindTexture</b>().

       <b>GL_TEXTURE_BINDING_RECTANGLE</b>
           <u>data</u> returns a single value, the name of the texture currently bound to the target
           <b>GL_TEXTURE_RECTANGLE</b>. The initial value is 0. See <b>glBindTexture</b>().

       <b>GL_TEXTURE_COMPRESSION_HINT</b>
           <u>data</u> returns a single value indicating the mode of the texture compression hint. The initial value is
           <b>GL_DONT_CARE</b>.

       <b>GL_TEXTURE_BINDING_BUFFER</b>
           <u>data</u> returns a single value, the name of the buffer object currently bound to the <b>GL_TEXTURE_BUFFER</b>
           buffer binding point. The initial value is 0. See <b>glBindBuffer</b>().

       <b>GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT</b>
           <u>data</u> returns a single value, the minimum required alignment for texture buffer sizes and offset. The
           initial value is 1. See <b>glUniformBlockBinding</b>().

       <b>GL_TIMESTAMP</b>
           <u>data</u> returns a single value, the 64-bit value of the current GL time. See <b>glQueryCounter</b>().

       <b>GL_TRANSFORM_FEEDBACK_BUFFER_BINDING</b>
           When used with non-indexed variants of <b>glGet</b> (such as <b>glGetIntegerv</b>), <u>data</u> returns a single value,
           the name of the buffer object currently bound to the target <b>GL_TRANSFORM_FEEDBACK_BUFFER</b>. If no
           buffer object is bound to this target, 0 is returned. When used with indexed variants of <b>glGet</b> (such
           as <b>glGetIntegeri_v</b>), <u>data</u> returns a single value, the name of the buffer object bound to the indexed
           transform feedback attribute stream. The initial value is 0 for all targets. See <b>glBindBuffer</b>(),
           <b>glBindBufferBase</b>(), and <b>glBindBufferRange</b>().

       <b>GL_TRANSFORM_FEEDBACK_BUFFER_START</b>
           When used with indexed variants of <b>glGet</b> (such as <b>glGetInteger64i_v</b>), <u>data</u> returns a single value,
           the start offset of the binding range for each transform feedback attribute stream. The initial value
           is 0 for all streams. See <b>glBindBufferRange</b>().

       <b>GL_TRANSFORM_FEEDBACK_BUFFER_SIZE</b>
           When used with indexed variants of <b>glGet</b> (such as <b>glGetInteger64i_v</b>), <u>data</u> returns a single value,
           the size of the binding range for each transform feedback attribute stream. The initial value is 0
           for all streams. See <b>glBindBufferRange</b>().

       <b>GL_UNIFORM_BUFFER_BINDING</b>
           When used with non-indexed variants of <b>glGet</b> (such as <b>glGetIntegerv</b>), <u>data</u> returns a single value,
           the name of the buffer object currently bound to the target <b>GL_UNIFORM_BUFFER</b>. If no buffer object is
           bound to this target, 0 is returned. When used with indexed variants of <b>glGet</b> (such as
           <b>glGetIntegeri_v</b>), <u>data</u> returns a single value, the name of the buffer object bound to the indexed
           uniform buffer binding point. The initial value is 0 for all targets. See <b>glBindBuffer</b>(),
           <b>glBindBufferBase</b>(), and <b>glBindBufferRange</b>().

       <b>GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT</b>
           <u>data</u> returns a single value, the minimum required alignment for uniform buffer sizes and offset. The
           initial value is 1. See <b>glUniformBlockBinding</b>().

       <b>GL_UNIFORM_BUFFER_SIZE</b>
           When used with indexed variants of <b>glGet</b> (such as <b>glGetInteger64i_v</b>), <u>data</u> returns a single value,
           the size of the binding range for each indexed uniform buffer binding. The initial value is 0 for all
           bindings. See <b>glBindBufferRange</b>().

       <b>GL_UNIFORM_BUFFER_START</b>
           When used with indexed variants of <b>glGet</b> (such as <b>glGetInteger64i_v</b>), <u>data</u> returns a single value,
           the start offset of the binding range for each indexed uniform buffer binding. The initial value is 0
           for all bindings. See <b>glBindBufferRange</b>().

       <b>GL_UNPACK_ALIGNMENT</b>
           <u>data</u> returns one value, the byte alignment used for reading pixel data from memory. The initial value
           is 4. See <b>glPixelStore</b>().

       <b>GL_UNPACK_IMAGE_HEIGHT</b>
           <u>data</u> returns one value, the image height used for reading pixel data from memory. The initial is 0.
           See <b>glPixelStore</b>().

       <b>GL_UNPACK_LSB_FIRST</b>
           <u>data</u> returns a single boolean value indicating whether single-bit pixels being read from memory are
           read first from the least significant bit of each unsigned byte. The initial value is <b>GL_FALSE</b>. See
           <b>glPixelStore</b>().

       <b>GL_UNPACK_ROW_LENGTH</b>
           <u>data</u> returns one value, the row length used for reading pixel data from memory. The initial value is
           0. See <b>glPixelStore</b>().

       <b>GL_UNPACK_SKIP_IMAGES</b>
           <u>data</u> returns one value, the number of pixel images skipped before the first pixel is read from
           memory. The initial value is 0. See <b>glPixelStore</b>().

       <b>GL_UNPACK_SKIP_PIXELS</b>
           <u>data</u> returns one value, the number of pixel locations skipped before the first pixel is read from
           memory. The initial value is 0. See <b>glPixelStore</b>().

       <b>GL_UNPACK_SKIP_ROWS</b>
           <u>data</u> returns one value, the number of rows of pixel locations skipped before the first pixel is read
           from memory. The initial value is 0. See <b>glPixelStore</b>().

       <b>GL_UNPACK_SWAP_BYTES</b>
           <u>data</u> returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel
           indices and components are swapped after being read from memory. The initial value is <b>GL_FALSE</b>. See
           <b>glPixelStore</b>().

       <b>GL_VERTEX_ARRAY_BINDING</b>
           <u>data</u> returns a single value, the name of the vertex array object currently bound to the context. If
           no vertex array object is bound to the context, 0 is returned. The initial value is 0. See
           <b>glBindVertexArray</b>().

       <b>GL_VERTEX_BINDING_DIVISOR</b>
           Accepted by the indexed forms.  <u>data</u> returns a single integer value representing the instance step
           divisor of the first element in the bound buffer's data store for vertex attribute bound to <u>index</u>.

       <b>GL_VERTEX_BINDING_OFFSET</b>
           Accepted by the indexed forms.  <u>data</u> returns a single integer value representing the byte offset of
           the first element in the bound buffer's data store for vertex attribute bound to <u>index</u>.

       <b>GL_VERTEX_BINDING_STRIDE</b>
           Accepted by the indexed forms.  <u>data</u> returns a single integer value representing the byte offset
           between the start of each element in the bound buffer's data store for vertex attribute bound to
           <u>index</u>.

       <b>GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET</b>
           <u>data</u> returns a single integer value containing the maximum offset that may be added to a vertex
           binding offset.

       <b>GL_MAX_VERTEX_ATTRIB_BINDINGS</b>
           <u>data</u> returns a single integer value containing the maximum number of vertex buffers that may be
           bound.

       <b>GL_VIEWPORT</b>
           When used with non-indexed variants of <b>glGet</b> (such as <b>glGetIntegerv</b>), <u>data</u> returns four values: the x
           and y window coordinates of the viewport, followed by its width and height. Initially the x and y
           window coordinates are both set to 0, and the width and height are set to the width and height of the
           window into which the GL will do its rendering. See <b>glViewport</b>().

           When used with indexed variants of <b>glGet</b> (such as <b>glGetIntegeri_v</b>), <u>data</u> returns four values: the x
           and y window coordinates of the indexed viewport, followed by its width and height. Initially the x
           and y window coordinates are both set to 0, and the width and height are set to the width and height
           of the window into which the GL will do its rendering. See

           <b>glViewportIndexedf</b>.

       <b>GL_VIEWPORT_BOUNDS_RANGE</b>
           <u>data</u> returns two values, the minimum and maximum viewport bounds range. The minimum range should be
           at least [-32768, 32767].

       <b>GL_VIEWPORT_INDEX_PROVOKING_VERTEX</b>
           <u>data</u> returns one value, the implementation dependent specifc vertex of a primitive that is used to
           select the viewport index. If the value returned is equivalent to <b>GL_PROVOKING_VERTEX</b>, then the
           vertex selection follows the convention specified by <b>glProvokingVertex</b>(). If the value returned is
           equivalent to <b>GL_FIRST_VERTEX_CONVENTION</b>, then the selection is always taken from the first vertex in
           the primitive. If the value returned is equivalent to <b>GL_LAST_VERTEX_CONVENTION</b>, then the selection
           is always taken from the last vertex in the primitive. If the value returned is equivalent to
           <b>GL_UNDEFINED_VERTEX</b>, then the selection is not guaranteed to be taken from any specific vertex in the
           primitive.

       <b>GL_VIEWPORT_SUBPIXEL_BITS</b>
           <u>data</u> returns a single value, the number of bits of sub-pixel precision which the GL uses to interpret
           the floating point viewport bounds. The minimum value is 0.

       <b>GL_MAX_ELEMENT_INDEX</b>
           <u>data</u> returns a single value, the maximum index that may be specified during the transfer of generic
           vertex attributes to the GL.

       Many of the boolean parameters can also be queried more easily using <b>glIsEnabled</b>().

</pre><h4><b>NOTES</b></h4><pre>
       The following parameters return the associated value for the active texture unit: <b>GL_TEXTURE_1D</b>,
       <b>GL_TEXTURE_BINDING_1D</b>, <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_BINDING_2D</b>, <b>GL_TEXTURE_3D</b> and <b>GL_TEXTURE_BINDING_3D</b>.

       <b>GL_MAX_VIEWPORTS</b>, <b>GL_VIEWPORT_SUBPIXEL_BITS</b>, <b>GL_VIEWPORT_BOUNDS_RANGE</b>, <b>GL_LAYER_PROVOKING_VERTEX</b>, and
       <b>GL_VIEWPORT_INDEX_PROVOKING_VERTEX</b> are available only if the GL version is 4.1 or greater.

       <b>GL_MAX_VERTEX_ATOMIC_COUNTERS</b>, <b>GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS</b>,
       <b>GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS</b>, <b>GL_MAX_GEOMETRY_ATOMIC_COUNTERS</b>, <b>GL_MAX_FRAMGENT_ATOMIC_COUNTERS</b>,
       and <b>GL_MIN_MAP_BUFFER_ALIGNMENT</b> are accepted by <u>pname</u> only if the GL version is 4.2 or greater.

       <b>GL_MAX_ELEMENT_INDEX</b> is accepted by <u>pname</u> only if the GL version is 4.3 or greater.

       <b>GL_MAX_COMPUTE_UNIFORM_BLOCKS</b>, <b>GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS</b>, <b>GL_MAX_COMPUTE_UNIFORM_COMPONENTS</b>,
       <b>GL_MAX_COMPUTE_ATOMIC_COUNTERS</b>, <b>GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS</b>,
       <b>GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS</b>, <b>GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS</b>,
       <b>GL_MAX_COMPUTE_WORK_GROUP_COUNT</b>, and <b>GL_MAX_COMPUTE_WORK_GROUP_SIZE</b> and
       <b>GL_DISPATCH_INDIRECT_BUFFER_BINDING</b> are available only if the GL version is 4.3 or greater.

       <b>GL_MAX_DEBUG_GROUP_STACK_DEPTH</b>, <b>GL_DEBUG_GROUP_STACK_DEPTH</b> and <b>GL_MAX_LABEL_LENGTH</b> are accepted only if
       the GL version is 4.3 or greater.

       <b>GL_MAX_UNIFORM_LOCATIONS</b> is accepted only if the GL version is 4.3 or greater.

       <b>GL_MAX_FRAMEBUFFER_WIDTH</b>, <b>GL_MAX_FRAMEBUFFER_HEIGHT</b>, <b>GL_MAX_FRAMEBUFFER_LAYERS</b>, and
       <b>GL_MAX_FRAMEBUFFER_SAMPLES</b> are available only if the GL version is 4.3 or greater.

       <b>GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS</b>, <b>GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS</b>,
       <b>GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS</b>, <b>GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS</b>,
       <b>GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS</b>, and <b>GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS</b> are available only if the
       GL version is 4.3 or higher.

       <b>GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT</b> is available only if the GL version is 4.3 or greater.

       <b>GL_VERTEX_BINDING_DIVISOR</b>, <b>GL_VERTEX_BINDING_OFFSET</b>, <b>GL_VERTEX_BINDING_STRIDE</b>,
       <b>GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET</b> and <b>GL_MAX_VERTEX_ATTRIB_BINDINGS</b> are available only if the GL
       version is 4.3 or greater.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>GL_INVALID_ENUM</b> is generated if <u>pname</u> is not an accepted value.

       <b>GL_INVALID_VALUE</b> is generated on any of <b>glGetBooleani_v</b>, <b>glGetIntegeri_v</b>, or <b>glGetInteger64i_v</b> if <u>index</u>
       is outside of the valid range for the indexed state <u>target</u>.

</pre><h4><b>VERSION</b> <b>SUPPORT</b></h4><pre>
       ┌───────────────────┬───────────────────────────────────────────────────────────────────────┐
       │                   │                <b>OpenGL</b> <b>Version</b>                                         │
       ├───────────────────┼─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┤
       │ <b>Function</b>          │ <b>2.0</b> │ <b>2.1</b> │ <b>3.0</b> │ <b>3.1</b> │ <b>3.2</b> │ <b>3.3</b> │ <b>4.0</b> │ <b>4.1</b> │ <b>4.2</b> │ <b>4.3</b> │ <b>4.4</b> │ <b>4.5</b> │
       │ <b>/</b>                 │     │     │     │     │     │     │     │     │     │     │     │     │
       │ <b>Feature</b>           │     │     │     │     │     │     │     │     │     │     │     │     │
       │ <b>Name</b>              │     │     │     │     │     │     │     │     │     │     │     │     │
       ├───────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glGetBooleani_v</b>   │  -  │  -  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       ├───────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glGetBooleanv</b>     │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       ├───────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glGetDoublei_v</b>    │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       ├───────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glGetDoublev</b>      │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       ├───────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glGetFloati_v</b>     │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       ├───────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glGetFloatv</b>       │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       ├───────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glGetInteger64i_v</b> │  -  │  -  │  -  │  -  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       ├───────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glGetInteger64v</b>   │  -  │  -  │  -  │  -  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       ├───────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glGetIntegeri_v</b>   │  -  │  -  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       ├───────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glGetIntegerv</b>     │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       └───────────────────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>glGetActiveUniform</b>(), <b>glGetAttachedShaders</b>(), <b>glGetAttribLocation</b>(), <b>glGetBufferParameter</b>(),
       <b>glGetBufferPointerv</b>(), <b>glGetBufferSubData</b>(), <b>glGetCompressedTexImage</b>(), <b>glGetError</b>(), <b>glGetProgram</b>(),
       <b>glGetProgramInfoLog</b>(), <b>glGetQueryiv</b>(), <b>glGetQueryObject</b>(), <b>glGetShader</b>(), <b>glGetShaderInfoLog</b>(),
       <b>glGetShaderSource</b>(), <b>glGetString</b>(), <b>glGetTexImage</b>(), <b>glGetTexLevelParameter</b>(), <b>glGetTexParameter</b>(),
       <b>glGetUniform</b>(), <b>glGetUniformLocation</b>(), <b>glGetVertexAttrib</b>(), <b>glGetVertexAttribPointerv</b>(), <b>glIsEnabled</b>()

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is
       licensed under the SGI Free Software B License. For details, see <b><a href="http://oss.sgi.com/projects/FreeB/">http://oss.sgi.com/projects/FreeB/</a></b>.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 1991-2006 Silicon Graphics, Inc.
       Copyright © 2010-2014 Khronos Group

[FIXME: source]                                    11/18/2024                                          <u><a href="../man3G/GLGET.3G.html">GLGET</a></u>(3G)
</pre>
 </div>
</div></section>
</div>
</body>
</html>