<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Table - Data type related to database tables, spreadsheets, CSV/TSV files, HTML table displays,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-table-perl">libdata-table-perl_1.78-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Table - Data type related to database tables, spreadsheets, CSV/TSV files, HTML table displays,
       etc.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         News: The package now includes "Perl Data::Table Cookbook" (PDF), which may serve as a better learning material.
         To download the free Cookbook, visit https://sites.google.com/site/easydatabase/

         # some cool ways to use Table.pm
         use Data::Table;

         $header = ["name", "age"];
         $data = [
           ["John", 20],
           ["Kate", 18],
           ["Mike", 23]
         ];
         $t = Data::Table-&gt;new($data, $header, 0);     # Construct a table object with
                                               # $data, $header, $type=0 (consider
                                               # $data as the rows of the table).
         print $t-&gt;csv;                        # Print out the table as a csv file.

         $t = Data::Table::fromCSV("aaa.csv");       # Read a csv file into a table object
         ### Since version 1.51, a new method fromFile can automatically guess the correct file format
         # either CSV or TSV file, file with or without a column header line
         # e.g.
         #   $t = Data::Table::fromFile("aaa.csv");
         # is equivalent.
         print $t-&gt;html;                       # Display a 'portrait' HTML TABLE on web.

         use DBI;
         $dbh= DBI-&gt;connect("DBI:mysql:test", "test", "") or die $DBI::errstr;
         my $minAge = 10;
         $t = Data::Table::fromSQL($dbh, "select * from mytable where age &gt;= ?", [$minAge]);
                                               # Construct a table form an SQL
                                               # database query.

         $t-&gt;sort("age", 0, 0);                # Sort by col 'age',numerical,ascending
         print $t-&gt;html2;                      # Print out a 'landscape' HTML Table.

         $row = $t-&gt;<a href="../man2/delRow.2.html">delRow</a>(2);                 # Delete the third row (index=2).
         $t-&gt;addRow($row, 4);                  # Add the deleted row back as fifth row.
         @rows = $t-&gt;delRows([0..2]);          # Delete three rows (row 0 to 2).
         $col = $t-&gt;delCol("age");             # Delete column 'age'.
         $t-&gt;addCol($col, "age",2);            # Add column 'age' as the third column
         @cols = $t-&gt;delCols(["name","phone","ssn"]);
                                               # Delete 3 columns at the same time.

         $name =  $t-&gt;elm(2,"name");           # Element access
         $t2=$t-&gt;subTable([1, 3..4],['age', 'name']);
                                               # Extract a sub-table

         $t-&gt;rename("Entry", "New Entry");     # Rename column 'Entry' by 'New Entry'
         $t-&gt;replace("Entry", [1..$t-&gt;nofRow()], "New Entry");
                                               # Replace column 'Entry' by an array of
                                               # numbers and rename it as 'New Entry'
         $t-&gt;swap("age","ssn");                # Swap the positions of column 'age'
                                               # with column 'ssn' in the table.

         $t-&gt;colMap('name', sub {return uc});  # Map a function to a column
         $t-&gt;sort('age',0,0,'name',1,0);       # Sort table first by the numerical
                                               # column 'age' and then by the
                                               # string column 'name' in ascending
                                               # order
         $t2=$t-&gt;match_pattern('$_-&gt;[0] =~ /^L/ &amp;&amp; $_-&gt;[3]&lt;0.2');
                                               # Select the rows that matched the
                                               # pattern specified
         $t2=$t-&gt;match_pattern_hash('$_{"Amino acid"} =~ /^L-a/ &amp;&amp; $_{"Grams \"(a.a.)\""}&lt;0.2'));
                 # use column name in the pattern, method added in 1.62
         $t2=$t-&gt;match_string('John');         # Select the rows that matches 'John'
                                               # in any column

         $t2=$t-&gt;clone();                      # Make a copy of the table.
         $t-&gt;rowMerge($t2);                    # Merge two tables
         $t-&gt;colMerge($t2);

         $t = Data::Table-&gt;new(                 # create an employ salary table
           [
             ['Tom', 'male', 'IT', 65000],
             ['John', 'male', 'IT', 75000],
             ['Tom', 'male', 'IT', 65000],
             ['John', 'male', 'IT', 75000],
             ['Peter', 'male', 'HR', 85000],
             ['Mary', 'female', 'HR', 80000],
             ['Nancy', 'female', 'IT', 55000],
             ['Jack', 'male', 'IT', 88000],
             ['Susan', 'female', 'HR', 92000]
           ],
           ['Name', 'Sex', 'Department', 'Salary'], 0);

         sub average {  # this is an subroutine calculate mathematical average, ignore NULL
           my @data = @_;
           my ($sum, $n) = (0, 0);
           foreach $x (@data) {
             next unless $x;
             $sum += $x; $n++;
           }
           return ($n&gt;0)?$sum/$n:undef;
         }

         $t2 = $t-&gt;group(["Department","Sex"],["Name", "Salary"], [sub {scalar @_}, \&amp;average], ["Nof Employee", "Average Salary"]);
         # For each (Department,Sex) pair, calculate the number of employees and average salary
         $t2 = $t2-&gt;pivot("Sex", 0, "Average Salary", ["Department"]);
         # Show average salary information in a Department by Sex spreadsheet

</pre><h4><b>ABSTRACT</b></h4><pre>
       This perl package uses perl5 objects to make it easy for manipulating spreadsheet data among disk files,
       database, and Web publishing.

       A table object contains a header and a two-dimensional array of scalars.  Four class methods
       Data::fromFile, Data::Table::fromCSV, Data::Table::fromTSV, and Data::Table::fromSQL allow users to
       create a table object from a CSV/TSV file or a database SQL selection in a snap.

       Table methods provide basic access, add, delete row(s) or column(s) operations, as well as more advanced
       sub-table extraction, table sorting, record matching via keywords or patterns, table merging, and web
       publishing.  Data::Table class also provides a straightforward interface to other popular Perl modules
       such as DBI and GD::Graph.

       The most updated version of the Perl Data::Table Cookbook is available at
        https://sites.google.com/site/easydatabase/

       We use Data::Table instead of Table, because Table.pm has already been used inside PerlQt module in CPAN.

</pre><h4><b>INTRODUCTION</b></h4><pre>
       A table object has three data members:

       1. $data:
           a reference to an array of array-references.  It's basically a reference to a two-dimensional array.

       2. $header:
           a reference to a string array. The array contains all the column names.

       3. $type = 1 or 0.
           1  means  that @$data is an array of table columns (fields) (column-based); 0 means that @$data is an
           array of table rows (records) (row-based);

       Row-based/Column-based are two internal implementations for a  table  object.   E.g.,  if  a  spreadsheet
       consists of two columns lastname and age.  In a row-based table, $data = [ ['Smith', 29], ['Dole', 32] ].
       In a column-based table, $data = [ ['Smith', 'Dole'], [29, 32] ].

       Two  implementations  have  their  pros  and  cons for different operations.  Row-based implementation is
       better for sorting and pattern matching, while column-based one is  better  for  adding/deleting/swapping
       columns.

       Users  only  need to specify the implementation type of the table upon its creation via Data::Table::new,
       and can forget about it afterwards.  Implementation type  of  a  table  should  be  considered  volatile,
       because  methods  switch  table  objects  from  one  type  into  another  internally.   Be  advised  that
       row/column/element references gained via table::rowRef, table::rowRefs, table::colRef, table::colRefs, or
       table::elmRef may become stale after other method calls afterwards.

       For those who want to inherit from the Data::Table class, internal method table::rotate is used to switch
       from one implementation type into another.  There is an  additional  internal  assistant  data  structure
       called  colHash  in  our  current  implementation.  This  hash  table  stores  all column names and their
       corresponding column index number as key-value pairs for fast conversion. This gives users an  option  to
       use  column name wherever a column ID is expected, so that user don't have to use table::colIndex all the
       time.     E.g.,     you     may     say     $t-&gt;rename('oldColName',     'newColName')     instead     of
       $t-&gt;rename($t-&gt;colIndex('oldColName'), 'newColIdx').

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Field</b> <b>Summary</b>
       data refto_arrayof_refto_array
           contains a two-dimensional spreadsheet data.

       header refto_array
           contains all column names.

       type 0/1
           0 is row-based, 1 is column-based, describe the orientation of @$data.

   <b>Package</b> <b>Variables</b>
       $Data::Table::VERSION
       @Data::Table::OK
           see table::match_string, table::match_pattern, and table::match_pattern_hash Since 1.62, we recommend
           you to use $table-&gt;{OK} instead, which is a local array reference.

       @Data::Table::MATCH
           see  table::match_string,  table::match_pattern,  and table::match_pattern_hash Since 1.67, we return
           the matched row indices in an array.  Data::Table::MATCH is this array reference.  Here is an example
           of setting a max price of 20 to all items with UnitPrice &gt; 20.

               $t_product-&gt;match_pattern_hash('$_{UnitPrice} &gt; 20');
               $t_product-&gt;setElm($t_product-&gt;{MATCH}, 'UnitPrice', 20);

       %Data::Table::DEFAULTS
           Store default settings, currently it contains CSV_DELIMITER (set to ','), CSV_QUALIFER (set to  '"'),
           and OS (set to 0).  see table::fromCSV, table::csv, table::fromTSV, table::tsv for details.

   <b>Class</b> <b>Methods</b>
       Syntax: return_type method_name ( [ parameter [ = default_value ]] [, parameter [ = default_value ]] )

       If  method_name starts with table::, this is an instance method, it can be used as $t-&gt;method( parameters
       ), where $t is a table reference.

       If method_name starts with Data::Table::, this is a class method, it should be called as
         Data::Table::method, e.g., $t = Data::Table::fromCSV("filename.csv").

       Conventions for local variables:

         colID: either a numerical column index or a column name;
         rowIdx: numerical row index;
         rowIDsRef: reference to an array of column IDs;
         rowIdcsRef: reference to an array of row indices;
         rowRef, colRef: reference to an array of scalars;
         data: ref_to_array_of_ref_to_array of data values;
         header: ref to array of column headers;
         table: a table object, a blessed reference.

   <b>Table</b> <b>Creation</b>
       table Data::Table::new ( $data = [], $header = [], $type = 0, $enforceCheck = 1)
           create a new table.  It returns a table object upon success, undef otherwise.  $data: points  to  the
           spreadsheet  data.   $header:  points to an array of column names. Before version 1.69, a column name
           must have at least one non-digit character. Since version 1 .69, this is  relaxed.  Although  integer
           and numeric column names can now be accepted, when accessing a column by integer, it is first interpr
           eted  as a column name.  $type: 0 or 1 for row-based/column-based spreadsheet.  $enforceCheck: 1/0 to
           turn on/off initial checking on the size of each row/column to make sure  the  data  argument  indeed
           points  to  a  valid  s  tructure.   In  1.63,  we  introduce  constants  Data::Table::ROW_BASED  and
           Data::Table::COL_BASED  as  synonyms  for  $type.   To  create  an   empty   Data::Table,   use   new
           Data::Table([], [], Data::Table::ROW_BASED);

       table table::subTable ($rowIdcsRef, $colIDsRef, $arg_ref)
           create  a  new  table,  which  is a subset of the original.  It returns a table object.  $rowIdcsRef:
           points to an array of row indices (or a true/false row mask array).  $colIDsRef: points to  an  array
           of  column  IDs.   The  function make a copy of selected elements from the original table.  Undefined
           $rowIdcsRef or $colIDsRef is interpreted as all rows or all columns.  The elements in $colIDsRef  may
           be modified as a side effect before version 1.62, fixed in 1.62.  If $arg_ref-&gt;{useRowMask} is set to
           1,  $rowIdcsRef is a true/false row mask array, where rows marked as TRUE will be returned.  Row mask
           array is typically the Data::Table::OK set by match_string/match_pattern/match_pattern_hash methods.

       table table::clone
           make a clone of the original.  It return a table object, equivalent to table::subTable(undef,undef).

       table Data::Table::fromCSV ($name_or_handler, $includeHeader = 1, $header = ["col1", ... ],
       {OS=&gt;$Data::Table::DEFAULTS{'OS'}, delimiter=&gt;$Data::Table::DEFAULTS{'CSV_DELIMITER'},
       qualifier=&gt;$Data::Table::DEFAULTS{'CSV_QUALIFIER'}, skip_lines=&gt;0, skip_pattern=&gt;undef,
       encoding=&gt;$Data::Table::DEFAULTS{'ENCODING'}})
           create a table from a CSV file.  return a table object.  $name_or_handler: the CSV file  name  or  an
           already  opened  file handler. If a handler is used, it's not closed upon return. To read from STDIN,
           use Data::Table::fromCSV(\*STDIN, 1).  $includeHeader: 0 or 1 to ignore/interpret the first  line  in
           the  file  as  column  names,  If  it  is  set  to 0, the array in $header is used. If $header is not
           supplied, the default column names are "col1", "col2", ...   optional  named  argument  OS  specifies
           under  which  operating system the CSV file was generated. 0 for UNIX, 1 for PC and 2 for MAC. If not
           specified, $Data::Table::DEFAULTS{'OS'} is used, which  defaults  to  UNIX.  Basically  linebreak  is
           defined as "\n", "\r\n" and "\r" for three systems, respectively.

           optional  name  argument  delimiter  and  qualifier  let user replace comma and double-quote by other
           meaningful single characters. &lt;b&gt;Exception&lt;/b&gt;: if the delimiter or the qualifier is a special symbol
           in regular expression, you must escape it by '\'. For example, in order to use  pipe  symbol  as  the
           delimiter, you must specify the delimiter as '\|'.

           optional  name  argument skip_lines let you specify how many lines in the csv file should be skipped,
           before the data are interpretted.

           optional name argument skip_pattern let you specify  a  regular  expression.  Lines  that  match  the
           regular expression will be skipped.

           optional  name  argument encoding let you specify an encoding method of the csv file.  This option is
           added to fromCSV, fromTSV, fromFile since version 1.69.

           The following example reads a DOS format CSV file and writes a MAC format:

             $t = Data::Table:fromCSV('A_DOS_CSV_FILE.csv', 1, undef, {OS=&gt;1});
             $t-&gt;csv(1, {OS=&gt;2, file=&gt;'A_MAC_CSV_FILE.csv'});
             open(SRC, 'A_DOS_CSV_FILE.csv') or die "Cannot open A_DOS_CSV_FILE.csv to read!";
             $t = Data::Table::fromCSV(\*SRC, 1);
             close(SRC);

           The following example reads a non-standard CSV file with : as the delimiter, ' as the qaulifier

             my $s="col_A:col_B:col_C\n1:2, 3 or 5:3.5\none:'one:two':'double\", single'''";
             open my $fh, "&lt;", \$s or die "Cannot open in-memory file\n";
             my $t_fh=Data::Table::fromCSV($fh, 1, undef, {delimiter=&gt;':', qualifier=&gt;"'"});
             close($fh);
             print $t_fh-&gt;csv;
             # convert to the standard CSV (comma as the delimiter, double quote as the qualifier)
             # col_A,col_B,col_C
             # 1,"2, 3 or 5",3.5
             # one,one:two,"double"", single'"
             print $t-&gt;csv(1, {delimiter=&gt;':', qualifier=&gt;"'"}); # prints the csv file use the original definition

           The following example reads bbb.csv file (included  in  the  package)  by  skipping  the  first  line
           (skip_lines=&gt;1),   then  treats  any  line  that  starts  with  '#'  (or  space  comma)  as  comments
           (skip_pattern=&gt;'^\s*#'), use ':' as the delimiter.

             $t = Data::Table::fromCSV("bbb.csv", 1, undef, {skip_lines=&gt;1, delimiter=&gt;':', skip_pattern=&gt;'^\s*#'});

           Use the optional name argument encoding to specify file encoding method.
             $t = Data::Table::fromCSV("bbb.csv", 1, undef, {encoding=&gt;'UTF-8'});

       table table::fromCSVi ($name, $includeHeader = 1, $header = ["col1", ... ])
           Same as Data::Table::fromCSV. However, this is an instant method (that's what 'i' stands for),  which
           can be inherited.

       table Data::Table::fromTSV ($name, $includeHeader = 1, $header = ["col1", ... ],
       {OS=&gt;$Data::Table::DEFAULTS{'OS'}, skip_lines=&gt;0, skip_pattern=&gt;undef, transform_element=&gt;1,
       encoding=&gt;$Data::Table::DEFAULTS{'ENCODING'}})
           create  a  table  from  a  TSV  file.  return a table object.  $name: the TSV file name or an already
           opened file handler. If a handler is used, it's not closed upon return.   To  read  from  STDIN,  use
           Data::Table::fromTSV(\*STDIN,  1).   $includeHeader: 0 or 1 to ignore/interpret the first line in the
           file as column names, If it is set to 0, the array in $header is used. If $header  is  not  supplied,
           the  default  column  names are "col1", "col2", ...  optional named argument OS specifies under which
           operating system the TSV file was generated. 0 for UNIX, 1 for P C and 2 for MAC. If  not  specified,
           $Data::Table::DEFAULTS{'OS'} is used, which defaults to UNIX. Basically linebreak is defined as "\n",
           "\r\n" and "\r" for three systems, respectively.  &lt;b&gt;Exception&lt;/b&gt;: if the delimiter or the qualifier
           is  a  special  symbol in regular expression, you must escape it by '\'. For example, in order to use
           pipe symbol as the delimiter, you must specify the delimiter as '\|'.

           optional name argument skip_lines let you specify how many lines in the csv file should  be  skipped,
           before the data are interpretted.

           optional  name  argument  skip_pattern  let  you  specify  a regular expression. Lines that match the
           regular expression will be skipped.

           optional name argument transform_element let you  switch  on/off  \t  to  tab,  \N  to  undef  (etc.)
           transformation.  See  TSV  FORMAT  for  details. However, elements are always transformed when export
           table to tsv format, because not escaping an element containing a tab will be disasterous.

           optional name argument encoding enables one to provide an encoding method when open the tsv file.

           See similar examples under Data::Table::fromCSV;

           Note: read "TSV FORMAT" section for details.

       table table::fromTSVi ($name, $includeHeader = 1, $header = ["col1", ... ])
           Same as Data::Table::fromTSV. However, this is an instant method (that's what 'i' stands for),  which
           can be inherited.

       table Data::Table::fromFile ($file_name, $arg_ref = {linesChecked=&gt;2, allowNumericHeader=&gt;0,
       encoding=&gt;$Data::Table::DEFAULTS{'ENCODING'}})
           create  a  table  from a text file.  return a table object.  $file_name: the file name (cannot take a
           file handler).  linesChecked: the first number of lines used  for  guessing  the  input  format.  The
           delimiter  will have to produce the same number of columns for these lines. By default only check the
           first 2 lines, 0 means all lines in the file.  $arg_ref can take additional parameters, such  as  OS,
           has_header,  delimiter,  transform_element, etc. Encoding allows one to specify encoding methods used
           to open the file, which defaults to UTF-8.

           fromFile is added after version 1.51. It relies on the following new methods to automatically  figure
           out the correct file format in order to call fromCSV or fromTSV internally:

             fromFileGuessOS($file_name, {encoding=&gt;'UTF-8'})
               returns integer, 0 for UNIX, 1 for PC, 2 for MAC
             fromFileGetTopLines($file_name, $os, $lineNumber, {encoding=&gt;'UTF-8'}) # $os defaults to fromFileGuessOS($file_name), if not specified
               returns an array of strings, each string represents each row with linebreak removed.
             fromFileGuessDelimiter($lineArrayRef)       # guess delimiter from ",", "\t", ":";
               returns the guessed delimiter string.
             fromFileIsHeader($line_concent, $delimiter, $allowNumericHeader) # $delimiter defaults to $Data::Table::DEFAULTS{'CSV_DELIMITER'}
               returns 1 or 0.

           It  first  ask fromFileGuessOS to figure out which OS (UNIX, PC or MAC) generated the input file. The
           fetch the first linesChecked lines using fromFileGetTopLines. It  then  guesses  the  best  delimiter
           using  fromFileGuessDelimiter,  then it checks if the first line looks like a column header row using
           fromFileIsHeader. Since fromFileGuessOS and fromFileGetTopLines needs to open/close the  input  file,
           these  methods  can  only  take file name, not file handler. If user specify formatting parameters in
           $arg_ref, the routine will skip the corresponding guess work.  At  the  end,  fromFile  simply  calls
           either fromCSV or fromTSV with $arg_ref forwarded. So if you call fromFile({transform_element=&gt;0}) on
           a TSV file, transform_elment will be passed onto fromTSV calls internally.

           fromFileGuessOS  finds the linebreak that gives shortest first line (in the priority of UNIX, PC, MAC
           upon tie).  fromFileGuessDelimiter works based on the assumption  that  the  correct  delimiter  will
           produce  equal  number  of  columns for the given rows. If multiple matches, it chooses the delimiter
           that  gives  maximum  number  of  columns.  If  none  matches,  it  returns  the  default  delimiter.
           fromFileIsHeader  works based on the assumption that no column header can be empty or numeric values.
           However, if we allow numeric column names (especially integer column names), set  {allowNumericHeader
           =&gt; 1}

       table Data::Table::fromSQL ($dbh, $sql, $vars)
           create  a table from the result of an SQL selection query.  It returns a table object upon success or
           undef otherwise.  $dbh: a valid database handler.  Typically $dbh is obtained from DBI-&gt;connect,  see
           "Interface  to  Database"  or  DBI.pm.   $sql:  an  SQL query string or a DBI::st object (starting in
           version 1.61).  $vars: optional reference to an array of variable values, required if  $sql  contains
           '?'s  which  need  to be replaced by the corresponding variable values upon execution, see DBI.pm for
           details.  Hint: in MySQL, Data::Table::fromSQL($dbh, 'show tables from  test')  will  also  create  a
           valid table object.

           Data::Table::fromSQL  now  can  take  DBI::st  instead  of  a SQL string. This is introduced, so that
           variable binding (such as CLOB/BLOB) can be done outside the method, for example:

             $sql = 'insert into test_table (id, blob_data) values (1, :val)';
             $sth = $dbh-&gt;prepare($sql);
             $sth-&gt;bind_param(':val', $blob, {ora_type =&gt; SQLT_BIN});
             Data::Table::fromSQL($dbh, $sth);

       table Data::Table::fromSQLi ($dbh, $sql, $vars)
           Same as Data::Table::fromSQL. However, this is an instant method (that's what 'i' stands for), whic h
           can be inherited.

   <b>Table</b> <b>Access</b> <b>and</b> <b>Properties</b>
       int table::colIndex ($colID)
           translate a column name into its numerical position, the first column has index 0 as in as  any  perl
           array.  return -1 for invalid column names.

           Since 1.69, we allow integer to be used as a column header.  The integer $colID will first be checked
           against  column  names,  if matched, the corresponding column index is returned. E.g., if column name
           for the 3rd column is "1", <b><a href="../man1/colIndex.1.html">colIndex</a></b>(1) will return 2 instead of 1! In  such  case,  if  one  need  to
           access the second column, one has to access it by column name, i.e., $t-&gt;col(($t-&gt;header)[1]).

       int table::nofCol
           return number of columns.

       int table::nofRow
           return number of rows.

       int table::lastCol
           return the index of the last columns, i.e., nofCol - 1.

       int table::lastRow
           return the index of the last rows, i.e., nofRow - 1; This is syntax sugar.

              # these two are equivalent
              foreach my $i (0 .. $t-&gt;lastRow)
              foreach my $i (0 .. $t-&gt;nofRow - 1)

       bool table::isEmpty
           return whether the table has any column, introduced in 1.63.

       bool table::hasCol($colID)
           returns whether the colID is a table column, introduced in 1.63.

       bool table::colName($colNumericIndex)
           returns  the  column  name  for  a  numeric  column index, notice the first column has an index of 0.
           Introduced in 1.68.

       scalar table::elm ($rowIdx, $colID)
           return the value of a table element at [$rowIdx, $colID], undef if $rowIdx or $colID is invalid.

       refto_scalar table::elmRef ($rowIdx, $colID)
           return the reference to a table element at [$rowIdx, $colID], to  allow  possible  modification.   It
           returns undef for invalid $rowIdx or $colID.

       array table::header ($header)
           Without argument, it returns an array of column names.  Otherwise, use the new header.

       int table::type
           return  the  implementation type of the table (row-based/column-based) at the time, be aware that the
           type of a table should be considered as volatile during method calls.

   <b>Table</b> <b>Formatting</b>
       string table::csv ($header, {OS=&gt;$Data::Table::DEFAULTS{'OS'}, file=&gt;undef,
       delimiter=&gt;$Data::Table::DEFAULTS{'CSV_DELIMITER'}, qualifier=&gt;$Data::Table::DEFAULTS{'CSV_QAULIFIER'}})
           return a string corresponding to the CSV representation of the table.  $header  controls  whether  to
           print the header line, 1 for yes, 0 for no.  optional named argument OS specifies for which operating
           system  the  CSV  file  is  generated.  0  for  UNIX,  1  for  P  C  and 2 for MAC. If not specified,
           $Data::Table::DEFAULTS{'OS'} is used. Basically linebreak is defined as "\n",  "\r\n"  and  "\r"  for
           three  systems,  respectively.   if 'file' is given, the csv content will be written into it, besides
           returning the string.  One may specify custom delimiter and qualifier if the other than  default  are
           desired.

       string table::tsv
           return  a  string  corresponding to the TSV representation of the table.  $header controls whether to
           print the header line, 1 for yes, 0 for no.  optional named argument OS specifies for which operating
           system the TSV file is generated. 0  for  UNIX,  1  for  P  C  and  2  for  MAC.  If  not  specified,
           $Data::Table::DEFAULTS{'OS'}  is  used.  Basically  linebreak is defined as "\n", "\r\n" and "\r" for
           three systems, respectively.  if 'file' is given, the tsv content will be written  into  it,  besides
           returning the string.

           Note: read "TSV FORMAT" section for details.

       string table::html ($colorArrayRef_or_colorHashRef = ["#D4D4BF","#ECECE4","#CCCC99"], $tag_tbl = {border
       =&gt; '1'}, $tag_tr  = {align =&gt; 'left'}, $tag_th  = {align =&gt; 'center'}, $tag_td  = {col3 =&gt; 'align="right"
       valign="bottom"', 4 =&gt; 'align="left"'}, $l_portrait = 1, $callback = undef )
           return    a    string    corresponding    to    a   'Portrait/Landscape'-style   html-tagged   table.
           $colorArrayRef_or_colorHashRef: If a hash reference is provided, it will take three CSS  class  names
           for   odd   data   rows,   even   data   rows   and   for  the  header  row.   The  default  hash  is
           {even=&gt;"data_table_even", odd=&gt;"data_table_odd", header=&gt;"data_table_header").  If a  hash  reference
           is  not found, a reference to an array of three color strings is expected to provided for backgrounds
           for  even-row  records,  odd-row  records,  and  -der  row,  respectively.   A  default  color  array
           ("#D4D4BF","#ECECE4","#CCCC99") will be used if $colors isn't defined.

           Since version 1.74, users can prevent default coloring by passing in a color array reference ["", "",
           ""].

           Before version 1.59, the parameter can only accept an array reference.

           $tag_tbl:  a reference to a hash that specifies any legal attributes such as name, border, id, class,
           etc. for the TABLE tag.

           $tag_tr: a reference to a hash that specifies any legal attributes for the TR tag.

           $tag_th: a reference to a hash that specifies any legal attributes for the TH tag.

           $tag_td: a reference to a hash that specifies any legal attributes for the TD tag.

           Notice $tag_tr and $tag_th controls all the rows and columns of the whole table. The keys of the hash
           are the attribute names in these cases. However, $tag_td is column specific, i.e., you should specify
           TD attributes for every column separately.  The key of %$tag_td are either  column  names  or  column
           indices,    the    value    is    a    reference   to   a   hash.   E.g.,   $tag_td    =   {col3   =&gt;
           {'style'=&gt;'background-color:#cccc99;'}}. However, before version 1.74, the value is the  full  string
           to be inserted into the TD tag. E.g., $tag_td  = {col3 =&gt; 'align=right valign=bottom} only change the
           TD  tag  in "col3" to be &lt;TD align=right valign=bottom&gt;;. This format is still supported for backward
           compatibility.

           $portrait controls the layout of the table. The default is  1,  i.e.,  the  table  is  shown  in  the
           "Portrait"  style,  like  in Excel. 0 means "Landscape". Since version 1.59, tbody and thead tags are
           added to the portrait mode output.

           Since version 1.74, $callback is introduced to give users fine control on  the  tag  for  each  cell,
           i.e.,  for  each  th/td cells. $callback is a subroutine reference, where the sub is expected to take
           parameters ($tag, $row_index, $col_index, $col_name, $table), $tag is reference to a hash  containing
           existing  TH/TD  tags,  the sub will return a new tag.  The rest of the parameters give sub access to
           the identity of the table cell, as well as the table itself.

           If the following example, the callback function colors each UnitPrice cell based on whether its value
           is &gt;=20 or &lt;20.  It colors each Discontinued cell based on whether its value is TRUE or  FALSE.   One
           can  also control the column header cells, which has row index of -1. That is the reason we use "$row
           &gt;=0 " within callback to make sure it cell is not a column header.

               $t=Data::Table::fromCSV("Data-Table-1.74/Product.csv",1,undef, {'OS'=&gt;1});
               my $callback = sub {
                   my ($tag, $row, $col, $colName, $table) = @_;
                   if ($row &gt;=0 &amp;&amp; $colName eq 'UnitPrice') {
                       $tag-&gt;{'style'} = 'background-color:'. (($table-&gt;elm($row, $col)&gt;=20) ? '#fc8d59':'#91bfdb') . ';';
                   }
                   if ($row &gt;=0 &amp;&amp; $colName eq 'Discontinued') {
                       $tag-&gt;{'style'} = 'background-color:'. (($table-&gt;elm($row, $col) eq 'TRUE') ? '#999999':'#af8dc3') .';';
                   }
                   return $tag;
               };

               print $t-&gt;html(undef, undef, undef, undef, undef, undef, $callback);

           Attention: You will have to escape HTML-Entities yourself (for example '&lt;' as '&amp;lt;'),  if  you  have
           characters  in  you  table which need to be escaped. You can do this for example with the escapeHTML-
           function from CGI.pm (or the HTML::Entities module).

             use CGI qw(escapeHTML);
             [...]
             $t-&gt;colMap($columnname, sub{escapeHTML($_)}); # for every column, where HTML-Entities occur.

       string table::html2 ($colors = ["#D4D4BF","#ECECE4","#CCCC99"], $specs = {'name' =&gt; '', 'border' =&gt; '1',
       ...})
           This method is deprecated. It's here for compatibility. It now simple call html method with $portrait
           = 0, see previous description.

           return a string corresponding to a "Landscape" html-tagged table.  This is useful to present a  table
           with many columns, but very few entries.  Check the above table::html for parameter descriptions.

       string table::wiki(...)
           This method accepts the same parameters as table::html, returns a wikitable instead.

       string table::wiki2(...)
           This  method  accepts  the  same parameters as table::html2, returns a wikitable instead in landscape
           orientation.

   <b>Table</b> <b>Operations</b>
       int table::setElm ($rowIdx, $colID, $val)
           modify the value of a table element at [$rowIdx, $colID] to a new value  $val.   It  returns  1  upon
           success,  undef  otherwise.   In  1.68,  setElm  can  manipulate multiple elements, i.e., $rowIdx and
           $colIdx can be references to an index array, and <b>setElm()</b> will modifies  all  cells  defined  by  the
           grid.

               $t-&gt;setElm([0..2], ['ColA', 'ColB'], 'new value');
               $t-&gt;setElm(0, [1..2], 'new value');

               # puts a limit on the price of all expensive items
               $t_product-&gt;match_pattern_hash('$_{UnitPrice} &gt; 20');
               $t_product-&gt;setElm($t_product-&gt;{MATCH}, 'UnitPrice', 20);

       int table::addRow ($rowRef, $rowIdx = table::nofRow, $arg_ref = {addNewCol =&gt; 0})
           add  a  new  row ($rowRef may point to the actual list of scalars, or it can be a hash_ref (supported
           since version 1.60)).  If $rowRef points to a hash, the method will lookup the value of a field by ts
           column name: $rowRef-&gt;{colName}, if not found, undef is used for that field.  The  new  row  will  be
           referred as $rowIdx as the result. E.g., addRow($aRow, 0) will put the new row as the very first row.
           By  default,  it appends a row to the end.  In 1.67, we support {addNewCol =&gt; 1}, if specified, a new
           column will be automatically created for each new element encountered in the $rowRef.

               # automatically add a new column "aNewColumn" to $t, in order to hold the new value
               $t-&gt;addRow({anExistingColumn =&gt; 123, aNewColumn =&gt; "XYZ"}, undef, {addNewCol =&gt; 1});
               # $t only had one column, after this call, it will contain a new column 'col2', in order to hold the new value
               $t-&gt;addRow([123, "XYZ"], undef, {addNewCol =&gt; 1});

           It returns 1 upon success, undef otherwise.

       refto_array table::delRow ( $rowIdx )
           delete a row at $rowIdx. It will the reference to the deleted row.

       refto_array table::delRows ( $rowIdcsRef )
           delete rows in @$rowIdcsRef. It will return an array of deleted rows in the same order of $rowIdcsRef
           upon success.  upon success.

       int table::addCol ($colRef, $colName, $colIdx = numCol)
           add a new column ($colRef points to the actual data), the new column will be referred as $colName  or
           $colIdx  as  the  result.  E.g., addCol($aCol, 'newCol', 0) will put the new column as the very first
           column.  By default, append a column to the end.  It will return 1 upon success or  undef  otherwise.
           In  1.68,  $colRef  can  be  a  scalar, which is the default value that can be used to create the new
           column.  E.g., to create a new column with default value of undef, 0,  'default',  respectively,  one
           can do:

              $t-&gt;addCol(undef, 'NewCol');
              $t-&gt;addCol(0, 'NewIntCol');
              $t-&gt;addCol('default', 'NewStringCol');

       refto_array table::delCol ($colID)
           delete a column at $colID return the reference to the deleted column.

       arrayof_refto_array table::delCols ($colIDsRef)
           delete  a  list  of columns, pointed by $colIDsRef. It will return an array of deleted columns in the
           same order of $colIDsRef  upon success.

       refto_array table::rowRef ($rowIdx)
           return a reference to the row at $rowIdx upon success or undef otherwise.

       refto_arrayof_refto_array table::rowRefs ($rowIdcsRef)
           return a reference to array of row references upon success, undef otherwise.

       array table::row ($rowIdx)
           return a copy of the row at $rowIdx upon success or undef otherwise.

       refto_hash table::rowHashRef ($rowIdx)
           return a reference to a hash, which contains a copy of the row at  $rowIdx,  upon  success  or  undef
           otherwise.  The  keys in the hash are column names, and the values are corresponding elements in that
           row. The hash is a copy, therefore modifying the hash values doesn't change the original table.

       refto_array table::colRef ($colID)
           return a reference to the column at $colID upon success.

       refto_arrayof_refto_array table::colRefs ($colIDsRef)
           return a reference to array of column references upon success.

       array table::col ($colID)
           return a copy to the column at $colID upon success or undef otherwise.

       int table::rename ($colID, $newName)
           rename the column at $colID to a $newName (the newName must be valid, and should not be identical  to
           any other existing column names).  It returns 1 upon success or undef otherwise.

       refto_array table::replace ($oldColID, $newColRef, $newName)
           replace  the  column  at  $oldColID  by  the array pointed by $newColRef, and renamed it to $newName.
           $newName is optional if you don't want to rename the column.  It returns  1  upon  success  or  undef
           otherwise.

       int table::swap ($colID1, $colID2)
           swap two columns referred by $colID1 and $colID2.  It returns 1 upon success or undef otherwise.

       int table::moveCol($colID, $colIdx, $newColName)
           move  column  referred  by $colID to a new location $colIdx.  If $newColName is specified, the column
           will be renamed as well.  It returns 1 upon success or undef otherwise.

       int table::reorder($colIDRefs, $arg_ref)
           Rearrange the columns according to the order specified in $colIDRef.  Columns not  specified  in  the
           reference  array  will  be appended to the end!  If one would like to drop columns not specified, set
           $arg_ref to {keepRest =&gt; 0}.  <b>reorder()</b> changes the table itself, while  subTable(undef,  $colIDRefs)
           will return a new table.  <b>reorder()</b> might also runs faster than subTable, as elements may not need to
           be copied.

       int table::colMap ($colID, $fun)
           foreach  element  in  column  $colID,  map a function $fun to it.  It returns 1 upon success or undef
           otherwise.  This is a handy way to format a column. E.g. if a column named URL contains URL  strings,
           colMap("URL",  sub {"&lt;a href='$_'&gt;$_&lt;/a&gt;"}) before <b>html()</b> will change each URL into a clickable hyper
           link while displayed in a web browser.

       int table::colsMap ($fun)
           foreach row in the table, map a function $fun to it.  It can do whatever colMap can do and more.   It
           returns  1  upon success or undef otherwise.  colMap function only give $fun access to the particular
           element per row, while colsMap give $fun full access to all elements per row.  E.g.  if  two  columns
           named  duration  and  unit (["2", "hrs"], ["30", "sec"]). colsMap(sub {$_-&gt;[0] .= " (".$_-&gt;[1].")"; }
           will change each row into (["2 hrs", "hrs"], ["30 sec", "sec"]).  As show, in  the  $func,  a  column
           element should be referred as $_-&gt;[$colIndex].

       int table::sort($colID1, $type1, $order1, $colID2, $type2, $order2, ... )
           sort  a  table  in place.  First sort by column $colID1 in $order1 as $type1, then sort by $colID2 in
           $order2 as $type2, ...  $type is 0 for numerical and 1 for others; $order is 0 for  ascending  and  1
           for descending;

           In  1.62,  instead  of memorize these numbers, you can use constants instead (notice constants do not
           start with '$').
             Data::Table::NUMBER
             Data::Table::STRING
             Data::Table::ASC
             Data::Table::DESC

           Sorting is done in the priority of colID1, colID2, ...  It returns 1 upon success or undef otherwise.
           Notice the table is rearranged as a result! This is different from perl's list sort, which returns  a
           sorted  copy  while  leave  the  original  list  untouched,  the authors feel inplace sorting is more
           natural.

           table::sort can take a user supplied operator, this is useful when neither numerical  nor  alphabetic
           order is correct.

             $Well=["A_1", "A_2", "A_11", "A_12", "B_1", "B_2", "B_11", "B_12"];
             $t = Data::Table-&gt;new([$Well], ["PlateWell"], 1);
             $t-&gt;sort("PlateWell", 1, 0);
             print join(" ", $t-&gt;col("PlateWell"));
             # prints: A_1 A_11 A_12 A_2 B_1 B_11 B_12 B_2
             # in string sorting, "A_11" and "A_12" appears before "A_2";
             my $my_sort_func = sub {
               my @a = split /_/, $_[0];
               my @b = split /_/, $_[1];
               my $res = ($a[0] cmp $b[0]) || (int($a[1]) &lt;=&gt; int($b[1]));
             };
             $t-&gt;sort("PlateWell", $my_sort_func, 0);
             print join(" ", $t-&gt;col("PlateWell"));
             # prints the correct order: A_1 A_2 A_11 A_12 B_1 B_2 B_11 B_12

       table table::match_pattern ($pattern, $countOnly)
           return  a  new  table  consisting  those  rows evaluated to be true by $pattern upon success or undef
           otherwise. If $countOnly is set to 1, it simply returns the number of rows that  matches  the  string
           without making a new copy of table. $countOnly is 0 by default.

           Side  effect:  @Data::Table::OK  (should  use  $t-&gt;{OK} after 1.62) stores a true/false array for the
           original table rows. Using it, users can find out what are the rows being selected/unselected.   Side
           effect:  @Data::Table::MATCH  stores  a  reference to an array containing all row indices for matched
           rows.

           In  the  $pattern  string,  a  column  element  should  be   referred   as   $_-&gt;[$colIndex].   E.g.,
           match_pattern('$_-&gt;[0]&gt;3  &amp;&amp;  $_-&gt;[1]=~/^L')  retrieve all the rows where its first column is greater
           than 3 and second column starts with letter 'L'. Notice it only takes colIndex, column names are  not
           acceptable here!

       table table::match_pattern_hash ($pattern, $countOnly)
           return  a  new  table  consisting  those  rows evaluated to be true by $pattern upon success or undef
           otherwise. If $countOnly is set to 1, it simply returns the number of rows that  matches  the  string
           without making a new copy of table. $countOnly is 0 by default.

           Side  effect:  @Data::Table::OK stores a reference to a true/false array for the original table rows.
           Using  it,  users  can  find  out  what  are  the  rows  being  selected/unselected.   Side   effect:
           @Data::Table::MATCH stores a reference to an array containing all row indices for matched rows.

           In  the $pattern string, a column element should be referred as ${column_name}.  <b>match_pattern_hash()</b>
           is added in 1.62. The difference between this method and match_pattern is each  row  is  fed  to  the
           pattern as a hash %_.  In the case of match_pattern, each row is fed as an array ref $_.  The pattern
           for <b>match_pattern_hash()</b> becomes much cleaner.

           If  a table has two columns: Col_A as the 1st column and Col_B as the 2nd column, a filter "Col_A &gt; 2
           AND Col_B &lt; 2" is written before as      $t-&gt;match_pattern('$_-&gt;[0] &gt; 2 &amp;&amp;  $_-&gt;[1]  &lt;2');  where  we
           need  to  figure out $t-&gt;colIndex('Col_A') is 0 and $t-&gt;colIndex('Col_B') is 1, in order to build the
           pattern.  Now you can use column name directly in the pattern:      $t-&gt;match_pattern_hash('$_{Col_A}
           &gt;2  &amp;&amp;  $_{Col_B}  &lt;2');  This  method  creates  $t-&gt;{OK},  as  well  as  @Data::Table::OK,  same  as
           <b>match_pattern()</b>.

           Simple  boolean  operators  such  as and/or can be directly put into the pattern string. More complex
           logic can also be supported in the example below:

               my $t= Data::Table-&gt;new([[2,5,'Jan'], [1,6,'Feb'], [-3,2,'Apr'], [6,-4,'Dec']], ['X','Y','Month'], 0);
               # we need to use our instead of my, so that %Q1 is accessible within match_pattern_hash
               our %Q1 = ('Jan'=&gt;1, 'Feb'=&gt;1, 'Mar'=&gt;1);
               # find records belongin to Q1 months, we need to use %::Q1 to access the Q1 defined outside Data::Table
               $t2=$t-&gt;match_pattern_hash('exists $::Q1{$_{Month}}');

           similarly, subroutines can be accessed inside match_pattern_hash using "::":

               sub in_Q1 {
                   my $x = shift;
                   return ($x eq 'Jan' or $x eq 'Feb' or $x eq 'Mar');
               }
               $t2=$t-&gt;match_pattern_hash('::in_Q1($_{Month})');

           However, such usage is discouraged, as <b>match_pattern_hash()</b> does not throw errors when the pattern is
           invalid.  For complex filtering logic, we strongly recommend you stick to row-based looping.

       table table::match_string ($s, $caseIgnore, $countOnly)
           return a new table consisting those rows contains string $s in any of its fields upon success,  undef
           otherwise.  if  $caseIgnore evaluated to true, case will is be ignored (s/$s/i). If $countOnly is set
           to 1, it simply returns the number of rows that matches the string  without  making  a  new  copy  of
           table. $countOnly is 0 by default.

           Side  effect:  @Data::Table::OK stores a reference to a true/false array for the original table rows.
           Side effect: @Data::Table::MATCH stores a reference to  an  array  containing  all  row  indices  for
           matched  rows.   Using  it,  users  can find out what are the rows being selected/unselected.  The $s
           string is actually treated as a regular expression and applied to each row element, therefore one can
           actually specify several keywords by saying, for instance, match_string('One|Other').

       table table::rowMask($mask, $complement)
           mask is reference to an array, where elements are evaluated to be true or false. The size of the mask
           must be equal to the nofRow of the table.  return  a  new  table  consisting  those  rows  where  the
           corresponding mask element is true (or false, when complement is set to true).

           E.g.,  $t1=$tbl-&gt;match_string('keyword');  $t2=$tbl-&gt;rowMask(\@Data::Table::OK,  1)  creates  two new
           tables. $t1 contains all rows match 'keyword', while $t2 contains all other rows.

           mask is reference to an array, where elements are evaluated to be true or false. The size of the mask
           must be equal to the nofRow of the table. return
            a new table consisting those rows where the corresponding mask  element  is  true  (or  false,  when
           complement is set to true).

           E.g.,  $t1=$tbl-&gt;match_string('keyword');  $t2=$tbl-&gt;rowMask(\@Data::Table::OK,  1)  creates  two new
           tables. $t1 contains all rows match 'keyword', while $t2 contains all other rows.

       table table::iterator({$reverse =&gt; 0})
           Returns a reference to a enumerator routine, which enables one to loop through  each  table  row.  If
           $reverse  is  set  to  1, it will enumerate backward.  The convenience here is each row is fetch as a
           rowHashRef, so one can easily access row elements by name.

               my $next = $t_product-&gt;iterator();
               while (my $row = $next-&gt;()) {
                 # have access to a row as a hash reference, access row number by &amp;$<a href="../man1/next.1.html">next</a>(1);
                 $t_product-&gt;setElm($next-&gt;(1), 'ProductName', 'New! '.$row-&gt;{ProductName});
               }

           In this example, each $row is fetched as a  hash  reference,  so  one  can  access  the  elements  by
           $row-&gt;{colName}.  Be aware that the elements in the hash is a copy of the original table elements, so
           modifying $row-&gt;{colName} does not modify the original table.  If table modification is intended, one
           needs to obtain the row index of the returned row.  $next-&gt;(1) call with a non-empty argument returns
           the  row  index  of the record that was previously fetched with $next-&gt;().  In this example, one uses
           the row index to modify the original table.

       table table::each_group($colsToGroupBy, $funsToApply)
           Primary key columns are specified in $colsToGroupBy. All rows are grouped by primary keys first (keys
           sorted as string). Then for each group, subroutines $funToAppy  is  applied  to  corresponding  rows.
           $funToApply  are  passed  with  two  parameters ($tableRef, $rowIDsRef). All rows sharing the key are
           passed in as a Data::Table object (with all columns and in the order of ascending row index)  in  the
           first  parameter.   The  second  optional  parameter  contains  an  array of row indices of the group
           members.  Since all rows in the passed-in table contains the same keys, the key value can be obtained
           from its first table row.

       table table::group($colsToGroupBy, $colsToCalculate, $funsToApply, $newColNames, $keepRestCols)
           Primary key columns are specified in $colsToGroupBy. All rows are grouped by primary keys first. Then
           for each group, an array of subroutines (in $funsToAppy) are applied  to  corresponding  columns  and
           yield a list of new columns (specified in $newColNames).

           $colsToGroupBy,  $colsToCalculate  are  references to array of colIDs. $funsToApply is a reference to
           array of subroutine references. $newColNames are a reference to array of new column name strings.  If
           specified,  the size of arrays pointed by $colsToCalculate, $funsToApply and $newColNames should be i
           dentical. A column may be used more than once in $colsToCalculate.

           $keepRestCols is default to 1 (was introduced as 0 in  1.64,  changed  to  1  in  1.66  for  backward
           compatibility)  introduced  in  1.64),  otherwise,  the remaining columns are returned with the first
           encountered value of that group.

           E.g., an employee salary table $t contains the following columns: Name, Sex, Department, Salary. (see
           examples in the SYNOPSIS)

             $t2 = $t-&gt;group(["Department","Sex"],["Name", "Salary"], [sub {scalar @_}, \&amp;average], ["Nof Employee", "Average Salary"], 0);

           Department, Sex are used together as the primary key columns, a new column "Nof Employee" is  created
           by  counting  the number of employee names in each group, a new column "Average Salary" is created by
           averaging the Salary data falled into each group. As the result, we have the head count  and  average
           salary  information  for  each (Department, Sex) pair. With your own functions (such as sum, product,
           average, standard deviation, etc), group method is very handy for accounting purpose.  If primary key
           columns are not defined, all records will be treated as one group.

             $t2 = $t-&gt;group(undef,["Name", "Salary"], [sub {scalar @_}, \&amp;average], ["Nof Employee", "Average Salary"], 0);

           The above statement will output the total number of employees and their average salary as one line.

       table table::pivot($colToSplit, $colToSplitIsStringOrNumeric, $colToFill, $colsToGroupBy, $keepRestCols)
           Every unique values in a column (specified by $colToSplit) become a new column.  undef  value  become
           "NULL".   $colToSplitIsStringOrNumeric  is  set  to numeric (0 or Data::Table:NUMBER), the new column
           names are prefixed by "oldColumnName=". The new cell element is filled  by  the  value  specified  by
           $colToFill (was 1/0 before version 1.63).

           Note:  yes, it seems I made an incompatible change in version 1.64, where $colToSplitIsStringOrNumber
           used to be $colToSplitIsNumeric, where 0 meant STRING and  1  meant  NUMBER.   Now  it  is  opposite.
           However,  I  also added auto-type detection code, that this parameter essentially is auto-guessed and
           most old code should behave the same as before.

           When primary key columns are specified by $colsToGroupBy, all records sharing the  same  primary  key
           collapse into one row, with values in $colToFill filling the corresponding new columns. If $colToFill
           is not specified, a cell is filled with the number of records fall into that cell.

           $colToSplit  and $colToFill are colIDs. $colToSplitIsNumeric is 1/0. $colsToGroupBy is a reference to
           array of colIDs. $keepRestCols is 1/0, by default is 0. If $keepRestCols is  off,  only  primary  key
           columns and new columns are exported, otherwise, all the rest columns are exported as well.

           E.g., applying pivot method to the resultant table of the example of the group method.

             $t2-&gt;pivot("Sex", 0, "Average Salary",["Department"]);

           This creates a 2x3 table, where Departments are use as row keys, Sex (female and male) become two new
           columns.  "Average  Salary"  values are used to fill the new table elements. Used together with group
           method, pivot method is very handy for accounting type of analysis.  If  $colsToGroupBy  is  left  as
           undef,  all rows are treated as one group.  If $colToSplit is left as undef, the method will generate
           a column named "(all)" that matches all records share the corresponding primary key.

       table table::melt($keyCols, $variableCols, $arg_ref)
           The idea of <b>melt()</b> and <b>cast()</b> are taken from Hadley Wickham's Reshape package in R language.  A table
           is first <b>melt()</b> into a tall-skiny format, where measurements are stored in the format of a  variable-
           value pair per row.  Such a format can then be easily <b>cast()</b> into various contingency tables.

           One  needs  to  specify the columns consisting of primary keys, columns that are consider as variable
           columns.    The   output   variable   column   is    named    'variable'    unless    specified    by
           $arg_ref{variableColName}.    The   output  value  column  is  named  'value',  unless  specified  in
           $arg_ref{valueColName}.  By default NULL values are not output, unless $arg_ref{skip_NULL} is set  to
           false.  By default empty string values are kept, unless one sets skip_empty to `.

             For each object (id), we measure variable x1 and x2 at two time points
             $t = new Data::Table([[1,1,5,6], [1,2,3,5], [2,1,6,1], [2,2,2,4]], ['id','time','x1','x2'], Data::Table::ROW_BASED);
             # id  time    x1      x2
             # 1   1       5       6
             # 1   2       3       5
             # 2   1       6       1
             # 2   2       2       4

             # melting a table into a tall-and-skinny table
             $t2 = $t-&gt;melt(['id','time']);
             #id      time    variable        value
             # 1       1       x1      5
             # 1       1       x2      6
             # 1       2       x1      3
             # 1       2       x2      5
             # 2       1       x1      6
             # 2       1       x2      1
             # 2       2       x1      2
             # 2       2       x2      4

             # casting the table, &amp;average is a method to calculate mean
             # for each object (id), we calculate average value of x1 and x2 over time
             $t3 = $t2-&gt;cast(['id'],'variable',Data::Table::STRING,'value', \&amp;average);
             # id      x1      x2
             # 1       4       5.5
             # 2       4       2.5

       table table::cast($colsToGroupBy, $colToSplit, $colToSplitIsStringOrNumeric, $colToCalculate,
       $funToApply)
           see <b>melt()</b>, as <b>melt()</b> and <b>cast()</b> are meant to use together.

           The  table  has  been  melten  before.  <b>cast()</b> group the table according to primary keys specified in
           $colsToGroupBy. For each group of objects sharing the same id, it further groups values (specified by
           $colToCalculate) according to unique variable names (specified  by  $colToSplit).   Then  it  applies
           subroutine $funToApply to obtain an aggregate value.  For the output, each unique primary key will be
           a row, each unique variable name will become a column, the cells are the calculated aggregated value.

           If  $colsToGroupBy is undef, all rows are treated as within the same group.  If $colToSplit is undef,
           a new column "(all)" is used to hold the results.

             $t = Data::Table-&gt;new( # create an employ salary table
               [
                 ['Tom', 'male', 'IT', 65000],
                 ['John', 'male', 'IT', 75000],
                 ['Tom', 'male', 'IT', 65000],
                 ['John', 'male', 'IT', 75000],
                 ['Peter', 'male', 'HR', 85000],
                 ['Mary', 'female', 'HR', 80000],
                 ['Nancy', 'female', 'IT', 55000],
                 ['Jack', 'male', 'IT', 88000],
                 ['Susan', 'female', 'HR', 92000]
               ],
               ['Name', 'Sex', 'Department', 'Salary'], Data::Table::ROW_BASED);

             # get a Department x Sex contingency table, get average salary across all four groups
             print $t-&gt;cast(['Department'], 'Sex', Data::Table::STRING, 'Salary', \&amp;average)-&gt;<a href="../man1/csv.1.html">csv</a>(1);
             Department,female,male
             IT,55000,73600
             HR,86000,85000
             # get average salary for each department
             print $t-&gt;cast(['Department'], undef, Data::Table::STRING, 'Salary', \&amp;average)-&gt;<a href="../man1/csv.1.html">csv</a>(1);
             Department,(all)
             IT,70500
             HR,85666.6666666667

             # get average salary for each gender
             print $t-&gt;cast(['Sex'], undef, Data::Table::STRING, 'Salary', \&amp;average)-&gt;<a href="../man1/csv.1.html">csv</a>(1);
             Sex,(all)
             male,75500
             female,75666.6666666667

             # get average salary for all records
             print $t-&gt;cast(undef, undef, Data::Table::STRING, 'Salary', \&amp;average)-&gt;<a href="../man1/csv.1.html">csv</a>(1);
             (all)
             75555.5555555556

   <b>Table-Table</b> <b>Manipulations</b>
       int table::rowMerge ($tbl, $argRef)
           Append all the rows in the table object $tbl to the original rows.  Before 1.62,  the  merging  table
           $tbl  must have the same number of columns as the original, as well as the columns are in exactly the
           same order.  It returns 1 upon success, undef otherwise.  The table object $tbl should  not  be  used
           afterwards, since it becomes part of the new table.

           Since  1.62,  you  may  provide  {byName  =&gt;1,  addNewCol=&gt;1} as $argRef.  If byName is set to 1, the
           columns in in $tbl do not need to be in the same order as they are in the first  table,  instead  the
           column  name  is used for the matching.  If addNewCol is set to 1, if $tbl contains a new column name
           that does not already exist in the first table, this new column will be automatically  added  to  the
           resultant table.  Typically, you want to specify there two options simultaneously.

       int table::colMerge ($tbl, $argRef)
           Append  all  the columns in table object $tbl to the original columns.  Table $tbl must have the same
           number of rows as the original.  It returns 1 upon success, undef otherwise.  Table $tbl  should  not
           be used afterwards, since it becomes part of the new table.

           Since  1.62,  you  can  specify  {renameCol  =&gt;  1}  as  $argRef. This is to auto fix any column name
           collision.  If $tbl contains a column that already exists in the first table, it will be renamed  (by
           a suffix _2) to avoid the collision.

       table table::join ($tbl, $type, $cols1, $cols2, $argRef)
           Join two tables. The following join types are supported (defined by $type):

           0: inner join 1: left outer join 2: right outer join 3: full outer join

           In  1.62,  instead  of memorize these numbers, you can use constants instead (notice constants do not
           start with '$').
             Data::Table::INNER_JOIN
             Data::Table::LEFT_JOIN
             Data::Table::RIGHT_JOIN
             Data::Table::FULL_JOIN

           $cols1 and $cols2 are references to array of colIDs, where rows with the same elements in all  listed
           columns  are merged. As the result table, columns listed in $cols2 are deleted, before a new table is
           returned.

           The implementation is hash-join, the running time should be linear with respect to the sum of  number
           of rows in the two tables (assume both tables fit in memory).

           If  the  non-key  columns of the two tables share the same name, the routine will fail, as the result
           table cannot contain two columns of the same name.   In  1.62,  one  can  specify  {renameCol=&gt;1}  as
           $argRef, so that the second column will be automatically renamed (with suffix _2) to avoid collision.

           If  you would like to treat the NULLs in the key columns as empty string, set {NULLasEmpty =&gt; 1}.  If
           you do not want to treat NULLs as empty strings, but you still like the NULLs in  two  tables  to  be
           considered  as equal (but not equal to ''), set {matchNULL =&gt; 1}.  Obviously if NULLasEmpty is set to
           1, matchNULL will have no effect.

   <b>Internal</b> <b>Methods</b>
       All internal methods are mainly implemented for used by other methods in the Table  class.  Users  should
       avoid  using  them.   Nevertheless,  they are listed here for developers who would like to understand the
       code and may derive a new class from Data::Table.

       int table::rotate
           convert the internal structure of a table between row-based and column-based.  return 1 upon success,
           undef otherwise.

       string csvEscape($string, {delimiter=&gt;, qualifier})
           Encode a scalar into a CSV-formatted field.

           optional named arguments: delimiter and qualifier, in case user wants to use  characters  other  than
           the      defaults.      The     default     delimiter     and     qualifier     is     taken     from
           $Data::Table::DEFAULTS{'CSV_DELIMITER'} (defaults to ',') and $Data::Table::DEFAULTS{'CSV_QUALIFIER'}
           (defaults to '"'), respectively.

           Please note that this function only escape one element in a table. To escape the whole table row, you
           need to
             join($delimiter, map {csvEscape($_)} @row . $endl; $endl refers to End-of-Line, which  you  may  or
           may not want to add, and it is OS-dependent. Therefore, csvEscape method is kept to the simplest form
           as an element transformer.

       refto_array parseCSV($string)
           Break a CSV encoded string to an array of scalars (check it out, we did it the cool way).

           optional  argument  size:  specify  the  expected  number  of fields after csv-split.  optional named
           arguments: delimiter and qualifier, in case user wants to use characters  other  than  the  defaults.
           respectively.      The      default      delimiter      and      qualifier      is     taken     from
           $Data::Table::DEFAULTS{'CSV_DELIMITER'} (defaults to ',') and $Data::Table::DEFAULTS{'CSV_QUALIFIER'}
           (defaults to '"'), respectively.

       string tsvEscape($rowRef)
           Encode a scalar into a TSV-formatted string.

</pre><h4><b>TSV</b> <b>FORMAT</b></h4><pre>
       There is no standard for TSV format as far as we know. CSV format can't handle  binary  data  very  well,
       therefore, we choose the TSV format to overcome this limitation.

       We define TSV based on MySQL convention.

         "\0", "\n", "\t", "\r", "\b", "'", "\"", and "\\" are all escaped by '\' in the TSV file.
         (Warning: MySQL treats '\f' as 'f', and it's not escaped here)
         Undefined values are represented as '\N'.

       However, you can switch off this transformation by setting {transform_element =&gt; 0} in the fromTSV or tsv
       method.   Before  if  a  cell  reads 'A line break is \n', it is read in as 'A link break is [return]' in
       memory. When use tsv method to export, it is transformed back to 'A line break is \n'. However, if it  is
       exported  as a csv, the [return] will break the format. Now if transform_element is set to 0, the cell is
       stored as 'A line break is \n' in memory, so that csv export will be correct. However, do remember to set
       {transform_element =&gt; 0} in tsv export method, otherwise, the cell will become 'A line break is \\n'.  Be
       aware that trasform_element controls column headers as well.

</pre><h4><b>INTERFACE</b> <b>TO</b> <b>OTHER</b> <b>SOFTWARES</b></h4><pre>
       Spreadsheet  is  a  very  generic  type,  therefore  Data::Table class provides an easy interface between
       databases, web pages, CSV/TSV files, graphics packages, etc.

       Here is a summary (partially repeat) of some classic usages of Data::Table.

   <b>Interface</b> <b>to</b> <b>Database</b> <b>and</b> <b>Web</b>
         use DBI;

         $dbh= DBI-&gt;connect("DBI:mysql:test", "test", "") or die $DBI::errstr;
         my $minAge = 10;
         $t = Data::Table::fromSQL($dbh, "select * from mytable where age &gt;= ?", [$minAge]);
         print $t-&gt;html;

   <b>Interface</b> <b>to</b> <b>CSV/TSV</b>
         $t = fromFile("mydata.csv"); # after version 1.51
         $t = fromFile("mydata.tsv"); # after version 1.51

         $t = fromCSV("mydata.csv");
         $t-&gt;sort(1,1,0);
         print $t-&gt;csv;

         Same for TSV

   <b>Interface</b> <b>to</b> <b>Excel</b> <b>XLS/XLSX</b>
       Read in two tables from NorthWind.xls file, writes them  out  to  XLSX  format.   See  Data::Table::Excel
       module for details.

         use Data::Table::Excel;

         my ($tableObjects, $tableNames)=xls2tables("NorthWind.xls");
         $t_category = $tableObjects[0];
         $t_product = $tableObjects[1];

         tables2xlsx("NorthWind.xlsx", [$t_category, $t_product]);

   <b>Interface</b> <b>to</b> <b>Graphics</b> <b>Package</b>
         use GD::Graph::points;

         $graph = GD::Graph::points-&gt;new(400, 300);
         $t2 = $t-&gt;match('$_-&gt;[1] &gt; 20 &amp;&amp; $_-&gt;[3] &lt; 35.7');
         my $gd = $graph-&gt;plot($t-&gt;colRefs([0,2]));
         open(IMG, '&gt;mygraph.png') or die $!;
         binmode IMG;
         print IMG $gd-&gt;png;
         close IMG;

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright 1998-2008, Yingyao Zhou &amp; Guangzhou Zou. All rights reserved.

       It  was  first  written  by  Zhou  in  1998, significantly improved and maintained by Zou since 1999. The
       authors thank Tong Peng and Yongchuang Tao for valuable suggestions.  We  also  thank  those  who  kindly
       reported bugs, some of them are acknowledged in the "Changes" file.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

       Please send bug reports and comments to: easydatabase at gmail dot com. When sending bug reports,  please
       provide the version of Table.pm, the version of Perl.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
         DBI, GD::Graph, Data::Table::Excel.

perl v5.36.0                                       2022-11-19                                         <u><a href="../man3pm/Table.3pm.html">Table</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>