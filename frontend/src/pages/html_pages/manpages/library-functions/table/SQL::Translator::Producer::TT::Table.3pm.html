<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL::Translator::Producer::TT::Table -</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsql-translator-perl">libsql-translator-perl_1.66-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SQL::Translator::Producer::TT::Table -
           Produces output using the Template Toolkit from a SQL schema, per table.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # Normal STDOUT version
         #
         my $translator     = SQL::Translator-&gt;new(
             from           =&gt; 'MySQL',
             filename       =&gt; 'foo_schema.sql',
             to             =&gt; 'TT::Table',
             producer_args  =&gt; {
                 tt_table     =&gt; 'foo_table.tt',
             },
         );
         print $translator-&gt;translate;

         # To generate a file per table
         #
         my $translator     = SQL::Translator-&gt;new(
             from           =&gt; 'MySQL',
             filename       =&gt; 'foo_schema.sql',
             to             =&gt; 'TT::Table',
             producer_args  =&gt; {
                 tt_table       =&gt; 'foo_table.tt.html',
                 mk_files      =&gt; 1,
                 mk_files_base =&gt; "./doc/tables",
                 mk_file_ext   =&gt; ".html",
                 on_exists     =&gt; "replace",
             },
         );
         #
         # ./doc/tables/ now contains the templated tables as $tablename.html
         #

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Produces schema output using a given Template Tookit template, processing that template for each table in
       the schema. Optionally allows you to write the result for each table to a separate file.

       It needs one additional producer_arg of "tt_table" which is the file name of the template to use.  This
       template will be passed a template var of "table", which is the current SQL::Translator::Schema::Table
       table we are producing, which you can then use to walk the schema via the methods documented in that
       module. You also get "schema" as a shortcut to the SQL::Translator::Schema for the table and
       "translator", the SQL::Translator object for this parse in case you want to get access to any of the
       options etc set here.

       Here's a brief example of what the template could look like:

         [% table.name %]
         ================
         [% FOREACH field = table.get_fields %]
             [% field.name %]   [% field.data_type %]([% field.size %])
         [% END -%]

       See <u>t/data/template/table.tt</u> for a more complete example.

       You can also set any of the options used to initialize the Template object by adding them to your
       producer_args. See Template Toolkit docs for details of the options.

         $translator          = SQL::Translator-&gt;new(
             to               =&gt; 'TT',
             producer_args    =&gt; {
                 ttfile       =&gt; 'foo_template.tt',
                 INCLUDE_PATH =&gt; '/foo/templates/tt',
                 INTERPOLATE  =&gt; 1,
             },
         );

       If you set "mk_files" and its additional options the producer will write a separate file for each table
       in the schema. This is useful for producing things like HTML documentation where every table gets its own
       page (you could also use TTSchema producer to add an index page).  It's also particularly good for code
       generation where you want to produce a class file per table.

</pre><h4><b>OPTIONS</b></h4><pre>
       tt_table
           File name of the template to run for each table.

       mk_files
           Set to true to output a file for each table in the schema (as well as returning the whole lot back to
           the  Translalor  and  hence  STDOUT).  The  file  will  be  named  after the table, with the optional
           "mk_files_ext" added and placed in the directory "mk_files_base".

       mk_files_ext
           Extension (without the dot) to add to the filename when using mk_files.

       mk_files_base = DIR
           Dir to build the table files into when using mk_files. Defaults to the current directory.

       mk_file_dir
           Set true and if the file needs to written to a directory that  doesn't  exist,  it  will  be  created
           first.

       on_exists [Default:replace]
           What  to  do  if  we  are  running with mk_files and a file already exists where we want to write our
           output. One of "skip", "die", "replace", "insert".  The default is die.

           <b>replace</b> - Over-write the existing file with the new one, clobbering anything already there.

           <b>skip</b> - Leave the original file as it was and don't write the new version anywhere.

           <b>die</b> - Die with an existing file error.

           <b>insert</b> - Insert the generated output into the file between a set of special comments (defined by  the
           following options.) Any code between the comments will be overwritten (ie the results from a previous
           produce)  but the rest of the file is left alone (your custom code).  This is particularly useful for
           code generation as it allows you to generate schema derived code and then add your own custom code to
           the file.  Then when the schema changes you just re-produce to insert the new code.

       insert_comment_start
           The comment to look for in the file when on_exists is "insert". Default is "SQLF INSERT START".  Must
           appear on it own line, with only whitespace either side, to be recognised.

       insert_comment_end
           The  end  comment  to look for in the file when on_exists is "insert".  Default is "SQLF INSERT END".
           Must appear on it own line, with only whitespace either side, to be recognised.

</pre><h4><b>AUTHOR</b></h4><pre>
       Mark Addison &lt;<a href="mailto:grommit@users.sourceforge.net">grommit@users.sourceforge.net</a>&gt;.

</pre><h4><b>TODO</b></h4><pre>
       - Some tests for the various on exists options (they have been tested implicitly through use in a project
       but need some proper tests).

       - More docs on code generation strategies.

       - Better hooks for filename generation.

       - Integrate with TT::Base and
         TTSchema.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       SQL::Translator.

perl v5.40.0                                       2024-11-23             <u>SQL::Translator...ucer::TT::<a href="../man3pm/Table.3pm.html">Table</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>