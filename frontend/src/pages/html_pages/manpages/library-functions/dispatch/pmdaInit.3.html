<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pmdaInit,   pmdaRehash,  pmdaSetData,  pmdaExtGetData,  pmdaExtSetData,  pmdaSetFlags,  pmdaSetCommFlags,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpcp-pmda3-dev">libpcp-pmda3-dev_6.3.8-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>pmdaInit</b>,   <b>pmdaRehash</b>,  <b>pmdaSetData</b>,  <b>pmdaExtGetData</b>,  <b>pmdaExtSetData</b>,  <b>pmdaSetFlags</b>,  <b>pmdaSetCommFlags</b>,
       <b>pmdaExtSetFlags</b> - initialize a PMDA

</pre><h4><b>C</b> <b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;pcp/pmapi.h&gt;</b>
       <b>#include</b> <b>&lt;pcp/pmda.h&gt;</b>

       <b>void</b> <b>pmdaInit(pmdaInterface</b> <b>*</b><u>dispatch</u><b>,</b> <b>pmdaIndom</b> <b>*</b><u>indoms</u><b>,</b> <b>int</b> <u>nindoms</u><b>,</b> <b>pmdaMetric</b> <b>*</b><u>metrics</u><b>,</b>
               <b>int</b> <u>nmetrics</u><b>);</b>

       <b>void</b> <b>pmdaRehash(pmdaExt</b> <b>*</b><u>pmda</u><b>,</b> <b>pmdaMetric</b> <b>*</b><u>metrics</u><b>,</b> <b>int</b> <u>nmetrics</u><b>);</b>

       <b>void</b> <b>pmdaSetFlags(pmdaInterface</b> <b>*</b><u>dispatch</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>
       <b>void</b> <b>pmdaSetCommFlags(pmdaInterface</b> <b>*</b><u>dispatch</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>
       <b>void</b> <b>pmdaExtSetFlags(pmdaExt</b> <b>*</b><u>pmda</u><b>,</b> <b>int</b> <u>flags</u><b>);</b>

       <b>void</b> <b>pmdaSetData(pmdaInterface</b> <b>*</b><u>dispatch</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>);</b>
       <b>void</b> <b>pmdaExtSetData(pmdaExt</b> <b>*</b><u>pmda</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>);</b>
       <b>void</b> <b>*pmdaExtGetData(pmdaExt</b> <b>*</b><u>pmda</u><b>);</b>

       <b>cc</b> <b>...</b> <b>-lpcp_pmda</b> <b>-lpcp</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>pmdaInit</b> initializes a PMDA so that it is ready to receive PDUs from <b><a href="../man1/pmcd.1.html">pmcd</a></b>(1).  The  function  expects  as
       arguments the instance domain table (<u>indoms</u>) and the metric description table (<u>metrics</u>) that are initial‐
       ized by the PMDA. The arguments <u>nindoms</u> and <u>nmetrics</u> should be set to the number of instances and metrics
       in the tables, respectively.

       Much  of  the  <b>pmdaInterface</b> structure can be automatically initialized with <b><a href="../man3/pmdaDaemon.3.html">pmdaDaemon</a></b>(3), <b><a href="../man3/pmdaGetOpt.3.html">pmdaGetOpt</a></b>(3)
       and <b><a href="../man3/pmdaDSO.3.html">pmdaDSO</a></b>(3).  <b>pmdaInit</b> completes the PMDA initialization phase with three operations.  The first oper‐
       ation adds the domain and instance numbers to the instance and metric tables.  Singular metrics  (metrics
       without  an  instance domain) should have the instance domain <b>PM_INDOM_NULL</b> set in the <u>indom</u> field of the
       <b>pmDesc</b> structure (see <b><a href="../man3/pmLookupDesc.3.html">pmLookupDesc</a></b>(3)).  Metrics with an instance domain should set this field to be  the
       serial number of the instance domain in the <u>indoms</u> table.

       The  instance domain table may be made empty by setting <u>indoms</u> to NULL and <u>nindoms</u> to 0.  This allows the
       caller to provide custom Fetch and Instance callback functions.  The metric table may be  made  empty  by
       setting <u>metrics</u> to NULL and <u>nmetrics</u> to 0.  This allows the caller to provide custom Fetch and Descriptor
       callback functions.

</pre><h4><b>EXAMPLE</b></h4><pre>
       For  example,  a PMDA has three metrics: A, B and C, and two instance domains X and Y, with two instances
       in each instance domain.  The instance domain and metrics description tables could be defined as:

            static pmdaInstid _X[] = {
                { 0, "X1" }, { 1, "X2" }
            };

            static pmdaInstid _Y[] = {
                { 0, "Y1" }, { 1, "Y2" }
            };

            static pmdaIndom indomtab[] = {
            #define X_INDOM 0
                { X_INDOM, 2, _X },
            #define Y_INDOM 3
                { Y_INDOM, 2, _Y }
            };

            static pmdaMetric metrictab[] = {
            /* A */
                { (void *)0,
                  { PMDA_PMID(0,0), PM_TYPE_U32, PM_INDOM_NULL, PM_SEM_INSTANT,
                    { 0,0,0,0,0,0} }, },
            /* B */
                { (void *)0,
                  { PMDA_PMID(0,1), PM_TYPE_U32, X_INDOM, PM_SEM_INSTANT,
                    { 0,0,0,0,0,0} }, },
            /* C */
                { (void *)0,
                  { PMDA_PMID(0,2), PM_TYPE_DOUBLE, Y_INDOM, PM_SEM_INSTANT,
                    { 0,1,0,0,PM_TIME_SEC,0} }, }
            };

       The metric description table defines metric A with no instance domain, metric B with  instance  domain  X
       and  metric  C  with  instance  domain Y.  Metric C has units of seconds, while the other metrics have no
       units (simple counters).  <b>pmdaInit</b> will take these structures and assign the <b><a href="../man3/PMDA.3.html">PMDA</a></b>(3) domain number to the
       <u>it_indom</u> field of each instance domain.  This identifier also replaces the <u>indom</u>  field  of  all  metrics
       which have that instance domain, so that they are correctly associated.

       The  second  stage  opens  the  help text file, if one was specified with the <b>-h</b> command line option (see
       <b><a href="../man3/pmdaGetOpt.3.html">pmdaGetOpt</a></b>(3)) or as a <u>helptext</u> argument to <b><a href="../man3/pmdaDSO.3.html">pmdaDSO</a></b>(3) or <b><a href="../man3/pmdaDaemon.3.html">pmdaDaemon</a></b>(3).

       The final stage involves preparing the metric table lookup strategy.

</pre><h4><b>METRIC</b> <b>LOOKUP</b></h4><pre>
       When fetch and descriptor requests are made of the PMDA, each requested PMID must be mapped to  a  metric
       table  entry.   There  are  currently  three  strategies for performing this mapping - direct, linear and
       hashed.  Each has its own set of tradeoffs and an appropriate strategy should be selected for each PMDA.

       If all of the metric PMID item numbers correspond to the position in the <u>metrics</u> table, then direct  map‐
       ping is used.  This is the most efficient of the lookup functions as it involves a direct array index (no
       additional memory is required nor any additional processing overhead).  If the PMID numbering requirement
       is met by the PMDA, it is ideal.  This strategy can be explicitly requested by calling <b>pmdaSetFlags</b>(<u>pmda</u>,
       <u>PMDA_EXT_FLAG_DIRECT</u>) before calling <b>pmdaInit</b>.  In this case, if the direct mapping is not possible (e.g.
       due  to  an  oversight on the part of the PMDA developer), a warning is logged and the linear strategy is
       used instead.

       The second strategy (linear search) is the default, when a direct mapping cannot  be  established.   This
       provides  greater  flexibility  in  the PMID numbering scheme, as the PMDA item numbers do not have to be
       unique (hence, the PMID cluster numbers can be used more freely, which is often extremely convenient  for
       the  PMDA  developer).  However, lookup involves a linear walk from the start of the metric table until a
       matching PMID is found, for each requested PMID in a request.

       The third strategy (hash lookup) can be requested by calling <b>pmdaSetFlags</b>(<u>pmda</u>, <u>PMDA_EXT_FLAG_HASHED</u>) be‐
       fore calling <b>pmdaInit</b>.  This strategy is most useful for PMDAs with large numbers of metrics  (many  hun‐
       dreds,  or  thousands).   Such  PMDAs  will almost always use the cluster numbering scheme, so the direct
       lookup scheme becomes inappropriate.  They may also be prepared to sacrifice a small amount of additional
       memory for a hash table, mapping PMID to metric table offsets, to speed up lookups in their  vast  metric
       tables.

       This  final  strategy  can also be used by PMDAs serving up dynamically numbered metrics.  For this case,
       the <b>pmdaRehash</b> function should be used to replace the metric table when new metrics become available,  or
       existing  metrics  are  removed.   The PMID hash mapping will be recomputed at the same time that the new
       metric table is installed.

</pre><h4><b>METRIC</b> <b>CHANGES</b></h4><pre>
       It should be well understood by PMDA authors that metric metadata for individual metrics  is  fixed,  and
       ideally  would  not  ever  change.   In  the situation where metadata is incorrect and is updated, such a
       change requires correction to logged metrics using <b><a href="../man1/pmlogrewrite.1.html">pmlogrewrite</a></b>(1), and as a  result  should  be  avoided
       whenever possible.

       However, a PMDA may become aware of new domain metrics at runtime, and in this case it is ideal to export
       them immediately (without any collector system restart).  In this situation, the PMDA can inform all run‐
       ning  PMAPI  clients  that  may  have  already  explored  the metric namespace (for example, using <b>pmTra‐</b>
       <b><a href="../man3/versePMNS.3.html">versePMNS</a></b>(3)) of the change to the metric namespace.

       This  is  achieved  using  <b>pmdaSetFlags</b>(<u>pmda</u>,  <u>PMDA_EXT_NAMES_CHANGE</u>)  which  will  result  in  the   PM‐
       CD_NAMES_CHANGE  state  change  notification being sent to each PMAPI client on next fetch.  If the newly
       discovered metrics have label metadata associated, then the <u>PMDA_EXT_LABEL_CHANGE</u> flag may also  be  set,
       which will result in the PMCD_LABEL_CHANGE notification being sent as well.

       <b>pmdaExtSetFlags</b>  is  equivalent to <b>pmdaSetFlags</b>, and is provided as a convenience interface in situations
       where the <b>pmdaExt</b> is more readily available than the <b>pmdaInterface</b> structure.

</pre><h4><b>COMMUNICATION</b> <b>ATTRIBUTES</b></h4><pre>
       Agents that make use of authentication or container attributes should indicate this  using  the  <b>pmdaSet‐</b>
       <b>CommFlags</b>  interface.  This indicates the need for these attributes to be communicated on the channel be‐
       tween the PMDA and <b>pmcd</b> or local context client.  Valid flags are PMDA_FLAG_AUTHORIZE (for authentication
       related attributes) and PMDA_FLAG_CONTAINER (for container name related attributes).

</pre><h4><b>PRIVATE</b> <b>DATA</b></h4><pre>
       A facility for associating private PMDA data with the <b>pmdaExt</b> structure is available.  This allows a PMDA
       to associate an arbitrary (and typically not global) pointer with the <b>pmdaExt</b> such that it can  be  later
       obtained  during  callbacks.  The interfaces for setting this pointer are <b>pmdaSetData</b> and <b>pmdaExtSetData</b>,
       and <b>pmdaExtGetData</b> for subsequently retrieving it.

</pre><h4><b>CAVEAT</b></h4><pre>
       The PMDA must be using <b>PMDA_INTERFACE_2</b> or later, as specified in the call to <b><a href="../man3/pmdaDSO.3.html">pmdaDSO</a></b>(3) or <b><a href="../man3/pmdaDaemon.3.html">pmdaDaemon</a></b>(3)
       to use <b>pmdaInit</b>.

       The PMDA must use <b>PMDA_INTERFACE_7</b> or later to issue state change notifications using <b>pmdaSetFlags</b> or <b>pm‐</b>
       <b>daExtSetFlags</b>.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       <b>pmdaInit</b> will set <u>dispatch-&gt;status</u> to a value less than zero if there is an error that would prevent  the
       <b><a href="../man3/PMDA.3.html">PMDA</a></b>(3) from successfully running.  <b><a href="../man1/pmcd.1.html">pmcd</a></b>(1) will terminate the connection to the <b><a href="../man3/PMDA.3.html">PMDA</a></b>(3) if this occurs.

       <b>pmdaInit</b> may issue any of these messages:

       <b>PMDA</b> <b>interface</b> <b>version</b> <u>interface</u> <b>not</b> <b>supported</b>
                      The <u>interface</u> version is not supported by <b>pmdaInit</b>.

       <b>Using</b> <b>pmdaFetch()</b> <b>but</b> <b>fetch</b> <b>call</b> <b>back</b> <b>not</b> <b>set</b>
                      The fetch callback, <b><a href="../man3/pmdaFetch.3.html">pmdaFetch</a></b>(3), requires an additional callback to be provided using <b>pm‐</b>
                      <b><a href="../man3/daSetFetchCallBack.3.html">daSetFetchCallBack</a></b>(3).

       <b>Illegal</b> <b>instance</b> <b>domain</b> <u>inst</u> <b>for</b> <b>metric</b> <u>pmid</u>
                      The instance domain <u>inst</u> that was specified for metric <u>pmid</u> is not within the range of the
                      instance domain table.

       <b>No</b> <b>help</b> <b>text</b> <b>path</b> <b>specified</b>
                      The  help  text  callback,  <b><a href="../man3/pmdaText.3.html">pmdaText</a></b>(3), requires a help text file for the metrics to have
                      been opened, however no path to the help text was specified as a command line  option,  or
                      as an argument to <b><a href="../man3/pmdaDSO.3.html">pmdaDSO</a></b>(3) or <b><a href="../man3/pmdaDaemon.3.html">pmdaDaemon</a></b>(3).  This message is only a warning.

       <b>Direct</b> <b>mapping</b> <b>for</b> <b>metrics</b> <b>disabled</b> <b>@</b> <u>num</u>
                      The  unit numbers of the metrics did not correspond to the index in the metric description
                      table.  The direct mapping failed for metric number <u>num</u> in the  <u>metrics</u>  table.   This  is
                      less efficient but is not fatal and the message is only a warning.

       <b>Hashed</b> <b>mapping</b> <b>for</b> <b>metrics</b> <b>disabled</b> <b>@</b> <u>num</u>
                      A memory allocation failure occurred while building the hash table to index the metric de‐
                      scription  table.   This  is  a non-fatal warning message - a fallback to linear searching
                      will be automatically performed should this situation arise.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/newhelp.1.html">newhelp</a></b>(1), <b><a href="../man1/pmcd.1.html">pmcd</a></b>(1), <b><a href="../man1/pmlogrewrite.1.html">pmlogrewrite</a></b>(1), <b><a href="../man3/PMAPI.3.html">PMAPI</a></b>(3), <b><a href="../man3/PMDA.3.html">PMDA</a></b>(3), <b><a href="../man3/pmdaDaemon.3.html">pmdaDaemon</a></b>(3), <b><a href="../man3/pmdaDSO.3.html">pmdaDSO</a></b>(3), <b><a href="../man3/pmdaFetch.3.html">pmdaFetch</a></b>(3), <b>pmdaGe‐</b>
       <b><a href="../man3/tOpt.3.html">tOpt</a></b>(3), <b><a href="../man3/pmdaText.3.html">pmdaText</a></b>(3), <b><a href="../man3/pmLookupDesc.3.html">pmLookupDesc</a></b>(3) and <b><a href="../man3/pmTraversePMNS.3.html">pmTraversePMNS</a></b>(3).

Performance Co-Pilot                                   PCP                                           <u><a href="../man3/PMDAINIT.3.html">PMDAINIT</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>