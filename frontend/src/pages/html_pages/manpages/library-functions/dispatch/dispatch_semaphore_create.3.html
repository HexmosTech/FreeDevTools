<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dispatch_semaphore_create,  dispatch_semaphore_signal,  dispatch_semaphore_wait  —  synchronized counting</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libdispatch-dev">libdispatch-dev_0~svn197-3.3ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dispatch_semaphore_create,  dispatch_semaphore_signal,  dispatch_semaphore_wait  —  synchronized counting
       semaphore

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;dispatch/dispatch.h&gt;</b>

       <u>dispatch_semaphore_t</u>
       <b>dispatch_semaphore_create</b>(<u>long</u> <u>count</u>);

       <u>long</u>
       <b>dispatch_semaphore_signal</b>(<u>dispatch_semaphore_t</u> <u>semaphore</u>);

       <u>long</u>
       <b>dispatch_semaphore_wait</b>(<u>dispatch_semaphore_t</u> <u>semaphore</u>, <u>dispatch_time_t</u> <u>timeout</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Dispatch semaphores are used to synchronize  threads.   The  <u>timeout</u>  parameter  is  creatable  with  the
       <u><a href="../man3/dispatch_time.3.html">dispatch_time</a></u>(3) or <u><a href="../man3/dispatch_walltime.3.html">dispatch_walltime</a></u>(3) functions.

</pre><h4><b>COMPLETION</b> <b>SYNCHRONIZATION</b></h4><pre>
       If  the  <u>count</u>  parameter  is equal to zero, then the semaphore is useful for synchronizing completion of
       work.  For example:

             sema = <a href="../man0/dispatch_semaphore_create.0.html">dispatch_semaphore_create</a>(0);

             dispatch_async(queue, ^{
                     foo();
                     dispatch_semaphore_signal(sema);
             });

             bar();

             dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);

</pre><h4><b>FINITE</b> <b>RESOURCE</b> <b>POOL</b></h4><pre>
       If the <u>count</u> parameter is greater than zero, then the semaphore is useful for managing a finite  pool  of
       resources.  For example, a library that wants to limit Unix descriptor usage:

             sema = dispatch_semaphore_create(getdtablesize() / 4);

       At each Unix FD allocation:

             dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
             fd = open("<a href="file:/etc/services">/etc/services</a>", O_RDONLY);

       When each FD is closed:

             close(fd);
             dispatch_semaphore_signal(sema);

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>dispatch_semaphore_create</b>() function returns NULL if no memory is available or if the <u>count</u> parameter
       is less than zero.

       The  <b>dispatch_semaphore_signal</b>()  function  returns  non-zero when a thread is woken.  Otherwise, zero is
       returned.

       The <b>dispatch_semaphore_wait</b>() function returns zero upon success and non-zero after the timeout  expires.
       If  the timeout is DISPATCH_TIME_FOREVER, then <b>dispatch_semaphore_wait</b>() waits forever and always returns
       zero.

</pre><h4><b>MEMORY</b> <b>MODEL</b></h4><pre>
       Dispatch semaphores are retained and released via calls to <b>dispatch_retain</b>() and <b>dispatch_release</b>().

</pre><h4><b>CAVEATS</b></h4><pre>
       Dispatch semaphores are strict counting semaphores.  In other words, dispatch semaphores do not  saturate
       at any particular value.  Saturation can be achieved through atomic compare-and-swap logic.  What follows
       is a saturating binary semaphore:

       void
       saturating_semaphore_signal(dispatch_semaphore_t dsema, int *sent)
       {
               if (__sync_bool_compare_and_swap(sent, 0, 1)) {
                       dispatch_semaphore_signal(dsema);
               }
       }

       void
       saturating_semaphore_wait(dispatch_semaphore_t dsema, int *sent)
       {
               *sent = 0;
               dispatch_semaphore_wait(dsema, DISPATCH_TIME_FOREVER);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/dispatch.3.html">dispatch</a></u>(3), <u><a href="../man3/dispatch_object.3.html">dispatch_object</a></u>(3)

Darwin                                             May 1, 2009                      <u><a href="../man3/dispatch_semaphore_create.3.html">dispatch_semaphore_create</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>