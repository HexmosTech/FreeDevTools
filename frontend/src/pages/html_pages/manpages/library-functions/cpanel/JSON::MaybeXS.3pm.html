<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON::MaybeXS - Use Cpanel::JSON::XS with a fallback to JSON::XS and JSON::PP</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libjson-maybexs-perl">libjson-maybexs-perl_1.004008-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       JSON::MaybeXS - Use Cpanel::JSON::XS with a fallback to JSON::XS and JSON::PP

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use JSON::MaybeXS;

         my $data_structure = decode_json($json_input);

         my $json_output = encode_json($data_structure);

         my $json = JSON()-&gt;new;

         my $json_with_args = JSON::MaybeXS-&gt;new(utf8 =&gt; 1); # or { utf8 =&gt; 1 }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module first checks to see if either Cpanel::JSON::XS or JSON::XS (at at least version 3.0) is
       already loaded, in which case it uses that module. Otherwise it tries to load Cpanel::JSON::XS, then
       JSON::XS, then JSON::PP in order, and either uses the first module it finds or throws an error.

       It then exports the "encode_json" and "decode_json" functions from the loaded module, along with a "JSON"
       constant that returns the class name for calling "new" on.

       If you're writing fresh code rather than replacing JSON.pm usage, you might want to pass options as
       constructor args rather than calling mutators, so we provide our own "new" method that supports that.

</pre><h4><b>EXPORTS</b></h4><pre>
       "encode_json", "decode_json" and "JSON" are exported by default; "is_bool" is exported on request.

       To import only some symbols, specify them on the "use" line:

         use JSON::MaybeXS qw(encode_json decode_json is_bool); # functions only

         use JSON::MaybeXS qw(JSON); # JSON constant only

       To import all available sensible symbols ("encode_json", "decode_json", and "is_bool"), use ":all":

         use JSON::MaybeXS ':all';

       To import all symbols including those needed by legacy apps that use JSON::PP:

         use JSON::MaybeXS ':legacy';

       This imports the "to_json" and "from_json" symbols as well as everything in ":all".  NOTE: This is to
       support legacy code that makes extensive use of "to_json" and "from_json" which you are not yet in a
       position to refactor.  DO NOT use this import tag in new code, in order to avoid the crawling horrors of
       getting UTF-8 support subtly wrong.  See the documentation for JSON for further details.

   <b>encode_json</b>
       This is the "encode_json" function provided by the selected implementation module, and takes a perl data
       structure which is serialised to JSON text.

         my $json_text = encode_json($data_structure);

   <b>decode_json</b>
       This is the "decode_json" function provided by the selected implementation module, and takes a string of
       JSON text to deserialise to a perl data structure.

         my $data_structure = decode_json($json_text);

   <b>to_json</b>
       This function is equivalent to calling "JSON()-&gt;new-&gt;encode($data_structure)".  It takes a perl data
       structure which is serialised to JSON text without encoding it to UTF-8. You should only use this
       function if you expect another layer to handle the UTF-8 encoding of the resulting JSON text.

         my $json_text = to_json($data_structure);

       Additional arguments can be passed and will be handled as in "to_json" in JSON, this is included to
       support legacy code <b>only</b>.

   <b>from_json</b>
       This function is equivalent to calling "JSON()-&gt;new-&gt;decode($json_text)". It takes a string of unencoded
       JSON text to deserialise to a perl data structure. You should only use this function if another layer is
       already handling the UTF-8 decoding of the input JSON text.

         my $data_structure = from_json($json_text);

       Additional arguments can be passed and will be handled as in "from_json" in JSON, this is included to
       support legacy code <b>only</b>.

   <b>JSON</b>
       The "JSON" constant returns the selected implementation module's name for use as a class name - so:

         my $json_obj = JSON()-&gt;new; # returns a Cpanel::JSON::XS or JSON::PP object

       and that object can then be used normally:

         my $data_structure = $json_obj-&gt;decode($json_text); # etc.

       The use of parentheses here is optional, and only used as a hint to the reader that this use of "JSON" is
       a <u>subroutine</u> call, <u>not</u> a class name.

   <b>is_bool</b>
         $is_boolean = is_bool($scalar)

       Returns true if the passed scalar represents either "true" or "false", two constants that act like 1 and
       0, respectively and are used to represent JSON "true" and "false" values in Perl.

       Since this is a bare sub in the various backend classes, it cannot be called as a class method like the
       other interfaces; it must be called as a function, with no invocant.  It supports the representation used
       in all JSON backends.

       Available since version 1.002004.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>new</b>
       With JSON::PP, JSON::XS and Cpanel::JSON::XS you are required to call mutators to set options, such as:

         my $json = $class-&gt;new-&gt;<a href="../man1/utf8.1.html">utf8</a>(1)-&gt;<a href="../man1/pretty.1.html">pretty</a>(1);

       Since this is a trifle irritating and noticeably un-perlish, we also offer:

         my $json = JSON::MaybeXS-&gt;new(utf8 =&gt; 1, pretty =&gt; 1);

       which works equivalently to the above (and in the usual tradition will accept a hashref instead of a
       hash, should you so desire).

       The resulting object is blessed into the underlying backend, which offers (at least) the methods "encode"
       and "decode".

</pre><h4><b>BOOLEANS</b></h4><pre>
       To include JSON-aware booleans ("true", "false") in your data, just do:

           use JSON::MaybeXS;
           my $true = JSON()-&gt;true;
           my $false = JSON()-&gt;false;

       The booleans are also available as subs or methods on JSON::MaybeXS.

           use JSON::MaybeXS ();
           my $true = JSON::MaybeXS::true;
           my $true = JSON::MaybeXS-&gt;true;
           my $false = JSON::MaybeXS::false;
           my $false = JSON::MaybeXS-&gt;false;

</pre><h4><b>CONVERTING</b> <b>FROM</b> <b>JSON::Any</b></h4><pre>
       JSON::Any used to be the favoured compatibility layer above the various JSON backends, but over time has
       grown a lot of extra code to deal with legacy backends (e.g. JSON::Syck) that are no longer needed.  This
       is a rough guide of translating such code:

       Change code from:

           use JSON::Any;
           my $json = JSON::Any-&gt;new-&gt;objToJson($data);    # or to_json($data), or Dump($data)

       to:

           use JSON::MaybeXS;
           my $json = encode_json($data);

       Change code from:

           use JSON::Any;
           my $data = JSON::Any-&gt;new-&gt;jsonToObj($json);    # or from_json($json), or Load($json)

       to:

           use JSON::MaybeXS;
           my $json = decode_json($data);

</pre><h4><b>CAVEATS</b></h4><pre>
       The new() method in this module is technically a factory, not a constructor, because the objects it
       returns will <u>NOT</u> be blessed into the "JSON::MaybeXS" class.

       If you are using an object returned by this module as a Moo(se) attribute, this type constraint code:

           is 'json' =&gt; ( isa =&gt; 'JSON::MaybeXS' );

       will <u>NOT</u> do what you expect. Instead, either rely on the "JSON" class constant described above, as so:

           is 'json' =&gt; ( isa =&gt; JSON::MaybeXS::JSON() );

       Alternatively, you can use duck typing:

           use Moose::Util::TypeConstraints 'duck_type';
           is 'json' =&gt; ( isa =&gt; Object , duck_type([qw/ encode decode /]));

</pre><h4><b>INSTALLATION</b></h4><pre>
       At installation time, <u>Makefile.PL</u> will attempt to determine if you have a working compiler available, and
       therefore whether you are able to run XS code.  If so, Cpanel::JSON::XS will be added to the prerequisite
       list, unless JSON::XS is already installed at a high enough version. JSON::XS may also be upgraded to fix
       any incompatibility issues.

       Because running XS code is not mandatory and JSON::PP (which is in perl core) is used as a fallback
       backend, this module is safe to be used in a suite of code that is fatpacked or installed into a
       restricted-resource environment.

       You can also prevent any XS dependencies from being installed by setting "PUREPERL_ONLY=1" in <u>Makefile.PL</u>
       options (or in the "PERL_MM_OPT" environment variable), or using the "--pp" or "--pureperl" flags with
       the cpanminus client.

</pre><h4><b>AUTHOR</b></h4><pre>
       mst - Matt S. Trout (cpan:MSTROUT) &lt;<a href="mailto:mst@shadowcat.co.uk">mst@shadowcat.co.uk</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Clinton Gormley &lt;<a href="mailto:drtech@cpan.org">drtech@cpan.org</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Kieren Diment &lt;<a href="mailto:diment@gmail.com">diment@gmail.com</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2013 the "JSON::MaybeXS" "AUTHOR" and "CONTRIBUTORS" as listed above.

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software and may be distributed under the same terms as perl itself.

perl v5.38.2                                       2024-08-11                                 <u>JSON::<a href="../man3pm/MaybeXS.3pm.html">MaybeXS</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>