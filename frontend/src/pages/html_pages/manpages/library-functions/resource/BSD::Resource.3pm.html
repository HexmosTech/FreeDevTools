<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BSD::Resource - BSD process resource limit and priority functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbsd-resource-perl">libbsd-resource-perl_1.2911-2build5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       BSD::Resource - BSD process resource limit and priority functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use BSD::Resource;

               #
               # the process resource consumption so far
               #

               ($usertime, $systemtime,
                $maxrss, $ixrss, $idrss, $isrss, $minflt, $majflt, $nswap,
                $inblock, $oublock, $msgsnd, $msgrcv,
                $nsignals, $nvcsw, $nivcsw) = getrusage($ru_who);

               $rusage = getrusage($ru_who);

               #
               # the process resource limits
               #

               ($nowsoft, $nowhard) = getrlimit($resource);

               $rlimit = getrlimit($resource);

               $success = setrlimit($resource, $newsoft, $newhard);

               #
               # the process scheduling priority
               #

               $nowpriority = getpriority($pr_which, $pr_who);

               $success = setpriority($pr_which, $pr_who, $priority);

               # The following is not a BSD function.
               # It is a Perlish utility for the users of BSD::Resource.

               $rlimits = get_rlimits();

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>getrusage</b>
               ($usertime, $systemtime,
                $maxrss, $ixrss, $idrss, $isrss, $minflt, $majflt, $nswap,
                $inblock, $oublock, $msgsnd, $msgrcv,
                $nsignals, $nvcsw, $nivcsw) = getrusage($ru_who);

               $rusage = getrusage($ru_who);

               # $ru_who argument is optional; it defaults to RUSAGE_SELF

               $rusage = getrusage();

       The $ru_who argument is either "RUSAGE_SELF" (the current process) or "RUSAGE_CHILDREN" (all the child
       processes of the current process) or it maybe left away in which case "RUSAGE_SELF" is used.

       The "RUSAGE_CHILDREN" is the total sum of all the so far <u>terminated</u> (either successfully or
       unsuccessfully) child processes: there is no way to find out information about child processes still
       running.

       On some systems (those supporting both <b>getrusage()</b> with the POSIX threads) there can also be
       "RUSAGE_THREAD". The BSD::Resource supports the "RUSAGE_THREAD" if it is present but understands nothing
       more about the POSIX threads themselves.  Similarly for "RUSAGE_BOTH": some systems support retrieving
       the sums of the self and child resource consumptions simultaneously.

       In list context <b>getrusage()</b> returns the current resource usages as a list. On failure it returns an empty
       list.

       The elements of the list are, in order:      index     name      meaning usually (quite system dependent)

                0      utime           user time
                1      stime           system time
                2      maxrss          maximum shared memory or current resident set
                3      ixrss           integral shared memory
                4      idrss           integral or current unshared data
                5      isrss           integral or current unshared stack
                6      minflt          page reclaims
                7      majflt          page faults
                8      nswap           swaps
                9      inblock         block input operations
               10      oublock         block output operations
               11      msgsnd          messages sent
               12      msgrcv          messaged received
               13      nsignals        signals received
               14      nvcsw           voluntary context switches
               15      nivcsw          involuntary context switches

       In scalar context <b>getrusage()</b> returns the current resource usages as a an object. The object can be
       queried via methods named exactly like the middle column, <u>name</u>, in the above table.

               $ru = getrusage();
               print $ru-&gt;stime, "\n";

               $total_context_switches = $ru-&gt;nvcsw + $ru-&gt;nivcsw;

       For a detailed description about the values returned by <b>getrusage()</b> please consult your usual C
       programming documentation about <b>getrusage()</b> and also the header file "&lt;sys/resource.h&gt;".  (In <b>Solaris</b>,
       this might be "&lt;sys/rusage.h&gt;").

       See also "KNOWN ISSUES".

   <b>getrlimit</b>
               ($nowsoft, $nowhard) = getrlimit($resource);

               $rlimit = getrlimit($resource);

       The $resource argument can be one of

               $resource               usual meaning           usual unit

               RLIMIT_CPU              CPU time                seconds

               RLIMIT_FSIZE            file size               bytes

               RLIMIT_DATA             data size               bytes
               RLIMIT_STACK            stack size              bytes
               RLIMIT_CORE             coredump size           bytes
               RLIMIT_RSS              resident set size       bytes
               RLIMIT_MEMLOCK          memory locked data size bytes

               RLIMIT_NPROC            number of processes     1

               RLIMIT_NOFILE           number of open files    1
               RLIMIT_OFILE            number of open files    1
               RLIMIT_OPEN_MAX         number of open files    1

               RLIMIT_LOCKS            number of file locks    1

               RLIMIT_AS               (virtual) address space bytes
               RLIMIT_VMEM             virtual memory (space)  bytes

               RLIMIT_PTHREAD          number of pthreads      1
               RLIMIT_TCACHE           maximum number of       1
                                       cached threads

               RLIMIT_AIO_MEM          maximum memory locked   bytes
                                       for POSIX AIO
               RLIMIT_AIO_OPS          maximum number          1
                                       for POSIX AIO ops

               RLIMIT_FREEMEM          portion of the total memory

               RLIMIT_NTHR             maximum number of       1
                                       threads

               RLIMIT_NPTS             maximum number of       1
                                       pseudo-terminals

               RLIMIT_RSESTACK         RSE stack size          bytes

               RLIMIT_SBSIZE           socket buffer size      bytes

               RLIMIT_SWAP             maximum swap size       bytes

               RLIMIT_MSGQUEUE         POSIX mq size           bytes

               RLIMIT_RTPRIO           maximum RT priority     1
               RLIMIT_RTTIME           maximum RT time         microseconds
               RLIMIT_SIGPENDING       pending signals         1

       <b>What</b> <b>limits</b> <b>are</b> <b>available</b> <b>depends</b> <b>on</b> <b>the</b> <b>operating</b> <b>system</b>.

       See below for get_rlimits() on how to find out which limits are available, for the exact documentation
       consult the documentation of your operating system (setrlimit documentation, usually).

       The two groups ("NOFILE", "OFILE", "OPEN_MAX") and ("AS", "VMEM") are aliases within themselves.

       Two meta-resource-symbols might exist

               RLIM_NLIMITS
               RLIM_INFINITY

       "RLIM_NLIMITS" being the number of possible (but not necessarily fully supported) resource limits, see
       also the <b>get_rlimits()</b> call below.  "RLIM_INFINITY" is useful in <b>setrlimit()</b>, the "RLIM_INFINITY" is
       often represented as minus one (-1).

       In list context getrlimit() returns the current soft and hard resource limits as a list.  On failure it
       returns an empty list.

       Processes have soft and hard resource limits.  On crossing the soft limit they receive a signal (for
       example the "SIGXCPU" or "SIGXFSZ", corresponding to the "RLIMIT_CPU" and "RLIMIT_FSIZE", respectively).
       The processes can trap and handle some of these signals, please see "Signals" in perlipc.  After the hard
       limit the processes will be ruthlessly killed by the "KILL" signal which cannot be caught.

       <b>NOTE</b>: the level of 'support' for a resource varies. Not all the systems

               a) even recognise all those limits
               b) really track the consumption of a resource
               c) care (send those signals) if a resource limit is exceeded

       Again, please consult your usual C programming documentation.

       One notable exception for the better: officially <b>HP-UX</b> does not support <b>getrlimit()</b> at all but for the
       time being, it does seem to.

       In scalar context getrlimit() returns the current soft limit.  On failure it returns "undef".

   <b>getpriority</b>
               # $pr_which can be PRIO_USER, PRIO_PROCESS, or PRIO_PGRP,
               # and in some systems PRIO_THREAD

               $nowpriority = getpriority($pr_which, $pr_who);

               # the default $pr_who is 0 (the current $pr_which)

               $nowpriority = getpriority($pr_which);

               # the default $pr_which is PRIO_PROCESS (the process priority)

               $nowpriority = getpriority();

       <b>getpriority()</b> returns the current priority. <b>NOTE</b>: <b>getpriority()</b> can return zero or negative values
       completely legally. On failure <b>getpriority()</b> returns "undef" (and $! is set as usual).

       The priorities returned by <b>getpriority()</b> are in the (inclusive) range "PRIO_MIN"..."PRIO_MAX".  The
       $pr_which argument can be any of PRIO_PROCESS (a process) "PRIO_USER" (a user), or "PRIO_PGRP" (a process
       group). The $pr_who argument tells which process/user/process group, 0 signifying the current one.

       Usual values for "PRIO_MIN", "PRIO_MAX", are -20, 20.  A negative value means better priority (more
       impolite process), a positive value means worse priority (more polite process).

   <b>setrlimit</b>
               $success = setrlimit($resource, $newsoft, $newhard);

       <b>setrlimit()</b> returns true on success and "undef" on failure.

       <b>NOTE</b>: A normal user process can only lower its resource limits.  Soft or hard limit "RLIM_INFINITY" means
       as much as possible, the real hard limits are normally buried inside the kernel and are <b>very</b> system-
       dependent.

       <b>NOTE</b>: Even the soft limit that is actually set might be lower than what requested for various reasons.
       One possibility is that the actual limit on a resource might be controlled by some system variable (e.g.
       in BSD systems the RLIMIT_NPROC can be capped by the system variable "maxprocperuid", try "sysctl -a
       kern.maxprocperuid"), or in many environments core dumping has been disabled from normal user processes.
       Another possibility is that a limit is rounded down to some alignment or granularity, for example the
       memory limits might be rounded down to the closest 4 kilobyte boundary.  In other words, do not expect to
       be able to <b>setrlimit()</b> a limit to a value and then be able to read back the same value with <b>getrlimit()</b>.

   <b>setpriority</b>
               $success = setpriority($pr_which, $pr_who, $priority);

               # NOTE! If there are two arguments the second one is
               # the new $priority (not $pr_who) and the $pr_who is
               # defaulted to 0 (the current $pr_which)

               $success = setpriority($pr_which, $priority);

               # The $pr_who defaults to 0 (the current $pr_which) and
               # the $priority defaults to half of the PRIO_MAX, usually
               # that amounts to 10 (being a nice $pr_which).

               $success = setpriority($pr_which);

               # The $pr_which defaults to PRIO_PROCESS.

               $success = setpriority();

       <b>setpriority()</b> is used to change the scheduling priority.  A positive priority means a more polite
       process/process group/user; a negative priority means a more impolite process/process group/user.  The
       priorities handled by <b>setpriority()</b> are ["PRIO_MIN","PRIO_MAX"].  A normal user process can only lower
       its priority (make it more positive).

       <b>NOTE</b>: A successful call returns 1, a failed one 0.

       See also "KNOWN ISSUES".

   <b>times</b>
               use BSD::Resource qw(times);

               ($user, $system, $child_user, $child_system) = times();

       The BSD::Resource module offers a <b>times()</b> implementation that has usually slightly better time
       granularity than the <b>times()</b> by Perl core.  The time granularity of the latter is usually 1/60 seconds
       while the former may achieve submilliseconds.

       <b>NOTE</b>: The current implementation uses two <b>getrusage()</b> system calls: one with RUSAGE_SELF and one with
       RUSAGE_CHILDREN.  Therefore the operation is not `atomic': the times for the children are recorded a
       little bit later.

       <b>NOTE</b>: <b>times()</b> is not imported by default by BSD::Resource.  You need to tell that you want to use it.

       <b>NOTE:</b> <b>times()</b> <b>is</b> <b>not</b> <b>a</b> <b>"real</b> <b>BSD"</b> <b>function.</b>  <b>It</b> <b>is</b> <b>older</b> <b>UNIX.</b>

   <b>get_rlimits</b>
               use BSD::Resource qw{get_rlimits};
               my $limits = get_rlimits();

       <b>NOTE:</b> <b>This</b> <b>is</b> <b>not</b> <b>a</b> <b>real</b> <b>BSD</b> <b>function.</b> <b>It</b> <b>is</b> <b>a</b> <b>convenience</b> <b>function</b> <b>introduced</b> <b>by</b> <b>BSD::Resource.</b>

       <b>get_rlimits()</b> returns a reference to hash which has the names of the available resource limits as keys
       and their indices (those which are needed as the first argument to <b>getrlimit()</b> and <b>setrlimit()</b>) as
       values. For example:

               use BSD::Resource qw{get_rlimits};
               my $limits = get_rlimits();
               for my $name (keys %$limits) {
                 my ($soft, $hard) = BSD::Resource::getrlimit($limits-&gt;{$name});
                 print "$name soft $soft hard $hard\n";
               }

       Note that a limit of -1 means unlimited.

</pre><h4><b>ERRORS</b></h4><pre>
       •

                   Your vendor has not defined BSD::Resource macro ...

           The  code  tried  to  call  getrlimit/setrlimit  for  a  resource  limit  that  your operating system
           vendor/supplier does not support.  Portable code should use <b>get_rlimits()</b>  to  check  which  resource
           limits are defined.

</pre><h4><b>EXAMPLES</b></h4><pre>
               # the user and system times so far by the process itself

               ($usertime, $systemtime) = getrusage();

               # ditto in OO way

               $ru = getrusage();

               $usertime   = $ru-&gt;utime;
               $systemtime = $ru-&gt;stime;

               # get the current priority level of this process

               $currprio = getpriority();

</pre><h4><b>KNOWN</b> <b>ISSUES</b></h4><pre>
       In  <b>AIX</b> (at least version 3, maybe later also releases) if the BSD compatibility library is not installed
       or  not  found  by  the  BSD::Resource  installation  procedure  and  when  using  the  <b>getpriority()</b>  or
       <b>setpriority()</b>,  the "PRIO_MIN" is 0 (corresponding to -20) and "PRIO_MAX" is 39 (corresponding to 19, the
       BSD priority 20 is unreachable).

       In <b>HP-UX</b> the <b>getrusage()</b> is not Officially Supported at all but for the time being, it does seem to be.

       In <b>Mac</b> <b>OS</b> <b>X</b> a normal user cannot raise the "RLIM_NPROC" over the maxprocperuid limit (the  default  value
       is 266, try the command "sysctl -a kern.maxprocperuid").

       In <b>NetBSD</b> "RLIMIT_STACK" <b>setrlimit()</b> calls fail.

       In       <b>Cygwin</b>       "RLIMIT_STACK"       setrlimit       calls       fail.       Also,      <b>setrlimit()</b>
       "RLIMIT_NOFILE/RLIMIT_OFILE/RLIMIT_OFILE" calls return success, but then the subsequent  getrlimit  calls
       show that the limits didn't really change.

       Because  not  all  UNIX  kernels  are  BSD  and also because of the sloppy support of <b>getrusage()</b> by many
       vendors many of the <b>getrusage()</b> values may not be correctly updated.  For example  <b>Solaris</b>  <b>1</b>  claims  in
       "&lt;sys/rusage.h&gt;"  that  the  "ixrss"  and  the  "isrss" fields are always zero.  In <b>SunOS</b> <b>5.5</b> <b>and</b> <b>5.6</b> the
       <b>getrusage()</b> leaves most of the fields zero and therefore <b>getrusage()</b> is not even used,  instead  of  that
       the  <b><a href="file:/proc">/proc</a></b>  interface  is  used.   The  mapping  is not perfect: the "maxrss" field is really the <b>current</b>
       resident size instead of the maximum, the "idrss" is really the <b>current</b> heap size instead of the integral
       data, and the "isrss" is really the <b>current</b> stack size instead of the integral stack.  The ixrss  has  no
       sensible counterpart at all so it stays zero.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 1995-2017 Jarkko Hietaniemi All Rights Reserved

       This  module  free  software;  you  can  redistribute it and/or modify it under the terms of the Artistic
       License 2.0 or GNU Lesser General Public License 2.0.  For  more  details,  see  the  full  text  of  the
       licenses             at             &lt;<a href="http://www.perlfoundation.org/artistic_license_2_0">http://www.perlfoundation.org/artistic_license_2_0</a>&gt;,             and
       &lt;<a href="http://www.gnu.org/licenses/gpl-2.0.html">http://www.gnu.org/licenses/gpl-2.0.html</a>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jarkko Hietaniemi, "<a href="mailto:jhi@iki.fi">jhi@iki.fi</a>"

perl v5.40.0                                       2024-10-20                                      <u><a href="../man3pm/Resource.3pm.html">Resource</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>