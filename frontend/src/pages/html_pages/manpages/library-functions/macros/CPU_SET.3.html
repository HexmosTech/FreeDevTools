<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPU_SET,  CPU_CLR,  CPU_ISSET,  CPU_ZERO,  CPU_COUNT,  CPU_AND,  CPU_OR,  CPU_XOR,  CPU_EQUAL, CPU_ALLOC,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CPU_SET,  CPU_CLR,  CPU_ISSET,  CPU_ZERO,  CPU_COUNT,  CPU_AND,  CPU_OR,  CPU_XOR,  CPU_EQUAL, CPU_ALLOC,
       CPU_ALLOC_SIZE,  CPU_FREE,  CPU_SET_S,  CPU_CLR_S,  CPU_ISSET_S,  CPU_ZERO_S,   CPU_COUNT_S,   CPU_AND_S,
       CPU_OR_S, CPU_XOR_S, CPU_EQUAL_S - macros for manipulating CPU sets

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>             /* See <a href="../man7/feature_test_macros.7.html">feature_test_macros</a>(7) */
       <b>#include</b> <b>&lt;<a href="file:/usr/include/sched.h">sched.h</a>&gt;</b>

       <b>void</b> <b>CPU_ZERO(cpu_set_t</b> <b>*</b><u>set</u><b>);</b>

       <b>void</b> <b>CPU_SET(int</b> <u>cpu</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>set</u><b>);</b>
       <b>void</b> <b>CPU_CLR(int</b> <u>cpu</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>set</u><b>);</b>
       <b>int</b>  <b>CPU_ISSET(int</b> <u>cpu</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>set</u><b>);</b>

       <b>int</b>  <b>CPU_COUNT(cpu_set_t</b> <b>*</b><u>set</u><b>);</b>

       <b>void</b> <b>CPU_AND(cpu_set_t</b> <b>*</b><u>destset</u><b>,</b>
                    <b>cpu_set_t</b> <b>*</b><u>srcset1</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>srcset2</u><b>);</b>
       <b>void</b> <b>CPU_OR(cpu_set_t</b> <b>*</b><u>destset</u><b>,</b>
                    <b>cpu_set_t</b> <b>*</b><u>srcset1</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>srcset2</u><b>);</b>
       <b>void</b> <b>CPU_XOR(cpu_set_t</b> <b>*</b><u>destset</u><b>,</b>
                    <b>cpu_set_t</b> <b>*</b><u>srcset1</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>srcset2</u><b>);</b>

       <b>int</b>  <b>CPU_EQUAL(cpu_set_t</b> <b>*</b><u>set1</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>set2</u><b>);</b>

       <b>cpu_set_t</b> <b>*CPU_ALLOC(int</b> <u>num_cpus</u><b>);</b>
       <b>void</b> <b>CPU_FREE(cpu_set_t</b> <b>*</b><u>set</u><b>);</b>
       <b>size_t</b> <b>CPU_ALLOC_SIZE(int</b> <u>num_cpus</u><b>);</b>

       <b>void</b> <b>CPU_ZERO_S(size_t</b> <u>setsize</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>set</u><b>);</b>

       <b>void</b> <b>CPU_SET_S(int</b> <u>cpu</u><b>,</b> <b>size_t</b> <u>setsize</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>set</u><b>);</b>
       <b>void</b> <b>CPU_CLR_S(int</b> <u>cpu</u><b>,</b> <b>size_t</b> <u>setsize</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>set</u><b>);</b>
       <b>int</b>  <b>CPU_ISSET_S(int</b> <u>cpu</u><b>,</b> <b>size_t</b> <u>setsize</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>set</u><b>);</b>

       <b>int</b>  <b>CPU_COUNT_S(size_t</b> <u>setsize</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>set</u><b>);</b>

       <b>void</b> <b>CPU_AND_S(size_t</b> <u>setsize</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>destset</u><b>,</b>
                    <b>cpu_set_t</b> <b>*</b><u>srcset1</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>srcset2</u><b>);</b>
       <b>void</b> <b>CPU_OR_S(size_t</b> <u>setsize</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>destset</u><b>,</b>
                    <b>cpu_set_t</b> <b>*</b><u>srcset1</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>srcset2</u><b>);</b>
       <b>void</b> <b>CPU_XOR_S(size_t</b> <u>setsize</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>destset</u><b>,</b>
                    <b>cpu_set_t</b> <b>*</b><u>srcset1</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>srcset2</u><b>);</b>

       <b>int</b>  <b>CPU_EQUAL_S(size_t</b> <u>setsize</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>set1</u><b>,</b> <b>cpu_set_t</b> <b>*</b><u>set2</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>cpu_set_t</u>  data  structure  represents a set of CPUs.  CPU sets are used by <b><a href="../man2/sched_setaffinity.2.html">sched_setaffinity</a></b>(2) and
       similar interfaces.

       The <u>cpu_set_t</u> data type is implemented as a bit mask.  However, the data structure should be  treated  as
       opaque: all manipulation of CPU sets should be done via the macros described in this page.

       The following macros are provided to operate on the CPU set <u>set</u>:

       <b>CPU_ZERO</b>()
              Clears <u>set</u>, so that it contains no CPUs.

       <b>CPU_SET</b>()
              Add CPU <u>cpu</u> to <u>set</u>.

       <b>CPU_CLR</b>()
              Remove CPU <u>cpu</u> from <u>set</u>.

       <b>CPU_ISSET</b>()
              Test to see if CPU <u>cpu</u> is a member of <u>set</u>.

       <b>CPU_COUNT</b>()
              Return the number of CPUs in <u>set</u>.

       Where  a  <u>cpu</u>  argument  is  specified,  it  should  not produce side effects, since the above macros may
       evaluate the argument more than once.

       The first CPU on the system corresponds to a <u>cpu</u> value of 0, the next CPU corresponds to a <u>cpu</u>  value  of
       1,  and  so  on.  No assumptions should be made about particular CPUs being available, or the set of CPUs
       being contiguous, since CPUs can be taken offline dynamically  or  be  otherwise  absent.   The  constant
       <b>CPU_SETSIZE</b> (currently 1024) specifies a value one greater than the maximum CPU number that can be stored
       in <u>cpu_set_t</u>.

       The following macros perform logical operations on CPU sets:

       <b>CPU_AND</b>()
              Store  the intersection of the sets <u>srcset1</u> and <u>srcset2</u> in <u>destset</u> (which may be one of the source
              sets).

       <b>CPU_OR</b>()
              Store the union of the sets <u>srcset1</u> and <u>srcset2</u> in <u>destset</u> (which may be one of the source sets).

       <b>CPU_XOR</b>()
              Store the XOR of the sets <u>srcset1</u> and <u>srcset2</u> in <u>destset</u> (which may be one of  the  source  sets).
              The XOR means the set of CPUs that are in either <u>srcset1</u> or <u>srcset2</u>, but not both.

       <b>CPU_EQUAL</b>()
              Test whether two CPU set contain exactly the same CPUs.

   <b>Dynamically</b> <b>sized</b> <b>CPU</b> <b>sets</b>
       Because  some  applications  may require the ability to dynamically size CPU sets (e.g., to allocate sets
       larger than that defined by the standard <u>cpu_set_t</u> data type), glibc nowadays provides a set of macros to
       support this.

       The following macros are used to allocate and deallocate CPU sets:

       <b>CPU_ALLOC</b>()
              Allocate a CPU set large enough to hold CPUs in the range 0 to <u>num_cpus-1</u>.

       <b>CPU_ALLOC_SIZE</b>()
              Return the size in bytes of the CPU set that would be needed to  hold  CPUs  in  the  range  0  to
              <u>num_cpus-1</u>.   This  macro  provides  the  value  that  can be used for the <u>setsize</u> argument in the
              <b>CPU_*_S</b>() macros described below.

       <b>CPU_FREE</b>()
              Free a CPU set previously allocated by <b>CPU_ALLOC</b>().

       The macros whose names end with "_S" are the analogs of the similarly named macros  without  the  suffix.
       These macros perform the same tasks as their analogs, but operate on the dynamically allocated CPU set(s)
       whose size is <u>setsize</u> bytes.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>CPU_ISSET</b>() and <b>CPU_ISSET_S</b>() return nonzero if <u>cpu</u> is in <u>set</u>; otherwise, it returns 0.

       <b>CPU_COUNT</b>() and <b>CPU_COUNT_S</b>() return the number of CPUs in <u>set</u>.

       <b>CPU_EQUAL</b>() and <b>CPU_EQUAL_S</b>() return nonzero if the two CPU sets are equal; otherwise they return 0.

       <b>CPU_ALLOC</b>() returns a pointer on success, or NULL on failure.  (Errors are as for <b><a href="../man3/malloc.3.html">malloc</a></b>(3).)

       <b>CPU_ALLOC_SIZE</b>() returns the number of bytes required to store a CPU set of the specified cardinality.

       The other functions do not return a value.

</pre><h4><b>STANDARDS</b></h4><pre>
       Linux.

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>CPU_ZERO</b>(), <b>CPU_SET</b>(), <b>CPU_CLR</b>(), and <b>CPU_ISSET</b>() macros were added in glibc 2.3.3.

       <b>CPU_COUNT</b>() first appeared in glibc 2.6.

       <b>CPU_AND</b>(),  <b>CPU_OR</b>(),  <b>CPU_XOR</b>(),  <b>CPU_EQUAL</b>(),  <b>CPU_ALLOC</b>(), <b>CPU_ALLOC_SIZE</b>(), <b>CPU_FREE</b>(), <b>CPU_ZERO_S</b>(),
       <b>CPU_SET_S</b>(), <b>CPU_CLR_S</b>(), <b>CPU_ISSET_S</b>(), <b>CPU_AND_S</b>(), <b>CPU_OR_S</b>(), <b>CPU_XOR_S</b>(),  and  <b>CPU_EQUAL_S</b>()  first
       appeared in glibc 2.7.

</pre><h4><b>NOTES</b></h4><pre>
       To duplicate a CPU set, use <b><a href="../man3/memcpy.3.html">memcpy</a></b>(3).

       Since CPU sets are bit masks allocated in units of long words, the actual number of CPUs in a dynamically
       allocated  CPU  set  will  be  rounded  up to the next multiple of <u>sizeof(unsigned</u> <u>long)</u>.  An application
       should consider the contents of these extra bits to be undefined.

       Notwithstanding the similarity in the names, note that the constant <b>CPU_SETSIZE</b> indicates the  number  of
       CPUs  in the <u>cpu_set_t</u> data type (thus, it is effectively a count of the bits in the bit mask), while the
       <u>setsize</u> argument of the <b>CPU_*_S</b>() macros is a size in bytes.

       The data types for arguments and return values shown in the SYNOPSIS are hints what about is expected  in
       each  case.   However,  since  these interfaces are implemented as macros, the compiler won't necessarily
       catch all type errors if you violate the suggestions.

</pre><h4><b>BUGS</b></h4><pre>
       On 32-bit platforms with glibc 2.8 and earlier, <b>CPU_ALLOC</b>() allocates twice as much space as is required,
       and <b>CPU_ALLOC_SIZE</b>() returns a value twice as large as  it  should.   This  bug  should  not  affect  the
       semantics  of a program, but does result in wasted memory and less efficient operation of the macros that
       operate on dynamically allocated CPU sets.  These bugs are fixed in glibc 2.9.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following program demonstrates the use of some of the macros used for dynamically allocated CPU sets.

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/sched.h">sched.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       #include &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           cpu_set_t *cpusetp;
           size_t size, num_cpus;

           if (argc &lt; 2) {
               fprintf(stderr, "Usage: %s &lt;num-cpus&gt;\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           num_cpus = atoi(argv[1]);

           cpusetp = CPU_ALLOC(num_cpus);
           if (cpusetp == NULL) {
               perror("CPU_ALLOC");
               exit(EXIT_FAILURE);
           }

           size = CPU_ALLOC_SIZE(num_cpus);

           CPU_ZERO_S(size, cpusetp);
           for (size_t cpu = 0; cpu &lt; num_cpus; cpu += 2)
               CPU_SET_S(cpu, size, cpusetp);

           printf("CPU_COUNT() of set:    %d\n", CPU_COUNT_S(size, cpusetp));

           CPU_FREE(cpusetp);
           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/sched_setaffinity.2.html">sched_setaffinity</a></b>(2), <b><a href="../man3/pthread_attr_setaffinity_np.3.html">pthread_attr_setaffinity_np</a></b>(3), <b><a href="../man3/pthread_setaffinity_np.3.html">pthread_setaffinity_np</a></b>(3), <b><a href="../man7/cpuset.7.html">cpuset</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                         <u><a href="../man3/CPU_SET.3.html">CPU_SET</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>