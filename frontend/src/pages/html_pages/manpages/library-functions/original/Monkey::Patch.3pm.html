<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monkey::Patch - Scoped monkeypatching (you can at least play nice)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmonkey-patch-perl">libmonkey-patch-perl_0.03-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Monkey::Patch - Scoped monkeypatching (you can at least play nice)

</pre><h4><b>VERSION</b></h4><pre>
       version 0.03

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Monkey::Patch qw(:all);

           sub some_subroutine {
               my $pkg = patch_class 'Some::Class' =&gt; 'something' =&gt; sub {
                   my $original = shift;
                   say "Whee!";
                   $original-&gt;(@_);
               };
               Some::Class-&gt;something(); # says Whee! and does whatever
               undef $pkg;
               Some::Class-&gt;something(); # no longer says Whee!

               my $obj = Some::Class-&gt;new;
               my $obj2 = Some::Class-&gt;new;

               my $whoah = patch_object $obj, 'twiddle' =&gt; sub {
                   my $original = shift;
                   my $self     = shift;
                   say "Whoah!";
                   $self-&gt;$original(@_);
               };

               $obj-&gt;twiddle();  # says Whoah!
               $obj2-&gt;twiddle(); # doesn't
               $obj-&gt;twiddle()   # still does
               undef $whoah;
               $obj-&gt;twiddle();  # but not any more

</pre><h4><b>SUBROUTINES</b></h4><pre>
       The following subroutines are available (either individually or via :all)

   <b>patch_package</b> <b>(package,</b> <b>subname,</b> <b>code)</b>
       Wraps "package"'s subroutine named &lt;subname&gt; with your &lt;code&gt;.  Your code receives the original
       subroutine as its first argument, followed by any arguments the subroutine would have normally gotten.
       You can always call the subroutine ref your received; if there was no subroutine by that name, the
       coderef will simply do nothing.

   <b>patch_class</b> <b>(class,</b> <b>methodname,</b> <b>code)</b>
       Just like "patch_package", except that the @ISA chain is walked when you try to call the original
       subroutine if there wasn't any subroutine by that name in the package.

   <b>patch_object</b> <b>(object,</b> <b>methodname,</b> <b>code)</b>
       Just like "patch_class", except that your code will only get called on the object you pass, not the
       entire class.

</pre><h4><b>HANDLES</b></h4><pre>
       All the "patch" functions return a handle object.  As soon as you lose the value of the handle (by
       calling in void context, assigning over the variable, undeffing the variable, letting it go out of scope,
       etc), the monkey patch is unwrapped.  You can stack monkeypatches and let go of the handles in any order;
       they obey a stack discipline, and the most recent valid monkeypatch will always be called.  Calling the
       "original" argument to your wrapper routine will always call the next-most-recent monkeypatched version
       (or, the original subroutine, of course).

</pre><h4><b>BUGS</b></h4><pre>
       This magic is only faintly black, but mucking around with the symbol table is not for the faint of heart.
       Help make this module better by reporting any strange behavior that you see!

perl v5.36.0                                       2022-11-29                                 <u>Monkey::<a href="../man3pm/Patch.3pm.html">Patch</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>