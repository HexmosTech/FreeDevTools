<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lalsa - lalsa: SVD of coefficient matrix, step in gelsd</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lalsa - lalsa: SVD of coefficient matrix, step in gelsd

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>clalsa</b> (icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, vt, k, difl, difr, z, poles,
           givptr, givcol, ldgcol, perm, givnum, c, s, rwork, iwork, info)
           <b>CLALSA</b> computes the SVD of the coefficient matrix in compact form. Used by sgelsd.
       subroutine <b>dlalsa</b> (icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, vt, k, difl, difr, z, poles,
           givptr, givcol, ldgcol, perm, givnum, c, s, work, iwork, info)
           <b>DLALSA</b> computes the SVD of the coefficient matrix in compact form. Used by sgelsd.
       subroutine <b>slalsa</b> (icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, vt, k, difl, difr, z, poles,
           givptr, givcol, ldgcol, perm, givnum, c, s, work, iwork, info)
           <b>SLALSA</b> computes the SVD of the coefficient matrix in compact form. Used by sgelsd.
       subroutine <b>zlalsa</b> (icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, vt, k, difl, difr, z, poles,
           givptr, givcol, ldgcol, perm, givnum, c, s, rwork, iwork, info)
           <b>ZLALSA</b> computes the SVD of the coefficient matrix in compact form. Used by sgelsd.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>clalsa</b> <b>(integer</b> <b>icompq,</b> <b>integer</b> <b>smlsiz,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>nrhs,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b>
       <b>integer</b> <b>ldb,</b> <b>complex,</b> <b>dimension(</b> <b>ldbx,</b> <b>*</b> <b>)</b> <b>bx,</b> <b>integer</b> <b>ldbx,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>u,</b> <b>integer</b> <b>ldu,</b>
       <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>vt,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>k,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>difl,</b> <b>real,</b> <b>dimension(</b>
       <b>ldu,</b> <b>*</b> <b>)</b> <b>difr,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>z,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>poles,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>givptr,</b> <b>integer,</b> <b>dimension(</b> <b>ldgcol,</b> <b>*</b> <b>)</b> <b>givcol,</b> <b>integer</b> <b>ldgcol,</b> <b>integer,</b> <b>dimension(</b> <b>ldgcol,</b> <b>*</b> <b>)</b> <b>perm,</b>
       <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>givnum,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>c,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>s,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>rwork,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>info)</b>
       <b>CLALSA</b> computes the SVD of the coefficient matrix in compact form. Used by sgelsd.

       <b>Purpose:</b>

            CLALSA is an intermediate step in solving the least squares problem
            by computing the SVD of the coefficient matrix in compact form (The
            singular vectors are computed as products of simple orthogonal
            matrices.).

            If ICOMPQ = 0, CLALSA applies the inverse of the left singular vector
            matrix of an upper bidiagonal matrix to the right hand side; and if
            ICOMPQ = 1, CLALSA applies the right singular vector matrix to the
            right hand side. The singular vector matrices were generated in
            compact form by CLALSA.

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                    Specifies whether the left or the right singular vector
                    matrix is involved.
                    = 0: Left singular vector matrix
                    = 1: Right singular vector matrix

           <u>SMLSIZ</u>

                     SMLSIZ is INTEGER
                    The maximum size of the subproblems at the bottom of the
                    computation tree.

           <u>N</u>

                     N is INTEGER
                    The row and column dimensions of the upper bidiagonal matrix.

           <u>NRHS</u>

                     NRHS is INTEGER
                    The number of columns of B and BX. NRHS must be at least 1.

           <u>B</u>

                     B is COMPLEX array, dimension ( LDB, NRHS )
                    On input, B contains the right hand sides of the least
                    squares problem in rows 1 through M.
                    On output, B contains the solution X in rows 1 through N.

           <u>LDB</u>

                     LDB is INTEGER
                    The leading dimension of B in the calling subprogram.
                    LDB must be at least max(1,MAX( M, N ) ).

           <u>BX</u>

                     BX is COMPLEX array, dimension ( LDBX, NRHS )
                    On exit, the result of applying the left or right singular
                    vector matrix to B.

           <u>LDBX</u>

                     LDBX is INTEGER
                    The leading dimension of BX.

           <u>U</u>

                     U is REAL array, dimension ( LDU, SMLSIZ ).
                    On entry, U contains the left singular vector matrices of all
                    subproblems at the bottom level.

           <u>LDU</u>

                     LDU is INTEGER, LDU = &gt; N.
                    The leading dimension of arrays U, VT, DIFL, DIFR,
                    POLES, GIVNUM, and Z.

           <u>VT</u>

                     VT is REAL array, dimension ( LDU, SMLSIZ+1 ).
                    On entry, VT**H contains the right singular vector matrices of
                    all subproblems at the bottom level.

           <u>K</u>

                     K is INTEGER array, dimension ( N ).

           <u>DIFL</u>

                     DIFL is REAL array, dimension ( LDU, NLVL ).
                    where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.

           <u>DIFR</u>

                     DIFR is REAL array, dimension ( LDU, 2 * NLVL ).
                    On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
                    distances between singular values on the I-th level and
                    singular values on the (I -1)-th level, and DIFR(*, 2 * I)
                    record the normalizing factors of the right singular vectors
                    matrices of subproblems on I-th level.

           <u>Z</u>

                     Z is REAL array, dimension ( LDU, NLVL ).
                    On entry, Z(1, I) contains the components of the deflation-
                    adjusted updating row vector for subproblems on the I-th
                    level.

           <u>POLES</u>

                     POLES is REAL array, dimension ( LDU, 2 * NLVL ).
                    On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
                    singular values involved in the secular equations on the I-th
                    level.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER array, dimension ( N ).
                    On entry, GIVPTR( I ) records the number of Givens
                    rotations performed on the I-th problem on the computation
                    tree.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
                    On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
                    locations of Givens rotations performed on the I-th level on
                    the computation tree.

           <u>LDGCOL</u>

                     LDGCOL is INTEGER, LDGCOL = &gt; N.
                    The leading dimension of arrays GIVCOL and PERM.

           <u>PERM</u>

                     PERM is INTEGER array, dimension ( LDGCOL, NLVL ).
                    On entry, PERM(*, I) records permutations done on the I-th
                    level of the computation tree.

           <u>GIVNUM</u>

                     GIVNUM is REAL array, dimension ( LDU, 2 * NLVL ).
                    On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
                    values of Givens rotations performed on the I-th level on the
                    computation tree.

           <u>C</u>

                     C is REAL array, dimension ( N ).
                    On entry, if the I-th subproblem is not square,
                    C( I ) contains the C-value of a Givens rotation related to
                    the right null space of the I-th subproblem.

           <u>S</u>

                     S is REAL array, dimension ( N ).
                    On entry, if the I-th subproblem is not square,
                    S( I ) contains the S-value of a Givens rotation related to
                    the right null space of the I-th subproblem.

           <u>RWORK</u>

                     RWORK is REAL array, dimension at least
                    MAX( (SMLSZ+1)*NRHS*3, N*(1+NRHS) + 2*NRHS ).

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (3*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ming Gu and Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA
            Osni Marques, LBNL/NERSC, USA

   <b>subroutine</b> <b>dlalsa</b> <b>(integer</b> <b>icompq,</b> <b>integer</b> <b>smlsiz,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>nrhs,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b>
       <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldbx,</b> <b>*</b> <b>)</b> <b>bx,</b> <b>integer</b> <b>ldbx,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldu,</b> <b>*</b> <b>)</b> <b>u,</b> <b>integer</b> <b>ldu,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>vt,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>k,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>difl,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>difr,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>z,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>poles,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>givptr,</b>
       <b>integer,</b> <b>dimension(</b> <b>ldgcol,</b> <b>*</b> <b>)</b> <b>givcol,</b> <b>integer</b> <b>ldgcol,</b> <b>integer,</b> <b>dimension(</b> <b>ldgcol,</b> <b>*</b> <b>)</b> <b>perm,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>givnum,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>c,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>s,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>info)</b>
       <b>DLALSA</b> computes the SVD of the coefficient matrix in compact form. Used by sgelsd.

       <b>Purpose:</b>

            DLALSA is an intermediate step in solving the least squares problem
            by computing the SVD of the coefficient matrix in compact form (The
            singular vectors are computed as products of simple orthogonal
            matrices.).

            If ICOMPQ = 0, DLALSA applies the inverse of the left singular vector
            matrix of an upper bidiagonal matrix to the right hand side; and if
            ICOMPQ = 1, DLALSA applies the right singular vector matrix to the
            right hand side. The singular vector matrices were generated in
            compact form by DLALSA.

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                    Specifies whether the left or the right singular vector
                    matrix is involved.
                    = 0: Left singular vector matrix
                    = 1: Right singular vector matrix

           <u>SMLSIZ</u>

                     SMLSIZ is INTEGER
                    The maximum size of the subproblems at the bottom of the
                    computation tree.

           <u>N</u>

                     N is INTEGER
                    The row and column dimensions of the upper bidiagonal matrix.

           <u>NRHS</u>

                     NRHS is INTEGER
                    The number of columns of B and BX. NRHS must be at least 1.

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension ( LDB, NRHS )
                    On input, B contains the right hand sides of the least
                    squares problem in rows 1 through M.
                    On output, B contains the solution X in rows 1 through N.

           <u>LDB</u>

                     LDB is INTEGER
                    The leading dimension of B in the calling subprogram.
                    LDB must be at least max(1,MAX( M, N ) ).

           <u>BX</u>

                     BX is DOUBLE PRECISION array, dimension ( LDBX, NRHS )
                    On exit, the result of applying the left or right singular
                    vector matrix to B.

           <u>LDBX</u>

                     LDBX is INTEGER
                    The leading dimension of BX.

           <u>U</u>

                     U is DOUBLE PRECISION array, dimension ( LDU, SMLSIZ ).
                    On entry, U contains the left singular vector matrices of all
                    subproblems at the bottom level.

           <u>LDU</u>

                     LDU is INTEGER, LDU = &gt; N.
                    The leading dimension of arrays U, VT, DIFL, DIFR,
                    POLES, GIVNUM, and Z.

           <u>VT</u>

                     VT is DOUBLE PRECISION array, dimension ( LDU, SMLSIZ+1 ).
                    On entry, VT**T contains the right singular vector matrices of
                    all subproblems at the bottom level.

           <u>K</u>

                     K is INTEGER array, dimension ( N ).

           <u>DIFL</u>

                     DIFL is DOUBLE PRECISION array, dimension ( LDU, NLVL ).
                    where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.

           <u>DIFR</u>

                     DIFR is DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
                    On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
                    distances between singular values on the I-th level and
                    singular values on the (I -1)-th level, and DIFR(*, 2 * I)
                    record the normalizing factors of the right singular vectors
                    matrices of subproblems on I-th level.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension ( LDU, NLVL ).
                    On entry, Z(1, I) contains the components of the deflation-
                    adjusted updating row vector for subproblems on the I-th
                    level.

           <u>POLES</u>

                     POLES is DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
                    On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
                    singular values involved in the secular equations on the I-th
                    level.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER array, dimension ( N ).
                    On entry, GIVPTR( I ) records the number of Givens
                    rotations performed on the I-th problem on the computation
                    tree.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
                    On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
                    locations of Givens rotations performed on the I-th level on
                    the computation tree.

           <u>LDGCOL</u>

                     LDGCOL is INTEGER, LDGCOL = &gt; N.
                    The leading dimension of arrays GIVCOL and PERM.

           <u>PERM</u>

                     PERM is INTEGER array, dimension ( LDGCOL, NLVL ).
                    On entry, PERM(*, I) records permutations done on the I-th
                    level of the computation tree.

           <u>GIVNUM</u>

                     GIVNUM is DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
                    On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
                    values of Givens rotations performed on the I-th level on the
                    computation tree.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension ( N ).
                    On entry, if the I-th subproblem is not square,
                    C( I ) contains the C-value of a Givens rotation related to
                    the right null space of the I-th subproblem.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension ( N ).
                    On entry, if the I-th subproblem is not square,
                    S( I ) contains the S-value of a Givens rotation related to
                    the right null space of the I-th subproblem.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (3*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ming Gu and Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA
            Osni Marques, LBNL/NERSC, USA

   <b>subroutine</b> <b>slalsa</b> <b>(integer</b> <b>icompq,</b> <b>integer</b> <b>smlsiz,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>nrhs,</b> <b>real,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b>
       <b>integer</b> <b>ldb,</b> <b>real,</b> <b>dimension(</b> <b>ldbx,</b> <b>*</b> <b>)</b> <b>bx,</b> <b>integer</b> <b>ldbx,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>u,</b> <b>integer</b> <b>ldu,</b> <b>real,</b>
       <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>vt,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>k,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>difl,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b>
       <b>*</b> <b>)</b> <b>difr,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>z,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>poles,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>givptr,</b>
       <b>integer,</b> <b>dimension(</b> <b>ldgcol,</b> <b>*</b> <b>)</b> <b>givcol,</b> <b>integer</b> <b>ldgcol,</b> <b>integer,</b> <b>dimension(</b> <b>ldgcol,</b> <b>*</b> <b>)</b> <b>perm,</b> <b>real,</b>
       <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>givnum,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>c,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>s,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>info)</b>
       <b>SLALSA</b> computes the SVD of the coefficient matrix in compact form. Used by sgelsd.

       <b>Purpose:</b>

            SLALSA is an intermediate step in solving the least squares problem
            by computing the SVD of the coefficient matrix in compact form (The
            singular vectors are computed as products of simple orthogonal
            matrices.).

            If ICOMPQ = 0, SLALSA applies the inverse of the left singular vector
            matrix of an upper bidiagonal matrix to the right hand side; and if
            ICOMPQ = 1, SLALSA applies the right singular vector matrix to the
            right hand side. The singular vector matrices were generated in
            compact form by SLALSA.

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                    Specifies whether the left or the right singular vector
                    matrix is involved.
                    = 0: Left singular vector matrix
                    = 1: Right singular vector matrix

           <u>SMLSIZ</u>

                     SMLSIZ is INTEGER
                    The maximum size of the subproblems at the bottom of the
                    computation tree.

           <u>N</u>

                     N is INTEGER
                    The row and column dimensions of the upper bidiagonal matrix.

           <u>NRHS</u>

                     NRHS is INTEGER
                    The number of columns of B and BX. NRHS must be at least 1.

           <u>B</u>

                     B is REAL array, dimension ( LDB, NRHS )
                    On input, B contains the right hand sides of the least
                    squares problem in rows 1 through M.
                    On output, B contains the solution X in rows 1 through N.

           <u>LDB</u>

                     LDB is INTEGER
                    The leading dimension of B in the calling subprogram.
                    LDB must be at least max(1,MAX( M, N ) ).

           <u>BX</u>

                     BX is REAL array, dimension ( LDBX, NRHS )
                    On exit, the result of applying the left or right singular
                    vector matrix to B.

           <u>LDBX</u>

                     LDBX is INTEGER
                    The leading dimension of BX.

           <u>U</u>

                     U is REAL array, dimension ( LDU, SMLSIZ ).
                    On entry, U contains the left singular vector matrices of all
                    subproblems at the bottom level.

           <u>LDU</u>

                     LDU is INTEGER, LDU = &gt; N.
                    The leading dimension of arrays U, VT, DIFL, DIFR,
                    POLES, GIVNUM, and Z.

           <u>VT</u>

                     VT is REAL array, dimension ( LDU, SMLSIZ+1 ).
                    On entry, VT**T contains the right singular vector matrices of
                    all subproblems at the bottom level.

           <u>K</u>

                     K is INTEGER array, dimension ( N ).

           <u>DIFL</u>

                     DIFL is REAL array, dimension ( LDU, NLVL ).
                    where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.

           <u>DIFR</u>

                     DIFR is REAL array, dimension ( LDU, 2 * NLVL ).
                    On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
                    distances between singular values on the I-th level and
                    singular values on the (I -1)-th level, and DIFR(*, 2 * I)
                    record the normalizing factors of the right singular vectors
                    matrices of subproblems on I-th level.

           <u>Z</u>

                     Z is REAL array, dimension ( LDU, NLVL ).
                    On entry, Z(1, I) contains the components of the deflation-
                    adjusted updating row vector for subproblems on the I-th
                    level.

           <u>POLES</u>

                     POLES is REAL array, dimension ( LDU, 2 * NLVL ).
                    On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
                    singular values involved in the secular equations on the I-th
                    level.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER array, dimension ( N ).
                    On entry, GIVPTR( I ) records the number of Givens
                    rotations performed on the I-th problem on the computation
                    tree.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
                    On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
                    locations of Givens rotations performed on the I-th level on
                    the computation tree.

           <u>LDGCOL</u>

                     LDGCOL is INTEGER, LDGCOL = &gt; N.
                    The leading dimension of arrays GIVCOL and PERM.

           <u>PERM</u>

                     PERM is INTEGER array, dimension ( LDGCOL, NLVL ).
                    On entry, PERM(*, I) records permutations done on the I-th
                    level of the computation tree.

           <u>GIVNUM</u>

                     GIVNUM is REAL array, dimension ( LDU, 2 * NLVL ).
                    On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
                    values of Givens rotations performed on the I-th level on the
                    computation tree.

           <u>C</u>

                     C is REAL array, dimension ( N ).
                    On entry, if the I-th subproblem is not square,
                    C( I ) contains the C-value of a Givens rotation related to
                    the right null space of the I-th subproblem.

           <u>S</u>

                     S is REAL array, dimension ( N ).
                    On entry, if the I-th subproblem is not square,
                    S( I ) contains the S-value of a Givens rotation related to
                    the right null space of the I-th subproblem.

           <u>WORK</u>

                     WORK is REAL array, dimension (N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (3*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ming Gu and Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA
            Osni Marques, LBNL/NERSC, USA

   <b>subroutine</b> <b>zlalsa</b> <b>(integer</b> <b>icompq,</b> <b>integer</b> <b>smlsiz,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>nrhs,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b>
       <b>b,</b> <b>integer</b> <b>ldb,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldbx,</b> <b>*</b> <b>)</b> <b>bx,</b> <b>integer</b> <b>ldbx,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b>
       <b>u,</b> <b>integer</b> <b>ldu,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>vt,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>k,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>difl,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>difr,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b>
       <b>)</b> <b>z,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>poles,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>givptr,</b> <b>integer,</b> <b>dimension(</b>
       <b>ldgcol,</b> <b>*</b> <b>)</b> <b>givcol,</b> <b>integer</b> <b>ldgcol,</b> <b>integer,</b> <b>dimension(</b> <b>ldgcol,</b> <b>*</b> <b>)</b> <b>perm,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>ldu,</b> <b>*</b> <b>)</b> <b>givnum,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>c,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>s,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>rwork,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>info)</b>
       <b>ZLALSA</b> computes the SVD of the coefficient matrix in compact form. Used by sgelsd.

       <b>Purpose:</b>

            ZLALSA is an intermediate step in solving the least squares problem
            by computing the SVD of the coefficient matrix in compact form (The
            singular vectors are computed as products of simple orthogonal
            matrices.).

            If ICOMPQ = 0, ZLALSA applies the inverse of the left singular vector
            matrix of an upper bidiagonal matrix to the right hand side; and if
            ICOMPQ = 1, ZLALSA applies the right singular vector matrix to the
            right hand side. The singular vector matrices were generated in
            compact form by ZLALSA.

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                    Specifies whether the left or the right singular vector
                    matrix is involved.
                    = 0: Left singular vector matrix
                    = 1: Right singular vector matrix

           <u>SMLSIZ</u>

                     SMLSIZ is INTEGER
                    The maximum size of the subproblems at the bottom of the
                    computation tree.

           <u>N</u>

                     N is INTEGER
                    The row and column dimensions of the upper bidiagonal matrix.

           <u>NRHS</u>

                     NRHS is INTEGER
                    The number of columns of B and BX. NRHS must be at least 1.

           <u>B</u>

                     B is COMPLEX*16 array, dimension ( LDB, NRHS )
                    On input, B contains the right hand sides of the least
                    squares problem in rows 1 through M.
                    On output, B contains the solution X in rows 1 through N.

           <u>LDB</u>

                     LDB is INTEGER
                    The leading dimension of B in the calling subprogram.
                    LDB must be at least max(1,MAX( M, N ) ).

           <u>BX</u>

                     BX is COMPLEX*16 array, dimension ( LDBX, NRHS )
                    On exit, the result of applying the left or right singular
                    vector matrix to B.

           <u>LDBX</u>

                     LDBX is INTEGER
                    The leading dimension of BX.

           <u>U</u>

                     U is DOUBLE PRECISION array, dimension ( LDU, SMLSIZ ).
                    On entry, U contains the left singular vector matrices of all
                    subproblems at the bottom level.

           <u>LDU</u>

                     LDU is INTEGER, LDU = &gt; N.
                    The leading dimension of arrays U, VT, DIFL, DIFR,
                    POLES, GIVNUM, and Z.

           <u>VT</u>

                     VT is DOUBLE PRECISION array, dimension ( LDU, SMLSIZ+1 ).
                    On entry, VT**H contains the right singular vector matrices of
                    all subproblems at the bottom level.

           <u>K</u>

                     K is INTEGER array, dimension ( N ).

           <u>DIFL</u>

                     DIFL is DOUBLE PRECISION array, dimension ( LDU, NLVL ).
                    where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.

           <u>DIFR</u>

                     DIFR is DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
                    On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
                    distances between singular values on the I-th level and
                    singular values on the (I -1)-th level, and DIFR(*, 2 * I)
                    record the normalizing factors of the right singular vectors
                    matrices of subproblems on I-th level.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension ( LDU, NLVL ).
                    On entry, Z(1, I) contains the components of the deflation-
                    adjusted updating row vector for subproblems on the I-th
                    level.

           <u>POLES</u>

                     POLES is DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
                    On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
                    singular values involved in the secular equations on the I-th
                    level.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER array, dimension ( N ).
                    On entry, GIVPTR( I ) records the number of Givens
                    rotations performed on the I-th problem on the computation
                    tree.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
                    On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
                    locations of Givens rotations performed on the I-th level on
                    the computation tree.

           <u>LDGCOL</u>

                     LDGCOL is INTEGER, LDGCOL = &gt; N.
                    The leading dimension of arrays GIVCOL and PERM.

           <u>PERM</u>

                     PERM is INTEGER array, dimension ( LDGCOL, NLVL ).
                    On entry, PERM(*, I) records permutations done on the I-th
                    level of the computation tree.

           <u>GIVNUM</u>

                     GIVNUM is DOUBLE PRECISION array, dimension ( LDU, 2 * NLVL ).
                    On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
                    values of Givens rotations performed on the I-th level on the
                    computation tree.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension ( N ).
                    On entry, if the I-th subproblem is not square,
                    C( I ) contains the C-value of a Givens rotation related to
                    the right null space of the I-th subproblem.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension ( N ).
                    On entry, if the I-th subproblem is not square,
                    S( I ) contains the S-value of a Givens rotation related to
                    the right null space of the I-th subproblem.

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension at least
                    MAX( (SMLSZ+1)*NRHS*3, N*(1+NRHS) + 2*NRHS ).

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (3*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ming Gu and Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA
            Osni Marques, LBNL/NERSC, USA

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                               Thu Aug 7 2025 17:26:25                                    <u><a href="../man3/lalsa.3.html">lalsa</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>