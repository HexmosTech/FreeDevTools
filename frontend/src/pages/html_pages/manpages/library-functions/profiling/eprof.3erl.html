<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>eprof - A Time Profiling Tool for Erlang</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       eprof - A Time Profiling Tool for Erlang

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  module  <u>eprof</u>  provides a set of functions for time profiling of Erlang programs to find out how the
       execution time is used. The profiling is done using the Erlang trace  BIFs.  Tracing  of  local  function
       calls for a specified set of processes is enabled when profiling is begun, and disabled when profiling is
       stopped.

       When using Eprof, expect a slowdown in program execution.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>start()</b> <b>-&gt;</b> <b>{ok,</b> <b>Pid}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Pid = pid()
                 Reason = {already_started, Pid}

              Starts the Eprof server which holds the internal state of the collected data.

       <b>start_profiling(Rootset)</b> <b>-&gt;</b> <b>profiling</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>start_profiling(Rootset,</b> <b>Pattern)</b> <b>-&gt;</b> <b>profiling</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>start_profiling(Rootset,</b> <b>Pattern,</b> <b>Options)</b> <b>-&gt;</b>
                          profiling | {error, Reason}

              Types:

                 Rootset = [atom() | pid()]
                 Pattern = trace_pattern_mfa()
                 Options = [set_on_spawn | {set_on_spawn, boolean()}]
                 Reason = term()
                 <b>trace_pattern_mfa()</b> = {atom(), atom(), arity() | '_'}

              Starts  profiling  for  the  processes  in  <u>Rootset</u>  (and  any  new  processes spawned from them).
              Information about activity in any profiled process is stored in the Eprof database.

              <u>Rootset</u> is a list of pids and registered names.

              The function returns <u>profiling</u> if tracing could be enabled for all processes in <u>Rootset</u>, or  <u>error</u>
              otherwise.

              A pattern can be selected to narrow the profiling. For instance a specific module can be selected,
              and only the code executed in that module will be profiled.

              The  <u>set_on_spawn</u>  option  will active call time tracing for all processes spawned by processes in
              the rootset. This is the default behaviour.

       <b>stop_profiling()</b> <b>-&gt;</b> <b>profiling_stopped</b> <b>|</b> <b>profiling_already_stopped</b>

              Stops profiling started with <u>start_profiling/1</u> or <u>prifile/1</u>.

       <b>profile(Fun)</b> <b>-&gt;</b> <b>{ok,</b> <b>Value}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>profile(Fun,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>Value}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>profile(Rootset)</b> <b>-&gt;</b> <b>profiling</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>profile(Rootset,</b> <b>Fun)</b> <b>-&gt;</b> <b>{ok,</b> <b>Value}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>profile(Rootset,</b> <b>Fun,</b> <b>Pattern)</b> <b>-&gt;</b> <b>{ok,</b> <b>Value}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>profile(Rootset,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b>
                  {ok, Value} | {error, Reason}

       <b>profile(Rootset,</b> <b>Fun,</b> <b>Pattern,</b> <b>Options)</b> <b>-&gt;</b>
                  {ok, Value} | {error, Reason}

       <b>profile(Rootset,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>Pattern)</b> <b>-&gt;</b>
                  {ok, Value} | {error, Reason}

       <b>profile(Rootset,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>Pattern,</b> <b>Options)</b> <b>-&gt;</b>
                  {ok, Value} | {error, Reason}

              Types:

                 Rootset = [atom() | pid()]
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Pattern = trace_pattern_mfa()
                 Options = [set_on_spawn | {set_on_spawn, boolean()}]
                 Value = Reason = term()
                 <b>trace_pattern_mfa()</b> = {atom(), atom(), arity() | '_'}

              This function first spawns a process <u>P</u> which evaluates <u>Fun()</u> or <u>apply(Module,Function,Args)</u>. Then,
              it starts profiling for <u>P</u> and the processes in <u>Rootset</u> (and any new processes spawned from  them).
              Information about activity in any profiled process is stored in the Eprof database.

              <u>Rootset</u> is a list of pids and registered names.

              If  tracing  could  be enabled for <u>P</u> and all processes in <u>Rootset</u>, the function returns <u>{ok,Value}</u>
              when <u>Fun()</u>/<u>apply</u> returns with the value <u>Value</u>, or <u>{error,Reason}</u> if <u>Fun()</u>/<u>apply</u>  fails  with  exit
              reason <u>Reason</u>. Otherwise it returns <u>{error,</u> <u>Reason}</u> immediately.

              The  <u>set_on_spawn</u>  option  will active call time tracing for all processes spawned by processes in
              the rootset. This is the default behaviour.

              The programmer must ensure that the function given as argument is truly synchronous  and  that  no
              work continues after the function has returned a value.

       <b>analyze()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>nothing_to_analyze</b>

       <b>analyze(Type)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>nothing_to_analyze</b>

       <b>analyze(Type,</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>nothing_to_analyze</b>

              Types:

                 Type = analyze_type()
                 Options = [Option]
                 Option = {filter, Filter} | {sort, Sort}
                 Filter = [{calls, integer() &gt;= 0} | {time, float()}]
                 Sort = time | calls | mfa
                 <b>analyze_type()</b> = procs | total

              Call this function when profiling has been stopped to display the results per process, that is:

                * how much time has been used by each process, and

                * in which function calls this time has been spent.

              Call <u>analyze</u> with <u>total</u> option when profiling has been stopped to display the results per function
              call, that is in which function calls the time has been spent.

              Time is shown as percentage of total time and as absolute time.

       <b>log(File)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 File = atom() | file:filename()

              This  function  ensures  that  the results displayed by <u>analyze/0,1,2</u> are printed both to the file
              <u>File</u> and the screen.

       <b>stop()</b> <b>-&gt;</b> <b>stopped</b>

              Stops the Eprof server.

Ericsson AB                                        tools 3.5.2                                       <u><a href="../man3erl/eprof.3erl.html">eprof</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>