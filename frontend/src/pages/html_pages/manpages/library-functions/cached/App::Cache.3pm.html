<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App::Cache - Easy application-level caching</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libapp-cache-perl">libapp-cache-perl_0.37-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       App::Cache - Easy application-level caching

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # in your class:
         my $cache = App::Cache-&gt;new({ ttl =&gt; 60*60 });
         $cache-&gt;delete('test');
         my $data = $cache-&gt;get('test');
         my $code = $cache-&gt;get_code("code", sub { $self-&gt;calculate() });
         my $html = $cache-&gt;get_url("<a href="http://www.google.com/">http://www.google.com/</a>");
         $cache-&gt;set('test', 'one');
         $cache-&gt;set('test', { foo =&gt; 'bar' });
         my $scratch = $cache-&gt;scratch;
         $cache-&gt;clear;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The App::Cache module lets an application cache data locally. There are a few times an application would
       need to cache data: when it is retrieving information from the network or when it has to complete a large
       calculation.

       For example, the Parse::BACKPAN::Packages module downloads a file off the net and parses it, creating a
       data structure. Only then can it actually provide any useful information for the programmer.
       Parse::BACKPAN::Packages uses App::Cache to cache both the file download and data structures, providing
       much faster use when the data is cached.

       This module stores data in the home directory of the user, in a dot directory. For example, the
       Parse::BACKPAN::Packages cache is actually stored underneath "<a href="file:~/.parse_backpan_packages/cache/">~/.parse_backpan_packages/cache/</a>". This is
       so that permisssions are not a problem - it is a per-user, per-application cache.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       The constructor creates an App::Cache object. It takes three optional parameters:

       •   ttl contains the number of seconds in which a cache entry expires. The default is 30 minutes.

             my $cache = App::Cache-&gt;new({ ttl =&gt; 30*60 });

       •   application  sets  the  application  name.  If you are calling <b>new()</b> from a class, the application is
           automagically set to the calling class, so you should rarely need to pass it in:

             my $cache = App::Cache-&gt;new({ application =&gt; 'Your::Module' });

       •   directory sets the directory to be used for the cache. Normally this is just set for you and will  be
           based  on  the application name and be created in the users home directory. Sometimes for testing, it
           can be useful to set this.

             my $cache = App::Cache-&gt;new({ directory =&gt; '/tmp/your/cache/dir' });

       •   enabled can be set to 0 for testing, in which case you will always get cache misses:

             my $cache = App::Cache-&gt;new({ enabled =&gt; 0 });

   <b>clear</b>
       Clears the cache:

         $cache-&gt;clear;

   <b>delete</b>
       Deletes an entry in the cache:

         $cache-&gt;delete('test');

   <b>get</b>
       Gets an entry from the cache. Returns undef if the entry does not exist or if it has expired:

         my $data = $cache-&gt;get('test');

   <b>get_code</b>
       This is a convenience method. Gets an entry from the cache, but if the entry  does  not  exist,  set  the
       entry to the value of the code reference passed:

         my $code = $cache-&gt;get_code("code", sub { $self-&gt;calculate() });

   <b>get_url</b>
       This  is a convenience method. Gets the content of a URL from the cache, but if the entry does not exist,
       set the entry to the content of the URL passed:

         my $html = $cache-&gt;get_url("<a href="http://www.google.com/">http://www.google.com/</a>");

   <b>scratch</b>
       Returns a directory in the cache that the application may use for scratch files:

         my $scratch = $cache-&gt;scratch;

   <b>set</b>
       Set an entry in the cache. Note that an entry value may be an arbitrary Perl data structure:

         $cache-&gt;set('test', 'one');
         $cache-&gt;set('test', { foo =&gt; 'bar' });

   <b>directory</b>
       Returns the full path to the cache directory. Primarily useful for when you are writing  tests  that  use
       App::Cache  and want to clean up after yourself. If you are doing that you may want to explicitly set the
       'application' constructor parameter to avoid later cleaning up a cache dir that was already in use.

         my $dir = $cache-&gt;directory;

</pre><h4><b>AUTHOR</b></h4><pre>
       Leon Brocard &lt;<a href="mailto:acme@astray.com">acme@astray.com</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2005-7, Leon Brocard

</pre><h4><b>LICENSE</b></h4><pre>
       This module is free software; you can redistribute it or modify it under the same terms as Perl itself.

perl v5.34.0                                       2022-06-26                                    <u>App::<a href="../man3pm/Cache.3pm.html">Cache</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>