<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cache - the Cache interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcache-perl">libcache-perl_2.11-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Cache - the Cache interface

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Cache modules are designed to assist a developer in persisting data for a specified period of time.
       Often these modules are used in web applications to store data locally to save repeated and redundant
       expensive calls to remote machines or databases.

       The Cache interface is implemented by derived classes that store cached data in different manners (such
       as files on a filesystem, or in memory).

</pre><h4><b>USAGE</b></h4><pre>
       To use the Cache system, a cache implementation must be chosen to suit your needs.  The most common is
       Cache::File, which is suitable for sharing data between multiple invocations and even between concurrent
       processes.

       Using a cache is simple.  Here is some very simple sample code for instantiating and using a file system
       based cache.

         use Cache::File;

         my $cache = Cache::File-&gt;new( cache_root =&gt; '/tmp/cacheroot' );
         my $customer = $cache-&gt;get( $name );

         unless ($customer) {
             $customer = get_customer_from_db( $name );
             $cache-&gt;set( $name, $customer, '10 minutes' );
         }

         return $customer;

       Of course, far more powerful methods are available for accessing cached data.  Also see the TIE INTERFACE
       below.

</pre><h4><b>METHODS</b></h4><pre>
       my $cache_entry = $c-&gt;entry( $key )
           Return  a  'Cache::Entry'  object  for the given key.  This object can then be used to manipulate the
           cache entry in various ways.  The key can be any scalar string that will uniquely identify  an  entry
           in the cache.

       $c-&gt;<b>purge()</b>
           Remove all expired data from the cache.

       $c-&gt;<b>clear()</b>
           Remove all entries from the cache - regardless of their expiry time.

       my $num = $c-&gt;<b>count()</b>
           Returns the number of entries in the cache.

       my $size = $c-&gt;<b>size()</b>
           Returns the size (in bytes) of the cache.

</pre><h4><b>PROPERTIES</b></h4><pre>
       When a cache is constructed these properties can be supplied as options to the <b>new()</b> method.

       default_expires
           The  current  default expiry time for new entries into the cache.  This property can also be reset at
           any time.

            my $time = $c-&gt;default_expires();
            $c-&gt;set_default_expires( $expiry );

       removal_strategy
           The removal strategy object for the cache.  This is used to remove object from the cache in order  to
           maintain the cache size limit.

           When  setting  the  removal  strategy  in <b>new()</b>, the name of a strategy package or a blessed strategy
           object reference should be provided  (in the former case an object  is  constructed  by  calling  the
           <b>new()</b> method of the named package).

           The  strategies  'Cache::RemovalStrategy::LRU'  and  'Cache::RemovalStrategy::FIFO'  are available by
           default.

            my $strategy = $c-&gt;removal_strategy();

       size_limit
           The size limit for the cache.

            my $limit = $c-&gt;size_limit();

       load_callback
           The load callback for the cache.  This may be set to a function that will get called anytime a  'get'
           is issued for data that does not exist in the cache.

            my $limit = $c-&gt;load_callback();
            $c-&gt;set_load_callback($callback_func);

       validate_callback
           The  validate  callback  for the cache.  This may be set to a function that will get called anytime a
           'get' is issued for data that does not exist in the cache.

            my $limit = $c-&gt;validate_callback();
            $c-&gt;set_validate_callback($callback_func);

</pre><h4><b>SHORTCUT</b> <b>METHODS</b></h4><pre>
       These methods all have counterparts in the Cache::Entry package, but  are  provided  here  as  shortcuts.
       They  all  default  to just wrappers that do '$c-&gt;entry($key)-&gt;<b>method_name()</b>'.  For documentation, please
       refer to Cache::Entry.

       my $bool = $c-&gt;exists( $key )
       $c-&gt;set( $key, $data, [ $expiry ] )
       my $data = $c-&gt;get( $key )
       my $data = $c-&gt;size( $key )
       $c-&gt;remove( $key )
       $c-&gt;expiry( $key )
       $c-&gt;set_expiry( $key, $time )
       $c-&gt;handle( $key, [$mode, [$expiry] ] )
       $c-&gt;validity( $key )
       $c-&gt;set_validity( $key, $data )
       $c-&gt;freeze( $key, $data, [ $expiry ] )
       $c-&gt;thaw( $key )

</pre><h4><b>TIE</b> <b>INTERFACE</b></h4><pre>
         tie %hash, 'Cache::File', { cache_root =&gt; $tempdir };

         $hash{'key'} = 'some data';
         $data = $hash{'key'};

       The Cache classes can be used via the tie interface, as shown in the synopsis.  This allows the cache  to
       be  accessed  via  a  hash.   All  the  standard  methods for accessing the hash are supported , with the
       exception of the 'keys' or 'each' call.

       The tie interface is especially useful with the load_callback to automatically populate the hash.

</pre><h4><b>REMOVAL</b> <b>STRATEGY</b> <b>METHODS</b></h4><pre>
       These methods are only for use internally (by concrete Cache implementations).

       These methods define the interface by which the removal strategy object can  manipulate  the  cache  (the
       Cache is the 'context' of the strategy).  By default, methods need to be provided to remove the oldest or
       stalest  objects  in  the  cache - thus allowing support for the default FIFO and LRU removal strategies.
       All derived Cache implementations should support these methods and may also introduce additional  methods
       (and additional removal strategies to match).

       my $size = $c-&gt;<b>remove_oldest()</b>
           Removes the oldest entry in the cache and returns its size.

       my $size = $c-&gt;<b>remove_stalest()</b>
           Removes the 'stalest' (least used) object in the cache and returns its size.

       $c-&gt;check_size( $size )
           This  method  isn't  actually part of the strategy interface, nor does it need to be defined by Cache
           implementations.  Instead it should be called by implementations  whenever  the  size  of  the  cache
           increases.   It  will  take  care  of  checking  the  size limit and invoking the removal strategy if
           required.  The size argument should be the new size of the cache.

</pre><h4><b>UTILITY</b> <b>METHODS</b></h4><pre>
       These methods are only for use internally (by concrete Cache implementations).

       my $time = Cache::Canonicalize_Expiration_Time($timespec)
           Converts a timespec as described for <b>Cache::Entry::set_expiry()</b> into a unix time.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Cache::Entry, Cache::File, Cache::RemovalStrategy

</pre><h4><b>DIFFERENCES</b> <b>FROM</b> <b>CACHE::CACHE</b></h4><pre>
       The Cache modules are a total redesign  and  reimplementation  of  Cache::Cache  and  thus  not  directly
       compatible.   It  would  be, however, quite possible to write a wrapper module that provides an identical
       interface to Cache::Cache.

       The semantics of use are very similar to Cache::Cache, with the following exceptions:

       The get/set methods DO NOT serialize complex data types.  Use freeze/thaw instead (but read the notes in
       Cache::Entry).
       The get_object / set_object methods are not available, but have been superseded by the more flexible
       entry method and Cache::Entry class.
       There is no concept of 'namespace' in the basic cache interface, although implementations (eg.
       Cache::Memory) may choose to provide them.  For instance, File::Cache does not provide this - but
       different namespaces can be created by varying cache_root.
       In the current Cache implementations purging is done automatically - there is no need to explicitly
       enable auto purge on get/set.  The purging algorithm is no longer implemented in the base Cache class,
       but is left up to the implementations and may thus be implemented in the most efficient way for the
       storage medium.
       Cache::SharedMemory is not yet available.
       Cache::File no longer supports separate masks for entries and directories.  It is not a very secure
       configuration and presents numerous issues for cache consistency and is hence deprecated.  There is still
       some work to be done to ensure cache consistency between accesses by different users.

</pre><h4><b>AUTHOR</b></h4><pre>
        Chris Leishman &lt;<a href="mailto:chris@leishman.org">chris@leishman.org</a>&gt;
        Based on work by DeWitt Clinton &lt;<a href="mailto:dewitt@unto.net">dewitt@unto.net</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
        Copyright (C) 2003-2006 Chris Leishman.  All Rights Reserved.

       This module is distributed on an "AS IS" basis,  WITHOUT  WARRANTY  OF  ANY  KIND,  either  expressed  or
       implied.  This  program  is free software; you can redistribute or modify it under the same terms as Perl
       itself.

       $Id: Cache.pm,v 1.7 2006/01/31 15:23:58 caleishm Exp $

perl v5.34.0                                       2022-06-09                                         <u><a href="../man3pm/Cache.3pm.html">Cache</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>