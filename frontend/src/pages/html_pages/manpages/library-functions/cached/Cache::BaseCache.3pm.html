<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cache::BaseCache -- abstract cache base class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcache-cache-perl">libcache-cache-perl_1.08-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Cache::BaseCache -- abstract cache base class

</pre><h4><b>DESCRIPTION</b></h4><pre>
       BaseCache provides functionality common to all instances of a cache.  It differs from the CacheUtils
       package insofar as it is designed to be used as superclass for cache implementations.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Cache::BaseCache is to be used as a superclass for cache implementations.  The most effective way to use
       BaseCache is to use the protected _set_backend method, which will be used to retrieve the persistence
       mechanism.  The subclass can then inherit the BaseCache's implementation of get, set, etc.  However, due
       to the difficulty inheriting static methods in Perl, the subclass will likely need to explicitly
       implement Clear, Purge, and Size.  Also, a factory pattern should be used to invoke the
       _complete_initialization routine after the object is constructed.

         package Cache::MyCache;

         use vars qw( @ISA );
         use Cache::BaseCache;
         use Cache::MyBackend;

         @ISA = qw( Cache::BaseCache );

         sub new
         {
           my ( $self ) = _new( @_ );

           $self-&gt;_complete_initialization( );

           return $self;
         }

         sub _new
         {
           my ( $proto, $p_options_hash_ref ) = @_;
           my $class = ref( $proto ) || $proto;
           my $self = $class-&gt;SUPER::_new( $p_options_hash_ref );
           $self-&gt;_set_backend( new Cache::MyBackend( ) );
           return $self;
         }

         sub Clear
         {
           foreach my $namespace ( _Namespaces( ) )
           {
             _Get_Backend( )-&gt;delete_namespace( $namespace );
           }
         }

         sub Purge
         {
           foreach my $namespace ( _Namespaces( ) )
           {
             _Get_Cache( $namespace )-&gt;purge( );
           }
         }

         sub Size
         {
           my $size = 0;

           foreach my $namespace ( _Namespaces( ) )
           {
             $size += _Get_Cache( $namespace )-&gt;size( );
           }

           return $size;
         }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Cache::Cache, Cache::FileCache, Cache::MemoryCache

</pre><h4><b>AUTHOR</b></h4><pre>
       Original author: DeWitt Clinton &lt;<a href="mailto:dewitt@unto.net">dewitt@unto.net</a>&gt;

       Last author:     $Author: dclinton $

       Copyright (C) 2001-2003 DeWitt Clinton

perl v5.34.0                                       2022-06-30                              <u>Cache::<a href="../man3pm/BaseCache.3pm.html">BaseCache</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>