<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Smart::FAQ - Frequently Asked Questions about XML::Smart.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-smart-perl">libxml-smart-perl_1.78-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Smart::FAQ - Frequently Asked Questions about XML::Smart.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This is the Frequently Asked Questions list for XML::Smart.

</pre><h4><b>QUESTIONS</b></h4><pre>
       <b>For</b> <b>new</b> <b>questions</b> <b>send</b> <b>an</b> <b>e-mail</b> <b>to</b> <b>the</b> <b>author,</b> <b>but</b> <b>please,</b> <b>read</b> <b>first</b> <b>all</b> <b>the</b> <b>F.A.Q.</b>

   <b>Do</b> <b>I</b> <b>need</b> <b>to</b> <b>install</b> <b>XML::Parser</b> <b>to</b> <b>can</b> <b>use</b> <b>XML::Smart?</b>
       No! XML::Smart already comes with 2 independent parsers, XML::Smart::Parser and XML::Smart::HTMLParser.

       If XML::Parser is found XML::Smart will use it by default, and the 2nd options will be
       XML::Smart::Parser.

       Note that for complex parsing XML::Parser is recommended, but XML::Smart::Parser will work fine too.

   <b>What</b> <b>is</b> <b>the</b> <b>best</b> <b>version</b> <b>of</b> <b>XML::Smart</b> <b>to</b> <b>install?</b>
       Is always the last! Always take a look for new versions before aks for help on XML::Smart.

       Note that internally XML::Smart is complex, since the main idea of it is to remove the complexity from
       the hand of the programmer.  Actually the idea is to enable the Perl programmer to use and create XML
       data without really know the XML format.

   <b>Where</b> <b>can</b> <b>I</b> <b>learn</b> <b>about</b> <b>XML?</b>
       <a href="http://www.xml.com">http://www.xml.com</a>

   <b>How</b> <b>to</b> <b>apply</b> <b>a</b> <b>DTD</b> <b>to</b> <b>a</b> <b>XML::Smart</b> <b>object</b> <b>tree?</b>
       Take a look in the method <u><b>apply_dtd()</b></u>. Example of use:

         $xml-&gt;apply_dtd(q`
         &lt;!DOCTYPE cds [
         &lt;!ELEMENT cds (album+)&gt;
         &lt;!ATTLIST cds
                   creator  CDATA
                   date     CDATA #REQUIRED
         &gt;
         &lt;!ELEMENT album (artist , tracks+)&gt;
         &lt;!ELEMENT artist (#PCDATA)&gt;
         &lt;!ELEMENT tracks (#PCDATA)&gt;
         ]&gt;
         `);

       This will format automatically elements, attributes, etc...

   <b>How</b> <b>XML::Smart</b> <b>works?</b>
       To create <u>XML::Smart</u>, first I have created the module Object::MultiType.  With it you can have an object
       that works at the same time as a HASH, ARRAY, SCALAR, CODE &amp; GLOB. So you can do things like this with
       the same object:

         $obj = Object::MultiType-&gt;new() ;

         $obj-&gt;{key} ;
         $obj-&gt;[0] ;
         $obj-&gt;method ;

         @l = @{$obj} ;
         %h = %{$obj} ;

         &amp;$obj(args) ;

         print $obj "send data\n" ;

       Seems to be crazy, and can be more if you use <b>tie()</b> inside it, and this is what <u>XML::Smart</u> does.

       For <u>XML::Smart</u>, the access in the Hash and Array way paste through <b>tie()</b>. In other words, you have a tied
       HASH and tied ARRAY inside it. This tied Hash and Array work together, soo <b>you</b> <b>can</b> <b>access</b> <b>a</b> <b>Hash</b> <b>key</b> <b>as</b>
       <b>the</b> <b>index</b> <b>0</b> <b>of</b> <b>an</b> <b>Array,</b> <b>or</b> <b>access</b> <b>an</b> <b>index</b> <b>0</b> <b>as</b> <b>the</b> <b>Hash</b> <b>key</b>:

         %hash = (
         key =&gt; ['a','b','c']
         ) ;

         $hash-&gt;{key}    ## return $hash{key}[0]
         $hash-&gt;{key}[0] ## return $hash{key}[0]
         $hash-&gt;{key}[1] ## return $hash{key}[1]

         ## Inverse:

         %hash = ( key =&gt; 'a' ) ;

         $hash-&gt;{key}    ## return $hash{key}
         $hash-&gt;{key}[0] ## return $hash{key}
         $hash-&gt;{key}[1] ## return undef

       The best thing of this new resource is to avoid wrong access to the data and warnings when you try to
       access a Hash having an Array (and the inverse). Thing that generally make the script <b>die()</b>.

       Once having an easy access to the data, you can use the same resource to <b>create</b> data!  For example:

         ## Previous data:
         &lt;hosts&gt;
           &lt;server address="192.168.2.100" os="linux" type="conectiva" version="9.0"/&gt;
         &lt;/hosts&gt;

         ## Now you have {address} as a normal key with a string inside:
         $XML-&gt;{hosts}{server}{address}

         ## And to add a new address, the key {address} need to be an ARRAY ref!
         ## So, XML::Smart make the convertion: ;-P
         $XML-&gt;{hosts}{server}{address}[1] = '192.168.2.101' ;

         ## Adding to a list that you don't know the size:
         push(@{$XML-&gt;{hosts}{server}{address}} , '192.168.2.102') ;

         ## The data now:
         &lt;hosts&gt;
           &lt;server os="linux" type="conectiva" version="9.0"/&gt;
             &lt;address&gt;192.168.2.100&lt;/address&gt;
             &lt;address&gt;192.168.2.101&lt;/address&gt;
             &lt;address&gt;192.168.2.102&lt;/address&gt;
           &lt;/server&gt;
         &lt;/hosts&gt;

       Than after changing your XML tree using the Hash and Array resources you just get the data remade
       (through the Hash tree inside the object):

         my $xmldata = $XML-&gt;data ;

       <b>But</b> <b>note</b> <b>that</b> <u><b>XML::Smart</b></u> <b>always</b> <b>return</b> <b>an</b> <b>object</b>! Even when you get a final key. So this actually returns
       another object, pointhing (inside it) to the key:

         $addr = $XML-&gt;{hosts}{server}{address}[0] ;

         ## Since $addr is an object you can TRY to access more data:
         $addr-&gt;{foo}{bar} ; ## This doens't make warnings! just return UNDEF.

         ## But you can use it like a normal SCALAR too:

         print "$addr\n" ;

         $addr .= ':80' ; ## After this $addr isn't an object any more, just a SCALAR!

   <b>When</b> <b>I</b> <b>generate</b> <b>the</b> <b>XML</b> <b>data</b> <b>new</b> <b>lines</b> <b>(\n)</b> <b>are</b> <b>added</b> <b>to</b> <b>the</b> <b>content!</b>
       You should use the options for the method <b>data()</b> and <b>save()</b> to not add identation to the generated data:

         $XML-&gt;data( noident =&gt; 1 ) ;

         ## or better:

         $XML-&gt;data( nospace =&gt; 1 ) ;

   <b>Your</b> <b>question</b> <b>is</b> <b>not</b> <b>here?</b>
       Just send me an e-mail. ;-P

</pre><h4><b>AUTHOR</b></h4><pre>
       Graciliano M. P. &lt;<a href="mailto:gm@virtuasites.com.br">gm@virtuasites.com.br</a>&gt;

       I will appreciate any type of feedback (include your opinions and/or suggestions). ;-P

       Enjoy and thanks for who are enjoying this tool and have sent e-mails! ;-P

</pre><h4><b>ePod</b></h4><pre>
       This document was written in ePod (easy-POD), than converted to POD, and from here you know the way.

perl v5.36.0                                       2022-11-19                               <u>XML::Smart::<a href="../man3pm/FAQ.3pm.html">FAQ</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>