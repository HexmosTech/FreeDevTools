<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Smart - A smart, easy and powerful way to access or create XML from fiels, data and URLs.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-smart-perl">libxml-smart-perl_1.78-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Smart - A smart, easy and powerful way to access or create XML from fiels, data and URLs.

</pre><h4><b>VERSION</b></h4><pre>
       Version 1.78

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This module provides an easy way to access/create XML data. It's based on a HASH tree created from the
       XML data, and enables dynamic access to it through the standard Perl syntax for Hash and Array, without
       necessarily caring about which you are working with. In other words, <b>each</b> <b>point</b> <b>in</b> <b>the</b> <b>tree</b> <b>works</b> <b>as</b> <b>a</b>
       <b>Hash</b> <b>and</b> <b>an</b> <b>Array</b> <b>at</b> <b>the</b> <b>same</b> <b>time</b>!

       This module additionally provides special resources such as: search for nodes by attribute, select an
       attribute value in each multiple node,  change the returned format, and so on.

       The module also automatically handles binary data (encoding/decoding to/from base64), CDATA (like
       contents with &lt;tags&gt;) and Unicode. It can be used to create XML files, load XML from the Web ( just by
       using an URL as the file path ) and has an easy way to send XML data through sockets - just adding the
       length of the data in the &lt;?xml?&gt; header.

       You can use <u>XML::Smart</u> with XML::Parser, or with the 2 standard parsers of XML::Smart:

       <u>XML::Smart::Parser</u>
       <u>XML::Smart::HTMLParser</u>.

       <u>XML::Smart::HTMLParser</u> can be used to load/parse wild/bad XML data, or HTML tags.

</pre><h4><b>Tutorial</b> <b>and</b> <b>F.A.Q.</b></h4><pre>
       You can find some extra documents about <u>XML::Smart</u> at:

       XML::Smart::Tutorial - Tutorial and examples for XML::Smart.
       XML::Smart::FAQ      - Frequently Asked Questions about XML::Smart.

</pre><h4><b>USAGE</b></h4><pre>
         ## Create the object and load the file:
         my $XML = XML::Smart-&gt;new('file.xml') ;

         ## Force the use of the parser 'XML::Smart::Parser'.
         my $XML = XML::Smart-&gt;new('file.xml' , 'XML::Smart::Parser') ;

         ## Get from the web:
         my $XML = XML::Smart-&gt;new('<a href="http://www.perlmonks.org/index.pl">http://www.perlmonks.org/index.pl</a>?node_id=16046') ;

         ## Cut the root:
         $XML = $XML-&gt;cut_root ;

         ## Or change the root:
         $XML = $XML-&gt;{hosts} ;

         ## Get the address [0] of server [0]:
         my $srv0_addr0 = $XML-&gt;{server}[0]{address}[0] ;
         ## ...or...
         my $srv0_addr0 = $XML-&gt;{server}{address} ;

         ## Get the server where the attibute 'type' eq 'suse':
         my $server = $XML-&gt;{server}('type','eq','suse') ;

         ## Get the address again:
         my $addr1 = $server-&gt;{address}[1] ;
         ## ...or...
         my $addr1 = $XML-&gt;{server}('type','eq','suse'){address}[1] ;

         ## Get all the addresses of a server:
         my @addrs = @{$XML-&gt;{server}{address}} ;
         ## ...or...
         my @addrs = $XML-&gt;{server}{address}('@') ;

         ## Get a list of types of all the servers:
         my @types = $XML-&gt;{server}('[@]','type') ;

         ## Add a new server node:
         my $newsrv = {
         os      =&gt; 'Linux' ,
         type    =&gt; 'Mandrake' ,
         version =&gt; 8.9 ,
         address =&gt; [qw(192.168.3.201 192.168.3.202)]
         } ;

         push(@{$XML-&gt;{server}} , $newsrv) ;

         ## Get/rebuild the XML data:
         my $xmldata = $XML-&gt;data ;

         ## Save in some file:
         $XML-&gt;save('newfile.xml') ;

         ## Send through a socket:
         print $socket $XML-&gt;data(length =&gt; 1) ; ## show the 'length' in the XML header to the
                                                 ## socket know the amount of data to read.

         __DATA__
         &lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
         &lt;hosts&gt;
           &lt;server os="linux" type="redhat" version="8.0"&gt;
             &lt;address&gt;192.168.0.1&lt;/address&gt;
             &lt;address&gt;192.168.0.2&lt;/address&gt;
           &lt;/server&gt;
           &lt;server os="linux" type="suse" version="7.0"&gt;
             &lt;address&gt;192.168.1.10&lt;/address&gt;
             &lt;address&gt;192.168.1.20&lt;/address&gt;
           &lt;/server&gt;
           &lt;server address="192.168.2.100" os="linux" type="conectiva" version="9.0"/&gt;
         &lt;/hosts&gt;

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b> <b>(FILE|DATA|URL</b> <b>,</b> <b>PARSER</b> <b>,</b> <b>OPTIONS)</b>
       Create a XML object.

       <b>Arguments:</b>

       FILE|DATA|URL
                 The first argument can be:

                   - XML data as string.
                   - File path.
                   - File Handle (GLOB).
                   - URL (Need LWP::UserAgent).

                 If  not  passed,  a  null  XML tree is started, where you should create your own XML data, than
                 build/save/send it.

       PARSER <b>(optional)</b>
                 Set the XML parser to use. Options:

                   XML::Parser
                   XML::Smart::Parser
                   XML::Smart::HTMLParser

                 <u>XML::Smart::Parser</u> can only handle basic XML data (not supported PCDATA, and any  header  like:
                 ENTITY,  NOTATION,  etc...), but is a good choice when you don't want to install big modules to
                 parse XML, since it comes with the main module. But it still can handle CDATA and binary data.

                 ** See <u>"PARSING</u> <u>HTML</u> <u>as</u> <u>XML"</u> for <b>XML::Smart::HTMLParser</b>.

                 Aliases for the options:

                   SMART|REGEXP   =&gt; XML::Smart::Parser
                   HTML           =&gt; XML::Smart::HTMLParser

                 <u>Default:</u>

                 If not set it will look for XML::Parser and load it.  If XML::Parser can't be  loaded  it  will
                 use XML::Smart::Parser, which is actually a clone of XML::Parser::Lite with some fixes.

       OPTIONS   You  can  force  the  uper case and lower case for tags (nodes) and arguments (attributes), and
                 other extra things.

                 lowtag    Make the tags lower case.

                 lowarg    Make the arguments lower case.

                 upertag   Make the tags uper case.

                 uperarg   Make the arguments uper case.

                 arg_single
                           Set the value of arguments to 1 when they have a <u>undef</u> value.

                           <u>**</u> <u>This</u> <u>option</u> <u>will</u> <u>work</u> <u>only</u> <u>when</u> <u>the</u> <u>XML</u> <u>is</u> <u>parsed</u> <u>by</u> <u><b>XML::Smart::HTMLParser</b>,</u> <u>since</u>
                           <u>it</u> <u>accept</u> <u>arguments</u> <u>without</u> <u>values:</u>

                             my $xml = new XML::Smart(
                             '&lt;root&gt;&lt;foo arg1="" flag&gt;&lt;<a href="file:/root">/root</a>&gt;' ,
                             'XML::Smart::HTMLParser' ,
                             arg_single =&gt; 1 ,
                             ) ;

                           In this example the option "arg_single" was used, what will define  <u>flag</u>  to  1,  but
                           <u>arg1</u> will still have a null string value ("").

                           Here's the tree of the example above:

                             'root' =&gt; {
                                         'foo' =&gt; {
                                                    'flag' =&gt; 1,
                                                    'arg1' =&gt; ''
                                                  },
                                       },

                 use_spaces
                           Accept contents that have only spaces.

                 on_start (CODE) <u>*optional</u>
                           Code/sub to call on start a tag.

                           <u>**</u>  <u>This</u>  <u>will</u>  <u>be</u>  <u>called</u> <u>after</u> <u>XML::Smart</u> <u>parse</u> <u>the</u> <u>tag,</u> <u>should</u> <u>be</u> <u>used</u> <u>only</u> <u>if</u> <u>you</u>
                           <u>want</u> <u>to</u> <u>change</u> <u>the</u> <u>tree.</u>

                 on_char (CODE) <u>*optional</u>
                           Code/sub to call on content.

                           <u>**</u> <u>This</u> <u>will</u> <u>be</u> <u>called</u> <u>after</u> <u>XML::Smart</u> <u>parse</u> <u>the</u> <u>tag,</u> <u>should</u> <u>be</u>  <u>used</u>  <u>only</u>  <u>if</u>  <u>you</u>
                           <u>want</u> <u>to</u> <u>change</u> <u>the</u> <u>tree.</u>

                 on_end (CODE) <u>*optional</u>
                           Code/sub to call on end a tag.

                           <u>**</u>  <u>This</u>  <u>will</u>  <u>be</u>  <u>called</u> <u>after</u> <u>XML::Smart</u> <u>parse</u> <u>the</u> <u>tag,</u> <u>should</u> <u>be</u> <u>used</u> <u>only</u> <u>if</u> <u>you</u>
                           <u>want</u> <u>to</u> <u>change</u> <u>the</u> <u>tree.</u>

                 <u>**</u> <u>This</u> <u>options</u> <u>are</u> <u>applied</u> <u>when</u> <u>the</u> <u>XML</u> <u>data</u> <u>is</u> <u>loaded.</u> <u>For</u> <u>XML</u> <u>generation</u> <u>see</u> <u><b>data()</b></u> <u>OPTIONS.</u>

       <b>Examples</b> <b>of</b> <b>use:</b>

         my $xml_from_url = XML::Smart-&gt;new("<a href="http://www.perlmonks.org/index.pl">http://www.perlmonks.org/index.pl</a>?node_id=16046") ;

         ...

         my $xml_from_str = XML::Smart-&gt;new(q`&lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
         &lt;root&gt;
           &lt;foo arg="xyz"/&gt;
         &lt;<a href="file:/root">/root</a>&gt;
         `) ;

         ...

         my $null_xml = XML::Smart-&gt;new() ;

         ...

         my $xml_from_html = XML::Smart-&gt;new($html_data , 'html' ,
         lowtag =&gt; 1 ,
         lowarg =&gt; 1 ,
         on_char =&gt; sub {
                      my ( $tag , $pointer , $pointer_back , $cont) = @_ ;
                      $pointer-&gt;{extra_arg} = 123 ; ## add an extrar argument.
                      $pointer_back-&gt;{$tag}{extra_arg} = 123 ; ## Same, but using the previous pointer.
                      $$cont .= "\n" ; ## append data to the content.
                    }
         ) ;

   <b>apply_dtd</b> <b>(DTD</b> <b>,</b> <b>OPTIONS)</b>
       Apply the <u>DTD</u> to the XML tree.

       <u>DTD</u> can be a source, file, GLOB or URL.

       This method is useful if you need to have the XML generated by <u><b>data()</b></u> formated in  a  specific  DTD,  so,
       elements  will  be nodes automatically, attributes will be checked, required elements and attributes will
       be created, the element order will be set, etc...

       <b>OPTIONS:</b>

       no_delete BOOL
                 If TRUE tells that not defined elements and attributes in the DTD won't be deleted from the XML
                 tree.

       <b>Example</b> <b>of</b> <b>use:</b>

         $xml-&gt;apply_dtd(q`
         &lt;!DOCTYPE cds [
         &lt;!ELEMENT cds (album+)&gt;
         &lt;!ATTLIST cds
                   creator  CDATA
                   date     CDATA #REQUIRED
                   type     (a|b|c) #REQUIRED "a"
         &gt;
         &lt;!ELEMENT album (#PCDATA)&gt;
         ]&gt;
         ` ,
         no_delete =&gt; 1 ,
         );

   <b>args()</b>
       Return the arguments names (not nodes).

   <b>args_values()</b>
       Return the arguments values (not nodes).

   <b>back()</b>
       Get back one level the pointer in the tree.

       ** Se <u><b>base()</b></u>.

   <b>base()</b>
       Get back to the base of the tree.

       Each query to the XML::Smart object return an object pointing to a different place in the tree (and share
       the same HASH tree). So, you can get the main object again (an object that points to the base):

         my $srv = $XML-&gt;{root}{host}{server} ;
         my $addr = $srv-&gt;{adress} ;
         my $XML2 = $srv-&gt;base() ;
         $XML2-&gt;{root}{hosts}...

   <b>content()</b>
       Return the content of a node:

         ## Data:
         &lt;foo&gt;my content&lt;/foo&gt;

         ## Access:

         my $content = $XML-&gt;{foo}-&gt;content ;
         print "&lt;&lt;$content&gt;&gt;\n" ; ## show: &lt;&lt;my content&gt;&gt;

         ## or just:
         my $content = $XML-&gt;{foo} ;

       <b>Also</b> <b>can</b> <b>be</b> <b>used</b> <b>with</b> <b>multiple</b> <b>contents:</b>

       For this XML data:

         &lt;root&gt;
         content0
         &lt;tag1 arg="1"/&gt;
         content1
         &lt;<a href="file:/root">/root</a>&gt;

       Getting all the content:

         my $all_content = $XML-&gt;{root}-&gt;content ;
         print "[$all_content]\n" ;

       Output:

         [
         content0

         content1
         ]

       Getting in parts:

         my @contents = $XML-&gt;{root}-&gt;content ;
         print "[@contents[0]]\n" ;
         print "[@contents[1]]\n" ;

       Output

         [
         content0
         ]
         [
         content1
         ]

       <b>Setting</b> <b>multiple</b> <b>contents:</b>

         $XML-&gt;{root}-&gt;content(0,"aaaaa") ;
         $XML-&gt;{root}-&gt;content(1,"bbbbb") ;

       Output now will be:

         [aaaaa]
         [bbbbb]

       And now the XML data generated will be:

         &lt;root&gt;aaaaa&lt;tag1 arg="1"/&gt;bbbbb&lt;<a href="file:/root">/root</a>&gt;

   <b>copy()</b>
       Return a copy of the XML::Smart object (pointing to the base).

       ** This is good when you want to keep 2 versions of the same XML tree in the  memory,  since  one  object
       can't change the tree of the other!

       <b>WARNING:</b>  <b>set_node()</b>, <b>set_cdata()</b> and <b>set_binary()</b> changes are not persistent over copy - Once you create
       a second copy these states are lost.

       b&lt;warning:&gt; do not copy after <b>apply_dtd()</b> unless you have checked for dtd errors.

   <b>cut_root()</b>
       Cut the root key:

         my $srv = $XML-&gt;{rootx}{host}{server} ;

         ## Or if you don't know the root name:
         $XML = $XML-&gt;cut_root() ;
         my $srv = $XML-&gt;{host}{server} ;

       ** Note that this will cut the root of the pointer in the tree.  So, if you are in some place  that  have
       more than one key (multiple roots), the same object will be retuned without cut anything.

   <b>data</b> <b>(OPTIONS)</b>
       Return the data of the XML object (rebuilding it).

       <b>Options:</b>

       nodtd      Do not add in the XML content the DTD applied by the method <u><b>apply_dtd()</b></u>.

       noident    If set to true the data isn't idented.

       nospace    If  set  to  true  the  data isn't idented and doesn't have space between the tags (unless the
                  CONTENT have).

       lowtag     Make the tags lower case.

       lowarg     Make the arguments lower case.

       upertag    Make the tags uper case.

       uperarg    Make the arguments uper case.

       length     If set true, add the attribute 'length' with the size of the data to  the  xml  header  (&lt;?xml
                  ...?&gt;).  This is useful when you send the data through a socket, since the socket can know the
                  total amount of data to read.

       noheader   Do not add  the &lt;?xml ...?&gt; header.

       nometagen  Do not add the meta generator tag: &lt;?meta generator="XML::Smart" ?&gt;

       meta       Set the meta tags of the XML document.

       decode     As  of  VERSION 1.73 there are three different base64 encodings that are used. They are picked
                  based on which of them support the data provided. If you  want  to  retrieve  data  using  the
                  'data'  function  the  resultant  xml  will  have dt:dt="binary.based" contained within it. To
                  retrieve the decoded data use: $XML-&gt;data( decode =&gt; 1 )

                  Examples:

                      my $meta = {
                      build_from =&gt; "wxWindows 2.4.0" ,
                      file =&gt; "wx26.htm" ,
                      } ;

                      print $XML-&gt;data( meta =&gt; $meta ) ;

                      __DATA__
                      &lt;?meta build_from="wxWindows 2.4.0" file="wx283.htm" ?&gt;

                  Multiple meta:

                      my $meta = [
                      {build_from =&gt; "wxWindows 2.4.0" , file =&gt; "wx26.htm" } ,
                      {script =&gt; "genxml.pl" , ver =&gt; "1.0" } ,
                      ] ;

                      __DATA__
                      &lt;?meta build_from="wxWindows 2.4.0" file="wx26.htm" ?&gt;
                      &lt;?meta script="genxml.pl" ver="1.0" ?&gt;

                  Or set directly the meta tag:

                      my $meta = '&lt;?meta foo="bar" ?&gt;' ;

                      ## For multiple:
                      my $meta = ['&lt;?meta foo="bar" ?&gt;' , '&lt;?meta x="1" ?&gt;'] ;

                      print $XML-&gt;data( meta =&gt; $meta ) ;

       tree       Set the HASH tree to parse. If not set will use the tree of the XML::Smart object (<u><b>tree()</b></u>). ;

       wild       Accept wild tags and arguments.

                  ** This wont fix wrong keys and tags.

       sortall    Sort all the tags alphabetically. If not set will keep the order of the  document  loaded,  or
                  the order of tag creation.  <u>Default:</u> off

   <b>data_pointer</b> <b>(OPTIONS)</b>
       Make the tree from current point in the XML tree (not from the base as <b>data()</b>).

       Accept the same OPTIONS of the method <u><b>data()</b></u>.

   <b>dump_tree()</b>
       Dump the tree of the object using Data::Dumper.

   <b>dump_tree_pointer()</b>
       Dump the tree of the object, from the pointer, using Data::Dumper.

   <b>dump_pointer()</b>
       <u>**</u> <u>Same</u> <u>as</u> <u><b>dump_tree_pointer()</b></u>.

   <b>i()</b>
       Return the index of the value.

       ** If the value is from an hash key (not an ARRAY ref) undef is returned.

   <b>is_node()</b>
       Return if a key is a node.

   <b>key()</b>
       Return the key of the value.

       If wantarray return the index too: return(KEY , I) ;

   <b>nodes()</b>
       Return the nodes (objects) in the pointer (keys that aren't arguments).

   <b>nodes_keys()</b>
       Return the nodes names (not the object) in the pointer (keys that aren't arguments).

   <b>null()</b>
       Return <u>true</u> if the XML object has a null tree or if the pointer is in some place that doesn't exist.

   <b>order()</b>
       Return the order of the keys. See <u><b>set_order()</b></u>.

   <b>path()</b>
       Return the path of the pointer.

       <u>Example</u>:

         /hosts/server[1]/address[0]

       <b>Note</b>  <b>that</b>  <b>the</b> <b>index</b> <b>is</b> <b>0</b> <b>based</b> <b>and</b> <b>'address'</b> <b>can</b> <b>be</b> <b>an</b> <b>attribute</b> <b>or</b> <b>a</b> <b>node,</b> <b>what</b> <b>is</b> <b>not</b> <b>compatible</b> <b>with</b>
       <b>XPath.</b>

       <b>**</b> <b>See</b> <u><b>path_as_xpath()</b></u><b>.</b>

   <b>path_as_xpath()</b>
       Return the path of the pointer in the XPath format.

   <b>pointer</b>
       Return the HASH tree from the pointer.

   <b>pointer_ok</b>
       Return a copy of the tree of the object, <b>from</b> <b>the</b> <b>pointer</b>, but without internal keys added by <u>XML::Smart</u>.

   <b>root</b>
       Return the ROOT name of the XML tree (main key).

       ** See also <u><b>key()</b></u> for sub nodes.

   <b>save</b> <b>(FILEPATH</b> <b>,</b> <b>OPTIONS)</b>
       Save the XML data inside a file.

       Accept the same OPTIONS of the method <u><b>data()</b></u>.

   <b>set_auto</b>
       Define the key to be handled automatically. Soo, <b>data()</b> will define automatically if it's a node, content
       or attribute.

       <u>**</u> <u>This</u> <u>method</u> <u>is</u> <u>useful</u> <u>to</u> <u>remove</u> <u><b>set_node()</b>,</u> <u><b>set_cdata()</b></u> <u>and</u> <u><b>set_binary()</b></u> <u>changes.</u>

   <b>set_auto_node</b>
       Define the key as a node, and <b>data()</b> will define automatically if it's CDATA or BINARY.

       <u>**</u> <u>This</u> <u>method</u> <u>is</u> <u>useful</u> <u>to</u> <u>remove</u> <u><b>set_cdata()</b></u> <u>and</u> <u><b>set_binary()</b></u> <u>changes.</u>

   <b>set_binary(BOOL)</b>
       Define the node as a BINARY content when TRUE, or force to <b>not</b> handle it as a BINARY on FALSE.

       Example of node handled as BINARY:

         &lt;root&gt;&lt;foo dt:dt="binary.base64"&gt;PGgxPnRlc3QgAzwvaDE+&lt;/foo&gt;&lt;<a href="file:/root">/root</a>&gt;

       Original content of foo (the base64 data):

         &lt;h1&gt;test \x03&lt;/h1&gt;

   <b>set_cdata(BOOL)</b>
       Define the node as CDATA when TRUE, or force to <b>not</b> handle it as CDATA on FALSE.

       Example of CDATA node:

         &lt;root&gt;&lt;foo&gt;&lt;![CDATA[bla bla bla &lt;tag&gt; bla bla]]&gt;&lt;/foo&gt;&lt;<a href="file:/root">/root</a>&gt;

   <b>set_node(BOOL)</b>
       Set/unset the current key as a node (tag).

       ** If BOOL is not defined will use <u>TRUE</u>.

       <b>WARNING:</b> You cannot set_node, copy the object and then set_node( 0 ) [ Unset node ]

   <b>set_order(KEYS)</b>
       Set the order of the keys (nodes and attributes) in this point.

   <b>set_tag</b>
       Same as set_node.

   <b>tree()</b>
       Return the HASH tree of the XML data.

       ** Note that the real HASH tree is returned here. All the other ways return an object that works  like  a
       HASH/ARRAY through tie.

   <b>tree_pointer()</b>
       Same as <u><b>pointer()</b></u>.

   <b>tree_ok()</b>
       Return  a  copy of the tree of the object, but without internal keys added by <u>XML::Smart</u>, like <u>/order</u> and
       <u>/nodes</u>.

   <b>tree_pointer_ok()</b>
       Return a copy of the tree of the object, <b>from</b> <b>the</b> <b>pointer</b>, but without internal keys added by <u>XML::Smart</u>.

   <b>xpath()</b> <b>||</b> <b>XPath()</b>
       Return a XML::XPath object, based in the XML root in the tree.

         ## look from the root:
         my $data = $XML-&gt;XPath-&gt;findnodes_as_string('/') ;

       <u>**</u> <u>Need</u> <u>XML::XPath</u> <u>installed,</u> <u>but</u> <u>only</u> <u>load</u> <u>when</u> <u>is</u> <u>needed.</u>

   <b>xpath_pointer()</b> <b>||</b> <b>XPath_pointer()</b>
       Return a XML::XPath object, based in the XML::Smart pointer in the tree.

         ## look from this point, soo XPath '/' actually starts at /server/:

         my $srvs = $XML-&gt;{server} ;
         my $data = $srvs-&gt;XPath_pointer-&gt;findnodes_as_string('/') ;

       <u>**</u> <u>Need</u> <u>XML::XPath</u> <u>installed,</u> <u>but</u> <u>only</u> <u>load</u> <u>when</u> <u>is</u> <u>needed.</u>

   <b>ANNIHILATE</b>
       XML::Smart uses XML::XPath that, for perfomance reasons, leaks memory. The ensure  that  this  memory  is
       freed you can explicitly call ANNIHILATE before the XML::Smart object goes out of scope.

</pre><h4><b>ACCESS</b></h4><pre>
       To access the data you use the object in a way similar to HASH and ARRAY:

         my $XML = XML::Smart-&gt;new('file.xml') ;

         my $server = $XML-&gt;{server} ;

       But  when  you get a key {server}, you are actually accessing the data through <b>tie()</b>, not directly to the
       HASH tree inside the object, (This will fix wrong accesses):

         ## {server} is a normal key, not an ARRAY ref:

         my $server = $XML-&gt;{server}[0] ; ## return $XML-&gt;{server}
         my $server = $XML-&gt;{server}[1] ; ## return UNDEF

         ## {server} has an ARRAY with 2 items:

         my $server = $XML-&gt;{server} ;    ## return $XML-&gt;{server}[0]
         my $server = $XML-&gt;{server}[0] ; ## return $XML-&gt;{server}[0]
         my $server = $XML-&gt;{server}[1] ; ## return $XML-&gt;{server}[1]

       To get all the values of multiple elements/keys:

         ## This work having only a string inside {address}, or with an ARRAY ref:
         my @addrsses = @{$XML-&gt;{server}{address}} ;

   <b>Select</b> <b>search</b>
       When you don't know the position of the nodes, you can select it by some attribute value:

         my $server = $XML-&gt;{server}('type','eq','suse') ; ## return $XML-&gt;{server}[1]

       Syntax for the select search:

         (NAME, CONDITION , VALUE)

       NAME      The attribute name in the node (tag).

       CONDITION Can be

                   eq  ne  ==  !=  &lt;=  &gt;=  &lt;  &gt;

                 For REGEX:

                   =~  !~

                   ## Case insensitive:
                   =~i !~i

       VALUE     The value.

                 For REGEX use like this:

                   $XML-&gt;{server}('type','=~','^s\w+$') ;

   <b>Select</b> <b>attributes</b> <b>in</b> <b>multiple</b> <b>nodes:</b>
       You can get the list of values of an attribute looking in all multiple nodes:

         ## Get all the server types:
         my @types = $XML-&gt;{server}('[@]','type') ;

       Also as:

         my @types = $XML-&gt;{server}{type}('&lt;@') ;

       Without the resource:

         my @list ;
         my @servers = @{$XML-&gt;{server}} ;

         foreach my $servers_i ( @servers ) {
           push(@list , $servers_i-&gt;{type} ) ;
         }

   <b>Return</b> <b>format</b>
       You can change the returned format:

       Syntax:

         (TYPE)

       Where TYPE can be:

         $  ## the content.
         @  ## an array (list of multiple values).
         %  ## a hash.
         .  ## The exact point in the tree, not an object.

         $@  ## an array, but with the content, not an objects.
         $%  ## a hash, but the values are the content, not an object.

         ## The use of $@ and $% is good if you don't want to keep the object
         ## reference (and save memory).

         @keys  ## The keys of the node. note that if you have a key with
                ## multiple nodes, it will be replicated (this is the
                ## difference of "keys %{$this-&gt;{node}}" ).

         &lt;@ ## Return the attribute in the previous node, but looking for
            ## multiple nodes. Example:

         my @names = $this-&gt;{method}{wxFrame}{arg}{name}('&lt;@') ;
         #### @names = (parent , id , title) ;

         &lt;xml&gt; ## Return a XML data from this point.

         __DATA__
         &lt;method&gt;
           &lt;wxFrame return="wxFrame"&gt;
             &lt;arg name="parent" type="wxWindow" /&gt;
             &lt;arg name="id" type="wxWindowID" /&gt;
             &lt;arg name="title" type="wxString" /&gt;
           &lt;/wxFrame&gt;
         &lt;/method&gt;

       Example:

         ## A servers content
         my $name = $XML-&gt;{server}{name}('$') ;
         ## ... or:
         my $name = $XML-&gt;{server}{name}-&gt;content ;
         ## ... or:
         my $name = $XML-&gt;{server}{name} ;
         $name = "$name" ;

         ## All the servers
         my @servers = $XML-&gt;{server}('@') ;
         ## ... or:
         my @servers = @{$XML-&gt;{server}} ;

         ## It still has the object reference:
         @servers[0]-&gt;{name} ;

         ## Without the reference:
         my @servers = $XML-&gt;{server}('$@') ;

         ## A XML data, same as data_pointer():
         my $xml_data = $XML-&gt;{server}('&lt;xml&gt;') ;

   <b>CONTENT</b>
       If a {key} has a content you can access it directly from the variable or from the method:

         my $server = $XML-&gt;{server} ;

         print "Content: $server\n" ;
         ## ...or...
         print "Content: ". $server-&gt;content ."\n" ;

       So, if you use the object as a string it works as a string, if you use  as  an  object  it  works  as  an
       object! ;-P

       <u>**See</u> <u>the</u> <u>method</u> <u><b>content()</b></u> <u>for</u> <u>more.</u>

</pre><h4><b>CREATING</b> <b>XML</b> <b>DATA</b></h4><pre>
       To  create  XML  data  is  easy,  you just use as a normal HASH, but you don't need to care with multiple
       nodes, and ARRAY creation/convertion!

         ## Create a null XML object:
         my $XML = XML::Smart-&gt;new() ;

         ## Add a server to the list:
         $XML-&gt;{server} = {
         os =&gt; 'Linux' ,
         type =&gt; 'mandrake' ,
         version =&gt; 8.9 ,
         address =&gt; '192.168.3.201' ,
         } ;

         ## The data now:
         &lt;server address="192.168.3.201" os="Linux" type="mandrake" version="8.9"/&gt;

         ## Add a new address to the server. Have an ARRAY creation, convertion
         ## of the previous key to ARRAY:
         $XML-&gt;{server}{address}[1] = '192.168.3.202' ;

         ## The data now:
         &lt;server os="Linux" type="mandrake" version="8.9"&gt;
           &lt;address&gt;192.168.3.201&lt;/address&gt;
           &lt;address&gt;192.168.3.202&lt;/address&gt;
         &lt;/server&gt;

       After create your XML tree you just save it or get the data:

         ## Get the data:
         my $data = $XML-&gt;data ;

         ## Or save it directly:
         $XML-&gt;save('newfile.xml') ;

         ## Or send to a socket:
         print $socket $XML-&gt;data(length =&gt; 1) ;

</pre><h4><b>BINARY</b> <b>DATA</b> <b>&amp;</b> <b>CDATA</b></h4><pre>
       From version 1.2 <u>XML::Smart</u> can handle binary data and CDATA blocks automatically.

       <b>When</b> <b>parsing</b>, binary data will be detected as:

         &lt;code dt:dt="binary.base64"&gt;f1NPTUUgQklOQVJZIERBVEE=&lt;/code&gt;

       <u>Since</u>   <u>this</u>    <u>is</u>    <u>the</u>    <u>oficial</u>    <u>automatically</u>    <u>format</u>    <u>for</u>    <u>binary</u>    <u>data</u>    <u>at</u>    <u>XML.com</u>
       <u>&lt;<a href="http://www.xml.com/pub/a/98/07/binary/binary.html">http://www.xml.com/pub/a/98/07/binary/binary.html</a>&gt;.</u>   The  content will be decoded from base64 and saved
       in the object tree.

       CDATA will be parsed as any other content, since CDATA is only a block that won't be parsed.

       <b>When</b> <b>creating</b> <b>XML</b> <b>data</b>, like at $XML-&gt;<b>data()</b>, the binary format and CDATA are detected using these rules:

         BINARY:
         - If your data has characters that can't be in XML.

         * Characters accepted:

           \s \w \d
           !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^`{|}~
           0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8e, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
           0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9e, 0x9f, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa,
           0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc,
           0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce,
           0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0,
           0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2,
           0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x20

         TODO: 0x80, 0x81, 0x8d, 0x8f, 0x90, 0xa0

         CDATA:
         - If have tags: &lt;...&gt;

         CONTENT: (&lt;tag&gt;content&lt;/tag&gt;)
         - If have \r\n\t, or ' and " at the same time.

       So, this will be a CDATA content:

         &lt;code&gt;&lt;![CDATA[
           line1
           &lt;tag_not_parsed&gt;
           line2
         ]]&gt;&lt;/code&gt;

       If binary content is detected, it will be converted to <b>base64</b> and a <b>dt:dt</b> attribute added in the  tag  to
       tell the format.

         &lt;code dt:dt="binary.base64"&gt;f1NPTUUgQklOQVJZIERBVEE=&lt;/code&gt;

       <b>NOTE:</b>  As of VERSION 1.73 there are three different base64 encodings that are used. They are picked based
       on which of them support the data provided. If you want to retrieve data using the  'data'  function  the
       resultant  xml  will  have  dt:dt="binary.based"  contained  within it. To retrieve the decoded data use:
       $XML-&gt;data( decode =&gt; 1 )

</pre><h4><b>UNICODE</b> <b>and</b> <b>ASCII-extended</b> <b>(ISO-8859-1)</b></h4><pre>
       <u>XML::Smart</u> support only thse 2 encode types, Unicode (UTF-8) and ASCII-extended (ISO-8859-1), and must be
       enough. (<b>Note</b> <b>that</b> <b>UTF-8</b> <b>is</b> <b>only</b> <b>supported</b> <b>on</b> <b>Perl-5.8+</b>).

       When creating XML data, if any UTF-8 character is detected the <u>encoding</u>  attribute  in  the  &lt;?xml  ...?&gt;
       header will be set to UTF-8:

         &lt;?xml version="1.0" encoding="utf-8" ?&gt;
         &lt;data&gt;0x82, 0x83&lt;/data&gt;

       If not, the <u>iso-8859-1</u> is used:

         &lt;?xml version="1.0" encoding="iso-8859-1" ?&gt;
         &lt;data&gt;0x82&lt;/data&gt;

       When loading XML data with UTF-8, Perl (5.8+) should make all the work internally.

</pre><h4><b>PARSING</b> <b>HTML</b> <b>as</b> <b>XML,</b> <b>or</b> <b>BAD</b> <b>XML</b> <b>formats</b></h4><pre>
       You can use the special parser <b>XML::Smart::HTMLParser</b> to "use" HTML as XML or not well-formed XML data.

       The differences between an normal XML parser and <u>XML::Smart::HTMLParser</u> are:

         - Accept values without quotes:
           &lt;foo bar=x&gt;

         - Accept any data in the values, including &lt;&gt; and &amp;:
           &lt;root&gt;&lt;echo sample="echo \"Hello!\"&gt;out.txt"&gt;&lt;<a href="file:/root">/root</a>&gt;

         - Accpet URI values without quotes:
           &lt;link url=<a href="http://www.foo.com/dir/file">http://www.foo.com/dir/file</a>?query?q=v&amp;x=y target=#_blank&gt;

         - Don't need to close the tags adding the '/' before '&gt;':
           &lt;root&gt;&lt;foo bar="1"&gt;&lt;<a href="file:/root">/root</a>&gt;

           ** Note that the parse will try hard to detect the nodes, and where
              auto-close or not.

         - Don't need to have only one root:
           &lt;foo&gt;data&lt;/foo&gt;&lt;bar&gt;data&lt;/bar&gt;

       So, <u>XML::Smart::HTMLParser</u> is a willd way to load markuped data (like HTML), or if you don't want to care
       with  quotes,  end  tags, etc... when writing by hand your XML data.  So, you can write by hand a bad XML
       file, load it with <u>XML::Smart::HTMLParser</u>, and <b>rewrite</b> <b>well</b> saving it again! ;-P

       ** Note that &lt;SCRIPT&gt; tags will only parse right if the content is inside comments &lt;!--...--&gt;, since they
       can have tags:

         &lt;SCRIPT LANGUAGE="JavaScript"&gt;&lt;!--
         document.writeln("some &lt;tag&gt; in the string");
         --&gt;&lt;/SCRIPT&gt;

</pre><h4><b>ENTITIES</b></h4><pre>
       Entities (ENTITY) are handled by the parser. So, if you use XML::Parser it will do all the job fine.  But
       If you use <u>XML::Smart::Parser</u> or <u>XML::Smart::HMLParser</u>,  only  the  basic  entities  (defaults)  will  be
       parsed:

         &amp;lt;   =&gt; The less than sign (&lt;).
         &amp;gt;   =&gt; The greater than sign (&gt;).
         &amp;amp;  =&gt; The ampersand (&amp;).
         &amp;apos; =&gt; The single quote or apostrophe (').
         &amp;quot; =&gt; The double quote (").

         &amp;#ddd;  =&gt; An ASCII character or an Unicode character (&gt;255). Where ddd is a decimal.
         &amp;#xHHH; =&gt; An Unicode character. Where HHH is in hexadecimal.

       <b>When</b>  <b>creating</b>  <b>XML</b> <b>data</b>, already existent Entities won't be changed, and the characters '&lt;', '&amp;' and '&gt;'
       will be converted to the appropriated entity.

       ** Note that if a content have a &lt;tag&gt;, the characters '&lt;' and '&gt;' won't be converted  to  entities,  and
       this content will be inside a CDATA block.

</pre><h4><b>WHY</b> <b>AND</b> <b>HOW</b> <b>IT</b> <b>WORKS</b></h4><pre>
       Every  one  that have tried to use Perl HASH and ARRAY to access XML data, like in XML::Simple, have some
       problems to add new nodes, or to access the node when the user doesn't know if it's inside  an  ARRAY,  a
       HASH  or a HASH key. <u>XML::Smart</u> create around it a very dynamic way to access the data, since at the same
       time any node/point in the tree can be a HASH and an ARRAY. You also have other extra resources,  like  a
       search for nodes by attribute:

         my $server = $XML-&gt;{server}('type','eq','suse') ; ## This syntax is not wrong! ;-)

         ## Instead of:
         my $server = $XML-&gt;{server}[1] ;

         __DATA__
         &lt;hosts&gt;
           &lt;server os="linux" type="redhat" version="8.0"&gt;
           &lt;server os="linux" type="suse" version="7.0"&gt;
         &lt;/hosts&gt;

       The  idea  for  this  module, came from the problem that exists to access a complex struture in XML.  You
       just need to know how is this structure, something that is generally made looking the XML file  (what  is
       wrong).  But at the same time is hard to always check (by code) the struture, before access it.  XML is a
       good  and easy format to declare your data, but to extrac it in a tree way, at least in my opinion, isn't
       easy. To fix that, came to my mind a way to access the data with some  query  language,  like  SQL.   The
       first idea was to access using something like:

         XML.foo.bar.baz{arg1}

         X = XML.foo.bar*
         X.baz{arg1}

         XML.hosts.server[0]{argx}

       And saw that this is very similar to Hashes and Arrays in Perl:

         $XML-&gt;{foo}{bar}{baz}{arg1} ;

         $X = $XML-&gt;{foo}{bar} ;
         $X-&gt;{baz}{arg1} ;

         $XML-&gt;{hosts}{server}[0]{argx} ;

       But  the problem of Hash and Array, is not knowing when you have an Array reference or not.  For example,
       in XML::Simple:

         ## This is very diffenrent
         $XML-&gt;{server}{address} ;
         ## ... of this:
         $XML-&gt;{server}{address}[0] ;

       So, why don't make both ways work? Because you need to make something crazy!

       To create <u>XML::Smart</u>, first I have created the module Object::MultiType.  With it you can have an  object
       that  works  at  the same time as a HASH, ARRAY, SCALAR, CODE &amp; GLOB. So you can do things like this with
       the same object:

         $obj = Object::MultiType-&gt;new() ;

         $obj-&gt;{key} ;
         $obj-&gt;[0] ;
         $obj-&gt;method ;

         @l = @{$obj} ;
         %h = %{$obj} ;

         &amp;$obj(args) ;

         print $obj "send data\n" ;

       Seems to be crazy, and can be more if you use <b>tie()</b> inside it, and this is what <u>XML::Smart</u> does.

       For <u>XML::Smart</u>, the access in the Hash and Array way paste through <b>tie()</b>. In other words, you have a tied
       HASH and tied ARRAY inside it. This tied Hash and Array work together, soo <b>you</b> <b>can</b> <b>access</b> <b>a</b> <b>Hash</b>  <b>key</b>  <b>as</b>
       <b>the</b> <b>index</b> <b>0</b> <b>of</b> <b>an</b> <b>Array,</b> <b>or</b> <b>access</b> <b>an</b> <b>index</b> <b>0</b> <b>as</b> <b>the</b> <b>Hash</b> <b>key</b>:

         %hash = (
         key =&gt; ['a','b','c']
         ) ;

         $hash-&gt;{key}    ## return $hash{key}[0]
         $hash-&gt;{key}[0] ## return $hash{key}[0]
         $hash-&gt;{key}[1] ## return $hash{key}[1]

         ## Inverse:

         %hash = ( key =&gt; 'a' ) ;

         $hash-&gt;{key}    ## return $hash{key}
         $hash-&gt;{key}[0] ## return $hash{key}
         $hash-&gt;{key}[1] ## return undef

       The  best  thing  of  this new resource is to avoid wrong access to the data and warnings when you try to
       access a Hash having an Array (and the inverse). Thing that generally make the script <b>die()</b>.

       Once having an easy access to the data, you can use the same resource to <b>create</b> data!  For example:

         ## Previous data:
         &lt;hosts&gt;
           &lt;server address="192.168.2.100" os="linux" type="conectiva" version="9.0"/&gt;
         &lt;/hosts&gt;

         ## Now you have {address} as a normal key with a string inside:
         $XML-&gt;{hosts}{server}{address}

         ## And to add a new address, the key {address} need to be an ARRAY ref!
         ## So, XML::Smart make the convertion: ;-P
         $XML-&gt;{hosts}{server}{address}[1] = '192.168.2.101' ;

         ## Adding to a list that you don't know the size:
         push(@{$XML-&gt;{hosts}{server}{address}} , '192.168.2.102') ;

         ## The data now:
         &lt;hosts&gt;
           &lt;server os="linux" type="conectiva" version="9.0"/&gt;
             &lt;address&gt;192.168.2.100&lt;/address&gt;
             &lt;address&gt;192.168.2.101&lt;/address&gt;
             &lt;address&gt;192.168.2.102&lt;/address&gt;
           &lt;/server&gt;
         &lt;/hosts&gt;

       Than after changing your XML tree using the Hash and  Array  resources  you  just  get  the  data  remade
       (through the Hash tree inside the object):

         my $xmldata = $XML-&gt;data ;

       <b>But</b> <b>note</b> <b>that</b> <u><b>XML::Smart</b></u> <b>always</b> <b>return</b> <b>an</b> <b>object</b>! Even when you get a final key. So this actually returns
       another object, pointhing (inside it) to the key:

         $addr = $XML-&gt;{hosts}{server}{address}[0] ;

         ## Since $addr is an object you can TRY to access more data:
         $addr-&gt;{foo}{bar} ; ## This doens't make warnings! just return UNDEF.

         ## But you can use it like a normal SCALAR too:

         print "$addr\n" ;

         $addr .= ':80' ; ## After this $addr isn't an object any more, just a SCALAR!

</pre><h4><b>TODO</b></h4><pre>
         * Finish XPath implementation.
         * DTD - Handle &lt;!DOCTYPE&gt; gracefully.
         * Implement a better way to declare meta tags.
         * Add 0x80, 0x81, 0x8d, 0x8f, 0x90, 0xa0 ( multi byte characters to the list of accepted binary characters )
         * Ensure object copy holds more in state including: -&gt;data( wild =&gt; 1 )

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::Parser, XML::Parser::Lite, XML::XPath, XML.

       Object::MultiType  -  This  is  the  module  that make everything possible, and was created specially for
       <u>XML::Smart</u>. ;-P

       ** See the test.pl script for examples of use.

       XML.com &lt;<a href="http://www.xml.com">http://www.xml.com</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Graciliano M. P. "&lt;gm at virtuasites.com.br&gt;"

       I will appreciate any type of feedback (include your opinions and/or suggestions). ;-P

       Enjoy and thanks for who are enjoying this tool and have sent e-mails! ;-P

</pre><h4><b>CURRENT</b> <b>MAINTAINER</b></h4><pre>
       Harish Madabushi, "&lt;harish.tmh at gmail.com&gt;"

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature  requests  to  "bug-xml-smart  at  rt.cpan.org",  or  through  the  web
       interface   at  &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=XML-Smart&gt;.   Both  the  author  and  the
       maintainer will be notified, and then you'll automatically be notified of progress on your bug as changes
       are made.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc XML::Smart

       You can also look for information at:

       •    RT: CPAN's request tracker (report bugs here)

            &lt;<a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=XML-Smart&gt;

       •    AnnoCPAN: Annotated CPAN documentation

            &lt;<a href="http://annocpan.org/dist/XML-Smart">http://annocpan.org/dist/XML-Smart</a>&gt;

       •    CPAN Ratings

            &lt;<a href="http://cpanratings.perl.org/d/XML-Smart">http://cpanratings.perl.org/d/XML-Smart</a>&gt;

       •    Search CPAN

            &lt;<a href="http://search.cpan.org/dist/XML-Smart/">http://search.cpan.org/dist/XML-Smart/</a>&gt;

       •    GitHub CPAN

            &lt;https://github.com/harishmadabushi/XML-Smart&gt;

</pre><h4><b>THANKS</b></h4><pre>
       Thanks to Rusty Allen for the extensive tests of CDATA and BINARY handling of XML::Smart.

       Thanks to Ted Haining to point a Perl-5.8.0 bug for tied keys of a HASH.

       Thanks to everybody that have sent ideas, patches or pointed bugs.

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright 2003 Graciliano M. P.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-11-19                                    <u>XML::<a href="../man3pm/Smart.3pm.html">Smart</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>