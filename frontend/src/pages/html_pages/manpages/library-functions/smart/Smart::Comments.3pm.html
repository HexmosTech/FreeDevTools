<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart::Comments - Comments that do more than just sit there</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsmart-comments-perl">libsmart-comments-perl_1.06-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Smart::Comments - Comments that do more than just sit there

</pre><h4><b>VERSION</b></h4><pre>
       This document describes Smart::Comments version 1.000005

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Smart::Comments;

           my $var = suspect_value();

           ### $var

           ### got: $var

           ### Now computing value...

           # and when looping:

           for my $big_num (@big_nums) {  ### Factoring...      done
               factor($big_num);
           }

           while ($error &gt; $tolerance) {  ### Refining---&gt;      done
               refine_approximation()
           }

           for (my $i=0; $i&lt;$MAX_INT; $i++) {   ### Working===[%]     done
               do_something_expensive_with($i);
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Smart comments provide an easy way to insert debugging and tracking code into a program. They can report
       the value of a variable, track the progress of a loop, and verify that particular assertions are true.

       Best of all, when you're finished debugging, you don't have to remove them.  Simply commenting out the
       "use Smart::Comments" line turns them back into regular comments. Leaving smart comments in your code is
       smart because if you needed them once, you'll almost certainly need them again later.

</pre><h4><b>INTERFACE</b></h4><pre>
       All smart comments start with three (or more) "#" characters. That is, they are regular "#"-introduced
       comments whose first two (or more) characters are also "#"'s.

   <b>Using</b> <b>the</b> <b>Module</b>
       The module is loaded like any other:

           use Smart::Comments;

       When loaded it filters the remaining code up to the next:

           no Smart::Comments;

       directive, replacing any smart comments with smart code that implements the comments behaviour.

       If you're debugging an application you can also invoke it with the module from the command-line:

           perl -MSmart::Comments $application.pl

       Of course, this only enables smart comments in the application file itself, not in any modules that the
       application loads.

       You can also specify particular levels of smartness, by including one or more markers as arguments to the
       "use":

           use Smart::Comments '###', '####';

       These arguments tell the module to filter only those comments that start with the same number of "#"'s.
       So the above "use" statement would "activate" any smart comments of the form:

           ###   Smart...

           ####  Smarter...

       but not those of the form:

           ##### Smartest...

       This facility is useful for differentiating progress bars (see "Progress Bars"), which should always be
       active, from debugging comments (see "Debugging via Comments"), which should not:

           #### Debugging here...

           for (@values) {         ### Progress: 0...  100
               do_stuff();
           }

       Note that, for simplicity, all smart comments described below will be written with three "#"'s; in all
       such cases, any number of "#"'s greater than three could be used instead.

   <b>Debugging</b> <b>via</b> <b>Comments</b>
       The simplest way to use smart comments is for debugging. The module supports the following forms, all of
       which print to "STDERR":

       "### LABEL : EXPRESSION"
           The  LABEL  is  any  sequence  of characters up to the first colon.  The EXPRESSION is any valid Perl
           expression, including a simple variable.  When active, the comment prints the label, followed by  the
           value of the expression. For example:

               ### Expected: 2 * $prediction
               ###      Got: $result

           prints:

               ### Expected: 42
               ###      Got: 13

       "### EXPRESSION"
           The  EXPRESSION  is  any valid Perl expression, including a simple variable. When active, the comment
           prints the expression, followed by the value of the expression. For example:

               ### 2 * $prediction
               ### $result

           prints:

               ### 2 * $prediction: 42
               ### $result: 13

       "### TEXT..."
           The TEXT is any sequence of characters that end in three dots.  When active, the comment just  prints
           the text, including the dots. For example:

               ### Acquiring data...

               $data = get_data();

               ### Verifying data...

               verify_data($data);

               ### Assimilating data...

               assimilate_data($data);

               ### Tired now, having a little lie down...

               sleep 900;

           would print:

               ### Acquiring data...

               ### Verifying data...

               ### Assimilating data...

               ### Tired now, having a little lie down...

           as  each  phase  commenced.  This  is  particularly useful for tracking down precisely where a bug is
           occurring. It is also useful in non-debugging situations, especially  when  batch  processing,  as  a
           simple progress feedback mechanism.

           Within  a  textual  smart  comment you can use the special sequence "&lt;now&gt;" (or "&lt;time&gt;" or "&lt;when&gt;")
           which is replaced with a timestamp. For example:

               ### [&lt;now&gt;] Acquiring data...

           would produce something like:

               ### [Fri Nov 18 15:11:15 EST 2005] Acquiring data...

           There are also "spacestamps": "&lt;here&gt;" (or "&lt;loc&gt;" or "&lt;place&gt;" or "&lt;where&gt;"):

               ### Acquiring data at &lt;loc&gt;...

           to produce something like:

               ### Acquiring data at "demo.pl", line 7...

           You can also request just the filename ("&lt;file&gt;") or just the line number  ("&lt;line&gt;")  to  get  finer
           control over formatting:

               ### Acquiring data at &lt;file&gt;[&lt;line&gt;]...

           and produce something like:

               ### Acquiring data at demo.pl[7]...

           You can, of course, use any combination of stamps in the one comment.

   <b>Checks</b> <b>and</b> <b>Assertions</b> <b>via</b> <b>Comments</b>
       "### require: BOOLEAN_EXPR"
       "### assert:  BOOLEAN_EXPR"
       "### ensure:  BOOLEAN_EXPR"
       "### insist:  BOOLEAN_EXPR"
           These  four  are  synonyms  for the same behaviour. The comment evaluates the expression in a boolean
           context. If the result is true, nothing more is done. If the result is false, the comment  throws  an
           exception  listing  the  expression, the fact that it failed, and the values of any variables used in
           the expression.

           For example, given the following assertion:

               ### require: $min &lt; $result &amp;&amp; $result &lt; $max

           if the expression evaluated false, the comment would die with the following message:

               ### $min &lt; $result &amp;&amp; $result &lt; $max was not true at demo.pl line 86.
               ###     $min was: 7
               ###     $result was: 1000004
               ###     $max was: 99

       "### check:   BOOLEAN_EXPR"
       "### confirm: BOOLEAN_EXPR"
       "### verify:  BOOLEAN_EXPR"
           These three are synonyms for the same behaviour. The comment evaluates the expression  in  a  boolean
           context.  If  the  result is true, nothing more is done. If the result is false, the comment prints a
           warning message listing the expression, the fact that it failed, and the values of any variables used
           in the expression.

           The effect is identical to that of the four assertions listed earlier, except  that  "warn"  is  used
           instead of "die".

   <b>Progress</b> <b>Bars</b>
       You can put a smart comment on the same line as any of the following types of Perl loop:

           foreach my VAR ( LIST ) {       ### Progressing...   done

           for my VAR ( LIST ) {           ### Progressing...   done

           foreach ( LIST ) {              ### Progressing...   done

           for ( LIST ) {                  ### Progressing...   done

           while (CONDITION) {             ### Progressing...   done

           until (CONDITION) {             ### Progressing...   done

           for (INIT; CONDITION; INCR) {   ### Progressing...   done

       In  each  case,  the module animates the comment, causing the dots to extend from the left text, reaching
       the right text on the last iteration. For "open ended" loops (like "while" and C-style "for" loops),  the
       dots will never reach the right text and their progress slows down as the number of iterations increases.

       For example, a smart comment like:

           for (@candidates) {       ### Evaluating...     done

       would  be  animated  is  the following sequence (which would appear sequentially on a single line, rather
       than on consecutive lines):

           Evaluating                          done

           Evaluating......                    done

           Evaluating.............             done

           Evaluating...................       done

           Evaluating..........................done

       The module animates the first sequence of three identical  characters  in  the  comment,  provided  those
       characters  are  followed  by  a  gap of at least two whitespace characters. So you can specify different
       types of progress bars. For example:

           for (@candidates) {       ### Evaluating:::     done

       or:

           for (@candidates) {       ### Evaluating===     done

       or:

           for (@candidates) {       ### Evaluating|||     done

       If the characters to be animated are immediately followed by other non-whitespace characters  before  the
       gap,  then  those  other non-whitespace characters are used as an "arrow head" or "leader" and are pushed
       right by the growing progress bar. For example:

           for (@candidates) {       ### Evaluating===|    done

       would animate like so:

           Evaluating|                         done

           Evaluating=====|                    done

           Evaluating============|             done

           Evaluating==================|       done

           Evaluating==========================done

       If a percentage character ("%") appears anywhere in  the  comment,  it  is  replaced  by  the  percentage
       completion. For example:

           for (@candidates) {       ### Evaluating [===|    ] % done

       animates like so:

           Evaluating [|                ]   0% done

           Evaluating [===|             ]  25% done

           Evaluating [========|        ]  50% done

           Evaluating [============|    ]  75% done

           Evaluating [=================] 100% done

       If the "%" is in the "arrow head" it moves with the progress bar. For example:

           for (@candidates) {       ### Evaluating |===[%]    |

       would be animated like so:

           Evaluating |[0%]                       |

           Evaluating |=[25%]                     |

           Evaluating |========[50%]              |

           Evaluating |===============[75%]       |

           Evaluating |===========================|

       For  "open-ended"  loops,  the percentage completion is unknown, so the module replaces each "%" with the
       current iteration count. For example:

           while ($next ne $target) {       ### Evaluating |===[%]    |

       would animate like so:

           Evaluating |[0]                        |

           Evaluating |=[2]                       |

           Evaluating |==[3]                      |

           Evaluating |===[5]                     |

           Evaluating |====[7]                    |

           Evaluating |=====[8]                   |

           Evaluating |======[11]                 |

       Note that the non-sequential numbering in the above example is a result of the "hurry up and  slow  down"
       algorithm that prevents open-ended loops from ever reaching the right-hand side.

       As a special case, if the progress bar is drawn as two pairs of identical brackets:

           for (@candidates) {       ### Evaluating: [][]

           for (@candidates) {       ### Evaluating: {}{}

           for (@candidates) {       ### Evaluating: ()()

           for (@candidates) {       ### Evaluating: &lt;&gt;&lt;&gt;

       Then the bar grows by repeating bracket pairs:

           Evaluating: [

           Evaluating: []

           Evaluating: [][

           Evaluating: [][]

           Evaluating: [][][

       etc.

       Finally, progress bars don't have to have an animated component. They can just report the loop's progress
       numerically:

           for (@candidates) {       ### Evaluating (% done)

       which would animate (all of the same line):

           Evaluating (0% done)

           Evaluating (25% done)

           Evaluating (50% done)

           Evaluating (75% done)

           Evaluating (100% done)

   <b>Time-Remaining</b> <b>Estimates</b>
       When  a  progress  bar is used with a "for" loop, the module tracks how long each iteration is taking and
       makes an estimate of how much time will be required to complete the entire loop.

       Normally this estimate is not shown, unless the estimate becomes large enough to  warrant  informing  the
       user.  Specifically,  the  estimate  will be shown if, after five seconds, the time remaining exceeds ten
       seconds.  In other words, a time-remaining estimate is shown if the module detects a "for" loop  that  is
       likely to take more than 15 seconds in total. For example:

           for (@seven_samurai) {      ### Fighting: [|||    ]
               fight();
               sleep 5;
           }

       would be animated like so:

           Fighting: [                           ]

           Fighting: [||||                       ]

           Fighting: [|||||||||                  ]  (about 20 seconds remaining)

           Fighting: [||||||||||||||             ]  (about 20 seconds remaining)

           Fighting: [||||||||||||||||||         ]  (about 10 seconds remaining)

           Fighting: [|||||||||||||||||||||||    ]  (less than 10 seconds remaining)

           Fighting: [|||||||||||||||||||||||||||]

       The  precision  of the reported time-remaining estimate is deliberately vague, mainly to prevent it being
       annoyingly wrong.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       In a sense, everything this module does is a diagnostic. All comments that print anything,  print  it  to
       "STDERR".

       However, the module itself has only one diagnostic:

       "Incomprehensible arguments: %s in call to 'use Smart::Comments"
           You  loaded  the  module  and  passed it an argument that wasn't three-or- more "#"'s. Arguments like
           '###', '####', '#####', etc. are the only ones that the module accepts.

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
       Smart::Comments can make use of an environment variable from your shell: "Smart_Comments". This  variable
       can be specified either with a true/false value (i.e. 1 or 0) or with the same arguments as may be passed
       on  the  "use"  line  when  loading  the  module  (see  "INTERFACE").  The following table summarizes the
       behaviour:

                Value of
           $ENV{Smart_Comments}          Equivalent Perl

                   1                     use Smart::Comments;
                   0                      no Smart::Comments;
               '###:####'                use Smart::Comments qw(### ####);
               '### ####'                use Smart::Comments qw(### ####);

       To enable the "Smart_Comments" environment variable, you need to load the module with the "-ENV" flag:

           use Smart::Comments -ENV;

       Note that you can still specify other arguments in the "use" statement:

           use Smart::Comments -ENV, qw(### #####);

       In this case, the contents of the environment variable replace the "-ENV" in the argument list.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       The module requires the following modules:

       •   Filter::Simple

       •   version

       •   List::Util

       •   Data::Dumper

       •   Text::Balanced

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       None reported. This module is probably even relatively safe with other Filter::Simple modules since it is
       very specific and limited in what it filters.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       No bugs have been reported.

       This module has the usual limitations of source filters (i.e. it looks smarter than it is).

       Please report any bugs or feature  requests  to  "<a href="mailto:bug-smart-comments@rt.cpan.org">bug-smart-comments@rt.cpan.org</a>",  or  through  the  web
       interface at &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt;.

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;https://github.com/neilb/Smart-Comments&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Damian Conway  "&lt;<a href="mailto:DCONWAY@cpan.org">DCONWAY@cpan.org</a>&gt;"

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005, Damian Conway "&lt;<a href="mailto:DCONWAY@cpan.org">DCONWAY@cpan.org</a>&gt;". All rights reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE,  TO  THE  EXTENT
       PERMITTED  BY  APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
       PARTIES PROVIDE THE SOFTWARE "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND,  EITHER  EXPRESSED  OR  IMPLIED,
       INCLUDING,  BUT  NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
       PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF  THE  SOFTWARE  IS  WITH  YOU.  SHOULD  THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN  NO  EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY
       OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE  LIABLE
       TO  YOU  FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF
       THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING BUT NOT  LIMITED  TO  LOSS  OF  DATA  OR  DATA  BEING
       RENDERED  INACCURATE  OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO OPERATE
       WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF  SUCH
       DAMAGES.

perl v5.36.0                                       2022-10-13                               <u>Smart::<a href="../man3pm/Comments.3pm.html">Comments</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>