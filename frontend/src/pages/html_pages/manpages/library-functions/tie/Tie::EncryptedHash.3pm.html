<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tie::EncryptedHash - Hashes (and objects based on hashes) with encrypting fields.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtie-encryptedhash-perl">libtie-encryptedhash-perl_1.24-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tie::EncryptedHash - Hashes (and objects based on hashes) with encrypting fields.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Tie::EncryptedHash;

           my %s = ();
           tie %s, Tie::EncryptedHash, 'passwd';

           $s{foo}  = "plaintext";     # Normal field, stored in plaintext.
           print $s{foo};              # (plaintext)

           $s{_bar} = "signature";     # Fieldnames that begin in single
                                       # underscore are encrypted.
           print $s{_bar};             # (signature)  Though, while the password
                                       # is set, they behave like normal fields.
           delete $s{__password};      # Delete password to disable access
                                       # to encrypting fields.
           print $s{_bar};             # (Blowfish NuRVFIr8UCAJu5AWY0w...)

           $s{__password} = 'passwd';  # Restore password to gain access.
           print $s{_bar};             # (signature)

           $s{_baz}{a}{b} = 42;        # Refs are fine, we encrypt them too.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Tie::EncryptedHash augments Perl hash semantics to build secure, encrypting containers of data.
       Tie::EncryptedHash introduces special hash fields that are coupled with encrypt/decrypt routines to
       encrypt assignments at <u>STORE()</u> and decrypt retrievals at <u>FETCH()</u>.  By design, <u>encrypting</u> <u>fields</u> are
       associated with keys that begin in single underscore.  The remaining keyspace is used for accessing
       normal hash fields, which are retained without modification.

       While the password is set, a Tie::EncryptedHash behaves exactly like a standard Perl hash.  This is its
       <u>transparent</u> <u>mode</u> of access.  Encrypting and normal fields are identical in this mode.  When password is
       deleted, encrypting fields are accessible only as ciphertext.  This is Tie::EncryptedHash's <u>opaque</u> <u>mode</u>
       of access, optimized for serialization.

       Encryption is done with <u>Crypt::<a href="../man3/CBC.3.html">CBC</a></u>(3) which encrypts in the cipher block chaining mode with Blowfish, DES
       or IDEA.  Tie::EncryptedHash uses Blowfish by default, but can be instructed to employ any cipher
       supported by <u>Crypt::<a href="../man3/CBC.3.html">CBC</a></u>(3).

</pre><h4><b>MOTIVATION</b></h4><pre>
       Tie::EncryptedHash was designed for storage and communication of key material used in public key
       cryptography algorithms.  I abstracted out the mechanism for encrypting selected fields of a structured
       data record because of the sheer convenience of this data security method.

       Quite often, applications that require data confidentiality eschew strong cryptography in favor of OS-
       based access control mechanisms because of the additional costs of cryptography integration.  Besides
       cipher implementations, which are available as ready-to-deploy perl modules, use of cryptography in an
       application requires code to aid conversion and representation of encrypted data.  This code is usually
       encapsulated in a data access layer that manages encryption, decryption, access control and re-
       structuring of flat plaintext according to a data model.  Tie::EncryptedHash provides these functions
       under the disguise of a Perl hash so perl applications can use strong cryptography without the cost of
       implementing a complex data access layer.

</pre><h4><b>CONSTRUCTION</b></h4><pre>
   <b>Tied</b> <b>Hash</b>
       "tie %h, Tie::EncryptedHash, 'Password', 'Cipher';"

       Ties %h to Tie::EncryptedHash and sets the value of password and cipher to 'Password' and 'Cipher'.  Both
       arguments are optional.

   <b>Blessed</b> <b>Object</b>
       "$h = new Tie::EncryptedHash __password =" 'Password',
                                __cipher =&gt; 'Cipher';&gt;

       The <u>new()</u> constructor returns an object that is both tied and blessed into Tie::EncryptedHash.  Both
       arguments are optional.  When used in this manner, Tie::EncryptedHash behaves like a class with
       encrypting data members.

</pre><h4><b>RESERVED</b> <b>ATTRIBUTES</b></h4><pre>
       The attributes __password, __cipher and __hide are reserved for communication with object methods.  They
       are "write-only" from everywhere except the class to which the hash is tied.  __scaffolding is
       inaccessible.  Tie::EncryptedHash stores the current encryption password and some transient data
       structures in these fields and restricts access to them on need-to-know basis.

   <b>__password</b>
       "$h{__password} = "new password"; delete $h{__password};"

       The password is stored under the attribute "__password".  In addition to specifying a password at
       construction, assigning to the __password attribute sets the current encryption password to the assigned
       value.  Deleting the __password unsets it and switches the hash into opaque mode.

   <b>__cipher</b>
       "$h{__cipher} = 'DES'; $h{__cipher} = 'Blowfish';"

       The cipher used for encryption/decryption is stored under the attribute __cipher.  The value defaults to
       'Blowfish'.

   <b>__hide</b>
       "$h{__hide} = 1;"

       Setting this attribute <u>hides</u> encrypting fields in opaque mode.  'undef' is returned at <u>FETCH()</u> and
       <u>EXISTS()</u>.

</pre><h4><b>BEHAVIOR</b></h4><pre>
   <b>References</b>
       A reference stored in an encrypting field is serialized before encryption.  The data structure
       represented by the reference is folded into a single line of ciphertext which is stored under the first
       level key.  In the opaque mode, therefore, only the first level of keys of the hash will be visible.

   <b>Opaque</b> <b>Mode</b>
       The opaque mode introduces several other constraints on access of encrypting fields.  Encrypting fields
       return ciphertext on <u>FETCH()</u> unless __hide attribute is set, which forces Tie::EncryptedHash to behave as
       if encrypting fields don't exist.  Irrespective of __hide, however, <u>DELETE()</u> and <u>CLEAR()</u> fail in opaque
       mode.  So does <u>STORE()</u> on an existing encrypting field.  Plaintext assignments to encrypting fields are
       silently ignored, but ciphertext assignments are fine.  Ciphertext assignments can be used to move data
       between different EncryptedHashes.

   <b>Multiple</b> <b>Passwords</b> <b>and</b> <b>Ciphers</b>
       Modality of Tie::EncryptedHash's access system breaks down when more than one password is used to with
       different encrypting fields.  This is a feature.  Tie::EncryptedHash lets you mix passwords and ciphers
       in the same hash.  Assign new values to __password and __cipher and create a new encrypting field.
       Transparent mode will be restricted to fields encrypted with the current password.

   <b>Error</b> <b>Handling</b>
       Tie::Encrypted silently ignores access errors.  It doesn't carp/croak when you perform an illegal
       operation (like assign plaintext to an encrypting field in opaque mode).  This is to prevent data
       lossage, the kind that results from abnormal termination of applications.

</pre><h4><b>QUIRKS</b></h4><pre>
   <b>Autovivification</b>
       Due to the nature of autovivified references (which spring into existence when an undefined reference is
       dereferenced), references are stored as plaintext in transparent mode.  Analogous ciphertext
       representations are maintained in parallel and restored to encrypting fields when password is deleted.
       This process is completely transparent to the user, though it's advisable to delete the password after
       the final assignment to a Tie::EncryptedHash.  This ensures plaintext representations and scaffolding
       data structures are duly flushed.

   <b>Data::Dumper</b>
       Serialization of references is done with Data::Dumper, therefore the nature of data that can be assigned
       to encrypting fields is limited by what Data::Dumper can grok.  We set $Data::Dumper::Purity = 1, so
       self-referential and recursive structures should be OK.

   <b>Speed</b>
       Tie::EncryptedHash'es keep their contents encrypted as much as possible, so there's a rather severe speed
       penalty.  With Blowfish, <u>STORE()</u> on EncryptedHash can be upto 70 times slower than a standard perl hash.
       Reference <u>STORE()</u>'es will be quicker, but speed gain will be adjusted at <u>FETCH()</u>.  <u>FETCH()</u> is about 35
       times slower than a standard perl hash.  DES affords speed improvements of upto 2x, but is not considered
       secure for long-term storage of data.  These values were computed on a DELL PIII-300 Mhz notebook with
       128 Mb RAM running perl 5.003 on Linux 2.2.16.  Variations in speed might be different on your machine.

</pre><h4><b>STANDARD</b> <b>USAGE</b></h4><pre>
       The standard usage for this module would be something along the lines of: populate Tie::EncryptedHash
       with sensitive data, delete the password, serialize the encrypted hash with Data::Dumper, store the
       result on disk or send it over the wire to another machine.  Later, when the sensitive data is required,
       procure the EncryptedHash, set the password and accesses the encrypted data fields.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Data::<a href="../man3/Dumper.3.html">Dumper</a></u>(3), <u>Crypt::<a href="../man3/CBC.3.html">CBC</a></u>(3), <u>Crypt::<a href="../man3/DES.3.html">DES</a></u>(3), <u>Crypt::<a href="../man3/Blowfish.3.html">Blowfish</a></u>(3), <u>Tie::<a href="../man3/SecureHash.3.html">SecureHash</a></u>(3)

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       The framework of Tie::EncryptedHash derives heavily from Damian Conway's Tie::SecureHash.  Objects that
       are blessed as well as tied are just one of the pleasant side-effects of stealing Damian's code.  Thanks
       to Damian for this brilliant module.

       PacificNet (<a href="http://www.pacificnet.net">http://www.pacificnet.net</a>) loaned me the aforementioned notebook to hack from the comfort of
       my bed.  Thanks folks!

</pre><h4><b>AUTHOR</b></h4><pre>
       Vipul Ved Prakash &lt;<a href="mailto:mail@vipul.net">mail@vipul.net</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This module is distributed under the same license as Perl itself.

perl v5.26.1                                       2018-03-31                            <u>Tie::<a href="../man3pm/EncryptedHash.3pm.html">EncryptedHash</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>