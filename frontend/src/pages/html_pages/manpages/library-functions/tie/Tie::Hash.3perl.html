<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes

</pre><h4><b>SYNOPSIS</b></h4><pre>
           package NewHash;
           require Tie::Hash;

           @ISA = qw(Tie::Hash);

           sub DELETE { ... }          # Provides needed method
           sub CLEAR { ... }           # Overrides inherited method

           package NewStdHash;
           require Tie::Hash;

           @ISA = qw(Tie::StdHash);

           # All methods provided by default, define
           # only those needing overrides
           # Accessors access the storage in %{$_[0]};
           # TIEHASH should return a reference to the actual storage
           sub DELETE { ... }

           package NewExtraHash;
           require Tie::Hash;

           @ISA = qw(Tie::ExtraHash);

           # All methods provided by default, define
           # only those needing overrides
           # Accessors access the storage in %{$_[0][0]};
           # TIEHASH should return an array reference with the first element
           # being the reference to the actual storage
           sub DELETE {
             $_[0][1]-&gt;('del', $_[0][0], $_[1]); # Call the report writer
             delete $_[0][0]-&gt;{$_[1]};           #  $_[0]-&gt;SUPER::DELETE($_[1])
           }

           package main;

           tie %new_hash, 'NewHash';
           tie %new_std_hash, 'NewStdHash';
           tie %new_extra_hash, 'NewExtraHash',
               sub {warn "Doing \U$_[1]\E of $_[2].\n"};

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides some skeletal methods for hash-tying classes. See perltie for a list of the
       functions required in order to tie a hash to a package. The basic <b>Tie::Hash</b> package provides a "new"
       method, as well as methods "TIEHASH", "EXISTS" and "CLEAR". The <b>Tie::StdHash</b> and <b>Tie::ExtraHash</b> packages
       provide most methods for hashes described in perltie (the exceptions are "UNTIE" and "DESTROY").  They
       cause tied hashes to behave exactly like standard hashes, and allow for selective overwriting of methods.
       <b>Tie::Hash</b> has legacy support for the "new" method: it is used if "TIEHASH" is not defined in the case a
       class forgets to include a "TIEHASH" method.

       For developers wishing to write their own tied hashes, the required methods are briefly defined below.
       See the perltie section for more detailed descriptive, as well as example code:

       TIEHASH classname, LIST
           The  method  invoked  by  the command "tie %hash, classname". Associates a new hash instance with the
           specified class. "LIST" would represent additional arguments (along  the  lines  of  AnyDBM_File  and
           compatriots) needed to complete the association.

       STORE this, key, value
           Store datum <u>value</u> into <u>key</u> for the tied hash <u>this</u>.

       FETCH this, key
           Retrieve the datum in <u>key</u> for the tied hash <u>this</u>.

       FIRSTKEY this
           Return the first key in the hash.

       NEXTKEY this, lastkey
           Return the next key in the hash.

       EXISTS this, key
           Verify that <u>key</u> exists with the tied hash <u>this</u>.

           The <b>Tie::Hash</b> implementation is a stub that simply croaks.

       DELETE this, key
           Delete the key <u>key</u> from the tied hash <u>this</u>.

       CLEAR this
           Clear all values from the tied hash <u>this</u>.

       SCALAR this
           Returns what evaluating the hash in scalar context yields.

           <b>Tie::Hash</b> does not implement this method (but <b>Tie::StdHash</b> and <b>Tie::ExtraHash</b> do).

</pre><h4><b>Inheriting</b> <b>from</b> <b>Tie::StdHash</b></h4><pre>
       The  accessor  methods  assume  that  the  actual  storage  for  the data in the tied hash is in the hash
       referenced by tied(%tiedhash).  Thus overwritten "TIEHASH" method should return a hash reference, and the
       remaining methods should operate on the hash referenced by the first argument:

         package ReportHash;
         our @ISA = 'Tie::StdHash';

         sub TIEHASH  {
           my $storage = bless {}, shift;
           warn "New ReportHash created, stored in $storage.\n";
           $storage
         }
         sub STORE    {
           warn "Storing data with key $_[1] at $_[0].\n";
           $_[0]{$_[1]} = $_[2]
         }

</pre><h4><b>Inheriting</b> <b>from</b> <b>Tie::ExtraHash</b></h4><pre>
       The accessor methods assume that the actual storage for the  data  in  the  tied  hash  is  in  the  hash
       referenced  by  "(tied(%tiedhash))-&gt;[0]".   Thus  overwritten  "TIEHASH"  method  should  return an array
       reference with the first element being a hash reference, and the remaining methods should operate on  the
       hash "%{ $_[0]-&gt;[0] }":

         package ReportHash;
         our @ISA = 'Tie::ExtraHash';

         sub TIEHASH  {
           my $class = shift;
           my $storage = bless [{}, @_], $class;
           warn "New ReportHash created, stored in $storage.\n";
           $storage;
         }
         sub STORE    {
           warn "Storing data with key $_[1] at $_[0].\n";
           $_[0][0]{$_[1]} = $_[2]
         }

       The  default  "TIEHASH"  method  stores  "extra"  arguments  to <b>tie()</b> starting from offset 1 in the array
       referenced by tied(%tiedhash); this is the same storage algorithm as in TIEHASH subroutine above.  Hence,
       a typical package inheriting from <b>Tie::ExtraHash</b> does not need to overwrite this method.

</pre><h4><b>SCALAR",</b> <b>"UNTIE"</b> <b>and</b> <b>"DESTROY"</b></h4><pre>
       The methods "UNTIE" and "DESTROY" are not defined in <b>Tie::Hash</b>, <b>Tie::StdHash</b>,  or  <b>Tie::ExtraHash</b>.   Tied
       hashes  do  not  require  presence of these methods, but if defined, the methods will be called in proper
       time, see perltie.

       "SCALAR" is only defined in <b>Tie::StdHash</b> and <b>Tie::ExtraHash</b>.

       If needed, these methods should be defined by the package inheriting  from  <b>Tie::Hash</b>,  <b>Tie::StdHash</b>,  or
       <b>Tie::ExtraHash</b>. See "SCALAR" in perltie to find out what happens when "SCALAR" does not exist.

</pre><h4><b>MORE</b> <b>INFORMATION</b></h4><pre>
       The  packages relating to various DBM-related implementations (<u>DB_File</u>, <u>NDBM_File</u>, etc.) show examples of
       general tied hashes, as does the Config module. While these do not utilize <b>Tie::Hash</b>, they serve as  good
       working examples.

perl v5.40.1                                       2025-07-27                                   <u>Tie::<a href="../man3perl/Hash.3perl.html">Hash</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>