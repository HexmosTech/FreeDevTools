<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tie - Array persistence</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tie - Array persistence

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>tie</b> <b>?1.3?</b>

       <b>::tie::tie</b> <u>arrayvarname</u> <u>options</u>... <u>dstype</u> <u>dsname</u>...

       <b>::tie::untie</b> <u>arrayvarname</u> ?<u>token</u>?

       <b>::tie::info</b> <b>ties</b> <u>arrayvarname</u>

       <b>::tie::info</b> <b>types</b>

       <b>::tie::info</b> <b>type</b> <u>dstype</u>

       <b>::tie::register</b> <u>dsclasscmd</u> <b>as</b> <u>dstype</u>

       <b>dsclasscmd</b> <u>objname</u> ?<u>dsname</u>...?

       <b>ds</b> <b>destroy</b>

       <b>ds</b> <b>names</b>

       <b>ds</b> <b>size</b>

       <b>ds</b> <b>get</b>

       <b>ds</b> <b>set</b> <u>dict</u>

       <b>ds</b> <b>unset</b> ?<u>pattern</u>?

       <b>ds</b> <b>setv</b> <u>index</u> <u>value</u>

       <b>ds</b> <b>unsetv</b> <u>index</u>

       <b>ds</b> <b>getv</b> <u>index</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>tie</b>  package  provides  a framework for the creation of persistent Tcl array variables. It should be
       noted that the provided mechanism is generic enough to also allow its usage for the distribution  of  the
       contents of Tcl arrays over multiple threads and processes, i.e. communication.

       This,  persistence  and  communication,  is accomplished by <u>tying</u>) a Tcl array variable to a <u>data</u> <u>source</u>.
       Examples of data sources are other Tcl arrays and files.

       It should be noted that a single Tcl array variable can be tied to more than one <u>data</u> <u>source</u>. It is  this
       feature  which  allows the framework to be used for communication as well. Just tie several Tcl arrays in
       many client processes to a Tcl array in a server and all changes to any of them will  be  distributed  to
       all. Less centralized variants of this are of course possible as well.

</pre><h4><b>USING</b> <b>TIES</b></h4><pre>
   <b>TIE</b> <b>API</b>
       This  section  describes  the basic API used to establish and remove ties between Tcl array variables and
       data sources. This interface is the only one a casual user has  to  be  concerned  about.  The  following
       sections about the various internal interfaces can be safely skipped.

       <b>::tie::tie</b> <u>arrayvarname</u> <u>options</u>... <u>dstype</u> <u>dsname</u>...
              This  command  establishes  a  tie  between  the  Tcl array whose name is provided by the argument
              <u>arrayvarname</u> and the <u>data</u> <u>source</u> identified by the <u>dstype</u> and its series of <u>dsname</u> arguments.  All
              changes  made  to  the  Tcl  array after this command returns will be saved to the <u>data</u> <u>source</u> for
              safekeeping (or distribution).

              The result of the command is always a token which identifies the new tie. This token can  be  used
              later to destroy this specific tie.

              varname <u>arrayvarname</u> (in)
                     The name of the Tcl array variable to connect the new tie to.

              name|command <u>dstype</u> (in)
                     This  argument  specifies the type of the <u>data</u> <u>source</u> we wish to access.  The <u>dstype</u> can be
                     one of <b>log</b>, <b>array</b>, <b>remotearray</b>, <b>file</b>, <b>growfile</b>, or <b>dsource</b>; in addition, the programmer can
                     register additional data source types.  Each <u>dstype</u> is followed by one  or  more  arguments
                     that identify the <u>data</u> <u>source</u> to which the array is to be tied.

              string <u>dsname</u> (in)
                     The  series  of <u>dsname</u> arguments coming after the <u>dstype</u> identifies the <u>data</u> <u>source</u> we wish
                     to connect to, and has to be appropriate for the chosen type.

       The command understands a number of additional  options  which  guide  the  process  of  setting  up  the
       connection between Tcl array and <u>data</u> <u>source</u>.

              <b>-open</b>  The  Tcl  array for the new tie is <u>loaded</u> from the <u>data</u> <u>source</u>, and the previously existing
                     contents of the Tcl array are erased. Care is taken to  <u>not</u>  erase  the  previous  contents
                     should the creation of the tie fail.

                     This  option  and the option <b>-save</b> exclude each other. If neither this nor option <b>-save</b> are
                     specified then this option is assumed as default.

              <b>-save</b>  The Tcl array for the new tie is <u>saved</u> to the <u>data</u>  <u>source</u>,  and  the  previously  existing
                     contents of the <u>data</u> <u>source</u> are erased.

                     This  option  and the option <b>-open</b> exclude each other. If neither this nor option <b>-open</b> are
                     specified then option <b>-open</b> is assumed as default.

              <b>-merge</b> Using this option prevents the erasure of any previously existing content  and  merges  the
                     data instead. It can be specified in conjunction with either <b>-open</b> or <b>-save</b>. They determine
                     how data existing in both Tcl array and <u>data</u> <u>source</u>, i.e duplicates, are dealt with.

                     When  used  with  <b>-open</b>  data  in  the  <u>data</u>  <u>source</u>  has  precedence.  In other words, for
                     duplicates the data in the <u>data</u> <u>source</u> is loaded into the Tcl array.

                     When used with <b>-save</b> data in the Tcl array has precedence. In other words,  for  duplicates
                     the data in the Tcl array is saved into the <u>data</u> <u>source</u>.

       <b>::tie::untie</b> <u>arrayvarname</u> ?<u>token</u>?
              This command dissolves one or more ties associated with the Tcl array named by <u>arrayvarname</u>. If no
              <u>token</u> is specified then all ties to that Tcl array are dissolved. Otherwise only the tie the token
              stands  for  is removed, if it is actually connected to the array. Trying to remove a specific tie
              not belonging to the provided array will cause an error.

              It should be noted that while severing a tie will destroy management information internal  to  the
              package the <u>data</u> <u>source</u> which was handled by the tie will not be touched, only closed.

              After  the  command  returns  none  of  changes made to the array will be saved to the <u>data</u> <u>source</u>
              anymore.

              The result of the command is an empty string.

              varname <u>arrayname</u> (in)
                     The name of a Tcl array variable which may have ties.

              handle <u>token</u> (in)
                     A handle representing a specific tie. This argument is optional.

       <b>::tie::info</b> <b>ties</b> <u>arrayvarname</u>
              This command returns a list of ties associated with the Tcl array variable named by  <u>arrayvarname</u>.
              The result list will be empty if the variable has no ties associated with it.

       <b>::tie::info</b> <b>types</b>
              This  command returns a dictionary of registered types, and the class commands they are associated
              with.

       <b>::tie::info</b> <b>type</b> <u>dstype</u>
              This command returns the fully resolved class command for a type name. This means that the command
              will follow a chain of type definitions ot its end.

   <b>STANDARD</b> <b>DATA</b> <b>SOURCE</b> <b>TYPES</b>
       This package provides the six following types as examples and standard data sources.

       <b>log</b>    This <u>data</u> <u>source</u> does not maintain any actual data,  nor  persistence.  It  does  not  accept  any
              identifying arguments. All changes are simply logged to <b>stdout</b>.

       <b>array</b>  This  <u>data</u>  <u>source</u>  uses  a  regular  Tcl array as the origin of the persistent data. It accepts a
              single identifying argument, the name of this Tcl array. All changes are mirrored to that array.

       <b>remotearray</b>
              This <u>data</u> <u>source</u> is similar to <b>array</b>. The difference is  that  the  Tcl  array  to  which  we  are
              mirroring is not directly accessible, but through a <b>send</b>-like command.

              It  accepts  three  identifying arguments, the name of the other Tcl array, the command prefix for
              the <b>send</b>-like accessor command, and an identifier for the remote entity hosting the array, in this
              order. All changes are mirrored to that array, via  the  command  prefix.  All  commands  will  be
              executed in the context of the global namespace.

              <b>send</b>-like  means  that  the  command  prefix  has  to have <b>send</b> syntax and semantics. I.e. it is a
              channel over which we can send arbitrary commands to some other entity.   The  remote  array  <u>data</u>
              <u>source</u>  however uses only the commands <b>set</b>, <b>unset</b>, <b>array</b> <b>exists</b>, <b>array</b> <b>names</b>, <b>array</b> <b>set</b>, and <b>array</b>
              <b>get</b> to retrieve and set values in the remote array.

              The command prefix and the entity id are separate to allow the data source  to  use  options  like
              <b>-async</b> when assembling the actual commands.

              Examples of command prefixes, listed with the id of the remote entity, without options. In reality
              only the part before the id is the command prefix:

              <b>send</b> <u>tkname</u>
                     The Tcl array is in a remote interpreter and is accessed via Tk's X communication.

              <b>comm::comm</b> <b>send</b> <u>hostportid</u>
                     The Tcl array is in a remote interpreter and is accessed through a socket.

              <b>thread::send</b> <u>threadid</u>
                     The Tcl array is in a remote interpreter in a different thread of this process.

       <b>file</b>   This  <u>data</u>  <u>source</u>  uses  a  single  file  as  origin  of the persistent data. It accepts a single
              identifying argument, the path to this file. The file has to be both readable and writable. It may
              not exist, the <u>data</u> <u>source</u> will create it in that  case.  This  (and  only  this)  situation  will
              require that the directory for the file exists and is writable as well.

              All  changes  are  saved  in the file, as proper Tcl commands, one command per operation. In other
              words, the file will always contain a proper Tcl script.

              If the file exists when the tie using it is set up, then it will be  compacted,  i.e.  superfluous
              operations  are removed, if the operations log stored in it contains either at least one operation
              clearing the whole array, or at least 1.5 times more operations than entries in the loaded array.

       <b>growfile</b>
              This <u>data</u> <u>source</u> is like <b>file</b> in terms of the storage medium for the array data,  and  how  it  is
              configured.  In  constrast  to  the former it however assumes and ensures that the tied array will
              never shrink. I.e. the creation of new array entries, and the modification of existing entries  is
              allowed, but the deletion of entries is not, and causes the data source to throw errors.

              This restriction allows us to simplify both file format and access to the file radically. For one,
              the  file  is read only once and the internal cache cannot be invalidated. Second, writing data is
              reduced to a simple append, and no compaction step is necessary. The format of the contents is the
              string representation of a dictionary which can be incrementally extended forever at the end.

       <b>dsource</b>
              This <u>data</u> <u>source</u> uses an explicitly specified <u>data</u> <u>source</u> <u>object</u> as the source for the  persistent
              data. It accepts a single identifying argument, the command prefix, i.e. object command.

              To  use  this  type  it  is  necessary to know how the framework manages ties and what <b>data</b> <b>source</b>
              <b>objects</b> are.

              All changes are delegated to the specified object.

</pre><h4><b>CREATING</b> <b>NEW</b> <b>DATA</b> <b>SOURCES</b></h4><pre>
       This section is of no interest to the casual user of ties. Only developers wishing  to  create  new  data
       sources have to know the information provided herein.

   <b>DATA</b> <b>SOURCE</b> <b>OBJECTS</b>
       All  ties  are represented internally by an in-memory object which mediates between the tie framework and
       the specific <u>data</u> <u>source</u>, like an array, file, etc.  This is the <u>data</u> <u>source</u> <u>object</u>.

       Its class, the <b>data</b> <b>source</b> <b>class</b> is <u>not</u> generic, but specific to the type of the <u>data</u> <u>source</u>.  Writing  a
       new  <u>data</u>  <u>source</u>  requires us to write such a class, and then registering it with the framework as a new
       type.

       The following subsections describe the various APIs a <b>data</b> <b>source</b> <b>class</b> and the objects it generates will
       have to follow to be compatible with the tie framework.

       Data source objects are normally automatically created and destroyed by  the  framework  when  a  tie  is
       created,  or removed. This management can be explicitly bypassed through the usage of the "dsource" type.
       The <u>data</u> <u>source</u> for this type is a <u>data</u> <u>source</u> <u>object</u> itself, and this object is outside of the scope  of
       the  tie  framework  and  not managed by it.  In other words, this type allows the creation of ties which
       talk to pre-existing <u>data</u> <u>source</u> <u>object</u>s, and these objects will survive the removal of  the  ties  using
       them as well.

   <b>REGISTERING</b> <b>A</b> <b>NEW</b> <b>DATA</b> <b>SOURCE</b> <b>CLASS</b>
       After  a  <b>data</b>  <b>source</b>  <b>class</b>  has  been  written  it  is necessary to register it as a new type with the
       framework.

       <b>::tie::register</b> <u>dsclasscmd</u> <b>as</b> <u>dstype</u>
              Using this command causes the tie framework to remember the class command  <u>dsclasscmd</u>  of  a  <b>data</b>
              <b>source</b> <b>class</b> under the type name <u>dstype</u>.

              After  the  call  the argument <u>dstype</u> of the basic user command <b>::tie::tie</b> will accept <u>dstype</u> as a
              type name and translate it internally to the appropriate class command for the  creation  of  <b>data</b>
              <b>source</b> <b>objects</b> for the new <u>data</u> <u>source</u>.

   <b>DATA</b> <b>SOURCE</b> <b>CLASS</b>
       Each  data  source  class  is  represented  by a single command, also called the <u>class</u> <u>command</u>, or <u>object</u>
       <u>creation</u> <u>command</u>. Its syntax is

       <b>dsclasscmd</b> <u>objname</u> ?<u>dsname</u>...?
              The first argument of the class command is the name of the <u>data</u>  <u>source</u>  <u>object</u>  to  create.   The
              framework  itself  will  always  supply the string <b>%AUTO%</b>, to signal that the class command has to
              generate not only the object, but the object name as well.

              This is followed by a series of arguments identifying the data source the new object is for. These
              are the same <u>dsname</u> arguments which are given to the basic user command <b>::tie::tie</b>.  Their  actual
              meaning is dependent on the <u>data</u> <u>source</u> <u>class</u>.

              The  result of the class command has to be the fully-qualified name of the new <u>data</u> <u>source</u> <u>object</u>,
              i.e. the name of the <u>object</u> <u>command</u>.  The interface this command has to follow is described in the
              section <b>DATA</b> <b>SOURCE</b> <b>OBJECT</b> <b>API</b>

   <b>DATA</b> <b>SOURCE</b> <b>OBJECT</b> <b>API</b>
       Please read the section <b>DATA</b> <b>SOURCE</b> <b>CLASS</b> first, to know how to generate new <u>object</u> <u>commands</u>.

       Each <u>object</u> <u>command</u> for a <u>data</u> <u>source</u> object has to provide at least the methods listed below for  proper
       inter-operation  with the tie framework. Note that the names of most of the methods match the subcommands
       of the builtin <b>array</b> command.

       <b>ds</b> <b>destroy</b>
              This method is called when the object <b>ds</b> is destroyed. It now has  to  release  all  its  internal
              resources associated with the external data source.

       <b>ds</b> <b>names</b>
              This  command  has  to return a list containing the names of all keys found in the <u>data</u> <u>source</u> the
              object talks to. This is equivalent to <b>array</b> <b>names</b>.

       <b>ds</b> <b>size</b>
              This command has to return an integer number specifying the number  of  keys  found  in  the  <u>data</u>
              <u>source</u> the object talks to. This is equivalent to <b>array</b> <b>size</b>.

       <b>ds</b> <b>get</b> This  command  has  to return a dictionary containing the data found in the <u>data</u> <u>source</u> the object
              talks to. This is equivalent to <b>array</b> <b>get</b>.

       <b>ds</b> <b>set</b> <u>dict</u>
              This command takes a dictionary and adds its contents to the data source the object talks to. This
              is equivalent to <b>array</b> <b>set</b>.

       <b>ds</b> <b>unset</b> ?<u>pattern</u>?
              This command takes a pattern and removes all elements whose keys matching it from the <u>data</u> <u>source</u>.
              If no pattern is specified it defaults to <b>*</b>, causing the removal of all elements. This  is  nearly
              equivalent to <b>array</b> <b>unset</b>.

       <b>ds</b> <b>setv</b> <u>index</u> <u>value</u>
              This command has to save the <u>value</u> in the <u>data</u> <u>source</u> the object talks to, under the key <u>index</u>.

              The  result of the command is ignored. If an error is thrown then this error will show up as error
              of the set operation which caused the method call.

       <b>ds</b> <b>unsetv</b> <u>index</u>
              This command has to remove the value under the key <u>index</u> from the <u>data</u> <u>source</u> the object talks to.

              The result of the command is ignored. If an error is thrown then this error will show up as  error
              of the unset operation which caused the method call.

       <b>ds</b> <b>getv</b> <u>index</u>
              This command has to return the value for the key <u>index</u> in the <u>data</u> <u>source</u> the object talks to.

       And  here  a  small  table comparing the <u>data</u> <u>source</u> methods to the regular Tcl commands for accessing an
       array.

                      Regular Tcl             Data source
                      -----------             -----------
                      array names a           ds names
                      array size  a           ds size
                      array get   a           ds get
                      array set   a dict      ds set   dict
                      array unset a pattern   ds unset ?pattern?
                      -----------             -----------
                      set a($idx) $val        ds setv   idx val
                      unset a($idx)           ds unsetv idx
                      $a($idx)                ds getv   idx
                      -----------             -----------

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the category <u>tie</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       array, database, file, metakit, persistence, tie, untie

</pre><h4><b>CATEGORY</b></h4><pre>
       Programming tools

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2004-2021 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.3                                             <u><a href="../man3tcl/tie.3tcl.html">tie</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>