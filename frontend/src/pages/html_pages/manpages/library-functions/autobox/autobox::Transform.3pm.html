<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>autobox::Transform - Autobox methods to transform Arrays and Hashes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libautobox-transform-perl">libautobox-transform-perl_1.035-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       autobox::Transform - Autobox methods to transform Arrays and Hashes

</pre><h4><b>CONTEXT</b></h4><pre>
       autobox provides the ability to call methods on native types, e.g. strings, arrays, and hashes as if they
       were objects.

       autobox::Core provides the basic methods for Perl core functions like "uc", "map", and "grep".

       This module, "autobox::Transform", provides higher level and more specific methods to transform and
       manipulate arrays and hashes, in particular when the values are hashrefs or objects.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use autobox::Core;  # map, uniq, sort, join, sum, etc.
           use autobox::Transform;

   <b>Arrays</b>
           # use autobox::Core for -&gt;map etc.

           # filter (like a more versatile grep)
           $book_locations-&gt;filter(); # true values
           $books-&gt;filter(sub { $_-&gt;is_in_library($library) });
           $book_names-&gt;filter( qr/lord/i );
           $book_genres-&gt;filter("scifi");
           $book_genres-&gt;filter({ fantasy =&gt; 1, scifi =&gt; 1 }); # hash key exists

           # reject: the inverse of filter
           $book_genres-&gt;reject("fantasy");

           # order (like a more succinct sort)
           $book_genres-&gt;order;
           $book_genres-&gt;order("desc");
           $book_prices-&gt;order([ "num", "desc" ]);
           $books-&gt;order([ sub { $_-&gt;{price} }, "desc", "num" ]);
           $log_lines-&gt;order([ num =&gt; qr/pid: "(\d+)"/ ]);
           $books-&gt;order(
               [ sub { $_-&gt;{price} }, "desc", "num" ] # first price
               sub { $_-&gt;{name} },                    # then name
           );

           # group (aggregate) array into hash
           $book_genres-&gt;group;       # "Sci-fi" =&gt; "Sci-fi"
           $book_genres-&gt;group_count; # "Sci-fi" =&gt; 3
           $book_genres-&gt;group_array; # "Sci-fi" =&gt; [ "Sci-fi", "Sci-fi", "Sci-fi"]

           # Flatten arrayrefs-of-arrayrefs
             $authors-&gt;map_by("books") # -&gt;books returns an arrayref
             # [ [ $book1, $book2 ], [ $book3 ] ]
             $authors-&gt;map_by("books")-&gt;flat;
             # [ $book1, $book2, $book3 ]

           # Return reference, even in list context, e.g. in a parameter list
           $book_locations-&gt;filter()-&gt;to_ref;

           # Return array, even in scalar context
           @books-&gt;to_array;

           # Turn paired items into a hash
           @titles_books-&gt;to_hash;

   <b>Arrays</b> <b>where</b> <b>the</b> <b>items</b> <b>are</b> <b>hashrefs/objects</b>
           # $books and $authors below are arrayrefs with either objects or
           # hashrefs (the call syntax is the same). These have methods/hash
           # keys like C&lt;$book-&gt;genre()&gt;, C&lt;$book-&gt;{is_in_stock}&gt;,
           # C&lt;$book-&gt;is_in_library($library)&gt;, etc.

           $books-&gt;map_by("genre");
           $books-&gt;map_by([ price_with_tax =&gt; $tax_pct ]);

           $books-&gt;filter_by("is_in_stock");
           $books-&gt;filter_by([ is_in_library =&gt; $library ]);
           $books-&gt;filter_by([ price_with_tax =&gt; $rate ], sub { $_ &gt; 56.00 });
           $books-&gt;filter_by("price", sub { $_ &gt; 56.00 });
           $books-&gt;filter_by("author", "James A. Corey");
           $books-&gt;filter_by("author", qr/corey/i);

           # grep_by is an alias for filter_by
           $books-&gt;grep_by("is_in_stock");

           # reject_by: the inverse of filter_by
           $books-&gt;reject_by("is_sold_out");

           $books-&gt;uniq_by("id");

           $books-&gt;order_by("name");
           $books-&gt;order_by(name =&gt; "desc");
           $books-&gt;order_by(price =&gt; "num");
           $books-&gt;order_by(price =&gt; [ "num", "desc" ]);
           $books-&gt;order_by(name =&gt; [ sub { uc($_) }, "desc" ]);
           $books-&gt;order_by([ price_with_tax =&gt; $rate ] =&gt; "num");
           $books-&gt;order_by(
               author =&gt; "str",             # first by author
               price  =&gt; [ "num", "desc" ], # then by price, most expensive first
           );
           $books-&gt;order_by(
               author                      =&gt; [ "desc", sub { uc($_) } ],
               [ price_with_tax =&gt; $rate ] =&gt; [ "num", "desc" ],
               "name",
           );

           $books-&gt;group_by("title"),
           # {
           #     "Leviathan Wakes"       =&gt; $books-&gt;[0],
           #     "Caliban's War"         =&gt; $books-&gt;[1],
           #     "The Tree-Body Problem" =&gt; $books-&gt;[2],
           #     "The Name of the Wind"  =&gt; $books-&gt;[3],
           # },

           $authors-&gt;group_by([ publisher_affiliation =&gt; "with" ]),
           # {
           #     'James A. Corey with Orbit'     =&gt; $authors-&gt;[0],
           #     'Cixin Liu with Head of Zeus'   =&gt; $authors-&gt;[1],
           #     'Patrick Rothfuss with Gollanz' =&gt; $authors-&gt;[2],
           # },

           $books-&gt;group_by_count("genre"),
           # {
           #     "Sci-fi"  =&gt; 3,
           #     "Fantasy" =&gt; 1,
           # },

           my $genre_books = $books-&gt;group_by_array("genre");
           # {
           #     "Sci-fi"  =&gt; [ $sf_book_1, $sf_book_2, $sf_book_3 ],
           #     "Fantasy" =&gt; [ $fantasy_book_1 ],
           # },

   <b>Hashes</b>
           # map over each pair
           # e.g. Upper-case the genre name, and make the count say "n books"
           #     (return a key =&gt; value pair)
           $genre_count-&gt;map_each(sub { uc( $_[0] ) =&gt; "$_ books" });
           # {
           #     "FANTASY" =&gt; "1 books",
           #     "SCI-FI"  =&gt; "3 books",
           # },

           # map over each value
           # e.g. Make the count say "n books"
           #     (return the new value)
           $genre_count-&gt;map_each_value(sub { "$_ books" });
           # {
           #     "Fantasy" =&gt; "1 books",
           #     "Sci-fi"  =&gt; "3 books",
           # },

           # map each pair into an array
           # e.g. Transform each pair to the string "n: genre"
           #     (return list of items)
           $genre_count-&gt;map_each_to_array(sub { "$_: $_[0]" });
           # [ "1: Fantasy", "3: Sci-fi" ]

           # filter each pair
           # Genres with more than five books
           $genre_count-&gt;filter_each(sub { $_ &gt; 5 });

           # filter out each pair
           # Genres with more than five books
           $genre_count-&gt;reject_each(sub { $_ &lt;= 5 });

           # Return reference, even in list context, e.g. in a parameter list
           %genre_count-&gt;to_ref;

           # Return hash, even in scalar context
           $author-&gt;book_count-&gt;to_hash;

           # Turn key-value pairs into an array
           %isbn__book-&gt;to_array;

   <b>Combined</b> <b>examples</b>
           my $order_authors = $order-&gt;books
               -&gt;filter_by("title", qr/^The/)
               -&gt;uniq_by("isbn")
               -&gt;map_by("author")
               -&gt;uniq_by("name")
               -&gt;order_by(publisher =&gt; "str", name =&gt; "str")
               -&gt;map_by("name")-&gt;uniq-&gt;join(", ");

           my $total_order_amount = $order-&gt;books
               -&gt;reject_by("is_sold_out")
               -&gt;filter_by([ covered_by_vouchers =&gt; $vouchers ], sub { ! $_ })
               -&gt;map_by([ price_with_tax =&gt; $tax_pct ])
               -&gt;sum;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "autobox::Transform" provides high level autobox methods you can call on arrays, arrayrefs, hashes and
       hashrefs.

   <b>Transforming</b> <b>lists</b> <b>of</b> <b>objects</b> <b>vs</b> <b>list</b> <b>of</b> <b>hashrefs</b>
       "map_by", "filter_by" "order_by" etc. (all methods named *_by) work with sets of hashrefs or objects.

       These methods are called the same way regardless of whether the array contains objects or hashrefs. The
       items in the list must be either all objects or all hashrefs.

       If the array contains hashrefs, the hash key is looked up on each item.

       If the array contains objects, a method is called on each object (possibly with the arguments provided).

       <u>Calling</u> <u>accessor</u> <u>methods</u> <u>with</u> <u>arguments</u>

       For method calls, it's possible to provide arguments to the method.

       Consider "map_by":

           $array-&gt;map_by($accessor)

       If the $accessor is a string, it's a simple method call.

           # method call without args
           $books-&gt;map_by("price")
           # becomes $_-&gt;price() or $_-&gt;{price}

       If the $accessor is an arrayref, the first item is the method name, and the rest of the items are the
       arguments to the method.

           # method call with args
           $books-&gt;map_by([ price_with_discount =&gt; 5.0 ])
           # becomes $_-&gt;price_with_discount(5.0)

   <b>Filter</b> <b>predicates</b>
       There are several methods that filter items, e.g. "@array-&gt;filter" (duh), "@array-&gt;filter_by", and
       "%hash-&gt;filter_each". These methods take a $predicate argument to determine which items to retain or
       filter out.

       The "reject" family of methods do the opposite, and <u>filter</u> <u>out</u> items that match the predicate, i.e. the
       opposite of the filter methods.

       If $predicate is an <u>unblessed</u> <u>scalar</u>, it is compared to each value with "string eq".

           $books-&gt;filter_by("author", "James A. Corey");

       If $predicate is a <u>regex</u>, it is compared to each value with "=~".

           $books-&gt;reject_by("author", qr/Corey/);

       If $predicate is a <u>hashref</u>, values in @array are retained if the $predicate hash key "exists" (the hash
       values are irrelevant).

           $books-&gt;filter_by(
               "author", {
                   "James A. Corey"   =&gt; undef,
                   "Cixin Liu"        =&gt; 0,
                   "Patrick Rothfuss" =&gt; 1,
               },
           );

       If $predicate is a <u>subref</u>, the subref is called for each value to check whether this item should remain
       in the list.

       The $predicate subref should return a true value to remain. $_ is set to the current $value.

           $authors-&gt;filter_by(publisher =&gt; sub { $_-&gt;name =~ /Orbit/ });

   <b>Sorting</b> <b>using</b> <b>order</b> <b>and</b> <b>order_by</b>
       Let's first compare how sorting is done with Perl's "sort" and autobox::Transform's "order"/"order_by".

       <u>Sorting</u> <u>with</u> <u>sort</u>

       •   provide a sub that returns the comparison outcome of two values: $a and $b

       •   in case of a tie, provide another comparison of $a and $b

           # If the name is the same, compare age (oldest first)
           sort {
               uc( $a-&gt;{name} ) cmp uc( $b-&gt;{name} )           # first comparison
               ||
               int( $b-&gt;{age} / 10 ) &lt;=&gt; int( $a-&gt;{age} / 10 ) # second comparison
           } @users

       (note the opposite order of $a and $b for the age comparison, something that's often difficult to discern
       at a glance)

       <u>Sorting</u> <u>with</u> <u>order,</u> <u>order_by</u>

       •   Provide order options for how one value should be compared with the others:

           •       how to compare ("cmp" or "&lt;=&gt;")

           •       which direction to sort ("asc"ending or "desc"ending)

           •       which value to compare, using a regex or subref, e.g. by "uc($_)"

       •   In case of a tie, provide another comparison

           # If the name is the same, compare age (oldest first)

           # -&gt;order
           @users-&gt;order(
               sub { uc( $_-&gt;{name} ) },                         # first comparison
               [ "num", sub { int( $_-&gt;{age} / 10 ) }, "desc" ], # second comparison
           )

           # -&gt;order_by
           @users-&gt;order_by(
               name =&gt; sub { uc },                                # first comparison
               age  =&gt; [ num =&gt; desc =&gt; sub { int( $_ / 10 ) } ], # second comparison
           )

       <u>Comparison</u> <u>Options</u>

       If  there's  only one option for a comparison (e.g. "num"), provide a single option (string/regex/subref)
       value. If there are many options, provide them in an arrayref in any order.

       <u>Comparison</u> <u>operator</u>

       •   "str" (cmp) - default

       •   "num" (&lt;=&gt;)

       <u>Sort</u> <u>order</u>

       •   "asc" (ascending) - default

       •   "desc" (descending)

       <u>The</u> <u>value</u> <u>to</u> <u>compare</u>

       •   A subref - default is: "sub { $_ }"

           •       The return value is used in the comparison

       •   A regex, e.g. "qr/id: (\d+)/"

           •       The value of "join("", @captured_groups)" are used in the  comparison  (@captured_groups  are
                   $1, $2, $3 etc.)

       <u>Examples</u> <u>of</u> <u>a</u> <u>single</u> <u>comparison</u>

           # order: the first arg is the comparison options (one or an
           # arrayref with many options)
           -&gt;order()  # Defaults to str, asc, $_, just like sort
           -&gt;order("num")
           -&gt;order(sub { uc($_) })
           # compare captured matches, e.g. "John" and "Doe" as "JohnDoe"
           -&gt;order( qr/first_name: (\w+), last_name: (\w+)/ )
           -&gt;order([ num =&gt; qr/id: (\d+)/ ])
           -&gt;order([ sub { int($_) }, "num" ])

           # order_by: the first arg is the accessor, just like with
           # map_by. Second arg is the comparison options (one or an arrayref
           # with many options)
           -&gt;order_by("id")
           -&gt;order_by("id", "num")
           -&gt;order_by("id", [ "num", "desc" ])
           -&gt;order_by("name", sub { uc($_) })
           -&gt;order_by(log_line =&gt; qr/first_name: (\w+), last_name: (\w+)/ )
           -&gt;order_by("log_line", [ num =&gt; qr/id: (\d+)/ ])
           -&gt;order_by(age =&gt; [ sub { int($_) }, "num" ])

           # compare int( $a-&gt;<a href="../man10/age_by_interval.10.html">age_by_interval</a>(10) )
           -&gt;order_by([ age_by_interval =&gt; 10 ] =&gt; [ sub { int($_) }, "num" ])
           # compare uc( $a-&gt;name_with_title($title) )
           -&gt;order_by([ name_with_title =&gt; $title ], sub { uc($_) })

       <u>Examples</u> <u>of</u> <u>fallback</u> <u>comparisons</u>

       When the first comparison is a tie, the subsequent ones are used.

           # order: list of comparison options (one or an arrayref with many
           # options, per comparison)
           -&gt;order(
               [ sub { $_-&gt;{price} }, "num" ], # First a numeric comparison of price
               [ sub { $_-&gt;{name} }, "desc" ], # or if same, a reverse comparison of the name
           )
           -&gt;order(
               [ sub { uc($_) }, "desc" ],
               "str",
           )
           -&gt;order(
               qr/type: (\w+)/,
               [ num =&gt; desc =&gt; qr/duration: (\d+)/ ]
               [ num =&gt; sub { /id: (\d+)/ } ],
               "str",
           )

           # order_by: pairs of accessor-comparison options
           -&gt;order_by(
               price =&gt; "num", # First a numeric comparison of price
               name =&gt; "desc", # or if same, a reverse comparison of the name
           )
           -&gt;order_by(
               price =&gt; [ "num", "desc" ],
               name  =&gt; "str",
           )
           # accessor is a method call with arg: $_-&gt;price_with_discount($discount)
           -&gt;order_by(
               [ price_with_discount =&gt; $discount ] =&gt; [ "num", "desc" ],
               name                                 =&gt; [ str =&gt; sub { uc($_) } ],
               "id",
           )

   <b>List</b> <b>and</b> <b>Scalar</b> <b>Context</b>
       Almost  all of the methods are context sensitive, i.e. they return a list in list context and an arrayref
       in scalar context, just like autobox::Core.

       <b>Beware</b>: <u>you</u> <u>might</u> <u>be</u> <u>in</u> <u>list</u> <u>context</u> <u>when</u> <u>you</u> <u>need</u> <u>an</u> <u>arrayref.</u>

       When in doubt, assume they work like "map" and "grep" (i.e. return a list), and convert the return  value
       to references where you might have an non-obvious list context. E.g.

       <u>Incorrect</u>

           $self-&gt;my_method(
               # Wrong, this is list context and wouldn't return an array ref
               books =&gt; $books-&gt;filter_by("is_published"),
           );

       <u>Correct</u>

           $self-&gt;my_method(
               # Correct, put the returned list in an anonymous array ref
               books =&gt; [ $books-&gt;filter_by("is_published") ],
           );
           $self-&gt;my_method(
               # Correct, ensure scalar context to get an array ref
               books =&gt; scalar $books-&gt;filter_by("is_published"),
           );

           # Probably the nicest, since -&gt;to_ref goes at the end
           $self-&gt;my_method(
               # Correct, use -&gt;to_ref to ensure an array ref is returned
               books =&gt; $books-&gt;filter_by("is_published")-&gt;to_ref,
           );

</pre><h4><b>METHODS</b> <b>ON</b> <b>ARRAYS</b></h4><pre>
   <b>@array-&gt;filter($predicate</b> <b>=</b> <b>*is_true_subref*)</b> <b>:</b> <b>@array</b> <b>|</b> <b>@$array</b>
       Similar to Perl's "grep", return an @array with values for which $predicate yields a true value.

       $predicate can be a subref, string, undef, regex, or hashref. See "Filter predicates".

       The default (no $predicate) is a subref which retains true values in the @array.

       <u>Examples</u>

           my @apples     = $fruit-&gt;filter("apple");
           my @any_apple  = $fruit-&gt;filter( qr/apple/i );
           my @publishers = $authors-&gt;filter(
               sub { $_-&gt;publisher-&gt;name =~ /Orbit/ },
           );

       <u>filter</u> <u>and</u> <u>grep</u>

       autobox::Core's  "grep"  method  takes  a subref, just like this method. "filter" also supports the other
       predicate types, like string, regex, etc.

   <b>@array-&gt;reject($predicate</b> <b>=</b> <b>*is_false_subref*)</b> <b>:</b> <b>@array</b> <b>|</b> <b>@$array</b>
       Similar to the Unix command "grep -v", return an @array with values for which $predicate yields  a  <u>false</u>
       value.

       $predicate can be a subref, string, undef, regex, or hashref. See "Filter predicates".

       The default (no $predicate) is a subref which <u>filters</u> <u>out</u> true values in the @array.

       Examples:

           my @apples     = $fruit-&gt;reject("apple");
           my @no_apples  = $fruit-&gt;reject( qr/apple/i );
           my @publishers = $authors-&gt;reject(
               sub { $_-&gt;publisher-&gt;name =~ /Orbit/ },
           );

   <b>@array-&gt;order(@comparisons</b> <b>=</b> <b>("str"))</b> <b>:</b> <b>@array</b> <b>|</b> <b>@$array</b>
       Return  @array  ordered  according to the @comparisons. The default comparison is the same as the default
       sort, e.g. a normal string comparison of the @array values.

       If the first item in @comparison ends in a tie, the next one is used, etc.

       Each <u>comparison</u> consists of a single <u>option</u> or an <u>arrayref</u> <u>of</u> <u>options</u>, e.g. "str"/"num", "asc"/"desc", or
       a subref/regex. See "Sorting using order and order_by" for details about how these work.

       Examples:

           @book_genres-&gt;order;
           @book_genres-&gt;order("desc");
           @book_prices-&gt;order([ "num", "desc" ]);
           @books-&gt;order([ sub { $_-&gt;{price} }, "desc", "num" ]);
           @log_lines-&gt;order([ num =&gt; qr/pid: "(\d+)"/ ]);
           @books-&gt;order(
               [ sub { $_-&gt;{price} }, "desc", "num" ] # first price
               sub { $_-&gt;{name} },                    # then name
           );

   <b>@array-&gt;group($value_subref</b> <b>=</b> <b>item)</b> <b>:</b> <b>%key_value</b> <b>|</b> <b>%$key_value</b>
       Group the @array items into a hashref with the items as keys.

       The default $value_subref puts each item in the list as the hash value. If the key is repeated, the value
       is overwritten with the last object.

       Example:

           my $title_book = $book_titles-&gt;group;
           # {
           #     "Leviathan Wakes"       =&gt; "Leviathan Wakes",
           #     "Caliban's War"         =&gt; "Caliban's War",
           #     "The Tree-Body Problem" =&gt; "The Tree-Body Problem",
           #     "The Name of the Wind"  =&gt; "The Name of the Wind",
           # },

       <u>The</u> <u>$value_subref</u>

       For simple cases of just grouping a single key to a single value, the $value_subref is straightforward to
       use.

       The hash key is the array item. The hash value is whatever is returned from

           my $new_value = $value_sub-&gt;($current_value, $object, $key);

       •   $current value is the current hash value for this key (or undef if the first one).

       •   $object is the current item in the list. The current $_ is also set to this.

       •   $key is the array item.

       See also: "-&gt;group_by".

   <b>@array-&gt;group_count</b> <b>:</b> <b>%key_count</b> <b>|</b> <b>%$key_count</b>
       Just like "group", but the hash values are the the number of instances each item occurs in the list.

       Example:

           $book_genres-&gt;group_count;
           # {
           #     "Sci-fi"  =&gt; 3,
           #     "Fantasy" =&gt; 1,
           # },

       There are three books counted for the "Sci-fi" key.

   <b>@array-&gt;group_array</b> <b>:</b> <b>%key_objects</b> <b>|</b> <b>%$key_objects</b>
       Just like "group", but the hash values are arrayrefs containing those same array items.

       Example:

           $book_genres-&gt;group_array;
           # {
           #     "Sci-fi"  =&gt; [ "Sci-fi", "Sci-fi", "Sci-fi" ],
           #     "Fantasy" =&gt; [ "Fantasy" ],
           # },

       The three Sci-fi genres are collected under the Sci-fi key.

   <b>@array-&gt;flat()</b> <b>:</b> <b>@array</b> <b>|</b> <b>@$array</b>
       Return a (one level) flattened array, assuming the array items themselves are array refs. I.e.

           [
               [ 1, 2, 3 ],
               [ "a", "b" ],
               [ [ 1, 2 ], { 3 =&gt; 4 } ]
           ]-&gt;flat

       returns

           [ 1, 2, 3, "a", "b ", [ 1, 2 ], { 3 =&gt; 4 } ]

       This is useful if e.g. a "-&gt;map_by("some_method")" returns arrayrefs of objects  which  you  want  to  do
       further method calls on. Example:

           # -&gt;books returns an arrayref of Book objects with a -&gt;title
           $authors-&gt;map_by("books")-&gt;flat-&gt;map_by("title")

       Note:  This  is  different from autobox::Core's "-&gt;flatten", which reurns a list rather than an array and
       therefore can't be used in this way.

   <b>@array-&gt;to_ref()</b> <b>:</b> <b>$arrayref</b>
       Return the reference to the @array, regardless of context.

       Useful for ensuring the last array method return a reference while in scalar context. Typically:

           do_stuff(
               books =&gt; $author-&gt;map_by("books")-&gt;to_ref,
           );

       map_by is called in list context, so without "-&gt;to_ref" it would have return an array, not an arrayref.

   <b>@array-&gt;to_array()</b> <b>:</b> <b>@array</b>
       Return the @array, regardless of context. This is mostly useful if called on a ArrayRef at the end  of  a
       chain of method calls.

   <b>@array-&gt;to_hash()</b> <b>:</b> <b>%hash</b> <b>|</b> <b>%$hash</b>
       Return the item pairs in the @array as the key-value pairs of a %hash (context sensitive).

       Useful if you need to continue calling %hash methods on it.

       Die if there aren't an even number of items in @array.

</pre><h4><b>METHODS</b> <b>ON</b> <b>ARRAYS</b> <b>CONTAINING</b> <b>OBJECTS/HASHES</b></h4><pre>
   <b>@array-&gt;map_by($accessor)</b> <b>:</b> <b>@array</b> <b>|</b> <b>@$array</b>
       $accessor is either a string, or an arrayref where the first item is a string.

       Call the $accessor on each object in @array, or get the hash key value on each hashref in @array. Like:

           map { $_-&gt;$accessor() } @array
           # or
           map { $_-&gt;{$accessor} } @array

       Examples:

           my @author_names = $authors-&gt;map_by("name");
           my $author_names = @publishers-&gt;map_by("authors")-&gt;flat-&gt;map_by("name");

       Or get the hash key value. Example:

           my @review_scores = $reviews-&gt;map_by("score");

       Alternatively  for  when @array contains objects, the $accessor can be an arrayref. The first item is the
       method name, and the rest of the items are passed as args in the method call. This obviously  won't  work
       when the @array contains hashrefs.

       Examples:

           my @prices_including_tax = $books-&gt;map_by([ "price_with_tax", $tax_pct ]);
           my $prices_including_tax = $books-&gt;map_by([ price_with_tax =&gt; $tax_pct ]);

   <b>@array-&gt;filter_by($accessor,</b> <b>$predicate</b> <b>=</b> <b>*is_true_subref*)</b> <b>:</b> <b>@array</b> <b>|</b> <b>@$array</b>
       $accessor is either a string, or an arrayref where the first item is a string.

       Call the $accessor on each object in the list, or get the hash key value on each hashref in the list.

       Example:

           my @prolific_authors = $authors-&gt;filter_by("is_prolific");

       Alternatively  the  $accessor  is  an  arrayref. The first item is the accessor name, and the rest of the
       items are passed as args the method call. This only works when working with objects, not with hashrefs.

       Example:

           my @books_to_charge_for = $books-&gt;filter_by([ price_with_tax =&gt; $tax_pct ]);

       Use the $predicate to determine whether the value should remain.  $predicate can  be  a  subref,  string,
       undef, regex, or hashref. See "Filter predicates".

       The default (no $predicate) is a subref which retains true values in the result @array.

       Examples:

           # Custom predicate subref
           my @authors = $authors-&gt;filter_by(
               "publisher",
               sub { $_-&gt;name =~ /Orbit/ },
           );

           # Call method with args and match a regex
           my @authors = $authors-&gt;filter_by(
               [ publisher_affiliation =&gt; "with" ],
               qr/Orbit/ },
           );

       Note:  if  you do something complicated with a $predicate subref, it might be easier and more readable to
       simply use "$array-$&lt;gt"<b>filter()</b>&gt;.

       <u>Alias</u>

       "grep_by" is an alias for "filter_by". Unlike "grep" vs "filter", this one works exaclty the same way.

   <b>@array-&gt;reject_by($accessor,</b> <b>$predicate</b> <b>=</b> <b>*is_false_subref*)</b> <b>:</b> <b>@array</b> <b>|</b> <b>@$array</b>
       "reject_by" is the same as "filter_by", except it <u>filters</u> <u>out</u> items that matches the $predicate.

       Example:

           my @unproductive_authors = $authors-&gt;reject_by("is_prolific");

       The default (no $predicate) is a subref which <u>filters</u> <u>out</u> true values in the result @array.

   <b>@array-&gt;uniq_by($accessor)</b> <b>:</b> <b>@array</b> <b>|</b> <b>@$array</b>
       $accessor is either a string, or an arrayref where the first item is a string.

       Call the $"accessor" on each object in the list, or get the hash key value on each hashref in  the  list.
       Return  list  of  items  which have a unique set of return values. The order is preserved. On duplicates,
       keep the first occurrence.

       Examples:

           # You have gathered multiple Author objects with duplicate ids
           my @authors = $authors-&gt;uniq_by("author_id");

       Alternatively the $accessor is an arrayref. The first item is the accessor name,  and  the  rest  of  the
       items are passed as args the method call. This only works when working with objects, not with hashrefs.

       Examples:

           my @example_book_at_price_point = $books-&gt;uniq_by(
               [ price_with_tax =&gt; $tax_pct ],
           );

   <b>@array-&gt;order_by(@accessor_comparison_pairs)</b> <b>:</b> <b>@array</b> <b>|</b> <b>@$array</b>
       Return @array ordered according to the @accessor_comparison_pairs.

       The comparison value comes from an initial "@array-"map_by($accessor)&gt; for each accessor-comparison pair.
       It  is  important  that  the $accessor call returns exactly a single scalar that can be compared with the
       other values.

       It then works just like with "-&gt;order".

           $books-&gt;order_by("name"); # default order, i.e. "str"
           $books-&gt;order_by(price =&gt; "num");
           $books-&gt;order_by(price =&gt; [ "num", "desc" ]);

       As with "map_by", if the $accessor is used on an object, the method call can include arguments.

           $books-&gt;order_by([ price_wih_tax =&gt; $tax_rate ] =&gt; "num");

       Just like with "order", the value returned by the accessor can be transformed using a sub, or be  matched
       against a regex.

           $books-&gt;order_by(price =&gt; [ num =&gt; sub { int($_) } ]);

           # Ignore leading "The" in book titles by optionally matching it
           # with a non-capturing group and the rest with a capturing group
           # paren
           $books-&gt;order_by( title =&gt; qr/^ (?: The \s+ )? (.+) /x );

       If a comparison is missing for the last pair, the default is a normal "str" comparison.

           $books-&gt;order_by("name"); # default "str"

       If  the  first  comparison  ends  in  a  tie,  the  next pair is used, etc. Note that in order to provide
       accessor-comparison pairs, it's often necessary to provide a default "str" comparison just to make  it  a
       pair.

           $books-&gt;order_by(
               author =&gt; "str",
               price  =&gt; [ "num", "desc" ],
           );

   <b>@array-&gt;group_by($accessor,</b> <b>$value_subref</b> <b>=</b> <b>object)</b> <b>:</b> <b>%key_value</b> <b>|</b> <b>%$key_value</b>
       $accessor is either a string, or an arrayref where the first item is a string.

       Call  "-&gt;$accessor"  on each object in the array, or get the hash key for each hashref in the array (just
       like "-&gt;map_by") and group the values as keys in a hashref.

       The default $value_subref puts each object in the list as the hash value. If the  key  is  repeated,  the
       value is overwritten with the last object.

       Example:

           my $title_book = $books-&gt;group_by("title");
           # {
           #     "Leviathan Wakes"       =&gt; $books-&gt;[0],
           #     "Caliban's War"         =&gt; $books-&gt;[1],
           #     "The Tree-Body Problem" =&gt; $books-&gt;[2],
           #     "The Name of the Wind"  =&gt; $books-&gt;[3],
           # },

       <u>The</u> <u>$value_subref</u>

       For simple cases of just grouping a single key to a single value, the $value_subref is straightforward to
       use.

       The hash key is whatever is returned from "$object-&gt;$accessor".

       The hash value is whatever is returned from

           my $new_value = $value_sub-&gt;($current_value, $object, $key);

       •   $current value is the current hash value for this key (or undef if the first one).

       •   $object is the current item in the list. The current $_ is also set to this.

       •   $key is the key returned by $object-&gt;$accessor(@$args)

       A  simple example would be to group by the accessor, but instead of the object used as the value you want
       to look up an attribute on each object:

           my $book_id__author = $books-&gt;group_by("id", sub { $_-&gt;author });
           # keys: book id; values: author

       If you want to create an aggregate value the $value_subref can be a bit tricky to use, so the most common
       thing would probably be to use one of the more  specific  group_by-methods  (see  below).  It  should  be
       capable enough to achieve what you need though.

   <b>@array-&gt;group_by_count($accessor)</b> <b>:</b> <b>%key_count</b> <b>|</b> <b>%$key_count</b>
       $accessor is either a string, or an arrayref where the first item is a string.

       Just  like "group_by", but the hash values are the the number of instances each $accessor value occurs in
       the list.

       Example:

           $books-&gt;group_by_count("genre"),
           # {
           #     "Sci-fi"  =&gt; 3,
           #     "Fantasy" =&gt; 1,
           # },

       "$book-&gt;genre()" returns the genre string. There are three books counted for the "Sci-fi" key.

   <b>@array-&gt;group_by_array($accessor)</b> <b>:</b> <b>%key_objects</b> <b>|</b> <b>%$key_objects</b>
       $accessor is either a string, or an arrayref where the first item is a string.

       Just like "group_by", but the hash values are arrayrefs containing the objects which has  each  $accessor
       value.

       Example:

           my $genre_books = $books-&gt;group_by_array("genre");
           # {
           #     "Sci-fi"  =&gt; [ $sf_book_1, $sf_book_2, $sf_book_3 ],
           #     "Fantasy" =&gt; [ $fantasy_book_1 ],
           # },

       $book-&gt;<b>genre()</b>  returns  the  genre  string. The three Sci-fi book objects are collected under the Sci-fi
       key.

</pre><h4><b>METHODS</b> <b>ON</b> <b>HASHES</b></h4><pre>
   <b>%hash-&gt;map_each($key_value_subref)</b> <b>:</b> <b>%new_hash</b> <b>|</b> <b>%$new_hash</b>
       Map each key-value pair in the hash using the $key_value_subref. Similar to how to how map  transforms  a
       list into another list, map_each transforms a hash into another hash.

       "$key_value_subref-&gt;($key, $value)" is called for each pair (with $_ set to the value).

       The  subref  should return an even-numbered list with zero or more key-value pairs which will make up the
       %new_hash. Typically two items are returned in the list (the key and the value).

       <u>Example</u>

           { a =&gt; 1, b =&gt; 2 }-&gt;map_each(sub { "$_[0]$_[0]" =&gt; $_ * 2 });
           # Returns { aa =&gt; 2, bb =&gt; 4 }

   <b>%hash-&gt;map_each_value($value_subref)</b> <b>:</b> <b>%new_hash</b> <b>|</b> <b>%$new_hash</b>
       Map each value in the hash using the $value_subref, but keep the keys the same.

       "$value_subref-&gt;($key, $value)" is called for each pair (with $_ set to the value).

       The subref should return a single value for each key which will make up the %new_hash (with the same keys
       but with new mapped values).

       <u>Example</u>

           { a =&gt; 1, b =&gt; 2 }-&gt;map_each_value(sub { $_ * 2 });
           # Returns { a =&gt; 2, b =&gt; 4 }

   <b>%hash-&gt;map_each_to_array($item_subref)</b> <b>:</b> <b>@new_array</b> <b>|</b> <b>@$new_array</b>
       Map each key-value pair in the hash into a list using the $item_subref.

       "$item_subref-&gt;($key, $value)" is called for each pair (with $_ set to the value) in key order.

       The subref should return zero or more list items which will make up the @new_array. Typically one item is
       returned.

       <u>Example</u>

           { a =&gt; 1, b =&gt; 2 }-&gt;map_each_to_array(sub { "$_[0]-$_" });
           # Returns [ "a-1", "b-2" ]

   <b>%hash-&gt;filter_each($predicate</b> <b>=</b> <b>*is_true_subref*)</b> <b>:</b> <b>@hash</b> <b>|</b> <b>@$hash</b>
       Return a %hash with values for which $predicate yields a true value.

       $predicate can be a subref, string, undef, regex, or hashref. See "Filter predicates".

       The default (no $predicate) is a subref which retains true values in the %hash.

       If the $predicate is a subref, "$predicate-&gt;($key, $value)" is called for each pair (with $_ set  to  the
       value).

       The subref should return a true value to retain the key-value pair in the result %hash.

       <u>Examples</u>

           { a =&gt; 1, b =&gt; 2 }-&gt;filter_each(sub { $_ == 2 });
           # Returns { b =&gt; 2 }

           $book_author-&gt;filter_each(sub { $_-&gt;name =~ /Corey/ });

   <b>%hash-&gt;reject_each($predicate</b> <b>=</b> <b>*is_false_subref*)</b> <b>:</b> <b>@hash</b> <b>|</b> <b>@$hash</b>
       "reject_each" is the same as "filter_each", except it <u>filters</u> <u>out</u> items that matches the $predicate.

       Examples:

           { a =&gt; 1, b =&gt; 2 }-&gt;reject_each(sub { $_ == 2 });
           # Returns { a =&gt; 1 }

       The default (no $predicate) is a subref which <u>filters</u> <u>out</u> true values in the %hash.

   <b>%hash-&gt;to_ref()</b> <b>:</b> <b>$hashref</b>
       Return the reference to the %hash, regardless of context.

       Useful for ensuring the last hash method return a reference while in scalar context. Typically:

           do_stuff(
               genre_count =&gt; $books-&gt;group_by_count("genre")-&gt;to_ref,
           );

   <b>%hash-&gt;to_hash()</b> <b>:</b> <b>%hash</b>
       Return  the  %hash,  regardless  of context. This is mostly useful if called on a HashRef at the end of a
       chain of method calls.

   <b>%hash-&gt;to_array()</b> <b>:</b> <b>@array</b> <b>|</b> <b>@$array</b>
       Return the key-value pairs of the %hash as an @array, ordered by the keys.

       Useful if you need to continue calling @array methods on it.

</pre><h4><b>AUTOBOX</b> <b>AND</b> <b>VANILLA</b> <b>PERL</b></h4><pre>
   <b>Raison</b> <b>d'etre</b>
       autobox::Core is awesome, for a variety of reasons.

       •   It cuts down on dereferencing punctuation clutter, both by using methods on references and  by  using
           -&gt;elements to deref arrayrefs.

       •   It makes map and grep transforms read in the same direction it's executed.

       •   It  makes it easier to write those things in a natural order. No need to move the cursor around a lot
           just to fix dereferencing, order of operations etc.

       On top of this, autobox::Transform provides a few higher level methods for mapping, filtering and sorting
       common cases which are easier to read and write.

       Since they are at a slightly higher semantic level, once you know them they also provide a more  specific
       meaning than just "map" or "grep".

       (Compare  the  difference  between seeing a "map" and seeing a "foreach" loop. Just seeing the word "map"
       hints at what type of thing is going on here: transforming a list into another list).

       The methods of "autobox::Transform" are not suitable for all cases, but when used appropriately they will
       lead to much more clear, succinct and direct code, especially in conjunction with "autobox::Core".

   <b>Code</b> <b>Comparison</b>
       These examples are only for when there's a straightforward and simple Perl equivalent.

           ### map_by - method call: $books are Book objects
           my @genres = map { $_-&gt;genre() } @$books;
           my @genres = $books-&gt;map_by("genre");

           my $genres = [ map { $_-&gt;genre() } @$books ];
           my $genres = $books-&gt;map_by("genre");

           # With sum from autobox::Core / List::AllUtils
           my $book_order_total = sum(
               map { $_-&gt;price_with_tax($tax_pct) } @{$order-&gt;books}
           );
           my $book_order_total = $order-&gt;books
               -&gt;map_by([ price_with_tax =&gt; $tax_pct ])-&gt;sum;

           ### map_by - hash key: $books are book hashrefs
           my @genres = map { $_-&gt;{genre} } @$books;
           my @genres = $books-&gt;map_by("genre");

           ### filter_by - method call: $books are Book objects
           my $sold_out_books = [ grep { $_-&gt;is_in_stock } @$books ];
           my $sold_out_books = $books-&gt;filter_by("is_in_stock");
           my $sold_out_books = $books-&gt;grep_by("is_in_stock");

           my $books_in_library = [ grep { $_-&gt;is_in_library($library) } @$books ];
           my $books_in_library = $books-&gt;filter_by([ is_in_library =&gt; $library ]);

           ### reject_by - hash key: $books are book hashrefs
           my $sold_out_books = [ grep { ! $_-&gt;{is_in_stock} } @$books ];
           my $sold_out_books = $books-&gt;reject_by("is_in_stock");

           ### uniq_by - method call: $books are Book objects
           my %seen; my $distinct_books = [ grep { ! %seen{ $_-&gt;id // "" }++ } @$books ];
           my $distinct_books = $books-&gt;uniq_by("id");

           ### uniq_by - hash key: $books are book hashrefs
           my %seen; my $distinct_books = [ grep { ! %seen{ $_-&gt;{id} // "" }++ } @$books ];
           my $distinct_books = $books-&gt;uniq_by("id");

           #### flat - $author-&gt;books returns an arrayref of Books
           my $author_books = [ map { @{$_-&gt;books} } @$authors ];
           my $author_books = $authors-&gt;map_by("books")-&gt;flat;

</pre><h4><b>DEVELOPMENT</b></h4><pre>
   <b>Author</b>
       Johan Lindstrom, "&lt;johanl [AT] cpan.org&gt;"

   <b>Source</b> <b>code</b>
       &lt;https://github.com/jplindstrom/p5-autobox-Transform&gt;

   <b>Bug</b> <b>reports</b>
       Please report any bugs or feature requests on GitHub:

       &lt;https://github.com/jplindstrom/p5-autobox-Transform/issues&gt;.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2016- Johan Lindstrom, All Rights Reserved.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.30.3                                       2020-07-30                            <u>autobox::<a href="../man3pm/Transform.3pm.html">Transform</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>