<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Mini::Document - Perl implementation of the XML::Mini Document API.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-mini-perl">libxml-mini-perl_1.38-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Mini::Document - Perl implementation of the XML::Mini Document API.

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use XML::Mini::Document;

               use Data::Dumper;

               ###### PARSING XML #######

               # create a new object
               my $xmlDoc = XML::Mini::Document-&gt;new();

               # init the doc from an XML string
               $xmlDoc-&gt;parse($XMLString);

               # You may use the toHash() method to automatically
               # convert the XML into a hash reference
               my $xmlHash = $xmlDoc-&gt;toHash();

               print Dumper($xmlHash);

               # You can also manipulate the elements like directly, like this:

               # Fetch the ROOT element for the document
               # (an instance of XML::Mini::Element)
               my $xmlRoot = $xmlDoc-&gt;getRoot();

               # play with the element and its children
               # ...
               my $topLevelChildren = $xmlRoot-&gt;getAllChildren();

               foreach my $childElement (@{$topLevelChildren})
               {
                       # ...
               }

               ###### CREATING XML #######

               # Create a new document from scratch

               my $newDoc = XML::Mini::Document-&gt;new();

               # This can be done easily by using a hash:
               my $h = {
                'spy'  =&gt; {
                       'id'    =&gt; '007',
                       'type'  =&gt; 'SuperSpy',
                       'name'  =&gt; 'James Bond',
                       'email' =&gt; '<a href="mailto:mi5@london.uk">mi5@london.uk</a>',
                       'address'       =&gt; 'Wherever he is needed most',
                       },
               };

               $newDoc-&gt;fromHash($h);

               # Or new XML can also be created by manipulating
               #elements directly:

               my $newDocRoot = $newDoc-&gt;getRoot();

               # create the &lt;? xml ?&gt; header
               my $xmlHeader = $newDocRoot-&gt;header('xml');
               # add the version
               $xmlHeader-&gt;attribute('version', '1.0');

               my $person = $newDocRoot-&gt;createChild('person');

               my $name = $person-&gt;createChild('name');
               $name-&gt;createChild('first')-&gt;text('John');
               $name-&gt;createChild('last')-&gt;text('Doe');

               my $eyes = $person-&gt;createChild('eyes');
               $eyes-&gt;attribute('color', 'blue');
               $eyes-&gt;attribute('number', 2);

               # output the document
               print $newDoc-&gt;toString();

       This example would output :

        &lt;?xml version="1.0"?&gt;
         &lt;person&gt;
          &lt;name&gt;
           &lt;first&gt;
            John
           &lt;/first&gt;
           &lt;last&gt;
            Doe
           &lt;/last&gt;
         &lt;/name&gt;
         &lt;eyes color="blue" number="2" /&gt;
         &lt;/person&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The XML::Mini::Document class is the programmer's handle to XML::Mini functionality.

       A XML::Mini::Document instance is created in every program that uses XML::Mini.  With the
       XML::Mini::Document object, you can access the root XML::Mini::Element, find/fetch/create elements and
       read in or output XML strings.

   <b>new</b> <b>[XMLSTRING]</b>
       Creates a new instance of XML::Mini::Document, optionally calling fromString with the passed XMLSTRING

   <b>getRoot</b>
       Returns a reference the this document's root element (an instance of XML::Mini::Element)

   <b>setRoot</b> <b>NEWROOT</b>
       setRoot NEWROOT Set the document root to the NEWROOT XML::Mini::Element object.

   <b>isElement</b> <b>ELEMENT</b>
       Returns a true value if ELEMENT is an instance of XML::Mini::Element, false otherwise.

   <b>isNode</b> <b>NODE</b>
       Returns a true value if NODE is an instance of XML::MiniNode, false otherwise.

   <b>createElement</b> <b>NAME</b> <b>[VALUE]</b>
       Creates a new XML::Mini::Element with name NAME.

       This element is an orphan (has no assigned parent) and will be lost unless it is appended
       (<b>XML::Mini::Element::appendChild()</b>) to an element at some point.

       If the optional VALUE (string or numeric) parameter is passed, the new element's text/numeric content
       will be set using VALUE.  Returns a reference to the newly created element.

   <b>getElement</b> <b>NAME</b> <b>[POSITON]</b>
       Searches the document for an element with name NAME.

       Returns a reference to the first XML::Mini::Element with name NAME, if found, NULL otherwise.

       NOTE: The search is performed like this, returning the first element that matches:

        - Check the Root Element's immediate children (in order) for a match.
        - Ask each immediate child (in order) to XML::Mini::Element::getElement()
         (each child will then proceed similarly, checking all it's immediate
          children in order and then asking them to getElement())

       If a numeric POSITION parameter is passed, <b>getElement()</b> will return only the POSITIONth element of name
       NAME (starting at 1).  Thus, on document

         &lt;?xml version="1.0"?&gt;
         &lt;people&gt;
          &lt;person&gt;
           bob
          &lt;/person&gt;
          &lt;person&gt;
           jane
          &lt;/person&gt;
          &lt;person&gt;
           ralph
          &lt;/person&gt;
         &lt;/people&gt;

       $people-&gt;getElement('person') will return the element containing the text node 'bob', while
       $people-&gt;getElement('person', 3) will return the element containing the text 'ralph'.

   <b>getElementByPath</b> <b>PATH</b> <b>[POSITIONARRAY]</b>
       Attempts to return a reference to the (first) element at PATH where PATH is the path in the structure
       from the root element to the requested element.

       For example, in the document represented by:

                &lt;partRateRequest&gt;
                 &lt;vendor&gt;
                  &lt;accessid user="myusername" password="mypassword" /&gt;
                 &lt;/vendor&gt;
                 &lt;partList&gt;
                  &lt;partNum&gt;
                   DA42
                  &lt;/partNum&gt;
                  &lt;partNum&gt;
                   D99983FFF
                  &lt;/partNum&gt;
                  &lt;partNum&gt;
                   ss-839uent
                  &lt;/partNum&gt;
                 &lt;/partList&gt;
                &lt;/partRateRequest&gt;

               $accessid = $xmlDocument-&gt;getElementByPath('partRateRequest/vendor/accessid');

       Will return what you expect (the accessid element with attributes user = "myusername" and password =
       "mypassword").

       BUT be careful:

               my $accessid = $xmlDocument-&gt;getElementByPath('partRateRequest/partList/partNum');

       will return the partNum element with the value "DA42".  To access other partNum elements you must either
       use the POSITIONSARRAY or the <b>getAllChildren()</b> method on the partRateRequest element.

       POSITIONSARRAY functions like the POSITION parameter to <b>getElement()</b>, but instead of specifying the
       position of a single element, you must indicate the position of all elements in the path.  Therefore, to
       get the third part number element, you would use

               my $thirdPart = $xmlDocument-&gt;getElementByPath('partRateRequest/partList/partNum', 1, 1, 3);

       The additional 1,1,3 parameters indicate that you wish to retrieve the 1st partRateRequest element in the
       document, the 1st partList child of partRateRequest and the 3rd partNum child of the partList element (in
       this instance, the partNum element that contains 'ss-839uent').

       Returns the XML::Mini::Element reference if found, NULL otherwise.

   <b>parse</b> <b>SOURCE</b>
       Initialise the XML::Mini::Document (and its root XML::Mini::Element) using the XML from file SOURCE.

       SOURCE may be a string containing your XML document.

       In addition to parsing strings, possible SOURCEs are:

               # a file location string
               $miniXMLDoc-&gt;parse('/path/to/file.xml');

               # an open file handle
               open(INFILE, '/path/to/file.xml');
               $miniXMLDoc-&gt;parse(*INFILE);

               # an open FileHandle object
               my $fhObj = FileHandle-&gt;new();
               $fhObj-&gt;open('/path/to/file.xml');
               $miniXML-&gt;parse($fhObj);

       In all cases where SOURCE is a file or file handle, XML::Mini takes care of slurping the contents and
       closing the handle.

   <b>fromHash</b> <b>HASHREF</b> <b>[OPTIONS]</b>
       Parses a "hash representation" of your XML structure.  For each key =&gt; value pair within the hash ref,
       XML::Mini will create an element of name 'key' :

               - with the text contents set to 'value' if 'value' is a string

               - for each element of 'value' if value is an ARRAY REFERENCE

               - with suitable children for each subkey =&gt; subvalue if 'value' is a HASH REFERENCE.

       For instance, if <b>fromHash()</b> is passed a simple hash ref like:

           my $h = {

                'spy'  =&gt; {
                       'id'    =&gt; '007',
                       'type'  =&gt; 'SuperSpy',
                       'name'  =&gt; 'James Bond',
                       'email' =&gt; '<a href="mailto:mi5@london.uk">mi5@london.uk</a>',
                       'address'       =&gt; 'Wherever he is needed most',
               },
          };

       then :

         $xmlDoc-&gt;fromHash($h);
         print $xmlDoc-&gt;toString();

       will output

        &lt;spy&gt;
         &lt;email&gt; <a href="mailto:mi5@london.uk">mi5@london.uk</a> &lt;/email&gt;
         &lt;name&gt; James Bond &lt;/name&gt;
         &lt;address&gt; Wherever he is needed most &lt;/address&gt;
         &lt;type&gt; SuperSpy &lt;/type&gt;
         &lt;id&gt; 007 &lt;/id&gt;
        &lt;/spy&gt;

       The optional OPTIONS parameter may be used to specify which keys to use as attributes (instead of
       creating subelements).  For example, calling

        my $options = {
                               'attributes'    =&gt; {
                                               'spy'   =&gt; 'id',
                                               'email' =&gt; 'type',
                                               'friend' =&gt; ['name', 'age'],
                                       }
                       };

        my $h = {

                'spy'  =&gt; {
                       'id'    =&gt; '007',
                       'type'  =&gt; 'SuperSpy',
                       'name'  =&gt; 'James Bond',
                       'email' =&gt; {
                                       'type'          =&gt; 'private',
                                       '-content'      =&gt; '<a href="mailto:mi5@london.uk">mi5@london.uk</a>',

                               },
                       'address' =&gt; {
                                       'type'  =&gt; 'residential',
                                       '-content' =&gt; 'Wherever he is needed most',
                               },

                       'friend' =&gt; [
                                               {
                                                       'name'  =&gt; 'claudia',
                                                       'age'   =&gt; 25,
                                                       'type'  =&gt; 'close',
                                               },

                                               {
                                                       'name'  =&gt; 'monneypenny',
                                                       'age'   =&gt; '40something',
                                                       'type'  =&gt; 'tease',
                                               },

                                               {
                                                       'name'  =&gt; 'Q',
                                                       'age'   =&gt; '10E4',
                                                       'type'  =&gt; 'pain',
                                               }
                                       ],

               },
          };

         $xmlDoc-&gt;fromHash($h, $options);
         print $xmlDoc-&gt;toString();

       will output something like:

        &lt;spy id="007"&gt;
         &lt;name&gt; James Bond &lt;/name&gt;
         &lt;email type="private"&gt; <a href="mailto:mi5@london.uk">mi5@london.uk</a> &lt;/email&gt;
         &lt;address&gt;
          &lt;type&gt; residential &lt;/type&gt;
          Wherever he is needed most
         &lt;/address&gt;
         &lt;type&gt; SuperSpy &lt;/type&gt;
         &lt;friend age="25" name="claudia"&gt;
          &lt;type&gt; close &lt;/type&gt;
         &lt;/friend&gt;
         &lt;friend age="40something" name="monneypenny"&gt;
          &lt;type&gt; tease &lt;/type&gt;
         &lt;/friend&gt;
         &lt;friend age="10E4" name="Q"&gt;
          &lt;type&gt; pain &lt;/type&gt;
         &lt;/friend&gt;
        &lt;/spy&gt;

       As demonstrated above, you can use the optional href to specify tags for which attributes (instead of
       elements) should be created and you may nest hash and array refs to create complex structures.

       NOTE: Whenever a hash references is used you lose the sequence in which the elements are placed - only
       the array references (which create a list of identically named elements) can preserve their order.

       See ALSO: the documentation for the related <b>toHash()</b> method.

       Still TODO: Create some better docs for this!  For the moment you can take a peek within the test suite
       of the source distribution.

   <b>fromString</b> <b>XMLSTRING</b>
       Initialise the XML::Mini::Document (and it's root XML::Mini::Element) using the XML string XMLSTRING.

       Returns the number of immediate children the root XML::Mini::Element now has.

   <b>fromFile</b> <b>FILENAME</b>
       Initialise the XML::Mini::Document (and it's root XML::Mini::Element) using the XML from file FILNAME.

       Returns the number of immediate children the root XML::Mini::Element now has.

   <b>toString</b> <b>[DEPTH]</b>
       Converts this XML::Mini::Document object to a string and returns it.

       The optional DEPTH may be passed to set the space offset for the first element.

       If the optional DEPTH is set to $XML::Mini::NoWhiteSpaces no \n or whitespaces will be inserted in the
       xml string (ie it will all be on a single line with no spaces between the tags.

       Returns a string of XML representing the document.

   <b>toFile</b> <b>FILENAME</b> <b>[SAFE]</b>
       Stringify and save the XML document to file FILENAME

       If SAFE flag is passed and is a true value, toFile will do some extra checking, refusing to open the file
       if the filename matches m|/\.\./| or m|#;`\*| or if FILENAME points to a softlink.  In addition, if SAFE
       is 'NOOVERWRITE', toFile will fail if the FILENAME already exists.

   <b>toHash</b>
       Transform the XML structure internally represented within the object (created manually or parsed from a
       file or string) into a HASH reference and returns the href.

       For instance, if this XML is <b>parse()</b>d:

       &lt;people&gt;

        &lt;person id="007"&gt;
         &lt;email&gt; <a href="mailto:mi5@london.uk">mi5@london.uk</a> &lt;/email&gt;
         &lt;name&gt; James Bond &lt;/name&gt;
         &lt;address&gt; Wherever he is needed most &lt;/address&gt;
         &lt;type&gt; SuperSpy &lt;/type&gt;
        &lt;/person&gt;

        &lt;person id="006" number="6"&gt;
         &lt;comment&gt; I am not a man, I am a free number &lt;/comment&gt;
         &lt;name&gt; Number 6 &lt;/name&gt;
         &lt;email type="private"&gt; <a href="mailto:prisoner@aol.com">prisoner@aol.com</a> &lt;/email&gt;
         &lt;address&gt; 6 Prison Island Road, Prison Island, Somewhere &lt;/address&gt;
        &lt;/person&gt;

       &lt;/people&gt;

       The hash reference returned will look like this (as output by Data::Dumper):

        'people' =&gt; {

             'person' =&gt; [
                           {
                             'email' =&gt; '<a href="mailto:mi5@london.uk">mi5@london.uk</a>',
                             'name' =&gt; 'James Bond',
                             'type' =&gt; 'SuperSpy',
                             'address' =&gt; 'Wherever he is needed most',
                             'id' =&gt; '007'
                           },
                           {
                             'email' =&gt; {
                                          'type' =&gt; 'private',
                                          '-content' =&gt; '<a href="mailto:prisoner@aol.com">prisoner@aol.com</a>'
                                        },
                             'comment' =&gt; 'I am not a man, I am a free number',
                             'number' =&gt; '6',
                             'name' =&gt; 'Number 6',
                             'address' =&gt; '6 Prison Island Road, Prison Island, Somewhere',
                             'id' =&gt; '006'
                           }
                         ]
           }

   <b>getValue</b>
       Utility function, call the root XML::Mini::Element's <b>getValue()</b>

   <b>dump</b>
       Debugging aid, dump returns a nicely formatted dump of the current structure of the XML::Mini::Document
       object.

</pre><h4><b>CAVEATS</b></h4><pre>
       It is impossible to parse "cross-nested" tags using regular expressions (i.e. sequences of the form
       &lt;a&gt;&lt;b&gt;&lt;a&gt;...&lt;/a&gt;&lt;/b&gt;&lt;/a&gt;).  However, if you have the Text::Balanced module installed (it is installed by
       default with Perl 5.8), such sequences will be handled flawlessly.

       Even if you do not have the Text::Balanced module available, it is still possible to generate this type
       of XML - the problem only appears when parsing.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) 2002-2008 Patrick Deegan, Psychogenic Inc.

       Programs that use this code are bound to the terms and conditions of the GNU GPL (see the LICENSE file).
       If you wish to include these modules in non-GPL code, you need prior written authorisation from the
       authors.

       This library is released under the terms of the GNU GPL version 3, making it available only for free
       programs ("free" here being used in the sense of the GPL, see <a href="http://www.gnu.org">http://www.gnu.org</a> for more details).
       Anyone wishing to use this library within a proprietary or otherwise non-GPLed program MUST contact
       psychogenic.com to acquire a distinct license for their application.  This approach encourages the use of
       free software while allowing for proprietary solutions that support further development.

   <b>LICENSE</b>
           XML::Mini::Document module, part of the XML::Mini XML parser/generator package.
           Copyright (C) 2002-2008 Patrick Deegan
           All rights reserved

           XML::Mini is free software: you can redistribute it and/or modify
           it under the terms of the GNU General Public License as published by
           the Free Software Foundation, either version 3 of the License, or
           (at your option) any later version.

           XML::Mini is distributed in the hope that it will be useful,
           but WITHOUT ANY WARRANTY; without even the implied warranty of
           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
           GNU General Public License for more details.

           You should have received a copy of the GNU General Public License
           along with XML::Mini.  If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::Mini, XML::Mini::Element

       <a href="http://minixml.psychogenic.com">http://minixml.psychogenic.com</a>

perl v5.36.0                                       2022-10-15                           <u>XML::Mini::<a href="../man3pm/Document.3pm.html">Document</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>