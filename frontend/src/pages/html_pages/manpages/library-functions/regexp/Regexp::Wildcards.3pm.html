<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regexp::Wildcards - Converts wildcard expressions to Perl regular expressions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libregexp-wildcards-perl">libregexp-wildcards-perl_1.05-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Regexp::Wildcards - Converts wildcard expressions to Perl regular expressions.

</pre><h4><b>VERSION</b></h4><pre>
       Version 1.05

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Regexp::Wildcards;

           my $rw = Regexp::Wildcards-&gt;new(type =&gt; 'unix');

           my $re;
           $re = $rw-&gt;convert('a{b?,c}*');          # Do it Unix shell style.
           $re = $rw-&gt;convert('a?,b*',   'win32');  # Do it Windows shell style.
           $re = $rw-&gt;convert('*{x,y}?', 'jokers'); # Process the jokers and
                                                    # escape the rest.
           $re = $rw-&gt;convert('%a_c%',   'sql');    # Turn SQL wildcards into
                                                    # regexps.

           $rw = Regexp::Wildcards-&gt;new(
            do      =&gt; [ qw&lt;jokers brackets&gt; ], # Do jokers and brackets.
            capture =&gt; [ qw&lt;any greedy&gt; ],      # Capture *'s greedily.
           );

           $rw-&gt;do(add =&gt; 'groups');            # Don't escape groups.
           $rw-&gt;capture(rem =&gt; [ qw&lt;greedy&gt; ]); # Actually we want non-greedy
                                                # matches.
           $re = $rw-&gt;convert('*a{,(b)?}?c*');  # '(.*?)a(?:|(b).).c(.*?)'
           $rw-&gt;capture();                      # No more captures.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       In many situations, users may want to specify patterns to match but don't need the full power of regexps.
       Wildcards make one of those sets of simplified rules.  This module converts wildcard expressions to Perl
       regular expressions, so that you can use them for matching.

       It handles the "*" and "?" wildcards, as well as Unix bracketed alternatives "{,}", but also "%" and "_"
       SQL wildcards.  If required, it can also keep original "(...)" groups or "^" and "$" anchors.  Backslash
       ("\") is used as an escape character.

       Typesets that mimic the behaviour of Windows and Unix shells are also provided.

</pre><h4><b>METHODS</b></h4><pre>
   <b>"new"</b>
           my $rw = Regexp::Wildcards-&gt;new(do =&gt; $what, capture =&gt; $capture);
           my $rw = Regexp::Wildcards-&gt;new(type =&gt; $type, capture =&gt; $capture);

       Constructs a new Regexp::Wildcard object.

       "do" lists all features that should be enabled when converting wildcards to regexps.  Refer to "do" for
       details on what can be passed in $what.

       The "type" specifies a predefined set of "do" features to use.  See "type" for details on which types are
       valid.  The "do" option overrides "type".

       "capture" lists which atoms should be capturing.  Refer to "capture" for more details.

   <b>"do"</b>
           $rw-&gt;do($what);
           $rw-&gt;do(set =&gt; $c1);
           $rw-&gt;do(add =&gt; $c2);
           $rw-&gt;do(rem =&gt; $c3);

       Specifies the list of metacharacters to convert or to prevent for escaping.  They fit into six classes :

       •   'jokers'

           Converts "?" to "." and "*" to ".*".

               'a**\\*b??\\?c' ==&gt; 'a.*\\*b..\\?c'

       •   'sql'

           Converts "_" to "." and "%" to ".*".

               'a%%\\%b__\\_c' ==&gt; 'a.*\\%b..\\_c'

       •   'commas'

           Converts all "," to "|" and puts the complete resulting regular expression inside "(?: ... )".

               'a,b{c,d},e' ==&gt; '(?:a|b\\{c|d\\}|e)'

       •   'brackets'

           Converts  all matching "{ ... ,  ... }" brackets to "(?: ... | ... )" alternations.  If some brackets
           are unbalanced, it tries to substitute as many of them as possible, and  then  escape  the  remaining
           unmatched "{" and "}".  Commas outside of any bracket-delimited block are also escaped.

               'a,b{c,d},e'    ==&gt; 'a\\,b(?:c|d)\\,e'
               '{a\\{b,c}d,e}' ==&gt; '(?:a\\{b|c)d\\,e\\}'
               '{a{b,c\\}d,e}' ==&gt; '\\{a\\{b\\,c\\}d\\,e\\}'

       •   'groups'

           Keeps the parenthesis "( ... )" of the original string without escaping them.  Currently, no check is
           done to ensure that the parenthesis are matching.

               'a(b(c))d\\(\\)' ==&gt; (no change)

       •   'anchors'

           Prevents  the  <u>beginning-of-line</u>  "^"  and  <u>end-of-line</u>  "$"  anchors  to  be escaped.  Since "[...]"
           character class are currently escaped, a "^" will always be interpreted as <u>beginning-of-line</u>.

               'a^b$c' ==&gt; (no change)

       Each $c can be any of :

       •   A hash reference, with wanted metacharacter group names (described above) as  keys  and  booleans  as
           values ;

       •   An array reference containing the list of wanted metacharacter classes ;

       •   A plain scalar, when only one group is required.

       When "set" is present, the classes given as its value replace the current object options.  Then the "add"
       classes are added, and the "rem" classes removed.

       Passing a sole scalar $what is equivalent as passing "set =&gt; $what".  No argument means "set =&gt; [ ]".

           $rw-&gt;do(set =&gt; 'jokers');           # Only translate jokers.
           $rw-&gt;do('jokers');                  # Same.
           $rw-&gt;do(add =&gt; [ qw&lt;sql commas&gt; ]); # Translate also SQL and commas.
           $rw-&gt;do(rem =&gt; 'jokers');           # Specifying both 'sql' and
                                               # 'jokers' is useless.
           $rw-&gt;do();                          # Translate nothing.

       The "do" method returns the Regexp::Wildcards object.

   <b>"type"</b>
           $rw-&gt;type($type);

       Notifies  to  convert the metacharacters that corresponds to the predefined type $type.  $type can be any
       of :

       •   'jokers', 'sql', 'commas', 'brackets'

           Singleton types that enable the corresponding "do" classes.

       •   'unix'

           Covers typical Unix shell globbing features (effectively 'jokers' and 'brackets').

       •   $^O values for common Unix systems

           Wrap to 'unix' (see perlport for the list).

       •   "undef"

           Defaults to 'unix'.

       •   'win32'

           Covers typical Windows shell globbing features (effectively 'jokers' and 'commas').

       •   'dos', 'os2', 'MSWin32', 'cygwin'

           Wrap to 'win32'.

       In particular, you can usually pass $^O as the $type and get the corresponding shell behaviour.

           $rw-&gt;type('win32'); # Set type to win32.
           $rw-&gt;type($^O);     # Set type to unix on Unices and win32 on Windows
           $rw-&gt;type();        # Set type to unix.

       The "type" method returns the Regexp::Wildcards object.

   <b>"capture"</b>
           $rw-&gt;capture($captures);
           $rw-&gt;capture(set =&gt; $c1);
           $rw-&gt;capture(add =&gt; $c2);
           $rw-&gt;capture(rem =&gt; $c3);

       Specifies the list of atoms to capture.  This method  works  like  "do",  except  that  the  classes  are
       different :

       •   'single'

           Captures all unescaped <u>"exactly</u> <u>one"</u> metacharacters, i.e. "?" for wildcards or "_" for SQL.

               'a???b\\??' ==&gt; 'a(.)(.)(.)b\\?(.)'
               'a___b\\__' ==&gt; 'a(.)(.)(.)b\\_(.)'

       •   'any'

           Captures all unescaped <u>"any"</u> metacharacters, i.e. "*" for wildcards or "%" for SQL.

               'a***b\\**' ==&gt; 'a(.*)b\\*(.*)'
               'a%%%b\\%%' ==&gt; 'a(.*)b\\%(.*)'

       •   'greedy'

           When used in conjunction with 'any', it makes the 'any' captures greedy (by default they are not).

               'a***b\\**' ==&gt; 'a(.*?)b\\*(.*?)'
               'a%%%b\\%%' ==&gt; 'a(.*?)b\\%(.*?)'

       •   'brackets'

           Capture matching "{ ... , ... }" alternations.

               'a{b\\},\\{c}' ==&gt; 'a(b\\}|\\{c)'

           $rw-&gt;capture(set =&gt; 'single');           # Only capture "exactly one"
                                                    # metacharacters.
           $rw-&gt;capture('single');                  # Same.
           $rw-&gt;capture(add =&gt; [ qw&lt;any greedy&gt; ]); # Also greedily capture
                                                    # "any" metacharacters.
           $rw-&gt;capture(rem =&gt; 'greedy');           # No more greed please.
           $rw-&gt;capture();                          # Capture nothing.

       The "capture" method returns the Regexp::Wildcards object.

   <b>"convert"</b>
           my $rx = $rw-&gt;convert($wc);
           my $rx = $rw-&gt;convert($wc, $type);

       Converts  the  wildcard expression $wc into a regular expression according to the options stored into the
       Regexp::Wildcards object, or to $type if it's supplied.  It successively escapes all  unprotected  regexp
       special characters that doesn't hold any meaning for wildcards, then replace 'jokers', 'sql' and 'commas'
       or  'brackets'  (depending  on  the  "do" or "type" options), all of this by applying the 'capture' rules
       specified in the constructor or by "capture".

</pre><h4><b>EXPORT</b></h4><pre>
       An object module shouldn't export any function, and so does this one.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       Carp (core module since perl 5), Scalar::Util, Text::Balanced (since 5.7.3).

</pre><h4><b>CAVEATS</b></h4><pre>
       This module does not implement the strange behaviours of Windows  shell  that  result  from  the  special
       handling of the three last characters (for the file extension).  For example, Windows XP shell matches *a
       like ".*a", "*a?" like ".*a.?", "*a??" like ".*a.{0,2}" and so on.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Text::Glob.

</pre><h4><b>AUTHOR</b></h4><pre>
       Vincent Pit, "&lt;perl at profvince.com&gt;", &lt;<a href="http://www.profvince.com">http://www.profvince.com</a>&gt;.

       You can contact me by mail or on "irc.perl.org" (vincent).

</pre><h4><b>BUGS</b></h4><pre>
       Please  report  any bugs or feature requests to "bug-regexp-wildcards at rt.cpan.org", or through the web
       interface at &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=Regexp-Wildcards&gt;.  I will be notified,  and
       then you'll automatically be notified of progress on your bug as I make changes.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc Regexp::Wildcards

       Tests code coverage report is available at &lt;<a href="http://www.profvince.com/perl/cover/Regexp-Wildcards">http://www.profvince.com/perl/cover/Regexp-Wildcards</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2007,2008,2009,2013 Vincent Pit, all rights reserved.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.34.0                                       2022-08-02                             <u>Regexp::<a href="../man3pm/Wildcards.3pm.html">Wildcards</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>