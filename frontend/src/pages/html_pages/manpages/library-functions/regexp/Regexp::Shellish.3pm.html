<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regexp::Shellish - Shell-like regular expressions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libregexp-shellish-perl">libregexp-shellish-perl_0.93-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Regexp::Shellish - Shell-like regular expressions

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use Regexp::Shellish qw( :all ) ;

          $re = compile_shellish( 'a/c*d' ) ;

          ## This next one's like 'a*d' except that it'll
          ## match 'a/d'.
          $re = compile_shellish( 'a**d' ) ;

          ## And here '**' won't match 'a/d', but behaves
          ## like 'a*d', except for the possibility of high
          ## cpu time consumption.
          $re = compile_shellish( 'a**d', { star_star =&gt; 0 } ) ;

          ## The next two result in identical $re1 and $re2.
          ## The second is a noop so that Regexp references can
          ## be easily accomodated.
          $re1 = compile_shellish( 'a{b,c}d' ) ;
          $re2 = compile_shellish( qr/\A(?:a(?:b|c)d)\Z/ ) ;

          @matches = shellish_glob( $re, @possibilities ) ;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Provides shell-like regular expressions.  The wildcards provided are "?", "*" and "**", where "**" is
       like "*" but matches "/".  See "compile_shellish" for details.

       Case sensitivity and constructs like &lt;**&gt;, "(a*b)", and "{a,b,c}" can be disabled.

       compile_shellish
           Compiles  a  string containing a 'shellish' regular expression, returning a Regexp reference.  Regexp
           references passed in are passed through unmolested.

           Here are the transformation rules from shellish expression terms to perl regular expression terms:

              Shellish  Perl RE
              ========  =======
              *         [^/]*
              ?         .
              **        .*               ## unless { star_star   =&gt; 0 }
              ...       .*               ## unless { dot_dot_dot =&gt; 0 }

              (         (                ## unless { parens =&gt; 0 }
              )         )                ## unless { parens =&gt; 0 }

              {a,b,c}   (?:a|b|c)        ## unless { braces =&gt; 0 }

              \a        a                ## These are de-escaped and
              \*        \*               ## passed to quotemeta()

           The wildcards treat newlines as normal characters.

           Parens group in to $1..$n, since they are passed through unmolested (unless option  parens  =&gt;  0  is
           passed).  This is useless when using <b>glob_shellish()</b>, though.

           The final parameter can be a hash reference containing options:

              compile_shellish(
                 '**',
                 {
                    anchors        =&gt; 0,   ## Doesn't put ^ and $ around the
                                           ## resulting regexp
                    case_sensitive =&gt; 0,   ## Make case insensitive
                    dot_dot_dot    =&gt; 0,   ## '...' is now just three '.' chars
                    star_star      =&gt; 0,   ## '**' is now two '*' wildcards
                    parens         =&gt; 0,   ## '(', ')' are now regular chars
                    braces         =&gt; 0,   ## '{', '}' are now regular chars
                 }
              ) ;

           No option affects Regexps passed through.

       shellish_glob
           Pass a regular expression and a list of possible values, get back a list of matching values.

              my @matches = shellish_glob( '*/*', @possibilities ) ;
              my @matches = shellish_glob( '*/*', @possibilities, \%options ) ;

</pre><h4><b>AUTHOR</b></h4><pre>
       Barrie Slaymaker &lt;<a href="mailto:barries@slaysys.com">barries@slaysys.com</a>&gt;

perl v5.36.0                                       2022-10-13                                      <u><a href="../man3pm/Shellish.3pm.html">Shellish</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>