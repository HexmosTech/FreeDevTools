<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perl::Critic::Policy::RegularExpressions::ProhibitComplexRegexes - Split long regexps into smaller "qr//"</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libperl-critic-perl">libperl-critic-perl_1.156-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Perl::Critic::Policy::RegularExpressions::ProhibitComplexRegexes - Split long regexps into smaller "qr//"
       chunks.

</pre><h4><b>AFFILIATION</b></h4><pre>
       This Policy is part of the core Perl::Critic distribution.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Big regexps are hard to read, perhaps even the hardest part of Perl.  A good practice to write digestible
       chunks of regexp and put them together.  This policy flags any regexp that is longer than "N" characters,
       where "N" is a configurable value that defaults to 60.  If the regexp uses the "x" flag, then the length
       is computed after parsing out any comments or whitespace.

       Unfortunately the use of descriptive (and therefore longish) variable names can cause regexps to be in
       violation of this policy, so interpolated variables are counted as 4 characters no matter how long their
       names actually are.

</pre><h4><b>CASE</b> <b>STUDY</b></h4><pre>
       As an example, look at the regexp used to match email addresses in Email::Valid::Loose (tweaked lightly
       to wrap for POD)

           (?x-ism:(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:".\\\[\]
           \000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015
           "]*)*")(?:(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:".\\\[
           \]\000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n
           \015"]*)*")|\.)*\@(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,
           ;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\]
           )(?:\.(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:".\\\[\]\000
           -\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\]))*)

       which is constructed from the following code:

           my $esc         = '\\\\';
           my $period      = '\.';
           my $space       = '\040';
           my $open_br     = '\[';
           my $close_br    = '\]';
           my $nonASCII    = '\x80-\xff';
           my $ctrl        = '\000-\037';
           my $cr_list     = '\n\015';
           my $qtext       = qq/[^$esc$nonASCII$cr_list\"]/; # "
           my $dtext       = qq/[^$esc$nonASCII$cr_list$open_br$close_br]/;
           my $quoted_pair = qq&lt;$esc&gt;.qq&lt;[^$nonASCII]&gt;;
           my $atom_char   = qq/[^($space)&lt;&gt;\@,;:\".$esc$open_br$close_br$ctrl$nonASCII]/;# "
           my $atom        = qq&lt;$atom_char+(?!$atom_char)&gt;;
           my $quoted_str  = qq&lt;\"$qtext*(?:$quoted_pair$qtext*)*\"&gt;; # "
           my $word        = qq&lt;(?:$atom|$quoted_str)&gt;;
           my $domain_ref  = $atom;
           my $domain_lit  = qq&lt;$open_br(?:$dtext|$quoted_pair)*$close_br&gt;;
           my $sub_domain  = qq&lt;(?:$domain_ref|$domain_lit)&gt;;
           my $domain      = qq&lt;$sub_domain(?:$period$sub_domain)*&gt;;
           my $local_part  = qq&lt;$word(?:$word|$period)*&gt;; # This part is modified
           $Addr_spec_re   = qr&lt;$local_part\@$domain&gt;;

       If you read the code from bottom to top, it is quite readable.  And, you can even see the one violation
       of RFC822 that Tatsuhiko Miyagawa deliberately put into Email::Valid::Loose to allow periods.  Look for
       the "|\." in the upper regexp to see that same deviation.

       One could certainly argue that the top regexp could be re-written more legibly with "m//x" and comments.
       But the bottom version is self-documenting and, for example, doesn't repeat "\x80-\xff" 18 times.
       Furthermore, it's much easier to compare the second version against the source BNF grammar in RFC 822 to
       judge whether the implementation is sound even before running tests.

</pre><h4><b>CONFIGURATION</b></h4><pre>
       This policy allows regexps up to "N" characters long, where "N" defaults to 60.  You can override this to
       set it to a different number with the "max_characters" setting.  To do this, put entries in a
       <u>.perlcriticrc</u> file like this:

           [RegularExpressions::ProhibitComplexRegexes]
           max_characters = 40

</pre><h4><b>CREDITS</b></h4><pre>
       Initial development of this policy was supported by a grant from the Perl Foundation.

</pre><h4><b>AUTHOR</b></h4><pre>
       Chris Dolan &lt;<a href="mailto:cdolan@cpan.org">cdolan@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2007-2023 Chris Dolan

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.  The full text of this license can be found in the LICENSE file included with this module

perl v5.40.0                                       2024-10-28             <u>Perl::Critic::<a href="../man3pm/P...tComplexRegexes.3pm.html">P...tComplexRegexes</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>