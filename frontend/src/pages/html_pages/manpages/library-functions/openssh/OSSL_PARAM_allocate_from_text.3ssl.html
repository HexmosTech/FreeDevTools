<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSSL_PARAM_allocate_from_text - OSSL_PARAM construction utilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       OSSL_PARAM_allocate_from_text - OSSL_PARAM construction utilities

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/params.h&gt;

        int OSSL_PARAM_allocate_from_text(OSSL_PARAM *to,
                                          const OSSL_PARAM *paramdefs,
                                          const char *key, const char *value,
                                          size_t value_n,
                                          int *found);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       With OpenSSL before version 3.0, parameters were passed down to or retrieved from algorithm
       implementations via control functions.  Some of these control functions existed in variants that took
       string parameters, for example <b><a href="../man3/EVP_PKEY_CTX_ctrl_str.3.html">EVP_PKEY_CTX_ctrl_str</a></b>(3).

       OpenSSL 3.0 introduces a new mechanism to do the same thing with an array of parameters that contain
       name, value, value type and value size (see <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) for more information).

       <b>OSSL_PARAM_allocate_from_text()</b> uses <u>key</u> to look up an item in <u>paramdefs</u>.  If an item was found, it
       converts <u>value</u> to something suitable for that item's <u>data_type</u>, and stores the result in <u>to-&gt;data</u> as well
       as its size in <u>to-&gt;data_size</u>.  <u>to-&gt;key</u> and <u>to-&gt;data_type</u> are assigned the corresponding values from the
       item that was found, and <u>to-&gt;return_size</u> is set to zero.

       <u>to-&gt;data</u> is always allocated using <b><a href="../man3/OPENSSL_zalloc.3.html">OPENSSL_zalloc</a></b>(3) and needs to be freed by the caller when it's not
       useful any more, using <b><a href="../man3/OPENSSL_free.3.html">OPENSSL_free</a></b>(3).

       If <u>found</u> is not NULL, <u>*found</u> is set to 1 if <u>key</u> could be located in <u>paramdefs</u>, and to 0 otherwise.

   <b>The</b> <b>use</b> <b>of</b> <u><b>key</b></u> <b>and</b> <u><b>value</b></u> <b>in</b> <b>detail</b>
       <b>OSSL_PARAM_allocate_from_text()</b> takes note if <u>key</u> starts with "hex", and will only use the rest of <u>key</u> to
       look up an item in <u>paramdefs</u> in that case.  As an example, if <u>key</u> is "hexid", "id" will be looked up in
       <u>paramdefs</u>.

       When an item in <u>paramdefs</u> has been found, <u>value</u> is converted depending on that item's <u>data_type</u>, as
       follows:

       <b>OSSL_PARAM_INTEGER</b> and <b>OSSL_PARAM_UNSIGNED_INTEGER</b>
           If  <u>key</u>  didn't  start  with "hex", <u>value</u> is assumed to contain <u>value_n</u> decimal characters, which are
           decoded, and the resulting bytes become the number stored in the <u>to-&gt;data</u> storage.

           If <u>value</u> starts with "0x", it is assumed to contain <u>value_n</u> hexadecimal characters.

           If <u>key</u> started with "hex", <u>value</u> is assumed to contain <u>value_n</u>  hexadecimal  characters  without  the
           "0x" prefix.

           If  <u>value</u>  contains  characters  that  couldn't  be  decoded  as  hexadecimal  or decimal characters,
           <b>OSSL_PARAM_allocate_from_text()</b> considers that an error.

       <b>OSSL_PARAM_UTF8_STRING</b>
           If <u>key</u> started with "hex", <b>OSSL_PARAM_allocate_from_text()</b> considers that an error.

           Otherwise, <u>value</u> is considered a C string and is copied to the <u>to-&gt;data</u> storage.   On  systems  where
           the native character encoding is EBCDIC, the bytes in <u>to-&gt;data</u> are converted to ASCII.

       <b>OSSL_PARAM_OCTET_STRING</b>
           If  <u>key</u>  started  with  "hex",  <u>value</u> is assumed to contain <u>value_n</u> hexadecimal characters, which are
           decoded, and the resulting bytes are stored in the <u>to-&gt;data</u> storage.  If  <u>value</u>  contains  characters
           that  couldn't  be  decoded  as  hexadecimal  or  decimal characters, <b>OSSL_PARAM_allocate_from_text()</b>
           considers that an error.

           If <u>key</u> didn't start with "hex", <u>value_n</u> bytes from <u>value</u> are copied to the <u>to-&gt;data</u> storage.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>OSSL_PARAM_allocate_from_text()</b> returns 1 if <u>key</u> was found in <u>paramdefs</u> and there was no  other  failure,
       otherwise 0.

</pre><h4><b>NOTES</b></h4><pre>
       The   parameter  descriptor  array  comes  from  functions  dedicated  to  return  them.   The  following
       <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) attributes are used:

       <u>key</u>
       <u>data_type</u>
       <u>data_size</u>

       All other attributes are ignored.

       The <u>data_size</u> attribute can be zero, meaning that the parameter it  describes  expects  arbitrary  length
       data.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Code that looked like this:

         int mac_ctrl_string(EVP_PKEY_CTX *ctx, const char *value)
         {
             int rv;
             char *stmp, *vtmp = NULL;

             stmp = OPENSSL_strdup(value);
             if (stmp == NULL)
                 return -1;
             vtmp = strchr(stmp, ':');
             if (vtmp != NULL)
                 *vtmp++ = '\0';
             rv = EVP_MAC_ctrl_str(ctx, stmp, vtmp);
             OPENSSL_free(stmp);
             return rv;
         }

         ...

         for (i = 0; i &lt; <a href="../manmacopts/sk_OPENSSL_STRING_num.macopts.html">sk_OPENSSL_STRING_num</a>(macopts); i++) {
             char *macopt = sk_OPENSSL_STRING_value(macopts, i);

             if (pkey_ctrl_string(mac_ctx, macopt) &lt;= 0) {
                 BIO_printf(bio_err,
                            "MAC parameter error \"%s\"\n", macopt);
                 ERR_print_errors(bio_err);
                 goto mac_end;
             }
         }

       Can be written like this instead:

         OSSL_PARAM *params =
             OPENSSL_zalloc(sizeof(*params)
                            * (sk_OPENSSL_STRING_num(opts) + 1));
         const OSSL_PARAM *paramdefs = <a href="../manmac/EVP_MAC_settable_ctx_params.mac.html">EVP_MAC_settable_ctx_params</a>(mac);
         size_t params_n;
         char *opt = "&lt;unknown&gt;";

         for (params_n = 0; params_n &lt; (size_t)sk_OPENSSL_STRING_num(opts);
              params_n++) {
             char *stmp, *vtmp = NULL;

             opt = sk_OPENSSL_STRING_value(opts, (int)params_n);
             if ((stmp = OPENSSL_strdup(opt)) == NULL
                     || (vtmp = strchr(stmp, ':')) == NULL)
                 goto err;

             *vtmp++ = '\0';
             if (!OSSL_PARAM_allocate_from_text(&amp;params[params_n],
                                                paramdefs, stmp,
                                                vtmp, strlen(vtmp), NULL))
                 goto err;
         }
         params[params_n] = OSSL_PARAM_construct_end();
         if (!EVP_MAC_CTX_set_params(ctx, params))
             goto err;
         while (params_n-- &gt; 0)
             OPENSSL_free(params[params_n].data);
         OPENSSL_free(params);
         /* ... */
         return;

        err:
         BIO_printf(bio_err, "MAC parameter error '%s'\n", opt);
         ERR_print_errors(bio_err);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3), <b><a href="../man3/OSSL_PARAM_int.3.html">OSSL_PARAM_int</a></b>(3)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2019-2021 The OpenSSL Project Authors. All Rights Reserved.

       Licensed  under  the  Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain  a  copy  in  the  file  LICENSE  in  the  source  distribution  or  at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                <u><a href="../man3SSL/OSSL_PARAM_ALLOCATE_FROM_TEXT.3SSL.html">OSSL_PARAM_ALLOCATE_FROM_TEXT</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>