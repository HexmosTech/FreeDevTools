<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRYPTO_THREAD_run_once, CRYPTO_THREAD_lock_new, CRYPTO_THREAD_read_lock, CRYPTO_THREAD_write_lock,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CRYPTO_THREAD_run_once, CRYPTO_THREAD_lock_new, CRYPTO_THREAD_read_lock, CRYPTO_THREAD_write_lock,
       CRYPTO_THREAD_unlock, CRYPTO_THREAD_lock_free, CRYPTO_atomic_add, CRYPTO_atomic_add64, CRYPTO_atomic_and,
       CRYPTO_atomic_or, CRYPTO_atomic_load, CRYPTO_atomic_store, CRYPTO_atomic_load_int, OSSL_set_max_threads,
       OSSL_get_max_threads, OSSL_get_thread_support_flags, OSSL_THREAD_SUPPORT_FLAG_THREAD_POOL,
       OSSL_THREAD_SUPPORT_FLAG_DEFAULT_SPAWN - OpenSSL thread support

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/crypto.h&gt;

        CRYPTO_ONCE CRYPTO_ONCE_STATIC_INIT;
        int CRYPTO_THREAD_run_once(CRYPTO_ONCE *once, void (*init)(void));

        CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void);
        int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock);
        int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock);
        int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock);
        void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock);

        int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock);
        int CRYPTO_atomic_add64(uint64_t *val, uint64_t op, uint64_t *ret,
                                CRYPTO_RWLOCK *lock);
        int CRYPTO_atomic_and(uint64_t *val, uint64_t op, uint64_t *ret,
                              CRYPTO_RWLOCK *lock);
        int CRYPTO_atomic_or(uint64_t *val, uint64_t op, uint64_t *ret,
                             CRYPTO_RWLOCK *lock);
        int CRYPTO_atomic_load(uint64_t *val, uint64_t *ret, CRYPTO_RWLOCK *lock);
        int CRYPTO_atomic_store(uint64_t *dst, uint64_t val, CRYPTO_RWLOCK *lock);
        int CRYPTO_atomic_load_int(int *val, int *ret, CRYPTO_RWLOCK *lock);

        int OSSL_set_max_threads(OSSL_LIB_CTX *ctx, uint64_t max_threads);
        uint64_t OSSL_get_max_threads(OSSL_LIB_CTX *ctx);
        uint32_t OSSL_get_thread_support_flags(void);

        #define OSSL_THREAD_SUPPORT_FLAG_THREAD_POOL
        #define OSSL_THREAD_SUPPORT_FLAG_DEFAULT_SPAWN

</pre><h4><b>DESCRIPTION</b></h4><pre>
       OpenSSL can be safely used in multi-threaded applications provided that support for the underlying OS
       threading API is built-in. Currently, OpenSSL supports the pthread and Windows APIs. OpenSSL can also be
       built without any multi-threading support, for example on platforms that don't provide any threading
       support or that provide a threading API that is not yet supported by OpenSSL.

       The following multi-threading function are provided:

       • <b>CRYPTO_THREAD_run_once()</b>  can  be used to perform one-time initialization.  The <u>once</u> argument must be a
         pointer to a  static  object  of  type  <b>CRYPTO_ONCE</b>  that  was  statically  initialized  to  the  value
         <b>CRYPTO_ONCE_STATIC_INIT</b>.   The  <u>init</u>  argument  is  a  pointer  to a function that performs the desired
         exactly once initialization.  In particular, this can be  used  to  allocate  locks  in  a  thread-safe
         manner, which can then be used with the locking functions below.

       • <b>CRYPTO_THREAD_lock_new()</b> allocates, initializes and returns a new read/write lock.

       • <b>CRYPTO_THREAD_read_lock()</b> locks the provided <u>lock</u> for reading.

       • <b>CRYPTO_THREAD_write_lock()</b> locks the provided <u>lock</u> for writing.

       • <b>CRYPTO_THREAD_unlock()</b> unlocks the previously locked <u>lock</u>.

       • <b>CRYPTO_THREAD_lock_free()</b> frees the provided <u>lock</u>.  If the argument is NULL, nothing is done.

       • <b>CRYPTO_atomic_add()</b>  atomically  adds  <u>amount</u>  to <u>*val</u> and returns the result of the operation in <u>*ret</u>.
         <u>lock</u> will be locked, unless atomic operations are supported on the specific platform. Because of  this,
         if a variable is modified by <b>CRYPTO_atomic_add()</b> then <b>CRYPTO_atomic_add()</b> must be the only way that the
         variable  is  modified. If atomic operations are not supported and <u>lock</u> is NULL, then the function will
         fail.

       • <b>CRYPTO_atomic_add64()</b> atomically adds <u>op</u> to <u>*val</u> and returns the result of the operation in <u>*ret</u>.  <u>lock</u>
         will  be locked, unless atomic operations are supported on the specific platform. Because of this, if a
         variable is modified by <b>CRYPTO_atomic_add64()</b> then <b>CRYPTO_atomic_add64()</b> must be the only way that  the
         variable  is  modified. If atomic operations are not supported and <u>lock</u> is NULL, then the function will
         fail.

       • <b>CRYPTO_atomic_and()</b> performs an atomic bitwise and of <u>op</u> and <u>*val</u> and stores the result back  in  <u>*val</u>.
         It  also returns the result of the operation in <u>*ret</u>. <u>lock</u> will be locked, unless atomic operations are
         supported on the specific platform. Because of this, if a variable is modified  by  <b>CRYPTO_atomic_and()</b>
         or  read  by  <b>CRYPTO_atomic_load()</b>  then  <b>CRYPTO_atomic_and()</b> must be the only way that the variable is
         modified. If atomic operations are not supported and <u>lock</u> is NULL, then the function will fail.

       • <b>CRYPTO_atomic_or()</b> performs an atomic bitwise or of <u>op</u> and <u>*val</u> and stores the result back in <u>*val</u>.  It
         also  returns  the  result  of the operation in <u>*ret</u>. <u>lock</u> will be locked, unless atomic operations are
         supported on the specific platform. Because of this, if a variable is modified by <b>CRYPTO_atomic_or()</b> or
         read by <b>CRYPTO_atomic_load()</b> then <b>CRYPTO_atomic_or()</b>  must  be  the  only  way  that  the  variable  is
         modified. If atomic operations are not supported and <u>lock</u> is NULL, then the function will fail.

       • <b>CRYPTO_atomic_load()</b>  atomically  loads  the  contents  of <u>*val</u> into <u>*ret</u>.  <u>lock</u> will be locked, unless
         atomic operations are supported on the specific platform. Because of this, if a variable is modified by
         <b>CRYPTO_atomic_or()</b> or read by <b>CRYPTO_atomic_load()</b> then <b>CRYPTO_atomic_load()</b> must be the only way  that
         the  variable  is read. If atomic operations are not supported and <u>lock</u> is NULL, then the function will
         fail.

       • <b>CRYPTO_atomic_store()</b> atomically stores the contents of <u>val</u> into <u>*dst</u>.  <u>lock</u>  will  be  locked,  unless
         atomic operations are supported on the specific platform.

       • <b>CRYPTO_atomic_load_int()</b> works identically to <b>CRYPTO_atomic_load()</b> but operates on an <u>int</u> value instead
         of a <u>uint64_t</u> value.

       • <b>OSSL_set_max_threads()</b>  sets  the  maximum  number  of  threads  to  be used by the thread pool. If the
         argument is 0, thread pooling is disabled. OpenSSL will not create any threads and existing threads  in
         the  thread pool will be torn down. The maximum thread count is a limit, not a target. Threads will not
         be spawned unless (and until) there is demand.  Thread  polling  is  disabled  by  default.  To  enable
         threading  you  must  call  <b>OSSL_set_max_threads()</b> explicitly.  Under no circumstances is this done for
         you.

       • <b>OSSL_get_thread_support_flags()</b> determines what thread pool functionality OpenSSL is compiled with  and
         is  able to support in the current run time environment. <b>OSSL_THREAD_SUPPORT_FLAG_THREAD_POOL</b> indicates
         that the base  thread  pool  functionality  is  available,  and  <b>OSSL_THREAD_SUPPORT_FLAG_DEFAULT_SPAWN</b>
         indicates  that  the default thread pool model is available. The default thread pool model is currently
         the only model available, therefore both of these flags must be set for thread pool functionality to be
         used.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>CRYPTO_THREAD_run_once()</b> returns 1 on success, or 0 on error.

       <b>CRYPTO_THREAD_lock_new()</b> returns the allocated lock, or NULL on error.

       <b>CRYPTO_THREAD_lock_free()</b> returns no value.

       <b>OSSL_set_max_threads()</b> returns 1 on success and 0 on failure. Returns failure if  OpenSSL-managed  thread
       pooling is not supported (for example, if it is not supported on the current platform, or because OpenSSL
       is not built with the necessary support).

       <b>OSSL_get_max_threads()</b>  returns  the maximum number of threads currently allowed to be used by the thread
       pool. If thread pooling is disabled or not available, returns 0.

       <b>OSSL_get_thread_support_flags()</b> returns zero or more <b>OSSL_THREAD_SUPPORT_FLAG</b> values.

       The other functions return 1 on success, or 0 on error.

</pre><h4><b>NOTES</b></h4><pre>
       On Windows platforms the CRYPTO_THREAD_*  types  and  functions  in  the  <u>&lt;openssl/crypto.h&gt;</u>  header  are
       dependent  on  some  of  the  types  customarily made available by including <u>&lt;windows.h&gt;</u>. The application
       developer is likely to require control over when the latter is included, commonly as  one  of  the  first
       included  headers.  Therefore,  it  is  defined  as  an application developer's responsibility to include
       <u>&lt;windows.h&gt;</u> prior to <u>&lt;openssl/crypto.h&gt;</u> where use of CRYPTO_THREAD_* types and functions is required.

</pre><h4><b>EXAMPLES</b></h4><pre>
       You can find out if OpenSSL was configured with thread support:

        #include &lt;openssl/opensslconf.h&gt;
        #if defined(OPENSSL_THREADS)
            /* thread support enabled */
        #else
            /* no thread support */
        #endif

       This example safely initializes and uses a lock.

        #ifdef _WIN32
        # include &lt;windows.h&gt;
        #endif
        #include &lt;openssl/crypto.h&gt;

        static CRYPTO_ONCE once = CRYPTO_ONCE_STATIC_INIT;
        static CRYPTO_RWLOCK *lock;

        static void myinit(void)
        {
            lock = CRYPTO_THREAD_lock_new();
        }

        static int mylock(void)
        {
            if (!CRYPTO_THREAD_run_once(&amp;once, void init) || lock == NULL)
                return 0;
            return CRYPTO_THREAD_write_lock(lock);
        }

        static int myunlock(void)
        {
            return CRYPTO_THREAD_unlock(lock);
        }

        int serialized(void)
        {
            int ret = 0;

            if (!mylock()) {
               /* Do not unlock unless the lock was successfully acquired. */
               return 0;
            }

            /* Your code here, do not return without releasing the lock! */
            ret = ... ;
            myunlock();
            return ret;
        }

       Finalization of locks is an advanced topic, not covered in this  example.   This  can  only  be  done  at
       process  exit  or  when  a  dynamically loaded library is no longer in use and is unloaded.  The simplest
       solution is to just "leak" the lock in applications and not repeatedly load/unload shared libraries  that
       allocate locks.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/crypto.7.html">crypto</a></b>(7), <b><a href="../man7/openssl-threads.7.html">openssl-threads</a></b>(7).

</pre><h4><b>HISTORY</b></h4><pre>
       <b>CRYPTO_atomic_load_int()</b>, <b>OSSL_set_max_threads()</b>, <b>OSSL_get_max_threads()</b>, <b>OSSL_get_thread_support_flags()</b>
       were added in OpenSSL 3.2.

       <b>CRYPTO_atomic_store()</b>, <b>CRYPTO_atomic_add64()</b>, <b>CRYPTO_atomic_and()</b> were added in OpenSSL 3.4.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2000-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed  under  the  Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain  a  copy  in  the  file  LICENSE  in  the  source  distribution  or  at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                       <u><a href="../man3SSL/CRYPTO_THREAD_RUN_ONCE.3SSL.html">CRYPTO_THREAD_RUN_ONCE</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>