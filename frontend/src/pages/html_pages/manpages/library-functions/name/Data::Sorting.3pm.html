<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Sorting - Multi-key sort using function results</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-sorting-perl">libdata-sorting-perl_0.9-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Sorting - Multi-key sort using function results

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Data::Sorting qw( :basics :arrays :extras );

         # Sorting functions default to simple string comparisons
         @names = qw( Bob Alice Ellen Charlie David );
         @ordered = sorted_by( undef, @names );

         # Various options can be passed before the list values
         @ordered = sorted_by( [ -order=&gt;'reverse' ], @names );

         # You can also generate a sorting function and then apply it
         $function = sort_function();
         @ordered = $function-&gt;( @names );  # or &amp;{$function}(@names)
         @ordered = sort_function( -order=&gt;'reverse' )-&gt;( @names );

         # The :array functions are prototyped to take the array first
         @ordered = sorted_array( @names );
         @ordered = sorted_arrayref( \@names );

         # You can also sort an array in place, changing its internal order
         sort_array( @names );
         sort_arrayref( \@names );

         # There are several sorting options, such as -compare =&gt; 'natural'
         @movies = ( 'The Matrix', 'Plan 9', '2001', 'Terminator 2' );
         @ordered = sort_function( -compare =&gt; 'natural' )-&gt;( @movies );
         # @ ordered now contains '2001', 'The Matrix', 'Plan 9', 'Terminator 2'

         # To sort numbers, pass the -compare =&gt; 'numeric' option
         @numbers = ( 18, 5, 23, 42, 156, 91, 64 );
         @ordered = sorted_by( [ -compare =&gt; 'numeric' ], @numbers );
         @ordered = sort_function( -compare =&gt; 'numeric' )-&gt;( @numbers );
         @ordered = sorted_array( @numbers, -compare =&gt; 'numeric' );
         sort_array( @numbers, -compare =&gt; 'numeric' );

         # You can sort by the results of a function to be called on each item
         sort_array( @numbers, -compare =&gt; 'numeric', sub { $_[0] % 16 } );
         # @numbers now contains 64, 18, 5, 23, 42, 91, 156

         # For arrays of datastructures, pass in keys to extract for sorting
         @records = (
           { 'rec_id'=&gt;3, 'name'=&gt;{'first'=&gt;'Bob', 'last'=&gt;'Macy'} },
           { 'rec_id'=&gt;1, 'name'=&gt;{'first'=&gt;'Sue', 'last'=&gt;'Jones'} },
           { 'rec_id'=&gt;2, 'name'=&gt;{'first'=&gt;'Al',  'last'=&gt;'Jones' } },
         );
         @ordered = sorted_array( @records, 'rec_id' );

         # For nested data structures, pass an array of keys to fetch
         @ordered = sorted_array( @records, ['name','first'] );

         # Pass multiple sort keys for multiple-level sorts
         @ordered = sorted_array( @records, ['name','last'], ['name','first'] );

         # Any selected sort options are applied to all subsequent sort keys
         @ordered = sorted_array( @records,
                       -order =&gt; 'reverse', ['name','last'], ['name','first'] );

         # Options specified within a hash-ref apply only to that key
         @ordered = sorted_array( @records,
                       { order=&gt;'reverse', sortkey=&gt;['name','last'] },
                       ['name','first'] );

         # Locale support is available if you have Perl 5.004 or later and POSIX
         POSIX::setlocale( POSIX::LC_COLLATE(), 'en_US' );
         POSIX::setlocale( POSIX::LC_CTYPE(), 'en_US' );
         @ordered = sorted_array( @records,
                        -compare=&gt;'locale', ['name','last'], ['name','first'] );

</pre><h4><b>ABSTRACT</b></h4><pre>
       Data::Sorting provides functions to sort the contents of arrays based on a collection of extraction and
       comparison rules. Extraction rules are used to identify the attributes of array elements on which the
       ordering is based; comparison rules specify how those values should be ordered.

       Index strings may be used to retrieve values from array elements, or function references may be passed in
       to call on each element. Comparison rules are provided for numeric, bytewise, and case-insensitive
       orders, as well as a 'natural' comparison that places numbers first, in numeric order, followed by the
       remaining items in case-insensitive textual order.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides several public functions with different calling interfaces that all use the same
       underlying sorting mechanisms.

       These functions may be imported individually or in groups using the following tags:

       :basics  <b>sorted_by()</b>, <b>sort_function()</b>: General-purpose sorting functions.

       :array   <b>sorted_array()</b>,  <b>sorted_arrayref()</b>,  <b>sort_array()</b>,  <b>sort_arrayref()</b>:  Prototyped  functions  for
                arrays.

       :extras  <b>sort_key_values()</b>, <b>sort_description()</b>: Two accessory functions that explain how sorting is being
                carried out.

       All of these functions take a list of sorting rules as arguments. See "Sort Rule Syntax" for a discussion
       of the contents of the $sort_rule or @sort_rules parameters shown below.

   <b>sorted_by</b>
         @ordered = sorted_by( $sort_rule, @value_array );
         @ordered = sorted_by( $sort_rule, @$value_arrayref );
         @ordered = sorted_by( $sort_rule, $value1, $value2, $value3 );

         @ordered = sorted_by( \@sort_rules, @value_array );
         @ordered = sorted_by( \@sort_rules, @$value_arrayref );
         @ordered = sorted_by( \@sort_rules, $value1, $value2, $value3 );

       This is a general-purpose sorting function which accepts one or more sort order rules and a list of input
       values, then returns the values in the order specified by the rules.

   <b>sort_function</b>
         @ordered = sort_function( @sort_rules )-&gt;( @value_array );
         @ordered = sort_function( @sort_rules )-&gt;( @$value_arrayref );
         @ordered = sort_function( @sort_rules )-&gt;( $value1, $value2, $value3 );

       Creates an anonymous function which applies the provided sort rules. The function may be cached and  used
       multiple times to apply the same rules again.

   <b>sorted_array</b>
         @ordered = sorted_array( @value_array, @sort_rules );
         @ordered = sorted_array( @$value_arrayref, @sort_rules );

       Returns a sorted list of the items without altering the order of the original list.

   <b>sorted_arrayref</b>
         @ordered = sorted_arrayref( \@value_array, @sort_rules );
         @ordered = sorted_arrayref( $value_arrayref, @sort_rules );

       Returns a sorted list of the items without altering the order of the original list.

   <b>sort_array</b>
         sort_array( @value_array, @sort_rules );
         sort_array( @$value_arrayref, @sort_rules );

       Sorts the contents of the specified array using a list of sorting rules.

   <b>sort_arrayref</b>
         sort_arrayref( \@value_array, @sort_rules );
         sort_arrayref( $value_arrayref, @sort_rules );

       Equivalent  to  sort_array,  but  takes an explicit array reference as its first argument, rather than an
       array variable.

   <b>sort_key_values</b>
         @key_values = sort_key_values( \@value_array, @sort_rules );
         @key_values = sort_key_values( $value_arrayref, @sort_rules );

       Doesn't actually perform any sorting. Extracts and returns the values which would be used  as  sort  keys
       from each item in the array, in their original order.

   <b>sort_description</b>
         @description = sort_description( $descriptor, @sort_rules );

       Doesn't  actually  perform  any  sorting.  Provides  descriptive  information  about  the  sort rules for
       diagnostic purposes.

   <b>Sort</b> <b>Rule</b> <b>Syntax</b>
       The sort rule argument list  may  contain  several  different  types  of  parameters,  which  are  parsed
       identically by all of the public functions described above.

       A sort rule definition list may contain any combination of the following argument structures:

       <u>nothing</u>
           If no sort keys are specified, a default sort key is created using the "extract =&gt; "self"" option.

             @ordered = sorted_array( @names );

       <u>sortkey</u>
           Specifies  a  sort key. Each <u>sortkey</u> may be either a scalar value, or an array reference. Appropriate
           values for a <u>sortkey</u> vary depending on which "extract"  option  is  being  used,  and  are  discussed
           further below.

             @ordered = sorted_array( @numbers, sub { $_[0] % 8 } );
             @ordered = sorted_array( @records, 'rec_id' );
             @ordered = sorted_array( @records, ['name','first'] );

           Any number of sortkeys may be provided:

             @ordered = sorted_array( @records, ['name','last'],
                                                ['name','first'] );

       -sortkey =&gt; <u>sortkey</u>
           Another way of specifying a sort key is by preceding it with the "-sortkey" flag.

             @ordered = sorted_array( @numbers, -sortkey =&gt; sub { $_[0] % 8 } );
             @ordered = sorted_array( @records, -sortkey =&gt; ['name','last'],
                                                -sortkey =&gt; ['name','first'] );

       { sortkey =&gt; <u>sortkey</u>, <u>option</u> =&gt; <u>option_value</u>, ... }
           Additional  options can be specified by passing a reference to a hash containing a sortkey and values
           for any number of options described in the list below.

             @ordered = sorted_array( @numbers, { sortkey =&gt; sub { abs(shift) },
                                                  compare =&gt; 'numeric',     } );

       -<u>option</u> =&gt; <u>option_value</u>
           Sets a default option for any subsequent sortkeys in the argument list.

             @ordered = sorted_array( @records, -compare =&gt; 'numeric',
                                                -sortkey =&gt; sub { abs(shift) });

             @ordered = sorted_array( @records, -compare =&gt; 'textual',
                                                -sortkey =&gt; ['name','last'],
                                                -sortkey =&gt; ['name','first'] );

       The possible <u>option</u> values are:

       extract
           Determines the function which will be used to retrieve the sort key value from each item in the input
           list.

       compare
           Determines the function which will be used to order the extracted values.

       order
           Can be set to "reverse" or "descending" to invert the sort order. Defaults to "ascending".

       engine
           Determines the underlying sorting algorithm which will be used to implement the sort. Generally  left
           blank, enabling the module to select the best one available.

       Each of these options is discussed at further length below.

   <b>Extraction</b> <b>Functions</b>
       For the extract option, you may specify one of the following <u>option_value</u>s:

       any The  default.  Based  on  the  <u>sortkey</u> may behave as the 'self', 'key', or 'method' options described
           below.

       self
           Uses the input value as the sort key, unaltered. Typically used when sorting strings or other  scalar
           values.

       key Allows for indexing in to hash or array references, allowing you to sort a list of arrayrefs based on
           the <u>n</u>th value in each, or to sort a list of hashrefs based on a given key.

           If  the sortkey is an array reference, then the keys are looked up sequentially, allowing you to sort
           on the contents of a nested hash or array structure.

       method
           Uses the sortkey as a method name to be called on each list value, enabling you to  sort  objects  by
           some calculated value.

           If  the  sortkey  is  an  array  reference,  then  the first value is used as the method name and the
           remaining values as arguments to that method.

       <u>CODEREF</u>
           You may pass in a reference to a custom extraction function that will be used to  retrieve  the  sort
           key  values  for  this rule. The function will be called separately for each value in the input list,
           receiving that current value as an argument.

           If the sortkey is an array reference, then the first value is used as the function reference and  the
           remaining values as arguments to be passed after the item value.

           extract =&gt; self | method | key     | code    | CODEREF | ...
           sortkey =&gt; -    | m.name | key/idx | CODEREF | args

   <b>Comparison</b> <b>Functions</b>
       For the compare option, you may specify one of the following <u>option_value</u>s:

       cmp The default comparison, using Perl's default cmp operator.

       numeric
           A numeric comparison using Perl's &lt;=&gt; operator.

       textual
           A text-oriented comparison that ignores whitespace and capitalization.

       natural
           A  multi-type  comparison  that places empty values first, then numeric values in numeric order, then
           non-textual values like punctuation, followed by textual values in text order. The  natural  ordering
           also includes moving subsidiary words to the end, eg "The Book of Verse" is sorted as "Book of Verse,
           The"

       locale : $three_way_cmp
           Comparator functions which use the POSIX strcoll function for ordering.

       lc_locale : $three_way_cmp
           A case-insensitive version of the POSIX strcoll ordering.

       num_lc_locale
           Like  the  'natural'  style, this comparison distinguishes between empty and numeric values, but uses
           the lc_locale function to sort the textual values.

       <u>CODEREF</u>
           You may pass in a reference to a custom comparison function that will be used to order the  sort  key
           values for this rule.

       Each  of  these  functions may return a postive, zero, or negative value based on the relationship of the
       values in the $a and $b positions of the current @ValueSet array. An undefined return indicates that  the
       comparator  is unable to provide an ordering for this pair, in which case the choice will fall through to
       the next comparator in the list; if no comparator specifies an order, they are  left  in  their  original
       order.

   <b>Ascending</b> <b>or</b> <b>Descending</b> <b>Order</b>
       For the order option, you may specify one of the following <u>option_value</u>s:

       forward <u>or</u> ascending
           The default order, from lower values to higher ones.

       reverse <u>or</u> descending
           Reverses the ordering dictated by a sort rule.

   <b>Sorting</b> <b>Engines</b>
       Depending  on  the  specific  sorting  rules  used  in a given call, this module automatically selects an
       internal function that provides an appropriate  approach  to  implementing  the  sort,  called  the  sort
       "engine".

       You  can  override  this  selection by setting an "engine" option on the first sort key, which can either
       contain either the name of one of the engines, described below, or a CODEREF with equivalent behavior.

       trivial
           In the common case of sorting raw values with a cmp comparison, the fast-but-simple "trivial"  engine
           is used, which simply applies Perl's default sorting.

       orcish
           For a complex multi-key sort the "orcish" engine is typically selected.

       precalc
           Used when there's only one sorting key.

           You  may  also  set  the  $PreCalculate package variable to true to force this engine to be selected.
           Because the sort key values for the list  are  calculated  before  entering  Perl's  sort  operation,
           there's less of a chance of possible re-entry problems due to nested uses of the sort operator, which
           causes a fatal error in at least some versions of Perl.

       packed
           Some  sorts  are  handled  with the Guttman-Rosler technique, extracting packed keys and using Perl's
           default sort function, which is substantially faster, but currently only  a  limited  set  of  simple
           comparisons  can  be  handled  this  way.  (For  more  information  on  packed-default  sorting,  see
           <a href="http://www.sysarch.com/perl/sort_paper.html">http://www.sysarch.com/perl/sort_paper.html</a> or search for "Guttman-Rosler".)

</pre><h4><b>STATUS</b> <b>AND</b> <b>SUPPORT</b></h4><pre>
       This release of Data::Sorting is intended for public review and feedback.

         Name            DSLIP  Description
         --------------  -----  ---------------------------------------------
         Data::
         ::Sorting       bdpfp  Multi-key sort using function results

       Further information and support for this module is available at www.evoscript.org.

       Please report bugs or other problems to &lt;<a href="mailto:bugs@evoscript.com">bugs@evoscript.com</a>&gt;.

</pre><h4><b>BUGS</b> <b>AND</b> <b>TO</b> <b>DO</b></h4><pre>
       The following issues have been noted for future improvements:

       Convert more types of comparisons to packed-default sorts for speed.

       Further investigate the current status of the Sort::Records module.

       Add a comparator function for an alpha-numeric-spans sorting model like Sort::Naturally.

       Interface to Sort::PolySort for alternate comparator styles, like "name" and "usdate".

       For non-scalar values, compare referents along the lines of <b>Ref::cmpref()</b>.

       Provide better handling for nested sorts; perhaps throw an exception  from  the  inner  instance  to  the
       outer, catch and set $PreCalculate, then go back into the loop?

       Replace  dynamic  scoping with object instances for thread safety.  May not be necessary given changes in
       threading models.

</pre><h4><b>CREDITS</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
   <b>Developed</b> <b>By</b>
         M. Simon Cavalletto, <a href="mailto:simonm@cavalletto.org">simonm@cavalletto.org</a>
         Evolution Softworks, www.evoscript.org

   <b>Copyright</b>
       Copyright 2003 Matthew Cavalletto.

       Portions copyright 1996, 1997, 1998, 1999 Evolution Online Systems, Inc.

   <b>License</b>
       You may use, modify, and distribute this software under the same terms as Perl.

perl v5.36.0                                       2022-11-21                                       <u><a href="../man3pm/Sorting.3pm.html">Sorting</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>