<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPIx::QuoteLike - Parse Perl string literals and string-literal-like things.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libppix-quotelike-perl">libppix-quotelike-perl_0.023-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PPIx::QuoteLike - Parse Perl string literals and string-literal-like things.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PPIx::QuoteLike;

        my $str = PPIx::QuoteLike-&gt;new( q&lt;"fu$bar"&gt; );
        say $str-&gt;interpolates() ?
           'interpolates' :
           'does not interpolate';

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This Perl class parses Perl string literals and things that are reasonably like string literals. Its real
       reason for being is to find interpolated variables for Perl::Critic policies and similar code.

       The parse is fairly straightforward, and a little poking around with <u>eg/pqldump</u> should show how it
       normally goes.

       But there is at least one quote-like thing that probably needs some explanation.

   <b>Indented</b> <b>Here</b> <b>Documents</b>
       These were introduced in Perl 5.25.7 (November 2016) but not recognized by this module until its version
       0.015 (February 2021). The indentation is parsed as PPIx::QuoteLike::Token::Whitespace objects, provided
       it is at least one character wide, otherwise it is not represented in the parse. That is to say,

        &lt;&lt;~EOD
            How doth the little crocodile
            Improve his shining tail
            EOD

       will have the three indentations represented by whitespace objects and each line of the literal
       represented by its own string object, but

        &lt;&lt;~EOD
        How doth the little crocodile
        Improve his shining tail
        EOD

       will parse the same as the non-indented version, except for the addition of the token representing the
       '~'.

       PPI is ahead of this module, and recognized indented here documents as of its version 1.246 (May 2019).
       Unfortunately, as of version 1.270 the indent gets lost in the parse, so a "PPIx::QuoteLike" object
       initialized from such a PPI::Token::HereDoc will be seen as having an indentation of '' regardless of the
       actual indentation in the source.  I believe this restriction will go away when
       &lt;https://github.com/Perl-Critic/PPI/issues/251&gt; is resolved.

</pre><h4><b>DEPRECATION</b> <b>NOTICE</b></h4><pre>
       The "postderef" argument to <b>new()</b> is being put through a deprecation cycle and retracted. After the
       retraction, postfix dereferences will always be recognized.

       Starting with version 0.012_01, the first use of this argument warned.  With version 0.016_01, all uses
       warn. With version 0.017_01 all uses are fatal. With 0.0.021_01, all mention of this argument is removed,
       except of course for this notice.

</pre><h4><b>INHERITANCE</b></h4><pre>
       "PPIx::QuoteLike" is not descended from any other class.

       "PPIx::QuoteLike" has no descendants.

</pre><h4><b>METHODS</b></h4><pre>
       This class supports the following public methods:

   <b>new</b>
        my $str = PPIx::QuoteLike-&gt;new( $source, %arg );

       This static method parses the argument, and returns a new object containing the parse. The $source
       argument can be either a scalar or an appropriate PPI::Element object.

       If the $source argument is a scalar, it is presumed to represent a quote-like literal of some sort,
       provided it begins like one. Otherwise this method will return nothing. The scalar representation of a
       here document is a multi-line string whose first line consists of the leading " &lt;&lt; " and the start
       delimiter, and whose subsequent lines consist of the content of the here document and the end delimiter.
       Indented here documents were not supported by this class until version 0.015.

       "PPI" classes that can be handled are PPI::Token::Quote, PPI::Token::QuoteLike::Backtick,
       PPI::Token::QuoteLike::Command, PPI::Token::QuoteLike::Readline, and PPI::Token::HereDoc. Any other
       object will cause "new()" to return nothing.

       Additional optional arguments can be passed as name/value pairs.  Supported arguments are:

       encoding
           This  is  the  encoding  of  the  $source.  If this is specified as something other than "undef", the
           $source will be decoded before processing.

           If the $source is a "PPI::Element", this encoding is used only if  the  document  that  contains  the
           element has neither a byte order mark nor 'use utf8'.

       index_locations
           This  Boolean argument determines whether the locations of the tokens should be computed. It defaults
           to true if the $source argument is a PPI::Element or if the "location"  argument  was  provided,  and
           false otherwise.

       location
           This argument is a reference to an array compatible with that returned by the PPI::Element <b>location()</b>
           method.  It defaults to the location of the $source argument if that was a PPI::Element, otherwise no
           locations will be available.

       trace
           This Boolean argument causes a trace of the parse to be written to standard out. Setting  this  to  a
           true value is unsupported in the sense that the author makes no representation as to what will happen
           if  you do it, and reserves the right to make changes to the functionality, or retract it completely,
           without notice.

       All other arguments are unsupported and reserved to the author.

   <b>child</b>
        my $kid = $str-&gt;child( 0 );

       This method returns the child element whose index is given as the argument. Children do not  include  the
       <b>type()</b>,  or  the  <b>start()</b>  or  <b>finish()</b>  delimiters. Negative indices are valid, and given the usual Perl
       interpretation.

   <b>children</b>
        my @kids = $str-&gt;children();

       This method returns all child elements. Children do not include the <b>type()</b>, or the  <b>start()</b>  or  <b>finish()</b>
       delimiters.

   <b>column_number</b>
       This  method  returns the column number of the first character in the element, or "undef" if that can not
       be determined.

   <b>content</b>
        say $str-&gt;content();

       This method returns the content of the object. If the original argument was a  valid  Perl  string,  this
       should be the same as the originally-parsed string.

   <b>delimiters</b>
        say $str-&gt;delimiters();

       This  method  returns  the  delimiters of the object, as a string. This will be two characters unless the
       argument to <b>new()</b> was a here document, missing its end delimiter, or an invalid  string.  In  the  latter
       case the return might be anything.

   <b>elements</b>
        my @elem = $str-&gt;elements();

       This  method returns all elements of the object. This includes <b>type()</b>, <b>start()</b>, <b>children()</b>, and <b>finish()</b>,
       in that order.

   <b>failures</b>
        say $str-&gt;failures();

       This method returns the number of parse failures found. These are instances where the  parser  could  not
       figure  out  what  was  going on, and should be the same as the number of PPIx::QuoteLike::Token::Unknown
       objects returned by <b>elements()</b>.

   <b>find</b>
        for ( @{[ $str-&gt;find( $criteria ) || [] } ) {
            ...
        }

       This method finds and returns a reference to an array of all elements that meet the  given  criteria.  If
       nothing is found, a false value is returned.

       The  $criteria  can  be  either  the  name of a PPIx::QuoteLike::Token class, or a code reference. In the
       latter case, the code is called for each element in <b>elements()</b>, with the element as  the  only  argument.
       The element is included in the output if the code returns a true value.

   <b>finish</b>
        say map { $_-&gt;content() } $str-&gt;finish();

       This  method returns the finishing elements of the parse. It is actually an array, with the first element
       being a PPIx::QuoteLike::Token::Delimiter.  If the parse is of a here document there  will  be  a  second
       element, which will be a PPIx::QuoteLike::Token::Whitespace containing the trailing new line character.

       If  called in list context you get the whole array. If called in scalar context you get the element whose
       index is given in the argument, or element zero if no argument is specified.

   <b>handles</b>
        say PPIx::QuoteLike-&gt;handles( $string ) ?
            "We can handle $string" :
            "We can not handle $string";

       This convenience static method returns a true value if this package can be expected to handle the content
       of $string (be it scalar or object), and a false value otherwise.

   <b>indentation</b>
       This method returns the indentation string if the object represents an indented here document, or "undef"
       if it represents anything else, including an unindented here document.

       <b>Note</b> that if indented syntax is used but the here document is not in fact indented, this will return  '',
       which evaluates to false.

   <b>interpolates</b>
        say $str-&gt;interpolates() ?
            'The string interpolates' :
            'The string does not interpolate';

       This  method  returns  a  true value if the parsed string interpolates, and a false value if it does not.
       This does <b>not</b> indicate whether any interpolation actually takes place, only whether the string is double-
       quotish or single-quotish.

   <b>line_number</b>
       This method returns the line number of the first character in the element, or "undef" if that can not  be
       determined.

   <b>location</b>
       This  method  returns  a  reference  to an array describing the position of the string, or "undef" if the
       location is unavailable.

       The array is compatible with the corresponding PPI::Element method.

   <b>logical_filename</b>
       This method returns the logical file name (taking "#line" directives into account) of the file containing
       first character in the element, or "undef" if that can not be determined.

   <b>logical_line_number</b>
       This method returns the logical line number  (taking  "#line"  directives  into  account)  of  the  first
       character in the element, or "undef" if that can not be determined.

   <b>parent</b>
       This method returns nothing, since the invocant is only used at the top of the object hierarchy.

   <b>perl_version_introduced</b>
       This  method  returns  the maximum value of "perl_version_introduced" returned by any of its elements. In
       other words, it returns the minimum version of Perl under which this quote-like object is valid. If there
       are no elements, 5.000 is returned, since that is the minimum value of Perl supported by this package.

   <b>perl_version_removed</b>
       This method returns the minimum defined value of "perl_version_removed" returned by any of the quote-like
       object's elements. In other words, it returns the lowest version of Perl in which this  object  is  "not"
       valid.   If  there  are  no  elements,  or if no element has a defined "perl_version_removed", "undef" is
       returned.

   <b>schild</b>
        my $skid = $str-&gt;schild( 0 );

       This method returns the significant child elements whose index is given by the argument. Negative indices
       are interpreted in the usual way.

   <b>schildren</b>
        my @skids = $str-&gt;schildren();

       This method returns the significant children.

   <b>source</b>
        my $source = $str-&gt;source();

       This method returns the $source argument to <b>new()</b>, whatever it was.

   <b>start</b>
        say map { $_-&gt;content() } $str-&gt;start();

       This method returns the starting elements of the parse. It is actually an array, with the  first  element
       being  a  PPIx::QuoteLike::Token::Delimiter.   If  the parse is of a here document there will be a second
       element, which will be a PPIx::QuoteLike::Token::Whitespace containing the trailing new line character.

       If called in list context you get the whole array. If called in scalar context you get the element  whose
       index is given in the argument, or element zero if no argument is specified.

   <b>statement</b>
       This  method returns the PPI::Statement that contains this string, or nothing if the statement can not be
       determined.

       In general this method will return something only under the following conditions:

       •   The string is contained in a PPIx::QuoteLike object;

       •   That object was initialized from a PPI::Element;

       •   The PPI::Element is contained in a statement.

   <b>top</b>
       This method returns the top of the hierarchy -- in this case, the invocant.

   <b>type</b>
        my $type = $str-&gt;type();

       This method returns the type object. This will be a PPIx::QuoteLike::Token::Structure if  the  parse  was
       successful; otherwise it might be "undef". Its contents will be everything up to the start delimiter, and
       will typically be 'q', 'qq', 'qx',  '&lt;&lt;'  (for here documents), or '' (for quoted strings).

       The type data are actually an array. If the second element is present it will be the white space (if any)
       separating  the actual type from the value.  If called in list context you get the whole array. If called
       in scalar context you get the element whose index is given  in  the  argument,  or  element  zero  if  no
       argument is specified.

   <b>variables</b>
        say "Interpolates $_" for $str-&gt;variables();

       <b>NOTE</b>  that  this  method is discouraged, and may well be deprecated and removed. I have two problems with
       it. The first is that it returns variable names rather than PPI::Element objects, leaving you no idea how
       the variables are used. The second is that it does not properly handle things like "${^CAPTURE[0]}",  and
       it   seems   infeasible   to   make   it   do   so.   It  was  originally  written  for  the  benefit  of
       Perl::Critic::Policy::Variables::ProhibitUnusedVarsStricter, but has proven inadequate to  that  policy's
       needs.

       This  convenience  method  returns  all  interpolated variables. Each is returned only once, and they are
       returned in no particular order. If the object does not represent a string that interpolates, nothing  is
       returned.

   <b>visual_column_number</b>
       This  method  returns  the  visual column number (taking tabs into account) of the first character in the
       element, or "undef" if that can not be determined.

</pre><h4><b>RESTRICTIONS</b></h4><pre>
       By the nature of this module, it is never going to get everything right.  Many of the known problem areas
       involve interpolations one way or another.

   <b>Changes</b> <b>in</b> <b>Syntax</b>
       Sometimes the introduction of new syntax changes the way a string is parsed. For example, the "\F"  (fold
       case)  case  control was introduced in Perl 5.15.8. But it did not represent a syntax error prior to that
       version of Perl, it was simply parsed as "F". So

        $ perl -le 'print "Foo\FBar"'

       prints "FooFBar" under Perl 5.14.4, but "Foobar" under 5.16.0.  "PPIx::QuoteLike" generally  assumes  the
       more modern parse in cases like this.

   <b>Static</b> <b>Parsing</b>
       It is well known that Perl can not be statically parsed. That is, you can not completely parse a piece of
       Perl code without executing that same code.

       Nevertheless,  this  class is trying to statically parse quote-like things. I do not have any examples of
       where the parse of a quote-like thing would change based on what is interpolated, but neither can I  rule
       it out. <u>Caveat</u> <u>user</u>.

   <b>PPI</b> <b>Restrictions</b>
       As  of  version  0.015  of  this module, the only known instance of this is the handling of indented here
       documents, as discussed above under Indented Here Documents.

   <b>Non-Standard</b> <b>Syntax</b>
       There are modules out there that alter the syntax of Perl. If  the  syntax  of  a  quote-like  string  is
       altered,  this  module  has  no  way  to  understand  that it has been altered, much less to adapt to the
       alteration. The following modules are known to cause problems:

       Acme::PerlML, which renders Perl as XML.

       "Data::PostfixDeref", which causes Perl to interpret suffixed empty brackets as dereferencing  the  thing
       they suffix. This module by Ben Morrow ("BMORROW") appears to have been retracted.

       Filter::Trigraph, which recognizes ANSI C trigraphs, allowing Perl to be written in the ISO 646 character
       set.

       Perl6::Pugs. Enough said.

</pre><h4><b>SUPPORT</b></h4><pre>
       Support       is       by       the       author.       Please       file       bug       reports      at
       &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=PPIx-QuoteLike&gt;,
       &lt;https://github.com/trwyant/perl-PPIx-QuoteLike/issues&gt;, or in electronic mail to the author.

</pre><h4><b>AUTHOR</b></h4><pre>
       Thomas R. Wyant, III <u>wyant</u> <u>at</u> <u>cpan</u> <u>dot</u> <u>org</u>

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2016-2022 by Thomas R. Wyant, III

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       5.10.0. For more details, see the full text of the licenses in the directory LICENSES.

       This  program  is  distributed in the hope that it will be useful, but without any warranty; without even
       the implied warranty of merchantability or fitness for a particular purpose.

perl v5.36.0                                       2022-09-21                               <u>PPIx::<a href="../man3pm/QuoteLike.3pm.html">QuoteLike</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>