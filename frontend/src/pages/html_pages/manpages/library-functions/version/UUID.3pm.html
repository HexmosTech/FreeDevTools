<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UUID - Universally Unique Identifier library for Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libuuid-perl">libuuid-perl_0.37-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       UUID - Universally Unique Identifier library for Perl

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # SIMPLE
           use UUID qw(uuid);    # see EXPORTS
           my $str = uuid();     # generate version 4 UUID string

           # SPECIFIC
           $str = uuid1();                   # new version 1 UUID string
           $str = uuid4();                   # new version 4 UUID string
           $str = uuid6();                   # new version 6 UUID string
           $str = uuid7();                   # new version 7 UUID string

           # NAMESPACE is 'dns', 'url', 'oid', or 'x500'; case-insensitive.
           $str = uuid3(dns =&gt; 'www.example.com');
           $str = uuid5(url =&gt; 'https://www.example.com/foo.html');

           UUID::generate_v1($bin);          # new version 1 binary UUID
           UUID::generate_v4($bin);          # new version 4 binary UUID
           UUID::generate_v6($bin);          # new version 6 binary UUID
           UUID::generate_v7($bin);          # new version 7 binary UUID

           UUID::generate_v3($bin, dns =&gt; 'www.example.com');
           UUID::generate_v5($bin, url =&gt; 'https://www.example.com/foo.txt');

           UUID::generate($bin);             # alias for generate_v1()
           UUID::generate_time($bin);        # alias for generate_v1()
           UUID::generate_random($bin);      # alias for generate_v4()

           UUID::unparse($bin, $str);        # stringify $bin; prefer lowercase
           UUID::unparse_lower($bin, $str);  # force lowercase stringify
           UUID::unparse_upper($bin, $str);  # force uppercase stringify

           UUID::parse($str, $bin);          # map string to binary UUID

           UUID::compare($bin1, $bin2);      # compare binary UUIDs
           UUID::copy($dst, $src);           # copy binary UUID from $src to $dst

           UUID::clear($bin);                # set binary UUID to NULL
           UUID::is_null($bin);              # compare binary UUID to NULL

           UUID::time($bin);                 # return UUID time
           UUID::type($bin);                 # return UUID type
           UUID::variant($bin);              # return UUID variant
           UUID::version($bin);              # return UUID version

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The UUID library is used to generate unique identifiers for objects that may be accessible beyond the
       local system. For instance, they could be used to generate unique HTTP cookies across multiple web
       servers without communication between the servers, and without fear of a name clash.

       The generated UUIDs can be reasonably expected to be unique within a system, and unique across all
       systems, and are compatible with those created by the Open Software Foundation (OSF) Distributed
       Computing Environment (DCE).

       All generated UUIDs are either version 1, 3, 4, 5, 6, or version 7. And all are variant 1, meaning
       compliant with the OSF DCE standard as described in RFC4122.

       Versions 6 and 7 are not standardized. They are presented here as proposed in RFC4122bis, version 14, and
       may change in the future.  RFC4122bis is noted to replace RFC4122, if approved.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       Most of the UUID functions expose the historically underlying <u>libuuid</u> C interface rather directly. That
       is, many return their values in their parameters and nothing else.

       Not very Perlish, but it's been like that for a long time so not likely to change any time soon.

       All take or return UUIDs in either binary or string format. The string format resembles the following:

           21b081a3-de83-4480-a14f-e89a1dcf8f0f

       Or, in terms of <b><a href="../man3/printf.3.html">printf</a></b>(3) format:

           "%08x-%04x-%04x-%04x-%012x"

       The binary form is simply a packed 16 byte binary value.

   <b>clear(</b> <u><b>$uuid</b></u> <b>)</b>
       Sets binary <u>$uuid</u> equal to the value of the NULL UUID.

   <b>compare(</b> <u><b>$uuid1</b></u><b>,</b> <u><b>$uuid2</b></u> <b>)</b>
       Compares two binary UUIDs.

       Returns an integer less than, equal to, or greater than zero if <u>$uuid1</u> is less than, equal to, or greater
       than <u>$uuid2</u>.

       If one is defined and the other not, the defined value is deemed the larger.

       If either operand is not a binary UUID, falls back to a simple string comparison returning similar
       values.

   <b>copy(</b> <u><b>$dst</b></u><b>,</b> <u><b>$src</b></u> <b>)</b>
       Copies the binary <u>$src</u> UUID to <u>$dst</u>.

       If <u>$src</u> isn't a UUID, <u>$dst</u> is set to the NULL UUID.

   <b>generate(</b> <u><b>$uuid</b></u> <b>)</b>
       Alias for <b>generate_v4()</b>.

       Prior to version 0.33, this function provided either a binary version 4 UUID or fell back to version 1 in
       some cases. This is no longer the case. The fallback feature was removed with the addition of an onboard
       crypto-strength number generator.

   <b>generate_random(</b> <u><b>$uuid</b></u> <b>)</b>
       Alias for <b>generate_v4()</b>.

   <b>generate_time(</b> <u><b>$uuid</b></u> <b>)</b>
       Alias for <b>generate_v1()</b>.

   <b>generate_v1(</b> <u><b>$uuid</b></u> <b>)</b>
       Generates a new version 1 binary UUID using the current time and the local ethernet MAC address, if
       available.

       If the MAC address is not available at startup, or a randomized address is requested (see <b>:mac</b> in
       <b>EXPORTS</b>), a random address is used. The multicast bit of this address is set to avoid conflict with
       addresses returned from network cards.

   <b>generate_v3(</b> <u><b>$uuid</b></u><b>,</b> <u><b>NAMESPACE</b></u> <b>=&gt;</b> <u><b>NAME</b></u> <b>)</b>
       Generate a new version 3 binary UUID using the given namespace and name hashed through the MD5 algorithm.

       Namespace is one of "dns", "url", "oid", or "x500", and case-insensitive. It is used to select the
       namespace UUID to hash with the name.

       Name should be an entity from the given namespace, but can really be any text.

   <b>generate_v4(</b> <u><b>$uuid</b></u> <b>)</b>
       Generates a new version 4 binary UUID using mostly random data. There are 6 bits used for the UUID
       format, leaving 122 bits for randomness.

   <b>generate_v5(</b> <u><b>$uuid</b></u><b>,</b> <u><b>NAMESPACE</b></u> <b>=&gt;</b> <u><b>NAME</b></u> <b>)</b>
       Generate a new version 5 binary UUID using the given namespace and name hashed through the SHA1
       algorithm.

       Namespace is one of "dns", "url", "oid", or "x500", and case-insensitive. It is used to select the
       namespace UUID to hash with the name.

       Name should be an entity from the given namespace, but can really be any text.

   <b>generate_v6(</b> <u><b>$uuid</b></u> <b>)</b>
       Generates a new version 6 binary UUID using the current time and the local ethernet MAC address, if
       available.

       If the MAC address is not available at startup, or a randomized address is requested (see <b>:mac</b> in
       <b>EXPORTS</b>), a random address is used. The multicast bit of this address is set to avoid conflict with
       addresses returned from network cards.

       Version 6 is the same as version 1, with reversed time fields to make it more database friendly.

   <b>generate_v7(</b> <u><b>$uuid</b></u> <b>)</b>
       Generates a new version 7 binary UUID using the current time and random data. There are 6 bits used for
       the UUID format and 48 bits for timestamp, leaving 74 bits for randomness.

       Version 7 is the same as version 6, in that it uses reversed timestamp fields, but also uses a Unix epoch
       time base instead of Gregorian.

   <b>is_null(</b> <u><b>$uuid</b></u> <b>)</b>
       Compares the value of <u>$uuid</u> to the NULL UUID.

       Returns 1 if NULL, and 0 otherwise.

   <b>parse(</b> <u><b>$string</b></u><b>,</b> <u><b>$uuid</b></u> <b>)</b>
       Converts the string format UUID in <u>$string</u> to binary and returns in <u>$uuid</u>. The previous content of <u>$uuid</u>,
       if any, is lost.

       Returns 0 on success and -1 on failure. Additionally on failure, the content of <u>$uuid</u> is unchanged.

   <b>time(</b> <u><b>$uuid</b></u> <b>)</b>
       Returns the time element of a binary UUID in seconds since the epoch, the same as <u>Perl</u>'s <b>time</b> function.

       Keep in mind this only works for version 1, 6, and version 7 UUIDs.  Values returned from other versions
       are always 0.

   <b>type(</b> <u><b>$uuid</b></u> <b>)</b>
       Alias for <b>version()</b>.

   <b>unparse(</b> <u><b>$uuid</b></u><b>,</b> <u><b>$string</b></u> <b>)</b>
       Alias for <b>unparse_lower()</b>.

       Prior to version 0.32, casing of the return value was system-dependent.  Later versions are lowercase,
       per RFC4122.

   <b>unparse_lower(</b> <u><b>$uuid</b></u><b>,</b> <u><b>$string</b></u> <b>)</b>
       Converts the binary UUID in <u>$uuid</u> to string format and returns in <u>$string</u>. The previous content of
       <u>$string</u>, if any, is lost.

   <b>unparse_upper(</b> <u><b>$uuid</b></u><b>,</b> <u><b>$string</b></u> <b>)</b>
       Same as <b>unparse_lower()</b> but <u>$string</u> is forced to upper case.

   <b>uuid()</b>
       Alias for <b>uuid4()</b>.

   <b>uuid0()</b>
       Returns a new string format NULL UUID.

   <b>uuid1()</b>
       Returns a new string format version 1 UUID. Functionally the equivalent of calling <b>generate_v1()</b> then
       <b>unparse()</b>, but throwing away the intermediate binary UUID.

   <b>uuid3(NAMESPACE</b> <b>=</b> <b>NAME)&gt;</b>
       Same as <b>uuid1()</b> but version 3. See <b>generate_v3()</b>.

   <b>uuid4()</b>
       Same as <b>uuid1()</b> but version 4.

   <b>uuid5(NAMESPACE</b> <b>=</b> <b>NAME)&gt;</b>
       Same as <b>uuid1()</b> but version 5. See <b>generate_v5()</b>.

   <b>uuid6()</b>
       Same as <b>uuid1()</b> but version 6.

   <b>uuid7()</b>
       Same as <b>uuid1()</b> but version 7.

   <b>variant(</b> <u><b>$uuid</b></u> <b>)</b>
       Returns the variant of binary <u>$uuid</u>.

       This module only generates variant 1 UUIDs. Others may be found in the wild.

       Known variants:

           0  NCS
           1  DCE
           2  Microsoft
           3  Other

   <b>version(</b> <u><b>$uuid</b></u><b>&gt;</b> <b>)</b>
       Returns the version of binary <u>$uuid</u>.

       This module only generates version 1, 3, 4, 5, 6, and version 7 UUIDs.  Others may be found in the wild.

       Known versions:

           v1  date/time and node address
           v2  date/time and node address, security version
           v3  namespace based, MD5 hash
           v4  random
           v5  namespace based, SHA-1 hash
           v6  reverse date/time and node address
           v7  reverse unix date/time and random
           v8  custom

</pre><h4><b>MAINTAINING</b> <b>STATE</b></h4><pre>
       Internal state is optionally maintained for timestamped UUIDs (versions 1, 6, and 7) via a file
       designated by the <b>:persist</b> export tag. See <b>EXPORTS</b> for details.

       The file records various internal states at the time the last UUID is generated, preventing future
       instances from overlapping the prior UUID sequence. This allows the sequence to absolutely survive
       reboots and, more importantly, backwards resetting of system time.

       If <b>:persist</b> is not used, time resets will still be detected while the module is loaded and handled by
       incrementing the UUID clock_seq field.  The clock_seq field is randomly initialized in this case anyway,
       so the chance of overlap is low but still exists since clock_seq is only 14 bits wide. Using a random MAC
       will help (see <b>:mac</b> in <b>EXPORTS</b>), adding an additional 48 bits of randomness.

       <b>NOTE:</b> Using <b>:persist</b> incurs a serious performance penalty, in excess of 95% on tested platforms. You can
       run "make compare" in the distribution directory to see how this might affect your application, but
       unless you need many thousands of UUIDs/sec it's probably a non-issue.

</pre><h4><b>RANDOM</b> <b>NUMBERS</b></h4><pre>
       Versions 4 and 7 UUIDs are partially filled with random numbers, as well as versions 1 and 6 when used
       with the <b>:mac</b> option.

       Prior to version 0.33, UUID obtained randomness from the system's <u>/dev/random</u> device, or similar
       interface. On some platforms it called <b>getrandom()</b> and on others it read directly from <u>/dev/urandom</u>. And
       of course, Win32 did something completely different.

       Starting in 0.33, UUID generates random numbers itself using the ChaCha20 algorithm which is considered
       crypto-strength in most circles.  This is the same algo used as the basis for many modern kernel RNGs,
       albeit without the same entropy gathering ability.

       To compensate, UUID mixes the output from ChaCha with output from another RNG, Xoshiro. The idea is that
       by mixing the two, the true output from either is effectively hidden, making discovery of either's key
       much more unlikely than it already is. And without the keys, you can't predict the future.

       Well, that's the theory anyway.

</pre><h4><b>NAMESPACES</b></h4><pre>
       Versions 3 and 5 generate UUIDs within namespaces. What this really means is that the <u>NAME</u> value is
       concatenated with a dedicated <u>NAMESPACE</u> UUID before hashing.

       Available namespaces and UUIDs:

           dns   6ba7b810-9dad-11d1-80b4-00c04fd430c8
           url   6ba7b811-9dad-11d1-80b4-00c04fd430c8
           oid   6ba7b812-9dad-11d1-80b4-00c04fd430c8
           x500  6ba7b814-9dad-11d1-80b4-00c04fd430c8

       For example, if you need to create some UUIDs within your own "questions" and "answers" namespaces using
       SHA1:

           $ns_base = uuid5( dns =&gt; 'www.example.com' );

           $ns_questions = uuid5( $ns_base, 'questions' );
           $ns_answers   = uuid5( $ns_base, 'answers'   );

           for $topic ( next_qa_aref() ) {
               ($q, $a) = @$topic;
               $uuid_question = uuid5( $ns_questions, $q );
               $uuid_answer   = uuid5( $ns_answers,   $a );
               ...
           }

       This way, you can deterministically convert existing (and likely colliding) namespaces over to one UUID
       namespace, which is often useful when merging datasets.

       You also don't need to publish your base and namespace UUIDs. Anyone using the same logic can generate
       the same question and answer UUIDs.

</pre><h4><b>EXPORTS</b></h4><pre>
       None by default. All functions may be imported in the usual manner, either individually or all at once
       using the <b>:all</b> tag.

       Beware that importing <b>:all</b> clobbers <u>Perl</u>'s <b>time()</b>, not to mention a few other commonly used subs, like
       <b>copy()</b> from <u>File::Copy</u>.

   <b>:mac=</b><u><b>mode</b></u>
       The MAC address used for MAC-inclusive UUIDS (versions 1 and 6) is forced to always be random in one of
       two modes:

           <u>random</u> The MAC address is generated once at startup and used through the lifetime of the process.
           This is the default if a real MAC cannot be found.

           <u>unique</u> A new MAC address is generated for each new UUID. It is not guaranteed to be unique beyond the
           probability of randomness.

   <b>:persist=</b><u><b>path/to/state.txt</b></u>
       Path to timestamp state maintenance file. (See <b>MAINTAINING</b> <b>STATE</b>.)  The path may be either relative or
       absolute.

       If the file does not exist, it will be created provided the path exists and the user has permission.

       If the file cannot be opened, cannot be created, or is a symlink, UUID will ignore it. No state will be
       maintained.

       <b>WARNING</b>: Do not <b>:persist</b> in a public directory. See CVE-2013-4184.  UUID attempts to avoid this, but
       nothing is foolproof. Only YOU can prevent symlink attacks!

   <b>:defer[=</b><u><b>N</b></u><b>]</b>
       Persistence of state is deferred <u>N</u> seconds when generating time-based UUIDs. More precisely, state is
       only saved every <u>N</u> seconds. If UUIDs are generated more often, those within the <u>N</u> second window will not
       save state.

       Defer values greater than some platform-specific interval greatly reduce the performance penalty
       introduced through persistence. While the default, <b>:defer=0.001</b>, is probably fine, you can run <b>make</b>
       <b>persist</b> in the distribution directory to see the effect of various values.

</pre><h4><b>THREAD</b> <b>SAFETY</b></h4><pre>
       This module is believed to be thread safe.

</pre><h4><b>UUID</b> <b>LIBRARY</b></h4><pre>
       Releases prior to UUID-0.32 required libuuid or similar be installed first. This is no longer the case.
       Version 0.33 bundled the e2fsprogs UUID code, and version 0.34 removed it altogether.

</pre><h4><b>BENCHMARKS</b></h4><pre>
       There are a few benchmarks in the distribution ubin directory which can be run either standalone or
       through the Makefile.

   <b>make</b> <b>compare</b>
       Runs all three of the following tests.

   <b>make</b> <b>speeds</b>
       Runs ubin/cmp_speeds.pl to compare the speeds of various UUID versions.

   <b>make</b> <b>styles</b>
       Runs ubin/cmp_styles.pl to compare different UUID calling styles.

   <b>make</b> <b>persist</b>
       Runs ubin/cmp_persist.pl to compare different deferral values for persistent state.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2014-2025 by Rick Myers.

       This is free software, licensed under:

         The Artistic License 2.0 (GPL Compatible)

       Details of this license can be found within the 'LICENSE' text file.

</pre><h4><b>AUTHOR</b></h4><pre>
       Current maintainer:

         Rick Myers &lt;<a href="mailto:jrm@cpan.org">jrm@cpan.org</a>&gt;.

       Authors and/or previous maintainers:

         Lukas Zapletal &lt;<a href="mailto:lzap@cpan.org">lzap@cpan.org</a>&gt;

         Joseph N. Hall &lt;<a href="mailto:joseph.nathan.hall@gmail.com">joseph.nathan.hall@gmail.com</a>&gt;

         Colin Faber &lt;<a href="mailto:cfaber@clusterfs.com">cfaber@clusterfs.com</a>&gt;

         Peter J. Braam &lt;<a href="mailto:braam@mountainviewdata.com">braam@mountainviewdata.com</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       David E. Wheeler

       William Faulk

       gregor herrmann

       Slaven Rezic

       twata

       Christopher Rasch-Olsen Raa

       Petr Pisar

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>RFC4122</b> - &lt;https://www.rfc-editor.org/rfc/rfc4122&gt;

       <b>RFC4122bis</b> - &lt;https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-14.html&gt;

       <b><a href="../man1/perl.1.html">perl</a>(1)</b>.

perl v5.40.1                                       2025-03-01                                          <u><a href="../man3pm/UUID.3pm.html">UUID</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>