<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>realOTHERauxiliary - real</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/liblapack-doc">liblapack-doc_3.10.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       realOTHERauxiliary - real

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       integer function <b>ilaslc</b> (M, N, A, LDA)
           <b>ILASLC</b> scans a matrix for its last non-zero column.
       integer function <b>ilaslr</b> (M, N, A, LDA)
           <b>ILASLR</b> scans a matrix for its last non-zero row.
       subroutine <b>slabrd</b> (M, N, NB, A, LDA, D, E, TAUQ, TAUP, X, LDX, Y, LDY)
           <b>SLABRD</b> reduces the first nb rows and columns of a general matrix to a bidiagonal form.
       subroutine <b>slacn2</b> (N, V, X, ISGN, EST, KASE, ISAVE)
           <b>SLACN2</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-
           vector products.
       subroutine <b>slacon</b> (N, V, X, ISGN, EST, KASE)
           <b>SLACON</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-
           vector products.
       subroutine <b>sladiv</b> (A, B, C, D, P, Q)
           <b>SLADIV</b> performs complex division in real arithmetic, avoiding unnecessary overflow.
       subroutine <b>sladiv1</b> (A, B, C, D, P, Q)
       real function <b>sladiv2</b> (A, B, C, D, R, T)
       subroutine <b>slaein</b> (RIGHTV, NOINIT, N, H, LDH, WR, WI, VR, VI, B, LDB, WORK, EPS3, SMLNUM, BIGNUM, INFO)
           <b>SLAEIN</b> computes a specified right or left eigenvector of an upper Hessenberg matrix by inverse
           iteration.
       subroutine <b>slaexc</b> (WANTQ, N, T, LDT, Q, LDQ, J1, N1, N2, WORK, INFO)
           <b>SLAEXC</b> swaps adjacent diagonal blocks of a real upper quasi-triangular matrix in Schur canonical
           form, by an orthogonal similarity transformation.
       subroutine <b>slag2</b> (A, LDA, B, LDB, SAFMIN, SCALE1, SCALE2, WR1, WR2, WI)
           <b>SLAG2</b> computes the eigenvalues of a 2-by-2 generalized eigenvalue problem, with scaling as necessary
           to avoid over-/underflow.
       subroutine <b>slags2</b> (UPPER, A1, A2, A3, B1, B2, B3, CSU, SNU, CSV, SNV, CSQ, SNQ)
           <b>SLAGS2</b> computes 2-by-2 orthogonal matrices U, V, and Q, and applies them to matrices A and B such
           that the rows of the transformed A and B are parallel.
       subroutine <b>slagtm</b> (TRANS, N, NRHS, ALPHA, DL, D, DU, X, LDX, BETA, B, LDB)
           <b>SLAGTM</b> performs a matrix-matrix product of the form C = αAB+βC, where A is a tridiagonal matrix, B
           and C are rectangular matrices, and α and β are scalars, which may be 0, 1, or -1.
       subroutine <b>slagv2</b> (A, LDA, B, LDB, ALPHAR, ALPHAI, BETA, CSL, SNL, CSR, SNR)
           <b>SLAGV2</b> computes the Generalized Schur factorization of a real 2-by-2 matrix pencil (A,B) where B is
           upper triangular.
       subroutine <b>slahqr</b> (WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI, ILOZ, IHIZ, Z, LDZ, INFO)
           <b>SLAHQR</b> computes the eigenvalues and Schur factorization of an upper Hessenberg matrix, using the
           double-shift/single-shift QR algorithm.
       subroutine <b>slahr2</b> (N, K, NB, A, LDA, TAU, T, LDT, Y, LDY)
           <b>SLAHR2</b> reduces the specified number of first columns of a general rectangular matrix A so that
           elements below the specified subdiagonal are zero, and returns auxiliary matrices which are needed to
           apply the transformation to the unreduced part of A.
       subroutine <b>slaic1</b> (JOB, J, X, SEST, W, GAMMA, SESTPR, S, C)
           <b>SLAIC1</b> applies one step of incremental condition estimation.
       subroutine <b>slaln2</b> (LTRANS, NA, NW, SMIN, CA, A, LDA, D1, D2, B, LDB, WR, WI, X, LDX, SCALE, XNORM, INFO)
           <b>SLALN2</b> solves a 1-by-1 or 2-by-2 linear system of equations of the specified form.
       real function <b>slangt</b> (NORM, N, DL, D, DU)
           <b>SLANGT</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value
           of any element of a general tridiagonal matrix.
       real function <b>slanhs</b> (NORM, N, A, LDA, WORK)
           <b>SLANHS</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value
           of any element of an upper Hessenberg matrix.
       real function <b>slansb</b> (NORM, UPLO, N, K, AB, LDAB, WORK)
           <b>SLANSB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a symmetric band matrix.
       real function <b>slansp</b> (NORM, UPLO, N, AP, WORK)
           <b>SLANSP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a symmetric matrix supplied in packed form.
       real function <b>slantb</b> (NORM, UPLO, DIAG, N, K, AB, LDAB, WORK)
           <b>SLANTB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a triangular band matrix.
       real function <b>slantp</b> (NORM, UPLO, DIAG, N, AP, WORK)
           <b>SLANTP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a triangular matrix supplied in packed form.
       real function <b>slantr</b> (NORM, UPLO, DIAG, M, N, A, LDA, WORK)
           <b>SLANTR</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a trapezoidal or triangular matrix.
       subroutine <b>slanv2</b> (A, B, C, D, RT1R, RT1I, RT2R, RT2I, CS, SN)
           <b>SLANV2</b> computes the Schur factorization of a real 2-by-2 nonsymmetric matrix in standard form.
       subroutine <b>slapll</b> (N, X, INCX, Y, INCY, SSMIN)
           <b>SLAPLL</b> measures the linear dependence of two vectors.
       subroutine <b>slapmr</b> (FORWRD, M, N, X, LDX, K)
           <b>SLAPMR</b> rearranges rows of a matrix as specified by a permutation vector.
       subroutine <b>slapmt</b> (FORWRD, M, N, X, LDX, K)
           <b>SLAPMT</b> performs a forward or backward permutation of the columns of a matrix.
       subroutine <b>slaqp2</b> (M, N, OFFSET, A, LDA, JPVT, TAU, VN1, VN2, WORK)
           <b>SLAQP2</b> computes a QR factorization with column pivoting of the matrix block.
       subroutine <b>slaqps</b> (M, N, OFFSET, NB, KB, A, LDA, JPVT, TAU, VN1, VN2, AUXV, F, LDF)
           <b>SLAQPS</b> computes a step of QR factorization with column pivoting of a real m-by-n matrix A by using
           BLAS level 3.
       subroutine <b>slaqr0</b> (WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI, ILOZ, IHIZ, Z, LDZ, WORK, LWORK, INFO)
           <b>SLAQR0</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
           decomposition.
       subroutine <b>slaqr1</b> (N, H, LDH, SR1, SI1, SR2, SI2, V)
           <b>SLAQR1</b> sets a scalar multiple of the first column of the product of 2-by-2 or 3-by-3 matrix H and
           specified shifts.
       subroutine <b>slaqr2</b> (WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ, IHIZ, Z, LDZ, NS, ND, SR, SI, V, LDV,
           NH, T, LDT, NV, WV, LDWV, WORK, LWORK)
           <b>SLAQR2</b> performs the orthogonal similarity transformation of a Hessenberg matrix to detect and deflate
           fully converged eigenvalues from a trailing principal submatrix (aggressive early deflation).
       subroutine <b>slaqr3</b> (WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ, IHIZ, Z, LDZ, NS, ND, SR, SI, V, LDV,
           NH, T, LDT, NV, WV, LDWV, WORK, LWORK)
           <b>SLAQR3</b> performs the orthogonal similarity transformation of a Hessenberg matrix to detect and deflate
           fully converged eigenvalues from a trailing principal submatrix (aggressive early deflation).
       subroutine <b>slaqr4</b> (WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI, ILOZ, IHIZ, Z, LDZ, WORK, LWORK, INFO)
           <b>SLAQR4</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
           decomposition.
       subroutine <b>slaqr5</b> (WANTT, WANTZ, KACC22, N, KTOP, KBOT, NSHFTS, SR, SI, H, LDH, ILOZ, IHIZ, Z, LDZ, V,
           LDV, U, LDU, NV, WV, LDWV, NH, WH, LDWH)
           <b>SLAQR5</b> performs a single small-bulge multi-shift QR sweep.
       subroutine <b>slaqsb</b> (UPLO, N, KD, AB, LDAB, S, SCOND, AMAX, EQUED)
           <b>SLAQSB</b> scales a symmetric/Hermitian band matrix, using scaling factors computed by spbequ.
       subroutine <b>slaqsp</b> (UPLO, N, AP, S, SCOND, AMAX, EQUED)
           <b>SLAQSP</b> scales a symmetric/Hermitian matrix in packed storage, using scaling factors computed by
           sppequ.
       subroutine <b>slaqtr</b> (LTRAN, LREAL, N, T, LDT, B, W, SCALE, X, WORK, INFO)
           <b>SLAQTR</b> solves a real quasi-triangular system of equations, or a complex quasi-triangular system of
           special form, in real arithmetic.
       subroutine <b>slar1v</b> (N, B1, BN, LAMBDA, D, L, LD, LLD, PIVMIN, GAPTOL, Z, WANTNC, NEGCNT, ZTZ, MINGMA, R,
           ISUPPZ, NRMINV, RESID, RQCORR, WORK)
           <b>SLAR1V</b> computes the (scaled) r-th column of the inverse of the submatrix in rows b1 through bn of the
           tridiagonal matrix LDLT - λI.
       subroutine <b>slar2v</b> (N, X, Y, Z, INCX, C, S, INCC)
           <b>SLAR2V</b> applies a vector of plane rotations with real cosines and real sines from both sides to a
           sequence of 2-by-2 symmetric/Hermitian matrices.
       subroutine <b>slarf</b> (SIDE, M, N, V, INCV, TAU, C, LDC, WORK)
           <b>SLARF</b> applies an elementary reflector to a general rectangular matrix.
       subroutine <b>slarfb</b> (SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV, T, LDT, C, LDC, WORK, LDWORK)
           <b>SLARFB</b> applies a block reflector or its transpose to a general rectangular matrix.
       subroutine <b>slarfg</b> (N, ALPHA, X, INCX, TAU)
           <b>SLARFG</b> generates an elementary reflector (Householder matrix).
       subroutine <b>slarfgp</b> (N, ALPHA, X, INCX, TAU)
           <b>SLARFGP</b> generates an elementary reflector (Householder matrix) with non-negative beta.
       subroutine <b>slarft</b> (DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT)
           <b>SLARFT</b> forms the triangular factor T of a block reflector H = I - vtvH
       subroutine <b>slarfx</b> (SIDE, M, N, V, TAU, C, LDC, WORK)
           <b>SLARFX</b> applies an elementary reflector to a general rectangular matrix, with loop unrolling when the
           reflector has order ≤ 10.
       subroutine <b>slarfy</b> (UPLO, N, V, INCV, TAU, C, LDC, WORK)
           <b>SLARFY</b>
       subroutine <b>slargv</b> (N, X, INCX, Y, INCY, C, INCC)
           <b>SLARGV</b> generates a vector of plane rotations with real cosines and real sines.
       subroutine <b>slarrv</b> (N, VL, VU, D, L, PIVMIN, ISPLIT, M, DOL, DOU, MINRGP, RTOL1, RTOL2, W, WERR, WGAP,
           IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ, WORK, IWORK, INFO)
           <b>SLARRV</b> computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues
           of L D LT.
       subroutine <b>slartv</b> (N, X, INCX, Y, INCY, C, S, INCC)
           <b>SLARTV</b> applies a vector of plane rotations with real cosines and real sines to the elements of a pair
           of vectors.
       subroutine <b>slaswp</b> (N, A, LDA, K1, K2, IPIV, INCX)
           <b>SLASWP</b> performs a series of row interchanges on a general rectangular matrix.
       subroutine <b>slatbs</b> (UPLO, TRANS, DIAG, NORMIN, N, KD, AB, LDAB, X, SCALE, CNORM, INFO)
           <b>SLATBS</b> solves a triangular banded system of equations.
       subroutine <b>slatdf</b> (IJOB, N, Z, LDZ, RHS, RDSUM, RDSCAL, IPIV, JPIV)
           <b>SLATDF</b> uses the LU factorization of the n-by-n matrix computed by sgetc2 and computes a contribution
           to the reciprocal Dif-estimate.
       subroutine <b>slatps</b> (UPLO, TRANS, DIAG, NORMIN, N, AP, X, SCALE, CNORM, INFO)
           <b>SLATPS</b> solves a triangular system of equations with the matrix held in packed storage.
       subroutine <b>slatrs</b> (UPLO, TRANS, DIAG, NORMIN, N, A, LDA, X, SCALE, CNORM, INFO)
           <b>SLATRS</b> solves a triangular system of equations with the scale factor set to prevent overflow.
       subroutine <b>slauu2</b> (UPLO, N, A, LDA, INFO)
           <b>SLAUU2</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices
           (unblocked algorithm).
       subroutine <b>slauum</b> (UPLO, N, A, LDA, INFO)
           <b>SLAUUM</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices (blocked
           algorithm).
       subroutine <b>srscl</b> (N, SA, SX, INCX)
           <b>SRSCL</b> multiplies a vector by the reciprocal of a real scalar.
       subroutine <b>stprfb</b> (SIDE, TRANS, DIRECT, STOREV, M, N, K, L, V, LDV, T, LDT, A, LDA, B, LDB, WORK, LDWORK)
           <b>STPRFB</b> applies a real or complex 'triangular-pentagonal' blocked reflector to a real or complex
           matrix, which is composed of two blocks.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       This is the group of real other auxiliary routines

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>integer</b> <b>function</b> <b>ilaslc</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA)</b>
       <b>ILASLC</b> scans a matrix for its last non-zero column.

       <b>Purpose:</b>

            ILASLC scans A for its last non-zero column.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     The m by n matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>integer</b> <b>function</b> <b>ilaslr</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA)</b>
       <b>ILASLR</b> scans a matrix for its last non-zero row.

       <b>Purpose:</b>

            ILASLR scans A for its last non-zero row.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     The m by n matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slabrd</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NB,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUQ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUP,</b> <b>real,</b>
       <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>real,</b> <b>dimension(</b> <b>ldy,</b> <b>*</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>LDY)</b>
       <b>SLABRD</b> reduces the first nb rows and columns of a general matrix to a bidiagonal form.

       <b>Purpose:</b>

            SLABRD reduces the first NB rows and columns of a real general
            m by n matrix A to upper or lower bidiagonal form by an orthogonal
            transformation Q**T * A * P, and returns the matrices X and Y which
            are needed to apply the transformation to the unreduced part of A.

            If m &gt;= n, A is reduced to upper bidiagonal form; if m &lt; n, to lower
            bidiagonal form.

            This is an auxiliary routine called by SGEBRD

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows in the matrix A.

           <u>N</u>

                     N is INTEGER
                     The number of columns in the matrix A.

           <u>NB</u>

                     NB is INTEGER
                     The number of leading rows and columns of A to be reduced.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     On entry, the m by n general matrix to be reduced.
                     On exit, the first NB rows and columns of the matrix are
                     overwritten; the rest of the array is unchanged.
                     If m &gt;= n, elements on and below the diagonal in the first NB
                       columns, with the array TAUQ, represent the orthogonal
                       matrix Q as a product of elementary reflectors; and
                       elements above the diagonal in the first NB rows, with the
                       array TAUP, represent the orthogonal matrix P as a product
                       of elementary reflectors.
                     If m &lt; n, elements below the diagonal in the first NB
                       columns, with the array TAUQ, represent the orthogonal
                       matrix Q as a product of elementary reflectors, and
                       elements on and above the diagonal in the first NB rows,
                       with the array TAUP, represent the orthogonal matrix P as
                       a product of elementary reflectors.
                     See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is REAL array, dimension (NB)
                     The diagonal elements of the first NB rows and columns of
                     the reduced matrix.  D(i) = A(i,i).

           <u>E</u>

                     E is REAL array, dimension (NB)
                     The off-diagonal elements of the first NB rows and columns of
                     the reduced matrix.

           <u>TAUQ</u>

                     TAUQ is REAL array, dimension (NB)
                     The scalar factors of the elementary reflectors which
                     represent the orthogonal matrix Q. See Further Details.

           <u>TAUP</u>

                     TAUP is REAL array, dimension (NB)
                     The scalar factors of the elementary reflectors which
                     represent the orthogonal matrix P. See Further Details.

           <u>X</u>

                     X is REAL array, dimension (LDX,NB)
                     The m-by-nb matrix X required to update the unreduced part
                     of A.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X. LDX &gt;= max(1,M).

           <u>Y</u>

                     Y is REAL array, dimension (LDY,NB)
                     The n-by-nb matrix Y required to update the unreduced part
                     of A.

           <u>LDY</u>

                     LDY is INTEGER
                     The leading dimension of the array Y. LDY &gt;= max(1,N).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The matrices Q and P are represented as products of elementary
             reflectors:

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nb)  and  P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(nb)

             Each H(i) and G(i) has the form:

                H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T

             where tauq and taup are real scalars, and v and u are real vectors.

             If m &gt;= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
             A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
             A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

             If m &lt; n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
             A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
             A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

             The elements of the vectors v and u together form the m-by-nb matrix
             V and the nb-by-n matrix U**T which are needed, with X and Y, to apply
             the transformation to the unreduced part of the matrix, using a block
             update of the form:  A := A - V*Y**T - X*U**T.

             The contents of A on exit are illustrated by the following examples
             with nb = 2:

             m = 6 and n = 5 (m &gt; n):          m = 5 and n = 6 (m &lt; n):

               (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
               (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
               (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
               (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
               (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
               (  v1  v2  a   a   a  )

             where a denotes an element of the original matrix which is unchanged,
             vi denotes an element of the vector defining H(i), and ui an element
             of the vector defining G(i).

   <b>subroutine</b> <b>slacn2</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISGN,</b>
       <b>real</b> <b>EST,</b> <b>integer</b> <b>KASE,</b> <b>integer,</b> <b>dimension(</b> <b>3</b> <b>)</b> <b>ISAVE)</b>
       <b>SLACN2</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-vector
       products.

       <b>Purpose:</b>

            SLACN2 estimates the 1-norm of a square, real matrix A.
            Reverse communication is used for evaluating matrix-vector products.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The order of the matrix.  N &gt;= 1.

           <u>V</u>

                     V is REAL array, dimension (N)
                    On the final return, V = A*W,  where  EST = norm(V)/norm(W)
                    (W is not returned).

           <u>X</u>

                     X is REAL array, dimension (N)
                    On an intermediate return, X should be overwritten by
                          A * X,   if KASE=1,
                          A**T * X,  if KASE=2,
                    and SLACN2 must be re-called with all the other parameters
                    unchanged.

           <u>ISGN</u>

                     ISGN is INTEGER array, dimension (N)

           <u>EST</u>

                     EST is REAL
                    On entry with KASE = 1 or 2 and <a href="../man1/ISAVE.1.html">ISAVE</a>(1) = 3, EST should be
                    unchanged from the previous call to SLACN2.
                    On exit, EST is an estimate (a lower bound) for norm(A).

           <u>KASE</u>

                     KASE is INTEGER
                    On the initial call to SLACN2, KASE should be 0.
                    On an intermediate return, KASE will be 1 or 2, indicating
                    whether X should be overwritten by A * X  or A**T * X.
                    On the final return from SLACN2, KASE will again be 0.

           <u>ISAVE</u>

                     ISAVE is INTEGER array, dimension (3)
                    ISAVE is used to save variables between calls to SLACN2

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Originally named SONEST, dated March 16, 1988.

             This is a thread safe version of SLACON, which uses the array ISAVE
             in place of a SAVE statement, as follows:

                SLACON     SLACN2
                 JUMP     <a href="../man1/ISAVE.1.html">ISAVE</a>(1)
                 J        <a href="../man2/ISAVE.2.html">ISAVE</a>(2)
                 ITER     <a href="../man3/ISAVE.3.html">ISAVE</a>(3)

       <b>Contributors:</b>
           Nick Higham, University of Manchester

       <b>References:</b>
           N.J. Higham, 'FORTRAN codes for estimating the one-norm of
             a real or complex matrix, with applications to condition estimation', ACM Trans. Math. Soft., vol.
           14, no. 4, pp. 381-396, December 1988.

   <b>subroutine</b> <b>slacon</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISGN,</b>
       <b>real</b> <b>EST,</b> <b>integer</b> <b>KASE)</b>
       <b>SLACON</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-vector
       products.

       <b>Purpose:</b>

            SLACON estimates the 1-norm of a square, real matrix A.
            Reverse communication is used for evaluating matrix-vector products.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The order of the matrix.  N &gt;= 1.

           <u>V</u>

                     V is REAL array, dimension (N)
                    On the final return, V = A*W,  where  EST = norm(V)/norm(W)
                    (W is not returned).

           <u>X</u>

                     X is REAL array, dimension (N)
                    On an intermediate return, X should be overwritten by
                          A * X,   if KASE=1,
                          A**T * X,  if KASE=2,
                    and SLACON must be re-called with all the other parameters
                    unchanged.

           <u>ISGN</u>

                     ISGN is INTEGER array, dimension (N)

           <u>EST</u>

                     EST is REAL
                    On entry with KASE = 1 or 2 and JUMP = 3, EST should be
                    unchanged from the previous call to SLACON.
                    On exit, EST is an estimate (a lower bound) for norm(A).

           <u>KASE</u>

                     KASE is INTEGER
                    On the initial call to SLACON, KASE should be 0.
                    On an intermediate return, KASE will be 1 or 2, indicating
                    whether X should be overwritten by A * X  or A**T * X.
                    On the final return from SLACON, KASE will again be 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Nick Higham, University of Manchester.
            Originally named SONEST, dated March 16, 1988.

       <b>References:</b>
           N.J. Higham, 'FORTRAN codes for estimating the one-norm of
             a real or complex matrix, with applications to condition estimation', ACM Trans. Math. Soft., vol.
           14, no. 4, pp. 381-396, December 1988.

   <b>subroutine</b> <b>sladiv</b> <b>(real</b> <b>A,</b> <b>real</b> <b>B,</b> <b>real</b> <b>C,</b> <b>real</b> <b>D,</b> <b>real</b> <b>P,</b> <b>real</b> <b>Q)</b>
       <b>SLADIV</b> performs complex division in real arithmetic, avoiding unnecessary overflow.

       <b>Purpose:</b>

            SLADIV performs complex division in  real arithmetic

                                  a + i*b
                       p + i*q = ---------
                                  c + i*d

            The algorithm is due to Michael Baudin and Robert L. Smith
            and can be found in the paper
            "A Robust Complex Division in Scilab"

       <b>Parameters</b>
           <u>A</u>

                     A is REAL

           <u>B</u>

                     B is REAL

           <u>C</u>

                     C is REAL

           <u>D</u>

                     D is REAL
                     The scalars a, b, c, and d in the above expression.

           <u>P</u>

                     P is REAL

           <u>Q</u>

                     Q is REAL
                     The scalars p and q in the above expression.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slaein</b> <b>(logical</b> <b>RIGHTV,</b> <b>logical</b> <b>NOINIT,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>real</b>
       <b>WR,</b> <b>real</b> <b>WI,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VI,</b> <b>real,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real</b> <b>EPS3,</b> <b>real</b> <b>SMLNUM,</b> <b>real</b> <b>BIGNUM,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAEIN</b> computes a specified right or left eigenvector of an upper Hessenberg matrix by inverse iteration.

       <b>Purpose:</b>

            SLAEIN uses inverse iteration to find a right or left eigenvector
            corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
            matrix H.

       <b>Parameters</b>
           <u>RIGHTV</u>

                     RIGHTV is LOGICAL
                     = .TRUE. : compute right eigenvector;
                     = .FALSE.: compute left eigenvector.

           <u>NOINIT</u>

                     NOINIT is LOGICAL
                     = .TRUE. : no initial vector supplied in (VR,VI).
                     = .FALSE.: initial vector supplied in (VR,VI).

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H.  N &gt;= 0.

           <u>H</u>

                     H is REAL array, dimension (LDH,N)
                     The upper Hessenberg matrix H.

           <u>LDH</u>

                     LDH is INTEGER
                     The leading dimension of the array H.  LDH &gt;= max(1,N).

           <u>WR</u>

                     WR is REAL

           <u>WI</u>

                     WI is REAL
                     The real and imaginary parts of the eigenvalue of H whose
                     corresponding right or left eigenvector is to be computed.

           <u>VR</u>

                     VR is REAL array, dimension (N)

           <u>VI</u>

                     VI is REAL array, dimension (N)
                     On entry, if NOINIT = .FALSE. and WI = 0.0, VR must contain
                     a real starting vector for inverse iteration using the real
                     eigenvalue WR; if NOINIT = .FALSE. and WI.ne.0.0, VR and VI
                     must contain the real and imaginary parts of a complex
                     starting vector for inverse iteration using the complex
                     eigenvalue (WR,WI); otherwise VR and VI need not be set.
                     On exit, if WI = 0.0 (real eigenvalue), VR contains the
                     computed real eigenvector; if WI.ne.0.0 (complex eigenvalue),
                     VR and VI contain the real and imaginary parts of the
                     computed complex eigenvector. The eigenvector is normalized
                     so that the component of largest magnitude has magnitude 1;
                     here the magnitude of a complex number (x,y) is taken to be
                     |x| + |y|.
                     VI is not referenced if WI = 0.0.

           <u>B</u>

                     B is REAL array, dimension (LDB,N)

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= N+1.

           <u>WORK</u>

                     WORK is REAL array, dimension (N)

           <u>EPS3</u>

                     EPS3 is REAL
                     A small machine-dependent value which is used to perturb
                     close eigenvalues, and to replace zero pivots.

           <u>SMLNUM</u>

                     SMLNUM is REAL
                     A machine-dependent value close to the underflow threshold.

           <u>BIGNUM</u>

                     BIGNUM is REAL
                     A machine-dependent value close to the overflow threshold.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     = 1:  inverse iteration did not converge; VR is set to the
                           last iterate, and so is VI if WI.ne.0.0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slaexc</b> <b>(logical</b> <b>WANTQ,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>real,</b> <b>dimension(</b> <b>ldq,</b>
       <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>integer</b> <b>J1,</b> <b>integer</b> <b>N1,</b> <b>integer</b> <b>N2,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAEXC</b> swaps adjacent diagonal blocks of a real upper quasi-triangular matrix in Schur canonical form, by
       an orthogonal similarity transformation.

       <b>Purpose:</b>

            SLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
            an upper quasi-triangular matrix T by an orthogonal similarity
            transformation.

            T must be in Schur canonical form, that is, block upper triangular
            with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
            has its diagonal elements equal and its off-diagonal elements of
            opposite sign.

       <b>Parameters</b>
           <u>WANTQ</u>

                     WANTQ is LOGICAL
                     = .TRUE. : accumulate the transformation in the matrix Q;
                     = .FALSE.: do not accumulate the transformation.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix T. N &gt;= 0.

           <u>T</u>

                     T is REAL array, dimension (LDT,N)
                     On entry, the upper quasi-triangular matrix T, in Schur
                     canonical form.
                     On exit, the updated matrix T, again in Schur canonical form.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= max(1,N).

           <u>Q</u>

                     Q is REAL array, dimension (LDQ,N)
                     On entry, if WANTQ is .TRUE., the orthogonal matrix Q.
                     On exit, if WANTQ is .TRUE., the updated matrix Q.
                     If WANTQ is .FALSE., Q is not referenced.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= 1; and if WANTQ is .TRUE., LDQ &gt;= N.

           <u>J1</u>

                     J1 is INTEGER
                     The index of the first row of the first block T11.

           <u>N1</u>

                     N1 is INTEGER
                     The order of the first block T11. N1 = 0, 1 or 2.

           <u>N2</u>

                     N2 is INTEGER
                     The order of the second block T22. N2 = 0, 1 or 2.

           <u>WORK</u>

                     WORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     = 1: the transformed matrix T would be too far from Schur
                          form; the blocks are not swapped and T and Q are
                          unchanged.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slag2</b> <b>(real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>real</b>
       <b>SAFMIN,</b> <b>real</b> <b>SCALE1,</b> <b>real</b> <b>SCALE2,</b> <b>real</b> <b>WR1,</b> <b>real</b> <b>WR2,</b> <b>real</b> <b>WI)</b>
       <b>SLAG2</b> computes the eigenvalues of a 2-by-2 generalized eigenvalue problem, with scaling as necessary to
       avoid over-/underflow.

       <b>Purpose:</b>

            SLAG2 computes the eigenvalues of a 2 x 2 generalized eigenvalue
            problem  A - w B, with scaling as necessary to avoid over-/underflow.

            The scaling factor "s" results in a modified eigenvalue equation

                s A - w B

            where  s  is a non-negative scaling factor chosen so that  w,  w B,
            and  s A  do not overflow and, if possible, do not underflow, either.

       <b>Parameters</b>
           <u>A</u>

                     A is REAL array, dimension (LDA, 2)
                     On entry, the 2 x 2 matrix A.  It is assumed that its 1-norm
                     is less than 1/SAFMIN.  Entries less than
                     sqrt(SAFMIN)*norm(A) are subject to being treated as zero.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= 2.

           <u>B</u>

                     B is REAL array, dimension (LDB, 2)
                     On entry, the 2 x 2 upper triangular matrix B.  It is
                     assumed that the one-norm of B is less than 1/SAFMIN.  The
                     diagonals should be at least sqrt(SAFMIN) times the largest
                     element of B (in absolute value); if a diagonal is smaller
                     than that, then  +/- sqrt(SAFMIN) will be used instead of
                     that diagonal.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= 2.

           <u>SAFMIN</u>

                     SAFMIN is REAL
                     The smallest positive number s.t. 1/SAFMIN does not
                     overflow.  (This should always be SLAMCH('S') -- it is an
                     argument in order to avoid having to call SLAMCH frequently.)

           <u>SCALE1</u>

                     SCALE1 is REAL
                     A scaling factor used to avoid over-/underflow in the
                     eigenvalue equation which defines the first eigenvalue.  If
                     the eigenvalues are complex, then the eigenvalues are
                     ( WR1  +/-  WI i ) / SCALE1  (which may lie outside the
                     exponent range of the machine), SCALE1=SCALE2, and SCALE1
                     will always be positive.  If the eigenvalues are real, then
                     the first (real) eigenvalue is  WR1 / SCALE1 , but this may
                     overflow or underflow, and in fact, SCALE1 may be zero or
                     less than the underflow threshold if the exact eigenvalue
                     is sufficiently large.

           <u>SCALE2</u>

                     SCALE2 is REAL
                     A scaling factor used to avoid over-/underflow in the
                     eigenvalue equation which defines the second eigenvalue.  If
                     the eigenvalues are complex, then SCALE2=SCALE1.  If the
                     eigenvalues are real, then the second (real) eigenvalue is
                     WR2 / SCALE2 , but this may overflow or underflow, and in
                     fact, SCALE2 may be zero or less than the underflow
                     threshold if the exact eigenvalue is sufficiently large.

           <u>WR1</u>

                     WR1 is REAL
                     If the eigenvalue is real, then WR1 is SCALE1 times the
                     eigenvalue closest to the (2,2) element of A B**(-1).  If the
                     eigenvalue is complex, then WR1=WR2 is SCALE1 times the real
                     part of the eigenvalues.

           <u>WR2</u>

                     WR2 is REAL
                     If the eigenvalue is real, then WR2 is SCALE2 times the
                     other eigenvalue.  If the eigenvalue is complex, then
                     WR1=WR2 is SCALE1 times the real part of the eigenvalues.

           <u>WI</u>

                     WI is REAL
                     If the eigenvalue is real, then WI is zero.  If the
                     eigenvalue is complex, then WI is SCALE1 times the imaginary
                     part of the eigenvalues.  WI will always be non-negative.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slags2</b> <b>(logical</b> <b>UPPER,</b> <b>real</b> <b>A1,</b> <b>real</b> <b>A2,</b> <b>real</b> <b>A3,</b> <b>real</b> <b>B1,</b> <b>real</b> <b>B2,</b> <b>real</b> <b>B3,</b> <b>real</b> <b>CSU,</b> <b>real</b> <b>SNU,</b>
       <b>real</b> <b>CSV,</b> <b>real</b> <b>SNV,</b> <b>real</b> <b>CSQ,</b> <b>real</b> <b>SNQ)</b>
       <b>SLAGS2</b> computes 2-by-2 orthogonal matrices U, V, and Q, and applies them to matrices A and B such that
       the rows of the transformed A and B are parallel.

       <b>Purpose:</b>

            SLAGS2 computes 2-by-2 orthogonal matrices U, V and Q, such
            that if ( UPPER ) then

                      U**T *A*Q = U**T *( A1 A2 )*Q = ( x  0  )
                                        ( 0  A3 )     ( x  x  )
            and
                      V**T*B*Q = V**T *( B1 B2 )*Q = ( x  0  )
                                       ( 0  B3 )     ( x  x  )

            or if ( .NOT.UPPER ) then

                      U**T *A*Q = U**T *( A1 0  )*Q = ( x  x  )
                                        ( A2 A3 )     ( 0  x  )
            and
                      V**T*B*Q = V**T*( B1 0  )*Q = ( x  x  )
                                      ( B2 B3 )     ( 0  x  )

            The rows of the transformed A and B are parallel, where

              U = (  CSU  SNU ), V = (  CSV SNV ), Q = (  CSQ   SNQ )
                  ( -SNU  CSU )      ( -SNV CSV )      ( -SNQ   CSQ )

            Z**T denotes the transpose of Z.

       <b>Parameters</b>
           <u>UPPER</u>

                     UPPER is LOGICAL
                     = .TRUE.: the input matrices A and B are upper triangular.
                     = .FALSE.: the input matrices A and B are lower triangular.

           <u>A1</u>

                     A1 is REAL

           <u>A2</u>

                     A2 is REAL

           <u>A3</u>

                     A3 is REAL
                     On entry, A1, A2 and A3 are elements of the input 2-by-2
                     upper (lower) triangular matrix A.

           <u>B1</u>

                     B1 is REAL

           <u>B2</u>

                     B2 is REAL

           <u>B3</u>

                     B3 is REAL
                     On entry, B1, B2 and B3 are elements of the input 2-by-2
                     upper (lower) triangular matrix B.

           <u>CSU</u>

                     CSU is REAL

           <u>SNU</u>

                     SNU is REAL
                     The desired orthogonal matrix U.

           <u>CSV</u>

                     CSV is REAL

           <u>SNV</u>

                     SNV is REAL
                     The desired orthogonal matrix V.

           <u>CSQ</u>

                     CSQ is REAL

           <u>SNQ</u>

                     SNQ is REAL
                     The desired orthogonal matrix Q.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slagtm</b> <b>(character</b> <b>TRANS,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>real</b> <b>ALPHA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DL,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DU,</b> <b>real,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>real</b> <b>BETA,</b> <b>real,</b>
       <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB)</b>
       <b>SLAGTM</b> performs a matrix-matrix product of the form C = αAB+βC, where A is a tridiagonal matrix, B and C
       are rectangular matrices, and α and β are scalars, which may be 0, 1, or -1.

       <b>Purpose:</b>

            SLAGTM performs a matrix-vector product of the form

               B := alpha * A * X + beta * B

            where A is a tridiagonal matrix of order N, B and X are N by NRHS
            matrices, and alpha and beta are real scalars, each of which may be
            0., 1., or -1.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  No transpose, B := alpha * A * X + beta * B
                     = 'T':  Transpose,    B := alpha * A'* X + beta * B
                     = 'C':  Conjugate transpose = Transpose

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices X and B.

           <u>ALPHA</u>

                     ALPHA is REAL
                     The scalar alpha.  ALPHA must be 0., 1., or -1.; otherwise,
                     it is assumed to be 0.

           <u>DL</u>

                     DL is REAL array, dimension (N-1)
                     The (n-1) sub-diagonal elements of T.

           <u>D</u>

                     D is REAL array, dimension (N)
                     The diagonal elements of T.

           <u>DU</u>

                     DU is REAL array, dimension (N-1)
                     The (n-1) super-diagonal elements of T.

           <u>X</u>

                     X is REAL array, dimension (LDX,NRHS)
                     The N by NRHS matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(N,1).

           <u>BETA</u>

                     BETA is REAL
                     The scalar beta.  BETA must be 0., 1., or -1.; otherwise,
                     it is assumed to be 1.

           <u>B</u>

                     B is REAL array, dimension (LDB,NRHS)
                     On entry, the N by NRHS matrix B.
                     On exit, B is overwritten by the matrix expression
                     B := alpha * A * X + beta * B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(N,1).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slagv2</b> <b>(real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>real,</b>
       <b>dimension(</b> <b>2</b> <b>)</b> <b>ALPHAR,</b> <b>real,</b> <b>dimension(</b> <b>2</b> <b>)</b> <b>ALPHAI,</b> <b>real,</b> <b>dimension(</b> <b>2</b> <b>)</b> <b>BETA,</b> <b>real</b> <b>CSL,</b> <b>real</b> <b>SNL,</b> <b>real</b>
       <b>CSR,</b> <b>real</b> <b>SNR)</b>
       <b>SLAGV2</b> computes the Generalized Schur factorization of a real 2-by-2 matrix pencil (A,B) where B is upper
       triangular.

       <b>Purpose:</b>

            SLAGV2 computes the Generalized Schur factorization of a real 2-by-2
            matrix pencil (A,B) where B is upper triangular. This routine
            computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
            SNR such that

            1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
               types), then

               [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
               [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]

               [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
               [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],

            2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
               then

               [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
               [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]

               [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
               [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]

               where b11 &gt;= b22 &gt; 0.

       <b>Parameters</b>
           <u>A</u>

                     A is REAL array, dimension (LDA, 2)
                     On entry, the 2 x 2 matrix A.
                     On exit, A is overwritten by the ``A-part'' of the
                     generalized Schur form.

           <u>LDA</u>

                     LDA is INTEGER
                     THe leading dimension of the array A.  LDA &gt;= 2.

           <u>B</u>

                     B is REAL array, dimension (LDB, 2)
                     On entry, the upper triangular 2 x 2 matrix B.
                     On exit, B is overwritten by the ``B-part'' of the
                     generalized Schur form.

           <u>LDB</u>

                     LDB is INTEGER
                     THe leading dimension of the array B.  LDB &gt;= 2.

           <u>ALPHAR</u>

                     ALPHAR is REAL array, dimension (2)

           <u>ALPHAI</u>

                     ALPHAI is REAL array, dimension (2)

           <u>BETA</u>

                     BETA is REAL array, dimension (2)
                     (ALPHAR(k)+i*ALPHAI(k))/BETA(k) are the eigenvalues of the
                     pencil (A,B), k=1,2, i = sqrt(-1).  Note that BETA(k) may
                     be zero.

           <u>CSL</u>

                     CSL is REAL
                     The cosine of the left rotation matrix.

           <u>SNL</u>

                     SNL is REAL
                     The sine of the left rotation matrix.

           <u>CSR</u>

                     CSR is REAL
                     The cosine of the right rotation matrix.

           <u>SNR</u>

                     SNR is REAL
                     The sine of the right rotation matrix.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA

   <b>subroutine</b> <b>slahqr</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>real,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b>
       <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WI,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>real,</b>
       <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAHQR</b> computes the eigenvalues and Schur factorization of an upper Hessenberg matrix, using the double-
       shift/single-shift QR algorithm.

       <b>Purpose:</b>

               SLAHQR is an auxiliary routine called by SHSEQR to update the
               eigenvalues and Schur decomposition already computed by SHSEQR, by
               dealing with the Hessenberg submatrix in rows and columns ILO to
               IHI.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     = .TRUE. : the full Schur form T is required;
                     = .FALSE.: only eigenvalues are required.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     = .TRUE. : the matrix of Schur vectors Z is required;
                     = .FALSE.: Schur vectors are not required.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                     It is assumed that H is already upper quasi-triangular in
                     rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
                     ILO = 1). SLAHQR works primarily with the Hessenberg
                     submatrix in rows and columns ILO to IHI, but applies
                     transformations to all of H if WANTT is .TRUE..
                     1 &lt;= ILO &lt;= max(1,IHI); IHI &lt;= N.

           <u>H</u>

                     H is REAL array, dimension (LDH,N)
                     On entry, the upper Hessenberg matrix H.
                     On exit, if INFO is zero and if WANTT is .TRUE., H is upper
                     quasi-triangular in rows and columns ILO:IHI, with any
                     2-by-2 diagonal blocks in standard form. If INFO is zero
                     and WANTT is .FALSE., the contents of H are unspecified on
                     exit.  The output state of H if INFO is nonzero is given
                     below under the description of INFO.

           <u>LDH</u>

                     LDH is INTEGER
                     The leading dimension of the array H. LDH &gt;= max(1,N).

           <u>WR</u>

                     WR is REAL array, dimension (N)

           <u>WI</u>

                     WI is REAL array, dimension (N)
                     The real and imaginary parts, respectively, of the computed
                     eigenvalues ILO to IHI are stored in the corresponding
                     elements of WR and WI. If two eigenvalues are computed as a
                     complex conjugate pair, they are stored in consecutive
                     elements of WR and WI, say the i-th and (i+1)th, with
                     WI(i) &gt; 0 and WI(i+1) &lt; 0. If WANTT is .TRUE., the
                     eigenvalues are stored in the same order as on the diagonal
                     of the Schur form returned in H, with WR(i) = H(i,i), and, if
                     H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
                     WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                     Specify the rows of Z to which transformations must be
                     applied if WANTZ is .TRUE..
                     1 &lt;= ILOZ &lt;= ILO; IHI &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is REAL array, dimension (LDZ,N)
                     If WANTZ is .TRUE., on entry Z must contain the current
                     matrix Z of transformations accumulated by SHSEQR, and on
                     exit Z has been updated; transformations are applied only to
                     the submatrix Z(ILOZ:IHIZ,ILO:IHI).
                     If WANTZ is .FALSE., Z is not referenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z. LDZ &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                      = 0:   successful exit
                      &gt; 0:   If INFO = i, SLAHQR failed to compute all the
                             eigenvalues ILO to IHI in a total of 30 iterations
                             per eigenvalue; elements i+1:ihi of WR and WI
                             contain those eigenvalues which have been
                             successfully computed.

                             If INFO &gt; 0 and WANTT is .FALSE., then on exit,
                             the remaining unconverged eigenvalues are the
                             eigenvalues of the upper Hessenberg matrix rows
                             and columns ILO through INFO of the final, output
                             value of H.

                             If INFO &gt; 0 and WANTT is .TRUE., then on exit
                     (*)       (initial value of H)*U  = U*(final value of H)
                             where U is an orthogonal matrix.    The final
                             value of H is upper Hessenberg and triangular in
                             rows and columns INFO+1 through IHI.

                             If INFO &gt; 0 and WANTZ is .TRUE., then on exit
                                 (final value of Z)  = (initial value of Z)*U
                             where U is the orthogonal matrix in (*)
                             (regardless of the value of WANTT.)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

                02-96 Based on modifications by
                David Day, Sandia National Laboratory, USA

                12-04 Further modifications by
                Ralph Byers, University of Kansas, USA
                This is a modified version of SLAHQR from LAPACK version 3.0.
                It is (1) more robust against overflow and underflow and
                (2) adopts the more conservative Ahues &amp; Tisseur stopping
                criterion (LAWN 122, 1997).

   <b>subroutine</b> <b>slahr2</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>integer</b> <b>NB,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b>
       <b>dimension(</b> <b>nb</b> <b>)</b> <b>TAU,</b> <b>real,</b> <b>dimension(</b> <b>ldt,</b> <b>nb</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>real,</b> <b>dimension(</b> <b>ldy,</b> <b>nb</b> <b>)</b> <b>Y,</b> <b>integer</b>
       <b>LDY)</b>
       <b>SLAHR2</b> reduces the specified number of first columns of a general rectangular matrix A so that elements
       below the specified subdiagonal are zero, and returns auxiliary matrices which are needed to apply the
       transformation to the unreduced part of A.

       <b>Purpose:</b>

            SLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
            matrix A so that elements below the k-th subdiagonal are zero. The
            reduction is performed by an orthogonal similarity transformation
            Q**T * A * Q. The routine returns the matrices V and T which determine
            Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.

            This is an auxiliary routine called by SGEHRD.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.

           <u>K</u>

                     K is INTEGER
                     The offset for the reduction. Elements below the k-th
                     subdiagonal in the first NB columns are reduced to zero.
                     K &lt; N.

           <u>NB</u>

                     NB is INTEGER
                     The number of columns to be reduced.

           <u>A</u>

                     A is REAL array, dimension (LDA,N-K+1)
                     On entry, the n-by-(n-k+1) general matrix A.
                     On exit, the elements on and above the k-th subdiagonal in
                     the first NB columns are overwritten with the corresponding
                     elements of the reduced matrix; the elements below the k-th
                     subdiagonal, with the array TAU, represent the matrix Q as a
                     product of elementary reflectors. The other columns of A are
                     unchanged. See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>TAU</u>

                     TAU is REAL array, dimension (NB)
                     The scalar factors of the elementary reflectors. See Further
                     Details.

           <u>T</u>

                     T is REAL array, dimension (LDT,NB)
                     The upper triangular matrix T.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= NB.

           <u>Y</u>

                     Y is REAL array, dimension (LDY,NB)
                     The n-by-nb matrix Y.

           <u>LDY</u>

                     LDY is INTEGER
                     The leading dimension of the array Y. LDY &gt;= N.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The matrix Q is represented as a product of nb elementary reflectors

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nb).

             Each H(i) has the form

                H(i) = I - tau * v * v**T

             where tau is a real scalar, and v is a real vector with
             v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
             A(i+k+1:n,i), and tau in TAU(i).

             The elements of the vectors v together form the (n-k+1)-by-nb matrix
             V which is needed, with T and Y, to apply the transformation to the
             unreduced part of the matrix, using an update of the form:
             A := (I - V*T*V**T) * (A - Y*V**T).

             The contents of A on exit are illustrated by the following example
             with n = 7, k = 3 and nb = 2:

                ( a   a   a   a   a )
                ( a   a   a   a   a )
                ( a   a   a   a   a )
                ( h   h   a   a   a )
                ( v1  h   a   a   a )
                ( v1  v2  a   a   a )
                ( v1  v2  a   a   a )

             where a denotes an element of the original matrix A, h denotes a
             modified element of the upper Hessenberg matrix H, and vi denotes an
             element of the vector defining H(i).

             This subroutine is a slight modification of LAPACK-3.0's SLAHRD
             incorporating improvements proposed by Quintana-Orti and Van de
             Gejin. Note that the entries of A(1:K,2:NB) differ from those
             returned by the original LAPACK-3.0's SLAHRD routine. (This
             subroutine is not backward compatible with LAPACK-3.0's SLAHRD.)

       <b>References:</b>
           Gregorio Quintana-Orti and Robert van de Geijn, 'Improving the
             performance of reduction to Hessenberg form,' ACM Transactions on Mathematical Software,
           <a href="../man2/32.2.html">32</a>(2):180-194, June 2006.

   <b>subroutine</b> <b>slaic1</b> <b>(integer</b> <b>JOB,</b> <b>integer</b> <b>J,</b> <b>real,</b> <b>dimension(</b> <b>j</b> <b>)</b> <b>X,</b> <b>real</b> <b>SEST,</b> <b>real,</b> <b>dimension(</b> <b>j</b> <b>)</b> <b>W,</b> <b>real</b>
       <b>GAMMA,</b> <b>real</b> <b>SESTPR,</b> <b>real</b> <b>S,</b> <b>real</b> <b>C)</b>
       <b>SLAIC1</b> applies one step of incremental condition estimation.

       <b>Purpose:</b>

            SLAIC1 applies one step of incremental condition estimation in
            its simplest version:

            Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
            lower triangular matrix L, such that
                     twonorm(L*x) = sest
            Then SLAIC1 computes sestpr, s, c such that
            the vector
                            [ s*x ]
                     xhat = [  c  ]
            is an approximate singular vector of
                            [ L      0  ]
                     Lhat = [ w**T gamma ]
            in the sense that
                     twonorm(Lhat*xhat) = sestpr.

            Depending on JOB, an estimate for the largest or smallest singular
            value is computed.

            Note that [s c]**T and sestpr**2 is an eigenpair of the system

                diag(sest*sest, 0) + [alpha  gamma] * [ alpha ]
                                                      [ gamma ]

            where  alpha =  x**T*w.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is INTEGER
                     = 1: an estimate for the largest singular value is computed.
                     = 2: an estimate for the smallest singular value is computed.

           <u>J</u>

                     J is INTEGER
                     Length of X and W

           <u>X</u>

                     X is REAL array, dimension (J)
                     The j-vector x.

           <u>SEST</u>

                     SEST is REAL
                     Estimated singular value of j by j matrix L

           <u>W</u>

                     W is REAL array, dimension (J)
                     The j-vector w.

           <u>GAMMA</u>

                     GAMMA is REAL
                     The diagonal element gamma.

           <u>SESTPR</u>

                     SESTPR is REAL
                     Estimated singular value of (j+1) by (j+1) matrix Lhat.

           <u>S</u>

                     S is REAL
                     Sine needed in forming xhat.

           <u>C</u>

                     C is REAL
                     Cosine needed in forming xhat.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slaln2</b> <b>(logical</b> <b>LTRANS,</b> <b>integer</b> <b>NA,</b> <b>integer</b> <b>NW,</b> <b>real</b> <b>SMIN,</b> <b>real</b> <b>CA,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b>
       <b>integer</b> <b>LDA,</b> <b>real</b> <b>D1,</b> <b>real</b> <b>D2,</b> <b>real,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>real</b> <b>WR,</b> <b>real</b> <b>WI,</b> <b>real,</b>
       <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>real</b> <b>SCALE,</b> <b>real</b> <b>XNORM,</b> <b>integer</b> <b>INFO)</b>
       <b>SLALN2</b> solves a 1-by-1 or 2-by-2 linear system of equations of the specified form.

       <b>Purpose:</b>

            SLALN2 solves a system of the form  (ca A - w D ) X = s B
            or (ca A**T - w D) X = s B   with possible scaling ("s") and
            perturbation of A.  (A**T means A-transpose.)

            A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
            real diagonal matrix, w is a real or complex value, and X and B are
            NA x 1 matrices -- real if w is real, complex if w is complex.  NA
            may be 1 or 2.

            If w is complex, X and B are represented as NA x 2 matrices,
            the first column of each being the real part and the second
            being the imaginary part.

            "s" is a scaling factor (&lt;= 1), computed by SLALN2, which is
            so chosen that X can be computed without overflow.  X is further
            scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
            than overflow.

            If both singular values of (ca A - w D) are less than SMIN,
            SMIN*identity will be used instead of (ca A - w D).  If only one
            singular value is less than SMIN, one element of (ca A - w D) will be
            perturbed enough to make the smallest singular value roughly SMIN.
            If both singular values are at least SMIN, (ca A - w D) will not be
            perturbed.  In any case, the perturbation will be at most some small
            multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
            are computed by infinity-norm approximations, and thus will only be
            correct to a factor of 2 or so.

            Note: all input quantities are assumed to be smaller than overflow
            by a reasonable factor.  (See BIGNUM.)

       <b>Parameters</b>
           <u>LTRANS</u>

                     LTRANS is LOGICAL
                     =.TRUE.:  A-transpose will be used.
                     =.FALSE.: A will be used (not transposed.)

           <u>NA</u>

                     NA is INTEGER
                     The size of the matrix A.  It may (only) be 1 or 2.

           <u>NW</u>

                     NW is INTEGER
                     1 if "w" is real, 2 if "w" is complex.  It may only be 1
                     or 2.

           <u>SMIN</u>

                     SMIN is REAL
                     The desired lower bound on the singular values of A.  This
                     should be a safe distance away from underflow or overflow,
                     say, between (underflow/machine precision) and  (machine
                     precision * overflow ).  (See BIGNUM and ULP.)

           <u>CA</u>

                     CA is REAL
                     The coefficient c, which A is multiplied by.

           <u>A</u>

                     A is REAL array, dimension (LDA,NA)
                     The NA x NA matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of A.  It must be at least NA.

           <u>D1</u>

                     D1 is REAL
                     The 1,1 element in the diagonal matrix D.

           <u>D2</u>

                     D2 is REAL
                     The 2,2 element in the diagonal matrix D.  Not used if NA=1.

           <u>B</u>

                     B is REAL array, dimension (LDB,NW)
                     The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
                     complex), column 1 contains the real part of B and column 2
                     contains the imaginary part.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of B.  It must be at least NA.

           <u>WR</u>

                     WR is REAL
                     The real part of the scalar "w".

           <u>WI</u>

                     WI is REAL
                     The imaginary part of the scalar "w".  Not used if NW=1.

           <u>X</u>

                     X is REAL array, dimension (LDX,NW)
                     The NA x NW matrix X (unknowns), as computed by SLALN2.
                     If NW=2 ("w" is complex), on exit, column 1 will contain
                     the real part of X and column 2 will contain the imaginary
                     part.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of X.  It must be at least NA.

           <u>SCALE</u>

                     SCALE is REAL
                     The scale factor that B must be multiplied by to insure
                     that overflow does not occur when computing X.  Thus,
                     (ca A - w D) X  will be SCALE*B, not B (ignoring
                     perturbations of A.)  It will be at most 1.

           <u>XNORM</u>

                     XNORM is REAL
                     The infinity-norm of X, when X is regarded as an NA x NW
                     real matrix.

           <u>INFO</u>

                     INFO is INTEGER
                     An error flag.  It will be set to zero if no error occurs,
                     a negative number if an argument is in error, or a positive
                     number if  ca A - w D  had to be perturbed.
                     The possible values are:
                     = 0: No error occurred, and (ca A - w D) did not have to be
                            perturbed.
                     = 1: (ca A - w D) had to be perturbed to make its smallest
                          (or only) singular value greater than SMIN.
                     NOTE: In the interests of speed, this routine does not
                           check the inputs for errors.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>real</b> <b>function</b> <b>slangt</b> <b>(character</b> <b>NORM,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DL,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>DU)</b>
       <b>SLANGT</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value of
       any element of a general tridiagonal matrix.

       <b>Purpose:</b>

            SLANGT  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real tridiagonal matrix A.

       <b>Returns</b>
           SLANGT

               SLANGT = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in SLANGT as described
                     above.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, SLANGT is
                     set to zero.

           <u>DL</u>

                     DL is REAL array, dimension (N-1)
                     The (n-1) sub-diagonal elements of A.

           <u>D</u>

                     D is REAL array, dimension (N)
                     The diagonal elements of A.

           <u>DU</u>

                     DU is REAL array, dimension (N-1)
                     The (n-1) super-diagonal elements of A.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>real</b> <b>function</b> <b>slanhs</b> <b>(character</b> <b>NORM,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>WORK)</b>
       <b>SLANHS</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value of
       any element of an upper Hessenberg matrix.

       <b>Purpose:</b>

            SLANHS  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            Hessenberg matrix A.

       <b>Returns</b>
           SLANHS

               SLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in SLANHS as described
                     above.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, SLANHS is
                     set to zero.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     The n by n upper Hessenberg matrix A; the part of A below the
                     first sub-diagonal is not referenced.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(N,1).

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>real</b> <b>function</b> <b>slansb</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>real,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b>
       <b>integer</b> <b>LDAB,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>SLANSB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a symmetric band matrix.

       <b>Purpose:</b>

            SLANSB  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the element of  largest absolute value  of an
            n by n symmetric band matrix A,  with k super-diagonals.

       <b>Returns</b>
           SLANSB

               SLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in SLANSB as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     band matrix A is supplied.
                     = 'U':  Upper triangular part is supplied
                     = 'L':  Lower triangular part is supplied

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, SLANSB is
                     set to zero.

           <u>K</u>

                     K is INTEGER
                     The number of super-diagonals or sub-diagonals of the
                     band matrix A.  K &gt;= 0.

           <u>AB</u>

                     AB is REAL array, dimension (LDAB,N)
                     The upper or lower triangle of the symmetric band matrix A,
                     stored in the first K+1 rows of AB.  The j-th column of A is
                     stored in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j&lt;=i&lt;=min(n,j+k).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= K+1.

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I' or '1' or 'O'; otherwise,
                     WORK is not referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>real</b> <b>function</b> <b>slansp</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>real,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>WORK)</b>
       <b>SLANSP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a symmetric matrix supplied in packed form.

       <b>Purpose:</b>

            SLANSP  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real symmetric matrix A,  supplied in packed form.

       <b>Returns</b>
           SLANSP

               SLANSP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in SLANSP as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is supplied.
                     = 'U':  Upper triangular part of A is supplied
                     = 'L':  Lower triangular part of A is supplied

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, SLANSP is
                     set to zero.

           <u>AP</u>

                     AP is REAL array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the symmetric matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I' or '1' or 'O'; otherwise,
                     WORK is not referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>real</b> <b>function</b> <b>slantb</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>real,</b> <b>dimension(</b>
       <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>SLANTB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a triangular band matrix.

       <b>Purpose:</b>

            SLANTB  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the element of  largest absolute value  of an
            n by n triangular band matrix A,  with ( k + 1 ) diagonals.

       <b>Returns</b>
           SLANTB

               SLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in SLANTB as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, SLANTB is
                     set to zero.

           <u>K</u>

                     K is INTEGER
                     The number of super-diagonals of the matrix A if UPLO = 'U',
                     or the number of sub-diagonals of the matrix A if UPLO = 'L'.
                     K &gt;= 0.

           <u>AB</u>

                     AB is REAL array, dimension (LDAB,N)
                     The upper or lower triangular band matrix A, stored in the
                     first k+1 rows of AB.  The j-th column of A is stored
                     in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j&lt;=i&lt;=min(n,j+k).
                     Note that when DIAG = 'U', the elements of the array AB
                     corresponding to the diagonal elements of the matrix A are
                     not referenced, but are assumed to be one.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= K+1.

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>real</b> <b>function</b> <b>slantp</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>SLANTP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a triangular matrix supplied in packed form.

       <b>Purpose:</b>

            SLANTP  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            triangular matrix A, supplied in packed form.

       <b>Returns</b>
           SLANTP

               SLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in SLANTP as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, SLANTP is
                     set to zero.

           <u>AP</u>

                     AP is REAL array, dimension (N*(N+1)/2)
                     The upper or lower triangular matrix A, packed columnwise in
                     a linear array.  The j-th column of A is stored in the array
                     AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     Note that when DIAG = 'U', the elements of the array AP
                     corresponding to the diagonal elements of the matrix A are
                     not referenced, but are assumed to be one.

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>real</b> <b>function</b> <b>slantr</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b>
       <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>SLANTR</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a trapezoidal or triangular matrix.

       <b>Purpose:</b>

            SLANTR  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            trapezoidal or triangular matrix A.

       <b>Returns</b>
           SLANTR

               SLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in SLANTR as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower trapezoidal.
                     = 'U':  Upper trapezoidal
                     = 'L':  Lower trapezoidal
                     Note that A is triangular instead of trapezoidal if M = N.

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A has unit diagonal.
                     = 'N':  Non-unit diagonal
                     = 'U':  Unit diagonal

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0, and if
                     UPLO = 'U', M &lt;= N.  When M = 0, SLANTR is set to zero.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0, and if
                     UPLO = 'L', N &lt;= M.  When N = 0, SLANTR is set to zero.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     The trapezoidal matrix A (A is triangular if M = N).
                     If UPLO = 'U', the leading m by n upper trapezoidal part of
                     the array A contains the upper trapezoidal matrix, and the
                     strictly lower triangular part of A is not referenced.
                     If UPLO = 'L', the leading m by n lower trapezoidal part of
                     the array A contains the lower trapezoidal matrix, and the
                     strictly upper triangular part of A is not referenced.  Note
                     that when DIAG = 'U', the diagonal elements of A are not
                     referenced and are assumed to be one.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(M,1).

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= M when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slanv2</b> <b>(real</b> <b>A,</b> <b>real</b> <b>B,</b> <b>real</b> <b>C,</b> <b>real</b> <b>D,</b> <b>real</b> <b>RT1R,</b> <b>real</b> <b>RT1I,</b> <b>real</b> <b>RT2R,</b> <b>real</b> <b>RT2I,</b> <b>real</b> <b>CS,</b> <b>real</b>
       <b>SN)</b>
       <b>SLANV2</b> computes the Schur factorization of a real 2-by-2 nonsymmetric matrix in standard form.

       <b>Purpose:</b>

            SLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
            matrix in standard form:

                 [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
                 [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]

            where either
            1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
            2) AA = DD and BB*CC &lt; 0, so that AA + or - sqrt(BB*CC) are complex
            conjugate eigenvalues.

       <b>Parameters</b>
           <u>A</u>

                     A is REAL

           <u>B</u>

                     B is REAL

           <u>C</u>

                     C is REAL

           <u>D</u>

                     D is REAL
                     On entry, the elements of the input matrix.
                     On exit, they are overwritten by the elements of the
                     standardised Schur form.

           <u>RT1R</u>

                     RT1R is REAL

           <u>RT1I</u>

                     RT1I is REAL

           <u>RT2R</u>

                     RT2R is REAL

           <u>RT2I</u>

                     RT2I is REAL
                     The real and imaginary parts of the eigenvalues. If the
                     eigenvalues are a complex conjugate pair, RT1I &gt; 0.

           <u>CS</u>

                     CS is REAL

           <u>SN</u>

                     SN is REAL
                     Parameters of the rotation matrix.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Modified by V. Sima, Research Institute for Informatics, Bucharest,
             Romania, to reduce the risk of cancellation errors,
             when computing real eigenvalues, and to ensure, if possible, that
             abs(RT1R) &gt;= abs(RT2R).

   <b>subroutine</b> <b>slapll</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>INCY,</b>
       <b>real</b> <b>SSMIN)</b>
       <b>SLAPLL</b> measures the linear dependence of two vectors.

       <b>Purpose:</b>

            Given two column vectors X and Y, let

                                 A = ( X Y ).

            The subroutine first computes the QR factorization of A = Q*R,
            and then computes the SVD of the 2-by-2 upper triangular matrix R.
            The smaller singular value of R is returned in SSMIN, which is used
            as the measurement of the linear dependency of the vectors X and Y.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The length of the vectors X and Y.

           <u>X</u>

                     X is REAL array,
                                    dimension (1+(N-1)*INCX)
                     On entry, X contains the N-vector X.
                     On exit, X is overwritten.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between successive elements of X. INCX &gt; 0.

           <u>Y</u>

                     Y is REAL array,
                                    dimension (1+(N-1)*INCY)
                     On entry, Y contains the N-vector Y.
                     On exit, Y is overwritten.

           <u>INCY</u>

                     INCY is INTEGER
                     The increment between successive elements of Y. INCY &gt; 0.

           <u>SSMIN</u>

                     SSMIN is REAL
                     The smallest singular value of the N-by-2 matrix A = ( X Y ).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slapmr</b> <b>(logical</b> <b>FORWRD,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>K)</b>
       <b>SLAPMR</b> rearranges rows of a matrix as specified by a permutation vector.

       <b>Purpose:</b>

            SLAPMR rearranges the rows of the M by N matrix X as specified
            by the permutation <a href="../man1/K.1.html">K</a>(1),<a href="../man2/K.2.html">K</a>(2),...,K(M) of the integers 1,...,M.
            If FORWRD = .TRUE.,  forward permutation:

                 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

            If FORWRD = .FALSE., backward permutation:

                 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

       <b>Parameters</b>
           <u>FORWRD</u>

                     FORWRD is LOGICAL
                     = .TRUE., forward permutation
                     = .FALSE., backward permutation

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix X. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix X. N &gt;= 0.

           <u>X</u>

                     X is REAL array, dimension (LDX,N)
                     On entry, the M by N matrix X.
                     On exit, X contains the permuted matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X, LDX &gt;= MAX(1,M).

           <u>K</u>

                     K is INTEGER array, dimension (M)
                     On entry, K contains the permutation vector. K is used as
                     internal workspace, but reset to its original value on
                     output.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slapmt</b> <b>(logical</b> <b>FORWRD,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>K)</b>
       <b>SLAPMT</b> performs a forward or backward permutation of the columns of a matrix.

       <b>Purpose:</b>

            SLAPMT rearranges the columns of the M by N matrix X as specified
            by the permutation <a href="../man1/K.1.html">K</a>(1),<a href="../man2/K.2.html">K</a>(2),...,K(N) of the integers 1,...,N.
            If FORWRD = .TRUE.,  forward permutation:

                 X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.

            If FORWRD = .FALSE., backward permutation:

                 X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.

       <b>Parameters</b>
           <u>FORWRD</u>

                     FORWRD is LOGICAL
                     = .TRUE., forward permutation
                     = .FALSE., backward permutation

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix X. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix X. N &gt;= 0.

           <u>X</u>

                     X is REAL array, dimension (LDX,N)
                     On entry, the M by N matrix X.
                     On exit, X contains the permuted matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X, LDX &gt;= MAX(1,M).

           <u>K</u>

                     K is INTEGER array, dimension (N)
                     On entry, K contains the permutation vector. K is used as
                     internal workspace, but reset to its original value on
                     output.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slaqp2</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>OFFSET,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>JPVT,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VN1,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VN2,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>SLAQP2</b> computes a QR factorization with column pivoting of the matrix block.

       <b>Purpose:</b>

            SLAQP2 computes a QR factorization with column pivoting of
            the block A(OFFSET+1:M,1:N).
            The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A. N &gt;= 0.

           <u>OFFSET</u>

                     OFFSET is INTEGER
                     The number of rows of the matrix A that must be pivoted
                     but no factorized. OFFSET &gt;= 0.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, the upper triangle of block A(OFFSET+1:M,1:N) is
                     the triangular factor obtained; the elements in block
                     A(OFFSET+1:M,1:N) below the diagonal, together with the
                     array TAU, represent the orthogonal matrix Q as a product of
                     elementary reflectors. Block A(1:OFFSET,1:N) has been
                     accordingly pivoted, but no factorized.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>JPVT</u>

                     JPVT is INTEGER array, dimension (N)
                     On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
                     to the front of A*P (a leading column); if JPVT(i) = 0,
                     the i-th column of A is a free column.
                     On exit, if JPVT(i) = k, then the i-th column of A*P
                     was the k-th column of A.

           <u>TAU</u>

                     TAU is REAL array, dimension (min(M,N))
                     The scalar factors of the elementary reflectors.

           <u>VN1</u>

                     VN1 is REAL array, dimension (N)
                     The vector with the partial column norms.

           <u>VN2</u>

                     VN2 is REAL array, dimension (N)
                     The vector with the exact column norms.

           <u>WORK</u>

                     WORK is REAL array, dimension (N)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain X. Sun, Computer Science Dept.,
           Duke University, USA
            Partial column norm updating strategy modified on April 2011 Z. Drmac and Z. Bujanovic, Dept. of
           Mathematics, University of Zagreb, Croatia.

       <b>References:</b>
           LAPACK Working Note 176

   <b>subroutine</b> <b>slaqps</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>OFFSET,</b> <b>integer</b> <b>NB,</b> <b>integer</b> <b>KB,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b>
       <b>integer</b> <b>LDA,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>JPVT,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VN1,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>VN2,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AUXV,</b> <b>real,</b> <b>dimension(</b> <b>ldf,</b> <b>*</b> <b>)</b> <b>F,</b> <b>integer</b> <b>LDF)</b>
       <b>SLAQPS</b> computes a step of QR factorization with column pivoting of a real m-by-n matrix A by using BLAS
       level 3.

       <b>Purpose:</b>

            SLAQPS computes a step of QR factorization with column pivoting
            of a real M-by-N matrix A by using Blas-3.  It tries to factorize
            NB columns from A starting from the row OFFSET+1, and updates all
            of the matrix with Blas-3 xGEMM.

            In some cases, due to catastrophic cancellations, it cannot
            factorize NB columns.  Hence, the actual number of factorized
            columns is returned in KB.

            Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A. N &gt;= 0

           <u>OFFSET</u>

                     OFFSET is INTEGER
                     The number of rows of A that have been factorized in
                     previous steps.

           <u>NB</u>

                     NB is INTEGER
                     The number of columns to factorize.

           <u>KB</u>

                     KB is INTEGER
                     The number of columns actually factorized.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, block A(OFFSET+1:M,1:KB) is the triangular
                     factor obtained and block A(1:OFFSET,1:N) has been
                     accordingly pivoted, but no factorized.
                     The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
                     been updated.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>JPVT</u>

                     JPVT is INTEGER array, dimension (N)
                     JPVT(I) = K &lt;==&gt; Column K of the full matrix A has been
                     permuted into position I in AP.

           <u>TAU</u>

                     TAU is REAL array, dimension (KB)
                     The scalar factors of the elementary reflectors.

           <u>VN1</u>

                     VN1 is REAL array, dimension (N)
                     The vector with the partial column norms.

           <u>VN2</u>

                     VN2 is REAL array, dimension (N)
                     The vector with the exact column norms.

           <u>AUXV</u>

                     AUXV is REAL array, dimension (NB)
                     Auxiliary vector.

           <u>F</u>

                     F is REAL array, dimension (LDF,NB)
                     Matrix F**T = L*Y**T*A.

           <u>LDF</u>

                     LDF is INTEGER
                     The leading dimension of the array F. LDF &gt;= max(1,N).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain X. Sun, Computer Science Dept.,
           Duke University, USA

        Partial column norm updating strategy modified on April 2011 Z. Drmac and Z. Bujanovic, Dept. of
       Mathematics, University of Zagreb, Croatia.

       <b>References:</b>
           LAPACK Working Note 176

   <b>subroutine</b> <b>slaqr0</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>real,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b>
       <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WI,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>real,</b>
       <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAQR0</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
       decomposition.

       <b>Purpose:</b>

               SLAQR0 computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**T, where T is an upper quasi-triangular matrix (the
               Schur form), and Z is the orthogonal matrix of Schur vectors.

               Optionally Z may be postmultiplied into an input orthogonal
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     = .TRUE. : the full Schur form T is required;
                     = .FALSE.: only eigenvalues are required.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     = .TRUE. : the matrix of Schur vectors Z is required;
                     = .FALSE.: Schur vectors are not required.

           <u>N</u>

                     N is INTEGER
                      The order of the matrix H.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                      It is assumed that H is already upper triangular in rows
                      and columns 1:ILO-1 and IHI+1:N and, if ILO &gt; 1,
                      H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
                      previous call to SGEBAL, and then passed to SGEHRD when the
                      matrix output by SGEBAL is reduced to Hessenberg form.
                      Otherwise, ILO and IHI should be set to 1 and N,
                      respectively.  If N &gt; 0, then 1 &lt;= ILO &lt;= IHI &lt;= N.
                      If N = 0, then ILO = 1 and IHI = 0.

           <u>H</u>

                     H is REAL array, dimension (LDH,N)
                      On entry, the upper Hessenberg matrix H.
                      On exit, if INFO = 0 and WANTT is .TRUE., then H contains
                      the upper quasi-triangular matrix T from the Schur
                      decomposition (the Schur form); 2-by-2 diagonal blocks
                      (corresponding to complex conjugate pairs of eigenvalues)
                      are returned in standard form, with H(i,i) = H(i+1,i+1)
                      and H(i+1,i)*H(i,i+1) &lt; 0. If INFO = 0 and WANTT is
                      .FALSE., then the contents of H are unspecified on exit.
                      (The output value of H when INFO &gt; 0 is given under the
                      description of INFO below.)

                      This subroutine may explicitly set H(i,j) = 0 for i &gt; j and
                      j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.

           <u>LDH</u>

                     LDH is INTEGER
                      The leading dimension of the array H. LDH &gt;= max(1,N).

           <u>WR</u>

                     WR is REAL array, dimension (IHI)

           <u>WI</u>

                     WI is REAL array, dimension (IHI)
                      The real and imaginary parts, respectively, of the computed
                      eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
                      and WI(ILO:IHI). If two eigenvalues are computed as a
                      complex conjugate pair, they are stored in consecutive
                      elements of WR and WI, say the i-th and (i+1)th, with
                      WI(i) &gt; 0 and WI(i+1) &lt; 0. If WANTT is .TRUE., then
                      the eigenvalues are stored in the same order as on the
                      diagonal of the Schur form returned in H, with
                      WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
                      block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
                      WI(i+1) = -WI(i).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                      Specify the rows of Z to which transformations must be
                      applied if WANTZ is .TRUE..
                      1 &lt;= ILOZ &lt;= ILO; IHI &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is REAL array, dimension (LDZ,IHI)
                      If WANTZ is .FALSE., then Z is not referenced.
                      If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
                      replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
                      orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
                      (The output value of Z when INFO &gt; 0 is given under
                      the description of INFO below.)

           <u>LDZ</u>

                     LDZ is INTEGER
                      The leading dimension of the array Z.  if WANTZ is .TRUE.
                      then LDZ &gt;= MAX(1,IHIZ).  Otherwise, LDZ &gt;= 1.

           <u>WORK</u>

                     WORK is REAL array, dimension LWORK
                      On exit, if LWORK = -1, <a href="../man1/WORK.1.html">WORK</a>(1) returns an estimate of
                      the optimal value for LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK.  LWORK &gt;= max(1,N)
                      is sufficient, but LWORK typically as large as 6*N may
                      be required for optimal performance.  A workspace query
                      to determine the optimal workspace size is recommended.

                      If LWORK = -1, then SLAQR0 does a workspace query.
                      In this case, SLAQR0 checks the input parameters and
                      estimates the optimal workspace size for the given
                      values of N, ILO and IHI.  The estimate is returned
                      in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is
                      issued by XERBLA.  Neither H nor Z are accessed.

           <u>INFO</u>

                     INFO is INTEGER
                        = 0:  successful exit
                        &gt; 0:  if INFO = i, SLAQR0 failed to compute all of
                           the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                           and WI contain those eigenvalues which have been
                           successfully computed.  (Failures are rare.)

                           If INFO &gt; 0 and WANT is .FALSE., then on exit,
                           the remaining unconverged eigenvalues are the eigen-
                           values of the upper Hessenberg matrix rows and
                           columns ILO through INFO of the final, output
                           value of H.

                           If INFO &gt; 0 and WANTT is .TRUE., then on exit

                      (*)  (initial value of H)*U  = U*(final value of H)

                           where U is an orthogonal matrix.  The final
                           value of H is upper Hessenberg and quasi-triangular
                           in rows and columns INFO+1 through IHI.

                           If INFO &gt; 0 and WANTZ is .TRUE., then on exit

                             (final value of Z(ILO:IHI,ILOZ:IHIZ)
                              =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U

                           where U is the orthogonal matrix in (*) (regard-
                           less of the value of WANTT.)

                           If INFO &gt; 0 and WANTZ is .FALSE., then Z is not
                           accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

       <b>References:</b>

             K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
             Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
             Performance, SIAM Journal of Matrix Analysis, volume 23, pages
             929--947, 2002.

            K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part II: Aggressive Early
           Deflation, SIAM Journal of Matrix Analysis, volume 23, pages 948--973, 2002.

   <b>subroutine</b> <b>slaqr1</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>real</b> <b>SR1,</b> <b>real</b> <b>SI1,</b> <b>real</b> <b>SR2,</b> <b>real</b>
       <b>SI2,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V)</b>
       <b>SLAQR1</b> sets a scalar multiple of the first column of the product of 2-by-2 or 3-by-3 matrix H and
       specified shifts.

       <b>Purpose:</b>

                 Given a 2-by-2 or 3-by-3 matrix H, SLAQR1 sets v to a
                 scalar multiple of the first column of the product

                 (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)

                 scaling to avoid overflows and most underflows. It
                 is assumed that either

                         1) sr1 = sr2 and si1 = -si2
                     or
                         2) si1 = si2 = 0.

                 This is useful for starting double implicit shift bulges
                 in the QR algorithm.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                         Order of the matrix H. N must be either 2 or 3.

           <u>H</u>

                     H is REAL array, dimension (LDH,N)
                         The 2-by-2 or 3-by-3 matrix H in (*).

           <u>LDH</u>

                     LDH is INTEGER
                         The leading dimension of H as declared in
                         the calling procedure.  LDH &gt;= N

           <u>SR1</u>

                     SR1 is REAL

           <u>SI1</u>

                     SI1 is REAL

           <u>SR2</u>

                     SR2 is REAL

           <u>SI2</u>

                     SI2 is REAL
                         The shifts in (*).

           <u>V</u>

                     V is REAL array, dimension (N)
                         A scalar multiple of the first column of the
                         matrix K in (*).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

   <b>subroutine</b> <b>slaqr2</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KTOP,</b> <b>integer</b> <b>KBOT,</b> <b>integer</b> <b>NW,</b> <b>real,</b>
       <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>real,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b>
       <b>integer</b> <b>NS,</b> <b>integer</b> <b>ND,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SI,</b> <b>real,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b>
       <b>integer</b> <b>LDV,</b> <b>integer</b> <b>NH,</b> <b>real,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>integer</b> <b>NV,</b> <b>real,</b> <b>dimension(</b> <b>ldwv,</b> <b>*</b> <b>)</b>
       <b>WV,</b> <b>integer</b> <b>LDWV,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK)</b>
       <b>SLAQR2</b> performs the orthogonal similarity transformation of a Hessenberg matrix to detect and deflate
       fully converged eigenvalues from a trailing principal submatrix (aggressive early deflation).

       <b>Purpose:</b>

               SLAQR2 is identical to SLAQR3 except that it avoids
               recursion by calling SLAHQR instead of SLAQR4.

               Aggressive early deflation:

               This subroutine accepts as input an upper Hessenberg matrix
               H and performs an orthogonal similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.  On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an orthogonal similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     If .TRUE., then the Hessenberg matrix H is fully updated
                     so that the quasi-triangular Schur factor may be
                     computed (in cooperation with the calling subroutine).
                     If .FALSE., then only enough of H is updated to preserve
                     the eigenvalues.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     If .TRUE., then the orthogonal matrix Z is updated so
                     so that the orthogonal Schur factor may be computed
                     (in cooperation with the calling subroutine).
                     If .FALSE., then Z is not referenced.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H and (if WANTZ is .TRUE.) the
                     order of the orthogonal matrix Z.

           <u>KTOP</u>

                     KTOP is INTEGER
                     It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
                     KBOT and KTOP together determine an isolated block
                     along the diagonal of the Hessenberg matrix.

           <u>KBOT</u>

                     KBOT is INTEGER
                     It is assumed without a check that either
                     KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
                     determine an isolated block along the diagonal of the
                     Hessenberg matrix.

           <u>NW</u>

                     NW is INTEGER
                     Deflation window size.  1 &lt;= NW &lt;= (KBOT-KTOP+1).

           <u>H</u>

                     H is REAL array, dimension (LDH,N)
                     On input the initial N-by-N section of H stores the
                     Hessenberg matrix undergoing aggressive early deflation.
                     On output H has been transformed by an orthogonal
                     similarity transformation, perturbed, and the returned
                     to Hessenberg form that (it is to be hoped) has some
                     zero subdiagonal entries.

           <u>LDH</u>

                     LDH is INTEGER
                     Leading dimension of H just as declared in the calling
                     subroutine.  N &lt;= LDH

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                     Specify the rows of Z to which transformations must be
                     applied if WANTZ is .TRUE.. 1 &lt;= ILOZ &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is REAL array, dimension (LDZ,N)
                     IF WANTZ is .TRUE., then on output, the orthogonal
                     similarity transformation mentioned above has been
                     accumulated into Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right.
                     If WANTZ is .FALSE., then Z is unreferenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of Z just as declared in the
                     calling subroutine.  1 &lt;= LDZ.

           <u>NS</u>

                     NS is INTEGER
                     The number of unconverged (ie approximate) eigenvalues
                     returned in SR and SI that may be used as shifts by the
                     calling subroutine.

           <u>ND</u>

                     ND is INTEGER
                     The number of converged eigenvalues uncovered by this
                     subroutine.

           <u>SR</u>

                     SR is REAL array, dimension (KBOT)

           <u>SI</u>

                     SI is REAL array, dimension (KBOT)
                     On output, the real and imaginary parts of approximate
                     eigenvalues that may be used for shifts are stored in
                     SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
                     SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
                     The real and imaginary parts of converged eigenvalues
                     are stored in SR(KBOT-ND+1) through SR(KBOT) and
                     SI(KBOT-ND+1) through SI(KBOT), respectively.

           <u>V</u>

                     V is REAL array, dimension (LDV,NW)
                     An NW-by-NW work array.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of V just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>NH</u>

                     NH is INTEGER
                     The number of columns of T.  NH &gt;= NW.

           <u>T</u>

                     T is REAL array, dimension (LDT,NW)

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of T just as declared in the
                     calling subroutine.  NW &lt;= LDT

           <u>NV</u>

                     NV is INTEGER
                     The number of rows of work array WV available for
                     workspace.  NV &gt;= NW.

           <u>WV</u>

                     WV is REAL array, dimension (LDWV,NW)

           <u>LDWV</u>

                     LDWV is INTEGER
                     The leading dimension of W just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>WORK</u>

                     WORK is REAL array, dimension (LWORK)
                     On exit, <a href="../man1/WORK.1.html">WORK</a>(1) is set to an estimate of the optimal value
                     of LWORK for the given values of N, NW, KTOP and KBOT.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the work array WORK.  LWORK = 2*NW
                     suffices, but greater efficiency may result from larger
                     values of LWORK.

                     If LWORK = -1, then a workspace query is assumed; SLAQR2
                     only estimates the optimal workspace size for the given
                     values of N, NW, KTOP and KBOT.  The estimate is returned
                     in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is issued
                     by XERBLA.  Neither H nor Z are accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

   <b>subroutine</b> <b>slaqr3</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KTOP,</b> <b>integer</b> <b>KBOT,</b> <b>integer</b> <b>NW,</b> <b>real,</b>
       <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>real,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b>
       <b>integer</b> <b>NS,</b> <b>integer</b> <b>ND,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SI,</b> <b>real,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b>
       <b>integer</b> <b>LDV,</b> <b>integer</b> <b>NH,</b> <b>real,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>integer</b> <b>NV,</b> <b>real,</b> <b>dimension(</b> <b>ldwv,</b> <b>*</b> <b>)</b>
       <b>WV,</b> <b>integer</b> <b>LDWV,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK)</b>
       <b>SLAQR3</b> performs the orthogonal similarity transformation of a Hessenberg matrix to detect and deflate
       fully converged eigenvalues from a trailing principal submatrix (aggressive early deflation).

       <b>Purpose:</b>

               Aggressive early deflation:

               SLAQR3 accepts as input an upper Hessenberg matrix
               H and performs an orthogonal similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.  On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an orthogonal similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     If .TRUE., then the Hessenberg matrix H is fully updated
                     so that the quasi-triangular Schur factor may be
                     computed (in cooperation with the calling subroutine).
                     If .FALSE., then only enough of H is updated to preserve
                     the eigenvalues.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     If .TRUE., then the orthogonal matrix Z is updated so
                     so that the orthogonal Schur factor may be computed
                     (in cooperation with the calling subroutine).
                     If .FALSE., then Z is not referenced.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H and (if WANTZ is .TRUE.) the
                     order of the orthogonal matrix Z.

           <u>KTOP</u>

                     KTOP is INTEGER
                     It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
                     KBOT and KTOP together determine an isolated block
                     along the diagonal of the Hessenberg matrix.

           <u>KBOT</u>

                     KBOT is INTEGER
                     It is assumed without a check that either
                     KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
                     determine an isolated block along the diagonal of the
                     Hessenberg matrix.

           <u>NW</u>

                     NW is INTEGER
                     Deflation window size.  1 &lt;= NW &lt;= (KBOT-KTOP+1).

           <u>H</u>

                     H is REAL array, dimension (LDH,N)
                     On input the initial N-by-N section of H stores the
                     Hessenberg matrix undergoing aggressive early deflation.
                     On output H has been transformed by an orthogonal
                     similarity transformation, perturbed, and the returned
                     to Hessenberg form that (it is to be hoped) has some
                     zero subdiagonal entries.

           <u>LDH</u>

                     LDH is INTEGER
                     Leading dimension of H just as declared in the calling
                     subroutine.  N &lt;= LDH

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                     Specify the rows of Z to which transformations must be
                     applied if WANTZ is .TRUE.. 1 &lt;= ILOZ &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is REAL array, dimension (LDZ,N)
                     IF WANTZ is .TRUE., then on output, the orthogonal
                     similarity transformation mentioned above has been
                     accumulated into Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right.
                     If WANTZ is .FALSE., then Z is unreferenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of Z just as declared in the
                     calling subroutine.  1 &lt;= LDZ.

           <u>NS</u>

                     NS is INTEGER
                     The number of unconverged (ie approximate) eigenvalues
                     returned in SR and SI that may be used as shifts by the
                     calling subroutine.

           <u>ND</u>

                     ND is INTEGER
                     The number of converged eigenvalues uncovered by this
                     subroutine.

           <u>SR</u>

                     SR is REAL array, dimension (KBOT)

           <u>SI</u>

                     SI is REAL array, dimension (KBOT)
                     On output, the real and imaginary parts of approximate
                     eigenvalues that may be used for shifts are stored in
                     SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
                     SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
                     The real and imaginary parts of converged eigenvalues
                     are stored in SR(KBOT-ND+1) through SR(KBOT) and
                     SI(KBOT-ND+1) through SI(KBOT), respectively.

           <u>V</u>

                     V is REAL array, dimension (LDV,NW)
                     An NW-by-NW work array.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of V just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>NH</u>

                     NH is INTEGER
                     The number of columns of T.  NH &gt;= NW.

           <u>T</u>

                     T is REAL array, dimension (LDT,NW)

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of T just as declared in the
                     calling subroutine.  NW &lt;= LDT

           <u>NV</u>

                     NV is INTEGER
                     The number of rows of work array WV available for
                     workspace.  NV &gt;= NW.

           <u>WV</u>

                     WV is REAL array, dimension (LDWV,NW)

           <u>LDWV</u>

                     LDWV is INTEGER
                     The leading dimension of W just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>WORK</u>

                     WORK is REAL array, dimension (LWORK)
                     On exit, <a href="../man1/WORK.1.html">WORK</a>(1) is set to an estimate of the optimal value
                     of LWORK for the given values of N, NW, KTOP and KBOT.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the work array WORK.  LWORK = 2*NW
                     suffices, but greater efficiency may result from larger
                     values of LWORK.

                     If LWORK = -1, then a workspace query is assumed; SLAQR3
                     only estimates the optimal workspace size for the given
                     values of N, NW, KTOP and KBOT.  The estimate is returned
                     in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is issued
                     by XERBLA.  Neither H nor Z are accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

   <b>subroutine</b> <b>slaqr4</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>real,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b>
       <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WI,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>real,</b>
       <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAQR4</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
       decomposition.

       <b>Purpose:</b>

               SLAQR4 implements one level of recursion for SLAQR0.
               It is a complete implementation of the small bulge multi-shift
               QR algorithm.  It may be called by SLAQR0 and, for large enough
               deflation window size, it may be called by SLAQR3.  This
               subroutine is identical to SLAQR0 except that it calls SLAQR2
               instead of SLAQR3.

               SLAQR4 computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**T, where T is an upper quasi-triangular matrix (the
               Schur form), and Z is the orthogonal matrix of Schur vectors.

               Optionally Z may be postmultiplied into an input orthogonal
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     = .TRUE. : the full Schur form T is required;
                     = .FALSE.: only eigenvalues are required.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     = .TRUE. : the matrix of Schur vectors Z is required;
                     = .FALSE.: Schur vectors are not required.

           <u>N</u>

                     N is INTEGER
                      The order of the matrix H.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                      It is assumed that H is already upper triangular in rows
                      and columns 1:ILO-1 and IHI+1:N and, if ILO &gt; 1,
                      H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
                      previous call to SGEBAL, and then passed to SGEHRD when the
                      matrix output by SGEBAL is reduced to Hessenberg form.
                      Otherwise, ILO and IHI should be set to 1 and N,
                      respectively.  If N &gt; 0, then 1 &lt;= ILO &lt;= IHI &lt;= N.
                      If N = 0, then ILO = 1 and IHI = 0.

           <u>H</u>

                     H is REAL array, dimension (LDH,N)
                      On entry, the upper Hessenberg matrix H.
                      On exit, if INFO = 0 and WANTT is .TRUE., then H contains
                      the upper quasi-triangular matrix T from the Schur
                      decomposition (the Schur form); 2-by-2 diagonal blocks
                      (corresponding to complex conjugate pairs of eigenvalues)
                      are returned in standard form, with H(i,i) = H(i+1,i+1)
                      and H(i+1,i)*H(i,i+1) &lt; 0. If INFO = 0 and WANTT is
                      .FALSE., then the contents of H are unspecified on exit.
                      (The output value of H when INFO &gt; 0 is given under the
                      description of INFO below.)

                      This subroutine may explicitly set H(i,j) = 0 for i &gt; j and
                      j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.

           <u>LDH</u>

                     LDH is INTEGER
                      The leading dimension of the array H. LDH &gt;= max(1,N).

           <u>WR</u>

                     WR is REAL array, dimension (IHI)

           <u>WI</u>

                     WI is REAL array, dimension (IHI)
                      The real and imaginary parts, respectively, of the computed
                      eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
                      and WI(ILO:IHI). If two eigenvalues are computed as a
                      complex conjugate pair, they are stored in consecutive
                      elements of WR and WI, say the i-th and (i+1)th, with
                      WI(i) &gt; 0 and WI(i+1) &lt; 0. If WANTT is .TRUE., then
                      the eigenvalues are stored in the same order as on the
                      diagonal of the Schur form returned in H, with
                      WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
                      block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
                      WI(i+1) = -WI(i).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                      Specify the rows of Z to which transformations must be
                      applied if WANTZ is .TRUE..
                      1 &lt;= ILOZ &lt;= ILO; IHI &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is REAL array, dimension (LDZ,IHI)
                      If WANTZ is .FALSE., then Z is not referenced.
                      If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
                      replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
                      orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
                      (The output value of Z when INFO &gt; 0 is given under
                      the description of INFO below.)

           <u>LDZ</u>

                     LDZ is INTEGER
                      The leading dimension of the array Z.  if WANTZ is .TRUE.
                      then LDZ &gt;= MAX(1,IHIZ).  Otherwise, LDZ &gt;= 1.

           <u>WORK</u>

                     WORK is REAL array, dimension LWORK
                      On exit, if LWORK = -1, <a href="../man1/WORK.1.html">WORK</a>(1) returns an estimate of
                      the optimal value for LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK.  LWORK &gt;= max(1,N)
                      is sufficient, but LWORK typically as large as 6*N may
                      be required for optimal performance.  A workspace query
                      to determine the optimal workspace size is recommended.

                      If LWORK = -1, then SLAQR4 does a workspace query.
                      In this case, SLAQR4 checks the input parameters and
                      estimates the optimal workspace size for the given
                      values of N, ILO and IHI.  The estimate is returned
                      in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is
                      issued by XERBLA.  Neither H nor Z are accessed.

           <u>INFO</u>

                     INFO is INTEGER
            batim
                     INFO is INTEGER
                        = 0:  successful exit
                        &gt; 0:  if INFO = i, SLAQR4 failed to compute all of
                           the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                           and WI contain those eigenvalues which have been
                           successfully computed.  (Failures are rare.)

                           If INFO &gt; 0 and WANT is .FALSE., then on exit,
                           the remaining unconverged eigenvalues are the eigen-
                           values of the upper Hessenberg matrix rows and
                           columns ILO through INFO of the final, output
                           value of H.

                           If INFO &gt; 0 and WANTT is .TRUE., then on exit

                      (*)  (initial value of H)*U  = U*(final value of H)

                           where U is a orthogonal matrix.  The final
                           value of  H is upper Hessenberg and triangular in
                           rows and columns INFO+1 through IHI.

                           If INFO &gt; 0 and WANTZ is .TRUE., then on exit

                             (final value of Z(ILO:IHI,ILOZ:IHIZ)
                              =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U

                           where U is the orthogonal matrix in (*) (regard-
                           less of the value of WANTT.)

                           If INFO &gt; 0 and WANTZ is .FALSE., then Z is not
                           accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

       <b>References:</b>

             K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
             Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
             Performance, SIAM Journal of Matrix Analysis, volume 23, pages
             929--947, 2002.

            K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part II: Aggressive Early
           Deflation, SIAM Journal of Matrix Analysis, volume 23, pages 948--973, 2002.

   <b>subroutine</b> <b>slaqr5</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>KACC22,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KTOP,</b> <b>integer</b> <b>KBOT,</b>
       <b>integer</b> <b>NSHFTS,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SI,</b> <b>real,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b>
       <b>LDH,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>real,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>real,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b>
       <b>integer</b> <b>LDV,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>integer</b> <b>NV,</b> <b>real,</b> <b>dimension(</b> <b>ldwv,</b> <b>*</b> <b>)</b> <b>WV,</b> <b>integer</b>
       <b>LDWV,</b> <b>integer</b> <b>NH,</b> <b>real,</b> <b>dimension(</b> <b>ldwh,</b> <b>*</b> <b>)</b> <b>WH,</b> <b>integer</b> <b>LDWH)</b>
       <b>SLAQR5</b> performs a single small-bulge multi-shift QR sweep.

       <b>Purpose:</b>

               SLAQR5, called by SLAQR0, performs a
               single small-bulge multi-shift QR sweep.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                        WANTT = .true. if the quasi-triangular Schur factor
                        is being computed.  WANTT is set to .false. otherwise.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                        WANTZ = .true. if the orthogonal Schur factor is being
                        computed.  WANTZ is set to .false. otherwise.

           <u>KACC22</u>

                     KACC22 is INTEGER with value 0, 1, or 2.
                        Specifies the computation mode of far-from-diagonal
                        orthogonal updates.
                   = 0: SLAQR5 does not accumulate reflections and does not
                        use matrix-matrix multiply to update far-from-diagonal
                        matrix entries.
                   = 1: SLAQR5 accumulates reflections and uses matrix-matrix
                        multiply to update the far-from-diagonal matrix entries.
                   = 2: Same as KACC22 = 1. This option used to enable exploiting
                        the 2-by-2 structure during matrix multiplications, but
                        this is no longer supported.

           <u>N</u>

                     N is INTEGER
                        N is the order of the Hessenberg matrix H upon which this
                        subroutine operates.

           <u>KTOP</u>

                     KTOP is INTEGER

           <u>KBOT</u>

                     KBOT is INTEGER
                        These are the first and last rows and columns of an
                        isolated diagonal block upon which the QR sweep is to be
                        applied. It is assumed without a check that
                                  either KTOP = 1  or   H(KTOP,KTOP-1) = 0
                        and
                                  either KBOT = N  or   H(KBOT+1,KBOT) = 0.

           <u>NSHFTS</u>

                     NSHFTS is INTEGER
                        NSHFTS gives the number of simultaneous shifts.  NSHFTS
                        must be positive and even.

           <u>SR</u>

                     SR is REAL array, dimension (NSHFTS)

           <u>SI</u>

                     SI is REAL array, dimension (NSHFTS)
                        SR contains the real parts and SI contains the imaginary
                        parts of the NSHFTS shifts of origin that define the
                        multi-shift QR sweep.  On output SR and SI may be
                        reordered.

           <u>H</u>

                     H is REAL array, dimension (LDH,N)
                        On input H contains a Hessenberg matrix.  On output a
                        multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
                        to the isolated diagonal block in rows and columns KTOP
                        through KBOT.

           <u>LDH</u>

                     LDH is INTEGER
                        LDH is the leading dimension of H just as declared in the
                        calling procedure.  LDH &gt;= MAX(1,N).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                        Specify the rows of Z to which transformations must be
                        applied if WANTZ is .TRUE.. 1 &lt;= ILOZ &lt;= IHIZ &lt;= N

           <u>Z</u>

                     Z is REAL array, dimension (LDZ,IHIZ)
                        If WANTZ = .TRUE., then the QR Sweep orthogonal
                        similarity transformation is accumulated into
                        Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right.
                        If WANTZ = .FALSE., then Z is unreferenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                        LDA is the leading dimension of Z just as declared in
                        the calling procedure. LDZ &gt;= N.

           <u>V</u>

                     V is REAL array, dimension (LDV,NSHFTS/2)

           <u>LDV</u>

                     LDV is INTEGER
                        LDV is the leading dimension of V as declared in the
                        calling procedure.  LDV &gt;= 3.

           <u>U</u>

                     U is REAL array, dimension (LDU,2*NSHFTS)

           <u>LDU</u>

                     LDU is INTEGER
                        LDU is the leading dimension of U just as declared in the
                        in the calling subroutine.  LDU &gt;= 2*NSHFTS.

           <u>NV</u>

                     NV is INTEGER
                        NV is the number of rows in WV agailable for workspace.
                        NV &gt;= 1.

           <u>WV</u>

                     WV is REAL array, dimension (LDWV,2*NSHFTS)

           <u>LDWV</u>

                     LDWV is INTEGER
                        LDWV is the leading dimension of WV as declared in the
                        in the calling subroutine.  LDWV &gt;= NV.

           <u>NH</u>

                     NH is INTEGER
                        NH is the number of columns in array WH available for
                        workspace. NH &gt;= 1.

           <u>WH</u>

                     WH is REAL array, dimension (LDWH,NH)

           <u>LDWH</u>

                     LDWH is INTEGER
                        Leading dimension of WH just as declared in the
                        calling procedure.  LDWH &gt;= 2*NSHFTS.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

       Lars Karlsson, Daniel Kressner, and Bruno Lang

       Thijs Steel, Department of Computer science, KU Leuven, Belgium

       <b>References:</b>
           K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part I: Maintaining Well Focused
           Shifts, and Level 3 Performance, SIAM Journal of Matrix Analysis, volume 23, pages 929--947, 2002.

       Lars Karlsson, Daniel Kressner, and Bruno Lang, Optimally packed chains of bulges in multishift QR
       algorithms. ACM Trans. Math. Softw. 40, 2, Article 12 (February 2014).

   <b>subroutine</b> <b>slaqsb</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>real,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>real</b> <b>SCOND,</b> <b>real</b> <b>AMAX,</b> <b>character</b> <b>EQUED)</b>
       <b>SLAQSB</b> scales a symmetric/Hermitian band matrix, using scaling factors computed by spbequ.

       <b>Purpose:</b>

            SLAQSB equilibrates a symmetric band matrix A using the scaling
            factors in the vector S.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is stored.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of super-diagonals of the matrix A if UPLO = 'U',
                     or the number of sub-diagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>AB</u>

                     AB is REAL array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the symmetric band
                     matrix A, stored in the first KD+1 rows of the array.  The
                     j-th column of A is stored in the j-th column of the array AB
                     as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

                     On exit, if INFO = 0, the triangular factor U or L from the
                     Cholesky factorization A = U**T*U or A = L*L**T of the band
                     matrix A, in the same storage format as A.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>S</u>

                     S is REAL array, dimension (N)
                     The scale factors for A.

           <u>SCOND</u>

                     SCOND is REAL
                     Ratio of the smallest S(i) to the largest S(i).

           <u>AMAX</u>

                     AMAX is REAL
                     Absolute value of largest matrix entry.

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                     Specifies whether or not equilibration was done.
                     = 'N':  No equilibration.
                     = 'Y':  Equilibration was done, i.e., A has been replaced by
                             diag(S) * A * diag(S).

       <b>Internal</b> <b>Parameters:</b>

             THRESH is a threshold value used to decide if scaling should be done
             based on the ratio of the scaling factors.  If SCOND &lt; THRESH,
             scaling is done.

             LARGE and SMALL are threshold values used to decide if scaling should
             be done based on the absolute size of the largest matrix element.
             If AMAX &gt; LARGE or AMAX &lt; SMALL, scaling is done.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slaqsp</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>real</b> <b>SCOND,</b>
       <b>real</b> <b>AMAX,</b> <b>character</b> <b>EQUED)</b>
       <b>SLAQSP</b> scales a symmetric/Hermitian matrix in packed storage, using scaling factors computed by sppequ.

       <b>Purpose:</b>

            SLAQSP equilibrates a symmetric matrix A using the scaling factors
            in the vector S.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is stored.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is REAL array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the symmetric matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

                     On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
                     the same storage format as A.

           <u>S</u>

                     S is REAL array, dimension (N)
                     The scale factors for A.

           <u>SCOND</u>

                     SCOND is REAL
                     Ratio of the smallest S(i) to the largest S(i).

           <u>AMAX</u>

                     AMAX is REAL
                     Absolute value of largest matrix entry.

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                     Specifies whether or not equilibration was done.
                     = 'N':  No equilibration.
                     = 'Y':  Equilibration was done, i.e., A has been replaced by
                             diag(S) * A * diag(S).

       <b>Internal</b> <b>Parameters:</b>

             THRESH is a threshold value used to decide if scaling should be done
             based on the ratio of the scaling factors.  If SCOND &lt; THRESH,
             scaling is done.

             LARGE and SMALL are threshold values used to decide if scaling should
             be done based on the absolute size of the largest matrix element.
             If AMAX &gt; LARGE or AMAX &lt; SMALL, scaling is done.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slaqtr</b> <b>(logical</b> <b>LTRAN,</b> <b>logical</b> <b>LREAL,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>B,</b> <b>real</b> <b>W,</b> <b>real</b> <b>SCALE,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAQTR</b> solves a real quasi-triangular system of equations, or a complex quasi-triangular system of
       special form, in real arithmetic.

       <b>Purpose:</b>

            SLAQTR solves the real quasi-triangular system

                         op(T)*p = scale*c,               if LREAL = .TRUE.

            or the complex quasi-triangular systems

                       op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.

            in real arithmetic, where T is upper quasi-triangular.
            If LREAL = .FALSE., then the first diagonal block of T must be
            1 by 1, B is the specially structured matrix

                           B = [ <a href="../man1/b.1.html">b</a>(1) <a href="../man2/b.2.html">b</a>(2) ... b(n) ]
                               [       w            ]
                               [           w        ]
                               [              .     ]
                               [                 w  ]

            op(A) = A or A**T, A**T denotes the transpose of
            matrix A.

            On input, X = [ c ].  On output, X = [ p ].
                          [ d ]                  [ q ]

            This subroutine is designed for the condition number estimation
            in routine STRSNA.

       <b>Parameters</b>
           <u>LTRAN</u>

                     LTRAN is LOGICAL
                     On entry, LTRAN specifies the option of conjugate transpose:
                        = .FALSE.,    op(T+i*B) = T+i*B,
                        = .TRUE.,     op(T+i*B) = (T+i*B)**T.

           <u>LREAL</u>

                     LREAL is LOGICAL
                     On entry, LREAL specifies the input matrix structure:
                        = .FALSE.,    the input is complex
                        = .TRUE.,     the input is real

           <u>N</u>

                     N is INTEGER
                     On entry, N specifies the order of T+i*B. N &gt;= 0.

           <u>T</u>

                     T is REAL array, dimension (LDT,N)
                     On entry, T contains a matrix in Schur canonical form.
                     If LREAL = .FALSE., then the first diagonal block of T must
                     be 1 by 1.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the matrix T. LDT &gt;= max(1,N).

           <u>B</u>

                     B is REAL array, dimension (N)
                     On entry, B contains the elements to form the matrix
                     B as described above.
                     If LREAL = .TRUE., B is not referenced.

           <u>W</u>

                     W is REAL
                     On entry, W is the diagonal element of the matrix B.
                     If LREAL = .TRUE., W is not referenced.

           <u>SCALE</u>

                     SCALE is REAL
                     On exit, SCALE is the scale factor.

           <u>X</u>

                     X is REAL array, dimension (2*N)
                     On entry, X contains the right hand side of the system.
                     On exit, X is overwritten by the solution.

           <u>WORK</u>

                     WORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     On exit, INFO is set to
                        0: successful exit.
                          1: the some diagonal 1 by 1 block has been perturbed by
                             a small number SMIN to keep nonsingularity.
                          2: the some diagonal 2 by 2 block has been perturbed by
                             a small number in SLALN2 to keep nonsingularity.
                     NOTE: In the interests of speed, this routine does not
                           check the inputs for errors.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slar1v</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>B1,</b> <b>integer</b> <b>BN,</b> <b>real</b> <b>LAMBDA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>L,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>LD,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>LLD,</b> <b>real</b> <b>PIVMIN,</b> <b>real</b> <b>GAPTOL,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b>
       <b>logical</b> <b>WANTNC,</b> <b>integer</b> <b>NEGCNT,</b> <b>real</b> <b>ZTZ,</b> <b>real</b> <b>MINGMA,</b> <b>integer</b> <b>R,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISUPPZ,</b> <b>real</b>
       <b>NRMINV,</b> <b>real</b> <b>RESID,</b> <b>real</b> <b>RQCORR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>SLAR1V</b> computes the (scaled) r-th column of the inverse of the submatrix in rows b1 through bn of the
       tridiagonal matrix LDLT - λI.

       <b>Purpose:</b>

            SLAR1V computes the (scaled) r-th column of the inverse of
            the sumbmatrix in rows B1 through BN of the tridiagonal matrix
            L D L**T - sigma I. When sigma is close to an eigenvalue, the
            computed vector is an accurate eigenvector. Usually, r corresponds
            to the index where the eigenvector is largest in magnitude.
            The following steps accomplish this computation :
            (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
            (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
            (c) Computation of the diagonal elements of the inverse of
                L D L**T - sigma I by combining the above transforms, and choosing
                r as the index where the diagonal of the inverse is (one of the)
                largest in magnitude.
            (d) Computation of the (scaled) r-th column of the inverse using the
                twisted factorization obtained by combining the top part of the
                the stationary and the bottom part of the progressive transform.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                      The order of the matrix L D L**T.

           <u>B1</u>

                     B1 is INTEGER
                      First index of the submatrix of L D L**T.

           <u>BN</u>

                     BN is INTEGER
                      Last index of the submatrix of L D L**T.

           <u>LAMBDA</u>

                     LAMBDA is REAL
                      The shift. In order to compute an accurate eigenvector,
                      LAMBDA should be a good approximation to an eigenvalue
                      of L D L**T.

           <u>L</u>

                     L is REAL array, dimension (N-1)
                      The (n-1) subdiagonal elements of the unit bidiagonal matrix
                      L, in elements 1 to N-1.

           <u>D</u>

                     D is REAL array, dimension (N)
                      The n diagonal elements of the diagonal matrix D.

           <u>LD</u>

                     LD is REAL array, dimension (N-1)
                      The n-1 elements L(i)*D(i).

           <u>LLD</u>

                     LLD is REAL array, dimension (N-1)
                      The n-1 elements L(i)*L(i)*D(i).

           <u>PIVMIN</u>

                     PIVMIN is REAL
                      The minimum pivot in the Sturm sequence.

           <u>GAPTOL</u>

                     GAPTOL is REAL
                      Tolerance that indicates when eigenvector entries are negligible
                      w.r.t. their contribution to the residual.

           <u>Z</u>

                     Z is REAL array, dimension (N)
                      On input, all entries of Z must be set to 0.
                      On output, Z contains the (scaled) r-th column of the
                      inverse. The scaling is such that Z(R) equals 1.

           <u>WANTNC</u>

                     WANTNC is LOGICAL
                      Specifies whether NEGCNT has to be computed.

           <u>NEGCNT</u>

                     NEGCNT is INTEGER
                      If WANTNC is .TRUE. then NEGCNT = the number of pivots &lt; pivmin
                      in the  matrix factorization L D L**T, and NEGCNT = -1 otherwise.

           <u>ZTZ</u>

                     ZTZ is REAL
                      The square of the 2-norm of Z.

           <u>MINGMA</u>

                     MINGMA is REAL
                      The reciprocal of the largest (in magnitude) diagonal
                      element of the inverse of L D L**T - sigma I.

           <u>R</u>

                     R is INTEGER
                      The twist index for the twisted factorization used to
                      compute Z.
                      On input, 0 &lt;= R &lt;= N. If R is input as 0, R is set to
                      the index where (L D L**T - sigma I)^{-1} is largest
                      in magnitude. If 1 &lt;= R &lt;= N, R is unchanged.
                      On output, R contains the twist index used to compute Z.
                      Ideally, R designates the position of the maximum entry in the
                      eigenvector.

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension (2)
                      The support of the vector in Z, i.e., the vector Z is
                      nonzero only in elements <a href="../man1/ISUPPZ.1.html">ISUPPZ</a>(1) through ISUPPZ( 2 ).

           <u>NRMINV</u>

                     NRMINV is REAL
                      NRMINV = 1/SQRT( ZTZ )

           <u>RESID</u>

                     RESID is REAL
                      The residual of the FP vector.
                      RESID = ABS( MINGMA )/SQRT( ZTZ )

           <u>RQCORR</u>

                     RQCORR is REAL
                      The Rayleigh Quotient correction to LAMBDA.
                      RQCORR = MINGMA*TMP

           <u>WORK</u>

                     WORK is REAL array, dimension (4*N)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Beresford Parlett, University of California, Berkeley, USA
            Jim Demmel, University of California, Berkeley, USA
            Inderjit Dhillon, University of Texas, Austin, USA
            Osni Marques, LBNL/NERSC, USA
            Christof Voemel, University of California, Berkeley, USA

   <b>subroutine</b> <b>slar2v</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b>
       <b>INCX,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>integer</b> <b>INCC)</b>
       <b>SLAR2V</b> applies a vector of plane rotations with real cosines and real sines from both sides to a sequence
       of 2-by-2 symmetric/Hermitian matrices.

       <b>Purpose:</b>

            SLAR2V applies a vector of real plane rotations from both sides to
            a sequence of 2-by-2 real symmetric matrices, defined by the elements
            of the vectors x, y and z. For i = 1,2,...,n

               ( x(i)  z(i) ) := (  c(i)  s(i) ) ( x(i)  z(i) ) ( c(i) -s(i) )
               ( z(i)  y(i) )    ( -s(i)  c(i) ) ( z(i)  y(i) ) ( s(i)  c(i) )

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of plane rotations to be applied.

           <u>X</u>

                     X is REAL array,
                                    dimension (1+(N-1)*INCX)
                     The vector x.

           <u>Y</u>

                     Y is REAL array,
                                    dimension (1+(N-1)*INCX)
                     The vector y.

           <u>Z</u>

                     Z is REAL array,
                                    dimension (1+(N-1)*INCX)
                     The vector z.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X, Y and Z. INCX &gt; 0.

           <u>C</u>

                     C is REAL array, dimension (1+(N-1)*INCC)
                     The cosines of the plane rotations.

           <u>S</u>

                     S is REAL array, dimension (1+(N-1)*INCC)
                     The sines of the plane rotations.

           <u>INCC</u>

                     INCC is INTEGER
                     The increment between elements of C and S. INCC &gt; 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slarf</b> <b>(character</b> <b>SIDE,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>INCV,</b> <b>real</b> <b>TAU,</b> <b>real,</b>
       <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>SLARF</b> applies an elementary reflector to a general rectangular matrix.

       <b>Purpose:</b>

            SLARF applies a real elementary reflector H to a real m by n matrix
            C, from either the left or the right. H is represented in the form

                  H = I - tau * v * v**T

            where tau is a real scalar and v is a real vector.

            If tau = 0, then H is taken to be the unit matrix.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': form  H * C
                     = 'R': form  C * H

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C.

           <u>V</u>

                     V is REAL array, dimension
                                (1 + (M-1)*abs(INCV)) if SIDE = 'L'
                             or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
                     The vector v in the representation of H. V is not used if
                     TAU = 0.

           <u>INCV</u>

                     INCV is INTEGER
                     The increment between elements of v. INCV &lt;&gt; 0.

           <u>TAU</u>

                     TAU is REAL
                     The value tau in the representation of H.

           <u>C</u>

                     C is REAL array, dimension (LDC,N)
                     On entry, the m by n matrix C.
                     On exit, C is overwritten by the matrix H * C if SIDE = 'L',
                     or C * H if SIDE = 'R'.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is REAL array, dimension
                                    (N) if SIDE = 'L'
                                 or (M) if SIDE = 'R'

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slarfb</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIRECT,</b> <b>character</b> <b>STOREV,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b>
       <b>integer</b> <b>K,</b> <b>real,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>real,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>real,</b>
       <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>real,</b> <b>dimension(</b> <b>ldwork,</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LDWORK)</b>
       <b>SLARFB</b> applies a block reflector or its transpose to a general rectangular matrix.

       <b>Purpose:</b>

            SLARFB applies a real block reflector H or its transpose H**T to a
            real m by n matrix C, from either the left or the right.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply H or H**T from the Left
                     = 'R': apply H or H**T from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply H (No transpose)
                     = 'T': apply H**T (Transpose)

           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Indicates how H is formed from a product of elementary
                     reflectors
                     = 'F': H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) (Forward)
                     = 'B': H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) (Backward)

           <u>STOREV</u>

                     STOREV is CHARACTER*1
                     Indicates how the vectors which define the elementary
                     reflectors are stored:
                     = 'C': Columnwise
                     = 'R': Rowwise

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C.

           <u>K</u>

                     K is INTEGER
                     The order of the matrix T (= the number of elementary
                     reflectors whose product defines the block reflector).
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>V</u>

                     V is REAL array, dimension
                                           (LDV,K) if STOREV = 'C'
                                           (LDV,M) if STOREV = 'R' and SIDE = 'L'
                                           (LDV,N) if STOREV = 'R' and SIDE = 'R'
                     The matrix V. See Further Details.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If STOREV = 'C' and SIDE = 'L', LDV &gt;= max(1,M);
                     if STOREV = 'C' and SIDE = 'R', LDV &gt;= max(1,N);
                     if STOREV = 'R', LDV &gt;= K.

           <u>T</u>

                     T is REAL array, dimension (LDT,K)
                     The triangular k by k matrix T in the representation of the
                     block reflector.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= K.

           <u>C</u>

                     C is REAL array, dimension (LDC,N)
                     On entry, the m by n matrix C.
                     On exit, C is overwritten by H*C or H**T*C or C*H or C*H**T.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is REAL array, dimension (LDWORK,K)

           <u>LDWORK</u>

                     LDWORK is INTEGER
                     The leading dimension of the array WORK.
                     If SIDE = 'L', LDWORK &gt;= max(1,N);
                     if SIDE = 'R', LDWORK &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The shape of the matrix V and the storage of the vectors which define
             the H(i) is best illustrated by the following example with n = 5 and
             k = 3. The elements equal to 1 are not stored; the corresponding
             array elements are modified but restored on exit. The rest of the
             array is not used.

             DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':

                          V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                              ( v1  1    )                     (     1 v2 v2 v2 )
                              ( v1 v2  1 )                     (        1 v3 v3 )
                              ( v1 v2 v3 )
                              ( v1 v2 v3 )

             DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':

                          V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                              ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                              (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                              (     1 v3 )
                              (        1 )

   <b>subroutine</b> <b>slarfg</b> <b>(integer</b> <b>N,</b> <b>real</b> <b>ALPHA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>real</b> <b>TAU)</b>
       <b>SLARFG</b> generates an elementary reflector (Householder matrix).

       <b>Purpose:</b>

            SLARFG generates a real elementary reflector H of order n, such
            that

                  H * ( alpha ) = ( beta ),   H**T * H = I.
                      (   x   )   (   0  )

            where alpha and beta are scalars, and x is an (n-1)-element real
            vector. H is represented in the form

                  H = I - tau * ( 1 ) * ( 1 v**T ) ,
                                ( v )

            where tau is a real scalar and v is a real (n-1)-element
            vector.

            If the elements of x are all zero, then tau = 0 and H is taken to be
            the unit matrix.

            Otherwise  1 &lt;= tau &lt;= 2.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the elementary reflector.

           <u>ALPHA</u>

                     ALPHA is REAL
                     On entry, the value alpha.
                     On exit, it is overwritten with the value beta.

           <u>X</u>

                     X is REAL array, dimension
                                    (1+(N-2)*abs(INCX))
                     On entry, the vector x.
                     On exit, it is overwritten with the vector v.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>TAU</u>

                     TAU is REAL
                     The value tau.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slarfgp</b> <b>(integer</b> <b>N,</b> <b>real</b> <b>ALPHA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>real</b> <b>TAU)</b>
       <b>SLARFGP</b> generates an elementary reflector (Householder matrix) with non-negative beta.

       <b>Purpose:</b>

            SLARFGP generates a real elementary reflector H of order n, such
            that

                  H * ( alpha ) = ( beta ),   H**T * H = I.
                      (   x   )   (   0  )

            where alpha and beta are scalars, beta is non-negative, and x is
            an (n-1)-element real vector.  H is represented in the form

                  H = I - tau * ( 1 ) * ( 1 v**T ) ,
                                ( v )

            where tau is a real scalar and v is a real (n-1)-element
            vector.

            If the elements of x are all zero, then tau = 0 and H is taken to be
            the unit matrix.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the elementary reflector.

           <u>ALPHA</u>

                     ALPHA is REAL
                     On entry, the value alpha.
                     On exit, it is overwritten with the value beta.

           <u>X</u>

                     X is REAL array, dimension
                                    (1+(N-2)*abs(INCX))
                     On entry, the vector x.
                     On exit, it is overwritten with the vector v.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>TAU</u>

                     TAU is REAL
                     The value tau.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slarft</b> <b>(character</b> <b>DIRECT,</b> <b>character</b> <b>STOREV,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>real,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b>
       <b>integer</b> <b>LDV,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>real,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT)</b>
       <b>SLARFT</b> forms the triangular factor T of a block reflector H = I - vtvH

       <b>Purpose:</b>

            SLARFT forms the triangular factor T of a real block reflector H
            of order n, which is defined as a product of k elementary reflectors.

            If DIRECT = 'F', H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) and T is upper triangular;

            If DIRECT = 'B', H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) and T is lower triangular.

            If STOREV = 'C', the vector which defines the elementary reflector
            H(i) is stored in the i-th column of the array V, and

               H  =  I - V * T * V**T

            If STOREV = 'R', the vector which defines the elementary reflector
            H(i) is stored in the i-th row of the array V, and

               H  =  I - V**T * T * V

       <b>Parameters</b>
           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Specifies the order in which the elementary reflectors are
                     multiplied to form the block reflector:
                     = 'F': H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) (Forward)
                     = 'B': H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) (Backward)

           <u>STOREV</u>

                     STOREV is CHARACTER*1
                     Specifies how the vectors which define the elementary
                     reflectors are stored (see also Further Details):
                     = 'C': columnwise
                     = 'R': rowwise

           <u>N</u>

                     N is INTEGER
                     The order of the block reflector H. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The order of the triangular factor T (= the number of
                     elementary reflectors). K &gt;= 1.

           <u>V</u>

                     V is REAL array, dimension
                                          (LDV,K) if STOREV = 'C'
                                          (LDV,N) if STOREV = 'R'
                     The matrix V. See further details.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If STOREV = 'C', LDV &gt;= max(1,N); if STOREV = 'R', LDV &gt;= K.

           <u>TAU</u>

                     TAU is REAL array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i).

           <u>T</u>

                     T is REAL array, dimension (LDT,K)
                     The k by k triangular factor T of the block reflector.
                     If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
                     lower triangular. The rest of the array is not used.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= K.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The shape of the matrix V and the storage of the vectors which define
             the H(i) is best illustrated by the following example with n = 5 and
             k = 3. The elements equal to 1 are not stored.

             DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':

                          V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                              ( v1  1    )                     (     1 v2 v2 v2 )
                              ( v1 v2  1 )                     (        1 v3 v3 )
                              ( v1 v2 v3 )
                              ( v1 v2 v3 )

             DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':

                          V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                              ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                              (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                              (     1 v3 )
                              (        1 )

   <b>subroutine</b> <b>slarfx</b> <b>(character</b> <b>SIDE,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>real</b> <b>TAU,</b> <b>real,</b> <b>dimension(</b>
       <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>SLARFX</b> applies an elementary reflector to a general rectangular matrix, with loop unrolling when the
       reflector has order ≤ 10.

       <b>Purpose:</b>

            SLARFX applies a real elementary reflector H to a real m by n
            matrix C, from either the left or the right. H is represented in the
            form

                  H = I - tau * v * v**T

            where tau is a real scalar and v is a real vector.

            If tau = 0, then H is taken to be the unit matrix

            This version uses inline code if H has order &lt; 11.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': form  H * C
                     = 'R': form  C * H

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C.

           <u>V</u>

                     V is REAL array, dimension (M) if SIDE = 'L'
                                                or (N) if SIDE = 'R'
                     The vector v in the representation of H.

           <u>TAU</u>

                     TAU is REAL
                     The value tau in the representation of H.

           <u>C</u>

                     C is REAL array, dimension (LDC,N)
                     On entry, the m by n matrix C.
                     On exit, C is overwritten by the matrix H * C if SIDE = 'L',
                     or C * H if SIDE = 'R'.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= (1,M).

           <u>WORK</u>

                     WORK is REAL array, dimension
                                 (N) if SIDE = 'L'
                                 or (M) if SIDE = 'R'
                     WORK is not referenced if H has order &lt; 11.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slarfy</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>INCV,</b> <b>real</b> <b>TAU,</b> <b>real,</b>
       <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>SLARFY</b>

       <b>Purpose:</b>

            SLARFY applies an elementary reflector, or Householder matrix, H,
            to an n x n symmetric matrix C, from both the left and the right.

            H is represented in the form

               H = I - tau * v * v'

            where  tau  is a scalar and  v  is a vector.

            If  tau  is  zero, then  H  is taken to be the unit matrix.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix C is stored.
                     = 'U':  Upper triangle
                     = 'L':  Lower triangle

           <u>N</u>

                     N is INTEGER
                     The number of rows and columns of the matrix C.  N &gt;= 0.

           <u>V</u>

                     V is REAL array, dimension
                             (1 + (N-1)*abs(INCV))
                     The vector v as described above.

           <u>INCV</u>

                     INCV is INTEGER
                     The increment between successive elements of v.  INCV must
                     not be zero.

           <u>TAU</u>

                     TAU is REAL
                     The value tau as described above.

           <u>C</u>

                     C is REAL array, dimension (LDC, N)
                     On entry, the matrix C.
                     On exit, C is overwritten by H * C * H'.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C.  LDC &gt;= max( 1, N ).

           <u>WORK</u>

                     WORK is REAL array, dimension (N)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slargv</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>INCY,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>INCC)</b>
       <b>SLARGV</b> generates a vector of plane rotations with real cosines and real sines.

       <b>Purpose:</b>

            SLARGV generates a vector of real plane rotations, determined by
            elements of the real vectors x and y. For i = 1,2,...,n

               (  c(i)  s(i) ) ( x(i) ) = ( a(i) )
               ( -s(i)  c(i) ) ( y(i) ) = (   0  )

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of plane rotations to be generated.

           <u>X</u>

                     X is REAL array,
                                    dimension (1+(N-1)*INCX)
                     On entry, the vector x.
                     On exit, x(i) is overwritten by a(i), for i = 1,...,n.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>Y</u>

                     Y is REAL array,
                                    dimension (1+(N-1)*INCY)
                     On entry, the vector y.
                     On exit, the sines of the plane rotations.

           <u>INCY</u>

                     INCY is INTEGER
                     The increment between elements of Y. INCY &gt; 0.

           <u>C</u>

                     C is REAL array, dimension (1+(N-1)*INCC)
                     The cosines of the plane rotations.

           <u>INCC</u>

                     INCC is INTEGER
                     The increment between elements of C. INCC &gt; 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slarrv</b> <b>(integer</b> <b>N,</b> <b>real</b> <b>VL,</b> <b>real</b> <b>VU,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>L,</b> <b>real</b> <b>PIVMIN,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISPLIT,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>DOL,</b> <b>integer</b> <b>DOU,</b> <b>real</b> <b>MINRGP,</b> <b>real</b> <b>RTOL1,</b> <b>real</b> <b>RTOL2,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WERR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WGAP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>IBLOCK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDEXW,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>GERS,</b> <b>real,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b>
       <b>LDZ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISUPPZ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b>
       <b>INFO)</b>
       <b>SLARRV</b> computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues of L
       D LT.

       <b>Purpose:</b>

            SLARRV computes the eigenvectors of the tridiagonal matrix
            T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
            The input eigenvalues should have been computed by SLARRE.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix.  N &gt;= 0.

           <u>VL</u>

                     VL is REAL
                     Lower bound of the interval that contains the desired
                     eigenvalues. VL &lt; VU. Needed to compute gaps on the left or right
                     end of the extremal eigenvalues in the desired RANGE.

           <u>VU</u>

                     VU is REAL
                     Upper bound of the interval that contains the desired
                     eigenvalues. VL &lt; VU.
                     Note: VU is currently not used by this implementation of SLARRV, VU is
                     passed to SLARRV because it could be used compute gaps on the right end
                     of the extremal eigenvalues. However, with not much initial accuracy in
                     LAMBDA and VU, the formula can lead to an overestimation of the right gap
                     and thus to inadequately early RQI 'convergence'. This is currently
                     prevented this by forcing a small right gap. And so it turns out that VU
                     is currently not used by this implementation of SLARRV.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the N diagonal elements of the diagonal matrix D.
                     On exit, D may be overwritten.

           <u>L</u>

                     L is REAL array, dimension (N)
                     On entry, the (N-1) subdiagonal elements of the unit
                     bidiagonal matrix L are in elements 1 to N-1 of L
                     (if the matrix is not split.) At the end of each block
                     is stored the corresponding shift as given by SLARRE.
                     On exit, L is overwritten.

           <u>PIVMIN</u>

                     PIVMIN is REAL
                     The minimum pivot allowed in the Sturm sequence.

           <u>ISPLIT</u>

                     ISPLIT is INTEGER array, dimension (N)
                     The splitting points, at which T breaks up into blocks.
                     The first block consists of rows/columns 1 to
                     ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
                     through ISPLIT( 2 ), etc.

           <u>M</u>

                     M is INTEGER
                     The total number of input eigenvalues.  0 &lt;= M &lt;= N.

           <u>DOL</u>

                     DOL is INTEGER

           <u>DOU</u>

                     DOU is INTEGER
                     If the user wants to compute only selected eigenvectors from all
                     the eigenvalues supplied, he can specify an index range DOL:DOU.
                     Or else the setting DOL=1, DOU=M should be applied.
                     Note that DOL and DOU refer to the order in which the eigenvalues
                     are stored in W.
                     If the user wants to compute only selected eigenpairs, then
                     the columns DOL-1 to DOU+1 of the eigenvector space Z contain the
                     computed eigenvectors. All other columns of Z are set to zero.

           <u>MINRGP</u>

                     MINRGP is REAL

           <u>RTOL1</u>

                     RTOL1 is REAL

           <u>RTOL2</u>

                     RTOL2 is REAL
                      Parameters for bisection.
                      An interval [LEFT,RIGHT] has converged if
                      RIGHT-LEFT &lt; MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )

           <u>W</u>

                     W is REAL array, dimension (N)
                     The first M elements of W contain the APPROXIMATE eigenvalues for
                     which eigenvectors are to be computed.  The eigenvalues
                     should be grouped by split-off block and ordered from
                     smallest to largest within the block ( The output array
                     W from SLARRE is expected here ). Furthermore, they are with
                     respect to the shift of the corresponding root representation
                     for their block. On exit, W holds the eigenvalues of the
                     UNshifted matrix.

           <u>WERR</u>

                     WERR is REAL array, dimension (N)
                     The first M elements contain the semiwidth of the uncertainty
                     interval of the corresponding eigenvalue in W

           <u>WGAP</u>

                     WGAP is REAL array, dimension (N)
                     The separation from the right neighbor eigenvalue in W.

           <u>IBLOCK</u>

                     IBLOCK is INTEGER array, dimension (N)
                     The indices of the blocks (submatrices) associated with the
                     corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue
                     W(i) belongs to the first block from the top, =2 if W(i)
                     belongs to the second block, etc.

           <u>INDEXW</u>

                     INDEXW is INTEGER array, dimension (N)
                     The indices of the eigenvalues within each block (submatrix);
                     for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the
                     i-th eigenvalue W(i) is the 10-th eigenvalue in the second block.

           <u>GERS</u>

                     GERS is REAL array, dimension (2*N)
                     The N Gerschgorin intervals (the i-th Gerschgorin interval
                     is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should
                     be computed from the original UNshifted matrix.

           <u>Z</u>

                     Z is REAL array, dimension (LDZ, max(1,M) )
                     If INFO = 0, the first M columns of Z contain the
                     orthonormal eigenvectors of the matrix T
                     corresponding to the input eigenvalues, with the i-th
                     column of Z holding the eigenvector associated with W(i).
                     Note: the user must ensure that at least max(1,M) columns are
                     supplied in the array Z.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     JOBZ = 'V', LDZ &gt;= max(1,N).

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
                     The support of the eigenvectors in Z, i.e., the indices
                     indicating the nonzero elements in Z. The I-th eigenvector
                     is nonzero only in elements ISUPPZ( 2*I-1 ) through
                     ISUPPZ( 2*I ).

           <u>WORK</u>

                     WORK is REAL array, dimension (12*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (7*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit

                     &gt; 0:  A problem occurred in SLARRV.
                     &lt; 0:  One of the called subroutines signaled an internal problem.
                           Needs inspection of the corresponding parameter IINFO
                           for further information.

                     =-1:  Problem in SLARRB when refining a child's eigenvalues.
                     =-2:  Problem in SLARRF when computing the RRR of a child.
                           When a child is inside a tight cluster, it can be difficult
                           to find an RRR. A partial remedy from the user's point of
                           view is to make the parameter MINRGP smaller and recompile.
                           However, as the orthogonality of the computed vectors is
                           proportional to 1/MINRGP, the user should be aware that
                           he might be trading in precision when he decreases MINRGP.
                     =-3:  Problem in SLARRB when refining a single eigenvalue
                           after the Rayleigh correction was rejected.
                     = 5:  The Rayleigh Quotient Iteration failed to converge to
                           full accuracy in MAXITR steps.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Beresford Parlett, University of California, Berkeley, USA
            Jim Demmel, University of California, Berkeley, USA
            Inderjit Dhillon, University of Texas, Austin, USA
            Osni Marques, LBNL/NERSC, USA
            Christof Voemel, University of California, Berkeley, USA

   <b>subroutine</b> <b>slartv</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>INCY,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>integer</b> <b>INCC)</b>
       <b>SLARTV</b> applies a vector of plane rotations with real cosines and real sines to the elements of a pair of
       vectors.

       <b>Purpose:</b>

            SLARTV applies a vector of real plane rotations to elements of the
            real vectors x and y. For i = 1,2,...,n

               ( x(i) ) := (  c(i)  s(i) ) ( x(i) )
               ( y(i) )    ( -s(i)  c(i) ) ( y(i) )

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of plane rotations to be applied.

           <u>X</u>

                     X is REAL array,
                                    dimension (1+(N-1)*INCX)
                     The vector x.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>Y</u>

                     Y is REAL array,
                                    dimension (1+(N-1)*INCY)
                     The vector y.

           <u>INCY</u>

                     INCY is INTEGER
                     The increment between elements of Y. INCY &gt; 0.

           <u>C</u>

                     C is REAL array, dimension (1+(N-1)*INCC)
                     The cosines of the plane rotations.

           <u>S</u>

                     S is REAL array, dimension (1+(N-1)*INCC)
                     The sines of the plane rotations.

           <u>INCC</u>

                     INCC is INTEGER
                     The increment between elements of C and S. INCC &gt; 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slaswp</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b> <b>K1,</b> <b>integer</b> <b>K2,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>integer</b> <b>INCX)</b>
       <b>SLASWP</b> performs a series of row interchanges on a general rectangular matrix.

       <b>Purpose:</b>

            SLASWP performs a series of row interchanges on the matrix A.
            One row interchange is initiated for each of rows K1 through K2 of A.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     On entry, the matrix of column dimension N to which the row
                     interchanges will be applied.
                     On exit, the permuted matrix.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.

           <u>K1</u>

                     K1 is INTEGER
                     The first element of IPIV for which a row interchange will
                     be done.

           <u>K2</u>

                     K2 is INTEGER
                     (K2-K1+1) is the number of elements of IPIV for which a row
                     interchange will be done.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (K1+(K2-K1)*abs(INCX))
                     The vector of pivot indices. Only the elements in positions
                     K1 through K1+(K2-K1)*abs(INCX) of IPIV are accessed.
                     IPIV(K1+(K-K1)*abs(INCX)) = L implies rows K and L are to be
                     interchanged.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between successive values of IPIV. If INCX
                     is negative, the pivots are applied in reverse order.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Modified by
              R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA

   <b>subroutine</b> <b>slatbs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>character</b> <b>NORMIN,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b>
       <b>real,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>real</b> <b>SCALE,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>CNORM,</b> <b>integer</b> <b>INFO)</b>
       <b>SLATBS</b> solves a triangular banded system of equations.

       <b>Purpose:</b>

            SLATBS solves one of the triangular systems

               A *x = s*b  or  A**T*x = s*b

            with scaling to prevent overflow, where A is an upper or lower
            triangular band matrix.  Here A**T denotes the transpose of A, x and b
            are n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine STBSV is called.  If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  Solve A * x = s*b  (No transpose)
                     = 'T':  Solve A**T* x = s*b  (Transpose)
                     = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>NORMIN</u>

                     NORMIN is CHARACTER*1
                     Specifies whether CNORM has been set or not.
                     = 'Y':  CNORM contains the column norms on entry
                     = 'N':  CNORM is not set on entry.  On exit, the norms will
                             be computed and stored in CNORM.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of subdiagonals or superdiagonals in the
                     triangular matrix A.  KD &gt;= 0.

           <u>AB</u>

                     AB is REAL array, dimension (LDAB,N)
                     The upper or lower triangular band matrix A, stored in the
                     first KD+1 rows of the array. The j-th column of A is stored
                     in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>X</u>

                     X is REAL array, dimension (N)
                     On entry, the right hand side b of the triangular system.
                     On exit, X is overwritten by the solution vector x.

           <u>SCALE</u>

                     SCALE is REAL
                     The scaling factor s for the triangular system
                        A * x = s*b  or  A**T* x = s*b.
                     If SCALE = 0, the matrix A is singular or badly scaled, and
                     the vector x is an exact or approximate solution to A*x = 0.

           <u>CNORM</u>

                     CNORM is REAL array, dimension (N)

                     If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
                     contains the norm of the off-diagonal part of the j-th column
                     of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
                     to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
                     must be greater than or equal to the 1-norm.

                     If NORMIN = 'N', CNORM is an output argument and CNORM(j)
                     returns the 1-norm of the offdiagonal part of the j-th column
                     of A.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             A rough bound on x is computed; if that is less than overflow, STBSV
             is called, otherwise, specific code is used which checks for possible
             overflow or divide-by-zero at every operation.

             A columnwise scheme is used for solving A*x = b.  The basic algorithm
             if A is lower triangular is

                  x[1:n] := b[1:n]
                  for j = 1, ..., n
                       x(j) := x(j) / A(j,j)
                       x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                  end

             Define bounds on the components of x after j iterations of the loop:
                M(j) = bound on x[1:j]
                G(j) = bound on x[j+1:n]
             Initially, let <a href="../man0/M.0.html">M</a>(0) = 0 and <a href="../man0/G.0.html">G</a>(0) = max{x(i), i=1,...,n}.

             Then for iteration j+1 we have
                M(j+1) &lt;= G(j) / | A(j+1,j+1) |
                G(j+1) &lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                       &lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

             where CNORM(j+1) is greater than or equal to the infinity-norm of
             column j+1 of A, not counting the diagonal.  Hence

                G(j) &lt;= <a href="../man0/G.0.html">G</a>(0) product ( 1 + CNORM(i) / | A(i,i) | )
                             1&lt;=i&lt;=j
             and

                |x(j)| &lt;= ( <a href="../man0/G.0.html">G</a>(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                              1&lt;=i&lt; j

             Since |x(j)| &lt;= M(j), we use the Level 2 BLAS routine STBSV if the
             reciprocal of the largest M(j), j=1,..,n, is larger than
             max(underflow, 1/overflow).

             The bound on x(j) is also used to determine when a step in the
             columnwise method can be performed without fear of overflow.  If
             the computed bound is greater than a large constant, x is scaled to
             prevent overflow, but if the bound overflows, x is set to 0, x(j) to
             1, and scale to 0, and a non-trivial solution to A*x = 0 is found.

             Similarly, a row-wise scheme is used to solve A**T*x = b.  The basic
             algorithm for A upper triangular is

                  for j = 1, ..., n
                       x(j) := ( b(j) - A[1:j-1,j]**T * x[1:j-1] ) / A(j,j)
                  end

             We simultaneously compute two bounds
                  G(j) = bound on ( b(i) - A[1:i-1,i]**T * x[1:i-1] ), 1&lt;=i&lt;=j
                  M(j) = bound on x(i), 1&lt;=i&lt;=j

             The initial values are <a href="../man0/G.0.html">G</a>(0) = 0, <a href="../man0/M.0.html">M</a>(0) = max{b(i), i=1,..,n}, and we
             add the constraint G(j) &gt;= G(j-1) and M(j) &gt;= M(j-1) for j &gt;= 1.
             Then the bound on x(j) is

                  M(j) &lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |

                       &lt;= <a href="../man0/M.0.html">M</a>(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                 1&lt;=i&lt;=j

             and we can safely call STBSV if 1/M(n) and 1/G(n) are both greater
             than max(underflow, 1/overflow).

   <b>subroutine</b> <b>slatdf</b> <b>(integer</b> <b>IJOB,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>RHS,</b> <b>real</b> <b>RDSUM,</b> <b>real</b> <b>RDSCAL,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>JPIV)</b>
       <b>SLATDF</b> uses the LU factorization of the n-by-n matrix computed by sgetc2 and computes a contribution to
       the reciprocal Dif-estimate.

       <b>Purpose:</b>

            SLATDF uses the LU factorization of the n-by-n matrix Z computed by
            SGETC2 and computes a contribution to the reciprocal Dif-estimate
            by solving Z * x = b for x, and choosing the r.h.s. b such that
            the norm of x is as large as possible. On entry RHS = b holds the
            contribution from earlier solved sub-systems, and on return RHS = x.

            The factorization of Z returned by SGETC2 has the form Z = P*L*U*Q,
            where P and Q are permutation matrices. L is lower triangular with
            unit diagonal elements and U is upper triangular.

       <b>Parameters</b>
           <u>IJOB</u>

                     IJOB is INTEGER
                     IJOB = 2: First compute an approximative null-vector e
                         of Z using SGECON, e is normalized and solve for
                         Zx = +-e - f with the sign giving the greater value
                         of 2-norm(x). About 5 times as expensive as Default.
                     IJOB .ne. 2: Local look ahead strategy where all entries of
                         the r.h.s. b is chosen as either +1 or -1 (Default).

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Z.

           <u>Z</u>

                     Z is REAL array, dimension (LDZ, N)
                     On entry, the LU part of the factorization of the n-by-n
                     matrix Z computed by SGETC2:  Z = P * L * U * Q

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDA &gt;= max(1, N).

           <u>RHS</u>

                     RHS is REAL array, dimension N.
                     On entry, RHS contains contributions from other subsystems.
                     On exit, RHS contains the solution of the subsystem with
                     entries according to the value of IJOB (see above).

           <u>RDSUM</u>

                     RDSUM is REAL
                     On entry, the sum of squares of computed contributions to
                     the Dif-estimate under computation by STGSYL, where the
                     scaling factor RDSCAL (see below) has been factored out.
                     On exit, the corresponding sum of squares updated with the
                     contributions from the current sub-system.
                     If TRANS = 'T' RDSUM is not touched.
                     NOTE: RDSUM only makes sense when STGSY2 is called by STGSYL.

           <u>RDSCAL</u>

                     RDSCAL is REAL
                     On entry, scaling factor used to prevent overflow in RDSUM.
                     On exit, RDSCAL is updated w.r.t. the current contributions
                     in RDSUM.
                     If TRANS = 'T', RDSCAL is not touched.
                     NOTE: RDSCAL only makes sense when STGSY2 is called by
                           STGSYL.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N).
                     The pivot indices; for 1 &lt;= i &lt;= N, row i of the
                     matrix has been interchanged with row IPIV(i).

           <u>JPIV</u>

                     JPIV is INTEGER array, dimension (N).
                     The pivot indices; for 1 &lt;= j &lt;= N, column j of the
                     matrix has been interchanged with column JPIV(j).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>
           This routine is a further developed implementation of algorithm BSOLVE in [1] using complete pivoting
           in the LU factorization.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

       <b>References:</b>

             [1] Bo Kagstrom and Lars Westin,
                 Generalized Schur Methods with Condition Estimators for
                 Solving the Generalized Sylvester Equation, IEEE Transactions
                 on Automatic Control, Vol. 34, No. 7, July 1989, pp 745-751.

             [2] Peter Poromaa,
                 On Efficient and Robust Estimators for the Separation
                 between two Regular Matrix Pairs with Applications in
                 Condition Estimation. Report IMINF-95.05, Departement of
                 Computing Science, Umea University, S-901 87 Umea, Sweden, 1995.

   <b>subroutine</b> <b>slatps</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>character</b> <b>NORMIN,</b> <b>integer</b> <b>N,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>real</b> <b>SCALE,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CNORM,</b> <b>integer</b> <b>INFO)</b>
       <b>SLATPS</b> solves a triangular system of equations with the matrix held in packed storage.

       <b>Purpose:</b>

            SLATPS solves one of the triangular systems

               A *x = s*b  or  A**T*x = s*b

            with scaling to prevent overflow, where A is an upper or lower
            triangular matrix stored in packed form.  Here A**T denotes the
            transpose of A, x and b are n-element vectors, and s is a scaling
            factor, usually less than or equal to 1, chosen so that the
            components of x will be less than the overflow threshold.  If the
            unscaled problem will not cause overflow, the Level 2 BLAS routine
            STPSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
            then s is set to 0 and a non-trivial solution to A*x = 0 is returned.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  Solve A * x = s*b  (No transpose)
                     = 'T':  Solve A**T* x = s*b  (Transpose)
                     = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>NORMIN</u>

                     NORMIN is CHARACTER*1
                     Specifies whether CNORM has been set or not.
                     = 'Y':  CNORM contains the column norms on entry
                     = 'N':  CNORM is not set on entry.  On exit, the norms will
                             be computed and stored in CNORM.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is REAL array, dimension (N*(N+1)/2)
                     The upper or lower triangular matrix A, packed columnwise in
                     a linear array.  The j-th column of A is stored in the array
                     AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>X</u>

                     X is REAL array, dimension (N)
                     On entry, the right hand side b of the triangular system.
                     On exit, X is overwritten by the solution vector x.

           <u>SCALE</u>

                     SCALE is REAL
                     The scaling factor s for the triangular system
                        A * x = s*b  or  A**T* x = s*b.
                     If SCALE = 0, the matrix A is singular or badly scaled, and
                     the vector x is an exact or approximate solution to A*x = 0.

           <u>CNORM</u>

                     CNORM is REAL array, dimension (N)

                     If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
                     contains the norm of the off-diagonal part of the j-th column
                     of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
                     to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
                     must be greater than or equal to the 1-norm.

                     If NORMIN = 'N', CNORM is an output argument and CNORM(j)
                     returns the 1-norm of the offdiagonal part of the j-th column
                     of A.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             A rough bound on x is computed; if that is less than overflow, STPSV
             is called, otherwise, specific code is used which checks for possible
             overflow or divide-by-zero at every operation.

             A columnwise scheme is used for solving A*x = b.  The basic algorithm
             if A is lower triangular is

                  x[1:n] := b[1:n]
                  for j = 1, ..., n
                       x(j) := x(j) / A(j,j)
                       x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                  end

             Define bounds on the components of x after j iterations of the loop:
                M(j) = bound on x[1:j]
                G(j) = bound on x[j+1:n]
             Initially, let <a href="../man0/M.0.html">M</a>(0) = 0 and <a href="../man0/G.0.html">G</a>(0) = max{x(i), i=1,...,n}.

             Then for iteration j+1 we have
                M(j+1) &lt;= G(j) / | A(j+1,j+1) |
                G(j+1) &lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                       &lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

             where CNORM(j+1) is greater than or equal to the infinity-norm of
             column j+1 of A, not counting the diagonal.  Hence

                G(j) &lt;= <a href="../man0/G.0.html">G</a>(0) product ( 1 + CNORM(i) / | A(i,i) | )
                             1&lt;=i&lt;=j
             and

                |x(j)| &lt;= ( <a href="../man0/G.0.html">G</a>(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                              1&lt;=i&lt; j

             Since |x(j)| &lt;= M(j), we use the Level 2 BLAS routine STPSV if the
             reciprocal of the largest M(j), j=1,..,n, is larger than
             max(underflow, 1/overflow).

             The bound on x(j) is also used to determine when a step in the
             columnwise method can be performed without fear of overflow.  If
             the computed bound is greater than a large constant, x is scaled to
             prevent overflow, but if the bound overflows, x is set to 0, x(j) to
             1, and scale to 0, and a non-trivial solution to A*x = 0 is found.

             Similarly, a row-wise scheme is used to solve A**T*x = b.  The basic
             algorithm for A upper triangular is

                  for j = 1, ..., n
                       x(j) := ( b(j) - A[1:j-1,j]**T * x[1:j-1] ) / A(j,j)
                  end

             We simultaneously compute two bounds
                  G(j) = bound on ( b(i) - A[1:i-1,i]**T * x[1:i-1] ), 1&lt;=i&lt;=j
                  M(j) = bound on x(i), 1&lt;=i&lt;=j

             The initial values are <a href="../man0/G.0.html">G</a>(0) = 0, <a href="../man0/M.0.html">M</a>(0) = max{b(i), i=1,..,n}, and we
             add the constraint G(j) &gt;= G(j-1) and M(j) &gt;= M(j-1) for j &gt;= 1.
             Then the bound on x(j) is

                  M(j) &lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |

                       &lt;= <a href="../man0/M.0.html">M</a>(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                 1&lt;=i&lt;=j

             and we can safely call STPSV if 1/M(n) and 1/G(n) are both greater
             than max(underflow, 1/overflow).

   <b>subroutine</b> <b>slatrs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>character</b> <b>NORMIN,</b> <b>integer</b> <b>N,</b> <b>real,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>real</b> <b>SCALE,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CNORM,</b>
       <b>integer</b> <b>INFO)</b>
       <b>SLATRS</b> solves a triangular system of equations with the scale factor set to prevent overflow.

       <b>Purpose:</b>

            SLATRS solves one of the triangular systems

               A *x = s*b  or  A**T*x = s*b

            with scaling to prevent overflow.  Here A is an upper or lower
            triangular matrix, A**T denotes the transpose of A, x and b are
            n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine STRSV is called.  If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  Solve A * x = s*b  (No transpose)
                     = 'T':  Solve A**T* x = s*b  (Transpose)
                     = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>NORMIN</u>

                     NORMIN is CHARACTER*1
                     Specifies whether CNORM has been set or not.
                     = 'Y':  CNORM contains the column norms on entry
                     = 'N':  CNORM is not set on entry.  On exit, the norms will
                             be computed and stored in CNORM.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     The triangular matrix A.  If UPLO = 'U', the leading n by n
                     upper triangular part of the array A contains the upper
                     triangular matrix, and the strictly lower triangular part of
                     A is not referenced.  If UPLO = 'L', the leading n by n lower
                     triangular part of the array A contains the lower triangular
                     matrix, and the strictly upper triangular part of A is not
                     referenced.  If DIAG = 'U', the diagonal elements of A are
                     also not referenced and are assumed to be 1.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max (1,N).

           <u>X</u>

                     X is REAL array, dimension (N)
                     On entry, the right hand side b of the triangular system.
                     On exit, X is overwritten by the solution vector x.

           <u>SCALE</u>

                     SCALE is REAL
                     The scaling factor s for the triangular system
                        A * x = s*b  or  A**T* x = s*b.
                     If SCALE = 0, the matrix A is singular or badly scaled, and
                     the vector x is an exact or approximate solution to A*x = 0.

           <u>CNORM</u>

                     CNORM is REAL array, dimension (N)

                     If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
                     contains the norm of the off-diagonal part of the j-th column
                     of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
                     to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
                     must be greater than or equal to the 1-norm.

                     If NORMIN = 'N', CNORM is an output argument and CNORM(j)
                     returns the 1-norm of the offdiagonal part of the j-th column
                     of A.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             A rough bound on x is computed; if that is less than overflow, STRSV
             is called, otherwise, specific code is used which checks for possible
             overflow or divide-by-zero at every operation.

             A columnwise scheme is used for solving A*x = b.  The basic algorithm
             if A is lower triangular is

                  x[1:n] := b[1:n]
                  for j = 1, ..., n
                       x(j) := x(j) / A(j,j)
                       x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                  end

             Define bounds on the components of x after j iterations of the loop:
                M(j) = bound on x[1:j]
                G(j) = bound on x[j+1:n]
             Initially, let <a href="../man0/M.0.html">M</a>(0) = 0 and <a href="../man0/G.0.html">G</a>(0) = max{x(i), i=1,...,n}.

             Then for iteration j+1 we have
                M(j+1) &lt;= G(j) / | A(j+1,j+1) |
                G(j+1) &lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                       &lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

             where CNORM(j+1) is greater than or equal to the infinity-norm of
             column j+1 of A, not counting the diagonal.  Hence

                G(j) &lt;= <a href="../man0/G.0.html">G</a>(0) product ( 1 + CNORM(i) / | A(i,i) | )
                             1&lt;=i&lt;=j
             and

                |x(j)| &lt;= ( <a href="../man0/G.0.html">G</a>(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                              1&lt;=i&lt; j

             Since |x(j)| &lt;= M(j), we use the Level 2 BLAS routine STRSV if the
             reciprocal of the largest M(j), j=1,..,n, is larger than
             max(underflow, 1/overflow).

             The bound on x(j) is also used to determine when a step in the
             columnwise method can be performed without fear of overflow.  If
             the computed bound is greater than a large constant, x is scaled to
             prevent overflow, but if the bound overflows, x is set to 0, x(j) to
             1, and scale to 0, and a non-trivial solution to A*x = 0 is found.

             Similarly, a row-wise scheme is used to solve A**T*x = b.  The basic
             algorithm for A upper triangular is

                  for j = 1, ..., n
                       x(j) := ( b(j) - A[1:j-1,j]**T * x[1:j-1] ) / A(j,j)
                  end

             We simultaneously compute two bounds
                  G(j) = bound on ( b(i) - A[1:i-1,i]**T * x[1:i-1] ), 1&lt;=i&lt;=j
                  M(j) = bound on x(i), 1&lt;=i&lt;=j

             The initial values are <a href="../man0/G.0.html">G</a>(0) = 0, <a href="../man0/M.0.html">M</a>(0) = max{b(i), i=1,..,n}, and we
             add the constraint G(j) &gt;= G(j-1) and M(j) &gt;= M(j-1) for j &gt;= 1.
             Then the bound on x(j) is

                  M(j) &lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |

                       &lt;= <a href="../man0/M.0.html">M</a>(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                 1&lt;=i&lt;=j

             and we can safely call STRSV if 1/M(n) and 1/G(n) are both greater
             than max(underflow, 1/overflow).

   <b>subroutine</b> <b>slauu2</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAUU2</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices (unblocked
       algorithm).

       <b>Purpose:</b>

            SLAUU2 computes the product U * U**T or L**T * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.

            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.

            This is the unblocked form of the algorithm, calling Level 2 BLAS.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the triangular factor stored in the array A
                     is upper or lower triangular:
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the triangular factor U or L.  N &gt;= 0.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     On entry, the triangular factor U or L.
                     On exit, if UPLO = 'U', the upper triangle of A is
                     overwritten with the upper triangle of the product U * U**T;
                     if UPLO = 'L', the lower triangle of A is overwritten with
                     the lower triangle of the product L**T * L.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slauum</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAUUM</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices (blocked
       algorithm).

       <b>Purpose:</b>

            SLAUUM computes the product U * U**T or L**T * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.

            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.

            This is the blocked form of the algorithm, calling Level 3 BLAS.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the triangular factor stored in the array A
                     is upper or lower triangular:
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the triangular factor U or L.  N &gt;= 0.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     On entry, the triangular factor U or L.
                     On exit, if UPLO = 'U', the upper triangle of A is
                     overwritten with the upper triangle of the product U * U**T;
                     if UPLO = 'L', the lower triangle of A is overwritten with
                     the lower triangle of the product L**T * L.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>srscl</b> <b>(integer</b> <b>N,</b> <b>real</b> <b>SA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SX,</b> <b>integer</b> <b>INCX)</b>
       <b>SRSCL</b> multiplies a vector by the reciprocal of a real scalar.

       <b>Purpose:</b>

            SRSCL multiplies an n-element real vector x by the real scalar 1/a.
            This is done without overflow or underflow as long as
            the final result x/a does not overflow or underflow.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of components of the vector x.

           <u>SA</u>

                     SA is REAL
                     The scalar a which is used to divide each component of x.
                     SA must be &gt;= 0, or the subroutine will divide by zero.

           <u>SX</u>

                     SX is REAL array, dimension
                                    (1+(N-1)*abs(INCX))
                     The n-element vector x.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between successive values of the vector SX.
                     &gt; 0:  <a href="../man1/SX.1.html">SX</a>(1) = <a href="../man1/X.1.html">X</a>(1) and SX(1+(i-1)*INCX) = x(i),     1&lt; i&lt;= n

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>stprfb</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIRECT,</b> <b>character</b> <b>STOREV,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b>
       <b>integer</b> <b>K,</b> <b>integer</b> <b>L,</b> <b>real,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>real,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b>
       <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>real,</b> <b>dimension(</b>
       <b>ldwork,</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LDWORK)</b>
       <b>STPRFB</b> applies a real or complex 'triangular-pentagonal' blocked reflector to a real or complex matrix,
       which is composed of two blocks.

       <b>Purpose:</b>

            STPRFB applies a real "triangular-pentagonal" block reflector H or its
            conjugate transpose H^H to a real matrix C, which is composed of two
            blocks A and B, either from the left or right.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply H or H^H from the Left
                     = 'R': apply H or H^H from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply H (No transpose)
                     = 'C': apply H^H (Conjugate transpose)

           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Indicates how H is formed from a product of elementary
                     reflectors
                     = 'F': H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) (Forward)
                     = 'B': H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) (Backward)

           <u>STOREV</u>

                     STOREV is CHARACTER*1
                     Indicates how the vectors which define the elementary
                     reflectors are stored:
                     = 'C': Columns
                     = 'R': Rows

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix B.
                     M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix B.
                     N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The order of the matrix T, i.e. the number of elementary
                     reflectors whose product defines the block reflector.
                     K &gt;= 0.

           <u>L</u>

                     L is INTEGER
                     The order of the trapezoidal part of V.
                     K &gt;= L &gt;= 0.  See Further Details.

           <u>V</u>

                     V is REAL array, dimension
                                           (LDV,K) if STOREV = 'C'
                                           (LDV,M) if STOREV = 'R' and SIDE = 'L'
                                           (LDV,N) if STOREV = 'R' and SIDE = 'R'
                     The pentagonal matrix V, which contains the elementary reflectors
                     <a href="../man1/H.1.html">H</a>(1), <a href="../man2/H.2.html">H</a>(2), ..., H(K).  See Further Details.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If STOREV = 'C' and SIDE = 'L', LDV &gt;= max(1,M);
                     if STOREV = 'C' and SIDE = 'R', LDV &gt;= max(1,N);
                     if STOREV = 'R', LDV &gt;= K.

           <u>T</u>

                     T is REAL array, dimension (LDT,K)
                     The triangular K-by-K matrix T in the representation of the
                     block reflector.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.
                     LDT &gt;= K.

           <u>A</u>

                     A is REAL array, dimension
                     (LDA,N) if SIDE = 'L' or (LDA,K) if SIDE = 'R'
                     On entry, the K-by-N or M-by-K matrix A.
                     On exit, A is overwritten by the corresponding block of
                     H*C or H^H*C or C*H or C*H^H.  See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDA &gt;= max(1,K);
                     If SIDE = 'R', LDA &gt;= max(1,M).

           <u>B</u>

                     B is REAL array, dimension (LDB,N)
                     On entry, the M-by-N matrix B.
                     On exit, B is overwritten by the corresponding block of
                     H*C or H^H*C or C*H or C*H^H.  See Further Details.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.
                     LDB &gt;= max(1,M).

           <u>WORK</u>

                     WORK is REAL array, dimension
                     (LDWORK,N) if SIDE = 'L',
                     (LDWORK,K) if SIDE = 'R'.

           <u>LDWORK</u>

                     LDWORK is INTEGER
                     The leading dimension of the array WORK.
                     If SIDE = 'L', LDWORK &gt;= K;
                     if SIDE = 'R', LDWORK &gt;= M.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The matrix C is a composite matrix formed from blocks A and B.
             The block B is of size M-by-N; if SIDE = 'R', A is of size M-by-K,
             and if SIDE = 'L', A is of size K-by-N.

             If SIDE = 'R' and DIRECT = 'F', C = [A B].

             If SIDE = 'L' and DIRECT = 'F', C = [A]
                                                 [B].

             If SIDE = 'R' and DIRECT = 'B', C = [B A].

             If SIDE = 'L' and DIRECT = 'B', C = [B]
                                                 [A].

             The pentagonal matrix V is composed of a rectangular block V1 and a
             trapezoidal block V2.  The size of the trapezoidal block is determined by
             the parameter L, where 0&lt;=L&lt;=K.  If L=K, the V2 block of V is triangular;
             if L=0, there is no trapezoidal block, thus V = V1 is rectangular.

             If DIRECT = 'F' and STOREV = 'C':  V = [V1]
                                                    [V2]
                - V2 is upper trapezoidal (first L rows of K-by-K upper triangular)

             If DIRECT = 'F' and STOREV = 'R':  V = [V1 V2]

                - V2 is lower trapezoidal (first L columns of K-by-K lower triangular)

             If DIRECT = 'B' and STOREV = 'C':  V = [V2]
                                                    [V1]
                - V2 is lower trapezoidal (last L rows of K-by-K lower triangular)

             If DIRECT = 'B' and STOREV = 'R':  V = [V2 V1]

                - V2 is upper trapezoidal (last L columns of K-by-K upper triangular)

             If STOREV = 'C' and SIDE = 'L', V is M-by-K with V2 L-by-K.

             If STOREV = 'C' and SIDE = 'R', V is N-by-K with V2 L-by-K.

             If STOREV = 'R' and SIDE = 'L', V is K-by-M with V2 K-by-L.

             If STOREV = 'R' and SIDE = 'R', V is K-by-N with V2 K-by-L.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.10.0                                   Wed Jan 12 2022                           <u><a href="../man3/realOTHERauxiliary.3.html">realOTHERauxiliary</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>