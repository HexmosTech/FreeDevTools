<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unm22 - {un,or}m22: multiply by banded Q, step in gghd3</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unm22 - {un,or}m22: multiply by banded Q, step in gghd3

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>cunm22</b> (side, trans, m, n, n1, n2, q, ldq, c, ldc, work, lwork, info)
           <b>CUNM22</b> multiplies a general matrix by a banded unitary matrix.
       subroutine <b>dorm22</b> (side, trans, m, n, n1, n2, q, ldq, c, ldc, work, lwork, info)
           <b>DORM22</b> multiplies a general matrix by a banded orthogonal matrix.
       subroutine <b>sorm22</b> (side, trans, m, n, n1, n2, q, ldq, c, ldc, work, lwork, info)
           <b>SORM22</b> multiplies a general matrix by a banded orthogonal matrix.
       subroutine <b>zunm22</b> (side, trans, m, n, n1, n2, q, ldq, c, ldc, work, lwork, info)
           <b>ZUNM22</b> multiplies a general matrix by a banded unitary matrix.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>cunm22</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>n1,</b> <b>integer</b> <b>n2,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>q,</b> <b>integer</b> <b>ldq,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>CUNM22</b> multiplies a general matrix by a banded unitary matrix.

       <b>Purpose</b>

             CUNM22 overwrites the general complex M-by-N matrix C with

                             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'C':      Q**H * C       C * Q**H

             where Q is a complex unitary matrix of order NQ, with NQ = M if
             SIDE = 'L' and NQ = N if SIDE = 'R'.
             The unitary matrix Q processes a 2-by-2 block structure

                    [  Q11  Q12  ]
                Q = [            ]
                    [  Q21  Q22  ],

             where Q12 is an N1-by-N1 lower triangular matrix and Q21 is an
             N2-by-N2 upper triangular matrix.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  apply Q (No transpose);
                     = 'C':  apply Q**H (Conjugate transpose).

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>N1</u>
           <u>N2</u>

                     N1 is INTEGER
                     N2 is INTEGER
                     The dimension of Q12 and Q21, respectively. N1, N2 &gt;= 0.
                     The following requirement must be satisfied:
                     N1 + N2 = M if SIDE = 'L' and N1 + N2 = N if SIDE = 'R'.

           <u>Q</u>

                     Q is COMPLEX array, dimension
                                         (LDQ,M) if SIDE = 'L'
                                         (LDQ,N) if SIDE = 'R'

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= max(1,M) if SIDE = 'L'; LDQ &gt;= max(1,N) if SIDE = 'R'.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= M*N.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dorm22</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>n1,</b> <b>integer</b> <b>n2,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>q,</b> <b>integer</b> <b>ldq,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>DORM22</b> multiplies a general matrix by a banded orthogonal matrix.

       <b>Purpose</b>

             DORM22 overwrites the general real M-by-N matrix C with

                             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T

             where Q is a real orthogonal matrix of order NQ, with NQ = M if
             SIDE = 'L' and NQ = N if SIDE = 'R'.
             The orthogonal matrix Q processes a 2-by-2 block structure

                    [  Q11  Q12  ]
                Q = [            ]
                    [  Q21  Q22  ],

             where Q12 is an N1-by-N1 lower triangular matrix and Q21 is an
             N2-by-N2 upper triangular matrix.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  apply Q (No transpose);
                     = 'C':  apply Q**T (Conjugate transpose).

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>N1</u>
           <u>N2</u>

                     N1 is INTEGER
                     N2 is INTEGER
                     The dimension of Q12 and Q21, respectively. N1, N2 &gt;= 0.
                     The following requirement must be satisfied:
                     N1 + N2 = M if SIDE = 'L' and N1 + N2 = N if SIDE = 'R'.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension
                                                  (LDQ,M) if SIDE = 'L'
                                                  (LDQ,N) if SIDE = 'R'

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= max(1,M) if SIDE = 'L'; LDQ &gt;= max(1,N) if SIDE = 'R'.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= M*N.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>sorm22</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>n1,</b> <b>integer</b> <b>n2,</b> <b>real,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>q,</b> <b>integer</b> <b>ldq,</b> <b>real,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b>
       <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>SORM22</b> multiplies a general matrix by a banded orthogonal matrix.

       <b>Purpose</b>

             SORM22 overwrites the general real M-by-N matrix C with

                             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T

             where Q is a real orthogonal matrix of order NQ, with NQ = M if
             SIDE = 'L' and NQ = N if SIDE = 'R'.
             The orthogonal matrix Q processes a 2-by-2 block structure

                    [  Q11  Q12  ]
                Q = [            ]
                    [  Q21  Q22  ],

             where Q12 is an N1-by-N1 lower triangular matrix and Q21 is an
             N2-by-N2 upper triangular matrix.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  apply Q (No transpose);
                     = 'C':  apply Q**T (Conjugate transpose).

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>N1</u>
           <u>N2</u>

                     N1 is INTEGER
                     N2 is INTEGER
                     The dimension of Q12 and Q21, respectively. N1, N2 &gt;= 0.
                     The following requirement must be satisfied:
                     N1 + N2 = M if SIDE = 'L' and N1 + N2 = N if SIDE = 'R'.

           <u>Q</u>

                     Q is REAL array, dimension
                                         (LDQ,M) if SIDE = 'L'
                                         (LDQ,N) if SIDE = 'R'

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= max(1,M) if SIDE = 'L'; LDQ &gt;= max(1,N) if SIDE = 'R'.

           <u>C</u>

                     C is REAL array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= M*N.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zunm22</b> <b>(character</b> <b>side,</b> <b>character</b> <b>trans,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>integer</b> <b>n1,</b> <b>integer</b> <b>n2,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>q,</b> <b>integer</b> <b>ldq,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer</b> <b>info)</b>
       <b>ZUNM22</b> multiplies a general matrix by a banded unitary matrix.

       <b>Purpose</b>

             ZUNM22 overwrites the general complex M-by-N matrix C with

                             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'C':      Q**H * C       C * Q**H

             where Q is a complex unitary matrix of order NQ, with NQ = M if
             SIDE = 'L' and NQ = N if SIDE = 'R'.
             The unitary matrix Q processes a 2-by-2 block structure

                    [  Q11  Q12  ]
                Q = [            ]
                    [  Q21  Q22  ],

             where Q12 is an N1-by-N1 lower triangular matrix and Q21 is an
             N2-by-N2 upper triangular matrix.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  apply Q (No transpose);
                     = 'C':  apply Q**H (Conjugate transpose).

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>N1</u>
           <u>N2</u>

                     N1 is INTEGER
                     N2 is INTEGER
                     The dimension of Q12 and Q21, respectively. N1, N2 &gt;= 0.
                     The following requirement must be satisfied:
                     N1 + N2 = M if SIDE = 'L' and N1 + N2 = N if SIDE = 'R'.

           <u>Q</u>

                     Q is COMPLEX*16 array, dimension
                                         (LDQ,M) if SIDE = 'L'
                                         (LDQ,N) if SIDE = 'R'

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= max(1,M) if SIDE = 'L'; LDQ &gt;= max(1,N) if SIDE = 'R'.

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= M*N.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                              Sun Jul 20 2025 01:40:05                                    <u><a href="../man3/unm22.3.html">unm22</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>