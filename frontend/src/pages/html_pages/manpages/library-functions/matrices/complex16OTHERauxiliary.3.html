<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>complex16OTHERauxiliary - complex16</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/liblapack-doc">liblapack-doc_3.10.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       complex16OTHERauxiliary - complex16

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>clag2z</b> (M, N, SA, LDSA, A, LDA, INFO)
           <b>CLAG2Z</b> converts a complex single precision matrix to a complex double precision matrix.
       double precision function <b>dzsum1</b> (N, CX, INCX)
           <b>DZSUM1</b> forms the 1-norm of the complex vector using the true absolute value.
       integer function <b>ilazlc</b> (M, N, A, LDA)
           <b>ILAZLC</b> scans a matrix for its last non-zero column.
       integer function <b>ilazlr</b> (M, N, A, LDA)
           <b>ILAZLR</b> scans a matrix for its last non-zero row.
       subroutine <b>zdrscl</b> (N, SA, SX, INCX)
           <b>ZDRSCL</b> multiplies a vector by the reciprocal of a real scalar.
       subroutine <b>zlabrd</b> (M, N, NB, A, LDA, D, E, TAUQ, TAUP, X, LDX, Y, LDY)
           <b>ZLABRD</b> reduces the first nb rows and columns of a general matrix to a bidiagonal form.
       subroutine <b>zlacgv</b> (N, X, INCX)
           <b>ZLACGV</b> conjugates a complex vector.
       subroutine <b>zlacn2</b> (N, V, X, EST, KASE, ISAVE)
           <b>ZLACN2</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-
           vector products.
       subroutine <b>zlacon</b> (N, V, X, EST, KASE)
           <b>ZLACON</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-
           vector products.
       subroutine <b>zlacp2</b> (UPLO, M, N, A, LDA, B, LDB)
           <b>ZLACP2</b> copies all or part of a real two-dimensional array to a complex array.
       subroutine <b>zlacpy</b> (UPLO, M, N, A, LDA, B, LDB)
           <b>ZLACPY</b> copies all or part of one two-dimensional array to another.
       subroutine <b>zlacrm</b> (M, N, A, LDA, B, LDB, C, LDC, RWORK)
           <b>ZLACRM</b> multiplies a complex matrix by a square real matrix.
       subroutine <b>zlacrt</b> (N, CX, INCX, CY, INCY, C, S)
           <b>ZLACRT</b> performs a linear transformation of a pair of complex vectors.
       complex *16 function <b>zladiv</b> (X, Y)
           <b>ZLADIV</b> performs complex division in real arithmetic, avoiding unnecessary overflow.
       subroutine <b>zlaein</b> (RIGHTV, NOINIT, N, H, LDH, W, V, B, LDB, RWORK, EPS3, SMLNUM, INFO)
           <b>ZLAEIN</b> computes a specified right or left eigenvector of an upper Hessenberg matrix by inverse
           iteration.
       subroutine <b>zlaev2</b> (A, B, C, RT1, RT2, CS1, SN1)
           <b>ZLAEV2</b> computes the eigenvalues and eigenvectors of a 2-by-2 symmetric/Hermitian matrix.
       subroutine <b>zlag2c</b> (M, N, A, LDA, SA, LDSA, INFO)
           <b>ZLAG2C</b> converts a complex double precision matrix to a complex single precision matrix.
       subroutine <b>zlags2</b> (UPPER, A1, A2, A3, B1, B2, B3, CSU, SNU, CSV, SNV, CSQ, SNQ)
           <b>ZLAGS2</b>
       subroutine <b>zlagtm</b> (TRANS, N, NRHS, ALPHA, DL, D, DU, X, LDX, BETA, B, LDB)
           <b>ZLAGTM</b> performs a matrix-matrix product of the form C = αAB+βC, where A is a tridiagonal matrix, B
           and C are rectangular matrices, and α and β are scalars, which may be 0, 1, or -1.
       subroutine <b>zlahqr</b> (WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILOZ, IHIZ, Z, LDZ, INFO)
           <b>ZLAHQR</b> computes the eigenvalues and Schur factorization of an upper Hessenberg matrix, using the
           double-shift/single-shift QR algorithm.
       subroutine <b>zlahr2</b> (N, K, NB, A, LDA, TAU, T, LDT, Y, LDY)
           <b>ZLAHR2</b> reduces the specified number of first columns of a general rectangular matrix A so that
           elements below the specified subdiagonal are zero, and returns auxiliary matrices which are needed to
           apply the transformation to the unreduced part of A.
       subroutine <b>zlaic1</b> (JOB, J, X, SEST, W, GAMMA, SESTPR, S, C)
           <b>ZLAIC1</b> applies one step of incremental condition estimation.
       double precision function <b>zlangt</b> (NORM, N, DL, D, DU)
           <b>ZLANGT</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value
           of any element of a general tridiagonal matrix.
       double precision function <b>zlanhb</b> (NORM, UPLO, N, K, AB, LDAB, WORK)
           <b>ZLANHB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a Hermitian band matrix.
       double precision function <b>zlanhp</b> (NORM, UPLO, N, AP, WORK)
           <b>ZLANHP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a complex Hermitian matrix supplied in packed form.
       double precision function <b>zlanhs</b> (NORM, N, A, LDA, WORK)
           <b>ZLANHS</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value
           of any element of an upper Hessenberg matrix.
       double precision function <b>zlanht</b> (NORM, N, D, E)
           <b>ZLANHT</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a complex Hermitian tridiagonal matrix.
       double precision function <b>zlansb</b> (NORM, UPLO, N, K, AB, LDAB, WORK)
           <b>ZLANSB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a symmetric band matrix.
       double precision function <b>zlansp</b> (NORM, UPLO, N, AP, WORK)
           <b>ZLANSP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a symmetric matrix supplied in packed form.
       double precision function <b>zlantb</b> (NORM, UPLO, DIAG, N, K, AB, LDAB, WORK)
           <b>ZLANTB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a triangular band matrix.
       double precision function <b>zlantp</b> (NORM, UPLO, DIAG, N, AP, WORK)
           <b>ZLANTP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a triangular matrix supplied in packed form.
       double precision function <b>zlantr</b> (NORM, UPLO, DIAG, M, N, A, LDA, WORK)
           <b>ZLANTR</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a trapezoidal or triangular matrix.
       subroutine <b>zlapll</b> (N, X, INCX, Y, INCY, SSMIN)
           <b>ZLAPLL</b> measures the linear dependence of two vectors.
       subroutine <b>zlapmr</b> (FORWRD, M, N, X, LDX, K)
           <b>ZLAPMR</b> rearranges rows of a matrix as specified by a permutation vector.
       subroutine <b>zlapmt</b> (FORWRD, M, N, X, LDX, K)
           <b>ZLAPMT</b> performs a forward or backward permutation of the columns of a matrix.
       subroutine <b>zlaqhb</b> (UPLO, N, KD, AB, LDAB, S, SCOND, AMAX, EQUED)
           <b>ZLAQHB</b> scales a Hermitian band matrix, using scaling factors computed by cpbequ.
       subroutine <b>zlaqhp</b> (UPLO, N, AP, S, SCOND, AMAX, EQUED)
           <b>ZLAQHP</b> scales a Hermitian matrix stored in packed form.
       subroutine <b>zlaqp2</b> (M, N, OFFSET, A, LDA, JPVT, TAU, VN1, VN2, WORK)
           <b>ZLAQP2</b> computes a QR factorization with column pivoting of the matrix block.
       subroutine <b>zlaqps</b> (M, N, OFFSET, NB, KB, A, LDA, JPVT, TAU, VN1, VN2, AUXV, F, LDF)
           <b>ZLAQPS</b> computes a step of QR factorization with column pivoting of a real m-by-n matrix A by using
           BLAS level 3.
       subroutine <b>zlaqr0</b> (WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILOZ, IHIZ, Z, LDZ, WORK, LWORK, INFO)
           <b>ZLAQR0</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
           decomposition.
       subroutine <b>zlaqr1</b> (N, H, LDH, S1, S2, V)
           <b>ZLAQR1</b> sets a scalar multiple of the first column of the product of 2-by-2 or 3-by-3 matrix H and
           specified shifts.
       subroutine <b>zlaqr2</b> (WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ, IHIZ, Z, LDZ, NS, ND, SH, V, LDV, NH,
           T, LDT, NV, WV, LDWV, WORK, LWORK)
           <b>ZLAQR2</b> performs the unitary similarity transformation of a Hessenberg matrix to detect and deflate
           fully converged eigenvalues from a trailing principal submatrix (aggressive early deflation).
       subroutine <b>zlaqr3</b> (WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ, IHIZ, Z, LDZ, NS, ND, SH, V, LDV, NH,
           T, LDT, NV, WV, LDWV, WORK, LWORK)
           <b>ZLAQR3</b> performs the unitary similarity transformation of a Hessenberg matrix to detect and deflate
           fully converged eigenvalues from a trailing principal submatrix (aggressive early deflation).
       subroutine <b>zlaqr4</b> (WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILOZ, IHIZ, Z, LDZ, WORK, LWORK, INFO)
           <b>ZLAQR4</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
           decomposition.
       subroutine <b>zlaqr5</b> (WANTT, WANTZ, KACC22, N, KTOP, KBOT, NSHFTS, S, H, LDH, ILOZ, IHIZ, Z, LDZ, V, LDV, U,
           LDU, NV, WV, LDWV, NH, WH, LDWH)
           <b>ZLAQR5</b> performs a single small-bulge multi-shift QR sweep.
       subroutine <b>zlaqsb</b> (UPLO, N, KD, AB, LDAB, S, SCOND, AMAX, EQUED)
           <b>ZLAQSB</b> scales a symmetric/Hermitian band matrix, using scaling factors computed by spbequ.
       subroutine <b>zlaqsp</b> (UPLO, N, AP, S, SCOND, AMAX, EQUED)
           <b>ZLAQSP</b> scales a symmetric/Hermitian matrix in packed storage, using scaling factors computed by
           sppequ.
       subroutine <b>zlar1v</b> (N, B1, BN, LAMBDA, D, L, LD, LLD, PIVMIN, GAPTOL, Z, WANTNC, NEGCNT, ZTZ, MINGMA, R,
           ISUPPZ, NRMINV, RESID, RQCORR, WORK)
           <b>ZLAR1V</b> computes the (scaled) r-th column of the inverse of the submatrix in rows b1 through bn of the
           tridiagonal matrix LDLT - λI.
       subroutine <b>zlar2v</b> (N, X, Y, Z, INCX, C, S, INCC)
           <b>ZLAR2V</b> applies a vector of plane rotations with real cosines and complex sines from both sides to a
           sequence of 2-by-2 symmetric/Hermitian matrices.
       subroutine <b>zlarcm</b> (M, N, A, LDA, B, LDB, C, LDC, RWORK)
           <b>ZLARCM</b> copies all or part of a real two-dimensional array to a complex array.
       subroutine <b>zlarf</b> (SIDE, M, N, V, INCV, TAU, C, LDC, WORK)
           <b>ZLARF</b> applies an elementary reflector to a general rectangular matrix.
       subroutine <b>zlarfb</b> (SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV, T, LDT, C, LDC, WORK, LDWORK)
           <b>ZLARFB</b> applies a block reflector or its conjugate-transpose to a general rectangular matrix.
       subroutine <b>zlarfb_gett</b> (IDENT, M, N, K, T, LDT, A, LDA, B, LDB, WORK, LDWORK)
           <b>ZLARFB_GETT</b>
       subroutine <b>zlarfg</b> (N, ALPHA, X, INCX, TAU)
           <b>ZLARFG</b> generates an elementary reflector (Householder matrix).
       subroutine <b>zlarfgp</b> (N, ALPHA, X, INCX, TAU)
           <b>ZLARFGP</b> generates an elementary reflector (Householder matrix) with non-negative beta.
       subroutine <b>zlarft</b> (DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT)
           <b>ZLARFT</b> forms the triangular factor T of a block reflector H = I - vtvH
       subroutine <b>zlarfx</b> (SIDE, M, N, V, TAU, C, LDC, WORK)
           <b>ZLARFX</b> applies an elementary reflector to a general rectangular matrix, with loop unrolling when the
           reflector has order ≤ 10.
       subroutine <b>zlarfy</b> (UPLO, N, V, INCV, TAU, C, LDC, WORK)
           <b>ZLARFY</b>
       subroutine <b>zlargv</b> (N, X, INCX, Y, INCY, C, INCC)
           <b>ZLARGV</b> generates a vector of plane rotations with real cosines and complex sines.
       subroutine <b>zlarnv</b> (IDIST, ISEED, N, X)
           <b>ZLARNV</b> returns a vector of random numbers from a uniform or normal distribution.
       subroutine <b>zlarrv</b> (N, VL, VU, D, L, PIVMIN, ISPLIT, M, DOL, DOU, MINRGP, RTOL1, RTOL2, W, WERR, WGAP,
           IBLOCK, INDEXW, GERS, Z, LDZ, ISUPPZ, WORK, IWORK, INFO)
           <b>ZLARRV</b> computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues
           of L D LT.
       subroutine <b>zlartv</b> (N, X, INCX, Y, INCY, C, S, INCC)
           <b>ZLARTV</b> applies a vector of plane rotations with real cosines and complex sines to the elements of a
           pair of vectors.
       subroutine <b>zlascl</b> (TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO)
           <b>ZLASCL</b> multiplies a general rectangular matrix by a real scalar defined as cto/cfrom.
       subroutine <b>zlaset</b> (UPLO, M, N, ALPHA, BETA, A, LDA)
           <b>ZLASET</b> initializes the off-diagonal elements and the diagonal elements of a matrix to given values.
       subroutine <b>zlasr</b> (SIDE, PIVOT, DIRECT, M, N, C, S, A, LDA)
           <b>ZLASR</b> applies a sequence of plane rotations to a general rectangular matrix.
       subroutine <b>zlaswp</b> (N, A, LDA, K1, K2, IPIV, INCX)
           <b>ZLASWP</b> performs a series of row interchanges on a general rectangular matrix.
       subroutine <b>zlat2c</b> (UPLO, N, A, LDA, SA, LDSA, INFO)
           <b>ZLAT2C</b> converts a double complex triangular matrix to a complex triangular matrix.
       subroutine <b>zlatbs</b> (UPLO, TRANS, DIAG, NORMIN, N, KD, AB, LDAB, X, SCALE, CNORM, INFO)
           <b>ZLATBS</b> solves a triangular banded system of equations.
       subroutine <b>zlatdf</b> (IJOB, N, Z, LDZ, RHS, RDSUM, RDSCAL, IPIV, JPIV)
           <b>ZLATDF</b> uses the LU factorization of the n-by-n matrix computed by sgetc2 and computes a contribution
           to the reciprocal Dif-estimate.
       subroutine <b>zlatps</b> (UPLO, TRANS, DIAG, NORMIN, N, AP, X, SCALE, CNORM, INFO)
           <b>ZLATPS</b> solves a triangular system of equations with the matrix held in packed storage.
       subroutine <b>zlatrd</b> (UPLO, N, NB, A, LDA, E, TAU, W, LDW)
           <b>ZLATRD</b> reduces the first nb rows and columns of a symmetric/Hermitian matrix A to real tridiagonal
           form by an unitary similarity transformation.
       subroutine <b>zlatrs</b> (UPLO, TRANS, DIAG, NORMIN, N, A, LDA, X, SCALE, CNORM, INFO)
           <b>ZLATRS</b> solves a triangular system of equations with the scale factor set to prevent overflow.
       subroutine <b>zlauu2</b> (UPLO, N, A, LDA, INFO)
           <b>ZLAUU2</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices
           (unblocked algorithm).
       subroutine <b>zlauum</b> (UPLO, N, A, LDA, INFO)
           <b>ZLAUUM</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices (blocked
           algorithm).
       subroutine <b>zrot</b> (N, CX, INCX, CY, INCY, C, S)
           <b>ZROT</b> applies a plane rotation with real cosine and complex sine to a pair of complex vectors.
       subroutine <b>zspmv</b> (UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY)
           <b>ZSPMV</b> computes a matrix-vector product for complex vectors using a complex symmetric packed matrix
       subroutine <b>zspr</b> (UPLO, N, ALPHA, X, INCX, AP)
           <b>ZSPR</b> performs the symmetrical rank-1 update of a complex symmetric packed matrix.
       subroutine <b>ztprfb</b> (SIDE, TRANS, DIRECT, STOREV, M, N, K, L, V, LDV, T, LDT, A, LDA, B, LDB, WORK, LDWORK)
           <b>ZTPRFB</b> applies a real or complex 'triangular-pentagonal' blocked reflector to a real or complex
           matrix, which is composed of two blocks.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       This is the group of complex16 other auxiliary routines

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>clag2z</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>ldsa,</b> <b>*</b> <b>)</b> <b>SA,</b> <b>integer</b> <b>LDSA,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b> <b>INFO)</b>
       <b>CLAG2Z</b> converts a complex single precision matrix to a complex double precision matrix.

       <b>Purpose:</b>

            CLAG2Z converts a COMPLEX matrix, SA, to a COMPLEX*16 matrix, A.

            Note that while it is possible to overflow while converting
            from double to single, it is not possible to overflow when
            converting from single to double.

            This is an auxiliary routine so there is no argument checking.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of lines of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>SA</u>

                     SA is COMPLEX array, dimension (LDSA,N)
                     On entry, the M-by-N coefficient matrix SA.

           <u>LDSA</u>

                     LDSA is INTEGER
                     The leading dimension of the array SA.  LDSA &gt;= max(1,M).

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On exit, the M-by-N coefficient matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>dzsum1</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CX,</b> <b>integer</b> <b>INCX)</b>
       <b>DZSUM1</b> forms the 1-norm of the complex vector using the true absolute value.

       <b>Purpose:</b>

            DZSUM1 takes the sum of the absolute values of a complex
            vector and returns a double precision result.

            Based on DZASUM from the Level 1 BLAS.
            The change is to use the 'genuine' absolute value.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of elements in the vector CX.

           <u>CX</u>

                     CX is COMPLEX*16 array, dimension (N)
                     The vector whose elements will be summed.

           <u>INCX</u>

                     INCX is INTEGER
                     The spacing between successive values of CX.  INCX &gt; 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Nick Higham for use with ZLACON.

   <b>integer</b> <b>function</b> <b>ilazlc</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA)</b>
       <b>ILAZLC</b> scans a matrix for its last non-zero column.

       <b>Purpose:</b>

            ILAZLC scans A for its last non-zero column.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     The m by n matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>integer</b> <b>function</b> <b>ilazlr</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA)</b>
       <b>ILAZLR</b> scans a matrix for its last non-zero row.

       <b>Purpose:</b>

            ILAZLR scans A for its last non-zero row.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     The m by n matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zdrscl</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision</b> <b>SA,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SX,</b> <b>integer</b> <b>INCX)</b>
       <b>ZDRSCL</b> multiplies a vector by the reciprocal of a real scalar.

       <b>Purpose:</b>

            ZDRSCL multiplies an n-element complex vector x by the real scalar
            1/a.  This is done without overflow or underflow as long as
            the final result x/a does not overflow or underflow.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of components of the vector x.

           <u>SA</u>

                     SA is DOUBLE PRECISION
                     The scalar a which is used to divide each component of x.
                     SA must be &gt;= 0, or the subroutine will divide by zero.

           <u>SX</u>

                     SX is COMPLEX*16 array, dimension
                                    (1+(N-1)*abs(INCX))
                     The n-element vector x.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between successive values of the vector SX.
                     &gt; 0:  <a href="../man1/SX.1.html">SX</a>(1) = <a href="../man1/X.1.html">X</a>(1) and SX(1+(i-1)*INCX) = x(i),     1&lt; i&lt;= n

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlabrd</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NB,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUQ,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUP,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>complex*16,</b> <b>dimension(</b>
       <b>ldy,</b> <b>*</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>LDY)</b>
       <b>ZLABRD</b> reduces the first nb rows and columns of a general matrix to a bidiagonal form.

       <b>Purpose:</b>

            ZLABRD reduces the first NB rows and columns of a complex general
            m by n matrix A to upper or lower real bidiagonal form by a unitary
            transformation Q**H * A * P, and returns the matrices X and Y which
            are needed to apply the transformation to the unreduced part of A.

            If m &gt;= n, A is reduced to upper bidiagonal form; if m &lt; n, to lower
            bidiagonal form.

            This is an auxiliary routine called by ZGEBRD

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows in the matrix A.

           <u>N</u>

                     N is INTEGER
                     The number of columns in the matrix A.

           <u>NB</u>

                     NB is INTEGER
                     The number of leading rows and columns of A to be reduced.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the m by n general matrix to be reduced.
                     On exit, the first NB rows and columns of the matrix are
                     overwritten; the rest of the array is unchanged.
                     If m &gt;= n, elements on and below the diagonal in the first NB
                       columns, with the array TAUQ, represent the unitary
                       matrix Q as a product of elementary reflectors; and
                       elements above the diagonal in the first NB rows, with the
                       array TAUP, represent the unitary matrix P as a product
                       of elementary reflectors.
                     If m &lt; n, elements below the diagonal in the first NB
                       columns, with the array TAUQ, represent the unitary
                       matrix Q as a product of elementary reflectors, and
                       elements on and above the diagonal in the first NB rows,
                       with the array TAUP, represent the unitary matrix P as
                       a product of elementary reflectors.
                     See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (NB)
                     The diagonal elements of the first NB rows and columns of
                     the reduced matrix.  D(i) = A(i,i).

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (NB)
                     The off-diagonal elements of the first NB rows and columns of
                     the reduced matrix.

           <u>TAUQ</u>

                     TAUQ is COMPLEX*16 array, dimension (NB)
                     The scalar factors of the elementary reflectors which
                     represent the unitary matrix Q. See Further Details.

           <u>TAUP</u>

                     TAUP is COMPLEX*16 array, dimension (NB)
                     The scalar factors of the elementary reflectors which
                     represent the unitary matrix P. See Further Details.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (LDX,NB)
                     The m-by-nb matrix X required to update the unreduced part
                     of A.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X. LDX &gt;= max(1,M).

           <u>Y</u>

                     Y is COMPLEX*16 array, dimension (LDY,NB)
                     The n-by-nb matrix Y required to update the unreduced part
                     of A.

           <u>LDY</u>

                     LDY is INTEGER
                     The leading dimension of the array Y. LDY &gt;= max(1,N).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The matrices Q and P are represented as products of elementary
             reflectors:

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nb)  and  P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(nb)

             Each H(i) and G(i) has the form:

                H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H

             where tauq and taup are complex scalars, and v and u are complex
             vectors.

             If m &gt;= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
             A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
             A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

             If m &lt; n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
             A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
             A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

             The elements of the vectors v and u together form the m-by-nb matrix
             V and the nb-by-n matrix U**H which are needed, with X and Y, to apply
             the transformation to the unreduced part of the matrix, using a block
             update of the form:  A := A - V*Y**H - X*U**H.

             The contents of A on exit are illustrated by the following examples
             with nb = 2:

             m = 6 and n = 5 (m &gt; n):          m = 5 and n = 6 (m &lt; n):

               (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
               (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
               (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
               (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
               (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
               (  v1  v2  a   a   a  )

             where a denotes an element of the original matrix which is unchanged,
             vi denotes an element of the vector defining H(i), and ui an element
             of the vector defining G(i).

   <b>subroutine</b> <b>zlacgv</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX)</b>
       <b>ZLACGV</b> conjugates a complex vector.

       <b>Purpose:</b>

            ZLACGV conjugates a complex vector of length N.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The length of the vector X.  N &gt;= 0.

           <u>X</u>

                     X is COMPLEX*16 array, dimension
                                    (1+(N-1)*abs(INCX))
                     On entry, the vector of length N to be conjugated.
                     On exit, X is overwritten with conjg(X).

           <u>INCX</u>

                     INCX is INTEGER
                     The spacing between successive elements of X.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlacn2</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>double</b> <b>precision</b>
       <b>EST,</b> <b>integer</b> <b>KASE,</b> <b>integer,</b> <b>dimension(</b> <b>3</b> <b>)</b> <b>ISAVE)</b>
       <b>ZLACN2</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-vector
       products.

       <b>Purpose:</b>

            ZLACN2 estimates the 1-norm of a square, complex matrix A.
            Reverse communication is used for evaluating matrix-vector products.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The order of the matrix.  N &gt;= 1.

           <u>V</u>

                     V is COMPLEX*16 array, dimension (N)
                    On the final return, V = A*W,  where  EST = norm(V)/norm(W)
                    (W is not returned).

           <u>X</u>

                     X is COMPLEX*16 array, dimension (N)
                    On an intermediate return, X should be overwritten by
                          A * X,   if KASE=1,
                          A**H * X,  if KASE=2,
                    where A**H is the conjugate transpose of A, and ZLACN2 must be
                    re-called with all the other parameters unchanged.

           <u>EST</u>

                     EST is DOUBLE PRECISION
                    On entry with KASE = 1 or 2 and <a href="../man1/ISAVE.1.html">ISAVE</a>(1) = 3, EST should be
                    unchanged from the previous call to ZLACN2.
                    On exit, EST is an estimate (a lower bound) for norm(A).

           <u>KASE</u>

                     KASE is INTEGER
                    On the initial call to ZLACN2, KASE should be 0.
                    On an intermediate return, KASE will be 1 or 2, indicating
                    whether X should be overwritten by A * X  or A**H * X.
                    On the final return from ZLACN2, KASE will again be 0.

           <u>ISAVE</u>

                     ISAVE is INTEGER array, dimension (3)
                    ISAVE is used to save variables between calls to ZLACN2

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Originally named CONEST, dated March 16, 1988.

             Last modified:  April, 1999

             This is a thread safe version of ZLACON, which uses the array ISAVE
             in place of a SAVE statement, as follows:

                ZLACON     ZLACN2
                 JUMP     <a href="../man1/ISAVE.1.html">ISAVE</a>(1)
                 J        <a href="../man2/ISAVE.2.html">ISAVE</a>(2)
                 ITER     <a href="../man3/ISAVE.3.html">ISAVE</a>(3)

       <b>Contributors:</b>
           Nick Higham, University of Manchester

       <b>References:</b>
           N.J. Higham, 'FORTRAN codes for estimating the one-norm of
             a real or complex matrix, with applications to condition estimation', ACM Trans. Math. Soft., vol.
           14, no. 4, pp. 381-396, December 1988.

   <b>subroutine</b> <b>zlacon</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>V,</b> <b>complex*16,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>X,</b> <b>double</b> <b>precision</b>
       <b>EST,</b> <b>integer</b> <b>KASE)</b>
       <b>ZLACON</b> estimates the 1-norm of a square matrix, using reverse communication for evaluating matrix-vector
       products.

       <b>Purpose:</b>

            ZLACON estimates the 1-norm of a square, complex matrix A.
            Reverse communication is used for evaluating matrix-vector products.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The order of the matrix.  N &gt;= 1.

           <u>V</u>

                     V is COMPLEX*16 array, dimension (N)
                    On the final return, V = A*W,  where  EST = norm(V)/norm(W)
                    (W is not returned).

           <u>X</u>

                     X is COMPLEX*16 array, dimension (N)
                    On an intermediate return, X should be overwritten by
                          A * X,   if KASE=1,
                          A**H * X,  if KASE=2,
                    where A**H is the conjugate transpose of A, and ZLACON must be
                    re-called with all the other parameters unchanged.

           <u>EST</u>

                     EST is DOUBLE PRECISION
                    On entry with KASE = 1 or 2 and JUMP = 3, EST should be
                    unchanged from the previous call to ZLACON.
                    On exit, EST is an estimate (a lower bound) for norm(A).

           <u>KASE</u>

                     KASE is INTEGER
                    On the initial call to ZLACON, KASE should be 0.
                    On an intermediate return, KASE will be 1 or 2, indicating
                    whether X should be overwritten by A * X  or A**H * X.
                    On the final return from ZLACON, KASE will again be 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>
           Originally named CONEST, dated March 16, 1988.
            Last modified: April, 1999

       <b>Contributors:</b>
           Nick Higham, University of Manchester

       <b>References:</b>
           N.J. Higham, 'FORTRAN codes for estimating the one-norm of
             a real or complex matrix, with applications to condition estimation', ACM Trans. Math. Soft., vol.
           14, no. 4, pp. 381-396, December 1988.

   <b>subroutine</b> <b>zlacp2</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b>
       <b>LDA,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB)</b>
       <b>ZLACP2</b> copies all or part of a real two-dimensional array to a complex array.

       <b>Purpose:</b>

            ZLACP2 copies all or part of a real two-dimensional matrix A to a
            complex matrix B.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies the part of the matrix A to be copied to B.
                     = 'U':      Upper triangular part
                     = 'L':      Lower triangular part
                     Otherwise:  All of the matrix A

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     The m by n matrix A.  If UPLO = 'U', only the upper trapezium
                     is accessed; if UPLO = 'L', only the lower trapezium is
                     accessed.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,N)
                     On exit, B = A in the locations specified by UPLO.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlacpy</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB)</b>
       <b>ZLACPY</b> copies all or part of one two-dimensional array to another.

       <b>Purpose:</b>

            ZLACPY copies all or part of a two-dimensional matrix A to another
            matrix B.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies the part of the matrix A to be copied to B.
                     = 'U':      Upper triangular part
                     = 'L':      Lower triangular part
                     Otherwise:  All of the matrix A

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     The m by n matrix A.  If UPLO = 'U', only the upper trapezium
                     is accessed; if UPLO = 'L', only the lower trapezium is
                     accessed.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,N)
                     On exit, B = A in the locations specified by UPLO.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlacrm</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK)</b>
       <b>ZLACRM</b> multiplies a complex matrix by a square real matrix.

       <b>Purpose:</b>

            ZLACRM performs a very simple matrix-matrix multiplication:
                     C := A * B,
            where A is M by N and complex; B is N by N and real;
            C is M by N and complex.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A and of the matrix C.
                     M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns and rows of the matrix B and
                     the number of columns of the matrix C.
                     N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA, N)
                     On entry, A contains the M by N matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;=max(1,M).

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB, N)
                     On entry, B contains the N by N matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;=max(1,N).

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC, N)
                     On exit, C contains the M by N matrix C.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;=max(1,N).

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (2*M*N)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlacrt</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CX,</b> <b>integer</b> <b>INCX,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CY,</b>
       <b>integer</b> <b>INCY,</b> <b>complex*16</b> <b>C,</b> <b>complex*16</b> <b>S)</b>
       <b>ZLACRT</b> performs a linear transformation of a pair of complex vectors.

       <b>Purpose:</b>

            ZLACRT performs the operation

               (  c  s )( x )  ==&gt; ( x )
               ( -s  c )( y )      ( y )

            where c and s are complex and the vectors x and y are complex.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of elements in the vectors CX and CY.

           <u>CX</u>

                     CX is COMPLEX*16 array, dimension (N)
                     On input, the vector x.
                     On output, CX is overwritten with c*x + s*y.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between successive values of CX.  INCX &lt;&gt; 0.

           <u>CY</u>

                     CY is COMPLEX*16 array, dimension (N)
                     On input, the vector y.
                     On output, CY is overwritten with -s*x + c*y.

           <u>INCY</u>

                     INCY is INTEGER
                     The increment between successive values of CY.  INCY &lt;&gt; 0.

           <u>C</u>

                     C is COMPLEX*16

           <u>S</u>

                     S is COMPLEX*16
                     C and S define the matrix
                        [  C   S  ].
                        [ -S   C  ]

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>complex*16</b> <b>function</b> <b>zladiv</b> <b>(complex*16</b> <b>X,</b> <b>complex*16</b> <b>Y)</b>
       <b>ZLADIV</b> performs complex division in real arithmetic, avoiding unnecessary overflow.

       <b>Purpose:</b>

            ZLADIV := X / Y, where X and Y are complex.  The computation of X / Y
            will not overflow on an intermediary step unless the results
            overflows.

       <b>Parameters</b>
           <u>X</u>

                     X is COMPLEX*16

           <u>Y</u>

                     Y is COMPLEX*16
                     The complex scalars X and Y.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlaein</b> <b>(logical</b> <b>RIGHTV,</b> <b>logical</b> <b>NOINIT,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b>
       <b>complex*16</b> <b>W,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>double</b> <b>precision</b> <b>EPS3,</b> <b>double</b> <b>precision</b> <b>SMLNUM,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLAEIN</b> computes a specified right or left eigenvector of an upper Hessenberg matrix by inverse iteration.

       <b>Purpose:</b>

            ZLAEIN uses inverse iteration to find a right or left eigenvector
            corresponding to the eigenvalue W of a complex upper Hessenberg
            matrix H.

       <b>Parameters</b>
           <u>RIGHTV</u>

                     RIGHTV is LOGICAL
                     = .TRUE. : compute right eigenvector;
                     = .FALSE.: compute left eigenvector.

           <u>NOINIT</u>

                     NOINIT is LOGICAL
                     = .TRUE. : no initial vector supplied in V
                     = .FALSE.: initial vector supplied in V.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H.  N &gt;= 0.

           <u>H</u>

                     H is COMPLEX*16 array, dimension (LDH,N)
                     The upper Hessenberg matrix H.

           <u>LDH</u>

                     LDH is INTEGER
                     The leading dimension of the array H.  LDH &gt;= max(1,N).

           <u>W</u>

                     W is COMPLEX*16
                     The eigenvalue of H whose corresponding right or left
                     eigenvector is to be computed.

           <u>V</u>

                     V is COMPLEX*16 array, dimension (N)
                     On entry, if NOINIT = .FALSE., V must contain a starting
                     vector for inverse iteration; otherwise V need not be set.
                     On exit, V contains the computed eigenvector, normalized so
                     that the component of largest magnitude has magnitude 1; here
                     the magnitude of a complex number (x,y) is taken to be
                     |x| + |y|.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,N)

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (N)

           <u>EPS3</u>

                     EPS3 is DOUBLE PRECISION
                     A small machine-dependent value which is used to perturb
                     close eigenvalues, and to replace zero pivots.

           <u>SMLNUM</u>

                     SMLNUM is DOUBLE PRECISION
                     A machine-dependent value close to the underflow threshold.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     = 1:  inverse iteration did not converge; V is set to the
                           last iterate.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlaev2</b> <b>(complex*16</b> <b>A,</b> <b>complex*16</b> <b>B,</b> <b>complex*16</b> <b>C,</b> <b>double</b> <b>precision</b> <b>RT1,</b> <b>double</b> <b>precision</b> <b>RT2,</b>
       <b>double</b> <b>precision</b> <b>CS1,</b> <b>complex*16</b> <b>SN1)</b>
       <b>ZLAEV2</b> computes the eigenvalues and eigenvectors of a 2-by-2 symmetric/Hermitian matrix.

       <b>Purpose:</b>

            ZLAEV2 computes the eigendecomposition of a 2-by-2 Hermitian matrix
               [  A         B  ]
               [  CONJG(B)  C  ].
            On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
            eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
            eigenvector for RT1, giving the decomposition

            [ CS1  CONJG(SN1) ] [    A     B ] [ CS1 -CONJG(SN1) ] = [ RT1  0  ]
            [-SN1     CS1     ] [ CONJG(B) C ] [ SN1     CS1     ]   [  0  RT2 ].

       <b>Parameters</b>
           <u>A</u>

                     A is COMPLEX*16
                    The (1,1) element of the 2-by-2 matrix.

           <u>B</u>

                     B is COMPLEX*16
                    The (1,2) element and the conjugate of the (2,1) element of
                    the 2-by-2 matrix.

           <u>C</u>

                     C is COMPLEX*16
                    The (2,2) element of the 2-by-2 matrix.

           <u>RT1</u>

                     RT1 is DOUBLE PRECISION
                    The eigenvalue of larger absolute value.

           <u>RT2</u>

                     RT2 is DOUBLE PRECISION
                    The eigenvalue of smaller absolute value.

           <u>CS1</u>

                     CS1 is DOUBLE PRECISION

           <u>SN1</u>

                     SN1 is COMPLEX*16
                    The vector (CS1, SN1) is a unit right eigenvector for RT1.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             RT1 is accurate to a few ulps barring over/underflow.

             RT2 may be inaccurate if there is massive cancellation in the
             determinant A*C-B*B; higher precision or correctly rounded or
             correctly truncated arithmetic would be needed to compute RT2
             accurately in all cases.

             CS1 and SN1 are accurate to a few ulps barring over/underflow.

             Overflow is possible only if RT1 is within a factor of 5 of overflow.
             Underflow is harmless if the input data is 0 or exceeds
                underflow_threshold / macheps.

   <b>subroutine</b> <b>zlag2c</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldsa,</b> <b>*</b> <b>)</b> <b>SA,</b> <b>integer</b> <b>LDSA,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLAG2C</b> converts a complex double precision matrix to a complex single precision matrix.

       <b>Purpose:</b>

            ZLAG2C converts a COMPLEX*16 matrix, SA, to a COMPLEX matrix, A.

            RMAX is the overflow for the SINGLE PRECISION arithmetic
            ZLAG2C checks that all the entries of A are between -RMAX and
            RMAX. If not the conversion is aborted and a flag is raised.

            This is an auxiliary routine so there is no argument checking.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of lines of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the M-by-N coefficient matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>SA</u>

                     SA is COMPLEX array, dimension (LDSA,N)
                     On exit, if INFO=0, the M-by-N coefficient matrix SA; if
                     INFO&gt;0, the content of SA is unspecified.

           <u>LDSA</u>

                     LDSA is INTEGER
                     The leading dimension of the array SA.  LDSA &gt;= max(1,M).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     = 1:  an entry of the matrix A is greater than the SINGLE
                           PRECISION overflow threshold, in this case, the content
                           of SA in exit is unspecified.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlags2</b> <b>(logical</b> <b>UPPER,</b> <b>double</b> <b>precision</b> <b>A1,</b> <b>complex*16</b> <b>A2,</b> <b>double</b> <b>precision</b> <b>A3,</b> <b>double</b> <b>precision</b>
       <b>B1,</b> <b>complex*16</b> <b>B2,</b> <b>double</b> <b>precision</b> <b>B3,</b> <b>double</b> <b>precision</b> <b>CSU,</b> <b>complex*16</b> <b>SNU,</b> <b>double</b> <b>precision</b> <b>CSV,</b>
       <b>complex*16</b> <b>SNV,</b> <b>double</b> <b>precision</b> <b>CSQ,</b> <b>complex*16</b> <b>SNQ)</b>
       <b>ZLAGS2</b>

       <b>Purpose:</b>

            ZLAGS2 computes 2-by-2 unitary matrices U, V and Q, such
            that if ( UPPER ) then

                      U**H *A*Q = U**H *( A1 A2 )*Q = ( x  0  )
                                        ( 0  A3 )     ( x  x  )
            and
                      V**H*B*Q = V**H *( B1 B2 )*Q = ( x  0  )
                                       ( 0  B3 )     ( x  x  )

            or if ( .NOT.UPPER ) then

                      U**H *A*Q = U**H *( A1 0  )*Q = ( x  x  )
                                        ( A2 A3 )     ( 0  x  )
            and
                      V**H *B*Q = V**H *( B1 0  )*Q = ( x  x  )
                                        ( B2 B3 )     ( 0  x  )
            where

              U = (   CSU    SNU ), V = (  CSV    SNV ),
                  ( -SNU**H  CSU )      ( -SNV**H CSV )

              Q = (   CSQ    SNQ )
                  ( -SNQ**H  CSQ )

            The rows of the transformed A and B are parallel. Moreover, if the
            input 2-by-2 matrix A is not zero, then the transformed (1,1) entry
            of A is not zero. If the input matrices A and B are both not zero,
            then the transformed (2,2) element of B is not zero, except when the
            first rows of input A and B are parallel and the second rows are
            zero.

       <b>Parameters</b>
           <u>UPPER</u>

                     UPPER is LOGICAL
                     = .TRUE.: the input matrices A and B are upper triangular.
                     = .FALSE.: the input matrices A and B are lower triangular.

           <u>A1</u>

                     A1 is DOUBLE PRECISION

           <u>A2</u>

                     A2 is COMPLEX*16

           <u>A3</u>

                     A3 is DOUBLE PRECISION
                     On entry, A1, A2 and A3 are elements of the input 2-by-2
                     upper (lower) triangular matrix A.

           <u>B1</u>

                     B1 is DOUBLE PRECISION

           <u>B2</u>

                     B2 is COMPLEX*16

           <u>B3</u>

                     B3 is DOUBLE PRECISION
                     On entry, B1, B2 and B3 are elements of the input 2-by-2
                     upper (lower) triangular matrix B.

           <u>CSU</u>

                     CSU is DOUBLE PRECISION

           <u>SNU</u>

                     SNU is COMPLEX*16
                     The desired unitary matrix U.

           <u>CSV</u>

                     CSV is DOUBLE PRECISION

           <u>SNV</u>

                     SNV is COMPLEX*16
                     The desired unitary matrix V.

           <u>CSQ</u>

                     CSQ is DOUBLE PRECISION

           <u>SNQ</u>

                     SNQ is COMPLEX*16
                     The desired unitary matrix Q.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlagtm</b> <b>(character</b> <b>TRANS,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>double</b> <b>precision</b> <b>ALPHA,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>DL,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DU,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b>
       <b>integer</b> <b>LDX,</b> <b>double</b> <b>precision</b> <b>BETA,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB)</b>
       <b>ZLAGTM</b> performs a matrix-matrix product of the form C = αAB+βC, where A is a tridiagonal matrix, B and C
       are rectangular matrices, and α and β are scalars, which may be 0, 1, or -1.

       <b>Purpose:</b>

            ZLAGTM performs a matrix-vector product of the form

               B := alpha * A * X + beta * B

            where A is a tridiagonal matrix of order N, B and X are N by NRHS
            matrices, and alpha and beta are real scalars, each of which may be
            0., 1., or -1.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  No transpose, B := alpha * A * X + beta * B
                     = 'T':  Transpose,    B := alpha * A**T * X + beta * B
                     = 'C':  Conjugate transpose, B := alpha * A**H * X + beta * B

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices X and B.

           <u>ALPHA</u>

                     ALPHA is DOUBLE PRECISION
                     The scalar alpha.  ALPHA must be 0., 1., or -1.; otherwise,
                     it is assumed to be 0.

           <u>DL</u>

                     DL is COMPLEX*16 array, dimension (N-1)
                     The (n-1) sub-diagonal elements of T.

           <u>D</u>

                     D is COMPLEX*16 array, dimension (N)
                     The diagonal elements of T.

           <u>DU</u>

                     DU is COMPLEX*16 array, dimension (N-1)
                     The (n-1) super-diagonal elements of T.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (LDX,NRHS)
                     The N by NRHS matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(N,1).

           <u>BETA</u>

                     BETA is DOUBLE PRECISION
                     The scalar beta.  BETA must be 0., 1., or -1.; otherwise,
                     it is assumed to be 1.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,NRHS)
                     On entry, the N by NRHS matrix B.
                     On exit, B is overwritten by the matrix expression
                     B := alpha * A * X + beta * B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(N,1).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlahqr</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>complex*16,</b> <b>dimension(</b>
       <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>complex*16,</b> <b>dimension(</b>
       <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLAHQR</b> computes the eigenvalues and Schur factorization of an upper Hessenberg matrix, using the double-
       shift/single-shift QR algorithm.

       <b>Purpose:</b>

               ZLAHQR is an auxiliary routine called by CHSEQR to update the
               eigenvalues and Schur decomposition already computed by CHSEQR, by
               dealing with the Hessenberg submatrix in rows and columns ILO to
               IHI.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     = .TRUE. : the full Schur form T is required;
                     = .FALSE.: only eigenvalues are required.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     = .TRUE. : the matrix of Schur vectors Z is required;
                     = .FALSE.: Schur vectors are not required.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                     It is assumed that H is already upper triangular in rows and
                     columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless ILO = 1).
                     ZLAHQR works primarily with the Hessenberg submatrix in rows
                     and columns ILO to IHI, but applies transformations to all of
                     H if WANTT is .TRUE..
                     1 &lt;= ILO &lt;= max(1,IHI); IHI &lt;= N.

           <u>H</u>

                     H is COMPLEX*16 array, dimension (LDH,N)
                     On entry, the upper Hessenberg matrix H.
                     On exit, if INFO is zero and if WANTT is .TRUE., then H
                     is upper triangular in rows and columns ILO:IHI.  If INFO
                     is zero and if WANTT is .FALSE., then the contents of H
                     are unspecified on exit.  The output state of H in case
                     INF is positive is below under the description of INFO.

           <u>LDH</u>

                     LDH is INTEGER
                     The leading dimension of the array H. LDH &gt;= max(1,N).

           <u>W</u>

                     W is COMPLEX*16 array, dimension (N)
                     The computed eigenvalues ILO to IHI are stored in the
                     corresponding elements of W. If WANTT is .TRUE., the
                     eigenvalues are stored in the same order as on the diagonal
                     of the Schur form returned in H, with W(i) = H(i,i).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                     Specify the rows of Z to which transformations must be
                     applied if WANTZ is .TRUE..
                     1 &lt;= ILOZ &lt;= ILO; IHI &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (LDZ,N)
                     If WANTZ is .TRUE., on entry Z must contain the current
                     matrix Z of transformations accumulated by CHSEQR, and on
                     exit Z has been updated; transformations are applied only to
                     the submatrix Z(ILOZ:IHIZ,ILO:IHI).
                     If WANTZ is .FALSE., Z is not referenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z. LDZ &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                      = 0:   successful exit
                      &gt; 0:   if INFO = i, ZLAHQR failed to compute all the
                             eigenvalues ILO to IHI in a total of 30 iterations
                             per eigenvalue; elements i+1:ihi of W contain
                             those eigenvalues which have been successfully
                             computed.

                             If INFO &gt; 0 and WANTT is .FALSE., then on exit,
                             the remaining unconverged eigenvalues are the
                             eigenvalues of the upper Hessenberg matrix
                             rows and columns ILO through INFO of the final,
                             output value of H.

                             If INFO &gt; 0 and WANTT is .TRUE., then on exit
                     (*)       (initial value of H)*U  = U*(final value of H)
                             where U is an orthogonal matrix.    The final
                             value of H is upper Hessenberg and triangular in
                             rows and columns INFO+1 through IHI.

                             If INFO &gt; 0 and WANTZ is .TRUE., then on exit
                                 (final value of Z)  = (initial value of Z)*U
                             where U is the orthogonal matrix in (*)
                             (regardless of the value of WANTT.)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

                02-96 Based on modifications by
                David Day, Sandia National Laboratory, USA

                12-04 Further modifications by
                Ralph Byers, University of Kansas, USA
                This is a modified version of ZLAHQR from LAPACK version 3.0.
                It is (1) more robust against overflow and underflow and
                (2) adopts the more conservative Ahues &amp; Tisseur stopping
                criterion (LAWN 122, 1997).

   <b>subroutine</b> <b>zlahr2</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>integer</b> <b>NB,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>nb</b> <b>)</b> <b>TAU,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldt,</b> <b>nb</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>complex*16,</b> <b>dimension(</b>
       <b>ldy,</b> <b>nb</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>LDY)</b>
       <b>ZLAHR2</b> reduces the specified number of first columns of a general rectangular matrix A so that elements
       below the specified subdiagonal are zero, and returns auxiliary matrices which are needed to apply the
       transformation to the unreduced part of A.

       <b>Purpose:</b>

            ZLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1)
            matrix A so that elements below the k-th subdiagonal are zero. The
            reduction is performed by an unitary similarity transformation
            Q**H * A * Q. The routine returns the matrices V and T which determine
            Q as a block reflector I - V*T*V**H, and also the matrix Y = A * V * T.

            This is an auxiliary routine called by ZGEHRD.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.

           <u>K</u>

                     K is INTEGER
                     The offset for the reduction. Elements below the k-th
                     subdiagonal in the first NB columns are reduced to zero.
                     K &lt; N.

           <u>NB</u>

                     NB is INTEGER
                     The number of columns to be reduced.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N-K+1)
                     On entry, the n-by-(n-k+1) general matrix A.
                     On exit, the elements on and above the k-th subdiagonal in
                     the first NB columns are overwritten with the corresponding
                     elements of the reduced matrix; the elements below the k-th
                     subdiagonal, with the array TAU, represent the matrix Q as a
                     product of elementary reflectors. The other columns of A are
                     unchanged. See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>TAU</u>

                     TAU is COMPLEX*16 array, dimension (NB)
                     The scalar factors of the elementary reflectors. See Further
                     Details.

           <u>T</u>

                     T is COMPLEX*16 array, dimension (LDT,NB)
                     The upper triangular matrix T.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= NB.

           <u>Y</u>

                     Y is COMPLEX*16 array, dimension (LDY,NB)
                     The n-by-nb matrix Y.

           <u>LDY</u>

                     LDY is INTEGER
                     The leading dimension of the array Y. LDY &gt;= N.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The matrix Q is represented as a product of nb elementary reflectors

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nb).

             Each H(i) has the form

                H(i) = I - tau * v * v**H

             where tau is a complex scalar, and v is a complex vector with
             v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
             A(i+k+1:n,i), and tau in TAU(i).

             The elements of the vectors v together form the (n-k+1)-by-nb matrix
             V which is needed, with T and Y, to apply the transformation to the
             unreduced part of the matrix, using an update of the form:
             A := (I - V*T*V**H) * (A - Y*V**H).

             The contents of A on exit are illustrated by the following example
             with n = 7, k = 3 and nb = 2:

                ( a   a   a   a   a )
                ( a   a   a   a   a )
                ( a   a   a   a   a )
                ( h   h   a   a   a )
                ( v1  h   a   a   a )
                ( v1  v2  a   a   a )
                ( v1  v2  a   a   a )

             where a denotes an element of the original matrix A, h denotes a
             modified element of the upper Hessenberg matrix H, and vi denotes an
             element of the vector defining H(i).

             This subroutine is a slight modification of LAPACK-3.0's ZLAHRD
             incorporating improvements proposed by Quintana-Orti and Van de
             Gejin. Note that the entries of A(1:K,2:NB) differ from those
             returned by the original LAPACK-3.0's ZLAHRD routine. (This
             subroutine is not backward compatible with LAPACK-3.0's ZLAHRD.)

       <b>References:</b>
           Gregorio Quintana-Orti and Robert van de Geijn, 'Improving the
             performance of reduction to Hessenberg form,' ACM Transactions on Mathematical Software,
           <a href="../man2/32.2.html">32</a>(2):180-194, June 2006.

   <b>subroutine</b> <b>zlaic1</b> <b>(integer</b> <b>JOB,</b> <b>integer</b> <b>J,</b> <b>complex*16,</b> <b>dimension(</b> <b>j</b> <b>)</b> <b>X,</b> <b>double</b> <b>precision</b> <b>SEST,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>j</b> <b>)</b> <b>W,</b> <b>complex*16</b> <b>GAMMA,</b> <b>double</b> <b>precision</b> <b>SESTPR,</b> <b>complex*16</b> <b>S,</b> <b>complex*16</b> <b>C)</b>
       <b>ZLAIC1</b> applies one step of incremental condition estimation.

       <b>Purpose:</b>

            ZLAIC1 applies one step of incremental condition estimation in
            its simplest version:

            Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
            lower triangular matrix L, such that
                     twonorm(L*x) = sest
            Then ZLAIC1 computes sestpr, s, c such that
            the vector
                            [ s*x ]
                     xhat = [  c  ]
            is an approximate singular vector of
                            [ L       0  ]
                     Lhat = [ w**H gamma ]
            in the sense that
                     twonorm(Lhat*xhat) = sestpr.

            Depending on JOB, an estimate for the largest or smallest singular
            value is computed.

            Note that [s c]**H and sestpr**2 is an eigenpair of the system

                diag(sest*sest, 0) + [alpha  gamma] * [ conjg(alpha) ]
                                                      [ conjg(gamma) ]

            where  alpha =  x**H * w.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is INTEGER
                     = 1: an estimate for the largest singular value is computed.
                     = 2: an estimate for the smallest singular value is computed.

           <u>J</u>

                     J is INTEGER
                     Length of X and W

           <u>X</u>

                     X is COMPLEX*16 array, dimension (J)
                     The j-vector x.

           <u>SEST</u>

                     SEST is DOUBLE PRECISION
                     Estimated singular value of j by j matrix L

           <u>W</u>

                     W is COMPLEX*16 array, dimension (J)
                     The j-vector w.

           <u>GAMMA</u>

                     GAMMA is COMPLEX*16
                     The diagonal element gamma.

           <u>SESTPR</u>

                     SESTPR is DOUBLE PRECISION
                     Estimated singular value of (j+1) by (j+1) matrix Lhat.

           <u>S</u>

                     S is COMPLEX*16
                     Sine needed in forming xhat.

           <u>C</u>

                     C is COMPLEX*16
                     Cosine needed in forming xhat.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>zlangt</b> <b>(character</b> <b>NORM,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DL,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DU)</b>
       <b>ZLANGT</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value of
       any element of a general tridiagonal matrix.

       <b>Purpose:</b>

            ZLANGT  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex tridiagonal matrix A.

       <b>Returns</b>
           ZLANGT

               ZLANGT = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in ZLANGT as described
                     above.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, ZLANGT is
                     set to zero.

           <u>DL</u>

                     DL is COMPLEX*16 array, dimension (N-1)
                     The (n-1) sub-diagonal elements of A.

           <u>D</u>

                     D is COMPLEX*16 array, dimension (N)
                     The diagonal elements of A.

           <u>DU</u>

                     DU is COMPLEX*16 array, dimension (N-1)
                     The (n-1) super-diagonal elements of A.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>zlanhb</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLANHB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a Hermitian band matrix.

       <b>Purpose:</b>

            ZLANHB  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the element of  largest absolute value  of an
            n by n hermitian band matrix A,  with k super-diagonals.

       <b>Returns</b>
           ZLANHB

               ZLANHB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in ZLANHB as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     band matrix A is supplied.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, ZLANHB is
                     set to zero.

           <u>K</u>

                     K is INTEGER
                     The number of super-diagonals or sub-diagonals of the
                     band matrix A.  K &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX*16 array, dimension (LDAB,N)
                     The upper or lower triangle of the hermitian band matrix A,
                     stored in the first K+1 rows of AB.  The j-th column of A is
                     stored in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j&lt;=i&lt;=min(n,j+k).
                     Note that the imaginary parts of the diagonal elements need
                     not be set and are assumed to be zero.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= K+1.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I' or '1' or 'O'; otherwise,
                     WORK is not referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>zlanhp</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLANHP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a complex Hermitian matrix supplied in packed form.

       <b>Purpose:</b>

            ZLANHP  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex hermitian matrix A,  supplied in packed form.

       <b>Returns</b>
           ZLANHP

               ZLANHP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in ZLANHP as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     hermitian matrix A is supplied.
                     = 'U':  Upper triangular part of A is supplied
                     = 'L':  Lower triangular part of A is supplied

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, ZLANHP is
                     set to zero.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the hermitian matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     Note that the  imaginary parts of the diagonal elements need
                     not be set and are assumed to be zero.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I' or '1' or 'O'; otherwise,
                     WORK is not referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>zlanhs</b> <b>(character</b> <b>NORM,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLANHS</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value of
       any element of an upper Hessenberg matrix.

       <b>Purpose:</b>

            ZLANHS  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            Hessenberg matrix A.

       <b>Returns</b>
           ZLANHS

               ZLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in ZLANHS as described
                     above.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, ZLANHS is
                     set to zero.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     The n by n upper Hessenberg matrix A; the part of A below the
                     first sub-diagonal is not referenced.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(N,1).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>zlanht</b> <b>(character</b> <b>NORM,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>E)</b>
       <b>ZLANHT</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a complex Hermitian tridiagonal matrix.

       <b>Purpose:</b>

            ZLANHT  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex Hermitian tridiagonal matrix A.

       <b>Returns</b>
           ZLANHT

               ZLANHT = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in ZLANHT as described
                     above.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, ZLANHT is
                     set to zero.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     The diagonal elements of A.

           <u>E</u>

                     E is COMPLEX*16 array, dimension (N-1)
                     The (n-1) sub-diagonal or super-diagonal elements of A.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>zlansb</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLANSB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a symmetric band matrix.

       <b>Purpose:</b>

            ZLANSB  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the element of  largest absolute value  of an
            n by n symmetric band matrix A,  with k super-diagonals.

       <b>Returns</b>
           ZLANSB

               ZLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in ZLANSB as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     band matrix A is supplied.
                     = 'U':  Upper triangular part is supplied
                     = 'L':  Lower triangular part is supplied

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, ZLANSB is
                     set to zero.

           <u>K</u>

                     K is INTEGER
                     The number of super-diagonals or sub-diagonals of the
                     band matrix A.  K &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX*16 array, dimension (LDAB,N)
                     The upper or lower triangle of the symmetric band matrix A,
                     stored in the first K+1 rows of AB.  The j-th column of A is
                     stored in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j&lt;=i&lt;=min(n,j+k).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= K+1.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I' or '1' or 'O'; otherwise,
                     WORK is not referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>zlansp</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLANSP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a symmetric matrix supplied in packed form.

       <b>Purpose:</b>

            ZLANSP  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex symmetric matrix A,  supplied in packed form.

       <b>Returns</b>
           ZLANSP

               ZLANSP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in ZLANSP as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is supplied.
                     = 'U':  Upper triangular part of A is supplied
                     = 'L':  Lower triangular part of A is supplied

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, ZLANSP is
                     set to zero.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the symmetric matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I' or '1' or 'O'; otherwise,
                     WORK is not referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>zlantb</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLANTB</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a triangular band matrix.

       <b>Purpose:</b>

            ZLANTB  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the element of  largest absolute value  of an
            n by n triangular band matrix A,  with ( k + 1 ) diagonals.

       <b>Returns</b>
           ZLANTB

               ZLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in ZLANTB as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, ZLANTB is
                     set to zero.

           <u>K</u>

                     K is INTEGER
                     The number of super-diagonals of the matrix A if UPLO = 'U',
                     or the number of sub-diagonals of the matrix A if UPLO = 'L'.
                     K &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX*16 array, dimension (LDAB,N)
                     The upper or lower triangular band matrix A, stored in the
                     first k+1 rows of AB.  The j-th column of A is stored
                     in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j&lt;=i&lt;=min(n,j+k).
                     Note that when DIAG = 'U', the elements of the array AB
                     corresponding to the diagonal elements of the matrix A are
                     not referenced, but are assumed to be one.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= K+1.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>zlantp</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLANTP</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a triangular matrix supplied in packed form.

       <b>Purpose:</b>

            ZLANTP  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            triangular matrix A, supplied in packed form.

       <b>Returns</b>
           ZLANTP

               ZLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in ZLANTP as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.  When N = 0, ZLANTP is
                     set to zero.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     The upper or lower triangular matrix A, packed columnwise in
                     a linear array.  The j-th column of A is stored in the array
                     AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     Note that when DIAG = 'U', the elements of the array AP
                     corresponding to the diagonal elements of the matrix A are
                     not referenced, but are assumed to be one.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= N when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>double</b> <b>precision</b> <b>function</b> <b>zlantr</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLANTR</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a trapezoidal or triangular matrix.

       <b>Purpose:</b>

            ZLANTR  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            trapezoidal or triangular matrix A.

       <b>Returns</b>
           ZLANTR

               ZLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in ZLANTR as described
                     above.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower trapezoidal.
                     = 'U':  Upper trapezoidal
                     = 'L':  Lower trapezoidal
                     Note that A is triangular instead of trapezoidal if M = N.

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A has unit diagonal.
                     = 'N':  Non-unit diagonal
                     = 'U':  Unit diagonal

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0, and if
                     UPLO = 'U', M &lt;= N.  When M = 0, ZLANTR is set to zero.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0, and if
                     UPLO = 'L', N &lt;= M.  When N = 0, ZLANTR is set to zero.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     The trapezoidal matrix A (A is triangular if M = N).
                     If UPLO = 'U', the leading m by n upper trapezoidal part of
                     the array A contains the upper trapezoidal matrix, and the
                     strictly lower triangular part of A is not referenced.
                     If UPLO = 'L', the leading m by n lower trapezoidal part of
                     the array A contains the lower trapezoidal matrix, and the
                     strictly upper triangular part of A is not referenced.  Note
                     that when DIAG = 'U', the diagonal elements of A are not
                     referenced and are assumed to be one.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(M,1).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= M when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlapll</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b>
       <b>integer</b> <b>INCY,</b> <b>double</b> <b>precision</b> <b>SSMIN)</b>
       <b>ZLAPLL</b> measures the linear dependence of two vectors.

       <b>Purpose:</b>

            Given two column vectors X and Y, let

                                 A = ( X Y ).

            The subroutine first computes the QR factorization of A = Q*R,
            and then computes the SVD of the 2-by-2 upper triangular matrix R.
            The smaller singular value of R is returned in SSMIN, which is used
            as the measurement of the linear dependency of the vectors X and Y.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The length of the vectors X and Y.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (1+(N-1)*INCX)
                     On entry, X contains the N-vector X.
                     On exit, X is overwritten.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between successive elements of X. INCX &gt; 0.

           <u>Y</u>

                     Y is COMPLEX*16 array, dimension (1+(N-1)*INCY)
                     On entry, Y contains the N-vector Y.
                     On exit, Y is overwritten.

           <u>INCY</u>

                     INCY is INTEGER
                     The increment between successive elements of Y. INCY &gt; 0.

           <u>SSMIN</u>

                     SSMIN is DOUBLE PRECISION
                     The smallest singular value of the N-by-2 matrix A = ( X Y ).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlapmr</b> <b>(logical</b> <b>FORWRD,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>K)</b>
       <b>ZLAPMR</b> rearranges rows of a matrix as specified by a permutation vector.

       <b>Purpose:</b>

            ZLAPMR rearranges the rows of the M by N matrix X as specified
            by the permutation <a href="../man1/K.1.html">K</a>(1),<a href="../man2/K.2.html">K</a>(2),...,K(M) of the integers 1,...,M.
            If FORWRD = .TRUE.,  forward permutation:

                 X(K(I),*) is moved X(I,*) for I = 1,2,...,M.

            If FORWRD = .FALSE., backward permutation:

                 X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.

       <b>Parameters</b>
           <u>FORWRD</u>

                     FORWRD is LOGICAL
                     = .TRUE., forward permutation
                     = .FALSE., backward permutation

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix X. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix X. N &gt;= 0.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (LDX,N)
                     On entry, the M by N matrix X.
                     On exit, X contains the permuted matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X, LDX &gt;= MAX(1,M).

           <u>K</u>

                     K is INTEGER array, dimension (M)
                     On entry, K contains the permutation vector. K is used as
                     internal workspace, but reset to its original value on
                     output.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlapmt</b> <b>(logical</b> <b>FORWRD,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>K)</b>
       <b>ZLAPMT</b> performs a forward or backward permutation of the columns of a matrix.

       <b>Purpose:</b>

            ZLAPMT rearranges the columns of the M by N matrix X as specified
            by the permutation <a href="../man1/K.1.html">K</a>(1),<a href="../man2/K.2.html">K</a>(2),...,K(N) of the integers 1,...,N.
            If FORWRD = .TRUE.,  forward permutation:

                 X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.

            If FORWRD = .FALSE., backward permutation:

                 X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.

       <b>Parameters</b>
           <u>FORWRD</u>

                     FORWRD is LOGICAL
                     = .TRUE., forward permutation
                     = .FALSE., backward permutation

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix X. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix X. N &gt;= 0.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (LDX,N)
                     On entry, the M by N matrix X.
                     On exit, X contains the permuted matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X, LDX &gt;= MAX(1,M).

           <u>K</u>

                     K is INTEGER array, dimension (N)
                     On entry, K contains the permutation vector. K is used as
                     internal workspace, but reset to its original value on
                     output.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlaqhb</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>double</b> <b>precision</b> <b>SCOND,</b> <b>double</b> <b>precision</b> <b>AMAX,</b> <b>character</b> <b>EQUED)</b>
       <b>ZLAQHB</b> scales a Hermitian band matrix, using scaling factors computed by cpbequ.

       <b>Purpose:</b>

            ZLAQHB equilibrates a Hermitian band matrix A
            using the scaling factors in the vector S.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is stored.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of super-diagonals of the matrix A if UPLO = 'U',
                     or the number of sub-diagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX*16 array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the symmetric band
                     matrix A, stored in the first KD+1 rows of the array.  The
                     j-th column of A is stored in the j-th column of the array AB
                     as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

                     On exit, if INFO = 0, the triangular factor U or L from the
                     Cholesky factorization A = U**H *U or A = L*L**H of the band
                     matrix A, in the same storage format as A.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (N)
                     The scale factors for A.

           <u>SCOND</u>

                     SCOND is DOUBLE PRECISION
                     Ratio of the smallest S(i) to the largest S(i).

           <u>AMAX</u>

                     AMAX is DOUBLE PRECISION
                     Absolute value of largest matrix entry.

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                     Specifies whether or not equilibration was done.
                     = 'N':  No equilibration.
                     = 'Y':  Equilibration was done, i.e., A has been replaced by
                             diag(S) * A * diag(S).

       <b>Internal</b> <b>Parameters:</b>

             THRESH is a threshold value used to decide if scaling should be done
             based on the ratio of the scaling factors.  If SCOND &lt; THRESH,
             scaling is done.

             LARGE and SMALL are threshold values used to decide if scaling should
             be done based on the absolute size of the largest matrix element.
             If AMAX &gt; LARGE or AMAX &lt; SMALL, scaling is done.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlaqhp</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>S,</b> <b>double</b> <b>precision</b> <b>SCOND,</b> <b>double</b> <b>precision</b> <b>AMAX,</b> <b>character</b> <b>EQUED)</b>
       <b>ZLAQHP</b> scales a Hermitian matrix stored in packed form.

       <b>Purpose:</b>

            ZLAQHP equilibrates a Hermitian matrix A using the scaling factors
            in the vector S.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     Hermitian matrix A is stored.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the Hermitian matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

                     On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
                     the same storage format as A.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (N)
                     The scale factors for A.

           <u>SCOND</u>

                     SCOND is DOUBLE PRECISION
                     Ratio of the smallest S(i) to the largest S(i).

           <u>AMAX</u>

                     AMAX is DOUBLE PRECISION
                     Absolute value of largest matrix entry.

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                     Specifies whether or not equilibration was done.
                     = 'N':  No equilibration.
                     = 'Y':  Equilibration was done, i.e., A has been replaced by
                             diag(S) * A * diag(S).

       <b>Internal</b> <b>Parameters:</b>

             THRESH is a threshold value used to decide if scaling should be done
             based on the ratio of the scaling factors.  If SCOND &lt; THRESH,
             scaling is done.

             LARGE and SMALL are threshold values used to decide if scaling should
             be done based on the absolute size of the largest matrix element.
             If AMAX &gt; LARGE or AMAX &lt; SMALL, scaling is done.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlaqp2</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>OFFSET,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>JPVT,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VN1,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VN2,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLAQP2</b> computes a QR factorization with column pivoting of the matrix block.

       <b>Purpose:</b>

            ZLAQP2 computes a QR factorization with column pivoting of
            the block A(OFFSET+1:M,1:N).
            The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A. N &gt;= 0.

           <u>OFFSET</u>

                     OFFSET is INTEGER
                     The number of rows of the matrix A that must be pivoted
                     but no factorized. OFFSET &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, the upper triangle of block A(OFFSET+1:M,1:N) is
                     the triangular factor obtained; the elements in block
                     A(OFFSET+1:M,1:N) below the diagonal, together with the
                     array TAU, represent the orthogonal matrix Q as a product of
                     elementary reflectors. Block A(1:OFFSET,1:N) has been
                     accordingly pivoted, but no factorized.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>JPVT</u>

                     JPVT is INTEGER array, dimension (N)
                     On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
                     to the front of A*P (a leading column); if JPVT(i) = 0,
                     the i-th column of A is a free column.
                     On exit, if JPVT(i) = k, then the i-th column of A*P
                     was the k-th column of A.

           <u>TAU</u>

                     TAU is COMPLEX*16 array, dimension (min(M,N))
                     The scalar factors of the elementary reflectors.

           <u>VN1</u>

                     VN1 is DOUBLE PRECISION array, dimension (N)
                     The vector with the partial column norms.

           <u>VN2</u>

                     VN2 is DOUBLE PRECISION array, dimension (N)
                     The vector with the exact column norms.

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (N)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain X. Sun, Computer Science Dept.,
           Duke University, USA
            Partial column norm updating strategy modified on April 2011 Z. Drmac and Z. Bujanovic, Dept. of
           Mathematics, University of Zagreb, Croatia.

       <b>References:</b>
           LAPACK Working Note 176

   <b>subroutine</b> <b>zlaqps</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>OFFSET,</b> <b>integer</b> <b>NB,</b> <b>integer</b> <b>KB,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b>
       <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>JPVT,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>VN1,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>VN2,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AUXV,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldf,</b> <b>*</b> <b>)</b> <b>F,</b> <b>integer</b> <b>LDF)</b>
       <b>ZLAQPS</b> computes a step of QR factorization with column pivoting of a real m-by-n matrix A by using BLAS
       level 3.

       <b>Purpose:</b>

            ZLAQPS computes a step of QR factorization with column pivoting
            of a complex M-by-N matrix A by using Blas-3.  It tries to factorize
            NB columns from A starting from the row OFFSET+1, and updates all
            of the matrix with Blas-3 xGEMM.

            In some cases, due to catastrophic cancellations, it cannot
            factorize NB columns.  Hence, the actual number of factorized
            columns is returned in KB.

            Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A. N &gt;= 0

           <u>OFFSET</u>

                     OFFSET is INTEGER
                     The number of rows of A that have been factorized in
                     previous steps.

           <u>NB</u>

                     NB is INTEGER
                     The number of columns to factorize.

           <u>KB</u>

                     KB is INTEGER
                     The number of columns actually factorized.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, block A(OFFSET+1:M,1:KB) is the triangular
                     factor obtained and block A(1:OFFSET,1:N) has been
                     accordingly pivoted, but no factorized.
                     The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
                     been updated.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>JPVT</u>

                     JPVT is INTEGER array, dimension (N)
                     JPVT(I) = K &lt;==&gt; Column K of the full matrix A has been
                     permuted into position I in AP.

           <u>TAU</u>

                     TAU is COMPLEX*16 array, dimension (KB)
                     The scalar factors of the elementary reflectors.

           <u>VN1</u>

                     VN1 is DOUBLE PRECISION array, dimension (N)
                     The vector with the partial column norms.

           <u>VN2</u>

                     VN2 is DOUBLE PRECISION array, dimension (N)
                     The vector with the exact column norms.

           <u>AUXV</u>

                     AUXV is COMPLEX*16 array, dimension (NB)
                     Auxiliary vector.

           <u>F</u>

                     F is COMPLEX*16 array, dimension (LDF,NB)
                     Matrix F**H = L * Y**H * A.

           <u>LDF</u>

                     LDF is INTEGER
                     The leading dimension of the array F. LDF &gt;= max(1,N).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain X. Sun, Computer Science Dept.,
           Duke University, USA
            Partial column norm updating strategy modified on April 2011 Z. Drmac and Z. Bujanovic, Dept. of
           Mathematics, University of Zagreb, Croatia.

       <b>References:</b>
           LAPACK Working Note 176

   <b>subroutine</b> <b>zlaqr0</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>complex*16,</b> <b>dimension(</b>
       <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>complex*16,</b> <b>dimension(</b>
       <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLAQR0</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
       decomposition.

       <b>Purpose:</b>

               ZLAQR0 computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**H, where T is an upper triangular matrix (the
               Schur form), and Z is the unitary matrix of Schur vectors.

               Optionally Z may be postmultiplied into an input unitary
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     = .TRUE. : the full Schur form T is required;
                     = .FALSE.: only eigenvalues are required.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     = .TRUE. : the matrix of Schur vectors Z is required;
                     = .FALSE.: Schur vectors are not required.

           <u>N</u>

                     N is INTEGER
                      The order of the matrix H.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER

                      It is assumed that H is already upper triangular in rows
                      and columns 1:ILO-1 and IHI+1:N and, if ILO &gt; 1,
                      H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
                      previous call to ZGEBAL, and then passed to ZGEHRD when the
                      matrix output by ZGEBAL is reduced to Hessenberg form.
                      Otherwise, ILO and IHI should be set to 1 and N,
                      respectively.  If N &gt; 0, then 1 &lt;= ILO &lt;= IHI &lt;= N.
                      If N = 0, then ILO = 1 and IHI = 0.

           <u>H</u>

                     H is COMPLEX*16 array, dimension (LDH,N)
                      On entry, the upper Hessenberg matrix H.
                      On exit, if INFO = 0 and WANTT is .TRUE., then H
                      contains the upper triangular matrix T from the Schur
                      decomposition (the Schur form). If INFO = 0 and WANT is
                      .FALSE., then the contents of H are unspecified on exit.
                      (The output value of H when INFO &gt; 0 is given under the
                      description of INFO below.)

                      This subroutine may explicitly set H(i,j) = 0 for i &gt; j and
                      j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.

           <u>LDH</u>

                     LDH is INTEGER
                      The leading dimension of the array H. LDH &gt;= max(1,N).

           <u>W</u>

                     W is COMPLEX*16 array, dimension (N)
                      The computed eigenvalues of H(ILO:IHI,ILO:IHI) are stored
                      in W(ILO:IHI). If WANTT is .TRUE., then the eigenvalues are
                      stored in the same order as on the diagonal of the Schur
                      form returned in H, with W(i) = H(i,i).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                      Specify the rows of Z to which transformations must be
                      applied if WANTZ is .TRUE..
                      1 &lt;= ILOZ &lt;= ILO; IHI &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (LDZ,IHI)
                      If WANTZ is .FALSE., then Z is not referenced.
                      If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
                      replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
                      orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
                      (The output value of Z when INFO &gt; 0 is given under
                      the description of INFO below.)

           <u>LDZ</u>

                     LDZ is INTEGER
                      The leading dimension of the array Z.  if WANTZ is .TRUE.
                      then LDZ &gt;= MAX(1,IHIZ).  Otherwise, LDZ &gt;= 1.

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension LWORK
                      On exit, if LWORK = -1, <a href="../man1/WORK.1.html">WORK</a>(1) returns an estimate of
                      the optimal value for LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK.  LWORK &gt;= max(1,N)
                      is sufficient, but LWORK typically as large as 6*N may
                      be required for optimal performance.  A workspace query
                      to determine the optimal workspace size is recommended.

                      If LWORK = -1, then ZLAQR0 does a workspace query.
                      In this case, ZLAQR0 checks the input parameters and
                      estimates the optimal workspace size for the given
                      values of N, ILO and IHI.  The estimate is returned
                      in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is
                      issued by XERBLA.  Neither H nor Z are accessed.

           <u>INFO</u>

                     INFO is INTEGER
                        = 0:  successful exit
                        &gt; 0:  if INFO = i, ZLAQR0 failed to compute all of
                           the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                           and WI contain those eigenvalues which have been
                           successfully computed.  (Failures are rare.)

                           If INFO &gt; 0 and WANT is .FALSE., then on exit,
                           the remaining unconverged eigenvalues are the eigen-
                           values of the upper Hessenberg matrix rows and
                           columns ILO through INFO of the final, output
                           value of H.

                           If INFO &gt; 0 and WANTT is .TRUE., then on exit

                      (*)  (initial value of H)*U  = U*(final value of H)

                           where U is a unitary matrix.  The final
                           value of  H is upper Hessenberg and triangular in
                           rows and columns INFO+1 through IHI.

                           If INFO &gt; 0 and WANTZ is .TRUE., then on exit

                             (final value of Z(ILO:IHI,ILOZ:IHIZ)
                              =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U

                           where U is the unitary matrix in (*) (regard-
                           less of the value of WANTT.)

                           If INFO &gt; 0 and WANTZ is .FALSE., then Z is not
                           accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

       <b>References:</b>

             K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
             Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
             Performance, SIAM Journal of Matrix Analysis, volume 23, pages
             929--947, 2002.

            K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part II: Aggressive Early
           Deflation, SIAM Journal of Matrix Analysis, volume 23, pages 948--973, 2002.

   <b>subroutine</b> <b>zlaqr1</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>complex*16</b> <b>S1,</b> <b>complex*16</b> <b>S2,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V)</b>
       <b>ZLAQR1</b> sets a scalar multiple of the first column of the product of 2-by-2 or 3-by-3 matrix H and
       specified shifts.

       <b>Purpose:</b>

                 Given a 2-by-2 or 3-by-3 matrix H, ZLAQR1 sets v to a
                 scalar multiple of the first column of the product

                 (*)  K = (H - s1*I)*(H - s2*I)

                 scaling to avoid overflows and most underflows.

                 This is useful for starting double implicit shift bulges
                 in the QR algorithm.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                         Order of the matrix H. N must be either 2 or 3.

           <u>H</u>

                     H is COMPLEX*16 array, dimension (LDH,N)
                         The 2-by-2 or 3-by-3 matrix H in (*).

           <u>LDH</u>

                     LDH is INTEGER
                         The leading dimension of H as declared in
                         the calling procedure.  LDH &gt;= N

           <u>S1</u>

                     S1 is COMPLEX*16

           <u>S2</u>

                     S2 is COMPLEX*16

                     S1 and S2 are the shifts defining K in (*) above.

           <u>V</u>

                     V is COMPLEX*16 array, dimension (N)
                         A scalar multiple of the first column of the
                         matrix K in (*).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

   <b>subroutine</b> <b>zlaqr2</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KTOP,</b> <b>integer</b> <b>KBOT,</b> <b>integer</b> <b>NW,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b>
       <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer</b> <b>NS,</b> <b>integer</b> <b>ND,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SH,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b>
       <b>V,</b> <b>integer</b> <b>LDV,</b> <b>integer</b> <b>NH,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>integer</b> <b>NV,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldwv,</b> <b>*</b> <b>)</b> <b>WV,</b> <b>integer</b> <b>LDWV,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK)</b>
       <b>ZLAQR2</b> performs the unitary similarity transformation of a Hessenberg matrix to detect and deflate fully
       converged eigenvalues from a trailing principal submatrix (aggressive early deflation).

       <b>Purpose:</b>

               ZLAQR2 is identical to ZLAQR3 except that it avoids
               recursion by calling ZLAHQR instead of ZLAQR4.

               Aggressive early deflation:

               ZLAQR2 accepts as input an upper Hessenberg matrix
               H and performs an unitary similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.  On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an unitary similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     If .TRUE., then the Hessenberg matrix H is fully updated
                     so that the triangular Schur factor may be
                     computed (in cooperation with the calling subroutine).
                     If .FALSE., then only enough of H is updated to preserve
                     the eigenvalues.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     If .TRUE., then the unitary matrix Z is updated so
                     so that the unitary Schur factor may be computed
                     (in cooperation with the calling subroutine).
                     If .FALSE., then Z is not referenced.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H and (if WANTZ is .TRUE.) the
                     order of the unitary matrix Z.

           <u>KTOP</u>

                     KTOP is INTEGER
                     It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
                     KBOT and KTOP together determine an isolated block
                     along the diagonal of the Hessenberg matrix.

           <u>KBOT</u>

                     KBOT is INTEGER
                     It is assumed without a check that either
                     KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
                     determine an isolated block along the diagonal of the
                     Hessenberg matrix.

           <u>NW</u>

                     NW is INTEGER
                     Deflation window size.  1 &lt;= NW &lt;= (KBOT-KTOP+1).

           <u>H</u>

                     H is COMPLEX*16 array, dimension (LDH,N)
                     On input the initial N-by-N section of H stores the
                     Hessenberg matrix undergoing aggressive early deflation.
                     On output H has been transformed by a unitary
                     similarity transformation, perturbed, and the returned
                     to Hessenberg form that (it is to be hoped) has some
                     zero subdiagonal entries.

           <u>LDH</u>

                     LDH is INTEGER
                     Leading dimension of H just as declared in the calling
                     subroutine.  N &lt;= LDH

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                     Specify the rows of Z to which transformations must be
                     applied if WANTZ is .TRUE.. 1 &lt;= ILOZ &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (LDZ,N)
                     IF WANTZ is .TRUE., then on output, the unitary
                     similarity transformation mentioned above has been
                     accumulated into Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right.
                     If WANTZ is .FALSE., then Z is unreferenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of Z just as declared in the
                     calling subroutine.  1 &lt;= LDZ.

           <u>NS</u>

                     NS is INTEGER
                     The number of unconverged (ie approximate) eigenvalues
                     returned in SR and SI that may be used as shifts by the
                     calling subroutine.

           <u>ND</u>

                     ND is INTEGER
                     The number of converged eigenvalues uncovered by this
                     subroutine.

           <u>SH</u>

                     SH is COMPLEX*16 array, dimension (KBOT)
                     On output, approximate eigenvalues that may
                     be used for shifts are stored in SH(KBOT-ND-NS+1)
                     through SR(KBOT-ND).  Converged eigenvalues are
                     stored in SH(KBOT-ND+1) through SH(KBOT).

           <u>V</u>

                     V is COMPLEX*16 array, dimension (LDV,NW)
                     An NW-by-NW work array.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of V just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>NH</u>

                     NH is INTEGER
                     The number of columns of T.  NH &gt;= NW.

           <u>T</u>

                     T is COMPLEX*16 array, dimension (LDT,NW)

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of T just as declared in the
                     calling subroutine.  NW &lt;= LDT

           <u>NV</u>

                     NV is INTEGER
                     The number of rows of work array WV available for
                     workspace.  NV &gt;= NW.

           <u>WV</u>

                     WV is COMPLEX*16 array, dimension (LDWV,NW)

           <u>LDWV</u>

                     LDWV is INTEGER
                     The leading dimension of W just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (LWORK)
                     On exit, <a href="../man1/WORK.1.html">WORK</a>(1) is set to an estimate of the optimal value
                     of LWORK for the given values of N, NW, KTOP and KBOT.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the work array WORK.  LWORK = 2*NW
                     suffices, but greater efficiency may result from larger
                     values of LWORK.

                     If LWORK = -1, then a workspace query is assumed; ZLAQR2
                     only estimates the optimal workspace size for the given
                     values of N, NW, KTOP and KBOT.  The estimate is returned
                     in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is issued
                     by XERBLA.  Neither H nor Z are accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

   <b>subroutine</b> <b>zlaqr3</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KTOP,</b> <b>integer</b> <b>KBOT,</b> <b>integer</b> <b>NW,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b>
       <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer</b> <b>NS,</b> <b>integer</b> <b>ND,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SH,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b>
       <b>V,</b> <b>integer</b> <b>LDV,</b> <b>integer</b> <b>NH,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>integer</b> <b>NV,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldwv,</b> <b>*</b> <b>)</b> <b>WV,</b> <b>integer</b> <b>LDWV,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK)</b>
       <b>ZLAQR3</b> performs the unitary similarity transformation of a Hessenberg matrix to detect and deflate fully
       converged eigenvalues from a trailing principal submatrix (aggressive early deflation).

       <b>Purpose:</b>

               Aggressive early deflation:

               ZLAQR3 accepts as input an upper Hessenberg matrix
               H and performs an unitary similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.  On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an unitary similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     If .TRUE., then the Hessenberg matrix H is fully updated
                     so that the triangular Schur factor may be
                     computed (in cooperation with the calling subroutine).
                     If .FALSE., then only enough of H is updated to preserve
                     the eigenvalues.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     If .TRUE., then the unitary matrix Z is updated so
                     so that the unitary Schur factor may be computed
                     (in cooperation with the calling subroutine).
                     If .FALSE., then Z is not referenced.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H and (if WANTZ is .TRUE.) the
                     order of the unitary matrix Z.

           <u>KTOP</u>

                     KTOP is INTEGER
                     It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
                     KBOT and KTOP together determine an isolated block
                     along the diagonal of the Hessenberg matrix.

           <u>KBOT</u>

                     KBOT is INTEGER
                     It is assumed without a check that either
                     KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
                     determine an isolated block along the diagonal of the
                     Hessenberg matrix.

           <u>NW</u>

                     NW is INTEGER
                     Deflation window size.  1 &lt;= NW &lt;= (KBOT-KTOP+1).

           <u>H</u>

                     H is COMPLEX*16 array, dimension (LDH,N)
                     On input the initial N-by-N section of H stores the
                     Hessenberg matrix undergoing aggressive early deflation.
                     On output H has been transformed by a unitary
                     similarity transformation, perturbed, and the returned
                     to Hessenberg form that (it is to be hoped) has some
                     zero subdiagonal entries.

           <u>LDH</u>

                     LDH is INTEGER
                     Leading dimension of H just as declared in the calling
                     subroutine.  N &lt;= LDH

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                     Specify the rows of Z to which transformations must be
                     applied if WANTZ is .TRUE.. 1 &lt;= ILOZ &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (LDZ,N)
                     IF WANTZ is .TRUE., then on output, the unitary
                     similarity transformation mentioned above has been
                     accumulated into Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right.
                     If WANTZ is .FALSE., then Z is unreferenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of Z just as declared in the
                     calling subroutine.  1 &lt;= LDZ.

           <u>NS</u>

                     NS is INTEGER
                     The number of unconverged (ie approximate) eigenvalues
                     returned in SR and SI that may be used as shifts by the
                     calling subroutine.

           <u>ND</u>

                     ND is INTEGER
                     The number of converged eigenvalues uncovered by this
                     subroutine.

           <u>SH</u>

                     SH is COMPLEX*16 array, dimension (KBOT)
                     On output, approximate eigenvalues that may
                     be used for shifts are stored in SH(KBOT-ND-NS+1)
                     through SR(KBOT-ND).  Converged eigenvalues are
                     stored in SH(KBOT-ND+1) through SH(KBOT).

           <u>V</u>

                     V is COMPLEX*16 array, dimension (LDV,NW)
                     An NW-by-NW work array.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of V just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>NH</u>

                     NH is INTEGER
                     The number of columns of T.  NH &gt;= NW.

           <u>T</u>

                     T is COMPLEX*16 array, dimension (LDT,NW)

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of T just as declared in the
                     calling subroutine.  NW &lt;= LDT

           <u>NV</u>

                     NV is INTEGER
                     The number of rows of work array WV available for
                     workspace.  NV &gt;= NW.

           <u>WV</u>

                     WV is COMPLEX*16 array, dimension (LDWV,NW)

           <u>LDWV</u>

                     LDWV is INTEGER
                     The leading dimension of W just as declared in the
                     calling subroutine.  NW &lt;= LDV

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (LWORK)
                     On exit, <a href="../man1/WORK.1.html">WORK</a>(1) is set to an estimate of the optimal value
                     of LWORK for the given values of N, NW, KTOP and KBOT.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the work array WORK.  LWORK = 2*NW
                     suffices, but greater efficiency may result from larger
                     values of LWORK.

                     If LWORK = -1, then a workspace query is assumed; ZLAQR3
                     only estimates the optimal workspace size for the given
                     values of N, NW, KTOP and KBOT.  The estimate is returned
                     in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is issued
                     by XERBLA.  Neither H nor Z are accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

   <b>subroutine</b> <b>zlaqr4</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>complex*16,</b> <b>dimension(</b>
       <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>integer</b> <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>complex*16,</b> <b>dimension(</b>
       <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLAQR4</b> computes the eigenvalues of a Hessenberg matrix, and optionally the matrices from the Schur
       decomposition.

       <b>Purpose:</b>

               ZLAQR4 implements one level of recursion for ZLAQR0.
               It is a complete implementation of the small bulge multi-shift
               QR algorithm.  It may be called by ZLAQR0 and, for large enough
               deflation window size, it may be called by ZLAQR3.  This
               subroutine is identical to ZLAQR0 except that it calls ZLAQR2
               instead of ZLAQR3.

               ZLAQR4 computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**H, where T is an upper triangular matrix (the
               Schur form), and Z is the unitary matrix of Schur vectors.

               Optionally Z may be postmultiplied into an input unitary
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                     = .TRUE. : the full Schur form T is required;
                     = .FALSE.: only eigenvalues are required.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     = .TRUE. : the matrix of Schur vectors Z is required;
                     = .FALSE.: Schur vectors are not required.

           <u>N</u>

                     N is INTEGER
                      The order of the matrix H.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER
                      It is assumed that H is already upper triangular in rows
                      and columns 1:ILO-1 and IHI+1:N and, if ILO &gt; 1,
                      H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
                      previous call to ZGEBAL, and then passed to ZGEHRD when the
                      matrix output by ZGEBAL is reduced to Hessenberg form.
                      Otherwise, ILO and IHI should be set to 1 and N,
                      respectively.  If N &gt; 0, then 1 &lt;= ILO &lt;= IHI &lt;= N.
                      If N = 0, then ILO = 1 and IHI = 0.

           <u>H</u>

                     H is COMPLEX*16 array, dimension (LDH,N)
                      On entry, the upper Hessenberg matrix H.
                      On exit, if INFO = 0 and WANTT is .TRUE., then H
                      contains the upper triangular matrix T from the Schur
                      decomposition (the Schur form). If INFO = 0 and WANT is
                      .FALSE., then the contents of H are unspecified on exit.
                      (The output value of H when INFO &gt; 0 is given under the
                      description of INFO below.)

                      This subroutine may explicitly set H(i,j) = 0 for i &gt; j and
                      j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.

           <u>LDH</u>

                     LDH is INTEGER
                      The leading dimension of the array H. LDH &gt;= max(1,N).

           <u>W</u>

                     W is COMPLEX*16 array, dimension (N)
                      The computed eigenvalues of H(ILO:IHI,ILO:IHI) are stored
                      in W(ILO:IHI). If WANTT is .TRUE., then the eigenvalues are
                      stored in the same order as on the diagonal of the Schur
                      form returned in H, with W(i) = H(i,i).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                      Specify the rows of Z to which transformations must be
                      applied if WANTZ is .TRUE..
                      1 &lt;= ILOZ &lt;= ILO; IHI &lt;= IHIZ &lt;= N.

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (LDZ,IHI)
                      If WANTZ is .FALSE., then Z is not referenced.
                      If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
                      replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
                      orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
                      (The output value of Z when INFO &gt; 0 is given under
                      the description of INFO below.)

           <u>LDZ</u>

                     LDZ is INTEGER
                      The leading dimension of the array Z.  if WANTZ is .TRUE.
                      then LDZ &gt;= MAX(1,IHIZ).  Otherwise, LDZ &gt;= 1.

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension LWORK
                      On exit, if LWORK = -1, <a href="../man1/WORK.1.html">WORK</a>(1) returns an estimate of
                      the optimal value for LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK.  LWORK &gt;= max(1,N)
                      is sufficient, but LWORK typically as large as 6*N may
                      be required for optimal performance.  A workspace query
                      to determine the optimal workspace size is recommended.

                      If LWORK = -1, then ZLAQR4 does a workspace query.
                      In this case, ZLAQR4 checks the input parameters and
                      estimates the optimal workspace size for the given
                      values of N, ILO and IHI.  The estimate is returned
                      in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is
                      issued by XERBLA.  Neither H nor Z are accessed.

           <u>INFO</u>

                     INFO is INTEGER
                        =  0:  successful exit
                        &gt; 0:  if INFO = i, ZLAQR4 failed to compute all of
                           the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                           and WI contain those eigenvalues which have been
                           successfully computed.  (Failures are rare.)

                           If INFO &gt; 0 and WANT is .FALSE., then on exit,
                           the remaining unconverged eigenvalues are the eigen-
                           values of the upper Hessenberg matrix rows and
                           columns ILO through INFO of the final, output
                           value of H.

                           If INFO &gt; 0 and WANTT is .TRUE., then on exit

                      (*)  (initial value of H)*U  = U*(final value of H)

                           where U is a unitary matrix.  The final
                           value of  H is upper Hessenberg and triangular in
                           rows and columns INFO+1 through IHI.

                           If INFO &gt; 0 and WANTZ is .TRUE., then on exit

                             (final value of Z(ILO:IHI,ILOZ:IHIZ)
                              =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U

                           where U is the unitary matrix in (*) (regard-
                           less of the value of WANTT.)

                           If INFO &gt; 0 and WANTZ is .FALSE., then Z is not
                           accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

       <b>References:</b>

             K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
             Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
             Performance, SIAM Journal of Matrix Analysis, volume 23, pages
             929--947, 2002.

            K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part II: Aggressive Early
           Deflation, SIAM Journal of Matrix Analysis, volume 23, pages 948--973, 2002.

   <b>subroutine</b> <b>zlaqr5</b> <b>(logical</b> <b>WANTT,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>KACC22,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KTOP,</b> <b>integer</b> <b>KBOT,</b>
       <b>integer</b> <b>NSHFTS,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>integer</b>
       <b>ILOZ,</b> <b>integer</b> <b>IHIZ,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b>
       <b>integer</b> <b>LDV,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>integer</b> <b>NV,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldwv,</b> <b>*</b> <b>)</b>
       <b>WV,</b> <b>integer</b> <b>LDWV,</b> <b>integer</b> <b>NH,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldwh,</b> <b>*</b> <b>)</b> <b>WH,</b> <b>integer</b> <b>LDWH)</b>
       <b>ZLAQR5</b> performs a single small-bulge multi-shift QR sweep.

       <b>Purpose:</b>

               ZLAQR5, called by ZLAQR0, performs a
               single small-bulge multi-shift QR sweep.

       <b>Parameters</b>
           <u>WANTT</u>

                     WANTT is LOGICAL
                        WANTT = .true. if the triangular Schur factor
                        is being computed.  WANTT is set to .false. otherwise.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                        WANTZ = .true. if the unitary Schur factor is being
                        computed.  WANTZ is set to .false. otherwise.

           <u>KACC22</u>

                     KACC22 is INTEGER with value 0, 1, or 2.
                        Specifies the computation mode of far-from-diagonal
                        orthogonal updates.
                   = 0: ZLAQR5 does not accumulate reflections and does not
                        use matrix-matrix multiply to update far-from-diagonal
                        matrix entries.
                   = 1: ZLAQR5 accumulates reflections and uses matrix-matrix
                        multiply to update the far-from-diagonal matrix entries.
                   = 2: Same as KACC22 = 1. This option used to enable exploiting
                        the 2-by-2 structure during matrix multiplications, but
                        this is no longer supported.

           <u>N</u>

                     N is INTEGER
                        N is the order of the Hessenberg matrix H upon which this
                        subroutine operates.

           <u>KTOP</u>

                     KTOP is INTEGER

           <u>KBOT</u>

                     KBOT is INTEGER
                        These are the first and last rows and columns of an
                        isolated diagonal block upon which the QR sweep is to be
                        applied. It is assumed without a check that
                                  either KTOP = 1  or   H(KTOP,KTOP-1) = 0
                        and
                                  either KBOT = N  or   H(KBOT+1,KBOT) = 0.

           <u>NSHFTS</u>

                     NSHFTS is INTEGER
                        NSHFTS gives the number of simultaneous shifts.  NSHFTS
                        must be positive and even.

           <u>S</u>

                     S is COMPLEX*16 array, dimension (NSHFTS)
                        S contains the shifts of origin that define the multi-
                        shift QR sweep.  On output S may be reordered.

           <u>H</u>

                     H is COMPLEX*16 array, dimension (LDH,N)
                        On input H contains a Hessenberg matrix.  On output a
                        multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
                        to the isolated diagonal block in rows and columns KTOP
                        through KBOT.

           <u>LDH</u>

                     LDH is INTEGER
                        LDH is the leading dimension of H just as declared in the
                        calling procedure.  LDH &gt;= MAX(1,N).

           <u>ILOZ</u>

                     ILOZ is INTEGER

           <u>IHIZ</u>

                     IHIZ is INTEGER
                        Specify the rows of Z to which transformations must be
                        applied if WANTZ is .TRUE.. 1 &lt;= ILOZ &lt;= IHIZ &lt;= N

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (LDZ,IHIZ)
                        If WANTZ = .TRUE., then the QR Sweep unitary
                        similarity transformation is accumulated into
                        Z(ILOZ:IHIZ,ILOZ:IHIZ) from the right.
                        If WANTZ = .FALSE., then Z is unreferenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                        LDA is the leading dimension of Z just as declared in
                        the calling procedure. LDZ &gt;= N.

           <u>V</u>

                     V is COMPLEX*16 array, dimension (LDV,NSHFTS/2)

           <u>LDV</u>

                     LDV is INTEGER
                        LDV is the leading dimension of V as declared in the
                        calling procedure.  LDV &gt;= 3.

           <u>U</u>

                     U is COMPLEX*16 array, dimension (LDU,2*NSHFTS)

           <u>LDU</u>

                     LDU is INTEGER
                        LDU is the leading dimension of U just as declared in the
                        in the calling subroutine.  LDU &gt;= 2*NSHFTS.

           <u>NV</u>

                     NV is INTEGER
                        NV is the number of rows in WV agailable for workspace.
                        NV &gt;= 1.

           <u>WV</u>

                     WV is COMPLEX*16 array, dimension (LDWV,2*NSHFTS)

           <u>LDWV</u>

                     LDWV is INTEGER
                        LDWV is the leading dimension of WV as declared in the
                        in the calling subroutine.  LDWV &gt;= NV.

           <u>NH</u>

                     NH is INTEGER
                        NH is the number of columns in array WH available for
                        workspace. NH &gt;= 1.

           <u>WH</u>

                     WH is COMPLEX*16 array, dimension (LDWH,NH)

           <u>LDWH</u>

                     LDWH is INTEGER
                        Leading dimension of WH just as declared in the
                        calling procedure.  LDWH &gt;= 2*NSHFTS.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

       Lars Karlsson, Daniel Kressner, and Bruno Lang

       Thijs Steel, Department of Computer science, KU Leuven, Belgium

       <b>References:</b>
           K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part I: Maintaining Well Focused
           Shifts, and Level 3 Performance, SIAM Journal of Matrix Analysis, volume 23, pages 929--947, 2002.

       Lars Karlsson, Daniel Kressner, and Bruno Lang, Optimally packed chains of bulges in multishift QR
       algorithms. ACM Trans. Math. Softw. 40, 2, Article 12 (February 2014).

   <b>subroutine</b> <b>zlaqsb</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>double</b> <b>precision</b> <b>SCOND,</b> <b>double</b> <b>precision</b> <b>AMAX,</b> <b>character</b> <b>EQUED)</b>
       <b>ZLAQSB</b> scales a symmetric/Hermitian band matrix, using scaling factors computed by spbequ.

       <b>Purpose:</b>

            ZLAQSB equilibrates a symmetric band matrix A using the scaling
            factors in the vector S.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is stored.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of super-diagonals of the matrix A if UPLO = 'U',
                     or the number of sub-diagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX*16 array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the symmetric band
                     matrix A, stored in the first KD+1 rows of the array.  The
                     j-th column of A is stored in the j-th column of the array AB
                     as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

                     On exit, if INFO = 0, the triangular factor U or L from the
                     Cholesky factorization A = U**H *U or A = L*L**H of the band
                     matrix A, in the same storage format as A.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (N)
                     The scale factors for A.

           <u>SCOND</u>

                     SCOND is DOUBLE PRECISION
                     Ratio of the smallest S(i) to the largest S(i).

           <u>AMAX</u>

                     AMAX is DOUBLE PRECISION
                     Absolute value of largest matrix entry.

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                     Specifies whether or not equilibration was done.
                     = 'N':  No equilibration.
                     = 'Y':  Equilibration was done, i.e., A has been replaced by
                             diag(S) * A * diag(S).

       <b>Internal</b> <b>Parameters:</b>

             THRESH is a threshold value used to decide if scaling should be done
             based on the ratio of the scaling factors.  If SCOND &lt; THRESH,
             scaling is done.

             LARGE and SMALL are threshold values used to decide if scaling should
             be done based on the absolute size of the largest matrix element.
             If AMAX &gt; LARGE or AMAX &lt; SMALL, scaling is done.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlaqsp</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>S,</b> <b>double</b> <b>precision</b> <b>SCOND,</b> <b>double</b> <b>precision</b> <b>AMAX,</b> <b>character</b> <b>EQUED)</b>
       <b>ZLAQSP</b> scales a symmetric/Hermitian matrix in packed storage, using scaling factors computed by sppequ.

       <b>Purpose:</b>

            ZLAQSP equilibrates a symmetric matrix A using the scaling factors
            in the vector S.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is stored.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the symmetric matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

                     On exit, the equilibrated matrix:  diag(S) * A * diag(S), in
                     the same storage format as A.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (N)
                     The scale factors for A.

           <u>SCOND</u>

                     SCOND is DOUBLE PRECISION
                     Ratio of the smallest S(i) to the largest S(i).

           <u>AMAX</u>

                     AMAX is DOUBLE PRECISION
                     Absolute value of largest matrix entry.

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                     Specifies whether or not equilibration was done.
                     = 'N':  No equilibration.
                     = 'Y':  Equilibration was done, i.e., A has been replaced by
                             diag(S) * A * diag(S).

       <b>Internal</b> <b>Parameters:</b>

             THRESH is a threshold value used to decide if scaling should be done
             based on the ratio of the scaling factors.  If SCOND &lt; THRESH,
             scaling is done.

             LARGE and SMALL are threshold values used to decide if scaling should
             be done based on the absolute size of the largest matrix element.
             If AMAX &gt; LARGE or AMAX &lt; SMALL, scaling is done.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlar1v</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>B1,</b> <b>integer</b> <b>BN,</b> <b>double</b> <b>precision</b> <b>LAMBDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>L,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>LD,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>LLD,</b> <b>double</b> <b>precision</b> <b>PIVMIN,</b> <b>double</b> <b>precision</b> <b>GAPTOL,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b>
       <b>logical</b> <b>WANTNC,</b> <b>integer</b> <b>NEGCNT,</b> <b>double</b> <b>precision</b> <b>ZTZ,</b> <b>double</b> <b>precision</b> <b>MINGMA,</b> <b>integer</b> <b>R,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>ISUPPZ,</b> <b>double</b> <b>precision</b> <b>NRMINV,</b> <b>double</b> <b>precision</b> <b>RESID,</b> <b>double</b> <b>precision</b> <b>RQCORR,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLAR1V</b> computes the (scaled) r-th column of the inverse of the submatrix in rows b1 through bn of the
       tridiagonal matrix LDLT - λI.

       <b>Purpose:</b>

            ZLAR1V computes the (scaled) r-th column of the inverse of
            the sumbmatrix in rows B1 through BN of the tridiagonal matrix
            L D L**T - sigma I. When sigma is close to an eigenvalue, the
            computed vector is an accurate eigenvector. Usually, r corresponds
            to the index where the eigenvector is largest in magnitude.
            The following steps accomplish this computation :
            (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
            (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
            (c) Computation of the diagonal elements of the inverse of
                L D L**T - sigma I by combining the above transforms, and choosing
                r as the index where the diagonal of the inverse is (one of the)
                largest in magnitude.
            (d) Computation of the (scaled) r-th column of the inverse using the
                twisted factorization obtained by combining the top part of the
                the stationary and the bottom part of the progressive transform.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                      The order of the matrix L D L**T.

           <u>B1</u>

                     B1 is INTEGER
                      First index of the submatrix of L D L**T.

           <u>BN</u>

                     BN is INTEGER
                      Last index of the submatrix of L D L**T.

           <u>LAMBDA</u>

                     LAMBDA is DOUBLE PRECISION
                      The shift. In order to compute an accurate eigenvector,
                      LAMBDA should be a good approximation to an eigenvalue
                      of L D L**T.

           <u>L</u>

                     L is DOUBLE PRECISION array, dimension (N-1)
                      The (n-1) subdiagonal elements of the unit bidiagonal matrix
                      L, in elements 1 to N-1.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                      The n diagonal elements of the diagonal matrix D.

           <u>LD</u>

                     LD is DOUBLE PRECISION array, dimension (N-1)
                      The n-1 elements L(i)*D(i).

           <u>LLD</u>

                     LLD is DOUBLE PRECISION array, dimension (N-1)
                      The n-1 elements L(i)*L(i)*D(i).

           <u>PIVMIN</u>

                     PIVMIN is DOUBLE PRECISION
                      The minimum pivot in the Sturm sequence.

           <u>GAPTOL</u>

                     GAPTOL is DOUBLE PRECISION
                      Tolerance that indicates when eigenvector entries are negligible
                      w.r.t. their contribution to the residual.

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (N)
                      On input, all entries of Z must be set to 0.
                      On output, Z contains the (scaled) r-th column of the
                      inverse. The scaling is such that Z(R) equals 1.

           <u>WANTNC</u>

                     WANTNC is LOGICAL
                      Specifies whether NEGCNT has to be computed.

           <u>NEGCNT</u>

                     NEGCNT is INTEGER
                      If WANTNC is .TRUE. then NEGCNT = the number of pivots &lt; pivmin
                      in the  matrix factorization L D L**T, and NEGCNT = -1 otherwise.

           <u>ZTZ</u>

                     ZTZ is DOUBLE PRECISION
                      The square of the 2-norm of Z.

           <u>MINGMA</u>

                     MINGMA is DOUBLE PRECISION
                      The reciprocal of the largest (in magnitude) diagonal
                      element of the inverse of L D L**T - sigma I.

           <u>R</u>

                     R is INTEGER
                      The twist index for the twisted factorization used to
                      compute Z.
                      On input, 0 &lt;= R &lt;= N. If R is input as 0, R is set to
                      the index where (L D L**T - sigma I)^{-1} is largest
                      in magnitude. If 1 &lt;= R &lt;= N, R is unchanged.
                      On output, R contains the twist index used to compute Z.
                      Ideally, R designates the position of the maximum entry in the
                      eigenvector.

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension (2)
                      The support of the vector in Z, i.e., the vector Z is
                      nonzero only in elements <a href="../man1/ISUPPZ.1.html">ISUPPZ</a>(1) through ISUPPZ( 2 ).

           <u>NRMINV</u>

                     NRMINV is DOUBLE PRECISION
                      NRMINV = 1/SQRT( ZTZ )

           <u>RESID</u>

                     RESID is DOUBLE PRECISION
                      The residual of the FP vector.
                      RESID = ABS( MINGMA )/SQRT( ZTZ )

           <u>RQCORR</u>

                     RQCORR is DOUBLE PRECISION
                      The Rayleigh Quotient correction to LAMBDA.
                      RQCORR = MINGMA*TMP

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (4*N)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Beresford Parlett, University of California, Berkeley, USA
            Jim Demmel, University of California, Berkeley, USA
            Inderjit Dhillon, University of Texas, Austin, USA
            Osni Marques, LBNL/NERSC, USA
            Christof Voemel, University of California, Berkeley, USA

   <b>subroutine</b> <b>zlar2v</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>INCX,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>integer</b>
       <b>INCC)</b>
       <b>ZLAR2V</b> applies a vector of plane rotations with real cosines and complex sines from both sides to a
       sequence of 2-by-2 symmetric/Hermitian matrices.

       <b>Purpose:</b>

            ZLAR2V applies a vector of complex plane rotations with real cosines
            from both sides to a sequence of 2-by-2 complex Hermitian matrices,
            defined by the elements of the vectors x, y and z. For i = 1,2,...,n

               (       x(i)  z(i) ) :=
               ( conjg(z(i)) y(i) )

                 (  c(i) conjg(s(i)) ) (       x(i)  z(i) ) ( c(i) -conjg(s(i)) )
                 ( -s(i)       c(i)  ) ( conjg(z(i)) y(i) ) ( s(i)        c(i)  )

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of plane rotations to be applied.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (1+(N-1)*INCX)
                     The vector x; the elements of x are assumed to be real.

           <u>Y</u>

                     Y is COMPLEX*16 array, dimension (1+(N-1)*INCX)
                     The vector y; the elements of y are assumed to be real.

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (1+(N-1)*INCX)
                     The vector z.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X, Y and Z. INCX &gt; 0.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
                     The cosines of the plane rotations.

           <u>S</u>

                     S is COMPLEX*16 array, dimension (1+(N-1)*INCC)
                     The sines of the plane rotations.

           <u>INCC</u>

                     INCC is INTEGER
                     The increment between elements of C and S. INCC &gt; 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlarcm</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK)</b>
       <b>ZLARCM</b> copies all or part of a real two-dimensional array to a complex array.

       <b>Purpose:</b>

            ZLARCM performs a very simple matrix-matrix multiplication:
                     C := A * B,
            where A is M by M and real; B is M by N and complex;
            C is M by N and complex.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A and of the matrix C.
                     M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns and rows of the matrix B and
                     the number of columns of the matrix C.
                     N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA, M)
                     On entry, A contains the M by M matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;=max(1,M).

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB, N)
                     On entry, B contains the M by N matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;=max(1,M).

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC, N)
                     On exit, C contains the M by N matrix C.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;=max(1,M).

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (2*M*N)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlarf</b> <b>(character</b> <b>SIDE,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>INCV,</b>
       <b>complex*16</b> <b>TAU,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLARF</b> applies an elementary reflector to a general rectangular matrix.

       <b>Purpose:</b>

            ZLARF applies a complex elementary reflector H to a complex M-by-N
            matrix C, from either the left or the right. H is represented in the
            form

                  H = I - tau * v * v**H

            where tau is a complex scalar and v is a complex vector.

            If tau = 0, then H is taken to be the unit matrix.

            To apply H**H, supply conjg(tau) instead
            tau.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': form  H * C
                     = 'R': form  C * H

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C.

           <u>V</u>

                     V is COMPLEX*16 array, dimension
                                (1 + (M-1)*abs(INCV)) if SIDE = 'L'
                             or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
                     The vector v in the representation of H. V is not used if
                     TAU = 0.

           <u>INCV</u>

                     INCV is INTEGER
                     The increment between elements of v. INCV &lt;&gt; 0.

           <u>TAU</u>

                     TAU is COMPLEX*16
                     The value tau in the representation of H.

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by the matrix H * C if SIDE = 'L',
                     or C * H if SIDE = 'R'.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension
                                    (N) if SIDE = 'L'
                                 or (M) if SIDE = 'R'

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlarfb</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIRECT,</b> <b>character</b> <b>STOREV,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b>
       <b>integer</b> <b>K,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b>
       <b>LDT,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldwork,</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b>
       <b>LDWORK)</b>
       <b>ZLARFB</b> applies a block reflector or its conjugate-transpose to a general rectangular matrix.

       <b>Purpose:</b>

            ZLARFB applies a complex block reflector H or its transpose H**H to a
            complex M-by-N matrix C, from either the left or the right.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply H or H**H from the Left
                     = 'R': apply H or H**H from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply H (No transpose)
                     = 'C': apply H**H (Conjugate transpose)

           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Indicates how H is formed from a product of elementary
                     reflectors
                     = 'F': H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) (Forward)
                     = 'B': H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) (Backward)

           <u>STOREV</u>

                     STOREV is CHARACTER*1
                     Indicates how the vectors which define the elementary
                     reflectors are stored:
                     = 'C': Columnwise
                     = 'R': Rowwise

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C.

           <u>K</u>

                     K is INTEGER
                     The order of the matrix T (= the number of elementary
                     reflectors whose product defines the block reflector).
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>V</u>

                     V is COMPLEX*16 array, dimension
                                           (LDV,K) if STOREV = 'C'
                                           (LDV,M) if STOREV = 'R' and SIDE = 'L'
                                           (LDV,N) if STOREV = 'R' and SIDE = 'R'
                     See Further Details.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If STOREV = 'C' and SIDE = 'L', LDV &gt;= max(1,M);
                     if STOREV = 'C' and SIDE = 'R', LDV &gt;= max(1,N);
                     if STOREV = 'R', LDV &gt;= K.

           <u>T</u>

                     T is COMPLEX*16 array, dimension (LDT,K)
                     The triangular K-by-K matrix T in the representation of the
                     block reflector.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= K.

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by H*C or H**H*C or C*H or C*H**H.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (LDWORK,K)

           <u>LDWORK</u>

                     LDWORK is INTEGER
                     The leading dimension of the array WORK.
                     If SIDE = 'L', LDWORK &gt;= max(1,N);
                     if SIDE = 'R', LDWORK &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The shape of the matrix V and the storage of the vectors which define
             the H(i) is best illustrated by the following example with n = 5 and
             k = 3. The elements equal to 1 are not stored; the corresponding
             array elements are modified but restored on exit. The rest of the
             array is not used.

             DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':

                          V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                              ( v1  1    )                     (     1 v2 v2 v2 )
                              ( v1 v2  1 )                     (        1 v3 v3 )
                              ( v1 v2 v3 )
                              ( v1 v2 v3 )

             DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':

                          V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                              ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                              (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                              (     1 v3 )
                              (        1 )

   <b>subroutine</b> <b>zlarfb_gett</b> <b>(character</b> <b>IDENT,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b>
       <b>integer</b> <b>LDT,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b>
       <b>LDB,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldwork,</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LDWORK)</b>
       <b>ZLARFB_GETT</b>

       <b>Purpose:</b>

            ZLARFB_GETT applies a complex Householder block reflector H from the
            left to a complex (K+M)-by-N  "triangular-pentagonal" matrix
            composed of two block matrices: an upper trapezoidal K-by-N matrix A
            stored in the array A, and a rectangular M-by-(N-K) matrix B, stored
            in the array B. The block reflector H is stored in a compact
            WY-representation, where the elementary reflectors are in the
            arrays A, B and T. See Further Details section.

       <b>Parameters</b>
           <u>IDENT</u>

                     IDENT is CHARACTER*1
                     If IDENT = not 'I', or not 'i', then V1 is unit
                        lower-triangular and stored in the left K-by-K block of
                        the input matrix A,
                     If IDENT = 'I' or 'i', then  V1 is an identity matrix and
                        not stored.
                     See Further Details section.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix B.
                     M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrices A and B.
                     N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number or rows of the matrix A.
                     K is also order of the matrix T, i.e. the number of
                     elementary reflectors whose product defines the block
                     reflector. 0 &lt;= K &lt;= N.

           <u>T</u>

                     T is COMPLEX*16 array, dimension (LDT,K)
                     The upper-triangular K-by-K matrix T in the representation
                     of the block reflector.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= K.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)

                     On entry:
                      a) In the K-by-N upper-trapezoidal part A: input matrix A.
                      b) In the columns below the diagonal: columns of V1
                         (ones are not stored on the diagonal).

                     On exit:
                       A is overwritten by rectangular K-by-N product H*A.

                     See Further Details section.

           <u>LDA</u>

                     LDB is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,K).

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,N)

                     On entry:
                       a) In the M-by-(N-K) right block: input matrix B.
                       b) In the M-by-N left block: columns of V2.

                     On exit:
                       B is overwritten by rectangular M-by-N product H*B.

                     See Further Details section.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX*16 array,
                     dimension (LDWORK,max(K,N-K))

           <u>LDWORK</u>

                     LDWORK is INTEGER
                     The leading dimension of the array WORK. LDWORK&gt;=max(1,K).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

            November 2020, Igor Kozachenko,
                           Computer Science Division,
                           University of California, Berkeley

       <b>Further</b> <b>Details:</b>

               (1) Description of the Algebraic Operation.

               The matrix A is a K-by-N matrix composed of two column block
               matrices, A1, which is K-by-K, and A2, which is K-by-(N-K):
               A = ( A1, A2 ).
               The matrix B is an M-by-N matrix composed of two column block
               matrices, B1, which is M-by-K, and B2, which is M-by-(N-K):
               B = ( B1, B2 ).

               Perform the operation:

                  ( A_out ) := H * ( A_in ) = ( I - V * T * V**H ) * ( A_in ) =
                  ( B_out )        ( B_in )                          ( B_in )
                             = ( I - ( V1 ) * T * ( V1**H, V2**H ) ) * ( A_in )
                                     ( V2 )                            ( B_in )
                On input:

               a) ( A_in )  consists of two block columns:
                  ( B_in )

                  ( A_in ) = (( A1_in ) ( A2_in )) = (( A1_in ) ( A2_in ))
                  ( B_in )   (( B1_in ) ( B2_in ))   ((     0 ) ( B2_in )),

                  where the column blocks are:

                  (  A1_in )  is a K-by-K upper-triangular matrix stored in the
                              upper triangular part of the array A(1:K,1:K).
                  (  B1_in )  is an M-by-K rectangular ZERO matrix and not stored.

                  ( A2_in )  is a K-by-(N-K) rectangular matrix stored
                             in the array A(1:K,K+1:N).
                  ( B2_in )  is an M-by-(N-K) rectangular matrix stored
                             in the array B(1:M,K+1:N).

               b) V = ( V1 )
                      ( V2 )

                  where:
                  1) if IDENT == 'I',V1 is a K-by-K identity matrix, not stored;
                  2) if IDENT != 'I',V1 is a K-by-K unit lower-triangular matrix,
                     stored in the lower-triangular part of the array
                     A(1:K,1:K) (ones are not stored),
                  and V2 is an M-by-K rectangular stored the array B(1:M,1:K),
                            (because on input B1_in is a rectangular zero
                             matrix that is not stored and the space is
                             used to store V2).

               c) T is a K-by-K upper-triangular matrix stored
                  in the array T(1:K,1:K).

               On output:

               a) ( A_out ) consists of two  block columns:
                  ( B_out )

                  ( A_out ) = (( A1_out ) ( A2_out ))
                  ( B_out )   (( B1_out ) ( B2_out )),

                  where the column blocks are:

                  ( A1_out )  is a K-by-K square matrix, or a K-by-K
                              upper-triangular matrix, if V1 is an
                              identity matrix. AiOut is stored in
                              the array A(1:K,1:K).
                  ( B1_out )  is an M-by-K rectangular matrix stored
                              in the array B(1:M,K:N).

                  ( A2_out )  is a K-by-(N-K) rectangular matrix stored
                              in the array A(1:K,K+1:N).
                  ( B2_out )  is an M-by-(N-K) rectangular matrix stored
                              in the array B(1:M,K+1:N).

               The operation above can be represented as the same operation
               on each block column:

                  ( A1_out ) := H * ( A1_in ) = ( I - V * T * V**H ) * ( A1_in )
                  ( B1_out )        (     0 )                          (     0 )

                  ( A2_out ) := H * ( A2_in ) = ( I - V * T * V**H ) * ( A2_in )
                  ( B2_out )        ( B2_in )                          ( B2_in )

               If IDENT != 'I':

                  The computation for column block 1:

                  A1_out: = A1_in - V1*T*(V1**H)*A1_in

                  B1_out: = - V2*T*(V1**H)*A1_in

                  The computation for column block 2, which exists if N &gt; K:

                  A2_out: = A2_in - V1*T*( (V1**H)*A2_in + (V2**H)*B2_in )

                  B2_out: = B2_in - V2*T*( (V1**H)*A2_in + (V2**H)*B2_in )

               If IDENT == 'I':

                  The operation for column block 1:

                  A1_out: = A1_in - V1*T*A1_in

                  B1_out: = - V2*T*A1_in

                  The computation for column block 2, which exists if N &gt; K:

                  A2_out: = A2_in - T*( A2_in + (V2**H)*B2_in )

                  B2_out: = B2_in - V2*T*( A2_in + (V2**H)*B2_in )

               (2) Description of the Algorithmic Computation.

               In the first step, we compute column block 2, i.e. A2 and B2.
               Here, we need to use the K-by-(N-K) rectangular workspace
               matrix W2 that is of the same size as the matrix A2.
               W2 is stored in the array WORK(1:K,1:(N-K)).

               In the second step, we compute column block 1, i.e. A1 and B1.
               Here, we need to use the K-by-K square workspace matrix W1
               that is of the same size as the as the matrix A1.
               W1 is stored in the array WORK(1:K,1:K).

               NOTE: Hence, in this routine, we need the workspace array WORK
               only of size WORK(1:K,1:max(K,N-K)) so it can hold both W2 from
               the first step and W1 from the second step.

               Case (A), when V1 is unit lower-triangular, i.e. IDENT != 'I',
               more computations than in the Case (B).

               if( IDENT != 'I' ) then
                if ( N &gt; K ) then
                  (First Step - column block 2)
                  <a href="../man1/col2_.1.html">col2_</a>(1) W2: = A2
                  <a href="../man2/col2_.2.html">col2_</a>(2) W2: = (V1**H) * W2 = (unit_lower_tr_of_(A1)**H) * W2
                  <a href="../man3/col2_.3.html">col2_</a>(3) W2: = W2 + (V2**H) * B2 = W2 + (B1**H) * B2
                  <a href="../man4/col2_.4.html">col2_</a>(4) W2: = T * W2
                  <a href="../man5/col2_.5.html">col2_</a>(5) B2: = B2 - V2 * W2 = B2 - B1 * W2
                  <a href="../man6/col2_.6.html">col2_</a>(6) W2: = V1 * W2 = unit_lower_tr_of_(A1) * W2
                  <a href="../man7/col2_.7.html">col2_</a>(7) A2: = A2 - W2
                else
                  (Second Step - column block 1)
                  <a href="../man1/col1_.1.html">col1_</a>(1) W1: = A1
                  <a href="../man2/col1_.2.html">col1_</a>(2) W1: = (V1**H) * W1 = (unit_lower_tr_of_(A1)**H) * W1
                  <a href="../man3/col1_.3.html">col1_</a>(3) W1: = T * W1
                  <a href="../man4/col1_.4.html">col1_</a>(4) B1: = - V2 * W1 = - B1 * W1
                  <a href="../man5/col1_.5.html">col1_</a>(5) square W1: = V1 * W1 = unit_lower_tr_of_(A1) * W1
                  <a href="../man6/col1_.6.html">col1_</a>(6) square A1: = A1 - W1
                end if
               end if

               Case (B), when V1 is an identity matrix, i.e. IDENT == 'I',
               less computations than in the Case (A)

               if( IDENT == 'I' ) then
                if ( N &gt; K ) then
                  (First Step - column block 2)
                  <a href="../man1/col2_.1.html">col2_</a>(1) W2: = A2
                  <a href="../man3/col2_.3.html">col2_</a>(3) W2: = W2 + (V2**H) * B2 = W2 + (B1**H) * B2
                  <a href="../man4/col2_.4.html">col2_</a>(4) W2: = T * W2
                  <a href="../man5/col2_.5.html">col2_</a>(5) B2: = B2 - V2 * W2 = B2 - B1 * W2
                  <a href="../man7/col2_.7.html">col2_</a>(7) A2: = A2 - W2
                else
                  (Second Step - column block 1)
                  <a href="../man1/col1_.1.html">col1_</a>(1) W1: = A1
                  <a href="../man3/col1_.3.html">col1_</a>(3) W1: = T * W1
                  <a href="../man4/col1_.4.html">col1_</a>(4) B1: = - V2 * W1 = - B1 * W1
                  <a href="../man6/col1_.6.html">col1_</a>(6) upper-triangular_of_(A1): = A1 - W1
                end if
               end if

               Combine these cases (A) and (B) together, this is the resulting
               algorithm:

               if ( N &gt; K ) then

                 (First Step - column block 2)

                 <a href="../man1/col2_.1.html">col2_</a>(1)  W2: = A2
                 if( IDENT != 'I' ) then
                   <a href="../man2/col2_.2.html">col2_</a>(2)  W2: = (V1**H) * W2
                                 = (unit_lower_tr_of_(A1)**H) * W2
                 end if
                 <a href="../man3/col2_.3.html">col2_</a>(3)  W2: = W2 + (V2**H) * B2 = W2 + (B1**H) * B2]
                 <a href="../man4/col2_.4.html">col2_</a>(4)  W2: = T * W2
                 <a href="../man5/col2_.5.html">col2_</a>(5)  B2: = B2 - V2 * W2 = B2 - B1 * W2
                 if( IDENT != 'I' ) then
                   <a href="../man6/col2_.6.html">col2_</a>(6)    W2: = V1 * W2 = unit_lower_tr_of_(A1) * W2
                 end if
                 <a href="../man7/col2_.7.html">col2_</a>(7) A2: = A2 - W2

               else

               (Second Step - column block 1)

                 <a href="../man1/col1_.1.html">col1_</a>(1) W1: = A1
                 if( IDENT != 'I' ) then
                   <a href="../man2/col1_.2.html">col1_</a>(2) W1: = (V1**H) * W1
                               = (unit_lower_tr_of_(A1)**H) * W1
                 end if
                 <a href="../man3/col1_.3.html">col1_</a>(3) W1: = T * W1
                 <a href="../man4/col1_.4.html">col1_</a>(4) B1: = - V2 * W1 = - B1 * W1
                 if( IDENT != 'I' ) then
                   <a href="../man5/col1_.5.html">col1_</a>(5) square W1: = V1 * W1 = unit_lower_tr_of_(A1) * W1
                   <a href="../man6_a/col1_.6_a.html">col1_</a>(6_a) below_diag_of_(A1): =  - below_diag_of_(W1)
                 end if
                 <a href="../man6_b/col1_.6_b.html">col1_</a>(6_b) up_tr_of_(A1): = up_tr_of_(A1) - up_tr_of_(W1)

               end if

   <b>subroutine</b> <b>zlarfg</b> <b>(integer</b> <b>N,</b> <b>complex*16</b> <b>ALPHA,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>complex*16</b> <b>TAU)</b>
       <b>ZLARFG</b> generates an elementary reflector (Householder matrix).

       <b>Purpose:</b>

            ZLARFG generates a complex elementary reflector H of order n, such
            that

                  H**H * ( alpha ) = ( beta ),   H**H * H = I.
                         (   x   )   (   0  )

            where alpha and beta are scalars, with beta real, and x is an
            (n-1)-element complex vector. H is represented in the form

                  H = I - tau * ( 1 ) * ( 1 v**H ) ,
                                ( v )

            where tau is a complex scalar and v is a complex (n-1)-element
            vector. Note that H is not hermitian.

            If the elements of x are all zero and alpha is real, then tau = 0
            and H is taken to be the unit matrix.

            Otherwise  1 &lt;= real(tau) &lt;= 2  and  abs(tau-1) &lt;= 1 .

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the elementary reflector.

           <u>ALPHA</u>

                     ALPHA is COMPLEX*16
                     On entry, the value alpha.
                     On exit, it is overwritten with the value beta.

           <u>X</u>

                     X is COMPLEX*16 array, dimension
                                    (1+(N-2)*abs(INCX))
                     On entry, the vector x.
                     On exit, it is overwritten with the vector v.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>TAU</u>

                     TAU is COMPLEX*16
                     The value tau.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlarfgp</b> <b>(integer</b> <b>N,</b> <b>complex*16</b> <b>ALPHA,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>complex*16</b> <b>TAU)</b>
       <b>ZLARFGP</b> generates an elementary reflector (Householder matrix) with non-negative beta.

       <b>Purpose:</b>

            ZLARFGP generates a complex elementary reflector H of order n, such
            that

                  H**H * ( alpha ) = ( beta ),   H**H * H = I.
                         (   x   )   (   0  )

            where alpha and beta are scalars, beta is real and non-negative, and
            x is an (n-1)-element complex vector.  H is represented in the form

                  H = I - tau * ( 1 ) * ( 1 v**H ) ,
                                ( v )

            where tau is a complex scalar and v is a complex (n-1)-element
            vector. Note that H is not hermitian.

            If the elements of x are all zero and alpha is real, then tau = 0
            and H is taken to be the unit matrix.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the elementary reflector.

           <u>ALPHA</u>

                     ALPHA is COMPLEX*16
                     On entry, the value alpha.
                     On exit, it is overwritten with the value beta.

           <u>X</u>

                     X is COMPLEX*16 array, dimension
                                    (1+(N-2)*abs(INCX))
                     On entry, the vector x.
                     On exit, it is overwritten with the vector v.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>TAU</u>

                     TAU is COMPLEX*16
                     The value tau.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlarft</b> <b>(character</b> <b>DIRECT,</b> <b>character</b> <b>STOREV,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b>
       <b>V,</b> <b>integer</b> <b>LDV,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT)</b>
       <b>ZLARFT</b> forms the triangular factor T of a block reflector H = I - vtvH

       <b>Purpose:</b>

            ZLARFT forms the triangular factor T of a complex block reflector H
            of order n, which is defined as a product of k elementary reflectors.

            If DIRECT = 'F', H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) and T is upper triangular;

            If DIRECT = 'B', H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) and T is lower triangular.

            If STOREV = 'C', the vector which defines the elementary reflector
            H(i) is stored in the i-th column of the array V, and

               H  =  I - V * T * V**H

            If STOREV = 'R', the vector which defines the elementary reflector
            H(i) is stored in the i-th row of the array V, and

               H  =  I - V**H * T * V

       <b>Parameters</b>
           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Specifies the order in which the elementary reflectors are
                     multiplied to form the block reflector:
                     = 'F': H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) (Forward)
                     = 'B': H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) (Backward)

           <u>STOREV</u>

                     STOREV is CHARACTER*1
                     Specifies how the vectors which define the elementary
                     reflectors are stored (see also Further Details):
                     = 'C': columnwise
                     = 'R': rowwise

           <u>N</u>

                     N is INTEGER
                     The order of the block reflector H. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The order of the triangular factor T (= the number of
                     elementary reflectors). K &gt;= 1.

           <u>V</u>

                     V is COMPLEX*16 array, dimension
                                          (LDV,K) if STOREV = 'C'
                                          (LDV,N) if STOREV = 'R'
                     The matrix V. See further details.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If STOREV = 'C', LDV &gt;= max(1,N); if STOREV = 'R', LDV &gt;= K.

           <u>TAU</u>

                     TAU is COMPLEX*16 array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i).

           <u>T</u>

                     T is COMPLEX*16 array, dimension (LDT,K)
                     The k by k triangular factor T of the block reflector.
                     If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
                     lower triangular. The rest of the array is not used.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= K.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The shape of the matrix V and the storage of the vectors which define
             the H(i) is best illustrated by the following example with n = 5 and
             k = 3. The elements equal to 1 are not stored.

             DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':

                          V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                              ( v1  1    )                     (     1 v2 v2 v2 )
                              ( v1 v2  1 )                     (        1 v3 v3 )
                              ( v1 v2 v3 )
                              ( v1 v2 v3 )

             DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':

                          V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                              ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                              (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                              (     1 v3 )
                              (        1 )

   <b>subroutine</b> <b>zlarfx</b> <b>(character</b> <b>SIDE,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>complex*16</b> <b>TAU,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLARFX</b> applies an elementary reflector to a general rectangular matrix, with loop unrolling when the
       reflector has order ≤ 10.

       <b>Purpose:</b>

            ZLARFX applies a complex elementary reflector H to a complex m by n
            matrix C, from either the left or the right. H is represented in the
            form

                  H = I - tau * v * v**H

            where tau is a complex scalar and v is a complex vector.

            If tau = 0, then H is taken to be the unit matrix

            This version uses inline code if H has order &lt; 11.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': form  H * C
                     = 'R': form  C * H

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C.

           <u>V</u>

                     V is COMPLEX*16 array, dimension (M) if SIDE = 'L'
                                                   or (N) if SIDE = 'R'
                     The vector v in the representation of H.

           <u>TAU</u>

                     TAU is COMPLEX*16
                     The value tau in the representation of H.

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC,N)
                     On entry, the m by n matrix C.
                     On exit, C is overwritten by the matrix H * C if SIDE = 'L',
                     or C * H if SIDE = 'R'.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (N) if SIDE = 'L'
                                                       or (M) if SIDE = 'R'
                     WORK is not referenced if H has order &lt; 11.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlarfy</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>INCV,</b> <b>complex*16</b> <b>TAU,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>ZLARFY</b>

       <b>Purpose:</b>

            ZLARFY applies an elementary reflector, or Householder matrix, H,
            to an n x n Hermitian matrix C, from both the left and the right.

            H is represented in the form

               H = I - tau * v * v'

            where  tau  is a scalar and  v  is a vector.

            If  tau  is  zero, then  H  is taken to be the unit matrix.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     Hermitian matrix C is stored.
                     = 'U':  Upper triangle
                     = 'L':  Lower triangle

           <u>N</u>

                     N is INTEGER
                     The number of rows and columns of the matrix C.  N &gt;= 0.

           <u>V</u>

                     V is COMPLEX*16 array, dimension
                             (1 + (N-1)*abs(INCV))
                     The vector v as described above.

           <u>INCV</u>

                     INCV is INTEGER
                     The increment between successive elements of v.  INCV must
                     not be zero.

           <u>TAU</u>

                     TAU is COMPLEX*16
                     The value tau as described above.

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC, N)
                     On entry, the matrix C.
                     On exit, C is overwritten by H * C * H'.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C.  LDC &gt;= max( 1, N ).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (N)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlargv</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b>
       <b>integer</b> <b>INCY,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>INCC)</b>
       <b>ZLARGV</b> generates a vector of plane rotations with real cosines and complex sines.

       <b>Purpose:</b>

            ZLARGV generates a vector of complex plane rotations with real
            cosines, determined by elements of the complex vectors x and y.
            For i = 1,2,...,n

               (        c(i)   s(i) ) ( x(i) ) = ( r(i) )
               ( -conjg(s(i))  c(i) ) ( y(i) ) = (   0  )

               where c(i)**2 + ABS(s(i))**2 = 1

            The following conventions are used (these are the same as in ZLARTG,
            but differ from the BLAS1 routine ZROTG):
               If y(i)=0, then c(i)=1 and s(i)=0.
               If x(i)=0, then c(i)=0 and s(i) is chosen so that r(i) is real.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of plane rotations to be generated.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (1+(N-1)*INCX)
                     On entry, the vector x.
                     On exit, x(i) is overwritten by r(i), for i = 1,...,n.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>Y</u>

                     Y is COMPLEX*16 array, dimension (1+(N-1)*INCY)
                     On entry, the vector y.
                     On exit, the sines of the plane rotations.

           <u>INCY</u>

                     INCY is INTEGER
                     The increment between elements of Y. INCY &gt; 0.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
                     The cosines of the plane rotations.

           <u>INCC</u>

                     INCC is INTEGER
                     The increment between elements of C. INCC &gt; 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             6-6-96 - Modified with a new algorithm by W. Kahan and J. Demmel

             This version has a few statements commented out for thread safety
             (machine parameters are computed on each entry). 10 feb 03, SJH.

   <b>subroutine</b> <b>zlarnv</b> <b>(integer</b> <b>IDIST,</b> <b>integer,</b> <b>dimension(</b> <b>4</b> <b>)</b> <b>ISEED,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X)</b>
       <b>ZLARNV</b> returns a vector of random numbers from a uniform or normal distribution.

       <b>Purpose:</b>

            ZLARNV returns a vector of n random complex numbers from a uniform or
            normal distribution.

       <b>Parameters</b>
           <u>IDIST</u>

                     IDIST is INTEGER
                     Specifies the distribution of the random numbers:
                     = 1:  real and imaginary parts each uniform (0,1)
                     = 2:  real and imaginary parts each uniform (-1,1)
                     = 3:  real and imaginary parts each normal (0,1)
                     = 4:  uniformly distributed on the disc abs(z) &lt; 1
                     = 5:  uniformly distributed on the circle abs(z) = 1

           <u>ISEED</u>

                     ISEED is INTEGER array, dimension (4)
                     On entry, the seed of the random number generator; the array
                     elements must be between 0 and 4095, and <a href="../man4/ISEED.4.html">ISEED</a>(4) must be
                     odd.
                     On exit, the seed is updated.

           <u>N</u>

                     N is INTEGER
                     The number of random numbers to be generated.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (N)
                     The generated random numbers.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             This routine calls the auxiliary routine DLARUV to generate random
             real numbers from a uniform (0,1) distribution, in batches of up to
             128 using vectorisable code. The Box-Muller method is used to
             transform numbers from a uniform to a normal distribution.

   <b>subroutine</b> <b>zlarrv</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision</b> <b>VL,</b> <b>double</b> <b>precision</b> <b>VU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>L,</b> <b>double</b> <b>precision</b> <b>PIVMIN,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISPLIT,</b> <b>integer</b> <b>M,</b>
       <b>integer</b> <b>DOL,</b> <b>integer</b> <b>DOU,</b> <b>double</b> <b>precision</b> <b>MINRGP,</b> <b>double</b> <b>precision</b> <b>RTOL1,</b> <b>double</b> <b>precision</b> <b>RTOL2,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WERR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WGAP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IBLOCK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDEXW,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>GERS,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISUPPZ,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLARRV</b> computes the eigenvectors of the tridiagonal matrix T = L D LT given L, D and the eigenvalues of L
       D LT.

       <b>Purpose:</b>

            ZLARRV computes the eigenvectors of the tridiagonal matrix
            T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
            The input eigenvalues should have been computed by DLARRE.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix.  N &gt;= 0.

           <u>VL</u>

                     VL is DOUBLE PRECISION
                     Lower bound of the interval that contains the desired
                     eigenvalues. VL &lt; VU. Needed to compute gaps on the left or right
                     end of the extremal eigenvalues in the desired RANGE.

           <u>VU</u>

                     VU is DOUBLE PRECISION
                     Upper bound of the interval that contains the desired
                     eigenvalues. VL &lt; VU. Needed to compute gaps on the left or right
                     end of the extremal eigenvalues in the desired RANGE.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     On entry, the N diagonal elements of the diagonal matrix D.
                     On exit, D may be overwritten.

           <u>L</u>

                     L is DOUBLE PRECISION array, dimension (N)
                     On entry, the (N-1) subdiagonal elements of the unit
                     bidiagonal matrix L are in elements 1 to N-1 of L
                     (if the matrix is not split.) At the end of each block
                     is stored the corresponding shift as given by DLARRE.
                     On exit, L is overwritten.

           <u>PIVMIN</u>

                     PIVMIN is DOUBLE PRECISION
                     The minimum pivot allowed in the Sturm sequence.

           <u>ISPLIT</u>

                     ISPLIT is INTEGER array, dimension (N)
                     The splitting points, at which T breaks up into blocks.
                     The first block consists of rows/columns 1 to
                     ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
                     through ISPLIT( 2 ), etc.

           <u>M</u>

                     M is INTEGER
                     The total number of input eigenvalues.  0 &lt;= M &lt;= N.

           <u>DOL</u>

                     DOL is INTEGER

           <u>DOU</u>

                     DOU is INTEGER
                     If the user wants to compute only selected eigenvectors from all
                     the eigenvalues supplied, he can specify an index range DOL:DOU.
                     Or else the setting DOL=1, DOU=M should be applied.
                     Note that DOL and DOU refer to the order in which the eigenvalues
                     are stored in W.
                     If the user wants to compute only selected eigenpairs, then
                     the columns DOL-1 to DOU+1 of the eigenvector space Z contain the
                     computed eigenvectors. All other columns of Z are set to zero.

           <u>MINRGP</u>

                     MINRGP is DOUBLE PRECISION

           <u>RTOL1</u>

                     RTOL1 is DOUBLE PRECISION

           <u>RTOL2</u>

                     RTOL2 is DOUBLE PRECISION
                      Parameters for bisection.
                      An interval [LEFT,RIGHT] has converged if
                      RIGHT-LEFT &lt; MAX( RTOL1*GAP, RTOL2*MAX(|LEFT|,|RIGHT|) )

           <u>W</u>

                     W is DOUBLE PRECISION array, dimension (N)
                     The first M elements of W contain the APPROXIMATE eigenvalues for
                     which eigenvectors are to be computed.  The eigenvalues
                     should be grouped by split-off block and ordered from
                     smallest to largest within the block ( The output array
                     W from DLARRE is expected here ). Furthermore, they are with
                     respect to the shift of the corresponding root representation
                     for their block. On exit, W holds the eigenvalues of the
                     UNshifted matrix.

           <u>WERR</u>

                     WERR is DOUBLE PRECISION array, dimension (N)
                     The first M elements contain the semiwidth of the uncertainty
                     interval of the corresponding eigenvalue in W

           <u>WGAP</u>

                     WGAP is DOUBLE PRECISION array, dimension (N)
                     The separation from the right neighbor eigenvalue in W.

           <u>IBLOCK</u>

                     IBLOCK is INTEGER array, dimension (N)
                     The indices of the blocks (submatrices) associated with the
                     corresponding eigenvalues in W; IBLOCK(i)=1 if eigenvalue
                     W(i) belongs to the first block from the top, =2 if W(i)
                     belongs to the second block, etc.

           <u>INDEXW</u>

                     INDEXW is INTEGER array, dimension (N)
                     The indices of the eigenvalues within each block (submatrix);
                     for example, INDEXW(i)= 10 and IBLOCK(i)=2 imply that the
                     i-th eigenvalue W(i) is the 10-th eigenvalue in the second block.

           <u>GERS</u>

                     GERS is DOUBLE PRECISION array, dimension (2*N)
                     The N Gerschgorin intervals (the i-th Gerschgorin interval
                     is (GERS(2*i-1), GERS(2*i)). The Gerschgorin intervals should
                     be computed from the original UNshifted matrix.

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (LDZ, max(1,M) )
                     If INFO = 0, the first M columns of Z contain the
                     orthonormal eigenvectors of the matrix T
                     corresponding to the input eigenvalues, with the i-th
                     column of Z holding the eigenvector associated with W(i).
                     Note: the user must ensure that at least max(1,M) columns are
                     supplied in the array Z.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     JOBZ = 'V', LDZ &gt;= max(1,N).

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
                     The support of the eigenvectors in Z, i.e., the indices
                     indicating the nonzero elements in Z. The I-th eigenvector
                     is nonzero only in elements ISUPPZ( 2*I-1 ) through
                     ISUPPZ( 2*I ).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (12*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (7*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit

                     &gt; 0:  A problem occurred in ZLARRV.
                     &lt; 0:  One of the called subroutines signaled an internal problem.
                           Needs inspection of the corresponding parameter IINFO
                           for further information.

                     =-1:  Problem in DLARRB when refining a child's eigenvalues.
                     =-2:  Problem in DLARRF when computing the RRR of a child.
                           When a child is inside a tight cluster, it can be difficult
                           to find an RRR. A partial remedy from the user's point of
                           view is to make the parameter MINRGP smaller and recompile.
                           However, as the orthogonality of the computed vectors is
                           proportional to 1/MINRGP, the user should be aware that
                           he might be trading in precision when he decreases MINRGP.
                     =-3:  Problem in DLARRB when refining a single eigenvalue
                           after the Rayleigh correction was rejected.
                     = 5:  The Rayleigh Quotient Iteration failed to converge to
                           full accuracy in MAXITR steps.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Beresford Parlett, University of California, Berkeley, USA
            Jim Demmel, University of California, Berkeley, USA
            Inderjit Dhillon, University of Texas, Austin, USA
            Osni Marques, LBNL/NERSC, USA
            Christof Voemel, University of California, Berkeley, USA

   <b>subroutine</b> <b>zlartv</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b>
       <b>integer</b> <b>INCY,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>integer</b> <b>INCC)</b>
       <b>ZLARTV</b> applies a vector of plane rotations with real cosines and complex sines to the elements of a pair
       of vectors.

       <b>Purpose:</b>

            ZLARTV applies a vector of complex plane rotations with real cosines
            to elements of the complex vectors x and y. For i = 1,2,...,n

               ( x(i) ) := (        c(i)   s(i) ) ( x(i) )
               ( y(i) )    ( -conjg(s(i))  c(i) ) ( y(i) )

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of plane rotations to be applied.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (1+(N-1)*INCX)
                     The vector x.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between elements of X. INCX &gt; 0.

           <u>Y</u>

                     Y is COMPLEX*16 array, dimension (1+(N-1)*INCY)
                     The vector y.

           <u>INCY</u>

                     INCY is INTEGER
                     The increment between elements of Y. INCY &gt; 0.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (1+(N-1)*INCC)
                     The cosines of the plane rotations.

           <u>S</u>

                     S is COMPLEX*16 array, dimension (1+(N-1)*INCC)
                     The sines of the plane rotations.

           <u>INCC</u>

                     INCC is INTEGER
                     The increment between elements of C and S. INCC &gt; 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlascl</b> <b>(character</b> <b>TYPE,</b> <b>integer</b> <b>KL,</b> <b>integer</b> <b>KU,</b> <b>double</b> <b>precision</b> <b>CFROM,</b> <b>double</b> <b>precision</b> <b>CTO,</b>
       <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLASCL</b> multiplies a general rectangular matrix by a real scalar defined as cto/cfrom.

       <b>Purpose:</b>

            ZLASCL multiplies the M by N complex matrix A by the real scalar
            CTO/CFROM.  This is done without over/underflow as long as the final
            result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
            A may be full, upper triangular, lower triangular, upper Hessenberg,
            or banded.

       <b>Parameters</b>
           <u>TYPE</u>

                     TYPE is CHARACTER*1
                     TYPE indices the storage type of the input matrix.
                     = 'G':  A is a full matrix.
                     = 'L':  A is a lower triangular matrix.
                     = 'U':  A is an upper triangular matrix.
                     = 'H':  A is an upper Hessenberg matrix.
                     = 'B':  A is a symmetric band matrix with lower bandwidth KL
                             and upper bandwidth KU and with the only the lower
                             half stored.
                     = 'Q':  A is a symmetric band matrix with lower bandwidth KL
                             and upper bandwidth KU and with the only the upper
                             half stored.
                     = 'Z':  A is a band matrix with lower bandwidth KL and upper
                             bandwidth KU. See ZGBTRF for storage details.

           <u>KL</u>

                     KL is INTEGER
                     The lower bandwidth of A.  Referenced only if TYPE = 'B',
                     'Q' or 'Z'.

           <u>KU</u>

                     KU is INTEGER
                     The upper bandwidth of A.  Referenced only if TYPE = 'B',
                     'Q' or 'Z'.

           <u>CFROM</u>

                     CFROM is DOUBLE PRECISION

           <u>CTO</u>

                     CTO is DOUBLE PRECISION

                     The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
                     without over/underflow if the final result CTO*A(I,J)/CFROM
                     can be represented without over/underflow.  CFROM must be
                     nonzero.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     The matrix to be multiplied by CTO/CFROM.  See TYPE for the
                     storage type.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If TYPE = 'G', 'L', 'U', 'H', LDA &gt;= max(1,M);
                        TYPE = 'B', LDA &gt;= KL+1;
                        TYPE = 'Q', LDA &gt;= KU+1;
                        TYPE = 'Z', LDA &gt;= 2*KL+KU+1.

           <u>INFO</u>

                     INFO is INTEGER
                     0  - successful exit
                     &lt;0 - if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlaset</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex*16</b> <b>ALPHA,</b> <b>complex*16</b> <b>BETA,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA)</b>
       <b>ZLASET</b> initializes the off-diagonal elements and the diagonal elements of a matrix to given values.

       <b>Purpose:</b>

            ZLASET initializes a 2-D array A to BETA on the diagonal and
            ALPHA on the offdiagonals.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies the part of the matrix A to be set.
                     = 'U':      Upper triangular part is set. The lower triangle
                                 is unchanged.
                     = 'L':      Lower triangular part is set. The upper triangle
                                 is unchanged.
                     Otherwise:  All of the matrix A is set.

           <u>M</u>

                     M is INTEGER
                     On entry, M specifies the number of rows of A.

           <u>N</u>

                     N is INTEGER
                     On entry, N specifies the number of columns of A.

           <u>ALPHA</u>

                     ALPHA is COMPLEX*16
                     All the offdiagonal array elements are set to ALPHA.

           <u>BETA</u>

                     BETA is COMPLEX*16
                     All the diagonal array elements are set to BETA.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the m by n matrix A.
                     On exit, A(i,j) = ALPHA, 1 &lt;= i &lt;= m, 1 &lt;= j &lt;= n, i.ne.j;
                              A(i,i) = BETA , 1 &lt;= i &lt;= min(m,n)

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlasr</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>PIVOT,</b> <b>character</b> <b>DIRECT,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA)</b>
       <b>ZLASR</b> applies a sequence of plane rotations to a general rectangular matrix.

       <b>Purpose:</b>

            ZLASR applies a sequence of real plane rotations to a complex matrix
            A, from either the left or the right.

            When SIDE = 'L', the transformation takes the form

               A := P*A

            and when SIDE = 'R', the transformation takes the form

               A := A*P**T

            where P is an orthogonal matrix consisting of a sequence of z plane
            rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
            and P**T is the transpose of P.

            When DIRECT = 'F' (Forward sequence), then

               P = P(z-1) * ... * <a href="../man2/P.2.html">P</a>(2) * <a href="../man1/P.1.html">P</a>(1)

            and when DIRECT = 'B' (Backward sequence), then

               P = <a href="../man1/P.1.html">P</a>(1) * <a href="../man2/P.2.html">P</a>(2) * ... * P(z-1)

            where P(k) is a plane rotation matrix defined by the 2-by-2 rotation

               R(k) = (  c(k)  s(k) )
                    = ( -s(k)  c(k) ).

            When PIVOT = 'V' (Variable pivot), the rotation is performed
            for the plane (k,k+1), i.e., P(k) has the form

               P(k) = (  1                                            )
                      (       ...                                     )
                      (              1                                )
                      (                   c(k)  s(k)                  )
                      (                  -s(k)  c(k)                  )
                      (                                1              )
                      (                                     ...       )
                      (                                            1  )

            where R(k) appears as a rank-2 modification to the identity matrix in
            rows and columns k and k+1.

            When PIVOT = 'T' (Top pivot), the rotation is performed for the
            plane (1,k+1), so P(k) has the form

               P(k) = (  c(k)                    s(k)                 )
                      (         1                                     )
                      (              ...                              )
                      (                     1                         )
                      ( -s(k)                    c(k)                 )
                      (                                 1             )
                      (                                      ...      )
                      (                                             1 )

            where R(k) appears in rows and columns 1 and k+1.

            Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
            performed for the plane (k,z), giving P(k) the form

               P(k) = ( 1                                             )
                      (      ...                                      )
                      (             1                                 )
                      (                  c(k)                    s(k) )
                      (                         1                     )
                      (                              ...              )
                      (                                     1         )
                      (                 -s(k)                    c(k) )

            where R(k) appears in rows and columns k and z.  The rotations are
            performed without ever forming P(k) explicitly.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     Specifies whether the plane rotation matrix P is applied to
                     A on the left or the right.
                     = 'L':  Left, compute A := P*A
                     = 'R':  Right, compute A:= A*P**T

           <u>PIVOT</u>

                     PIVOT is CHARACTER*1
                     Specifies the plane for which P(k) is a plane rotation
                     matrix.
                     = 'V':  Variable pivot, the plane (k,k+1)
                     = 'T':  Top pivot, the plane (1,k+1)
                     = 'B':  Bottom pivot, the plane (k,z)

           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Specifies whether P is a forward or backward sequence of
                     plane rotations.
                     = 'F':  Forward, P = P(z-1)*...*<a href="../man2/P.2.html">P</a>(2)*<a href="../man1/P.1.html">P</a>(1)
                     = 'B':  Backward, P = <a href="../man1/P.1.html">P</a>(1)*<a href="../man2/P.2.html">P</a>(2)*...*P(z-1)

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  If m &lt;= 1, an immediate
                     return is effected.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  If n &lt;= 1, an
                     immediate return is effected.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension
                             (M-1) if SIDE = 'L'
                             (N-1) if SIDE = 'R'
                     The cosines c(k) of the plane rotations.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension
                             (M-1) if SIDE = 'L'
                             (N-1) if SIDE = 'R'
                     The sines s(k) of the plane rotations.  The 2-by-2 plane
                     rotation part of the matrix P(k), R(k), has the form
                     R(k) = (  c(k)  s(k) )
                            ( -s(k)  c(k) ).

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     The M-by-N matrix A.  On exit, A is overwritten by P*A if
                     SIDE = 'R' or by A*P**T if SIDE = 'L'.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlaswp</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b> <b>K1,</b> <b>integer</b> <b>K2,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>integer</b> <b>INCX)</b>
       <b>ZLASWP</b> performs a series of row interchanges on a general rectangular matrix.

       <b>Purpose:</b>

            ZLASWP performs a series of row interchanges on the matrix A.
            One row interchange is initiated for each of rows K1 through K2 of A.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the matrix of column dimension N to which the row
                     interchanges will be applied.
                     On exit, the permuted matrix.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.

           <u>K1</u>

                     K1 is INTEGER
                     The first element of IPIV for which a row interchange will
                     be done.

           <u>K2</u>

                     K2 is INTEGER
                     (K2-K1+1) is the number of elements of IPIV for which a row
                     interchange will be done.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (K1+(K2-K1)*abs(INCX))
                     The vector of pivot indices. Only the elements in positions
                     K1 through K1+(K2-K1)*abs(INCX) of IPIV are accessed.
                     IPIV(K1+(K-K1)*abs(INCX)) = L implies rows K and L are to be
                     interchanged.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between successive values of IPIV. If INCX
                     is negative, the pivots are applied in reverse order.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Modified by
              R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA

   <b>subroutine</b> <b>zlat2c</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldsa,</b> <b>*</b> <b>)</b> <b>SA,</b> <b>integer</b> <b>LDSA,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLAT2C</b> converts a double complex triangular matrix to a complex triangular matrix.

       <b>Purpose:</b>

            ZLAT2C converts a COMPLEX*16 triangular matrix, SA, to a COMPLEX
            triangular matrix, A.

            RMAX is the overflow for the SINGLE PRECISION arithmetic
            ZLAT2C checks that all the entries of A are between -RMAX and
            RMAX. If not the conversion is aborted and a flag is raised.

            This is an auxiliary routine so there is no argument checking.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>N</u>

                     N is INTEGER
                     The number of rows and columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the N-by-N triangular coefficient matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>SA</u>

                     SA is COMPLEX array, dimension (LDSA,N)
                     Only the UPLO part of SA is referenced.  On exit, if INFO=0,
                     the N-by-N coefficient matrix SA; if INFO&gt;0, the content of
                     the UPLO part of SA is unspecified.

           <u>LDSA</u>

                     LDSA is INTEGER
                     The leading dimension of the array SA.  LDSA &gt;= max(1,M).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     = 1:  an entry of the matrix A is greater than the SINGLE
                           PRECISION overflow threshold, in this case, the content
                           of the UPLO part of SA in exit is unspecified.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlatbs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>character</b> <b>NORMIN,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>double</b> <b>precision</b> <b>SCALE,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CNORM,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLATBS</b> solves a triangular banded system of equations.

       <b>Purpose:</b>

            ZLATBS solves one of the triangular systems

               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,

            with scaling to prevent overflow, where A is an upper or lower
            triangular band matrix.  Here A**T denotes the transpose of A, x and b
            are n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine ZTBSV is called.  If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  Solve A * x = s*b     (No transpose)
                     = 'T':  Solve A**T * x = s*b  (Transpose)
                     = 'C':  Solve A**H * x = s*b  (Conjugate transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>NORMIN</u>

                     NORMIN is CHARACTER*1
                     Specifies whether CNORM has been set or not.
                     = 'Y':  CNORM contains the column norms on entry
                     = 'N':  CNORM is not set on entry.  On exit, the norms will
                             be computed and stored in CNORM.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of subdiagonals or superdiagonals in the
                     triangular matrix A.  KD &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX*16 array, dimension (LDAB,N)
                     The upper or lower triangular band matrix A, stored in the
                     first KD+1 rows of the array. The j-th column of A is stored
                     in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (N)
                     On entry, the right hand side b of the triangular system.
                     On exit, X is overwritten by the solution vector x.

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     The scaling factor s for the triangular system
                        A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
                     If SCALE = 0, the matrix A is singular or badly scaled, and
                     the vector x is an exact or approximate solution to A*x = 0.

           <u>CNORM</u>

                     CNORM is DOUBLE PRECISION array, dimension (N)

                     If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
                     contains the norm of the off-diagonal part of the j-th column
                     of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
                     to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
                     must be greater than or equal to the 1-norm.

                     If NORMIN = 'N', CNORM is an output argument and CNORM(j)
                     returns the 1-norm of the offdiagonal part of the j-th column
                     of A.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             A rough bound on x is computed; if that is less than overflow, ZTBSV
             is called, otherwise, specific code is used which checks for possible
             overflow or divide-by-zero at every operation.

             A columnwise scheme is used for solving A*x = b.  The basic algorithm
             if A is lower triangular is

                  x[1:n] := b[1:n]
                  for j = 1, ..., n
                       x(j) := x(j) / A(j,j)
                       x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                  end

             Define bounds on the components of x after j iterations of the loop:
                M(j) = bound on x[1:j]
                G(j) = bound on x[j+1:n]
             Initially, let <a href="../man0/M.0.html">M</a>(0) = 0 and <a href="../man0/G.0.html">G</a>(0) = max{x(i), i=1,...,n}.

             Then for iteration j+1 we have
                M(j+1) &lt;= G(j) / | A(j+1,j+1) |
                G(j+1) &lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                       &lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

             where CNORM(j+1) is greater than or equal to the infinity-norm of
             column j+1 of A, not counting the diagonal.  Hence

                G(j) &lt;= <a href="../man0/G.0.html">G</a>(0) product ( 1 + CNORM(i) / | A(i,i) | )
                             1&lt;=i&lt;=j
             and

                |x(j)| &lt;= ( <a href="../man0/G.0.html">G</a>(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                              1&lt;=i&lt; j

             Since |x(j)| &lt;= M(j), we use the Level 2 BLAS routine ZTBSV if the
             reciprocal of the largest M(j), j=1,..,n, is larger than
             max(underflow, 1/overflow).

             The bound on x(j) is also used to determine when a step in the
             columnwise method can be performed without fear of overflow.  If
             the computed bound is greater than a large constant, x is scaled to
             prevent overflow, but if the bound overflows, x is set to 0, x(j) to
             1, and scale to 0, and a non-trivial solution to A*x = 0 is found.

             Similarly, a row-wise scheme is used to solve A**T *x = b  or
             A**H *x = b.  The basic algorithm for A upper triangular is

                  for j = 1, ..., n
                       x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
                  end

             We simultaneously compute two bounds
                  G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1&lt;=i&lt;=j
                  M(j) = bound on x(i), 1&lt;=i&lt;=j

             The initial values are <a href="../man0/G.0.html">G</a>(0) = 0, <a href="../man0/M.0.html">M</a>(0) = max{b(i), i=1,..,n}, and we
             add the constraint G(j) &gt;= G(j-1) and M(j) &gt;= M(j-1) for j &gt;= 1.
             Then the bound on x(j) is

                  M(j) &lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |

                       &lt;= <a href="../man0/M.0.html">M</a>(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                 1&lt;=i&lt;=j

             and we can safely call ZTBSV if 1/M(n) and 1/G(n) are both greater
             than max(underflow, 1/overflow).

   <b>subroutine</b> <b>zlatdf</b> <b>(integer</b> <b>IJOB,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>RHS,</b> <b>double</b> <b>precision</b> <b>RDSUM,</b> <b>double</b> <b>precision</b> <b>RDSCAL,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>JPIV)</b>
       <b>ZLATDF</b> uses the LU factorization of the n-by-n matrix computed by sgetc2 and computes a contribution to
       the reciprocal Dif-estimate.

       <b>Purpose:</b>

            ZLATDF computes the contribution to the reciprocal Dif-estimate
            by solving for x in Z * x = b, where b is chosen such that the norm
            of x is as large as possible. It is assumed that LU decomposition
            of Z has been computed by ZGETC2. On entry RHS = f holds the
            contribution from earlier solved sub-systems, and on return RHS = x.

            The factorization of Z returned by ZGETC2 has the form
            Z = P * L * U * Q, where P and Q are permutation matrices. L is lower
            triangular with unit diagonal elements and U is upper triangular.

       <b>Parameters</b>
           <u>IJOB</u>

                     IJOB is INTEGER
                     IJOB = 2: First compute an approximative null-vector e
                         of Z using ZGECON, e is normalized and solve for
                         Zx = +-e - f with the sign giving the greater value of
                         2-norm(x).  About 5 times as expensive as Default.
                     IJOB .ne. 2: Local look ahead strategy where
                         all entries of the r.h.s. b is chosen as either +1 or
                         -1.  Default.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Z.

           <u>Z</u>

                     Z is COMPLEX*16 array, dimension (LDZ, N)
                     On entry, the LU part of the factorization of the n-by-n
                     matrix Z computed by ZGETC2:  Z = P * L * U * Q

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDA &gt;= max(1, N).

           <u>RHS</u>

                     RHS is COMPLEX*16 array, dimension (N).
                     On entry, RHS contains contributions from other subsystems.
                     On exit, RHS contains the solution of the subsystem with
                     entries according to the value of IJOB (see above).

           <u>RDSUM</u>

                     RDSUM is DOUBLE PRECISION
                     On entry, the sum of squares of computed contributions to
                     the Dif-estimate under computation by ZTGSYL, where the
                     scaling factor RDSCAL (see below) has been factored out.
                     On exit, the corresponding sum of squares updated with the
                     contributions from the current sub-system.
                     If TRANS = 'T' RDSUM is not touched.
                     NOTE: RDSUM only makes sense when ZTGSY2 is called by CTGSYL.

           <u>RDSCAL</u>

                     RDSCAL is DOUBLE PRECISION
                     On entry, scaling factor used to prevent overflow in RDSUM.
                     On exit, RDSCAL is updated w.r.t. the current contributions
                     in RDSUM.
                     If TRANS = 'T', RDSCAL is not touched.
                     NOTE: RDSCAL only makes sense when ZTGSY2 is called by
                     ZTGSYL.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N).
                     The pivot indices; for 1 &lt;= i &lt;= N, row i of the
                     matrix has been interchanged with row IPIV(i).

           <u>JPIV</u>

                     JPIV is INTEGER array, dimension (N).
                     The pivot indices; for 1 &lt;= j &lt;= N, column j of the
                     matrix has been interchanged with column JPIV(j).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>
           This routine is a further developed implementation of algorithm BSOLVE in [1] using complete pivoting
           in the LU factorization.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

       <b>References:</b>
           [1] Bo Kagstrom and Lars Westin, Generalized Schur Methods with Condition Estimators for Solving the
           Generalized Sylvester Equation, IEEE Transactions on Automatic Control, Vol. 34, No. 7, July 1989, pp
           745-751.
            [2] Peter Poromaa, On Efficient and Robust Estimators for the Separation between two Regular Matrix
           Pairs with Applications in Condition Estimation. Report UMINF-95.05, Department of Computing Science,
           Umea University, S-901 87 Umea, Sweden, 1995.

   <b>subroutine</b> <b>zlatps</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>character</b> <b>NORMIN,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>double</b> <b>precision</b> <b>SCALE,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>CNORM,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLATPS</b> solves a triangular system of equations with the matrix held in packed storage.

       <b>Purpose:</b>

            ZLATPS solves one of the triangular systems

               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,

            with scaling to prevent overflow, where A is an upper or lower
            triangular matrix stored in packed form.  Here A**T denotes the
            transpose of A, A**H denotes the conjugate transpose of A, x and b
            are n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine ZTPSV is called. If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  Solve A * x = s*b     (No transpose)
                     = 'T':  Solve A**T * x = s*b  (Transpose)
                     = 'C':  Solve A**H * x = s*b  (Conjugate transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>NORMIN</u>

                     NORMIN is CHARACTER*1
                     Specifies whether CNORM has been set or not.
                     = 'Y':  CNORM contains the column norms on entry
                     = 'N':  CNORM is not set on entry.  On exit, the norms will
                             be computed and stored in CNORM.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     The upper or lower triangular matrix A, packed columnwise in
                     a linear array.  The j-th column of A is stored in the array
                     AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (N)
                     On entry, the right hand side b of the triangular system.
                     On exit, X is overwritten by the solution vector x.

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     The scaling factor s for the triangular system
                        A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
                     If SCALE = 0, the matrix A is singular or badly scaled, and
                     the vector x is an exact or approximate solution to A*x = 0.

           <u>CNORM</u>

                     CNORM is DOUBLE PRECISION array, dimension (N)

                     If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
                     contains the norm of the off-diagonal part of the j-th column
                     of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
                     to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
                     must be greater than or equal to the 1-norm.

                     If NORMIN = 'N', CNORM is an output argument and CNORM(j)
                     returns the 1-norm of the offdiagonal part of the j-th column
                     of A.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             A rough bound on x is computed; if that is less than overflow, ZTPSV
             is called, otherwise, specific code is used which checks for possible
             overflow or divide-by-zero at every operation.

             A columnwise scheme is used for solving A*x = b.  The basic algorithm
             if A is lower triangular is

                  x[1:n] := b[1:n]
                  for j = 1, ..., n
                       x(j) := x(j) / A(j,j)
                       x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                  end

             Define bounds on the components of x after j iterations of the loop:
                M(j) = bound on x[1:j]
                G(j) = bound on x[j+1:n]
             Initially, let <a href="../man0/M.0.html">M</a>(0) = 0 and <a href="../man0/G.0.html">G</a>(0) = max{x(i), i=1,...,n}.

             Then for iteration j+1 we have
                M(j+1) &lt;= G(j) / | A(j+1,j+1) |
                G(j+1) &lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                       &lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

             where CNORM(j+1) is greater than or equal to the infinity-norm of
             column j+1 of A, not counting the diagonal.  Hence

                G(j) &lt;= <a href="../man0/G.0.html">G</a>(0) product ( 1 + CNORM(i) / | A(i,i) | )
                             1&lt;=i&lt;=j
             and

                |x(j)| &lt;= ( <a href="../man0/G.0.html">G</a>(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                              1&lt;=i&lt; j

             Since |x(j)| &lt;= M(j), we use the Level 2 BLAS routine ZTPSV if the
             reciprocal of the largest M(j), j=1,..,n, is larger than
             max(underflow, 1/overflow).

             The bound on x(j) is also used to determine when a step in the
             columnwise method can be performed without fear of overflow.  If
             the computed bound is greater than a large constant, x is scaled to
             prevent overflow, but if the bound overflows, x is set to 0, x(j) to
             1, and scale to 0, and a non-trivial solution to A*x = 0 is found.

             Similarly, a row-wise scheme is used to solve A**T *x = b  or
             A**H *x = b.  The basic algorithm for A upper triangular is

                  for j = 1, ..., n
                       x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
                  end

             We simultaneously compute two bounds
                  G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1&lt;=i&lt;=j
                  M(j) = bound on x(i), 1&lt;=i&lt;=j

             The initial values are <a href="../man0/G.0.html">G</a>(0) = 0, <a href="../man0/M.0.html">M</a>(0) = max{b(i), i=1,..,n}, and we
             add the constraint G(j) &gt;= G(j-1) and M(j) &gt;= M(j-1) for j &gt;= 1.
             Then the bound on x(j) is

                  M(j) &lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |

                       &lt;= <a href="../man0/M.0.html">M</a>(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                 1&lt;=i&lt;=j

             and we can safely call ZTPSV if 1/M(n) and 1/G(n) are both greater
             than max(underflow, 1/overflow).

   <b>subroutine</b> <b>zlatrd</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NB,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldw,</b> <b>*</b> <b>)</b> <b>W,</b>
       <b>integer</b> <b>LDW)</b>
       <b>ZLATRD</b> reduces the first nb rows and columns of a symmetric/Hermitian matrix A to real tridiagonal form
       by an unitary similarity transformation.

       <b>Purpose:</b>

            ZLATRD reduces NB rows and columns of a complex Hermitian matrix A to
            Hermitian tridiagonal form by a unitary similarity
            transformation Q**H * A * Q, and returns the matrices V and W which are
            needed to apply the transformation to the unreduced part of A.

            If UPLO = 'U', ZLATRD reduces the last NB rows and columns of a
            matrix, of which the upper triangle is supplied;
            if UPLO = 'L', ZLATRD reduces the first NB rows and columns of a
            matrix, of which the lower triangle is supplied.

            This is an auxiliary routine called by ZHETRD.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     Hermitian matrix A is stored:
                     = 'U': Upper triangular
                     = 'L': Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.

           <u>NB</u>

                     NB is INTEGER
                     The number of rows and columns to be reduced.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
                     n-by-n upper triangular part of A contains the upper
                     triangular part of the matrix A, and the strictly lower
                     triangular part of A is not referenced.  If UPLO = 'L', the
                     leading n-by-n lower triangular part of A contains the lower
                     triangular part of the matrix A, and the strictly upper
                     triangular part of A is not referenced.
                     On exit:
                     if UPLO = 'U', the last NB columns have been reduced to
                       tridiagonal form, with the diagonal elements overwriting
                       the diagonal elements of A; the elements above the diagonal
                       with the array TAU, represent the unitary matrix Q as a
                       product of elementary reflectors;
                     if UPLO = 'L', the first NB columns have been reduced to
                       tridiagonal form, with the diagonal elements overwriting
                       the diagonal elements of A; the elements below the diagonal
                       with the array TAU, represent the  unitary matrix Q as a
                       product of elementary reflectors.
                     See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (N-1)
                     If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
                     elements of the last NB columns of the reduced matrix;
                     if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
                     the first NB columns of the reduced matrix.

           <u>TAU</u>

                     TAU is COMPLEX*16 array, dimension (N-1)
                     The scalar factors of the elementary reflectors, stored in
                     TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
                     See Further Details.

           <u>W</u>

                     W is COMPLEX*16 array, dimension (LDW,NB)
                     The n-by-nb matrix W required to update the unreduced part
                     of A.

           <u>LDW</u>

                     LDW is INTEGER
                     The leading dimension of the array W. LDW &gt;= max(1,N).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             If UPLO = 'U', the matrix Q is represented as a product of elementary
             reflectors

                Q = H(n) H(n-1) . . . H(n-nb+1).

             Each H(i) has the form

                H(i) = I - tau * v * v**H

             where tau is a complex scalar, and v is a complex vector with
             v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
             and tau in TAU(i-1).

             If UPLO = 'L', the matrix Q is represented as a product of elementary
             reflectors

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nb).

             Each H(i) has the form

                H(i) = I - tau * v * v**H

             where tau is a complex scalar, and v is a complex vector with
             v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
             and tau in TAU(i).

             The elements of the vectors v together form the n-by-nb matrix V
             which is needed, with W, to apply the transformation to the unreduced
             part of the matrix, using a Hermitian rank-2k update of the form:
             A := A - V*W**H - W*V**H.

             The contents of A on exit are illustrated by the following examples
             with n = 5 and nb = 2:

             if UPLO = 'U':                       if UPLO = 'L':

               (  a   a   a   v4  v5 )              (  d                  )
               (      a   a   v4  v5 )              (  1   d              )
               (          a   1   v5 )              (  v1  1   a          )
               (              d   1  )              (  v1  v2  a   a      )
               (                  d  )              (  v1  v2  a   a   a  )

             where d denotes a diagonal element of the reduced matrix, a denotes
             an element of the original matrix that is unchanged, and vi denotes
             an element of the vector defining H(i).

   <b>subroutine</b> <b>zlatrs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>character</b> <b>NORMIN,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>double</b> <b>precision</b> <b>SCALE,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CNORM,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLATRS</b> solves a triangular system of equations with the scale factor set to prevent overflow.

       <b>Purpose:</b>

            ZLATRS solves one of the triangular systems

               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,

            with scaling to prevent overflow.  Here A is an upper or lower
            triangular matrix, A**T denotes the transpose of A, A**H denotes the
            conjugate transpose of A, x and b are n-element vectors, and s is a
            scaling factor, usually less than or equal to 1, chosen so that the
            components of x will be less than the overflow threshold.  If the
            unscaled problem will not cause overflow, the Level 2 BLAS routine
            ZTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
            then s is set to 0 and a non-trivial solution to A*x = 0 is returned.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the operation applied to A.
                     = 'N':  Solve A * x = s*b     (No transpose)
                     = 'T':  Solve A**T * x = s*b  (Transpose)
                     = 'C':  Solve A**H * x = s*b  (Conjugate transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>NORMIN</u>

                     NORMIN is CHARACTER*1
                     Specifies whether CNORM has been set or not.
                     = 'Y':  CNORM contains the column norms on entry
                     = 'N':  CNORM is not set on entry.  On exit, the norms will
                             be computed and stored in CNORM.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     The triangular matrix A.  If UPLO = 'U', the leading n by n
                     upper triangular part of the array A contains the upper
                     triangular matrix, and the strictly lower triangular part of
                     A is not referenced.  If UPLO = 'L', the leading n by n lower
                     triangular part of the array A contains the lower triangular
                     matrix, and the strictly upper triangular part of A is not
                     referenced.  If DIAG = 'U', the diagonal elements of A are
                     also not referenced and are assumed to be 1.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max (1,N).

           <u>X</u>

                     X is COMPLEX*16 array, dimension (N)
                     On entry, the right hand side b of the triangular system.
                     On exit, X is overwritten by the solution vector x.

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     The scaling factor s for the triangular system
                        A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
                     If SCALE = 0, the matrix A is singular or badly scaled, and
                     the vector x is an exact or approximate solution to A*x = 0.

           <u>CNORM</u>

                     CNORM is DOUBLE PRECISION array, dimension (N)

                     If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
                     contains the norm of the off-diagonal part of the j-th column
                     of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
                     to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
                     must be greater than or equal to the 1-norm.

                     If NORMIN = 'N', CNORM is an output argument and CNORM(j)
                     returns the 1-norm of the offdiagonal part of the j-th column
                     of A.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             A rough bound on x is computed; if that is less than overflow, ZTRSV
             is called, otherwise, specific code is used which checks for possible
             overflow or divide-by-zero at every operation.

             A columnwise scheme is used for solving A*x = b.  The basic algorithm
             if A is lower triangular is

                  x[1:n] := b[1:n]
                  for j = 1, ..., n
                       x(j) := x(j) / A(j,j)
                       x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                  end

             Define bounds on the components of x after j iterations of the loop:
                M(j) = bound on x[1:j]
                G(j) = bound on x[j+1:n]
             Initially, let <a href="../man0/M.0.html">M</a>(0) = 0 and <a href="../man0/G.0.html">G</a>(0) = max{x(i), i=1,...,n}.

             Then for iteration j+1 we have
                M(j+1) &lt;= G(j) / | A(j+1,j+1) |
                G(j+1) &lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                       &lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )

             where CNORM(j+1) is greater than or equal to the infinity-norm of
             column j+1 of A, not counting the diagonal.  Hence

                G(j) &lt;= <a href="../man0/G.0.html">G</a>(0) product ( 1 + CNORM(i) / | A(i,i) | )
                             1&lt;=i&lt;=j
             and

                |x(j)| &lt;= ( <a href="../man0/G.0.html">G</a>(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                              1&lt;=i&lt; j

             Since |x(j)| &lt;= M(j), we use the Level 2 BLAS routine ZTRSV if the
             reciprocal of the largest M(j), j=1,..,n, is larger than
             max(underflow, 1/overflow).

             The bound on x(j) is also used to determine when a step in the
             columnwise method can be performed without fear of overflow.  If
             the computed bound is greater than a large constant, x is scaled to
             prevent overflow, but if the bound overflows, x is set to 0, x(j) to
             1, and scale to 0, and a non-trivial solution to A*x = 0 is found.

             Similarly, a row-wise scheme is used to solve A**T *x = b  or
             A**H *x = b.  The basic algorithm for A upper triangular is

                  for j = 1, ..., n
                       x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
                  end

             We simultaneously compute two bounds
                  G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1&lt;=i&lt;=j
                  M(j) = bound on x(i), 1&lt;=i&lt;=j

             The initial values are <a href="../man0/G.0.html">G</a>(0) = 0, <a href="../man0/M.0.html">M</a>(0) = max{b(i), i=1,..,n}, and we
             add the constraint G(j) &gt;= G(j-1) and M(j) &gt;= M(j-1) for j &gt;= 1.
             Then the bound on x(j) is

                  M(j) &lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |

                       &lt;= <a href="../man0/M.0.html">M</a>(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                 1&lt;=i&lt;=j

             and we can safely call ZTRSV if 1/M(n) and 1/G(n) are both greater
             than max(underflow, 1/overflow).

   <b>subroutine</b> <b>zlauu2</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLAUU2</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices (unblocked
       algorithm).

       <b>Purpose:</b>

            ZLAUU2 computes the product U * U**H or L**H * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.

            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.

            This is the unblocked form of the algorithm, calling Level 2 BLAS.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the triangular factor stored in the array A
                     is upper or lower triangular:
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the triangular factor U or L.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the triangular factor U or L.
                     On exit, if UPLO = 'U', the upper triangle of A is
                     overwritten with the upper triangle of the product U * U**H;
                     if UPLO = 'L', the lower triangle of A is overwritten with
                     the lower triangle of the product L**H * L.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zlauum</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b> <b>INFO)</b>
       <b>ZLAUUM</b> computes the product UUH or LHL, where U and L are upper or lower triangular matrices (blocked
       algorithm).

       <b>Purpose:</b>

            ZLAUUM computes the product U * U**H or L**H * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.

            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.

            This is the blocked form of the algorithm, calling Level 3 BLAS.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the triangular factor stored in the array A
                     is upper or lower triangular:
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the triangular factor U or L.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the triangular factor U or L.
                     On exit, if UPLO = 'U', the upper triangle of A is
                     overwritten with the upper triangle of the product U * U**H;
                     if UPLO = 'L', the lower triangle of A is overwritten with
                     the lower triangle of the product L**H * L.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zrot</b> <b>(integer</b> <b>N,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CX,</b> <b>integer</b> <b>INCX,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CY,</b>
       <b>integer</b> <b>INCY,</b> <b>double</b> <b>precision</b> <b>C,</b> <b>complex*16</b> <b>S)</b>
       <b>ZROT</b> applies a plane rotation with real cosine and complex sine to a pair of complex vectors.

       <b>Purpose:</b>

            ZROT   applies a plane rotation, where the cos (C) is real and the
            sin (S) is complex, and the vectors CX and CY are complex.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of elements in the vectors CX and CY.

           <u>CX</u>

                     CX is COMPLEX*16 array, dimension (N)
                     On input, the vector X.
                     On output, CX is overwritten with C*X + S*Y.

           <u>INCX</u>

                     INCX is INTEGER
                     The increment between successive values of CX.  INCX &lt;&gt; 0.

           <u>CY</u>

                     CY is COMPLEX*16 array, dimension (N)
                     On input, the vector Y.
                     On output, CY is overwritten with -CONJG(S)*X + C*Y.

           <u>INCY</u>

                     INCY is INTEGER
                     The increment between successive values of CY.  INCX &lt;&gt; 0.

           <u>C</u>

                     C is DOUBLE PRECISION

           <u>S</u>

                     S is COMPLEX*16
                     C and S define a rotation
                        [  C          S  ]
                        [ -conjg(S)   C  ]
                     where C*C + S*CONJG(S) = 1.0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zspmv</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex*16</b> <b>ALPHA,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b> <b>complex*16</b> <b>BETA,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b> <b>integer</b> <b>INCY)</b>
       <b>ZSPMV</b> computes a matrix-vector product for complex vectors using a complex symmetric packed matrix

       <b>Purpose:</b>

            ZSPMV  performs the matrix-vector operation

               y := alpha*A*x + beta*y,

            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n symmetric matrix, supplied in packed form.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                      On entry, UPLO specifies whether the upper or lower
                      triangular part of the matrix A is supplied in the packed
                      array AP as follows:

                         UPLO = 'U' or 'u'   The upper triangular part of A is
                                             supplied in AP.

                         UPLO = 'L' or 'l'   The lower triangular part of A is
                                             supplied in AP.

                      Unchanged on exit.

           <u>N</u>

                     N is INTEGER
                      On entry, N specifies the order of the matrix A.
                      N must be at least zero.
                      Unchanged on exit.

           <u>ALPHA</u>

                     ALPHA is COMPLEX*16
                      On entry, ALPHA specifies the scalar alpha.
                      Unchanged on exit.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension at least
                      ( ( N*( N + 1 ) )/2 ).
                      Before entry, with UPLO = 'U' or 'u', the array AP must
                      contain the upper triangular part of the symmetric matrix
                      packed sequentially, column by column, so that AP( 1 )
                      contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
                      and a( 2, 2 ) respectively, and so on.
                      Before entry, with UPLO = 'L' or 'l', the array AP must
                      contain the lower triangular part of the symmetric matrix
                      packed sequentially, column by column, so that AP( 1 )
                      contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
                      and a( 3, 1 ) respectively, and so on.
                      Unchanged on exit.

           <u>X</u>

                     X is COMPLEX*16 array, dimension at least
                      ( 1 + ( N - 1 )*abs( INCX ) ).
                      Before entry, the incremented array X must contain the N-
                      element vector x.
                      Unchanged on exit.

           <u>INCX</u>

                     INCX is INTEGER
                      On entry, INCX specifies the increment for the elements of
                      X. INCX must not be zero.
                      Unchanged on exit.

           <u>BETA</u>

                     BETA is COMPLEX*16
                      On entry, BETA specifies the scalar beta. When BETA is
                      supplied as zero then Y need not be set on input.
                      Unchanged on exit.

           <u>Y</u>

                     Y is COMPLEX*16 array, dimension at least
                      ( 1 + ( N - 1 )*abs( INCY ) ).
                      Before entry, the incremented array Y must contain the n
                      element vector y. On exit, Y is overwritten by the updated
                      vector y.

           <u>INCY</u>

                     INCY is INTEGER
                      On entry, INCY specifies the increment for the elements of
                      Y. INCY must not be zero.
                      Unchanged on exit.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zspr</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex*16</b> <b>ALPHA,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>INCX,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP)</b>
       <b>ZSPR</b> performs the symmetrical rank-1 update of a complex symmetric packed matrix.

       <b>Purpose:</b>

            ZSPR    performs the symmetric rank 1 operation

               A := alpha*x*x**H + A,

            where alpha is a complex scalar, x is an n element vector and A is an
            n by n symmetric matrix, supplied in packed form.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                      On entry, UPLO specifies whether the upper or lower
                      triangular part of the matrix A is supplied in the packed
                      array AP as follows:

                         UPLO = 'U' or 'u'   The upper triangular part of A is
                                             supplied in AP.

                         UPLO = 'L' or 'l'   The lower triangular part of A is
                                             supplied in AP.

                      Unchanged on exit.

           <u>N</u>

                     N is INTEGER
                      On entry, N specifies the order of the matrix A.
                      N must be at least zero.
                      Unchanged on exit.

           <u>ALPHA</u>

                     ALPHA is COMPLEX*16
                      On entry, ALPHA specifies the scalar alpha.
                      Unchanged on exit.

           <u>X</u>

                     X is COMPLEX*16 array, dimension at least
                      ( 1 + ( N - 1 )*abs( INCX ) ).
                      Before entry, the incremented array X must contain the N-
                      element vector x.
                      Unchanged on exit.

           <u>INCX</u>

                     INCX is INTEGER
                      On entry, INCX specifies the increment for the elements of
                      X. INCX must not be zero.
                      Unchanged on exit.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension at least
                      ( ( N*( N + 1 ) )/2 ).
                      Before entry, with  UPLO = 'U' or 'u', the array AP must
                      contain the upper triangular part of the symmetric matrix
                      packed sequentially, column by column, so that AP( 1 )
                      contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
                      and a( 2, 2 ) respectively, and so on. On exit, the array
                      AP is overwritten by the upper triangular part of the
                      updated matrix.
                      Before entry, with UPLO = 'L' or 'l', the array AP must
                      contain the lower triangular part of the symmetric matrix
                      packed sequentially, column by column, so that AP( 1 )
                      contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
                      and a( 3, 1 ) respectively, and so on. On exit, the array
                      AP is overwritten by the lower triangular part of the
                      updated matrix.
                      Note that the imaginary parts of the diagonal elements need
                      not be set, they are assumed to be zero, and on exit they
                      are set to zero.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ztprfb</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIRECT,</b> <b>character</b> <b>STOREV,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b>
       <b>integer</b> <b>K,</b> <b>integer</b> <b>L,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b>
       <b>integer</b> <b>LDT,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b>
       <b>LDB,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldwork,</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LDWORK)</b>
       <b>ZTPRFB</b> applies a real or complex 'triangular-pentagonal' blocked reflector to a real or complex matrix,
       which is composed of two blocks.

       <b>Purpose:</b>

            ZTPRFB applies a complex "triangular-pentagonal" block reflector H or its
            conjugate transpose H**H to a complex matrix C, which is composed of two
            blocks A and B, either from the left or right.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply H or H**H from the Left
                     = 'R': apply H or H**H from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply H (No transpose)
                     = 'C': apply H**H (Conjugate transpose)

           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Indicates how H is formed from a product of elementary
                     reflectors
                     = 'F': H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) (Forward)
                     = 'B': H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) (Backward)

           <u>STOREV</u>

                     STOREV is CHARACTER*1
                     Indicates how the vectors which define the elementary
                     reflectors are stored:
                     = 'C': Columns
                     = 'R': Rows

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix B.
                     M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix B.
                     N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The order of the matrix T, i.e. the number of elementary
                     reflectors whose product defines the block reflector.
                     K &gt;= 0.

           <u>L</u>

                     L is INTEGER
                     The order of the trapezoidal part of V.
                     K &gt;= L &gt;= 0.  See Further Details.

           <u>V</u>

                     V is COMPLEX*16 array, dimension
                                           (LDV,K) if STOREV = 'C'
                                           (LDV,M) if STOREV = 'R' and SIDE = 'L'
                                           (LDV,N) if STOREV = 'R' and SIDE = 'R'
                     The pentagonal matrix V, which contains the elementary reflectors
                     <a href="../man1/H.1.html">H</a>(1), <a href="../man2/H.2.html">H</a>(2), ..., H(K).  See Further Details.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If STOREV = 'C' and SIDE = 'L', LDV &gt;= max(1,M);
                     if STOREV = 'C' and SIDE = 'R', LDV &gt;= max(1,N);
                     if STOREV = 'R', LDV &gt;= K.

           <u>T</u>

                     T is COMPLEX*16 array, dimension (LDT,K)
                     The triangular K-by-K matrix T in the representation of the
                     block reflector.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.
                     LDT &gt;= K.

           <u>A</u>

                     A is COMPLEX*16 array, dimension
                     (LDA,N) if SIDE = 'L' or (LDA,K) if SIDE = 'R'
                     On entry, the K-by-N or M-by-K matrix A.
                     On exit, A is overwritten by the corresponding block of
                     H*C or H**H*C or C*H or C*H**H.  See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDA &gt;= max(1,K);
                     If SIDE = 'R', LDA &gt;= max(1,M).

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,N)
                     On entry, the M-by-N matrix B.
                     On exit, B is overwritten by the corresponding block of
                     H*C or H**H*C or C*H or C*H**H.  See Further Details.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.
                     LDB &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension
                     (LDWORK,N) if SIDE = 'L',
                     (LDWORK,K) if SIDE = 'R'.

           <u>LDWORK</u>

                     LDWORK is INTEGER
                     The leading dimension of the array WORK.
                     If SIDE = 'L', LDWORK &gt;= K;
                     if SIDE = 'R', LDWORK &gt;= M.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The matrix C is a composite matrix formed from blocks A and B.
             The block B is of size M-by-N; if SIDE = 'R', A is of size M-by-K,
             and if SIDE = 'L', A is of size K-by-N.

             If SIDE = 'R' and DIRECT = 'F', C = [A B].

             If SIDE = 'L' and DIRECT = 'F', C = [A]
                                                 [B].

             If SIDE = 'R' and DIRECT = 'B', C = [B A].

             If SIDE = 'L' and DIRECT = 'B', C = [B]
                                                 [A].

             The pentagonal matrix V is composed of a rectangular block V1 and a
             trapezoidal block V2.  The size of the trapezoidal block is determined by
             the parameter L, where 0&lt;=L&lt;=K.  If L=K, the V2 block of V is triangular;
             if L=0, there is no trapezoidal block, thus V = V1 is rectangular.

             If DIRECT = 'F' and STOREV = 'C':  V = [V1]
                                                    [V2]
                - V2 is upper trapezoidal (first L rows of K-by-K upper triangular)

             If DIRECT = 'F' and STOREV = 'R':  V = [V1 V2]

                - V2 is lower trapezoidal (first L columns of K-by-K lower triangular)

             If DIRECT = 'B' and STOREV = 'C':  V = [V2]
                                                    [V1]
                - V2 is lower trapezoidal (last L rows of K-by-K lower triangular)

             If DIRECT = 'B' and STOREV = 'R':  V = [V2 V1]

                - V2 is upper trapezoidal (last L columns of K-by-K upper triangular)

             If STOREV = 'C' and SIDE = 'L', V is M-by-K with V2 L-by-K.

             If STOREV = 'C' and SIDE = 'R', V is N-by-K with V2 L-by-K.

             If STOREV = 'R' and SIDE = 'L', V is K-by-M with V2 K-by-L.

             If STOREV = 'R' and SIDE = 'R', V is K-by-N with V2 K-by-L.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.10.0                                   Wed Jan 12 2022                      <u><a href="../man3/complex16OTHERauxiliary.3.html">complex16OTHERauxiliary</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>