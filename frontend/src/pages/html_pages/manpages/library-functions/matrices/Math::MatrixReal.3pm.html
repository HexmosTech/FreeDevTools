<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::MatrixReal - Matrix of Reals</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmath-matrixreal-perl">libmath-matrixreal-perl_2.13-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::MatrixReal - Matrix of Reals

       Implements the data type "matrix of real numbers" (and consequently also "vector of real numbers").

</pre><h4><b>SYNOPSIS</b></h4><pre>
       my $a = Math::MatrixReal-&gt;new_random(5, 5);

       my $b = $a-&gt;new_random(10, 30, { symmetric=&gt;1, bounded_by=&gt;[-1,1] });

       my $c = $b * $a ** 3;

       my $d = $b-&gt;new_from_rows( [ [ 5, 3 ,4], [3, 4, 5], [ 2, 4, 1 ] ] );

       print $a;

       my $row        = ($a * $b)-&gt;<b><a href="../man3/row.3.html">row</a></b>(3);

       my $col        = (5*$c)-&gt;<b><a href="../man2/col.2.html">col</a></b>(2);

       my $transpose  = ~$c;

       my $transpose  = $c-&gt;transpose;

       my $inverse    = $a-&gt;inverse;

       my $inverse    = 1/$a;

       my $inverse    = $a ** -1;

       my $determinant= $a-&gt;det;

       •   $matrix-&gt;display_precision($integer)

           Sets  the  default precision when matrices are printed or stringified.  $matrix-&gt;<b><a href="../man0/display_precision.0.html">display_precision</a></b>(0)
           will only show the integer part of all the entries of $matrix and  $matrix-&gt;<b>display_precision()</b>  will
           return  to  the default scientific display notation. This method does not effect the precision of the
           calculations.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>Constructor</b> <b>Methods</b> <b>And</b> <b>Such</b>
       •   use Math::MatrixReal;

           Makes the methods and overloaded operators of this module available to your program.

       •   $new_matrix = new Math::MatrixReal($rows,$columns);

           The matrix object constructor method. A new matrix of size $rows by $columns will  be  created,  with
           the value 0.0 for all elements.

           Note that this method is implicitly called by many of the other methods in this module.

       •   $new_matrix = $some_matrix-&gt;new($rows,$columns);

           Another way of calling the matrix object constructor method.

           Matrix $some_matrix is not changed by this in any way.

       •   $new_matrix = $matrix-&gt;new_from_cols( [ $column_vector|$array_ref|$string, ... ] )

           Creates a new matrix given a reference to an array of any of the following:

           •   column vectors ( n by 1 Math::MatrixReal matrices )

           •   references to arrays

           •   strings properly formatted to create a column with Math::MatrixReal's new_from_string command

           You  may  mix  and  match  these as you wish.  However, all must be of the same dimension--no padding
           happens automatically.  Example:

               my $matrix = Math::MatrixReal-&gt;new_from_cols( [ [1,2], [3,4] ] );
               print $matrix;

           will print

               [  1.000000000000E+00  3.000000000000E+00 ]
               [  2.000000000000E+00  4.000000000000E+00 ]

       •   new_from_rows( [ $row_vector|$array_ref|$string, ... ] )

           Creates a new matrix given a reference to an array of any of the following:

           •   row vectors ( 1 by n Math::MatrixReal matrices )

           •   references to arrays

           •   strings properly formatted to create a row with Math::MatrixReal's new_from_string command

           You may mix and match these as you wish.  However, all must be  of  the  same  dimension--no  padding
           happens automatically. Example:

                   my $matrix = Math::MatrixReal-&gt;new_from_rows( [ [1,2], [3,4] ] );
                   print $matrix;

           will print

                   [  1.000000000000E+00  2.000000000000E+00 ]
                   [  3.000000000000E+00  4.000000000000E+00 ]

       •   $new_matrix = Math::MatrixReal-&gt;new_random($rows, $cols, %options );

           This  method  allows you to create a random matrix with various properties controlled by the %options
           matrix, which is optional. The default values of the %options matrix are { integer =&gt; 0, symmetric =&gt;
           0, tridiagonal =&gt; 0, diagonal =&gt; 0, bounded_by =&gt; [0,10] } .

            Example:

               $matrix = Math::MatrixReal-&gt;new_random(4, { diagonal =&gt; 1, integer =&gt; 1 }  );
               print $matrix;

           will print a 4x4 random diagonal matrix with integer entries between zero and ten, something like

               [  5.000000000000E+00  0.000000000000E+00  0.000000000000E+00  0.000000000000E+00 ]
               [  0.000000000000E+00  2.000000000000E+00  0.000000000000E+00  0.000000000000E+00 ]
               [  0.000000000000E+00  0.000000000000E+00  1.000000000000E+00  0.000000000000E+00 ]
               [  0.000000000000E+00  0.000000000000E+00  0.000000000000E+00  8.000000000000E+00 ]

       •   $new_matrix = Math::MatrixReal-&gt;new_diag( $array_ref );

           This method allows you to create a diagonal matrix by only specifying the diagonal elements. Example:

               $matrix = Math::MatrixReal-&gt;new_diag( [ 1,2,3,4 ] );
               print $matrix;

           will print

               [  1.000000000000E+00  0.000000000000E+00  0.000000000000E+00  0.000000000000E+00 ]
               [  0.000000000000E+00  2.000000000000E+00  0.000000000000E+00  0.000000000000E+00 ]
               [  0.000000000000E+00  0.000000000000E+00  3.000000000000E+00  0.000000000000E+00 ]
               [  0.000000000000E+00  0.000000000000E+00  0.000000000000E+00  4.000000000000E+00 ]

       •   $new_matrix = Math::MatrixReal-&gt;new_tridiag( $lower, $diag, $upper );

           This method allows you to create a tridiagonal matrix by only specifying the lower diagonal, diagonal
           and upper diagonal, respectively.

               $matrix = Math::MatrixReal-&gt;new_tridiag( [ 6, 4, 2 ], [1,2,3,4], [1, 8, 9] );
               print $matrix;

           will print

               [  1.000000000000E+00  1.000000000000E+00  0.000000000000E+00  0.000000000000E+00 ]
               [  6.000000000000E+00  2.000000000000E+00  8.000000000000E+00  0.000000000000E+00 ]
               [  0.000000000000E+00  4.000000000000E+00  3.000000000000E+00  9.000000000000E+00 ]
               [  0.000000000000E+00  0.000000000000E+00  2.000000000000E+00  4.000000000000E+00 ]

       •   $new_matrix = Math::MatrixReal-&gt;new_from_string($string);

           This method allows you to read in a matrix from a string (for instance, from  the  keyboard,  from  a
           file or from your code).

           The syntax is simple: each row must start with ""[ "" and end with "" ]\n"" (""\n"" being the newline
           character and "" "" a space or tab) and contain one or more numbers, all separated from each other by
           spaces or tabs.

           Additional spaces or tabs can be added at will, but no comments.

           Examples:

             $string = "[ 1 2 3 ]\n[ 2 2 -1 ]\n[ 1 1 1 ]\n";
             $matrix = Math::MatrixReal-&gt;new_from_string($string);
             print "$matrix";

           By the way, this prints

             [  1.000000000000E+00  2.000000000000E+00  3.000000000000E+00 ]
             [  2.000000000000E+00  2.000000000000E+00 -1.000000000000E+00 ]
             [  1.000000000000E+00  1.000000000000E+00  1.000000000000E+00 ]

           But you can also do this in a much more comfortable way using the shell-like "here-document" syntax:

             $matrix = Math::MatrixReal-&gt;new_from_string(&lt;&lt;'MATRIX');
             [  1  0  0  0  0  0  1  ]
             [  0  1  0  0  0  0  0  ]
             [  0  0  1  0  0  0  0  ]
             [  0  0  0  1  0  0  0  ]
             [  0  0  0  0  1  0  0  ]
             [  0  0  0  0  0  1  0  ]
             [  1  0  0  0  0  0 -1  ]
             MATRIX

           You can even use variables in the matrix:

             $c1 =   2  /  3;
             $c2 =  -2  /  5;
             $c3 =  26  /  9;

             $matrix = Math::MatrixReal-&gt;new_from_string(&lt;&lt;"MATRIX");

                 [   3    2    0   ]
                 [   0    3    2   ]
                 [  $c1  $c2  $c3  ]

             MATRIX

           (Remember that you may use spaces and tabs to format the matrix to your taste)

           Note  that  this method uses exactly the same representation for a matrix as the "stringify" operator
           "": this means that you can convert any matrix into a string with "$string = "$matrix";" and read  it
           back in later (for instance from a file!).

           Note  however  that  you  may  suffer  a  precision  loss  in this process because only 13 digits are
           supported in the mantissa when printed!!

           If the string you supply (or someone else supplies) does not obey  the  syntax  mentioned  above,  an
           exception is raised, which can be caught by "eval" as follows:

             print "Please enter your matrix (in one line): ";
             $string = &lt;STDIN&gt;;
             $string =~ s/\\n/\n/g;
             eval { $matrix = Math::MatrixReal-&gt;new_from_string($string); };
             if ($@)
             {
                 print "$@";
                 # ...
                 # (error handling)
             }
             else
             {
                 # continue...
             }

           or as follows:

             eval { $matrix = Math::MatrixReal-&gt;new_from_string(&lt;&lt;"MATRIX"); };
             [   3    2    0   ]
             [   0    3    2   ]
             [  $c1  $c2  $c3  ]
             MATRIX
             if ($@)
             # ...

           Actually,  the  method  shown above for reading a matrix from the keyboard is a little awkward, since
           you have to enter a lot of "\n"'s for the newlines.

           A better way is shown in this piece of code:

             while (1)
             {
                 print "\nPlease enter your matrix ";
                 print "(multiple lines, &lt;ctrl-D&gt; = done):\n";
                 eval { $new_matrix =
                     Math::MatrixReal-&gt;new_from_string(join('',&lt;STDIN&gt;)); };
                 if ($@)
                 {
                     $@ =~ s/\s+at\b.*?$//;
                     print "${@}Please try again.\n";
                 }
                 else { last; }
             }

           Possible error messages of the "<b>new_from_string()</b>" method are:

             Math::MatrixReal::new_from_string(): syntax error in input string
             Math::MatrixReal::new_from_string(): empty input string

           If the input string has rows with varying numbers of columns, the following warning will  be  printed
           to STDERR:

             Math::MatrixReal::new_from_string(): missing elements will be set to zero!

           If  everything  is  okay,  the  method  returns  an  object reference to the (newly allocated) matrix
           containing the elements you specified.

       •   $new_matrix = $some_matrix-&gt;<b>shadow()</b>;

           Returns an object reference to a <b>NEW</b> but <b>EMPTY</b> matrix (filled with zero's) of the <b>SAME</b> <b>SIZE</b> as matrix
           "$some_matrix".

           Matrix "$some_matrix" is not changed by this in any way.

       •   $matrix1-&gt;copy($matrix2);

           Copies the contents of matrix "$matrix2" to an <b>ALREADY</b> <b>EXISTING</b> matrix "$matrix1"  (which  must  have
           the same size as matrix "$matrix2"!).

           Matrix "$matrix2" is not changed by this in any way.

       •   $twin_matrix = $some_matrix-&gt;<b>clone()</b>;

           Returns  an  object reference to a <b>NEW</b> matrix of the <b>SAME</b> <b>SIZE</b> as matrix "$some_matrix". The contents
           of matrix "$some_matrix" have <b>ALREADY</b> <b>BEEN</b> <b>COPIED</b> to the  new  matrix  "$twin_matrix".  This  is  the
           method that the operator "=" is overloaded to when you type "$a = $b", when $a and $b are matrices.

           Matrix "$some_matrix" is not changed by this in any way.

       •   $matrix = Math::MatrixReal-&gt;reshape($rows, $cols, $array_ref);

           Return  a  matrix  with  the  specified dimensions ($rows x $cols)  whose elements are taken from the
           array reference $array_ref.  The elements of the matrix are  accessed  in  column-major  order  (like
           Fortran arrays are stored).

                $matrix = Math::MatrixReal-&gt;reshape(4, 3, [1..12]);

           Creates the following matrix:

               [ 1    5    9 ]
               [ 2    6   10 ]
               [ 3    7   11 ]
               [ 4    8   12 ]

   <b>Matrix</b> <b>Row,</b> <b>Column</b> <b>and</b> <b>Element</b> <b>operations</b>
       •   $value = $matrix-&gt;element($row,$column);

           Returns  the  value  of  a specific element of the matrix "$matrix", located in row "$row" and column
           "$column".

           <b>NOTE:</b> Unlike Perl, matrices are indexed with base-one indexes. Thus, the first element of the  matrix
           is placed in the <b>first</b> line, <b>first</b> column:

               $elem = $matrix-&gt;element(1, 1); # first element of the matrix.

       •   $matrix-&gt;assign($row,$column,$value);

           Explicitly  assigns  a  value  "$value"  to  a single element of the matrix "$matrix", located in row
           "$row" and column "$column", thereby replacing the value previously stored there.

       •   $row_vector = $matrix-&gt;row($row);

           This is a projection method which returns an object reference to a <b>NEW</b> matrix (which  in  fact  is  a
           (row)  vector  since  it has only one row) to which row number "$row" of matrix "$matrix" has already
           been copied.

           Matrix "$matrix" is not changed by this in any way.

       •   $column_vector = $matrix-&gt;column($column);

           This is a projection method which returns an object reference to a <b>NEW</b> matrix (which  in  fact  is  a
           (column)  vector  since  it has only one column) to which column number "$column" of matrix "$matrix"
           has already been copied.

           Matrix "$matrix" is not changed by this in any way.

       •   @all_elements = $matrix-&gt;as_list;

           Get the contents of a Math::MatrixReal object as a Perl list.

           Example:

              my $matrix = Math::MatrixReal-&gt;new_from_rows([ [1, 2], [3, 4] ]);
              my @list = $matrix-&gt;as_list; # 1, 2, 3, 4

           This method is suitable for use with OpenGL. For example, there is need to rotate model around X-axis
           to 90 degrees clock-wise. That could be achieved via:

            use Math::Trig;
            use OpenGL;
            ...;
            my $axis = [1, 0, 0];
            my $angle = 90;
            ...
            my ($x, $y, $z) = @$axis;
            my $f = $angle;
            my $cos_f = cos(deg2rad($f));
            my $sin_f = sin(deg2rad($f));
            my $rotation = Math::MatrixReal-&gt;new_from_rows([
               [$cos_f+(1-$cos_f)*$x**2,    (1-$cos_f)*$x*$y-$sin_f*$z, (1-$cos_f)*$x*$z+$sin_f*$y, 0 ],
               [(1-$cos_f)*$y*$z+$sin_f*$z, $cos_f+(1-$cos_f)*$y**2 ,   (1-$cos_f)*$y*$z-$sin_f*$x, 0 ],
               [(1-$cos_f)*$z*$x-$sin_f*$y, (1-$cos_f)*$z*$y+$sin_f*$x, $cos_f+(1-$cos_f)*$z**2    ,0 ],
               [0,                          0,                          0,                          1 ],
            ]);
            ...;
            my $model_initial = Math::MatrixReal-&gt;new_diag( [1, 1, 1, 1] ); # identity matrix
            my $model = $model_initial * $rotation;
            $model = ~$model; # OpenGL operates on transposed matrices
            my $model_oga = OpenGL::Array-&gt;new_list(GL_FLOAT, $model-&gt;as_list);
            $shader-&gt;SetMatrix(model =&gt; $model_oga); # instance of OpenGL::Shader

           See         OpenGL,         OpenGL::Shader,          OpenGL::Array,          rotation          matrix
           &lt;https://en.wikipedia.org/wiki/Rotation_matrix&gt;.

       •   $new_matrix = $matrix-&gt;each( \&amp;function );

           Creates a new matrix by evaluating a code reference on each element of the given matrix. The function
           is  passed  the  element,  the  row index and the column index, in that order. The value the function
           returns ( or the value of the last executed statement ) is  the  value  given  to  the  corresponding
           element in $new_matrix.

           Example:

               # add 1 to every element in the matrix
               $matrix = $matrix-&gt;each ( sub { (shift) + 1 } );

           Example:

               my $cofactor = $matrix-&gt;each( sub { my(undef,$i,$j) = @_;
                   ($i+$j) % 2 == 0 ? $matrix-&gt;minor($i,$j)-&gt;det()
                   : -1*$matrix-&gt;minor($i,$j)-&gt;det();
                   } );

           This  code  needs  some explanation. For each element of $matrix, it throws away the actual value and
           stores the row and column indexes in $i and $j. Then it sets element  [$i,$j]  in  $cofactor  to  the
           determinant  of  "$matrix-&gt;minor($i,$j)" if it is an "even" element, or "-1*$matrix-&gt;minor($i,$j)" if
           it is an "odd" element.

       •   $new_matrix = $matrix-&gt;each_diag( \&amp;function );

           Creates a new matrix by evaluating a code reference on each diagonal element of the given matrix. The
           function is passed the element, the row index and the column index, in  that  order.  The  value  the
           function  returns  (  or  the  value  of  the  last  executed  statement  ) is the value given to the
           corresponding element in $new_matrix.

       •   $matrix-&gt;swap_col( $col1, $col2 );

           This method takes two one-based column numbers and swaps the values of each element in  each  column.
           "$matrix-&gt;swap_col(2,3)"  would  replace column 2 in $matrix with column 3, and replace column 3 with
           column 2.

       •   $matrix-&gt;swap_row( $row1, $row2 );

           This method takes two one-based row numbers and swaps  the  values  of  each  element  in  each  row.
           "$matrix-&gt;swap_row(2,3)" would replace row 2 in $matrix with row 3, and replace row 3 with row 2.

       •   $matrix-&gt;assign_row( $row_number , $new_row_vector );

           This  method takes a one-based row number and assigns row $row_number of $matrix with $new_row_vector
           and returns the resulting matrix.  "$matrix-&gt;assign_row(5, $x)" would replace row 5 in  $matrix  with
           the row vector $x.

       •   $matrix-&gt;<b>maximum()</b>;  and  $matrix-&gt;<b>minimum()</b>;

           These  two  methods  work similarly, one for computing the maximum element or elements from a matrix,
           and the minimum element or elements from a matrix.  They work  in  a  similar  way  as  Octave/MatLab
           max/min functions.

           When  computing  the  maximum  or minimum from a vector (vertical or horizontal), only one element is
           returned. When  computing the maximum or minimum from a matrix, the maximum/minimum element for  each
           column is returned in an array reference.

           When  called  in  list  context,  the  function  returns  a  pair,  where  the  first  element is the
           maximum/minimum element (or elements) and the second is the position of  that  value  in  the  vector
           (first occurrence), or the row where it occurs, for matrices.

           Consider the matrix and vector below for the following examples:

                      [ 1 9 4 ]
                 $A = [ 3 5 2 ]       $B = [ 8 7 9 5 3 ]
                      [ 8 7 6 ]

           When used in scalar context:

               $max = $A-&gt;maximum();    # $max = [ 8, 9, 6 ]
               $min = $B-&gt;minimum();    # $min = 3

           When used in list context:

               ($min, $pos) = $A-&gt;minimum(); # $min = [ 1 5 2 ]
                                             # $pos = [ 1 2 2 ]
               ($max, $pos) = $B-&gt;maximum(); # $max = 9
                                             # $pos = 3

   <b>Matrix</b> <b>Operations</b>
       •   "$det = $matrix-&gt;det();"

           Returns  the  determinant  of  the  matrix,  without  going  through the rigamarole of computing a LR
           decomposition. This method should be much faster than LR decomposition if the matrix is  diagonal  or
           triangular.  Otherwise,  it is just a wrapper for "$matrix-&gt;decompose_LR-&gt;det_LR". If the determinant
           is zero, there is no inverse and vice-versa. Only quadratic matrices have determinants.

       •   "$inverse = $matrix-&gt;inverse();"

           Returns  the  inverse  of  a  matrix,  without  going  through  the  rigamarole  of  computing  a  LR
           decomposition. If no inverse exists, undef is returned and an error is printed via "carp()".  This is
           nothing but a wrapper for "$matrix-&gt;decompose_LR-&gt;invert_LR".

       •   "($rows,$columns) = $matrix-&gt;dim();"

           Returns  a  list of two items, representing the number of rows and columns the given matrix "$matrix"
           contains.

       •   "$norm_one = $matrix-&gt;norm_one();"

           Returns the "one"-norm of the given matrix "$matrix".

           The "one"-norm is defined as follows:

           For each column, the sum of the absolute values of the elements in the different rows of that  column
           is calculated. Finally, the maximum of these sums is returned.

           Note  that the "one"-norm and the "maximum"-norm are mathematically equivalent, although for the same
           matrix they usually yield a different value.

           Therefore, you should only compare values that have been calculated using the same norm!

           Throughout this package, the "one"-norm is (arbitrarily) used for all comparisons, for  the  sake  of
           uniformity  and  comparability,  except  for  the  iterative methods "<b>solve_GSM()</b>", "<b>solve_SSM()</b>" and
           "<b>solve_RM()</b>" which use either norm depending on the matrix itself.

       •   "$norm_max = $matrix-&gt;norm_max();"

           Returns the "maximum"-norm of the given matrix $matrix.

           The "maximum"-norm is defined as follows:

           For each row, the sum of the absolute values of the elements in the different columns of that row  is
           calculated. Finally, the maximum of these sums is returned.

           Note  that the "maximum"-norm and the "one"-norm are mathematically equivalent, although for the same
           matrix they usually yield a different value.

           Therefore, you should only compare values that have been calculated using the same norm!

           Throughout this package, the "one"-norm is (arbitrarily) used for all comparisons, for  the  sake  of
           uniformity  and  comparability,  except  for  the  iterative methods "<b>solve_GSM()</b>", "<b>solve_SSM()</b>" and
           "<b>solve_RM()</b>" which use either norm depending on the matrix itself.

       •   "$norm_sum = $matrix-&gt;norm_sum();"

           This is a very simple norm which is defined as the sum of the absolute values of every element.

       •   $p_norm = $matrix-&gt;norm_p($n);&gt;

           This function returns the "p-norm" of a vector. The argument $n must be  a  number  greater  than  or
           equal  to  1  or  the string "Inf".  The p-norm is defined as (sum(x_i^p))^(1/p). In words, it raised
           each element to the p-th power, adds them up, and then takes the p-th root of  that  number.  If  the
           string "Inf" is passed, the "infinity-norm" is computed, which is really the limit of the p-norm as p
           goes  to  infinity.  It is defined as the maximum element of the vector. Also, note that the familiar
           Euclidean distance between two vectors is just a special case of a p-norm, when p is equal to 2.

           Example:
               $a = Math::MatrixReal-&gt;new_from_cols([[1,2,3]]);
               $p1   = $a-&gt;<b><a href="../man1/norm_p.1.html">norm_p</a></b>(1);
                   $p2   = $a-&gt;<b><a href="../man2/norm_p.2.html">norm_p</a></b>(2);
                   $p3   = $a-&gt;<b><a href="../man3/norm_p.3.html">norm_p</a></b>(3);
               $pinf = $a-&gt;norm_p("Inf");

               print "(1,2,3,Inf) norm:\n$p1\n$p2\n$p3\n$pinf\n";

               $i1 = $a-&gt;new_from_rows([[1,0]]);
               $i2 = $a-&gt;new_from_rows([[0,1]]);

               # this should be <a href="../man2/sqrt.2.html">sqrt</a>(2) since it is the same as the
               # hypotenuse of a 1 by 1 right triangle

               $dist  = ($i1-$i2)-&gt;<a href="../man2/norm_p.2.html">norm_p</a>(2);
               print "Distance is $dist, which should be " . <a href="../man2/sqrt.2.html">sqrt</a>(2) . "\n";

           Output:

               (1,2,3,Inf) norm:
               6
               3.74165738677394139
               3.30192724889462668
               3

               Distance is 1.41421356237309505, which should be 1.41421356237309505

       •   $frob_norm = "$matrix-&gt;norm_frobenius();"

           This norm is similar to that of a p-norm where p is 2, except it acts on a <b>matrix</b>, not a vector. Each
           element of the matrix is squared, this is added up, and then a square root is taken.

       •   "$matrix-&gt;spectral_radius();"

           Returns the maximum value of the absolute value of all  eigenvalues.   Currently  this  computes  <b>all</b>
           eigenvalues,  then sifts through them to find the largest in absolute value. Needless to say, this is
           very inefficient, and in the future an algorithm that computes only the  largest  eigenvalue  may  be
           implemented.

       •   "$matrix1-&gt;transpose($matrix2);"

           Calculates the transposed matrix of matrix $matrix2 and stores the result in matrix "$matrix1" (which
           must already exist and have the same size as matrix "$matrix2"!).

           This operation can also be carried out "in-place", i.e., input and output matrix may be identical.

           Transposition  is  a  symmetry  operation:  imagine  you rotate the matrix along the axis of its main
           diagonal (going through elements (1,1), (2,2), (3,3) and so on) by 180 degrees.

           Another way of looking at it is to say that rows and columns are swapped. In  fact  the  contents  of
           element "(i,j)" are swapped with those of element "(j,i)".

           Note that (especially for vectors) it makes a big difference if you have a row vector, like this:

             [ -1 0 1 ]

           or a column vector, like this:

             [ -1 ]
             [  0 ]
             [  1 ]

           the one vector being the transposed of the other!

           This is especially true for the matrix product of two vectors:

                          [ -1 ]
             [ -1 0 1 ] * [  0 ]  =  [ 2 ] ,  whereas
                          [  1 ]

                                        *     [ -1  0  1 ]
             [ -1 ]                                            [  1  0 -1 ]
             [  0 ] * [ -1 0 1 ]  =  [ -1 ]   [  1  0 -1 ]  =  [  0  0  0 ]
             [  1 ]                  [  0 ]   [  0  0  0 ]     [ -1  0  1 ]
                                     [  1 ]   [ -1  0  1 ]

           So be careful about what you really mean!

           Hint:  throughout this module, whenever a vector is explicitly required for input, a <b>COLUMN</b> vector is
           expected!

       •   "$trace = $matrix-&gt;trace();"

           This returns the trace of the matrix, which is defined as the  sum  of  the  diagonal  elements.  The
           matrix must be quadratic.

       •   "$minor = $matrix-&gt;minor($row,$col);"

           Returns  the minor matrix corresponding to $row and $col. $matrix must be quadratic.  If $matrix is n
           rows by n cols, the minor of $row and $col will be an (n-1) by (n-1) matrix. The minor is defined  as
           crossing  out the row and the col specified and returning the remaining rows and columns as a matrix.
           This method is used by "cofactor()".

       •   "$cofactor = $matrix-&gt;cofactor();"

           The cofactor matrix is constructed as follows:

           For each element, cross out the row and column that it sits in.  Now, take  the  determinant  of  the
           matrix  that  is left in the other rows and columns.  Multiply the determinant by (-1)^(i+j), where i
           is the row index, and j is the column index.  Replace the given element with this value.

           The cofactor matrix can be used to find the inverse of the matrix. One formula for the inverse  of  a
           matrix is the cofactor matrix transposed divided by the original determinant of the matrix.

           The following two inverses should be exactly the same:

               my $inverse1 = $matrix-&gt;inverse;
               my $inverse2 = ~($matrix-&gt;cofactor)-&gt;each( sub { (shift)/$matrix-&gt;det() } );

           Caveat:  Although the cofactor matrix is simple algorithm to compute the inverse of a matrix, and can
           be used with pencil and paper for small matrices, it is comically slower than the native  "inverse()"
           function. Here is a small benchmark:

               # $matrix1 is 15x15
               $det = $matrix1-&gt;det;
               timethese( 10,
                   {'inverse' =&gt; sub { $matrix1-&gt;inverse(); },
                     'cofactor' =&gt; sub { (~$matrix1-&gt;cofactor)-&gt;each ( sub { (shift)/$det; } ) }
                   } );

               Benchmark: timing 10 iterations of LR, cofactor, inverse...
                   inverse:  1 wallclock secs ( 0.56 usr +  0.00 sys =  0.56 CPU) @ 17.86/s (n=10)
               cofactor: 36 wallclock secs (36.62 usr +  0.01 sys = 36.63 CPU) @  0.27/s (n=10)

       •   "$adjoint = $matrix-&gt;adjoint();"

           The  adjoint  is  just  the  transpose  of  the  cofactor  matrix. This method is just an alias for "
           ~($matrix-&gt;cofactor)".

       •   "$part_of_matrix = $matrix-&gt;submatrix(x1,y1,x2,Y2);"

           Submatrix permits one to select only part of existing matrix in order to produce  a  new  one.   This
           method take four arguments to define a selection area:

           - firstly: Coordinate of top left corner to select (x1,y1)
           - secondly: Coordinate of bottom right corner to select (x2,y2)

           Example:

               my $matrix = Math::MatrixReal-&gt;new_from_string(&lt;&lt;'MATRIX');
               [  0  0  0  0  0  0  0  ]
               [  0  0  0  0  0  0  0  ]
               [  0  0  0  0  0  0  0  ]
               [  0  0  0  0  0  0  0  ]
               [  0  0  0  0  1  0  1  ]
               [  0  0  0  0  0  1  0  ]
               [  0  0  0  0  1  0  1  ]
               MATRIX

               my $submatrix = $matrix-&gt;submatrix(5,5,7,7);
               $submatrix-&gt;<a href="../man0/display_precision.0.html">display_precision</a>(0);
               print $submatrix;

           Output:

               [  1  0  1  ]
               [  0  1  0  ]
               [  1  0  1  ]

   <b>Arithmetic</b> <b>Operations</b>
       •   "$matrix1-&gt;add($matrix2,$matrix3);"

           Calculates  the  sum  of  matrix  "$matrix2"  and  matrix  "$matrix3" and stores the result in matrix
           "$matrix1" (which must already exist  and  have  the  same  size  as  matrix  "$matrix2"  and  matrix
           "$matrix3"!).

           This  operation  can  also be carried out "in-place", i.e., the output and one (or both) of the input
           matrices may be identical.

       •   "$matrix1-&gt;subtract($matrix2,$matrix3);"

           Calculates the difference of matrix "$matrix2" minus matrix  "$matrix3"  and  stores  the  result  in
           matrix  "$matrix1"  (which  must already exist and have the same size as matrix "$matrix2" and matrix
           "$matrix3"!).

           This operation can also be carried out "in-place", i.e., the output and one (or both)  of  the  input
           matrices may be identical.

           Note  that this operation is the same as "$matrix1-&gt;add($matrix2,-$matrix3);", although the latter is
           a little less efficient.

       •   "$matrix1-&gt;multiply_scalar($matrix2,$scalar);"

           Calculates the product of matrix "$matrix2" and the number "$scalar" (i.e., multiplies  each  element
           of  matrix  "$matrix2"  with  the factor "$scalar") and stores the result in matrix "$matrix1" (which
           must already exist and have the same size as matrix "$matrix2"!).

           This operation can also be carried out "in-place", i.e., input and output matrix may be identical.

       •   "$product_matrix = $matrix1-&gt;multiply($matrix2);"

           Calculates the product of matrix "$matrix1" and matrix "$matrix2" and returns an object reference  to
           a new matrix "$product_matrix" in which the result of this operation has been stored.

           Note  that  the dimensions of the two matrices "$matrix1" and "$matrix2" (i.e., their numbers of rows
           and columns) must harmonize in the following way (example):

                                     [ 2 2 ]
                                     [ 2 2 ]
                                     [ 2 2 ]

                         [ 1 1 1 ]   [ * * ]
                         [ 1 1 1 ]   [ * * ]
                         [ 1 1 1 ]   [ * * ]
                         [ 1 1 1 ]   [ * * ]

           I.e., the number of columns of matrix "$matrix1" has to be the same as the number of rows  of  matrix
           "$matrix2".

           The  number of rows and columns of the resulting matrix "$product_matrix" is determined by the number
           of rows of matrix "$matrix1" and the number of columns of matrix "$matrix2", respectively.

       •   "$matrix1-&gt;negate($matrix2);"

           Calculates the negative of matrix "$matrix2" (i.e., multiplies all elements with "-1") and stores the
           result in matrix "$matrix1" (which must already exist and have the same size as matrix "$matrix2"!).

           This operation can also be carried out "in-place", i.e., input and output matrix may be identical.

       •   "$matrix_to_power = $matrix1-&gt;exponent($integer);"

           Raises the matrix to the $integer power. Obviously, $integer must be an integer. If it is  zero,  the
           identity  matrix  is  returned.  If  a negative integer is given, the inverse will be computed (if it
           exists) and then raised the the absolute value of $integer. The matrix must be quadratic.

   <b>Boolean</b> <b>Matrix</b> <b>Operations</b>
       •   "$matrix-&gt;is_quadratic();"

           Returns a boolean value indicating if the given matrix is quadratic (also know as "square" or  "n  by
           n"). A matrix is quadratic if it has the same number of rows as it does columns.

       •   "$matrix-&gt;is_square();"

           This is an alias for "is_quadratic()".

       •   "$matrix-&gt;is_symmetric();"

           Returns  a  boolean  value  indicating  if  the given matrix is symmetric. By definition, a matrix is
           symmetric if and only if (<b>M</b>[<u>i</u>,<u>j</u>]=<b>M</b>[<u>j</u>,<u>i</u>]). This is equivalent to "($matrix == ~$matrix)"  but  without
           memory allocation.  Only quadratic matrices can be symmetric.

           Notes:  A  symmetric matrix always has real eigenvalues/eigenvectors.  A matrix plus its transpose is
           always symmetric.

       •   "$matrix-&gt;is_skew_symmetric();"

           Returns a boolean value indicating if the given matrix is skew symmetric. By definition, a matrix  is
           symmetric  if  and  only  if  (<b>M</b>[<u>i</u>,<u>j</u>]=<b>-M</b>[<u>j</u>,<u>i</u>]).  This is equivalent to "($matrix == -(~$matrix))" but
           without memory allocation.  Only quadratic matrices can be skew symmetric.

       •   "$matrix-&gt;is_diagonal();"

           Returns a boolean value indicating if the given matrix is diagonal, i.e. all of the nonzero  elements
           are on the main diagonal.  Only quadratic matrices can be diagonal.

       •   "$matrix-&gt;is_tridiagonal();"

           Returns  a  boolean  value  indicating  if  the  given matrix is tridiagonal, i.e. all of the nonzero
           elements are on the main diagonal or the diagonals above and below the main diagonal.  Only quadratic
           matrices can be tridiagonal.

       •   "$matrix-&gt;is_upper_triangular();"

           Returns a boolean value indicating if the given matrix is upper triangular, i.e. all of  the  nonzero
           elements  not  on  the  main diagonal are above it.  Only quadratic matrices can be upper triangular.
           Note: diagonal matrices are both upper and lower triangular.

       •   "$matrix-&gt;is_lower_triangular();"

           Returns a boolean value indicating if the given matrix is lower triangular, i.e. all of  the  nonzero
           elements  not  on  the  main diagonal are below it.  Only quadratic matrices can be lower triangular.
           Note: diagonal matrices are both upper and lower triangular.

       •   "$matrix-&gt;is_orthogonal();"

           Returns a boolean value indicating if the given matrix is orthogonal.  An orthogonal  matrix  is  has
           the  property  that  the  transpose  equals  the inverse of the matrix. Instead of computing each and
           comparing them, this method multiplies the matrix by it's transpose, and returns true if  this  turns
           out to be the identity matrix, false otherwise.  Only quadratic matrices can orthogonal.

       •   "$matrix-&gt;is_binary();"

           Returns  a boolean value indicating if the given matrix is binary.  A matrix is binary if it contains
           only zeroes or ones.

       •   "$matrix-&gt;is_gramian();"

           Returns a boolean value indicating if the give matrix is Gramian.  A matrix $A is Gramian if and only
           if there exists a square matrix $B such that "$A = ~$B*$B". This is equivalent to checking if  $A  is
           symmetric  and has all nonnegative eigenvalues, which is what Math::MatrixReal uses to check for this
           property.

       •   "$matrix-&gt;is_LR();"

           Returns a boolean value indicating if the matrix is an LR decomposition matrix.

       •   "$matrix-&gt;is_positive();"

           Returns a boolean value indicating if the matrix contains only positive entries.  Note  that  a  zero
           entry is not positive and will cause "is_positive()" to return false.

       •   "$matrix-&gt;is_negative();"

           Returns  a  boolean  value  indicating if the matrix contains only negative entries. Note that a zero
           entry is not negative and will cause "is_negative()" to return false.

       •   "$matrix-&gt;is_periodic($k);"

           Returns a boolean value indicating if the matrix is periodic with period $k. This is true if "$matrix
           ** ($k+1) == $matrix".  When "$k == 1", this reduces down to the "is_idempotent()" function.

       •   "$matrix-&gt;is_idempotent();"

           Returns a boolean value indicating if the matrix is idempotent, which is defined as the square of the
           matrix being equal to the original matrix, i.e "$matrix ** 2 == $matrix".

       •   "$matrix-&gt;is_row_vector();"

           Returns a boolean value indicating if the matrix is a row vector.  A row vector is a matrix which  is
           1xn. Note that the 1x1 matrix is both a row and column vector.

       •   "$matrix-&gt;is_col_vector();"

           Returns  a boolean value indicating if the matrix is a col vector.  A col vector is a matrix which is
           nx1. Note that the 1x1 matrix is both a row and column vector.

   <b>Eigensystems</b>
       • "($l, $V) = $matrix-&gt;sym_diagonalize();"

         This method performs the diagonalization of the quadratic <u>symmetric</u> matrix <b>M</b>  stored  in  $matrix.   On
         output,  <b>l</b>  is  a column vector containing all the eigenvalues of <b>M</b> and <b>V</b> is an orthogonal matrix which
         columns are the corresponding normalized eigenvectors.  The primary property of an eigenvalue <u>l</u> and  an
         eigenvector <b>x</b> is of course that: <b>M</b> * <b>x</b> = <u>l</u> * <b>x</b>.

         The  method  uses  a Householder reduction to tridiagonal form followed by a QL algorithm with implicit
         shifts on this tridiagonal. (The tridiagonal matrix is kept  internally  in  a  compact  form  in  this
         routine  to  save memory.)  In fact, this routine wraps the <b>householder()</b> and <b>tri_diagonalize()</b> methods
         described below when their intermediate results are not desired.  The overall algorithmic complexity of
         this technique is O(N^3). According to several books, the coefficient hidden by the 'O' is one  of  the
         best possible for general (symmetric) matrixes.

       • "($T, $Q) = $matrix-&gt;householder();"

         This  method  performs  the  Householder  algorithm  which  reduces  the <u>n</u> by <u>n</u> real <u>symmetric</u> matrix <b>M</b>
         contained in $matrix to tridiagonal form.  On  output,  <b>T</b>  is  a  symmetric  tridiagonal  matrix  (only
         diagonal  and  off-diagonal  elements  are  non-zero)  and  <b>Q</b>  is  an  <u>orthogonal</u> matrix performing the
         transformation between <b>M</b> and <b>T</b> ("$M == $Q * $T * ~$Q").

       • "($l, $V) = $T-&gt;tri_diagonalize([$Q]);"

         This method diagonalizes the symmetric tridiagonal matrix <b>T</b>. On output, $l and $V are  similar  to  the
         output values described for <b>sym_diagonalize()</b>.

         The  optional  argument  $Q  corresponds  to  an orthogonal transformation matrix <b>Q</b> that should be used
         additionally during <b>V</b> (eigenvectors) computation. It should be supplied  if  the  desired  eigenvectors
         correspond  to  a more general symmetric matrix <b>M</b> previously reduced by the <b>householder()</b> method, not a
         mere tridiagonal. If <b>T</b> is really a tridiagonal matrix, <b>Q</b> can be omitted (it will be internally  created
         in fact as an identity matrix).  The method uses a QL algorithm (with implicit shifts).

       • "$l = $matrix-&gt;sym_eigenvalues();"

         This method computes the eigenvalues of the quadratic <u>symmetric</u> matrix <b>M</b> stored in $matrix.  On output,
         <b>l</b>  is  a  column  vector  containing  all  the  eigenvalues of <b>M</b>. Eigenvectors are not computed (on the
         contrary of "sym_diagonalize()") and this method is more efficient  (even  though  it  uses  a  similar
         algorithm  with  two phases).  However, understand that the algorithmic complexity of this technique is
         still also O(N^3). But the coefficient hidden by the 'O' is better by a factor of...,  well,  see  your
         benchmark, it's wiser.

         This routine wraps the <b>householder_tridiagonal()</b> and <b>tri_eigenvalues()</b> methods described below when the
         intermediate tridiagonal matrix is not needed.

       • "$T = $matrix-&gt;householder_tridiagonal();"

         This  method  performs  the  Householder  algorithm  which  reduces  the <u>n</u> by <u>n</u> real <u>symmetric</u> matrix <b>M</b>
         contained in $matrix to tridiagonal form.  On output, <b>T</b> is the obtained  symmetric  tridiagonal  matrix
         (only  diagonal  and off-diagonal elements are non-zero). The operation is similar to the <b>householder()</b>
         method, but potentially a little more efficient as the transformation matrix is not computed.

       • $l = $T-&gt;<b>tri_eigenvalues()</b>;

         This method computesthe eigenvalues of the symmetric tridiagonal matrix <b>T</b>. On output, $l  is  a  vector
         containing  the  eigenvalues (similar to "sym_eigenvalues()").  This method is much more efficient than
         <b>tri_diagonalize()</b> when eigenvectors are not needed.

   <b>Miscellaneous</b>
       •   $matrix-&gt;<b>zero()</b>;

           Assigns a zero to every element of the matrix "$matrix", i.e., erases all  values  previously  stored
           there, thereby effectively transforming the matrix into a "zero"-matrix or "null"-matrix, the neutral
           element of the addition operation in a Ring.

           (For  instance  the  (quadratic)  matrices  with  "n"  rows  and  columns  and  matrix  addition  and
           multiplication form a Ring. Most prominent characteristic of a Ring is  that  multiplication  is  not
           commutative, i.e., in general, ""matrix1 * matrix2"" is not the same as ""matrix2 * matrix1""!)

       •   $matrix-&gt;<b>one()</b>;

           Assigns one's to the elements on the main diagonal (elements (1,1), (2,2), (3,3) and so on) of matrix
           "$matrix"  and  zero's  to  all  others,  thereby  erasing  all  values  previously  stored there and
           transforming the matrix into a "one"-matrix, the neutral element of the multiplication operation in a
           Ring.

           (If the matrix is quadratic (which this method doesn't require, though), then multiplying this matrix
           with itself yields this same matrix again, and multiplying it with  some  other  matrix  leaves  that
           other matrix unchanged!)

       •   "$latex_string = $matrix-&gt;as_latex( align=&gt; "c", format =&gt; "%s", name =&gt; "" );"

           This  function  returns the matrix as a LaTeX string. It takes a hash as an argument which is used to
           control the style of the output. The hash element "align" may be "c","l"  or  "r",  corresponding  to
           center,  left  and  right,  respectively.  The  "format"  element is a format string that is given to
           "sprintf" to control the style of number format, such a floating point or  scientific  notation.  The
           "name" element can be used so that a LaTeX string of "$name = " is prepended to the string.

           Example:

               my $a = Math::MatrixReal-&gt;new_from_cols([[ 1.234, 5.678, 9.1011],[1,2,3]] );
               print $a-&gt;as_latex( ( format =&gt; "%.2f", align =&gt; "l",name =&gt; "A" ) );

               Output:
               $A = $ $
               \left( \begin{array}{ll}
               1.23&amp;1.00 \\
               5.68&amp;2.00 \\
               9.10&amp;3.00
               \end{array} \right)
               $

       •   "$yacas_string = $matrix-&gt;as_yacas( format =&gt; "%s", name =&gt; "", semi =&gt; 0 );"

           This  function  returns  the  matrix as a string that can be read by Yacas.  It takes a hash as an an
           argument which controls the style of the output. The "format" element is  a  format  string  that  is
           given  to  "sprintf"  to  control  the  style  of  number format, such a floating point or scientific
           notation. The "name" element can be used so that "$name = " is prepended to the  string.  The  &lt;semi&gt;
           element can be set to 1 to that a semicolon is appended (so Matlab does not print out the matrix.)

           Example:

               $a = Math::MatrixReal-&gt;new_from_cols([[ 1.234, 5.678, 9.1011],[1,2,3]] );
               print $a-&gt;as_yacas( ( format =&gt; "%.2f", align =&gt; "l",name =&gt; "A" ) );

           Output:

               A := {{1.23,1.00},{5.68,2.00},{9.10,3.00}}

       •   "$matlab_string = $matrix-&gt;as_matlab( format =&gt; "%s", name =&gt; "", semi =&gt; 0 );"

           This  function  returns  the  matrix as a string that can be read by Matlab. It takes a hash as an an
           argument which controls the style of the output. The "format" element is  a  format  string  that  is
           given  to  "sprintf"  to  control  the  style  of  number format, such a floating point or scientific
           notation. The "name" element can be used so that "$name = " is prepended to the  string.  The  &lt;semi&gt;
           element can be set to 1 to that a semicolon is appended (so Matlab does not print out the matrix.)

           Example:

                   my $a = Math::MatrixReal-&gt;new_from_rows([[ 1.234, 5.678, 9.1011],[1,2,3]] );
                   print $a-&gt;as_matlab( ( format =&gt; "%.3f", name =&gt; "A",semi =&gt; 1 ) );

           Output:
                   A = [ 1.234 5.678 9.101;
                    1.000 2.000 3.000];

       •   "$scilab_string = $matrix-&gt;as_scilab( format =&gt; "%s", name =&gt; "", semi =&gt; 0 );"

           This  function  is just an alias for "as_matlab()", since both Scilab and Matlab have the same matrix
           format.

       •   "$minimum = Math::MatrixReal::min($number1,$number2);" "$minimum  =  Math::MatrixReal::min($matrix);"
           "&lt;$minimum = $matrix-"min;&gt;&gt;

           Returns  the  minimum of the two numbers ""number1"" and ""number2"" if called with two arguments, or
           returns the value of the smallest element of a matrix if called with one argument  or  as  an  object
           method.

       •   "$maximum          =          Math::MatrixReal::max($number1,$number2);"          "$maximum         =
           Math::MatrixReal::max($number1,$number2);" "$maximum = Math::MatrixReal::max($matrix);" "&lt;$maximum  =
           $matrix-"max;&gt;&gt;

           Returns  the  maximum of the two numbers ""number1"" and ""number2"" if called with two arguments, or
           returns the value of the largest element of a matrix if called with one  arguemnt  or  as  on  object
           method.

       •   "$minimal_cost_matrix = $cost_matrix-&gt;kleene();"

           Copies the matrix "$cost_matrix" (which has to be quadratic!) to a new matrix of the same size (i.e.,
           "clones" the input matrix) and applies Kleene's algorithm to it.

           See <b>Math::<a href="../man3/Kleene.3.html">Kleene</a></b>(3) for more details about this algorithm!

           The method returns an object reference to the new matrix.

           Matrix "$cost_matrix" is not changed by this method in any way.

       •   "($norm_matrix,$norm_vector) = $matrix-&gt;normalize($vector);"

           This method is used to improve the numerical stability when solving linear equation systems.

           Suppose you have a matrix "A" and a vector "b" and you want to find out a vector "x" so that "A * x =
           b",  i.e.,  the  vector  "x"  which  solves the equation system represented by the matrix "A" and the
           vector "b".

           Applying this method to the pair (A,b) yields a pair (A',b') where each row has been divided by  (the
           absolute  value of) the greatest coefficient appearing in that row. So this coefficient becomes equal
           to "1" (or "-1") in the new pair (A',b') (all others become smaller than one and greater  than  minus
           one).

           Note  that  this  operation  does  not change the equation system itself because the same division is
           carried out on either side of the equation sign!

           The method requires a quadratic (!) matrix "$matrix" and a vector "$vector"  for  input  (the  vector
           must  be  a column vector with the same number of rows as the input matrix) and returns a list of two
           items which are object references to a new matrix and a new vector, in this order.

           The output matrix and vector are clones of the  input  matrix  and  vector  to  which  the  operation
           explained above has been applied.

           The input matrix and vector are not changed by this in any way.

           Example  of how this method can affect the result of the methods to solve equation systems (explained
           immediately below following this method):

           Consider the following little program:

             #!perl -w

             use Math::MatrixReal qw(new_from_string);

             $A = Math::MatrixReal-&gt;new_from_string(&lt;&lt;"MATRIX");
             [  1   2   3  ]
             [  5   7  11  ]
             [ 23  19  13  ]
             MATRIX

             $b = Math::MatrixReal-&gt;new_from_string(&lt;&lt;"MATRIX");
             [   0   ]
             [   1   ]
             [  29   ]
             MATRIX

             $LR = $A-&gt;decompose_LR();
             if (($dim,$x,$B) = $LR-&gt;solve_LR($b))
             {
                 $test = $A * $x;
                 print "x = \n$x";
                 print "A * x = \n$test";
             }

             ($A_,$b_) = $A-&gt;normalize($b);

             $LR = $A_-&gt;decompose_LR();
             if (($dim,$x,$B) = $LR-&gt;solve_LR($b_))
             {
                 $test = $A * $x;
                 print "x = \n$x";
                 print "A * x = \n$test";
             }

           This will print:

             x =
             [  1.000000000000E+00 ]
             [  1.000000000000E+00 ]
             [ -1.000000000000E+00 ]
             A * x =
             [  4.440892098501E-16 ]
             [  1.000000000000E+00 ]
             [  2.900000000000E+01 ]
             x =
             [  1.000000000000E+00 ]
             [  1.000000000000E+00 ]
             [ -1.000000000000E+00 ]
             A * x =
             [  0.000000000000E+00 ]
             [  1.000000000000E+00 ]
             [  2.900000000000E+01 ]

           You can see that in the second example (where "<b>normalize()</b>" has been used), the result  is  "better",
           i.e., more accurate!

       •   "$LR_matrix = $matrix-&gt;decompose_LR();"

           This method is needed to solve linear equation systems.

           Suppose you have a matrix "A" and a vector "b" and you want to find out a vector "x" so that "A * x =
           b",  i.e.,  the  vector  "x"  which  solves the equation system represented by the matrix "A" and the
           vector "b".

           You might also have a matrix "A" and a whole bunch of different vectors "b1".."bk" for which you need
           to find vectors "x1".."xk" so that "A * xi = bi", for "i=1..k".

           Using Gaussian transformations (multiplying a row or column with a factor, swapping two rows  or  two
           columns  and  adding  a  multiple  of  one row or column to another), it is possible to decompose any
           matrix "A" into two triangular matrices, called "L" and "R" (for "Left" and "Right").

           "L" has one's on the main diagonal (the elements (1,1), (2,2), (3,3) and so so), non-zero  values  to
           the left and below of the main diagonal and all zero's in the upper right half of the matrix.

           "R"  has  non-zero values on the main diagonal as well as to the right and above of the main diagonal
           and all zero's in the lower left half of the matrix, as follows:

                     [ 1 0 0 0 0 ]      [ x x x x x ]
                     [ x 1 0 0 0 ]      [ 0 x x x x ]
                 L = [ x x 1 0 0 ]  R = [ 0 0 x x x ]
                     [ x x x 1 0 ]      [ 0 0 0 x x ]
                     [ x x x x 1 ]      [ 0 0 0 0 x ]

           Note that ""L * R"" is equivalent to matrix "A" in the sense that "L * R * x = b  &lt;==&gt;  A *  x  =  b"
           for  all  vectors  "x",  leaving out of account permutations of the rows and columns (these are taken
           care of "magically" by this module!) and numerical errors.

           Trick:

           Because we know that "L" has one's on its main diagonal, we can store both matrices together  in  the
           same array without information loss! I.e.,

                            [ R R R R R ]
                            [ L R R R R ]
                       LR = [ L L R R R ]
                            [ L L L R R ]
                            [ L L L L R ]

           Beware, though, that "LR" and ""L * R"" are not the same!!!

           Note  also  that  for  the  same  reason,  you  cannot  apply  the  method  "<b>normalize()</b>"  to an "LR"
           decomposition matrix. Trying to do so will yield meaningless rubbish!

           (You need to apply "<b>normalize()</b>" to each pair (Ai,bi) <b>BEFORE</b> decomposing the matrix "Ai'"!)

           Now what does all this help us in solving linear equation systems?

           It helps us because a triangular matrix is the next best thing  that  can  happen  to  us  besides  a
           diagonal  matrix  (a  matrix  that  has non-zero values only on its main diagonal - in which case the
           solution is trivial, simply divide ""b[i]"" by ""A[i,i]"" to get ""x[i]""!).

           To find the solution to our problem ""A * x = b"", we  divide  this  problem  in  parts:  instead  of
           solving  "A  *  x = b" directly, we first decompose "A" into "L" and "R" and then solve ""L * y = b""
           and finally ""R * x = y"" (motto: divide and rule!).

           From the illustration above it is clear  that  solving  ""L  *  y  =  b""  and  ""R  *  x  =  y""  is
           straightforward: we immediately know that "y[1] = b[1]". We then deduce swiftly that

             y[2] = b[2] - L[2,1] * y[1]

           (and we know ""y[1]"" by now!), that

             y[3] = b[3] - L[3,1] * y[1] - L[3,2] * y[2]

           and so on.

           Having  effortlessly  calculated  the  vector  "y",  we  now proceed to calculate the vector "x" in a
           similar fashion: we see immediately that "x[n] = y[n] / R[n,n]". It follows that

             x[n-1] = ( y[n-1] - R[n-1,n] * x[n] ) / R[n-1,n-1]

           and

             x[n-2] = ( y[n-2] - R[n-2,n-1] * x[n-1] - R[n-2,n] * x[n] )
                      / R[n-2,n-2]

           and so on.

           You can see that - especially when you have many vectors  "b1".."bk"  for  which  you  are  searching
           solutions to "A * xi = bi" - this scheme is much more efficient than a straightforward, "brute force"
           approach.

           This method requires a quadratic matrix as its input matrix.

           If  you don't have that many equations, fill up with zero's (i.e., do nothing to fill the superfluous
           rows if it's a "fresh" matrix, i.e., a matrix that has been created with "<b>new()</b>" or "<b>shadow()</b>").

           The method returns an object reference to a new matrix containing the matrices "L" and "R".

           The input matrix is not changed by this method in any way.

           Note that you can "<b>copy()</b>" or "<b>clone()</b>" the result  of  this  method  without  losing  its  "magical"
           properties (for instance concerning the hidden permutations of its rows and columns).

           However, as soon as you are applying any method that alters the contents of the matrix, its "magical"
           properties  are  stripped  off,  and the matrix immediately reverts to an "ordinary" matrix (with the
           values it just happens to contain at that moment, be they meaningful as an ordinary matrix or not!).

       •   "($dimension,$x_vector,$base_matrix) = $LR_matrix""-&gt;""solve_LR($b_vector);"

           Use this method to actually solve an equation system.

           Matrix "$LR_matrix" must be a (quadratic) matrix returned by  the  method  "<b>decompose_LR()</b>",  the  LR
           decomposition matrix of the matrix "A" of your equation system "A * x = b".

           The  input  vector "$b_vector" is the vector "b" in your equation system "A * x = b", which must be a
           column vector and have the same number of rows as the input matrix "$LR_matrix".

           The method returns a list of three items if a solution exists or an empty list otherwise (!).

           Therefore, you should always use this method like this:

             if ( ($dim,$x_vec,$base) = $LR-&gt;solve_LR($b_vec) )
             {
                 # do something with the solution...
             }
             else
             {
                 # do something with the fact that there is no solution...
             }

           The three items returned are: the dimension "$dimension" of the solution space (which is zero if only
           one solution exists, one if the solution is a straight line, two if the solution is a plane,  and  so
           on),  the  solution  vector "$x_vector" (which is the vector "x" of your equation system "A * x = b")
           and a matrix "$base_matrix" representing a base of the solution space (a set of vectors which put  up
           the solution space like the spokes of an umbrella).

           Only  the  first  "$dimension"  columns  of  this base matrix actually contain entries, the remaining
           columns are all zero.

           Now what is all this stuff with that "base" good for?

           The output vector "x" is <b>ALWAYS</b> a solution of your equation system "A * x = b".

           But also any vector "$vector"

             $vector = $x_vector-&gt;clone();

             $machine_infinity = 1E+99; # or something like that

             for ( $i = 1; $i &lt;= $dimension; $i++ )
             {
                 $vector += rand($machine_infinity) * $base_matrix-&gt;column($i);
             }

           is a solution to your problem "A * x = b", i.e., if "$A_matrix" contains your matrix "A", then

             print abs( $A_matrix * $vector - $b_vector ), "\n";

           should print a number around 1E-16 or so!

           By the way, note that you can actually calculate those vectors "$vector" a little more  efficient  as
           follows:

             $rand_vector = $x_vector-&gt;shadow();

             $machine_infinity = 1E+99; # or something like that

             for ( $i = 1; $i &lt;= $dimension; $i++ )
             {
                 $rand_vector-&gt;assign($i,1, rand($machine_infinity) );
             }

             $vector = $x_vector + ( $base_matrix * $rand_vector );

           Note that the input matrix and vector are not changed by this method in any way.

       •   "$inverse_matrix = $LR_matrix-&gt;invert_LR();"

           Use  this method to calculate the inverse of a given matrix "$LR_matrix", which must be a (quadratic)
           matrix returned by the method "<b>decompose_LR()</b>".

           The method returns an object reference to a  new  matrix  of  the  same  size  as  the  input  matrix
           containing  the  inverse  of  the  matrix that you initially fed into "<b>decompose_LR()</b>" <b>IF</b> <b>THE</b> <b>INVERSE</b>
           <b>EXISTS</b>, or an empty list otherwise.

           Therefore, you should always use this method in the following way:

             if ( $inverse_matrix = $LR-&gt;invert_LR() )
             {
                 # do something with the inverse matrix...
             }
             else
             {
                 # do something with the fact that there is no inverse matrix...
             }

           Note that by definition (disregarding numerical errors), the product of the initial  matrix  and  its
           inverse  (or  vice-versa)  is  always a matrix containing one's on the main diagonal (elements (1,1),
           (2,2), (3,3) and so on) and zero's elsewhere.

           The input matrix is not changed by this method in any way.

       •   "$condition = $matrix-&gt;condition($inverse_matrix);"

           In fact this method is just a shortcut for

             abs($matrix) * abs($inverse_matrix)

           Both input matrices must be quadratic and have the same size, and the result is  meaningful  only  if
           one of them is the inverse of the other (for instance, as returned by the method "<b>invert_LR()</b>").

           The number returned is a measure of the "condition" of the given matrix "$matrix", i.e., a measure of
           the numerical stability of the matrix.

           This  number  is  always  positive, and the smaller its value, the better the condition of the matrix
           (the better the stability of all subsequent computations carried out using this matrix).

           Numerical stability means for example that if

             abs( $vec_correct - $vec_with_error ) &lt; $epsilon

           holds,  there  must  be  a  "$delta"  which  doesn't  depend  on  the  vector   "$vec_correct"   (nor
           "$vec_with_error", by the way) so that

             abs( $matrix * $vec_correct - $matrix * $vec_with_error ) &lt; $delta

           also holds.

       •   "$determinant = $LR_matrix-&gt;det_LR();"

           Calculates  the  determinant  of  a  matrix, whose LR decomposition matrix "$LR_matrix" must be given
           (which must be a (quadratic) matrix returned by the method "<b>decompose_LR()</b>").

           In fact the determinant is a by-product of the LR decomposition: It is (in principle, that is, except
           for the sign) simply the product of the elements on the main diagonal (elements (1,1),  (2,2),  (3,3)
           and so on) of the LR decomposition matrix.

           (The sign is taken care of "magically" by this module)

       •   "$order = $LR_matrix-&gt;order_LR();"

           Calculates  the  order  (called  "Rang"  in  German)  of  a  matrix,  whose  LR  decomposition matrix
           "$LR_matrix"  must  be  given  (which  must  be  a  (quadratic)  matrix  returned   by   the   method
           "<b>decompose_LR()</b>").

           This  number  is  a  measure  of the number of linear independent row and column vectors (= number of
           linear independent equations in the case of a matrix representing an equation system) of  the  matrix
           that was initially fed into "<b>decompose_LR()</b>".

           If  "n"  is  the  number  of  rows  and  columns  of the (quadratic!) matrix, then "n - order" is the
           dimension of the solution space of the associated equation system.

       •   "$rank = $LR_matrix-&gt;rank_LR();"

           This is an alias for the "order_LR()" function. The "order" is  usually  called  the  "rank"  in  the
           United States.

       •   "$scalar_product = $vector1-&gt;scalar_product($vector2);"

           Returns the scalar product of vector "$vector1" and vector "$vector2".

           Both vectors must be column vectors (i.e., a matrix having several rows but only one column).

           This is a (more efficient!) shortcut for

             $temp           = ~$vector1 * $vector2;
             $scalar_product =  $temp-&gt;element(1,1);

           or the sum "i=1..n" of the products "vector1[i] * vector2[i]".

           Provided none of the two input vectors is the null vector, then the two vectors are orthogonal, i.e.,
           have an angle of 90 degrees between them, exactly when their scalar product is zero, and vice-versa.

       •   "$vector_product = $vector1-&gt;vector_product($vector2);"

           Returns the vector product of vector "$vector1" and vector "$vector2".

           Both vectors must be column vectors (i.e., a matrix having several rows but only one column).

           Currently, the vector product is only defined for 3 dimensions (i.e., vectors with 3 rows); all other
           vectors trigger an error message.

           In 3 dimensions, the vector product of two vectors "x" and "y" is defined as

                         |  x[1]  y[1]  e[1]  |
             determinant |  x[2]  y[2]  e[2]  |
                         |  x[3]  y[3]  e[3]  |

           where  the ""x[i]"" and ""y[i]"" are the components of the two vectors "x" and "y", respectively, and
           the ""e[i]"" are unity vectors (i.e., vectors with a length equal to one) with a one in row  "i"  and
           zero's elsewhere (this means that you have numbers and vectors as elements in this matrix!).

           This determinant evaluates to the rather simple formula

             z[1] = x[2] * y[3] - x[3] * y[2]
             z[2] = x[3] * y[1] - x[1] * y[3]
             z[3] = x[1] * y[2] - x[2] * y[1]

           A characteristic property of the vector product is that the resulting vector is orthogonal to both of
           the  input  vectors  (if  neither  of  both is the null vector, otherwise this is trivial), i.e., the
           scalar product of each of the input vectors with the resulting vector is always zero.

       •   "$length = $vector-&gt;length();"

           This is actually a shortcut for

             $length = sqrt( $vector-&gt;scalar_product($vector) );

           and returns the length of a given column or row vector "$vector".

           Note that the "length" calculated by this method  is  in  fact  the  "two"-norm  (also  know  as  the
           Euclidean norm) of a vector "$vector"!

           The general definition for norms of vectors is the following:

             sub vector_norm
             {
                 croak "Usage: \$norm = \$vector-&gt;vector_norm(\$n);"
                   if (@_ != 2);

                 my($vector,$n) = @_;
                 my($rows,$cols) = ($vector-&gt;[1],$vector-&gt;[2]);
                 my($k,$comp,$sum);

                 croak "Math::MatrixReal::vector_norm(): vector is not a column vector"
                   unless ($cols == 1);

                 croak "Math::MatrixReal::vector_norm(): norm index must be &gt; 0"
                   unless ($n &gt; 0);

                 croak "Math::MatrixReal::vector_norm(): norm index must be integer"
                   unless ($n == int($n));

                 $sum = 0;
                 for ( $k = 0; $k &lt; $rows; $k++ )
                 {
                     $comp = abs( $vector-&gt;[0][$k][0] );
                     $sum += $comp ** $n;
                 }
                 return( $sum ** (1 / $n) );
             }

           Note  that  the  case "n = 1" is the "one"-norm for matrices applied to a vector, the case "n = 2" is
           the euclidian norm or length of a vector, and if "n" goes to infinity, you have  the  "infinity"-  or
           "maximum"-norm for matrices applied to a vector!

       •   "$xn_vector = $matrix-&gt;""solve_GSM($x0_vector,$b_vector,$epsilon);"

       •   "$xn_vector = $matrix-&gt;""solve_SSM($x0_vector,$b_vector,$epsilon);"

       •   "$xn_vector = $matrix-&gt;""solve_RM($x0_vector,$b_vector,$weight,$epsilon);"

           In  some cases it might not be practical or desirable to solve an equation system ""A * x = b"" using
           an analytical algorithm like the "<b>decompose_LR()</b>" and "<b>solve_LR()</b>" method pair.

           In fact in some cases, due to the numerical properties (the  "condition")  of  the  matrix  "A",  the
           numerical  error  of  the  obtained  result can be greater than by using an approximative (iterative)
           algorithm like one of the three implemented here.

           All three methods, GSM ("Global Step Method" or "Gesamtschrittverfahren"), SSM ("Single Step  Method"
           or  "Einzelschrittverfahren")  and  RM ("Relaxation Method" or "Relaxationsverfahren"), are fix-point
           iterations, that is, can be described by an iteration function ""x(t+1) = Phi( x(t) )"" which has the
           property:

             Phi(x)  =  x    &lt;==&gt;    A * x  =  b

           We can define "Phi(x)" as follows:

             Phi(x)  :=  ( En - A ) * x  +  b

           where "En" is a matrix of the same size as "A" ("n" rows and columns) with one's on its main diagonal
           and zero's elsewhere.

           This function has the required property.

           Proof:

                      A * x        =   b

             &lt;==&gt;  -( A * x )      =  -b

             &lt;==&gt;  -( A * x ) + x  =  -b + x

             &lt;==&gt;  -( A * x ) + x + b  =  x

             &lt;==&gt;  x - ( A * x ) + b  =  x

             &lt;==&gt;  ( En - A ) * x + b  =  x

           This last step is true because

             x[i] - ( a[i,1] x[1] + ... + a[i,i] x[i] + ... + a[i,n] x[n] ) + b[i]

           is the same as

             ( -a[i,1] x[1] + ... + (1 - a[i,i]) x[i] + ... + -a[i,n] x[n] ) + b[i]

           qed

           Note that actually solving the equation system ""A * x = b"" means to calculate

                   a[i,1] x[1] + ... + a[i,i] x[i] + ... + a[i,n] x[n]  =  b[i]

             &lt;==&gt;  a[i,i] x[i]  =
                   b[i]
                   - ( a[i,1] x[1] + ... + a[i,i] x[i] + ... + a[i,n] x[n] )
                   + a[i,i] x[i]

             &lt;==&gt;  x[i]  =
                   ( b[i]
                       - ( a[i,1] x[1] + ... + a[i,i] x[i] + ... + a[i,n] x[n] )
                       + a[i,i] x[i]
                   ) / a[i,i]

             &lt;==&gt;  x[i]  =
                   ( b[i] -
                       ( a[i,1] x[1] + ... + a[i,i-1] x[i-1] +
                         a[i,i+1] x[i+1] + ... + a[i,n] x[n] )
                   ) / a[i,i]

           There is one major restriction, though: a fix-point iteration is guaranteed to converge only  if  the
           first  derivative of the iteration function has an absolute value less than one in an area around the
           point "x(*)" for which ""Phi( x(*) ) = x(*)"" is to be true, and if  the  start  vector  "<a href="../man0/x.0.html">x</a>(0)"  lies
           within that area!

           This  is  best  verified  graphically,  which  unfortunately  is  impossible  to  do  in this textual
           documentation!

           See literature on Numerical Analysis for details!

           In our case, this restriction translates to the following three conditions:

           There must exist a norm so that the norm of the matrix of the iteration function, "( En - A )", has a
           value less than one, the matrix "A" may not have any zero value on its main diagonal and the  initial
           vector "<a href="../man0/x.0.html">x</a>(0)" must be "good enough", i.e., "close enough" to the solution "x(*)".

           (Remember school math: the first derivative of a straight line given by ""y = a * x + b"" is "a"!)

           The  three  methods  expect  a  (quadratic!) matrix "$matrix" as their first argument, a start vector
           "$x0_vector", a vector "$b_vector" (which is the vector "b" in your equation system ""A * x  =  b""),
           in the case of the "Relaxation Method" ("RM"), a real number "$weight" best between zero and two, and
           finally an error limit (real number) "$epsilon".

           (Note  that  the weight "$weight" used by the "Relaxation Method" ("RM") is <b>NOT</b> checked to lie within
           any reasonable range!)

           The three methods first test the first two conditions of the three conditions listed above and return
           an empty list if these conditions are not fulfilled.

           Therefore, you should always test their return value using some code like:

             if ( $xn_vector = $A_matrix-&gt;solve_GSM($x0_vector,$b_vector,1E-12) )
             {
                 # do something with the solution...
             }
             else
             {
                 # do something with the fact that there is no solution...
             }

           Otherwise, they iterate until "abs( Phi(x) - x ) &lt; epsilon".

           (Beware that theoretically, infinite loops might result if the starting vector is too far  "off"  the
           solution!  In  practice,  this  shouldn't  be a problem. Anyway, you can always press &lt;ctrl-C&gt; if you
           think that the iteration takes too long!)

           The difference between the three methods is the following:

           In the "Global Step Method" ("GSM"), the new vector ""x(t+1)"" (called "y" here) is  calculated  from
           the vector "x(t)" (called "x" here) according to the formula:

             y[i] =
             ( b[i]
                 - ( a[i,1] x[1] + ... + a[i,i-1] x[i-1] +
                     a[i,i+1] x[i+1] + ... + a[i,n] x[n] )
             ) / a[i,i]

           In  the "Single Step Method" ("SSM"), the components of the vector ""x(t+1)"" which have already been
           calculated are used to calculate the remaining components, i.e.

             y[i] =
             ( b[i]
                 - ( a[i,1] y[1] + ... + a[i,i-1] y[i-1] +  # note the "y[]"!
                     a[i,i+1] x[i+1] + ... + a[i,n] x[n] )  # note the "x[]"!
             ) / a[i,i]

           In the "Relaxation method" ("RM"), the components of the vector ""x(t+1)"" are calculated by "mixing"
           old and new value (like cold and hot water), and the weight "$weight" determines  the  "aperture"  of
           both the "hot water tap" as well as of the "cold water tap", according to the formula:

             y[i] =
             ( b[i]
                 - ( a[i,1] y[1] + ... + a[i,i-1] y[i-1] +  # note the "y[]"!
                     a[i,i+1] x[i+1] + ... + a[i,n] x[n] )  # note the "x[]"!
             ) / a[i,i]
             y[i] = weight * y[i] + (1 - weight) * x[i]

           Note that the weight "$weight" should be greater than zero and less than two (!).

           The three methods are supposed to be of different efficiency.  Experiment!

           Remember  that in most cases, it is probably advantageous to first "<b>normalize()</b>" your equation system
           prior to solving it!

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
   <b>SYNOPSIS</b>
       • Unary operators:

         ""-"", ""~"", ""abs"", "test", ""!"", '""'

       • Binary operators:

         "".""

         Binary (arithmetic) operators:

         ""+"", ""-"", ""*"", ""**"", ""+="", ""-="", ""*="", ""/="",""**=""

       • Binary (relational) operators:

         ""=="", ""!="", ""&lt;"", ""&lt;="", ""&gt;"", ""&gt;=""

         ""eq"", ""ne"", ""lt"", ""le"", ""gt"", ""ge""

         Note that the latter (""eq"", ""ne"", ... ) are just synonyms of the former  (""=="",  ""!="",  ...  ),
         defined for convenience only.

   <b>DESCRIPTION</b>
       '.'  Concatenation

            Returns the two matrices concatenated side by side.

            Example:      $c = $a . $b;

            For example, if

                    $a=[ 1 2 ]   $b=[ 5 6 ]
                       [ 3 4 ]      [ 7 8 ]
            then

                    $c=[ 1 2 5 6 ]
                       [ 3 4 7 8 ]

            Note that only matrices with the same number of rows may be concatenated.

       '-'  Unary minus

            Returns  the  negative  of  the given matrix, i.e., the matrix with all elements multiplied with the
            factor "-1".

            Example:

                $matrix = -$matrix;

       '~'  Transposition

            Returns the transposed of the given matrix.

            Examples:

                $temp = ~$vector * $vector;
                $length = sqrt( $temp-&gt;element(1,1) );

                if (~$matrix == $matrix) { # matrix is symmetric ... }

       abs  Norm

            Returns the "one"-Norm of the given matrix.

            Example:

                $error = abs( $A * $x - $b );

       test Boolean test

            Tests whether there is at least one non-zero element in the matrix.

            Example:

                if ($xn_vector) { # result of iteration is not zero ... }

       '!'  Negated boolean test

            Tests whether the matrix contains only zero's.

            Examples:

                if (! $b_vector) { # heterogenous equation system ... }
                else             { # homogenous equation system ... }

                unless ($x_vector) { # not the null-vector! }

       '""""'
            "Stringify" operator

            Converts the given matrix into a string.

            Uses scientific representation to keep precision loss to a minimum in case you  want  to  read  this
            string back in again later with "<b>new_from_string()</b>".

            By  default a 13-digit mantissa and a 20-character field for each element is used so that lines will
            wrap nicely on an 80-column screen.

            Examples:

                $matrix = Math::MatrixReal-&gt;new_from_string(&lt;&lt;"MATRIX");
                [ 1  0 ]
                [ 0 -1 ]
                MATRIX
                print "$matrix";

                [  1.000000000000E+00  0.000000000000E+00 ]
                [  0.000000000000E+00 -1.000000000000E+00 ]

                $string = "$matrix";
                $test = Math::MatrixReal-&gt;new_from_string($string);
                if ($test == $matrix) { print ":-)\n"; } else { print ":-(\n"; }

       '+'  Addition

            Returns the sum of the two given matrices.

            Examples:

                $matrix_S = $matrix_A + $matrix_B;

                $matrix_A += $matrix_B;

       '-'  Subtraction

            Returns the difference of the two given matrices.

            Examples:

                $matrix_D = $matrix_A - $matrix_B;

                $matrix_A -= $matrix_B;

            Note that this is the same as:

                $matrix_S = $matrix_A + -$matrix_B;

                $matrix_A += -$matrix_B;

            (The latter are less efficient, though)

       '*'  Multiplication

            Returns the matrix product of the two given matrices or the product of the given matrix  and  scalar
            factor.

            Examples:

                $matrix_P = $matrix_A * $matrix_B;

                $matrix_A *= $matrix_B;

                $vector_b = $matrix_A * $vector_x;

                $matrix_B = -1 * $matrix_A;

                $matrix_B = $matrix_A * -1;

                $matrix_A *= -1;

       '/'  Division

            Currently  a  shortcut  for doing $a * $b ** -1 is $a / $b, which works for square matrices. One can
            also use 1/$a .

       '**' Exponentiation

            Returns the matrix raised to an integer power. If 0 is passed, the identity matrix is returned. If a
            negative integer is passed, it computes the inverse (if it exists) and then raised  the  inverse  to
            the absolute value of the integer. The matrix must be quadratic.

            Examples:

                $matrix2 = $matrix ** 2;

                $matrix **= 2;

                $inv2 = $matrix ** -2;

                $ident = $matrix ** 0;

       '==' Equality

            Tests two matrices for equality.

            Example:

                if ( $A * $x == $b ) { print "EUREKA!\n"; }

            Note  that  in  most  cases,  due  to  numerical  errors  (due  to  the finite precision of computer
            arithmetics), it is a bad idea to compare two matrices or vectors this way.

            Better use the norm of the difference of the two matrices you want to compare and compare that  norm
            with a small number, like this:

                if ( abs( $A * $x - $b ) &lt; 1E-12 ) { print "BINGO!\n"; }

       '!=' Inequality

            Tests two matrices for inequality.

            Example:

                while ($x0_vector != $xn_vector) { # proceed with iteration ... }

            (Stops when the iteration becomes stationary)

            Note  that  (just  like  with  the  '=='  operator), it is usually a bad idea to compare matrices or
            vectors this way. Compare the norm of the difference  of  the  two  matrices  with  a  small  number
            instead.

       '&lt;'  Less than

            Examples:

                if ( $matrix1 &lt; $matrix2 ) { # ... }

                if ( $vector &lt; $epsilon ) { # ... }

                if ( 1E-12 &lt; $vector ) { # ... }

                if ( $A * $x - $b &lt; 1E-12 ) { # ... }

            These are just shortcuts for saying:

                if ( abs($matrix1) &lt; abs($matrix2) ) { # ... }

                if ( abs($vector) &lt; abs($epsilon) ) { # ... }

                if ( abs(1E-12) &lt; abs($vector) ) { # ... }

                if ( abs( $A * $x - $b ) &lt; abs(1E-12) ) { # ... }

            Uses the "one"-norm for matrices and Perl's built-in "<b>abs()</b>" for scalars.

       '&lt;=' Less than or equal

            As  with  the  '&lt;' operator, this is just a shortcut for the same expression with "<b>abs()</b>" around all
            arguments.

            Example:

                if ( $A * $x - $b &lt;= 1E-12 ) { # ... }

            which in fact is the same as:

                if ( abs( $A * $x - $b ) &lt;= abs(1E-12) ) { # ... }

            Uses the "one"-norm for matrices and Perl's built-in "<b>abs()</b>" for scalars.

       '&gt;'  Greater than

            As with the '&lt;' and '&lt;=' operator, this

                if ( $xn - $x0 &gt; 1E-12 ) { # ... }

            is just a shortcut for:

                if ( abs( $xn - $x0 ) &gt; abs(1E-12) ) { # ... }

            Uses the "one"-norm for matrices and Perl's built-in "<b>abs()</b>" for scalars.

       '&gt;=' Greater than or equal

            As with the '&lt;', '&lt;=' and '&gt;' operator, the following

                if ( $LR &gt;= $A ) { # ... }

            is simply a shortcut for:

                if ( abs($LR) &gt;= abs($A) ) { # ... }

            Uses the "one"-norm for matrices and Perl's built-in "<b>abs()</b>" for scalars.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Math::VectorReal, Math::PARI, Math::MatrixBool, Math::Vec, DFA::Kleene, Math::Kleene,  Set::IntegerRange,
       Set::IntegerFast .

</pre><h4><b>VERSION</b></h4><pre>
       This man page documents Math::MatrixReal version 2.13

       The latest code can be found at https://github.com/leto/math--matrixreal .

</pre><h4><b>AUTHORS</b></h4><pre>
       Steffen   Beyer   &lt;<a href="mailto:sb@engelschall.com">sb@engelschall.com</a>&gt;,   Rodolphe   Ortalo   &lt;<a href="mailto:ortalo@laas.fr">ortalo@laas.fr</a>&gt;,   Jonathan   "Duke"  Leto
       &lt;<a href="mailto:jonathan@leto.net">jonathan@leto.net</a>&gt;.

       Currently  maintained  by   Jonathan   "Duke"   Leto,   send   all   bugs/patches   to   Github   Issues:
       https://github.com/leto/math--matrixreal/issues

</pre><h4><b>CREDITS</b></h4><pre>
       Many thanks to Prof. Pahlings for stoking the fire of my enthusiasm for Algebra and Linear Algebra at the
       university  (RWTH  Aachen,  Germany),  and  to  Prof.  Esser  and  his assistant, Mr. Jarausch, for their
       fascinating lectures in Numerical Analysis!

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 1996-2016 by various authors including  the  original  developer  Steffen  Beyer,  Rodolphe
       Ortalo, the current maintainer Jonathan "Duke" Leto and all the wonderful people in the AUTHORS file. All
       rights reserved.

</pre><h4><b>LICENSE</b> <b>AGREEMENT</b></h4><pre>
       This  package  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself. Fuck yeah.

perl v5.30.3                                       2020-06-13                              <u>Math::<a href="../man3pm/MatrixReal.3pm.html">MatrixReal</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>