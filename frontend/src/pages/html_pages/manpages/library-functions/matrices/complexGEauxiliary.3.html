<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>complexGEauxiliary - complex</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/liblapack-doc">liblapack-doc_3.10.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       complexGEauxiliary - complex

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>cgesc2</b> (N, A, LDA, RHS, IPIV, JPIV, SCALE)
           <b>CGESC2</b> solves a system of linear equations using the LU factorization with complete pivoting computed
           by sgetc2.
       subroutine <b>cgetc2</b> (N, A, LDA, IPIV, JPIV, INFO)
           <b>CGETC2</b> computes the LU factorization with complete pivoting of the general n-by-n matrix.
       real function <b>clange</b> (NORM, M, N, A, LDA, WORK)
           <b>CLANGE</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value
           of any element of a general rectangular matrix.
       subroutine <b>claqge</b> (M, N, A, LDA, R, C, ROWCND, COLCND, AMAX, EQUED)
           <b>CLAQGE</b> scales a general rectangular matrix, using row and column scaling factors computed by sgeequ.
       subroutine <b>ctgex2</b> (WANTQ, WANTZ, N, A, LDA, B, LDB, Q, LDQ, Z, LDZ, J1, INFO)
           <b>CTGEX2</b> swaps adjacent diagonal blocks in an upper (quasi) triangular matrix pair by an unitary
           equivalence transformation.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       This is the group of complex auxiliary functions for GE matrices

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>cgesc2</b> <b>(integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RHS,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>JPIV,</b> <b>real</b> <b>SCALE)</b>
       <b>CGESC2</b> solves a system of linear equations using the LU factorization with complete pivoting computed by
       sgetc2.

       <b>Purpose:</b>

            CGESC2 solves a system of linear equations

                      A * X = scale* RHS

            with a general N-by-N matrix A using the LU factorization with
            complete pivoting computed by CGETC2.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA, N)
                     On entry, the  LU part of the factorization of the n-by-n
                     matrix A computed by CGETC2:  A = P * L * U * Q

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1, N).

           <u>RHS</u>

                     RHS is COMPLEX array, dimension N.
                     On entry, the right hand side vector b.
                     On exit, the solution vector X.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N).
                     The pivot indices; for 1 &lt;= i &lt;= N, row i of the
                     matrix has been interchanged with row IPIV(i).

           <u>JPIV</u>

                     JPIV is INTEGER array, dimension (N).
                     The pivot indices; for 1 &lt;= j &lt;= N, column j of the
                     matrix has been interchanged with column JPIV(j).

           <u>SCALE</u>

                     SCALE is REAL
                      On exit, SCALE contains the scale factor. SCALE is chosen
                      0 &lt;= SCALE &lt;= 1 to prevent overflow in the solution.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

   <b>subroutine</b> <b>cgetc2</b> <b>(integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>JPIV,</b> <b>integer</b> <b>INFO)</b>
       <b>CGETC2</b> computes the LU factorization with complete pivoting of the general n-by-n matrix.

       <b>Purpose:</b>

            CGETC2 computes an LU factorization, using complete pivoting, of the
            n-by-n matrix A. The factorization has the form A = P * L * U * Q,
            where P and Q are permutation matrices, L is lower triangular with
            unit diagonal elements and U is upper triangular.

            This is a level 1 BLAS version of the algorithm.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix A. N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA, N)
                     On entry, the n-by-n matrix to be factored.
                     On exit, the factors L and U from the factorization
                     A = P*L*U*Q; the unit diagonal elements of L are not stored.
                     If U(k, k) appears to be less than SMIN, U(k, k) is given the
                     value of SMIN, giving a nonsingular perturbed system.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1, N).

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N).
                     The pivot indices; for 1 &lt;= i &lt;= N, row i of the
                     matrix has been interchanged with row IPIV(i).

           <u>JPIV</u>

                     JPIV is INTEGER array, dimension (N).
                     The pivot indices; for 1 &lt;= j &lt;= N, column j of the
                     matrix has been interchanged with column JPIV(j).

           <u>INFO</u>

                     INFO is INTEGER
                      = 0: successful exit
                      &gt; 0: if INFO = k, U(k, k) is likely to produce overflow if
                           one tries to solve for x in Ax = b. So U is perturbed
                           to avoid the overflow.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

   <b>real</b> <b>function</b> <b>clange</b> <b>(character</b> <b>NORM,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>CLANGE</b> returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute value of
       any element of a general rectangular matrix.

       <b>Purpose:</b>

            CLANGE  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex matrix A.

       <b>Returns</b>
           CLANGE

               CLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies the value to be returned in CLANGE as described
                     above.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.  When M = 0,
                     CLANGE is set to zero.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.  When N = 0,
                     CLANGE is set to zero.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     The m by n matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(M,1).

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK)),
                     where LWORK &gt;= M when NORM = 'I'; otherwise, WORK is not
                     referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>claqge</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>R,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>real</b> <b>ROWCND,</b> <b>real</b> <b>COLCND,</b> <b>real</b> <b>AMAX,</b> <b>character</b> <b>EQUED)</b>
       <b>CLAQGE</b> scales a general rectangular matrix, using row and column scaling factors computed by sgeequ.

       <b>Purpose:</b>

            CLAQGE equilibrates a general M by N matrix A using the row and
            column scaling factors in the vectors R and C.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the M by N matrix A.
                     On exit, the equilibrated matrix.  See EQUED for the form of
                     the equilibrated matrix.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(M,1).

           <u>R</u>

                     R is REAL array, dimension (M)
                     The row scale factors for A.

           <u>C</u>

                     C is REAL array, dimension (N)
                     The column scale factors for A.

           <u>ROWCND</u>

                     ROWCND is REAL
                     Ratio of the smallest R(i) to the largest R(i).

           <u>COLCND</u>

                     COLCND is REAL
                     Ratio of the smallest C(i) to the largest C(i).

           <u>AMAX</u>

                     AMAX is REAL
                     Absolute value of largest matrix entry.

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                     Specifies the form of equilibration that was done.
                     = 'N':  No equilibration
                     = 'R':  Row equilibration, i.e., A has been premultiplied by
                             diag(R).
                     = 'C':  Column equilibration, i.e., A has been postmultiplied
                             by diag(C).
                     = 'B':  Both row and column equilibration, i.e., A has been
                             replaced by diag(R) * A * diag(C).

       <b>Internal</b> <b>Parameters:</b>

             THRESH is a threshold value used to decide if row or column scaling
             should be done based on the ratio of the row or column scaling
             factors.  If ROWCND &lt; THRESH, row scaling is done, and if
             COLCND &lt; THRESH, column scaling is done.

             LARGE and SMALL are threshold values used to decide if row scaling
             should be done based on the absolute size of the largest matrix
             element.  If AMAX &gt; LARGE or AMAX &lt; SMALL, row scaling is done.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctgex2</b> <b>(logical</b> <b>WANTQ,</b> <b>logical</b> <b>WANTZ,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer</b> <b>J1,</b> <b>integer</b> <b>INFO)</b>
       <b>CTGEX2</b> swaps adjacent diagonal blocks in an upper (quasi) triangular matrix pair by an unitary
       equivalence transformation.

       <b>Purpose:</b>

            CTGEX2 swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)
            in an upper triangular matrix pair (A, B) by an unitary equivalence
            transformation.

            (A, B) must be in generalized Schur canonical form, that is, A and
            B are both upper triangular.

            Optionally, the matrices Q and Z of generalized Schur vectors are
            updated.

                   Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
                   Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H

       <b>Parameters</b>
           <u>WANTQ</u>

                     WANTQ is LOGICAL
                     .TRUE. : update the left transformation matrix Q;
                     .FALSE.: do not update Q.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     .TRUE. : update the right transformation matrix Z;
                     .FALSE.: do not update Z.

           <u>N</u>

                     N is INTEGER
                     The order of the matrices A and B. N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the matrix A in the pair (A, B).
                     On exit, the updated matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,N).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,N)
                     On entry, the matrix B in the pair (A, B).
                     On exit, the updated matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,N).

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                     If WANTQ = .TRUE, on entry, the unitary matrix Q. On exit,
                     the updated matrix Q.
                     Not referenced if WANTQ = .FALSE..

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q. LDQ &gt;= 1;
                     If WANTQ = .TRUE., LDQ &gt;= N.

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ,N)
                     If WANTZ = .TRUE, on entry, the unitary matrix Z. On exit,
                     the updated matrix Z.
                     Not referenced if WANTZ = .FALSE..

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z. LDZ &gt;= 1;
                     If WANTZ = .TRUE., LDZ &gt;= N.

           <u>J1</u>

                     J1 is INTEGER
                     The index to the first block (A11, B11).

           <u>INFO</u>

                     INFO is INTEGER
                      =0:  Successful exit.
                      =1:  The transformed matrix pair (A, B) would be too far
                           from generalized Schur form; the problem is ill-
                           conditioned.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>
           In the current code both weak and strong stability tests are performed. The user can omit the strong
           stability test by changing the internal logical parameter WANDS to .FALSE.. See ref. [2] for details.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

       <b>References:</b>
           [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the Generalized Real Schur Form of a
           Regular Matrix Pair (A, B), in M.S. Moonen et al (eds), Linear Algebra for Large Scale and Real-Time
           Applications, Kluwer Academic Publ. 1993, pp 195-218.
            [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified Eigenvalues of a Regular Matrix
           Pair (A, B) and Condition Estimation: Theory, Algorithms and Software, Report UMINF-94.04, Department
           of Computing Science, Umea University, S-901 87 Umea, Sweden, 1994. Also as LAPACK Working Note 87.
           To appear in Numerical Algorithms, 1996.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.10.0                                   Wed Jan 12 2022                           <u><a href="../man3/complexGEauxiliary.3.html">complexGEauxiliary</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>