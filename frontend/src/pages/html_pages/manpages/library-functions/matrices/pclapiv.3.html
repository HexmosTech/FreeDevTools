<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCLAPIV  -  applie  either  P  (permutation  matrix  indicated  by  IPIV) or inv( P ) to a general M-by-N</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/scalapack-doc">scalapack-doc_1.5-11_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PCLAPIV  -  applie  either  P  (permutation  matrix  indicated  by  IPIV) or inv( P ) to a general M-by-N
       distributed matrix sub( A ) = A(IA:IA+M-1,JA:JA+N-1), resulting in row or column pivoting

</pre><h4><b>SYNOPSIS</b></h4><pre>
       SUBROUTINE PCLAPIV( DIREC, ROWCOL, PIVROC, M, N, A, IA, JA, DESCA, IPIV, IP, JP, DESCIP, IWORK )

           CHARACTER*1     DIREC, PIVROC, ROWCOL

           INTEGER         IA, IP, JA, JP, M, N

           INTEGER         DESCA( * ), DESCIP( * ), IPIV( * ), IWORK( * )

           COMPLEX         A( * )

</pre><h4><b>PURPOSE</b></h4><pre>
       PCLAPIV applies either P (permutation matrix indicated  by  IPIV)  or  inv(  P  )  to  a  general  M-by-N
       distributed  matrix  sub(  A  )  = A(IA:IA+M-1,JA:JA+N-1), resulting in row or column pivoting. The pivot
       vector may be distributed across a process row or a column. The pivot vector should be aligned  with  the
       distributed  matrix A. This routine will transpose the pivot vector if necessary.  For example if the row
       pivots should be applied to the columns of sub( A ), pass ROWCOL='C' and PIVROC='C'.

       Notes
       =====

       Each global data object is described by  an  associated  description  vector.   This  vector  stores  the
       information required to establish the mapping between an object element and its corresponding process and
       memory location.

       Let  A  be  a  generic  term  for  any  2D  block cyclicly distributed array.  Such a global array has an
       associated description vector DESCA.  In the following comments, the character _ should be  read  as  "of
       the global array".

       NOTATION        STORED IN      EXPLANATION
       ---------------  -------------- -------------------------------------- DTYPE_A(global) DESCA( DTYPE_ )The
       descriptor type.  In this case,
                                      DTYPE_A = 1.
       CTXT_A (global) DESCA( CTXT_ ) The BLACS context handle, indicating
                                      the BLACS process grid A is distribu-
                                      ted over. The context itself is glo-
                                      bal, but the handle (the integer
                                      value) may vary.
       M_A    (global) DESCA( M_ )    The number of rows in the global
                                      array A.
       N_A    (global) DESCA( N_ )    The number of columns in the global
                                      array A.
       MB_A   (global) DESCA( MB_ )   The blocking factor used to distribute
                                      the rows of the array.
       NB_A   (global) DESCA( NB_ )   The blocking factor used to distribute
                                      the columns of the array.
       RSRC_A (global) DESCA( RSRC_ ) The process row over which the first
                                      row of the array A is distributed.  CSRC_A (global)  DESCA(  CSRC_  )  The
       process column over which the
                                      first column of the array A is
                                      distributed.
       LLD_A  (local)  DESCA( LLD_ )  The leading dimension of the local
                                      array.  LLD_A &gt;= MAX(1,LOCr(M_A)).

       Let  K  be  the  number  of rows or columns of a distributed matrix, and assume that its process grid has
       dimension p x q.
       LOCr( K ) denotes the number of elements of K that a process would receive if K were distributed over the
       p processes of its process column.
       Similarly, LOCc( K ) denotes the number of elements  of  K  that  a  process  would  receive  if  K  were
       distributed over the q processes of its process row.
       The values of LOCr() and LOCc() may be determined via a call to the ScaLAPACK tool function, NUMROC:
               LOCr( M ) = NUMROC( M, MB_A, MYROW, RSRC_A, NPROW ),
               LOCc(  N ) = NUMROC( N, NB_A, MYCOL, CSRC_A, NPCOL ).  An upper bound for these quantities may be
       computed by:
               LOCr( M ) &lt;= ceil( ceil(M/MB_A)/NPROW )*MB_A
               LOCc( N ) &lt;= ceil( ceil(N/NB_A)/NPCOL )*NB_A

       Restrictions
       ============

       IPIV must always be a distributed vector (not a matrix).  Thus: IF( ROWPIV .EQ. 'C' ) THEN
          JP must be 1
       ELSE
          IP must be 1
       END IF

       The following restrictions apply when IPIV must be transposed:  IF(  ROWPIV.EQ.'C'  .AND.  PIVROC.EQ.'C')
       THEN
           DESCIP(MB_) must equal DESCA(NB_)
       ELSE IF( ROWPIV.EQ.'R" .AND. PIVROC.EQ.'R') THEN
           DESCIP(NB_) must equal DESCA(MB_)
       END IF

</pre><h4><b>ARGUMENTS</b></h4><pre>
       DIREC   (global input) CHARACTER*1
               Specifies  in which order the permutation is applied: = 'F' (Forward) Applies pivots Forward from
               top of matrix.  Computes P*sub( A ).  = 'B' (Backward) Applies pivots  Backward  from  bottom  of
               matrix. Computes inv( P )*sub( A ).

       ROWCOL  (global input) CHARACTER*1
               Specifies  if  the rows or columns are to be permuted: = 'R' Rows will be permuted, = 'C' Columns
               will be permuted.

       PIVROC  (global input) CHARACTER*1
               Specifies whether IPIV is distributed over a process row or column: = 'R' IPIV distributed over a
               process row = 'C' IPIV distributed over a process column

       M       (global input) INTEGER
               The number of rows to be operated on, i.e. the number of rows of the distributed submatrix sub( A
               ). M &gt;= 0.

       N       (global input) INTEGER
               The number of columns to be operated on, i.e. the number of columns of the distributed  submatrix
               sub( A ). N &gt;= 0.

       A       (local input/local output) COMPLEX pointer into the
               local  memory  to an array of dimension (LLD_A, LOCc(JA+N-1)).  On entry, this array contains the
               local pieces of the distributed submatrix sub( A ) to which the row or column  interchanges  will
               be applied. On exit, the local pieces of the permuted distributed submatrix.

       IA      (global input) INTEGER
               The row index in the global array A indicating the first row of sub( A ).

       JA      (global input) INTEGER
               The column index in the global array A indicating the first column of sub( A ).

       DESCA   (global and local input) INTEGER array of dimension DLEN_.
               The array descriptor for the distributed matrix A.

       IPIV    (local input) INTEGER array, dimension &gt;= LOCr(M_A)+MB_A
               if  ROWCOL='R',  otherwise  LOCc(N_A)+NB_A.  It contains the pivoting information. IPIV(i) is the
               global row (column), local row (column) i was swapped with.  The last piece of the array of  size
               MB_A (resp. NB_A) is used as workspace.  This array is tied to the distributed matrix A.

       IWORK   (local workspace) INTEGER array, dimension (LDW)
               where LDW is equal to the workspace necessary for transposition, and the storage of the tranposed
               IPIV:

               Let LCM be the least common multiple of NPROW and NPCOL.  IF( ROWCOL.EQ.'R' .AND. PIVROC.EQ.'R' )
               THEN  IF( NPROW.EQ.NPCOL ) THEN LDW = LOCr( N_P + MOD(JP-1, NB_P) ) + NB_P ELSE LDW = LOCr( N_P +
               MOD(JP-1, NB_P) )  +  NB_P  *  CEIL(  CEIL(LOCc(N_P)/NB_P)  /  (LCM/NPCOL)  )  END  IF  ELSE  IF(
               ROWCOL.EQ.'C'  .AND.  PIVROC.EQ.'C'  ) THEN IF( NPROW.EQ.NPCOL ) THEN LDW = LOCc( M_P + MOD(IP-1,
               MB_P) ) + MB_P ELSE LDW = LOCc( M_P + MOD(IP-1, MB_P) ) + MB_P  *  CEIL(  CEIL(LOCr(M_P)/MB_P)  /
               (LCM/NPROW) ) END IF ELSE IWORK is not referenced.  END IF

LAPACK version 1.5                                 12 May 1997                                        <u>PCLAPIV</u>(l)
</pre>
 </div>
</div></section>
</div>
</body>
</html>