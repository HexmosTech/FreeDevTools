<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>auxOTHERcomputational - auxiliary Computational routines</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/liblapack-doc">liblapack-doc_3.10.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       auxOTHERcomputational - auxiliary Computational routines

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       character *1 function <b>chla_transtype</b> (TRANS)
           <b>CHLA_TRANSTYPE</b>
       subroutine <b>dbdsdc</b> (UPLO, COMPQ, N, D, E, U, LDU, VT, LDVT, Q, IQ, WORK, IWORK, INFO)
           <b>DBDSDC</b>
       subroutine <b>dbdsqr</b> (UPLO, N, NCVT, NRU, NCC, D, E, VT, LDVT, U, LDU, C, LDC, WORK, INFO)
           <b>DBDSQR</b>
       subroutine <b>ddisna</b> (JOB, M, N, D, SEP, INFO)
           <b>DDISNA</b>
       subroutine <b>dlaed0</b> (ICOMPQ, QSIZ, N, D, E, Q, LDQ, QSTORE, LDQS, WORK, IWORK, INFO)
           <b>DLAED0</b> used by DSTEDC. Computes all eigenvalues and corresponding eigenvectors of an unreduced
           symmetric tridiagonal matrix using the divide and conquer method.
       subroutine <b>dlaed1</b> (N, D, Q, LDQ, INDXQ, RHO, CUTPNT, WORK, IWORK, INFO)
           <b>DLAED1</b> used by DSTEDC. Computes the updated eigensystem of a diagonal matrix after modification by a
           rank-one symmetric matrix. Used when the original matrix is tridiagonal.
       subroutine <b>dlaed2</b> (K, N, N1, D, Q, LDQ, INDXQ, RHO, Z, DLAMDA, W, Q2, INDX, INDXC, INDXP, COLTYP, INFO)
           <b>DLAED2</b> used by DSTEDC. Merges eigenvalues and deflates secular equation. Used when the original
           matrix is tridiagonal.
       subroutine <b>dlaed3</b> (K, N, N1, D, Q, LDQ, RHO, DLAMDA, Q2, INDX, CTOT, W, S, INFO)
           <b>DLAED3</b> used by DSTEDC. Finds the roots of the secular equation and updates the eigenvectors. Used
           when the original matrix is tridiagonal.
       subroutine <b>dlaed4</b> (N, I, D, Z, DELTA, RHO, DLAM, INFO)
           <b>DLAED4</b> used by DSTEDC. Finds a single root of the secular equation.
       subroutine <b>dlaed5</b> (I, D, Z, DELTA, RHO, DLAM)
           <b>DLAED5</b> used by DSTEDC. Solves the 2-by-2 secular equation.
       subroutine <b>dlaed6</b> (KNITER, ORGATI, RHO, D, Z, FINIT, TAU, INFO)
           <b>DLAED6</b> used by DSTEDC. Computes one Newton step in solution of the secular equation.
       subroutine <b>dlaed7</b> (ICOMPQ, N, QSIZ, TLVLS, CURLVL, CURPBM, D, Q, LDQ, INDXQ, RHO, CUTPNT, QSTORE, QPTR,
           PRMPTR, PERM, GIVPTR, GIVCOL, GIVNUM, WORK, IWORK, INFO)
           <b>DLAED7</b> used by DSTEDC. Computes the updated eigensystem of a diagonal matrix after modification by a
           rank-one symmetric matrix. Used when the original matrix is dense.
       subroutine <b>dlaed8</b> (ICOMPQ, K, N, QSIZ, D, Q, LDQ, INDXQ, RHO, CUTPNT, Z, DLAMDA, Q2, LDQ2, W, PERM,
           GIVPTR, GIVCOL, GIVNUM, INDXP, INDX, INFO)
           <b>DLAED8</b> used by DSTEDC. Merges eigenvalues and deflates secular equation. Used when the original
           matrix is dense.
       subroutine <b>dlaed9</b> (K, KSTART, KSTOP, N, D, Q, LDQ, RHO, DLAMDA, W, S, LDS, INFO)
           <b>DLAED9</b> used by DSTEDC. Finds the roots of the secular equation and updates the eigenvectors. Used
           when the original matrix is dense.
       subroutine <b>dlaeda</b> (N, TLVLS, CURLVL, CURPBM, PRMPTR, PERM, GIVPTR, GIVCOL, GIVNUM, Q, QPTR, Z, ZTEMP,
           INFO)
           <b>DLAEDA</b> used by DSTEDC. Computes the Z vector determining the rank-one modification of the diagonal
           matrix. Used when the original matrix is dense.
       subroutine <b>dlagtf</b> (N, A, LAMBDA, B, C, TOL, D, IN, INFO)
           <b>DLAGTF</b> computes an LU factorization of a matrix T-λI, where T is a general tridiagonal matrix, and λ
           a scalar, using partial pivoting with row interchanges.
       subroutine <b>dlamrg</b> (N1, N2, A, DTRD1, DTRD2, INDEX)
           <b>DLAMRG</b> creates a permutation list to merge the entries of two independently sorted sets into a single
           set sorted in ascending order.
       subroutine <b>dlartgs</b> (X, Y, SIGMA, CS, SN)
           <b>DLARTGS</b> generates a plane rotation designed to introduce a bulge in implicit QR iteration for the
           bidiagonal SVD problem.
       subroutine <b>dlasq1</b> (N, D, E, WORK, INFO)
           <b>DLASQ1</b> computes the singular values of a real square bidiagonal matrix. Used by sbdsqr.
       subroutine <b>dlasq2</b> (N, Z, INFO)
           <b>DLASQ2</b> computes all the eigenvalues of the symmetric positive definite tridiagonal matrix associated
           with the qd Array Z to high relative accuracy. Used by sbdsqr and sstegr.
       subroutine <b>dlasq3</b> (I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL, ITER, NDIV, IEEE, TTYPE, DMIN1, DMIN2,
           DN, DN1, DN2, G, TAU)
           <b>DLASQ3</b> checks for deflation, computes a shift and calls dqds. Used by sbdsqr.
       subroutine <b>dlasq4</b> (I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN, DN1, DN2, TAU, TTYPE, G)
           <b>DLASQ4</b> computes an approximation to the smallest eigenvalue using values of d from the previous
           transform. Used by sbdsqr.
       subroutine <b>dlasq5</b> (I0, N0, Z, PP, TAU, SIGMA, DMIN, DMIN1, DMIN2, DN, DNM1, DNM2, IEEE, EPS)
           <b>DLASQ5</b> computes one dqds transform in ping-pong form. Used by sbdsqr and sstegr.
       subroutine <b>dlasq6</b> (I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN, DNM1, DNM2)
           <b>DLASQ6</b> computes one dqd transform in ping-pong form. Used by sbdsqr and sstegr.
       subroutine <b>dlasrt</b> (ID, N, D, INFO)
           <b>DLASRT</b> sorts numbers in increasing or decreasing order.
       subroutine <b>dstebz</b> (RANGE, ORDER, N, VL, VU, IL, IU, ABSTOL, D, E, M, NSPLIT, W, IBLOCK, ISPLIT, WORK,
           IWORK, INFO)
           <b>DSTEBZ</b>
       subroutine <b>dstedc</b> (COMPZ, N, D, E, Z, LDZ, WORK, LWORK, IWORK, LIWORK, INFO)
           <b>DSTEDC</b>
       subroutine <b>dsteqr</b> (COMPZ, N, D, E, Z, LDZ, WORK, INFO)
           <b>DSTEQR</b>
       subroutine <b>dsterf</b> (N, D, E, INFO)
           <b>DSTERF</b>
       integer function <b>iladiag</b> (DIAG)
           <b>ILADIAG</b>
       integer function <b>ilaprec</b> (PREC)
           <b>ILAPREC</b>
       integer function <b>ilatrans</b> (TRANS)
           <b>ILATRANS</b>
       integer function <b>ilauplo</b> (UPLO)
           <b>ILAUPLO</b>
       subroutine <b>sbdsdc</b> (UPLO, COMPQ, N, D, E, U, LDU, VT, LDVT, Q, IQ, WORK, IWORK, INFO)
           <b>SBDSDC</b>
       subroutine <b>sbdsqr</b> (UPLO, N, NCVT, NRU, NCC, D, E, VT, LDVT, U, LDU, C, LDC, WORK, INFO)
           <b>SBDSQR</b>
       subroutine <b>sdisna</b> (JOB, M, N, D, SEP, INFO)
           <b>SDISNA</b>
       subroutine <b>slaed0</b> (ICOMPQ, QSIZ, N, D, E, Q, LDQ, QSTORE, LDQS, WORK, IWORK, INFO)
           <b>SLAED0</b> used by SSTEDC. Computes all eigenvalues and corresponding eigenvectors of an unreduced
           symmetric tridiagonal matrix using the divide and conquer method.
       subroutine <b>slaed1</b> (N, D, Q, LDQ, INDXQ, RHO, CUTPNT, WORK, IWORK, INFO)
           <b>SLAED1</b> used by SSTEDC. Computes the updated eigensystem of a diagonal matrix after modification by a
           rank-one symmetric matrix. Used when the original matrix is tridiagonal.
       subroutine <b>slaed2</b> (K, N, N1, D, Q, LDQ, INDXQ, RHO, Z, DLAMDA, W, Q2, INDX, INDXC, INDXP, COLTYP, INFO)
           <b>SLAED2</b> used by SSTEDC. Merges eigenvalues and deflates secular equation. Used when the original
           matrix is tridiagonal.
       subroutine <b>slaed3</b> (K, N, N1, D, Q, LDQ, RHO, DLAMDA, Q2, INDX, CTOT, W, S, INFO)
           <b>SLAED3</b> used by SSTEDC. Finds the roots of the secular equation and updates the eigenvectors. Used
           when the original matrix is tridiagonal.
       subroutine <b>slaed4</b> (N, I, D, Z, DELTA, RHO, DLAM, INFO)
           <b>SLAED4</b> used by SSTEDC. Finds a single root of the secular equation.
       subroutine <b>slaed5</b> (I, D, Z, DELTA, RHO, DLAM)
           <b>SLAED5</b> used by SSTEDC. Solves the 2-by-2 secular equation.
       subroutine <b>slaed6</b> (KNITER, ORGATI, RHO, D, Z, FINIT, TAU, INFO)
           <b>SLAED6</b> used by SSTEDC. Computes one Newton step in solution of the secular equation.
       subroutine <b>slaed7</b> (ICOMPQ, N, QSIZ, TLVLS, CURLVL, CURPBM, D, Q, LDQ, INDXQ, RHO, CUTPNT, QSTORE, QPTR,
           PRMPTR, PERM, GIVPTR, GIVCOL, GIVNUM, WORK, IWORK, INFO)
           <b>SLAED7</b> used by SSTEDC. Computes the updated eigensystem of a diagonal matrix after modification by a
           rank-one symmetric matrix. Used when the original matrix is dense.
       subroutine <b>slaed8</b> (ICOMPQ, K, N, QSIZ, D, Q, LDQ, INDXQ, RHO, CUTPNT, Z, DLAMDA, Q2, LDQ2, W, PERM,
           GIVPTR, GIVCOL, GIVNUM, INDXP, INDX, INFO)
           <b>SLAED8</b> used by SSTEDC. Merges eigenvalues and deflates secular equation. Used when the original
           matrix is dense.
       subroutine <b>slaed9</b> (K, KSTART, KSTOP, N, D, Q, LDQ, RHO, DLAMDA, W, S, LDS, INFO)
           <b>SLAED9</b> used by SSTEDC. Finds the roots of the secular equation and updates the eigenvectors. Used
           when the original matrix is dense.
       subroutine <b>slaeda</b> (N, TLVLS, CURLVL, CURPBM, PRMPTR, PERM, GIVPTR, GIVCOL, GIVNUM, Q, QPTR, Z, ZTEMP,
           INFO)
           <b>SLAEDA</b> used by SSTEDC. Computes the Z vector determining the rank-one modification of the diagonal
           matrix. Used when the original matrix is dense.
       subroutine <b>slagtf</b> (N, A, LAMBDA, B, C, TOL, D, IN, INFO)
           <b>SLAGTF</b> computes an LU factorization of a matrix T-λI, where T is a general tridiagonal matrix, and λ
           a scalar, using partial pivoting with row interchanges.
       subroutine <b>slamrg</b> (N1, N2, A, STRD1, STRD2, INDEX)
           <b>SLAMRG</b> creates a permutation list to merge the entries of two independently sorted sets into a single
           set sorted in ascending order.
       subroutine <b>slartgs</b> (X, Y, SIGMA, CS, SN)
           <b>SLARTGS</b> generates a plane rotation designed to introduce a bulge in implicit QR iteration for the
           bidiagonal SVD problem.
       subroutine <b>slasq1</b> (N, D, E, WORK, INFO)
           <b>SLASQ1</b> computes the singular values of a real square bidiagonal matrix. Used by sbdsqr.
       subroutine <b>slasq2</b> (N, Z, INFO)
           <b>SLASQ2</b> computes all the eigenvalues of the symmetric positive definite tridiagonal matrix associated
           with the qd Array Z to high relative accuracy. Used by sbdsqr and sstegr.
       subroutine <b>slasq3</b> (I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL, ITER, NDIV, IEEE, TTYPE, DMIN1, DMIN2,
           DN, DN1, DN2, G, TAU)
           <b>SLASQ3</b> checks for deflation, computes a shift and calls dqds. Used by sbdsqr.
       subroutine <b>slasq4</b> (I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN, DN1, DN2, TAU, TTYPE, G)
           <b>SLASQ4</b> computes an approximation to the smallest eigenvalue using values of d from the previous
           transform. Used by sbdsqr.
       subroutine <b>slasq5</b> (I0, N0, Z, PP, TAU, SIGMA, DMIN, DMIN1, DMIN2, DN, DNM1, DNM2, IEEE, EPS)
            <b>SLASQ5</b> <b>computes</b> <b>one</b> <b>dqds</b> <b>transform</b> <b>in</b> <b>ping-pong</b> <b>form.</b> <b>Used</b> <b>by</b> <b>sbdsqr</b> <b>and</b> <b>sstegr.</b>
       subroutine <b>slasq6</b> (I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN, DNM1, DNM2)
           <b>SLASQ6</b> computes one dqd transform in ping-pong form. Used by sbdsqr and sstegr.
       subroutine <b>slasrt</b> (ID, N, D, INFO)
           <b>SLASRT</b> sorts numbers in increasing or decreasing order.
       subroutine <b>spttrf</b> (N, D, E, INFO)
           <b>SPTTRF</b>
       subroutine <b>sstebz</b> (RANGE, ORDER, N, VL, VU, IL, IU, ABSTOL, D, E, M, NSPLIT, W, IBLOCK, ISPLIT, WORK,
           IWORK, INFO)
           <b>SSTEBZ</b>
       subroutine <b>sstedc</b> (COMPZ, N, D, E, Z, LDZ, WORK, LWORK, IWORK, LIWORK, INFO)
           <b>SSTEDC</b>
       subroutine <b>ssteqr</b> (COMPZ, N, D, E, Z, LDZ, WORK, INFO)
           <b>SSTEQR</b>
       subroutine <b>ssterf</b> (N, D, E, INFO)
           <b>SSTERF</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       This is the group of auxiliary Computational routines

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>character*1</b> <b>function</b> <b>chla_transtype</b> <b>(integer</b> <b>TRANS)</b>
       <b>CHLA_TRANSTYPE</b>

       <b>Purpose:</b>

            This subroutine translates from a BLAST-specified integer constant to
            the character string specifying a transposition operation.

            CHLA_TRANSTYPE returns an CHARACTER*1.  If CHLA_TRANSTYPE is 'X',
            then input is not an integer indicating a transposition operator.
            Otherwise CHLA_TRANSTYPE returns the constant value corresponding to
            TRANS.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dbdsdc</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>COMPQ,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldvt,</b> <b>*</b> <b>)</b> <b>VT,</b> <b>integer</b> <b>LDVT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IQ,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DBDSDC</b>

       <b>Purpose:</b>

            DBDSDC computes the singular value decomposition (SVD) of a real
            N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
            using a divide and conquer method, where S is a diagonal matrix
            with non-negative diagonal elements (the singular values of B), and
            U and VT are orthogonal matrices of left and right singular vectors,
            respectively. DBDSDC can be used to compute all singular values,
            and optionally, singular vectors or singular vectors in compact form.

            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.  See DLASD3 for details.

            The code currently calls DLASDQ if singular values only are desired.
            However, it can be slightly modified to compute singular values
            using the divide and conquer method.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  B is upper bidiagonal.
                     = 'L':  B is lower bidiagonal.

           <u>COMPQ</u>

                     COMPQ is CHARACTER*1
                     Specifies whether singular vectors are to be computed
                     as follows:
                     = 'N':  Compute singular values only;
                     = 'P':  Compute singular values and compute singular
                             vectors in compact form;
                     = 'I':  Compute singular values and singular vectors.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix B.  N &gt;= 0.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     On entry, the n diagonal elements of the bidiagonal matrix B.
                     On exit, if INFO=0, the singular values of B.

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (N-1)
                     On entry, the elements of E contain the offdiagonal
                     elements of the bidiagonal matrix whose SVD is desired.
                     On exit, E has been destroyed.

           <u>U</u>

                     U is DOUBLE PRECISION array, dimension (LDU,N)
                     If  COMPQ = 'I', then:
                        On exit, if INFO = 0, U contains the left singular vectors
                        of the bidiagonal matrix.
                     For other values of COMPQ, U is not referenced.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U.  LDU &gt;= 1.
                     If singular vectors are desired, then LDU &gt;= max( 1, N ).

           <u>VT</u>

                     VT is DOUBLE PRECISION array, dimension (LDVT,N)
                     If  COMPQ = 'I', then:
                        On exit, if INFO = 0, VT**T contains the right singular
                        vectors of the bidiagonal matrix.
                     For other values of COMPQ, VT is not referenced.

           <u>LDVT</u>

                     LDVT is INTEGER
                     The leading dimension of the array VT.  LDVT &gt;= 1.
                     If singular vectors are desired, then LDVT &gt;= max( 1, N ).

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (LDQ)
                     If  COMPQ = 'P', then:
                        On exit, if INFO = 0, Q and IQ contain the left
                        and right singular vectors in a compact form,
                        requiring O(N log N) space instead of 2*N**2.
                        In particular, Q contains all the DOUBLE PRECISION data in
                        LDQ &gt;= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
                        words of memory, where SMLSIZ is returned by ILAENV and
                        is equal to the maximum size of the subproblems at the
                        bottom of the computation tree (usually about 25).
                     For other values of COMPQ, Q is not referenced.

           <u>IQ</u>

                     IQ is INTEGER array, dimension (LDIQ)
                     If  COMPQ = 'P', then:
                        On exit, if INFO = 0, Q and IQ contain the left
                        and right singular vectors in a compact form,
                        requiring O(N log N) space instead of 2*N**2.
                        In particular, IQ contains all INTEGER data in
                        LDIQ &gt;= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
                        words of memory, where SMLSIZ is returned by ILAENV and
                        is equal to the maximum size of the subproblems at the
                        bottom of the computation tree (usually about 25).
                     For other values of COMPQ, IQ is not referenced.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     If COMPQ = 'N' then LWORK &gt;= (4 * N).
                     If COMPQ = 'P' then LWORK &gt;= (6 * N).
                     If COMPQ = 'I' then LWORK &gt;= (3 * N**2 + 4 * N).

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (8*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  The algorithm failed to compute a singular value.
                           The update process of divide and conquer failed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>dbdsqr</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NCVT,</b> <b>integer</b> <b>NRU,</b> <b>integer</b> <b>NCC,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldvt,</b> <b>*</b> <b>)</b> <b>VT,</b> <b>integer</b>
       <b>LDVT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b>
       <b>integer</b> <b>LDC,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DBDSQR</b>

       <b>Purpose:</b>

            DBDSQR computes the singular values and, optionally, the right and/or
            left singular vectors from the singular value decomposition (SVD) of
            a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
            zero-shift QR algorithm.  The SVD of B has the form

               B = Q * S * P**T

            where S is the diagonal matrix of singular values, Q is an orthogonal
            matrix of left singular vectors, and P is an orthogonal matrix of
            right singular vectors.  If left singular vectors are requested, this
            subroutine actually returns U*Q instead of Q, and, if right singular
            vectors are requested, this subroutine returns P**T*VT instead of
            P**T, for given real input matrices U and VT.  When U and VT are the
            orthogonal matrices that reduce a general matrix A to bidiagonal
            form:  A = U*B*VT, as computed by DGEBRD, then

               A = (U*Q) * S * (P**T*VT)

            is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
            for a given real input matrix C.

            See "Computing  Small Singular Values of Bidiagonal Matrices With
            Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
            LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
            no. 5, pp. 873-912, Sept 1990) and
            "Accurate singular values and differential qd algorithms," by
            B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
            Department, University of California at Berkeley, July 1992
            for a detailed description of the algorithm.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  B is upper bidiagonal;
                     = 'L':  B is lower bidiagonal.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix B.  N &gt;= 0.

           <u>NCVT</u>

                     NCVT is INTEGER
                     The number of columns of the matrix VT. NCVT &gt;= 0.

           <u>NRU</u>

                     NRU is INTEGER
                     The number of rows of the matrix U. NRU &gt;= 0.

           <u>NCC</u>

                     NCC is INTEGER
                     The number of columns of the matrix C. NCC &gt;= 0.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     On entry, the n diagonal elements of the bidiagonal matrix B.
                     On exit, if INFO=0, the singular values of B in decreasing
                     order.

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (N-1)
                     On entry, the N-1 offdiagonal elements of the bidiagonal
                     matrix B.
                     On exit, if INFO = 0, E is destroyed; if INFO &gt; 0, D and E
                     will contain the diagonal and superdiagonal elements of a
                     bidiagonal matrix orthogonally equivalent to the one given
                     as input.

           <u>VT</u>

                     VT is DOUBLE PRECISION array, dimension (LDVT, NCVT)
                     On entry, an N-by-NCVT matrix VT.
                     On exit, VT is overwritten by P**T * VT.
                     Not referenced if NCVT = 0.

           <u>LDVT</u>

                     LDVT is INTEGER
                     The leading dimension of the array VT.
                     LDVT &gt;= max(1,N) if NCVT &gt; 0; LDVT &gt;= 1 if NCVT = 0.

           <u>U</u>

                     U is DOUBLE PRECISION array, dimension (LDU, N)
                     On entry, an NRU-by-N matrix U.
                     On exit, U is overwritten by U * Q.
                     Not referenced if NRU = 0.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U.  LDU &gt;= max(1,NRU).

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC, NCC)
                     On entry, an N-by-NCC matrix C.
                     On exit, C is overwritten by Q**T * C.
                     Not referenced if NCC = 0.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C.
                     LDC &gt;= max(1,N) if NCC &gt; 0; LDC &gt;=1 if NCC = 0.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (4*(N-1))

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  If INFO = -i, the i-th argument had an illegal value
                     &gt; 0:
                        if NCVT = NRU = NCC = 0,
                           = 1, a split was marked by a positive value in E
                           = 2, current block of Z not diagonalized after 30*N
                                iterations (in inner while loop)
                           = 3, termination criterion of outer while loop not met
                                (program created more than N unreduced blocks)
                        else NCVT = NRU = NCC = 0,
                              the algorithm did not converge; D and E contain the
                              elements of a bidiagonal matrix which is orthogonally
                              similar to the input matrix B;  if INFO = i, i
                              elements of E have not converged to zero.

       <b>Internal</b> <b>Parameters:</b>

             TOLMUL  DOUBLE PRECISION, default = max(10,min(100,EPS**(-1/8)))
                     TOLMUL controls the convergence criterion of the QR loop.
                     If it is positive, TOLMUL*EPS is the desired relative
                        precision in the computed singular values.
                     If it is negative, abs(TOLMUL*EPS*sigma_max) is the
                        desired absolute accuracy in the computed singular
                        values (corresponds to relative accuracy
                        abs(TOLMUL*EPS) in the largest singular value.
                     abs(TOLMUL) should be between 1 and 1/EPS, and preferably
                        between 10 (for fast convergence) and .1/EPS
                        (for there to be some accuracy in the results).
                     Default is to lose at either one eighth or 2 of the
                        available decimal digits in each computed singular value
                        (whichever is smaller).

             MAXITR  INTEGER, default = 6
                     MAXITR controls the maximum number of passes of the
                     algorithm through its inner loop. The algorithms stops
                     (and so fails to converge) if the number of passes
                     through the inner loop exceeds MAXITR*N**2.

       <b>Note:</b>

             Bug report from Cezary Dendek.
             On March 23rd 2017, the INTEGER variable MAXIT = MAXITR*N**2 is
             removed since it can overflow pretty easily (for N larger or equal
             than 18,919). We instead use MAXITDIVN = MAXITR*N.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ddisna</b> <b>(character</b> <b>JOB,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>SEP,</b> <b>integer</b> <b>INFO)</b>
       <b>DDISNA</b>

       <b>Purpose:</b>

            DDISNA computes the reciprocal condition numbers for the eigenvectors
            of a real symmetric or complex Hermitian matrix or for the left or
            right singular vectors of a general m-by-n matrix. The reciprocal
            condition number is the 'gap' between the corresponding eigenvalue or
            singular value and the nearest other one.

            The bound on the error, measured by angle in radians, in the I-th
            computed vector is given by

                   DLAMCH( 'E' ) * ( ANORM / SEP( I ) )

            where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
            to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
            the error bound.

            DDISNA may also be used to compute error bounds for eigenvectors of
            the generalized symmetric definite eigenproblem.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                     Specifies for which problem the reciprocal condition numbers
                     should be computed:
                     = 'E':  the eigenvectors of a symmetric/Hermitian matrix;
                     = 'L':  the left singular vectors of a general matrix;
                     = 'R':  the right singular vectors of a general matrix.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     If JOB = 'L' or 'R', the number of columns of the matrix,
                     in which case N &gt;= 0. Ignored if JOB = 'E'.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (M) if JOB = 'E'
                                         dimension (min(M,N)) if JOB = 'L' or 'R'
                     The eigenvalues (if JOB = 'E') or singular values (if JOB =
                     'L' or 'R') of the matrix, in either increasing or decreasing
                     order. If singular values, they must be non-negative.

           <u>SEP</u>

                     SEP is DOUBLE PRECISION array, dimension (M) if JOB = 'E'
                                          dimension (min(M,N)) if JOB = 'L' or 'R'
                     The reciprocal condition numbers of the vectors.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlaed0</b> <b>(integer</b> <b>ICOMPQ,</b> <b>integer</b> <b>QSIZ,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldqs,</b> <b>*</b> <b>)</b> <b>QSTORE,</b> <b>integer</b> <b>LDQS,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAED0</b> used by DSTEDC. Computes all eigenvalues and corresponding eigenvectors of an unreduced symmetric
       tridiagonal matrix using the divide and conquer method.

       <b>Purpose:</b>

            DLAED0 computes all eigenvalues and corresponding eigenvectors of a
            symmetric tridiagonal matrix using the divide and conquer method.

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                     = 0:  Compute eigenvalues only.
                     = 1:  Compute eigenvectors of original dense symmetric matrix
                           also.  On entry, Q contains the orthogonal matrix used
                           to reduce the original matrix to tridiagonal form.
                     = 2:  Compute eigenvalues and eigenvectors of tridiagonal
                           matrix.

           <u>QSIZ</u>

                     QSIZ is INTEGER
                    The dimension of the orthogonal matrix used to reduce
                    the full matrix to tridiagonal form.  QSIZ &gt;= N if ICOMPQ = 1.

           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                    On entry, the main diagonal of the tridiagonal matrix.
                    On exit, its eigenvalues.

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (N-1)
                    The off-diagonal elements of the tridiagonal matrix.
                    On exit, E has been destroyed.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (LDQ, N)
                    On entry, Q must contain an N-by-N orthogonal matrix.
                    If ICOMPQ = 0    Q is not referenced.
                    If ICOMPQ = 1    On entry, Q is a subset of the columns of the
                                     orthogonal matrix used to reduce the full
                                     matrix to tridiagonal form corresponding to
                                     the subset of the full matrix which is being
                                     decomposed at this time.
                    If ICOMPQ = 2    On entry, Q will be the identity matrix.
                                     On exit, Q contains the eigenvectors of the
                                     tridiagonal matrix.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  If eigenvectors are
                    desired, then  LDQ &gt;= max(1,N).  In any case,  LDQ &gt;= 1.

           <u>QSTORE</u>

                     QSTORE is DOUBLE PRECISION array, dimension (LDQS, N)
                    Referenced only when ICOMPQ = 1.  Used to store parts of
                    the eigenvector matrix when the updating matrix multiplies
                    take place.

           <u>LDQS</u>

                     LDQS is INTEGER
                    The leading dimension of the array QSTORE.  If ICOMPQ = 1,
                    then  LDQS &gt;= max(1,N).  In any case,  LDQS &gt;= 1.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array,
                    If ICOMPQ = 0 or 1, the dimension of WORK must be at least
                                1 + 3*N + 2*N*lg N + 3*N**2
                                ( lg( N ) = smallest integer k
                                            such that 2^k &gt;= N )
                    If ICOMPQ = 2, the dimension of WORK must be at least
                                4*N + N**2.

           <u>IWORK</u>

                     IWORK is INTEGER array,
                    If ICOMPQ = 0 or 1, the dimension of IWORK must be at least
                                   6 + 6*N + 5*N*lg N.
                                   ( lg( N ) = smallest integer k
                                               such that 2^k &gt;= N )
                    If ICOMPQ = 2, the dimension of IWORK must be at least
                                   3 + 5*N.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  The algorithm failed to compute an eigenvalue while
                           working on the submatrix lying in rows and columns
                           INFO/(N+1) through mod(INFO,N+1).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>dlaed1</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b>
       <b>integer</b> <b>LDQ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXQ,</b> <b>double</b> <b>precision</b> <b>RHO,</b> <b>integer</b> <b>CUTPNT,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAED1</b> used by DSTEDC. Computes the updated eigensystem of a diagonal matrix after modification by a
       rank-one symmetric matrix. Used when the original matrix is tridiagonal.

       <b>Purpose:</b>

            DLAED1 computes the updated eigensystem of a diagonal
            matrix after modification by a rank-one symmetric matrix.  This
            routine is used only for the eigenproblem which requires all
            eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
            the case in which eigenvalues only or eigenvalues and eigenvectors
            of a full symmetric matrix (which was reduced to tridiagonal form)
            are desired.

              T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)

               where Z = Q**T*u, u is a vector of length N with ones in the
               CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.

               The eigenvectors of the original matrix are stored in Q, and the
               eigenvalues are in D.  The algorithm consists of three stages:

                  The first stage consists of deflating the size of the problem
                  when there are multiple eigenvalues or if there is a zero in
                  the Z vector.  For each such occurrence the dimension of the
                  secular equation problem is reduced by one.  This stage is
                  performed by the routine DLAED2.

                  The second stage consists of calculating the updated
                  eigenvalues. This is done by finding the roots of the secular
                  equation via the routine DLAED4 (as called by DLAED3).
                  This routine also calculates the eigenvectors of the current
                  problem.

                  The final stage consists of computing the updated eigenvectors
                  directly using the updated eigenvalues.  The eigenvectors for
                  the current problem are multiplied with the eigenvectors from
                  the overall problem.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                    On entry, the eigenvalues of the rank-1-perturbed matrix.
                    On exit, the eigenvalues of the repaired matrix.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (LDQ,N)
                    On entry, the eigenvectors of the rank-1-perturbed matrix.
                    On exit, the eigenvectors of the repaired tridiagonal matrix.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>INDXQ</u>

                     INDXQ is INTEGER array, dimension (N)
                    On entry, the permutation which separately sorts the two
                    subproblems in D into ascending order.
                    On exit, the permutation which will reintegrate the
                    subproblems back into sorted order,
                    i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.

           <u>RHO</u>

                     RHO is DOUBLE PRECISION
                    The subdiagonal entry used to create the rank-1 modification.

           <u>CUTPNT</u>

                     CUTPNT is INTEGER
                    The location of the last eigenvalue in the leading sub-matrix.
                    min(1,N) &lt;= CUTPNT &lt;= N/2.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (4*N + N**2)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (4*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if INFO = 1, an eigenvalue did not converge

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA
            Modified by Francoise Tisseur, University of Tennessee

   <b>subroutine</b> <b>dlaed2</b> <b>(integer</b> <b>K,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>N1,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXQ,</b> <b>double</b> <b>precision</b> <b>RHO,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DLAMDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Q2,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDX,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXC,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>COLTYP,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAED2</b> used by DSTEDC. Merges eigenvalues and deflates secular equation. Used when the original matrix is
       tridiagonal.

       <b>Purpose:</b>

            DLAED2 merges the two sets of eigenvalues together into a single
            sorted set.  Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            eigenvalues are close together or if there is a tiny entry in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.

       <b>Parameters</b>
           <u>K</u>

                     K is INTEGER
                    The number of non-deflated eigenvalues, and the order of the
                    related secular equation. 0 &lt;= K &lt;=N.

           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>N1</u>

                     N1 is INTEGER
                    The location of the last eigenvalue in the leading sub-matrix.
                    min(1,N) &lt;= N1 &lt;= N/2.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                    On entry, D contains the eigenvalues of the two submatrices to
                    be combined.
                    On exit, D contains the trailing (N-K) updated eigenvalues
                    (those which were deflated) sorted into increasing order.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (LDQ, N)
                    On entry, Q contains the eigenvectors of two submatrices in
                    the two square blocks with corners at (1,1), (N1,N1)
                    and (N1+1, N1+1), (N,N).
                    On exit, Q contains the trailing (N-K) updated eigenvectors
                    (those which were deflated) in its last N-K columns.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>INDXQ</u>

                     INDXQ is INTEGER array, dimension (N)
                    The permutation which separately sorts the two sub-problems
                    in D into ascending order.  Note that elements in the second
                    half of this permutation must first have N1 added to their
                    values. Destroyed on exit.

           <u>RHO</u>

                     RHO is DOUBLE PRECISION
                    On entry, the off-diagonal element associated with the rank-1
                    cut which originally split the two submatrices which are now
                    being recombined.
                    On exit, RHO has been modified to the value required by
                    DLAED3.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (N)
                    On entry, Z contains the updating vector (the last
                    row of the first sub-eigenvector matrix and the first row of
                    the second sub-eigenvector matrix).
                    On exit, the contents of Z have been destroyed by the updating
                    process.

           <u>DLAMDA</u>

                     DLAMDA is DOUBLE PRECISION array, dimension (N)
                    A copy of the first K eigenvalues which will be used by
                    DLAED3 to form the secular equation.

           <u>W</u>

                     W is DOUBLE PRECISION array, dimension (N)
                    The first k values of the final deflation-altered z-vector
                    which will be passed to DLAED3.

           <u>Q2</u>

                     Q2 is DOUBLE PRECISION array, dimension (N1**2+(N-N1)**2)
                    A copy of the first K eigenvectors which will be used by
                    DLAED3 in a matrix multiply (DGEMM) to solve for the new
                    eigenvectors.

           <u>INDX</u>

                     INDX is INTEGER array, dimension (N)
                    The permutation used to sort the contents of DLAMDA into
                    ascending order.

           <u>INDXC</u>

                     INDXC is INTEGER array, dimension (N)
                    The permutation used to arrange the columns of the deflated
                    Q matrix into three groups:  the first group contains non-zero
                    elements only at and above N1, the second contains
                    non-zero elements only below N1, and the third is dense.

           <u>INDXP</u>

                     INDXP is INTEGER array, dimension (N)
                    The permutation used to place deflated values of D at the end
                    of the array.  INDXP(1:K) points to the nondeflated D-values
                    and INDXP(K+1:N) points to the deflated eigenvalues.

           <u>COLTYP</u>

                     COLTYP is INTEGER array, dimension (N)
                    During execution, a label which will indicate which of the
                    following types a column in the Q2 matrix is:
                    1 : non-zero in the upper half only;
                    2 : dense;
                    3 : non-zero in the lower half only;
                    4 : deflated.
                    On exit, COLTYP(i) is the number of columns of type i,
                    for i=1 to 4 only.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA
            Modified by Francoise Tisseur, University of Tennessee

   <b>subroutine</b> <b>dlaed3</b> <b>(integer</b> <b>K,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>N1,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>double</b> <b>precision</b> <b>RHO,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DLAMDA,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Q2,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDX,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CTOT,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAED3</b> used by DSTEDC. Finds the roots of the secular equation and updates the eigenvectors. Used when
       the original matrix is tridiagonal.

       <b>Purpose:</b>

            DLAED3 finds the roots of the secular equation, as defined by the
            values in D, W, and RHO, between 1 and K.  It makes the
            appropriate calls to DLAED4 and then updates the eigenvectors by
            multiplying the matrix of eigenvectors of the pair of eigensystems
            being combined by the matrix of eigenvectors of the K-by-K system
            which is solved here.

            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.

       <b>Parameters</b>
           <u>K</u>

                     K is INTEGER
                     The number of terms in the rational function to be solved by
                     DLAED4.  K &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of rows and columns in the Q matrix.
                     N &gt;= K (deflation may result in N&gt;K).

           <u>N1</u>

                     N1 is INTEGER
                     The location of the last eigenvalue in the leading submatrix.
                     min(1,N) &lt;= N1 &lt;= N/2.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     D(I) contains the updated eigenvalues for
                     1 &lt;= I &lt;= K.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (LDQ,N)
                     Initially the first K columns are used as workspace.
                     On output the columns 1 to K contain
                     the updated eigenvectors.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>RHO</u>

                     RHO is DOUBLE PRECISION
                     The value of the parameter in the rank one update equation.
                     RHO &gt;= 0 required.

           <u>DLAMDA</u>

                     DLAMDA is DOUBLE PRECISION array, dimension (K)
                     The first K elements of this array contain the old roots
                     of the deflated updating problem.  These are the poles
                     of the secular equation. May be changed on output by
                     having lowest order bit set to zero on Cray X-MP, Cray Y-MP,
                     Cray-2, or Cray C-90, as described above.

           <u>Q2</u>

                     Q2 is DOUBLE PRECISION array, dimension (LDQ2*N)
                     The first K columns of this matrix contain the non-deflated
                     eigenvectors for the split problem.

           <u>INDX</u>

                     INDX is INTEGER array, dimension (N)
                     The permutation used to arrange the columns of the deflated
                     Q matrix into three groups (see DLAED2).
                     The rows of the eigenvectors found by DLAED4 must be likewise
                     permuted before the matrix multiply can take place.

           <u>CTOT</u>

                     CTOT is INTEGER array, dimension (4)
                     A count of the total number of the various types of columns
                     in Q, as described in INDX.  The fourth column type is any
                     column which has been deflated.

           <u>W</u>

                     W is DOUBLE PRECISION array, dimension (K)
                     The first K elements of this array contain the components
                     of the deflation-adjusted updating vector. Destroyed on
                     output.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (N1 + 1)*K
                     Will contain the eigenvectors of the repaired matrix which
                     will be multiplied by the previously accumulated eigenvectors
                     to update the system.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if INFO = 1, an eigenvalue did not converge

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA
            Modified by Francoise Tisseur, University of Tennessee

   <b>subroutine</b> <b>dlaed4</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>I,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>Z,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DELTA,</b> <b>double</b> <b>precision</b> <b>RHO,</b> <b>double</b> <b>precision</b> <b>DLAM,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAED4</b> used by DSTEDC. Finds a single root of the secular equation.

       <b>Purpose:</b>

            This subroutine computes the I-th updated eigenvalue of a symmetric
            rank-one modification to a diagonal matrix whose elements are
            given in the array d, and that

                       D(i) &lt; D(j)  for  i &lt; j

            and that RHO &gt; 0.  This is arranged by the calling routine, and is
            no loss in generality.  The rank-one modified system is thus

                       diag( D )  +  RHO * Z * Z_transpose.

            where we assume the Euclidean norm of Z is 1.

            The method consists of approximating the rational functions in the
            secular equation by simpler interpolating rational functions.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The length of all arrays.

           <u>I</u>

                     I is INTEGER
                    The index of the eigenvalue to be computed.  1 &lt;= I &lt;= N.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                    The original eigenvalues.  It is assumed that they are in
                    order, D(I) &lt; D(J)  for I &lt; J.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (N)
                    The components of the updating vector.

           <u>DELTA</u>

                     DELTA is DOUBLE PRECISION array, dimension (N)
                    If N &gt; 2, DELTA contains (D(j) - lambda_I) in its  j-th
                    component.  If N = 1, then <a href="../man1/DELTA.1.html">DELTA</a>(1) = 1. If N = 2, see DLAED5
                    for detail. The vector DELTA contains the information necessary
                    to construct the eigenvectors by DLAED3 and DLAED9.

           <u>RHO</u>

                     RHO is DOUBLE PRECISION
                    The scalar in the symmetric updating formula.

           <u>DLAM</u>

                     DLAM is DOUBLE PRECISION
                    The computed lambda_I, the I-th updated eigenvalue.

           <u>INFO</u>

                     INFO is INTEGER
                    = 0:  successful exit
                    &gt; 0:  if INFO = 1, the updating process failed.

       <b>Internal</b> <b>Parameters:</b>

             Logical variable ORGATI (origin-at-i?) is used for distinguishing
             whether D(i) or D(i+1) is treated as the origin.

                       ORGATI = .true.    origin at i
                       ORGATI = .false.   origin at i+1

              Logical variable SWTCH3 (switch-for-3-poles?) is for noting
              if we are working with THREE poles!

              MAXIT is the maximum number of iterations allowed for each
              eigenvalue.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>dlaed5</b> <b>(integer</b> <b>I,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>2</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>2</b> <b>)</b> <b>Z,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>2</b> <b>)</b> <b>DELTA,</b> <b>double</b> <b>precision</b> <b>RHO,</b> <b>double</b> <b>precision</b> <b>DLAM)</b>
       <b>DLAED5</b> used by DSTEDC. Solves the 2-by-2 secular equation.

       <b>Purpose:</b>

            This subroutine computes the I-th eigenvalue of a symmetric rank-one
            modification of a 2-by-2 diagonal matrix

                       diag( D )  +  RHO * Z * transpose(Z) .

            The diagonal elements in the array D are assumed to satisfy

                       D(i) &lt; D(j)  for  i &lt; j .

            We also assume RHO &gt; 0 and that the Euclidean norm of the vector
            Z is one.

       <b>Parameters</b>
           <u>I</u>

                     I is INTEGER
                    The index of the eigenvalue to be computed.  I = 1 or I = 2.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (2)
                    The original eigenvalues.  We assume <a href="../man1/D.1.html">D</a>(1) &lt; <a href="../man2/D.2.html">D</a>(2).

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (2)
                    The components of the updating vector.

           <u>DELTA</u>

                     DELTA is DOUBLE PRECISION array, dimension (2)
                    The vector DELTA contains the information necessary
                    to construct the eigenvectors.

           <u>RHO</u>

                     RHO is DOUBLE PRECISION
                    The scalar in the symmetric updating formula.

           <u>DLAM</u>

                     DLAM is DOUBLE PRECISION
                    The computed lambda_I, the I-th updated eigenvalue.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>dlaed6</b> <b>(integer</b> <b>KNITER,</b> <b>logical</b> <b>ORGATI,</b> <b>double</b> <b>precision</b> <b>RHO,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>3</b> <b>)</b> <b>D,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>3</b> <b>)</b> <b>Z,</b> <b>double</b> <b>precision</b> <b>FINIT,</b> <b>double</b> <b>precision</b> <b>TAU,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAED6</b> used by DSTEDC. Computes one Newton step in solution of the secular equation.

       <b>Purpose:</b>

            DLAED6 computes the positive or negative root (closest to the origin)
            of
                             <a href="../man1/z.1.html">z</a>(1)        <a href="../man2/z.2.html">z</a>(2)        <a href="../man3/z.3.html">z</a>(3)
            f(x) =   rho + --------- + ---------- + ---------
                            <a href="../man1/d.1.html">d</a>(1)-x      <a href="../man2/d.2.html">d</a>(2)-x      <a href="../man3/d.3.html">d</a>(3)-x

            It is assumed that

                  if ORGATI = .true. the root is between <a href="../man2/d.2.html">d</a>(2) and <a href="../man3/d.3.html">d</a>(3);
                  otherwise it is between <a href="../man1/d.1.html">d</a>(1) and <a href="../man2/d.2.html">d</a>(2)

            This routine will be called by DLAED4 when necessary. In most cases,
            the root sought is the smallest in magnitude, though it might not be
            in some extremely rare situations.

       <b>Parameters</b>
           <u>KNITER</u>

                     KNITER is INTEGER
                          Refer to DLAED4 for its significance.

           <u>ORGATI</u>

                     ORGATI is LOGICAL
                          If ORGATI is true, the needed root is between <a href="../man2/d.2.html">d</a>(2) and
                          <a href="../man3/d.3.html">d</a>(3); otherwise it is between <a href="../man1/d.1.html">d</a>(1) and <a href="../man2/d.2.html">d</a>(2).  See
                          DLAED4 for further details.

           <u>RHO</u>

                     RHO is DOUBLE PRECISION
                          Refer to the equation f(x) above.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (3)
                          D satisfies <a href="../man1/d.1.html">d</a>(1) &lt; <a href="../man2/d.2.html">d</a>(2) &lt; <a href="../man3/d.3.html">d</a>(3).

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (3)
                          Each of the elements in z must be positive.

           <u>FINIT</u>

                     FINIT is DOUBLE PRECISION
                          The value of f at 0. It is more accurate than the one
                          evaluated inside this routine (if someone wants to do
                          so).

           <u>TAU</u>

                     TAU is DOUBLE PRECISION
                          The root of the equation f(x).

           <u>INFO</u>

                     INFO is INTEGER
                          = 0: successful exit
                          &gt; 0: if INFO = 1, failure to converge

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             10/02/03: This version has a few statements commented out for thread
             safety (machine parameters are computed on each entry). SJH.

             05/10/06: Modified from a new version of Ren-Cang Li, use
                Gragg-Thornton-Warner cubic convergent scheme for better stability.

       <b>Contributors:</b>
           Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>dlaed7</b> <b>(integer</b> <b>ICOMPQ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>QSIZ,</b> <b>integer</b> <b>TLVLS,</b> <b>integer</b> <b>CURLVL,</b> <b>integer</b> <b>CURPBM,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXQ,</b> <b>double</b> <b>precision</b> <b>RHO,</b> <b>integer</b> <b>CUTPNT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>QSTORE,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>QPTR,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PRMPTR,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PERM,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>GIVPTR,</b> <b>integer,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVCOL,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVNUM,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAED7</b> used by DSTEDC. Computes the updated eigensystem of a diagonal matrix after modification by a
       rank-one symmetric matrix. Used when the original matrix is dense.

       <b>Purpose:</b>

            DLAED7 computes the updated eigensystem of a diagonal
            matrix after modification by a rank-one symmetric matrix. This
            routine is used only for the eigenproblem which requires all
            eigenvalues and optionally eigenvectors of a dense symmetric matrix
            that has been reduced to tridiagonal form.  DLAED1 handles
            the case in which all eigenvalues and eigenvectors of a symmetric
            tridiagonal matrix are desired.

              T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)

               where Z = Q**Tu, u is a vector of length N with ones in the
               CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.

               The eigenvectors of the original matrix are stored in Q, and the
               eigenvalues are in D.  The algorithm consists of three stages:

                  The first stage consists of deflating the size of the problem
                  when there are multiple eigenvalues or if there is a zero in
                  the Z vector.  For each such occurrence the dimension of the
                  secular equation problem is reduced by one.  This stage is
                  performed by the routine DLAED8.

                  The second stage consists of calculating the updated
                  eigenvalues. This is done by finding the roots of the secular
                  equation via the routine DLAED4 (as called by DLAED9).
                  This routine also calculates the eigenvectors of the current
                  problem.

                  The final stage consists of computing the updated eigenvectors
                  directly using the updated eigenvalues.  The eigenvectors for
                  the current problem are multiplied with the eigenvectors from
                  the overall problem.

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                     = 0:  Compute eigenvalues only.
                     = 1:  Compute eigenvectors of original dense symmetric matrix
                           also.  On entry, Q contains the orthogonal matrix used
                           to reduce the original matrix to tridiagonal form.

           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>QSIZ</u>

                     QSIZ is INTEGER
                    The dimension of the orthogonal matrix used to reduce
                    the full matrix to tridiagonal form.  QSIZ &gt;= N if ICOMPQ = 1.

           <u>TLVLS</u>

                     TLVLS is INTEGER
                    The total number of merging levels in the overall divide and
                    conquer tree.

           <u>CURLVL</u>

                     CURLVL is INTEGER
                    The current level in the overall merge routine,
                    0 &lt;= CURLVL &lt;= TLVLS.

           <u>CURPBM</u>

                     CURPBM is INTEGER
                    The current problem in the current level in the overall
                    merge routine (counting from upper left to lower right).

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                    On entry, the eigenvalues of the rank-1-perturbed matrix.
                    On exit, the eigenvalues of the repaired matrix.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (LDQ, N)
                    On entry, the eigenvectors of the rank-1-perturbed matrix.
                    On exit, the eigenvectors of the repaired tridiagonal matrix.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>INDXQ</u>

                     INDXQ is INTEGER array, dimension (N)
                    The permutation which will reintegrate the subproblem just
                    solved back into sorted order, i.e., D( INDXQ( I = 1, N ) )
                    will be in ascending order.

           <u>RHO</u>

                     RHO is DOUBLE PRECISION
                    The subdiagonal element used to create the rank-1
                    modification.

           <u>CUTPNT</u>

                     CUTPNT is INTEGER
                    Contains the location of the last eigenvalue in the leading
                    sub-matrix.  min(1,N) &lt;= CUTPNT &lt;= N.

           <u>QSTORE</u>

                     QSTORE is DOUBLE PRECISION array, dimension (N**2+1)
                    Stores eigenvectors of submatrices encountered during
                    divide and conquer, packed together. QPTR points to
                    beginning of the submatrices.

           <u>QPTR</u>

                     QPTR is INTEGER array, dimension (N+2)
                    List of indices pointing to beginning of submatrices stored
                    in QSTORE. The submatrices are numbered starting at the
                    bottom left of the divide and conquer tree, from left to
                    right and bottom to top.

           <u>PRMPTR</u>

                     PRMPTR is INTEGER array, dimension (N lg N)
                    Contains a list of pointers which indicate where in PERM a
                    level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
                    indicates the size of the permutation and also the size of
                    the full, non-deflated problem.

           <u>PERM</u>

                     PERM is INTEGER array, dimension (N lg N)
                    Contains the permutations (from deflation and sorting) to be
                    applied to each eigenblock.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER array, dimension (N lg N)
                    Contains a list of pointers which indicate where in GIVCOL a
                    level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
                    indicates the number of Givens rotations.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension (2, N lg N)
                    Each pair of numbers indicates a pair of columns to take place
                    in a Givens rotation.

           <u>GIVNUM</u>

                     GIVNUM is DOUBLE PRECISION array, dimension (2, N lg N)
                    Each number indicates the S value to be used in the
                    corresponding Givens rotation.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (3*N+2*QSIZ*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (4*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if INFO = 1, an eigenvalue did not converge

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>dlaed8</b> <b>(integer</b> <b>ICOMPQ,</b> <b>integer</b> <b>K,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>QSIZ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXQ,</b> <b>double</b> <b>precision</b>
       <b>RHO,</b> <b>integer</b> <b>CUTPNT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DLAMDA,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldq2,</b> <b>*</b> <b>)</b> <b>Q2,</b> <b>integer</b> <b>LDQ2,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>integer,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>PERM,</b> <b>integer</b> <b>GIVPTR,</b> <b>integer,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVCOL,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVNUM,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDX,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAED8</b> used by DSTEDC. Merges eigenvalues and deflates secular equation. Used when the original matrix is
       dense.

       <b>Purpose:</b>

            DLAED8 merges the two sets of eigenvalues together into a single
            sorted set.  Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            eigenvalues are close together or if there is a tiny element in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                     = 0:  Compute eigenvalues only.
                     = 1:  Compute eigenvectors of original dense symmetric matrix
                           also.  On entry, Q contains the orthogonal matrix used
                           to reduce the original matrix to tridiagonal form.

           <u>K</u>

                     K is INTEGER
                    The number of non-deflated eigenvalues, and the order of the
                    related secular equation.

           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>QSIZ</u>

                     QSIZ is INTEGER
                    The dimension of the orthogonal matrix used to reduce
                    the full matrix to tridiagonal form.  QSIZ &gt;= N if ICOMPQ = 1.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                    On entry, the eigenvalues of the two submatrices to be
                    combined.  On exit, the trailing (N-K) updated eigenvalues
                    (those which were deflated) sorted into increasing order.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (LDQ,N)
                    If ICOMPQ = 0, Q is not referenced.  Otherwise,
                    on entry, Q contains the eigenvectors of the partially solved
                    system which has been previously updated in matrix
                    multiplies with other partially solved eigensystems.
                    On exit, Q contains the trailing (N-K) updated eigenvectors
                    (those which were deflated) in its last N-K columns.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>INDXQ</u>

                     INDXQ is INTEGER array, dimension (N)
                    The permutation which separately sorts the two sub-problems
                    in D into ascending order.  Note that elements in the second
                    half of this permutation must first have CUTPNT added to
                    their values in order to be accurate.

           <u>RHO</u>

                     RHO is DOUBLE PRECISION
                    On entry, the off-diagonal element associated with the rank-1
                    cut which originally split the two submatrices which are now
                    being recombined.
                    On exit, RHO has been modified to the value required by
                    DLAED3.

           <u>CUTPNT</u>

                     CUTPNT is INTEGER
                    The location of the last eigenvalue in the leading
                    sub-matrix.  min(1,N) &lt;= CUTPNT &lt;= N.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (N)
                    On entry, Z contains the updating vector (the last row of
                    the first sub-eigenvector matrix and the first row of the
                    second sub-eigenvector matrix).
                    On exit, the contents of Z are destroyed by the updating
                    process.

           <u>DLAMDA</u>

                     DLAMDA is DOUBLE PRECISION array, dimension (N)
                    A copy of the first K eigenvalues which will be used by
                    DLAED3 to form the secular equation.

           <u>Q2</u>

                     Q2 is DOUBLE PRECISION array, dimension (LDQ2,N)
                    If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
                    a copy of the first K eigenvectors which will be used by
                    DLAED7 in a matrix multiply (DGEMM) to update the new
                    eigenvectors.

           <u>LDQ2</u>

                     LDQ2 is INTEGER
                    The leading dimension of the array Q2.  LDQ2 &gt;= max(1,N).

           <u>W</u>

                     W is DOUBLE PRECISION array, dimension (N)
                    The first k values of the final deflation-altered z-vector and
                    will be passed to DLAED3.

           <u>PERM</u>

                     PERM is INTEGER array, dimension (N)
                    The permutations (from deflation and sorting) to be applied
                    to each eigenblock.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER
                    The number of Givens rotations which took place in this
                    subproblem.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension (2, N)
                    Each pair of numbers indicates a pair of columns to take place
                    in a Givens rotation.

           <u>GIVNUM</u>

                     GIVNUM is DOUBLE PRECISION array, dimension (2, N)
                    Each number indicates the S value to be used in the
                    corresponding Givens rotation.

           <u>INDXP</u>

                     INDXP is INTEGER array, dimension (N)
                    The permutation used to place deflated values of D at the end
                    of the array.  INDXP(1:K) points to the nondeflated D-values
                    and INDXP(K+1:N) points to the deflated eigenvalues.

           <u>INDX</u>

                     INDX is INTEGER array, dimension (N)
                    The permutation used to sort the contents of D into ascending
                    order.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>dlaed9</b> <b>(integer</b> <b>K,</b> <b>integer</b> <b>KSTART,</b> <b>integer</b> <b>KSTOP,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>double</b> <b>precision</b> <b>RHO,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>DLAMDA,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lds,</b> <b>*</b> <b>)</b> <b>S,</b> <b>integer</b> <b>LDS,</b>
       <b>integer</b> <b>INFO)</b>
       <b>DLAED9</b> used by DSTEDC. Finds the roots of the secular equation and updates the eigenvectors. Used when
       the original matrix is dense.

       <b>Purpose:</b>

            DLAED9 finds the roots of the secular equation, as defined by the
            values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
            appropriate calls to DLAED4 and then stores the new matrix of
            eigenvectors for use in calculating the next level of Z vectors.

       <b>Parameters</b>
           <u>K</u>

                     K is INTEGER
                     The number of terms in the rational function to be solved by
                     DLAED4.  K &gt;= 0.

           <u>KSTART</u>

                     KSTART is INTEGER

           <u>KSTOP</u>

                     KSTOP is INTEGER
                     The updated eigenvalues Lambda(I), KSTART &lt;= I &lt;= KSTOP
                     are to be computed.  1 &lt;= KSTART &lt;= KSTOP &lt;= K.

           <u>N</u>

                     N is INTEGER
                     The number of rows and columns in the Q matrix.
                     N &gt;= K (delation may result in N &gt; K).

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     D(I) contains the updated eigenvalues
                     for KSTART &lt;= I &lt;= KSTOP.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (LDQ,N)

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.  LDQ &gt;= max( 1, N ).

           <u>RHO</u>

                     RHO is DOUBLE PRECISION
                     The value of the parameter in the rank one update equation.
                     RHO &gt;= 0 required.

           <u>DLAMDA</u>

                     DLAMDA is DOUBLE PRECISION array, dimension (K)
                     The first K elements of this array contain the old roots
                     of the deflated updating problem.  These are the poles
                     of the secular equation.

           <u>W</u>

                     W is DOUBLE PRECISION array, dimension (K)
                     The first K elements of this array contain the components
                     of the deflation-adjusted updating vector.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (LDS, K)
                     Will contain the eigenvectors of the repaired matrix which
                     will be stored for subsequent Z vector calculation and
                     multiplied by the previously accumulated eigenvectors
                     to update the system.

           <u>LDS</u>

                     LDS is INTEGER
                     The leading dimension of S.  LDS &gt;= max( 1, K ).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if INFO = 1, an eigenvalue did not converge

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>dlaeda</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>TLVLS,</b> <b>integer</b> <b>CURLVL,</b> <b>integer</b> <b>CURPBM,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PRMPTR,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PERM,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>GIVPTR,</b> <b>integer,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVCOL,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVNUM,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>QPTR,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ZTEMP,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAEDA</b> used by DSTEDC. Computes the Z vector determining the rank-one modification of the diagonal
       matrix. Used when the original matrix is dense.

       <b>Purpose:</b>

            DLAEDA computes the Z vector corresponding to the merge step in the
            CURLVLth step of the merge process with TLVLS steps for the CURPBMth
            problem.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>TLVLS</u>

                     TLVLS is INTEGER
                    The total number of merging levels in the overall divide and
                    conquer tree.

           <u>CURLVL</u>

                     CURLVL is INTEGER
                    The current level in the overall merge routine,
                    0 &lt;= curlvl &lt;= tlvls.

           <u>CURPBM</u>

                     CURPBM is INTEGER
                    The current problem in the current level in the overall
                    merge routine (counting from upper left to lower right).

           <u>PRMPTR</u>

                     PRMPTR is INTEGER array, dimension (N lg N)
                    Contains a list of pointers which indicate where in PERM a
                    level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
                    indicates the size of the permutation and incidentally the
                    size of the full, non-deflated problem.

           <u>PERM</u>

                     PERM is INTEGER array, dimension (N lg N)
                    Contains the permutations (from deflation and sorting) to be
                    applied to each eigenblock.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER array, dimension (N lg N)
                    Contains a list of pointers which indicate where in GIVCOL a
                    level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
                    indicates the number of Givens rotations.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension (2, N lg N)
                    Each pair of numbers indicates a pair of columns to take place
                    in a Givens rotation.

           <u>GIVNUM</u>

                     GIVNUM is DOUBLE PRECISION array, dimension (2, N lg N)
                    Each number indicates the S value to be used in the
                    corresponding Givens rotation.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension (N**2)
                    Contains the square eigenblocks from previous levels, the
                    starting positions for blocks are given by QPTR.

           <u>QPTR</u>

                     QPTR is INTEGER array, dimension (N+2)
                    Contains a list of pointers which indicate where in Q an
                    eigenblock is stored.  SQRT( QPTR(i+1) - QPTR(i) ) indicates
                    the size of the block.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (N)
                    On output this vector contains the updating vector (the last
                    row of the first sub-eigenvector matrix and the first row of
                    the second sub-eigenvector matrix).

           <u>ZTEMP</u>

                     ZTEMP is DOUBLE PRECISION array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>dlagtf</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>A,</b> <b>double</b> <b>precision</b> <b>LAMBDA,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>B,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>double</b> <b>precision</b> <b>TOL,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>D,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IN,</b> <b>integer</b> <b>INFO)</b>
       <b>DLAGTF</b> computes an LU factorization of a matrix T-λI, where T is a general tridiagonal matrix, and λ a
       scalar, using partial pivoting with row interchanges.

       <b>Purpose:</b>

            DLAGTF factorizes the matrix (T - lambda*I), where T is an n by n
            tridiagonal matrix and lambda is a scalar, as

               T - lambda*I = PLU,

            where P is a permutation matrix, L is a unit lower tridiagonal matrix
            with at most one non-zero sub-diagonal elements per column and U is
            an upper triangular matrix with at most two non-zero super-diagonal
            elements per column.

            The factorization is obtained by Gaussian elimination with partial
            pivoting and implicit row scaling.

            The parameter LAMBDA is included in the routine so that DLAGTF may
            be used, in conjunction with DLAGTS, to obtain eigenvectors of T by
            inverse iteration.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix T.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (N)
                     On entry, A must contain the diagonal elements of T.

                     On exit, A is overwritten by the n diagonal elements of the
                     upper triangular matrix U of the factorization of T.

           <u>LAMBDA</u>

                     LAMBDA is DOUBLE PRECISION
                     On entry, the scalar lambda.

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (N-1)
                     On entry, B must contain the (n-1) super-diagonal elements of
                     T.

                     On exit, B is overwritten by the (n-1) super-diagonal
                     elements of the matrix U of the factorization of T.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (N-1)
                     On entry, C must contain the (n-1) sub-diagonal elements of
                     T.

                     On exit, C is overwritten by the (n-1) sub-diagonal elements
                     of the matrix L of the factorization of T.

           <u>TOL</u>

                     TOL is DOUBLE PRECISION
                     On entry, a relative tolerance used to indicate whether or
                     not the matrix (T - lambda*I) is nearly singular. TOL should
                     normally be chose as approximately the largest relative error
                     in the elements of T. For example, if the elements of T are
                     correct to about 4 significant figures, then TOL should be
                     set to about 5*10**(-4). If TOL is supplied as less than eps,
                     where eps is the relative machine precision, then the value
                     eps is used in place of TOL.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N-2)
                     On exit, D is overwritten by the (n-2) second super-diagonal
                     elements of the matrix U of the factorization of T.

           <u>IN</u>

                     IN is INTEGER array, dimension (N)
                     On exit, IN contains details of the permutation matrix P. If
                     an interchange occurred at the kth step of the elimination,
                     then IN(k) = 1, otherwise IN(k) = 0. The element IN(n)
                     returns the smallest positive integer j such that

                        abs( u(j,j) ) &lt;= norm( (T - lambda*I)(j) )*TOL,

                     where norm( A(j) ) denotes the sum of the absolute values of
                     the jth row of the matrix A. If no such j exists then IN(n)
                     is returned as zero. If IN(n) is returned as positive, then a
                     diagonal element of U is small, indicating that
                     (T - lambda*I) is singular or nearly singular,

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -k, the kth argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlamrg</b> <b>(integer</b> <b>N1,</b> <b>integer</b> <b>N2,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>DTRD1,</b> <b>integer</b> <b>DTRD2,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDEX)</b>
       <b>DLAMRG</b> creates a permutation list to merge the entries of two independently sorted sets into a single set
       sorted in ascending order.

       <b>Purpose:</b>

            DLAMRG will create a permutation list which will merge the elements
            of A (which is composed of two independently sorted sets) into a
            single set which is sorted in ascending order.

       <b>Parameters</b>
           <u>N1</u>

                     N1 is INTEGER

           <u>N2</u>

                     N2 is INTEGER
                    These arguments contain the respective lengths of the two
                    sorted lists to be merged.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (N1+N2)
                    The first N1 elements of A contain a list of numbers which
                    are sorted in either ascending or descending order.  Likewise
                    for the final N2 elements.

           <u>DTRD1</u>

                     DTRD1 is INTEGER

           <u>DTRD2</u>

                     DTRD2 is INTEGER
                    These are the strides to be taken through the array A.
                    Allowable strides are 1 and -1.  They indicate whether a
                    subset of A is sorted in ascending (DTRDx = 1) or descending
                    (DTRDx = -1) order.

           <u>INDEX</u>

                     INDEX is INTEGER array, dimension (N1+N2)
                    On exit this array will contain a permutation such that
                    if B( I ) = A( INDEX( I ) ) for I=1,N1+N2, then B will be
                    sorted in ascending order.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlartgs</b> <b>(double</b> <b>precision</b> <b>X,</b> <b>double</b> <b>precision</b> <b>Y,</b> <b>double</b> <b>precision</b> <b>SIGMA,</b> <b>double</b> <b>precision</b> <b>CS,</b>
       <b>double</b> <b>precision</b> <b>SN)</b>
       <b>DLARTGS</b> generates a plane rotation designed to introduce a bulge in implicit QR iteration for the
       bidiagonal SVD problem.

       <b>Purpose:</b>

            DLARTGS generates a plane rotation designed to introduce a bulge in
            Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
            problem. X and Y are the top-row entries, and SIGMA is the shift.
            The computed CS and SN define a plane rotation satisfying

               [  CS  SN  ]  .  [ X^2 - SIGMA ]  =  [ R ],
               [ -SN  CS  ]     [    X * Y    ]     [ 0 ]

            with R nonnegative.  If X^2 - SIGMA and X * Y are 0, then the
            rotation is by PI/2.

       <b>Parameters</b>
           <u>X</u>

                     X is DOUBLE PRECISION
                     The (1,1) entry of an upper bidiagonal matrix.

           <u>Y</u>

                     Y is DOUBLE PRECISION
                     The (1,2) entry of an upper bidiagonal matrix.

           <u>SIGMA</u>

                     SIGMA is DOUBLE PRECISION
                     The shift.

           <u>CS</u>

                     CS is DOUBLE PRECISION
                     The cosine of the rotation.

           <u>SN</u>

                     SN is DOUBLE PRECISION
                     The sine of the rotation.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlasq1</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DLASQ1</b> computes the singular values of a real square bidiagonal matrix. Used by sbdsqr.

       <b>Purpose:</b>

            DLASQ1 computes the singular values of a real N-by-N bidiagonal
            matrix with diagonal D and off-diagonal E. The singular values
            are computed to high relative accuracy, in the absence of
            denormalization, underflow and overflow. The algorithm was first
            presented in

            "Accurate singular values and differential qd algorithms" by K. V.
            Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
            1994,

            and the present implementation is described in "An implementation of
            the dqds Algorithm (Positive Case)", LAPACK Working Note.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                   The number of rows and columns in the matrix. N &gt;= 0.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                   On entry, D contains the diagonal elements of the
                   bidiagonal matrix whose SVD is desired. On normal exit,
                   D contains the singular values in decreasing order.

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (N)
                   On entry, elements E(1:N-1) contain the off-diagonal elements
                   of the bidiagonal matrix whose SVD is desired.
                   On exit, E is overwritten.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (4*N)

           <u>INFO</u>

                     INFO is INTEGER
                   = 0: successful exit
                   &lt; 0: if INFO = -i, the i-th argument had an illegal value
                   &gt; 0: the algorithm failed
                        = 1, a split was marked by a positive value in E
                        = 2, current block of Z not diagonalized after 100*N
                             iterations (in inner while loop)  On exit D and E
                             represent a matrix with the same singular values
                             which the calling subroutine could use to finish the
                             computation, or even feed back into DLASQ1
                        = 3, termination criterion of outer while loop not met
                             (program created more than N unreduced blocks)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlasq2</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>INFO)</b>
       <b>DLASQ2</b> computes all the eigenvalues of the symmetric positive definite tridiagonal matrix associated with
       the qd Array Z to high relative accuracy. Used by sbdsqr and sstegr.

       <b>Purpose:</b>

            DLASQ2 computes all the eigenvalues of the symmetric positive
            definite tridiagonal matrix associated with the qd array Z to high
            relative accuracy are computed to high relative accuracy, in the
            absence of denormalization, underflow and overflow.

            To see the relation of Z to the tridiagonal matrix, let L be a
            unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
            let U be an upper bidiagonal matrix with 1's above and diagonal
            Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
            symmetric tridiagonal to which it is similar.

            Note : DLASQ2 defines a logical variable, IEEE, which is true
            on machines which follow ieee-754 floating-point standard in their
            handling of infinities and NaNs, and false otherwise. This variable
            is passed to DLASQ3.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                   The number of rows and columns in the matrix. N &gt;= 0.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension ( 4*N )
                   On entry Z holds the qd array. On exit, entries 1 to N hold
                   the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
                   trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
                   N &gt; 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
                   holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
                   shifts that failed.

           <u>INFO</u>

                     INFO is INTEGER
                   = 0: successful exit
                   &lt; 0: if the i-th argument is a scalar and had an illegal
                        value, then INFO = -i, if the i-th argument is an
                        array and the j-entry had an illegal value, then
                        INFO = -(i*100+j)
                   &gt; 0: the algorithm failed
                         = 1, a split was marked by a positive value in E
                         = 2, current block of Z not diagonalized after 100*N
                              iterations (in inner while loop).  On exit Z holds
                              a qd array with the same eigenvalues as the given Z.
                         = 3, termination criterion of outer while loop not met
                              (program created more than N unreduced blocks)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Local Variables: I0:N0 defines a current unreduced segment of Z.
             The shifts are accumulated in SIGMA. Iteration count is in ITER.
             Ping-pong is controlled by PP (alternates between 0 and 1).

   <b>subroutine</b> <b>dlasq3</b> <b>(integer</b> <b>I0,</b> <b>integer</b> <b>N0,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>PP,</b> <b>double</b> <b>precision</b>
       <b>DMIN,</b> <b>double</b> <b>precision</b> <b>SIGMA,</b> <b>double</b> <b>precision</b> <b>DESIG,</b> <b>double</b> <b>precision</b> <b>QMAX,</b> <b>integer</b> <b>NFAIL,</b> <b>integer</b> <b>ITER,</b>
       <b>integer</b> <b>NDIV,</b> <b>logical</b> <b>IEEE,</b> <b>integer</b> <b>TTYPE,</b> <b>double</b> <b>precision</b> <b>DMIN1,</b> <b>double</b> <b>precision</b> <b>DMIN2,</b> <b>double</b>
       <b>precision</b> <b>DN,</b> <b>double</b> <b>precision</b> <b>DN1,</b> <b>double</b> <b>precision</b> <b>DN2,</b> <b>double</b> <b>precision</b> <b>G,</b> <b>double</b> <b>precision</b> <b>TAU)</b>
       <b>DLASQ3</b> checks for deflation, computes a shift and calls dqds. Used by sbdsqr.

       <b>Purpose:</b>

            DLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.
            In case of failure it changes shifts, and tries again until output
            is positive.

       <b>Parameters</b>
           <u>I0</u>

                     I0 is INTEGER
                    First index.

           <u>N0</u>

                     N0 is INTEGER
                    Last index.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension ( 4*N0 )
                    Z holds the qd array.

           <u>PP</u>

                     PP is INTEGER
                    PP=0 for ping, PP=1 for pong.
                    PP=2 indicates that flipping was applied to the Z array
                    and that the initial tests for deflation should not be
                    performed.

           <u>DMIN</u>

                     DMIN is DOUBLE PRECISION
                    Minimum value of d.

           <u>SIGMA</u>

                     SIGMA is DOUBLE PRECISION
                    Sum of shifts used in current segment.

           <u>DESIG</u>

                     DESIG is DOUBLE PRECISION
                    Lower order part of SIGMA

           <u>QMAX</u>

                     QMAX is DOUBLE PRECISION
                    Maximum value of q.

           <u>NFAIL</u>

                     NFAIL is INTEGER
                    Increment NFAIL by 1 each time the shift was too big.

           <u>ITER</u>

                     ITER is INTEGER
                    Increment ITER by 1 for each iteration.

           <u>NDIV</u>

                     NDIV is INTEGER
                    Increment NDIV by 1 for each division.

           <u>IEEE</u>

                     IEEE is LOGICAL
                    Flag for IEEE or non IEEE arithmetic (passed to DLASQ5).

           <u>TTYPE</u>

                     TTYPE is INTEGER
                    Shift type.

           <u>DMIN1</u>

                     DMIN1 is DOUBLE PRECISION

           <u>DMIN2</u>

                     DMIN2 is DOUBLE PRECISION

           <u>DN</u>

                     DN is DOUBLE PRECISION

           <u>DN1</u>

                     DN1 is DOUBLE PRECISION

           <u>DN2</u>

                     DN2 is DOUBLE PRECISION

           <u>G</u>

                     G is DOUBLE PRECISION

           <u>TAU</u>

                     TAU is DOUBLE PRECISION

                    These are passed as arguments in order to save their values
                    between calls to DLASQ3.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlasq4</b> <b>(integer</b> <b>I0,</b> <b>integer</b> <b>N0,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>PP,</b> <b>integer</b> <b>N0IN,</b>
       <b>double</b> <b>precision</b> <b>DMIN,</b> <b>double</b> <b>precision</b> <b>DMIN1,</b> <b>double</b> <b>precision</b> <b>DMIN2,</b> <b>double</b> <b>precision</b> <b>DN,</b> <b>double</b>
       <b>precision</b> <b>DN1,</b> <b>double</b> <b>precision</b> <b>DN2,</b> <b>double</b> <b>precision</b> <b>TAU,</b> <b>integer</b> <b>TTYPE,</b> <b>double</b> <b>precision</b> <b>G)</b>
       <b>DLASQ4</b> computes an approximation to the smallest eigenvalue using values of d from the previous
       transform. Used by sbdsqr.

       <b>Purpose:</b>

            DLASQ4 computes an approximation TAU to the smallest eigenvalue
            using values of d from the previous transform.

       <b>Parameters</b>
           <u>I0</u>

                     I0 is INTEGER
                   First index.

           <u>N0</u>

                     N0 is INTEGER
                   Last index.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension ( 4*N0 )
                   Z holds the qd array.

           <u>PP</u>

                     PP is INTEGER
                   PP=0 for ping, PP=1 for pong.

           <u>N0IN</u>

                     N0IN is INTEGER
                   The value of N0 at start of EIGTEST.

           <u>DMIN</u>

                     DMIN is DOUBLE PRECISION
                   Minimum value of d.

           <u>DMIN1</u>

                     DMIN1 is DOUBLE PRECISION
                   Minimum value of d, excluding D( N0 ).

           <u>DMIN2</u>

                     DMIN2 is DOUBLE PRECISION
                   Minimum value of d, excluding D( N0 ) and D( N0-1 ).

           <u>DN</u>

                     DN is DOUBLE PRECISION
                   d(N)

           <u>DN1</u>

                     DN1 is DOUBLE PRECISION
                   d(N-1)

           <u>DN2</u>

                     DN2 is DOUBLE PRECISION
                   d(N-2)

           <u>TAU</u>

                     TAU is DOUBLE PRECISION
                   This is the shift.

           <u>TTYPE</u>

                     TTYPE is INTEGER
                   Shift type.

           <u>G</u>

                     G is DOUBLE PRECISION
                   G is passed as an argument in order to save its value between
                   calls to DLASQ4.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             CNST1 = 9/16

   <b>subroutine</b> <b>dlasq5</b> <b>(integer</b> <b>I0,</b> <b>integer</b> <b>N0,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>PP,</b> <b>double</b> <b>precision</b>
       <b>TAU,</b> <b>double</b> <b>precision</b> <b>SIGMA,</b> <b>double</b> <b>precision</b> <b>DMIN,</b> <b>double</b> <b>precision</b> <b>DMIN1,</b> <b>double</b> <b>precision</b> <b>DMIN2,</b>
       <b>double</b> <b>precision</b> <b>DN,</b> <b>double</b> <b>precision</b> <b>DNM1,</b> <b>double</b> <b>precision</b> <b>DNM2,</b> <b>logical</b> <b>IEEE,</b> <b>double</b> <b>precision</b> <b>EPS)</b>
       <b>DLASQ5</b> computes one dqds transform in ping-pong form. Used by sbdsqr and sstegr.

       <b>Purpose:</b>

            DLASQ5 computes one dqds transform in ping-pong form, one
            version for IEEE machines another for non IEEE machines.

       <b>Parameters</b>
           <u>I0</u>

                     I0 is INTEGER
                   First index.

           <u>N0</u>

                     N0 is INTEGER
                   Last index.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension ( 4*N )
                   Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
                   an extra argument.

           <u>PP</u>

                     PP is INTEGER
                   PP=0 for ping, PP=1 for pong.

           <u>TAU</u>

                     TAU is DOUBLE PRECISION
                   This is the shift.

           <u>SIGMA</u>

                     SIGMA is DOUBLE PRECISION
                   This is the accumulated shift up to this step.

           <u>DMIN</u>

                     DMIN is DOUBLE PRECISION
                   Minimum value of d.

           <u>DMIN1</u>

                     DMIN1 is DOUBLE PRECISION
                   Minimum value of d, excluding D( N0 ).

           <u>DMIN2</u>

                     DMIN2 is DOUBLE PRECISION
                   Minimum value of d, excluding D( N0 ) and D( N0-1 ).

           <u>DN</u>

                     DN is DOUBLE PRECISION
                   d(N0), the last value of d.

           <u>DNM1</u>

                     DNM1 is DOUBLE PRECISION
                   d(N0-1).

           <u>DNM2</u>

                     DNM2 is DOUBLE PRECISION
                   d(N0-2).

           <u>IEEE</u>

                     IEEE is LOGICAL
                   Flag for IEEE or non IEEE arithmetic.

           <u>EPS</u>

                     EPS is DOUBLE PRECISION
                   This is the value of epsilon used.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlasq6</b> <b>(integer</b> <b>I0,</b> <b>integer</b> <b>N0,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>PP,</b> <b>double</b> <b>precision</b>
       <b>DMIN,</b> <b>double</b> <b>precision</b> <b>DMIN1,</b> <b>double</b> <b>precision</b> <b>DMIN2,</b> <b>double</b> <b>precision</b> <b>DN,</b> <b>double</b> <b>precision</b> <b>DNM1,</b> <b>double</b>
       <b>precision</b> <b>DNM2)</b>
       <b>DLASQ6</b> computes one dqd transform in ping-pong form. Used by sbdsqr and sstegr.

       <b>Purpose:</b>

            DLASQ6 computes one dqd (shift equal to zero) transform in
            ping-pong form, with protection against underflow and overflow.

       <b>Parameters</b>
           <u>I0</u>

                     I0 is INTEGER
                   First index.

           <u>N0</u>

                     N0 is INTEGER
                   Last index.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension ( 4*N )
                   Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
                   an extra argument.

           <u>PP</u>

                     PP is INTEGER
                   PP=0 for ping, PP=1 for pong.

           <u>DMIN</u>

                     DMIN is DOUBLE PRECISION
                   Minimum value of d.

           <u>DMIN1</u>

                     DMIN1 is DOUBLE PRECISION
                   Minimum value of d, excluding D( N0 ).

           <u>DMIN2</u>

                     DMIN2 is DOUBLE PRECISION
                   Minimum value of d, excluding D( N0 ) and D( N0-1 ).

           <u>DN</u>

                     DN is DOUBLE PRECISION
                   d(N0), the last value of d.

           <u>DNM1</u>

                     DNM1 is DOUBLE PRECISION
                   d(N0-1).

           <u>DNM2</u>

                     DNM2 is DOUBLE PRECISION
                   d(N0-2).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dlasrt</b> <b>(character</b> <b>ID,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>integer</b> <b>INFO)</b>
       <b>DLASRT</b> sorts numbers in increasing or decreasing order.

       <b>Purpose:</b>

            Sort the numbers in D in increasing order (if ID = 'I') or
            in decreasing order (if ID = 'D' ).

            Use Quick Sort, reverting to Insertion sort on arrays of
            size &lt;= 20. Dimension of STACK limits N to about 2**32.

       <b>Parameters</b>
           <u>ID</u>

                     ID is CHARACTER*1
                     = 'I': sort D in increasing order;
                     = 'D': sort D in decreasing order.

           <u>N</u>

                     N is INTEGER
                     The length of the array D.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     On entry, the array to be sorted.
                     On exit, D has been sorted into increasing order
                     (<a href="../man1/D.1.html">D</a>(1) &lt;= ... &lt;= D(N) ) or into decreasing order
                     (<a href="../man1/D.1.html">D</a>(1) &gt;= ... &gt;= D(N) ), depending on ID.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dstebz</b> <b>(character</b> <b>RANGE,</b> <b>character</b> <b>ORDER,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision</b> <b>VL,</b> <b>double</b> <b>precision</b> <b>VU,</b>
       <b>integer</b> <b>IL,</b> <b>integer</b> <b>IU,</b> <b>double</b> <b>precision</b> <b>ABSTOL,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>NSPLIT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>IBLOCK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISPLIT,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DSTEBZ</b>

       <b>Purpose:</b>

            DSTEBZ computes the eigenvalues of a symmetric tridiagonal
            matrix T.  The user may ask for all eigenvalues, all eigenvalues
            in the half-open interval (VL, VU], or the IL-th through IU-th
            eigenvalues.

            To avoid overflow, the matrix must be scaled so that its
            largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
            accuracy, it should not be much smaller than that.

            See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
            Matrix", Report CS41, Computer Science Dept., Stanford
            University, July 21, 1966.

       <b>Parameters</b>
           <u>RANGE</u>

                     RANGE is CHARACTER*1
                     = 'A': ("All")   all eigenvalues will be found.
                     = 'V': ("Value") all eigenvalues in the half-open interval
                                      (VL, VU] will be found.
                     = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
                                      entire matrix) will be found.

           <u>ORDER</u>

                     ORDER is CHARACTER*1
                     = 'B': ("By Block") the eigenvalues will be grouped by
                                         split-off block (see IBLOCK, ISPLIT) and
                                         ordered from smallest to largest within
                                         the block.
                     = 'E': ("Entire matrix")
                                         the eigenvalues for the entire matrix
                                         will be ordered from smallest to
                                         largest.

           <u>N</u>

                     N is INTEGER
                     The order of the tridiagonal matrix T.  N &gt;= 0.

           <u>VL</u>

                     VL is DOUBLE PRECISION

                     If RANGE='V', the lower bound of the interval to
                     be searched for eigenvalues.  Eigenvalues less than or equal
                     to VL, or greater than VU, will not be returned.  VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>VU</u>

                     VU is DOUBLE PRECISION

                     If RANGE='V', the upper bound of the interval to
                     be searched for eigenvalues.  Eigenvalues less than or equal
                     to VL, or greater than VU, will not be returned.  VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>IL</u>

                     IL is INTEGER

                     If RANGE='I', the index of the
                     smallest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>IU</u>

                     IU is INTEGER

                     If RANGE='I', the index of the
                     largest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>ABSTOL</u>

                     ABSTOL is DOUBLE PRECISION
                     The absolute tolerance for the eigenvalues.  An eigenvalue
                     (or cluster) is considered to be located if it has been
                     determined to lie in an interval whose width is ABSTOL or
                     less.  If ABSTOL is less than or equal to zero, then ULP*|T|
                     will be used, where |T| means the 1-norm of T.

                     Eigenvalues will be computed most accurately when ABSTOL is
                     set to twice the underflow threshold 2*DLAMCH('S'), not zero.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     The n diagonal elements of the tridiagonal matrix T.

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (N-1)
                     The (n-1) off-diagonal elements of the tridiagonal matrix T.

           <u>M</u>

                     M is INTEGER
                     The actual number of eigenvalues found. 0 &lt;= M &lt;= N.
                     (See also the description of INFO=2,3.)

           <u>NSPLIT</u>

                     NSPLIT is INTEGER
                     The number of diagonal blocks in the matrix T.
                     1 &lt;= NSPLIT &lt;= N.

           <u>W</u>

                     W is DOUBLE PRECISION array, dimension (N)
                     On exit, the first M elements of W will contain the
                     eigenvalues.  (DSTEBZ may use the remaining N-M elements as
                     workspace.)

           <u>IBLOCK</u>

                     IBLOCK is INTEGER array, dimension (N)
                     At each row/column j where E(j) is zero or small, the
                     matrix T is considered to split into a block diagonal
                     matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which
                     block (from 1 to the number of blocks) the eigenvalue W(i)
                     belongs.  (DSTEBZ may use the remaining N-M elements as
                     workspace.)

           <u>ISPLIT</u>

                     ISPLIT is INTEGER array, dimension (N)
                     The splitting points, at which T breaks up into submatrices.
                     The first submatrix consists of rows/columns 1 to <a href="../man1/ISPLIT.1.html">ISPLIT</a>(1),
                     the second of rows/columns <a href="../man1/ISPLIT.1.html">ISPLIT</a>(1)+1 through <a href="../man2/ISPLIT.2.html">ISPLIT</a>(2),
                     etc., and the NSPLIT-th consists of rows/columns
                     ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
                     (Only the first NSPLIT elements will actually be used, but
                     since the user cannot know a priori what value NSPLIT will
                     have, N words must be reserved for ISPLIT.)

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (4*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (3*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  some or all of the eigenvalues failed to converge or
                           were not computed:
                           =1 or 3: Bisection failed to converge for some
                                   eigenvalues; these eigenvalues are flagged by a
                                   negative block number.  The effect is that the
                                   eigenvalues may not be as accurate as the
                                   absolute and relative tolerances.  This is
                                   generally caused by unexpectedly inaccurate
                                   arithmetic.
                           =2 or 3: RANGE='I' only: Not all of the eigenvalues
                                   IL:IU were found.
                                   Effect: M &lt; IU+1-IL
                                   Cause:  non-monotonic arithmetic, causing the
                                           Sturm sequence to be non-monotonic.
                                   Cure:   recalculate, using RANGE='A', and pick
                                           out eigenvalues IL:IU.  In some cases,
                                           increasing the PARAMETER "FUDGE" may
                                           make things work.
                           = 4:    RANGE='I', and the Gershgorin interval
                                   initially used was too small.  No eigenvalues
                                   were computed.
                                   Probable cause: your machine has sloppy
                                                   floating-point arithmetic.
                                   Cure: Increase the PARAMETER "FUDGE",
                                         recompile, and try again.

       <b>Internal</b> <b>Parameters:</b>

             RELFAC  DOUBLE PRECISION, default = 2.0e0
                     The relative tolerance.  An interval (a,b] lies within
                     "relative tolerance" if  b-a &lt; RELFAC*ulp*max(|a|,|b|),
                     where "ulp" is the machine precision (distance from 1 to
                     the next larger floating point number.)

             FUDGE   DOUBLE PRECISION, default = 2
                     A "fudge factor" to widen the Gershgorin intervals.  Ideally,
                     a value of 1 should work, but on machines with sloppy
                     arithmetic, this needs to be larger.  The default for
                     publicly released versions should be large enough to handle
                     the worst machine around.  Note that this has no effect
                     on accuracy of the solution.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dstedc</b> <b>(character</b> <b>COMPZ,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>LIWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DSTEDC</b>

       <b>Purpose:</b>

            DSTEDC computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the divide and conquer method.
            The eigenvectors of a full or band real symmetric matrix can also be
            found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
            matrix to tridiagonal form.

            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.  See DLAED3 for details.

       <b>Parameters</b>
           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only.
                     = 'I':  Compute eigenvectors of tridiagonal matrix also.
                     = 'V':  Compute eigenvectors of original dense symmetric
                             matrix also.  On entry, Z contains the orthogonal
                             matrix used to reduce the original matrix to
                             tridiagonal form.

           <u>N</u>

                     N is INTEGER
                     The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     On entry, the diagonal elements of the tridiagonal matrix.
                     On exit, if INFO = 0, the eigenvalues in ascending order.

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (N-1)
                     On entry, the subdiagonal elements of the tridiagonal matrix.
                     On exit, E has been destroyed.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ,N)
                     On entry, if COMPZ = 'V', then Z contains the orthogonal
                     matrix used in the reduction to tridiagonal form.
                     On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
                     orthonormal eigenvectors of the original symmetric matrix,
                     and if COMPZ = 'I', Z contains the orthonormal eigenvectors
                     of the symmetric tridiagonal matrix.
                     If  COMPZ = 'N', then Z is not referenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1.
                     If eigenvectors are desired, then LDZ &gt;= max(1,N).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If COMPZ = 'N' or N &lt;= 1 then LWORK must be at least 1.
                     If COMPZ = 'V' and N &gt; 1 then LWORK must be at least
                                    ( 1 + 3*N + 2*N*lg N + 4*N**2 ),
                                    where lg( N ) = smallest integer k such
                                    that 2**k &gt;= N.
                     If COMPZ = 'I' and N &gt; 1 then LWORK must be at least
                                    ( 1 + 4*N + N**2 ).
                     Note that for COMPZ = 'I' or 'V', then if N is less than or
                     equal to the minimum divide size, usually 25, then LWORK need
                     only be max(1,2*(N-1)).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(1,LIWORK))
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal LIWORK.

           <u>LIWORK</u>

                     LIWORK is INTEGER
                     The dimension of the array IWORK.
                     If COMPZ = 'N' or N &lt;= 1 then LIWORK must be at least 1.
                     If COMPZ = 'V' and N &gt; 1 then LIWORK must be at least
                                    ( 6 + 6*N + 5*N*lg N ).
                     If COMPZ = 'I' and N &gt; 1 then LIWORK must be at least
                                    ( 3 + 5*N ).
                     Note that for COMPZ = 'I' or 'V', then if N is less than or
                     equal to the minimum divide size, usually 25, then LIWORK
                     need only be 1.

                     If LIWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal size of the IWORK array,
                     returns this value as the first entry of the IWORK array, and
                     no error message related to LIWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  The algorithm failed to compute an eigenvalue while
                           working on the submatrix lying in rows and columns
                           INFO/(N+1) through mod(INFO,N+1).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA
            Modified by Francoise Tisseur, University of Tennessee

   <b>subroutine</b> <b>dsteqr</b> <b>(character</b> <b>COMPZ,</b> <b>integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DSTEQR</b>

       <b>Purpose:</b>

            DSTEQR computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the implicit QL or QR method.
            The eigenvectors of a full or band symmetric matrix can also be found
            if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
            tridiagonal form.

       <b>Parameters</b>
           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only.
                     = 'V':  Compute eigenvalues and eigenvectors of the original
                             symmetric matrix.  On entry, Z must contain the
                             orthogonal matrix used to reduce the original matrix
                             to tridiagonal form.
                     = 'I':  Compute eigenvalues and eigenvectors of the
                             tridiagonal matrix.  Z is initialized to the identity
                             matrix.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix.  N &gt;= 0.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     On entry, the diagonal elements of the tridiagonal matrix.
                     On exit, if INFO = 0, the eigenvalues in ascending order.

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (N-1)
                     On entry, the (n-1) subdiagonal elements of the tridiagonal
                     matrix.
                     On exit, E has been destroyed.

           <u>Z</u>

                     Z is DOUBLE PRECISION array, dimension (LDZ, N)
                     On entry, if  COMPZ = 'V', then Z contains the orthogonal
                     matrix used in the reduction to tridiagonal form.
                     On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
                     orthonormal eigenvectors of the original symmetric matrix,
                     and if COMPZ = 'I', Z contains the orthonormal eigenvectors
                     of the symmetric tridiagonal matrix.
                     If COMPZ = 'N', then Z is not referenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     eigenvectors are desired, then  LDZ &gt;= max(1,N).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (max(1,2*N-2))
                     If COMPZ = 'N', then WORK is not referenced.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  the algorithm has failed to find all the eigenvalues in
                           a total of 30*N iterations; if INFO = i, then i
                           elements of E have not converged to zero; on exit, D
                           and E contain the elements of a symmetric tridiagonal
                           matrix which is orthogonally similar to the original
                           matrix.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dsterf</b> <b>(integer</b> <b>N,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>integer</b>
       <b>INFO)</b>
       <b>DSTERF</b>

       <b>Purpose:</b>

            DSTERF computes all eigenvalues of a symmetric tridiagonal matrix
            using the Pal-Walker-Kahan variant of the QL or QR algorithm.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix.  N &gt;= 0.

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension (N)
                     On entry, the n diagonal elements of the tridiagonal matrix.
                     On exit, if INFO = 0, the eigenvalues in ascending order.

           <u>E</u>

                     E is DOUBLE PRECISION array, dimension (N-1)
                     On entry, the (n-1) subdiagonal elements of the tridiagonal
                     matrix.
                     On exit, E has been destroyed.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  the algorithm failed to find all of the eigenvalues in
                           a total of 30*N iterations; if INFO = i, then i
                           elements of E have not converged to zero.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>integer</b> <b>function</b> <b>iladiag</b> <b>(character</b> <b>DIAG)</b>
       <b>ILADIAG</b>

       <b>Purpose:</b>

            This subroutine translated from a character string specifying if a
            matrix has unit diagonal or not to the relevant BLAST-specified
            integer constant.

            ILADIAG returns an INTEGER.  If ILADIAG &lt; 0, then the input is not a
            character indicating a unit or non-unit diagonal.  Otherwise ILADIAG
            returns the constant value corresponding to DIAG.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>integer</b> <b>function</b> <b>ilaprec</b> <b>(character</b> <b>PREC)</b>
       <b>ILAPREC</b>

       <b>Purpose:</b>

            This subroutine translated from a character string specifying an
            intermediate precision to the relevant BLAST-specified integer
            constant.

            ILAPREC returns an INTEGER.  If ILAPREC &lt; 0, then the input is not a
            character indicating a supported intermediate precision.  Otherwise
            ILAPREC returns the constant value corresponding to PREC.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>integer</b> <b>function</b> <b>ilatrans</b> <b>(character</b> <b>TRANS)</b>
       <b>ILATRANS</b>

       <b>Purpose:</b>

            This subroutine translates from a character string specifying a
            transposition operation to the relevant BLAST-specified integer
            constant.

            ILATRANS returns an INTEGER.  If ILATRANS &lt; 0, then the input is not
            a character indicating a transposition operator.  Otherwise ILATRANS
            returns the constant value corresponding to TRANS.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>integer</b> <b>function</b> <b>ilauplo</b> <b>(character</b> <b>UPLO)</b>
       <b>ILAUPLO</b>

       <b>Purpose:</b>

            This subroutine translated from a character string specifying a
            upper- or lower-triangular matrix to the relevant BLAST-specified
            integer constant.

            ILAUPLO returns an INTEGER.  If ILAUPLO &lt; 0, then the input is not
            a character indicating an upper- or lower-triangular matrix.
            Otherwise ILAUPLO returns the constant value corresponding to UPLO.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>sbdsdc</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>COMPQ,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>E,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>real,</b> <b>dimension(</b> <b>ldvt,</b> <b>*</b> <b>)</b> <b>VT,</b> <b>integer</b> <b>LDVT,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IQ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b>
       <b>integer</b> <b>INFO)</b>
       <b>SBDSDC</b>

       <b>Purpose:</b>

            SBDSDC computes the singular value decomposition (SVD) of a real
            N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
            using a divide and conquer method, where S is a diagonal matrix
            with non-negative diagonal elements (the singular values of B), and
            U and VT are orthogonal matrices of left and right singular vectors,
            respectively. SBDSDC can be used to compute all singular values,
            and optionally, singular vectors or singular vectors in compact form.

            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.  See SLASD3 for details.

            The code currently calls SLASDQ if singular values only are desired.
            However, it can be slightly modified to compute singular values
            using the divide and conquer method.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  B is upper bidiagonal.
                     = 'L':  B is lower bidiagonal.

           <u>COMPQ</u>

                     COMPQ is CHARACTER*1
                     Specifies whether singular vectors are to be computed
                     as follows:
                     = 'N':  Compute singular values only;
                     = 'P':  Compute singular values and compute singular
                             vectors in compact form;
                     = 'I':  Compute singular values and singular vectors.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix B.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the n diagonal elements of the bidiagonal matrix B.
                     On exit, if INFO=0, the singular values of B.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     On entry, the elements of E contain the offdiagonal
                     elements of the bidiagonal matrix whose SVD is desired.
                     On exit, E has been destroyed.

           <u>U</u>

                     U is REAL array, dimension (LDU,N)
                     If  COMPQ = 'I', then:
                        On exit, if INFO = 0, U contains the left singular vectors
                        of the bidiagonal matrix.
                     For other values of COMPQ, U is not referenced.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U.  LDU &gt;= 1.
                     If singular vectors are desired, then LDU &gt;= max( 1, N ).

           <u>VT</u>

                     VT is REAL array, dimension (LDVT,N)
                     If  COMPQ = 'I', then:
                        On exit, if INFO = 0, VT**T contains the right singular
                        vectors of the bidiagonal matrix.
                     For other values of COMPQ, VT is not referenced.

           <u>LDVT</u>

                     LDVT is INTEGER
                     The leading dimension of the array VT.  LDVT &gt;= 1.
                     If singular vectors are desired, then LDVT &gt;= max( 1, N ).

           <u>Q</u>

                     Q is REAL array, dimension (LDQ)
                     If  COMPQ = 'P', then:
                        On exit, if INFO = 0, Q and IQ contain the left
                        and right singular vectors in a compact form,
                        requiring O(N log N) space instead of 2*N**2.
                        In particular, Q contains all the REAL data in
                        LDQ &gt;= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
                        words of memory, where SMLSIZ is returned by ILAENV and
                        is equal to the maximum size of the subproblems at the
                        bottom of the computation tree (usually about 25).
                     For other values of COMPQ, Q is not referenced.

           <u>IQ</u>

                     IQ is INTEGER array, dimension (LDIQ)
                     If  COMPQ = 'P', then:
                        On exit, if INFO = 0, Q and IQ contain the left
                        and right singular vectors in a compact form,
                        requiring O(N log N) space instead of 2*N**2.
                        In particular, IQ contains all INTEGER data in
                        LDIQ &gt;= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
                        words of memory, where SMLSIZ is returned by ILAENV and
                        is equal to the maximum size of the subproblems at the
                        bottom of the computation tree (usually about 25).
                     For other values of COMPQ, IQ is not referenced.

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK))
                     If COMPQ = 'N' then LWORK &gt;= (4 * N).
                     If COMPQ = 'P' then LWORK &gt;= (6 * N).
                     If COMPQ = 'I' then LWORK &gt;= (3 * N**2 + 4 * N).

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (8*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  The algorithm failed to compute a singular value.
                           The update process of divide and conquer failed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>sbdsqr</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NCVT,</b> <b>integer</b> <b>NRU,</b> <b>integer</b> <b>NCC,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>real,</b> <b>dimension(</b> <b>ldvt,</b> <b>*</b> <b>)</b> <b>VT,</b> <b>integer</b> <b>LDVT,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b>
       <b>LDU,</b> <b>real,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>SBDSQR</b>

       <b>Purpose:</b>

            SBDSQR computes the singular values and, optionally, the right and/or
            left singular vectors from the singular value decomposition (SVD) of
            a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
            zero-shift QR algorithm.  The SVD of B has the form

               B = Q * S * P**T

            where S is the diagonal matrix of singular values, Q is an orthogonal
            matrix of left singular vectors, and P is an orthogonal matrix of
            right singular vectors.  If left singular vectors are requested, this
            subroutine actually returns U*Q instead of Q, and, if right singular
            vectors are requested, this subroutine returns P**T*VT instead of
            P**T, for given real input matrices U and VT.  When U and VT are the
            orthogonal matrices that reduce a general matrix A to bidiagonal
            form:  A = U*B*VT, as computed by SGEBRD, then

               A = (U*Q) * S * (P**T*VT)

            is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
            for a given real input matrix C.

            See "Computing  Small Singular Values of Bidiagonal Matrices With
            Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
            LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
            no. 5, pp. 873-912, Sept 1990) and
            "Accurate singular values and differential qd algorithms," by
            B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
            Department, University of California at Berkeley, July 1992
            for a detailed description of the algorithm.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  B is upper bidiagonal;
                     = 'L':  B is lower bidiagonal.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix B.  N &gt;= 0.

           <u>NCVT</u>

                     NCVT is INTEGER
                     The number of columns of the matrix VT. NCVT &gt;= 0.

           <u>NRU</u>

                     NRU is INTEGER
                     The number of rows of the matrix U. NRU &gt;= 0.

           <u>NCC</u>

                     NCC is INTEGER
                     The number of columns of the matrix C. NCC &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the n diagonal elements of the bidiagonal matrix B.
                     On exit, if INFO=0, the singular values of B in decreasing
                     order.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     On entry, the N-1 offdiagonal elements of the bidiagonal
                     matrix B.
                     On exit, if INFO = 0, E is destroyed; if INFO &gt; 0, D and E
                     will contain the diagonal and superdiagonal elements of a
                     bidiagonal matrix orthogonally equivalent to the one given
                     as input.

           <u>VT</u>

                     VT is REAL array, dimension (LDVT, NCVT)
                     On entry, an N-by-NCVT matrix VT.
                     On exit, VT is overwritten by P**T * VT.
                     Not referenced if NCVT = 0.

           <u>LDVT</u>

                     LDVT is INTEGER
                     The leading dimension of the array VT.
                     LDVT &gt;= max(1,N) if NCVT &gt; 0; LDVT &gt;= 1 if NCVT = 0.

           <u>U</u>

                     U is REAL array, dimension (LDU, N)
                     On entry, an NRU-by-N matrix U.
                     On exit, U is overwritten by U * Q.
                     Not referenced if NRU = 0.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U.  LDU &gt;= max(1,NRU).

           <u>C</u>

                     C is REAL array, dimension (LDC, NCC)
                     On entry, an N-by-NCC matrix C.
                     On exit, C is overwritten by Q**T * C.
                     Not referenced if NCC = 0.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C.
                     LDC &gt;= max(1,N) if NCC &gt; 0; LDC &gt;=1 if NCC = 0.

           <u>WORK</u>

                     WORK is REAL array, dimension (4*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  If INFO = -i, the i-th argument had an illegal value
                     &gt; 0:
                        if NCVT = NRU = NCC = 0,
                           = 1, a split was marked by a positive value in E
                           = 2, current block of Z not diagonalized after 30*N
                                iterations (in inner while loop)
                           = 3, termination criterion of outer while loop not met
                                (program created more than N unreduced blocks)
                        else NCVT = NRU = NCC = 0,
                              the algorithm did not converge; D and E contain the
                              elements of a bidiagonal matrix which is orthogonally
                              similar to the input matrix B;  if INFO = i, i
                              elements of E have not converged to zero.

       <b>Internal</b> <b>Parameters:</b>

             TOLMUL  REAL, default = max(10,min(100,EPS**(-1/8)))
                     TOLMUL controls the convergence criterion of the QR loop.
                     If it is positive, TOLMUL*EPS is the desired relative
                        precision in the computed singular values.
                     If it is negative, abs(TOLMUL*EPS*sigma_max) is the
                        desired absolute accuracy in the computed singular
                        values (corresponds to relative accuracy
                        abs(TOLMUL*EPS) in the largest singular value.
                     abs(TOLMUL) should be between 1 and 1/EPS, and preferably
                        between 10 (for fast convergence) and .1/EPS
                        (for there to be some accuracy in the results).
                     Default is to lose at either one eighth or 2 of the
                        available decimal digits in each computed singular value
                        (whichever is smaller).

             MAXITR  INTEGER, default = 6
                     MAXITR controls the maximum number of passes of the
                     algorithm through its inner loop. The algorithms stops
                     (and so fails to converge) if the number of passes
                     through the inner loop exceeds MAXITR*N**2.

       <b>Note:</b>

             Bug report from Cezary Dendek.
             On March 23rd 2017, the INTEGER variable MAXIT = MAXITR*N**2 is
             removed since it can overflow pretty easily (for N larger or equal
             than 18,919). We instead use MAXITDIVN = MAXITR*N.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>sdisna</b> <b>(character</b> <b>JOB,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SEP,</b>
       <b>integer</b> <b>INFO)</b>
       <b>SDISNA</b>

       <b>Purpose:</b>

            SDISNA computes the reciprocal condition numbers for the eigenvectors
            of a real symmetric or complex Hermitian matrix or for the left or
            right singular vectors of a general m-by-n matrix. The reciprocal
            condition number is the 'gap' between the corresponding eigenvalue or
            singular value and the nearest other one.

            The bound on the error, measured by angle in radians, in the I-th
            computed vector is given by

                   SLAMCH( 'E' ) * ( ANORM / SEP( I ) )

            where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
            to be smaller than SLAMCH( 'E' )*ANORM in order to limit the size of
            the error bound.

            SDISNA may also be used to compute error bounds for eigenvectors of
            the generalized symmetric definite eigenproblem.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                     Specifies for which problem the reciprocal condition numbers
                     should be computed:
                     = 'E':  the eigenvectors of a symmetric/Hermitian matrix;
                     = 'L':  the left singular vectors of a general matrix;
                     = 'R':  the right singular vectors of a general matrix.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     If JOB = 'L' or 'R', the number of columns of the matrix,
                     in which case N &gt;= 0. Ignored if JOB = 'E'.

           <u>D</u>

                     D is REAL array, dimension (M) if JOB = 'E'
                                         dimension (min(M,N)) if JOB = 'L' or 'R'
                     The eigenvalues (if JOB = 'E') or singular values (if JOB =
                     'L' or 'R') of the matrix, in either increasing or decreasing
                     order. If singular values, they must be non-negative.

           <u>SEP</u>

                     SEP is REAL array, dimension (M) if JOB = 'E'
                                          dimension (min(M,N)) if JOB = 'L' or 'R'
                     The reciprocal condition numbers of the vectors.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slaed0</b> <b>(integer</b> <b>ICOMPQ,</b> <b>integer</b> <b>QSIZ,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b>
       <b>real,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>real,</b> <b>dimension(</b> <b>ldqs,</b> <b>*</b> <b>)</b> <b>QSTORE,</b> <b>integer</b> <b>LDQS,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAED0</b> used by SSTEDC. Computes all eigenvalues and corresponding eigenvectors of an unreduced symmetric
       tridiagonal matrix using the divide and conquer method.

       <b>Purpose:</b>

            SLAED0 computes all eigenvalues and corresponding eigenvectors of a
            symmetric tridiagonal matrix using the divide and conquer method.

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                     = 0:  Compute eigenvalues only.
                     = 1:  Compute eigenvectors of original dense symmetric matrix
                           also.  On entry, Q contains the orthogonal matrix used
                           to reduce the original matrix to tridiagonal form.
                     = 2:  Compute eigenvalues and eigenvectors of tridiagonal
                           matrix.

           <u>QSIZ</u>

                     QSIZ is INTEGER
                    The dimension of the orthogonal matrix used to reduce
                    the full matrix to tridiagonal form.  QSIZ &gt;= N if ICOMPQ = 1.

           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                    On entry, the main diagonal of the tridiagonal matrix.
                    On exit, its eigenvalues.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                    The off-diagonal elements of the tridiagonal matrix.
                    On exit, E has been destroyed.

           <u>Q</u>

                     Q is REAL array, dimension (LDQ, N)
                    On entry, Q must contain an N-by-N orthogonal matrix.
                    If ICOMPQ = 0    Q is not referenced.
                    If ICOMPQ = 1    On entry, Q is a subset of the columns of the
                                     orthogonal matrix used to reduce the full
                                     matrix to tridiagonal form corresponding to
                                     the subset of the full matrix which is being
                                     decomposed at this time.
                    If ICOMPQ = 2    On entry, Q will be the identity matrix.
                                     On exit, Q contains the eigenvectors of the
                                     tridiagonal matrix.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  If eigenvectors are
                    desired, then  LDQ &gt;= max(1,N).  In any case,  LDQ &gt;= 1.

           <u>QSTORE</u>

                     QSTORE is REAL array, dimension (LDQS, N)
                    Referenced only when ICOMPQ = 1.  Used to store parts of
                    the eigenvector matrix when the updating matrix multiplies
                    take place.

           <u>LDQS</u>

                     LDQS is INTEGER
                    The leading dimension of the array QSTORE.  If ICOMPQ = 1,
                    then  LDQS &gt;= max(1,N).  In any case,  LDQS &gt;= 1.

           <u>WORK</u>

                     WORK is REAL array,
                    If ICOMPQ = 0 or 1, the dimension of WORK must be at least
                                1 + 3*N + 2*N*lg N + 3*N**2
                                ( lg( N ) = smallest integer k
                                            such that 2^k &gt;= N )
                    If ICOMPQ = 2, the dimension of WORK must be at least
                                4*N + N**2.

           <u>IWORK</u>

                     IWORK is INTEGER array,
                    If ICOMPQ = 0 or 1, the dimension of IWORK must be at least
                                   6 + 6*N + 5*N*lg N.
                                   ( lg( N ) = smallest integer k
                                               such that 2^k &gt;= N )
                    If ICOMPQ = 2, the dimension of IWORK must be at least
                                   3 + 5*N.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  The algorithm failed to compute an eigenvalue while
                           working on the submatrix lying in rows and columns
                           INFO/(N+1) through mod(INFO,N+1).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>slaed1</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXQ,</b> <b>real</b> <b>RHO,</b> <b>integer</b> <b>CUTPNT,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b>
       <b>integer</b> <b>INFO)</b>
       <b>SLAED1</b> used by SSTEDC. Computes the updated eigensystem of a diagonal matrix after modification by a
       rank-one symmetric matrix. Used when the original matrix is tridiagonal.

       <b>Purpose:</b>

            SLAED1 computes the updated eigensystem of a diagonal
            matrix after modification by a rank-one symmetric matrix.  This
            routine is used only for the eigenproblem which requires all
            eigenvalues and eigenvectors of a tridiagonal matrix.  SLAED7 handles
            the case in which eigenvalues only or eigenvalues and eigenvectors
            of a full symmetric matrix (which was reduced to tridiagonal form)
            are desired.

              T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)

               where Z = Q**T*u, u is a vector of length N with ones in the
               CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.

               The eigenvectors of the original matrix are stored in Q, and the
               eigenvalues are in D.  The algorithm consists of three stages:

                  The first stage consists of deflating the size of the problem
                  when there are multiple eigenvalues or if there is a zero in
                  the Z vector.  For each such occurrence the dimension of the
                  secular equation problem is reduced by one.  This stage is
                  performed by the routine SLAED2.

                  The second stage consists of calculating the updated
                  eigenvalues. This is done by finding the roots of the secular
                  equation via the routine SLAED4 (as called by SLAED3).
                  This routine also calculates the eigenvectors of the current
                  problem.

                  The final stage consists of computing the updated eigenvectors
                  directly using the updated eigenvalues.  The eigenvectors for
                  the current problem are multiplied with the eigenvectors from
                  the overall problem.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                    On entry, the eigenvalues of the rank-1-perturbed matrix.
                    On exit, the eigenvalues of the repaired matrix.

           <u>Q</u>

                     Q is REAL array, dimension (LDQ,N)
                    On entry, the eigenvectors of the rank-1-perturbed matrix.
                    On exit, the eigenvectors of the repaired tridiagonal matrix.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>INDXQ</u>

                     INDXQ is INTEGER array, dimension (N)
                    On entry, the permutation which separately sorts the two
                    subproblems in D into ascending order.
                    On exit, the permutation which will reintegrate the
                    subproblems back into sorted order,
                    i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.

           <u>RHO</u>

                     RHO is REAL
                    The subdiagonal entry used to create the rank-1 modification.

           <u>CUTPNT</u>

                     CUTPNT is INTEGER
                    The location of the last eigenvalue in the leading sub-matrix.
                    min(1,N) &lt;= CUTPNT &lt;= N/2.

           <u>WORK</u>

                     WORK is REAL array, dimension (4*N + N**2)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (4*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if INFO = 1, an eigenvalue did not converge

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA
            Modified by Francoise Tisseur, University of Tennessee

   <b>subroutine</b> <b>slaed2</b> <b>(integer</b> <b>K,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>N1,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b>
       <b>integer</b> <b>LDQ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXQ,</b> <b>real</b> <b>RHO,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>DLAMDA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Q2,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDX,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXC,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>COLTYP,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAED2</b> used by SSTEDC. Merges eigenvalues and deflates secular equation. Used when the original matrix is
       tridiagonal.

       <b>Purpose:</b>

            SLAED2 merges the two sets of eigenvalues together into a single
            sorted set.  Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            eigenvalues are close together or if there is a tiny entry in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.

       <b>Parameters</b>
           <u>K</u>

                     K is INTEGER
                    The number of non-deflated eigenvalues, and the order of the
                    related secular equation. 0 &lt;= K &lt;=N.

           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>N1</u>

                     N1 is INTEGER
                    The location of the last eigenvalue in the leading sub-matrix.
                    min(1,N) &lt;= N1 &lt;= N/2.

           <u>D</u>

                     D is REAL array, dimension (N)
                    On entry, D contains the eigenvalues of the two submatrices to
                    be combined.
                    On exit, D contains the trailing (N-K) updated eigenvalues
                    (those which were deflated) sorted into increasing order.

           <u>Q</u>

                     Q is REAL array, dimension (LDQ, N)
                    On entry, Q contains the eigenvectors of two submatrices in
                    the two square blocks with corners at (1,1), (N1,N1)
                    and (N1+1, N1+1), (N,N).
                    On exit, Q contains the trailing (N-K) updated eigenvectors
                    (those which were deflated) in its last N-K columns.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>INDXQ</u>

                     INDXQ is INTEGER array, dimension (N)
                    The permutation which separately sorts the two sub-problems
                    in D into ascending order.  Note that elements in the second
                    half of this permutation must first have N1 added to their
                    values. Destroyed on exit.

           <u>RHO</u>

                     RHO is REAL
                    On entry, the off-diagonal element associated with the rank-1
                    cut which originally split the two submatrices which are now
                    being recombined.
                    On exit, RHO has been modified to the value required by
                    SLAED3.

           <u>Z</u>

                     Z is REAL array, dimension (N)
                    On entry, Z contains the updating vector (the last
                    row of the first sub-eigenvector matrix and the first row of
                    the second sub-eigenvector matrix).
                    On exit, the contents of Z have been destroyed by the updating
                    process.

           <u>DLAMDA</u>

                     DLAMDA is REAL array, dimension (N)
                    A copy of the first K eigenvalues which will be used by
                    SLAED3 to form the secular equation.

           <u>W</u>

                     W is REAL array, dimension (N)
                    The first k values of the final deflation-altered z-vector
                    which will be passed to SLAED3.

           <u>Q2</u>

                     Q2 is REAL array, dimension (N1**2+(N-N1)**2)
                    A copy of the first K eigenvectors which will be used by
                    SLAED3 in a matrix multiply (SGEMM) to solve for the new
                    eigenvectors.

           <u>INDX</u>

                     INDX is INTEGER array, dimension (N)
                    The permutation used to sort the contents of DLAMDA into
                    ascending order.

           <u>INDXC</u>

                     INDXC is INTEGER array, dimension (N)
                    The permutation used to arrange the columns of the deflated
                    Q matrix into three groups:  the first group contains non-zero
                    elements only at and above N1, the second contains
                    non-zero elements only below N1, and the third is dense.

           <u>INDXP</u>

                     INDXP is INTEGER array, dimension (N)
                    The permutation used to place deflated values of D at the end
                    of the array.  INDXP(1:K) points to the nondeflated D-values
                    and INDXP(K+1:N) points to the deflated eigenvalues.

           <u>COLTYP</u>

                     COLTYP is INTEGER array, dimension (N)
                    During execution, a label which will indicate which of the
                    following types a column in the Q2 matrix is:
                    1 : non-zero in the upper half only;
                    2 : dense;
                    3 : non-zero in the lower half only;
                    4 : deflated.
                    On exit, COLTYP(i) is the number of columns of type i,
                    for i=1 to 4 only.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA
            Modified by Francoise Tisseur, University of Tennessee

   <b>subroutine</b> <b>slaed3</b> <b>(integer</b> <b>K,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>N1,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b>
       <b>integer</b> <b>LDQ,</b> <b>real</b> <b>RHO,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DLAMDA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Q2,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>INDX,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CTOT,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAED3</b> used by SSTEDC. Finds the roots of the secular equation and updates the eigenvectors. Used when
       the original matrix is tridiagonal.

       <b>Purpose:</b>

            SLAED3 finds the roots of the secular equation, as defined by the
            values in D, W, and RHO, between 1 and K.  It makes the
            appropriate calls to SLAED4 and then updates the eigenvectors by
            multiplying the matrix of eigenvectors of the pair of eigensystems
            being combined by the matrix of eigenvectors of the K-by-K system
            which is solved here.

            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.

       <b>Parameters</b>
           <u>K</u>

                     K is INTEGER
                     The number of terms in the rational function to be solved by
                     SLAED4.  K &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of rows and columns in the Q matrix.
                     N &gt;= K (deflation may result in N&gt;K).

           <u>N1</u>

                     N1 is INTEGER
                     The location of the last eigenvalue in the leading submatrix.
                     min(1,N) &lt;= N1 &lt;= N/2.

           <u>D</u>

                     D is REAL array, dimension (N)
                     D(I) contains the updated eigenvalues for
                     1 &lt;= I &lt;= K.

           <u>Q</u>

                     Q is REAL array, dimension (LDQ,N)
                     Initially the first K columns are used as workspace.
                     On output the columns 1 to K contain
                     the updated eigenvectors.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>RHO</u>

                     RHO is REAL
                     The value of the parameter in the rank one update equation.
                     RHO &gt;= 0 required.

           <u>DLAMDA</u>

                     DLAMDA is REAL array, dimension (K)
                     The first K elements of this array contain the old roots
                     of the deflated updating problem.  These are the poles
                     of the secular equation. May be changed on output by
                     having lowest order bit set to zero on Cray X-MP, Cray Y-MP,
                     Cray-2, or Cray C-90, as described above.

           <u>Q2</u>

                     Q2 is REAL array, dimension (LDQ2*N)
                     The first K columns of this matrix contain the non-deflated
                     eigenvectors for the split problem.

           <u>INDX</u>

                     INDX is INTEGER array, dimension (N)
                     The permutation used to arrange the columns of the deflated
                     Q matrix into three groups (see SLAED2).
                     The rows of the eigenvectors found by SLAED4 must be likewise
                     permuted before the matrix multiply can take place.

           <u>CTOT</u>

                     CTOT is INTEGER array, dimension (4)
                     A count of the total number of the various types of columns
                     in Q, as described in INDX.  The fourth column type is any
                     column which has been deflated.

           <u>W</u>

                     W is REAL array, dimension (K)
                     The first K elements of this array contain the components
                     of the deflation-adjusted updating vector. Destroyed on
                     output.

           <u>S</u>

                     S is REAL array, dimension (N1 + 1)*K
                     Will contain the eigenvectors of the repaired matrix which
                     will be multiplied by the previously accumulated eigenvectors
                     to update the system.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if INFO = 1, an eigenvalue did not converge

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA
            Modified by Francoise Tisseur, University of Tennessee

   <b>subroutine</b> <b>slaed4</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>I,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>DELTA,</b> <b>real</b> <b>RHO,</b> <b>real</b> <b>DLAM,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAED4</b> used by SSTEDC. Finds a single root of the secular equation.

       <b>Purpose:</b>

            This subroutine computes the I-th updated eigenvalue of a symmetric
            rank-one modification to a diagonal matrix whose elements are
            given in the array d, and that

                       D(i) &lt; D(j)  for  i &lt; j

            and that RHO &gt; 0.  This is arranged by the calling routine, and is
            no loss in generality.  The rank-one modified system is thus

                       diag( D )  +  RHO * Z * Z_transpose.

            where we assume the Euclidean norm of Z is 1.

            The method consists of approximating the rational functions in the
            secular equation by simpler interpolating rational functions.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The length of all arrays.

           <u>I</u>

                     I is INTEGER
                    The index of the eigenvalue to be computed.  1 &lt;= I &lt;= N.

           <u>D</u>

                     D is REAL array, dimension (N)
                    The original eigenvalues.  It is assumed that they are in
                    order, D(I) &lt; D(J)  for I &lt; J.

           <u>Z</u>

                     Z is REAL array, dimension (N)
                    The components of the updating vector.

           <u>DELTA</u>

                     DELTA is REAL array, dimension (N)
                    If N &gt; 2, DELTA contains (D(j) - lambda_I) in its  j-th
                    component.  If N = 1, then <a href="../man1/DELTA.1.html">DELTA</a>(1) = 1. If N = 2, see SLAED5
                    for detail. The vector DELTA contains the information necessary
                    to construct the eigenvectors by SLAED3 and SLAED9.

           <u>RHO</u>

                     RHO is REAL
                    The scalar in the symmetric updating formula.

           <u>DLAM</u>

                     DLAM is REAL
                    The computed lambda_I, the I-th updated eigenvalue.

           <u>INFO</u>

                     INFO is INTEGER
                    = 0:  successful exit
                    &gt; 0:  if INFO = 1, the updating process failed.

       <b>Internal</b> <b>Parameters:</b>

             Logical variable ORGATI (origin-at-i?) is used for distinguishing
             whether D(i) or D(i+1) is treated as the origin.

                       ORGATI = .true.    origin at i
                       ORGATI = .false.   origin at i+1

              Logical variable SWTCH3 (switch-for-3-poles?) is for noting
              if we are working with THREE poles!

              MAXIT is the maximum number of iterations allowed for each
              eigenvalue.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>slaed5</b> <b>(integer</b> <b>I,</b> <b>real,</b> <b>dimension(</b> <b>2</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>2</b> <b>)</b> <b>Z,</b> <b>real,</b> <b>dimension(</b> <b>2</b> <b>)</b> <b>DELTA,</b>
       <b>real</b> <b>RHO,</b> <b>real</b> <b>DLAM)</b>
       <b>SLAED5</b> used by SSTEDC. Solves the 2-by-2 secular equation.

       <b>Purpose:</b>

            This subroutine computes the I-th eigenvalue of a symmetric rank-one
            modification of a 2-by-2 diagonal matrix

                       diag( D )  +  RHO * Z * transpose(Z) .

            The diagonal elements in the array D are assumed to satisfy

                       D(i) &lt; D(j)  for  i &lt; j .

            We also assume RHO &gt; 0 and that the Euclidean norm of the vector
            Z is one.

       <b>Parameters</b>
           <u>I</u>

                     I is INTEGER
                    The index of the eigenvalue to be computed.  I = 1 or I = 2.

           <u>D</u>

                     D is REAL array, dimension (2)
                    The original eigenvalues.  We assume <a href="../man1/D.1.html">D</a>(1) &lt; <a href="../man2/D.2.html">D</a>(2).

           <u>Z</u>

                     Z is REAL array, dimension (2)
                    The components of the updating vector.

           <u>DELTA</u>

                     DELTA is REAL array, dimension (2)
                    The vector DELTA contains the information necessary
                    to construct the eigenvectors.

           <u>RHO</u>

                     RHO is REAL
                    The scalar in the symmetric updating formula.

           <u>DLAM</u>

                     DLAM is REAL
                    The computed lambda_I, the I-th updated eigenvalue.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>slaed6</b> <b>(integer</b> <b>KNITER,</b> <b>logical</b> <b>ORGATI,</b> <b>real</b> <b>RHO,</b> <b>real,</b> <b>dimension(</b> <b>3</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>3</b> <b>)</b> <b>Z,</b>
       <b>real</b> <b>FINIT,</b> <b>real</b> <b>TAU,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAED6</b> used by SSTEDC. Computes one Newton step in solution of the secular equation.

       <b>Purpose:</b>

            SLAED6 computes the positive or negative root (closest to the origin)
            of
                             <a href="../man1/z.1.html">z</a>(1)        <a href="../man2/z.2.html">z</a>(2)        <a href="../man3/z.3.html">z</a>(3)
            f(x) =   rho + --------- + ---------- + ---------
                            <a href="../man1/d.1.html">d</a>(1)-x      <a href="../man2/d.2.html">d</a>(2)-x      <a href="../man3/d.3.html">d</a>(3)-x

            It is assumed that

                  if ORGATI = .true. the root is between <a href="../man2/d.2.html">d</a>(2) and <a href="../man3/d.3.html">d</a>(3);
                  otherwise it is between <a href="../man1/d.1.html">d</a>(1) and <a href="../man2/d.2.html">d</a>(2)

            This routine will be called by SLAED4 when necessary. In most cases,
            the root sought is the smallest in magnitude, though it might not be
            in some extremely rare situations.

       <b>Parameters</b>
           <u>KNITER</u>

                     KNITER is INTEGER
                          Refer to SLAED4 for its significance.

           <u>ORGATI</u>

                     ORGATI is LOGICAL
                          If ORGATI is true, the needed root is between <a href="../man2/d.2.html">d</a>(2) and
                          <a href="../man3/d.3.html">d</a>(3); otherwise it is between <a href="../man1/d.1.html">d</a>(1) and <a href="../man2/d.2.html">d</a>(2).  See
                          SLAED4 for further details.

           <u>RHO</u>

                     RHO is REAL
                          Refer to the equation f(x) above.

           <u>D</u>

                     D is REAL array, dimension (3)
                          D satisfies <a href="../man1/d.1.html">d</a>(1) &lt; <a href="../man2/d.2.html">d</a>(2) &lt; <a href="../man3/d.3.html">d</a>(3).

           <u>Z</u>

                     Z is REAL array, dimension (3)
                          Each of the elements in z must be positive.

           <u>FINIT</u>

                     FINIT is REAL
                          The value of f at 0. It is more accurate than the one
                          evaluated inside this routine (if someone wants to do
                          so).

           <u>TAU</u>

                     TAU is REAL
                          The root of the equation f(x).

           <u>INFO</u>

                     INFO is INTEGER
                          = 0: successful exit
                          &gt; 0: if INFO = 1, failure to converge

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             10/02/03: This version has a few statements commented out for thread
             safety (machine parameters are computed on each entry). SJH.

             05/10/06: Modified from a new version of Ren-Cang Li, use
                Gragg-Thornton-Warner cubic convergent scheme for better stability.

       <b>Contributors:</b>
           Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>slaed7</b> <b>(integer</b> <b>ICOMPQ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>QSIZ,</b> <b>integer</b> <b>TLVLS,</b> <b>integer</b> <b>CURLVL,</b> <b>integer</b> <b>CURPBM,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXQ,</b> <b>real</b>
       <b>RHO,</b> <b>integer</b> <b>CUTPNT,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>QSTORE,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>QPTR,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>PRMPTR,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PERM,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>GIVPTR,</b> <b>integer,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVCOL,</b>
       <b>real,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVNUM,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAED7</b> used by SSTEDC. Computes the updated eigensystem of a diagonal matrix after modification by a
       rank-one symmetric matrix. Used when the original matrix is dense.

       <b>Purpose:</b>

            SLAED7 computes the updated eigensystem of a diagonal
            matrix after modification by a rank-one symmetric matrix. This
            routine is used only for the eigenproblem which requires all
            eigenvalues and optionally eigenvectors of a dense symmetric matrix
            that has been reduced to tridiagonal form.  SLAED1 handles
            the case in which all eigenvalues and eigenvectors of a symmetric
            tridiagonal matrix are desired.

              T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)

               where Z = Q**Tu, u is a vector of length N with ones in the
               CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.

               The eigenvectors of the original matrix are stored in Q, and the
               eigenvalues are in D.  The algorithm consists of three stages:

                  The first stage consists of deflating the size of the problem
                  when there are multiple eigenvalues or if there is a zero in
                  the Z vector.  For each such occurrence the dimension of the
                  secular equation problem is reduced by one.  This stage is
                  performed by the routine SLAED8.

                  The second stage consists of calculating the updated
                  eigenvalues. This is done by finding the roots of the secular
                  equation via the routine SLAED4 (as called by SLAED9).
                  This routine also calculates the eigenvectors of the current
                  problem.

                  The final stage consists of computing the updated eigenvectors
                  directly using the updated eigenvalues.  The eigenvectors for
                  the current problem are multiplied with the eigenvectors from
                  the overall problem.

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                     = 0:  Compute eigenvalues only.
                     = 1:  Compute eigenvectors of original dense symmetric matrix
                           also.  On entry, Q contains the orthogonal matrix used
                           to reduce the original matrix to tridiagonal form.

           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>QSIZ</u>

                     QSIZ is INTEGER
                    The dimension of the orthogonal matrix used to reduce
                    the full matrix to tridiagonal form.  QSIZ &gt;= N if ICOMPQ = 1.

           <u>TLVLS</u>

                     TLVLS is INTEGER
                    The total number of merging levels in the overall divide and
                    conquer tree.

           <u>CURLVL</u>

                     CURLVL is INTEGER
                    The current level in the overall merge routine,
                    0 &lt;= CURLVL &lt;= TLVLS.

           <u>CURPBM</u>

                     CURPBM is INTEGER
                    The current problem in the current level in the overall
                    merge routine (counting from upper left to lower right).

           <u>D</u>

                     D is REAL array, dimension (N)
                    On entry, the eigenvalues of the rank-1-perturbed matrix.
                    On exit, the eigenvalues of the repaired matrix.

           <u>Q</u>

                     Q is REAL array, dimension (LDQ, N)
                    On entry, the eigenvectors of the rank-1-perturbed matrix.
                    On exit, the eigenvectors of the repaired tridiagonal matrix.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>INDXQ</u>

                     INDXQ is INTEGER array, dimension (N)
                    The permutation which will reintegrate the subproblem just
                    solved back into sorted order, i.e., D( INDXQ( I = 1, N ) )
                    will be in ascending order.

           <u>RHO</u>

                     RHO is REAL
                    The subdiagonal element used to create the rank-1
                    modification.

           <u>CUTPNT</u>

                     CUTPNT is INTEGER
                    Contains the location of the last eigenvalue in the leading
                    sub-matrix.  min(1,N) &lt;= CUTPNT &lt;= N.

           <u>QSTORE</u>

                     QSTORE is REAL array, dimension (N**2+1)
                    Stores eigenvectors of submatrices encountered during
                    divide and conquer, packed together. QPTR points to
                    beginning of the submatrices.

           <u>QPTR</u>

                     QPTR is INTEGER array, dimension (N+2)
                    List of indices pointing to beginning of submatrices stored
                    in QSTORE. The submatrices are numbered starting at the
                    bottom left of the divide and conquer tree, from left to
                    right and bottom to top.

           <u>PRMPTR</u>

                     PRMPTR is INTEGER array, dimension (N lg N)
                    Contains a list of pointers which indicate where in PERM a
                    level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
                    indicates the size of the permutation and also the size of
                    the full, non-deflated problem.

           <u>PERM</u>

                     PERM is INTEGER array, dimension (N lg N)
                    Contains the permutations (from deflation and sorting) to be
                    applied to each eigenblock.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER array, dimension (N lg N)
                    Contains a list of pointers which indicate where in GIVCOL a
                    level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
                    indicates the number of Givens rotations.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension (2, N lg N)
                    Each pair of numbers indicates a pair of columns to take place
                    in a Givens rotation.

           <u>GIVNUM</u>

                     GIVNUM is REAL array, dimension (2, N lg N)
                    Each number indicates the S value to be used in the
                    corresponding Givens rotation.

           <u>WORK</u>

                     WORK is REAL array, dimension (3*N+2*QSIZ*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (4*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if INFO = 1, an eigenvalue did not converge

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>slaed8</b> <b>(integer</b> <b>ICOMPQ,</b> <b>integer</b> <b>K,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>QSIZ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXQ,</b> <b>real</b> <b>RHO,</b> <b>integer</b> <b>CUTPNT,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DLAMDA,</b> <b>real,</b> <b>dimension(</b> <b>ldq2,</b> <b>*</b> <b>)</b> <b>Q2,</b> <b>integer</b> <b>LDQ2,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PERM,</b> <b>integer</b> <b>GIVPTR,</b> <b>integer,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVCOL,</b> <b>real,</b>
       <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVNUM,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDX,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAED8</b> used by SSTEDC. Merges eigenvalues and deflates secular equation. Used when the original matrix is
       dense.

       <b>Purpose:</b>

            SLAED8 merges the two sets of eigenvalues together into a single
            sorted set.  Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            eigenvalues are close together or if there is a tiny element in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                     = 0:  Compute eigenvalues only.
                     = 1:  Compute eigenvectors of original dense symmetric matrix
                           also.  On entry, Q contains the orthogonal matrix used
                           to reduce the original matrix to tridiagonal form.

           <u>K</u>

                     K is INTEGER
                    The number of non-deflated eigenvalues, and the order of the
                    related secular equation.

           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>QSIZ</u>

                     QSIZ is INTEGER
                    The dimension of the orthogonal matrix used to reduce
                    the full matrix to tridiagonal form.  QSIZ &gt;= N if ICOMPQ = 1.

           <u>D</u>

                     D is REAL array, dimension (N)
                    On entry, the eigenvalues of the two submatrices to be
                    combined.  On exit, the trailing (N-K) updated eigenvalues
                    (those which were deflated) sorted into increasing order.

           <u>Q</u>

                     Q is REAL array, dimension (LDQ,N)
                    If ICOMPQ = 0, Q is not referenced.  Otherwise,
                    on entry, Q contains the eigenvectors of the partially solved
                    system which has been previously updated in matrix
                    multiplies with other partially solved eigensystems.
                    On exit, Q contains the trailing (N-K) updated eigenvectors
                    (those which were deflated) in its last N-K columns.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>INDXQ</u>

                     INDXQ is INTEGER array, dimension (N)
                    The permutation which separately sorts the two sub-problems
                    in D into ascending order.  Note that elements in the second
                    half of this permutation must first have CUTPNT added to
                    their values in order to be accurate.

           <u>RHO</u>

                     RHO is REAL
                    On entry, the off-diagonal element associated with the rank-1
                    cut which originally split the two submatrices which are now
                    being recombined.
                    On exit, RHO has been modified to the value required by
                    SLAED3.

           <u>CUTPNT</u>

                     CUTPNT is INTEGER
                    The location of the last eigenvalue in the leading
                    sub-matrix.  min(1,N) &lt;= CUTPNT &lt;= N.

           <u>Z</u>

                     Z is REAL array, dimension (N)
                    On entry, Z contains the updating vector (the last row of
                    the first sub-eigenvector matrix and the first row of the
                    second sub-eigenvector matrix).
                    On exit, the contents of Z are destroyed by the updating
                    process.

           <u>DLAMDA</u>

                     DLAMDA is REAL array, dimension (N)
                    A copy of the first K eigenvalues which will be used by
                    SLAED3 to form the secular equation.

           <u>Q2</u>

                     Q2 is REAL array, dimension (LDQ2,N)
                    If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
                    a copy of the first K eigenvectors which will be used by
                    SLAED7 in a matrix multiply (SGEMM) to update the new
                    eigenvectors.

           <u>LDQ2</u>

                     LDQ2 is INTEGER
                    The leading dimension of the array Q2.  LDQ2 &gt;= max(1,N).

           <u>W</u>

                     W is REAL array, dimension (N)
                    The first k values of the final deflation-altered z-vector and
                    will be passed to SLAED3.

           <u>PERM</u>

                     PERM is INTEGER array, dimension (N)
                    The permutations (from deflation and sorting) to be applied
                    to each eigenblock.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER
                    The number of Givens rotations which took place in this
                    subproblem.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension (2, N)
                    Each pair of numbers indicates a pair of columns to take place
                    in a Givens rotation.

           <u>GIVNUM</u>

                     GIVNUM is REAL array, dimension (2, N)
                    Each number indicates the S value to be used in the
                    corresponding Givens rotation.

           <u>INDXP</u>

                     INDXP is INTEGER array, dimension (N)
                    The permutation used to place deflated values of D at the end
                    of the array.  INDXP(1:K) points to the nondeflated D-values
                    and INDXP(K+1:N) points to the deflated eigenvalues.

           <u>INDX</u>

                     INDX is INTEGER array, dimension (N)
                    The permutation used to sort the contents of D into ascending
                    order.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>slaed9</b> <b>(integer</b> <b>K,</b> <b>integer</b> <b>KSTART,</b> <b>integer</b> <b>KSTOP,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>real</b> <b>RHO,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DLAMDA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>real,</b>
       <b>dimension(</b> <b>lds,</b> <b>*</b> <b>)</b> <b>S,</b> <b>integer</b> <b>LDS,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAED9</b> used by SSTEDC. Finds the roots of the secular equation and updates the eigenvectors. Used when
       the original matrix is dense.

       <b>Purpose:</b>

            SLAED9 finds the roots of the secular equation, as defined by the
            values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
            appropriate calls to SLAED4 and then stores the new matrix of
            eigenvectors for use in calculating the next level of Z vectors.

       <b>Parameters</b>
           <u>K</u>

                     K is INTEGER
                     The number of terms in the rational function to be solved by
                     SLAED4.  K &gt;= 0.

           <u>KSTART</u>

                     KSTART is INTEGER

           <u>KSTOP</u>

                     KSTOP is INTEGER
                     The updated eigenvalues Lambda(I), KSTART &lt;= I &lt;= KSTOP
                     are to be computed.  1 &lt;= KSTART &lt;= KSTOP &lt;= K.

           <u>N</u>

                     N is INTEGER
                     The number of rows and columns in the Q matrix.
                     N &gt;= K (delation may result in N &gt; K).

           <u>D</u>

                     D is REAL array, dimension (N)
                     D(I) contains the updated eigenvalues
                     for KSTART &lt;= I &lt;= KSTOP.

           <u>Q</u>

                     Q is REAL array, dimension (LDQ,N)

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.  LDQ &gt;= max( 1, N ).

           <u>RHO</u>

                     RHO is REAL
                     The value of the parameter in the rank one update equation.
                     RHO &gt;= 0 required.

           <u>DLAMDA</u>

                     DLAMDA is REAL array, dimension (K)
                     The first K elements of this array contain the old roots
                     of the deflated updating problem.  These are the poles
                     of the secular equation.

           <u>W</u>

                     W is REAL array, dimension (K)
                     The first K elements of this array contain the components
                     of the deflation-adjusted updating vector.

           <u>S</u>

                     S is REAL array, dimension (LDS, K)
                     Will contain the eigenvectors of the repaired matrix which
                     will be stored for subsequent Z vector calculation and
                     multiplied by the previously accumulated eigenvectors
                     to update the system.

           <u>LDS</u>

                     LDS is INTEGER
                     The leading dimension of S.  LDS &gt;= max( 1, K ).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if INFO = 1, an eigenvalue did not converge

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>slaeda</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>TLVLS,</b> <b>integer</b> <b>CURLVL,</b> <b>integer</b> <b>CURPBM,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PRMPTR,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PERM,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>GIVPTR,</b> <b>integer,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVCOL,</b> <b>real,</b>
       <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVNUM,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>QPTR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ZTEMP,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAEDA</b> used by SSTEDC. Computes the Z vector determining the rank-one modification of the diagonal
       matrix. Used when the original matrix is dense.

       <b>Purpose:</b>

            SLAEDA computes the Z vector corresponding to the merge step in the
            CURLVLth step of the merge process with TLVLS steps for the CURPBMth
            problem.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>TLVLS</u>

                     TLVLS is INTEGER
                    The total number of merging levels in the overall divide and
                    conquer tree.

           <u>CURLVL</u>

                     CURLVL is INTEGER
                    The current level in the overall merge routine,
                    0 &lt;= curlvl &lt;= tlvls.

           <u>CURPBM</u>

                     CURPBM is INTEGER
                    The current problem in the current level in the overall
                    merge routine (counting from upper left to lower right).

           <u>PRMPTR</u>

                     PRMPTR is INTEGER array, dimension (N lg N)
                    Contains a list of pointers which indicate where in PERM a
                    level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
                    indicates the size of the permutation and incidentally the
                    size of the full, non-deflated problem.

           <u>PERM</u>

                     PERM is INTEGER array, dimension (N lg N)
                    Contains the permutations (from deflation and sorting) to be
                    applied to each eigenblock.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER array, dimension (N lg N)
                    Contains a list of pointers which indicate where in GIVCOL a
                    level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
                    indicates the number of Givens rotations.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension (2, N lg N)
                    Each pair of numbers indicates a pair of columns to take place
                    in a Givens rotation.

           <u>GIVNUM</u>

                     GIVNUM is REAL array, dimension (2, N lg N)
                    Each number indicates the S value to be used in the
                    corresponding Givens rotation.

           <u>Q</u>

                     Q is REAL array, dimension (N**2)
                    Contains the square eigenblocks from previous levels, the
                    starting positions for blocks are given by QPTR.

           <u>QPTR</u>

                     QPTR is INTEGER array, dimension (N+2)
                    Contains a list of pointers which indicate where in Q an
                    eigenblock is stored.  SQRT( QPTR(i+1) - QPTR(i) ) indicates
                    the size of the block.

           <u>Z</u>

                     Z is REAL array, dimension (N)
                    On output this vector contains the updating vector (the last
                    row of the first sub-eigenvector matrix and the first row of
                    the second sub-eigenvector matrix).

           <u>ZTEMP</u>

                     ZTEMP is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>slagtf</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>A,</b> <b>real</b> <b>LAMBDA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>B,</b> <b>real,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>C,</b> <b>real</b> <b>TOL,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IN,</b> <b>integer</b> <b>INFO)</b>
       <b>SLAGTF</b> computes an LU factorization of a matrix T-λI, where T is a general tridiagonal matrix, and λ a
       scalar, using partial pivoting with row interchanges.

       <b>Purpose:</b>

            SLAGTF factorizes the matrix (T - lambda*I), where T is an n by n
            tridiagonal matrix and lambda is a scalar, as

               T - lambda*I = PLU,

            where P is a permutation matrix, L is a unit lower tridiagonal matrix
            with at most one non-zero sub-diagonal elements per column and U is
            an upper triangular matrix with at most two non-zero super-diagonal
            elements per column.

            The factorization is obtained by Gaussian elimination with partial
            pivoting and implicit row scaling.

            The parameter LAMBDA is included in the routine so that SLAGTF may
            be used, in conjunction with SLAGTS, to obtain eigenvectors of T by
            inverse iteration.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix T.

           <u>A</u>

                     A is REAL array, dimension (N)
                     On entry, A must contain the diagonal elements of T.

                     On exit, A is overwritten by the n diagonal elements of the
                     upper triangular matrix U of the factorization of T.

           <u>LAMBDA</u>

                     LAMBDA is REAL
                     On entry, the scalar lambda.

           <u>B</u>

                     B is REAL array, dimension (N-1)
                     On entry, B must contain the (n-1) super-diagonal elements of
                     T.

                     On exit, B is overwritten by the (n-1) super-diagonal
                     elements of the matrix U of the factorization of T.

           <u>C</u>

                     C is REAL array, dimension (N-1)
                     On entry, C must contain the (n-1) sub-diagonal elements of
                     T.

                     On exit, C is overwritten by the (n-1) sub-diagonal elements
                     of the matrix L of the factorization of T.

           <u>TOL</u>

                     TOL is REAL
                     On entry, a relative tolerance used to indicate whether or
                     not the matrix (T - lambda*I) is nearly singular. TOL should
                     normally be chose as approximately the largest relative error
                     in the elements of T. For example, if the elements of T are
                     correct to about 4 significant figures, then TOL should be
                     set to about 5*10**(-4). If TOL is supplied as less than eps,
                     where eps is the relative machine precision, then the value
                     eps is used in place of TOL.

           <u>D</u>

                     D is REAL array, dimension (N-2)
                     On exit, D is overwritten by the (n-2) second super-diagonal
                     elements of the matrix U of the factorization of T.

           <u>IN</u>

                     IN is INTEGER array, dimension (N)
                     On exit, IN contains details of the permutation matrix P. If
                     an interchange occurred at the kth step of the elimination,
                     then IN(k) = 1, otherwise IN(k) = 0. The element IN(n)
                     returns the smallest positive integer j such that

                        abs( u(j,j) ) &lt;= norm( (T - lambda*I)(j) )*TOL,

                     where norm( A(j) ) denotes the sum of the absolute values of
                     the jth row of the matrix A. If no such j exists then IN(n)
                     is returned as zero. If IN(n) is returned as positive, then a
                     diagonal element of U is small, indicating that
                     (T - lambda*I) is singular or nearly singular,

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -k, the kth argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slamrg</b> <b>(integer</b> <b>N1,</b> <b>integer</b> <b>N2,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>STRD1,</b> <b>integer</b> <b>STRD2,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>INDEX)</b>
       <b>SLAMRG</b> creates a permutation list to merge the entries of two independently sorted sets into a single set
       sorted in ascending order.

       <b>Purpose:</b>

            SLAMRG will create a permutation list which will merge the elements
            of A (which is composed of two independently sorted sets) into a
            single set which is sorted in ascending order.

       <b>Parameters</b>
           <u>N1</u>

                     N1 is INTEGER

           <u>N2</u>

                     N2 is INTEGER
                    These arguments contain the respective lengths of the two
                    sorted lists to be merged.

           <u>A</u>

                     A is REAL array, dimension (N1+N2)
                    The first N1 elements of A contain a list of numbers which
                    are sorted in either ascending or descending order.  Likewise
                    for the final N2 elements.

           <u>STRD1</u>

                     STRD1 is INTEGER

           <u>STRD2</u>

                     STRD2 is INTEGER
                    These are the strides to be taken through the array A.
                    Allowable strides are 1 and -1.  They indicate whether a
                    subset of A is sorted in ascending (STRDx = 1) or descending
                    (STRDx = -1) order.

           <u>INDEX</u>

                     INDEX is INTEGER array, dimension (N1+N2)
                    On exit this array will contain a permutation such that
                    if B( I ) = A( INDEX( I ) ) for I=1,N1+N2, then B will be
                    sorted in ascending order.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slartgs</b> <b>(real</b> <b>X,</b> <b>real</b> <b>Y,</b> <b>real</b> <b>SIGMA,</b> <b>real</b> <b>CS,</b> <b>real</b> <b>SN)</b>
       <b>SLARTGS</b> generates a plane rotation designed to introduce a bulge in implicit QR iteration for the
       bidiagonal SVD problem.

       <b>Purpose:</b>

            SLARTGS generates a plane rotation designed to introduce a bulge in
            Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
            problem. X and Y are the top-row entries, and SIGMA is the shift.
            The computed CS and SN define a plane rotation satisfying

               [  CS  SN  ]  .  [ X^2 - SIGMA ]  =  [ R ],
               [ -SN  CS  ]     [    X * Y    ]     [ 0 ]

            with R nonnegative.  If X^2 - SIGMA and X * Y are 0, then the
            rotation is by PI/2.

       <b>Parameters</b>
           <u>X</u>

                     X is REAL
                     The (1,1) entry of an upper bidiagonal matrix.

           <u>Y</u>

                     Y is REAL
                     The (1,2) entry of an upper bidiagonal matrix.

           <u>SIGMA</u>

                     SIGMA is REAL
                     The shift.

           <u>CS</u>

                     CS is REAL
                     The cosine of the rotation.

           <u>SN</u>

                     SN is REAL
                     The sine of the rotation.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slasq1</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b>
       <b>integer</b> <b>INFO)</b>
       <b>SLASQ1</b> computes the singular values of a real square bidiagonal matrix. Used by sbdsqr.

       <b>Purpose:</b>

            SLASQ1 computes the singular values of a real N-by-N bidiagonal
            matrix with diagonal D and off-diagonal E. The singular values
            are computed to high relative accuracy, in the absence of
            denormalization, underflow and overflow. The algorithm was first
            presented in

            "Accurate singular values and differential qd algorithms" by K. V.
            Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
            1994,

            and the present implementation is described in "An implementation of
            the dqds Algorithm (Positive Case)", LAPACK Working Note.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                   The number of rows and columns in the matrix. N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                   On entry, D contains the diagonal elements of the
                   bidiagonal matrix whose SVD is desired. On normal exit,
                   D contains the singular values in decreasing order.

           <u>E</u>

                     E is REAL array, dimension (N)
                   On entry, elements E(1:N-1) contain the off-diagonal elements
                   of the bidiagonal matrix whose SVD is desired.
                   On exit, E is overwritten.

           <u>WORK</u>

                     WORK is REAL array, dimension (4*N)

           <u>INFO</u>

                     INFO is INTEGER
                   = 0: successful exit
                   &lt; 0: if INFO = -i, the i-th argument had an illegal value
                   &gt; 0: the algorithm failed
                        = 1, a split was marked by a positive value in E
                        = 2, current block of Z not diagonalized after 100*N
                             iterations (in inner while loop)  On exit D and E
                             represent a matrix with the same singular values
                             which the calling subroutine could use to finish the
                             computation, or even feed back into SLASQ1
                        = 3, termination criterion of outer while loop not met
                             (program created more than N unreduced blocks)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slasq2</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>INFO)</b>
       <b>SLASQ2</b> computes all the eigenvalues of the symmetric positive definite tridiagonal matrix associated with
       the qd Array Z to high relative accuracy. Used by sbdsqr and sstegr.

       <b>Purpose:</b>

            SLASQ2 computes all the eigenvalues of the symmetric positive
            definite tridiagonal matrix associated with the qd array Z to high
            relative accuracy are computed to high relative accuracy, in the
            absence of denormalization, underflow and overflow.

            To see the relation of Z to the tridiagonal matrix, let L be a
            unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
            let U be an upper bidiagonal matrix with 1's above and diagonal
            Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
            symmetric tridiagonal to which it is similar.

            Note : SLASQ2 defines a logical variable, IEEE, which is true
            on machines which follow ieee-754 floating-point standard in their
            handling of infinities and NaNs, and false otherwise. This variable
            is passed to SLASQ3.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                   The number of rows and columns in the matrix. N &gt;= 0.

           <u>Z</u>

                     Z is REAL array, dimension ( 4*N )
                   On entry Z holds the qd array. On exit, entries 1 to N hold
                   the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
                   trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
                   N &gt; 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
                   holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
                   shifts that failed.

           <u>INFO</u>

                     INFO is INTEGER
                   = 0: successful exit
                   &lt; 0: if the i-th argument is a scalar and had an illegal
                        value, then INFO = -i, if the i-th argument is an
                        array and the j-entry had an illegal value, then
                        INFO = -(i*100+j)
                   &gt; 0: the algorithm failed
                         = 1, a split was marked by a positive value in E
                         = 2, current block of Z not diagonalized after 100*N
                              iterations (in inner while loop).  On exit Z holds
                              a qd array with the same eigenvalues as the given Z.
                         = 3, termination criterion of outer while loop not met
                              (program created more than N unreduced blocks)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Local Variables: I0:N0 defines a current unreduced segment of Z.
             The shifts are accumulated in SIGMA. Iteration count is in ITER.
             Ping-pong is controlled by PP (alternates between 0 and 1).

   <b>subroutine</b> <b>slasq3</b> <b>(integer</b> <b>I0,</b> <b>integer</b> <b>N0,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>PP,</b> <b>real</b> <b>DMIN,</b> <b>real</b> <b>SIGMA,</b> <b>real</b>
       <b>DESIG,</b> <b>real</b> <b>QMAX,</b> <b>integer</b> <b>NFAIL,</b> <b>integer</b> <b>ITER,</b> <b>integer</b> <b>NDIV,</b> <b>logical</b> <b>IEEE,</b> <b>integer</b> <b>TTYPE,</b> <b>real</b> <b>DMIN1,</b>
       <b>real</b> <b>DMIN2,</b> <b>real</b> <b>DN,</b> <b>real</b> <b>DN1,</b> <b>real</b> <b>DN2,</b> <b>real</b> <b>G,</b> <b>real</b> <b>TAU)</b>
       <b>SLASQ3</b> checks for deflation, computes a shift and calls dqds. Used by sbdsqr.

       <b>Purpose:</b>

            SLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.
            In case of failure it changes shifts, and tries again until output
            is positive.

       <b>Parameters</b>
           <u>I0</u>

                     I0 is INTEGER
                    First index.

           <u>N0</u>

                     N0 is INTEGER
                    Last index.

           <u>Z</u>

                     Z is REAL array, dimension ( 4*N0 )
                    Z holds the qd array.

           <u>PP</u>

                     PP is INTEGER
                    PP=0 for ping, PP=1 for pong.
                    PP=2 indicates that flipping was applied to the Z array
                    and that the initial tests for deflation should not be
                    performed.

           <u>DMIN</u>

                     DMIN is REAL
                    Minimum value of d.

           <u>SIGMA</u>

                     SIGMA is REAL
                    Sum of shifts used in current segment.

           <u>DESIG</u>

                     DESIG is REAL
                    Lower order part of SIGMA

           <u>QMAX</u>

                     QMAX is REAL
                    Maximum value of q.

           <u>NFAIL</u>

                     NFAIL is INTEGER
                    Increment NFAIL by 1 each time the shift was too big.

           <u>ITER</u>

                     ITER is INTEGER
                    Increment ITER by 1 for each iteration.

           <u>NDIV</u>

                     NDIV is INTEGER
                    Increment NDIV by 1 for each division.

           <u>IEEE</u>

                     IEEE is LOGICAL
                    Flag for IEEE or non IEEE arithmetic (passed to SLASQ5).

           <u>TTYPE</u>

                     TTYPE is INTEGER
                    Shift type.

           <u>DMIN1</u>

                     DMIN1 is REAL

           <u>DMIN2</u>

                     DMIN2 is REAL

           <u>DN</u>

                     DN is REAL

           <u>DN1</u>

                     DN1 is REAL

           <u>DN2</u>

                     DN2 is REAL

           <u>G</u>

                     G is REAL

           <u>TAU</u>

                     TAU is REAL

                    These are passed as arguments in order to save their values
                    between calls to SLASQ3.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slasq4</b> <b>(integer</b> <b>I0,</b> <b>integer</b> <b>N0,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>PP,</b> <b>integer</b> <b>N0IN,</b> <b>real</b> <b>DMIN,</b> <b>real</b>
       <b>DMIN1,</b> <b>real</b> <b>DMIN2,</b> <b>real</b> <b>DN,</b> <b>real</b> <b>DN1,</b> <b>real</b> <b>DN2,</b> <b>real</b> <b>TAU,</b> <b>integer</b> <b>TTYPE,</b> <b>real</b> <b>G)</b>
       <b>SLASQ4</b> computes an approximation to the smallest eigenvalue using values of d from the previous
       transform. Used by sbdsqr.

       <b>Purpose:</b>

            SLASQ4 computes an approximation TAU to the smallest eigenvalue
            using values of d from the previous transform.

       <b>Parameters</b>
           <u>I0</u>

                     I0 is INTEGER
                   First index.

           <u>N0</u>

                     N0 is INTEGER
                   Last index.

           <u>Z</u>

                     Z is REAL array, dimension ( 4*N0 )
                   Z holds the qd array.

           <u>PP</u>

                     PP is INTEGER
                   PP=0 for ping, PP=1 for pong.

           <u>N0IN</u>

                     N0IN is INTEGER
                   The value of N0 at start of EIGTEST.

           <u>DMIN</u>

                     DMIN is REAL
                   Minimum value of d.

           <u>DMIN1</u>

                     DMIN1 is REAL
                   Minimum value of d, excluding D( N0 ).

           <u>DMIN2</u>

                     DMIN2 is REAL
                   Minimum value of d, excluding D( N0 ) and D( N0-1 ).

           <u>DN</u>

                     DN is REAL
                   d(N)

           <u>DN1</u>

                     DN1 is REAL
                   d(N-1)

           <u>DN2</u>

                     DN2 is REAL
                   d(N-2)

           <u>TAU</u>

                     TAU is REAL
                   This is the shift.

           <u>TTYPE</u>

                     TTYPE is INTEGER
                   Shift type.

           <u>G</u>

                     G is REAL
                   G is passed as an argument in order to save its value between
                   calls to SLASQ4.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             CNST1 = 9/16

   <b>subroutine</b> <b>slasq5</b> <b>(integer</b> <b>I0,</b> <b>integer</b> <b>N0,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>PP,</b> <b>real</b> <b>TAU,</b> <b>real</b> <b>SIGMA,</b> <b>real</b>
       <b>DMIN,</b> <b>real</b> <b>DMIN1,</b> <b>real</b> <b>DMIN2,</b> <b>real</b> <b>DN,</b> <b>real</b> <b>DNM1,</b> <b>real</b> <b>DNM2,</b> <b>logical</b> <b>IEEE,</b> <b>real</b> <b>EPS)</b>
        <b>SLASQ5</b> <b>computes</b> <b>one</b> <b>dqds</b> <b>transform</b> <b>in</b> <b>ping-pong</b> <b>form.</b> <b>Used</b> <b>by</b> <b>sbdsqr</b> <b>and</b> <b>sstegr.</b>

       <b>Purpose:</b>

            SLASQ5 computes one dqds transform in ping-pong form, one
            version for IEEE machines another for non IEEE machines.

       <b>Parameters</b>
           <u>I0</u>

                     I0 is INTEGER
                   First index.

           <u>N0</u>

                     N0 is INTEGER
                   Last index.

           <u>Z</u>

                     Z is REAL array, dimension ( 4*N )
                   Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
                   an extra argument.

           <u>PP</u>

                     PP is INTEGER
                   PP=0 for ping, PP=1 for pong.

           <u>TAU</u>

                     TAU is REAL
                   This is the shift.

           <u>SIGMA</u>

                     SIGMA is REAL
                   This is the accumulated shift up to this step.

           <u>DMIN</u>

                     DMIN is REAL
                   Minimum value of d.

           <u>DMIN1</u>

                     DMIN1 is REAL
                   Minimum value of d, excluding D( N0 ).

           <u>DMIN2</u>

                     DMIN2 is REAL
                   Minimum value of d, excluding D( N0 ) and D( N0-1 ).

           <u>DN</u>

                     DN is REAL
                   d(N0), the last value of d.

           <u>DNM1</u>

                     DNM1 is REAL
                   d(N0-1).

           <u>DNM2</u>

                     DNM2 is REAL
                   d(N0-2).

           <u>IEEE</u>

                     IEEE is LOGICAL
                   Flag for IEEE or non IEEE arithmetic.

           <u>EPS</u>

                    EPS is REAL
                   This is the value of epsilon used.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slasq6</b> <b>(integer</b> <b>I0,</b> <b>integer</b> <b>N0,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>PP,</b> <b>real</b> <b>DMIN,</b> <b>real</b> <b>DMIN1,</b> <b>real</b>
       <b>DMIN2,</b> <b>real</b> <b>DN,</b> <b>real</b> <b>DNM1,</b> <b>real</b> <b>DNM2)</b>
       <b>SLASQ6</b> computes one dqd transform in ping-pong form. Used by sbdsqr and sstegr.

       <b>Purpose:</b>

            SLASQ6 computes one dqd (shift equal to zero) transform in
            ping-pong form, with protection against underflow and overflow.

       <b>Parameters</b>
           <u>I0</u>

                     I0 is INTEGER
                   First index.

           <u>N0</u>

                     N0 is INTEGER
                   Last index.

           <u>Z</u>

                     Z is REAL array, dimension ( 4*N )
                   Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
                   an extra argument.

           <u>PP</u>

                     PP is INTEGER
                   PP=0 for ping, PP=1 for pong.

           <u>DMIN</u>

                     DMIN is REAL
                   Minimum value of d.

           <u>DMIN1</u>

                     DMIN1 is REAL
                   Minimum value of d, excluding D( N0 ).

           <u>DMIN2</u>

                     DMIN2 is REAL
                   Minimum value of d, excluding D( N0 ) and D( N0-1 ).

           <u>DN</u>

                     DN is REAL
                   d(N0), the last value of d.

           <u>DNM1</u>

                     DNM1 is REAL
                   d(N0-1).

           <u>DNM2</u>

                     DNM2 is REAL
                   d(N0-2).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>slasrt</b> <b>(character</b> <b>ID,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>integer</b> <b>INFO)</b>
       <b>SLASRT</b> sorts numbers in increasing or decreasing order.

       <b>Purpose:</b>

            Sort the numbers in D in increasing order (if ID = 'I') or
            in decreasing order (if ID = 'D' ).

            Use Quick Sort, reverting to Insertion sort on arrays of
            size &lt;= 20. Dimension of STACK limits N to about 2**32.

       <b>Parameters</b>
           <u>ID</u>

                     ID is CHARACTER*1
                     = 'I': sort D in increasing order;
                     = 'D': sort D in decreasing order.

           <u>N</u>

                     N is INTEGER
                     The length of the array D.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the array to be sorted.
                     On exit, D has been sorted into increasing order
                     (<a href="../man1/D.1.html">D</a>(1) &lt;= ... &lt;= D(N) ) or into decreasing order
                     (<a href="../man1/D.1.html">D</a>(1) &gt;= ... &gt;= D(N) ), depending on ID.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>spttrf</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>integer</b> <b>INFO)</b>
       <b>SPTTRF</b>

       <b>Purpose:</b>

            SPTTRF computes the L*D*L**T factorization of a real symmetric
            positive definite tridiagonal matrix A.  The factorization may also
            be regarded as having the form A = U**T*D*U.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the n diagonal elements of the tridiagonal matrix
                     A.  On exit, the n diagonal elements of the diagonal matrix
                     D from the L*D*L**T factorization of A.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     On entry, the (n-1) subdiagonal elements of the tridiagonal
                     matrix A.  On exit, the (n-1) subdiagonal elements of the
                     unit bidiagonal factor L from the L*D*L**T factorization of A.
                     E can also be regarded as the superdiagonal of the unit
                     bidiagonal factor U from the U**T*D*U factorization of A.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -k, the k-th argument had an illegal value
                     &gt; 0: if INFO = k, the leading minor of order k is not
                          positive definite; if k &lt; N, the factorization could not
                          be completed, while if k = N, the factorization was
                          completed, but D(N) &lt;= 0.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>sstebz</b> <b>(character</b> <b>RANGE,</b> <b>character</b> <b>ORDER,</b> <b>integer</b> <b>N,</b> <b>real</b> <b>VL,</b> <b>real</b> <b>VU,</b> <b>integer</b> <b>IL,</b> <b>integer</b> <b>IU,</b>
       <b>real</b> <b>ABSTOL,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>NSPLIT,</b> <b>real,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>W,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IBLOCK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISPLIT,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>SSTEBZ</b>

       <b>Purpose:</b>

            SSTEBZ computes the eigenvalues of a symmetric tridiagonal
            matrix T.  The user may ask for all eigenvalues, all eigenvalues
            in the half-open interval (VL, VU], or the IL-th through IU-th
            eigenvalues.

            To avoid overflow, the matrix must be scaled so that its
            largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
            accuracy, it should not be much smaller than that.

            See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
            Matrix", Report CS41, Computer Science Dept., Stanford
            University, July 21, 1966.

       <b>Parameters</b>
           <u>RANGE</u>

                     RANGE is CHARACTER*1
                     = 'A': ("All")   all eigenvalues will be found.
                     = 'V': ("Value") all eigenvalues in the half-open interval
                                      (VL, VU] will be found.
                     = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
                                      entire matrix) will be found.

           <u>ORDER</u>

                     ORDER is CHARACTER*1
                     = 'B': ("By Block") the eigenvalues will be grouped by
                                         split-off block (see IBLOCK, ISPLIT) and
                                         ordered from smallest to largest within
                                         the block.
                     = 'E': ("Entire matrix")
                                         the eigenvalues for the entire matrix
                                         will be ordered from smallest to
                                         largest.

           <u>N</u>

                     N is INTEGER
                     The order of the tridiagonal matrix T.  N &gt;= 0.

           <u>VL</u>

                     VL is REAL

                     If RANGE='V', the lower bound of the interval to
                     be searched for eigenvalues.  Eigenvalues less than or equal
                     to VL, or greater than VU, will not be returned.  VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>VU</u>

                     VU is REAL

                     If RANGE='V', the upper bound of the interval to
                     be searched for eigenvalues.  Eigenvalues less than or equal
                     to VL, or greater than VU, will not be returned.  VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>IL</u>

                     IL is INTEGER

                     If RANGE='I', the index of the
                     smallest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>IU</u>

                     IU is INTEGER

                     If RANGE='I', the index of the
                     largest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>ABSTOL</u>

                     ABSTOL is REAL
                     The absolute tolerance for the eigenvalues.  An eigenvalue
                     (or cluster) is considered to be located if it has been
                     determined to lie in an interval whose width is ABSTOL or
                     less.  If ABSTOL is less than or equal to zero, then ULP*|T|
                     will be used, where |T| means the 1-norm of T.

                     Eigenvalues will be computed most accurately when ABSTOL is
                     set to twice the underflow threshold 2*SLAMCH('S'), not zero.

           <u>D</u>

                     D is REAL array, dimension (N)
                     The n diagonal elements of the tridiagonal matrix T.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     The (n-1) off-diagonal elements of the tridiagonal matrix T.

           <u>M</u>

                     M is INTEGER
                     The actual number of eigenvalues found. 0 &lt;= M &lt;= N.
                     (See also the description of INFO=2,3.)

           <u>NSPLIT</u>

                     NSPLIT is INTEGER
                     The number of diagonal blocks in the matrix T.
                     1 &lt;= NSPLIT &lt;= N.

           <u>W</u>

                     W is REAL array, dimension (N)
                     On exit, the first M elements of W will contain the
                     eigenvalues.  (SSTEBZ may use the remaining N-M elements as
                     workspace.)

           <u>IBLOCK</u>

                     IBLOCK is INTEGER array, dimension (N)
                     At each row/column j where E(j) is zero or small, the
                     matrix T is considered to split into a block diagonal
                     matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which
                     block (from 1 to the number of blocks) the eigenvalue W(i)
                     belongs.  (SSTEBZ may use the remaining N-M elements as
                     workspace.)

           <u>ISPLIT</u>

                     ISPLIT is INTEGER array, dimension (N)
                     The splitting points, at which T breaks up into submatrices.
                     The first submatrix consists of rows/columns 1 to <a href="../man1/ISPLIT.1.html">ISPLIT</a>(1),
                     the second of rows/columns <a href="../man1/ISPLIT.1.html">ISPLIT</a>(1)+1 through <a href="../man2/ISPLIT.2.html">ISPLIT</a>(2),
                     etc., and the NSPLIT-th consists of rows/columns
                     ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
                     (Only the first NSPLIT elements will actually be used, but
                     since the user cannot know a priori what value NSPLIT will
                     have, N words must be reserved for ISPLIT.)

           <u>WORK</u>

                     WORK is REAL array, dimension (4*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (3*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  some or all of the eigenvalues failed to converge or
                           were not computed:
                           =1 or 3: Bisection failed to converge for some
                                   eigenvalues; these eigenvalues are flagged by a
                                   negative block number.  The effect is that the
                                   eigenvalues may not be as accurate as the
                                   absolute and relative tolerances.  This is
                                   generally caused by unexpectedly inaccurate
                                   arithmetic.
                           =2 or 3: RANGE='I' only: Not all of the eigenvalues
                                   IL:IU were found.
                                   Effect: M &lt; IU+1-IL
                                   Cause:  non-monotonic arithmetic, causing the
                                           Sturm sequence to be non-monotonic.
                                   Cure:   recalculate, using RANGE='A', and pick
                                           out eigenvalues IL:IU.  In some cases,
                                           increasing the PARAMETER "FUDGE" may
                                           make things work.
                           = 4:    RANGE='I', and the Gershgorin interval
                                   initially used was too small.  No eigenvalues
                                   were computed.
                                   Probable cause: your machine has sloppy
                                                   floating-point arithmetic.
                                   Cure: Increase the PARAMETER "FUDGE",
                                         recompile, and try again.

       <b>Internal</b> <b>Parameters:</b>

             RELFAC  REAL, default = 2.0e0
                     The relative tolerance.  An interval (a,b] lies within
                     "relative tolerance" if  b-a &lt; RELFAC*ulp*max(|a|,|b|),
                     where "ulp" is the machine precision (distance from 1 to
                     the next larger floating point number.)

             FUDGE   REAL, default = 2
                     A "fudge factor" to widen the Gershgorin intervals.  Ideally,
                     a value of 1 should work, but on machines with sloppy
                     arithmetic, this needs to be larger.  The default for
                     publicly released versions should be large enough to handle
                     the worst machine around.  Note that this has no effect
                     on accuracy of the solution.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>sstedc</b> <b>(character</b> <b>COMPZ,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>real,</b>
       <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>IWORK,</b> <b>integer</b> <b>LIWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>SSTEDC</b>

       <b>Purpose:</b>

            SSTEDC computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the divide and conquer method.
            The eigenvectors of a full or band real symmetric matrix can also be
            found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this
            matrix to tridiagonal form.

            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.  See SLAED3 for details.

       <b>Parameters</b>
           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only.
                     = 'I':  Compute eigenvectors of tridiagonal matrix also.
                     = 'V':  Compute eigenvectors of original dense symmetric
                             matrix also.  On entry, Z contains the orthogonal
                             matrix used to reduce the original matrix to
                             tridiagonal form.

           <u>N</u>

                     N is INTEGER
                     The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the diagonal elements of the tridiagonal matrix.
                     On exit, if INFO = 0, the eigenvalues in ascending order.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     On entry, the subdiagonal elements of the tridiagonal matrix.
                     On exit, E has been destroyed.

           <u>Z</u>

                     Z is REAL array, dimension (LDZ,N)
                     On entry, if COMPZ = 'V', then Z contains the orthogonal
                     matrix used in the reduction to tridiagonal form.
                     On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
                     orthonormal eigenvectors of the original symmetric matrix,
                     and if COMPZ = 'I', Z contains the orthonormal eigenvectors
                     of the symmetric tridiagonal matrix.
                     If  COMPZ = 'N', then Z is not referenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1.
                     If eigenvectors are desired, then LDZ &gt;= max(1,N).

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If COMPZ = 'N' or N &lt;= 1 then LWORK must be at least 1.
                     If COMPZ = 'V' and N &gt; 1 then LWORK must be at least
                                    ( 1 + 3*N + 2*N*lg N + 4*N**2 ),
                                    where lg( N ) = smallest integer k such
                                    that 2**k &gt;= N.
                     If COMPZ = 'I' and N &gt; 1 then LWORK must be at least
                                    ( 1 + 4*N + N**2 ).
                     Note that for COMPZ = 'I' or 'V', then if N is less than or
                     equal to the minimum divide size, usually 25, then LWORK need
                     only be max(1,2*(N-1)).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(1,LIWORK))
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal LIWORK.

           <u>LIWORK</u>

                     LIWORK is INTEGER
                     The dimension of the array IWORK.
                     If COMPZ = 'N' or N &lt;= 1 then LIWORK must be at least 1.
                     If COMPZ = 'V' and N &gt; 1 then LIWORK must be at least
                                    ( 6 + 6*N + 5*N*lg N ).
                     If COMPZ = 'I' and N &gt; 1 then LIWORK must be at least
                                    ( 3 + 5*N ).
                     Note that for COMPZ = 'I' or 'V', then if N is less than or
                     equal to the minimum divide size, usually 25, then LIWORK
                     need only be 1.

                     If LIWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal size of the IWORK array,
                     returns this value as the first entry of the IWORK array, and
                     no error message related to LIWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  The algorithm failed to compute an eigenvalue while
                           working on the submatrix lying in rows and columns
                           INFO/(N+1) through mod(INFO,N+1).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA
            Modified by Francoise Tisseur, University of Tennessee

   <b>subroutine</b> <b>ssteqr</b> <b>(character</b> <b>COMPZ,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>real,</b>
       <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>SSTEQR</b>

       <b>Purpose:</b>

            SSTEQR computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the implicit QL or QR method.
            The eigenvectors of a full or band symmetric matrix can also be found
            if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to
            tridiagonal form.

       <b>Parameters</b>
           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only.
                     = 'V':  Compute eigenvalues and eigenvectors of the original
                             symmetric matrix.  On entry, Z must contain the
                             orthogonal matrix used to reduce the original matrix
                             to tridiagonal form.
                     = 'I':  Compute eigenvalues and eigenvectors of the
                             tridiagonal matrix.  Z is initialized to the identity
                             matrix.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the diagonal elements of the tridiagonal matrix.
                     On exit, if INFO = 0, the eigenvalues in ascending order.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     On entry, the (n-1) subdiagonal elements of the tridiagonal
                     matrix.
                     On exit, E has been destroyed.

           <u>Z</u>

                     Z is REAL array, dimension (LDZ, N)
                     On entry, if  COMPZ = 'V', then Z contains the orthogonal
                     matrix used in the reduction to tridiagonal form.
                     On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
                     orthonormal eigenvectors of the original symmetric matrix,
                     and if COMPZ = 'I', Z contains the orthonormal eigenvectors
                     of the symmetric tridiagonal matrix.
                     If COMPZ = 'N', then Z is not referenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     eigenvectors are desired, then  LDZ &gt;= max(1,N).

           <u>WORK</u>

                     WORK is REAL array, dimension (max(1,2*N-2))
                     If COMPZ = 'N', then WORK is not referenced.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  the algorithm has failed to find all the eigenvalues in
                           a total of 30*N iterations; if INFO = i, then i
                           elements of E have not converged to zero; on exit, D
                           and E contain the elements of a symmetric tridiagonal
                           matrix which is orthogonally similar to the original
                           matrix.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ssterf</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>integer</b> <b>INFO)</b>
       <b>SSTERF</b>

       <b>Purpose:</b>

            SSTERF computes all eigenvalues of a symmetric tridiagonal matrix
            using the Pal-Walker-Kahan variant of the QL or QR algorithm.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the n diagonal elements of the tridiagonal matrix.
                     On exit, if INFO = 0, the eigenvalues in ascending order.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     On entry, the (n-1) subdiagonal elements of the tridiagonal
                     matrix.
                     On exit, E has been destroyed.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  the algorithm failed to find all of the eigenvalues in
                           a total of 30*N iterations; if INFO = i, then i
                           elements of E have not converged to zero.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.10.0                                   Wed Jan 12 2022                        <u><a href="../man3/auxOTHERcomputational.3.html">auxOTHERcomputational</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>