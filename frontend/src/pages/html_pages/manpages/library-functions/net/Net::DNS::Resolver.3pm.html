<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::DNS::Resolver - DNS resolver class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-dns-perl">libnet-dns-perl_1.50-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::DNS::Resolver - DNS resolver class

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Net::DNS;

               $resolver = Net::DNS::Resolver-&gt;new();

               # Perform a lookup, using the searchlist if appropriate.
               $reply = $resolver-&gt;search( 'example.com' );

               # Perform a lookup, without the searchlist
               $reply = $resolver-&gt;query( 'example.com', 'MX' );

               # Perform a lookup, without pre or post-processing
               $reply = $resolver-&gt;send( 'example.com', 'MX', 'IN' );

               # Send a prebuilt query packet
               $query = Net::DNS::Packet-&gt;new( ... );
               $reply = $resolver-&gt;send( $query );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Instances of the Net::DNS::Resolver class represent resolver objects.  A program may have multiple
       resolver objects, each maintaining its own state information such as the nameservers to be queried,
       whether recursion is desired, etc.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
               # Use the default configuration
               $resolver = Net::DNS::Resolver-&gt;new();

               # Use my own configuration file
               $resolver = Net::DNS::Resolver-&gt;new( config_file =&gt; '/my/dns.conf' );

               # Set options in the constructor
               $resolver = Net::DNS::Resolver-&gt;new(
                               nameservers =&gt; [ '2001:DB8::1', 'ns.example.com' ],
                               recurse     =&gt; 0,
                               debug       =&gt; 1
                               );

       Returns a resolver object.  If no arguments are supplied, new() returns an object having the default
       configuration.

       On Unix and Linux systems, the default values are read from the following files, in the order indicated:

           <u><a href="file:/etc/resolv.conf">/etc/resolv.conf</a></u>, <u>$HOME/.resolv.conf</u>, <u>./.resolv.conf</u>

       The following keywords are recognised in resolver configuration files:

       <b>nameserver</b>
           IP address of a name server that the resolver should query.

       <b>domain</b>
           The domain suffix to be appended to a short non-absolute name.

       <b>search</b>
           A space-separated list of domains in the desired search path.

       <b>options</b>
           A space-separated list of key:value items.

       Except  for  <u><a href="file:/etc/resolv.conf">/etc/resolv.conf</a></u>,  files  will  only  be  read  if owned by the effective userid running the
       program.   In  addition,  several  environment  variables  may  contain  configuration  information;  see
       "ENVIRONMENT".

       Note  that the domain and searchlist keywords are mutually exclusive.  If both are present, the resulting
       behaviour is unspecified.  If neither is present, the domain is determined from the local hostname.

       On Windows systems, an attempt is made to determine the system defaults using the registry.  Systems with
       many dynamically configured network interfaces may confuse Net::DNS.

       If a custom configuration file is specified at first instantiation, all  other  configuration  files  and
       environment variables are ignored.

       Explicit  arguments  to  new()  override  the  corresponding  configuration variables.  The argument list
       consists of a sequence of (name=&gt;value) pairs, each interpreted as an  invocation  of  the  corresponding
       method.

   <b>print</b>
               $resolver-&gt;print;

       Prints the resolver state on the standard output.

   <b>query</b>
               $packet = $resolver-&gt;query( 'host' );
               $packet = $resolver-&gt;query( 'host.example.com' );
               $packet = $resolver-&gt;query( '2001:DB8::1' );
               $packet = $resolver-&gt;query( 'example.com', 'MX' );
               $packet = $resolver-&gt;query( 'annotation.example.com', 'TXT', 'IN' );

       Performs  a  DNS  query  for  the given name; the search list is not applied.  If "defnames" is true, the
       default domain will be appended to unqualified names.

       The record type and class can be omitted; they default to A and IN.  If the name looks like an IP address
       (IPv4 or IPv6), then a query within in-addr.arpa or ip6.arpa will be performed.

       Returns a Net::DNS::Packet object, or "undef" if no answers were found.  The reason for  failure  may  be
       determined using errorstring().

       If you need to examine the response packet, whether it contains any answers or not, use the send() method
       instead.

   <b>search</b>
               $packet = $resolver-&gt;search( 'host' );
               $packet = $resolver-&gt;search( 'host.example.com' );
               $packet = $resolver-&gt;search( '2001:DB8::1' );
               $packet = $resolver-&gt;search( 'example.com', 'MX' );
               $packet = $resolver-&gt;search( 'annotation.example.com', 'TXT', 'IN' );

       Performs a DNS query for the given name, applying the searchlist if appropriate.  The search algorithm is
       as follows:

       If the name contains one or more non-terminal dots, perform an initial query using the unmodified name.

       If  the  number  of dots is less than "ndots", and there is no terminal dot, try appending each suffix in
       the search list.

       The record type and class can be omitted; they default to A and IN.  If the name looks like an IP address
       (IPv4 or IPv6), then a query within in-addr.arpa or ip6.arpa will be performed.

       Returns a Net::DNS::Packet object, or "undef" if no answers were found.  The reason for  failure  may  be
       determined using errorstring().

       If you need to examine the response packet, whether it contains any answers or not, use the send() method
       instead.

   <b>send</b>
               $packet = $resolver-&gt;send( $query );

               $packet = $resolver-&gt;send( 'host.example.com' );
               $packet = $resolver-&gt;send( '2001:DB8::1' );
               $packet = $resolver-&gt;send( 'example.com', 'MX' );
               $packet = $resolver-&gt;send( 'annotation.example.com', 'TXT', 'IN' );

       Performs a DNS query for the given name.  Neither the searchlist nor the default domain will be appended.

       The argument list can be either a pre-built query Net::DNS::Packet or a list of strings.  The record type
       and class can be omitted; they default to A and IN.  If the name looks like an IP address (IPv4 or IPv6),
       then a query within in-addr.arpa or ip6.arpa will be performed.

       Returns  a Net::DNS::Packet object whether there were any answers or not.  Use "$packet-&gt;header-&gt;ancount"
       or "$packet-&gt;answer" to find out if there were any records in the answer section.  Returns "undef" if  no
       response was received.

   <b>axfr</b>
               @zone = $resolver-&gt;axfr();
               @zone = $resolver-&gt;axfr( 'example.com' );
               @zone = $resolver-&gt;axfr( 'example.com', 'IN' );

               $iterator = $resolver-&gt;axfr();
               $iterator = $resolver-&gt;axfr( 'example.com' );
               $iterator = $resolver-&gt;axfr( 'example.com', 'IN' );

               $rr = $iterator-&gt;();

       Performs a zone transfer using the resolver nameservers list, attempted in the order listed.

       If the zone is omitted, it defaults to the first zone listed in the resolver search list.

       If the class is omitted, it defaults to IN.

       When  called  in  list  context, axfr() returns a list of Net::DNS::RR objects.  The redundant SOA record
       that terminates the zone transfer is not returned to the caller.

       In deferrence to RFC1035(6.3), a complete zone transfer is expected to return all records in the zone  or
       nothing  at  all.   When  no  resource  records  are  returned  by  axfr(), the reason for failure may be
       determined using errorstring().

       Here is an example that uses a timeout and TSIG verification:

               $resolver-&gt;tcp_timeout( 10 );
               $resolver-&gt;tsig( $keyfile );
               @zone = $resolver-&gt;axfr( 'example.com' );

               foreach $rr (@zone) {
                       $rr-&gt;print;
               }

       When called in scalar context, axfr() returns an  iterator  object.   Each  invocation  of  the  iterator
       returns a single Net::DNS::RR or "undef" when the zone is exhausted.

       An exception is raised if the zone transfer can not be completed.

       The redundant SOA record that terminates the zone transfer is not returned to the caller.

       Here is the example above, implemented using an iterator:

               $resolver-&gt;tcp_timeout( 10 );
               $resolver-&gt;tsig( $keyfile );
               $iterator = $resolver-&gt;axfr( 'example.com' );

               while ( $rr = $iterator-&gt;() ) {
                       $rr-&gt;print;
               }

   <b>bgsend</b>
               $handle = $resolver-&gt;bgsend( $packet ) || die $resolver-&gt;errorstring;

               $handle = $resolver-&gt;bgsend( 'host.example.com' );
               $handle = $resolver-&gt;bgsend( '2001:DB8::1' );
               $handle = $resolver-&gt;bgsend( 'example.com', 'MX' );
               $handle = $resolver-&gt;bgsend( 'annotation.example.com', 'TXT', 'IN' );

       Performs  a  background  DNS  query  for  the  given name and returns immediately without waiting for the
       response. The program can then perform other tasks while awaiting the response from the nameserver.

       The argument list can be either a Net::DNS::Packet object or a list of  strings.   The  record  type  and
       class  can  be  omitted;  they default to A and IN.  If the name looks like an IP address (IPv4 or IPv6),
       then a query within in-addr.arpa or ip6.arpa will be performed.

       Returns an opaque handle which is passed to subsequent invocations of the bgbusy() and bgread()  methods.
       Errors  are  indicated  by returning "undef" in which case the reason for failure may be determined using
       errorstring().

       The response Net::DNS::Packet object is obtained by calling bgread().

       <b>BEWARE</b>: Programs should make no assumptions about the nature of the handles returned  by  bgsend()  which
       should be used strictly as described here.

   <b>bgread</b>
               $handle = $resolver-&gt;bgsend( 'www.example.com' );
               $packet = $resolver-&gt;bgread($handle);

       Reads the response following a background query.  The argument is the handle returned by bgsend().

       Returns  a  Net::DNS::Packet  object  or  "undef" if no response was received before the timeout interval
       expired.

   <b>bgbusy</b>
               $handle = $resolver-&gt;bgsend( 'foo.example.com' );

               while ($resolver-&gt;bgbusy($handle)) {
                       ...
               }

               $packet = $resolver-&gt;bgread($handle);

       Returns true while awaiting the response or for the transaction to time out.  The argument is the  handle
       returned by bgsend().

       Truncated  UDP  packets  will  be  retried transparently using TCP while continuing to assert busy to the
       caller.

   <b>debug</b>
               print 'debug flag: ', $resolver-&gt;debug, "\n";
               $resolver-&gt;<a href="../man1/debug.1.html">debug</a>(1);

       Get or set the debug flag.  If  set,  calls  to  search(),  query(),  and  send()  will  print  debugging
       information on the standard output.  The default is false.

   <b>defnames</b>
               print 'defnames flag: ', $resolver-&gt;defnames, "\n";
               $resolver-&gt;<a href="../man0/defnames.0.html">defnames</a>(0);

       Get  or set the defnames flag.  If true, calls to query() will append the default domain to resolve names
       that are not fully qualified.  The default is true.

   <b>dnsrch</b>
               print 'dnsrch flag: ', $resolver-&gt;dnsrch, "\n";
               $resolver-&gt;<a href="../man0/dnsrch.0.html">dnsrch</a>(0);

       Get or set the dnsrch flag.  If true, calls to search() will apply the search list to resolve names  that
       are not fully qualified.  The default is true.

   <b>domain</b>
               $domain = $resolver-&gt;domain;
               $resolver-&gt;domain( 'domain.example' );

       Gets or sets the resolver default domain.

   <b>igntc</b>
               print 'igntc flag: ', $resolver-&gt;igntc, "\n";
               $resolver-&gt;<a href="../man1/igntc.1.html">igntc</a>(1);

       Get  or  set  the  igntc  flag.  If true, truncated packets will be ignored.  If false, the query will be
       retried using TCP.  The default is false.

   <b>nameserver,</b> <b>nameservers</b>
               @nameservers = $resolver-&gt;nameservers();
               $resolver-&gt;nameservers( '2001:DB8::1', '192.0.2.1' );
               $resolver-&gt;nameservers( 'ns.domain.example.' );

       Gets or sets the nameservers to be queried.

       Also see the IPv6 transport notes below

   <b>persistent_tcp</b>
               print 'Persistent TCP flag: ', $resolver-&gt;persistent_tcp, "\n";
               $resolver-&gt;<a href="../man1/persistent_tcp.1.html">persistent_tcp</a>(1);

       Get or set the persistent TCP setting.  If true, Net::DNS will keep a TCP socket open for each  host:port
       to  which  it connects.  This is useful if you are using TCP and need to make a lot of queries or updates
       to the same nameserver.

       The default is false unless you are running a SOCKSified Perl, in which case the default is true.

   <b>persistent_udp</b>
               print 'Persistent UDP flag: ', $resolver-&gt;persistent_udp, "\n";
               $resolver-&gt;<a href="../man1/persistent_udp.1.html">persistent_udp</a>(1);

       Get or set the persistent UDP setting.  If true, a Net::DNS resolver will use the same UDP socket for all
       queries within each address family.

       This avoids  the  cost  of  creating  and  tearing  down  UDP  sockets,  but  also  defeats  source  port
       randomisation.

   <b>port</b>
               print 'sending queries to port ', $resolver-&gt;port, "\n";
               $resolver-&gt;<a href="../man9732/port.9732.html">port</a>(9732);

       Gets  or sets the port to which queries are sent.  Convenient for nameserver testing using a non-standard
       port.  The default is port 53.

   <b>recurse</b>
               print 'recursion flag: ', $resolver-&gt;recurse, "\n";
               $resolver-&gt;<a href="../man0/recurse.0.html">recurse</a>(0);

       Get or set the recursion flag.  If true, this will direct nameservers to perform a recursive query.   The
       default is true.

   <b>retrans</b>
               print 'retrans interval: ', $resolver-&gt;retrans, "\n";
               $resolver-&gt;<a href="../man3/retrans.3.html">retrans</a>(3);

       Get or set the retransmission interval The default is 5 seconds.

   <b>retry</b>
               print 'number of tries: ', $resolver-&gt;retry, "\n";
               $resolver-&gt;<a href="../man2/retry.2.html">retry</a>(2);

       Get or set the number of times to try the query.  The default is 4.

   <b>searchlist</b>
               @searchlist = $resolver-&gt;searchlist;
               $resolver-&gt;searchlist( 'a.example', 'b.example', 'c.example' );

       Gets or sets the resolver search list.

   <b>srcaddr</b>
               $resolver-&gt;srcaddr('2001::DB8::1');

       Sets  the  source  address  from  which queries are sent.  Convenient for forcing queries from a specific
       interface on a multi-homed host.  The default is to use any local address.

   <b>srcport</b>
               $resolver-&gt;<a href="../man5353/srcport.5353.html">srcport</a>(5353);

       Sets the port from which queries are sent.  The default is 0, meaning any port.

   <b>tcp_timeout</b>
               print 'TCP timeout: ', $resolver-&gt;tcp_timeout, "\n";
               $resolver-&gt;<a href="../man10/tcp_timeout.10.html">tcp_timeout</a>(10);

       Get or set the TCP timeout in seconds.  The default is 120 seconds (2 minutes).

   <b>udp_timeout</b>
               print 'UDP timeout: ', $resolver-&gt;udp_timeout, "\n";
               $resolver-&gt;<a href="../man10/udp_timeout.10.html">udp_timeout</a>(10);

       Get or set the <b>bgsend()</b> UDP timeout in seconds.  The default is 30 seconds.

   <b>udppacketsize</b>
               print "udppacketsize: ", $resolver-&gt;udppacketsize, "\n";
               $resolver-&gt;<a href="../man2048/udppacketsize.2048.html">udppacketsize</a>(2048);

       Get or set the UDP packet size.  If set to a value not less than the default DNS  packet  size,  an  EDNS
       extension will be added indicating support for large UDP datagrams.

   <b>usevc</b>
               print 'usevc flag: ', $resolver-&gt;usevc, "\n";
               $resolver-&gt;<a href="../man1/usevc.1.html">usevc</a>(1);

       Get  or  set  the usevc flag.  If true, queries will be performed using virtual circuits (TCP) instead of
       datagrams (UDP).  The default is false.

   <b>replyfrom</b>
               print 'last response was from: ', $resolver-&gt;replyfrom, "\n";

       Returns the IP address from which the most recent packet was received in response to a query.

   <b>errorstring</b>
               print 'query status: ', $resolver-&gt;errorstring, "\n";

       Returns  a  string  containing  error  information  from  the  most  recent  DNS  protocol   interaction.
       errorstring() is meaningful only when interrogated immediately after the corresponding method call.

   <b>dnssec</b>
               print "dnssec flag: ", $resolver-&gt;dnssec, "\n";
               $resolver-&gt;<a href="../man0/dnssec.0.html">dnssec</a>(0);

       The  dnssec  flag causes the resolver to transmit DNSSEC queries and to add a EDNS0 record as required by
       RFC2671 and RFC3225.  The actions of, and response from, the  remote  nameserver  is  determined  by  the
       settings of the AD and CD flags.

       Calling  the dnssec() method with a non-zero value will also set the UDP packet size to the default value
       of 2048. If that is too small or too big for your environment, you should call the udppacketsize() method
       immediately after.

               $resolver-&gt;<a href="../man1/dnssec.1.html">dnssec</a>(1);
               $resolver-&gt;<a href="../man1250/udppacketsize.1250.html">udppacketsize</a>(1250); # adjust UDP packet size

       A fatal exception will be raised if the dnssec() method is called but the Net::DNS::SEC library  has  not
       been installed.

   <b>adflag</b>
               $resolver-&gt;<a href="../man1/dnssec.1.html">dnssec</a>(1);
               $resolver-&gt;<a href="../man1/adflag.1.html">adflag</a>(1);
               print "authentication desired flag: ", $resolver-&gt;adflag, "\n";

       Gets  or  sets  the  AD  bit for dnssec queries.  This bit indicates that the caller is interested in the
       returned AD (authentic data) bit but does not require any dnssec RRs to be included in the response.  The
       default value is false.

   <b>cdflag</b>
               $resolver-&gt;<a href="../man1/dnssec.1.html">dnssec</a>(1);
               $resolver-&gt;<a href="../man1/cdflag.1.html">cdflag</a>(1);
               print "checking disabled flag: ", $resolver-&gt;cdflag, "\n";

       Gets or sets the CD bit  for  dnssec  queries.   This  bit  indicates  that  authentication  by  upstream
       nameservers should be suppressed.  Any dnssec RRs required to execute the authentication procedure should
       be included in the response.  The default value is false.

   <b>tsig</b>
               $resolver-&gt;tsig( $keyfile );

               $resolver-&gt;tsig( $keyfile, fudge =&gt; 60 );

               $resolver-&gt;tsig( $tsig_rr );

               $resolver-&gt;tsig( undef );

       Set  the  TSIG  record used to automatically sign outgoing queries, zone transfers and updates. Automatic
       signing is disabled if called with undefined arguments.

       The default resolver behaviour is not to sign any packets.  You must call this method to set the  key  if
       you would like the resolver to sign and verify packets automatically.

       Packets  can  also  be  signed  manually;  see the Net::DNS::Packet and Net::DNS::Update manual pages for
       examples.  TSIG records in manually-signed packets take precedence over those that the resolver would add
       automatically.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       The following environment variables can also be used to configure the resolver:

   <b>RES_NAMESERVERS</b>
               # Bourne Shell
               RES_NAMESERVERS="2001:DB8::1 192.0.2.1"
               export RES_NAMESERVERS

               # C Shell
               setenv RES_NAMESERVERS "2001:DB8::1 192.0.2.1"

       A space-separated list of nameservers to query.

   <b>RES_SEARCHLIST</b>
               # Bourne Shell
               RES_SEARCHLIST="a.example.com b.example.com c.example.com"
               export RES_SEARCHLIST

               # C Shell
               setenv RES_SEARCHLIST "a.example.com b.example.com c.example.com"

       A space-separated list of domains to put in the search list.

   <b>LOCALDOMAIN</b>
               # Bourne Shell
               LOCALDOMAIN=example.com
               export LOCALDOMAIN

               # C Shell
               setenv LOCALDOMAIN example.com

       The default domain.

   <b>RES_OPTIONS</b>
               # Bourne Shell
               RES_OPTIONS="retrans:3 retry:2 inet6"
               export RES_OPTIONS

               # C Shell
               setenv RES_OPTIONS "retrans:3 retry:2 inet6"

       A space-separated list  of  resolver  options  to  set.   Options  that  take  values  are  specified  as
       "option:value".

</pre><h4><b>IPv4</b> <b>TRANSPORT</b></h4><pre>
       The  force_v4(),  force_v6(),  prefer_v4(), and prefer_v6() methods with non-zero argument may be used to
       configure transport selection.

       The behaviour of the nameserver() method illustrates the transport selection mechanism.  If, for example,
       IPv4 transport has been forced, the nameserver() method will only return IPv4 addresses:

               $resolver-&gt;nameservers( '192.0.2.1', '192.0.2.2', '2001:DB8::3' );
               $resolver-&gt;<a href="../man1/force_v4.1.html">force_v4</a>(1);
               print join ' ', $resolver-&gt;nameservers();

       will print

               192.0.2.1 192.0.2.2

</pre><h4><b>CUSTOMISED</b> <b>RESOLVERS</b></h4><pre>
       Net::DNS::Resolver is actually an empty subclass.  At compile time a super class is chosen based  on  the
       current   platform.    A   side  benefit  of  this  allows  for  easy  modification  of  the  methods  in
       Net::DNS::Resolver.  You can simply add a method to the namespace!

       For example, if we wanted to cache lookups:

               package Net::DNS::Resolver;

               my %cache;

               sub send {
                       my ( $self, @q ) = @_;
                       return $cache{"@q"} ||= $self-&gt;SUPER::send(@q);
               }

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c)1997-2000 Michael Fuhr.

       Portions Copyright (c)2002-2004 Chris Reinhardt.

       Portions Copyright (c)2005 Olaf M. Kolkman, NLnet Labs.

       Portions Copyright (c)2014,2015 Dick Franks.

       All rights reserved.

</pre><h4><b>LICENSE</b></h4><pre>
       Permission to use, copy, modify, and distribute this software and its documentation for any  purpose  and
       without fee is hereby granted, provided that the original copyright notices appear in all copies and that
       both copyright notice and this permission notice appear in supporting documentation, and that the name of
       the  author  not  be  used in advertising or publicity pertaining to distribution of the software without
       specific prior written permission.

       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  IMPLIED,  INCLUDING  BUT  NOT
       LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
       EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
       IN  AN  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
       THE USE OR OTHER DEALINGS IN THE SOFTWARE.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       perl Net::DNS  Net::DNS::Packet  Net::DNS::Header  Net::DNS::Question  Net::DNS::RR  <b><a href="../man5/resolver.5.html">resolver</a></b>(5)  RFC1034
       &lt;https://iana.org/go/rfc1034&gt; RFC1035 &lt;https://iana.org/go/rfc1035&gt;

perl v5.40.1                                       2025-03-05                            <u>Net::DNS::<a href="../man3pm/Resolver.3pm.html">Resolver</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>