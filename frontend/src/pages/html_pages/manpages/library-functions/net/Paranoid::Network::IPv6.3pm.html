<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paranoid::Network::IPv6 - IPv6-related functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libparanoid-perl">libparanoid-perl_2.10-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Paranoid::Network::IPv6 - IPv6-related functions

</pre><h4><b>VERSION</b></h4><pre>
       $Id: lib/Paranoid/Network/IPv6.pm, 2.10 2022/03/08 00:01:04 acorliss Exp $

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Paranoid::Network::IPv6;

           @net = ipv6NetConvert($netAddr);
           $rv = ipv6NetIntersect($net1, $net2);

       or

           use Paranoid::Network::IPv6 qw(:all);

           print "Valid IP address\n" if $netAddr =~ /^@{[ IPV6REGEX ]}$/;

           @net = ipv6NetConvert($netAddr);
           $broadcast = $net[IPV6BRDCST];

           use Paranoid::Network::IPv6 qw(:ipv6Sort);

           @nets = sort ipv6StrSort    @nets;
           @nets = sort ipv6PackedSort @nets;
           @nets = sort ipv6NumSort    @nets;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module contains a few convenience functions for working with IPv6 addresses.

</pre><h4><b>IMPORT</b> <b>LISTS</b></h4><pre>
       This module exports the following symbols by default:

           ipv6NetConvert ipv6NetPacked ipv6NetIntersect

       The following specialized import lists also exist:

           List        Members
           --------------------------------------------------------
           base        @defaults
           constants   MAXIPV6CIDR IPV6REGEX IPV6CIDRRGX IPV6BASE
                       IPV6BRDCST IPV6MASK
           ipv6Sort    ipv6StrSort ipv6PackedSort ipv6NumSort
           all         @base @constants @ipv6Sort

</pre><h4><b>SUBROUTINES/METHODS</b></h4><pre>
   <b>ipv6NetConvert</b>
           @net = ipv6NetConvert($netAddr);

       This function takes an IPv4 network address in string format and converts it into and array of arrays.
       The arrays will contain the base network address, the broadcast address, and the netmask, each split into
       native 32bit integer format chunks.  Each sub array is essentially what you would get from:

           @chunks = unpack 'NNNN', inet_pton(AF_INET6, '::1');

       using '::1' as the sample IPv6 address.

       The network address must have the netmask in CIDR format.  In the case of a single IP address, the array
       with only have one subarray, that of the IP itself, split into 32bit integers.

       Passing any argument to this function that is not a string representation of an IP address (including
       undef values) will cause this function to return an empty array.

   <b>ipv6NetPacked</b>
           @net = ipv6NetPacked('fe80::/64');

       This function is a wrapper for <b>ipv6NetConvert</b>, but instead of subarrays each element is the packed
       (opaque) string as returned by <b>inet_pton</b>.

   <b>ipv6NetIntersect</b>
           $rv = ipv6NetIntersect($net1, $net2);

       This function tests whether an IP or subnet intersects with another IP or subnet.  The return value is
       essentially boolean, but the true value can vary to indicate which is a subset of the other:

           -1: destination range encompasses target range
            0: both ranges do not intersect at all
            1: target range encompasses destination range

       The function handles the same string formats as <b>ipv6NetConvert</b>, but will allow you to test single IPs in
       integer format as well.

   <b>ipv6StrSort</b>
           @sorted = sort ipv6StrSort @nets;

       This function allows IPv6 addresses and networks to be passed in string format.  Networks can be in CIDR
       format.  Sorts in ascending order.  :w

   <b>ipv6PackedSort</b>
           @sorted = sort ipv6PackedSort @nets;

       This function sorts addresses that are in packed format, such as returned by inet_pton.  Sorts in
       ascending order.

   <b>ipv6NumSort</b>
           @sorted = sort ipv6NumSort @nets;

       This function sorts addresses that are in unpacked, native integer format, such as one gets from:

           @ip = unpack 'NNNN', inet_pton(AF_INET6, $ipAddr);

       Sorts in ascending order.  List of addresses should be a list of lists.

</pre><h4><b>CONSTANTS</b></h4><pre>
       These are only imported if explicitly requested or with the <b>:all</b> tag.

   <b>MAXIPV6CIDR</b>
       Simply put: 128.  This is the largest CIDR notation supported in IPv6.

   <b>IPV6REGEX</b>
       Regular expression.

       You can use this for validating IP addresses as such:

           $ip =~ m#^@{[ IPV6REGEX ]}$#;

       or to extract potential IPs from  extraneous text:

           @ips = ( $string =~ m#(@{[ IPV6REGEX ]})#g);

   <b>IPV6CIDRRGX</b>
       Regular expression.

       By default this will extract CIDR notation network addresses:

           @networks = ( $string =~ m#(@{[ IPV6CIDRRGX ]})#si );

   <b>IPV6BASE</b>
       This is the ordinal index of the base network address as returned by <b>ipv6NetConvert</b>.

   <b>IPV6BRDCST</b>
       This is the ordinal index of the broadcast address as returned by <b>ipv6NetConvert</b>.

   <b>IPV6MASK</b>
       This is the ordinal index of the network mask as returned by <b>ipv6NetConvert</b>.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       o   Paranoid

       o   Paranoid::Debug

       o   Paranoid::Network::Socket

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
</pre><h4><b>AUTHOR</b></h4><pre>
       Arthur Corliss (<a href="mailto:corliss@digitalmages.com">corliss@digitalmages.com</a>)

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       This  software  is  free  software.   Similar to Perl, you can redistribute it and/or modify it under the
       terms of either:

         a)     the GNU General Public License
                &lt;https://www.gnu.org/licenses/gpl-1.0.html&gt; as published by the
                Free Software Foundation &lt;<a href="http://www.fsf.org/">http://www.fsf.org/</a>&gt;; either version 1
                &lt;https://www.gnu.org/licenses/gpl-1.0.html&gt;, or any later version
                &lt;https://www.gnu.org/licenses/license-list.html#GNUGPL&gt;, or
         b)     the Artistic License 2.0
                &lt;https://opensource.org/licenses/Artistic-2.0&gt;,

       subject to the following additional term:  No trademark rights to "Paranoid" have been  or  are  conveyed
       under  any  of  the  above  licenses.  However, "Paranoid" may be used fairly to describe this unmodified
       software, in good faith, but not as a trademark.

       (c)  2005  -  2020,  Arthur  Corliss  (<a href="mailto:corliss@digitalmages.com">corliss@digitalmages.com</a>)  (tm)  2008  -   2020,   Paranoid   Inc.
       (www.paranoid.com)

perl v5.38.2                                       2024-03-07                       <u>Paranoid::Network::<a href="../man3pm/IPv6.3pm.html">IPv6</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>