<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::Complex - handle complex numbers (DEPRECATED - use native complex)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/pdl">pdl_2.074-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::Complex - handle complex numbers (DEPRECATED - use native complex)

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use PDL;
         use PDL::Complex;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is deprecated in favour of using "native complex" data types, e.g.:

         use PDL;
         my $complex_pdl = cdouble('[1+3i]');
         print $complex_pdl * pdl('i'); # [-3+i]

       This module features a growing number of functions manipulating complex numbers. These are usually
       represented as a pair "[ real imag ]" or "[ magnitude phase ]". If not explicitly mentioned, the
       functions can work inplace (not yet implemented!!!) and require rectangular form.

       While there is a procedural interface available ("$x/$y*$c &lt;=&gt; Cmul (Cdiv ($x, $y), $c)"), you can also
       opt to cast your pdl's into the "PDL::Complex" datatype, which works just like your normal ndarrays, but
       with all the normal perl operators overloaded.

       The latter means that "sin($x) + $y/$c" will be evaluated using the normal rules of complex numbers,
       while other pdl functions (like "max") just treat the ndarray as a real-valued ndarray with a lowest
       dimension of size 2, so "max" will return the maximum of all real and imaginary parts, not the "highest"
       (for some definition)

   <b>Native</b> <b>complex</b> <b>support</b>
       2.027 added changes in complex number handling, with support for C99 complex floating-point types, and
       most functions and modules in the core distribution support these as well.

       PDL can now handle complex numbers natively as scalars. This has the advantage that real and complex
       valued ndarrays have the same dimensions. Consider this when writing code in the future.

       See "re" in PDL::Ops, "im" in PDL::Ops, "abs" in PDL::Ops, "carg" in PDL::Ops, "conj" in PDL::Ops for
       more.

</pre><h4><b>TIPS,</b> <b>TRICKS</b> <b>&amp;</b> <b>CAVEATS</b></h4><pre>
       •   "i" is a function (not, as of 2.047, a constant) exported by this module, which represents "-1**0.5",
           i.e.  the  imaginary  unit.  it  can be used to quickly and conveniently write complex constants like
           this: "4+3*i".

           <b>NB</b> This will override the PDL::Core function of the same name, which returns a native complex value.

       •   Use "r2C(real-values)" to convert from real to  complex,  as  in  "$r  =  Cpow  $cplx,  r2C  2".  The
           overloaded operators automatically do that for you, all the other functions, do not. So "Croots 1, 5"
           will return all the fifths roots of 1+1*i (due to threading).

       •   use  "cplx(real-valued-ndarray)"  to  cast  from  normal  ndarrays  into  the  complex  datatype. Use
           "real(complex-valued-ndarray)" to cast back. This requires a copy, though.

       •   This module has received some testing by Vanuxem Grégory (g.vanuxem at wanadoo dot fr). Please report
           any other errors you come across!

</pre><h4><b>EXAMPLE</b> <b>WALK-THROUGH</b></h4><pre>
       The complex constant five is equal to "pdl(1,0)":

          pdl&gt; p $x = r2C 5
          5 +0i

       Now calculate the three cubic roots of five:

          pdl&gt; p $r = Croots $x, 3
          [1.70998 +0i  -0.854988 +1.48088i  -0.854988 -1.48088i]

       Check that these really are the roots:

          pdl&gt; p $r ** 3
          [5 +0i  5 -1.22465e-15i  5 -7.65714e-15i]

       Duh! Could be better. Now try by multiplying $r three times with itself:

          pdl&gt; p $r*$r*$r
          [5 +0i  5 -4.72647e-15i  5 -7.53694e-15i]

       Well... maybe "Cpow" (which is used by the "**" operator) isn't as bad as I thought. Now multiply by  "i"
       and  negate,  then  take  the  complex conjugate, which is just a very expensive way of swapping real and
       imaginary parts.

          pdl&gt; p Cconj(-($r*i))
          [0 +1.70998i  1.48088 -0.854988i  -1.48088 -0.854988i]

       Now plot the magnitude of (part of) the complex sine. First generate the coefficients:

          pdl&gt; $sin = i * <a href="../man50/zeroes.50.html">zeroes</a>(50)-&gt;xlinvals(2,4) + <a href="../man50/zeroes.50.html">zeroes</a>(50)-&gt;xlinvals(0,7)

       Now plot the imaginary part, the real part and the magnitude of the sine into the same diagram:

          pdl&gt; use PDL::Graphics::Gnuplot
          pdl&gt; gplot( with =&gt; 'lines',
                     PDL::cat(im ( sin $sin ),
                              re ( sin $sin ),
                              abs( sin $sin ) ))

       An ASCII version of this plot looks like this:

         30 ++-----+------+------+------+------+------+------+------+------+-----++
            +      +      +      +      +      +      +      +      +      +      +
            |                                                                   $$|
            |                                                                  $  |
         25 ++                                                               $$  ++
            |                                                              ***    |
            |                                                            **   *** |
            |                                                         $$*        *|
         20 ++                                                       $**         ++
            |                                                     $$$*           #|
            |                                                  $$$   *          # |
            |                                                $$     *           # |
         15 ++                                            $$$       *          # ++
            |                                          $$$        **           #  |
            |                                      $$$$          *            #   |
            |                                  $$$$              *            #   |
         10 ++                            $$$$$                 *            #   ++
            |                        $$$$$                     *             #    |
            |                 $$$$$$$                         *             #     |
          5 ++       $$$############                          *             #    ++
            |*****$$$###            ###                      *             #      |
            *    #*****                #                     *             #      |
            | ###      ***              ###                **              #      |
          0 ##            ***              #              *               #      ++
            |                *              #             *              #        |
            |                 ***            #          **               #        |
            |                    *            #        *                #         |
         -5 ++                    **           #      *                 #        ++
            |                       ***         ##  **                 #          |
            |                          *          #*                  #           |
            |                           ****    ***##                #            |
        -10 ++                              ****     #              #            ++
            |                                         #             #             |
            |                                          ##         ##              |
            +      +      +      +      +      +      +  ### + ###  +      +      +
        -15 ++-----+------+------+------+------+------+-----###-----+------+-----++
            0      5      10     15     20     25     30     35     40     45     50

</pre><h4><b>OPERATORS</b></h4><pre>
       The following operators are overloaded:

       +, += (addition)
       -, -= (subtraction)
       *, *= (multiplication; "Cmul")
       /, /= (division; "Cdiv")
       **, **= (exponentiation; "Cpow")
       atan2 (4-quadrant arc tangent)
       sin ("Csin")
       cos ("Ccos")
       exp ("Cexp")
       abs ("Cabs")
       log ("Clog")
       sqrt ("Csqrt")
       ++, -- (increment, decrement; they affect the real part of the complex number only)
       "" (stringification)

       Comparing complex numbers other than for equality is a fatal error.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>from_native</b>
       Class method to convert a native-complex ndarray to a PDL::Complex object.

        PDL::Complex-&gt;from_native($native_complex_ndarray)

   <b>as_native</b>
       Object method to convert a PDL::Complex object to a native-complex ndarray.

        $pdl_complex_obj-&gt;as_native

   <b>cplx</b>
       Cast a real-valued ndarray to the complex datatype.

       The first dimension of the ndarray must be of size 2. After this the usual (complex) arithmetic operators
       are applied to this pdl, rather than the normal elementwise  pdl  operators.   Dataflow  to  the  complex
       parent works. Use "sever" on the result if you don't want this.

        cplx($real_valued_pdl)

   <b>complex</b>
       Cast a real-valued ndarray to the complex datatype <u>without</u> dataflow and <u>inplace</u>.

       Achieved by merely reblessing an ndarray. The first dimension of the ndarray must be of size 2.

        complex($real_valued_pdl)

   <b>real</b>
       Cast a complex valued pdl back to the "normal" pdl datatype.

       Afterwards  the  normal  elementwise  pdl  operators  are used in operations. Dataflow to the real parent
       works. Use "sever" on the result if you don't want this.

        real($cplx_valued_pdl)

   <b>r2C</b>
         Signature: (r(); [o]c(m=2))

       convert real to complex, assuming an imaginary part of zero

       r2C does not process bad values.  It will set the bad-value flag of all output ndarrays if  the  flag  is
       set for any of the input ndarrays.

   <b>i2C</b>
         Signature: (r(); [o]c(m=2))

       convert imaginary to complex, assuming a real part of zero

       i2C  does  not  process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Cr2p</b>
         Signature: (r(m=2); float+ [o]p(m=2))

       convert complex numbers in rectangular form to polar (mod,arg) form. Works inplace

       Cr2p does not process bad values.  It will set the bad-value flag of all output ndarrays if the  flag  is
       set for any of the input ndarrays.

   <b>Cp2r</b>
         Signature: (r(m=2); [o]p(m=2))

       convert complex numbers in polar (mod,arg) form to rectangular form. Works inplace

       Cp2r  does  not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Cmul</b>
         Signature: (a(m=2); b(m=2); [o]c(m=2))

       complex multiplication

       Cmul does not process bad values.  It will set the bad-value flag of all output ndarrays if the  flag  is
       set for any of the input ndarrays.

   <b>Cprodover</b>
         Signature: (a(m=2,n); [o]c(m=2))

       Project via product to N-1 dimension

       Cprodover does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>Cscale</b>
         Signature: (a(m=2); b(); [o]c(m=2))

       mixed complex/real multiplication

       Cscale does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Cdiv</b>
         Signature: (a(m=2); b(m=2); [o]c(m=2))

       complex division

       Cdiv  does  not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Ceq</b>
         Signature: (a(m=2); b(m=2); [o]c())

       Complex equality operator.

       Ceq does not process bad values.  It will set the bad-value flag of all output ndarrays if  the  flag  is
       set for any of the input ndarrays.

   <b>Cconj</b>
         Signature: (a(m=2); [o]c(m=2))

       complex conjugation. Works inplace

       Cconj  does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Cabs</b>
         Signature: (a(m=2); [o]c())

       complex "abs()" (also known as <u>modulus</u>)

       Cabs does not process bad values.  It will set the bad-value flag of all output ndarrays if the  flag  is
       set for any of the input ndarrays.

   <b>Cabs2</b>
         Signature: (a(m=2); [o]c())

       complex squared "abs()" (also known <u>squared</u> <u>modulus</u>)

       Cabs2  does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Carg</b>
         Signature: (a(m=2); [o]c())

       complex argument function ("angle")

       Carg does not process bad values.  It will set the bad-value flag of all output ndarrays if the  flag  is
       set for any of the input ndarrays.

   <b>Csin</b>
         Signature: (a(m=2); [o]c(m=2))

         sin (a) = 1/(2*i) * (exp (a*i) - exp (-a*i)). Works inplace

       Csin  does  not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Ccos</b>
         Signature: (a(m=2); [o]c(m=2))

         cos (a) = 1/2 * (exp (a*i) + exp (-a*i)). Works inplace

       Ccos does not process bad values.  It will set the bad-value flag of all output ndarrays if the  flag  is
       set for any of the input ndarrays.

   <b>Ctan</b>
       Complex tangent

         tan (a) = -i * (exp (a*i) - exp (-a*i)) / (exp (a*i) + exp (-a*i))

       Does not work inplace.

   <b>Cexp</b>
         Signature: (a(m=2); [o]c(m=2))

         exp (a) = exp (real (a)) * (cos (imag (a)) + i * sin (imag (a))). Works inplace

       Cexp  does  not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Clog</b>
         Signature: (a(m=2); [o]c(m=2))

         log (a) = log (cabs (a)) + i * carg (a). Works inplace

       Clog does not process bad values.  It will set the bad-value flag of all output ndarrays if the  flag  is
       set for any of the input ndarrays.

   <b>Cpow</b>
         Signature: (a(m=2); b(m=2); [o]c(m=2))

       complex "pow()" ("**"-operator)

       Cpow  does  not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Csqrt</b>
         Signature: (a(m=2); [o]c(m=2))

       Works inplace

       Csqrt does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag  is
       set for any of the input ndarrays.

   <b>Casin</b>
         Signature: (a(m=2); [o]c(m=2))

       Works inplace

       Casin  does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Cacos</b>
         Signature: (a(m=2); [o]c(m=2))

       Works inplace

       Cacos does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag  is
       set for any of the input ndarrays.

   <b>Catan</b>
       Return the complex "atan()".

       Does not work inplace.

   <b>Csinh</b>
         Signature: (a(m=2); [o]c(m=2))

         sinh (a) = (exp (a) - exp (-a)) / 2. Works inplace

       Csinh  does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Ccosh</b>
         Signature: (a(m=2); [o]c(m=2))

         cosh (a) = (exp (a) + exp (-a)) / 2. Works inplace

       Ccosh does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag  is
       set for any of the input ndarrays.

   <b>Ctanh</b>
         Signature: (a(m=2); [o]c(m=2))

       Works inplace

       Ctanh  does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Casinh</b>
         Signature: (a(m=2); [o]c(m=2))

       Works inplace

       Casinh does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Cacosh</b>
         Signature: (a(m=2); [o]c(m=2))

       Works inplace

       Cacosh does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Catanh</b>
         Signature: (a(m=2); [o]c(m=2))

       Works inplace

       Catanh does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>Cproj</b>
         Signature: (a(m=2); [o]c(m=2))

       compute the projection of a complex number to the riemann sphere. Works inplace

       Cproj does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag  is
       set for any of the input ndarrays.

   <b>Croots</b>
         Signature: (a(m=2); [o]c(m=2,n); int n =&gt; n)

       Compute the "n" roots of "a". "n" must be a positive integer. The result will always be a complex type!

       Croots does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>re,</b> <b>im</b>
       Return the real or imaginary part of the complex number(s) given.

       These  are  slicing  operators, so data flow works. The real and imaginary parts are returned as ndarrays
       (ref eq PDL).

   <b>rCpolynomial</b>
         Signature: (coeffs(n); x(c=2,m); [o]out(c=2,m))

       evaluate the polynomial with (real) coefficients "coeffs" at the (complex) position(s)  "x".  "coeffs[0]"
       is the constant term.

       rCpolynomial  does  not process bad values.  It will set the bad-value flag of all output ndarrays if the
       flag is set for any of the input ndarrays.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) 2000 Marc Lehmann &lt;<a href="mailto:pcg@goof.com">pcg@goof.com</a>&gt;.  All rights reserved.  There  is  no  warranty.  You  are
       allowed  to  redistribute  this  software  /  documentation  as  described in the file COPYING in the PDL
       distribution.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), PDL.

perl v5.34.0                                       2022-02-08                                       <u><a href="../man3pm/Complex.3pm.html">Complex</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>