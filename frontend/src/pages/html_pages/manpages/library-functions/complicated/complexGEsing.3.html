<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>complexGEsing - complex</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/liblapack-doc">liblapack-doc_3.10.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       complexGEsing - complex

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>cgejsv</b> (JOBA, JOBU, JOBV, JOBR, JOBT, JOBP, M, N, A, LDA, SVA, U, LDU, V, LDV, CWORK, LWORK,
           RWORK, LRWORK, IWORK, INFO)
           <b>CGEJSV</b>
       subroutine <b>cgesdd</b> (JOBZ, M, N, A, LDA, S, U, LDU, VT, LDVT, WORK, LWORK, RWORK, IWORK, INFO)
           <b>CGESDD</b>
       subroutine <b>cgesvd</b> (JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT, WORK, LWORK, RWORK, INFO)
            <b>CGESVD</b> <b>computes</b> <b>the</b> <b>singular</b> <b>value</b> <b>decomposition</b> <b>(SVD)</b> <b>for</b> <b>GE</b> <b>matrices</b>
       subroutine <b>cgesvdq</b> (JOBA, JOBP, JOBR, JOBU, JOBV, M, N, A, LDA, S, U, LDU, V, LDV, NUMRANK, IWORK,
           LIWORK, CWORK, LCWORK, RWORK, LRWORK, INFO)
            <b>CGESVDQ</b> <b>computes</b> <b>the</b> <b>singular</b> <b>value</b> <b>decomposition</b> <b>(SVD)</b> <b>with</b> <b>a</b> <b>QR-Preconditioned</b> <b>QR</b> <b>SVD</b> <b>Method</b> <b>for</b>
           <b>GE</b> <b>matrices</b>
       subroutine <b>cgesvdx</b> (JOBU, JOBVT, RANGE, M, N, A, LDA, VL, VU, IL, IU, NS, S, U, LDU, VT, LDVT, WORK,
           LWORK, RWORK, IWORK, INFO)
            <b>CGESVDX</b> <b>computes</b> <b>the</b> <b>singular</b> <b>value</b> <b>decomposition</b> <b>(SVD)</b> <b>for</b> <b>GE</b> <b>matrices</b>
       subroutine <b>cggsvd3</b> (JOBU, JOBV, JOBQ, M, N, P, K, L, A, LDA, B, LDB, ALPHA, BETA, U, LDU, V, LDV, Q, LDQ,
           WORK, LWORK, RWORK, IWORK, INFO)
            <b>CGGSVD3</b> <b>computes</b> <b>the</b> <b>singular</b> <b>value</b> <b>decomposition</b> <b>(SVD)</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       This is the group of complex singular value driver functions for GE matrices

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>cgejsv</b> <b>(character*1</b> <b>JOBA,</b> <b>character*1</b> <b>JOBU,</b> <b>character*1</b> <b>JOBV,</b> <b>character*1</b> <b>JOBR,</b> <b>character*1</b> <b>JOBT,</b>
       <b>character*1</b> <b>JOBP,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b> <b>dimension(</b> <b>n</b> <b>)</b>
       <b>SVA,</b> <b>complex,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>complex,</b>
       <b>dimension(</b> <b>lwork</b> <b>)</b> <b>CWORK,</b> <b>integer</b> <b>LWORK,</b> <b>real,</b> <b>dimension(</b> <b>lrwork</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>LRWORK,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CGEJSV</b>

       <b>Purpose:</b>

            CGEJSV computes the singular value decomposition (SVD) of a complex M-by-N
            matrix [A], where M &gt;= N. The SVD of [A] is written as

                         [A] = [U] * [SIGMA] * [V]^*,

            where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
            diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
            [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
            the singular values of [A]. The columns of [U] and [V] are the left and
            the right singular vectors of [A], respectively. The matrices [U] and [V]
            are computed and stored in the arrays U and V, respectively. The diagonal
            of [SIGMA] is computed and stored in the array SVA.

</pre><h4><b>Arguments:</b></h4><pre>
       <b>Parameters</b>
           <u>JOBA</u>

                     JOBA is CHARACTER*1
                    Specifies the level of accuracy:
                  = 'C': This option works well (high relative accuracy) if A = B * D,
                         with well-conditioned B and arbitrary diagonal matrix D.
                         The accuracy cannot be spoiled by COLUMN scaling. The
                         accuracy of the computed output depends on the condition of
                         B, and the procedure aims at the best theoretical accuracy.
                         The relative error max_{i=1:N}|d sigma_i| / sigma_i is
                         bounded by f(M,N)*epsilon* cond(B), independent of D.
                         The input matrix is preprocessed with the QRF with column
                         pivoting. This initial preprocessing and preconditioning by
                         a rank revealing QR factorization is common for all values of
                         JOBA. Additional actions are specified as follows:
                  = 'E': Computation as with 'C' with an additional estimate of the
                         condition number of B. It provides a realistic error bound.
                  = 'F': If A = D1 * C * D2 with ill-conditioned diagonal scalings
                         D1, D2, and well-conditioned matrix C, this option gives
                         higher accuracy than the 'C' option. If the structure of the
                         input matrix is not known, and relative accuracy is
                         desirable, then this option is advisable. The input matrix A
                         is preprocessed with QR factorization with FULL (row and
                         column) pivoting.
                  = 'G': Computation as with 'F' with an additional estimate of the
                         condition number of B, where A=B*D. If A has heavily weighted
                         rows, then using this condition number gives too pessimistic
                         error bound.
                  = 'A': Small singular values are not well determined by the data
                         and are considered as noisy; the matrix is treated as
                         numerically rank deficient. The error in the computed
                         singular values is bounded by f(m,n)*epsilon*||A||.
                         The computed SVD A = U * S * V^* restores A up to
                         f(m,n)*epsilon*||A||.
                         This gives the procedure the licence to discard (set to zero)
                         all singular values below N*epsilon*||A||.
                  = 'R': Similar as in 'A'. Rank revealing property of the initial
                         QR factorization is used do reveal (using triangular factor)
                         a gap sigma_{r+1} &lt; epsilon * sigma_r in which case the
                         numerical RANK is declared to be r. The SVD is computed with
                         absolute error bounds, but more accurately than with 'A'.

           <u>JOBU</u>

                     JOBU is CHARACTER*1
                    Specifies whether to compute the columns of U:
                  = 'U': N columns of U are returned in the array U.
                  = 'F': full set of M left sing. vectors is returned in the array U.
                  = 'W': U may be used as workspace of length M*N. See the description
                         of U.
                  = 'N': U is not computed.

           <u>JOBV</u>

                     JOBV is CHARACTER*1
                    Specifies whether to compute the matrix V:
                  = 'V': N columns of V are returned in the array V; Jacobi rotations
                         are not explicitly accumulated.
                  = 'J': N columns of V are returned in the array V, but they are
                         computed as the product of Jacobi rotations, if JOBT = 'N'.
                  = 'W': V may be used as workspace of length N*N. See the description
                         of V.
                  = 'N': V is not computed.

           <u>JOBR</u>

                     JOBR is CHARACTER*1
                    Specifies the RANGE for the singular values. Issues the licence to
                    set to zero small positive singular values if they are outside
                    specified range. If A .NE. 0 is scaled so that the largest singular
                    value of c*A is around SQRT(BIG), BIG=SLAMCH('O'), then JOBR issues
                    the licence to kill columns of A whose norm in c*A is less than
                    SQRT(SFMIN) (for JOBR = 'R'), or less than SMALL=SFMIN/EPSLN,
                    where SFMIN=SLAMCH('S'), EPSLN=SLAMCH('E').
                  = 'N': Do not kill small columns of c*A. This option assumes that
                         BLAS and QR factorizations and triangular solvers are
                         implemented to work in that range. If the condition of A
                         is greater than BIG, use CGESVJ.
                  = 'R': RESTRICTED range for sigma(c*A) is [SQRT(SFMIN), SQRT(BIG)]
                         (roughly, as described above). This option is recommended.
                                                        ===========================
                    For computing the singular values in the FULL range [SFMIN,BIG]
                    use CGESVJ.

           <u>JOBT</u>

                     JOBT is CHARACTER*1
                    If the matrix is square then the procedure may determine to use
                    transposed A if A^* seems to be better with respect to convergence.
                    If the matrix is not square, JOBT is ignored.
                    The decision is based on two values of entropy over the adjoint
                    orbit of A^* * A. See the descriptions of <a href="../man6/WORK.6.html">WORK</a>(6) and <a href="../man7/WORK.7.html">WORK</a>(7).
                  = 'T': transpose if entropy test indicates possibly faster
                    convergence of Jacobi process if A^* is taken as input. If A is
                    replaced with A^*, then the row pivoting is included automatically.
                  = 'N': do not speculate.
                    The option 'T' can be used to compute only the singular values, or
                    the full SVD (U, SIGMA and V). For only one set of singular vectors
                    (U or V), the caller should provide both U and V, as one of the
                    matrices is used as workspace if the matrix A is transposed.
                    The implementer can easily remove this constraint and make the
                    code more complicated. See the descriptions of U and V.
                    In general, this option is considered experimental, and 'N'; should
                    be preferred. This is subject to changes in the future.

           <u>JOBP</u>

                     JOBP is CHARACTER*1
                    Issues the licence to introduce structured perturbations to drown
                    denormalized numbers. This licence should be active if the
                    denormals are poorly implemented, causing slow computation,
                    especially in cases of fast convergence (!). For details see [1,2].
                    For the sake of simplicity, this perturbations are included only
                    when the full SVD or only the singular values are requested. The
                    implementer/user can easily add the perturbation for the cases of
                    computing one set of singular vectors.
                  = 'P': introduce perturbation
                  = 'N': do not perturb

           <u>M</u>

                     M is INTEGER
                    The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                    The number of columns of the input matrix A. M &gt;= N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>SVA</u>

                     SVA is REAL array, dimension (N)
                     On exit,
                     - For <a href="../man1/WORK.1.html">WORK</a>(1)/<a href="../man2/WORK.2.html">WORK</a>(2) = ONE: The singular values of A. During the
                       computation SVA contains Euclidean column norms of the
                       iterated matrices in the array A.
                     - For <a href="../man1/WORK.1.html">WORK</a>(1) .NE. <a href="../man2/WORK.2.html">WORK</a>(2): The singular values of A are
                       (<a href="../man1/WORK.1.html">WORK</a>(1)/<a href="../man2/WORK.2.html">WORK</a>(2)) * SVA(1:N). This factored form is used if
                       sigma_max(A) overflows or if small singular values have been
                       saved from underflow by scaling the input matrix A.
                     - If JOBR='R' then some of the singular values may be returned
                       as exact zeros obtained by "set to zero" because they are
                       below the numerical rank threshold or are denormalized numbers.

           <u>U</u>

                     U is COMPLEX array, dimension ( LDU, N ) or ( LDU, M )
                     If JOBU = 'U', then U contains on exit the M-by-N matrix of
                                    the left singular vectors.
                     If JOBU = 'F', then U contains on exit the M-by-M matrix of
                                    the left singular vectors, including an ONB
                                    of the orthogonal complement of the Range(A).
                     If JOBU = 'W'  .AND. (JOBV = 'V' .AND. JOBT = 'T' .AND. M = N),
                                    then U is used as workspace if the procedure
                                    replaces A with A^*. In that case, [V] is computed
                                    in U as left singular vectors of A^* and then
                                    copied back to the V array. This 'W' option is just
                                    a reminder to the caller that in this case U is
                                    reserved as workspace of length N*N.
                     If JOBU = 'N'  U is not referenced, unless JOBT='T'.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U,  LDU &gt;= 1.
                     IF  JOBU = 'U' or 'F' or 'W',  then LDU &gt;= M.

           <u>V</u>

                     V is COMPLEX array, dimension ( LDV, N )
                     If JOBV = 'V', 'J' then V contains on exit the N-by-N matrix of
                                    the right singular vectors;
                     If JOBV = 'W', AND (JOBU = 'U' AND JOBT = 'T' AND M = N),
                                    then V is used as workspace if the pprocedure
                                    replaces A with A^*. In that case, [U] is computed
                                    in V as right singular vectors of A^* and then
                                    copied back to the U array. This 'W' option is just
                                    a reminder to the caller that in this case V is
                                    reserved as workspace of length N*N.
                     If JOBV = 'N'  V is not referenced, unless JOBT='T'.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V,  LDV &gt;= 1.
                     If JOBV = 'V' or 'J' or 'W', then LDV &gt;= N.

           <u>CWORK</u>

                     CWORK is COMPLEX array, dimension (MAX(2,LWORK))
                     If the call to CGEJSV is a workspace query (indicated by LWORK=-1 or
                     LRWORK=-1), then on exit <a href="../man1/CWORK.1.html">CWORK</a>(1) contains the required length of
                     CWORK for the job parameters used in the call.

           <u>LWORK</u>

                     LWORK is INTEGER
                     Length of CWORK to confirm proper allocation of workspace.
                     LWORK depends on the job:

                     1. If only SIGMA is needed ( JOBU = 'N', JOBV = 'N' ) and
                       1.1 .. no scaled condition estimate required (JOBA.NE.'E'.AND.JOBA.NE.'G'):
                          LWORK &gt;= 2*N+1. This is the minimal requirement.
                          -&gt;&gt; For optimal performance (blocked code) the optimal value
                          is LWORK &gt;= N + (N+1)*NB. Here NB is the optimal
                          block size for CGEQP3 and CGEQRF.
                          In general, optimal LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3),N+LWORK(CGEQRF), LWORK(CGESVJ)).
                       1.2. .. an estimate of the scaled condition number of A is
                          required (JOBA='E', or 'G'). In this case, LWORK the minimal
                          requirement is LWORK &gt;= N*N + 2*N.
                          -&gt;&gt; For optimal performance (blocked code) the optimal value
                          is LWORK &gt;= max(N+(N+1)*NB, N*N+2*N)=N**2+2*N.
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3),N+LWORK(CGEQRF), LWORK(CGESVJ),
                                       N*N+LWORK(CPOCON)).
                     2. If SIGMA and the right singular vectors are needed (JOBV = 'V'),
                        (JOBU = 'N')
                       2.1   .. no scaled condition estimate requested (JOBE = 'N'):
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance,
                          LWORK &gt;= max(N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for CGEQP3, CGEQRF, CGELQ,
                          CUNMLQ. In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3), N+LWORK(CGESVJ),
                                  N+LWORK(CGELQF), 2*N+LWORK(CGEQRF), N+LWORK(CUNMLQ)).
                       2.2 .. an estimate of the scaled condition number of A is
                          required (JOBA='E', or 'G').
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance,
                          LWORK &gt;= max(N+(N+1)*NB, 2*N,2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for CGEQP3, CGEQRF, CGELQ,
                          CUNMLQ. In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3), LWORK(CPOCON), N+LWORK(CGESVJ),
                                  N+LWORK(CGELQF), 2*N+LWORK(CGEQRF), N+LWORK(CUNMLQ)).
                     3. If SIGMA and the left singular vectors are needed
                       3.1  .. no scaled condition estimate requested (JOBE = 'N'):
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance:
                          if JOBU = 'U' :: LWORK &gt;= max(3*N, N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for CGEQP3, CGEQRF, CUNMQR.
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3), 2*N+LWORK(CGEQRF), N+LWORK(CUNMQR)).
                       3.2  .. an estimate of the scaled condition number of A is
                          required (JOBA='E', or 'G').
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance:
                          if JOBU = 'U' :: LWORK &gt;= max(3*N, N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for CGEQP3, CGEQRF, CUNMQR.
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3),N+LWORK(CPOCON),
                                   2*N+LWORK(CGEQRF), N+LWORK(CUNMQR)).

                     4. If the full SVD is needed: (JOBU = 'U' or JOBU = 'F') and
                       4.1. if JOBV = 'V'
                          the minimal requirement is LWORK &gt;= 5*N+2*N*N.
                       4.2. if JOBV = 'J' the minimal requirement is
                          LWORK &gt;= 4*N+N*N.
                       In both cases, the allocated CWORK can accommodate blocked runs
                       of CGEQP3, CGEQRF, CGELQF, CUNMQR, CUNMLQ.

                     If the call to CGEJSV is a workspace query (indicated by LWORK=-1 or
                     LRWORK=-1), then on exit <a href="../man1/CWORK.1.html">CWORK</a>(1) contains the optimal and <a href="../man2/CWORK.2.html">CWORK</a>(2) contains the
                     minimal length of CWORK for the job parameters used in the call.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (MAX(7,LWORK))
                     On exit,
                     <a href="../man1/RWORK.1.html">RWORK</a>(1) = Determines the scaling factor SCALE = <a href="../man2/RWORK.2.html">RWORK</a>(2) / <a href="../man1/RWORK.1.html">RWORK</a>(1)
                               such that SCALE*SVA(1:N) are the computed singular values
                               of A. (See the description of SVA().)
                     <a href="../man2/RWORK.2.html">RWORK</a>(2) = See the description of <a href="../man1/RWORK.1.html">RWORK</a>(1).
                     <a href="../man3/RWORK.3.html">RWORK</a>(3) = SCONDA is an estimate for the condition number of
                               column equilibrated A. (If JOBA = 'E' or 'G')
                               SCONDA is an estimate of SQRT(||(R^* * R)^(-1)||_1).
                               It is computed using CPOCON. It holds
                               N^(-1/4) * SCONDA &lt;= ||R^(-1)||_2 &lt;= N^(1/4) * SCONDA
                               where R is the triangular factor from the QRF of A.
                               However, if R is truncated and the numerical rank is
                               determined to be strictly smaller than N, SCONDA is
                               returned as -1, thus indicating that the smallest
                               singular values might be lost.

                     If full SVD is needed, the following two condition numbers are
                     useful for the analysis of the algorithm. They are provided for
                     a developer/implementer who is familiar with the details of
                     the method.

                     <a href="../man4/RWORK.4.html">RWORK</a>(4) = an estimate of the scaled condition number of the
                               triangular factor in the first QR factorization.
                     <a href="../man5/RWORK.5.html">RWORK</a>(5) = an estimate of the scaled condition number of the
                               triangular factor in the second QR factorization.
                     The following two parameters are computed if JOBT = 'T'.
                     They are provided for a developer/implementer who is familiar
                     with the details of the method.
                     <a href="../man6/RWORK.6.html">RWORK</a>(6) = the entropy of A^* * A :: this is the Shannon entropy
                               of diag(A^* * A) / Trace(A^* * A) taken as point in the
                               probability simplex.
                     <a href="../man7/RWORK.7.html">RWORK</a>(7) = the entropy of A * A^*. (See the description of <a href="../man6/RWORK.6.html">RWORK</a>(6).)
                     If the call to CGEJSV is a workspace query (indicated by LWORK=-1 or
                     LRWORK=-1), then on exit <a href="../man1/RWORK.1.html">RWORK</a>(1) contains the required length of
                     RWORK for the job parameters used in the call.

           <u>LRWORK</u>

                     LRWORK is INTEGER
                     Length of RWORK to confirm proper allocation of workspace.
                     LRWORK depends on the job:

                  1. If only the singular values are requested i.e. if
                     LSAME(JOBU,'N') .AND. LSAME(JOBV,'N')
                     then:
                     1.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                          then: LRWORK = max( 7, 2 * M ).
                     1.2. Otherwise, LRWORK  = max( 7,  N ).
                  2. If singular values with the right singular vectors are requested
                     i.e. if
                     (LSAME(JOBV,'V').OR.LSAME(JOBV,'J')) .AND.
                     .NOT.(LSAME(JOBU,'U').OR.LSAME(JOBU,'F'))
                     then:
                     2.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                     then LRWORK = max( 7, 2 * M ).
                     2.2. Otherwise, LRWORK  = max( 7,  N ).
                  3. If singular values with the left singular vectors are requested, i.e. if
                     (LSAME(JOBU,'U').OR.LSAME(JOBU,'F')) .AND.
                     .NOT.(LSAME(JOBV,'V').OR.LSAME(JOBV,'J'))
                     then:
                     3.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                     then LRWORK = max( 7, 2 * M ).
                     3.2. Otherwise, LRWORK  = max( 7,  N ).
                  4. If singular values with both the left and the right singular vectors
                     are requested, i.e. if
                     (LSAME(JOBU,'U').OR.LSAME(JOBU,'F')) .AND.
                     (LSAME(JOBV,'V').OR.LSAME(JOBV,'J'))
                     then:
                     4.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                     then LRWORK = max( 7, 2 * M ).
                     4.2. Otherwise, LRWORK  = max( 7, N ).

                     If, on entry, LRWORK = -1 or LWORK=-1, a workspace query is assumed and
                     the length of RWORK is returned in <a href="../man1/RWORK.1.html">RWORK</a>(1).

           <u>IWORK</u>

                     IWORK is INTEGER array, of dimension at least 4, that further depends
                     on the job:

                     1. If only the singular values are requested then:
                        If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                        then the length of IWORK is N+M; otherwise the length of IWORK is N.
                     2. If the singular values and the right singular vectors are requested then:
                        If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                        then the length of IWORK is N+M; otherwise the length of IWORK is N.
                     3. If the singular values and the left singular vectors are requested then:
                        If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                        then the length of IWORK is N+M; otherwise the length of IWORK is N.
                     4. If the singular values with both the left and the right singular vectors
                        are requested, then:
                        4.1. If LSAME(JOBV,'J') the length of IWORK is determined as follows:
                             If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                             then the length of IWORK is N+M; otherwise the length of IWORK is N.
                        4.2. If LSAME(JOBV,'V') the length of IWORK is determined as follows:
                             If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                             then the length of IWORK is 2*N+M; otherwise the length of IWORK is 2*N.

                     On exit,
                     <a href="../man1/IWORK.1.html">IWORK</a>(1) = the numerical rank determined after the initial
                                QR factorization with pivoting. See the descriptions
                                of JOBA and JOBR.
                     <a href="../man2/IWORK.2.html">IWORK</a>(2) = the number of the computed nonzero singular values
                     <a href="../man3/IWORK.3.html">IWORK</a>(3) = if nonzero, a warning message:
                                If <a href="../man3/IWORK.3.html">IWORK</a>(3) = 1 then some of the column norms of A
                                were denormalized floats. The requested high accuracy
                                is not warranted by the data.
                     <a href="../man4/IWORK.4.html">IWORK</a>(4) = 1 or -1. If <a href="../man4/IWORK.4.html">IWORK</a>(4) = 1, then the procedure used A^* to
                                do the job as specified by the JOB parameters.
                     If the call to CGEJSV is a workspace query (indicated by LWORK = -1 and
                     LRWORK = -1), then on exit <a href="../man1/IWORK.1.html">IWORK</a>(1) contains the required length of
                     IWORK for the job parameters used in the call.

           <u>INFO</u>

                     INFO is INTEGER
                      &lt; 0:  if INFO = -i, then the i-th argument had an illegal value.
                      = 0:  successful exit;
                      &gt; 0:  CGEJSV  did not converge in the maximal allowed number
                            of sweeps. The computed values may be inaccurate.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             CGEJSV implements a preconditioned Jacobi SVD algorithm. It uses CGEQP3,
             CGEQRF, and CGELQF as preprocessors and preconditioners. Optionally, an
             additional row pivoting can be used as a preprocessor, which in some
             cases results in much higher accuracy. An example is matrix A with the
             structure A = D1 * C * D2, where D1, D2 are arbitrarily ill-conditioned
             diagonal matrices and C is well-conditioned matrix. In that case, complete
             pivoting in the first QR factorizations provides accuracy dependent on the
             condition number of C, and independent of D1, D2. Such higher accuracy is
             not completely understood theoretically, but it works well in practice.
             Further, if A can be written as A = B*D, with well-conditioned B and some
             diagonal D, then the high accuracy is guaranteed, both theoretically and
             in software, independent of D. For more details see [1], [2].
                The computational range for the singular values can be the full range
             ( UNDERFLOW,OVERFLOW ), provided that the machine arithmetic and the BLAS
             &amp; LAPACK routines called by CGEJSV are implemented to work in that range.
             If that is not the case, then the restriction for safe computation with
             the singular values in the range of normalized IEEE numbers is that the
             spectral condition number kappa(A)=sigma_max(A)/sigma_min(A) does not
             overflow. This code (CGEJSV) is best used in this restricted range,
             meaning that singular values of magnitude below ||A||_2 / SLAMCH('O') are
             returned as zeros. See JOBR for details on this.
                Further, this implementation is somewhat slower than the one described
             in [1,2] due to replacement of some non-LAPACK components, and because
             the choice of some tuning parameters in the iterative part (CGESVJ) is
             left to the implementer on a particular machine.
                The rank revealing QR factorization (in this code: CGEQP3) should be
             implemented as in [3]. We have a new version of CGEQP3 under development
             that is more robust than the current one in LAPACK, with a cleaner cut in
             rank deficient cases. It will be available in the SIGMA library [4].
             If M is much larger than N, it is obvious that the initial QRF with
             column pivoting can be preprocessed by the QRF without pivoting. That
             well known trick is not used in CGEJSV because in some cases heavy row
             weighting can be treated with complete pivoting. The overhead in cases
             M much larger than N is then only due to pivoting, but the benefits in
             terms of accuracy have prevailed. The implementer/user can incorporate
             this extra QRF step easily. The implementer can also improve data movement
             (matrix transpose, matrix copy, matrix transposed copy) - this
             implementation of CGEJSV uses only the simplest, naive data movement.

       <b>Contributor:</b>
           Zlatko Drmac (Zagreb, Croatia)

       <b>References:</b>

            [1] Z. Drmac and K. Veselic: New fast and accurate Jacobi SVD algorithm I.
                SIAM J. Matrix Anal. Appl. Vol. 35, No. 2 (2008), pp. 1322-1342.
                LAPACK Working note 169.
            [2] Z. Drmac and K. Veselic: New fast and accurate Jacobi SVD algorithm II.
                SIAM J. Matrix Anal. Appl. Vol. 35, No. 2 (2008), pp. 1343-1362.
                LAPACK Working note 170.
            [3] Z. Drmac and Z. Bujanovic: On the failure of rank-revealing QR
                factorization software - a case study.
                ACM Trans. Math. Softw. Vol. 35, No 2 (2008), pp. 1-28.
                LAPACK Working note 176.
            [4] Z. Drmac: SIGMA - mathematical software library for accurate SVD, PSV,
                QSVD, (H,K)-SVD computations.
                Department of Mathematics, University of Zagreb, 2008, 2016.

       <b>Bugs,</b> <b>examples</b> <b>and</b> <b>comments:</b>
           Please report all bugs and send interesting examples and/or comments to <a href="mailto:drmac@math.hr">drmac@math.hr</a>. Thank you.

   <b>subroutine</b> <b>cgesdd</b> <b>(character</b> <b>JOBZ,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>complex,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>complex,</b> <b>dimension(</b> <b>ldvt,</b> <b>*</b> <b>)</b> <b>VT,</b> <b>integer</b>
       <b>LDVT,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CGESDD</b>

       <b>Purpose:</b>

            CGESDD computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, optionally computing the left and/or right singular
            vectors, by using divide-and-conquer method. The SVD is written

                 A = U * SIGMA * conjugate-transpose(V)

            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
            V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.

            Note that the routine returns VT = V**H, not V.

            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.

       <b>Parameters</b>
           <u>JOBZ</u>

                     JOBZ is CHARACTER*1
                     Specifies options for computing all or part of the matrix U:
                     = 'A':  all M columns of U and all N rows of V**H are
                             returned in the arrays U and VT;
                     = 'S':  the first min(M,N) columns of U and the first
                             min(M,N) rows of V**H are returned in the arrays U
                             and VT;
                     = 'O':  If M &gt;= N, the first N columns of U are overwritten
                             in the array A and all rows of V**H are returned in
                             the array VT;
                             otherwise, all columns of U are returned in the
                             array U and the first M rows of V**H are overwritten
                             in the array A;
                     = 'N':  no columns of U or rows of V**H are computed.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the input matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit,
                     if JOBZ = 'O',  A is overwritten with the first N columns
                                     of U (the left singular vectors, stored
                                     columnwise) if M &gt;= N;
                                     A is overwritten with the first M rows
                                     of V**H (the right singular vectors, stored
                                     rowwise) otherwise.
                     if JOBZ .ne. 'O', the contents of A are destroyed.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>S</u>

                     S is REAL array, dimension (min(M,N))
                     The singular values of A, sorted so that S(i) &gt;= S(i+1).

           <u>U</u>

                     U is COMPLEX array, dimension (LDU,UCOL)
                     UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                     UCOL = min(M,N) if JOBZ = 'S'.
                     If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                     unitary matrix U;
                     if JOBZ = 'S', U contains the first min(M,N) columns of U
                     (the left singular vectors, stored columnwise);
                     if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U.  LDU &gt;= 1;
                     if JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.

           <u>VT</u>

                     VT is COMPLEX array, dimension (LDVT,N)
                     If JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the
                     N-by-N unitary matrix V**H;
                     if JOBZ = 'S', VT contains the first min(M,N) rows of
                     V**H (the right singular vectors, stored rowwise);
                     if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.

           <u>LDVT</u>

                     LDVT is INTEGER
                     The leading dimension of the array VT.  LDVT &gt;= 1;
                     if JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N;
                     if JOBZ = 'S', LDVT &gt;= min(M,N).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= 1.
                     If LWORK = -1, a workspace query is assumed.  The optimal
                     size for the WORK array is calculated and stored in <a href="../man1/WORK.1.html">WORK</a>(1),
                     and no other work except argument checking is performed.

                     Let mx = max(M,N) and mn = min(M,N).
                     If JOBZ = 'N', LWORK &gt;= 2*mn + mx.
                     If JOBZ = 'O', LWORK &gt;= 2*mn*mn + 2*mn + mx.
                     If JOBZ = 'S', LWORK &gt;=   mn*mn + 3*mn.
                     If JOBZ = 'A', LWORK &gt;=   mn*mn + 2*mn + mx.
                     These are not tight minimums in all cases; see comments inside code.
                     For good performance, LWORK should generally be larger;
                     a query is recommended.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (MAX(1,LRWORK))
                     Let mx = max(M,N) and mn = min(M,N).
                     If JOBZ = 'N',    LRWORK &gt;= 5*mn (LAPACK &lt;= 3.6 needs 7*mn);
                     else if mx &gt;&gt; mn, LRWORK &gt;= 5*mn*mn + 5*mn;
                     else              LRWORK &gt;= max( 5*mn*mn + 5*mn,
                                                      2*mx*mn + 2*mn*mn + mn ).

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (8*min(M,N))

           <u>INFO</u>

                     INFO is INTEGER
                     &lt;  0:  if INFO = -i, the i-th argument had an illegal value.
                     = -4:  if A had a NAN entry.
                     &gt;  0:  The updating process of SBDSDC did not converge.
                     =  0:  successful exit.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>cgesvd</b> <b>(character</b> <b>JOBU,</b> <b>character</b> <b>JOBVT,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b>
       <b>integer</b> <b>LDA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>complex,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldvt,</b> <b>*</b> <b>)</b> <b>VT,</b> <b>integer</b> <b>LDVT,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b>
       <b>integer</b> <b>INFO)</b>
        <b>CGESVD</b> <b>computes</b> <b>the</b> <b>singular</b> <b>value</b> <b>decomposition</b> <b>(SVD)</b> <b>for</b> <b>GE</b> <b>matrices</b>

       <b>Purpose:</b>

            CGESVD computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, optionally computing the left and/or right singular
            vectors. The SVD is written

                 A = U * SIGMA * conjugate-transpose(V)

            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
            V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.

            Note that the routine returns V**H, not V.

       <b>Parameters</b>
           <u>JOBU</u>

                     JOBU is CHARACTER*1
                     Specifies options for computing all or part of the matrix U:
                     = 'A':  all M columns of U are returned in array U:
                     = 'S':  the first min(m,n) columns of U (the left singular
                             vectors) are returned in the array U;
                     = 'O':  the first min(m,n) columns of U (the left singular
                             vectors) are overwritten on the array A;
                     = 'N':  no columns of U (no left singular vectors) are
                             computed.

           <u>JOBVT</u>

                     JOBVT is CHARACTER*1
                     Specifies options for computing all or part of the matrix
                     V**H:
                     = 'A':  all N rows of V**H are returned in the array VT;
                     = 'S':  the first min(m,n) rows of V**H (the right singular
                             vectors) are returned in the array VT;
                     = 'O':  the first min(m,n) rows of V**H (the right singular
                             vectors) are overwritten on the array A;
                     = 'N':  no rows of V**H (no right singular vectors) are
                             computed.

                     JOBVT and JOBU cannot both be 'O'.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the input matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit,
                     if JOBU = 'O',  A is overwritten with the first min(m,n)
                                     columns of U (the left singular vectors,
                                     stored columnwise);
                     if JOBVT = 'O', A is overwritten with the first min(m,n)
                                     rows of V**H (the right singular vectors,
                                     stored rowwise);
                     if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
                                     are destroyed.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>S</u>

                     S is REAL array, dimension (min(M,N))
                     The singular values of A, sorted so that S(i) &gt;= S(i+1).

           <u>U</u>

                     U is COMPLEX array, dimension (LDU,UCOL)
                     (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
                     If JOBU = 'A', U contains the M-by-M unitary matrix U;
                     if JOBU = 'S', U contains the first min(m,n) columns of U
                     (the left singular vectors, stored columnwise);
                     if JOBU = 'N' or 'O', U is not referenced.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U.  LDU &gt;= 1; if
                     JOBU = 'S' or 'A', LDU &gt;= M.

           <u>VT</u>

                     VT is COMPLEX array, dimension (LDVT,N)
                     If JOBVT = 'A', VT contains the N-by-N unitary matrix
                     V**H;
                     if JOBVT = 'S', VT contains the first min(m,n) rows of
                     V**H (the right singular vectors, stored rowwise);
                     if JOBVT = 'N' or 'O', VT is not referenced.

           <u>LDVT</u>

                     LDVT is INTEGER
                     The leading dimension of the array VT.  LDVT &gt;= 1; if
                     JOBVT = 'A', LDVT &gt;= N; if JOBVT = 'S', LDVT &gt;= min(M,N).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     LWORK &gt;=  MAX(1,2*MIN(M,N)+MAX(M,N)).
                     For good performance, LWORK should generally be larger.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (5*min(M,N))
                     On exit, if INFO &gt; 0, RWORK(1:MIN(M,N)-1) contains the
                     unconverged superdiagonal elements of an upper bidiagonal
                     matrix B whose diagonal is in S (not necessarily sorted).
                     B satisfies A = U * B * VT, so it has the same singular
                     values as A, and singular vectors related by U and VT.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if CBDSQR did not converge, INFO specifies how many
                           superdiagonals of an intermediate bidiagonal form B
                           did not converge to zero. See the description of RWORK
                           above for details.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cgesvdq</b> <b>(character</b> <b>JOBA,</b> <b>character</b> <b>JOBP,</b> <b>character</b> <b>JOBR,</b> <b>character</b> <b>JOBU,</b> <b>character</b> <b>JOBV,</b> <b>integer</b>
       <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>integer</b> <b>NUMRANK,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>LIWORK,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>CWORK,</b> <b>integer</b> <b>LCWORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>RWORK,</b> <b>integer</b> <b>LRWORK,</b> <b>integer</b> <b>INFO)</b>
        <b>CGESVDQ</b> <b>computes</b> <b>the</b> <b>singular</b> <b>value</b> <b>decomposition</b> <b>(SVD)</b> <b>with</b> <b>a</b> <b>QR-Preconditioned</b> <b>QR</b> <b>SVD</b> <b>Method</b> <b>for</b> <b>GE</b>
       <b>matrices</b>

       <b>Purpose:</b>

            CGESVDQ computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, where M &gt;= N. The SVD of A is written as
                                               [++]   [xx]   [x0]   [xx]
                         A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
                                               [++]   [xx]
            where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
            matrix, and V is an N-by-N unitary matrix. The diagonal elements
            of SIGMA are the singular values of A. The columns of U and V are the
            left and the right singular vectors of A, respectively.

       <b>Parameters</b>
           <u>JOBA</u>

             JOBA is CHARACTER*1
             Specifies the level of accuracy in the computed SVD
             = 'A' The requested accuracy corresponds to having the backward
                   error bounded by || delta A ||_F &lt;= f(m,n) * EPS * || A ||_F,
                   where EPS = SLAMCH('Epsilon'). This authorises CGESVDQ to
                   truncate the computed triangular factor in a rank revealing
                   QR factorization whenever the truncated part is below the
                   threshold of the order of EPS * ||A||_F. This is aggressive
                   truncation level.
             = 'M' Similarly as with 'A', but the truncation is more gentle: it
                   is allowed only when there is a drop on the diagonal of the
                   triangular factor in the QR factorization. This is medium
                   truncation level.
             = 'H' High accuracy requested. No numerical rank determination based
                   on the rank revealing QR factorization is attempted.
             = 'E' Same as 'H', and in addition the condition number of column
                   scaled A is estimated and returned in  <a href="../man1/RWORK.1.html">RWORK</a>(1).
                   N^(-1/4)*<a href="../man1/RWORK.1.html">RWORK</a>(1) &lt;= ||pinv(A_scaled)||_2 &lt;= N^(1/4)*<a href="../man1/RWORK.1.html">RWORK</a>(1)

           <u>JOBP</u>

             JOBP is CHARACTER*1
             = 'P' The rows of A are ordered in decreasing order with respect to
                   ||A(i,:)||_infty. This enhances numerical accuracy at the cost
                   of extra data movement. Recommended for numerical robustness.
             = 'N' No row pivoting.

           <u>JOBR</u>

                     JOBR is CHARACTER*1
                     = 'T' After the initial pivoted QR factorization, CGESVD is applied to
                     the adjoint R**H of the computed triangular factor R. This involves
                     some extra data movement (matrix transpositions). Useful for
                     experiments, research and development.
                     = 'N' The triangular factor R is given as input to CGESVD. This may be
                     preferred as it involves less data movement.

           <u>JOBU</u>

                     JOBU is CHARACTER*1
                     = 'A' All M left singular vectors are computed and returned in the
                     matrix U. See the description of U.
                     = 'S' or 'U' N = min(M,N) left singular vectors are computed and returned
                     in the matrix U. See the description of U.
                     = 'R' Numerical rank NUMRANK is determined and only NUMRANK left singular
                     vectors are computed and returned in the matrix U.
                     = 'F' The N left singular vectors are returned in factored form as the
                     product of the Q factor from the initial QR factorization and the
                     N left singular vectors of (R**H , 0)**H. If row pivoting is used,
                     then the necessary information on the row pivoting is stored in
                     IWORK(N+1:N+M-1).
                     = 'N' The left singular vectors are not computed.

           <u>JOBV</u>

                     JOBV is CHARACTER*1
                     = 'A', 'V' All N right singular vectors are computed and returned in
                     the matrix V.
                     = 'R' Numerical rank NUMRANK is determined and only NUMRANK right singular
                     vectors are computed and returned in the matrix V. This option is
                     allowed only if JOBU = 'R' or JOBU = 'N'; otherwise it is illegal.
                     = 'N' The right singular vectors are not computed.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the input matrix A.  M &gt;= N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array of dimensions LDA x N
                     On entry, the input matrix A.
                     On exit, if JOBU .NE. 'N' or JOBV .NE. 'N', the lower triangle of A contains
                     the Householder vectors as stored by CGEQP3. If JOBU = 'F', these Householder
                     vectors together with CWORK(1:N) can be used to restore the Q factors from
                     the initial pivoted QR factorization of A. See the description of U.

           <u>LDA</u>

                     LDA is INTEGER.
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>S</u>

                     S is REAL array of dimension N.
                     The singular values of A, ordered so that S(i) &gt;= S(i+1).

           <u>U</u>

                     U is COMPLEX array, dimension
                     LDU x M if JOBU = 'A'; see the description of LDU. In this case,
                     on exit, U contains the M left singular vectors.
                     LDU x N if JOBU = 'S', 'U', 'R' ; see the description of LDU. In this
                     case, U contains the leading N or the leading NUMRANK left singular vectors.
                     LDU x N if JOBU = 'F' ; see the description of LDU. In this case U
                     contains N x N unitary matrix that can be used to form the left
                     singular vectors.
                     If JOBU = 'N', U is not referenced.

           <u>LDU</u>

                     LDU is INTEGER.
                     The leading dimension of the array U.
                     If JOBU = 'A', 'S', 'U', 'R',  LDU &gt;= max(1,M).
                     If JOBU = 'F',                 LDU &gt;= max(1,N).
                     Otherwise,                     LDU &gt;= 1.

           <u>V</u>

                     V is COMPLEX array, dimension
                     LDV x N if JOBV = 'A', 'V', 'R' or if JOBA = 'E' .
                     If JOBV = 'A', or 'V',  V contains the N-by-N unitary matrix  V**H;
                     If JOBV = 'R', V contains the first NUMRANK rows of V**H (the right
                     singular vectors, stored rowwise, of the NUMRANK largest singular values).
                     If JOBV = 'N' and JOBA = 'E', V is used as a workspace.
                     If JOBV = 'N', and JOBA.NE.'E', V is not referenced.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If JOBV = 'A', 'V', 'R',  or JOBA = 'E', LDV &gt;= max(1,N).
                     Otherwise,                               LDV &gt;= 1.

           <u>NUMRANK</u>

                     NUMRANK is INTEGER
                     NUMRANK is the numerical rank first determined after the rank
                     revealing QR factorization, following the strategy specified by the
                     value of JOBA. If JOBV = 'R' and JOBU = 'R', only NUMRANK
                     leading singular values and vectors are then requested in the call
                     of CGESVD. The final value of NUMRANK might be further reduced if
                     some singular values are computed as zeros.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (max(1, LIWORK)).
                     On exit, IWORK(1:N) contains column pivoting permutation of the
                     rank revealing QR factorization.
                     If JOBP = 'P', IWORK(N+1:N+M-1) contains the indices of the sequence
                     of row swaps used in row pivoting. These can be used to restore the
                     left singular vectors in the case JOBU = 'F'.

                     If LIWORK, LCWORK, or LRWORK = -1, then on exit, if INFO = 0,
                     <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the minimal LIWORK.

           <u>LIWORK</u>

                     LIWORK is INTEGER
                     The dimension of the array IWORK.
                     LIWORK &gt;= N + M - 1,  if JOBP = 'P';
                     LIWORK &gt;= N           if JOBP = 'N'.

                     If LIWORK = -1, then a workspace query is assumed; the routine
                     only calculates and returns the optimal and minimal sizes
                     for the CWORK, IWORK, and RWORK arrays, and no error
                     message related to LCWORK is issued by XERBLA.

           <u>CWORK</u>

                     CWORK is COMPLEX array, dimension (max(2, LCWORK)), used as a workspace.
                     On exit, if, on entry, LCWORK.NE.-1, CWORK(1:N) contains parameters
                     needed to recover the Q factor from the QR factorization computed by
                     CGEQP3.

                     If LIWORK, LCWORK, or LRWORK = -1, then on exit, if INFO = 0,
                     <a href="../man1/CWORK.1.html">CWORK</a>(1) returns the optimal LCWORK, and
                     <a href="../man2/CWORK.2.html">CWORK</a>(2) returns the minimal LCWORK.

           <u>LCWORK</u>

                     LCWORK is INTEGER
                     The dimension of the array CWORK. It is determined as follows:
                     Let  LWQP3 = N+1,  LWCON = 2*N, and let
                     LWUNQ = { MAX( N, 1 ),  if JOBU = 'R', 'S', or 'U'
                             { MAX( M, 1 ),  if JOBU = 'A'
                     LWSVD = MAX( 3*N, 1 )
                     LWLQF = MAX( N/2, 1 ), LWSVD2 = MAX( 3*(N/2), 1 ), LWUNLQ = MAX( N, 1 ),
                     LWQRF = MAX( N/2, 1 ), LWUNQ2 = MAX( N, 1 )
                     Then the minimal value of LCWORK is:
                     = MAX( N + LWQP3, LWSVD )        if only the singular values are needed;
                     = MAX( N + LWQP3, LWCON, LWSVD ) if only the singular values are needed,
                                              and a scaled condition estimate requested;

                     = N + MAX( LWQP3, LWSVD, LWUNQ ) if the singular values and the left
                                              singular vectors are requested;
                     = N + MAX( LWQP3, LWCON, LWSVD, LWUNQ ) if the singular values and the left
                                              singular vectors are requested, and also
                                              a scaled condition estimate requested;

                     = N + MAX( LWQP3, LWSVD )        if the singular values and the right
                                              singular vectors are requested;
                     = N + MAX( LWQP3, LWCON, LWSVD ) if the singular values and the right
                                              singular vectors are requested, and also
                                              a scaled condition etimate requested;

                     = N + MAX( LWQP3, LWSVD, LWUNQ ) if the full SVD is requested with JOBV = 'R';
                                              independent of JOBR;
                     = N + MAX( LWQP3, LWCON, LWSVD, LWUNQ ) if the full SVD is requested,
                                              JOBV = 'R' and, also a scaled condition
                                              estimate requested; independent of JOBR;
                     = MAX( N + MAX( LWQP3, LWSVD, LWUNQ ),
                    N + MAX( LWQP3, N/2+LWLQF, N/2+LWSVD2, N/2+LWUNLQ, LWUNQ) ) if the
                                    full SVD is requested with JOBV = 'A' or 'V', and
                                    JOBR ='N'
                     = MAX( N + MAX( LWQP3, LWCON, LWSVD, LWUNQ ),
                    N + MAX( LWQP3, LWCON, N/2+LWLQF, N/2+LWSVD2, N/2+LWUNLQ, LWUNQ ) )
                                    if the full SVD is requested with JOBV = 'A' or 'V', and
                                    JOBR ='N', and also a scaled condition number estimate
                                    requested.
                     = MAX( N + MAX( LWQP3, LWSVD, LWUNQ ),
                    N + MAX( LWQP3, N/2+LWQRF, N/2+LWSVD2, N/2+LWUNQ2, LWUNQ ) ) if the
                                    full SVD is requested with JOBV = 'A', 'V', and JOBR ='T'
                     = MAX( N + MAX( LWQP3, LWCON, LWSVD, LWUNQ ),
                    N + MAX( LWQP3, LWCON, N/2+LWQRF, N/2+LWSVD2, N/2+LWUNQ2, LWUNQ ) )
                                    if the full SVD is requested with JOBV = 'A', 'V' and
                                    JOBR ='T', and also a scaled condition number estimate
                                    requested.
                     Finally, LCWORK must be at least two: LCWORK = MAX( 2, LCWORK ).

                     If LCWORK = -1, then a workspace query is assumed; the routine
                     only calculates and returns the optimal and minimal sizes
                     for the CWORK, IWORK, and RWORK arrays, and no error
                     message related to LCWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (max(1, LRWORK)).
                     On exit,
                     1. If JOBA = 'E', <a href="../man1/RWORK.1.html">RWORK</a>(1) contains an estimate of the condition
                     number of column scaled A. If A = C * D where D is diagonal and C
                     has unit columns in the Euclidean norm, then, assuming full column rank,
                     N^(-1/4) * <a href="../man1/RWORK.1.html">RWORK</a>(1) &lt;= ||pinv(C)||_2 &lt;= N^(1/4) * <a href="../man1/RWORK.1.html">RWORK</a>(1).
                     Otherwise, <a href="../man1/RWORK.1.html">RWORK</a>(1) = -1.
                     2. <a href="../man2/RWORK.2.html">RWORK</a>(2) contains the number of singular values computed as
                     exact zeros in CGESVD applied to the upper triangular or trapezoidal
                     R (from the initial QR factorization). In case of early exit (no call to
                     CGESVD, such as in the case of zero matrix) <a href="../man2/RWORK.2.html">RWORK</a>(2) = -1.

                     If LIWORK, LCWORK, or LRWORK = -1, then on exit, if INFO = 0,
                     <a href="../man1/RWORK.1.html">RWORK</a>(1) returns the minimal LRWORK.

           <u>LRWORK</u>

                     LRWORK is INTEGER.
                     The dimension of the array RWORK.
                     If JOBP ='P', then LRWORK &gt;= MAX(2, M, 5*N);
                     Otherwise, LRWORK &gt;= MAX(2, 5*N).

                     If LRWORK = -1, then a workspace query is assumed; the routine
                     only calculates and returns the optimal and minimal sizes
                     for the CWORK, IWORK, and RWORK arrays, and no error
                     message related to LCWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if CBDSQR did not converge, INFO specifies how many superdiagonals
                     of an intermediate bidiagonal form B (computed in CGESVD) did not
                     converge to zero.

       <b>Further</b> <b>Details:</b>

              1. The data movement (matrix transpose) is coded using simple nested
              DO-loops because BLAS and LAPACK do not provide corresponding subroutines.
              Those DO-loops are easily identified in this source code - by the CONTINUE
              statements labeled with 11**. In an optimized version of this code, the
              nested DO loops should be replaced with calls to an optimized subroutine.
              2. This code scales A by 1/SQRT(M) if the largest ABS(A(i,j)) could cause
              column norm overflow. This is the minial precaution and it is left to the
              SVD routine (CGESVD) to do its own preemptive scaling if potential over-
              or underflows are detected. To avoid repeated scanning of the array A,
              an optimal implementation would do all necessary scaling before calling
              CGESVD and the scaling in CGESVD can be switched off.
              3. Other comments related to code optimization are given in comments in the
              code, enlosed in [[double brackets]].

       <b>Bugs,</b> <b>examples</b> <b>and</b> <b>comments</b>

             Please report all bugs and send interesting examples and/or comments to
             <a href="mailto:drmac@math.hr">drmac@math.hr</a>. Thank you.

       <b>References</b>

             [1] Zlatko Drmac, Algorithm 977: A QR-Preconditioned QR SVD Method for
                 Computing the SVD with High Accuracy. ACM Trans. Math. Softw.
                 <a href="../man1/44.1.html">44</a>(1): 11:1-11:30 (2017)

             SIGMA library, xGESVDQ section updated February 2016.
             Developed and coded by Zlatko Drmac, Department of Mathematics
             University of Zagreb, Croatia, <a href="mailto:drmac@math.hr">drmac@math.hr</a>

       <b>Contributors:</b>

            Developed and coded by Zlatko Drmac, Department of Mathematics
             University of Zagreb, Croatia, <a href="mailto:drmac@math.hr">drmac@math.hr</a>

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cgesvdx</b> <b>(character</b> <b>JOBU,</b> <b>character</b> <b>JOBVT,</b> <b>character</b> <b>RANGE,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real</b> <b>VL,</b> <b>real</b> <b>VU,</b> <b>integer</b> <b>IL,</b> <b>integer</b> <b>IU,</b> <b>integer</b> <b>NS,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>complex,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>complex,</b> <b>dimension(</b> <b>ldvt,</b> <b>*</b> <b>)</b> <b>VT,</b> <b>integer</b>
       <b>LDVT,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
        <b>CGESVDX</b> <b>computes</b> <b>the</b> <b>singular</b> <b>value</b> <b>decomposition</b> <b>(SVD)</b> <b>for</b> <b>GE</b> <b>matrices</b>

       <b>Purpose:</b>

             CGESVDX computes the singular value decomposition (SVD) of a complex
             M-by-N matrix A, optionally computing the left and/or right singular
             vectors. The SVD is written

                 A = U * SIGMA * transpose(V)

             where SIGMA is an M-by-N matrix which is zero except for its
             min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
             V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
             are the singular values of A; they are real and non-negative, and
             are returned in descending order.  The first min(m,n) columns of
             U and V are the left and right singular vectors of A.

             CGESVDX uses an eigenvalue problem for obtaining the SVD, which
             allows for the computation of a subset of singular values and
             vectors. See SBDSVDX for details.

             Note that the routine returns V**T, not V.

       <b>Parameters</b>
           <u>JOBU</u>

                     JOBU is CHARACTER*1
                     Specifies options for computing all or part of the matrix U:
                     = 'V':  the first min(m,n) columns of U (the left singular
                             vectors) or as specified by RANGE are returned in
                             the array U;
                     = 'N':  no columns of U (no left singular vectors) are
                             computed.

           <u>JOBVT</u>

                     JOBVT is CHARACTER*1
                      Specifies options for computing all or part of the matrix
                      V**T:
                      = 'V':  the first min(m,n) rows of V**T (the right singular
                              vectors) or as specified by RANGE are returned in
                              the array VT;
                      = 'N':  no rows of V**T (no right singular vectors) are
                              computed.

           <u>RANGE</u>

                     RANGE is CHARACTER*1
                     = 'A': all singular values will be found.
                     = 'V': all singular values in the half-open interval (VL,VU]
                            will be found.
                     = 'I': the IL-th through IU-th singular values will be found.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the input matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, the contents of A are destroyed.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>VL</u>

                     VL is REAL
                     If RANGE='V', the lower bound of the interval to
                     be searched for singular values. VU &gt; VL.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>VU</u>

                     VU is REAL
                     If RANGE='V', the upper bound of the interval to
                     be searched for singular values. VU &gt; VL.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>IL</u>

                     IL is INTEGER
                     If RANGE='I', the index of the
                     smallest singular value to be returned.
                     1 &lt;= IL &lt;= IU &lt;= min(M,N), if min(M,N) &gt; 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>IU</u>

                     IU is INTEGER
                     If RANGE='I', the index of the
                     largest singular value to be returned.
                     1 &lt;= IL &lt;= IU &lt;= min(M,N), if min(M,N) &gt; 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>NS</u>

                     NS is INTEGER
                     The total number of singular values found,
                     0 &lt;= NS &lt;= min(M,N).
                     If RANGE = 'A', NS = min(M,N); if RANGE = 'I', NS = IU-IL+1.

           <u>S</u>

                     S is REAL array, dimension (min(M,N))
                     The singular values of A, sorted so that S(i) &gt;= S(i+1).

           <u>U</u>

                     U is COMPLEX array, dimension (LDU,UCOL)
                     If JOBU = 'V', U contains columns of U (the left singular
                     vectors, stored columnwise) as specified by RANGE; if
                     JOBU = 'N', U is not referenced.
                     Note: The user must ensure that UCOL &gt;= NS; if RANGE = 'V',
                     the exact value of NS is not known in advance and an upper
                     bound must be used.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U.  LDU &gt;= 1; if
                     JOBU = 'V', LDU &gt;= M.

           <u>VT</u>

                     VT is COMPLEX array, dimension (LDVT,N)
                     If JOBVT = 'V', VT contains the rows of V**T (the right singular
                     vectors, stored rowwise) as specified by RANGE; if JOBVT = 'N',
                     VT is not referenced.
                     Note: The user must ensure that LDVT &gt;= NS; if RANGE = 'V',
                     the exact value of NS is not known in advance and an upper
                     bound must be used.

           <u>LDVT</u>

                     LDVT is INTEGER
                     The leading dimension of the array VT.  LDVT &gt;= 1; if
                     JOBVT = 'V', LDVT &gt;= NS (see above).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK;

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     LWORK &gt;= MAX(1,MIN(M,N)*(MIN(M,N)+4)) for the paths (see
                     comments inside the code):
                        - PATH 1  (M much larger than N)
                        - PATH 1t (N much larger than M)
                     LWORK &gt;= MAX(1,MIN(M,N)*2+MAX(M,N)) for the other paths.
                     For good performance, LWORK should generally be larger.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (MAX(1,LRWORK))
                     LRWORK &gt;= MIN(M,N)*(MIN(M,N)*2+15*MIN(M,N)).

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (12*MIN(M,N))
                     If INFO = 0, the first NS elements of IWORK are zero. If INFO &gt; 0,
                     then IWORK contains the indices of the eigenvectors that failed
                     to converge in SBDSVDX/SSTEVX.

           <u>INFO</u>

                INFO is INTEGER
                      = 0:  successful exit
                      &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                      &gt; 0:  if INFO = i, then i eigenvectors failed to converge
                            in SBDSVDX/SSTEVX.
                            if INFO = N*2 + 1, an internal error occurred in
                            SBDSVDX

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cggsvd3</b> <b>(character</b> <b>JOBU,</b> <b>character</b> <b>JOBV,</b> <b>character</b> <b>JOBQ,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>P,</b> <b>integer</b>
       <b>K,</b> <b>integer</b> <b>L,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ALPHA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BETA,</b> <b>complex,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b>
       <b>INFO)</b>
        <b>CGGSVD3</b> <b>computes</b> <b>the</b> <b>singular</b> <b>value</b> <b>decomposition</b> <b>(SVD)</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            CGGSVD3 computes the generalized singular value decomposition (GSVD)
            of an M-by-N complex matrix A and P-by-N complex matrix B:

                  U**H*A*Q = D1*( 0 R ),    V**H*B*Q = D2*( 0 R )

            where U, V and Q are unitary matrices.
            Let K+L = the effective numerical rank of the
            matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper
            triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
            matrices and of the following structures, respectively:

            If M-K-L &gt;= 0,

                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )

                              K  L
                   D2 =   L ( 0  S )
                        P-L ( 0  0 )

                            N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 )
                        L (  0    0   R22 )

            where

              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.

              R is stored in A(1:K+L,N-K-L+1:N) on exit.

            If M-K-L &lt; 0,

                              K M-K K+L-M
                   D1 =   K ( I  0    0   )
                        M-K ( 0  C    0   )

                                K M-K K+L-M
                   D2 =   M-K ( 0  S    0  )
                        K+L-M ( 0  0    I  )
                          P-L ( 0  0    0  )

                               N-K-L  K   M-K  K+L-M
              ( 0 R ) =     K ( 0    R11  R12  R13  )
                          M-K ( 0     0   R22  R23  )
                        K+L-M ( 0     0    0   R33  )

            where

              C = diag( ALPHA(K+1), ... , ALPHA(M) ),
              S = diag( BETA(K+1),  ... , BETA(M) ),
              C**2 + S**2 = I.

              (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
              ( 0  R22 R23 )
              in B(M-K+1:L,N+M-K-L+1:N) on exit.

            The routine computes C, S, R, and optionally the unitary
            transformation matrices U, V and Q.

            In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
            A and B implicitly gives the SVD of A*inv(B):
                                 A*inv(B) = U*(D1*inv(D2))*V**H.
            If ( A**H,B**H)**H has orthonormal columns, then the GSVD of A and B is also
            equal to the CS decomposition of A and B. Furthermore, the GSVD can
            be used to derive the solution of the eigenvalue problem:
                                 A**H*A x = lambda* B**H*B x.
            In some literature, the GSVD of A and B is presented in the form
                             U**H*A*X = ( 0 D1 ),   V**H*B*X = ( 0 D2 )
            where U and V are orthogonal and X is nonsingular, and D1 and D2 are
            ``diagonal''.  The former GSVD form can be converted to the latter
            form by taking the nonsingular matrix X as

                                  X = Q*(  I   0    )
                                        (  0 inv(R) )

       <b>Parameters</b>
           <u>JOBU</u>

                     JOBU is CHARACTER*1
                     = 'U':  Unitary matrix U is computed;
                     = 'N':  U is not computed.

           <u>JOBV</u>

                     JOBV is CHARACTER*1
                     = 'V':  Unitary matrix V is computed;
                     = 'N':  V is not computed.

           <u>JOBQ</u>

                     JOBQ is CHARACTER*1
                     = 'Q':  Unitary matrix Q is computed;
                     = 'N':  Q is not computed.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrices A and B.  N &gt;= 0.

           <u>P</u>

                     P is INTEGER
                     The number of rows of the matrix B.  P &gt;= 0.

           <u>K</u>

                     K is INTEGER

           <u>L</u>

                     L is INTEGER

                     On exit, K and L specify the dimension of the subblocks
                     described in Purpose.
                     K + L = effective numerical rank of (A**H,B**H)**H.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, A contains the triangular matrix R, or part of R.
                     See Purpose for details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,N)
                     On entry, the P-by-N matrix B.
                     On exit, B contains part of the triangular matrix R if
                     M-K-L &lt; 0.  See Purpose for details.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,P).

           <u>ALPHA</u>

                     ALPHA is REAL array, dimension (N)

           <u>BETA</u>

                     BETA is REAL array, dimension (N)

                     On exit, ALPHA and BETA contain the generalized singular
                     value pairs of A and B;
                       ALPHA(1:K) = 1,
                       BETA(1:K)  = 0,
                     and if M-K-L &gt;= 0,
                       ALPHA(K+1:K+L) = C,
                       BETA(K+1:K+L)  = S,
                     or if M-K-L &lt; 0,
                       ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
                       BETA(K+1:M) =S, BETA(M+1:K+L) =1
                     and
                       ALPHA(K+L+1:N) = 0
                       BETA(K+L+1:N)  = 0

           <u>U</u>

                     U is COMPLEX array, dimension (LDU,M)
                     If JOBU = 'U', U contains the M-by-M unitary matrix U.
                     If JOBU = 'N', U is not referenced.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U. LDU &gt;= max(1,M) if
                     JOBU = 'U'; LDU &gt;= 1 otherwise.

           <u>V</u>

                     V is COMPLEX array, dimension (LDV,P)
                     If JOBV = 'V', V contains the P-by-P unitary matrix V.
                     If JOBV = 'N', V is not referenced.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V. LDV &gt;= max(1,P) if
                     JOBV = 'V'; LDV &gt;= 1 otherwise.

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                     If JOBQ = 'Q', Q contains the N-by-N unitary matrix Q.
                     If JOBQ = 'N', Q is not referenced.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q. LDQ &gt;= max(1,N) if
                     JOBQ = 'Q'; LDQ &gt;= 1 otherwise.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (2*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (N)
                     On exit, IWORK stores the sorting information. More
                     precisely, the following loop will sort ALPHA
                        for I = K+1, min(M,K+L)
                            swap ALPHA(I) and ALPHA(IWORK(I))
                        endfor
                     such that <a href="../man1/ALPHA.1.html">ALPHA</a>(1) &gt;= <a href="../man2/ALPHA.2.html">ALPHA</a>(2) &gt;= ... &gt;= ALPHA(N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if INFO = 1, the Jacobi-type procedure failed to
                           converge.  For further details, see subroutine CTGSJA.

       <b>Internal</b> <b>Parameters:</b>

             TOLA    REAL
             TOLB    REAL
                     TOLA and TOLB are the thresholds to determine the effective
                     rank of (A**H,B**H)**H. Generally, they are set to
                              TOLA = MAX(M,N)*norm(A)*MACHEPS,
                              TOLB = MAX(P,N)*norm(B)*MACHEPS.
                     The size of TOLA and TOLB may affect the size of backward
                     errors of the decomposition.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ming Gu and Huan Ren, Computer Science Division, University of California at Berkeley, USA

       <b>Further</b> <b>Details:</b>
           CGGSVD3 replaces the deprecated subroutine CGGSVD.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.10.0                                   Wed Jan 12 2022                                <u><a href="../man3/complexGEsing.3.html">complexGEsing</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>